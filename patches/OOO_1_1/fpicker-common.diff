--- /dev/null	2004-04-06 15:27:52.000000000 +0200
+++ fpicker/source/unx/FPentry.cxx	2004-06-14 14:08:19.923932848 +0200
@@ -0,0 +1,169 @@
+/*************************************************************************
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
+ *
+ *  Copyright: 2000 by Sun Microsystems, Inc.
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+
+#ifndef _CPPUHELPER_FACTORY_HXX_
+#include <cppuhelper/factory.hxx>
+#endif
+
+#ifndef _COM_SUN_STAR_CONTAINER_XSET_HPP_
+#include <com/sun/star/container/XSet.hpp>
+#endif
+
+#ifndef _OSL_DIAGNOSE_H_
+#include <osl/diagnose.h>
+#endif
+
+#ifndef _UNXFILEPICKER_HXX_
+#include "UnxFilePicker.hxx"
+#endif
+
+#ifndef _FPSERVICEINFO_HXX_
+#include "FPServiceInfo.hxx"
+#endif
+
+using namespace ::rtl;
+using namespace ::com::sun::star::uno;
+using namespace ::com::sun::star::container;
+using namespace ::com::sun::star::lang;
+using namespace ::com::sun::star::registry;
+using namespace ::cppu;
+using ::com::sun::star::ui::dialogs::XFilePicker;
+
+//////////////////////////////////////////////////////////////////////////
+// 
+//////////////////////////////////////////////////////////////////////////
+
+static Reference< XInterface > SAL_CALL createInstance( const Reference< XMultiServiceFactory >& rServiceManager )
+{
+    return Reference< XInterface >( 
+            static_cast< XFilePicker* >( new UnxFilePicker( rServiceManager ) ) );
+}
+
+//////////////////////////////////////////////////////////////////////////
+// the three uno functions that will be exported
+//////////////////////////////////////////////////////////////////////////
+
+extern "C" 
+{
+
+//////////////////////////////////////////////////////////////////////////
+// component_getImplementationEnvironment
+//////////////////////////////////////////////////////////////////////////
+
+void SAL_CALL component_getImplementationEnvironment( const sal_Char ** ppEnvTypeName, uno_Environment ** ppEnv )
+{
+    *ppEnvTypeName = CPPU_CURRENT_LANGUAGE_BINDING_NAME;
+}
+
+//////////////////////////////////////////////////////////////////////////
+//
+//////////////////////////////////////////////////////////////////////////
+
+sal_Bool SAL_CALL component_writeInfo( void* pServiceManager, void* pRegistryKey )
+{
+    sal_Bool bRetVal = sal_True;
+
+    if ( pRegistryKey )
+    {
+        try
+        {
+            Reference< XRegistryKey > pXNewKey( static_cast< XRegistryKey* >( pRegistryKey ) );				
+            pXNewKey->createKey( OUString::createFromAscii( FILE_PICKER_REGKEY_NAME ) );
+        }
+        catch( InvalidRegistryException& )
+        {			
+            OSL_ENSURE( sal_False, "InvalidRegistryException caught" );			
+            bRetVal = sal_False;
+        }
+    }
+
+    return bRetVal;
+}
+
+//////////////////////////////////////////////////////////////////////////
+//
+//////////////////////////////////////////////////////////////////////////
+
+void* SAL_CALL component_getFactory( const sal_Char* pImplName, uno_Interface* pSrvManager, uno_Interface* pRegistryKey )
+{
+    void* pRet = 0;
+
+    if ( pSrvManager && ( 0 == rtl_str_compare( pImplName, FILE_PICKER_IMPL_NAME ) ) )
+    {
+        Sequence< OUString > aSNS( 1 );
+        aSNS.getArray( )[0] = OUString::createFromAscii( FILE_PICKER_SERVICE_NAME );		
+
+        Reference< XSingleServiceFactory > xFactory ( createSingleFactory(
+                    reinterpret_cast< XMultiServiceFactory* > ( pSrvManager ),
+                    OUString::createFromAscii( pImplName ),
+                    createInstance,
+                    aSNS ) );
+        if ( xFactory.is() )
+        {
+            xFactory->acquire();
+            pRet = xFactory.get();
+        }			
+    }
+
+    return pRet;
+}
+
+} // extern "C"
--- /dev/null	2004-04-06 15:27:52.000000000 +0200
+++ fpicker/source/unx/FPServiceInfo.hxx	2004-06-14 14:09:17.226221576 +0200
@@ -0,0 +1,77 @@
+/*************************************************************************
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
+ *
+ *  Copyright: 2000 by Sun Microsystems, Inc.
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+
+#ifndef _FPSERVICEINFO_HXX_
+#define _FPSERVICEINFO_HXX_
+
+// the service names
+#define FILE_PICKER_SERVICE_NAME "com.sun.star.ui.dialogs.SystemFilePicker"
+
+// the implementation names		
+#define FILE_PICKER_IMPL_NAME    "com.sun.star.ui.dialogs.UnxFilePicker"
+
+// the registry key names
+// a key under which this service will be registered,
+// Format: -> "/ImplName/UNO/SERVICES/ServiceName"
+//  <Implementation-Name></UNO/SERVICES/><Service-Name> 
+#define FILE_PICKER_REGKEY_NAME  "/com.sun.star.ui.dialogs.UnxFilePicker/UNO/SERVICES/com.sun.star.ui.dialogs.SystemFilePicker"
+
+#endif
--- /dev/null	2004-04-06 15:27:52.000000000 +0200
+++ fpicker/source/unx/fps.xml	2004-06-21 17:30:23.370313432 +0200
@@ -0,0 +1,51 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!DOCTYPE module-description PUBLIC "-//StarOffice//DTD ComponentDescription 1.0//EN" "module-description.dtd">
+<module-description xmlns:xlink="http://www.w3.org/1999/xlink">
+    <module-name>fps</module-name>
+    <component-description>
+        <author> Jan Holesovsky </author>
+        <name>    com.sun.star.comp.ui.dialogs.FilePicker </name>
+        <description>
+            The Unx implementation of the FilePicker service.
+        </description>
+        <loader-name>com.sun.star.loader.SharedLibrary</loader-name>
+        <language>    c++    </language>
+        <status value="beta"/>
+        <supported-service>    com.sun.star.ui.dialogs.FilePicker </supported-service>        
+        <service-dependency>...</service-dependency>
+        <type>    com.sun.star.ui.dialogs.XExecutableDialog            </type>
+        <type>    com.sun.star.ui.dialogs.XFilePicker                  </type>
+        <type>    com.sun.star.ui.dialogs.XFilterManager               </type>
+        <type>    com.sun.star.ui.dialogs.XFilterGroupManager          </type>
+        <type>    com.sun.star.ui.dialogs.XFilePickerListener          </type>
+        <type>    com.sun.star.ui.dialogs.ExecutableDialogException    </type>
+        <type>    com.sun.star.ui.dialogs.XFilePickerNotifier          </type>
+        <type>    com.sun.star.ui.dialogs.XFilePickerControlAccess     </type>
+        <type>    com.sun.star.ui.dialogs.XFilePreview                 </type>
+        <type>    com.sun.star.ui.dialogs.ExtendedFilePickerElementIds </type>
+        <type>    com.sun.star.ui.dialogs.ExecutableDialogResults      </type>        
+        <type>    com.sun.star.ui.dialogs.FilePickerEvent              </type>
+        <type>    com.sun.star.ui.dialogs.CommonFilePickerElementIds   </type>
+        <type>    com.sun.star.ui.dialogs.ListboxControlActions        </type>
+        <type>    com.sun.star.ui.dialogs.TemplateDescription          </type>        
+        <type>    com.sun.star.ui.dialogs.FilePreviewImageFormats      </type>    
+        <type>    com.sun.star.util.XCancellable                       </type>
+        <type>    com.sun.star.lang.XComponent                         </type>
+        <type>    com.sun.star.lang.XMultiServiceFactory               </type>
+        <type>    com.sun.star.lang.XSingleServiceFactory              </type>
+        <type>    com.sun.star.lang.XServiceInfo                       </type>
+        <type>    com.sun.star.lang.XTypeProvider                      </type>
+        <type>    com.sun.star.lang.IllegalArgumentException           </type>
+        <type>    com.sun.star.uno.TypeClass                           </type>
+        <type>    com.sun.star.uno.XWeak                               </type>
+        <type>    com.sun.star.uno.XAggregation                        </type>
+        <type>    com.sun.star.registry.XRegistryKey                   </type>
+        <type>    com.sun.star.container.XSet                          </type>
+    </component-description>
+    <project-build-dependency>     cppuhelper  </project-build-dependency>
+    <project-build-dependency>     cppu        </project-build-dependency>
+    <project-build-dependency>     sal         </project-build-dependency>
+    <runtime-module-dependency>    cppuhelper  </runtime-module-dependency>
+    <runtime-module-dependency>    cppu2       </runtime-module-dependency>
+    <runtime-module-dependency>    sal2        </runtime-module-dependency>
+</module-description>
--- /dev/null	2004-04-06 15:27:52.000000000 +0200
+++ fpicker/source/unx/makefile.mk	2004-06-15 10:52:55.099580592 +0200
@@ -0,0 +1,100 @@
+#*************************************************************************
+#
+#   $RCSfile$
+#
+#   $Revision$
+#
+#   last change: $Author$ $Date$
+#
+#   The Contents of this file are made available subject to the terms of
+#   either of the following licenses
+#
+#          - GNU Lesser General Public License Version 2.1
+#          - Sun Industry Standards Source License Version 1.1
+#
+#   Sun Microsystems Inc., October, 2000
+#
+#   GNU Lesser General Public License Version 2.1
+#   =============================================
+#   Copyright 2000 by Sun Microsystems, Inc.
+#   901 San Antonio Road, Palo Alto, CA 94303, USA
+#
+#   This library is free software; you can redistribute it and/or
+#   modify it under the terms of the GNU Lesser General Public
+#   License version 2.1, as published by the Free Software Foundation.
+#
+#   This library is distributed in the hope that it will be useful,
+#   but WITHOUT ANY WARRANTY; without even the implied warranty of
+#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+#   Lesser General Public License for more details.
+#
+#   You should have received a copy of the GNU Lesser General Public
+#   License along with this library; if not, write to the Free Software
+#   Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+#   MA  02111-1307  USA
+#
+#
+#   Sun Industry Standards Source License Version 1.1
+#   =================================================
+#   The contents of this file are subject to the Sun Industry Standards
+#   Source License Version 1.1 (the "License"); You may not use this file
+#   except in compliance with the License. You may obtain a copy of the
+#   License at http://www.openoffice.org/license.html.
+#
+#   Software provided under this License is provided on an "AS IS" basis,
+#   WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+#   WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+#   MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+#   See the License for the specific provisions governing your rights and
+#   obligations concerning the Software.
+#
+#   The Initial Developer of the Original Code is: Sun Microsystems, Inc.
+#
+#   Copyright: 2000 by Sun Microsystems, Inc.
+#
+#   All Rights Reserved.
+#
+#   Contributor(s): _______________________________________
+#
+#
+#
+#*************************************************************************
+
+PRJ=..$/..
+
+PRJNAME=fpicker
+TARGET=fps
+#LIBTARGET=NO
+ENABLE_EXCEPTIONS=TRUE
+COMP1TYPELIST=$(TARGET)
+COMPRDB=$(SOLARBINDIR)$/types.rdb
+
+# --- Settings -----------------------------------------------------
+
+.INCLUDE :  settings.mk
+
+# ------------------------------------------------------------------
+
+# Currently just KDE is supported...
+.IF "$(GUIBASE)" != "unx" || "$(ENABLE_FPICKER_KDE)" != "TRUE"
+
+dummy:
+	@echo "Nothing to build. GUIBASE == $(GUIBASE), ENABLE_FPICKER_KDE is not set"
+
+.ELSE # we build for KDE
+
+.INCLUDE : ..$/cppumaker.mk
+
+# --- Files --------------------------------------------------------
+
+SLOFILES =\
+		$(SLO)$/UnxCommandThread.obj	\
+		$(SLO)$/UnxFilePicker.obj		\
+		$(SLO)$/UnxNotifyThread.obj		\
+		$(SLO)$/FPentry.obj
+
+.ENDIF # "$(GUIBASE)" != "unx" || "$(ENABLE_FPICKER_KDE)" != "TRUE"
+
+# --- Targets ------------------------------------------------------
+
+.INCLUDE :	target.mk
--- /dev/null	2004-04-06 15:27:52.000000000 +0200
+++ fpicker/source/unx/UnxCommandThread.cxx	2004-06-21 17:39:06.421797520 +0200
@@ -0,0 +1,351 @@
+/*************************************************************************
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$ 
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
+ *
+ *  Copyright: 2000 by Sun Microsystems, Inc.
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): Jan Holesovsky <kendy@openoffice.org>
+ *
+ *
+ ************************************************************************/
+
+#ifndef _UNXCOMMANDTHREAD_HXX_
+#include <UnxCommandThread.hxx>
+#endif
+
+#ifndef _UNXNOTIFYTHREAD_HXX_
+#include <UnxNotifyThread.hxx>
+#endif
+
+#ifndef _RTL_USTRING_H_
+#include <rtl/ustring.hxx>
+#endif
+
+#ifndef _RTL_USTRBUF_HXX_
+#include <rtl/ustrbuf.hxx>
+#endif
+
+#include <unistd.h>
+
+#include <iostream>
+
+using namespace ::com::sun::star;
+
+//////////////////////////////////////////////////////////////////////////
+// UnxFilePickerCommandThread
+//////////////////////////////////////////////////////////////////////////
+
+UnxFilePickerCommandThread::UnxFilePickerCommandThread( UnxFilePickerNotifyThread *pNotifyThread, int nReadFD )
+    : m_pNotifyThread( pNotifyThread ),
+      m_nReadFD( nReadFD )
+{
+}
+
+UnxFilePickerCommandThread::~UnxFilePickerCommandThread()
+{
+}
+
+sal_Bool SAL_CALL UnxFilePickerCommandThread::result()
+{
+    ::osl::MutexGuard aGuard( m_aMutex );
+
+    return m_aResult;
+}
+
+::rtl::OUString SAL_CALL UnxFilePickerCommandThread::getCurrentFilter()
+{
+    ::osl::MutexGuard aGuard( m_aMutex );
+    
+    return m_aGetCurrentFilter;
+}
+
+::rtl::OUString SAL_CALL UnxFilePickerCommandThread::getDirectory()
+{
+    ::osl::MutexGuard aGuard( m_aMutex );
+
+    return m_aGetDirectory;
+}
+
+uno::Sequence< ::rtl::OUString > SAL_CALL UnxFilePickerCommandThread::getFiles()
+{
+    ::osl::MutexGuard aGuard( m_aMutex );
+
+    sal_Int32 nSize = m_aGetFiles.size();
+    uno::Sequence< ::rtl::OUString > aFiles( ( nSize > 1 )? nSize + 1: nSize );
+
+    if ( nSize == 1 )
+        aFiles[0] = m_aGetFiles.front();
+    else if ( nSize > 1 )
+    {
+        // First entry in the sequence must be the dirname, the others are the
+        // filenames, so we have to rearrange the list...
+
+        ::rtl::OUString aFront = m_aGetFiles.front();
+        sal_Int32 nLastSlash = aFront.lastIndexOf( '/' );
+        
+        aFiles[0] = ( nLastSlash >= 0 )? aFront.copy( 0, nLastSlash ): ::rtl::OUString();
+        ++nLastSlash;
+
+        sal_Int32 nIdx = 1;
+        for ( ::std::list< ::rtl::OUString >::const_iterator it = m_aGetFiles.begin();
+                it != m_aGetFiles.end(); ++it, ++nIdx )
+        {
+            sal_Int32 nLength = (*it).getLength() - nLastSlash;
+            aFiles[nIdx] = ( nLength >= 0 )? (*it).copy( nLastSlash, nLength ): ::rtl::OUString();
+        }
+    }
+
+    return aFiles;
+}
+
+uno::Any SAL_CALL UnxFilePickerCommandThread::getValue()
+{
+    ::osl::MutexGuard aGuard( m_aMutex );
+
+    return m_aGetValue;
+}
+
+void SAL_CALL UnxFilePickerCommandThread::run()
+{
+    if ( m_nReadFD < 0 )
+        return;
+
+    sal_Int32 nBufferSize = 1; // FIXME 1 is for testing, 1024 for real use
+    sal_Char *pBuffer = new sal_Char[nBufferSize];
+    sal_Char *pBufferEnd = pBuffer + nBufferSize;
+
+    sal_Char *pWhereToRead = pBuffer;
+    sal_Char *pEntryBegin = pBuffer;
+    sal_Int32 nBytesRead = 0;
+    while ( ( nBytesRead = read( m_nReadFD, pWhereToRead, pBufferEnd - pWhereToRead ) ) > 0 )
+    {
+        sal_Bool bFoundNL = sal_False;
+        sal_Char *pWhereToReadEnd = pWhereToRead + nBytesRead;
+        sal_Char *pEntryEnd = pWhereToRead;
+        do {
+            for ( ; pEntryEnd < pWhereToReadEnd && *pEntryEnd != '\n'; ++pEntryEnd )
+                ;
+
+            if ( pEntryEnd < pWhereToReadEnd )
+            {
+                bFoundNL = sal_True;
+                *pEntryEnd = 0;
+
+                handleCommand( ::rtl::OUString( pEntryBegin, pEntryEnd - pEntryBegin, RTL_TEXTENCODING_UTF8 )/*, bQuit*/ );
+
+                pEntryBegin = pEntryEnd + 1;
+            }
+        } while ( pEntryEnd < pWhereToReadEnd );
+
+        if ( bFoundNL )
+        {
+            if ( pEntryBegin < pBufferEnd )
+                memmove( pBuffer, pEntryBegin, pWhereToReadEnd - pEntryBegin );
+        }
+        else
+        {
+            // enlarge the buffer size
+            nBufferSize *= 2;
+            sal_Char *pNewBuffer = new sal_Char[nBufferSize];
+            if ( pEntryBegin < pBufferEnd )
+                memmove( pNewBuffer, pEntryBegin, pWhereToReadEnd - pEntryBegin );
+
+            delete[] pBuffer;
+            pBuffer = pNewBuffer;
+            pBufferEnd = pBuffer + nBufferSize;
+        }
+
+        pWhereToRead = pBuffer + ( pWhereToReadEnd - pEntryBegin );
+        pEntryBegin = pBuffer;
+    }
+}
+
+void SAL_CALL UnxFilePickerCommandThread::handleCommand( const ::rtl::OUString &rCommand )
+{
+    ::osl::MutexGuard aGuard( m_aMutex );
+    
+#if OSL_DEBUG_LEVEL > 0
+    ::std::cerr << "UnxFilePicker received: \"" <<
+        OUStringToOString( rCommand, RTL_TEXTENCODING_ASCII_US ).getStr() << "\"" << ::std::endl;
+#endif
+
+    ::std::list< ::rtl::OUString > aList = tokenize( rCommand );
+
+    if ( aList.size() == 0 )
+        return;
+
+    ::rtl::OUString aCommandName = aList.front();
+    aList.pop_front();
+
+    if ( aCommandName.equalsAscii( "accept" ) )
+    {
+        m_aResult = sal_True;
+        m_aExecCondition.set();
+    }
+    else if ( aCommandName.equalsAscii( "reject" ) )
+    {
+        m_aResult = sal_False;
+        m_aExecCondition.set();
+    }
+    else if ( aCommandName.equalsAscii( "fileSelectionChanged" ) )
+    {
+        if ( m_pNotifyThread )
+            m_pNotifyThread->fileSelectionChanged();
+    }
+    else if ( aCommandName.equalsAscii( "files" ) )
+    {
+        m_aGetFiles = aList;
+        m_aGetFilesCondition.set();
+    }
+    else if ( aCommandName.equalsAscii( "value" ) )
+    {
+        ::rtl::OUString aType;
+        if ( !aList.empty() )
+        {
+            aType = aList.front();
+            aList.pop_front();
+        }
+        
+        if ( aType.equalsAscii( "bool" ) )
+        {
+            sal_Bool bValue = !aList.empty() && aList.front().equalsIgnoreAsciiCaseAscii( "true" );
+
+            m_aGetValue <<= bValue;
+            m_aGetValueCondition.set();
+        }
+        else if ( aType.equalsAscii( "int" ) )
+        {
+            sal_Int32 nValue = 0;
+            if ( !aList.empty() )
+                nValue = aList.front().toInt32();
+
+            m_aGetValue <<= nValue;
+            m_aGetValueCondition.set();
+        }
+        else if ( aType.equalsAscii( "string" ) )
+        {
+            ::rtl::OUString aValue;
+            if ( !aList.empty() )
+                aValue = aList.front();
+
+            m_aGetValue <<= aValue;
+            m_aGetValueCondition.set();
+        }
+        else if ( aType.equalsAscii( "stringList" ) )
+        {
+            uno::Sequence< ::rtl::OUString > aSequence( aList.size() );
+            sal_Int32 nIdx = 0;
+            for ( ::std::list< ::rtl::OUString >::const_iterator it = aList.begin(); it != aList.end(); ++it, ++nIdx )
+                aSequence[nIdx] = (*it);
+
+            m_aGetValue <<= aSequence;
+            m_aGetValueCondition.set();
+        }
+        else
+        {
+            m_aGetValue = uno::Any();
+            m_aGetValueCondition.set();
+        }
+    }
+    else if ( aCommandName.equalsAscii( "currentFilter" ) )
+    {
+        m_aGetCurrentFilter = aList.empty()? ::rtl::OUString(): aList.front();
+        m_aGetCurrentFilterCondition.set();
+    }
+    else if ( aCommandName.equalsAscii( "currentDirectory" ) )
+    {
+        m_aGetDirectory = aList.empty()? ::rtl::OUString(): aList.front();
+        m_aGetDirectoryCondition.set();
+    }
+    else
+    {
+#if OSL_DEBUG_LEVEL > 0
+        ::std::cerr << "Unrecognized command: "
+            << OUStringToOString( aCommandName, RTL_TEXTENCODING_ASCII_US ).getStr() << "\"" << ::std::endl;
+#endif
+    }
+}
+
+::std::list< ::rtl::OUString > SAL_CALL UnxFilePickerCommandThread::tokenize( const ::rtl::OUString &rCommand )
+{
+    ::std::list< ::rtl::OUString > aList;
+    ::rtl::OUStringBuffer aBuffer( 1024 );
+
+    const sal_Unicode *pUnicode = rCommand.getStr();
+    const sal_Unicode *pEnd     = pUnicode + rCommand.getLength();
+    sal_Bool bQuoted            = sal_False;
+
+    for ( ; pUnicode != pEnd; ++pUnicode )
+    {
+        if ( *pUnicode == '\\' )
+        {
+            ++pUnicode;
+            if ( pUnicode != pEnd )
+            {
+                if ( *pUnicode == 'n' )
+                    aBuffer.appendAscii( "\n", 1 );
+                else
+                    aBuffer.append( *pUnicode );
+            }
+        }
+        else if ( *pUnicode == '"' )
+            bQuoted = !bQuoted;
+        else if ( *pUnicode == ' ' && !bQuoted )
+            aList.push_back( aBuffer.makeStringAndClear() );
+        else
+            aBuffer.append( *pUnicode );
+    }
+    aList.push_back( aBuffer.makeStringAndClear() );
+
+    return aList;
+}
--- /dev/null	2004-04-06 15:27:52.000000000 +0200
+++ fpicker/source/unx/UnxCommandThread.hxx	2004-06-11 17:08:30.375883816 +0200
@@ -0,0 +1,142 @@
+/*************************************************************************
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
+ *
+ *  Copyright: 2000 by Sun Microsystems, Inc.
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): Jan Holesovsky <kendy@openoffice.org>
+ *
+ *
+ ************************************************************************/
+
+#ifndef _UNXCOMMANDTHREAD_HXX_
+#define _UNXCOMMANDTHREAD_HXX_
+
+#ifndef _COM_SUN_STAR_UNO_ANY_H_
+#include <com/sun/star/uno/Any.h>
+#endif
+
+#ifndef _COM_SUN_STAR_UNO_SEQUENCE_H_
+#include <com/sun/star/uno/Sequence.h>
+#endif
+
+#ifndef _OSL_CONDITN_HXX_
+#include <osl/conditn.hxx>
+#endif
+
+#ifndef _OSL_MUTEX_HXX_
+#include <osl/mutex.hxx>
+#endif
+
+#ifndef _OSL_THREAD_HXX_
+#include <osl/thread.hxx>
+#endif
+
+#ifndef _RTL_USTRBUF_HXX_
+#include <rtl/ustring.hxx>
+#endif
+
+#include <list>
+
+class UnxFilePickerNotifyThread;
+
+class UnxFilePickerCommandThread : public ::osl::Thread
+{
+protected:
+    UnxFilePickerNotifyThread  *m_pNotifyThread;
+    int                         m_nReadFD;
+
+    ::osl::Mutex                m_aMutex;
+
+    ::osl::Condition            m_aExecCondition;
+    sal_Bool                    m_aResult;
+
+    ::osl::Condition            m_aGetCurrentFilterCondition;
+    ::rtl::OUString             m_aGetCurrentFilter;
+
+    ::osl::Condition            m_aGetDirectoryCondition;
+    ::rtl::OUString             m_aGetDirectory;
+
+    ::osl::Condition            m_aGetFilesCondition;
+    ::std::list< ::rtl::OUString > m_aGetFiles;
+
+    ::osl::Condition            m_aGetValueCondition;
+    ::com::sun::star::uno::Any  m_aGetValue;
+
+public:
+    UnxFilePickerCommandThread( UnxFilePickerNotifyThread *pNotifyThread, int nReadFD );
+    ~UnxFilePickerCommandThread();
+    
+    ::osl::Condition& SAL_CALL  execCondition() { return m_aExecCondition; }
+    sal_Bool SAL_CALL           result();
+
+    ::osl::Condition& SAL_CALL  getCurrentFilterCondition() { return m_aGetCurrentFilterCondition; }
+    ::rtl::OUString SAL_CALL    getCurrentFilter();
+
+    ::osl::Condition& SAL_CALL  getDirectoryCondition() { return m_aGetDirectoryCondition; }
+    ::rtl::OUString SAL_CALL    getDirectory();
+    
+    ::osl::Condition& SAL_CALL  getFilesCondition() { return m_aGetFilesCondition; }
+    ::com::sun::star::uno::Sequence< ::rtl::OUString > SAL_CALL getFiles();
+
+    ::osl::Condition& SAL_CALL  getValueCondition() { return m_aGetValueCondition; }
+    ::com::sun::star::uno::Any SAL_CALL getValue();
+
+protected:
+    virtual void SAL_CALL       run();
+    
+    virtual void SAL_CALL       handleCommand( const ::rtl::OUString &rCommand/*, sal_Bool &rQuit*/ );
+    ::std::list< ::rtl::OUString > SAL_CALL tokenize( const ::rtl::OUString &rCommand );
+};
+
+#endif // _UNXCOMMANDTHREAD_HXX_
--- /dev/null	2004-04-06 15:27:52.000000000 +0200
+++ fpicker/source/unx/UnxFilePicker.cxx	2004-06-21 17:40:01.026496344 +0200
@@ -0,0 +1,977 @@
+/*************************************************************************
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$ 
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
+ *
+ *  Copyright: 2000 by Sun Microsystems, Inc.
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): Jan Holesovsky <kendy@openoffice.org>
+ *
+ *
+ ************************************************************************/
+
+//////////////////////////////////////////////////////////////////////////
+// includes
+//////////////////////////////////////////////////////////////////////////
+
+#ifndef _COM_SUN_STAR_LANG_DISPOSEDEXCEPTION_HPP_
+#include <com/sun/star/lang/DisposedException.hpp>
+#endif
+
+#ifndef _COM_SUN_STAR_LANG_XMULTISERVICEFACTORY_HPP_
+#include <com/sun/star/lang/XMultiServiceFactory.hpp>
+#endif
+
+#ifndef _CPPUHELPER_INTERFACECONTAINER_H_
+#include <cppuhelper/interfacecontainer.h>
+#endif
+
+#ifndef _OSL_DIAGNOSE_H_
+#include <osl/diagnose.h>
+#endif
+
+#ifndef _COM_SUN_STAR_UI_DIALOGS_TEMPLATEDESCRIPTION_HPP_
+#include <com/sun/star/ui/dialogs/TemplateDescription.hpp>
+#endif
+
+#ifndef _COM_SUN_STAR_UI_DIALOGS_COMMONFILEPICKERELEMENTIDS_HPP_
+#include <com/sun/star/ui/dialogs/CommonFilePickerElementIds.hpp>
+#endif
+
+#ifndef _COM_SUN_STAR_UI_DIALOGS_EXTENDEDFILEPICKERELEMENTIDS_HPP_
+#include <com/sun/star/ui/dialogs/ExtendedFilePickerElementIds.hpp>
+#endif
+
+#ifndef _COM_SUN_STAR_UI_DIALOGS_CONTROLACTIONS_HPP_
+#include <com/sun/star/ui/dialogs/ControlActions.hpp>
+#endif
+
+#ifndef _RTL_USTRING_H_
+#include <rtl/ustring.hxx>
+#endif
+
+#ifndef _RTL_USTRBUF_HXX_
+#include <rtl/ustrbuf.hxx>
+#endif
+
+#ifndef _FPSERVICEINFO_HXX_
+#include <FPServiceInfo.hxx>
+#endif
+
+#ifndef _SVTOOLS_SVTDATA_HXX
+#include <svtools/svtdata.hxx>
+#endif
+
+#ifndef _SVTOOLS_HRC
+#include <svtools/svtools.hrc>
+#endif
+
+#ifndef _UNXFILEOPENIMPL_HXX_
+#include <UnxFilePicker.hxx>
+#endif
+
+#ifndef _UNXCOMMANDTHREAD_HXX_
+#include <UnxCommandThread.hxx>
+#endif
+
+#ifndef _UNXNOTIFYTHREAD_HXX_
+#include <UnxNotifyThread.hxx>
+#endif
+
+#include <sys/wait.h>
+#include <unistd.h>
+#include <fcntl.h>
+
+#include <iostream>
+
+using namespace ::com::sun::star;
+
+using namespace ::com::sun::star::ui::dialogs;
+using namespace ::com::sun::star::ui::dialogs::TemplateDescription;
+
+//////////////////////////////////////////////////////////////////////////
+// helper functions
+//////////////////////////////////////////////////////////////////////////
+
+namespace
+{
+    // controling event notifications    
+    const bool STARTUP_SUSPENDED = true;
+    const bool STARTUP_ALIVE     = false;
+
+    uno::Sequence<rtl::OUString> SAL_CALL FilePicker_getSupportedServiceNames()
+    {
+        uno::Sequence<rtl::OUString> aRet(2);
+        aRet[0] = rtl::OUString::createFromAscii("com.sun.star.ui.dialogs.FilePicker");
+        aRet[1] = rtl::OUString::createFromAscii("com.sun.star.ui.dialogs.SystemFilePicker");
+        return aRet;
+    }
+}
+
+//////////////////////////////////////////////////////////////////////////
+// UnxFilePicker
+//////////////////////////////////////////////////////////////////////////
+
+UnxFilePicker::UnxFilePicker( const uno::Reference<lang::XMultiServiceFactory>& xServiceMgr )
+    : cppu::WeakComponentImplHelper8< 		
+          XFilterManager, 
+          XFilterGroupManager,
+          XFilePickerControlAccess,
+          XFilePickerNotifier,
+// TODO   XFilePreview,
+          lang::XInitialization,
+          util::XCancellable,
+          lang::XEventListener, 
+          lang::XServiceInfo>( m_rbHelperMtx ),
+          m_xServiceMgr( xServiceMgr ),
+          m_nFilePickerPid( -1 ),
+          m_nFilePickerWrite( -1 ),
+          m_nFilePickerRead( -1 ),
+          m_pNotifyThread( NULL ),
+          m_pCommandThread( NULL )
+{	
+}
+
+UnxFilePicker::~UnxFilePicker()
+{
+    if ( m_nFilePickerPid > 0 )
+    {
+        sendCommand( ::rtl::OUString::createFromAscii( "exit" ) );
+        waitpid( m_nFilePickerPid, NULL, 0 );
+    }
+    
+    if ( m_pCommandThread )
+    {
+        if ( m_pCommandThread->isRunning() )
+            m_pCommandThread->terminate();
+        delete m_pCommandThread, m_pCommandThread = NULL;
+    }
+
+    if ( m_pNotifyThread )
+    {
+        m_pNotifyThread->exit();
+
+        if ( m_pNotifyThread->isRunning() )
+            m_pNotifyThread->terminate();
+        delete m_pNotifyThread, m_pNotifyThread = NULL;
+    }
+
+    if ( m_nFilePickerWrite >= 0 )
+        close( m_nFilePickerWrite );
+    
+    if ( m_nFilePickerRead >= 0 )
+        close( m_nFilePickerRead );
+}
+
+void SAL_CALL UnxFilePicker::addFilePickerListener( const uno::Reference<XFilePickerListener>& xListener )
+    throw( uno::RuntimeException )
+{
+    OSL_ASSERT( m_pNotifyThread );
+    osl::MutexGuard aGuard( m_aMutex );
+
+    m_pNotifyThread->addFilePickerListener( xListener );
+}
+
+void SAL_CALL UnxFilePicker::removeFilePickerListener( const uno::Reference<XFilePickerListener>& xListener )
+    throw( uno::RuntimeException )
+{
+    OSL_ASSERT( m_pNotifyThread );
+    osl::MutexGuard aGuard( m_aMutex );
+
+    m_pNotifyThread->removeFilePickerListener( xListener );
+}
+
+void SAL_CALL UnxFilePicker::setTitle( const rtl::OUString &rTitle )
+    throw( uno::RuntimeException )
+{
+    checkFilePicker();
+    ::osl::MutexGuard aGuard( m_aMutex );
+
+    ::rtl::OUStringBuffer aBuffer( 1024 );
+
+    aBuffer.appendAscii( "setTitle " );
+    appendEscaped( aBuffer, rTitle );
+
+    sendCommand( aBuffer.makeStringAndClear() );
+}
+
+sal_Int16 SAL_CALL UnxFilePicker::execute()
+    throw( uno::RuntimeException )
+{
+    checkFilePicker();
+
+    sendCommand( ::rtl::OUString::createFromAscii( "exec" ),
+                 m_pCommandThread->execCondition() );
+
+    return m_pCommandThread->result();
+}
+
+void SAL_CALL UnxFilePicker::setMultiSelectionMode( sal_Bool bMode )
+    throw( uno::RuntimeException )
+{
+    checkFilePicker();
+    ::osl::MutexGuard aGuard( m_aMutex );
+
+    ::rtl::OUString aString = bMode?
+        ::rtl::OUString::createFromAscii( "setMultiSelection true" ):
+        ::rtl::OUString::createFromAscii( "setMultiSelection false" );
+
+    sendCommand( aString );
+}
+
+void SAL_CALL UnxFilePicker::setDefaultName( const ::rtl::OUString &rName )
+    throw( uno::RuntimeException )
+{
+    checkFilePicker();
+    ::osl::MutexGuard aGuard( m_aMutex );
+
+    ::rtl::OUStringBuffer aBuffer( 1024 );
+
+    aBuffer.appendAscii( "setDefaultName " );
+    appendEscaped( aBuffer, rName );
+
+    sendCommand( aBuffer.makeStringAndClear() );
+}
+
+void SAL_CALL UnxFilePicker::setDisplayDirectory( const rtl::OUString &rDirectory )
+    throw( uno::RuntimeException )
+{
+    checkFilePicker();
+    ::osl::MutexGuard aGuard( m_aMutex );
+
+    ::rtl::OUStringBuffer aBuffer( 1024 );
+
+    aBuffer.appendAscii( "setDirectory " );
+    appendEscaped( aBuffer, rDirectory );
+
+    sendCommand( aBuffer.makeStringAndClear() );
+}
+
+rtl::OUString SAL_CALL UnxFilePicker::getDisplayDirectory()
+    throw( uno::RuntimeException )
+{
+    checkFilePicker();
+    ::osl::MutexGuard aGuard( m_aMutex );
+
+    sendCommand( ::rtl::OUString::createFromAscii( "getDirectory" ),
+                 m_pCommandThread->getDirectoryCondition() );
+
+    return m_pCommandThread->getDirectory();
+}
+
+uno::Sequence< ::rtl::OUString > SAL_CALL UnxFilePicker::getFiles()
+    throw( uno::RuntimeException )
+{
+    checkFilePicker();
+    ::osl::MutexGuard aGuard( m_aMutex );
+
+    sendCommand( ::rtl::OUString::createFromAscii( "getFiles" ),
+                 m_pCommandThread->getFilesCondition() );
+
+    return m_pCommandThread->getFiles();
+}
+
+void SAL_CALL UnxFilePicker::appendFilter( const ::rtl::OUString &rTitle, const ::rtl::OUString &rFilter )
+    throw( lang::IllegalArgumentException, uno::RuntimeException )
+{
+    checkFilePicker();
+    ::osl::MutexGuard aGuard( m_aMutex );
+
+    ::rtl::OUStringBuffer aBuffer( 1024 );
+
+    aBuffer.appendAscii( "appendFilter " );
+    appendEscaped( aBuffer, rTitle );
+    aBuffer.appendAscii( " ", 1 );
+    appendEscaped( aBuffer, rFilter );
+
+    sendCommand( aBuffer.makeStringAndClear() );
+}
+
+void SAL_CALL UnxFilePicker::setCurrentFilter( const rtl::OUString &rTitle )
+    throw( lang::IllegalArgumentException, uno::RuntimeException )
+{
+    checkFilePicker();
+    ::osl::MutexGuard aGuard( m_aMutex );
+
+    ::rtl::OUStringBuffer aBuffer( 1024 );
+
+    aBuffer.appendAscii( "setCurrentFilter " );
+    appendEscaped( aBuffer, rTitle );
+
+    sendCommand( aBuffer.makeStringAndClear() );
+}
+
+rtl::OUString SAL_CALL UnxFilePicker::getCurrentFilter()
+    throw( uno::RuntimeException )
+{
+    checkFilePicker();
+    ::osl::MutexGuard aGuard( m_aMutex );
+
+    sendCommand( ::rtl::OUString::createFromAscii( "getCurrentFilter" ),
+                 m_pCommandThread->getCurrentFilterCondition() );
+
+    return m_pCommandThread->getCurrentFilter();
+}
+
+void SAL_CALL UnxFilePicker::appendFilterGroup( const rtl::OUString &rGroupTitle, const uno::Sequence<beans::StringPair> &rFilters )
+    throw( lang::IllegalArgumentException, uno::RuntimeException )
+{
+    checkFilePicker();
+    ::osl::MutexGuard aGuard( m_aMutex );
+
+    ::rtl::OUStringBuffer aBuffer( 1024 );
+
+    aBuffer.appendAscii( "appendFilterGroup " );
+    appendEscaped( aBuffer, rGroupTitle );
+    
+    for ( sal_Int32 i = 0; i < rFilters.getLength(); ++i )
+    {
+        beans::StringPair aPair = rFilters[i];
+
+        aBuffer.appendAscii( " ", 1 );
+        appendEscaped( aBuffer, aPair.First );
+        aBuffer.appendAscii( " ", 1 );
+        appendEscaped( aBuffer, aPair.Second );
+    }
+
+    sendCommand( aBuffer.makeStringAndClear() );
+}
+
+void SAL_CALL UnxFilePicker::setValue( sal_Int16 nControlId, sal_Int16 nControlAction, const uno::Any &rValue )
+    throw( uno::RuntimeException )
+{
+    checkFilePicker();
+    ::osl::MutexGuard aGuard( m_aMutex );
+
+    ::rtl::OUString aType;
+    ::rtl::OUString aAction;
+    sal_Int32 nTitleId;
+
+    if ( controlIdInfo( nControlId, aType, nTitleId ) && controlActionInfo( nControlAction, aAction ) )
+    {
+        ::rtl::OUStringBuffer aBuffer( 1024 );
+
+        aBuffer.appendAscii( "setValue " );
+        aBuffer.append( static_cast< sal_Int32 >( nControlId ) );
+        aBuffer.appendAscii( " ", 1 );
+        aBuffer.append( aAction );
+
+        if ( aType.equalsAscii( "checkbox" ) )
+        {
+            sal_Bool bControlValue;
+            if ( ( rValue >>= bControlValue ) && bControlValue )
+                aBuffer.appendAscii( " true" );
+            else
+                aBuffer.appendAscii( " false" );
+        }
+        else if ( aType.equalsAscii( "listbox" ) )
+        {
+            switch ( nControlAction )
+            {
+                case ControlActions::ADD_ITEM:
+                case ControlActions::SET_HELP_URL:
+                    {
+                        ::rtl::OUString aString;
+                        if ( rValue >>= aString )
+                        {
+                            aBuffer.appendAscii( " ", 1 );
+                            appendEscaped( aBuffer, aString );
+                        }
+                    }
+                    break;
+
+                case ControlActions::ADD_ITEMS:
+                    {
+                        uno::Sequence< ::rtl::OUString > aSequence;
+                        if ( rValue >>= aSequence )
+                        {
+                            for ( sal_Int32 nIdx = 0; nIdx < aSequence.getLength(); ++nIdx )
+                            {
+                                aBuffer.appendAscii( " ", 1 );
+                                appendEscaped( aBuffer, aSequence[nIdx] );
+                            }
+
+                        }
+                    }
+                    break;
+
+                case ControlActions::DELETE_ITEM:
+                case ControlActions::SET_SELECT_ITEM:
+                    {
+                        sal_Int32 nInt;
+                        if ( rValue >>= nInt )
+                        {
+                            aBuffer.appendAscii( " ", 1 );
+                            aBuffer.append( nInt );
+                        }
+                    }
+                    break;
+
+                default:
+                    // nothing
+                    break;
+            }
+        }
+        // TODO else if push button...
+
+        sendCommand( aBuffer.makeStringAndClear() );
+    }
+}
+
+uno::Any SAL_CALL UnxFilePicker::getValue( sal_Int16 nControlId, sal_Int16 nControlAction )
+    throw( uno::RuntimeException )
+{
+    checkFilePicker();
+    ::osl::MutexGuard aGuard( m_aMutex );
+
+    ::rtl::OUString aAction;
+    
+    if ( controlActionInfo( nControlAction, aAction ) )
+    {
+        ::rtl::OUStringBuffer aBuffer( 1024 );
+
+        aBuffer.appendAscii( "getValue " );
+        aBuffer.append( static_cast< sal_Int32 >( nControlId ) );
+        aBuffer.appendAscii( " ", 1 );
+        aBuffer.append( aAction );
+
+        sendCommand( aBuffer.makeStringAndClear(),
+                m_pCommandThread->getValueCondition() );
+
+        return m_pCommandThread->getValue();
+    }
+    
+    return uno::Any();
+}
+
+void SAL_CALL UnxFilePicker::enableControl( sal_Int16 nControlId, sal_Bool bEnable )
+    throw( uno::RuntimeException )
+{
+    checkFilePicker();
+    ::osl::MutexGuard aGuard( m_aMutex );
+
+    ::rtl::OUStringBuffer aBuffer( 1024 );
+
+    aBuffer.appendAscii( "enableControl " );
+    aBuffer.append( static_cast< sal_Int32 >( nControlId ) );
+    aBuffer.appendAscii( bEnable? " true": " false" );
+
+    sendCommand( aBuffer.makeStringAndClear() );
+}
+
+void SAL_CALL UnxFilePicker::setLabel( sal_Int16 nControlId, const ::rtl::OUString &rLabel )
+    throw( uno::RuntimeException )
+{
+    checkFilePicker();
+    ::osl::MutexGuard aGuard( m_aMutex );
+
+    ::rtl::OUStringBuffer aBuffer( 1024 );
+
+    aBuffer.appendAscii( "setLabel " );
+    aBuffer.append( static_cast< sal_Int32 >( nControlId ) );
+    aBuffer.appendAscii( " ", 1 );
+    appendEscaped( aBuffer, rLabel );
+
+    sendCommand( aBuffer.makeStringAndClear() );
+}
+
+rtl::OUString SAL_CALL UnxFilePicker::getLabel(sal_Int16 nControlId) 
+    throw ( uno::RuntimeException )
+{
+    // FIXME getLabel() is not yet implemented
+    checkFilePicker();
+    ::osl::MutexGuard aGuard( m_aMutex );
+
+    // TODO return m_pImpl->getLabel(nControlId);
+    return ::rtl::OUString();
+}
+
+/* TODO
+uno::Sequence<sal_Int16> SAL_CALL UnxFilePicker::getSupportedImageFormats()
+    throw( uno::RuntimeException )
+{
+    checkFilePicker();
+    ::osl::MutexGuard aGuard( m_aMutex );
+
+    return m_pImpl->getSupportedImageFormats();
+}
+
+sal_Int32 SAL_CALL UnxFilePicker::getTargetColorDepth()
+    throw( uno::RuntimeException )
+{
+    checkFilePicker();
+    ::osl::MutexGuard aGuard( m_aMutex );
+
+    return m_pImpl->getTargetColorDepth();
+}
+
+sal_Int32 SAL_CALL UnxFilePicker::getAvailableWidth()
+    throw( uno::RuntimeException )
+{
+    checkFilePicker();
+    ::osl::MutexGuard aGuard( m_aMutex );
+
+    return m_pImpl->getAvailableWidth();
+}
+
+sal_Int32 SAL_CALL UnxFilePicker::getAvailableHeight()
+    throw( uno::RuntimeException )
+{
+    checkFilePicker();
+    ::osl::MutexGuard aGuard( m_aMutex );
+
+    return m_pImpl->getAvailableHeight();
+}
+
+void SAL_CALL UnxFilePicker::setImage( sal_Int16 aImageFormat, const uno::Any &rImage ) 
+    throw( lang::IllegalArgumentException, uno::RuntimeException )
+{
+    checkFilePicker();
+    ::osl::MutexGuard aGuard( m_aMutex );
+
+    m_pImpl->setImage( aImageFormat, aImage );
+}
+
+sal_Bool SAL_CALL UnxFilePicker::setShowState( sal_Bool bShowState )
+    throw( uno::RuntimeException )
+{
+    checkFilePicker();
+    ::osl::MutexGuard aGuard( m_aMutex );   
+
+    return m_pImpl->setShowState( bShowState );
+}
+
+sal_Bool SAL_CALL UnxFilePicker::getShowState()
+    throw( uno::RuntimeException )
+{
+    checkFilePicker();
+    ::osl::MutexGuard aGuard( m_aMutex );
+
+    return m_pImpl->getShowState();
+}
+*/
+
+void SAL_CALL UnxFilePicker::initialize( const uno::Sequence<uno::Any> &rArguments ) 
+    throw( uno::Exception, uno::RuntimeException )
+{
+    initFilePicker();
+
+    // parameter checking	    
+    uno::Any aAny;
+    if ( 0 == rArguments.getLength( ) )
+        throw lang::IllegalArgumentException(
+                rtl::OUString::createFromAscii( "no arguments" ),
+                static_cast< XFilePicker* >( this ), 1 );
+
+    aAny = rArguments[0];
+
+    if ( ( aAny.getValueType() != ::getCppuType( (sal_Int16*)0 ) ) && ( aAny.getValueType() != ::getCppuType( (sal_Int8*)0 ) ) )
+        throw lang::IllegalArgumentException(
+                rtl::OUString::createFromAscii( "invalid argument type" ),
+                static_cast< XFilePicker* >( this ), 1 );
+
+    sal_Int16 templateId = -1;
+    aAny >>= templateId;
+
+    // FIXME Get these names from resources
+    ::rtl::OUString aTitleOpen   = ::rtl::OUString::createFromAscii( "setTitle \"Open\"" );
+    ::rtl::OUString aTitleSaveAs = ::rtl::OUString::createFromAscii( "setTitle \"Save As\"" );
+
+    switch ( templateId )
+    {
+        case FILEOPEN_SIMPLE:
+            sendCommand( aTitleOpen );
+            break;
+
+        case FILESAVE_SIMPLE:
+            sendCommand( aTitleSaveAs );
+            break;
+
+        case FILESAVE_AUTOEXTENSION_PASSWORD:
+            sendCommand( aTitleSaveAs );
+
+            sendAppendControlCommand( ExtendedFilePickerElementIds::CHECKBOX_AUTOEXTENSION );
+            sendAppendControlCommand( ExtendedFilePickerElementIds::CHECKBOX_PASSWORD );
+            break;
+
+        case FILESAVE_AUTOEXTENSION_PASSWORD_FILTEROPTIONS:
+            sendCommand( aTitleSaveAs );
+
+            sendAppendControlCommand( ExtendedFilePickerElementIds::CHECKBOX_AUTOEXTENSION );
+            sendAppendControlCommand( ExtendedFilePickerElementIds::CHECKBOX_PASSWORD );
+            sendAppendControlCommand( ExtendedFilePickerElementIds::CHECKBOX_FILTEROPTIONS );
+            break;
+
+        case FILESAVE_AUTOEXTENSION_SELECTION:
+            sendCommand( aTitleSaveAs );
+
+            sendAppendControlCommand( ExtendedFilePickerElementIds::CHECKBOX_AUTOEXTENSION );
+            sendAppendControlCommand( ExtendedFilePickerElementIds::CHECKBOX_SELECTION );
+            break;
+
+        case FILESAVE_AUTOEXTENSION_TEMPLATE:
+            sendCommand( aTitleSaveAs );
+
+            sendAppendControlCommand( ExtendedFilePickerElementIds::CHECKBOX_AUTOEXTENSION );
+            sendAppendControlCommand( ExtendedFilePickerElementIds::LISTBOX_TEMPLATE );
+            break;
+
+        case FILEOPEN_LINK_PREVIEW_IMAGE_TEMPLATE:
+            sendCommand( aTitleOpen );
+
+            sendAppendControlCommand( ExtendedFilePickerElementIds::CHECKBOX_LINK );
+            sendAppendControlCommand( ExtendedFilePickerElementIds::CHECKBOX_PREVIEW );
+            sendAppendControlCommand( ExtendedFilePickerElementIds::LISTBOX_IMAGE_TEMPLATE );
+            break;
+
+        case FILEOPEN_PLAY:        
+            sendCommand( aTitleOpen );
+
+            sendAppendControlCommand( ExtendedFilePickerElementIds::PUSHBUTTON_PLAY );
+            break;
+
+        case FILEOPEN_READONLY_VERSION:
+            sendCommand( aTitleOpen );
+
+            sendAppendControlCommand( ExtendedFilePickerElementIds::CHECKBOX_READONLY );
+            sendAppendControlCommand( ExtendedFilePickerElementIds::LISTBOX_VERSION );
+            break;
+
+        case FILEOPEN_LINK_PREVIEW:
+            sendCommand( aTitleOpen );
+
+            sendAppendControlCommand( ExtendedFilePickerElementIds::CHECKBOX_LINK );
+            sendAppendControlCommand( ExtendedFilePickerElementIds::CHECKBOX_PREVIEW );
+            break;
+
+        case FILESAVE_AUTOEXTENSION:
+            sendCommand( aTitleSaveAs );
+
+            sendAppendControlCommand( ExtendedFilePickerElementIds::CHECKBOX_AUTOEXTENSION );
+            break;
+
+        default:
+            throw lang::IllegalArgumentException(
+                    rtl::OUString::createFromAscii( "Unknown template" ),
+                    static_cast< XFilePicker* >( this ),
+                    1 );
+    }
+}
+
+void SAL_CALL UnxFilePicker::cancel()
+    throw ( uno::RuntimeException )
+{
+    // FIXME cancel() is not implemented
+    checkFilePicker();
+    ::osl::MutexGuard aGuard( m_aMutex );
+
+    // TODO m_pImpl->cancel();    
+}
+
+void SAL_CALL UnxFilePicker::disposing( const lang::EventObject &rEvent )
+    throw( uno::RuntimeException )
+{
+    uno::Reference<XFilePickerListener> xFilePickerListener( rEvent.Source, uno::UNO_QUERY );
+
+    if ( xFilePickerListener.is() )
+        removeFilePickerListener( xFilePickerListener );
+}
+
+rtl::OUString SAL_CALL UnxFilePicker::getImplementationName() 
+    throw( uno::RuntimeException )
+{
+    return rtl::OUString::createFromAscii( FILE_PICKER_IMPL_NAME );
+}
+
+sal_Bool SAL_CALL UnxFilePicker::supportsService( const rtl::OUString& ServiceName ) 
+    throw( uno::RuntimeException )
+{
+    uno::Sequence< ::rtl::OUString > SupportedServicesNames = FilePicker_getSupportedServiceNames();
+
+    for ( sal_Int32 n = SupportedServicesNames.getLength(); n--; )
+    {
+        if ( SupportedServicesNames[n].compareTo( ServiceName ) == 0 )
+            return sal_True;
+    }
+
+    return sal_False;
+}
+
+uno::Sequence< ::rtl::OUString > SAL_CALL UnxFilePicker::getSupportedServiceNames() 
+    throw( uno::RuntimeException )
+{
+    return FilePicker_getSupportedServiceNames();
+}
+
+void UnxFilePicker::initFilePicker()
+{
+    int aFiledesStdin[2], aFiledesStdout[2];
+    if ( pipe( aFiledesStdin ) < 0 || pipe( aFiledesStdout ) < 0 )
+        return;
+
+    m_nFilePickerPid = fork();
+    if ( m_nFilePickerPid < 0 )
+        return;
+
+    if ( m_nFilePickerPid == 0 )
+    {
+        // Child...
+        close( aFiledesStdin[1] ); // write end of the pipe
+        dup2(  aFiledesStdin[0], 0 );
+        close( aFiledesStdin[0] );
+
+        close( aFiledesStdout[0] ); // read end of the pipe
+        dup2(  aFiledesStdout[1], 1 );
+        close( aFiledesStdout[1] );
+        
+#if OSL_DEBUG_LEVEL == 0
+        int nRedirect = open( "/dev/null", O_WRONLY );
+        if( nRedirect != -1 )
+        {
+            dup2( nRedirect, 2 );
+        }
+#endif
+
+        // FIXME: window id, etc.
+        const char *pFname = "kdefilepicker";
+
+        execlp( pFname, pFname, NULL );
+
+        // Error, finish the child
+        exit( -1 );
+    }
+
+    // Parent continues
+    close( aFiledesStdin[0] );
+    m_nFilePickerWrite = aFiledesStdin[1];
+
+    close( aFiledesStdout[1] );
+    m_nFilePickerRead = aFiledesStdout[0];
+
+    // Create the notify thread
+    if ( !m_pNotifyThread )
+        m_pNotifyThread = new UnxFilePickerNotifyThread( this );
+    
+    // Create the command thread
+    if ( !m_pCommandThread )
+        m_pCommandThread = new UnxFilePickerCommandThread( m_pNotifyThread, m_nFilePickerRead );
+
+    // Start the threads
+    m_pNotifyThread->create();
+    m_pCommandThread->create();
+
+    return;
+}
+
+void UnxFilePicker::checkFilePicker() throw( ::com::sun::star::uno::RuntimeException )
+{
+    if ( m_nFilePickerPid > 0 )
+    {
+        // TODO check if external file picker is runnning
+    }
+    else
+    {
+        throw uno::RuntimeException(
+                ::rtl::OUString::createFromAscii( "the external file picker does not run" ),
+                *this );
+    }
+}
+
+void UnxFilePicker::sendCommand( const ::rtl::OUString &rCommand )
+{
+    if ( m_nFilePickerWrite < 0 )
+        return;
+
+    ::rtl::OString aUtfString = OUStringToOString( rCommand + ::rtl::OUString::createFromAscii( "\n" ), RTL_TEXTENCODING_UTF8 );
+
+#if OSL_DEBUG_LEVEL > 0
+    ::std::cerr << "UnxFilePicker sent: \"" << aUtfString.getStr() << "\"" << ::std::endl;
+#endif
+    
+    write( m_nFilePickerWrite, aUtfString.getStr(), aUtfString.getLength() );
+}
+
+void UnxFilePicker::sendCommand( const ::rtl::OUString &rCommand, ::osl::Condition &rCondition )
+{
+    rCondition.reset();
+    
+    sendCommand( rCommand );
+
+    rCondition.wait();
+}
+
+void UnxFilePicker::appendEscaped( ::rtl::OUStringBuffer &rBuffer, const ::rtl::OUString &rString )
+{
+    const sal_Unicode *pUnicode = rString.getStr();
+    const sal_Unicode *pEnd     = pUnicode + rString.getLength();
+
+    rBuffer.appendAscii( "\"" , 1 );
+    
+    for ( ; pUnicode != pEnd; ++pUnicode )
+    {
+        if ( *pUnicode == '\\' )
+            rBuffer.appendAscii( "\\\\", 2 );
+        else if ( *pUnicode == '"' )
+            rBuffer.appendAscii( "\\\"", 2 );
+        else if ( *pUnicode == '\n' )
+            rBuffer.appendAscii( "\\n", 2 );
+        else
+            rBuffer.append( *pUnicode );
+    }
+    
+    rBuffer.appendAscii( "\"", 1 );
+}
+
+sal_Bool UnxFilePicker::controlIdInfo( sal_Int16 nControlId, ::rtl::OUString &rType, sal_Int32 &rTitleId )
+{
+    typedef struct {
+        sal_Int16 nId;
+        const ::rtl::OUString *pType;
+        sal_Int32 nTitle;
+    } ElementToName;
+
+    const ::rtl::OUString aCheckBox( RTL_CONSTASCII_USTRINGPARAM(   "checkbox" ) );
+    const ::rtl::OUString aControl( RTL_CONSTASCII_USTRINGPARAM(    "control" ) );
+    const ::rtl::OUString aEdit( RTL_CONSTASCII_USTRINGPARAM(       "edit" ) );
+    const ::rtl::OUString aLabel( RTL_CONSTASCII_USTRINGPARAM(      "label" ) );
+    const ::rtl::OUString aListBox( RTL_CONSTASCII_USTRINGPARAM(    "listbox" ) );
+    const ::rtl::OUString aPushButton( RTL_CONSTASCII_USTRINGPARAM( "pushbutton" ) );
+    
+    const ElementToName *pPtr;
+    const ElementToName pArray[] =
+    {
+        { CommonFilePickerElementIds::PUSHBUTTON_OK,            &aPushButton, 0/*FIXME?*/ },
+        { CommonFilePickerElementIds::PUSHBUTTON_CANCEL,        &aPushButton, 0/*FIXME?*/ },
+        { CommonFilePickerElementIds::LISTBOX_FILTER,           &aListBox,    0/*FIXME?*/ },
+        { CommonFilePickerElementIds::CONTROL_FILEVIEW,         &aControl,    0/*FIXME?*/ },
+        { CommonFilePickerElementIds::EDIT_FILEURL,             &aEdit,       0/*FIXME?*/ },
+        { CommonFilePickerElementIds::LISTBOX_FILTER_LABEL,     &aLabel,      0/*FIXME?*/ },
+        { CommonFilePickerElementIds::EDIT_FILEURL_LABEL,       &aLabel,      0/*FIXME?*/ },
+        
+        { ExtendedFilePickerElementIds::CHECKBOX_AUTOEXTENSION, &aCheckBox,   STR_SVT_FILEPICKER_AUTO_EXTENSION },
+        { ExtendedFilePickerElementIds::CHECKBOX_PASSWORD,      &aCheckBox,   STR_SVT_FILEPICKER_PASSWORD },
+        { ExtendedFilePickerElementIds::CHECKBOX_FILTEROPTIONS, &aCheckBox,   STR_SVT_FILEPICKER_FILTER_OPTIONS },
+        { ExtendedFilePickerElementIds::CHECKBOX_READONLY,      &aCheckBox,   STR_SVT_FILEPICKER_READONLY },
+        { ExtendedFilePickerElementIds::CHECKBOX_LINK,          &aCheckBox,   STR_SVT_FILEPICKER_INSERT_AS_LINK },
+        { ExtendedFilePickerElementIds::CHECKBOX_PREVIEW,       &aCheckBox,   STR_SVT_FILEPICKER_SHOW_PREVIEW },
+        { ExtendedFilePickerElementIds::PUSHBUTTON_PLAY,        &aPushButton, STR_SVT_FILEPICKER_PLAY },
+        { ExtendedFilePickerElementIds::LISTBOX_VERSION,        &aListBox,    STR_SVT_FILEPICKER_VERSION },
+        { ExtendedFilePickerElementIds::LISTBOX_TEMPLATE,       &aListBox,    STR_SVT_FILEPICKER_TEMPLATES },
+        { ExtendedFilePickerElementIds::LISTBOX_IMAGE_TEMPLATE, &aListBox,    STR_SVT_FILEPICKER_IMAGE_TEMPLATE },
+        { ExtendedFilePickerElementIds::CHECKBOX_SELECTION,     &aCheckBox,   STR_SVT_FILEPICKER_SELECTION },
+        { 0, 0, 0 }
+    };
+    
+    for ( pPtr = pArray; pPtr->nId && ( pPtr->nId != nControlId ); ++pPtr )
+        ;
+
+    if ( pPtr->nId == nControlId )
+    {
+        rType = *(pPtr->pType);
+        rTitleId = pPtr->nTitle;
+
+        return sal_True;
+    }
+
+    return sal_False;
+}
+
+sal_Bool UnxFilePicker::controlActionInfo( sal_Int16 nControlAction, ::rtl::OUString &rType )
+{
+    typedef struct {
+        sal_Int16 nId;
+        const ::rtl::OUString pType;
+    } ElementToName;
+
+    const ElementToName *pPtr;
+    const ElementToName pArray[] =
+    {
+        { ControlActions::ADD_ITEM,                ::rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "addItem" ) ) },
+        { ControlActions::ADD_ITEMS,               ::rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "addItems" ) ) },
+        { ControlActions::DELETE_ITEM,             ::rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "deleteItem" ) ) },
+        { ControlActions::DELETE_ITEMS,            ::rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "deleteItems" ) ) },
+        { ControlActions::SET_SELECT_ITEM,         ::rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "setSelectedItem" ) ) },
+        { ControlActions::GET_ITEMS,               ::rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "getItems" ) ) },
+        { ControlActions::GET_SELECTED_ITEM,       ::rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "getSelectedItem" ) ) },
+        { ControlActions::GET_SELECTED_ITEM_INDEX, ::rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "getSelectedItemIndex" ) ) },
+        { ControlActions::SET_HELP_URL,            ::rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "setHelpURL" ) ) },
+        { ControlActions::GET_HELP_URL,            ::rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "getHelpURL" ) ) },
+        { 0,                                       ::rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "noAction" ) ) }
+    };
+
+    for ( pPtr = pArray; pPtr->nId && ( pPtr->nId != nControlAction ); ++pPtr )
+        ;
+
+    rType = pPtr->pType;
+
+    return sal_True;
+}
+
+void UnxFilePicker::sendAppendControlCommand( sal_Int16 nControlId )
+{
+    ::rtl::OUString aType;
+    sal_Int32 nTitleId;
+
+    if ( controlIdInfo( nControlId, aType, nTitleId ) )
+    {
+        ::rtl::OUStringBuffer aBuffer( 1024 );
+        
+        aBuffer.appendAscii( "appendControl " );
+        aBuffer.append( static_cast< sal_Int32 >( nControlId ) );
+        aBuffer.appendAscii( " ", 1 );
+        appendEscaped( aBuffer, aType );
+        aBuffer.appendAscii( " ", 1 );
+        appendEscaped( aBuffer, ::rtl::OUString( SvtResId( nTitleId ) ) );
+
+        sendCommand( aBuffer.makeStringAndClear() );
+    }
+}
--- /dev/null	2004-04-06 15:27:52.000000000 +0200
+++ fpicker/source/unx/UnxFilePicker.hxx	2004-06-16 13:57:49.733143432 +0200
@@ -0,0 +1,238 @@
+/*************************************************************************
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
+ *
+ *  Copyright: 2000 by Sun Microsystems, Inc.
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): Jan Holesovsky <kendy@openoffice.org>
+ *
+ *
+ ************************************************************************/
+
+#ifndef _UNXFILEPICKER_HXX_
+#define _UNXFILEPICKER_HXX_
+
+#ifndef _CPPUHELPER_COMPBASE8_HXX_
+#include <cppuhelper/compbase8.hxx>
+#endif
+
+#ifndef _OSL_CONDITN_HXX_
+#include <osl/conditn.hxx>
+#endif
+
+#ifndef _OSL_MUTEX_HXX_
+#include <osl/mutex.hxx>
+#endif
+
+#ifndef _COM_SUN_STAR_LANG_XINITIALIZATION_HPP_
+#include <com/sun/star/lang/XInitialization.hpp>
+#endif
+
+#ifndef _COM_SUN_STAR_LANG_XSERVICEINFO_HPP_
+#include <com/sun/star/lang/XServiceInfo.hpp>
+#endif
+
+#ifndef _COM_SUN_STAR_UI_DIALOGS_XFILEPICKERNOTIFIER_HPP_
+#include <com/sun/star/ui/dialogs/XFilePickerNotifier.hpp>
+#endif
+
+#ifndef _COM_SUN_STAR_UI_DIALOGS_XFILTERMANAGER_HPP_
+#include <com/sun/star/ui/dialogs/XFilterManager.hpp>
+#endif
+
+#ifndef _COM_SUN_STAR_UI_DIALOGS_XFILTERGROUPMANAGER_HPP_
+#include <com/sun/star/ui/dialogs/XFilterGroupManager.hpp>
+#endif
+
+#ifndef _COM_SUN_STAR_UI_DIALOGS_XFILEPICKERCONTROLACCESS_HPP_
+#include <com/sun/star/ui/dialogs/XFilePickerControlAccess.hpp>
+#endif
+
+#ifndef _COM_SUN_STAR_UI_DIALOGS_XFILEPREVIEW_HPP_
+#include <com/sun/star/ui/dialogs/XFilePreview.hpp>
+#endif
+
+#ifndef _COM_SUN_STAR_UTIL_XCANCELLABLE_HPP_
+#include <com/sun/star/util/XCancellable.hpp>
+#endif
+
+#ifndef _RTL_USTRBUF_HXX_
+#include <rtl/ustrbuf.hxx>
+#endif
+
+#include <list>
+
+class UnxFilePickerCommandThread;
+class UnxFilePickerNotifyThread;
+
+class UnxFilePickerDummy
+{
+protected:
+    osl::Mutex                  m_aMutex;
+    osl::Mutex                  m_rbHelperMtx;
+};
+
+class UnxFilePicker : 
+    public UnxFilePickerDummy,
+    public cppu::WeakComponentImplHelper8<
+        ::com::sun::star::ui::dialogs::XFilterManager,
+        ::com::sun::star::ui::dialogs::XFilterGroupManager,
+        ::com::sun::star::ui::dialogs::XFilePickerControlAccess,
+        ::com::sun::star::ui::dialogs::XFilePickerNotifier,
+// TODO ::com::sun::star::ui::dialogs::XFilePreview,
+        ::com::sun::star::lang::XInitialization,
+        ::com::sun::star::util::XCancellable,
+        ::com::sun::star::lang::XEventListener,
+        ::com::sun::star::lang::XServiceInfo >		
+{
+protected:
+    ::com::sun::star::uno::Reference< ::com::sun::star::lang::XMultiServiceFactory > m_xServiceMgr;   // to instanciate own services		
+
+    pid_t                       m_nFilePickerPid;
+    int                         m_nFilePickerWrite; // (kde|...)filepicker gets it as stdin
+    int                         m_nFilePickerRead;  // (kde|...)filepicker gets it as stdout
+
+    UnxFilePickerNotifyThread  *m_pNotifyThread;
+    UnxFilePickerCommandThread *m_pCommandThread;
+
+public:
+    UnxFilePicker( const ::com::sun::star::uno::Reference< ::com::sun::star::lang::XMultiServiceFactory >& xServiceMgr );
+    virtual ~UnxFilePicker();
+
+    // XFilePickerNotifier
+
+    virtual void SAL_CALL       addFilePickerListener( const ::com::sun::star::uno::Reference< ::com::sun::star::ui::dialogs::XFilePickerListener >& xListener ) throw( ::com::sun::star::uno::RuntimeException );
+    virtual void SAL_CALL       removeFilePickerListener( const ::com::sun::star::uno::Reference< ::com::sun::star::ui::dialogs::XFilePickerListener >& xListener ) throw( ::com::sun::star::uno::RuntimeException );
+
+    // XExecutableDialog functions
+
+    virtual void SAL_CALL       setTitle( const ::rtl::OUString &rTitle ) throw( ::com::sun::star::uno::RuntimeException );
+    virtual sal_Int16 SAL_CALL  execute() throw( ::com::sun::star::uno::RuntimeException );
+
+    // XFilePicker functions
+
+    virtual void SAL_CALL       setMultiSelectionMode( sal_Bool bMode ) throw( ::com::sun::star::uno::RuntimeException );
+    virtual void SAL_CALL       setDefaultName( const ::rtl::OUString &rName ) throw( ::com::sun::star::uno::RuntimeException );
+    virtual void SAL_CALL       setDisplayDirectory( const ::rtl::OUString &rDirectory ) throw( ::com::sun::star::uno::RuntimeException );
+    virtual ::rtl::OUString SAL_CALL getDisplayDirectory() throw( ::com::sun::star::uno::RuntimeException );
+    virtual ::com::sun::star::uno::Sequence< ::rtl::OUString > SAL_CALL getFiles() throw( ::com::sun::star::uno::RuntimeException );
+
+    // XFilterManager functions
+
+    virtual void SAL_CALL       appendFilter( const ::rtl::OUString &rTitle, const ::rtl::OUString &rFilter ) throw( ::com::sun::star::lang::IllegalArgumentException, ::com::sun::star::uno::RuntimeException );
+    virtual void SAL_CALL       setCurrentFilter( const ::rtl::OUString &rTitle ) throw( ::com::sun::star::lang::IllegalArgumentException, ::com::sun::star::uno::RuntimeException );
+    virtual ::rtl::OUString SAL_CALL getCurrentFilter() throw( ::com::sun::star::uno::RuntimeException );
+
+    // XFilterGroupManager functions
+
+    virtual void SAL_CALL       appendFilterGroup( const ::rtl::OUString &rGroupTitle, const ::com::sun::star::uno::Sequence< ::com::sun::star::beans::StringPair > &rFilters ) throw (::com::sun::star::lang::IllegalArgumentException, ::com::sun::star::uno::RuntimeException);
+
+    // XFilePickerControlAccess functions
+
+    virtual void SAL_CALL       setValue( sal_Int16 nControlId, sal_Int16 nControlAction, const ::com::sun::star::uno::Any &rValue ) throw (::com::sun::star::uno::RuntimeException);
+    virtual ::com::sun::star::uno::Any SAL_CALL getValue( sal_Int16 nControlId, sal_Int16 nControlAction ) throw (::com::sun::star::uno::RuntimeException);
+    virtual void SAL_CALL       enableControl( sal_Int16 nControlId, sal_Bool bEnable ) throw( ::com::sun::star::uno::RuntimeException );
+    virtual void SAL_CALL       setLabel( sal_Int16 nControlId, const ::rtl::OUString &rLabel ) throw (::com::sun::star::uno::RuntimeException);
+    virtual ::rtl::OUString SAL_CALL getLabel( sal_Int16 nControlId ) throw (::com::sun::star::uno::RuntimeException);
+
+    /* TODO XFilePreview
+
+    virtual ::com::sun::star::uno::Sequence< sal_Int16 > SAL_CALL getSupportedImageFormats(  ) throw (::com::sun::star::uno::RuntimeException);
+    virtual sal_Int32 SAL_CALL  getTargetColorDepth(  ) throw (::com::sun::star::uno::RuntimeException);
+    virtual sal_Int32 SAL_CALL  getAvailableWidth(  ) throw (::com::sun::star::uno::RuntimeException);
+    virtual sal_Int32 SAL_CALL  getAvailableHeight(  ) throw (::com::sun::star::uno::RuntimeException);
+    virtual void SAL_CALL       setImage( sal_Int16 aImageFormat, const ::com::sun::star::uno::Any &rImage ) throw (::com::sun::star::lang::IllegalArgumentException, ::com::sun::star::uno::RuntimeException);
+    virtual sal_Bool SAL_CALL   setShowState( sal_Bool bShowState ) throw (::com::sun::star::uno::RuntimeException);
+    virtual sal_Bool SAL_CALL   getShowState(  ) throw (::com::sun::star::uno::RuntimeException);
+    */
+
+    // XInitialization
+
+    virtual void SAL_CALL       initialize( const ::com::sun::star::uno::Sequence< ::com::sun::star::uno::Any > &rArguments ) throw( ::com::sun::star::uno::Exception, ::com::sun::star::uno::RuntimeException );
+
+    // XCancellable
+
+    virtual void SAL_CALL       cancel( ) throw( ::com::sun::star::uno::RuntimeException );
+
+    // XEventListener
+
+    virtual void SAL_CALL       disposing( const ::com::sun::star::lang::EventObject &rEvent ) throw( ::com::sun::star::uno::RuntimeException );
+
+    // XServiceInfo
+
+    virtual ::rtl::OUString SAL_CALL getImplementationName() throw( ::com::sun::star::uno::RuntimeException );
+    virtual sal_Bool SAL_CALL   supportsService( const ::rtl::OUString &rServiceName ) throw( ::com::sun::star::uno::RuntimeException );
+    virtual ::com::sun::star::uno::Sequence< ::rtl::OUString > SAL_CALL getSupportedServiceNames() throw( ::com::sun::star::uno::RuntimeException );
+
+private:
+    // prevent copy and assignment
+    UnxFilePicker( const UnxFilePicker& );           
+    UnxFilePicker& operator=( const UnxFilePicker& );
+
+protected:
+    void                        initFilePicker();
+    void                        checkFilePicker() throw( ::com::sun::star::uno::RuntimeException );
+
+    // Async sendCommand
+    void                        sendCommand( const ::rtl::OUString &rCommand );
+    // Synchronized sendCommand
+    void                        sendCommand( const ::rtl::OUString &rCommand, ::osl::Condition &rCondition );
+    void                        appendEscaped( ::rtl::OUStringBuffer &rBuffer, const ::rtl::OUString &rString );
+
+private:
+    sal_Bool                    controlIdInfo( sal_Int16 nControlId, ::rtl::OUString &rType, sal_Int32 &rTitleId );
+    sal_Bool                    controlActionInfo( sal_Int16 nControlId, ::rtl::OUString &rType );
+    void                        sendAppendControlCommand( sal_Int16 nControlId );
+}; 
+
+#endif // _UNXFILEPICKER_HXX_
--- /dev/null	2004-04-06 15:27:52.000000000 +0200
+++ fpicker/source/unx/UnxNotifyThread.cxx	2004-06-16 17:38:35.509479352 +0200
@@ -0,0 +1,150 @@
+/*************************************************************************
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$ 
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
+ *
+ *  Copyright: 2000 by Sun Microsystems, Inc.
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): Jan Holesovsky <kendy@openoffice.org>
+ *
+ *
+ ************************************************************************/
+
+#ifndef _UNXNOTIFYTHREAD_HXX_
+#include <UnxNotifyThread.hxx>
+#endif
+
+#ifndef _UNXFILEOPENIMPL_HXX_
+#include <UnxFilePicker.hxx>
+#endif
+
+using namespace ::com::sun::star;
+
+//////////////////////////////////////////////////////////////////////////
+// UnxFilePickerNotifyThread
+//////////////////////////////////////////////////////////////////////////
+
+UnxFilePickerNotifyThread::UnxFilePickerNotifyThread( UnxFilePicker *pUnxFilePicker )
+    : m_pUnxFilePicker( pUnxFilePicker ),
+      m_bExit( sal_False ),
+      m_eNotifyType( Nothing ),
+      m_nControlId( 0 )
+{
+}
+
+void SAL_CALL UnxFilePickerNotifyThread::addFilePickerListener( const uno::Reference< ui::dialogs::XFilePickerListener >& xListener )
+    throw( uno::RuntimeException )
+{
+    ::osl::MutexGuard aGuard( m_aMutex );
+
+    m_xListener = xListener;
+}
+
+void SAL_CALL UnxFilePickerNotifyThread::removeFilePickerListener( const uno::Reference< ui::dialogs::XFilePickerListener >& xListener ) 
+    throw( uno::RuntimeException )
+{
+    ::osl::MutexGuard aGuard( m_aMutex );
+
+    m_xListener.clear();
+}
+
+void SAL_CALL UnxFilePickerNotifyThread::exit()
+{
+    ::osl::MutexGuard aGuard( m_aMutex );
+
+    m_bExit = sal_True;
+
+    m_aExitCondition.reset();
+    m_aNotifyCondition.set();
+    
+    m_aExitCondition.wait();
+}
+
+void SAL_CALL UnxFilePickerNotifyThread::fileSelectionChanged()
+{
+    ::osl::MutexGuard aGuard( m_aMutex );
+
+    m_eNotifyType = FileSelectionChanged;
+    m_nControlId = 0;
+    
+    m_aNotifyCondition.set();
+}
+
+void SAL_CALL UnxFilePickerNotifyThread::run()
+{
+    do {
+        m_aNotifyCondition.reset();
+        m_aNotifyCondition.wait();
+
+        if ( m_xListener.is() && m_pUnxFilePicker )
+        {
+            ::osl::MutexGuard aGuard( m_aMutex );
+
+            ui::dialogs::FilePickerEvent aEvent( *m_pUnxFilePicker, m_nControlId );
+
+            switch ( m_eNotifyType )
+            {
+                case FileSelectionChanged:
+                    m_xListener->fileSelectionChanged( aEvent );
+                    break;
+
+                // TODO More to come...
+
+                default:
+                    // nothing
+                    break;
+            }
+        }
+    } while ( !m_bExit );
+
+    m_aExitCondition.set();
+}
--- /dev/null	2004-04-06 15:27:52.000000000 +0200
+++ fpicker/source/unx/UnxNotifyThread.hxx	2004-06-16 17:30:52.535862040 +0200
@@ -0,0 +1,132 @@
+/*************************************************************************
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
+ *
+ *  Copyright: 2000 by Sun Microsystems, Inc.
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): Jan Holesovsky <kendy@openoffice.org>
+ *
+ *
+ ************************************************************************/
+
+#ifndef _UNXNOTIFYTHREAD_HXX_
+#define _UNXNOTIFYTHREAD_HXX_
+
+#ifndef _COM_SUN_STAR_UI_DIALOGS_XFILEPICKERLISTENER_HPP_
+#include <com/sun/star/ui/dialogs/XFilePickerListener.hpp>
+#endif
+
+#ifndef _COM_SUN_STAR_UNO_REFERENCE_H_
+#include <com/sun/star/uno/Reference.h>
+#endif
+
+#ifndef _OSL_CONDITN_HXX_
+#include <osl/conditn.hxx>
+#endif
+
+#ifndef _OSL_MUTEX_HXX_
+#include <osl/mutex.hxx>
+#endif
+
+#ifndef _OSL_THREAD_HXX_
+#include <osl/thread.hxx>
+#endif
+
+class UnxFilePicker;
+
+class UnxFilePickerNotifyThread : public ::osl::Thread
+{
+protected:
+    enum NotifyType
+    {
+        Nothing = 0,
+        FileSelectionChanged
+	// TODO More to come...
+    };
+
+    UnxFilePicker              *m_pUnxFilePicker;
+
+    ::osl::Mutex                m_aMutex;
+
+    ::com::sun::star::uno::Reference< ::com::sun::star::ui::dialogs::XFilePickerListener > m_xListener;
+
+    sal_Bool                    m_bExit;
+    ::osl::Condition            m_aExitCondition;
+
+    NotifyType                  m_eNotifyType;
+    ::osl::Condition            m_aNotifyCondition;
+    sal_Int16                   m_nControlId;
+    
+public:
+    UnxFilePickerNotifyThread( UnxFilePicker *pUnxFilePicker );
+
+    virtual void SAL_CALL addFilePickerListener( const ::com::sun::star::uno::Reference< ::com::sun::star::ui::dialogs::XFilePickerListener >& xListener ) 
+        throw( ::com::sun::star::uno::RuntimeException );
+    virtual void SAL_CALL removeFilePickerListener( const ::com::sun::star::uno::Reference< ::com::sun::star::ui::dialogs::XFilePickerListener >& xListener ) 
+        throw( ::com::sun::star::uno::RuntimeException );
+
+    void SAL_CALL               exit();
+
+    void SAL_CALL               fileSelectionChanged();
+    /* TODO
+    void SAL_CALL directoryChanged( ::com::sun::star::ui::dialogs::FilePickerEvent aEvent );
+    rtl::OUString SAL_CALL helpRequested( ::com::sun::star::ui::dialogs::FilePickerEvent aEvent ) const;
+    void SAL_CALL controlStateChanged( ::com::sun::star::ui::dialogs::FilePickerEvent aEvent );
+    void SAL_CALL dialogSizeChanged( );
+     */
+
+protected:
+    virtual void SAL_CALL       run();
+};
+
+#endif // _UNXNOTIFYTHREAD_HXX_
