--- xmloff/source/forms/strings.hxx.orig	1970-01-01 08:00:00.000000000 +0800
+++ xmloff/source/forms/strings.hxx	2008-06-04 12:38:12.000000000 +0800
@@ -0,0 +1,283 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: strings.hxx,v $
+ * $Revision: 1.18 $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+
+#ifndef _XMLOFF_FORMS_STRINGS_HXX_
+#define _XMLOFF_FORMS_STRINGS_HXX_
+
+#include <sal/types.h>
+#include <rtl/ustring.hxx>
+
+//.........................................................................
+namespace xmloff
+{
+//.........................................................................
+
+	//============================================================
+	//= a helper for static ascii pseudo-unicode strings
+	//============================================================
+	struct ConstAsciiString
+	{
+		const sal_Char*	ascii;
+		sal_Int32		length;
+
+		inline const ::rtl::OUString* operator& () const;
+		inline	operator const ::rtl::OUString& () const { return *(&(*this)); }
+		inline	operator const sal_Char* () const { return ascii; }
+
+		inline ConstAsciiString(const sal_Char* _pAsciiZeroTerminated, const sal_Int32 _nLength);
+		inline ~ConstAsciiString();
+
+	private:
+		mutable ::rtl::OUString*	m_pString;
+
+	private:
+		ConstAsciiString();	// never implemented
+	};
+
+	//------------------------------------------------------------
+	inline ConstAsciiString::ConstAsciiString(const sal_Char* _pAsciiZeroTerminated, const sal_Int32 _nLength)
+		:ascii( _pAsciiZeroTerminated )
+		,length( _nLength )
+		,m_pString( NULL )
+	{
+	}
+
+	//------------------------------------------------------------
+	inline ConstAsciiString::~ConstAsciiString()
+	{
+		if ( m_pString )
+		{
+			delete m_pString;
+			m_pString = NULL;
+		}
+	}
+
+	//------------------------------------------------------------
+	inline const ::rtl::OUString* ConstAsciiString::operator& () const
+	{
+		if ( !m_pString )
+			m_pString = new ::rtl::OUString( ascii, length, RTL_TEXTENCODING_ASCII_US );
+		return m_pString;
+	}
+
+#ifndef XMLFORM_IMPLEMENT_STRINGS
+	#define XMLFORM_CONSTASCII_STRING(ident, string) extern const ConstAsciiString ident
+#else
+	#define XMLFORM_CONSTASCII_STRING(ident, string) extern const ConstAsciiString ident(string, sizeof(string)-1)
+#endif
+
+	//============================================================
+	//= string constants
+	//============================================================
+
+	// properties
+	XMLFORM_CONSTASCII_STRING( PROPERTY_CLASSID,			"ClassId" );
+	XMLFORM_CONSTASCII_STRING( PROPERTY_ECHOCHAR,			"EchoChar" );
+	XMLFORM_CONSTASCII_STRING( PROPERTY_MULTILINE,			"MultiLine" );
+	XMLFORM_CONSTASCII_STRING( PROPERTY_NAME,				"Name" );
+	XMLFORM_CONSTASCII_STRING( PROPERTY_IMAGEURL,			"ImageURL" );
+	XMLFORM_CONSTASCII_STRING( PROPERTY_LABEL,				"Label" );
+	XMLFORM_CONSTASCII_STRING( PROPERTY_TARGETFRAME,		"TargetFrame" );
+	XMLFORM_CONSTASCII_STRING( PROPERTY_TARGETURL,			"TargetURL" );
+	XMLFORM_CONSTASCII_STRING( PROPERTY_TITLE,				"Tag" );
+	XMLFORM_CONSTASCII_STRING( PROPERTY_DROPDOWN,			"Dropdown" );
+	XMLFORM_CONSTASCII_STRING( PROPERTY_PRINTABLE,			"Printable" );
+	XMLFORM_CONSTASCII_STRING( PROPERTY_READONLY,			"ReadOnly" );
+	XMLFORM_CONSTASCII_STRING( PROPERTY_DEFAULT_STATE,		"DefaultState" );
+	XMLFORM_CONSTASCII_STRING( PROPERTY_TABSTOP,			"Tabstop" );
+	XMLFORM_CONSTASCII_STRING( PROPERTY_STATE,				"State" );
+	XMLFORM_CONSTASCII_STRING( PROPERTY_ENABLED,			"Enabled" );
+	XMLFORM_CONSTASCII_STRING( PROPERTY_ENABLEVISIBLE,		"EnableVisible" );
+	XMLFORM_CONSTASCII_STRING( PROPERTY_MAXTEXTLENGTH,		"MaxTextLen" );
+	XMLFORM_CONSTASCII_STRING( PROPERTY_LINECOUNT,			"LineCount" );
+	XMLFORM_CONSTASCII_STRING( PROPERTY_TABINDEX,			"TabIndex" );
+	XMLFORM_CONSTASCII_STRING( PROPERTY_COMMAND,			"Command" );
+	XMLFORM_CONSTASCII_STRING( PROPERTY_DATASOURCENAME,		"DataSourceName" );
+	XMLFORM_CONSTASCII_STRING( PROPERTY_FILTER,				"Filter" );
+	XMLFORM_CONSTASCII_STRING( PROPERTY_ORDER,				"Order" );
+	XMLFORM_CONSTASCII_STRING( PROPERTY_ALLOWDELETES,		"AllowDeletes" );
+	XMLFORM_CONSTASCII_STRING( PROPERTY_ALLOWINSERTS,		"AllowInserts" );
+	XMLFORM_CONSTASCII_STRING( PROPERTY_ALLOWUPDATES,		"AllowUpdates" );
+	XMLFORM_CONSTASCII_STRING( PROPERTY_APPLYFILTER,		"ApplyFilter" );
+	XMLFORM_CONSTASCII_STRING( PROPERTY_ESCAPEPROCESSING,	"EscapeProcessing" );
+	XMLFORM_CONSTASCII_STRING( PROPERTY_IGNORERESULT,		"IgnoreResult" );
+	XMLFORM_CONSTASCII_STRING( PROPERTY_SUBMIT_ENCODING,	"SubmitEncoding" );
+	XMLFORM_CONSTASCII_STRING( PROPERTY_SUBMIT_METHOD,		"SubmitMethod" );
+	XMLFORM_CONSTASCII_STRING( PROPERTY_COMMAND_TYPE,		"CommandType" );
+	XMLFORM_CONSTASCII_STRING( PROPERTY_NAVIGATION,			"NavigationBarMode" );
+	XMLFORM_CONSTASCII_STRING( PROPERTY_CYCLE,				"Cycle" );
+	XMLFORM_CONSTASCII_STRING( PROPERTY_BUTTONTYPE,			"ButtonType" );
+	XMLFORM_CONSTASCII_STRING( PROPERTY_DATAFIELD,			"DataField" );
+	XMLFORM_CONSTASCII_STRING( PROPERTY_BOUNDCOLUMN,		"BoundColumn");
+	XMLFORM_CONSTASCII_STRING( PROPERTY_EMPTY_IS_NULL,		"ConvertEmptyToNull");
+	XMLFORM_CONSTASCII_STRING( PROPERTY_LISTSOURCE,			"ListSource");
+	XMLFORM_CONSTASCII_STRING( PROPERTY_LISTSOURCETYPE,		"ListSourceType");
+	XMLFORM_CONSTASCII_STRING( PROPERTY_ECHO_CHAR,			"EchoChar");
+	XMLFORM_CONSTASCII_STRING( PROPERTY_STRICTFORMAT,		"StrictFormat");
+	XMLFORM_CONSTASCII_STRING( PROPERTY_AUTOCOMPLETE,		"Autocomplete");
+	XMLFORM_CONSTASCII_STRING( PROPERTY_MULTISELECTION,		"MultiSelection");
+	XMLFORM_CONSTASCII_STRING( PROPERTY_DEFAULTBUTTON,		"DefaultButton");
+	XMLFORM_CONSTASCII_STRING( PROPERTY_TRISTATE,			"TriState");
+	XMLFORM_CONSTASCII_STRING( PROPERTY_CONTROLLABEL,		"LabelControl");
+	XMLFORM_CONSTASCII_STRING( PROPERTY_STRING_ITEM_LIST,	"StringItemList");
+	XMLFORM_CONSTASCII_STRING( PROPERTY_VALUE_SEQ,			"ValueItemList");
+	XMLFORM_CONSTASCII_STRING( PROPERTY_DEFAULT_SELECT_SEQ, "DefaultSelection");
+	XMLFORM_CONSTASCII_STRING( PROPERTY_SELECT_SEQ,			"SelectedItems");
+	XMLFORM_CONSTASCII_STRING( PROPERTY_DATE_MIN,			"DateMin");
+	XMLFORM_CONSTASCII_STRING( PROPERTY_DATE_MAX,			"DateMax");
+	XMLFORM_CONSTASCII_STRING( PROPERTY_TIME_MIN,			"TimeMin");
+	XMLFORM_CONSTASCII_STRING( PROPERTY_TIME_MAX,			"TimeMax");
+	XMLFORM_CONSTASCII_STRING( PROPERTY_VALUE_MIN,			"ValueMin");
+	XMLFORM_CONSTASCII_STRING( PROPERTY_VALUE_MAX,			"ValueMax");
+	XMLFORM_CONSTASCII_STRING( PROPERTY_EFFECTIVE_MIN,		"EffectiveMin");
+	XMLFORM_CONSTASCII_STRING( PROPERTY_EFFECTIVE_MAX,		"EffectiveMax");
+	XMLFORM_CONSTASCII_STRING( PROPERTY_DEFAULT_DATE,		"DefaultDate");
+	XMLFORM_CONSTASCII_STRING( PROPERTY_DATE,				"Date");
+	XMLFORM_CONSTASCII_STRING( PROPERTY_DEFAULT_TIME,		"DefaultTime");
+	XMLFORM_CONSTASCII_STRING( PROPERTY_TIME,				"Time");
+	XMLFORM_CONSTASCII_STRING( PROPERTY_DEFAULT_VALUE,		"DefaultValue");
+	XMLFORM_CONSTASCII_STRING( PROPERTY_VALUE,				"Value");
+	XMLFORM_CONSTASCII_STRING( PROPERTY_HIDDEN_VALUE,		"HiddenValue");
+	XMLFORM_CONSTASCII_STRING( PROPERTY_DEFAULT_TEXT,		"DefaultText");
+	XMLFORM_CONSTASCII_STRING( PROPERTY_TEXT,				"Text");
+	XMLFORM_CONSTASCII_STRING( PROPERTY_EFFECTIVE_VALUE,	"EffectiveValue");
+	XMLFORM_CONSTASCII_STRING( PROPERTY_EFFECTIVE_DEFAULT,	"EffectiveDefault");
+	XMLFORM_CONSTASCII_STRING( PROPERTY_REFVALUE,			"RefValue");
+	XMLFORM_CONSTASCII_STRING( PROPERTY_URL,				"URL");
+	XMLFORM_CONSTASCII_STRING( PROPERTY_FONT,				"FontDescriptor");
+	XMLFORM_CONSTASCII_STRING( PROPERTY_BACKGROUNDCOLOR,	"BackgroundColor");
+	XMLFORM_CONSTASCII_STRING( PROPERTY_MASTERFIELDS,		"MasterFields");
+	XMLFORM_CONSTASCII_STRING( PROPERTY_DETAILFIELDS,		"DetailFields");
+	XMLFORM_CONSTASCII_STRING( PROPERTY_COLUMNSERVICENAME,	"ColumnServiceName");
+	XMLFORM_CONSTASCII_STRING( PROPERTY_FORMATKEY,			"FormatKey");
+	XMLFORM_CONSTASCII_STRING( PROPERTY_ALIGN,				"Align");
+	XMLFORM_CONSTASCII_STRING( PROPERTY_BORDER,				"Border");
+	XMLFORM_CONSTASCII_STRING( PROPERTY_AUTOCONTROLFOCUS,	"AutomaticControlFocus");
+	XMLFORM_CONSTASCII_STRING( PROPERTY_APPLYDESIGNMODE,	"ApplyFormDesignMode");
+	XMLFORM_CONSTASCII_STRING( PROPERTY_FORMATSSUPPLIER,	"FormatsSupplier");
+	XMLFORM_CONSTASCII_STRING( PROPERTY_LOCALE,				"Locale");
+	XMLFORM_CONSTASCII_STRING( PROPERTY_FORMATSTRING,		"FormatString");
+	XMLFORM_CONSTASCII_STRING( PROPERTY_DATEFORMAT,			"DateFormat");
+	XMLFORM_CONSTASCII_STRING( PROPERTY_TIMEFORMAT,			"TimeFormat");
+	XMLFORM_CONSTASCII_STRING( PROPERTY_PERSISTENCE_MAXTEXTLENGTH,	"PersistenceMaxTextLength");
+    XMLFORM_CONSTASCII_STRING( PROPERTY_SCROLLVALUE_MIN,    "ScrollValueMin");
+	XMLFORM_CONSTASCII_STRING( PROPERTY_SCROLLVALUE_MAX,    "ScrollValueMax");
+	XMLFORM_CONSTASCII_STRING( PROPERTY_SCROLLVALUE,        "ScrollValue");
+	XMLFORM_CONSTASCII_STRING( PROPERTY_SCROLLVALUE_DEFAULT,"DefaultScrollValue");
+    XMLFORM_CONSTASCII_STRING( PROPERTY_LINE_INCREMENT,     "LineIncrement");
+    XMLFORM_CONSTASCII_STRING( PROPERTY_BLOCK_INCREMENT,    "BlockIncrement");
+    XMLFORM_CONSTASCII_STRING( PROPERTY_REPEAT_DELAY,       "RepeatDelay");
+    XMLFORM_CONSTASCII_STRING( PROPERTY_SPINVALUE,          "SpinValue");
+    XMLFORM_CONSTASCII_STRING( PROPERTY_SPINVALUE_MIN,      "SpinValueMin");
+    XMLFORM_CONSTASCII_STRING( PROPERTY_SPINVALUE_MAX,      "SpinValueMax");
+    XMLFORM_CONSTASCII_STRING( PROPERTY_DEFAULT_SPINVALUE,  "DefaultSpinValue");
+    XMLFORM_CONSTASCII_STRING( PROPERTY_SPIN_INCREMENT,     "SpinIncrement");
+    XMLFORM_CONSTASCII_STRING( PROPERTY_ORIENTATION,        "Orientation");
+    XMLFORM_CONSTASCII_STRING( PROPERTY_TOGGLE,             "Toggle");
+    XMLFORM_CONSTASCII_STRING( PROPERTY_FOCUS_ON_CLICK,     "FocusOnClick");
+    XMLFORM_CONSTASCII_STRING( PROPERTY_VISUAL_EFFECT,      "VisualEffect");
+    XMLFORM_CONSTASCII_STRING( PROPERTY_IMAGE_POSITION,     "ImagePosition");
+    XMLFORM_CONSTASCII_STRING( PROPERTY_IMAGE_ALIGN,        "ImageAlign");
+
+    XMLFORM_CONSTASCII_STRING( PROPERTY_BOUND_CELL,		    "BoundCell");
+    XMLFORM_CONSTASCII_STRING( PROPERTY_LIST_CELL_RANGE,    "CellRange");
+    XMLFORM_CONSTASCII_STRING( PROPERTY_ADDRESS,		    "Address");
+    XMLFORM_CONSTASCII_STRING( PROPERTY_FILE_REPRESENTATION,"PersistentRepresentation");
+    XMLFORM_CONSTASCII_STRING( PROPERTY_RICH_TEXT,          "RichText");
+
+	// services
+	XMLFORM_CONSTASCII_STRING( SERVICE_FORMSCOLLECTION,			"com.sun.star.form.Forms" );
+	XMLFORM_CONSTASCII_STRING( SERVICE_NUMBERFORMATSSUPPLIER,	"com.sun.star.util.NumberFormatsSupplier" );
+    XMLFORM_CONSTASCII_STRING( SERVICE_SPREADSHEET_DOCUMENT,    "com.sun.star.sheet.SpreadsheetDocument");
+	XMLFORM_CONSTASCII_STRING( SERVICE_CELLVALUEBINDING,	    "com.sun.star.table.CellValueBinding" );
+	XMLFORM_CONSTASCII_STRING( SERVICE_LISTINDEXCELLBINDING,    "com.sun.star.table.ListPositionCellBinding" );
+	XMLFORM_CONSTASCII_STRING( SERVICE_CELLRANGELISTSOURCE,	    "com.sun.star.table.CellRangeListSource" );
+    XMLFORM_CONSTASCII_STRING( SERVICE_ADDRESS_CONVERSION,      "com.sun.star.table.CellAddressConversion");
+    XMLFORM_CONSTASCII_STRING( SERVICE_RANGEADDRESS_CONVERSION, "com.sun.star.table.CellRangeAddressConversion");
+
+	// old service names (compatibility)
+	XMLFORM_CONSTASCII_STRING( SERVICE_PERSISTENT_COMPONENT_FORM,			"stardiv.one.form.component.Form");
+	XMLFORM_CONSTASCII_STRING( SERVICE_PERSISTENT_COMPONENT_EDIT,			"stardiv.one.form.component.Edit");
+	XMLFORM_CONSTASCII_STRING( SERVICE_PERSISTENT_COMPONENT_LISTBOX,		"stardiv.one.form.component.ListBox");
+	XMLFORM_CONSTASCII_STRING( SERVICE_PERSISTENT_COMPONENT_COMBOBOX,		"stardiv.one.form.component.ComboBox");
+	XMLFORM_CONSTASCII_STRING( SERVICE_PERSISTENT_COMPONENT_RADIOBUTTON,	"stardiv.one.form.component.RadioButton");
+	XMLFORM_CONSTASCII_STRING( SERVICE_PERSISTENT_COMPONENT_GROUPBOX,		"stardiv.one.form.component.GroupBox");
+	XMLFORM_CONSTASCII_STRING( SERVICE_PERSISTENT_COMPONENT_FIXEDTEXT,		"stardiv.one.form.component.FixedText");
+	XMLFORM_CONSTASCII_STRING( SERVICE_PERSISTENT_COMPONENT_COMMANDBUTTON,	"stardiv.one.form.component.CommandButton");
+	XMLFORM_CONSTASCII_STRING( SERVICE_PERSISTENT_COMPONENT_CHECKBOX,		"stardiv.one.form.component.CheckBox");
+	XMLFORM_CONSTASCII_STRING( SERVICE_PERSISTENT_COMPONENT_GRID,			"stardiv.one.form.component.Grid");
+	XMLFORM_CONSTASCII_STRING( SERVICE_PERSISTENT_COMPONENT_IMAGEBUTTON,	"stardiv.one.form.component.ImageButton");
+	XMLFORM_CONSTASCII_STRING( SERVICE_PERSISTENT_COMPONENT_FILECONTROL,	"stardiv.one.form.component.FileControl");
+	XMLFORM_CONSTASCII_STRING( SERVICE_PERSISTENT_COMPONENT_TIMEFIELD,		"stardiv.one.form.component.TimeField");
+	XMLFORM_CONSTASCII_STRING( SERVICE_PERSISTENT_COMPONENT_DATEFIELD,		"stardiv.one.form.component.DateField");
+	XMLFORM_CONSTASCII_STRING( SERVICE_PERSISTENT_COMPONENT_NUMERICFIELD,	"stardiv.one.form.component.NumericField");
+	XMLFORM_CONSTASCII_STRING( SERVICE_PERSISTENT_COMPONENT_CURRENCYFIELD,	"stardiv.one.form.component.CurrencyField");
+	XMLFORM_CONSTASCII_STRING( SERVICE_PERSISTENT_COMPONENT_PATTERNFIELD,	"stardiv.one.form.component.PatternField");
+	XMLFORM_CONSTASCII_STRING( SERVICE_PERSISTENT_COMPONENT_HIDDENCONTROL,	"stardiv.one.form.component.Hidden");
+	XMLFORM_CONSTASCII_STRING( SERVICE_PERSISTENT_COMPONENT_IMAGECONTROL,	"stardiv.one.form.component.ImageControl");
+	XMLFORM_CONSTASCII_STRING( SERVICE_PERSISTENT_COMPONENT_FORMATTEDFIELD,	"stardiv.one.form.component.FormattedField");
+
+	// new service names, the old ones are translated into this new ones
+	XMLFORM_CONSTASCII_STRING( SERVICE_FORM, 			"com.sun.star.form.component.Form");
+	XMLFORM_CONSTASCII_STRING( SERVICE_EDIT, 			"com.sun.star.form.component.TextField");
+	XMLFORM_CONSTASCII_STRING( SERVICE_LISTBOX, 		"com.sun.star.form.component.ListBox");
+	XMLFORM_CONSTASCII_STRING( SERVICE_COMBOBOX, 		"com.sun.star.form.component.ComboBox");
+	XMLFORM_CONSTASCII_STRING( SERVICE_RADIOBUTTON, 	"com.sun.star.form.component.RadioButton");
+	XMLFORM_CONSTASCII_STRING( SERVICE_GROUPBOX, 		"com.sun.star.form.component.GroupBox");
+	XMLFORM_CONSTASCII_STRING( SERVICE_FIXEDTEXT, 		"com.sun.star.form.component.FixedText");
+	XMLFORM_CONSTASCII_STRING( SERVICE_COMMANDBUTTON, 	"com.sun.star.form.component.CommandButton");
+	XMLFORM_CONSTASCII_STRING( SERVICE_CHECKBOX, 		"com.sun.star.form.component.CheckBox");
+	XMLFORM_CONSTASCII_STRING( SERVICE_GRID, 			"com.sun.star.form.component.GridControl");
+	XMLFORM_CONSTASCII_STRING( SERVICE_IMAGEBUTTON, 	"com.sun.star.form.component.ImageButton");
+	XMLFORM_CONSTASCII_STRING( SERVICE_FILECONTROL, 	"com.sun.star.form.component.FileControl");
+	XMLFORM_CONSTASCII_STRING( SERVICE_TIMEFIELD, 		"com.sun.star.form.component.TimeField");
+	XMLFORM_CONSTASCII_STRING( SERVICE_DATEFIELD, 		"com.sun.star.form.component.DateField");
+	XMLFORM_CONSTASCII_STRING( SERVICE_NUMERICFIELD, 	"com.sun.star.form.component.NumericField");
+	XMLFORM_CONSTASCII_STRING( SERVICE_CURRENCYFIELD, 	"com.sun.star.form.component.CurrencyField");
+	XMLFORM_CONSTASCII_STRING( SERVICE_PATTERNFIELD, 	"com.sun.star.form.component.PatternField");
+	XMLFORM_CONSTASCII_STRING( SERVICE_HIDDENCONTROL, 	"com.sun.star.form.component.HiddenControl");
+	XMLFORM_CONSTASCII_STRING( SERVICE_IMAGECONTROL, 	"com.sun.star.form.component.DatabaseImageControl");
+	XMLFORM_CONSTASCII_STRING( SERVICE_FORMATTEDFIELD,	"com.sun.star.form.component.FormattedField" );
+
+	// various strings
+	XMLFORM_CONSTASCII_STRING( EVENT_NAME_SEPARATOR, "::" );
+	XMLFORM_CONSTASCII_STRING( EVENT_TYPE, "EventType" );
+	XMLFORM_CONSTASCII_STRING( EVENT_LIBRARY, "Library" );
+	XMLFORM_CONSTASCII_STRING( EVENT_LOCALMACRONAME, "MacroName" );
+	XMLFORM_CONSTASCII_STRING( EVENT_SCRIPTURL, "Script" );
+	XMLFORM_CONSTASCII_STRING( EVENT_STAROFFICE, "StarOffice" );
+	XMLFORM_CONSTASCII_STRING( EVENT_STARBASIC, "StarBasic" );
+	XMLFORM_CONSTASCII_STRING( EVENT_APPLICATION, "application" );
+
+//.........................................................................
+}	// namespace xmloff
+//.........................................................................
+
+#endif // _XMLOFF_FORMS_STRINGS_HXX_
--- xmloff/source/forms/formattributes.hxx.orig	1970-01-01 08:00:00.000000000 +0800
+++ xmloff/source/forms/formattributes.hxx	2008-06-04 12:38:12.000000000 +0800
@@ -0,0 +1,365 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: formattributes.hxx,v $
+ * $Revision: 1.14 $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+
+#ifndef _XMLOFF_FORMATTRIBUTES_HXX_
+#define _XMLOFF_FORMATTRIBUTES_HXX_
+
+#include <com/sun/star/beans/XPropertySet.hpp>
+#include <sal/types.h>
+#include <vos/refernce.hxx>
+#include <comphelper/stl_types.hxx>
+
+class SvXMLExport;
+struct SvXMLEnumMapEntry;
+
+//.........................................................................
+namespace xmloff
+{
+//.........................................................................
+
+	// flags for common control attributes
+	#define CCA_NAME					0x00000001
+	#define CCA_SERVICE_NAME			0x00000002
+	#define CCA_BUTTON_TYPE				0x00000004
+	#define CCA_CONTROL_ID				0x00000008
+	#define CCA_CURRENT_SELECTED		0x00000010
+	#define CCA_CURRENT_VALUE			0x00000020
+	#define CCA_DISABLED				0x00000040
+	#define CCA_DROPDOWN				0x00000080
+	#define CCA_FOR						0x00000100
+	#define CCA_IMAGE_DATA				0x00000200
+	#define CCA_LABEL					0x00000400
+	#define CCA_MAX_LENGTH				0x00000800
+	#define CCA_PRINTABLE				0x00001000
+	#define CCA_READONLY				0x00002000
+	#define CCA_SELECTED				0x00004000
+	#define CCA_SIZE					0x00008000
+	#define CCA_TAB_INDEX				0x00010000
+	#define CCA_TARGET_FRAME			0x00020000
+	#define CCA_TARGET_LOCATION			0x00040000
+	#define CCA_TAB_STOP				0x00080000
+	#define CCA_TITLE					0x00100000
+	#define CCA_VALUE					0x00200000
+    #define CCA_ORIENTATION             0x00400000
+    #define CCA_VISUAL_EFFECT           0x00800000
+    #define CCA_ENABLEVISIBLE                 0x01000000
+
+	// flags for database control atttributes
+	#define DA_BOUND_COLUMN				0x00000001
+	#define DA_CONVERT_EMPTY			0x00000002
+	#define DA_DATA_FIELD				0x00000004
+	#define DA_LIST_SOURCE				0x00000008
+	#define DA_LIST_SOURCE_TYPE			0x00000010
+
+    // flags for binding related control attributes
+    #define BA_LINKED_CELL              0x00000001
+    #define BA_LIST_LINKING_TYPE        0x00000002
+    #define BA_LIST_CELL_RANGE          0x00000004
+    #define BA_XFORMS_BIND              0x00000008
+    #define BA_XFORMS_LISTBIND          0x00000010
+    #define BA_XFORMS_SUBMISSION        0x00000020
+
+	// flags for event attributes
+	#define EA_CONTROL_EVENTS			0x00000001
+	#define EA_ON_CHANGE				0x00000002
+	#define EA_ON_CLICK					0x00000004
+	#define EA_ON_DBLCLICK				0x00000008
+	#define EA_ON_SELECT				0x00000010
+
+	/// attributes in the xml tag representing a form
+	enum FormAttributes
+	{
+		faName,
+		faServiceName,
+		faAction,
+		faEnctype,
+		faMethod,
+		faTargetFrame,
+		faAllowDeletes,
+		faAllowInserts,
+		faAllowUpdates,
+		faApplyFilter,
+		faCommand,
+		faCommandType,
+		faEscapeProcessing,
+		faDatasource,
+		faConnectionResource,
+		faDetailFiels,
+		faFilter,
+		faIgnoreResult,
+		faMasterFields,
+		faNavigationMode,
+		faOrder,
+		faTabbingCycle
+	};
+
+	// any other attributes, which are special to some control types
+	#define SCA_ECHO_CHAR				0x00000001
+	#define SCA_MAX_VALUE				0x00000002
+	#define SCA_MIN_VALUE				0x00000004
+	#define SCA_VALIDATION				0x00000008
+	#define SCA_MULTI_LINE				0x00000020
+	#define SCA_AUTOMATIC_COMPLETION	0x00000080
+	#define SCA_MULTIPLE				0x00000100
+	#define SCA_DEFAULT_BUTTON			0x00000200
+	#define SCA_CURRENT_STATE			0x00000400
+	#define SCA_IS_TRISTATE				0x00000800
+	#define SCA_STATE					0x00001000
+	#define SCA_COLUMN_STYLE_NAME		0x00002000
+	#define SCA_STEP_SIZE               0x00004000
+	#define SCA_PAGE_STEP_SIZE          0x00008000
+	#define SCA_REPEAT_DELAY            0x00010000
+    #define SCA_TOGGLE                  0x00020000
+    #define SCA_FOCUS_ON_CLICK          0x00040000
+    #define SCA_IMAGE_POSITION          0x00080000
+
+	// attributes of the office:forms element
+	enum OfficeFormsAttributes
+	{
+		ofaAutomaticFocus,
+		ofaApplyDesignMode
+	};
+
+	//=====================================================================
+	//= OAttributeMetaData
+	//=====================================================================
+	/** allows the translation of attribute ids into strings.
+
+		<p>This class does not allow to connect xml attributes to property names or
+		something like that, it only deals with the xml side</p>
+	*/
+	class OAttributeMetaData
+	{
+	public:
+		/** calculates the xml attribute representation of a common control attribute.
+			@param _nId
+				the id of the attribute. Has to be one of the CCA_* constants.
+		*/
+		static const sal_Char* getCommonControlAttributeName(sal_Int32 _nId);
+
+		/** calculates the xml namespace key to use for a common control attribute
+			@param _nId
+				the id of the attribute. Has to be one of the CCA_* constants.
+		*/
+		static sal_uInt16 getCommonControlAttributeNamespace(sal_Int32 _nId);
+
+		/** retrieves the name of an attribute of a form xml representation
+			@param	_eAttrib
+				enum value specifying the attribute
+		*/
+		static const sal_Char* getFormAttributeName(FormAttributes _eAttrib);
+
+		/** calculates the xml namespace key to use for a attribute of a form xml representation
+			@param	_eAttrib
+				enum value specifying the attribute
+		*/
+		static sal_uInt16 getFormAttributeNamespace(FormAttributes _eAttrib);
+
+		/** calculates the xml attribute representation of a database attribute.
+			@param _nId
+				the id of the attribute. Has to be one of the DA_* constants.
+		*/
+		static const sal_Char* getDatabaseAttributeName(sal_Int32 _nId);
+
+		/** calculates the xml namespace key to use for a database attribute.
+			@param _nId
+				the id of the attribute. Has to be one of the DA_* constants.
+		*/
+		static sal_uInt16 getDatabaseAttributeNamespace(sal_Int32 _nId);
+
+		/** calculates the xml attribute representation of a special attribute.
+			@param _nId
+				the id of the attribute. Has to be one of the SCA_* constants.
+		*/
+		static const sal_Char* getSpecialAttributeName(sal_Int32 _nId);
+
+		/** calculates the xml attribute representation of a binding attribute.
+			@param _nId
+				the id of the attribute. Has to be one of the BA_* constants.
+		*/
+		static const sal_Char* getBindingAttributeName(sal_Int32 _nId);
+
+        /** calculates the xml namespace key to use for a binding attribute.
+			@param _nId
+				the id of the attribute. Has to be one of the BA_* constants.
+		*/
+		static sal_uInt16 getBindingAttributeNamespace(sal_Int32 _nId);
+
+        /** calculates the xml namespace key to use for a special attribute.
+			@param _nId
+				the id of the attribute. Has to be one of the SCA_* constants.
+		*/
+		static sal_uInt16 getSpecialAttributeNamespace(sal_Int32 _nId);
+
+		/** calculates the xml attribute representation of a attribute of the office:forms element
+			@param _nId
+				the id of the attribute
+		*/
+		static const sal_Char* getOfficeFormsAttributeName(OfficeFormsAttributes _eAttrib);
+
+		/** calculates the xml namedspace key of a attribute of the office:forms element
+			@param _nId
+				the id of the attribute
+		*/
+		static sal_uInt16 getOfficeFormsAttributeNamespace(OfficeFormsAttributes _eAttrib);
+	};
+
+	//=====================================================================
+	//= OAttribute2Property
+	//=====================================================================
+	/** some kind of opposite to the OAttributeMetaData class. Able to translate
+		attributes into property names/types
+
+		<p>The construction of this class is rather expensive (or at least it's initialization from outside),
+		so it should be shared</p>
+	*/
+	class OAttribute2Property
+	{
+	public:
+		// TODO: maybe the following struct should be used for exports, too. In this case we would not need to
+		// store it's instances in a map, but in a vector for faster access.
+		struct AttributeAssignment
+		{
+			::rtl::OUString					sAttributeName;			// the attribute name
+			::rtl::OUString					sPropertyName;			// the property name
+			::com::sun::star::uno::Type		aPropertyType;			// the property type
+			::rtl::OUString					sAttributeDefault;		// the default if the attribute is not present
+
+			// entries which are special to some value types
+			const SvXMLEnumMapEntry*		pEnumMap;				// the enum map, if appliable
+			sal_Bool						bInverseSemantics;		// for booleanss: attribute and property value have the same or an inverse semantics?
+
+			AttributeAssignment() : pEnumMap(NULL), bInverseSemantics(sal_False) { }
+		};
+
+	protected:
+		DECLARE_STL_USTRINGACCESS_MAP( AttributeAssignment, AttributeAssignments );
+		AttributeAssignments		m_aKnownProperties;
+
+	public:
+		OAttribute2Property();
+		virtual ~OAttribute2Property();
+
+		/** return the AttributeAssignment which corresponds to the given attribute
+
+			@param _rAttribName
+				the name of the attrribute
+			@return
+				a pointer to the <type>AttributeAssignment</type> structure as requested, NULL if the attribute
+				does not represent a property.
+		*/
+		const AttributeAssignment* getAttributeTranslation(
+			const ::rtl::OUString& _rAttribName);
+
+		/** add a attribute assignment referring to a string property to the map
+			@param _pAttributeName
+				the name of the attrribute
+			@param _rPropertyName
+				the name of the property assigned to the attribute
+			@param _pAttributeDefault
+				the default value for the attribute, if any. May be NULL, in this case the default is assumed to be
+				an empty string.
+		*/
+		void	addStringProperty(
+			const sal_Char* _pAttributeName, const ::rtl::OUString& _rPropertyName,
+			const sal_Char* _pAttributeDefault = NULL);
+
+		/** add a attribute assignment referring to a boolean property to the map
+
+			@param _pAttributeName
+				the name of the attrribute
+			@param _rPropertyName
+				the name of the property assigned to the attribute
+			@param _bAttributeDefault
+				the default value for the attribute.
+			@param _bInverseSemantics
+				if <TRUE/>, a attribute value of <TRUE/> means a property value of <FALSE/> and vice verse.<br/>
+				if <FALSE/>, the attribute value is used as property value directly
+		*/
+		void	addBooleanProperty(
+			const sal_Char* _pAttributeName, const ::rtl::OUString& _rPropertyName,
+			const sal_Bool _bAttributeDefault, const sal_Bool _bInverseSemantics = sal_False);
+
+		/** add a attribute assignment referring to an int16 property to the map
+
+			@param _pAttributeName
+				the name of the attrribute
+			@param _rPropertyName
+				the name of the property assigned to the attribute
+			@param _nAttributeDefault
+				the default value for the attribute.
+		*/
+		void	addInt16Property(
+			const sal_Char* _pAttributeName, const ::rtl::OUString& _rPropertyName,
+			const sal_Int16 _nAttributeDefault);
+
+		/** add a attribute assignment referring to an int32 property to the map
+
+			@param _pAttributeName
+				the name of the attrribute
+			@param _rPropertyName
+				the name of the property assigned to the attribute
+			@param _nAttributeDefault
+				the default value for the attribute.
+		*/
+		void	addInt32Property(
+			const sal_Char* _pAttributeName, const ::rtl::OUString& _rPropertyName,
+			const sal_Int32 _nAttributeDefault );
+
+		/** add a attribute assignment referring to an enum property to the map
+
+			@param _pAttributeName
+				the name of the attrribute
+			@param _rPropertyName
+				the name of the property assigned to the attribute
+			@param _nAttributeDefault
+				the default value for the attribute, as (32bit) integer
+			@param _pValueMap
+				the map to translate strings into enum values
+			@param _pType
+				the type of the property. May be NULL, in this case 32bit integer is assumed.
+		*/
+		void	addEnumProperty(
+			const sal_Char* _pAttributeName, const ::rtl::OUString& _rPropertyName,
+			const sal_uInt16 _nAttributeDefault, const SvXMLEnumMapEntry* _pValueMap,
+			const ::com::sun::star::uno::Type* _pType = NULL);
+
+	protected:
+		/// some common code for the various add*Property methods
+		AttributeAssignment& implAdd(
+			const sal_Char* _pAttributeName, const ::rtl::OUString& _rPropertyName,
+			const ::com::sun::star::uno::Type& _rType, const ::rtl::OUString& _rDefaultString);
+	};
+//.........................................................................
+}	// namespace xmloff
+//.........................................................................
+
+#endif // _XMLOFF_FORMATTRIBUTES_HXX_
+
--- xmloff/source/forms/formattributes.cxx.orig	1970-01-01 08:00:00.000000000 +0800
+++ xmloff/source/forms/formattributes.cxx	2008-06-04 12:38:12.000000000 +0800
@@ -0,0 +1,343 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: formattributes.cxx,v $
+ * $Revision: 1.21 $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+
+// MARKER(update_precomp.py): autogen include statement, do not remove
+#include "precompiled_xmloff.hxx"
+#include "formattributes.hxx"
+#include "xmlnmspe.hxx"
+#include <xmloff/xmluconv.hxx>
+#include <rtl/ustrbuf.hxx>
+
+//.........................................................................
+namespace xmloff
+{
+//.........................................................................
+
+	using namespace ::com::sun::star::uno;
+	using namespace ::com::sun::star::lang;
+	using namespace ::com::sun::star::beans;
+
+
+	//=====================================================================
+	//= OAttributeMetaData
+	//=====================================================================
+	//---------------------------------------------------------------------
+	const sal_Char* OAttributeMetaData::getCommonControlAttributeName(sal_Int32 _nId)
+	{
+		switch (_nId)
+		{
+			case CCA_NAME: 				return "name";
+			case CCA_SERVICE_NAME: 		return "control-implementation";
+			case CCA_BUTTON_TYPE: 		return "button-type";
+			case CCA_CONTROL_ID: 		return "id";
+			case CCA_CURRENT_SELECTED: 	return "current-selected";
+			case CCA_CURRENT_VALUE: 	return "current-value";
+			case CCA_DISABLED: 			return "disabled";
+			case CCA_ENABLEVISIBLE: 	return "enablevisible";
+			case CCA_DROPDOWN: 			return "dropdown";
+			case CCA_FOR: 				return "for";
+			case CCA_IMAGE_DATA: 		return "image-data";
+			case CCA_LABEL: 			return "label";
+			case CCA_MAX_LENGTH: 		return "max-length";
+			case CCA_PRINTABLE: 		return "printable";
+			case CCA_READONLY: 			return "readonly";
+			case CCA_SELECTED: 			return "selected";
+			case CCA_SIZE: 				return "size";
+			case CCA_TAB_INDEX: 		return "tab-index";
+			case CCA_TARGET_FRAME: 		return "target-frame";
+			case CCA_TARGET_LOCATION: 	return "href";		// the only special thing here: TargetLocation is represented by an xlink:href attribute
+			case CCA_TAB_STOP: 			return "tab-stop";
+			case CCA_TITLE: 			return "title";
+			case CCA_VALUE: 			return "value";
+            case CCA_ORIENTATION:       return "orientation";
+            case CCA_VISUAL_EFFECT:     return "visual-effect";
+			default:
+				OSL_ENSURE(sal_False, "OAttributeMetaData::getCommonControlAttributeName: invalid id (maybe you or-ed two flags?)!");
+		}
+		return "";
+	}
+
+	//---------------------------------------------------------------------
+	sal_uInt16 OAttributeMetaData::getCommonControlAttributeNamespace(sal_Int32 _nId)
+	{
+		if (CCA_TARGET_LOCATION == _nId)
+			return XML_NAMESPACE_XLINK;
+
+		if (CCA_TARGET_FRAME == _nId)
+			return XML_NAMESPACE_OFFICE;
+
+		return XML_NAMESPACE_FORM;
+	}
+
+	//---------------------------------------------------------------------
+	const sal_Char* OAttributeMetaData::getFormAttributeName(FormAttributes _eAttrib)
+	{
+		switch (_eAttrib)
+		{
+			case faName: 				return "name";
+			case faServiceName: 		return "service-name";
+			case faAction: 				return "href";		// the only special thing here: Action is represented by an xlink:href attribute
+			case faEnctype: 			return "enctype";
+			case faMethod: 				return "method";
+			case faTargetFrame: 		return "target-frame";
+			case faAllowDeletes:		return "allow-deletes";
+			case faAllowInserts:		return "allow-inserts";
+			case faAllowUpdates:		return "allow-updates";
+			case faApplyFilter: 		return "apply-filter";
+			case faCommand: 			return "command";
+			case faCommandType: 		return "command-type";
+			case faEscapeProcessing:	return "escape-processing";
+			case faDatasource: 			return "datasource";
+			case faConnectionResource: 	return "connection-resource";
+			case faDetailFiels: 		return "detail-fields";
+			case faFilter: 				return "filter";
+			case faIgnoreResult: 		return "ignore-result";
+			case faMasterFields: 		return "master-fields";
+			case faNavigationMode:		return "navigation-mode";
+			case faOrder: 				return "order";
+			case faTabbingCycle: 		return "tab-cycle";
+			default:
+				OSL_ENSURE(sal_False, "OAttributeMetaData::getFormAttributeName: invalid id!");
+		}
+		return "";
+	}
+
+	//---------------------------------------------------------------------
+	sal_uInt16 OAttributeMetaData::getFormAttributeNamespace(FormAttributes _eAttrib)
+	{
+		if (faAction == _eAttrib)
+			return XML_NAMESPACE_XLINK;
+
+		if (faTargetFrame == _eAttrib)
+			return XML_NAMESPACE_OFFICE;
+
+		return XML_NAMESPACE_FORM;
+	}
+
+	//---------------------------------------------------------------------
+	const sal_Char* OAttributeMetaData::getDatabaseAttributeName(sal_Int32 _nId)
+	{
+		switch (_nId)
+		{
+			case DA_BOUND_COLUMN:		return "bound-column";
+			case DA_CONVERT_EMPTY:		return "convert-empty-to-null";
+			case DA_DATA_FIELD:			return "data-field";
+			case DA_LIST_SOURCE:		return "list-source";
+			case DA_LIST_SOURCE_TYPE:	return "list-source-type";
+			default:
+				OSL_ENSURE(sal_False, "OAttributeMetaData::getDatabaseAttributeName: invalid id (maybe you or-ed two flags?)!");
+		}
+		return "";
+	}
+
+	//---------------------------------------------------------------------
+	sal_uInt16 OAttributeMetaData::getDatabaseAttributeNamespace(sal_Int32 /*_nId*/)
+	{
+		// nothing special here
+		return XML_NAMESPACE_FORM;
+	}
+
+	//---------------------------------------------------------------------
+    const sal_Char* OAttributeMetaData::getBindingAttributeName(sal_Int32 _nId)
+    {
+		switch (_nId)
+		{
+			case BA_LINKED_CELL:       return "linked-cell";
+            case BA_LIST_LINKING_TYPE: return "list-linkage-type";
+			case BA_LIST_CELL_RANGE:   return "source-cell-range";
+			default:
+				OSL_ENSURE(sal_False, "OAttributeMetaData::getBindingAttributeName: invalid id (maybe you or-ed two flags?)!");
+		}
+		return "";
+    }
+
+	//---------------------------------------------------------------------
+	sal_uInt16 OAttributeMetaData::getBindingAttributeNamespace(sal_Int32)
+    {
+		// nothing special here
+		return XML_NAMESPACE_FORM;
+    }
+
+	//---------------------------------------------------------------------
+	const sal_Char* OAttributeMetaData::getSpecialAttributeName(sal_Int32 _nId)
+	{
+		switch (_nId)
+		{
+			case SCA_ECHO_CHAR: 			return "echo-char";
+			case SCA_MAX_VALUE:				return "max-value";
+			case SCA_MIN_VALUE:				return "min-value";
+			case SCA_VALIDATION:			return "validation";
+			case SCA_MULTI_LINE:			return "multi-line";
+			case SCA_AUTOMATIC_COMPLETION:	return "auto-complete";
+			case SCA_MULTIPLE: 				return "multiple";
+			case SCA_DEFAULT_BUTTON: 		return "default-button";
+			case SCA_CURRENT_STATE: 		return "current-state";
+			case SCA_IS_TRISTATE: 			return "is-tristate";
+			case SCA_STATE: 				return "state";
+			case SCA_COLUMN_STYLE_NAME:		return "text-style-name";
+			case SCA_STEP_SIZE:		        return "step-size";
+			case SCA_PAGE_STEP_SIZE:		return "page-step-size";
+			case SCA_REPEAT_DELAY:		    return "delay-for-repeat";
+            case SCA_TOGGLE:                return "toggle";
+            case SCA_FOCUS_ON_CLICK:        return "focus-on-click";
+			default:
+				OSL_ENSURE(sal_False, "OAttributeMetaData::getSpecialAttributeName: invalid id (maybe you or-ed two flags?)!");
+		}
+		return "";
+	}
+
+	//---------------------------------------------------------------------
+	sal_uInt16 OAttributeMetaData::getSpecialAttributeNamespace(sal_Int32 /*_nId*/)
+	{
+		// nothing special here
+		return XML_NAMESPACE_FORM;
+	}
+
+	//---------------------------------------------------------------------
+	const sal_Char* OAttributeMetaData::getOfficeFormsAttributeName(OfficeFormsAttributes _eAttrib)
+	{
+		switch (_eAttrib)
+		{
+			case ofaAutomaticFocus:		return "automatic-focus";
+			case ofaApplyDesignMode:	return "apply-design-mode";
+			default:
+				OSL_ENSURE(sal_False, "OAttributeMetaData::getOfficeFormsAttributeName: invalid id!");
+		}
+		return "";
+	}
+
+	//---------------------------------------------------------------------
+	sal_uInt16 OAttributeMetaData::getOfficeFormsAttributeNamespace(OfficeFormsAttributes /* _eAttrib */)
+	{
+		// nothing special here
+		return XML_NAMESPACE_FORM;
+	}
+
+	//=====================================================================
+	//= OAttribute2Property
+	//=====================================================================
+	//---------------------------------------------------------------------
+	OAttribute2Property::OAttribute2Property()
+	{
+	}
+
+	//---------------------------------------------------------------------
+	OAttribute2Property::~OAttribute2Property()
+	{
+	}
+
+	//---------------------------------------------------------------------
+	const OAttribute2Property::AttributeAssignment* OAttribute2Property::getAttributeTranslation(
+			const ::rtl::OUString& _rAttribName)
+	{
+		ConstAttributeAssignmentsIterator aPos = m_aKnownProperties.find(_rAttribName);
+		if (m_aKnownProperties.end() != aPos)
+			return &aPos->second;
+		return NULL;
+	}
+
+	//---------------------------------------------------------------------
+	void OAttribute2Property::addStringProperty(
+		const sal_Char* _pAttributeName, const ::rtl::OUString& _rPropertyName,
+		const sal_Char* _pAttributeDefault)
+	{
+		implAdd(_pAttributeName, _rPropertyName, ::getCppuType( static_cast< ::rtl::OUString* >(NULL) ),
+			_pAttributeDefault ? ::rtl::OUString::createFromAscii(_pAttributeDefault) : ::rtl::OUString());
+	}
+
+	//---------------------------------------------------------------------
+	void OAttribute2Property::addBooleanProperty(
+		const sal_Char* _pAttributeName, const ::rtl::OUString& _rPropertyName,
+		const sal_Bool _bAttributeDefault, const sal_Bool _bInverseSemantics)
+	{
+		::rtl::OUStringBuffer aDefault;
+		SvXMLUnitConverter::convertBool(aDefault, _bAttributeDefault);
+		AttributeAssignment& aAssignment = implAdd(_pAttributeName, _rPropertyName, ::getBooleanCppuType(), aDefault.makeStringAndClear());
+		aAssignment.bInverseSemantics = _bInverseSemantics;
+	}
+
+	//---------------------------------------------------------------------
+	void OAttribute2Property::addInt16Property(
+		const sal_Char* _pAttributeName, const ::rtl::OUString& _rPropertyName,
+		const sal_Int16 _nAttributeDefault)
+	{
+		::rtl::OUStringBuffer aDefault;
+		SvXMLUnitConverter::convertNumber(aDefault, (sal_Int32)_nAttributeDefault);
+		implAdd(_pAttributeName, _rPropertyName, ::getCppuType( static_cast< sal_Int16* >(NULL) ), aDefault.makeStringAndClear());
+	}
+
+	//---------------------------------------------------------------------
+	void OAttribute2Property::addInt32Property(
+		const sal_Char* _pAttributeName, const ::rtl::OUString& _rPropertyName,
+		const sal_Int32 _nAttributeDefault)
+	{
+		::rtl::OUStringBuffer aDefault;
+		SvXMLUnitConverter::convertNumber( aDefault, _nAttributeDefault );
+		implAdd( _pAttributeName, _rPropertyName, ::getCppuType( static_cast< sal_Int32* >(NULL) ), aDefault.makeStringAndClear() );
+	}
+
+	//---------------------------------------------------------------------
+	void OAttribute2Property::addEnumProperty(
+			const sal_Char* _pAttributeName, const ::rtl::OUString& _rPropertyName,
+			const sal_uInt16 _nAttributeDefault, const SvXMLEnumMapEntry* _pValueMap,
+			const ::com::sun::star::uno::Type* _pType)
+	{
+		::rtl::OUStringBuffer aDefault;
+		SvXMLUnitConverter::convertEnum(aDefault, _nAttributeDefault, _pValueMap);
+		AttributeAssignment& aAssignment = implAdd(_pAttributeName, _rPropertyName,
+			_pType ? *_pType : ::getCppuType( static_cast< sal_Int32* >(NULL) ),
+				// this assumes that the setPropertyValue for enums can handle int32's ....
+			aDefault.makeStringAndClear());
+		aAssignment.pEnumMap = _pValueMap;
+	}
+
+	//---------------------------------------------------------------------
+	OAttribute2Property::AttributeAssignment& OAttribute2Property::implAdd(
+			const sal_Char* _pAttributeName, const ::rtl::OUString& _rPropertyName,
+			const ::com::sun::star::uno::Type& _rType, const ::rtl::OUString& /*_rDefaultString*/)
+	{
+		OSL_ENSURE(m_aKnownProperties.end() == m_aKnownProperties.find(::rtl::OUString::createFromAscii(_pAttributeName)),
+			"OAttribute2Property::implAdd: already have this attribute!");
+
+		::rtl::OUString sAttributeName = ::rtl::OUString::createFromAscii(_pAttributeName);
+
+		AttributeAssignment aAssignment;
+		aAssignment.sAttributeName = sAttributeName;
+		aAssignment.sPropertyName = _rPropertyName;
+		aAssignment.aPropertyType = _rType;
+
+		// redundance, the accessor is stored in aAssignment.sAttributeName, too
+		return m_aKnownProperties[sAttributeName] = aAssignment;
+	}
+
+//.........................................................................
+}	// namespace xmloff
+//.........................................................................
+
--- xmloff/source/forms/elementexport.cxx.orig	1970-01-01 08:00:00.000000000 +0800
+++ xmloff/source/forms/elementexport.cxx	2008-06-04 12:38:12.000000000 +0800
@@ -0,0 +1,2155 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: elementexport.cxx,v $
+ * $Revision: 1.48 $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+
+// MARKER(update_precomp.py): autogen include statement, do not remove
+#include "precompiled_xmloff.hxx"
+
+#include <stdio.h>
+#include "elementexport.hxx"
+#include "strings.hxx"
+#include <xmloff/xmlexp.hxx>
+#include <xmloff/nmspmap.hxx>
+#include "xmlnmspe.hxx"
+#include <xmloff/xmluconv.hxx>
+#include <xmloff/xmltoken.hxx>
+#include <tools/time.hxx>
+#include <tools/diagnose_ex.h>
+#include <comphelper/extract.hxx>
+#include "eventexport.hxx"
+#include "formenums.hxx"
+#include <vcl/wintypes.hxx>		// for check states
+#include <xmloff/XMLEventExport.hxx>
+#include "formcellbinding.hxx"
+
+#include <algorithm>
+
+/** === begin UNO includes === **/
+#include <com/sun/star/text/XText.hpp>
+#include <com/sun/star/lang/XServiceInfo.hpp>
+#include <com/sun/star/io/XPersistObject.hpp>
+#include <com/sun/star/form/FormComponentType.hpp>
+#include <com/sun/star/beans/PropertyAttribute.hpp>
+#include <com/sun/star/form/FormSubmitEncoding.hpp>
+#include <com/sun/star/form/FormSubmitMethod.hpp>
+#include <com/sun/star/sdb/CommandType.hpp>
+#include <com/sun/star/form/NavigationBarMode.hpp>
+#include <com/sun/star/form/TabulatorCycle.hpp>
+#include <com/sun/star/form/FormButtonType.hpp>
+#include <com/sun/star/awt/ScrollBarOrientation.hpp>
+#include <com/sun/star/awt/VisualEffect.hpp>
+#include <com/sun/star/form/ListSourceType.hpp>
+#include <com/sun/star/awt/ImagePosition.hpp>
+/** === end UNO includes === **/
+#include <vcl/wintypes.hxx>		// for check states
+#include <xmloff/txtprmap.hxx>
+#include "formcellbinding.hxx"
+#include "xformsexport.hxx"
+#include <com/sun/star/form/binding/XBindableValue.hpp>
+#include <com/sun/star/form/binding/XListEntrySink.hpp>
+#include <tools/urlobj.hxx>
+#include <algorithm>
+
+
+//.........................................................................
+namespace xmloff
+{
+//.........................................................................
+
+    using namespace ::xmloff::token;
+	using namespace ::com::sun::star::uno;
+	using namespace ::com::sun::star::sdb;
+	using namespace ::com::sun::star::awt;
+	using namespace ::com::sun::star::form;
+	using namespace ::com::sun::star::lang;
+	using namespace ::com::sun::star::lang;
+	using namespace ::com::sun::star::beans;
+	using namespace ::com::sun::star::container;
+	using namespace ::com::sun::star::script;
+	using namespace ::com::sun::star::io;
+	using namespace ::com::sun::star::table;
+	using namespace ::com::sun::star::text;
+    using namespace ::com::sun::star::form::binding;
+
+	//=====================================================================
+	//= OElementExport
+	//=====================================================================
+	OElementExport::OElementExport(IFormsExportContext& _rContext, const Reference< XPropertySet >& _rxProps,
+		const Sequence< ScriptEventDescriptor >& _rEvents)
+		:OPropertyExport(_rContext, _rxProps)
+		,m_aEvents(_rEvents)
+		,m_pXMLElement(NULL)
+	{
+	}
+
+	//---------------------------------------------------------------------
+	OElementExport::~OElementExport()
+	{
+		implEndElement();
+	}
+
+	//---------------------------------------------------------------------
+	void OElementExport::doExport()
+	{
+		// collect some general information about the element
+		examine();
+
+		// first add the attributes necessary for the element
+		m_rContext.getGlobalContext().ClearAttrList();
+
+		// add the attributes
+		exportAttributes();
+
+		// start the XML element
+		implStartElement(getXMLElementName());
+
+		// the sub elements (mostly control type dependent)
+		exportSubTags();
+
+		implEndElement();
+	}
+
+	//---------------------------------------------------------------------
+	void OElementExport::examine()
+	{
+		// nothing to do here
+	}
+
+	//---------------------------------------------------------------------
+	void OElementExport::exportAttributes()
+	{
+		// nothing to do here
+	}
+
+	//---------------------------------------------------------------------
+	void OElementExport::exportSubTags()
+	{
+		// the properties which where not exported 'til now
+		exportRemainingProperties();
+
+		// the script:events sub tags
+		exportEvents();
+	}
+
+	//---------------------------------------------------------------------
+	void OElementExport::implStartElement(const sal_Char* _pName)
+	{
+		m_pXMLElement = new SvXMLElementExport(m_rContext.getGlobalContext(), XML_NAMESPACE_FORM, _pName, sal_True, sal_True);
+	}
+
+	//---------------------------------------------------------------------
+	void OElementExport::implEndElement()
+	{
+		delete m_pXMLElement;
+		m_pXMLElement = NULL;
+	}
+
+	//---------------------------------------------------------------------
+	void OElementExport::exportServiceNameAttribute()
+	{
+		Reference< XPersistObject > xPersistence(m_xProps, UNO_QUERY);
+		if (!xPersistence.is())
+		{
+			OSL_ENSURE(sal_False, "OElementExport::exportServiceNameAttribute: no XPersistObject!");
+			return;
+		}
+
+		::rtl::OUString sServiceName = xPersistence->getServiceName();
+		// we don't want to write the old service name directly: it's a name used for compatibility reasons, but
+		// as we start some kind of new file format here (with this xml export), we don't care about
+		// compatibility ...
+		// So we translate the old persistence service name into new ones, if possible
+
+		::rtl::OUString sToWriteServiceName = sServiceName;
+#define CHECK_N_TRANSLATE( name )	\
+		else if (0 == sServiceName.compareToAscii(SERVICE_PERSISTENT_COMPONENT_##name))	\
+			sToWriteServiceName = SERVICE_##name
+
+		if (sal_False)
+			;
+		CHECK_N_TRANSLATE( FORM );
+		CHECK_N_TRANSLATE( FORM );
+		CHECK_N_TRANSLATE( LISTBOX );
+		CHECK_N_TRANSLATE( COMBOBOX );
+		CHECK_N_TRANSLATE( RADIOBUTTON );
+		CHECK_N_TRANSLATE( GROUPBOX );
+		CHECK_N_TRANSLATE( FIXEDTEXT );
+		CHECK_N_TRANSLATE( COMMANDBUTTON );
+		CHECK_N_TRANSLATE( CHECKBOX );
+		CHECK_N_TRANSLATE( GRID );
+		CHECK_N_TRANSLATE( IMAGEBUTTON );
+		CHECK_N_TRANSLATE( FILECONTROL );
+		CHECK_N_TRANSLATE( TIMEFIELD );
+		CHECK_N_TRANSLATE( DATEFIELD );
+		CHECK_N_TRANSLATE( NUMERICFIELD );
+		CHECK_N_TRANSLATE( CURRENCYFIELD );
+		CHECK_N_TRANSLATE( PATTERNFIELD );
+		CHECK_N_TRANSLATE( HIDDENCONTROL );
+		CHECK_N_TRANSLATE( IMAGECONTROL );
+		CHECK_N_TRANSLATE( FORMATTEDFIELD );
+		else if (0 == sServiceName.compareToAscii(SERVICE_PERSISTENT_COMPONENT_EDIT))
+		{	// special handling for the edit field: we have two controls using this as persistence service name
+			sToWriteServiceName = SERVICE_EDIT;
+			Reference< XServiceInfo > xSI(m_xProps, UNO_QUERY);
+			if (xSI.is() && xSI->supportsService(SERVICE_FORMATTEDFIELD))
+				sToWriteServiceName = SERVICE_FORMATTEDFIELD;
+		}
+#if OSL_DEBUG_LEVEL > 0
+		Reference< XServiceInfo > xSI(m_xProps, UNO_QUERY);
+		OSL_ENSURE(xSI.is() && xSI->supportsService(sToWriteServiceName),
+			"OElementExport::exportServiceNameAttribute: wrong service name translation!");
+
+#endif
+		sToWriteServiceName =
+			m_rContext.getGlobalContext().GetNamespaceMap().GetQNameByKey(
+				XML_NAMESPACE_OOO, sToWriteServiceName );
+
+		// now write this
+		AddAttribute(
+			OAttributeMetaData::getCommonControlAttributeNamespace(CCA_SERVICE_NAME),
+			OAttributeMetaData::getCommonControlAttributeName(CCA_SERVICE_NAME),
+			sToWriteServiceName);
+	}
+
+	//---------------------------------------------------------------------
+	void OElementExport::exportEvents()
+	{
+		if (!m_aEvents.getLength())
+			// nothing to do
+			return;
+
+		Reference< XNameReplace > xWrapper = new OEventDescriptorMapper(m_aEvents);
+		m_rContext.getGlobalContext().GetEventExport().Export(xWrapper);
+	}
+
+	//=====================================================================
+	//= OControlExport
+	//=====================================================================
+	//---------------------------------------------------------------------
+	OControlExport::OControlExport(IFormsExportContext& _rContext,  const Reference< XPropertySet >& _rxControl,
+		const ::rtl::OUString& _rControlId, const ::rtl::OUString& _rReferringControls,
+		const Sequence< ScriptEventDescriptor >& _rEvents)
+		:OElementExport(_rContext, _rxControl, _rEvents)
+		,m_sControlId(_rControlId)
+		,m_sReferringControls(_rReferringControls)
+        ,m_nClassId(FormComponentType::CONTROL)
+        ,m_eType( UNKNOWN )
+		,m_nIncludeCommon(0)
+		,m_nIncludeDatabase(0)
+		,m_nIncludeSpecial(0)
+		,m_nIncludeEvents(0)
+        ,m_nIncludeBindings(0)
+		,m_pOuterElement(NULL)
+	{
+		OSL_ENSURE(m_xProps.is(), "OControlExport::OControlExport: invalid arguments!");
+	}
+
+	//---------------------------------------------------------------------
+	OControlExport::~OControlExport()
+	{
+		implEndElement();
+	}
+
+	//---------------------------------------------------------------------
+	void OControlExport::exportOuterAttributes()
+	{
+		// the control id
+		if (CCA_NAME & m_nIncludeCommon)
+		{
+			exportStringPropertyAttribute(
+				OAttributeMetaData::getCommonControlAttributeNamespace(CCA_NAME),
+				OAttributeMetaData::getCommonControlAttributeName(CCA_NAME),
+				PROPERTY_NAME
+				);
+        #if OSL_DEBUG_LEVEL > 0
+			//  reset the bit for later checking
+			m_nIncludeCommon = m_nIncludeCommon & ~CCA_NAME;
+		#endif
+		}
+
+		// the service name
+		if (m_nIncludeCommon & CCA_SERVICE_NAME)
+		{
+			exportServiceNameAttribute();
+		#if OSL_DEBUG_LEVEL > 0
+			//  reset the bit for later checking
+			m_nIncludeCommon = m_nIncludeCommon & ~CCA_SERVICE_NAME;
+		#endif
+		}
+	}
+
+	//---------------------------------------------------------------------
+	void OControlExport::exportInnerAttributes()
+	{
+		// the control id
+		if (CCA_CONTROL_ID & m_nIncludeCommon)
+		{
+			OSL_ENSURE(m_sControlId.getLength(), "OControlExport::exportOuterAttributes: have no control id for the control!");
+			AddAttribute(
+				OAttributeMetaData::getCommonControlAttributeNamespace(CCA_CONTROL_ID),
+				OAttributeMetaData::getCommonControlAttributeName(CCA_CONTROL_ID),
+				m_sControlId);
+		#if OSL_DEBUG_LEVEL > 0
+			//  reset the bit for later checking
+			m_nIncludeCommon = m_nIncludeCommon & ~CCA_CONTROL_ID;
+		#endif
+		}
+
+        // common control attributes
+		exportCommonControlAttributes();
+
+		// common database attributes
+		exportDatabaseAttributes();
+
+        // attributes related to external bindings
+        exportBindingAtributes();
+
+		// attributes special to the respective control type
+		exportSpecialAttributes();
+
+		// add the style references to the attributes
+		flagStyleProperties();
+	}
+
+	//---------------------------------------------------------------------
+	void OControlExport::exportAttributes()
+	{
+		exportOuterAttributes();
+	}
+
+	//---------------------------------------------------------------------
+	void OControlExport::exportSubTags() throw (Exception)
+	{
+		// for the upcoming exportRemainingProperties:
+		// if a control has the LabelControl property, this is not stored with the control itself, but instead with
+		// the control which is referenced by this property. As the base class' exportRemainingProperties doesn't
+		// know anything about this, we need to prevent that it tries to export this property
+		exportedProperty(PROPERTY_CONTROLLABEL);
+
+        // if it's a control supporting XText, then we need to declare all text-related properties
+        // as "already exported". This prevents them from being exported as generic "form:property"-tags.
+        // *If* we would export them this way, they would be completely superfluous, and sometimes even
+        // disastrous, since they may, at import time, override paragraph properties which already have
+        // been set before
+        Reference< XText > xControlText( m_xProps, UNO_QUERY );
+        if ( xControlText.is() )
+        {
+            const XMLPropertyMapEntry* pCharAttributeProperties = XMLTextPropertySetMapper::getPropertyMapForType( TEXT_PROP_MAP_TEXT );
+            while ( pCharAttributeProperties->msApiName )
+            {
+                exportedProperty( ::rtl::OUString::createFromAscii( pCharAttributeProperties->msApiName ) );
+                ++pCharAttributeProperties;
+            }
+
+            const XMLPropertyMapEntry* pParaAttributeProperties = XMLTextPropertySetMapper::getPropertyMapForType( TEXT_PROP_MAP_SHAPE_PARA );
+            while ( pParaAttributeProperties->msApiName )
+            {
+                exportedProperty( ::rtl::OUString::createFromAscii( pParaAttributeProperties->msApiName ) );
+                ++pParaAttributeProperties;
+            }
+
+            // the RichText property is not exported. The presence of the text:p element
+            // will be used - upon reading - as indicator for the value of the RichText property
+            exportedProperty( PROPERTY_RICH_TEXT );
+
+            // strange thing: paragraphs support both a CharStrikeout and a CharCrossedOut property
+            // The former is a short/enum value, the latter a boolean. The former has a real meaning
+            // (the strikeout type), the latter hasn't. But, when the CharCrossedOut is exported and
+            // later on imported, it overwrites anything which has previously been imported for
+            // CharStrikeout.
+            // 2004-04-14 - #i27729# - fs@openoffice.org
+            exportedProperty( ::rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "CharCrossedOut" ) ) );
+        }
+
+        if ( m_eType == LISTBOX )
+        {
+            // will be exported in exportListSourceAsElements:
+            if ( controlHasUserSuppliedListEntries() )
+                exportedProperty( PROPERTY_DEFAULT_SELECT_SEQ );
+
+            // will not be exported in a generic way. Either exportListSourceAsElements cares
+            // for them, or we don't need them
+            exportedProperty( PROPERTY_STRING_ITEM_LIST );
+            exportedProperty( PROPERTY_VALUE_SEQ );
+            exportedProperty( PROPERTY_SELECT_SEQ );
+            exportedProperty( PROPERTY_LISTSOURCE );
+        }
+        if ( m_eType == COMBOBOX )
+            exportedProperty( PROPERTY_STRING_ITEM_LIST );
+
+		// let the base class export the remaining properties and the events
+		OElementExport::exportSubTags();
+
+		// special sub tags for some controls
+		switch (m_eType)
+		{
+			case LISTBOX:
+                // don't export the list entries if the are not provided by the user, but obtained implicitly
+                // from other sources
+                // #i26944# - 2004-05-17 - fs@openoffice.org
+                if ( controlHasUserSuppliedListEntries() )
+				    exportListSourceAsElements();
+				break;
+			case GRID:
+			{	// a grid control requires us to store all columns as sub elements
+				Reference< XIndexAccess > xColumnContainer(m_xProps, UNO_QUERY);
+				OSL_ENSURE(xColumnContainer.is(), "OControlExport::exportSubTags: a grid control which is no IndexAccess?!!");
+				if (xColumnContainer.is())
+					m_rContext.exportCollectionElements(xColumnContainer);
+			}
+			break;
+			case COMBOBOX:
+			{	// a combox box description has sub elements: the items
+				DBG_CHECK_PROPERTY( PROPERTY_STRING_ITEM_LIST, Sequence< ::rtl::OUString > );
+
+                // don't export the list entries if the are not provided by the user, but obtained implicitly
+                // from other sources
+                // #i26944# - 2004-05-17 - fs@openoffice.org
+                if ( controlHasUserSuppliedListEntries() )
+                {
+				    // get the item list
+				    Sequence< ::rtl::OUString > aListItems;
+				    m_xProps->getPropertyValue(PROPERTY_STRING_ITEM_LIST) >>= aListItems;
+				    // loop through it and write the sub elements
+				    const ::rtl::OUString* pListItems = aListItems.getConstArray();
+				    for (sal_Int32 i=0; i<aListItems.getLength(); ++i, ++pListItems)
+				    {
+					    m_rContext.getGlobalContext().ClearAttrList();
+					    AddAttribute(
+						    OAttributeMetaData::getCommonControlAttributeNamespace(CCA_LABEL),
+						    OAttributeMetaData::getCommonControlAttributeName(CCA_LABEL),
+						    *pListItems);
+					    SvXMLElementExport aFormElement(m_rContext.getGlobalContext(), XML_NAMESPACE_FORM, "item", sal_True, sal_True);
+				    }
+                }
+			}
+			break;
+
+            case TEXT_AREA:
+            {
+                // if we act as rich text control, we need to export some text:p elements
+                if ( xControlText.is() )
+                {
+                    sal_Bool bActingAsRichText = sal_False;
+        			if ( m_xPropertyInfo->hasPropertyByName( PROPERTY_RICH_TEXT ) )
+                    {
+                        OSL_VERIFY(m_xProps->getPropertyValue( PROPERTY_RICH_TEXT ) >>= bActingAsRichText );
+                    }
+
+                    if ( bActingAsRichText )
+                		m_rContext.getGlobalContext().GetTextParagraphExport()->exportText( xControlText );
+                }
+            }
+            break;
+            default:
+                // nothing do to
+                break;
+		}
+	}
+
+	//---------------------------------------------------------------------
+	void OControlExport::exportCommonControlAttributes()
+	{
+		size_t i=0;
+
+		// I decided to handle all the properties here with some static arrays describing the property-attribute
+		// relations. This leads to somewhat ugly code :), but the only alternative I can think of right now
+		// would require maps and O(log n) searches, which seems somewhat expensive as this code is used
+		// very frequently.
+
+		// the extra indents for the respective blocks are to ensure that there is no copy'n'paste error, using
+		// map identifiers from the wrong block
+
+		// --------------------------------------------------------------------
+		// some string properties
+		{
+			// the attribute ids of all properties which are expected to be of type string
+			static sal_Int32 nStringPropertyAttributeIds[] =
+			{
+				CCA_LABEL, CCA_TITLE
+			};
+			// the names of all properties which are expected to be of type string
+			static ::rtl::OUString aStringPropertyNames[] =
+			{
+				PROPERTY_LABEL, PROPERTY_TITLE
+			};
+			OSL_ENSURE(	sizeof(aStringPropertyNames)/sizeof(aStringPropertyNames[0]) ==
+						sizeof(nStringPropertyAttributeIds)/sizeof(nStringPropertyAttributeIds[0]),
+						"OControlExport::exportCommonControlAttributes: somebody tampered with the maps (1)!");
+
+			for (i=0; i<sizeof(nStringPropertyAttributeIds)/sizeof(nStringPropertyAttributeIds[0]); ++i)
+				if (nStringPropertyAttributeIds[i] & m_nIncludeCommon)
+				{
+					exportStringPropertyAttribute(
+						OAttributeMetaData::getCommonControlAttributeNamespace(nStringPropertyAttributeIds[i]),
+						OAttributeMetaData::getCommonControlAttributeName(nStringPropertyAttributeIds[i]),
+						aStringPropertyNames[i]
+						);
+				#if OSL_DEBUG_LEVEL > 0
+					//  reset the bit for later checking
+					m_nIncludeCommon = m_nIncludeCommon & ~nStringPropertyAttributeIds[i];
+				#endif
+				}
+		}
+
+		// --------------------------------------------------------------------
+		// some boolean properties
+		{
+			static sal_Int32 nBooleanPropertyAttributeIds[] =
+			{	// attribute flags
+				CCA_CURRENT_SELECTED, CCA_DISABLED, CCA_DROPDOWN, CCA_PRINTABLE, CCA_READONLY, CCA_SELECTED, CCA_TAB_STOP, CCA_ENABLEVISIBLE
+			};
+			static const ::rtl::OUString* pBooleanPropertyNames[] =
+			{	// property names
+				&PROPERTY_STATE, &PROPERTY_ENABLED, &PROPERTY_DROPDOWN, &PROPERTY_PRINTABLE, &PROPERTY_READONLY, &PROPERTY_DEFAULT_STATE, &PROPERTY_TABSTOP, &PROPERTY_ENABLEVISIBLE
+			};
+			static sal_Bool nBooleanPropertyAttrFlags[] =
+			{	// attribute defaults
+				BOOLATTR_DEFAULT_FALSE, BOOLATTR_DEFAULT_FALSE | BOOLATTR_INVERSE_SEMANTICS, BOOLATTR_DEFAULT_FALSE, BOOLATTR_DEFAULT_TRUE, BOOLATTR_DEFAULT_FALSE, BOOLATTR_DEFAULT_FALSE, BOOLATTR_DEFAULT_VOID, BOOLATTR_DEFAULT_FALSE
+			};
+		#if OSL_DEBUG_LEVEL > 0
+			sal_Int32 nIdCount = sizeof(nBooleanPropertyAttributeIds) / sizeof(nBooleanPropertyAttributeIds[0]);
+			sal_Int32 nNameCount = sizeof(pBooleanPropertyNames) / sizeof(pBooleanPropertyNames[0]);
+			sal_Int32 nFlagsCount = sizeof(nBooleanPropertyAttrFlags) / sizeof(nBooleanPropertyAttrFlags[0]);
+			OSL_ENSURE((nIdCount == nNameCount) && (nNameCount == nFlagsCount),
+				"OControlExport::exportCommonControlAttributes: somebody tampered with the maps (2)!");
+		#endif
+			for (i=0; i<sizeof(nBooleanPropertyAttributeIds)/sizeof(nBooleanPropertyAttributeIds[0]); ++i)
+				if (nBooleanPropertyAttributeIds[i] & m_nIncludeCommon)
+				{
+					exportBooleanPropertyAttribute(
+						OAttributeMetaData::getCommonControlAttributeNamespace(nBooleanPropertyAttributeIds[i]),
+						OAttributeMetaData::getCommonControlAttributeName(nBooleanPropertyAttributeIds[i]),
+						*(pBooleanPropertyNames[i]),
+						nBooleanPropertyAttrFlags[i]);
+		#if OSL_DEBUG_LEVEL > 0
+					//  reset the bit for later checking
+					m_nIncludeCommon = m_nIncludeCommon & ~nBooleanPropertyAttributeIds[i];
+		#endif
+				}
+		}
+
+
+		// --------------------------------------------------------------------
+		// some integer properties
+		{
+			// now the common handling
+			static sal_Int32 nIntegerPropertyAttributeIds[] =
+			{	// attribute flags
+				CCA_SIZE, CCA_TAB_INDEX
+			};
+			static const ::rtl::OUString* pIntegerPropertyNames[] =
+			{	// property names
+				&PROPERTY_LINECOUNT, &PROPERTY_TABINDEX
+			};
+			static const sal_Int16 nIntegerPropertyAttrDefaults[] =
+			{	// attribute defaults
+				5, 0
+			};
+
+			if ( m_nIncludeCommon & CCA_MAX_LENGTH )
+				exportedProperty(PROPERTY_MAXTEXTLENGTH);
+
+		#if OSL_DEBUG_LEVEL > 0
+			sal_Int32 nIdCount = sizeof(nIntegerPropertyAttributeIds) / sizeof(nIntegerPropertyAttributeIds[0]);
+			sal_Int32 nNameCount = sizeof(pIntegerPropertyNames) / sizeof(pIntegerPropertyNames[0]);
+			sal_Int32 nDefaultCount = sizeof(nIntegerPropertyAttrDefaults) / sizeof(nIntegerPropertyAttrDefaults[0]);
+			OSL_ENSURE((nIdCount == nNameCount) && (nNameCount == nDefaultCount),
+				"OControlExport::exportCommonControlAttributes: somebody tampered with the maps (3)!");
+		#endif
+			for (i=0; i<sizeof(nIntegerPropertyAttributeIds)/sizeof(nIntegerPropertyAttributeIds[0]); ++i)
+				if (nIntegerPropertyAttributeIds[i] & m_nIncludeCommon)
+				{
+					exportInt16PropertyAttribute(
+						OAttributeMetaData::getCommonControlAttributeNamespace(nIntegerPropertyAttributeIds[i]),
+						OAttributeMetaData::getCommonControlAttributeName(nIntegerPropertyAttributeIds[i]),
+						*(pIntegerPropertyNames[i]),
+						nIntegerPropertyAttrDefaults[i]);
+		#if OSL_DEBUG_LEVEL > 0
+					//  reset the bit for later checking
+					m_nIncludeCommon = m_nIncludeCommon & ~nIntegerPropertyAttributeIds[i];
+		#endif
+				}
+
+
+		}
+
+		// --------------------------------------------------------------------
+		// some enum properties
+		{
+			if (m_nIncludeCommon & CCA_BUTTON_TYPE)
+			{
+				exportEnumPropertyAttribute(
+					OAttributeMetaData::getCommonControlAttributeNamespace(CCA_BUTTON_TYPE),
+					OAttributeMetaData::getCommonControlAttributeName(CCA_BUTTON_TYPE),
+					PROPERTY_BUTTONTYPE,
+					OEnumMapper::getEnumMap(OEnumMapper::epButtonType),
+					FormButtonType_PUSH);
+		#if OSL_DEBUG_LEVEL > 0
+				//  reset the bit for later checking
+				m_nIncludeCommon = m_nIncludeCommon & ~CCA_BUTTON_TYPE;
+		#endif
+			}
+			if ( m_nIncludeCommon & CCA_ORIENTATION )
+			{
+				exportEnumPropertyAttribute(
+					OAttributeMetaData::getCommonControlAttributeNamespace( CCA_ORIENTATION ),
+					OAttributeMetaData::getCommonControlAttributeName( CCA_ORIENTATION ),
+					PROPERTY_ORIENTATION,
+					OEnumMapper::getEnumMap( OEnumMapper::epOrientation ),
+                    ScrollBarOrientation::HORIZONTAL
+                );
+		#if OSL_DEBUG_LEVEL > 0
+				//  reset the bit for later checking
+				m_nIncludeCommon = m_nIncludeCommon & ~CCA_ORIENTATION;
+		#endif
+			}
+
+            if ( m_nIncludeCommon & CCA_VISUAL_EFFECT )
+            {
+				exportEnumPropertyAttribute(
+					OAttributeMetaData::getCommonControlAttributeNamespace( CCA_VISUAL_EFFECT ),
+					OAttributeMetaData::getCommonControlAttributeName( CCA_VISUAL_EFFECT ),
+					PROPERTY_VISUAL_EFFECT,
+					OEnumMapper::getEnumMap( OEnumMapper::epVisualEffect ),
+                    VisualEffect::LOOK3D
+                );
+			#if OSL_DEBUG_LEVEL > 0
+				//  reset the bit for later checking
+				m_nIncludeCommon = m_nIncludeCommon & ~CCA_VISUAL_EFFECT;
+			#endif
+            }
+		}
+
+		// --------------------------------------------------------------------
+		// some properties which require a special handling
+
+		// the target frame
+		if (m_nIncludeCommon & CCA_TARGET_FRAME)
+		{
+			exportTargetFrameAttribute();
+		#if OSL_DEBUG_LEVEL > 0
+			//  reset the bit for later checking
+			m_nIncludeCommon = m_nIncludeCommon & ~CCA_TARGET_FRAME;
+		#endif
+		}
+
+		// max text length
+		if ( m_nIncludeCommon & CCA_MAX_LENGTH )
+		{
+			// normally, the respective property would be "MaxTextLen"
+			// However, if the model has a property "PersistenceMaxTextLength", then we prefer this
+
+			// determine the name of the property to export
+			::rtl::OUString sTextLenPropertyName( PROPERTY_MAXTEXTLENGTH );
+			if ( m_xPropertyInfo->hasPropertyByName( PROPERTY_PERSISTENCE_MAXTEXTLENGTH ) )
+				sTextLenPropertyName = PROPERTY_PERSISTENCE_MAXTEXTLENGTH;
+
+			// export it
+			exportInt16PropertyAttribute(
+				OAttributeMetaData::getCommonControlAttributeNamespace( CCA_MAX_LENGTH ),
+				OAttributeMetaData::getCommonControlAttributeName( CCA_MAX_LENGTH ),
+				sTextLenPropertyName,
+				0
+			);
+
+			// in either way, both properties count as "exported"
+			exportedProperty( PROPERTY_MAXTEXTLENGTH );
+			exportedProperty( PROPERTY_PERSISTENCE_MAXTEXTLENGTH );
+
+		#if OSL_DEBUG_LEVEL > 0
+			//  reset the bit for later checking
+			m_nIncludeCommon = m_nIncludeCommon & ~CCA_MAX_LENGTH;
+		#endif
+		}
+
+		if (m_nIncludeCommon & CCA_TARGET_LOCATION)
+		{
+			exportTargetLocationAttribute();
+		#if OSL_DEBUG_LEVEL > 0
+			//  reset the bit for later checking
+			m_nIncludeCommon = m_nIncludeCommon & ~CCA_TARGET_LOCATION;
+		#endif
+		}
+
+		// OJ #99721#
+		if (m_nIncludeCommon & CCA_IMAGE_DATA)
+		{
+			exportImageDataAttribute();
+		#if OSL_DEBUG_LEVEL > 0
+			//  reset the bit for later checking
+			m_nIncludeCommon = m_nIncludeCommon & ~CCA_IMAGE_DATA;
+		#endif
+		}
+
+		// the for attribute
+		// the target frame
+		if (m_nIncludeCommon & CCA_FOR)
+		{
+			if (m_sReferringControls.getLength())
+			{	// there is at least one control referring to the one we're handling currently
+				AddAttribute(
+					OAttributeMetaData::getCommonControlAttributeNamespace(CCA_FOR),
+					OAttributeMetaData::getCommonControlAttributeName(CCA_FOR),
+					m_sReferringControls);
+			}
+		#if OSL_DEBUG_LEVEL > 0
+			//  reset the bit for later checking
+			m_nIncludeCommon = m_nIncludeCommon & ~CCA_FOR;
+		#endif
+		}
+
+		if ((CCA_CURRENT_VALUE | CCA_VALUE) & m_nIncludeCommon)
+		{
+			const sal_Char* pCurrentValuePropertyName = NULL;
+			const sal_Char* pValuePropertyName = NULL;
+
+			// get the property names
+			getValuePropertyNames(m_eType, m_nClassId, pCurrentValuePropertyName, pValuePropertyName);
+
+			static const sal_Char* pCurrentValueAttributeName = OAttributeMetaData::getCommonControlAttributeName(CCA_CURRENT_VALUE);
+			static const sal_Char* pValueAttributeName = OAttributeMetaData::getCommonControlAttributeName(CCA_VALUE);
+			static const sal_uInt16 nCurrentValueAttributeNamespaceKey = OAttributeMetaData::getCommonControlAttributeNamespace(CCA_CURRENT_VALUE);
+			static const sal_uInt16 nValueAttributeNamespaceKey = OAttributeMetaData::getCommonControlAttributeNamespace(CCA_VALUE);
+
+			// add the atrtributes if necessary and possible
+			if (pCurrentValuePropertyName && (CCA_CURRENT_VALUE & m_nIncludeCommon))
+            {
+                // don't export the current-value if this value originates from a data binding
+                // #i26944# - 2004-05-17 - fs@openoffice.org
+                if ( controlHasActiveDataBinding() )
+                    exportedProperty( ::rtl::OUString::createFromAscii( pCurrentValuePropertyName ) );
+                else
+				    exportGenericPropertyAttribute(
+					    nCurrentValueAttributeNamespaceKey,
+					    pCurrentValueAttributeName,
+					    pCurrentValuePropertyName
+                    );
+            }
+
+			if (pValuePropertyName && (CCA_VALUE & m_nIncludeCommon))
+				exportGenericPropertyAttribute(
+					nValueAttributeNamespaceKey,
+					pValueAttributeName,
+					pValuePropertyName);
+
+			OSL_ENSURE((NULL == pValuePropertyName) == (0 == (CCA_VALUE & m_nIncludeCommon)),
+				"OControlExport::exportCommonControlAttributes: no property found for the value attribute!");
+			OSL_ENSURE((NULL == pCurrentValuePropertyName ) == (0 == (CCA_CURRENT_VALUE & m_nIncludeCommon)),
+				"OControlExport::exportCommonControlAttributes: no property found for the current-value attribute!");
+
+		#if OSL_DEBUG_LEVEL > 0
+			//  reset the bit for later checking
+			m_nIncludeCommon = m_nIncludeCommon & ~(CCA_CURRENT_VALUE | CCA_VALUE);
+		#endif
+		}
+
+		OSL_ENSURE(0 == m_nIncludeCommon,
+			"OControlExport::exportCommonControlAttributes: forgot some flags!");
+			// in the dbg_util version, we should have removed every bit we handled from the mask, so it should
+			// be 0 now ...
+	}
+
+	//---------------------------------------------------------------------
+	void OControlExport::exportDatabaseAttributes()
+	{
+#if OSL_DEBUG_LEVEL > 0
+		sal_Int32 nIncludeDatabase = m_nIncludeDatabase;
+#endif
+		// the only string property: DataField
+		if (DA_DATA_FIELD & m_nIncludeDatabase)
+		{
+			exportStringPropertyAttribute(
+				OAttributeMetaData::getDatabaseAttributeNamespace(DA_DATA_FIELD),
+				OAttributeMetaData::getDatabaseAttributeName(DA_DATA_FIELD),
+				PROPERTY_DATAFIELD);
+        #if OSL_DEBUG_LEVEL > 0
+			//  reset the bit for later checking
+			nIncludeDatabase = nIncludeDatabase & ~DA_DATA_FIELD;
+		#endif
+		}
+
+		// the only int16 property: BoundColumn
+		if (DA_BOUND_COLUMN & m_nIncludeDatabase)
+		{
+			exportInt16PropertyAttribute(
+				OAttributeMetaData::getDatabaseAttributeNamespace(DA_BOUND_COLUMN),
+				OAttributeMetaData::getDatabaseAttributeName(DA_BOUND_COLUMN),
+				PROPERTY_BOUNDCOLUMN,
+				0);
+        #if OSL_DEBUG_LEVEL > 0
+			//  reset the bit for later checking
+			nIncludeDatabase = nIncludeDatabase & ~DA_BOUND_COLUMN;
+		#endif
+		}
+
+		// the only boolean property: ConvertEmptyToNull
+		if (DA_CONVERT_EMPTY & m_nIncludeDatabase)
+		{
+			exportBooleanPropertyAttribute(
+				OAttributeMetaData::getDatabaseAttributeNamespace(DA_CONVERT_EMPTY),
+				OAttributeMetaData::getDatabaseAttributeName(DA_CONVERT_EMPTY),
+				PROPERTY_EMPTY_IS_NULL,
+				BOOLATTR_DEFAULT_FALSE
+				);
+        #if OSL_DEBUG_LEVEL > 0
+			//  reset the bit for later checking
+			nIncludeDatabase = nIncludeDatabase & ~DA_CONVERT_EMPTY;
+		#endif
+		}
+
+		// the only enum property: ListSourceType
+		if (DA_LIST_SOURCE_TYPE & m_nIncludeDatabase)
+		{
+			exportEnumPropertyAttribute(
+				OAttributeMetaData::getDatabaseAttributeNamespace(DA_LIST_SOURCE_TYPE),
+				OAttributeMetaData::getDatabaseAttributeName(DA_LIST_SOURCE_TYPE),
+				PROPERTY_LISTSOURCETYPE,
+				OEnumMapper::getEnumMap(OEnumMapper::epListSourceType),
+				ListSourceType_VALUELIST
+				);
+        #if OSL_DEBUG_LEVEL > 0
+			//  reset the bit for later checking
+			nIncludeDatabase = nIncludeDatabase & ~DA_LIST_SOURCE_TYPE;
+		#endif
+		}
+
+		if (m_nIncludeDatabase & DA_LIST_SOURCE)
+		{
+			exportListSourceAsAttribute();
+        #if OSL_DEBUG_LEVEL > 0
+			//  reset the bit for later checking
+			nIncludeDatabase = nIncludeDatabase & ~DA_LIST_SOURCE;
+		#endif
+		}
+
+#if OSL_DEBUG_LEVEL > 0
+		OSL_ENSURE(0 == nIncludeDatabase,
+			"OControlExport::exportDatabaseAttributes: forgot some flags!");
+			// in the dbg_util version, we should have removed every bit we handled from the mask, so it should
+			// be 0 now ...
+#endif
+	}
+
+	//---------------------------------------------------------------------
+	void OControlExport::exportBindingAtributes()
+    {
+#if OSL_DEBUG_LEVEL > 0
+		sal_Int32 nIncludeBinding = m_nIncludeBindings;
+#endif
+
+        // ....................................................
+        if ( m_nIncludeBindings & BA_LINKED_CELL )
+        {
+            exportCellBindingAttributes( ( m_nIncludeBindings & BA_LIST_LINKING_TYPE ) != 0 );
+        #if OSL_DEBUG_LEVEL > 0
+			//  reset the bit for later checking
+			nIncludeBinding = nIncludeBinding & ~( BA_LINKED_CELL | BA_LIST_LINKING_TYPE );
+		#endif
+        }
+
+        // ....................................................
+        if ( m_nIncludeBindings & BA_LIST_CELL_RANGE )
+        {
+            exportCellListSourceRange();
+        #if OSL_DEBUG_LEVEL > 0
+			//  reset the bit for later checking
+			nIncludeBinding = nIncludeBinding & ~BA_LIST_CELL_RANGE;
+		#endif
+        }
+
+        if ( m_nIncludeBindings & BA_XFORMS_BIND )
+        {
+            exportXFormsBindAttributes();
+        #if OSL_DEBUG_LEVEL > 0
+			//  reset the bit for later checking
+			nIncludeBinding = nIncludeBinding & ~BA_XFORMS_BIND;
+		#endif
+        }
+
+        if ( m_nIncludeBindings & BA_XFORMS_LISTBIND )
+        {
+            exportXFormsListAttributes();
+        #if OSL_DEBUG_LEVEL > 0
+			//  reset the bit for later checking
+			nIncludeBinding = nIncludeBinding & ~BA_XFORMS_LISTBIND;
+		#endif
+        }
+
+        if ( m_nIncludeBindings & BA_XFORMS_SUBMISSION )
+        {
+            exportXFormsSubmissionAttributes();
+        #if OSL_DEBUG_LEVEL > 0
+			//  reset the bit for later checking
+			nIncludeBinding = nIncludeBinding & ~BA_XFORMS_SUBMISSION;
+		#endif
+        }
+
+        OSL_ENSURE( 0 == nIncludeBinding,
+			"OControlExport::exportBindingAtributes: forgot some flags!");
+			// in the debug version, we should have removed every bit we handled from the mask, so it should
+			// be 0 now ...
+    }
+
+	//---------------------------------------------------------------------
+	void OControlExport::exportSpecialAttributes()
+	{
+		sal_Int32 i=0;
+
+		// ----------------------
+		// the boolean properties
+		{
+			static const sal_Int32 nBooleanPropertyAttributeIds[] =
+			{	// attribute flags
+				SCA_VALIDATION, SCA_MULTI_LINE, SCA_AUTOMATIC_COMPLETION, SCA_MULTIPLE, SCA_DEFAULT_BUTTON, SCA_IS_TRISTATE,
+                SCA_TOGGLE, SCA_FOCUS_ON_CLICK
+			};
+			static const ::rtl::OUString* pBooleanPropertyNames[] =
+			{	// property names
+				&PROPERTY_STRICTFORMAT, &PROPERTY_MULTILINE, &PROPERTY_AUTOCOMPLETE, &PROPERTY_MULTISELECTION, &PROPERTY_DEFAULTBUTTON, &PROPERTY_TRISTATE,
+                &PROPERTY_TOGGLE, &PROPERTY_FOCUS_ON_CLICK
+			};
+			sal_Int32 nIdCount = sizeof(nBooleanPropertyAttributeIds) / sizeof(nBooleanPropertyAttributeIds[0]);
+		#if OSL_DEBUG_LEVEL > 0
+			sal_Int32 nNameCount = sizeof(pBooleanPropertyNames) / sizeof(pBooleanPropertyNames[0]);
+			OSL_ENSURE((nIdCount == nNameCount),
+				"OControlExport::exportSpecialAttributes: somebody tampered with the maps (1)!");
+		#endif
+            const sal_Int32* pAttributeId = nBooleanPropertyAttributeIds;
+            const ::rtl::OUString** pPropertyName = pBooleanPropertyNames;
+			for ( i = 0; i < nIdCount; ++i, ++pAttributeId, ++pPropertyName )
+            {
+				if ( *pAttributeId& m_nIncludeSpecial)
+				{
+					exportBooleanPropertyAttribute(
+						OAttributeMetaData::getSpecialAttributeNamespace( *pAttributeId ),
+						OAttributeMetaData::getSpecialAttributeName( *pAttributeId ),
+						*(*pPropertyName),
+                        ( *pAttributeId == SCA_FOCUS_ON_CLICK ) ? BOOLATTR_DEFAULT_TRUE : BOOLATTR_DEFAULT_FALSE
+					);
+			#if OSL_DEBUG_LEVEL > 0
+				//  reset the bit for later checking
+				m_nIncludeSpecial = m_nIncludeSpecial & ~*pAttributeId;
+			#endif
+				}
+            }
+		}
+
+		// ----------------------
+		// the integer properties
+		{
+			static sal_Int32 nIntegerPropertyAttributeIds[] =
+			{	// attribute flags
+				SCA_PAGE_STEP_SIZE
+			};
+			static const ::rtl::OUString* pIntegerPropertyNames[] =
+			{	// property names
+                &PROPERTY_BLOCK_INCREMENT
+			};
+			static const sal_Int32 nIntegerPropertyAttrDefaults[] =
+			{	// attribute defaults (XML defaults, not runtime defaults!)
+				10
+			};
+
+            sal_Int32 nIdCount = sizeof( nIntegerPropertyAttributeIds ) / sizeof( nIntegerPropertyAttributeIds[0] );
+		#if OSL_DEBUG_LEVEL > 0
+			sal_Int32 nNameCount = sizeof( pIntegerPropertyNames ) / sizeof( pIntegerPropertyNames[0] );
+			OSL_ENSURE( ( nIdCount == nNameCount ),
+				"OControlExport::exportSpecialAttributes: somebody tampered with the maps (2)!" );
+            sal_Int32 nDefaultCount = sizeof( nIntegerPropertyAttrDefaults ) / sizeof( nIntegerPropertyAttrDefaults[0] );
+			OSL_ENSURE( ( nIdCount == nDefaultCount ),
+				"OControlExport::exportSpecialAttributes: somebody tampered with the maps (3)!" );
+		#endif
+			for ( i = 0; i < nIdCount; ++i )
+				if ( nIntegerPropertyAttributeIds[i] & m_nIncludeSpecial )
+				{
+					exportInt32PropertyAttribute(
+						OAttributeMetaData::getSpecialAttributeNamespace( nIntegerPropertyAttributeIds[i] ),
+						OAttributeMetaData::getSpecialAttributeName( nIntegerPropertyAttributeIds[i] ),
+						*( pIntegerPropertyNames[i] ),
+						nIntegerPropertyAttrDefaults[i]
+					);
+			#if OSL_DEBUG_LEVEL > 0
+				//  reset the bit for later checking
+				m_nIncludeSpecial = m_nIncludeSpecial & ~nIntegerPropertyAttributeIds[i];
+			#endif
+				}
+
+            if ( SCA_STEP_SIZE & m_nIncludeSpecial )
+            {
+                ::rtl::OUString sPropertyName;
+                if ( m_xPropertyInfo->hasPropertyByName( PROPERTY_LINE_INCREMENT ) )
+                    sPropertyName = PROPERTY_LINE_INCREMENT;
+                else if ( m_xPropertyInfo->hasPropertyByName( PROPERTY_SPIN_INCREMENT ) )
+                    sPropertyName = PROPERTY_SPIN_INCREMENT;
+                else
+                    OSL_ENSURE( sal_False, "OControlExport::exportSpecialAttributes: not property which can be mapped to step-size attribute!" );
+
+                if ( sPropertyName.getLength() )
+					exportInt32PropertyAttribute(
+						OAttributeMetaData::getSpecialAttributeNamespace( SCA_STEP_SIZE ),
+						OAttributeMetaData::getSpecialAttributeName( SCA_STEP_SIZE ),
+						sPropertyName,
+						1
+					);
+
+            #if OSL_DEBUG_LEVEL > 0
+				//  reset the bit for later checking
+				m_nIncludeSpecial = m_nIncludeSpecial & ~SCA_STEP_SIZE;
+			#endif
+            }
+
+        }
+
+		// -------------------
+		// the enum properties
+		{
+			if (SCA_STATE & m_nIncludeSpecial)
+			{
+				exportEnumPropertyAttribute(
+					OAttributeMetaData::getSpecialAttributeNamespace(SCA_STATE),
+					OAttributeMetaData::getSpecialAttributeName(SCA_STATE),
+					PROPERTY_DEFAULT_STATE,
+					OEnumMapper::getEnumMap(OEnumMapper::epCheckState),
+					STATE_NOCHECK);
+			#if OSL_DEBUG_LEVEL > 0
+				//  reset the bit for later checking
+				m_nIncludeSpecial = m_nIncludeSpecial & ~SCA_STATE;
+			#endif
+			}
+
+			if (SCA_CURRENT_STATE & m_nIncludeSpecial)
+			{
+				exportEnumPropertyAttribute(
+					OAttributeMetaData::getSpecialAttributeNamespace(SCA_CURRENT_STATE),
+					OAttributeMetaData::getSpecialAttributeName(SCA_CURRENT_STATE),
+					PROPERTY_STATE,
+					OEnumMapper::getEnumMap(OEnumMapper::epCheckState),
+					STATE_NOCHECK);
+			#if OSL_DEBUG_LEVEL > 0
+				//  reset the bit for later checking
+				m_nIncludeSpecial = m_nIncludeSpecial & ~SCA_CURRENT_STATE;
+			#endif
+			}
+		}
+
+		// --------------------------------------------------------------------
+		// some properties which require a special handling
+        // the repeat delay
+        {
+		    if ( m_nIncludeSpecial & SCA_REPEAT_DELAY )
+		    {
+		        DBG_CHECK_PROPERTY( PROPERTY_REPEAT_DELAY, sal_Int32 );
+
+                sal_Int32 nRepeatDelay = 0;
+                m_xProps->getPropertyValue( PROPERTY_REPEAT_DELAY ) >>= nRepeatDelay;
+                Time aTime;
+                aTime.MakeTimeFromMS( nRepeatDelay );
+
+			    AddAttribute(OAttributeMetaData::getSpecialAttributeNamespace( SCA_REPEAT_DELAY )
+						    ,OAttributeMetaData::getSpecialAttributeName( SCA_REPEAT_DELAY )
+						    ,SvXMLUnitConverter::convertTimeDuration( aTime, nRepeatDelay % 1000 ) );
+
+		        exportedProperty( PROPERTY_REPEAT_DELAY );
+
+            #if OSL_DEBUG_LEVEL > 0
+			    //  reset the bit for later checking
+			    m_nIncludeSpecial = m_nIncludeSpecial & ~SCA_REPEAT_DELAY;
+		    #endif
+		    }
+        }
+
+		// ----------------------------------
+		// the EchoChar property needs special handling, cause it's a Int16, but must be stored as one-character-string
+		{
+			if (SCA_ECHO_CHAR & m_nIncludeSpecial)
+			{
+				DBG_CHECK_PROPERTY( PROPERTY_ECHO_CHAR, sal_Int16 );
+				sal_Int16 nValue(0);
+				m_xProps->getPropertyValue(PROPERTY_ECHO_CHAR) >>= nValue;
+				if (nValue)
+				{
+					::rtl::OUString sCharacter(reinterpret_cast<const sal_Unicode*>(&nValue), 1);
+					AddAttribute(
+						OAttributeMetaData::getSpecialAttributeNamespace(SCA_ECHO_CHAR),
+						OAttributeMetaData::getSpecialAttributeName(SCA_ECHO_CHAR),
+						sCharacter);
+				}
+				exportedProperty(PROPERTY_ECHO_CHAR);
+			#if OSL_DEBUG_LEVEL > 0
+				//  reset the bit for later checking
+				m_nIncludeSpecial = m_nIncludeSpecial & ~SCA_ECHO_CHAR;
+			#endif
+			}
+		}
+
+		// ----------------------------------
+		if ((SCA_MIN_VALUE | SCA_MAX_VALUE) & m_nIncludeSpecial)
+		{
+			// need to export the min value and the max value as attributes
+			// It depends on the real type (FormComponentType) of the control, which properties hold these
+			// values
+			const sal_Char* pMinValuePropertyName = NULL;
+			const sal_Char* pMaxValuePropertyName = NULL;
+			getValueLimitPropertyNames(m_nClassId, pMinValuePropertyName, pMaxValuePropertyName);
+
+			OSL_ENSURE((NULL == pMinValuePropertyName) == (0 == (SCA_MIN_VALUE & m_nIncludeSpecial)),
+				"OControlExport::exportCommonControlAttributes: no property found for the min value attribute!");
+			OSL_ENSURE((NULL == pMaxValuePropertyName) == (0 == (SCA_MAX_VALUE & m_nIncludeSpecial)),
+				"OControlExport::exportCommonControlAttributes: no property found for the max value attribute!");
+
+			// add the two attributes
+			static const sal_Char* pMinValueAttributeName = OAttributeMetaData::getSpecialAttributeName(SCA_MIN_VALUE);
+			static const sal_Char* pMaxValueAttributeName = OAttributeMetaData::getSpecialAttributeName(SCA_MAX_VALUE);
+			static const sal_uInt16 nMinValueNamespaceKey = OAttributeMetaData::getSpecialAttributeNamespace(SCA_MIN_VALUE);
+			static const sal_uInt16 nMaxValueNamespaceKey = OAttributeMetaData::getSpecialAttributeNamespace(SCA_MAX_VALUE);
+
+			if (pMinValuePropertyName && (SCA_MIN_VALUE & m_nIncludeSpecial))
+				exportGenericPropertyAttribute(
+					nMinValueNamespaceKey,
+					pMinValueAttributeName,
+					pMinValuePropertyName);
+
+			if (pMaxValuePropertyName && (SCA_MAX_VALUE & m_nIncludeSpecial))
+				exportGenericPropertyAttribute(
+					nMaxValueNamespaceKey,
+					pMaxValueAttributeName,
+					pMaxValuePropertyName);
+		#if OSL_DEBUG_LEVEL > 0
+			//  reset the bit for later checking
+			m_nIncludeSpecial = m_nIncludeSpecial & ~(SCA_MIN_VALUE | SCA_MAX_VALUE);
+		#endif
+		}
+
+		// ----------------------------------
+        if ( SCA_IMAGE_POSITION & m_nIncludeSpecial )
+        {
+            exportImagePositionAttributes();
+
+        #if OSL_DEBUG_LEVEL > 0
+			//  reset the bit for later checking
+			m_nIncludeSpecial = m_nIncludeSpecial & ~SCA_IMAGE_POSITION;
+		#endif
+        }
+
+		OSL_ENSURE(0 == m_nIncludeSpecial,
+			"OControlExport::exportSpecialAttributes: forgot some flags!");
+			// in the dbg_util version, we should have removed every bit we handled from the mask, so it should
+			// be 0 now ...
+	}
+
+	//---------------------------------------------------------------------
+    ::rtl::OUString OControlExport::getScalarListSourceValue() const
+    {
+		::rtl::OUString sListSource;
+		Any aListSource = m_xProps->getPropertyValue( PROPERTY_LISTSOURCE );
+		if ( !( aListSource >>= sListSource ) )
+		{
+			Sequence< ::rtl::OUString > aListSourceSequence;
+			aListSource >>= aListSourceSequence;
+			if ( aListSourceSequence.getLength() )
+				sListSource = aListSourceSequence[ 0 ];
+		}
+        return sListSource;
+    }
+
+	//---------------------------------------------------------------------
+	void OControlExport::exportListSourceAsAttribute()
+	{
+		// DA_LIST_SOURCE needs some special handling
+		DBG_CHECK_PROPERTY_NO_TYPE( PROPERTY_LISTSOURCE );
+
+        ::rtl::OUString sListSource = getScalarListSourceValue();
+		if ( sListSource.getLength() )
+		{	// the ListSource property needs to be exported as attribute, and it is not empty
+			AddAttribute(
+				OAttributeMetaData::getDatabaseAttributeNamespace(DA_LIST_SOURCE),
+				OAttributeMetaData::getDatabaseAttributeName(DA_LIST_SOURCE),
+				sListSource);
+		}
+
+        exportedProperty( PROPERTY_LISTSOURCE );
+	}
+
+	//---------------------------------------------------------------------
+	void OControlExport::getSequenceInt16PropertyAsSet(const ::rtl::OUString& _rPropertyName, Int16Set& _rOut)
+	{
+		Sequence< sal_Int16 > aValueSequence;
+		DBG_CHECK_PROPERTY(_rPropertyName, Sequence< sal_Int16 >);
+		m_xProps->getPropertyValue(_rPropertyName) >>= aValueSequence;
+
+		const sal_Int16* pValues = aValueSequence.getConstArray();
+		for (sal_Int32 i=0; i<aValueSequence.getLength(); ++i, ++pValues)
+			_rOut.insert(*pValues);
+	}
+
+	//---------------------------------------------------------------------
+	void OControlExport::exportListSourceAsElements()
+	{
+		// the string lists
+		Sequence< ::rtl::OUString > aItems, aValues;
+		DBG_CHECK_PROPERTY( PROPERTY_STRING_ITEM_LIST, Sequence< ::rtl::OUString > );
+		m_xProps->getPropertyValue(PROPERTY_STRING_ITEM_LIST) >>= aItems;
+
+		DBG_CHECK_PROPERTY( PROPERTY_LISTSOURCE, Sequence< ::rtl::OUString > );
+		if ( 0 == ( m_nIncludeDatabase & DA_LIST_SOURCE ) )
+			m_xProps->getPropertyValue(PROPERTY_LISTSOURCE) >>= aValues;
+		// if we exported the list source as attribute, we do not repeat it as sub elements
+
+		// the selection lists
+		Int16Set aSelection, aDefaultSelection;
+		getSequenceInt16PropertyAsSet(PROPERTY_SELECT_SEQ, aSelection);
+		getSequenceInt16PropertyAsSet(PROPERTY_DEFAULT_SELECT_SEQ, aDefaultSelection);
+
+		// the string for "true"
+		::rtl::OUString sTrue;
+		::rtl::OUStringBuffer sBuffer;
+		m_rContext.getGlobalContext().GetMM100UnitConverter().convertBool(sBuffer, sal_True);
+		sTrue = sBuffer.makeStringAndClear();
+
+		// loop through both lists ('til the maximum of both lengths)
+		const ::rtl::OUString* pItems = aItems.getConstArray();
+		const ::rtl::OUString* pValues = aValues.getConstArray();
+
+		sal_Int32 nItems = aItems.getLength();
+		sal_Int32 nValues = aValues.getLength();
+
+		sal_Int16 nMaxLen = (sal_Int16)std::max(nItems, nValues);
+
+		for	(sal_Int16 i=0; i<nMaxLen; ++i )
+		{
+			m_rContext.getGlobalContext().ClearAttrList();
+			if (i < nItems)
+			{
+				// there is an item at this position
+				AddAttribute(
+					OAttributeMetaData::getCommonControlAttributeNamespace(CCA_LABEL),
+					OAttributeMetaData::getCommonControlAttributeName(CCA_LABEL),
+					*pItems);
+				++pItems;
+			}
+			if (i < nValues)
+			{
+				// there is an value at this position
+				AddAttribute(
+					OAttributeMetaData::getCommonControlAttributeNamespace(CCA_VALUE),
+					OAttributeMetaData::getCommonControlAttributeName(CCA_VALUE),
+					*pValues);
+				++pValues;
+			}
+
+			Int16SetIterator aSelectedPos = aSelection.find(i);
+			if (aSelection.end() != aSelectedPos)
+			{	// the item at this position is selected
+				AddAttribute(
+					OAttributeMetaData::getCommonControlAttributeNamespace(CCA_CURRENT_SELECTED),
+					OAttributeMetaData::getCommonControlAttributeName(CCA_CURRENT_SELECTED),
+					sTrue
+					);
+				aSelection.erase(aSelectedPos);
+			}
+
+			Int16SetIterator aDefaultSelectedPos = aDefaultSelection.find(i);
+			if (aDefaultSelection.end() != aDefaultSelectedPos)
+			{	// the item at this position is selected as default
+				AddAttribute(
+					OAttributeMetaData::getCommonControlAttributeNamespace(CCA_SELECTED),
+					OAttributeMetaData::getCommonControlAttributeName(CCA_SELECTED),
+					sTrue
+					);
+				aDefaultSelection.erase(aDefaultSelectedPos);
+			}
+			SvXMLElementExport aFormElement(m_rContext.getGlobalContext(), XML_NAMESPACE_FORM, "option", sal_True, sal_True);
+		}
+
+		// There may be more "selected" or "default-selected" items than there are in the lists in real,
+		// so we need to store some additional "form:option" items which have no name and no label, but
+		// one or both of the selected flags.
+		// 21.05.2001 - 85388 - frank.schoenheit@germany.sun.com
+
+		if (aSelection.size() || aDefaultSelection.size())
+		{
+			sal_Int16 nLastSelected = -1;
+			if (aSelection.size())
+				nLastSelected = *(--aSelection.end());
+
+			sal_Int16 nLastDefaultSelected = -1;
+			if (aDefaultSelection.size())
+				nLastDefaultSelected = *(--aDefaultSelection.end());
+
+			// the maximum element in both sets
+			sal_Int16 nLastReferredEntry = std::max(nLastSelected, nLastDefaultSelected);
+			OSL_ENSURE(nLastReferredEntry >= nMaxLen, "OControlExport::exportListSourceAsElements: inconsistence!");
+				// if the maximum (selected or default selected) entry number is less than the maximum item count
+				// in both lists, the entry number should have been removed from the set
+
+			for (sal_Int16 i=nMaxLen; i<=nLastReferredEntry; ++i)
+			{
+				if (aSelection.end() != aSelection.find(i))
+				{	// the (not existent) item at this position is selected
+					AddAttribute(
+						OAttributeMetaData::getCommonControlAttributeNamespace(CCA_CURRENT_SELECTED),
+						OAttributeMetaData::getCommonControlAttributeName(CCA_CURRENT_SELECTED),
+						sTrue
+						);
+				}
+
+				if (aDefaultSelection.end() != aDefaultSelection.find(i))
+				{	// the (not existent) item at this position is selected as default
+					AddAttribute(
+						OAttributeMetaData::getCommonControlAttributeNamespace(CCA_SELECTED),
+						OAttributeMetaData::getCommonControlAttributeName(CCA_SELECTED),
+						sTrue
+						);
+				}
+				SvXMLElementExport aFormElement(m_rContext.getGlobalContext(), XML_NAMESPACE_FORM, "option", sal_True, sal_True);
+			}
+		}
+	}
+
+	//---------------------------------------------------------------------
+	void OControlExport::implStartElement(const sal_Char* _pName)
+	{
+		// before we let the base class start it's outer element, we add a wrapper element
+		const sal_Char *pOuterElementName = getOuterXMLElementName();
+		m_pOuterElement = pOuterElementName
+		   					? new SvXMLElementExport(
+										m_rContext.getGlobalContext(),
+										XML_NAMESPACE_FORM,
+										pOuterElementName, sal_True,
+										sal_True)
+							: 0;
+
+		// add the attributes for the inner element
+		exportInnerAttributes();
+
+		// and start the inner element
+		OElementExport::implStartElement(_pName);
+	}
+
+	//---------------------------------------------------------------------
+	void OControlExport::implEndElement()
+	{
+		// end the inner element
+		OElementExport::implEndElement();
+
+		// end the outer element if it exists
+		delete m_pOuterElement;
+		m_pOuterElement = NULL;
+	}
+
+	//---------------------------------------------------------------------
+	const sal_Char* OControlExport::getOuterXMLElementName() const
+	{
+		return 0;
+	}
+
+	//---------------------------------------------------------------------
+	const sal_Char* OControlExport::getXMLElementName() const
+	{
+		return getElementName(m_eType);
+	}
+
+	//---------------------------------------------------------------------
+	void OControlExport::examine()
+	{
+        OSL_ENSURE( ( m_nIncludeCommon == 0 ) && ( m_nIncludeSpecial == 0 ) && ( m_nIncludeDatabase == 0 )
+                 && ( m_nIncludeEvents == 0 ) && ( m_nIncludeBindings == 0),
+                 "OControlExport::examine: called me twice? Not initialized?" );
+
+        // get the class id to decide which kind of element we need in the XML stream
+		m_nClassId = FormComponentType::CONTROL;
+		DBG_CHECK_PROPERTY( PROPERTY_CLASSID, sal_Int16 );
+		m_xProps->getPropertyValue(PROPERTY_CLASSID) >>= m_nClassId;
+		switch (m_nClassId)
+		{
+			case FormComponentType::DATEFIELD:
+			case FormComponentType::TIMEFIELD:
+			case FormComponentType::NUMERICFIELD:
+			case FormComponentType::CURRENCYFIELD:
+			case FormComponentType::PATTERNFIELD:
+				m_eType = FORMATTED_TEXT;
+				// NO BREAK
+			case FormComponentType::TEXTFIELD:
+			{	// it's some kind of edit. To know which type we need further investigation
+
+				if (FORMATTED_TEXT != m_eType)
+				{	// not coming from the previous cases which had a class id .ne. TEXTFIELD
+
+					// check if it's a formatted field
+					if (m_xPropertyInfo->hasPropertyByName(PROPERTY_FORMATKEY))
+					{
+						m_eType = FORMATTED_TEXT;
+					}
+					else
+					{
+						// all other controls are represented by an ordinary edit control, but which XML control type
+						// it is depends on the current values of some properties
+
+						// if the EchoChar string is not empty, it is a password field
+						sal_Int16 nEchoChar = 0;
+						if (m_xPropertyInfo->hasPropertyByName(PROPERTY_ECHOCHAR))
+							// grid columns do not have this property ....
+							m_xProps->getPropertyValue(PROPERTY_ECHOCHAR) >>= nEchoChar;
+						if (nEchoChar)
+						{
+							m_eType = PASSWORD;
+							m_nIncludeSpecial |= SCA_ECHO_CHAR;
+						}
+						else
+						{
+							// if the MultiLine property is sal_True, it is a TextArea
+							sal_Bool bMultiLine = sal_False;
+							if (m_xPropertyInfo->hasPropertyByName(PROPERTY_MULTILINE))
+								// grid columns do not have this property ....
+								bMultiLine = ::cppu::any2bool(m_xProps->getPropertyValue(PROPERTY_MULTILINE));
+
+                            if ( bMultiLine )
+								m_eType = TEXT_AREA;
+							else
+								// the only case left is represented by a Text element
+								m_eType = TEXT;
+						}
+					}
+				}
+
+				// attributes which are common to all the four types:
+				// common attributes
+				m_nIncludeCommon =
+					CCA_NAME | CCA_SERVICE_NAME | CCA_DISABLED | CCA_VALUE |
+					CCA_PRINTABLE | CCA_TAB_INDEX | CCA_TAB_STOP | CCA_TITLE;
+
+                // database attributes
+				m_nIncludeDatabase = DA_DATA_FIELD;
+
+				// event attributes
+				m_nIncludeEvents = EA_CONTROL_EVENTS | EA_ON_CHANGE | EA_ON_SELECT;
+
+				// only text and pattern fields have a ConvertEmptyToNull property
+				if  (   ( m_nClassId == FormComponentType::TEXTFIELD )
+                    ||  ( m_nClassId == FormComponentType::PATTERNFIELD )
+                    )
+					m_nIncludeDatabase |= DA_CONVERT_EMPTY;
+
+				// all controls but the file control fields have a readonly property
+				if ( m_nClassId != FormComponentType::FILECONTROL )
+					m_nIncludeCommon |= CCA_READONLY;
+
+				// a text field has a max text len
+                if ( m_nClassId == FormComponentType::TEXTFIELD )
+					m_nIncludeCommon |= CCA_MAX_LENGTH;
+
+				// max and min values and validation:
+				if (FORMATTED_TEXT == m_eType)
+				{	// in general all controls represented as formatted-text have these props
+					if (FormComponentType::PATTERNFIELD != m_nClassId)
+						// but the PatternField does not have value limits
+						m_nIncludeSpecial |= SCA_MAX_VALUE | SCA_MIN_VALUE;
+
+					if (FormComponentType::TEXTFIELD != m_nClassId)
+						// and the FormattedField does not have a validation flag
+						m_nIncludeSpecial |= SCA_VALIDATION;
+				}
+
+				// if it's not a password field or rich text control, the CurrentValue needs to be stored, too
+				if ( PASSWORD != m_eType )
+					m_nIncludeCommon |= CCA_CURRENT_VALUE;
+			}
+			break;
+
+			case FormComponentType::FILECONTROL:
+				m_eType = FILE;
+				m_nIncludeCommon =
+					CCA_NAME | CCA_SERVICE_NAME | CCA_CURRENT_VALUE | CCA_DISABLED |
+					CCA_PRINTABLE | CCA_TAB_INDEX | CCA_TAB_STOP | CCA_TITLE |
+					CCA_VALUE;
+				m_nIncludeEvents = EA_CONTROL_EVENTS | EA_ON_CHANGE | EA_ON_SELECT;
+				break;
+
+			case FormComponentType::FIXEDTEXT:
+				m_eType = FIXED_TEXT;
+				m_nIncludeCommon =
+					CCA_NAME | CCA_SERVICE_NAME | CCA_DISABLED | CCA_LABEL |
+					CCA_PRINTABLE | CCA_TITLE | CCA_FOR;
+				m_nIncludeSpecial = SCA_MULTI_LINE;
+				m_nIncludeEvents = EA_CONTROL_EVENTS;
+				break;
+
+			case FormComponentType::COMBOBOX:
+				m_eType = COMBOBOX;
+				m_nIncludeCommon =
+					CCA_NAME | CCA_SERVICE_NAME | CCA_CURRENT_VALUE |
+					CCA_DISABLED | CCA_DROPDOWN | CCA_MAX_LENGTH | CCA_PRINTABLE | CCA_READONLY | CCA_SIZE |
+					CCA_TAB_INDEX | CCA_TAB_STOP | CCA_TITLE | CCA_VALUE;
+				m_nIncludeSpecial = SCA_AUTOMATIC_COMPLETION;
+				m_nIncludeDatabase = DA_CONVERT_EMPTY | DA_DATA_FIELD | DA_LIST_SOURCE | DA_LIST_SOURCE_TYPE;
+				m_nIncludeEvents = EA_CONTROL_EVENTS | EA_ON_CHANGE | EA_ON_SELECT;
+				break;
+
+			case FormComponentType::LISTBOX:
+				m_eType = LISTBOX;
+				m_nIncludeCommon =
+					CCA_NAME | CCA_SERVICE_NAME | CCA_DISABLED | CCA_DROPDOWN |
+					CCA_PRINTABLE | CCA_SIZE | CCA_TAB_INDEX | CCA_TAB_STOP | CCA_TITLE;
+				m_nIncludeSpecial = SCA_MULTIPLE;
+				m_nIncludeDatabase = DA_BOUND_COLUMN | DA_DATA_FIELD | DA_LIST_SOURCE_TYPE;
+				m_nIncludeEvents = EA_CONTROL_EVENTS | EA_ON_CHANGE | EA_ON_CLICK | EA_ON_DBLCLICK;
+				// check if we need to export the ListSource as attribute
+				{
+					// for a list box, if the ListSourceType is VALUE_LIST, no ListSource is stored, but instead
+					// a sequence of pairs which is build from the StringItemList and the ValueList
+					ListSourceType eListSourceType = ListSourceType_VALUELIST;
+                #if OSL_DEBUG_LEVEL > 0
+					sal_Bool bSuccess =
+				#endif
+					m_xProps->getPropertyValue(PROPERTY_LISTSOURCETYPE) >>= eListSourceType;
+					OSL_ENSURE(bSuccess, "OControlExport::examineControl: could not retrieve the ListSourceType!");
+					if (ListSourceType_VALUELIST != eListSourceType)
+					{
+						m_nIncludeDatabase |= DA_LIST_SOURCE;
+					}
+				}
+
+				break;
+
+			case FormComponentType::COMMANDBUTTON:
+				m_eType = BUTTON;
+				m_nIncludeCommon |= CCA_TAB_STOP | CCA_LABEL;
+				m_nIncludeSpecial = SCA_DEFAULT_BUTTON | SCA_TOGGLE | SCA_FOCUS_ON_CLICK | SCA_IMAGE_POSITION | SCA_REPEAT_DELAY;
+				// NO BREAK !
+			case FormComponentType::IMAGEBUTTON:
+				if (BUTTON != m_eType)
+					// not coming from the previous case
+					m_eType = IMAGE;
+				m_nIncludeCommon |=
+					CCA_NAME | CCA_SERVICE_NAME | CCA_BUTTON_TYPE | CCA_DISABLED |
+					CCA_IMAGE_DATA | CCA_PRINTABLE | CCA_TAB_INDEX | CCA_TARGET_FRAME |
+					CCA_TARGET_LOCATION | CCA_TITLE;
+				m_nIncludeEvents = EA_CONTROL_EVENTS | EA_ON_CLICK	| EA_ON_DBLCLICK;
+				break;
+
+			case FormComponentType::CHECKBOX:
+				m_eType = CHECKBOX;
+				m_nIncludeSpecial = SCA_CURRENT_STATE | SCA_IS_TRISTATE | SCA_STATE;
+				// NO BREAK !
+			case FormComponentType::RADIOBUTTON:
+				m_nIncludeCommon =
+					CCA_NAME | CCA_SERVICE_NAME | CCA_DISABLED | CCA_LABEL | CCA_PRINTABLE |
+                    CCA_TAB_INDEX | CCA_TAB_STOP | CCA_TITLE | CCA_VALUE | CCA_VISUAL_EFFECT;
+				if (CHECKBOX != m_eType)
+				{	// not coming from the previous case
+					m_eType = RADIO;
+					m_nIncludeCommon |= CCA_CURRENT_SELECTED | CCA_SELECTED;
+				}
+                if ( m_xPropertyInfo->hasPropertyByName( PROPERTY_IMAGE_POSITION ) )
+                    m_nIncludeSpecial |= SCA_IMAGE_POSITION;
+				m_nIncludeDatabase = DA_DATA_FIELD;
+				m_nIncludeEvents = EA_CONTROL_EVENTS | EA_ON_CHANGE;
+				break;
+
+			case FormComponentType::GROUPBOX:
+				m_eType = FRAME;
+				m_nIncludeCommon =
+					CCA_NAME | CCA_SERVICE_NAME | CCA_DISABLED | CCA_LABEL |
+					CCA_PRINTABLE | CCA_TITLE | CCA_FOR;
+				m_nIncludeEvents = EA_CONTROL_EVENTS;
+				break;
+
+			case FormComponentType::IMAGECONTROL:
+				m_eType = IMAGE_FRAME;
+				m_nIncludeCommon =
+					CCA_NAME | CCA_SERVICE_NAME | CCA_DISABLED | CCA_IMAGE_DATA |
+					CCA_PRINTABLE | CCA_READONLY | CCA_TITLE;
+				m_nIncludeDatabase = DA_DATA_FIELD;
+				m_nIncludeEvents = EA_CONTROL_EVENTS;
+				break;
+
+			case FormComponentType::HIDDENCONTROL:
+				m_eType = HIDDEN;
+				m_nIncludeCommon =
+					CCA_NAME | CCA_SERVICE_NAME | CCA_VALUE;
+				break;
+
+			case FormComponentType::GRIDCONTROL:
+				m_eType = GRID;
+				m_nIncludeCommon =
+					CCA_NAME | CCA_SERVICE_NAME | CCA_DISABLED | CCA_PRINTABLE |
+					CCA_TAB_INDEX | CCA_TAB_STOP | CCA_TITLE;
+				m_nIncludeEvents = EA_CONTROL_EVENTS;
+				break;
+
+			case FormComponentType::SCROLLBAR:
+			case FormComponentType::SPINBUTTON:
+				m_eType = VALUERANGE;
+				m_nIncludeCommon =
+					CCA_NAME | CCA_SERVICE_NAME | CCA_DISABLED | CCA_PRINTABLE |
+                    CCA_TITLE | CCA_CURRENT_VALUE | CCA_VALUE | CCA_ORIENTATION;
+                m_nIncludeSpecial = SCA_MAX_VALUE | SCA_STEP_SIZE | SCA_MIN_VALUE | SCA_REPEAT_DELAY;
+
+                if ( m_nClassId == FormComponentType::SCROLLBAR )
+                    m_nIncludeSpecial |= SCA_PAGE_STEP_SIZE ;
+
+				m_nIncludeEvents = EA_CONTROL_EVENTS;
+                break;
+
+            default:
+				OSL_ENSURE(sal_False, "OControlExport::examineControl: unknown control type (class id)!");
+                // NO break!
+
+            case FormComponentType::NAVIGATIONBAR:
+                // TODO: should we have an own file format for this?
+                // NO break
+
+            case FormComponentType::CONTROL:
+				m_eType = GENERIC_CONTROL;
+				// unknown control type
+				m_nIncludeCommon = CCA_NAME | CCA_SERVICE_NAME;
+					// at least a name should be there, 'cause without a name the control could never have been
+					// inserted into it's parent container
+					// In addition, the service name is absolutely necessary to create the control upon reading.
+				m_nIncludeEvents = EA_CONTROL_EVENTS;
+					// we always should be able to export events - this is not control type dependent
+				break;
+		}
+
+		// in general, all control types need to export the control id
+		m_nIncludeCommon |= CCA_CONTROL_ID;
+
+        // is is a control bound to a calc cell?
+        if ( FormCellBindingHelper::livesInSpreadsheetDocument( m_xProps ) )
+        {
+            FormCellBindingHelper aHelper( m_xProps, NULL );
+            {
+                if ( aHelper.isCellBinding( aHelper.getCurrentBinding( ) ) )
+                {
+                    m_nIncludeBindings |= BA_LINKED_CELL;
+                    if ( m_nClassId == FormComponentType::LISTBOX )
+                        m_nIncludeBindings |= BA_LIST_LINKING_TYPE;
+                }
+            }
+
+            // is it a list-like control which uses a calc cell range as list source?
+            {
+                if ( aHelper.isCellRangeListSource( aHelper.getCurrentListSource( ) ) )
+                    m_nIncludeBindings |= BA_LIST_CELL_RANGE;
+            }
+        }
+
+        // is control bound to XForms?
+        if( getXFormsBindName( m_xProps ).getLength() > 0 )
+        {
+            m_nIncludeBindings |= BA_XFORMS_BIND;
+        }
+
+        // is (list-)control bound to XForms list?
+        if( getXFormsListBindName( m_xProps ).getLength() > 0 )
+        {
+            m_nIncludeBindings |= BA_XFORMS_LISTBIND;
+        }
+
+        // does the control have an XForms submission?
+        if( getXFormsSubmissionName( m_xProps ).getLength() > 0 )
+        {
+            m_nIncludeBindings |= BA_XFORMS_SUBMISSION;
+        }
+	}
+
+	//---------------------------------------------------------------------
+    void OControlExport::exportCellBindingAttributes( bool _bIncludeListLinkageType )
+    {
+        try
+        {
+            FormCellBindingHelper aHelper( m_xProps, NULL );
+            Reference< XValueBinding > xBinding( aHelper.getCurrentBinding() );
+            OSL_ENSURE( xBinding.is(), "OControlExport::exportCellBindingAttributes: invalid bindable or invalid binding!" );
+            if ( xBinding.is() )
+            {
+                // ....................................................
+    			AddAttribute(
+                    OAttributeMetaData::getBindingAttributeNamespace( BA_LINKED_CELL ),
+                    OAttributeMetaData::getBindingAttributeName( BA_LINKED_CELL ),
+                    aHelper.getStringAddressFromCellBinding( xBinding )
+                );
+
+                // ....................................................
+                if ( _bIncludeListLinkageType )
+                {
+                    sal_Int16 nLinkageType = aHelper.isCellIntegerBinding( xBinding ) ? 1 : 0;
+
+                    ::rtl::OUStringBuffer sBuffer;
+			        m_rContext.getGlobalContext().GetMM100UnitConverter().convertEnum(
+                        sBuffer,
+                        (sal_uInt16)nLinkageType,
+                        OEnumMapper::getEnumMap( OEnumMapper::epListLinkageType )
+                    );
+
+                    AddAttribute(
+                        OAttributeMetaData::getBindingAttributeNamespace( BA_LIST_LINKING_TYPE ),
+                        OAttributeMetaData::getBindingAttributeName( BA_LIST_LINKING_TYPE ),
+                        sBuffer.makeStringAndClear()
+                    );
+                }
+
+            }
+        }
+        catch( const Exception& )
+        {
+            OSL_ENSURE( sal_False, "OControlExport::exportCellBindingAttributes: caught an exception!" );
+        }
+    }
+
+	//---------------------------------------------------------------------
+    void OControlExport::exportXFormsBindAttributes()
+    {
+        rtl::OUString sBindName = getXFormsBindName( m_xProps );
+        AddAttribute( XML_NAMESPACE_XFORMS, XML_BIND, sBindName );
+    }
+	//---------------------------------------------------------------------
+    void OControlExport::exportXFormsListAttributes()
+    {
+        rtl::OUString sBindName = getXFormsListBindName( m_xProps );
+        AddAttribute( XML_NAMESPACE_FORM, XML_XFORMS_LIST_SOURCE, sBindName );
+    }
+	//---------------------------------------------------------------------
+    void OControlExport::exportXFormsSubmissionAttributes()
+    {
+        rtl::OUString sSubmission = getXFormsSubmissionName( m_xProps );
+        AddAttribute( XML_NAMESPACE_FORM, XML_XFORMS_SUBMISSION, sSubmission );
+    }
+	//---------------------------------------------------------------------
+    void OControlExport::exportCellListSourceRange( )
+    {
+        try
+        {
+            Reference< XListEntrySink > xSink( m_xProps, UNO_QUERY );
+            Reference< XListEntrySource > xSource;
+            if ( xSink.is() )
+                xSource = xSource.query( xSink->getListEntrySource() );
+            OSL_ENSURE( xSource.is(), "OControlExport::exportCellListSourceRange: list source or sink!" );
+            if ( xSource.is() )
+            {
+                FormCellBindingHelper aHelper( m_xProps, NULL );
+
+    			AddAttribute(
+                    OAttributeMetaData::getBindingAttributeNamespace( BA_LIST_CELL_RANGE ),
+                    OAttributeMetaData::getBindingAttributeName( BA_LIST_CELL_RANGE ),
+                    aHelper.getStringAddressFromCellListSource( xSource )
+                );
+            }
+        }
+        catch( const Exception& )
+        {
+            OSL_ENSURE( sal_False, "OControlExport::exportCellListSourceRange: caught an exception!" );
+        }
+    }
+
+	//---------------------------------------------------------------------
+    void OControlExport::exportImagePositionAttributes()
+    {
+        try
+        {
+            sal_Int16 nImagePosition = ImagePosition::Centered;
+            OSL_VERIFY( m_xProps->getPropertyValue( PROPERTY_IMAGE_POSITION ) >>= nImagePosition );
+            OSL_ENSURE( ( nImagePosition >= ImagePosition::LeftTop ) && ( nImagePosition <= ImagePosition::Centered ),
+                "OControlExport::exportImagePositionAttributes: don't know this image position!" );
+
+            if ( ( nImagePosition < ImagePosition::LeftTop ) || ( nImagePosition > ImagePosition::Centered ) )
+                // this is important to prevent potential buffer overflows below, so don't optimize
+                nImagePosition = ImagePosition::Centered;
+
+            if ( nImagePosition == ImagePosition::Centered )
+            {
+    		    AddAttribute( XML_NAMESPACE_FORM, GetXMLToken( XML_IMAGE_POSITION ), GetXMLToken( XML_CENTER ) );
+            }
+            else
+            {
+                XMLTokenEnum eXmlImagePositions[] =
+                {
+                    XML_START, XML_END, XML_TOP, XML_BOTTOM
+                };
+                XMLTokenEnum eXmlImageAligns[] =
+                {
+                    XML_START, XML_CENTER, XML_END
+                };
+
+                XMLTokenEnum eXmlImagePosition = eXmlImagePositions[ nImagePosition / 3 ];
+                XMLTokenEnum eXmlImageAlign    = eXmlImageAligns   [ nImagePosition % 3 ];
+
+    		    AddAttribute( XML_NAMESPACE_FORM, GetXMLToken( XML_IMAGE_POSITION ), GetXMLToken( eXmlImagePosition ) );
+    		    AddAttribute( XML_NAMESPACE_FORM, GetXMLToken( XML_IMAGE_ALIGN    ), GetXMLToken( eXmlImageAlign    ) );
+            }
+
+            exportedProperty( PROPERTY_IMAGE_POSITION );
+            // some of the controls which have an ImagePosition also have an ImageAlign for compatibility
+            // reasons. Since the ImageAlign values simply represent a sub set of the ImagePosition values,
+            // we don't need to export ImageAlign anymore
+            exportedProperty( PROPERTY_IMAGE_ALIGN );
+        }
+        catch( const Exception& )
+        {
+            DBG_UNHANDLED_EXCEPTION();
+        }
+    }
+
+	//---------------------------------------------------------------------
+	bool OControlExport::controlHasActiveDataBinding() const
+    {
+        try
+        {
+            // currently exchanging the data with a database column?
+            ::rtl::OUString sBoundFieldPropertyName( RTL_CONSTASCII_USTRINGPARAM( "BoundField" ) );
+            if ( m_xPropertyInfo.is() && m_xPropertyInfo->hasPropertyByName( sBoundFieldPropertyName ) )
+            {
+                Reference< XPropertySet > xBoundField;
+                m_xProps->getPropertyValue( sBoundFieldPropertyName ) >>= xBoundField;
+                if ( xBoundField.is() )
+                    return true;
+            }
+
+            // currently exchanging data with an external binding?
+            Reference< XBindableValue > xBindable( m_xProps, UNO_QUERY );
+            if ( xBindable.is() && xBindable->getValueBinding().is() )
+                return true;
+        }
+        catch( const Exception& )
+        {
+        	OSL_ENSURE( sal_False, "OColumnExport::controlHasActiveDataBinding: caught an exception!" );
+        }
+
+        return false;
+    }
+
+	//---------------------------------------------------------------------
+	bool OControlExport::controlHasUserSuppliedListEntries() const
+    {
+        try
+        {
+            // an external list source?
+            Reference< XListEntrySink > xEntrySink( m_xProps, UNO_QUERY );
+            if ( xEntrySink.is() && xEntrySink->getListEntrySource().is() )
+                return false;
+
+            if ( m_xPropertyInfo.is() && m_xPropertyInfo->hasPropertyByName( PROPERTY_LISTSOURCETYPE ) )
+            {
+                ListSourceType eListSourceType = ListSourceType_VALUELIST;
+                OSL_VERIFY( m_xProps->getPropertyValue( PROPERTY_LISTSOURCETYPE ) >>= eListSourceType );
+                if ( eListSourceType == ListSourceType_VALUELIST )
+                    // for value lists, the list entries as entered by the user are used
+                    return true;
+
+                // for every other type, the list entries are filled with some data obtained
+                // from a database - if and only if the ListSource property is not empty
+                return ( 0 == getScalarListSourceValue().getLength() );
+            }
+        }
+        catch( const Exception& )
+        {
+        	OSL_ENSURE( sal_False, "OControlExport::controlHasUserSuppliedListEntries: caught an exception!" );
+        }
+
+        OSL_ENSURE( sal_False, "OControlExport::controlHasUserSuppliedListEntries: unreachable code!" );
+            // this method should be called for list and combo boxes only
+        return true;
+    }
+
+	//=====================================================================
+	//= OColumnExport
+	//=====================================================================
+	//---------------------------------------------------------------------
+	OColumnExport::OColumnExport(IFormsExportContext& _rContext, const Reference< XPropertySet >& _rxControl, const ::rtl::OUString& _rControlId,
+		const Sequence< ScriptEventDescriptor >& _rEvents)
+		:OControlExport(_rContext, _rxControl, _rControlId, ::rtl::OUString(), _rEvents)
+	{
+	}
+
+	//---------------------------------------------------------------------
+	OColumnExport::~OColumnExport()
+	{
+		implEndElement();
+	}
+
+	//---------------------------------------------------------------------
+	void OColumnExport::exportServiceNameAttribute()
+	{
+		// the attribute "service name" (which has a slightly different meaning for columns
+		DBG_CHECK_PROPERTY( PROPERTY_COLUMNSERVICENAME, ::rtl::OUString );
+		::rtl::OUString sColumnServiceName;
+		m_xProps->getPropertyValue(PROPERTY_COLUMNSERVICENAME) >>= sColumnServiceName;
+		// the service name is a full qualified one (i.e. com.sun.star.form.TextField), but the
+		// real service name for the column (for use with the XGridColumnFactory) is only the last
+		// token of this complete name.
+		sal_Int32 nLastSep = sColumnServiceName.lastIndexOf('.');
+		OSL_ENSURE(-1 != nLastSep, "OColumnExport::startExportElement: invalid service name!");
+		sColumnServiceName = sColumnServiceName.copy(nLastSep + 1);
+		sColumnServiceName =
+			m_rContext.getGlobalContext().GetNamespaceMap().GetQNameByKey(
+				XML_NAMESPACE_OOO, sColumnServiceName );
+		// add the attribute
+		AddAttribute( OAttributeMetaData::getCommonControlAttributeNamespace(CCA_SERVICE_NAME)
+					, OAttributeMetaData::getCommonControlAttributeName(CCA_SERVICE_NAME)
+					, sColumnServiceName);
+		// flag the property as "handled"
+		exportedProperty(PROPERTY_COLUMNSERVICENAME);
+
+	}
+
+	//---------------------------------------------------------------------
+	const sal_Char* OColumnExport::getOuterXMLElementName() const
+	{
+		return "column";
+	}
+
+	//---------------------------------------------------------------------
+	void OColumnExport::exportAttributes()
+	{
+		OControlExport::exportAttributes();
+
+		// the attribute "label"
+		exportStringPropertyAttribute(
+			OAttributeMetaData::getCommonControlAttributeNamespace(CCA_LABEL),
+			OAttributeMetaData::getCommonControlAttributeName(CCA_LABEL),
+			PROPERTY_LABEL);
+
+		// the style attribute
+		::rtl::OUString sStyleName = m_rContext.getObjectStyleName( m_xProps );
+		if ( sStyleName.getLength() )
+		{
+			AddAttribute(
+				OAttributeMetaData::getSpecialAttributeNamespace( SCA_COLUMN_STYLE_NAME ),
+				OAttributeMetaData::getSpecialAttributeName( SCA_COLUMN_STYLE_NAME ),
+				sStyleName
+			);
+		}
+	}
+
+	//---------------------------------------------------------------------
+	void OColumnExport::examine()
+	{
+		OControlExport::examine();
+
+		// grid columns miss some properties of the controls they're representing
+		m_nIncludeCommon &= ~(CCA_FOR | CCA_PRINTABLE | CCA_TAB_INDEX | CCA_TAB_STOP | CCA_LABEL);
+		m_nIncludeSpecial &= ~(SCA_ECHO_CHAR | SCA_AUTOMATIC_COMPLETION | SCA_MULTIPLE | SCA_MULTI_LINE | SCA_IS_TRISTATE);
+
+		if (FormComponentType::DATEFIELD != m_nClassId)
+			// except date fields, no column has the DropDown property
+			m_nIncludeCommon &= ~CCA_DROPDOWN;
+	}
+
+	//=====================================================================
+	//= OFormExport
+	//=====================================================================
+	//---------------------------------------------------------------------
+	OFormExport::OFormExport(IFormsExportContext& _rContext, const Reference< XPropertySet >& _rxForm,
+		const Sequence< ScriptEventDescriptor >& _rEvents)
+		:OElementExport(_rContext, _rxForm, _rEvents)
+		,m_bCreateConnectionResourceElement(sal_False)
+	{
+		OSL_ENSURE(m_xProps.is(), "OFormExport::OFormExport: invalid arguments!");
+	}
+
+	//---------------------------------------------------------------------
+	const sal_Char* OFormExport::getXMLElementName() const
+	{
+		return "form";
+	}
+
+	//---------------------------------------------------------------------
+	void OFormExport::exportSubTags()
+	{
+		if ( m_bCreateConnectionResourceElement && m_xProps.is() )
+		{
+			m_rContext.getGlobalContext().ClearAttrList();
+			::rtl::OUString sPropValue;
+			m_xProps->getPropertyValue( PROPERTY_DATASOURCENAME ) >>= sPropValue; // if set it is a file url
+			if ( !sPropValue.getLength() )
+				m_xProps->getPropertyValue( PROPERTY_URL ) >>= sPropValue;
+			if ( sPropValue.getLength() )
+				AddAttribute(
+					OAttributeMetaData::getCommonControlAttributeNamespace(CCA_TARGET_LOCATION),
+					OAttributeMetaData::getCommonControlAttributeName(CCA_TARGET_LOCATION),
+					sPropValue);
+			if ( m_rContext.getGlobalContext().GetAttrList().getLength() )
+			{
+				SvXMLElementExport aFormElement(m_rContext.getGlobalContext(), XML_NAMESPACE_FORM, xmloff::token::XML_CONNECTION_RESOURCE, sal_True, sal_True);
+			}
+		}
+
+		// let the base class export the remaining properties and the events
+		OElementExport::exportSubTags();
+		// loop through all children
+		Reference< XIndexAccess > xCollection(m_xProps, UNO_QUERY);
+		OSL_ENSURE(xCollection.is(), "OFormLayerXMLExport::implExportForm: a form which is not an index access? Suspicous!");
+
+		if (xCollection.is())
+			m_rContext.exportCollectionElements(xCollection);
+	}
+
+	//---------------------------------------------------------------------
+	void OFormExport::exportAttributes()
+	{
+		sal_Int32 i=0;
+
+		// ---------------------
+		// the string properties
+		{
+			static FormAttributes eStringPropertyIds[] =
+			{
+				faName, /*faAction,*/ faCommand, faFilter, faOrder
+			};
+			static ::rtl::OUString aStringPropertyNames[] =
+			{
+				PROPERTY_NAME, /*PROPERTY_TARGETURL,*/ PROPERTY_COMMAND, PROPERTY_FILTER, PROPERTY_ORDER
+			};
+			sal_Int32 nIdCount = sizeof(eStringPropertyIds) / sizeof(eStringPropertyIds[0]);
+		#if OSL_DEBUG_LEVEL > 0
+			sal_Int32 nNameCount = sizeof(aStringPropertyNames) / sizeof(aStringPropertyNames[0]);
+			OSL_ENSURE((nIdCount == nNameCount),
+				"OFormExport::exportAttributes: somebody tampered with the maps (1)!");
+		#endif
+			for (i=0; i<nIdCount; ++i)
+				exportStringPropertyAttribute(
+					OAttributeMetaData::getFormAttributeNamespace(eStringPropertyIds[i]),
+					OAttributeMetaData::getFormAttributeName(eStringPropertyIds[i]),
+					aStringPropertyNames[i]);
+			// now export the data source name or databaselocation or connection resource
+			::rtl::OUString sPropValue;
+			m_xProps->getPropertyValue( PROPERTY_DATASOURCENAME ) >>= sPropValue;
+            m_bCreateConnectionResourceElement = !sPropValue.getLength();
+			if ( !m_bCreateConnectionResourceElement )
+			{
+				INetURLObject aURL(sPropValue);
+                m_bCreateConnectionResourceElement = ( aURL.GetProtocol() == INET_PROT_FILE );
+				if ( !m_bCreateConnectionResourceElement )
+					exportStringPropertyAttribute(
+						OAttributeMetaData::getFormAttributeNamespace(faDatasource),
+						OAttributeMetaData::getFormAttributeName(faDatasource),
+						PROPERTY_DATASOURCENAME);
+			}
+			else
+				exportedProperty(PROPERTY_URL);
+			if ( m_bCreateConnectionResourceElement )
+				exportedProperty(PROPERTY_DATASOURCENAME);
+		}
+
+		// ----------------------
+		// the boolean properties
+		{
+			static FormAttributes eBooleanPropertyIds[] =
+			{
+				faAllowDeletes, faAllowInserts, faAllowUpdates, faApplyFilter, faEscapeProcessing, faIgnoreResult
+			};
+			static const ::rtl::OUString* pBooleanPropertyNames[] =
+			{
+				&PROPERTY_ALLOWDELETES, &PROPERTY_ALLOWINSERTS, &PROPERTY_ALLOWUPDATES, &PROPERTY_APPLYFILTER, &PROPERTY_ESCAPEPROCESSING, &PROPERTY_IGNORERESULT
+			};
+			static sal_Int8 nBooleanPropertyAttrFlags[] =
+			{
+				BOOLATTR_DEFAULT_TRUE, BOOLATTR_DEFAULT_TRUE, BOOLATTR_DEFAULT_TRUE, BOOLATTR_DEFAULT_FALSE, BOOLATTR_DEFAULT_TRUE, BOOLATTR_DEFAULT_FALSE
+			};
+			sal_Int32 nIdCount = sizeof(eBooleanPropertyIds) / sizeof(eBooleanPropertyIds[0]);
+		#if OSL_DEBUG_LEVEL > 0
+			sal_Int32 nNameCount = sizeof(pBooleanPropertyNames) / sizeof(pBooleanPropertyNames[0]);
+			sal_Int32 nFlagsCount = sizeof(nBooleanPropertyAttrFlags) / sizeof(nBooleanPropertyAttrFlags[0]);
+			OSL_ENSURE((nIdCount == nNameCount) && (nNameCount == nFlagsCount),
+				"OFormExport::exportAttributes: somebody tampered with the maps (2)!");
+		#endif
+			for (i=0; i<nIdCount; ++i)
+				exportBooleanPropertyAttribute(
+					OAttributeMetaData::getFormAttributeNamespace(eBooleanPropertyIds[i]),
+					OAttributeMetaData::getFormAttributeName(eBooleanPropertyIds[i]),
+					*(pBooleanPropertyNames[i]),
+					nBooleanPropertyAttrFlags[i]
+				);
+		}
+
+		// -------------------
+		// the enum properties
+		{
+			static FormAttributes eEnumPropertyIds[] =
+			{
+				faEnctype, faMethod, faCommandType, faNavigationMode, faTabbingCycle
+			};
+			static const sal_Char* pEnumPropertyNames[] =
+			{
+				PROPERTY_SUBMIT_ENCODING, PROPERTY_SUBMIT_METHOD, PROPERTY_COMMAND_TYPE, PROPERTY_NAVIGATION, PROPERTY_CYCLE
+			};
+			static OEnumMapper::EnumProperties eEnumPropertyMaps[] =
+			{
+				OEnumMapper::epSubmitEncoding, OEnumMapper::epSubmitMethod, OEnumMapper::epCommandType, OEnumMapper::epNavigationType, OEnumMapper::epTabCyle
+			};
+			static sal_Int32 nEnumPropertyAttrDefaults[] =
+			{
+				FormSubmitEncoding_URL, FormSubmitMethod_GET, CommandType::COMMAND, NavigationBarMode_CURRENT, TabulatorCycle_RECORDS
+			};
+			static sal_Bool nEnumPropertyAttrDefaultFlags[] =
+			{
+				sal_False, sal_False, sal_False, sal_False, sal_True
+			};
+			sal_Int32 nIdCount = sizeof(eEnumPropertyIds) / sizeof(eEnumPropertyIds[0]);
+		#if OSL_DEBUG_LEVEL > 0
+			sal_Int32 nNameCount = sizeof(pEnumPropertyNames) / sizeof(pEnumPropertyNames[0]);
+			sal_Int32 nDefaultCount = sizeof(nEnumPropertyAttrDefaults) / sizeof(nEnumPropertyAttrDefaults[0]);
+			sal_Int32 nDefaultFlagCount = sizeof(nEnumPropertyAttrDefaultFlags) / sizeof(nEnumPropertyAttrDefaultFlags[0]);
+			sal_Int32 nMapCount = sizeof(eEnumPropertyMaps) / sizeof(eEnumPropertyMaps[0]);
+			OSL_ENSURE((nIdCount == nNameCount) && (nNameCount == nDefaultCount) && (nDefaultCount == nDefaultFlagCount) && (nDefaultFlagCount == nMapCount),
+				"OFormExport::exportAttributes: somebody tampered with the maps (3)!");
+		#endif
+			for (i=0; i<nIdCount; ++i)
+				exportEnumPropertyAttribute(
+					OAttributeMetaData::getFormAttributeNamespace(eEnumPropertyIds[i]),
+					OAttributeMetaData::getFormAttributeName(eEnumPropertyIds[i]),
+					pEnumPropertyNames[i],
+					OEnumMapper::getEnumMap(eEnumPropertyMaps[i]),
+					nEnumPropertyAttrDefaults[i],
+					nEnumPropertyAttrDefaultFlags[i]
+                );
+		}
+
+		// the service name
+		exportServiceNameAttribute();
+		// the target frame
+		exportTargetFrameAttribute();
+		// the target URL
+		exportTargetLocationAttribute();
+
+		// master fields
+		exportStringSequenceAttribute(
+			OAttributeMetaData::getFormAttributeNamespace(faMasterFields),
+			OAttributeMetaData::getFormAttributeName(faMasterFields),
+			PROPERTY_MASTERFIELDS);
+		// detail fields
+		exportStringSequenceAttribute(
+			OAttributeMetaData::getFormAttributeNamespace(faDetailFiels),
+			OAttributeMetaData::getFormAttributeName(faDetailFiels),
+			PROPERTY_DETAILFIELDS);
+	}
+//.........................................................................
+}	// namespace xmloff
+//.........................................................................
--- toolkit/inc/toolkit/awt/vclxwindow.hxx.orig	1970-01-01 08:00:00.000000000 +0800
+++ toolkit/inc/toolkit/awt/vclxwindow.hxx	2008-04-11 16:49:35.000000000 +0800
@@ -0,0 +1,263 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: vclxwindow.hxx,v $
+ * $Revision: 1.28 $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+
+#ifndef _TOOLKIT_AWT_VCLXWINDOW_HXX_
+#define _TOOLKIT_AWT_VCLXWINDOW_HXX_
+
+#include <toolkit/dllapi.h>
+#include <com/sun/star/awt/XWindow.hpp>
+#include <com/sun/star/awt/XWindow2.hpp>
+#include <com/sun/star/awt/XVclWindowPeer.hpp>
+#include <com/sun/star/awt/XLayoutConstrains.hpp>
+#include <com/sun/star/awt/XView.hpp>
+#include <com/sun/star/awt/XPointer.hpp>
+#include <com/sun/star/awt/XGraphics.hpp>
+#include <com/sun/star/beans/XPropertyChangeListener.hpp>
+#include <com/sun/star/beans/XPropertySetInfo.hpp>
+#include <com/sun/star/accessibility/XAccessible.hpp>
+#include <com/sun/star/accessibility/XAccessibleContext.hpp>
+#include <com/sun/star/awt/XDockableWindow.hpp>
+#include <cppuhelper/weak.hxx>
+#include <osl/mutex.hxx>
+
+#include <toolkit/awt/vclxdevice.hxx>
+#include <toolkit/helper/listenermultiplexer.hxx>
+
+#include <tools/gen.hxx>	// Size
+#include <tools/link.hxx>
+
+#include <stdarg.h>
+#include <list>
+
+class Window;
+class VclSimpleEvent;
+class VclWindowEvent;
+struct AccessibilityInfos;
+struct SystemParentData;
+
+namespace toolkit
+{
+    class IAccessibleFactory;
+}
+
+
+//	----------------------------------------------------
+//	class VCLXWINDOW
+//	----------------------------------------------------
+
+class UnoPropertyArrayHelper;
+class VCLXWindowImpl;
+class TOOLKIT_DLLPUBLIC VCLXWindow :	public ::com::sun::star::awt::XWindow2,
+					public ::com::sun::star::awt::XVclWindowPeer,
+					public ::com::sun::star::awt::XLayoutConstrains,
+					public ::com::sun::star::awt::XView,
+					public ::com::sun::star::awt::XDockableWindow,
+					public ::com::sun::star::accessibility::XAccessible,
+					public ::com::sun::star::lang::XEventListener,
+					public ::com::sun::star::beans::XPropertySetInfo,
+					public VCLXDevice
+{
+private:
+	EventListenerMultiplexer		maEventListeners;
+	FocusListenerMultiplexer		maFocusListeners;
+	WindowListenerMultiplexer		maWindowListeners;
+	KeyListenerMultiplexer			maKeyListeners;
+	MouseListenerMultiplexer		maMouseListeners;
+	MouseMotionListenerMultiplexer	maMouseMotionListeners;
+	PaintListenerMultiplexer		maPaintListeners;
+	VclContainerListenerMultiplexer	maContainerListeners;
+	TopWindowListenerMultiplexer	maTopWindowListeners;
+
+	::com::sun::star::uno::Reference< ::com::sun::star::awt::XPointer>	mxPointer;
+	::com::sun::star::uno::Reference< ::com::sun::star::awt::XGraphics>	mxViewGraphics;
+
+	::com::sun::star::uno::Reference< ::com::sun::star::accessibility::XAccessibleContext > mxAccessibleContext;
+	::com::sun::star::uno::Reference< ::com::sun::star::awt::XDockableWindowListener> mxDockableWindowListener;
+
+	ULONG                           mnListenerLockLevel;
+	ULONG                           nDummy2;
+    VCLXWindowImpl*                 mpImpl;
+    UnoPropertyArrayHelper         *mpPropHelper;
+
+
+	sal_Bool						mbDisposing : 1;
+	sal_Bool						mbDesignMode : 1;
+	sal_Bool						mbSynthesizingVCLEvent : 1;
+    sal_Bool                        mbWithDefaultProps : 1;
+	sal_Bool						mbDrawingOntoParent;
+
+    UnoPropertyArrayHelper *GetPropHelper();
+	
+protected:
+	Size			ImplCalcWindowSize( const Size& rOutSz ) const;
+	DECL_LINK(      WindowEventListener, VclSimpleEvent* );
+
+	virtual void    ProcessWindowEvent( const VclWindowEvent& rVclWindowEvent );
+	virtual ::com::sun::star::uno::Reference< ::com::sun::star::accessibility::XAccessibleContext >
+					CreateAccessibleContext();
+
+    void            SetSynthesizingVCLEvent( sal_Bool b )   { mbSynthesizingVCLEvent = b; }
+    BOOL            IsSynthesizingVCLEvent() const          { return mbSynthesizingVCLEvent; }
+    void 	    SetSystemParent_Impl( const com::sun::star::uno::Any& rHandle );
+
+    ::toolkit::IAccessibleFactory&  getAccessibleFactory();
+
+    // helper ...
+    static void     PushPropertyIds( std::list< sal_uInt16 > &aIds, int nFirstId, ...);
+    // for use in controls/
+    static void     ImplGetPropertyIds( std::list< sal_uInt16 > &aIds,
+                                        bool bWithDefaults = false );
+    virtual void    GetPropertyIds( std::list< sal_uInt16 > &aIds )
+        { return ImplGetPropertyIds( aIds, mbWithDefaultProps ); }
+
+public:
+	VCLXWindow( bool bWithDefaultProps = false );
+	~VCLXWindow();
+
+	virtual void	SetWindow( Window* pWindow );
+	Window*			GetWindow() const 									{ return (Window*)GetOutputDevice(); }
+	::com::sun::star::uno::Reference< ::com::sun::star::awt::XGraphics>	GetViewGraphics() const	{ return mxViewGraphics; }
+
+    void    suspendVclEventListening( );
+    void    resumeVclEventListening( );
+
+	EventListenerMultiplexer&		GetEventListeners()		{ return maEventListeners; }
+	FocusListenerMultiplexer&		GetFocusListeners()		{ return maFocusListeners; }
+	WindowListenerMultiplexer&		GetWindowListeners() 	{ return maWindowListeners; }
+	KeyListenerMultiplexer&			GetKeyListeners() 		{ return maKeyListeners; }
+	MouseListenerMultiplexer&		GetMouseListeners() 	{ return maMouseListeners; }
+	MouseMotionListenerMultiplexer&	GetMouseMotionListeners() { return maMouseMotionListeners; }
+	PaintListenerMultiplexer&		GetPaintListeners() 	{ return maPaintListeners; }
+	VclContainerListenerMultiplexer& GetContainerListeners() { return maContainerListeners; }
+	TopWindowListenerMultiplexer&	GetTopWindowListeners()	{ return maTopWindowListeners; }
+
+	// ::com::sun::star::uno::XInterface
+    ::com::sun::star::uno::Any	SAL_CALL queryInterface( const ::com::sun::star::uno::Type & rType ) throw(::com::sun::star::uno::RuntimeException);
+	void						SAL_CALL acquire() throw()	{ OWeakObject::acquire(); }
+	void						SAL_CALL release() throw()	{ OWeakObject::release(); }
+
+	// ::com::sun::star::lang::XUnoTunnel
+	static const ::com::sun::star::uno::Sequence< sal_Int8 >&	GetUnoTunnelId() throw();
+	static VCLXWindow*											GetImplementation( const ::com::sun::star::uno::Reference< ::com::sun::star::uno::XInterface >& rxIFace ) throw();
+	sal_Int64													SAL_CALL getSomething( const ::com::sun::star::uno::Sequence< sal_Int8 >& rIdentifier ) throw(::com::sun::star::uno::RuntimeException);
+
+	// ::com::sun::star::lang::XTypeProvider
+	::com::sun::star::uno::Sequence< ::com::sun::star::uno::Type >	SAL_CALL getTypes() throw(::com::sun::star::uno::RuntimeException);
+	::com::sun::star::uno::Sequence< sal_Int8 >						SAL_CALL getImplementationId() throw(::com::sun::star::uno::RuntimeException);
+
+
+	// ::com::sun::star::lang::XEventListener
+    virtual void SAL_CALL disposing( const ::com::sun::star::lang::EventObject& Source ) throw (::com::sun::star::uno::RuntimeException);
+
+	// ::com::sun::star::lang::XComponent
+    void SAL_CALL dispose(  ) throw(::com::sun::star::uno::RuntimeException);
+    void SAL_CALL addEventListener( const ::com::sun::star::uno::Reference< ::com::sun::star::lang::XEventListener >& rxListener ) throw(::com::sun::star::uno::RuntimeException);
+    void SAL_CALL removeEventListener( const ::com::sun::star::uno::Reference< ::com::sun::star::lang::XEventListener >& rxListener ) throw(::com::sun::star::uno::RuntimeException);
+
+	// ::com::sun::star::awt::XWindow
+	void SAL_CALL setPosSize( sal_Int32 X, sal_Int32 Y, sal_Int32 Width, sal_Int32 Height, sal_Int16 Flags ) throw(::com::sun::star::uno::RuntimeException);
+	::com::sun::star::awt::Rectangle SAL_CALL getPosSize(  ) throw(::com::sun::star::uno::RuntimeException);
+	void SAL_CALL setVisible( sal_Bool Visible ) throw(::com::sun::star::uno::RuntimeException);
+	void SAL_CALL setEnable( sal_Bool Enable ) throw(::com::sun::star::uno::RuntimeException);
+	void SAL_CALL setFocus(  ) throw(::com::sun::star::uno::RuntimeException);
+	void SAL_CALL addWindowListener( const ::com::sun::star::uno::Reference< ::com::sun::star::awt::XWindowListener >& rrxListener ) throw(::com::sun::star::uno::RuntimeException);
+	void SAL_CALL removeWindowListener( const ::com::sun::star::uno::Reference< ::com::sun::star::awt::XWindowListener >& rrxListener ) throw(::com::sun::star::uno::RuntimeException);
+	void SAL_CALL addFocusListener( const ::com::sun::star::uno::Reference< ::com::sun::star::awt::XFocusListener >& rrxListener ) throw(::com::sun::star::uno::RuntimeException);
+	void SAL_CALL removeFocusListener( const ::com::sun::star::uno::Reference< ::com::sun::star::awt::XFocusListener >& rrxListener ) throw(::com::sun::star::uno::RuntimeException);
+	void SAL_CALL addKeyListener( const ::com::sun::star::uno::Reference< ::com::sun::star::awt::XKeyListener >& rrxListener ) throw(::com::sun::star::uno::RuntimeException);
+	void SAL_CALL removeKeyListener( const ::com::sun::star::uno::Reference< ::com::sun::star::awt::XKeyListener >& rrxListener ) throw(::com::sun::star::uno::RuntimeException);
+	void SAL_CALL addMouseListener( const ::com::sun::star::uno::Reference< ::com::sun::star::awt::XMouseListener >& rrxListener ) throw(::com::sun::star::uno::RuntimeException);
+	void SAL_CALL removeMouseListener( const ::com::sun::star::uno::Reference< ::com::sun::star::awt::XMouseListener >& rrxListener ) throw(::com::sun::star::uno::RuntimeException);
+	void SAL_CALL addMouseMotionListener( const ::com::sun::star::uno::Reference< ::com::sun::star::awt::XMouseMotionListener >& rrxListener ) throw(::com::sun::star::uno::RuntimeException);
+	void SAL_CALL removeMouseMotionListener( const ::com::sun::star::uno::Reference< ::com::sun::star::awt::XMouseMotionListener >& rrxListener ) throw(::com::sun::star::uno::RuntimeException);
+	void SAL_CALL addPaintListener( const ::com::sun::star::uno::Reference< ::com::sun::star::awt::XPaintListener >& rrxListener ) throw(::com::sun::star::uno::RuntimeException);
+	void SAL_CALL removePaintListener( const ::com::sun::star::uno::Reference< ::com::sun::star::awt::XPaintListener >& rrxListener ) throw(::com::sun::star::uno::RuntimeException);
+
+	// ::com::sun::star::awt::XWindowPeer
+    ::com::sun::star::uno::Reference< ::com::sun::star::awt::XToolkit > SAL_CALL getToolkit(  ) throw(::com::sun::star::uno::RuntimeException);
+    void SAL_CALL setPointer( const ::com::sun::star::uno::Reference< ::com::sun::star::awt::XPointer >& Pointer ) throw(::com::sun::star::uno::RuntimeException);
+    void SAL_CALL setBackground( sal_Int32 Color ) throw(::com::sun::star::uno::RuntimeException);
+    void SAL_CALL invalidate( sal_Int16 Flags ) throw(::com::sun::star::uno::RuntimeException);
+    void SAL_CALL invalidateRect( const ::com::sun::star::awt::Rectangle& Rect, sal_Int16 Flags ) throw(::com::sun::star::uno::RuntimeException);
+
+	// ::com::sun::star::awt::XVclWindowPeer
+    sal_Bool SAL_CALL isChild( const ::com::sun::star::uno::Reference< ::com::sun::star::awt::XWindowPeer >& Peer ) throw(::com::sun::star::uno::RuntimeException);
+    void SAL_CALL setDesignMode( sal_Bool bOn ) throw(::com::sun::star::uno::RuntimeException);
+    sal_Bool SAL_CALL isDesignMode(  ) throw(::com::sun::star::uno::RuntimeException);
+    void SAL_CALL enableClipSiblings( sal_Bool bClip ) throw(::com::sun::star::uno::RuntimeException);
+    void SAL_CALL setForeground( sal_Int32 Color ) throw(::com::sun::star::uno::RuntimeException);
+    void SAL_CALL setControlFont( const ::com::sun::star::awt::FontDescriptor& aFont ) throw(::com::sun::star::uno::RuntimeException);
+    void SAL_CALL getStyles( sal_Int16 nType, ::com::sun::star::awt::FontDescriptor& Font, sal_Int32& ForegroundColor, sal_Int32& BackgroundColor ) throw(::com::sun::star::uno::RuntimeException);
+    void SAL_CALL setProperty( const ::rtl::OUString& PropertyName, const ::com::sun::star::uno::Any& Value ) throw(::com::sun::star::uno::RuntimeException);
+    ::com::sun::star::uno::Any SAL_CALL getProperty( const ::rtl::OUString& PropertyName ) throw(::com::sun::star::uno::RuntimeException);
+
+	// ::com::sun::star::awt::XLayoutConstrains
+    ::com::sun::star::awt::Size SAL_CALL getMinimumSize(  ) throw(::com::sun::star::uno::RuntimeException);
+    ::com::sun::star::awt::Size SAL_CALL getPreferredSize(  ) throw(::com::sun::star::uno::RuntimeException);
+    ::com::sun::star::awt::Size SAL_CALL calcAdjustedSize( const ::com::sun::star::awt::Size& aNewSize ) throw(::com::sun::star::uno::RuntimeException);
+
+	// ::com::sun::star::awt::XView
+    sal_Bool SAL_CALL setGraphics( const ::com::sun::star::uno::Reference< ::com::sun::star::awt::XGraphics >& aDevice ) throw(::com::sun::star::uno::RuntimeException);
+    ::com::sun::star::uno::Reference< ::com::sun::star::awt::XGraphics > SAL_CALL getGraphics(  ) throw(::com::sun::star::uno::RuntimeException);
+    ::com::sun::star::awt::Size SAL_CALL getSize(  ) throw(::com::sun::star::uno::RuntimeException);
+    void SAL_CALL draw( sal_Int32 nX, sal_Int32 nY ) throw(::com::sun::star::uno::RuntimeException);
+    void SAL_CALL setZoom( float fZoomX, float fZoomY ) throw(::com::sun::star::uno::RuntimeException);
+
+	// ::com::sun::star::accessibility::XAccessible
+    ::com::sun::star::uno::Reference< ::com::sun::star::accessibility::XAccessibleContext > SAL_CALL getAccessibleContext(  ) throw (::com::sun::star::uno::RuntimeException);
+
+	// ::com::sun::star::awt::XDockableWindow
+    void SAL_CALL addDockableWindowListener( const ::com::sun::star::uno::Reference< ::com::sun::star::awt::XDockableWindowListener >& xListener ) throw (::com::sun::star::uno::RuntimeException);
+    void SAL_CALL removeDockableWindowListener( const ::com::sun::star::uno::Reference< ::com::sun::star::awt::XDockableWindowListener >& xListener ) throw (::com::sun::star::uno::RuntimeException);
+    void SAL_CALL enableDocking( sal_Bool bEnable ) throw (::com::sun::star::uno::RuntimeException);
+    sal_Bool SAL_CALL isFloating(  ) throw (::com::sun::star::uno::RuntimeException);
+    void SAL_CALL setFloatingMode( sal_Bool bFloating ) throw (::com::sun::star::uno::RuntimeException);
+    void SAL_CALL lock(  ) throw (::com::sun::star::uno::RuntimeException);
+    void SAL_CALL unlock(  ) throw (::com::sun::star::uno::RuntimeException);
+    sal_Bool SAL_CALL isLocked(  ) throw (::com::sun::star::uno::RuntimeException);
+    void SAL_CALL startPopupMode( const ::com::sun::star::awt::Rectangle& WindowRect ) throw (::com::sun::star::uno::RuntimeException);
+    sal_Bool SAL_CALL isInPopupMode(  ) throw (::com::sun::star::uno::RuntimeException);
+
+	// ::com::sun::star::awt::XWindow2
+    void SAL_CALL setOutputSize( const ::com::sun::star::awt::Size& aSize ) throw (::com::sun::star::uno::RuntimeException);
+    ::com::sun::star::awt::Size SAL_CALL getOutputSize(  ) throw (::com::sun::star::uno::RuntimeException);
+    sal_Bool SAL_CALL isVisible(  ) throw (::com::sun::star::uno::RuntimeException);
+    sal_Bool SAL_CALL isActive(  ) throw (::com::sun::star::uno::RuntimeException);
+    sal_Bool SAL_CALL isEnabled(  ) throw (::com::sun::star::uno::RuntimeException);
+    sal_Bool SAL_CALL hasFocus(  ) throw (::com::sun::star::uno::RuntimeException);
+
+    // ::com::sun::star::beans::XPropertySetInfo
+    ::com::sun::star::uno::Sequence< ::com::sun::star::beans::Property > SAL_CALL getProperties(  ) throw (::com::sun::star::uno::RuntimeException);
+    ::com::sun::star::beans::Property SAL_CALL getPropertyByName( const ::rtl::OUString& aName ) throw (::com::sun::star::beans::UnknownPropertyException, ::com::sun::star::uno::RuntimeException);
+    ::sal_Bool SAL_CALL hasPropertyByName( const ::rtl::OUString& Name ) throw (::com::sun::star::uno::RuntimeException);
+};
+
+#endif // _TOOLKIT_AWT_VCLXWINDOW_HXX_
+
--- toolkit/inc/toolkit/helper/property.hxx.orig	2008-05-20 22:32:24.000000000 +0800
+++ toolkit/inc/toolkit/helper/property.hxx	2008-06-04 12:39:56.000000000 +0800
@@ -188,6 +188,7 @@ namespace rtl {
 #define BASEPROPERTY_URL                            134  // ::rtl::OUString
 #define BASEPROPERTY_UNIT                           135  // ::awt::FieldUnit
 #define BASEPROPERTY_CUSTOMUNITTEXT                 136  // ::rtl::OUString
+#define BASEPROPERTY_VISIBLE                        137  // sal_Bool
 
 // Keine gebundenen Properties, werden immer aus der Property BASEPROPERTY_FONTDESCRIPTOR entnommen.
 #define BASEPROPERTY_FONTDESCRIPTORPART_START			1000
--- toolkit/source/helper/property.cxx.orig	2008-04-11 17:36:59.000000000 +0800
+++ toolkit/source/helper/property.cxx	2008-06-04 12:38:12.000000000 +0800
@@ -269,7 +269,8 @@ ImplPropertyInfo* ImplGetPropertyInfos( 
 			DECL_PROP_3		( "RowHeight",				TREE_ROWHEIGHT,			sal_Int32,			BOUND, MAYBEDEFAULT, MAYBEVOID ),
 			DECL_PROP_2		( "InvokesStopNodeEditing",	TREE_INVOKESSTOPNODEEDITING, sal_Bool,		BOUND, MAYBEDEFAULT ),
             DECL_PROP_2     ( "DialogSourceURL",        DIALOGSOURCEURL,        ::rtl::OUString,    BOUND, MAYBEDEFAULT ),
-            DECL_PROP_2     ( "URL",                    URL,                    ::rtl::OUString,    BOUND, MAYBEDEFAULT )
+            DECL_PROP_2     ( "URL",                    URL,                    ::rtl::OUString,    BOUND, MAYBEDEFAULT ),
+            DECL_PROP_2     ( "EnableVisible",          ENABLEVISIBLE,          sal_Bool,    BOUND, MAYBEDEFAULT )
             };
 			pPropertyInfos = aImplPropertyInfos;
 			nElements = sizeof( aImplPropertyInfos ) / sizeof( ImplPropertyInfo );
--- toolkit/source/awt/vclxwindow.cxx.orig	2008-05-14 17:47:01.000000000 +0800
+++ toolkit/source/awt/vclxwindow.cxx	2008-06-04 12:38:12.000000000 +0800
@@ -207,6 +207,8 @@ private:
     ::vos::IMutex&                      mrMutex;
     ::toolkit::AccessibilityClient      maAccFactory;
     bool                                mbDisposed;
+    sal_Bool                            mbEnableVisible;
+    sal_Bool                            mbDirectVisible;
     ::osl::Mutex                        maListenerContainerMutex;
     ::cppu::OInterfaceContainerHelper   maWindow2Listeners;
 
@@ -228,6 +230,15 @@ public:
     */
     VCLXWindowImpl( VCLXWindow& _rAntiImpl, ::vos::IMutex& _rMutex );
 
+    /** synchronously mbEnableVisible
+    */
+    void    setEnableVisible( sal_Bool bEnableVisible ) { mbEnableVisible = bEnableVisible; }
+    sal_Bool    isEnableVisible() { return mbEnableVisible; }
+    /** synchronously mbDirectVisible;
+    */
+    void    setDirectVisible( sal_Bool bDirectVisible ) { mbDirectVisible = bDirectVisible; }
+    sal_Bool    isDirectVisible() { return mbDirectVisible; }
+
     /** asynchronously notifies a mouse event to the VCLXWindow's XMouseListeners
     */
     void    notifyMouseEvent( const awt::MouseEvent& _rMouseEvent, MouseEventType _nType );
@@ -298,6 +309,8 @@ VCLXWindowImpl::VCLXWindowImpl( VCLXWind
     ,mrAntiImpl( _rAntiImpl )
     ,mrMutex( _rMutex )
     ,mbDisposed( false )
+    ,mbEnableVisible(sal_True)
+    ,mbDirectVisible(sal_True)
     ,maListenerContainerMutex( )
     ,maWindow2Listeners( maListenerContainerMutex )
 #ifdef THREADED_NOTIFICATION
@@ -600,7 +613,12 @@ void VCLXWindow::SetWindow( Window* pWin
     SetOutputDevice( pWindow );
 
     if ( GetWindow() )
+    {
         GetWindow()->AddEventListener( LINK( this, VCLXWindow, WindowEventListener ) );
+        sal_Bool bDirectVisible = pWindow ? pWindow->IsVisible() : sal_False;
+        mpImpl->setDirectVisible( bDirectVisible );
+    }
+    
 }
 
 void VCLXWindow::suspendVclEventListening( )
@@ -1223,7 +1241,13 @@ void VCLXWindow::setVisible( sal_Bool bV
 			}
 		}
 */
-		pWindow->Show( bVisible );
+        if( mpImpl->isEnableVisible() )
+        {
+            mpImpl->setDirectVisible( bVisible );
+		    pWindow->Show( bVisible );
+        }
+        else
+            pWindow->Show( sal_False );
 	}
 }
 
@@ -1537,6 +1561,7 @@ void VCLXWindow::ImplGetPropertyIds( std
                          BASEPROPERTY_HELPURL,
                          BASEPROPERTY_TEXT,
                          BASEPROPERTY_PRINTABLE,
+                         BASEPROPERTY_ENABLEVISIBLE, // for visibility
                          BASEPROPERTY_TABSTOP,
                          0);
 
@@ -1610,6 +1635,23 @@ void VCLXWindow::setProperty( const ::rt
 					setEnable( b );
 			}
 			break;
+            case BASEPROPERTY_ENABLEVISIBLE:
+            {
+                sal_Bool b = sal_Bool();
+                if ( Value >>= b )
+                {
+                    if( b != mpImpl->isEnableVisible() )
+                    {
+                        mpImpl->setEnableVisible( b );
+                        // if mbEnableVisible change from false to true.
+                        // it will ignore the mbDirectVisible, setVisilbe
+                        // and set mbDirectVisible as true.
+                        if( mpImpl->isDirectVisible() || b )
+                            setVisible( b );
+                    }
+                }
+            }
+            break;
 			case BASEPROPERTY_TEXT:
 			case BASEPROPERTY_LABEL:
 			case BASEPROPERTY_TITLE:
@@ -2068,6 +2110,10 @@ void VCLXWindow::setProperty( const ::rt
 				aProp <<= (sal_Bool) GetWindow()->IsEnabled();
 			    break;
 
+			case BASEPROPERTY_ENABLEVISIBLE:
+				aProp <<= (sal_Bool) GetWindow()->IsVisible();
+			    break;
+
 			case BASEPROPERTY_TEXT:
 			case BASEPROPERTY_LABEL:
 			case BASEPROPERTY_TITLE:
@@ -2374,8 +2420,8 @@ void VCLXWindow::draw( sal_Int32 nX, sal
 	Window* pWindow = GetWindow();
     if ( !pWindow )
         return;
-
-	if ( pWindow )
+    
+	if ( pWindow && mpImpl->isEnableVisible() )
 	{
 		TabPage* pTabPage = dynamic_cast< TabPage* >( pWindow );
         if ( pTabPage )
--- toolkit/source/controls/unocontrolmodel.cxx.orig	2008-04-11 17:32:33.000000000 +0800
+++ toolkit/source/controls/unocontrolmodel.cxx	2008-06-04 12:38:12.000000000 +0800
@@ -338,6 +338,7 @@ void UnoControlModel::ImplPropertyChange
             case BASEPROPERTY_SCALEIMAGE:
             case BASEPROPERTY_ENABLED:
             case BASEPROPERTY_PRINTABLE:
+            case BASEPROPERTY_ENABLEVISIBLE:
             case BASEPROPERTY_DECORATION:           aDefault <<= (sal_Bool) sal_True; break;
 
             case BASEPROPERTY_HELPTEXT:
--- toolkit/source/controls/unocontrol.cxx.orig	1970-01-01 08:00:00.000000000 +0800
+++ toolkit/source/controls/unocontrol.cxx	2008-06-04 12:38:12.000000000 +0800
@@ -0,0 +1,1534 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: unocontrol.cxx,v $
+ * $Revision: 1.54 $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+
+// MARKER(update_precomp.py): autogen include statement, do not remove
+#include "precompiled_toolkit.hxx"
+#include <com/sun/star/awt/XControlContainer.hpp>
+#include <com/sun/star/awt/WindowAttribute.hpp>
+#include <com/sun/star/awt/VclWindowPeerAttribute.hpp>
+#include <com/sun/star/awt/PosSize.hpp>
+#ifndef _COM_SUN_STAR_LAN_XMULTISERVICEFACTORY_HPP_
+#include <com/sun/star/lang/XMultiServiceFactory.hpp>
+#endif
+#include <com/sun/star/beans/PropertyValue.hpp>
+#include <com/sun/star/resource/XStringResourceResolver.hpp>
+#include <toolkit/controls/unocontrol.hxx>
+#include <toolkit/helper/vclunohelper.hxx>
+#include <cppuhelper/typeprovider.hxx>
+#include <rtl/memory.h>
+#include <rtl/uuid.h>
+#include <vos/mutex.hxx>
+#include <tools/string.hxx>
+#include <tools/table.hxx>
+#include <tools/date.hxx>
+#include <tools/time.hxx>
+#include <tools/urlobj.hxx>
+#include <tools/debug.hxx>
+#include <vcl/svapp.hxx>
+#include <vcl/wrkwin.hxx>
+#include <comphelper/stl_types.hxx>
+#include <toolkit/helper/property.hxx>
+#include <toolkit/helper/servicenames.hxx>
+#include <toolkit/helper/vclunohelper.hxx>
+#include <toolkit/awt/vclxwindow.hxx>
+#include <vcl/svapp.hxx>
+#include <vos/mutex.hxx>
+#include <toolkit/controls/accessiblecontrolcontext.hxx>
+#include <comphelper/container.hxx>
+
+#include <algorithm>
+#include <set>
+
+using namespace ::com::sun::star;
+using namespace ::com::sun::star::uno;
+using namespace ::com::sun::star::awt;
+using namespace ::com::sun::star::beans;
+using namespace ::com::sun::star::lang;
+using namespace ::com::sun::star::util;
+
+using ::com::sun::star::accessibility::XAccessibleContext;
+using ::com::sun::star::accessibility::XAccessible;
+
+struct LanguageDependentProp
+{
+    const char* pPropName;
+    sal_Int32   nPropNameLength;
+};
+
+static const LanguageDependentProp aLanguageDependentProp[] =
+{
+    { "Text",            4 },
+    { "Label",           5 },
+    { "Title",           5 },
+    { "HelpText",        8 },
+    { "CurrencySymbol", 14 },
+    { "StringItemList", 14 },
+    { 0, 0                 }
+};
+
+WorkWindow* lcl_GetDefaultWindow()
+{
+	static WorkWindow* pW = NULL;
+	if ( !pW )
+    {
+		pW = new WorkWindow( NULL, 0 );
+        pW->EnableChildTransparentMode();
+    }
+	return pW;
+}
+
+static Sequence< ::rtl::OUString> lcl_ImplGetPropertyNames( const Reference< XMultiPropertySet > & rxModel )
+{
+	Sequence< ::rtl::OUString> aNames;
+	Reference< XPropertySetInfo >  xPSInf = rxModel->getPropertySetInfo();
+	DBG_ASSERT( xPSInf.is(), "UpdateFromModel: No PropertySetInfo!" );
+	if ( xPSInf.is() ) 
+	{	
+		Sequence< Property> aProps = xPSInf->getProperties();
+		sal_Int32 nLen = aProps.getLength();
+		aNames = Sequence< ::rtl::OUString>( nLen );
+		::rtl::OUString* pNames = aNames.getArray();
+		const Property* pProps = aProps.getConstArray();
+		for ( sal_Int32 n = 0; n < nLen; ++n, ++pProps, ++pNames)
+			*pNames = pProps->Name;
+	}
+	return aNames;
+}
+
+//	====================================================
+class VclListenerLock
+{
+private:
+    VCLXWindow*  m_pLockWindow;
+
+public:
+    inline VclListenerLock( VCLXWindow* _pLockWindow )
+        :m_pLockWindow( _pLockWindow )
+    {
+//        DBG_ASSERT( m_pLockWindow, "VclListenerLock::VclListenerLock: invalid window!" );
+		if ( m_pLockWindow )
+			m_pLockWindow->suspendVclEventListening( );
+    }
+    inline ~VclListenerLock( )
+    {
+		if ( m_pLockWindow )
+			m_pLockWindow->resumeVclEventListening( );
+    }
+
+private:
+    VclListenerLock();                                          // never implemented
+    VclListenerLock( const VclListenerLock& );              // never implemented
+    VclListenerLock& operator=( const VclListenerLock& );   // never implemented
+};
+
+struct UnoControl_Data
+{
+    ::std::set< ::rtl::OUString >   aPropertyNotificationFilter;
+};
+
+//	----------------------------------------------------
+//	class UnoControl
+//	----------------------------------------------------
+DBG_NAME( UnoControl )
+UnoControl::UnoControl()
+	: maDisposeListeners( *this )
+	, maWindowListeners( *this )
+	, maFocusListeners( *this )
+	, maKeyListeners( *this )
+	, maMouseListeners( *this )
+	, maMouseMotionListeners( *this )
+	, maPaintListeners( *this )
+	, maModeChangeListeners( GetMutex() )
+    , mpData( new UnoControl_Data )
+{
+    DBG_CTOR( UnoControl, NULL );
+	mbDisposePeer = sal_True;
+	mbRefeshingPeer = sal_False;
+	mbCreatingPeer = sal_False;
+	mbCreatingCompatiblePeer = sal_False;
+	mbDesignMode = sal_False;
+}
+
+UnoControl::~UnoControl()
+{
+    DELETEZ( mpData );
+    DBG_DTOR( UnoControl, NULL );
+}
+
+::rtl::OUString UnoControl::GetComponentServiceName()
+{
+	return ::rtl::OUString();
+}
+
+Reference< XWindowPeer >	UnoControl::ImplGetCompatiblePeer( sal_Bool bAcceptExistingPeer )
+{
+	DBG_ASSERT( !mbCreatingCompatiblePeer, "ImplGetCompatiblePeer - rekursive?" );
+
+	mbCreatingCompatiblePeer = sal_True;
+
+	Reference< XWindowPeer > xCompatiblePeer;
+
+	if ( bAcceptExistingPeer )
+		xCompatiblePeer = getPeer();
+
+	if ( !xCompatiblePeer.is() )
+	{
+		// Peer unsichtbar erzeugen...
+		sal_Bool bVis = maComponentInfos.bVisible;
+		if( bVis )
+			maComponentInfos.bVisible = sal_False;
+
+		Reference< XWindowPeer >	xCurrentPeer = getPeer();
+		setPeer( NULL );
+
+		// queryInterface ourself, to allow aggregation
+		Reference< XControl > xMe;
+		OWeakAggObject::queryInterface( ::getCppuType( &xMe ) ) >>= xMe;
+
+		WorkWindow* pWW;
+		{
+		    osl::Guard< vos::IMutex > aGuard( Application::GetSolarMutex() );
+		    pWW = lcl_GetDefaultWindow();
+		}
+        try
+        {
+		    xMe->createPeer( NULL, pWW->GetComponentInterface( sal_True ) );
+        }
+        catch( const Exception& )
+        {
+	        mbCreatingCompatiblePeer = sal_False;
+            throw;
+        }
+		xCompatiblePeer = getPeer();
+		setPeer( xCurrentPeer );
+
+        if ( xCompatiblePeer.is() && mxGraphics.is() )
+        {
+            Reference< XView > xPeerView( xCompatiblePeer, UNO_QUERY );
+            if ( xPeerView.is() )
+                xPeerView->setGraphics( mxGraphics );
+        }
+
+		if( bVis )
+			maComponentInfos.bVisible = sal_True;
+	}
+
+	mbCreatingCompatiblePeer = sal_False;
+
+	return xCompatiblePeer;
+}
+
+bool UnoControl::ImplMapPlaceHolder( ::rtl::OUString& rPlaceHolder )
+{
+    rtl::OUString aMappedValue;
+
+	Reference< XPropertySet > xPropSet( mxModel, UNO_QUERY );
+    if ( xPropSet.is() )
+    {
+        Any a;
+        Reference< resource::XStringResourceResolver > xStringResourceResolver;
+        a = xPropSet->getPropertyValue( ::rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "ResourceResolver" )));
+        if ( a >>= xStringResourceResolver )
+        {
+            if ( xStringResourceResolver.is() )
+            {
+                try
+                {
+                    rPlaceHolder = xStringResourceResolver->resolveString( rPlaceHolder );
+                    return true;
+                }
+                catch ( resource::MissingResourceException& )
+                {
+                    return false;
+                }
+            }
+        }
+    }
+
+    return false;
+}
+
+void UnoControl::ImplSetPeerProperty( const ::rtl::OUString& rPropName, const Any& rVal )
+{
+    // since a change made in propertiesChange, we can't be sure that this is called with an valid getPeer(),
+	// this assumption may be false in some (seldom) multi-threading scenarios (cause propertiesChange
+	// releases our mutex before calling here in)
+	// That's why this additional check
+	
+    if ( mxVclWindowPeer.is() )
+    {
+		Any aVal( rVal );
+        
+        // We now support a mapping for language dependent properties. This is the
+        // central method to implement it.
+        if (( rPropName.equalsAsciiL( "Text",            4 )) ||
+            ( rPropName.equalsAsciiL( "Label",           5 )) ||
+            ( rPropName.equalsAsciiL( "Title",           5 )) ||
+            ( rPropName.equalsAsciiL( "HelpText",        8 )) ||
+            ( rPropName.equalsAsciiL( "CurrencySymbol", 14 )) ||
+            ( rPropName.equalsAsciiL( "StringItemList", 14 )) )
+        {
+            rtl::OUString aValue;
+            uno::Sequence< rtl::OUString > aSeqValue;
+
+            if ( aVal >>= aValue )
+            {
+                // Map single string value
+                if (( aValue.getLength() > 0 ) && 
+                    ( aValue.compareToAscii( "&", 1 ) == 0 ))
+                {
+                    // Magic symbol '&' found at first place. Interpret as a place
+                    // holder identifier. Now try to map it to the real value. The
+                    // magic symbol must be removed.
+                    rtl::OUString aKeyValue( aValue.copy( 1 ));
+                    if ( ImplMapPlaceHolder( aKeyValue ))
+                        aVal <<= aKeyValue;
+                }
+            }
+            else if ( aVal >>= aSeqValue )
+            {
+                // Map sequence strings
+                for ( sal_Int32 i = 0; i < aSeqValue.getLength(); i++ )
+                {
+                    aValue = aSeqValue[i];
+                    if (( aValue.getLength() > 0 ) && 
+                        ( aValue.compareToAscii( "&", 1 ) == 0 ))
+                    {
+                        // Magic symbol '&' found at first place. Interpret as a place
+                        // holder identifier. Now try to map it to the real value. The
+                        // magic symbol must be removed.
+                        rtl::OUString aKeyValue( aValue.copy( 1 ));
+                        if ( ImplMapPlaceHolder( aKeyValue ))
+                            aSeqValue[i] = aKeyValue;
+                    }
+                }
+                aVal <<= aSeqValue;
+            }
+        }
+        
+		mxVclWindowPeer->setProperty( rPropName, aVal );
+    }
+}
+
+void UnoControl::PrepareWindowDescriptor( WindowDescriptor& )
+{
+}
+
+Reference< XWindow >	UnoControl::getParentPeer() const
+{
+	Reference< XWindow > xPeer;
+	if( mxContext.is() )
+	{
+		Reference< XControl > xContComp( mxContext, UNO_QUERY );
+		if ( xContComp.is() )
+		{
+			Reference< XWindowPeer > xP = xContComp->getPeer();
+			if ( xP.is() )
+				xP->queryInterface( ::getCppuType((const Reference< XWindow >*)0) ) >>= xPeer;
+		}
+	}
+	return xPeer;
+}
+
+void UnoControl::updateFromModel()
+{
+	// Alle standard Properties werden ausgelesen und in das Peer uebertragen
+	if( getPeer().is() )
+	{
+		Reference< XMultiPropertySet >	xPropSet( mxModel, UNO_QUERY );
+        if( xPropSet.is() )
+        {
+	        Sequence< ::rtl::OUString> aNames = lcl_ImplGetPropertyNames( xPropSet );
+	        xPropSet->firePropertiesChangeEvent( aNames, this );
+        }
+	}
+}
+
+
+// XTypeProvider
+IMPL_IMPLEMENTATION_ID( UnoControl )
+
+void UnoControl::disposeAccessibleContext()
+{
+	Reference< XComponent > xContextComp( maAccessibleContext.get(), UNO_QUERY );
+	if ( xContextComp.is() )
+	{
+		maAccessibleContext = NULL;
+		try
+		{
+			xContextComp->removeEventListener( this );
+			xContextComp->dispose();
+		}
+		catch( const Exception& )
+		{
+			DBG_ERROR( "UnoControl::disposeAccessibleContext: could not dispose my AccessibleContext!" );
+		}
+	}
+}
+
+void UnoControl::dispose(  ) throw(RuntimeException)
+{
+	::osl::MutexGuard aGuard( GetMutex() );
+	
+	if( getPeer().is() && mbDisposePeer )
+	{
+		getPeer()->dispose();
+		setPeer( NULL);
+	}
+
+	// dispose and release our AccessibleContext
+	disposeAccessibleContext();
+
+	EventObject aDisposeEvent;
+	aDisposeEvent.Source = static_cast< XAggregation* >( this );
+
+	maDisposeListeners.disposeAndClear( aDisposeEvent );
+	maWindowListeners.disposeAndClear( aDisposeEvent );
+	maFocusListeners.disposeAndClear( aDisposeEvent );
+	maKeyListeners.disposeAndClear( aDisposeEvent );
+	maMouseListeners.disposeAndClear( aDisposeEvent );
+	maMouseMotionListeners.disposeAndClear( aDisposeEvent );
+	maPaintListeners.disposeAndClear( aDisposeEvent );
+	maModeChangeListeners.disposeAndClear( aDisposeEvent );
+	
+	// Model wieder freigeben
+	setModel( Reference< XControlModel > () );
+	setContext( Reference< XInterface > () );
+}
+
+void UnoControl::addEventListener( const Reference< XEventListener >& rxListener ) throw(RuntimeException)
+{
+	::osl::MutexGuard aGuard( GetMutex() );
+	
+	maDisposeListeners.addInterface( rxListener );
+}
+
+void UnoControl::removeEventListener( const Reference< XEventListener >& rxListener ) throw(RuntimeException)
+{
+	::osl::MutexGuard aGuard( GetMutex() );
+	
+	maDisposeListeners.removeInterface( rxListener );
+}
+
+sal_Bool UnoControl::requiresNewPeer( const ::rtl::OUString& /* _rPropertyName */ ) const
+{
+    return sal_False;
+}
+
+// XPropertiesChangeListener
+void UnoControl::propertiesChange( const Sequence< PropertyChangeEvent >& rEvents ) throw(RuntimeException)
+{
+    Sequence< PropertyChangeEvent > aEvents( rEvents );
+    {
+	    ::osl::MutexGuard aGuard( GetMutex() );
+
+        if ( !mpData->aPropertyNotificationFilter.empty() )
+        {
+            // strip the property which we are currently updating (somewhere up the stack)
+            PropertyChangeEvent* pEvents = aEvents.getArray();
+            PropertyChangeEvent* pEventsEnd = pEvents + aEvents.getLength();
+            for ( ; pEvents < pEventsEnd; )
+                if ( mpData->aPropertyNotificationFilter.find( pEvents->PropertyName ) != mpData->aPropertyNotificationFilter.end() )
+                {
+                    if ( pEvents != pEventsEnd )
+                        ::std::copy( pEvents + 1, pEventsEnd, pEvents );
+                    --pEventsEnd;
+                }
+                else
+                    ++pEvents;
+            aEvents.realloc( pEventsEnd - aEvents.getConstArray() );
+
+            if ( !aEvents.getLength() )
+                return;
+        }
+    }
+
+    ImplModelPropertiesChanged( aEvents );
+}
+	
+void UnoControl::ImplLockPropertyChangeNotification( const ::rtl::OUString& rPropertyName, bool bLock )
+{
+    if ( bLock )
+    {
+        OSL_PRECOND( mpData->aPropertyNotificationFilter.find( rPropertyName ) == mpData->aPropertyNotificationFilter.end(),
+            "UnoControl::ImplLockPropertyChangeNotification: already locked!" );
+        mpData->aPropertyNotificationFilter.insert( rPropertyName );
+    }
+    else
+    {
+        OSL_PRECOND( mpData->aPropertyNotificationFilter.find( rPropertyName ) != mpData->aPropertyNotificationFilter.end(),
+            "UnoControl::ImplLockPropertyChangeNotification: not locked!" );
+        mpData->aPropertyNotificationFilter.erase( rPropertyName );
+    }
+}
+
+void UnoControl::ImplLockPropertyChangeNotifications( const Sequence< ::rtl::OUString >& rPropertyNames, bool bLock )
+{
+    for (   const ::rtl::OUString* pPropertyName = rPropertyNames.getConstArray();
+            pPropertyName != rPropertyNames.getConstArray() + rPropertyNames.getLength();
+            ++pPropertyName
+        )
+        ImplLockPropertyChangeNotification( *pPropertyName, bLock );
+}
+
+void UnoControl::ImplModelPropertiesChanged( const Sequence< PropertyChangeEvent >& rEvents )
+{
+	::osl::ClearableGuard< ::osl::Mutex > aGuard( GetMutex() );
+
+    if( getPeer().is() )
+	{
+		DECLARE_STL_VECTOR( PropertyValue, PropertyValueVector);
+		PropertyValueVector 	aPeerPropertiesToSet;
+		sal_Int32				nIndependentPos = 0;
+        bool                    bResourceResolverSet( false );
+			// position where to insert the independent properties into aPeerPropertiesToSet,
+            // dependent ones are inserted at the end of the vector
+
+		sal_Bool bNeedNewPeer = sal_False;
+			// some properties require a re-creation of the peer, 'cause they can't be changed on the fly
+
+		Reference< XControlModel > xOwnModel( getModel(), UNO_QUERY );
+			// our own model for comparison
+        Reference< XPropertySet > xPS( xOwnModel, UNO_QUERY );
+        Reference< XPropertySetInfo > xPSI( xPS->getPropertySetInfo(), UNO_QUERY );
+        OSL_ENSURE( xPSI.is(), "UnoControl::ImplModelPropertiesChanged: should have property set meta data!" );
+
+		const PropertyChangeEvent* pEvents = rEvents.getConstArray();
+
+		sal_Int32 nLen = rEvents.getLength();
+		aPeerPropertiesToSet.reserve(nLen);
+
+		for( sal_Int32 i = 0; i < nLen; ++i, ++pEvents )
+		{
+			Reference< XControlModel > xModel( pEvents->Source, UNO_QUERY );
+			sal_Bool bOwnModel = xModel.get() == xOwnModel.get();
+			if ( !bOwnModel )
+                continue;
+
+            // Detect changes on our resource resolver which invalidates
+            // automatically some language dependent properties.
+            if ( pEvents->PropertyName.equalsAsciiL( "ResourceResolver", 16 ))
+            {
+                Reference< resource::XStringResourceResolver > xStrResolver;
+                if ( pEvents->NewValue >>= xStrResolver )
+                    bResourceResolverSet = xStrResolver.is();
+            }
+            
+            sal_uInt16 nPType = GetPropertyId( pEvents->PropertyName );
+			if ( mbDesignMode && mbDisposePeer && !mbRefeshingPeer && !mbCreatingPeer )	 
+            {
+                // if we're in design mode, then some properties can change which
+                // require creating a *new* peer (since these properties cannot
+                // be switched at existing peers)
+                if ( nPType )
+                    bNeedNewPeer = ( nPType == BASEPROPERTY_BORDER )
+                                || ( nPType == BASEPROPERTY_MULTILINE )
+							    || ( nPType == BASEPROPERTY_DROPDOWN )
+							    || ( nPType == BASEPROPERTY_HSCROLL )
+							    || ( nPType == BASEPROPERTY_VSCROLL )
+							    || ( nPType == BASEPROPERTY_AUTOHSCROLL )
+							    || ( nPType == BASEPROPERTY_AUTOVSCROLL )
+							    || ( nPType == BASEPROPERTY_ORIENTATION )
+							    || ( nPType == BASEPROPERTY_SPIN )
+							    || ( nPType == BASEPROPERTY_ALIGN )
+							    || ( nPType == BASEPROPERTY_PAINTTRANSPARENT );
+                else
+                    bNeedNewPeer = requiresNewPeer( pEvents->PropertyName );
+
+                if ( bNeedNewPeer )
+					break;
+			}
+
+			if ( nPType && ( nLen > 1 ) && DoesDependOnOthers( nPType ) )
+			{
+				// Properties die von anderen abhaengen erst hinterher einstellen,
+				// weil sie von anderen Properties abhaengig sind, die aber erst spaeter
+				// eingestellt werden, z.B. VALUE nach VALUEMIN/MAX.
+				aPeerPropertiesToSet.push_back(PropertyValue(pEvents->PropertyName, 0, pEvents->NewValue, PropertyState_DIRECT_VALUE));
+			}
+			else
+			{
+                if ( bResourceResolverSet )
+                {
+					// The resource resolver property change should be one of the first ones.
+                    // All language dependent properties are dependent on this property.
+                    // As BASEPROPERTY_NATIVE_WIDGET_LOOK is not dependent on resource
+                    // resolver. We don't need to handle a special order for these two props.
+                    aPeerPropertiesToSet.insert(
+                        aPeerPropertiesToSet.begin(),
+						PropertyValue( pEvents->PropertyName, 0, pEvents->NewValue, PropertyState_DIRECT_VALUE ) );
+                    ++nIndependentPos;
+                }
+                else if ( nPType == BASEPROPERTY_NATIVE_WIDGET_LOOK )
+                {
+                    // since *a lot* of other properties might be overruled by this one, we need
+                    // a special handling:
+                    // NativeWidgetLook needs to be set first: If it is set to ON, all other
+                    // properties describing the look (e.g. BackgroundColor) are ignored, anyway.
+                    // If it is switched OFF, then we need to do it first because else it will
+                    // overrule other look-related properties, and re-initialize them from system
+                    // defaults.
+                    aPeerPropertiesToSet.insert(
+                        aPeerPropertiesToSet.begin(),
+						PropertyValue( pEvents->PropertyName, 0, pEvents->NewValue, PropertyState_DIRECT_VALUE ) );
+                    ++nIndependentPos;
+                }
+                else
+                {
+					aPeerPropertiesToSet.insert(aPeerPropertiesToSet.begin() + nIndependentPos,
+						PropertyValue(pEvents->PropertyName, 0, pEvents->NewValue, PropertyState_DIRECT_VALUE));
+					++nIndependentPos;
+                }
+			}
+		}
+
+		Reference< XWindow >	xParent = getParentPeer();
+		Reference< XControl > xThis( (XAggregation*)(::cppu::OWeakAggObject*)this, UNO_QUERY );
+		// call createPeer via a interface got from queryInterface, so the aggregating class can intercept it
+
+		DBG_ASSERT( !bNeedNewPeer || xParent.is(), "Need new peer, but don't have a parent!" );
+
+        // Check if we have to update language dependent properties
+        if ( !bNeedNewPeer && bResourceResolverSet )
+        {
+            // Add language dependent properties into the peer property set.
+            // Our resource resolver has been changed and we must be sure
+            // that language dependent props use the new resolver.
+            const LanguageDependentProp* pLangDepProp = aLanguageDependentProp;
+            while ( pLangDepProp->pPropName != 0 )
+            {
+                bool bMustBeInserted( true );
+                for ( sal_uInt32 i = 0; i < aPeerPropertiesToSet.size(); i++ )
+                {
+                    if ( aPeerPropertiesToSet[i].Name.equalsAsciiL( 
+                            pLangDepProp->pPropName, pLangDepProp->nPropNameLength ))
+                    {
+                        bMustBeInserted = false;
+                        break;
+                    }
+                }
+                
+                if ( bMustBeInserted )
+                {
+                    // Add language dependent props at the end
+                    ::rtl::OUString aPropName( ::rtl::OUString::createFromAscii( pLangDepProp->pPropName ));
+                    if ( xPSI.is() && xPSI->hasPropertyByName( aPropName ) )
+                    {
+                        aPeerPropertiesToSet.push_back(
+                            PropertyValue( aPropName, 0, xPS->getPropertyValue( aPropName ), PropertyState_DIRECT_VALUE ) );
+                    }
+                }
+                
+                ++pLangDepProp;
+            }
+        }
+        aGuard.clear();
+		
+        // clear the guard before creating a new peer - as usual, our peer implementations use the SolarMutex
+		// #82300# - 2000-12-21 - fs@openoffice.org
+		if (bNeedNewPeer && xParent.is())
+		{
+			NAMESPACE_VOS(OGuard) aVclGuard( Application::GetSolarMutex() );
+				// and now this is the final withdrawal:
+				// With 83561, I have no other idea than locking the SolarMutex here ....
+				// I really hate the fact that VCL is not theadsafe ....
+				// #83561# - 2001-03-01 - fs@openoffice.org
+
+			// Funktioniert beim Container nicht!
+			getPeer()->dispose();
+			mxPeer.clear();
+			mxVclWindowPeer = NULL;
+			mbRefeshingPeer = sal_True;
+			Reference< XWindowPeer >	xP( xParent, UNO_QUERY );
+			xThis->createPeer( Reference< XToolkit > (), xP );
+			mbRefeshingPeer = sal_False;
+			aPeerPropertiesToSet.clear();
+		}
+
+        // lock the multiplexing of VCL events to our UNO listeners
+        // this is for compatibility reasons: in OOo 1.0.x, changes which were done at the
+        // model did not cause the listeners of the controls/peers to be called
+        // Since the implementations for the listeners changed a lot towards 1.1, this
+        // would not be the case anymore, if we would not do this listener-lock below
+        // #i14703# - 2003-05-23 - fs@openoffice.org
+        Window* pVclPeer = VCLUnoHelper::GetWindow( getPeer() );
+        VCLXWindow* pPeer = pVclPeer ? pVclPeer->GetWindowPeer() : NULL;
+        VclListenerLock aNoVclEventMultiplexing( pPeer );
+
+        // setting peer properties may result in an attemp to acquire the solar mutex, 'cause the peers
+		// usually don't have an own mutex but use the SolarMutex instead.
+		// To prevent deadlocks resulting from this, we do this without our own mutex locked
+		// 2000-11-03 - fs@openoffice.org
+		PropertyValueVectorIterator aEnd = aPeerPropertiesToSet.end();
+		for (	PropertyValueVectorIterator aLoop = aPeerPropertiesToSet.begin();
+				aLoop != aEnd;
+				++aLoop
+			)
+		{
+			ImplSetPeerProperty( aLoop->Name, aLoop->Value );
+		}
+	}
+}
+
+void UnoControl::disposing( const EventObject& rEvt ) throw(RuntimeException)
+{
+	::osl::ClearableMutexGuard aGuard( GetMutex() );
+	// bei "Multible Inheritance" nicht unterschiedliche Typen vergleichen.
+
+    if ( maAccessibleContext.get() == rEvt.Source )
+    {
+		// just in case the context is disposed, but not released - ensure that we do not re-use it in the future
+		maAccessibleContext = NULL;
+    }
+	else if( mxModel.get() == Reference< XControlModel >(rEvt.Source,UNO_QUERY).get() )
+	{
+		// #62337# if the model dies, it does not make sense for us to live ...
+		Reference< XControl >  xThis = this;
+
+        aGuard.clear();
+        xThis->dispose();
+
+		DBG_ASSERT( !mxModel.is(), "UnoControl::disposing: invalid dispose behaviour!" );
+		mxModel.clear();
+	}
+}
+
+
+void SAL_CALL UnoControl::setOutputSize( const awt::Size& aSize ) throw (RuntimeException)
+{
+	Reference< XWindow2 > xPeerWindow;
+	{
+		::osl::MutexGuard aGuard( GetMutex() );
+		xPeerWindow = xPeerWindow.query( getPeer() );
+	}
+
+    if ( xPeerWindow.is() )
+		xPeerWindow->setOutputSize( aSize );
+}
+
+namespace
+{
+    template < typename RETVALTYPE >
+    RETVALTYPE lcl_askPeer( const uno::Reference< awt::XWindowPeer >& _rxPeer, RETVALTYPE (SAL_CALL XWindow2::*_pMethod)(), RETVALTYPE _aDefault )
+    {
+        RETVALTYPE aReturn( _aDefault );
+
+        Reference< XWindow2 > xPeerWindow( _rxPeer, UNO_QUERY );
+        if ( xPeerWindow.is() )
+            aReturn = (xPeerWindow.get()->*_pMethod)();
+
+        return aReturn;
+    }
+}
+
+awt::Size SAL_CALL UnoControl::getOutputSize(  ) throw (RuntimeException)
+{
+    return lcl_askPeer( getPeer(), &XWindow2::getOutputSize, awt::Size() );
+}
+
+::sal_Bool SAL_CALL UnoControl::isVisible(  ) throw (RuntimeException)
+{
+    return lcl_askPeer( getPeer(), &XWindow2::isVisible, maComponentInfos.bVisible );
+}
+
+::sal_Bool SAL_CALL UnoControl::isActive(  ) throw (RuntimeException)
+{
+    return lcl_askPeer( getPeer(), &XWindow2::isActive, sal_False );
+}
+
+::sal_Bool SAL_CALL UnoControl::isEnabled(  ) throw (RuntimeException)
+{
+    return lcl_askPeer( getPeer(), &XWindow2::isEnabled, maComponentInfos.bEnable );
+}
+
+::sal_Bool SAL_CALL UnoControl::hasFocus(  ) throw (RuntimeException)
+{
+    return lcl_askPeer( getPeer(), &XWindow2::hasFocus, sal_False );
+}
+
+// XWindow
+void UnoControl::setPosSize( sal_Int32 X, sal_Int32 Y, sal_Int32 Width, sal_Int32 Height, sal_Int16 Flags ) throw(RuntimeException)
+{
+	Reference< XWindow > xWindow;
+	{
+		::osl::MutexGuard aGuard( GetMutex() );
+		
+        if ( Flags & awt::PosSize::X )
+		    maComponentInfos.nX = X; 
+        if ( Flags & awt::PosSize::Y )
+		    maComponentInfos.nY = Y; 
+        if ( Flags & awt::PosSize::WIDTH )
+		    maComponentInfos.nWidth = Width; 
+        if ( Flags & awt::PosSize::HEIGHT )
+		    maComponentInfos.nHeight = Height;
+		maComponentInfos.nFlags |= Flags;
+		
+		xWindow = xWindow.query( getPeer() );
+	}
+
+    if( xWindow.is() )
+		xWindow->setPosSize( X, Y, Width, Height, Flags );
+}
+
+awt::Rectangle UnoControl::getPosSize(  ) throw(RuntimeException)
+{
+    awt::Rectangle aRect( maComponentInfos.nX, maComponentInfos.nY, maComponentInfos.nWidth, maComponentInfos.nHeight);
+    Reference< XWindow > xWindow;
+
+    {
+	    ::osl::MutexGuard aGuard( GetMutex() );
+        xWindow = xWindow.query( getPeer() );
+    }
+
+    if( xWindow.is() )
+	    aRect = xWindow->getPosSize();
+    return aRect;
+}
+
+void UnoControl::setVisible( sal_Bool bVisible ) throw(RuntimeException)
+{
+	Reference< XWindow > xWindow;
+	{
+		::osl::MutexGuard aGuard( GetMutex() );
+	
+		// Visible status ist Sache der View
+		maComponentInfos.bVisible = bVisible;
+		xWindow = xWindow.query( getPeer() );
+	}
+	if ( xWindow.is() )
+		xWindow->setVisible( bVisible );
+}
+
+void UnoControl::setEnable( sal_Bool bEnable ) throw(RuntimeException)
+{
+	Reference< XWindow > xWindow;
+	{
+		::osl::MutexGuard aGuard( GetMutex() );
+	
+		// Enable status ist Sache der View
+		maComponentInfos.bEnable = bEnable;
+		xWindow = xWindow.query( getPeer() );
+	}
+	if ( xWindow.is() )
+		xWindow->setEnable( bEnable );
+}
+
+void UnoControl::setFocus(	) throw(RuntimeException)
+{
+	Reference< XWindow > xWindow;
+	{
+		::osl::MutexGuard aGuard( GetMutex() );
+		xWindow = xWindow.query( getPeer() );
+	}
+	if ( xWindow.is() )
+		xWindow->setFocus();
+}
+
+void UnoControl::addWindowListener( const Reference< XWindowListener >& rxListener ) throw(RuntimeException)
+{
+    Reference< XWindow > xPeerWindow;
+    {
+	    ::osl::MutexGuard aGuard( GetMutex() );
+	    maWindowListeners.addInterface( rxListener );
+	    if ( maWindowListeners.getLength() == 1 )
+		    xPeerWindow = xPeerWindow.query( getPeer() );
+    }
+    if ( xPeerWindow.is() )
+	    xPeerWindow->addWindowListener( &maWindowListeners );
+}
+
+void UnoControl::removeWindowListener( const Reference< XWindowListener >& rxListener ) throw(RuntimeException)
+{
+    Reference< XWindow > xPeerWindow;
+    {
+	    ::osl::MutexGuard aGuard( GetMutex() );
+	    if ( maWindowListeners.getLength() == 1 )
+		    xPeerWindow = xPeerWindow.query( getPeer() );
+        maWindowListeners.removeInterface( rxListener );
+    }
+    if ( xPeerWindow.is() )
+	    xPeerWindow->removeWindowListener( &maWindowListeners );
+}
+
+void UnoControl::addFocusListener( const Reference< XFocusListener >& rxListener ) throw(RuntimeException)
+{
+    Reference< XWindow > xPeerWindow;
+    {
+	    ::osl::MutexGuard aGuard( GetMutex() );
+	    maFocusListeners.addInterface( rxListener );
+	    if ( maFocusListeners.getLength() == 1 )
+		    xPeerWindow = xPeerWindow.query( getPeer() );
+    }
+    if ( xPeerWindow.is() )
+	    xPeerWindow->addFocusListener( &maFocusListeners );
+}
+
+void UnoControl::removeFocusListener( const Reference< XFocusListener >& rxListener ) throw(RuntimeException)
+{
+    Reference< XWindow > xPeerWindow;
+    {
+	    ::osl::MutexGuard aGuard( GetMutex() );
+	    if ( maFocusListeners.getLength() == 1 )
+		    xPeerWindow = xPeerWindow.query( getPeer() );
+        maFocusListeners.removeInterface( rxListener );
+    }
+    if ( xPeerWindow.is() )
+	    xPeerWindow->removeFocusListener( &maFocusListeners );
+}
+
+void UnoControl::addKeyListener( const Reference< XKeyListener >& rxListener ) throw(RuntimeException)
+{
+    Reference< XWindow > xPeerWindow;
+    {
+	    ::osl::MutexGuard aGuard( GetMutex() );
+	    maKeyListeners.addInterface( rxListener );
+	    if ( maKeyListeners.getLength() == 1 )
+		    xPeerWindow = xPeerWindow.query( getPeer() );
+    }
+    if ( xPeerWindow.is() )
+        xPeerWindow->addKeyListener( &maKeyListeners);
+}
+
+void UnoControl::removeKeyListener( const Reference< XKeyListener >& rxListener ) throw(RuntimeException)
+{
+    Reference< XWindow > xPeerWindow;
+    {
+	    ::osl::MutexGuard aGuard( GetMutex() );
+	    if ( maKeyListeners.getLength() == 1 )
+            xPeerWindow = xPeerWindow.query( getPeer() );
+        maKeyListeners.removeInterface( rxListener );
+    }
+    if ( xPeerWindow.is() )
+		xPeerWindow->removeKeyListener( &maKeyListeners);
+}
+
+void UnoControl::addMouseListener( const Reference< XMouseListener >& rxListener ) throw(RuntimeException)
+{
+    Reference< XWindow > xPeerWindow;
+    {
+	    ::osl::MutexGuard aGuard( GetMutex() );
+	    maMouseListeners.addInterface( rxListener );
+	    if ( maMouseListeners.getLength() == 1 )
+		    xPeerWindow = xPeerWindow.query( getPeer() );
+    }
+    if ( xPeerWindow.is() )
+        xPeerWindow->addMouseListener( &maMouseListeners);
+}
+
+void UnoControl::removeMouseListener( const Reference< XMouseListener >& rxListener ) throw(RuntimeException)
+{
+    Reference< XWindow > xPeerWindow;
+    {
+	    ::osl::MutexGuard aGuard( GetMutex() );
+	    if ( maMouseListeners.getLength() == 1 )
+		    xPeerWindow = xPeerWindow.query( getPeer() );
+        maMouseListeners.removeInterface( rxListener );
+    }
+    if ( xPeerWindow.is() )
+	    xPeerWindow->removeMouseListener( &maMouseListeners );
+}
+
+void UnoControl::addMouseMotionListener( const Reference< XMouseMotionListener >& rxListener ) throw(RuntimeException)
+{
+    Reference< XWindow > xPeerWindow;
+    {
+	    ::osl::MutexGuard aGuard( GetMutex() );
+	    maMouseMotionListeners.addInterface( rxListener );
+	    if ( maMouseMotionListeners.getLength() == 1 )
+		    xPeerWindow = xPeerWindow.query( getPeer() );
+    }
+    if ( xPeerWindow.is() )
+        xPeerWindow->addMouseMotionListener( &maMouseMotionListeners);
+}
+
+void UnoControl::removeMouseMotionListener( const Reference< XMouseMotionListener >& rxListener ) throw(RuntimeException)
+{
+    Reference< XWindow > xPeerWindow;
+    {
+	    ::osl::MutexGuard aGuard( GetMutex() );
+	    if ( maMouseMotionListeners.getLength() == 1 )
+		    xPeerWindow = xPeerWindow.query( getPeer() );
+        maMouseMotionListeners.removeInterface( rxListener );
+    }
+    if ( xPeerWindow.is() )
+	    xPeerWindow->removeMouseMotionListener( &maMouseMotionListeners );
+}
+
+void UnoControl::addPaintListener( const Reference< XPaintListener >& rxListener ) throw(RuntimeException)
+{
+    Reference< XWindow > xPeerWindow;
+    {
+	    ::osl::MutexGuard aGuard( GetMutex() );
+	    maPaintListeners.addInterface( rxListener );
+	    if ( maPaintListeners.getLength() == 1 )
+		    xPeerWindow = xPeerWindow.query( getPeer() );
+    }
+    if ( xPeerWindow.is() )
+        xPeerWindow->addPaintListener( &maPaintListeners);
+}
+
+void UnoControl::removePaintListener( const Reference< XPaintListener >& rxListener ) throw(RuntimeException)
+{
+    Reference< XWindow > xPeerWindow;
+    {
+	    ::osl::MutexGuard aGuard( GetMutex() );
+	    if ( maPaintListeners.getLength() == 1 )
+		    xPeerWindow = xPeerWindow.query( getPeer() );
+        maPaintListeners.removeInterface( rxListener );
+    }
+    if ( xPeerWindow.is() )
+	    xPeerWindow->removePaintListener( &maPaintListeners );
+}
+
+// XView
+sal_Bool UnoControl::setGraphics( const Reference< XGraphics >& rDevice ) throw(RuntimeException)
+{
+	Reference< XView > xView;
+	{
+		::osl::MutexGuard aGuard( GetMutex() );
+	
+		mxGraphics = rDevice;
+		xView = xView.query( getPeer() );
+	}
+	return xView.is() ? xView->setGraphics( rDevice ) : sal_True;
+}
+
+Reference< XGraphics > UnoControl::getGraphics(  ) throw(RuntimeException)
+{
+	return mxGraphics;
+}
+
+awt::Size UnoControl::getSize(  ) throw(RuntimeException)
+{
+	::osl::MutexGuard aGuard( GetMutex() );
+	return awt::Size( maComponentInfos.nWidth, maComponentInfos.nHeight );
+}
+
+void UnoControl::draw( sal_Int32 x, sal_Int32 y ) throw(RuntimeException)
+{
+    Reference< XWindowPeer > xDrawPeer;
+    Reference< XView > xDrawPeerView;
+
+    bool bDisposeDrawPeer( false );
+    {
+	    ::osl::MutexGuard aGuard( GetMutex() );
+
+        xDrawPeer = ImplGetCompatiblePeer( sal_True );
+        bDisposeDrawPeer = xDrawPeer.is() && ( xDrawPeer != getPeer() );
+
+        xDrawPeerView.set( xDrawPeer, UNO_QUERY );
+        DBG_ASSERT( xDrawPeerView.is(), "UnoControl::draw: no peer!" );
+    }
+
+    if ( xDrawPeerView.is() )
+        xDrawPeerView->draw( x, y );
+
+    if ( bDisposeDrawPeer )
+        xDrawPeer->dispose();
+}
+
+void UnoControl::setZoom( float fZoomX, float fZoomY ) throw(RuntimeException)
+{
+	Reference< XView > xView;
+	{
+		::osl::MutexGuard aGuard( GetMutex() );
+		
+		maComponentInfos.nZoomX = fZoomX;
+		maComponentInfos.nZoomY = fZoomY;
+
+		xView = xView.query( getPeer() );
+	}
+	if ( xView.is() )
+		xView->setZoom( fZoomX, fZoomY );
+}
+
+// XControl
+void UnoControl::setContext( const Reference< XInterface >& rxContext ) throw(RuntimeException)
+{
+	::osl::MutexGuard aGuard( GetMutex() );
+	
+	mxContext = rxContext;
+}
+
+Reference< XInterface > UnoControl::getContext(  ) throw(RuntimeException)
+{
+	::osl::MutexGuard aGuard( GetMutex() );
+	
+	return mxContext;
+}
+
+void UnoControl::peerCreated()
+{
+    Reference< XWindow > xWindow( getPeer(), UNO_QUERY );
+    if ( !xWindow.is() )
+        return;
+
+    if ( maWindowListeners.getLength() )
+	    xWindow->addWindowListener( &maWindowListeners );
+
+    if ( maFocusListeners.getLength() )
+	    xWindow->addFocusListener( &maFocusListeners );
+
+    if ( maKeyListeners.getLength() )
+	    xWindow->addKeyListener( &maKeyListeners );
+
+    if ( maMouseListeners.getLength() )
+	    xWindow->addMouseListener( &maMouseListeners );
+
+    if ( maMouseMotionListeners.getLength() )
+	    xWindow->addMouseMotionListener( &maMouseMotionListeners );
+
+    if ( maPaintListeners.getLength() )
+	    xWindow->addPaintListener( &maPaintListeners );
+}
+
+void UnoControl::createPeer( const Reference< XToolkit >& rxToolkit, const Reference< XWindowPeer >& rParentPeer ) throw(RuntimeException)
+{
+	::osl::ClearableMutexGuard aGuard( GetMutex() );
+
+	if ( !mxModel.is() )
+	{
+		RuntimeException aException;
+		aException.Message = ::rtl::OUString::createFromAscii( "createPeer: no model!" );
+		aException.Context = (XAggregation*)(::cppu::OWeakAggObject*)this;
+		throw( aException );
+	}
+	
+	if( !getPeer().is() )
+	{
+		mbCreatingPeer = sal_True;
+
+		WindowClass eType;
+		Reference< XToolkit >  xToolkit = rxToolkit;
+		if( rParentPeer.is() && mxContext.is() )
+		{
+			// kein TopWindow
+			if ( !xToolkit.is() ) 
+				xToolkit = rParentPeer->getToolkit();
+			Any aAny = OWeakAggObject::queryInterface( ::getCppuType((const Reference< XControlContainer>*)0) );
+			Reference< XControlContainer > xC;
+			aAny >>= xC;
+			if( xC.is() )
+				// Es ist ein Container
+				eType = WindowClass_CONTAINER;
+			else
+				eType = WindowClass_SIMPLE;
+		}
+		else
+		{ // Nur richtig, wenn es sich um ein Top Window handelt
+			if( rParentPeer.is() )
+			{
+				if ( !xToolkit.is() ) 
+					xToolkit = rParentPeer->getToolkit();
+				eType = WindowClass_CONTAINER;
+			}
+			else
+			{
+				if ( !xToolkit.is() ) 
+					xToolkit = VCLUnoHelper::CreateToolkit();
+				eType = WindowClass_TOP;
+			}
+		}
+		WindowDescriptor aDescr;
+		aDescr.Type = eType;
+		aDescr.WindowServiceName = GetComponentServiceName();
+		aDescr.Parent = rParentPeer;
+		aDescr.Bounds = getPosSize();
+		aDescr.WindowAttributes = 0;
+
+        // Border
+		Reference< XPropertySet > xPSet( mxModel, UNO_QUERY );
+		Reference< XPropertySetInfo >  xInfo = xPSet->getPropertySetInfo();
+		
+		Any aVal;
+		::rtl::OUString aPropName = GetPropertyName( BASEPROPERTY_BORDER );
+		if ( xInfo->hasPropertyByName( aPropName ) )
+		{
+			aVal = xPSet->getPropertyValue( aPropName );
+			sal_Int16 n = sal_Int16();
+			if ( aVal >>= n )
+			{
+				if ( n )
+					aDescr.WindowAttributes |= WindowAttribute::BORDER;
+				else
+					aDescr.WindowAttributes |= VclWindowPeerAttribute::NOBORDER;
+			}
+		}
+
+		// DESKTOP_AS_PARENT
+        if ( aDescr.Type == WindowClass_TOP )
+        {
+            aPropName = GetPropertyName( BASEPROPERTY_DESKTOP_AS_PARENT );
+            if ( xInfo->hasPropertyByName( aPropName ) )
+            {
+                aVal = xPSet->getPropertyValue( aPropName );
+                sal_Bool b = sal_Bool();
+                if ( ( aVal >>= b ) && b)
+                    aDescr.ParentIndex = -1;
+            }
+        }
+		// Moveable
+		aPropName = GetPropertyName( BASEPROPERTY_MOVEABLE );
+		if ( xInfo->hasPropertyByName( aPropName ) )
+		{
+			aVal = xPSet->getPropertyValue( aPropName );
+			sal_Bool b = sal_Bool();
+			if ( ( aVal >>= b ) && b)
+				aDescr.WindowAttributes |= WindowAttribute::MOVEABLE;
+		}
+
+		// Closeable
+		aPropName = GetPropertyName( BASEPROPERTY_CLOSEABLE );
+		if ( xInfo->hasPropertyByName( aPropName ) )
+		{
+			aVal = xPSet->getPropertyValue( aPropName );
+			sal_Bool b = sal_Bool();
+			if ( ( aVal >>= b ) && b)
+				aDescr.WindowAttributes |= WindowAttribute::CLOSEABLE;
+		}
+
+		// Dropdown
+		aPropName = GetPropertyName( BASEPROPERTY_DROPDOWN );
+		if ( xInfo->hasPropertyByName( aPropName ) )
+		{
+			aVal = xPSet->getPropertyValue( aPropName );
+			sal_Bool b = sal_Bool();
+			if ( ( aVal >>= b ) && b)
+				aDescr.WindowAttributes |= VclWindowPeerAttribute::DROPDOWN;
+		}
+		
+		// Spin
+		aPropName = GetPropertyName( BASEPROPERTY_SPIN );
+		if ( xInfo->hasPropertyByName( aPropName ) )
+		{
+			aVal = xPSet->getPropertyValue( aPropName );
+			sal_Bool b = sal_Bool();
+			if ( ( aVal >>= b ) && b)
+				aDescr.WindowAttributes |= VclWindowPeerAttribute::SPIN;
+		}
+
+		// HScroll
+		aPropName = GetPropertyName( BASEPROPERTY_HSCROLL );
+		if ( xInfo->hasPropertyByName( aPropName ) )
+		{
+			aVal = xPSet->getPropertyValue( aPropName );
+			sal_Bool b = sal_Bool();
+			if ( ( aVal >>= b ) && b)
+				aDescr.WindowAttributes |= VclWindowPeerAttribute::HSCROLL;
+		}
+
+		// VScroll
+		aPropName = GetPropertyName( BASEPROPERTY_VSCROLL );
+		if ( xInfo->hasPropertyByName( aPropName ) )
+		{
+			aVal = xPSet->getPropertyValue( aPropName );
+			sal_Bool b = sal_Bool();
+			if ( ( aVal >>= b ) && b)
+				aDescr.WindowAttributes |= VclWindowPeerAttribute::VSCROLL;
+		}
+
+		// AutoHScroll
+		aPropName = GetPropertyName( BASEPROPERTY_AUTOHSCROLL );
+		if ( xInfo->hasPropertyByName( aPropName ) )
+		{
+			aVal = xPSet->getPropertyValue( aPropName );
+			sal_Bool b = sal_Bool();
+			if ( ( aVal >>= b ) && b)
+				aDescr.WindowAttributes |= VclWindowPeerAttribute::AUTOHSCROLL;
+		}
+
+		// AutoVScroll
+		aPropName = GetPropertyName( BASEPROPERTY_AUTOVSCROLL );
+		if ( xInfo->hasPropertyByName( aPropName ) )
+		{
+			aVal = xPSet->getPropertyValue( aPropName );
+			sal_Bool b = sal_Bool();
+			if ( ( aVal >>= b ) && b)
+				aDescr.WindowAttributes |= VclWindowPeerAttribute::AUTOVSCROLL;
+		}
+
+		//added for issue79712
+		//NoLabel 
+		aPropName = GetPropertyName( BASEPROPERTY_NOLABEL );
+		if ( xInfo->hasPropertyByName( aPropName ) )
+		{
+			aVal = xPSet->getPropertyValue( aPropName );
+			sal_Bool b = sal_Bool();
+			if ( ( aVal >>=b ) && b )
+				aDescr.WindowAttributes |= VclWindowPeerAttribute::NOLABEL;
+		}
+		//issue79712 ends
+		
+		// Visible
+		aPropName = GetPropertyName( BASEPROPERTY_ENABLEVISIBLE );
+		if ( xInfo->hasPropertyByName( aPropName ) )
+		{
+			aVal = xPSet->getPropertyValue( aPropName );
+			sal_Bool b = sal_Bool();
+			if ( ( aVal >>=b ) && !b )
+            {
+                maComponentInfos.bVisible = b;
+            }
+		}
+
+		// Align
+		aPropName = GetPropertyName( BASEPROPERTY_ALIGN );
+		if ( xInfo->hasPropertyByName( aPropName ) )
+		{
+			aVal = xPSet->getPropertyValue( aPropName );
+			sal_Int16 n = sal_Int16();
+			if ( aVal >>= n )
+			{
+				if ( n == PROPERTY_ALIGN_LEFT )
+					aDescr.WindowAttributes |= VclWindowPeerAttribute::LEFT;
+				else if ( n == PROPERTY_ALIGN_CENTER )
+					aDescr.WindowAttributes |= VclWindowPeerAttribute::CENTER;
+				else
+					aDescr.WindowAttributes |= VclWindowPeerAttribute::RIGHT;
+			}
+		}
+
+        // Ableitungen die Moeglichkeit geben die Attribute zu manipulieren
+		PrepareWindowDescriptor(aDescr);
+
+		// create the peer
+		setPeer( xToolkit->createWindow( aDescr ) );
+
+		// release the mutex guard (and work with copies of our members)
+		// this is necessary as our peer may lock the SolarMutex (actually, all currently known peers do), so calling
+		// into the peer with our own mutex locked may cause deadlocks
+		// (We _really_ need peers which do not use the SolarMutex. It's really pissing me off that from time to
+		// time deadlocks pop up because the low-level components like our peers use a mutex which ususally
+		// is locked at the top of the stack (it protects the global message looping). This is always dangerous, and
+		// can not always be solved by tampering with other mutexes.
+		// Unfortunately, the VCL used in the peers is not threadsafe, and by definition needs a locked SolarMutex.)
+		// 82300 - 12/21/00 - FS
+		UnoControlComponentInfos aComponentInfos(maComponentInfos);
+		sal_Bool bDesignMode(mbDesignMode);
+
+        Reference< XGraphics >  xGraphics( mxGraphics           );
+		Reference< XView >      xView    ( getPeer(), UNO_QUERY );
+		Reference< XWindow >    xWindow  ( getPeer(), UNO_QUERY );
+
+		aGuard.clear();
+
+		// the updateFromModel is done without a locked mutex, too.
+		// The reason is that the only thing this method does  is firing property changes, and this in general has
+		// to be done without locked mutexes (as every notification to external listeners).
+		// 82300 - 12/21/00 - FS
+		updateFromModel();
+
+		xView->setZoom( aComponentInfos.nZoomX, aComponentInfos.nZoomY );
+
+        setPosSize( aComponentInfos.nX, aComponentInfos.nY, aComponentInfos.nWidth, aComponentInfos.nHeight, aComponentInfos.nFlags );
+
+		if( aComponentInfos.bVisible && !bDesignMode )
+			// Erst nach dem setzen der Daten anzeigen
+			xWindow->setVisible( aComponentInfos.bVisible );
+
+		if( !aComponentInfos.bEnable )
+			xWindow->setEnable( aComponentInfos.bEnable );
+
+		xView->setGraphics( xGraphics );
+
+        peerCreated();
+
+		mbCreatingPeer = sal_False;
+	}
+}
+
+Reference< XWindowPeer > UnoControl::getPeer() throw(RuntimeException)
+{
+	::osl::MutexGuard aGuard( GetMutex() );
+	return mxPeer;
+}
+
+sal_Bool UnoControl::setModel( const Reference< XControlModel >& rxModel ) throw(RuntimeException)
+{
+	::osl::MutexGuard aGuard( GetMutex() );
+	
+	Reference< XMultiPropertySet > xPropSet( mxModel, UNO_QUERY );
+
+    // query for the XPropertiesChangeListener - our delegator is allowed to overwrite this interface
+    Reference< XPropertiesChangeListener > xListener;
+    queryInterface( ::getCppuType( &xListener ) ) >>= xListener;
+
+	if( xPropSet.is() )
+		xPropSet->removePropertiesChangeListener( xListener );
+	
+	mxModel = rxModel;
+	if( mxModel.is() )
+	{
+		xPropSet = Reference< XMultiPropertySet > ( mxModel, UNO_QUERY );
+		if( xPropSet.is() )
+		{
+			Sequence< ::rtl::OUString> aNames = lcl_ImplGetPropertyNames( xPropSet );
+			xPropSet->addPropertiesChangeListener( aNames, xListener );
+		}
+	}
+	return mxModel.is();
+}
+
+Reference< XControlModel > UnoControl::getModel(	) throw(RuntimeException)
+{
+	return mxModel;
+}
+
+Reference< XView > UnoControl::getView(  ) throw(RuntimeException)
+{
+	return	static_cast< XView* >( this );
+}
+
+void UnoControl::setDesignMode( sal_Bool bOn ) throw(RuntimeException)
+{
+	ModeChangeEvent aModeChangeEvent;
+
+	Reference< XWindow > xWindow;
+	{
+		::osl::MutexGuard aGuard( GetMutex() );
+		if ( bOn == mbDesignMode )
+			return;
+
+		// remember this
+		mbDesignMode = bOn;
+		xWindow = xWindow.query( getPeer() );
+
+		// dispose our current AccessibleContext, if we have one
+		// (changing the design mode implies having a new implementation for this context,
+		// so the old one must be declared DEFUNC)
+		disposeAccessibleContext();
+
+		aModeChangeEvent.Source = *this;
+		aModeChangeEvent.NewMode = ::rtl::OUString::createFromAscii( mbDesignMode ? "design" : "alive" );
+	}
+
+	// ajust the visibility of our window
+	if ( xWindow.is() )
+		xWindow->setVisible( !bOn );
+
+	// and notify our mode listeners
+    maModeChangeListeners.notifyEach( &XModeChangeListener::modeChanged, aModeChangeEvent );
+}
+
+sal_Bool UnoControl::isDesignMode(	) throw(RuntimeException)
+{
+	return mbDesignMode;
+}
+
+sal_Bool UnoControl::isTransparent(  ) throw(RuntimeException)
+{
+	return sal_False;
+}
+
+// XServiceInfo
+::rtl::OUString UnoControl::getImplementationName(	) throw(RuntimeException)
+{
+	DBG_ERROR( "This method should be overloaded!" );
+	return ::rtl::OUString();
+}
+
+sal_Bool UnoControl::supportsService( const ::rtl::OUString& rServiceName ) throw(RuntimeException)
+{
+	::osl::MutexGuard aGuard( GetMutex() );
+	
+	Sequence< ::rtl::OUString > aSNL = getSupportedServiceNames();
+	const ::rtl::OUString* pArray = aSNL.getConstArray();
+	const ::rtl::OUString* pArrayEnd = aSNL.getConstArray();
+	for (; pArray != pArrayEnd; ++pArray )
+		if( *pArray == rServiceName )
+			break;
+
+	return pArray != pArrayEnd;
+}
+
+Sequence< ::rtl::OUString > UnoControl::getSupportedServiceNames(  ) throw(RuntimeException)
+{
+	::rtl::OUString sName( RTL_CONSTASCII_USTRINGPARAM( "com.sun.star.awt.UnoControl" ) );
+	return Sequence< ::rtl::OUString >( &sName, 1 );
+}
+
+// ------------------------------------------------------------------------
+Reference< XAccessibleContext > SAL_CALL UnoControl::getAccessibleContext(  ) throw (RuntimeException)
+{
+    // creation of the context will certainly require the SolarMutex ...
+    ::vos::OGuard aSolarGuard( Application::GetSolarMutex() );
+	::osl::MutexGuard aGuard( GetMutex() );
+
+	Reference< XAccessibleContext > xCurrentContext( maAccessibleContext.get(), UNO_QUERY );
+	if ( !xCurrentContext.is() )
+	{
+		if ( !mbDesignMode )
+		{	// in alive mode, use the AccessibleContext of the peer
+			Reference< XAccessible > xPeerAcc( getPeer(), UNO_QUERY );
+			if ( xPeerAcc.is() )
+				xCurrentContext = xPeerAcc->getAccessibleContext( );
+		}
+		else
+			// in design mode, use a fallback
+			xCurrentContext = ::toolkit::OAccessibleControlContext::create( this );
+
+		DBG_ASSERT( xCurrentContext.is(), "UnoControl::getAccessibleContext: invalid context (invalid peer?)!" );
+		maAccessibleContext = xCurrentContext;
+
+		// get notified when the context is disposed
+		Reference< XComponent > xContextComp( xCurrentContext, UNO_QUERY );
+		if ( xContextComp.is() )
+			xContextComp->addEventListener( this );
+		// In an ideal world, this is not necessary - there the object would be released as soon as it has been
+		// disposed, and thus our weak reference would be empty, too.
+		// But 'til this ideal world comes (means 'til we do never have any refcount/lifetime bugs anymore), we
+		// need to listen for disposal and reset our weak reference then.
+	}
+
+	return xCurrentContext;
+}
+
+void SAL_CALL UnoControl::addModeChangeListener( const Reference< XModeChangeListener >& _rxListener ) throw (RuntimeException)
+{
+	::osl::MutexGuard aGuard( GetMutex() );
+	maModeChangeListeners.addInterface( _rxListener );
+}
+
+void SAL_CALL UnoControl::removeModeChangeListener( const Reference< XModeChangeListener >& _rxListener ) throw (RuntimeException)
+{
+	::osl::MutexGuard aGuard( GetMutex() );
+	maModeChangeListeners.removeInterface( _rxListener );
+}
+
+void SAL_CALL UnoControl::addModeChangeApproveListener( const Reference< XModeChangeApproveListener >& ) throw (NoSupportException, RuntimeException)
+{
+	throw NoSupportException( );
+}
+
+void SAL_CALL UnoControl::removeModeChangeApproveListener( const Reference< XModeChangeApproveListener >&  ) throw (NoSupportException, RuntimeException)
+{
+	throw NoSupportException( );
+}
+
--- sc/source/filter/inc/xlescher.hxx.orig	1970-01-01 08:00:00.000000000 +0800
+++ sc/source/filter/inc/xlescher.hxx	2008-04-11 04:52:34.000000000 +0800
@@ -0,0 +1,288 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: xlescher.hxx,v $
+ * $Revision: 1.22 $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+
+#ifndef SC_XLESCHER_HXX
+#define SC_XLESCHER_HXX
+
+#include <vcl/mapunit.hxx>
+#include "fapihelper.hxx"
+#include "xladdress.hxx"
+
+// Constants and Enumerations =================================================
+
+// misc -----------------------------------------------------------------------
+
+const long EXC_ESCHER_AUTOMARGIN            = 20000;    /// Automatic text margin.
+
+// (0x001C) NOTE --------------------------------------------------------------
+
+const sal_uInt16 EXC_ID_NOTE                = 0x001C;
+const sal_uInt16 EXC_NOTE_VISIBLE           = 0x0002;
+const sal_uInt16 EXC_NOTE5_MAXLEN           = 2048;
+
+// (0x005D) OBJ ---------------------------------------------------------------
+
+const sal_uInt16 EXC_ID_OBJ                 = 0x005D;
+
+const sal_uInt16 EXC_OBJ_INVALID_ID         = 0x0000;
+
+// sub records
+const sal_uInt16 EXC_ID_OBJ_FTEND           = 0x0000;   /// End of OBJ.
+const sal_uInt16 EXC_ID_OBJ_FTMACRO         = 0x0004;   /// Macro link.
+const sal_uInt16 EXC_ID_OBJ_FTGMO           = 0x0006;   /// Group marker.
+const sal_uInt16 EXC_ID_OBJ_FTCF            = 0x0007;   /// Clipboard format.
+const sal_uInt16 EXC_ID_OBJ_FTPIOGRBIT      = 0x0008;   /// Option flags.
+const sal_uInt16 EXC_ID_OBJ_FTPICTFMLA      = 0x0009;   /// OLE link formula.
+const sal_uInt16 EXC_ID_OBJ_FTCBLS          = 0x000A;   /// Check box/radio button data.
+const sal_uInt16 EXC_ID_OBJ_FTSBS           = 0x000C;   /// Scroll bar data.
+const sal_uInt16 EXC_ID_OBJ_FTSBSFMLA       = 0x000E;   /// Scroll bar/list box/combo box cell link.
+const sal_uInt16 EXC_ID_OBJ_FTGBODATA       = 0x000F;   /// Group box data.
+const sal_uInt16 EXC_ID_OBJ_FTLBSDATA       = 0x0013;   /// List box/combo box data.
+const sal_uInt16 EXC_ID_OBJ_FTCBLSFMLA      = 0x0014;   /// Check box/radio button cell link.
+const sal_uInt16 EXC_ID_OBJ_FTCMO           = 0x0015;   /// Common object settings.
+const sal_uInt16 EXC_ID_OBJ_FTUNKNOWN       = 0xFFFF;   /// For internal use only.
+
+// ftCmo: object types
+const sal_uInt16 EXC_OBJ_CMO_GROUP          = 0x0000;
+const sal_uInt16 EXC_OBJ_CMO_LINE           = 0x0001;
+const sal_uInt16 EXC_OBJ_CMO_RECTANGLE      = 0x0002;
+const sal_uInt16 EXC_OBJ_CMO_ELLIPSE        = 0x0003;
+const sal_uInt16 EXC_OBJ_CMO_ARC            = 0x0004;
+const sal_uInt16 EXC_OBJ_CMO_CHART          = 0x0005;
+const sal_uInt16 EXC_OBJ_CMO_TEXT           = 0x0006;
+const sal_uInt16 EXC_OBJ_CMO_BUTTON         = 0x0007;
+const sal_uInt16 EXC_OBJ_CMO_PICTURE        = 0x0008;
+const sal_uInt16 EXC_OBJ_CMO_POLYGON        = 0x0009;
+const sal_uInt16 EXC_OBJ_CMO_CHECKBOX       = 0x000B;
+const sal_uInt16 EXC_OBJ_CMO_OPTIONBUTTON   = 0x000C;
+const sal_uInt16 EXC_OBJ_CMO_EDIT           = 0x000D;
+const sal_uInt16 EXC_OBJ_CMO_LABEL          = 0x000E;
+const sal_uInt16 EXC_OBJ_CMO_DIALOG         = 0x000F;
+const sal_uInt16 EXC_OBJ_CMO_SPIN           = 0x0010;
+const sal_uInt16 EXC_OBJ_CMO_SCROLLBAR      = 0x0011;
+const sal_uInt16 EXC_OBJ_CMO_LISTBOX        = 0x0012;
+const sal_uInt16 EXC_OBJ_CMO_GROUPBOX       = 0x0013;
+const sal_uInt16 EXC_OBJ_CMO_COMBOBOX       = 0x0014;
+const sal_uInt16 EXC_OBJ_CMO_NOTE           = 0x0019;
+const sal_uInt16 EXC_OBJ_CMO_DRAWING        = 0x001E;
+const sal_uInt16 EXC_OBJ_CMO_UNKNOWN        = 0xFFFF;   /// For internal use only.
+
+// ftCmo: flags
+const sal_uInt16 EXC_OBJ_CMO_PRINTABLE      = 0x0010;   /// Object printable
+
+// ftPioGrbit: flags
+const sal_uInt16 EXC_OBJ_PIO_MANUALSIZE     = 0x0001;
+const sal_uInt16 EXC_OBJ_PIO_LINKED         = 0x0002;
+const sal_uInt16 EXC_OBJ_PIO_SYMBOL         = 0x0008;
+const sal_uInt16 EXC_OBJ_PIO_CONTROL        = 0x0010;   /// Form control.
+const sal_uInt16 EXC_OBJ_PIO_CTLSSTREAM     = 0x0020;   /// Data in Ctls stream.
+const sal_uInt16 EXC_OBJ_PIO_AUTOLOAD       = 0x0200;
+
+// ftCbls: Check box/radio button data
+const sal_uInt16 EXC_OBJ_CBLS_STATEMASK     = 0x0003;
+const sal_uInt16 EXC_OBJ_CBLS_STATE_UNCHECK = 0x0000;
+const sal_uInt16 EXC_OBJ_CBLS_STATE_CHECK   = 0x0001;
+const sal_uInt16 EXC_OBJ_CBLS_STATE_TRI     = 0x0002;
+const sal_uInt16 EXC_OBJ_CBLS_FLAT          = 0x0001;
+
+// ftGboData: Group box data
+const sal_uInt16 EXC_OBJ_GBO_FLAT           = 0x0001;
+
+// ftLbsData: List box data
+const sal_uInt16 EXC_OBJ_LBS_SELMASK        = 0x0030;   /// Mask for selection type.
+const sal_uInt16 EXC_OBJ_LBS_SEL_SIMPLE     = 0x0000;   /// Simple selection.
+const sal_uInt16 EXC_OBJ_LBS_SEL_MULTI      = 0x0010;   /// Multi selection.
+const sal_uInt16 EXC_OBJ_LBS_SEL_EXT        = 0x0020;   /// Extended selection.
+const sal_uInt16 EXC_OBJ_LBS_FLAT           = 0x0008;
+const sal_uInt16 EXC_OBJ_LBS_COMBOMASK      = 0x0003;   /// Mask for combobox style.
+const sal_uInt16 EXC_OBJ_LBS_COMBO_STD      = 0x0000;   /// Standard combo box.
+const sal_uInt16 EXC_OBJ_LBS_COMBO_SIMPLE   = 0x0002;   /// Simple dropdown without field.
+const sal_uInt16 EXC_OBJ_LBS_FILTERED       = 0x0008;   /// Drowdown style: filtered.
+
+// ftSbs: Spin button/scrollbar data
+const sal_uInt16 EXC_OBJ_SBS_HORIZONTAL     = 0x0001;
+const sal_uInt16 EXC_OBJ_SBS_DEFAULTFLAGS   = 0x0001;
+const sal_uInt16 EXC_OBJ_SBS_FLAT           = 0x0008;
+const sal_Int16 EXC_OBJ_SBS_MINSCROLL       = 0;
+const sal_Int16 EXC_OBJ_SBS_MAXSCROLL       = 30000;
+
+/** Value binding mode for cells linked to form controls. */
+enum XclCtrlBindMode
+{
+    EXC_CTRL_BINDCONTENT,       /// Binds cell to content of control.
+    EXC_CTRL_BINDPOSITION       /// Binds cell to position in control (e.g. listbox selection index).
+};
+
+// (0x00EB) MSODRAWINGGROUP ---------------------------------------------------
+
+const sal_uInt16 EXC_ID_MSODRAWINGGROUP     = 0x00EB;
+
+// (0x00EC) MSODRAWING --------------------------------------------------------
+
+const sal_uInt16 EXC_ID_MSODRAWING          = 0x00EC;
+
+// additional flags not extant in svx headers
+const sal_uInt16 EXC_ESC_ANCHOR_POSLOCKED   = 0x0001;
+const sal_uInt16 EXC_ESC_ANCHOR_SIZELOCKED  = 0x0002;
+const sal_uInt16 EXC_ESC_ANCHOR_LOCKED      = EXC_ESC_ANCHOR_POSLOCKED|EXC_ESC_ANCHOR_SIZELOCKED;
+
+// (0x00ED) MSODRAWINGSELECTION -----------------------------------------------
+
+const sal_uInt16 EXC_ID_MSODRAWINGSEL       = 0x00ED;
+
+// (0x01B6) TXO ---------------------------------------------------------------
+
+const sal_uInt16 EXC_ID_TXO                 = 0x01B6;
+
+const sal_uInt8 EXC_TXO_HOR_LEFT            = 0x01;
+const sal_uInt8 EXC_TXO_HOR_CENTER          = 0x02;
+const sal_uInt8 EXC_TXO_HOR_RIGHT           = 0x03;
+const sal_uInt8 EXC_TXO_HOR_JUSTIFY         = 0x04;
+
+const sal_uInt8 EXC_TXO_VER_TOP             = 0x01;
+const sal_uInt8 EXC_TXO_VER_CENTER          = 0x02;
+const sal_uInt8 EXC_TXO_VER_BOTTOM          = 0x03;
+const sal_uInt8 EXC_TXO_VER_JUSTIFY         = 0x04;
+
+const sal_uInt16 EXC_TXO_TEXTROT_NONE       = 0x0000;
+const sal_uInt16 EXC_TXO_TEXTROT_STACKED    = 0x0001;      /// Stacked top to bottom.
+const sal_uInt16 EXC_TXO_TEXTROT_90_CCW     = 0x0002;      /// 90 degr. counterclockwise.
+const sal_uInt16 EXC_TXO_TEXTROT_90_CW      = 0x0003;      /// 90 degr. clockwise.
+
+// Structs and classes ========================================================
+
+// Escher client anchor -------------------------------------------------------
+
+class Rectangle;
+class ScDocument;
+class SvStream;
+class XclImpStream;
+class XclExpStream;
+
+/** Represents the position (anchor) of an Escher object in a Calc document. */
+struct XclEscherAnchor
+{
+    XclRange            maXclRange; /// Cell range address.
+    SCTAB               mnScTab;    /// Calc sheet index.
+    sal_uInt16          mnLX;       /// X offset in left column (1/1024 of column width).
+    sal_uInt16          mnTY;       /// Y offset in top row (1/256 of row height).
+    sal_uInt16          mnRX;       /// X offset in right column (1/1024 of column width).
+    sal_uInt16          mnBY;       /// Y offset in bottom row (1/256 of row height).
+
+    explicit            XclEscherAnchor( SCTAB nScTab );
+
+    /** Calculates a rectangle from the contained coordinates. */
+    Rectangle           GetRect( ScDocument& rDoc, MapUnit eMapUnit ) const;
+    /** Initializes the anchor coordinates from a rectangle. */
+    void                SetRect( ScDocument& rDoc, const Rectangle& rRect, MapUnit eMapUnit );
+};
+
+SvStream& operator>>( SvStream& rStrm, XclEscherAnchor& rAnchor );
+SvStream& operator<<( SvStream& rStrm, const XclEscherAnchor& rAnchor );
+
+XclImpStream& operator>>( XclImpStream& rStrm, XclEscherAnchor& rAnchor );
+XclExpStream& operator<<( XclExpStream& rStrm, const XclEscherAnchor& rAnchor );
+
+// ----------------------------------------------------------------------------
+
+/** Identifies an Escher object by sheet index and object identifier. */
+struct XclObjId
+{
+    SCTAB               mnScTab;        /// Calc sheet index.
+    sal_uInt16          mnObjId;        /// Excel object identifier.
+
+    explicit            XclObjId();
+    explicit            XclObjId( SCTAB nScTab, sal_uInt16 nObjId );
+};
+
+bool operator==( const XclObjId& rL, const XclObjId& rR );
+bool operator<( const XclObjId& rL, const XclObjId& rR );
+
+// ----------------------------------------------------------------------------
+
+/** Contains data of a TXO record for text boxes. */
+struct XclTxoData
+{
+    sal_uInt16          mnFlags;        /// Option flags and alignment.
+    sal_uInt16          mnOrient;       /// Text orientation.
+    sal_uInt16          mnTextLen;      /// Length of the string.
+    sal_uInt16          mnFormatSize;   /// Size of the format run buffer (bytes).
+
+    explicit            XclTxoData();
+
+    sal_uInt8           GetXclHorAlignment() const;
+    void                SetXclHorAlignment( sal_uInt8 nXclAlign );
+
+    sal_uInt8           GetXclVerAlignment() const;
+    void                SetXclVerAlignment( sal_uInt8 nXclAlign );
+};
+
+XclImpStream& operator>>( XclImpStream& rStrm, XclTxoData& rData );
+XclExpStream& operator<<( XclExpStream& rStrm, const XclTxoData& rData );
+
+// ----------------------------------------------------------------------------
+
+namespace com { namespace sun { namespace star {
+    namespace drawing { class XShape; }
+    namespace awt { class XControlModel; }
+} } }
+
+class SdrObject;
+
+/** Provides static helper functions for form controls. */
+class XclControlObjHelper
+{
+public:
+    /** Returns the API control model from the passed API shape object. */
+    static ::com::sun::star::uno::Reference< ::com::sun::star::awt::XControlModel >
+                        GetModelFromShape( ::com::sun::star::uno::Reference< ::com::sun::star::drawing::XShape > xShape );
+
+    /** Returns the component service name for the passed control type. */
+    static ::rtl::OUString GetTbxServiceName( sal_uInt16 nCtrlType );
+    /** Returns a default control name for the passed control type. */
+    static ::rtl::OUString GetTbxControlName( sal_uInt16 nCtrlType );
+
+    /** Returns the listener type (interface name) for macro events for the passed control type. */
+    static ::rtl::OUString GetTbxListenerType( sal_uInt16 nCtrlType );
+    /** Returns the event method (function name) for macro events for the passed control type. */
+    static ::rtl::OUString GetTbxEventMethod( sal_uInt16 nCtrlType );
+    /** Returns the script type string needed for a script event descriptor. */
+    static ::rtl::OUString GetTbxScriptType();
+
+    /** Returns the Calc macro name from an Excel macro name. */
+    static ::rtl::OUString GetScMacroName( const String& rXclMacroName );
+    /** Returns the Excel macro name from a Calc macro name. */
+    static String       GetXclMacroName( const ::rtl::OUString& rScMacroName );
+};
+
+// ============================================================================
+
+#endif
+
--- sc/source/filter/inc/xiescher.hxx.orig	1970-01-01 08:00:00.000000000 +0800
+++ sc/source/filter/inc/xiescher.hxx	2008-06-04 12:38:12.000000000 +0800
@@ -0,0 +1,633 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: xiescher.hxx,v $
+ * $Revision: 1.28 $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+
+#ifndef SC_XIESCHER_HXX
+#define SC_XIESCHER_HXX
+
+#include <vector>
+#include <list>
+#include <map>
+#include <svx/msdffimp.hxx>
+#include "xlescher.hxx"
+#include "xiroot.hxx"
+#include "xistring.hxx"
+
+namespace com { namespace sun { namespace star {
+    namespace script { struct ScriptEventDescriptor; }
+} } }
+
+class ScfProgressBar;
+class ScfPropertySet;
+
+// Text box data ==============================================================
+
+class XclImpTxoData : protected XclImpRoot
+{
+public:
+    explicit            XclImpTxoData( const XclImpRoot& rRoot );
+
+    /** Reads a TXO record and following CONTINUE records for string and formatting data. */
+    void                ReadTxo( XclImpStream& rStrm );
+
+    /** Returns the text orientation. */
+    inline sal_uInt16   GetOrientation() const { return maData.mnOrient; }
+    /** Returns the string data, if there is any. */
+    inline const XclImpString* GetString() const { return mxString.get(); }
+
+    /** Sets the text to the passed SdrObject, if it can take text. */
+    void                ProcessSdrObject( SdrObject& rSdrObj ) const;
+
+private:
+    XclTxoData          maData;         /// Data from the TXO record.
+    XclImpStringRef     mxString;       /// Plain or rich string.
+};
+
+typedef ScfRef< XclImpTxoData > XclImpTxoDataRef;
+
+// Escher objects =============================================================
+
+class XclImpDrawObjBase;
+typedef ScfRef< XclImpDrawObjBase > XclImpDrawObjRef;
+
+/** Base class for drawing objects (OBJ records). */
+class XclImpDrawObjBase : protected XclImpRoot, ScfNoCopy
+{
+public:
+    explicit            XclImpDrawObjBase( const XclImpRoot& rRoot );
+    virtual             ~XclImpDrawObjBase();
+
+    /** Reads the FTCMO subrecord (common object data) in an OBJ record, returns a new object. */
+    static XclImpDrawObjRef ReadObjCmo( XclImpStream& rStrm );
+    /** Reads the contents of the specified subrecord of an OBJ record from stream. */
+    virtual void        ReadSubRecord( XclImpStream& rStrm, sal_uInt16 nSubRecId, sal_uInt16 nSubRecSize );
+    /** Reads the client anchor from an msofbtClientAnchor Escher record. */
+    void                ReadClientAnchor( SvStream& rEscherStrm, const DffRecordHeader& rHeader );
+
+    /** Sets common object data from FTCMO subrecord. */
+    void                SetObjData( sal_uInt16 nObjType, sal_uInt16 nObjId, sal_uInt16 nObjFlags );
+    /** Sets shape data from Escher stream. */
+    void                SetShapeData( sal_uInt32 nShapeId, sal_uInt32 nShapeFlags, sal_uInt32 nShapeBlipId );
+    /** Sets shape data from Escher stream. */
+    inline void         SetVisible( const bool nObjVisible ) { mnObjVisible = nObjVisible; }
+    /** Sets whether this is an area object (then its width and height must be greater than 0). */
+    inline void         SetAreaObj( bool bAreaObj ) { mbAreaObj = bAreaObj; }
+    /** Sets the object anchor explicitly. */
+    void                SetClientAnchor( const XclEscherAnchor& rAnchor );
+
+    /** If set, the SdrObject will not be created, processed, or inserted into the draw page. */
+    inline void         SetInvalid() { mbValid = false; }
+    /** If set, the SdrObject will be created or processed, but not be inserted into the draw page. */
+    inline void         SetSkipInsertSdr() { mbInsSdr = false; }
+
+    /** Returns the Calc sheet index of this object. */
+    inline SCTAB        GetScTab() const { return maObjId.mnScTab; }
+    /** Returns the sheet index and Excel object identifier from OBJ record. */
+    inline const XclObjId& GetObjId() const { return maObjId; }
+    /** Returns the Excel object type from OBJ record. */
+    inline sal_uInt16   GetObjType() const { return mnObjType; }
+    /** Returns associated macro name, if set, otherwise zero length string. */
+    const String        GetMacroName() const { return maMacroName; }
+
+    /** Returns the shape identifier used in the Escher stream. */
+    inline sal_uInt32   GetShapeId() const { return mnShapeId; }
+    /** Returns the shape flags from the Escher stream. */
+    inline sal_uInt32   GetShapeFlags() const { return mnShapeFlags; }
+    /** Returns the BLIP identifier for the meta file. */
+    inline sal_uInt32   GetShapeBlipId() const { return mnShapeBlipId; }
+
+    /** Returns true, if the object is valid and will be processed.. */
+    inline bool         IsValid() const { return mbValid; }
+    /** Returns true, if the SdrObject will be created or processed, but not be inserted into the draw page. */
+    inline bool         IsInsertSdr() const { return mbInsSdr; }
+    /** Returns true, if Escher object is printable. */
+    inline bool         IsPrintable() const { return ::get_flag( mnObjFlags, EXC_OBJ_CMO_PRINTABLE ); }
+    /** Returns true, if Escher objest is not hidden. */
+    inline bool         IsVisible() const { return mnObjVisible; }
+
+    /** Returns true, if the passed size is valid for this object. */
+    bool                IsValidSize( const Rectangle& rAnchorRect ) const;
+    /** Returns the area in the sheet used by this object. */
+    ScRange             GetUsedArea() const;
+    /** Returns the area on the drawing layer for this object. */
+    Rectangle           GetAnchorRect() const;
+
+    /** Returns the needed size on the progress bar (calls virtual DoGetProgressSize() function). */
+    sal_Size            GetProgressSize() const;
+    /** Additional processing for the passed SdrObject (calls virtual DoProcessSdrObj() function). */
+    void                ProcessSdrObject( SdrObject& rSdrObj ) const;
+
+protected:
+    /** Reads the contents of the ftMacro sub structure in an OBJ record. */
+    void                ReadMacro( XclImpStream& rStrm );
+
+    /** Derived classes may return a progress bar size different from 1. */
+    virtual sal_Size    DoGetProgressSize() const;
+    /** Derived classes may perform additional processing for the passed SdrObject. */
+    virtual void        DoProcessSdrObj( SdrObject& rSdrObj ) const;
+
+private:
+    typedef ScfRef< XclEscherAnchor > XclEscherAnchorRef;
+
+    XclEscherAnchorRef  mxAnchor;       /// The position of the object in the containing sheet.
+    XclObjId            maObjId;        /// Sheet index and object identifier.
+    sal_uInt16          mnObjType;      /// The Excel object type from OBJ record.
+    sal_uInt16          mnObjFlags;     /// Additional flags from OBJ record.
+    sal_uInt32          mnShapeId;      /// Shape ID from Escher stream.
+    sal_uInt32          mnShapeFlags;   /// Shape flags from Escher stream.
+    sal_uInt32          mnShapeBlipId;  /// The BLIP identifier (meta file).
+    String              maMacroName;    /// Name of an attached macro.
+    bool                mbValid;        /// true = Object is valid, do processing and insertion.
+    bool                mbAreaObj;      /// true = Width and height must be greater than 0.
+    bool                mbInsSdr;       /// true = Insert the SdrObject into draw page.
+    bool                mnObjVisible;   /// falgs for visibility
+};
+
+// ----------------------------------------------------------------------------
+
+/** A simple drawing object, e.g. line, rectangle, textbox, or bitmap. */
+class XclImpDrawingObj : public XclImpDrawObjBase
+{
+public:
+    /** @param bAreaObj  true = Width and height of the object must be greater than 0. */
+    explicit            XclImpDrawingObj( const XclImpRoot& rRoot, bool bAreaObj );
+
+    /** Stores the passed textbox data from a TXO record. */
+    inline void         SetTxoData( XclImpTxoDataRef xTxoData ) { mxTxoData = xTxoData; }
+
+    /** Returns the text orientation from the contained textbox data. */
+    inline sal_uInt16   GetOrientation() const { return mxTxoData.is() ? mxTxoData->GetOrientation() : EXC_TXO_TEXTROT_NONE; }
+    /** Returns the string from the contained textbox data. */
+    inline const XclImpString* GetString() const { return mxTxoData.is() ? mxTxoData->GetString() : 0; }
+
+protected:
+    /** Inserts the contained text data at the passed object. */
+    virtual void        DoProcessSdrObj( SdrObject& rSdrObj ) const;
+
+private:
+    XclImpTxoDataRef    mxTxoData;      /// Textbox data from TXO record.
+};
+
+// ----------------------------------------------------------------------------
+
+/** A note object, which is a specialized text box objext. */
+class XclImpNoteObj : public XclImpDrawingObj
+{
+public:
+    explicit            XclImpNoteObj( const XclImpRoot& rRoot );
+
+    /** Sets note flags and the note position in the Calc sheet. */
+    void                SetNoteData( const ScAddress& rScPos, sal_uInt16 nNoteFlags );
+
+protected:
+    /** Inserts the note into the document, sets visibility. */
+    virtual void        DoProcessSdrObj( SdrObject& rSdrObj ) const;
+
+private:
+    ScAddress           maScPos;        /// Cell position of the note object.
+    sal_uInt16          mnNoteFlags;    /// Flags from NOTE record.
+};
+
+// ----------------------------------------------------------------------------
+
+/** Helper class for form controils to manage spreadsheet links . */
+class XclImpControlObjHelper
+{
+public:
+    typedef ::com::sun::star::uno::Reference< ::com::sun::star::awt::XControlModel > XControlModelRef;
+
+public:
+    explicit            XclImpControlObjHelper( XclCtrlBindMode eBindMode );
+    virtual             ~XclImpControlObjHelper();
+
+    /** Sets the control model from the created form control object. */
+    inline void         SetControlModel( XControlModelRef xCtrlModel ) { mxCtrlModel = xCtrlModel; }
+
+protected:
+    /** Reads the formula for the linked cell from the current position of the stream. */
+    void                ReadCellLinkFormula( XclImpStream& rStrm );
+    /** Reads the formula for the source range from the current position of the stream. */
+    void                ReadSrcRangeFormula( XclImpStream& rStrm );
+
+    /** Returns true, if a linked cell address is present. */
+    inline bool         HasCellLink() const { return mxCellLink.is(); }
+    /** Returns true, if a linked source cell range is present. */
+    inline bool         HasSourceRange() const { return mxSrcRange.is(); }
+
+    /** Returns the property set of the form control object. */
+    ScfPropertySet      GetControlPropSet() const;
+    /** Tries to set a spreadsheet cell link and source range link at the passed form control. */
+    void                ConvertSheetLinks( const XclImpRoot& rRoot, SdrObject& rSdrObj ) const;
+
+private:
+    XControlModelRef    mxCtrlModel;    /// Model of the created form control object.
+    ScfRef< ScAddress > mxCellLink;     /// Linked cell in the Calc document.
+    ScfRef< ScRange >   mxSrcRange;     /// Source data range in the Calc document.
+    XclCtrlBindMode     meBindMode;     /// Value binding mode.
+};
+
+// ----------------------------------------------------------------------------
+
+/** An old form control object (does not use the OLE mechanism, but is a "simple" drawing object). */
+class XclImpTbxControlObj : public XclImpDrawingObj, public XclImpControlObjHelper
+{
+public:
+    explicit            XclImpTbxControlObj( const XclImpRoot& rRoot );
+
+    /** Reads the contents of the specified subrecord of an OBJ record from stream. */
+    virtual void        ReadSubRecord( XclImpStream& rStrm, sal_uInt16 nSubRecId, sal_uInt16 nSubRecSize );
+
+    /** Returns the complete component service name for this control. */
+    ::rtl::OUString     GetServiceName() const;
+    /** Tries to fill the passed descriptor with imported macro data.
+        @return  true = Control is associated with a macro, rEvent contains valid data. */
+    bool                FillMacroDescriptor(
+                            ::com::sun::star::script::ScriptEventDescriptor& rEvent ) const;
+
+protected:
+    /** Overloaded to do additional processing on the SdrObject. */
+    virtual void        DoProcessSdrObj( SdrObject& rSdrObj ) const;
+
+private:
+    /** Reads the contents of the ftCbls sub structure in an OBJ record. */
+    void                ReadCbls( XclImpStream& rStrm );
+    /** Reads the contents of the ftCblsFmla sub structure in an OBJ record. */
+    void                ReadCblsFmla( XclImpStream& rStrm );
+    /** Reads the contents of the ftLbsData sub structure in an OBJ record. */
+    void                ReadLbsData( XclImpStream& rStrm );
+    /** Reads the contents of the ftSbs sub structure in an OBJ record. */
+    void                ReadSbs( XclImpStream& rStrm );
+    /** Reads the contents of the ftGboData sub structure in an OBJ record. */
+    void                ReadGboData( XclImpStream& rStrm );
+
+private:
+    ScfInt16Vec         maMultiSel;     /// Indexes of all selected entries in a multi selection.
+    sal_uInt16          mnState;        /// Checked/unchecked state.
+    sal_Int16           mnSelEntry;     /// Index of selected entry (1-based).
+    sal_Int16           mnSelType;      /// Selection type.
+    sal_Int16           mnLineCount;    /// Combobox dropdown line count.
+    sal_Int16           mnScrollValue;  /// Scrollbar: Current value.
+    sal_Int16           mnScrollMin;    /// Scrollbar: Minimum value.
+    sal_Int16           mnScrollMax;    /// Scrollbar: Maximum value.
+    sal_Int16           mnScrollStep;   /// Scrollbar: Single step.
+    sal_Int16           mnScrollPage;   /// Scrollbar: Page step.
+    bool                mbFlatButton;   /// False = 3D button style; True = Flat button style.
+    bool                mbFlatBorder;   /// False = 3D border style; True = Flat border style.
+    bool                mbScrollHor;    /// Scrollbar: true = horizontal.
+};
+
+// ----------------------------------------------------------------------------
+
+/** A common Escher OLE object, or an OLE form control. */
+class XclImpOleObj : public XclImpDrawObjBase, public XclImpControlObjHelper
+{
+public:
+    explicit            XclImpOleObj( const XclImpRoot& rRoot );
+
+    /** Reads the contents of the specified subrecord of an OBJ record from stream. */
+    virtual void        ReadSubRecord( XclImpStream& rStrm, sal_uInt16 nSubRecId, sal_uInt16 nSubRecSize );
+
+    /** Allows to detect whether the object is iconified. */
+    inline bool         IsIconified() const { return mbAsSymbol; }
+    /** Returns true, if this object is a form control, and false, if it is a common OLE object. */
+    inline bool         IsControl() const { return mbControl && mbUseCtlsStrm; }
+
+    /** Returns the OLE storage name used in the Excel document. */
+    inline const String& GetStorageName() const { return maStorageName; }
+    /** Returns the position in Ctrl stream for additional form control data. */
+    inline sal_Size      GetCtlsStreamPos() const { return mnCtlsStrmPos; }
+
+protected:
+    /** Overloaded to do additional processing on the SdrObject. */
+    virtual void        DoProcessSdrObj( SdrObject& rSdrObj ) const;
+
+private:
+    /** Reads the contents of the ftPioGrbit sub structure in an OBJ record. */
+    void                ReadPioGrbit( XclImpStream& rStrm );
+    /** Reads the contents of the ftPictFmla sub structure in an OBJ record. */
+    void                ReadPictFmla( XclImpStream& rStrm, sal_uInt16 nRecSize );
+
+private:
+    String              maStorageName;  /// Name of the OLE storage for this object.
+    sal_Size            mnCtlsStrmPos;  /// Position in 'Ctls' stream for controls.
+    bool                mbAsSymbol;     /// true = Show as symbol.
+    bool                mbLinked;       /// true = Linked; false = Embedded.
+    bool                mbControl;      /// true = Form control, false = OLE object.
+    bool                mbUseCtlsStrm;  /// true = Form control data in 'Ctls' stream, false = Own storage.
+};
+
+// ----------------------------------------------------------------------------
+
+struct XclChLineFormat;
+struct XclChAreaFormat;
+class XclImpChart;
+
+/** A chart object. This is the drawing object wrapper for the chart data. */
+class XclImpChartObj : public XclImpDrawObjBase
+{
+public:
+    /** @param bOwnTab  True = chart is on an own sheet; false = chart is an embedded object. */
+    explicit            XclImpChartObj( const XclImpRoot& rRoot, bool bOwnTab );
+
+    /** Reads remaining data from a BIFF5 OBJ record. */
+    void                ReadObj5( XclImpStream& rStrm );
+    /** Reads the complete chart substream (BOF/EOF block).
+        @descr  The passed stream must be located in the BOF record of the chart substream. */
+    void                ReadChartSubStream( XclImpStream& rStrm );
+
+    /** Creates and returns a new SdrObject that contains the chart. Caller takes ownership! */
+    SdrObject*          CreateSdrObject( const Rectangle& rAnchorRect, ScfProgressBar& rProgress ) const;
+
+protected:
+    /** Returns the needed size on the progress bar. */
+    virtual sal_Size    DoGetProgressSize() const;
+
+private:
+    /** Calculates the object anchor of a sheet chart (chart fills one page). */
+    void                FinalizeTabChart();
+
+private:
+    typedef ScfRef< XclImpChart >       XclImpChartRef;
+    typedef ScfRef< XclChLineFormat >   XclChLineFmtRef;
+    typedef ScfRef< XclChAreaFormat >   XclChAreaFmtRef;
+
+    XclImpChartRef      mxChart;        /// The chart itself (BOF/EOF substream data).
+    XclChLineFmtRef     mxLineFmt;      /// Line formatting for chart frame (BIFF5).
+    XclChAreaFmtRef     mxAreaFmt;      /// Area formatting for chart frame (BIFF5).
+    bool                mbOwnTab;       /// true = own sheet; false = embedded object.
+};
+
+// Escher stream conversion ===================================================
+
+/** The solver container collects all connector rules for connected objects. */
+class XclImpSolverContainer : public SvxMSDffSolverContainer
+{
+public:
+    /** Reads the entire solver container. Stream must point to begin of container header. */
+    void                ReadSolverContainer( SvStream& rEscherStrm );
+
+    /** Inserts a new pointer to an SdrObject by the related shape ID. */
+    void                InsertSdrObjectInfo( const XclImpDrawObjBase& rDrawObj, SdrObject* pSdrObj );
+    /** Removes a pointer to an SdrObject by the related shape ID. */
+    void                RemoveSdrObjectInfo( const XclImpDrawObjBase& rDrawObj );
+
+    /** Inserts the SdrObject pointers into all connector rules. */
+    void                UpdateConnectorRules();
+    /** Removes all contained connector rules. */
+    void                RemoveConnectorRules();
+
+private:
+    /** Returns the first connector rule from the internal list. */
+    SvxMSDffConnectorRule* GetFirstRule();
+    /** Returns the next connector rule from the internal list. */
+    SvxMSDffConnectorRule* GetNextRule();
+    /** Updates the data of a connected shape in a connector rule. */
+    void                UpdateConnection( sal_uInt32 nShapeId, SdrObject*& rpSdrObj, sal_uInt32* pnShapeFlags = 0 );
+
+private:
+    /** Stores data about an SdrObject processed during import. */
+    struct XclImpSdrInfo
+    {
+        SdrObject*          mpSdrObj;       /// Pointer to an SdrObject.
+        sal_uInt32          mnShapeFlags;   /// Shape flags from escher stream.
+        inline explicit     XclImpSdrInfo() : mpSdrObj( 0 ), mnShapeFlags( 0 ) {}
+        inline void         Set( SdrObject* pSdrObj, sal_uInt32 nShapeFlags )
+                                { mpSdrObj = pSdrObj; mnShapeFlags = nShapeFlags; }
+    };
+    typedef ::std::map< sal_uInt32, XclImpSdrInfo > XclImpSdrInfoMap;
+
+    XclImpSdrInfoMap    maSdrInfoMap;   /// Maps shape IDs to SdrObjects.
+};
+
+// ----------------------------------------------------------------------------
+
+class XclImpObjectManager;
+class XclImpOcxConverter;
+
+/** Derived from SvxMSDffManager, contains core implementation of Escher stream import. */
+class XclImpDffManager : public SvxMSDffManager, protected XclImpRoot
+{
+public:
+    explicit            XclImpDffManager(
+                            const XclImpRoot& rRoot,
+                            XclImpObjectManager& rObjManager,
+                            SvStream& rEscherStrm );
+    virtual             ~XclImpDffManager();
+
+    /** Initializes the internal progress bar with the passed size and starts it. */
+    void                StartProgressBar( sal_Size nProgressSize );
+    /** Processes the leading drawing group container in the Escher stream. */
+    void                ProcessDrawingGroup( SvStream& rEscherStrm );
+    /** Processes a drawing container for a sheet in the Escher stream, converts all objects. */
+    void                ProcessDrawing( SvStream& rEscherStrm, sal_Size nStrmPos );
+    /** Processes a chart from an Excel chart sheet, converts it to a chart object. */
+    void                ProcessTabChart( const XclImpChartObj& rChartObj );
+
+    /** Returns the used area in the sheet with the passed index. */
+    ScRange             GetUsedArea( SCTAB nScTab ) const;
+
+protected:
+    /** Reads the client anchor from the Escher stream and sets it at the correct Escher object. */
+    virtual void        ProcessClientAnchor2(
+                            SvStream& rEscherStrm,
+                            DffRecordHeader& rHeader,
+                            void* pClientData,
+                            DffObjData& rObjData );
+    /** Processes an Escher object, reads properties from Escher stream. */
+    virtual SdrObject*  ProcessObj(
+                            SvStream& rEscherStrm,
+                            DffObjData& rObjData,
+                            void* pClientData,
+                            Rectangle& rTextRect,
+                            SdrObject* pOldSdrObj = 0 );
+    /** Returns the BLIP stream position, based on the passed Escher stream position. */
+    virtual ULONG       Calc_nBLIPPos( ULONG nOrgVal, ULONG nStreamPos ) const;
+    /** Returns a color from the Excel color palette. */
+    virtual FASTBOOL    GetColorFromPalette( USHORT nIndex, Color& rColor ) const;
+
+private:
+    /** Reads contents of a hyperlink property and returns the extracted URL. */
+    ::rtl::OUString     ReadHlinkProperty( SvStream& rEscherStrm ) const;
+
+    /** Processes a drawing group container (global drawing data). */
+    void                ProcessDggContainer( SvStream& rEscherStrm, const DffRecordHeader& rDggHeader );
+    /** Processes a drawing container (all drawing data of a sheet). */
+    void                ProcessDgContainer( SvStream& rEscherStrm, const DffRecordHeader& rDgHeader );
+    /** Processes the global shape group container (all shapes of a sheet). */
+    void                ProcessShGrContainer( SvStream& rEscherStrm, const DffRecordHeader& rShGrHeader );
+    /** Processes the solver container (connectors of a sheet). */
+    void                ProcessSolverContainer( SvStream& rEscherStrm, const DffRecordHeader& rSolverHeader );
+    /** Processes a shape or shape group container (one top-level shape). */
+    void                ProcessShContainer( SvStream& rEscherStrm, const DffRecordHeader& rShHeader );
+
+    /** Inserts the passed SdrObject into the document. This function takes ownership of pSdrObj! */
+    void                InsertSdrObject( const XclImpDrawObjBase& rDrawObj, SdrObject* pSdrObj );
+
+    /** Tries to create a custom SdrObject for specific object types. */
+    SdrObject*          CreateCustomSdrObject( XclImpDrawObjBase& rDrawObj, const Rectangle& rAnchorRect );
+    /** Creates the SdrObject for the passed Excel OLE object. */
+    SdrObject*          CreateSdrObject( XclImpOleObj& rOleObj, const Rectangle& rAnchorRect );
+    /** Creates the SdrObject for the passed Excel textbox control object. */
+    SdrObject*          CreateSdrObject( XclImpTbxControlObj& rTbxCtrlObj, const Rectangle& rAnchorRect );
+    /** Creates the SdrObject for the passed Excel chart object. */
+    SdrObject*          CreateSdrObject( const XclImpChartObj& rChartObj, const Rectangle& rAnchorRect );
+
+    /** Updates the used area of a sheet with the position and size of the passed object. */
+    void                UpdateUsedArea( const XclImpDrawObjBase& rDrawObj );
+
+private:
+    typedef ::std::map< SCTAB, ScRange >    ScRangeMap;
+    typedef ScfRef< ScfProgressBar >        ScfProgressBarRef;
+    typedef ScfRef< XclImpOcxConverter >    XclImpOcxConvRef;
+
+    XclImpObjectManager& mrObjManager;      /// The Excel object manager.
+    XclImpSolverContainer maSolverCont;     /// The solver container for connector rules.
+    ScRangeMap          maUsedAreaMap;      /// Used ranges for all sheets.
+    ScfProgressBarRef   mxProgress;         /// The progress bar used in ProcessObj().
+    XclImpOcxConvRef    mxOcxConverter;     /// The form controls converter.
+    sal_uInt32          mnOleImpFlags;      /// Application OLE import settings.
+};
+
+// The object manager =========================================================
+
+/** Stores all drawing and OLE objects and additional data related to these objects. */
+class XclImpObjectManager : protected XclImpRoot
+{
+public:
+    explicit            XclImpObjectManager( const XclImpRoot& rRoot );
+    virtual             ~XclImpObjectManager();
+
+    // *** Read Excel records *** ---------------------------------------------
+
+    /** Reads the OBJ record (BIFF5 only). */
+    void                ReadObj5( XclImpStream& rStrm );
+
+    /** Reads the MSODRAWINGGROUP record. */
+    void                ReadMsoDrawingGroup( XclImpStream& rStrm );
+    /** Reads the MSODRAWING or MSODRAWINGSELECTION record. */
+    void                ReadMsoDrawing( XclImpStream& rStrm );
+    /** Reads the NOTE record. */
+    void                ReadNote( XclImpStream& rStrm );
+
+    /** Inserts a new chart object and reads the chart substream (BOF/EOF block).
+        @descr  Used to import chart sheets, which do not have a corresponding OBJ record. */
+    void                ReadTabChart( XclImpStream& rStrm );
+
+    // *** Drawing objects *** ------------------------------------------------
+
+    /** Finds the OBJ record data related to the Escher shape at the passed position. */
+    XclImpDrawObjRef    FindDrawObj( const DffRecordHeader& rHeader ) const;
+    /** Finds the OBJ record data specified by the passed object identifier. */
+    XclImpDrawObjRef    FindDrawObj( const XclObjId& rObjId ) const;
+    /** Finds the TXO record data related to the Escher shape at the passed position. */
+    XclImpTxoDataRef    FindTxoData( const DffRecordHeader& rHeader ) const;
+
+    /** Sets the object with the passed identification to be ignored on import. */
+    void                SetInvalidObj( SCTAB nScTab, sal_uInt16 nObjId );
+
+    // *** Drawing object conversion *** --------------------------------------
+
+    /** Returns the DFF manager (Escher stream converter). Don't call before the Escher stream is read. */
+    XclImpDffManager&   GetDffManager();
+    /** Inserts all objects into the Calc document. */
+    void                ConvertObjects();
+
+    /** Returns the used area in the sheet with the passed index. */
+    ScRange             GetUsedArea( SCTAB nScTab ) const;
+
+    // ------------------------------------------------------------------------
+private:
+    /** Reads contents of an Escher record and append data to internal Escher stream. */
+    void                ReadEscherRecord( XclImpStream& rStrm );
+    /** Reads a BIFF8 OBJ record following an MSODRAWING record. */
+    void                ReadObj8( XclImpStream& rStrm );
+    /** Reads the TXO record. */
+    void                ReadTxo( XclImpStream& rStrm );
+
+    /** Tries to start a complete chart substream by checking if next record is a BOF. */
+    bool                StartChartSubStream( XclImpStream& rStrm );
+
+    /** Returns the size of the progress bar shown while processing all objects. */
+    sal_Size            GetProgressSize() const;
+
+    // ------------------------------------------------------------------------
+private:
+    typedef ::std::vector< sal_Size >                   StreamPosVec;
+    typedef ::std::map< sal_Size, XclImpDrawObjRef >    XclImpObjMap;
+    typedef ::std::map< XclObjId, XclImpDrawObjRef >    XclImpObjMapById;
+    typedef ::std::map< sal_Size, XclImpTxoDataRef >    XclImpTxoMap;
+    typedef ScfRef< XclImpChartObj >                    XclImpChartObjRef;
+    typedef ::std::list< XclImpChartObjRef >            XclImpChartObjList;
+    typedef ScfRef< XclImpDffManager >                  XclImpDffMgrRef;
+    typedef ::std::vector< XclObjId >                   XclObjIdVec;
+
+    SvMemoryStream      maEscherStrm;       /// Copy of Escher stream in memory.
+    StreamPosVec        maTabStrmPos;       /// Start positions of Escher data for sheets.
+    XclImpObjMap        maObjMap;           /// Maps drawing objects to Escher stream position.
+    XclImpObjMapById    maObjMapId;         /// Maps drawing objects to sheet index and object ID.
+    XclImpTxoMap        maTxoMap;           /// Maps TXO textbox data to sheet index and object ID.
+    XclImpChartObjList  maTabCharts;        /// Charts imported from Excel chart sheets.
+    XclImpDffMgrRef     mxDffManager;   /// The Escher stream converter.
+    XclObjIdVec         maInvalidObjs;      /// All Escher objects to skip.
+};
+
+// Escher property set helper =================================================
+
+/** This class reads an Escher property set (msofbtOPT record).
+    @descr  It can return separate property values or an item set which contains
+    items translated from these properties. */
+class XclImpEscherPropSet : protected XclImpRoot
+{
+public:
+    explicit            XclImpEscherPropSet( const XclImpRoot& rRoot );
+
+    /** Reads an Escher property set from the stream.
+        @descr  The stream must point to the start of an Escher record containing properties. */
+    void                Read( XclImpStream& rStrm );
+
+    /** Returns the specified property or the default value, if not extant. */
+    sal_uInt32          GetPropertyValue( sal_uInt16 nPropId, sal_uInt32 nDefault = 0 ) const;
+
+    /** Translates the properties and fills the item set. */
+    void                FillToItemSet( SfxItemSet& rItemSet ) const;
+
+private:
+    typedef ::std::auto_ptr< SvMemoryStream > SvMemoryStreamPtr;
+
+    XclImpObjectManager maObjManager;   /// Local object manager, contains SVX DFF manager.
+    XclImpDffManager&   mrDffManager;   /// Reference to DFF manager contained in object manager.
+    SvMemoryStreamPtr   mxMemStrm;      /// Helper stream.
+};
+
+XclImpStream& operator>>( XclImpStream& rStrm, XclImpEscherPropSet& rPropSet );
+
+// ============================================================================
+
+#endif
+
--- sc/source/filter/excel/xiescher.cxx.orig	2008-04-11 04:16:07.000000000 +0800
+++ sc/source/filter/excel/xiescher.cxx	2008-06-04 12:38:12.000000000 +0800
@@ -296,7 +296,8 @@ XclImpDrawObjBase::XclImpDrawObjBase( co
     mnShapeBlipId( 0 ),
     mbValid( true ),
     mbAreaObj( false ),
-    mbInsSdr( true )
+    mbInsSdr( true ),
+    mnObjVisible( 0 )
 {
 }
 
@@ -790,6 +791,7 @@ void XclImpTbxControlObj::DoProcessSdrOb
 
     // control printable?
     aPropSet.SetBoolProperty( CREATE_OUSTRING( "Printable" ), IsPrintable() );
+    aPropSet.SetBoolProperty( CREATE_OUSTRING( "EnableVisible" ), IsVisible() );
 
     // #118053# #i51348# set internal name of the control (use name from SdrObject, if extant)
     OUString aCtrlName = rSdrObj.GetName();
@@ -1552,6 +1554,7 @@ SdrObject* XclImpDffManager::ProcessObj(
 
     // set shape information from Escher stream
     xDrawObj->SetShapeData( rObjData.nShapeId, rObjData.nSpFlags, GetPropertyValue( DFF_Prop_pib ) );
+    xDrawObj->SetVisible( !GetPropertyBool( DFF_Prop_fHidden ) );
 
     /*  Connect textbox data (string, alignment, text orientation) to object.
         #98132# don't ask for a text-ID, Escher export doesn't set one. */
