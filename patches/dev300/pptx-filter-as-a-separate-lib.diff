diff --git a/scp2/source/ooo/file_ooo.scp b/scp2/source/ooo/file_ooo.scp
index f731f78..0990ba8 100644
--- scp2/source/ooo/file_ooo.scp
+++ scp2/source/ooo/file_ooo.scp
@@ -361,6 +361,8 @@ STD_FILTER_FILE( gid_File_Filter_Eme, eme)
 
 STD_FILTER_FILE_PATCH( gid_File_Filter_Sdfilt, sdfilt)
 
+STD_UNO_LIB_FILE( gid_File_Lib_Pptx, pptx )
+
 STD_FILTER_FILE( gid_File_Filter_Icg, icg)
 
 STD_FILTER_FILE( gid_File_Filter_Egi, egi)
diff --git a/scp2/source/ooo/module_hidden_ooo.scp b/scp2/source/ooo/module_hidden_ooo.scp
index 08f3d34..2b93f24 100644
--- scp2/source/ooo/module_hidden_ooo.scp
+++ scp2/source/ooo/module_hidden_ooo.scp
@@ -141,6 +141,7 @@ Module gid_Module_Root_Files_4
 	Files = (gid_File_Dat_Root4,
 	gid_File_Filter_Eme,
 	gid_File_Filter_Sdfilt,
+	gid_File_Filter_Pptx,
 	gid_File_Filter_Icg,
 	gid_File_Filter_Egi,
 	gid_File_Filter_Epb,
diff --git a/sd/prj/build.lst b/sd/prj/build.lst
index c5ed381..9f3b451 100644
--- sd/prj/build.lst
+++ sd/prj/build.lst
@@ -30,6 +30,7 @@ sd	sd\source\filter\ppt					nmake	-	all	sd_ppt sd_inc NULL
 sd	sd\source\filter						nmake	-	all	sd_filt sd_sdi sd_ppt sd_inc NULL
 sd	sd\source\filter\cgm					nmake	-	all	sd_cgm sd_inc NULL
 sd	sd\source\filter\eppt					nmake	-	all	sd_eppt sd_inc NULL
+sd	sd\source\filter\pptx					nmake	-	all	sd_pptx sd_inc NULL
 sd	sd\source\filter\grf					nmake	-	all	sd_grf sd_inc NULL
 sd	sd\source\filter\xml					nmake	-	all	sd_xml sd_inc NULL
 sd	sd\source\filter\html					nmake	-	all	sd_html sd_inc NULL
@@ -40,4 +41,4 @@ sd	sd\source\ui\framework\configuration	nmake	-	all sd_framework_configuration s
 sd	sd\source\ui\framework\module       	nmake	-	all sd_framework_module sd_inc NULL
 sd	sd\source\ui\framework\factories       	nmake	-	all sd_framework_factories sd_inc NULL
 sd	sd\source\ui\framework\tools           	nmake	-	all sd_framework_tools sd_inc NULL
-sd	sd\util									nmake	-	all	sd_util sd_app sd_cgm sd_core sd_dlg sd_docsh sd_eppt sd_filt sd_func sd_grf sd_unid sd_view sd_xml sd_html sd_ppt sd_accessibility sd_animations sd_toolpanel sd_toolpanel_controls sd_tools sd_slsshell sd_slsmodel sd_slsview sd_slscontroller sd_slscache sd_notes sd_table sd_slideshow sd_presenter sd_undo sd_helper sd_framework_configuration sd_framework_module sd_framework_tools sd_framework_factories NULL
+sd	sd\util									nmake	-	all	sd_util sd_app sd_cgm sd_core sd_dlg sd_docsh sd_eppt sd_pptx sd_filt sd_func sd_grf sd_unid sd_view sd_xml sd_html sd_ppt sd_accessibility sd_animations sd_toolpanel sd_toolpanel_controls sd_tools sd_slsshell sd_slsmodel sd_slsview sd_slscontroller sd_slscache sd_notes sd_table sd_slideshow sd_presenter sd_undo sd_helper sd_framework_configuration sd_framework_module sd_framework_tools sd_framework_factories NULL
diff --git a/sd/prj/d.lst b/sd/prj/d.lst
index fd21f7c..ebc244f 100644
--- sd/prj/d.lst
+++ sd/prj/d.lst
@@ -32,6 +32,7 @@ mkdir: %_DEST%\xml%_EXT%\uiconfig\modules\simpress\statusbar
 ..\%__SRC%\bin\sd??????.dll %_DEST%\bin%_EXT%\sd??????.dll
 ..\%__SRC%\bin\sd*.res %_DEST%\bin%_EXT%\sd*.res
 ..\%__SRC%\bin\sd???????.dll %_DEST%\bin%_EXT%\sd???????.dll
+..\%__SRC%\bin\pptx*.dll %_DEST%\bin%_EXT%\pptx*.dll
 ..\%__SRC%\bin\emp?????.* %_DEST%\bin%_EXT%\emp?????.*
 
 mkdir: %_DEST%\pck%_EXT%
diff --git a/sd/source/filter/pptx/eppt.hxx b/sd/source/filter/pptx/eppt.hxx
new file mode 100644
index 0000000..9d0ab80
--- /dev/null
+++ sd/source/filter/pptx/eppt.hxx
@@ -0,0 +1,853 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: eppt.hxx,v $
+ * $Revision: 1.51 $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+
+#ifndef _EPPT_HXX_
+#define _EPPT_HXX_
+#include <vector>
+#ifndef _PptEscherEx_HXX
+#include "escherex.hxx"
+#endif
+#include <tools/solar.h>
+#include <sot/storage.hxx>
+#include <tools/gen.hxx>
+#include <vcl/graph.hxx>
+#include <vcl/fontcvt.hxx>
+#include <tools/string.hxx>
+#include "pptexanimations.hxx"
+#include <pptexsoundcollection.hxx>
+
+// ------------------------------------------------------------------------
+
+#include <vcl/mapmod.hxx>
+#include <com/sun/star/uno/Any.hxx>
+#include <com/sun/star/frame/XModel.hpp>
+#include <com/sun/star/drawing/FillStyle.hpp>
+#include <com/sun/star/drawing/LineStyle.hpp>
+#include <com/sun/star/drawing/DashStyle.hpp>
+#include <com/sun/star/drawing/HatchStyle.hpp>
+#include <com/sun/star/drawing/LineEndType.hpp>
+#include <com/sun/star/drawing/Alignment.hpp>
+#include <com/sun/star/drawing/TextAdjust.hpp>
+#include <com/sun/star/drawing/CircleKind.hpp>
+#include <com/sun/star/drawing/PolygonKind.hpp>
+#include <com/sun/star/drawing/PolygonFlags.hpp>
+#include <com/sun/star/drawing/XUniversalShapeDescriptor.hpp>
+#include <com/sun/star/drawing/XShapeGrouper.hpp>
+#include <com/sun/star/text/XSimpleText.hpp>
+#include <com/sun/star/drawing/XConnectorShape.hpp>
+#include <com/sun/star/drawing/BezierPoint.hpp>
+#include <com/sun/star/drawing/Hatch.hpp>
+#include <com/sun/star/drawing/LineDash.hpp>
+#include <com/sun/star/drawing/PolyPolygonBezierCoords.hpp>
+#include <com/sun/star/presentation/XPresentationSupplier.hpp>
+#include <com/sun/star/presentation/XCustomPresentationSupplier.hpp>
+#include <com/sun/star/drawing/XMasterPageTarget.hpp>
+#include <com/sun/star/drawing/XDrawPagesSupplier.hpp>
+#include <com/sun/star/drawing/XMasterPagesSupplier.hpp>
+#include <com/sun/star/awt/XGraphics.hpp>
+#include <com/sun/star/task/XStatusIndicatorSupplier.hpp>
+#include <com/sun/star/presentation/AnimationEffect.hpp>
+#include <com/sun/star/presentation/FadeEffect.hpp>
+#include <com/sun/star/presentation/ClickAction.hpp>
+#include <com/sun/star/presentation/AnimationSpeed.hpp>
+#include <com/sun/star/presentation/PresentationRange.hpp>
+#include <com/sun/star/text/XTextFieldsSupplier.hpp>
+#include <com/sun/star/text/XTextField.hpp>
+#include <com/sun/star/container/XNamed.hpp>
+#include <com/sun/star/awt/FontDescriptor.hpp>
+#include <com/sun/star/container/XIndexContainer.hpp>
+#include <com/sun/star/awt/XControlModel.hpp>
+#include <com/sun/star/style/TabStop.hpp>
+#include <svx/msocximex.hxx>
+#include <com/sun/star/beans/XPropertySet.hpp>
+#include <com/sun/star/beans/XPropertyState.hpp>
+#include <com/sun/star/beans/XPropertySetInfo.hpp>
+#include <com/sun/star/awt/FontFamily.hpp>
+#include <com/sun/star/awt/FontPitch.hpp>
+#include <com/sun/star/awt/CharSet.hpp>
+#include <com/sun/star/text/WritingMode.hpp>
+#include <com/sun/star/lang/Locale.hpp>
+
+enum PageType { NORMAL = 0, MASTER = 1, NOTICE = 2, UNDEFINED = 3 };
+
+#define EPP_MAINMASTER_PERSIST_KEY		0x80010000
+#define EPP_MAINNOTESMASTER_PERSIST_KEY	0x80020000
+#define EPP_MAINSLIDE_PERSIST_KEY		0x80030000
+#define EPP_MAINNOTES_PERSIST_KEY		0x80040000
+
+#define EPP_Persist_Document			0x80080000
+#define EPP_Persist_MainMaster			0x80100000
+#define EPP_Persist_MainNotes			0x80200000
+#define EPP_Persist_Slide				0x80400000
+#define EPP_Persist_Notes				0x80800000
+#define EPP_Persist_CurrentPos			0x81000000
+#define EPP_Persist_VBAInfoAtom			0x84000000
+#define EPP_Persist_ExObj				0x88000000
+
+#define EPP_TEXTSTYLE_NORMAL			0x00000001
+#define EPP_TEXTSTYLE_TITLE				0x00000010
+#define EPP_TEXTSTYLE_BODY				0x00000100
+#define EPP_TEXTSTYLE_TEXT				0x00001000
+
+// PLACEMENT_ID
+#define EPP_LAYOUT_TITLESLIDE             0 /* The slide is a title slide                                                             */
+#define EPP_LAYOUT_TITLEANDBODYSLIDE      1 /* Title and body slide                                                                   */
+#define EPP_LAYOUT_TITLEMASTERSLIDE       2 /* Title master slide                                                                     */
+#define	EPP_LAYOUT_MASTERSLIDE            3 /* Master slide layout                                                                    */
+#define EPP_LAYOUT_MASTERNOTES            4 /* Master notes layout                                                                    */
+#define EPP_LAYOUT_NOTESTITLEBODY         5 /* Notes title/body layout                                                                */
+#define EPP_LAYOUT_HANDOUTLAYOUT          6 /* Handout layout, therefore it doesn't have placeholders except header, footer, and date */
+#define EPP_LAYOUT_ONLYTITLE              7 /* Only title placeholder                                                                 */
+#define EPP_LAYOUT_2COLUMNSANDTITLE       8 /* Body of the slide has 2 columns and a title                                            */
+#define EPP_LAYOUT_2ROWSANDTITLE          9 /* Slide's body has 2 rows and a title                                                    */
+#define EPP_LAYOUT_RIGHTCOLUMN2ROWS      10 /* Body contains 2 columns, right column has 2 rows                                       */
+#define EPP_LAYOUT_LEFTCOLUMN2ROWS       11 /* Body contains 2 columns, left column has 2 rows                                        */
+#define EPP_LAYOUT_BOTTOMROW2COLUMNS     12 /* Body contains 2 rows, bottom row has 2 columns                                         */
+#define EPP_LAYOUT_TOPROW2COLUMN         13 /* Body contains 2 rows, top row has 2 columns                                            */
+#define EPP_LAYOUT_4OBJECTS              14 /* 4 objects                                                                              */
+#define EPP_LAYOUT_BIGOBJECT             15 /* Big object                                                                             */
+#define EPP_LAYOUT_BLANCSLIDE            16 /* Blank slide                                                                            */
+#define EPP_LAYOUT_TITLERIGHTBODYLEFT    17 /* Vertical title on the right, body on the left                                          */
+#define EPP_LAYOUT_TITLERIGHT2BODIESLEFT 18 /* Vertical title on the right, body on the left split into 2 rows                        */
+
+class Polygon;
+class PptEscherEx;
+class XStatusIndicatorRef;
+
+struct PHLayout
+{
+	sal_Int32	nLayout;
+	sal_uInt8	nPlaceHolder[ 8 ];
+
+	sal_uInt8	nUsedObjectPlaceHolder;
+	sal_uInt8	nTypeOfTitle;
+	sal_uInt8	nTypeOfOutliner;
+
+	BOOL	bTitlePossible;
+	BOOL	bOutlinerPossible;
+	BOOL	bSecOutlinerPossible;
+};
+
+struct SOParagraph
+{
+	sal_Bool				bExtendedParameters;
+	sal_uInt32				nParaFlags;
+	sal_Int16				nBulletFlags;
+	String					sPrefix;
+	String					sSuffix;
+	String					sGraphicUrl;			// String auf eine Graphic
+	Size					aBuGraSize;
+	sal_uInt32				nNumberingType;			// in wirlichkeit ist dies ein SvxEnum
+	sal_uInt32				nHorzAdjust;
+	sal_uInt32				nBulletColor;
+	sal_Int32				nBulletOfs;
+	sal_Int16				nStartWith;				// Start der nummerierung
+	sal_Int16				nTextOfs;
+	sal_Int16				nBulletRealSize;		// GroessenVerhaeltnis in Proz
+	sal_Int16				nDepth;					// aktuelle tiefe
+	sal_Unicode				cBulletId;				// wenn Numbering Type == CharSpecial
+	::com::sun::star::awt::FontDescriptor		aFontDesc;
+
+	sal_Bool				bExtendedBulletsUsed;
+	sal_uInt16				nBulletId;
+	sal_uInt32				nMappedNumType;
+	sal_Bool				bNumberingIsNumber;
+
+	SOParagraph()
+	{
+		nDepth = 0;
+		bExtendedParameters = FALSE;
+		nParaFlags = 0;
+		nBulletFlags = 0;
+		nBulletOfs = 0;
+		nTextOfs = 0;
+		bExtendedBulletsUsed = FALSE;
+		nBulletId = 0xffff;
+		bNumberingIsNumber = sal_True;
+	};
+};
+
+// ------------------------------------------------------------------------
+
+class EscherGraphicProvider;
+class PPTExBulletProvider
+{
+	friend struct PPTExParaSheet;
+
+	protected :
+
+		SvMemoryStream			aBuExPictureStream;
+		SvMemoryStream			aBuExOutlineStream;
+		SvMemoryStream			aBuExMasterStream;
+
+		EscherGraphicProvider*	pGraphicProv;
+
+	public :
+
+		sal_uInt16				GetId( const ByteString& rUniqueId, Size& rGraphicSize );
+
+								PPTExBulletProvider();
+								~PPTExBulletProvider();
+};
+
+struct FontCollectionEntry
+{
+		String					Name;
+        double                  Scaling;
+		sal_Int16				Family;
+		sal_Int16				Pitch;
+		sal_Int16				CharSet;
+    
+        String                  Original;
+        sal_Bool                bIsConverted;
+
+		FontCollectionEntry( const String& rName, sal_Int16 nFamily, sal_Int16 nPitch, sal_Int16 nCharSet ) :
+                            Scaling ( 1.0 ),
+							Family	( nFamily ),
+							Pitch	( nPitch ),
+							CharSet	( nCharSet ),
+                            Original( rName )
+                            {
+                                ImplInit( rName );
+                            };
+
+		FontCollectionEntry( const String& rName ) :
+							Scaling ( 1.0 ),
+                            Original( rName )
+                            {
+                                ImplInit( rName );
+                            };
+        ~FontCollectionEntry();
+
+    private :
+        
+        FontCollectionEntry() {};
+
+        void ImplInit( const String& rName );
+};
+
+class VirtualDevice;
+class FontCollection : private List
+{
+        VirtualDevice* pVDev;
+	public :
+					FontCollection();
+					~FontCollection();
+
+		short		GetScriptDirection( const String& rText ) const;
+		sal_uInt32	GetId( FontCollectionEntry& rFontDescriptor );
+		sal_uInt32	GetCount() const { return List::Count(); };
+		const FontCollectionEntry*						GetById( sal_uInt32 nId );
+		FontCollectionEntry&	GetLast() { return *(FontCollectionEntry*)List::Last(); };
+};
+
+// ------------------------------------------------------------------------
+
+#define PPTEX_STYLESHEETENTRYS	9
+
+enum PPTExTextAttr
+{
+	ParaAttr_BulletOn,
+	ParaAttr_BuHardFont,
+	ParaAttr_BuHardColor,
+	ParaAttr_BuHardHeight,
+	ParaAttr_BulletChar,
+	ParaAttr_BulletFont,
+	ParaAttr_BulletHeight,
+	ParaAttr_BulletColor,
+	ParaAttr_Adjust,
+	ParaAttr_LineFeed,
+	ParaAttr_UpperDist,
+	ParaAttr_LowerDist,
+	ParaAttr_TextOfs,
+	ParaAttr_BulletOfs,
+	ParaAttr_DefaultTab,
+    ParaAttr_AsianLB_1,
+    ParaAttr_AsianLB_2,
+    ParaAttr_AsianLB_3,
+	ParaAttr_BiDi,
+	CharAttr_Bold,
+	CharAttr_Italic,
+	CharAttr_Underline,
+	CharAttr_Shadow,
+	CharAttr_Strikeout,
+	CharAttr_Embossed,
+	CharAttr_Font,
+	CharAttr_AsianOrComplexFont,
+	CharAttr_Symbol,
+	CharAttr_FontHeight,
+	CharAttr_FontColor,
+	CharAttr_Escapement
+};
+
+struct PPTExCharLevel
+{
+	sal_uInt16		mnFlags;
+	sal_uInt16		mnFont;
+	sal_uInt16		mnAsianOrComplexFont;
+	sal_uInt16		mnFontHeight;
+	sal_uInt16		mnEscapement;
+	sal_uInt32		mnFontColor;
+};
+
+struct PPTExCharSheet
+{
+				PPTExCharLevel	maCharLevel[ 5 ];
+
+				PPTExCharSheet( int nInstance );
+
+				void	SetStyleSheet( const ::com::sun::star::uno::Reference< ::com::sun::star::beans::XPropertySet > &,
+										FontCollection& rFontCollection, int nLevel );
+				void	Write( SvStream& rSt, PptEscherEx* pEx, sal_uInt16 nLev, sal_Bool bFirst, sal_Bool bSimpleText, 
+                            const ::com::sun::star::uno::Reference< ::com::sun::star::beans::XPropertySet > & rPagePropSet );
+
+};
+
+struct PPTExParaLevel
+{
+	sal_Bool	    mbIsBullet;
+	sal_uInt16		mnBulletChar;
+	sal_uInt16		mnBulletFont;
+	sal_uInt16		mnBulletHeight;
+	sal_uInt32		mnBulletColor;
+
+	sal_uInt16		mnAdjust;
+	sal_uInt16		mnLineFeed;
+	sal_uInt16		mnUpperDist;
+	sal_uInt16		mnLowerDist;
+	sal_uInt16		mnTextOfs;
+	sal_uInt16		mnBulletOfs;
+	sal_uInt16		mnDefaultTab;
+
+	sal_Bool		mbExtendedBulletsUsed;
+	sal_uInt16		mnBulletId;
+	sal_uInt16		mnBulletStart;
+	sal_uInt32		mnMappedNumType;
+	sal_uInt32		mnNumberingType;
+    sal_uInt16      mnAsianSettings;
+	sal_uInt16		mnBiDi;
+};
+
+struct PPTExParaSheet
+{
+				PPTExBulletProvider& rBuProv;
+
+				sal_uInt32	mnInstance;
+
+				PPTExParaLevel	maParaLevel[ 5 ];
+				PPTExParaSheet( int nInstance, sal_uInt16 nDefaultTab, PPTExBulletProvider& rProv );
+
+				void	SetStyleSheet( const ::com::sun::star::uno::Reference< ::com::sun::star::beans::XPropertySet > &,
+										FontCollection& rFontCollection, int nLevel, const PPTExCharLevel& rCharLevel );
+				void	Write( SvStream& rSt, PptEscherEx* pEx, sal_uInt16 nLev, sal_Bool bFirst, sal_Bool bSimpleText,
+                    const ::com::sun::star::uno::Reference< ::com::sun::star::beans::XPropertySet > & rPagePropSet );
+};
+
+class PPTExStyleSheet
+{
+
+	public :
+
+        	    PPTExCharSheet*		mpCharSheet[ PPTEX_STYLESHEETENTRYS ];
+	            PPTExParaSheet*		mpParaSheet[ PPTEX_STYLESHEETENTRYS ];
+
+				PPTExStyleSheet( sal_uInt16 nDefaultTab, PPTExBulletProvider& rBuProv );
+				~PPTExStyleSheet();
+
+				PPTExParaSheet& GetParaSheet( int nInstance ) { return *mpParaSheet[ nInstance ]; };
+				PPTExCharSheet& GetCharSheet( int nInstance ) { return *mpCharSheet[ nInstance ]; };
+
+				void			SetStyleSheet( const ::com::sun::star::uno::Reference< ::com::sun::star::beans::XPropertySet > &,
+												FontCollection& rFontCollection, int nInstance, int nLevel );
+				sal_Bool		IsHardAttribute( sal_uInt32 nInstance, sal_uInt32 nLevel, PPTExTextAttr eAttr, sal_uInt32 nValue );
+
+				sal_uInt32		SizeOfTxCFStyleAtom() const;
+				void			WriteTxCFStyleAtom( SvStream& rSt );
+};
+
+
+struct EPPTHyperlink
+{
+	String		aURL;
+	sal_uInt32	nType;		// bit 0-7 : type		( 1: click action to a slide )
+							//						( 2: hyperlink url )
+							// bit 8-23: index
+							// bit 31  : hyperlink is attached to a shape
+
+	EPPTHyperlink( const String rURL, sal_uInt32 nT ) :
+		aURL		( rURL ),
+		nType		( nT ){};
+};
+
+enum PPTExOleObjEntryType
+{
+	NORMAL_OLE_OBJECT, OCX_CONTROL		
+};
+
+struct PPTExOleObjEntry
+{
+	PPTExOleObjEntryType	eType;
+	sal_uInt32				nOfsA;			// offset to the EPP_ExOleObjAtom in mpExEmbed (set at creation)
+	sal_uInt32				nOfsB;			// offset to the EPP_ExOleObjStg
+
+	::com::sun::star::uno::Reference< ::com::sun::star::awt::XControlModel >	xControlModel;
+	::com::sun::star::uno::Reference< ::com::sun::star::drawing::XShape >  		xShape;
+
+	PPTExOleObjEntry( PPTExOleObjEntryType eT, sal_uInt32 nOfs ) :
+		eType	( eT ),
+		nOfsA	( nOfs ) {};
+};
+
+struct TextRuleEntry
+{
+	int					nPageNumber;
+	SvMemoryStream*		pOut;
+
+	TextRuleEntry( int nPg ) :
+		nPageNumber( nPg ),
+		pOut ( NULL ){};
+
+	~TextRuleEntry() { delete pOut; };
+};
+
+// ------------------------------------------------------------------------
+
+struct GroupEntry
+{
+		sal_uInt32					mnCurrentPos;
+		sal_uInt32					mnCount;
+		::com::sun::star::uno::Reference< ::com::sun::star::container::XIndexAccess >			mXIndexAccess;
+								GroupEntry( ::com::sun::star::uno::Reference< ::com::sun::star::container::XIndexAccess > & rIndex )
+								{
+									mXIndexAccess = rIndex;
+									mnCount =mXIndexAccess->getCount();
+									mnCurrentPos = 0;
+								};
+								GroupEntry( sal_uInt32 nCount )
+								{
+									mnCount = nCount;
+									mnCurrentPos = 0;
+								};
+								~GroupEntry(){};
+};
+
+// ------------------------------------------------------------------------
+
+class GroupTable
+{
+	protected:
+
+		sal_uInt32				mnIndex;
+		sal_uInt32				mnCurrentGroupEntry;
+		sal_uInt32				mnMaxGroupEntry;
+		sal_uInt32				mnGroupsClosed;
+		GroupEntry**			mpGroupEntry;
+
+		void					ImplResizeGroupTable( sal_uInt32 nEntrys );
+
+	public:
+
+		sal_uInt32				GetCurrentGroupIndex() const { return mnIndex; };
+		sal_Int32				GetCurrentGroupLevel() const { return mnCurrentGroupEntry - 1; };	
+		::com::sun::star::uno::Reference< ::com::sun::star::container::XIndexAccess > &
+								GetCurrentGroupAccess() const { return mpGroupEntry[  mnCurrentGroupEntry - 1 ]->mXIndexAccess; };
+		sal_uInt32				GetGroupsClosed();
+		void					SkipCurrentGroup();
+		void					ResetGroupTable( sal_uInt32 nCount );
+		void					ClearGroupTable();
+		sal_Bool                EnterGroup( ::com::sun::star::uno::Reference< ::com::sun::star::container::XIndexAccess > & rIndex );
+		sal_Bool				GetNextGroupEntry();
+								GroupTable();
+								~GroupTable();
+};
+
+class PropValue
+{
+	protected :
+
+		::com::sun::star::uno::Any								mAny;
+
+		::com::sun::star::uno::Reference
+			< ::com::sun::star::beans::XPropertySet	>			mXPropSet;
+
+		sal_Bool	ImplGetPropertyValue( const String& rString );
+		sal_Bool	ImplGetPropertyValue( const ::com::sun::star::uno::Reference
+						< ::com::sun::star::beans::XPropertySet > &, const String& );
+
+	public :
+
+		static sal_Bool GetPropertyValue(
+				::com::sun::star::uno::Any& rAny,
+					const ::com::sun::star::uno::Reference< ::com::sun::star::beans::XPropertySet > &,
+						const String& rPropertyName,
+							sal_Bool bTestPropertyAvailability = sal_False );
+
+		static ::com::sun::star::beans::PropertyState GetPropertyState(
+					const ::com::sun::star::uno::Reference < ::com::sun::star::beans::XPropertySet > &,
+						const String& rPropertyName );
+};
+
+class PropStateValue : public PropValue
+{
+	protected :
+
+		::com::sun::star::beans::PropertyState					ePropState;
+		::com::sun::star::uno::Reference
+			< ::com::sun::star::beans::XPropertyState >			mXPropState;
+
+		sal_Bool	ImplGetPropertyValue( const String& rString, sal_Bool bGetPropertyState = TRUE );
+
+};
+
+// ------------------------------------------------------------------------
+
+struct FieldEntry;
+class PortionObj : public PropStateValue
+{
+
+	friend class ParagraphObj;
+
+	protected :
+
+		void			ImplClear();
+		void			ImplConstruct( PortionObj& rPortionObj );
+		sal_uInt32		ImplGetTextField( ::com::sun::star::uno::Reference< ::com::sun::star::text::XTextRange > & rXTextRangeRef,
+							const ::com::sun::star::uno::Reference< ::com::sun::star::beans::XPropertySet > & rXPropSetRef, String& rURL );
+		sal_uInt32		ImplCalculateTextPositions( sal_uInt32 nCurrentTextPosition );
+		void			ImplGetPortionValues( FontCollection& rFontCollection, sal_Bool bGetPropStateValue = FALSE );
+
+	public :
+
+		::com::sun::star::beans::PropertyState	meCharColor;
+		::com::sun::star::beans::PropertyState	meCharHeight;
+		::com::sun::star::beans::PropertyState	meFontName;
+		::com::sun::star::beans::PropertyState	meAsianOrComplexFont;
+		::com::sun::star::beans::PropertyState	meCharEscapement;
+		::com::sun::star::lang::Locale			meCharLocale;
+		sal_uInt16		mnCharAttrHard;
+
+		sal_uInt32		mnCharColor;
+		sal_uInt16		mnCharAttr;
+		sal_uInt16		mnCharHeight;
+		sal_uInt16		mnFont;
+		sal_uInt16		mnAsianOrComplexFont;
+		sal_Int16		mnCharEscapement;
+
+		sal_uInt32		mnTextSize;
+		sal_Bool		mbLastPortion;
+
+		sal_uInt16*		mpText;
+		FieldEntry*		mpFieldEntry;
+
+						PortionObj( ::com::sun::star::uno::Reference< ::com::sun::star::text::XTextRange > & rXTextRangeRef,
+										sal_Bool bLast, FontCollection& rFontCollection );
+						PortionObj( const ::com::sun::star::uno::Reference< ::com::sun::star::beans::XPropertySet > & rXPropSetRef,
+										FontCollection& rFontCollection );
+						PortionObj( PortionObj& rPortionObj );
+						~PortionObj();
+
+		void			Write( SvStream* pStrm, sal_Bool bLast );
+		sal_uInt32		Count() const { return mnTextSize; };
+
+		PortionObj&		operator=( PortionObj& rPortionObj );
+};
+
+struct ParaFlags
+{
+	sal_Bool	bFirstParagraph : 1;
+	sal_Bool	bLastParagraph	: 1;
+
+					ParaFlags() { bFirstParagraph = TRUE; bLastParagraph = FALSE; };
+};
+
+class ParagraphObj : public List, public PropStateValue, public SOParagraph
+{
+	friend class TextObj;
+	friend struct PPTExParaSheet;
+
+		MapMode			maMapModeSrc;
+		MapMode			maMapModeDest;
+
+	protected :
+
+		void			ImplConstruct( ParagraphObj& rParagraphObj );
+		void			ImplClear();
+		sal_uInt32		ImplCalculateTextPositions( sal_uInt32 nCurrentTextPosition );
+		::com::sun::star::awt::Size			ImplMapSize( const ::com::sun::star::awt::Size& rSize );
+		void			ImplGetParagraphValues( PPTExBulletProvider& rBuProv, sal_Bool bGetPropStateValue = FALSE );
+		void			ImplGetNumberingLevel( PPTExBulletProvider& rBuProv, sal_Int16 nDepth, sal_Bool bIsBullet, sal_Bool bGetPropStateValue = FALSE );
+
+	public :
+
+		::com::sun::star::uno::Sequence< ::com::sun::star::style::TabStop > maTabStop;
+
+		sal_uInt32			mnTextSize;
+
+		sal_Bool			mbIsBullet;
+		sal_Bool			mbFirstParagraph;
+		sal_Bool			mbLastParagraph;
+
+		::com::sun::star::beans::PropertyState	meBullet;
+		::com::sun::star::beans::PropertyState	meTextAdjust;
+		::com::sun::star::beans::PropertyState	meLineSpacing;
+		::com::sun::star::beans::PropertyState	meLineSpacingTop;
+		::com::sun::star::beans::PropertyState	meLineSpacingBottom;
+		::com::sun::star::beans::PropertyState	meForbiddenRules;
+		::com::sun::star::beans::PropertyState	meParagraphPunctation;
+		::com::sun::star::beans::PropertyState	meBiDi;
+
+		sal_uInt16								mnTextAdjust;
+		sal_Int16								mnLineSpacing;
+        sal_Bool								mbFixedLineSpacing;
+		sal_Int16								mnLineSpacingTop;
+		sal_Int16								mnLineSpacingBottom;
+        sal_Bool								mbForbiddenRules;
+        sal_Bool								mbParagraphPunctation;
+		sal_uInt16								mnBiDi;
+
+						ParagraphObj( ::com::sun::star::uno::Reference< ::com::sun::star::text::XTextContent > & rXTextContentRef,
+							ParaFlags, FontCollection& rFontCollection,
+								PPTExBulletProvider& rBuProv );
+						ParagraphObj( ParagraphObj& rParargraphObj );
+						ParagraphObj( const ::com::sun::star::uno::Reference< ::com::sun::star::beans::XPropertySet > & rXPropSetRef,
+										PPTExBulletProvider& rBuProv );
+
+		void			CalculateGraphicBulletSize( sal_uInt16 nFontHeight );
+						~ParagraphObj();
+
+		void			Write( SvStream* pStrm );
+		sal_uInt32			Count() const { return mnTextSize; };
+
+		ParagraphObj&	operator=( ParagraphObj& rParagraphObj );
+};
+
+struct ImplTextObj
+{
+	sal_uInt32		mnRefCount;
+	sal_uInt32		mnTextSize;
+	int				mnInstance;
+	List*			mpList;
+	sal_Bool		mbHasExtendedBullets;
+	sal_Bool		mbFixedCellHeightUsed;
+
+					ImplTextObj( int nInstance );
+					~ImplTextObj();
+};
+
+class TextObj
+{
+		ImplTextObj*	mpImplTextObj;
+		void			ImplCalculateTextPositions();
+
+	public :
+						TextObj( ::com::sun::star::uno::Reference< ::com::sun::star::text::XSimpleText > &
+									rXText, int nInstance, FontCollection& rFontCollection, PPTExBulletProvider& rBuProv );
+						TextObj( TextObj& rTextObj );
+						~TextObj();
+
+		void			Write( SvStream* pStrm );
+
+		ParagraphObj*	First(){ return (ParagraphObj*)mpImplTextObj->mpList->First(); };
+		ParagraphObj*	Next(){ return(ParagraphObj*)mpImplTextObj->mpList->Next(); };
+		sal_uInt32		Count() const { return mpImplTextObj->mnTextSize; };
+		int				GetInstance() const { return mpImplTextObj->mnInstance; };
+		sal_Bool		HasExtendedBullets(){ return mpImplTextObj->mbHasExtendedBullets; };
+		void			WriteTextSpecInfo( SvStream* pStrm );
+
+		TextObj&		operator=( TextObj& rTextObj );
+};
+
+// ------------------------------------------------------------------------
+struct CellBorder;
+class PPTWriter : public GroupTable, public PropValue, public PPTExBulletProvider
+{
+		sal_Bool						mbStatus;
+		sal_Bool						mbUseNewAnimations;
+		sal_uInt32						mnStatMaxValue;
+		sal_uInt32						mnLatestStatValue;
+		std::vector< PPTExStyleSheet* >	maStyleSheetList;
+		PPTExStyleSheet*				mpStyleSheet;
+
+		EscherGraphicProvider*			mpGraphicProvider;
+		Fraction						maFraction;
+		MapMode							maMapModeSrc;
+		MapMode							maMapModeDest;
+		::com::sun::star::awt::Size		maDestPageSize;
+		::com::sun::star::awt::Size		maNotesPageSize;
+		PageType						meLatestPageType;
+		List							maSlideNameList;
+
+		::com::sun::star::uno::Reference< ::com::sun::star::frame::XModel >					mXModel;
+		::com::sun::star::uno::Reference< ::com::sun::star::task::XStatusIndicator >		mXStatusIndicator;
+		::com::sun::star::uno::Reference< ::com::sun::star::drawing::XDrawPagesSupplier >	mXDrawPagesSupplier;
+		::com::sun::star::uno::Reference< ::com::sun::star::drawing::XMasterPagesSupplier >	mXMasterPagesSupplier;
+		::com::sun::star::uno::Reference< ::com::sun::star::drawing::XDrawPages	>			mXDrawPages;
+		::com::sun::star::uno::Reference< ::com::sun::star::drawing::XDrawPage >			mXDrawPage;
+		::com::sun::star::uno::Reference< ::com::sun::star::beans::XPropertySet >			mXPagePropSet;
+	    ::com::sun::star::uno::Reference< ::com::sun::star::beans::XPropertySet >			mXBackgroundPropSet;
+		::com::sun::star::uno::Reference< ::com::sun::star::drawing::XShapes >  			mXShapes;
+		::com::sun::star::uno::Reference< ::com::sun::star::drawing::XShape	>				mXShape;
+		::com::sun::star::uno::Reference< ::com::sun::star::text::XSimpleText >				mXText;				// TextRef des globalen Text
+		::com::sun::star::uno::Reference< ::com::sun::star::text::XTextCursor >				mXCursor;
+		::com::sun::star::uno::Reference< ::com::sun::star::text::XTextRange >				mXCursorText;		// TextRef des Teilstuecks des Cursors
+		::com::sun::star::uno::Reference< ::com::sun::star::beans::XPropertySet	>			mXCursorPropSet;	// die Properties des Teilstueckes
+		::com::sun::star::uno::Reference< ::com::sun::star::text::XTextField >				mXTextField;
+		::com::sun::star::awt::Size			maSize;
+		::com::sun::star::awt::Point		maPosition;
+		Rectangle			maRect;
+		ByteString			mType;
+		sal_Bool			mbPresObj;
+		sal_Bool			mbEmptyPresObj;
+		sal_Bool			mbStatusIndicator;
+		sal_Int32			mnAngle;
+		sal_uInt32			mnTextStyle;
+
+		sal_Bool			mbFontIndependentLineSpacing;
+		sal_uInt32			mnTextSize;
+
+		SvStorageRef		mrStg;
+		SvStorageStream*	mpCurUserStrm;
+		SvStorageStream*	mpStrm;
+		SvStorageStream*	mpPicStrm;
+		PptEscherEx*		mpPptEscherEx;
+
+		List				maExOleObj;
+		sal_uInt32			mnVBAOleOfs;
+		SvMemoryStream*		mpVBA;
+		sal_uInt32			mnExEmbed;
+		SvMemoryStream*		mpExEmbed;
+
+		sal_uInt32			mnPages;			// anzahl einzelner Slides ( ohne masterpages & notes & handout )
+		sal_uInt32			mnMasterPages;		//
+		sal_uInt32			mnDrawings;			// anzahl Slides +  masterpages + notes +  handout
+		sal_uInt32			mnPagesWritten;
+		sal_uInt32			mnUniqueSlideIdentifier;
+		sal_uInt32			mnTxId;				// Identifier determined by the HOST (PP) ????
+		sal_uInt32			mnDiaMode;			// 0 -> manuell
+												// 1 -> halbautomatisch
+												// 2 -> automatisch
+
+		sal_uInt32			mnShapeMasterTitle;
+		sal_uInt32			mnShapeMasterBody;
+
+		List				maTextRuleList;		// TextRuleEntry's
+		List				maHyperlink;
+
+		FontCollection			maFontCollection;
+		ppt::ExSoundCollection	maSoundCollection;
+	
+		PHLayout&			ImplGetLayout( const ::com::sun::star::uno::Reference< ::com::sun::star::beans::XPropertySet >& rXPropSet ) const;
+		void				ImplWriteExtParaHeader( SvMemoryStream& rSt, sal_uInt32 nRef, sal_uInt32 nInstance, sal_uInt32 nSlideId ); 
+		
+
+		sal_uInt32			ImplProgBinaryTag( SvStream* pOutStrm = NULL );
+		sal_uInt32			ImplProgBinaryTagContainer( SvStream* pOutStrm = NULL, SvMemoryStream* pBinTag = NULL );
+		sal_uInt32			ImplProgTagContainer( SvStream* pOutStrm = NULL, SvMemoryStream* pBinTag = NULL );
+		sal_uInt32			ImplOutlineViewInfoContainer( SvStream* pOutStrm = NULL );
+		sal_uInt32			ImplSlideViewInfoContainer( sal_uInt32 nInstance, SvStream* pOutStrm = NULL );
+		sal_uInt32			ImplVBAInfoContainer( SvStream* pOutStrm = NULL );
+		sal_uInt32			ImplDocumentListContainer( SvStream* pOutStrm = NULL );
+		sal_uInt32			ImplMasterSlideListContainer( SvStream* pOutStrm = NULL );
+
+	protected:
+
+		sal_Bool			ImplCreateDocumentSummaryInformation( sal_uInt32 nCnvrtFlags );
+		sal_Bool			ImplCreateCurrentUserStream();
+		void				ImplCreateHeaderFooterStrings( SvStream& rOut,
+								::com::sun::star::uno::Reference< ::com::sun::star::beans::XPropertySet >& rXPagePropSet );
+		void				ImplCreateHeaderFooters( ::com::sun::star::uno::Reference< ::com::sun::star::beans::XPropertySet >& rXPagePropSet );
+		sal_Bool			ImplCreateDocument();
+		sal_Bool			ImplCreateHyperBlob( SvMemoryStream& rStream );
+		sal_uInt32			ImplInsertBookmarkURL( const String& rBookmark, const sal_uInt32 nType,
+			const String& rStringVer0, const String& rStringVer1, const String& rStringVer2, const String& rStringVer3 );
+		sal_Bool			ImplCreateMaster( sal_uInt32 nPageNum );
+		sal_Bool			ImplCreateMainNotes();
+		sal_Bool			ImplCreateSlide( sal_uInt32 nPageNum );
+		sal_Bool			ImplCreateNotes( sal_uInt32 nPageNum );
+		void				ImplWriteBackground( ::com::sun::star::uno::Reference< ::com::sun::star::beans::XPropertySet > & rXBackgroundPropSet );
+		void				ImplWriteVBA( SvMemoryStream* pVBA );
+		void				ImplWriteOLE( sal_uInt32 nCnvrtFlags );
+		sal_Bool			ImplWriteAtomEnding();
+
+		sal_Bool			ImplInitSOIface();
+		sal_Bool			ImplSetCurrentStyleSheet( sal_uInt32 nPageNum );
+		sal_Bool			ImplGetPageByIndex( sal_uInt32 nIndex, PageType );
+		sal_Bool			ImplGetShapeByIndex( sal_uInt32 nIndex, sal_Bool bGroup = FALSE );
+		sal_uInt32			ImplGetMasterIndex( PageType ePageType );
+		void				ImplFlipBoundingBox( EscherPropertyContainer& rPropOpt );
+		sal_Bool			ImplGetText();
+		sal_Bool			ImplCreatePresentationPlaceholder( const sal_Bool bMaster, const PageType PageType,
+								const sal_uInt32 StyleInstance, const sal_uInt8 PlaceHolderId );
+		sal_Bool			ImplGetEffect( const ::com::sun::star::uno::Reference< ::com::sun::star::beans::XPropertySet > &,
+								::com::sun::star::presentation::AnimationEffect& eEffect,
+								::com::sun::star::presentation::AnimationEffect& eTextEffect,
+								sal_Bool& bHasSound );								
+		void				ImplWriteObjectEffect( SvStream& rSt,
+								::com::sun::star::presentation::AnimationEffect eEffect,
+								::com::sun::star::presentation::AnimationEffect eTextEffect,
+								sal_uInt16 nOrder );
+		void				ImplWriteClickAction( SvStream& rSt, ::com::sun::star::presentation::ClickAction eAction, sal_Bool bMediaClickAction );
+		sal_Bool			ImplGetStyleSheets();
+		void				ImplWriteParagraphs( SvStream& rOutStrm, TextObj& rTextObj );
+		void				ImplWritePortions( SvStream& rOutStrm, TextObj& rTextObj );
+		void				ImplWriteTextStyleAtom( SvStream& rOut, int nTextInstance, sal_uInt32 nAtomInstance,
+								TextRuleEntry* pTextRule, SvStream& rExtBu, EscherPropertyContainer* );
+		void				ImplAdjustFirstLineLineSpacing( TextObj& rTextObj, EscherPropertyContainer& rPropOpt );
+		void				ImplCreateShape( sal_uInt32 nType, sal_uInt32 nFlags, EscherSolverContainer& );
+		void				ImplCreateTextShape( EscherPropertyContainer&, EscherSolverContainer&, sal_Bool bFill );
+
+		void				ImplWritePage( const PHLayout& rLayout,
+												EscherSolverContainer& rSolver,
+													PageType ePageType,
+														sal_Bool bMaster,
+															int nPageNumber = 0 );
+		void				ImplCreateCellBorder( const CellBorder* pCellBorder, sal_Int32 nX1, sal_Int32 nY1, sal_Int32 nX2, sal_Int32 nY2 );
+		void				ImplCreateTable( com::sun::star::uno::Reference< com::sun::star::drawing::XShape >& rXShape, EscherSolverContainer& aSolverContainer,
+								EscherPropertyContainer& aPropOpt );
+		::com::sun::star::awt::Point		ImplMapPoint( const ::com::sun::star::awt::Point& );
+		::com::sun::star::awt::Size			ImplMapSize( const ::com::sun::star::awt::Size& );
+		Rectangle							ImplMapRectangle( const ::com::sun::star::awt::Rectangle& );
+
+		sal_Bool							ImplCloseDocument();		// die font-, hyper-, Soundliste wird geschrieben ..
+		void								ImplWriteCString( SvStream&, const String&, sal_uInt32 nInstance = 0 );
+
+	public:
+								PPTWriter( SvStorageRef& rSvStorage,
+											::com::sun::star::uno::Reference< ::com::sun::star::frame::XModel > & rModel,
+											::com::sun::star::uno::Reference< ::com::sun::star::task::XStatusIndicator > & rStatInd,
+												SvMemoryStream* pVBA, sal_uInt32 nCnvrtFlags );
+
+								~PPTWriter();
+
+		sal_Bool				IsValid() const { return mbStatus; };
+};
+
+
+#endif
diff --git a/sd/source/filter/pptx/epptdef.hxx b/sd/source/filter/pptx/epptdef.hxx
new file mode 100644
index 0000000..cd35da8
--- /dev/null
+++ sd/source/filter/pptx/epptdef.hxx
@@ -0,0 +1,263 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: epptdef.hxx,v $
+ * $Revision: 1.4 $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+
+#ifndef _EPPT_DEF_HXX
+#define _EPPT_DEF_HXX
+
+#include <tools/solar.h>
+
+#define EPP_FLAG_CONTAINER 0x0F				// If the version field of a record
+											// header takes on this value, the
+											// record header marks the start of
+											// a container.
+
+#define EPP_Unknown                        0
+#define EPP_SubContainerCompleted          1
+#define EPP_IRRAtom                        2
+#define EPP_PSS                            3
+#define EPP_SubContainerException          4
+#define EPP_ClientSignal1                  6
+#define EPP_ClientSignal2                  7
+#define EPP_PowerPointStateInfoAtom       10
+#define EPP_Document                    1000
+#define EPP_DocumentAtom                1001
+#define EPP_EndDocument                 1002
+#define EPP_SlidePersist                1003
+#define EPP_SlideBase                   1004
+#define EPP_SlideBaseAtom               1005
+#define EPP_Slide                       1006
+#define EPP_SlideAtom                   1007
+#define EPP_Notes                       1008
+#define EPP_NotesAtom                   1009
+#define EPP_Environment                 1010
+#define EPP_SlidePersistAtom            1011	//0x03F3
+#define EPP_Scheme                      1012
+#define EPP_SchemeAtom                  1013
+#define EPP_DocViewInfo                 1014
+#define EPP_SslideLayoutAtom            1015
+#define EPP_MainMaster                  1016
+#define EPP_SSSlideInfoAtom             1017
+#define EPP_SlideViewInfo               1018
+#define EPP_GuideAtom                   1019
+#define EPP_ViewInfo                    1020
+#define EPP_ViewInfoAtom                1021
+#define EPP_SlideViewInfoAtom           1022
+#define EPP_VBAInfo                     1023
+#define EPP_VBAInfoAtom                 1024
+#define EPP_SSDocInfoAtom               1025
+#define EPP_Summary                     1026
+#define EPP_Texture                     1027
+#define EPP_VBASlideInfo                1028
+#define EPP_VBASlideInfoAtom            1029
+#define EPP_DocRoutingSlip              1030
+#define EPP_OutlineViewInfo             1031
+#define EPP_SorterViewInfo              1032
+#define EPP_ExObjList                   1033
+#define EPP_ExObjListAtom               1034
+#define EPP_PPDrawingGroup              1035
+#define EPP_PPDrawing                   1036
+#define EPP_NamedShows                  1040
+#define EPP_NamedShow                   1041
+#define EPP_NamedShowSlides             1042
+#define EPP_List                        2000
+#define EPP_FontCollection              2005
+#define EPP_ListPlaceholder             2017
+#define EPP_BookmarkCollection          2019
+#define EPP_SoundCollection             2020
+#define EPP_SoundCollAtom               2021
+#define EPP_Sound                       2022
+#define EPP_SoundData                   2023
+#define EPP_BookmarkSeedAtom            2025
+#define EPP_GuideList                   2026
+#define EPP_RunArray                    2028
+#define EPP_RunArrayAtom                2029
+#define EPP_ArrayElementAtom            2030
+#define EPP_Int4ArrayAtom               2031
+#define EPP_ColorSchemeAtom             2032
+
+// these atoms first was seen in ppt2000 in a private Tag atom
+#define EPP_PST_ExtendedBuGraContainer			2040	// consist of 4041
+#define EPP_PST_ExtendedBuGraAtom				2041	// the instance of this atom indices the current graphic
+
+#define EPP_OEShape                     3008
+#define EPP_ExObjRefAtom                3009
+#define EPP_OEPlaceholderAtom           3011
+#define EPP_GrColor                     3020
+#define EPP_GrectAtom                   3025
+#define EPP_GratioAtom                  3031
+#define EPP_Gscaling                    3032
+#define EPP_GpointAtom                  3034
+#define EPP_OEShapeAtom                 3035
+#define EPP_OutlineTextRefAtom          3998
+#define EPP_TextHeaderAtom              3999
+#define EPP_TextCharsAtom               4000
+#define EPP_StyleTextPropAtom           4001
+#define EPP_BaseTextPropAtom            4002
+#define EPP_TxMasterStyleAtom           4003
+#define EPP_TxCFStyleAtom               4004
+#define EPP_TxPFStyleAtom               4005
+#define EPP_TextRulerAtom               4006
+#define EPP_TextBookmarkAtom            4007
+#define EPP_TextBytesAtom               4008
+#define EPP_TxSIStyleAtom               4009
+#define EPP_TextSpecInfoAtom            4010
+#define EPP_DefaultRulerAtom            4011
+
+// these atoms first was seen in ppt2000 in a private Tag atom
+#define EPP_PST_ExtendedParagraphAtom			4012
+#define EPP_PST_ExtendedParagraphMasterAtom		4013
+#define EPP_PST_ExtendedPresRuleContainer		4014	// consist of 4012, 4015, 
+#define EPP_PST_ExtendedParagraphHeaderAtom		4015	// the instance of this atom indices the current presobj
+														// the first UINT32 in this atom indices the current slideId
+
+#define EPP_FontEnityAtom				4023
+#define EPP_FontEmbedData               4024
+#define EPP_TypeFace                    4025
+#define EPP_CString                     4026
+#define EPP_ExternalObject              4027
+#define EPP_MetaFile                    4033
+#define EPP_ExOleObj                    4034
+#define EPP_ExOleObjAtom                4035
+#define EPP_ExPlainLinkAtom             4036
+#define EPP_CorePict                    4037
+#define EPP_CorePictAtom                4038
+#define EPP_ExPlainAtom                 4039
+#define EPP_SrKinsoku                   4040
+#define EPP_Handout                     4041
+#define EPP_ExEmbed                     4044
+#define EPP_ExEmbedAtom                 4045
+#define EPP_ExLink                      4046
+#define EPP_ExLinkAtom_old              4047
+#define EPP_BookmarkEntityAtom          4048
+#define EPP_ExLinkAtom                  4049
+#define EPP_SrKinsokuAtom               4050
+#define EPP_ExHyperlinkAtom             4051
+#define EPP_ExPlain                     4053
+#define EPP_ExPlainLink                 4054
+#define EPP_ExHyperlink                 4055
+#define EPP_SlideNumberMCAtom           4056
+#define EPP_HeadersFooters              4057
+#define EPP_HeadersFootersAtom          4058
+#define EPP_RecolorEntryAtom            4062
+#define EPP_TxInteractiveInfoAtom       4063
+#define EPP_EmFormatAtom                4065
+#define EPP_CharFormatAtom              4066
+#define EPP_ParaFormatAtom              4067
+#define EPP_MasterText                  4068
+#define EPP_RecolorInfoAtom             4071
+#define EPP_ExQuickTime                 4073
+#define EPP_ExQuickTimeMovie            4074
+#define EPP_ExQuickTimeMovieData        4075
+#define EPP_ExSubscription              4076
+#define EPP_ExSubscriptionSection       4077
+#define EPP_ExControl                   4078
+#define EPP_ExControlAtom               4091
+#define EPP_SlideListWithText           4080	// 0x0FF0
+#define EPP_AnimationInfoAtom           4081
+#define EPP_InteractiveInfo             4082
+#define EPP_InteractiveInfoAtom         4083
+#define EPP_SlideList                   4084
+#define EPP_UserEditAtom                4085
+#define EPP_CurrentUserAtom             4086
+#define EPP_DateTimeMCAtom              4087
+#define EPP_GenericDateMCAtom           4088
+#define EPP_HeaderMCAtom                4089
+#define EPP_FooterMCAtom                4090
+#define EPP_ExMediaAtom                 4100
+#define EPP_ExVideo                     4101
+#define EPP_ExAviMovie                  4102
+#define EPP_ExMCIMovie                  4103
+#define EPP_ExMIDIAudio                 4109
+#define EPP_ExCDAudio                   4110
+#define EPP_ExWAVAudioEmbedded          4111
+#define EPP_ExWAVAudioLink              4112
+#define EPP_ExOleObjStg                 4113
+#define EPP_ExCDAudioAtom               4114
+#define EPP_ExWAVAudioEmbeddedAtom      4115
+#define EPP_AnimationInfo               4116
+#define EPP_RTFDateTimeMCAtom           4117
+#define EPP_ProgTags                    5000
+#define EPP_ProgStringTag               5001
+#define EPP_ProgBinaryTag               5002
+#define EPP_BinaryTagData               5003
+#define EPP_PrintOptions                6000
+#define EPP_PersistPtrFullBlock         6001
+#define EPP_PersistPtrIncrementalBlock  6002
+#define EPP_RulerIndentAtom            10000
+#define EPP_GscalingAtom               10001
+#define EPP_GrColorAtom                10002
+#define EPP_GLPointAtom                10003
+
+#define EPP_PLACEHOLDER_NONE					0	//	0 None
+#define EPP_PLACEHOLDER_MASTERTITLE				1	//  1 Master title
+#define EPP_PLACEHOLDER_MASTERBODY				2	//  2 Master body
+#define EPP_PLACEHOLDER_MASTERCENTEREDTITLE		3	//  3 Master centered title
+#define EPP_PLACEHOLDER_MASTERSUBTITLE			4	// 10 Master subtitle
+#define EPP_PLACEHOLDER_MASTERNOTESSLIDEIMAGE	5	//  4 Master notes slide image
+#define EPP_PLACEHOLDER_MASTERNOTESBODYIMAGE	6	//  5 Master notes body image
+#define EPP_PLACEHOLDER_MASTERDATE				7	//  6 Master date
+#define EPP_PLACEHOLDER_MASTERSLIDENUMBER		8	//  7 Master slide number
+#define EPP_PLACEHOLDER_MASTERFOOTER			9	//  8 Master footer
+#define EPP_PLACEHOLDER_MASTERHEADER			10	//  9 Master header
+#define EPP_PLACEHOLDER_GENERICTEXTOBJECT			// 11 Generic text object
+#define EPP_PLACEHOLDER_TITLE					13	// 12 Title
+#define EPP_PLACEHOLDER_BODY					14	// 13 Body
+#define EPP_PLACEHOLDER_NOTESBODY				12	// 14 Notes body
+#define EPP_PLACEHOLDER_CENTEREDTITLE			15	// 15 Centered title
+#define EPP_PLACEHOLDER_SUBTITLE				16	// 16 Subtitle
+#define EPP_PLACEHOLDER_VERTICALTEXTTITLE		17	// 17 Vertical text title
+#define EPP_PLACEHOLDER_VERTICALTEXTBODY		18	// 18 Vertical text body
+#define EPP_PLACEHOLDER_NOTESSLIDEIMAGE			11	// 19 Notes slide image
+#define EPP_PLACEHOLDER_OBJECT					19	// 20 Object (no matter the size)
+#define EPP_PLACEHOLDER_GRAPH					20	// 21 Graph
+#define EPP_PLACEHOLDER_TABLE					21	// 22 Table
+#define EPP_PLACEHOLDER_CLIPART					22	// 23 Clip Art
+#define EPP_PLACEHOLDER_ORGANISZATIONCHART		23	// 24 Organization Chart
+#define EPP_PLACEHOLDER_MEDIACLIP				24	// 25 Media Clip
+
+#define EPP_TEXTTYPE_Title				0
+#define EPP_TEXTTYPE_Body				1
+#define EPP_TEXTTYPE_Notes				2
+#define EPP_TEXTTYPE_notUsed			3
+#define EPP_TEXTTYPE_Other				4	// ( Text in a shape )
+#define EPP_TEXTTYPE_CenterBody			5	// ( subtitle in title slide )
+#define EPP_TEXTTYPE_CenterTitle		6	// ( title in title slide )
+#define EPP_TEXTTYPE_HalfBody			7	// ( body in two-column slide )
+#define EPP_TEXTTYPE_QuarterBody		8	// ( body in four-body slide )
+
+#define EPP_SLIDESIZE_TYPEONSCREEN			0
+#define EPP_SLIDESIZE_TYPELETTERSIZERPAPER	1
+#define EPP_SLIDESIZE_TYPEA4PAPER			2
+#define EPP_SLIDESIZE_TYPE35MM				3
+#define EPP_SLIDESIZE_TYPEOVERHEAD			4
+#define EPP_SLIDESIZE_TYPEBANNER			5
+#define EPP_SLIDESIZE_TYPECUSTOM			6
+
+#endif
diff --git a/sd/source/filter/pptx/escherex.hxx b/sd/source/filter/pptx/escherex.hxx
new file mode 100644
index 0000000..ced7adf
--- /dev/null
+++ sd/source/filter/pptx/escherex.hxx
@@ -0,0 +1,85 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: escherex.hxx,v $
+ * $Revision: 1.12 $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+
+#ifndef _PptEscherEX_HXX
+#define _PptEscherEX_HXX
+#include <svx/escherex.hxx>
+
+// ---------------------------------------------------------------------------------------------
+// Werte fuer den ULONG im PPT_PST_TextHeaderAtom
+enum PPT_TextHeader
+{
+	PPTTH_TITLE,
+	PPTTH_BODY,
+	PPTTH_NOTES,
+	PPTTH_NOTUSED,
+	PPTTH_OTHER,       // Text in a Shape
+	PPTTH_CENTERBODY,  // Subtitle in Title-Slide
+	PPTTH_CENTERTITLE, // Title in Title-Slide
+	PPTTH_HALFBODY,    // Body in two-column slide
+	PPTTH_QUARTERBODY  // Body in four-body slide
+};
+
+// ---------------------------------------------------------------------------------------------
+
+class PptEscherEx : public EscherEx
+{
+		SvMemoryStream			maFIDCLs;
+
+		sal_uInt32	ImplDggContainerSize();
+		void		ImplWriteDggContainer( SvStream& rSt );
+
+		sal_uInt32	ImplDggAtomSize();
+		void		ImplWriteDggAtom( SvStream& rSt );
+		
+		sal_uInt32	ImplOptAtomSize();
+		void		ImplWriteOptAtom( SvStream& rSt );
+
+		sal_uInt32	ImplSplitMenuColorsAtomSize();
+		void		ImplWriteSplitMenuColorsAtom( SvStream& rSt );
+
+	public:
+
+				PptEscherEx( SvStream& rOut, UINT32 nDrawings );
+				~PptEscherEx();
+
+		void	OpenContainer( UINT16 n_EscherContainer, int nRecInstance = 0 );
+		void	CloseContainer();
+
+		sal_uInt32 EnterGroup( Rectangle* pBoundRect, SvMemoryStream* pClientData );
+
+		UINT32	DrawingGroupContainerSize();
+		void	WriteDrawingGroupContainer( SvStream& rSt );
+
+		using EscherEx::EnterGroup;
+};
+
+
+#endif
diff --git a/sd/source/filter/pptx/exports.map b/sd/source/filter/pptx/exports.map
new file mode 100644
index 0000000..e69de29
diff --git a/sd/source/filter/pptx/makefile.mk b/sd/source/filter/pptx/makefile.mk
new file mode 100644
index 0000000..239135b
--- /dev/null
+++ sd/source/filter/pptx/makefile.mk
@@ -0,0 +1,61 @@
+#*************************************************************************
+#
+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+# 
+# Copyright 2008 by Sun Microsystems, Inc.
+#
+# OpenOffice.org - a multi-platform office productivity suite
+#
+# $RCSfile: makefile.mk,v $
+#
+# $Revision: 1.15 $
+#
+# This file is part of OpenOffice.org.
+#
+# OpenOffice.org is free software: you can redistribute it and/or modify
+# it under the terms of the GNU Lesser General Public License version 3
+# only, as published by the Free Software Foundation.
+#
+# OpenOffice.org is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU Lesser General Public License version 3 for more details
+# (a copy is included in the LICENSE file that accompanied this code).
+#
+# You should have received a copy of the GNU Lesser General Public License
+# version 3 along with OpenOffice.org.  If not, see
+# <http://www.openoffice.org/license.html>
+# for a copy of the LGPLv3 License.
+#
+#*************************************************************************
+
+PRJ=..$/..$/..
+PRJNAME=sd
+TARGET=pptx
+ENABLE_EXCEPTIONS=TRUE
+VISIBILITY_HIDDEN=TRUE
+
+# --- Settings -----------------------------------------------------
+
+.INCLUDE : settings.mk
+
+# --- Files --------------------------------------------------------
+
+.IF "$(COM)"=="GCC"
+NOOPTFILES= $(SLO)$/pptx-epptso.obj
+.ENDIF
+
+SLOFILES =	$(SLO)$/pptx-eppt.obj				\
+			$(SLO)$/pptx-epptbase.obj			\
+			$(SLO)$/pptx-epptooxml.obj			\
+			$(SLO)$/pptx-epptso.obj				\
+			$(SLO)$/pptx-escherex.obj			\
+			$(SLO)$/pptx-grouptable.obj			\
+			$(SLO)$/pptx-pptexanimations.obj		\
+			$(SLO)$/pptx-pptexsoundcollection.obj 	\
+			$(SLO)$/pptx-text.obj			\
+			$(SLO)$/pptx-stylesheet.obj
+
+# --- Targets --------------------------------------------------------------
+
+.INCLUDE : target.mk
diff --git a/sd/source/filter/pptx/pptexanimations.hxx b/sd/source/filter/pptx/pptexanimations.hxx
new file mode 100644
index 0000000..5099900
--- /dev/null
+++ sd/source/filter/pptx/pptexanimations.hxx
@@ -0,0 +1,140 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: pptexanimations.hxx,v $
+ * $Revision: 1.9 $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+
+#ifndef _SD_PPT_EXANIMATIONS_HXX
+#define _SD_PPT_EXANIMATIONS_HXX
+
+#include <com/sun/star/animations/XTimeContainer.hpp>
+#include <com/sun/star/drawing/XDrawPage.hpp>
+#include <com/sun/star/animations/XAnimate.hpp>
+#ifndef _SD_PPTANIMATIONS_HXX
+#include "../ppt/pptanimations.hxx"
+#endif
+#include <pptexsoundcollection.hxx>
+#include <svx/escherex.hxx>
+
+#ifdef DBG_ANIM_LOG
+#include <stdio.h>
+#endif
+
+#ifndef BOOST_SHARED_PTR_HPP_INCLUDED
+#include <boost/shared_ptr.hpp>
+#endif
+
+#include <list>
+
+class DffRecordHeader;
+class SdPage;
+class SvStream;
+
+namespace ppt
+{ 
+
+	struct AfterEffectNode
+	{
+		::com::sun::star::uno::Reference< ::com::sun::star::animations::XAnimationNode > mxNode;
+		::com::sun::star::uno::Reference< ::com::sun::star::animations::XAnimationNode > mxMaster;
+
+		AfterEffectNode( const ::com::sun::star::uno::Reference< ::com::sun::star::animations::XAnimationNode >& xNode,
+						 const ::com::sun::star::uno::Reference< ::com::sun::star::animations::XAnimationNode >& xMaster )
+						 : mxNode( xNode ), mxMaster( xMaster ) {}
+	};
+
+	typedef boost::shared_ptr< AfterEffectNode > AfterEffectNodePtr;
+
+typedef sal_uInt32 TranslateMode;
+#define TRANSLATE_NONE				0
+#define TRANSLATE_VALUE				1
+#define TRANSLATE_ATTRIBUTE			2
+#define TRANSLATE_MEASURE			4
+#define TRANSLATE_NUMBER_TO_STRING	8
+
+const int AFTEREFFECT_NONE = 0;
+const int AFTEREFFECT_COLOR = 1;
+const int AFTEREFFECT_SET = 2;
+
+class AnimationExporter
+{
+	::com::sun::star::uno::Any aTarget;
+
+	void writeZString( SvStream& rStrm, const rtl::OUString& rVal );
+	sal_Bool getColorAny( const ::com::sun::star::uno::Any& rAny, const sal_Int16 nColorSpace, sal_Int32& rMode, sal_Int32& rA, sal_Int32& rB, sal_Int32& rC ) const;
+	sal_Bool exportAnimProperty( SvStream& rStrm, const sal_uInt16 nPropertyId, const ::com::sun::star::uno::Any& rAny, const TranslateMode eTranslateMode );
+	::com::sun::star::uno::Any convertAnimateValue( const ::com::sun::star::uno::Any& rSource, const rtl::OUString& rAttributeName ) const;
+	void exportAnimPropertyString( SvStream& rStrm, const sal_uInt16 nPropertyId, const rtl::OUString& rVal, const TranslateMode eTranslateMode );
+	void exportAnimPropertyFloat( SvStream& rStrm, const sal_uInt16 nPropertyId, const double& rVal, const TranslateMode eTranslateMode );
+	void exportAnimPropertyuInt32( SvStream& rStrm, const sal_uInt16 nPropertyId, const sal_uInt32 nVal, const TranslateMode eTranslateMode );
+	void exportAnimPropertyByte( SvStream& rStrm, const sal_uInt16 nPropertyId, const sal_uInt8 nVal, const TranslateMode eTranslateMode );
+	
+	// if available exportAnimPropertySet returns the ::com::sun::star::presentation::EffectNodeType
+	sal_Int16 exportAnimPropertySet( SvStream& rStrm, const ::com::sun::star::uno::Reference< ::com::sun::star::animations::XAnimationNode >& xNode );
+	void exportAnimNode( SvStream& rStrm, const ::com::sun::star::uno::Reference< ::com::sun::star::animations::XAnimationNode >& xNode,
+						const ::com::sun::star::uno::Reference< ::com::sun::star::animations::XAnimationNode >* pParent, const sal_Int32 nGroupLevel, const sal_Int16 nFillDefault );
+	void exportAnimate( SvStream& rStrm, const ::com::sun::star::uno::Reference< ::com::sun::star::animations::XAnimationNode >& xNode );
+	void exportAnimateTarget( SvStream& rStrm, const ::com::sun::star::uno::Reference< ::com::sun::star::animations::XAnimationNode >& xNode, const sal_uInt32 nForceAttributeName = 0, int nAfterEffectType = AFTEREFFECT_NONE );
+	void exportAnimateSet( SvStream& rStrm, const ::com::sun::star::uno::Reference< ::com::sun::star::animations::XAnimationNode >&  xNode, int nAfterEffectType );
+	void exportAnimAction( SvStream& rStrm, const ::com::sun::star::uno::Reference< ::com::sun::star::animations::XAnimationNode >& xNode );
+	void exportAnimEvent( SvStream& rStrm, const ::com::sun::star::uno::Reference< ::com::sun::star::animations::XAnimationNode >& xNode, const sal_Int32 nFlags = 0 );
+	void exportNode( SvStream& rStrm, ::com::sun::star::uno::Reference< ::com::sun::star::animations::XAnimationNode > xNode,
+						const ::com::sun::star::uno::Reference< ::com::sun::star::animations::XAnimationNode >* xParent,
+							const sal_uInt16 nContainerRecType, const sal_uInt16 nInstance, const sal_Int32 nGroupLevel, const sal_Bool bTakeBackInteractiveSequenceTiming,
+								const sal_Int16 nFillDefault );
+	void exportAnimateTargetElement( SvStream& rStrm, const ::com::sun::star::uno::Any aAny, const sal_Bool bCreate2b01Atom );
+	void exportAnimateKeyPoints( SvStream& rStrm, const ::com::sun::star::uno::Reference< ::com::sun::star::animations::XAnimate >& xAnimate );
+	void exportAnimValue( SvStream& rStrm, const ::com::sun::star::uno::Reference< ::com::sun::star::animations::XAnimationNode >& xNode, const sal_Bool bExportAlways );
+	void exportTransitionFilter( SvStream& rStrm, const ::com::sun::star::uno::Reference< ::com::sun::star::animations::XAnimationNode >& xNode );
+	void exportAnimateMotion( SvStream& rStrm, const ::com::sun::star::uno::Reference< ::com::sun::star::animations::XAnimationNode >& xNode );
+	void exportAnimateTransform( SvStream& rStrm, const ::com::sun::star::uno::Reference< ::com::sun::star::animations::XAnimationNode >& xNode );
+	void exportAnimateColor( SvStream& rStrm, const ::com::sun::star::uno::Reference< ::com::sun::star::animations::XAnimationNode >& xNode, int nAfterEffectType );
+	void exportIterate( SvStream& rStrm, const ::com::sun::star::uno::Reference< ::com::sun::star::animations::XAnimationNode >& xNode );
+
+	const EscherSolverContainer& mrSolverContainer;
+	ppt::ExSoundCollection& mrExSoundCollection;
+	void processAfterEffectNodes( const ::com::sun::star::uno::Reference< ::com::sun::star::animations::XAnimationNode >& xNode );
+
+	bool isAfterEffectNode( const ::com::sun::star::uno::Reference< ::com::sun::star::animations::XAnimationNode >& xNode ) const;
+	bool hasAfterEffectNode( const ::com::sun::star::uno::Reference< ::com::sun::star::animations::XAnimationNode >& xNode, ::com::sun::star::uno::Reference< ::com::sun::star::animations::XAnimationNode >& xAfterEffectNode ) const;
+	bool isEmptyNode( const ::com::sun::star::uno::Reference< ::com::sun::star::animations::XAnimationNode >& xNode ) const;
+
+	::com::sun::star::uno::Reference< ::com::sun::star::animations::XAnimationNode > createAfterEffectNodeClone( const ::com::sun::star::uno::Reference< ::com::sun::star::animations::XAnimationNode >& xNode ) const;
+
+	std::list< AfterEffectNodePtr > maAfterEffectNodes;
+
+public:
+	AnimationExporter( const EscherSolverContainer& rSolverContainer, ppt::ExSoundCollection& rExSoundCollection );
+
+	void doexport( const ::com::sun::star::uno::Reference< ::com::sun::star::drawing::XDrawPage >& xPage, SvStream& rStrm );
+
+	sal_Int32 mnCurrentGroup;
+};
+
+} // namespace ppt
+
+#endif
diff --git a/sd/source/filter/pptx/pptexsoundcollection.hxx b/sd/source/filter/pptx/pptexsoundcollection.hxx
new file mode 100644
index 0000000..9dc8e54
--- /dev/null
+++ sd/source/filter/pptx/pptexsoundcollection.hxx
@@ -0,0 +1,86 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: pptexsoundcollection.hxx,v $
+ * $Revision: 1.4 $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+
+#ifndef _SD_PPT_EXSOUNDCOLLECTION_HXX
+#define _SD_PPT_EXSOUNDCOLLECTION_HXX
+
+#ifdef DBG_ANIM_LOG
+#include <stdio.h>
+#endif
+#include <tools/string.hxx>
+#include <tools/stream.hxx>
+#ifndef BOOST_SHARED_PTR_HPP_INCLUDED
+#include <boost/shared_ptr.hpp>
+#endif
+
+#include <list>
+
+namespace ppt
+{ 
+
+class ExSoundEntry
+{
+		sal_uInt32				nFileSize;
+		String					aSoundURL;
+
+		String					ImplGetName() const;
+		String					ImplGetExtension() const;
+
+	public :
+		
+		sal_Bool				IsSameURL( const String& rURL ) const;
+		sal_uInt32				GetFileSize( ) const { return nFileSize; };
+
+								ExSoundEntry( const String& rSoundURL );
+
+		// returns the size of a complete SoundContainer
+		sal_uInt32				GetSize( sal_uInt32 nId ) const;
+		void					Write( SvStream& rSt, sal_uInt32 nId );
+};
+
+class ExSoundCollection : private List
+{
+		const ExSoundEntry*		ImplGetByIndex( sal_uInt32 nId ) const;
+
+	public:
+
+								ExSoundCollection() {}
+								~ExSoundCollection();
+
+		sal_uInt32				GetId( const String& );
+
+		// returns the size of a complete SoundCollectionContainer
+		sal_uInt32				GetSize() const;
+		void					Write( SvStream& rSt );
+};
+
+} // namespace ppt
+
+#endif
diff --git a/sd/source/filter/pptx/pptx-eppt.cxx b/sd/source/filter/pptx/pptx-eppt.cxx
new file mode 100644
index 0000000..29f6829
--- /dev/null
+++ sd/source/filter/pptx/pptx-eppt.cxx
@@ -0,0 +1,2458 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: eppt.cxx,v $
+ * $Revision: 1.64.78.1 $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+
+// MARKER(update_precomp.py): autogen include statement, do not remove
+#include "precompiled_sd.hxx"
+#include <eppt.hxx>
+#include "epptdef.hxx"
+#include <tools/globname.hxx>
+#include <tools/datetime.hxx>
+#include <tools/poly.hxx>
+#include <vcl/graph.hxx>
+#include <vcl/bmpacc.hxx>
+#include <vcl/gradient.hxx>
+#include <rtl/ustring.hxx>
+#include <tools/stream.hxx>
+#include <svtools/fltcall.hxx>
+#include <sfx2/docfile.hxx>
+#include <svx/unoapi.hxx>
+#include <svx/svdobj.hxx>
+#include <svx/svdoole2.hxx>
+#include <svx/svdmodel.hxx>
+#include <svx/svdpage.hxx>
+#include <com/sun/star/view/PaperOrientation.hpp>
+#include <com/sun/star/view/PaperFormat.hpp>
+#include <com/sun/star/document/XDocumentPropertiesSupplier.hpp>
+#include <tools/zcodec.hxx>
+#include <svx/svxenum.hxx>
+#include <sot/storinfo.hxx>
+#include <svx/msoleexp.hxx>
+#include <vcl/virdev.hxx>
+#include <svtools/wmf.hxx>
+#include <svx/msdffimp.hxx>
+#include <svx/flditem.hxx>
+#include <sfx2/docinf.hxx>
+
+#define PPT_TRANSITION_TYPE_NONE            0
+#define PPT_TRANSITION_TYPE_RANDOM          1
+#define PPT_TRANSITION_TYPE_BLINDS          2
+#define PPT_TRANSITION_TYPE_CHECKER         3
+#define PPT_TRANSITION_TYPE_COVER           4
+#define PPT_TRANSITION_TYPE_DISSOLVE        5
+#define PPT_TRANSITION_TYPE_FADE            6
+#define PPT_TRANSITION_TYPE_PULL            7
+#define PPT_TRANSITION_TYPE_RANDOM_BARS     8
+#define PPT_TRANSITION_TYPE_STRIPS          9
+#define PPT_TRANSITION_TYPE_WIPE           10
+#define PPT_TRANSITION_TYPE_ZOOM           11
+#define PPT_TRANSITION_TYPE_SPLIT          13
+
+// effects, new in xp
+#define PPT_TRANSITION_TYPE_DIAMOND			17
+#define PPT_TRANSITION_TYPE_PLUS			18
+#define PPT_TRANSITION_TYPE_WEDGE			19
+#define PPT_TRANSITION_TYPE_PUSH			20
+#define PPT_TRANSITION_TYPE_COMB			21
+#define PPT_TRANSITION_TYPE_NEWSFLASH		22
+#define PPT_TRANSITION_TYPE_SMOOTHFADE		23
+#define PPT_TRANSITION_TYPE_WHEEL			26
+#define PPT_TRANSITION_TYPE_CIRCLE			27
+
+using namespace com::sun::star;
+
+static PHLayout pPHLayout[] =
+{
+	{ EPP_LAYOUT_TITLESLIDE,			{ 0x0d, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }, 0x00, 0x0d, 0x10, TRUE, TRUE, FALSE },
+	{ EPP_LAYOUT_TITLEANDBODYSLIDE,		{ 0x0d, 0x0e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }, 0x00, 0x0d, 0x0e, TRUE, TRUE, FALSE },
+	{ EPP_LAYOUT_TITLEANDBODYSLIDE,		{ 0x0d, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }, 0x14, 0x0d, 0x0e, TRUE, TRUE, FALSE },
+	{ EPP_LAYOUT_2COLUMNSANDTITLE,		{ 0x0d, 0x0e, 0x0e, 0x00, 0x00, 0x00, 0x00, 0x00 }, 0x00, 0x0d, 0x0e, TRUE, TRUE, TRUE },
+	{ EPP_LAYOUT_2COLUMNSANDTITLE,		{ 0x0d, 0x0e, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00 }, 0x14, 0x0d, 0x0e, TRUE, TRUE, FALSE },
+	{ EPP_LAYOUT_BLANCSLIDE,			{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }, 0x00, 0x0d, 0x0e, FALSE, FALSE, FALSE },
+	{ EPP_LAYOUT_2COLUMNSANDTITLE,		{ 0x0d, 0x0e, 0x16, 0x00, 0x00, 0x00, 0x00, 0x00 }, 0x16, 0x0d, 0x0e, TRUE, TRUE, FALSE },
+	{ EPP_LAYOUT_2COLUMNSANDTITLE,		{ 0x0d, 0x14, 0x0e, 0x00, 0x00, 0x00, 0x00, 0x00 }, 0x14, 0x0d, 0x0e, TRUE, TRUE, FALSE },
+	{ EPP_LAYOUT_TITLEANDBODYSLIDE,		{ 0x0d, 0x15, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }, 0x15, 0x0d, 0x0e, TRUE, FALSE, FALSE },
+	{ EPP_LAYOUT_2COLUMNSANDTITLE,		{ 0x0d, 0x16, 0x0e, 0x00, 0x00, 0x00, 0x00, 0x00 }, 0x16, 0x0d, 0x0e, TRUE, TRUE, FALSE },
+	{ EPP_LAYOUT_2COLUMNSANDTITLE,		{ 0x0d, 0x0e, 0x13, 0x00, 0x00, 0x00, 0x00, 0x00 }, 0x13, 0x0d, 0x0e, TRUE, TRUE, FALSE },
+	{ EPP_LAYOUT_TITLEANDBODYSLIDE,		{ 0x0d, 0x13, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }, 0x13, 0x0d, 0x0e, TRUE, FALSE, FALSE },
+	{ EPP_LAYOUT_RIGHTCOLUMN2ROWS,		{ 0x0d, 0x0e, 0x13, 0x13, 0x00, 0x00, 0x00, 0x00 }, 0x13, 0x0d, 0x0e, TRUE, TRUE, FALSE },
+	{ EPP_LAYOUT_2COLUMNSANDTITLE,		{ 0x0d, 0x13, 0x0e, 0x00, 0x00, 0x00, 0x00, 0x00 }, 0x13, 0x0d, 0x0e, TRUE, TRUE, FALSE },
+	{ EPP_LAYOUT_2ROWSANDTITLE,			{ 0x0d, 0x13, 0x0e, 0x00, 0x00, 0x00, 0x00, 0x00 }, 0x13, 0x0d, 0x0e, TRUE, TRUE, FALSE },
+	{ EPP_LAYOUT_LEFTCOLUMN2ROWS,		{ 0x0d, 0x13, 0x13, 0x0e, 0x00, 0x00, 0x00, 0x00 }, 0x13, 0x0d, 0x0e, TRUE, TRUE, FALSE },
+	{ EPP_LAYOUT_TOPROW2COLUMN,			{ 0x0d, 0x13, 0x13, 0x0e, 0x00, 0x00, 0x00, 0x00 }, 0x13, 0x0d, 0x0e, TRUE, TRUE, FALSE },
+	{ EPP_LAYOUT_2ROWSANDTITLE,			{ 0x0d, 0x0e, 0x13, 0x00, 0x00, 0x00, 0x00, 0x00 }, 0x13, 0x0d, 0x0e, TRUE, TRUE, FALSE },
+	{ EPP_LAYOUT_4OBJECTS,				{ 0x0d, 0x13, 0x13, 0x13, 0x13, 0x00, 0x00, 0x00 }, 0x13, 0x0d, 0x0e, TRUE, FALSE, FALSE },
+	{ EPP_LAYOUT_ONLYTITLE,				{ 0x0d, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }, 0x00, 0x0d, 0x0e, TRUE, FALSE, FALSE },
+	{ EPP_LAYOUT_BLANCSLIDE,			{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }, 0x00, 0x0d, 0x0e, FALSE, FALSE, FALSE },
+	{ EPP_LAYOUT_TITLERIGHT2BODIESLEFT, { 0x11, 0x12, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00 }, 0x14, 0x11, 0x12, TRUE, TRUE, FALSE },
+	{ EPP_LAYOUT_TITLERIGHTBODYLEFT,	{ 0x11, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }, 0x00, 0x11, 0x12, TRUE, TRUE, FALSE },
+	{ EPP_LAYOUT_TITLEANDBODYSLIDE,		{ 0x0d, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }, 0x00, 0x0d, 0x12, TRUE, TRUE, FALSE },
+	{ EPP_LAYOUT_2COLUMNSANDTITLE,		{ 0x0d, 0x16, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00 }, 0x16, 0x0d, 0x12, TRUE, TRUE, FALSE }
+};
+
+//============================ PPTWriter ==================================
+
+PPTWriter::PPTWriter( SvStorageRef& rSvStorage,
+            ::com::sun::star::uno::Reference< ::com::sun::star::frame::XModel > & rXModel,
+            ::com::sun::star::uno::Reference< ::com::sun::star::task::XStatusIndicator > & rXStatInd,
+            SvMemoryStream* pVBA, sal_uInt32 nCnvrtFlags ) :
+    mbStatus                ( sal_False ),
+	mbUseNewAnimations		( sal_True ),
+    mnLatestStatValue       ( 0 ),
+    maFraction              ( 1, 576 ),
+    maMapModeSrc            ( MAP_100TH_MM ),
+    maMapModeDest           ( MAP_INCH, Point(), maFraction, maFraction ),
+    meLatestPageType        ( NORMAL ),
+    mXModel                 ( rXModel ),
+	mXStatusIndicator       ( rXStatInd ),
+	mbStatusIndicator       ( FALSE ),
+	mpCurUserStrm           ( NULL ),
+	mpStrm                  ( NULL ),
+    mpPicStrm               ( NULL ),
+	mpPptEscherEx           ( NULL ),
+    mnVBAOleOfs             ( 0 ),
+    mpVBA                   ( pVBA ),
+    mnExEmbed               ( 0 ),
+    mpExEmbed               ( new SvMemoryStream ),
+    mnPagesWritten          ( 0 ),
+	mnTxId                  ( 0x7a2f64 )
+{
+    sal_uInt32 i;
+    if ( !ImplInitSOIface() )
+        return;
+
+    FontCollectionEntry aDefaultFontDesc( String( RTL_CONSTASCII_USTRINGPARAM( "Times New Roman" ) ),
+                                            ::com::sun::star::awt::FontFamily::ROMAN,
+                                                ::com::sun::star::awt::FontPitch::VARIABLE,
+                                                    RTL_TEXTENCODING_MS_1252 );
+    maFontCollection.GetId( aDefaultFontDesc ); // default is always times new roman
+
+    if ( !ImplGetPageByIndex( 0, NOTICE ) )
+        return;
+    INT32 nWidth = 21000;
+    if ( ImplGetPropertyValue( mXPagePropSet, String( RTL_CONSTASCII_USTRINGPARAM(  "Width" ) ) ) )
+        mAny >>= nWidth;
+    INT32 nHeight = 29700;
+    if ( ImplGetPropertyValue( mXPagePropSet, String( RTL_CONSTASCII_USTRINGPARAM( "Height" ) ) ) )
+        mAny >>= nHeight;
+
+    maNotesPageSize = ImplMapSize( ::com::sun::star::awt::Size( nWidth, nHeight ) );
+
+    if ( !ImplGetPageByIndex( 0, MASTER ) )
+        return;
+    nWidth = 28000;
+    if ( ImplGetPropertyValue( mXPagePropSet, String( RTL_CONSTASCII_USTRINGPARAM( "Width" ) ) ) )
+        mAny >>= nWidth;
+    nHeight = 21000;
+    if ( ImplGetPropertyValue( mXPagePropSet, String( RTL_CONSTASCII_USTRINGPARAM( "Height" ) ) ) )
+        mAny >>= nHeight;
+    maDestPageSize = ImplMapSize( ::com::sun::star::awt::Size( nWidth, nHeight ) );
+
+    mrStg = rSvStorage;
+    if ( !mrStg.Is() )
+        return;
+
+    // MasterPages + Slides und Notizen + NotesMasterPage
+    mnDrawings = mnMasterPages + ( mnPages << 1 ) + 1;
+
+    if ( mXStatusIndicator.is() )
+    {
+        mbStatusIndicator = TRUE;
+        mnStatMaxValue = ( mnPages + mnMasterPages ) * 5;
+        mXStatusIndicator->start( String( RTL_CONSTASCII_USTRINGPARAM( "PowerPoint Export" ) ),
+                                    mnStatMaxValue + ( mnStatMaxValue >> 3 ) );
+    }
+
+    SvGlobalName aGName( 0x64818d10L, 0x4f9b, 0x11cf, 0x86, 0xea, 0x00, 0xaa, 0x00, 0xb9, 0x29, 0xe8 );
+    mrStg->SetClass( aGName, 0, String( RTL_CONSTASCII_USTRINGPARAM( "MS PowerPoint 97" ) ) );
+
+    if ( !ImplCreateCurrentUserStream() )
+        return;
+
+    mpStrm = mrStg->OpenSotStream( String( RTL_CONSTASCII_USTRINGPARAM( "PowerPoint Document" ) ) );
+    if ( !mpStrm )
+        return;
+
+    if ( !mpPicStrm )
+        mpPicStrm = mrStg->OpenSotStream( String( RTL_CONSTASCII_USTRINGPARAM( "Pictures" ) ) );
+
+    mpPptEscherEx = new PptEscherEx( *mpStrm, mnDrawings );
+
+    if ( !ImplGetStyleSheets() )
+        return;
+
+    if ( !ImplCreateDocument() )
+        return;
+
+    for ( i = 0; i < mnMasterPages; i++ )
+    {
+        if ( !ImplCreateMaster( i ) )
+            return;
+    }
+	if ( !ImplCreateMainNotes() )
+		return;
+    maTextRuleList.First();                         // rewind list, so we can get the current or next entry without
+                                                    // searching, all entrys are sorted#
+    for ( i = 0; i < mnPages; i++ )
+    {
+        if ( !ImplCreateSlide( i ) )
+            return;
+    }
+    for ( i = 0; i < mnPages; i++ )
+    {
+        if ( !ImplCreateNotes( i ) )
+            return;
+    }
+    if ( !ImplCloseDocument() )
+        return;
+
+    if ( mbStatusIndicator )
+    {
+        mXStatusIndicator->setText( String( RTL_CONSTASCII_USTRINGPARAM( "PowerPoint Export" ) ) );
+        sal_uInt32 nValue = mnStatMaxValue + ( mnStatMaxValue >> 3 );
+        if ( nValue > mnLatestStatValue )
+        {
+            mXStatusIndicator->setValue( nValue );
+            mnLatestStatValue = nValue;
+        }
+    }
+
+    ImplWriteOLE( nCnvrtFlags );
+
+    ImplWriteVBA( pVBA );
+
+    if ( !ImplWriteAtomEnding() )
+        return;
+
+    if ( !ImplCreateDocumentSummaryInformation( nCnvrtFlags ) )
+        return;
+
+    mbStatus = TRUE;
+};
+
+
+// ---------------------------------------------------------------------------------------------
+
+PPTWriter::~PPTWriter()
+{
+    void*  pPtr;
+    delete mpExEmbed;
+    delete mpPptEscherEx;
+
+	std::vector< PPTExStyleSheet* >::iterator aStyleSheetIter( maStyleSheetList.begin() );
+	while( aStyleSheetIter < maStyleSheetList.end() )
+		delete *aStyleSheetIter++;
+
+    for ( pPtr = maTextRuleList.First(); pPtr; pPtr = maTextRuleList.Next() )
+        delete (TextRuleEntry*)pPtr;
+    for ( pPtr = maSlideNameList.First(); pPtr; pPtr = maSlideNameList.Next() )
+        delete (::rtl::OUString*)pPtr;
+    for ( pPtr = maHyperlink.First(); pPtr; pPtr = maHyperlink.Next() )
+        delete (EPPTHyperlink*)pPtr;
+    for ( pPtr = maExOleObj.First(); pPtr; pPtr = maExOleObj.Next() )
+        delete (PPTExOleObjEntry*)pPtr;
+
+    if ( mbStatusIndicator )
+        mXStatusIndicator->end();
+}
+
+// ---------------------------------------------------------------------------------------------
+
+static inline sal_uInt32 PPTtoEMU( INT32 nPPT )
+{
+    return (sal_uInt32)( (double)nPPT * 1587.5 );
+}
+
+// ---------------------------------------------------------------------------------------------
+
+sal_Bool PPTWriter::ImplCreateCurrentUserStream()
+{
+    mpCurUserStrm = mrStg->OpenSotStream( String( RTL_CONSTASCII_USTRINGPARAM( "Current User" ) ) );
+    if ( !mpCurUserStrm )
+        return FALSE;
+    char pUserName[] = "Current User";
+    sal_uInt32 nLenOfUserName = strlen( pUserName );
+    sal_uInt32 nSizeOfRecord = 0x14 + ( ( nLenOfUserName + 4 ) & ~ 3 );
+
+    *mpCurUserStrm << (sal_uInt16)0 << (sal_uInt16)EPP_CurrentUserAtom << nSizeOfRecord;
+    *mpCurUserStrm << (sal_uInt32)0x14                  // Len
+                   << (sal_uInt32)0xe391c05f;           // Magic
+
+    sal_uInt32 nEditPos = mpCurUserStrm->Tell();
+    *mpCurUserStrm << (sal_uInt32)0x0                   // OffsetToCurrentEdit;
+                   << (sal_uInt16)nLenOfUserName        //
+                   << (sal_uInt16)0x3f4                 // DocFileVersion
+                   << (sal_uInt8)3                      // MajorVersion
+                   << (sal_uInt8)0                      // MinorVersion
+                   << (sal_uInt16)0;                    // Pad Word
+    pUserName[ nLenOfUserName ] = 8;
+    mpCurUserStrm->Write( pUserName, nLenOfUserName + 1 );
+    for ( sal_uInt32 i = 0x15 + nLenOfUserName; i < nSizeOfRecord; i++ )
+    {
+        *mpCurUserStrm << (sal_uInt8)0;                 // pad bytes
+    };
+    mpCurUserStrm->Seek( nEditPos );
+    return TRUE;
+};
+
+// ---------------------------------------------------------------------------------------------
+
+sal_Bool PPTWriter::ImplCreateDocumentSummaryInformation( sal_uInt32 nCnvrtFlags )
+{
+    uno::Reference<document::XDocumentPropertiesSupplier> xDPS(
+        mXModel, uno::UNO_QUERY_THROW);
+    uno::Reference<document::XDocumentProperties> xDocProps(
+        xDPS->getDocumentProperties());
+
+    if (xDocProps.is()) {
+
+        // no idea what this is...
+        static sal_uInt8 aGuid[ 0x52 ] =
+        {
+            0x4e, 0x00, 0x00, 0x00,
+            '{',0,'D',0,'B',0,'1',0,'A',0,'C',0,'9',0,'6',0,'4',0,'-',0,
+            'E',0,'3',0,'9',0,'C',0,'-',0,'1',0,'1',0,'D',0,'2',0,'-',0,
+            'A',0,'1',0,'E',0,'F',0,'-',0,'0',0,'0',0,'6',0,'0',0,'9',0,
+            '7',0,'D',0,'A',0,'5',0,'6',0,'8',0,'9',0,'}',0
+        };
+        uno::Sequence<sal_uInt8> aGuidSeq(aGuid, 0x52);
+
+        SvMemoryStream  aHyperBlob;
+        ImplCreateHyperBlob( aHyperBlob );
+
+        uno::Sequence<sal_uInt8> aHyperSeq(aHyperBlob.Tell());
+        const sal_uInt8* pBlob(
+            static_cast<const sal_uInt8*>(aHyperBlob.GetData()));
+        for (sal_Int32 j = 0; j < aHyperSeq.getLength(); ++j) {
+            aHyperSeq[j] = pBlob[j];
+        }
+
+		if ( nCnvrtFlags & 0x8000 )
+		{
+			uno::Sequence<sal_uInt8> aThumbSeq;
+			if ( ImplGetPageByIndex( 0, NORMAL ) &&
+				 ImplGetPropertyValue( mXPagePropSet,
+					String( RTL_CONSTASCII_USTRINGPARAM( "PreviewBitmap" ) ) ) )
+			{
+				aThumbSeq =
+					*static_cast<const uno::Sequence<sal_uInt8>*>(mAny.getValue());
+			}
+			sfx2::SaveOlePropertySet( xDocProps, mrStg,
+					&aThumbSeq, &aGuidSeq, &aHyperSeq);
+		}
+		else
+		{
+			sfx2::SaveOlePropertySet( xDocProps, mrStg,
+					NULL, &aGuidSeq, &aHyperSeq );
+		}
+    }
+
+    return sal_True;
+}
+
+// ---------------------------------------------------------------------------------------------
+
+void PPTWriter::ImplWriteExtParaHeader( SvMemoryStream& rSt, sal_uInt32 nRef, sal_uInt32 nInstance, sal_uInt32 nSlideId )
+{
+    if ( rSt.Tell() )
+    {
+        aBuExOutlineStream << (sal_uInt32)( ( EPP_PST_ExtendedParagraphHeaderAtom << 16 )
+                                | ( nRef << 4 ) )
+                            << (sal_uInt32)8
+                            << (sal_uInt32)nSlideId
+                            << (sal_uInt32)nInstance;
+        aBuExOutlineStream.Write( rSt.GetData(), rSt.Tell() );
+    }
+}
+
+// ---------------------------------------------------------------------------------------------
+
+void PPTWriter::ImplCreateHeaderFooterStrings( SvStream& rStrm, ::com::sun::star::uno::Reference< ::com::sun::star::beans::XPropertySet >& rXPagePropSet )
+{
+	if ( rXPagePropSet.is() )
+	{
+		rtl::OUString aString;
+        ::com::sun::star::uno::Any aAny;
+        if ( PropValue::GetPropertyValue( aAny, rXPagePropSet, String( RTL_CONSTASCII_USTRINGPARAM( "HeaderText" ) ), sal_True ) )
+		{
+            if ( aAny >>= aString )
+				ImplWriteCString( rStrm, aString, 1 );
+		}
+        if ( PropValue::GetPropertyValue( aAny, rXPagePropSet, String( RTL_CONSTASCII_USTRINGPARAM( "FooterText" ) ), sal_True ) )
+		{
+            if ( aAny >>= aString )
+				ImplWriteCString( rStrm, aString, 2 );
+		}
+        if ( PropValue::GetPropertyValue( aAny, rXPagePropSet, String( RTL_CONSTASCII_USTRINGPARAM( "DateTimeText" ) ), sal_True ) )
+		{
+            if ( aAny >>= aString )
+				ImplWriteCString( rStrm, aString, 0 );
+		}
+	}
+}
+
+// ---------------------------------------------------------------------------------------------
+
+void PPTWriter::ImplCreateHeaderFooters( ::com::sun::star::uno::Reference< ::com::sun::star::beans::XPropertySet >& rXPagePropSet )
+{
+	if ( rXPagePropSet.is() )
+	{
+		sal_Bool bVal = sal_False;
+		sal_uInt32 nVal = 0;
+        ::com::sun::star::uno::Any aAny;
+        if ( PropValue::GetPropertyValue( aAny, rXPagePropSet, String( RTL_CONSTASCII_USTRINGPARAM( "IsHeaderVisible" ) ), sal_True ) )
+		{
+			if ( ( aAny >>= bVal ) && bVal )
+				nVal |= 0x100000;
+		}
+        if ( PropValue::GetPropertyValue( aAny, rXPagePropSet, String( RTL_CONSTASCII_USTRINGPARAM( "IsFooterVisible" ) ), sal_True ) )
+		{
+			if ( ( aAny >>= bVal ) && bVal )
+				nVal |= 0x200000;
+		}
+        if ( PropValue::GetPropertyValue( aAny, rXPagePropSet, String( RTL_CONSTASCII_USTRINGPARAM( "IsDateTimeVisible" ) ), sal_True ) )
+		{
+			if ( ( aAny >>= bVal ) && bVal )
+				nVal |= 0x010000;
+		}
+        if ( PropValue::GetPropertyValue( aAny, rXPagePropSet, String( RTL_CONSTASCII_USTRINGPARAM( "IsPageNumberVisible" ) ), sal_True ) )
+		{
+			if ( ( aAny >>= bVal ) && bVal )
+				nVal |= 0x080000;
+		}
+        if ( PropValue::GetPropertyValue( aAny, rXPagePropSet, String( RTL_CONSTASCII_USTRINGPARAM( "IsDateTimeFixed" ) ), sal_True ) )
+		{
+			if ( ( aAny >>= bVal ) && !bVal )
+				nVal |= 0x20000;
+			else
+				nVal |= 0x40000;
+		}
+		if ( PropValue::GetPropertyValue( aAny, rXPagePropSet, String( RTL_CONSTASCII_USTRINGPARAM( "DateTimeFormat" ) ), sal_True ) )
+		{
+			sal_Int32 nFormat = *(sal_Int32*)aAny.getValue();
+			SvxDateFormat eDateFormat = (SvxDateFormat)( nFormat & 0xf );
+			SvxTimeFormat eTimeFormat = (SvxTimeFormat)( ( nFormat >> 4 ) & 0xf );
+			switch( eDateFormat )
+			{
+				case SVXDATEFORMAT_F :
+					nFormat = 1;
+				break;
+				case SVXDATEFORMAT_D :
+					nFormat = 2;
+				break;
+				case SVXDATEFORMAT_C :
+					nFormat = 4;
+				break;
+				default:
+				case SVXDATEFORMAT_A :
+					nFormat = 0;
+			}
+			switch( eTimeFormat )
+			{
+				case SVXTIMEFORMAT_24_HM :
+					nFormat = 9;
+				break;
+				case SVXTIMEFORMAT_12_HM :
+					nFormat = 11;
+				break;
+				case SVXTIMEFORMAT_24_HMS :
+					nFormat = 10;
+				break;
+				case SVXTIMEFORMAT_12_HMS :
+					nFormat = 12;
+				break;
+				default:
+					break;
+			}
+			nVal |= nFormat;
+		}
+
+		mpPptEscherEx->OpenContainer( EPP_HeadersFooters, 0 );
+		mpPptEscherEx->AddAtom( 4, EPP_HeadersFootersAtom );
+		*mpStrm << nVal;
+		ImplCreateHeaderFooterStrings( *mpStrm, rXPagePropSet );
+		mpPptEscherEx->CloseContainer();
+	}
+}
+
+// ---------------------------------------------------------------------------------------------
+
+sal_Bool PPTWriter::ImplCreateDocument()
+{
+    sal_uInt32 i;
+    sal_uInt16 nSlideType = EPP_SLIDESIZE_TYPECUSTOM;
+
+    sal_uInt32 nWidth = maDestPageSize.Width;
+    sal_uInt32 nHeight = maDestPageSize.Height;
+
+    if ( ( nWidth == 0x1680 ) && ( nHeight == 0x10e0 ) )
+        nSlideType = EPP_SLIDESIZE_TYPEONSCREEN;
+    else if ( ( nWidth == 0x1200 ) && ( nHeight == 0x240 ) )
+        nSlideType = EPP_SLIDESIZE_TYPEBANNER;
+    else if ( ( nWidth == 0x1950 ) && ( nHeight == 0x10e0 ) )
+        nSlideType = EPP_SLIDESIZE_TYPE35MM;
+    else if ( ( nWidth == 0x1860 ) && ( nHeight == 0x10e0 ) )
+        nSlideType = EPP_SLIDESIZE_TYPEA4PAPER;
+
+    mpPptEscherEx->OpenContainer( EPP_Document );
+    // CREATE DOCUMENT ATOM
+    mpPptEscherEx->AddAtom( 40, EPP_DocumentAtom, 1 );
+    *mpStrm << nWidth                           // Slide Size in Master coordinates X
+            << nHeight                          //   "     "   "    "        "      Y
+            << (INT32)maNotesPageSize.Width     // Notes Page Size                  X
+            << (INT32)maNotesPageSize.Height    //   "     "   "                    Y
+            << (INT32)1 << (INT32)2;            // the scale used when the Powerpoint document is embedded. the default is 1:2
+    mpPptEscherEx->InsertPersistOffset( EPP_MAINNOTESMASTER_PERSIST_KEY, mpStrm->Tell() );
+    *mpStrm << (sal_uInt32)0                        // Reference to NotesMaster ( 0 if none );
+            << (sal_uInt32)0                        // Reference to HandoutMaster ( 0 if none );
+            << (sal_Int16)1                         // Number of the first slide;
+            << nSlideType                           // Size of the document slides ( default: EPP_SLIDESIZETYPEONSCREEN )
+            << (sal_uInt8)0                         // bool1 indicates if document was saved with embedded true type fonts
+            << (sal_uInt8)0                         // bool1 indicates if the placeholders on the title slide are omitted
+            << (sal_uInt8)0                         // bool1 right to left ( flag for Bidi version )
+            << (sal_uInt8)1;                            // bool1 visibility of comments shapes
+
+    mpPptEscherEx->PtInsert( EPP_Persist_Document, mpStrm->Tell() );
+
+	mpPptEscherEx->OpenContainer( EPP_HeadersFooters, 3 );	//Master footer	(default)
+	mpPptEscherEx->AddAtom( 4, EPP_HeadersFootersAtom );
+	*mpStrm << (sal_uInt32)0x25000d;
+    if ( ImplGetPageByIndex( 0, MASTER ) )
+		ImplCreateHeaderFooterStrings( *mpStrm, mXPagePropSet );
+	mpPptEscherEx->CloseContainer();
+	mpPptEscherEx->OpenContainer( EPP_HeadersFooters, 4 );	//NotesMaster footer (default)
+	mpPptEscherEx->AddAtom( 4, EPP_HeadersFootersAtom );
+	*mpStrm << (sal_uInt32)0x3d000d;
+    if ( ImplGetPageByIndex( 0, NOTICE ) )
+		ImplCreateHeaderFooterStrings( *mpStrm, mXPagePropSet );
+	mpPptEscherEx->CloseContainer();
+
+    mpPptEscherEx->OpenContainer( EPP_SlideListWithText );      // Animation info fuer die Slides
+
+    sal_uInt32  nShapes;
+    sal_Bool    bOtherThanPlaceHolders;
+
+    for ( i = 0; i < mnPages; i++ )
+    {
+        sal_uInt32  nPOffset, nPObjects;
+        sal_Bool    bOutliner, bTitle;
+
+        bOtherThanPlaceHolders = bOutliner = bTitle = FALSE;
+        nPObjects = 0;
+
+        mpPptEscherEx->AddAtom( 20, EPP_SlidePersistAtom );
+        mpPptEscherEx->InsertPersistOffset( EPP_MAINSLIDE_PERSIST_KEY | i, mpStrm->Tell() );
+        *mpStrm << (sal_uInt32)0;                               // psrReference - logical reference to the slide persist object ( EPP_MAINSLIDE_PERSIST_KEY )
+        nPOffset = mpStrm->Tell();
+        *mpStrm << (sal_uInt32)0                                // flags - only bit 3 used, if set then slide contains shapes other than placeholders
+                << (INT32)0                                     // numberTexts - number of placeholder texts stored with the persist object.  Allows to display outline view without loading the slide persist objects
+                << (INT32)i + 0x100                             // slideId - Unique slide identifier, used for OLE link monikers for example
+                << (sal_uInt32)0;                               // reserved, usualy 0
+
+        if ( !ImplGetPageByIndex( i, NORMAL ) )                 // sehr aufregend: noch einmal ueber alle seiten
+            return FALSE;
+		ImplSetCurrentStyleSheet( ImplGetMasterIndex( NORMAL ) );
+
+        const PHLayout& rLayout = ImplGetLayout( mXPagePropSet );
+
+        ::com::sun::star::uno::Reference< ::com::sun::star::container::XNamed >
+            aXName( mXDrawPage, ::com::sun::star::uno::UNO_QUERY );
+
+        if ( aXName.is() )
+        {
+            ::rtl::OUString aStr = aXName->getName();
+            ::rtl::OUString *pUStr = new ::rtl::OUString( aStr );
+            maSlideNameList.Insert( pUStr, LIST_APPEND );
+        }
+        else
+            maSlideNameList.Insert( new ::rtl::OUString(), LIST_APPEND );
+
+        nShapes = mXShapes->getCount();
+
+        sal_Bool bSecOutl = FALSE;
+        if ( nShapes && ( rLayout.bTitlePossible || rLayout.bOutlinerPossible ) )
+        {
+            for ( sal_uInt32 nIndex = 0; nIndex < nShapes; nIndex++ )
+            {
+                if ( !ImplGetShapeByIndex( nIndex ) )
+                    continue;
+
+                if ( mbPresObj && ( ( mType == "presentation.Outliner" ) || ( mType == "presentation.Subtitle" ) ) )
+                {
+                    if ( bOutliner == FALSE )
+                    {
+                        bOutliner = TRUE;
+                        mnTextStyle = EPP_TEXTSTYLE_BODY;
+                        sal_uInt32 nTextType = EPP_TEXTTYPE_Body;
+                        if ( bSecOutl )
+                            nTextType = EPP_TEXTTYPE_HalfBody;
+                        else if ( mType == "presentation.Subtitle" )
+                            nTextType = EPP_TEXTTYPE_CenterBody;
+
+                        TextRuleEntry* pRule = new TextRuleEntry( i );
+                        SvMemoryStream aExtBu( 0x200, 0x200 );
+                        if ( !mbEmptyPresObj )
+                            ImplGetText();
+                        ImplWriteTextStyleAtom( *mpStrm, nTextType, nPObjects, pRule, aExtBu, NULL );
+                        ImplWriteExtParaHeader( aExtBu, nPObjects++, nTextType, i + 0x100 );
+                        maTextRuleList.Insert( (void*)pRule, LIST_APPEND );
+                        if ( rLayout.bSecOutlinerPossible )
+                        {
+                            if ( ( nIndex + 1 ) < nShapes )
+                            {
+                                if ( ImplGetShapeByIndex( nIndex + 1 ) && mType == "presentation.Outliner" )
+                                {
+                                    bSecOutl = TRUE;
+                                    TextRuleEntry* pTempRule = new TextRuleEntry( i );
+                                    SvMemoryStream aTmpStrm( 0x200, 0x200 );
+                                    if ( !mbEmptyPresObj )
+                                        ImplGetText();
+                                    ImplWriteTextStyleAtom( *mpStrm, nTextType, nPObjects, pTempRule, aTmpStrm, NULL );
+                                    ImplWriteExtParaHeader( aTmpStrm, nPObjects++, nTextType, i + 0x100 );
+                                    maTextRuleList.Insert( (void*)pTempRule, LIST_APPEND );
+                                }
+                            }
+                        }
+                    }
+                }
+                else if ( rLayout.bTitlePossible && ( mType == "presentation.TitleText" ) )
+                {
+                    if ( bTitle == FALSE )
+                    {
+                        bTitle = TRUE;
+                        mnTextStyle = EPP_TEXTSTYLE_TITLE;
+                        TextRuleEntry* pRule = new TextRuleEntry( i );
+                        SvMemoryStream aExtBu( 0x200, 0x200 );
+                        if ( !mbEmptyPresObj )
+                            ImplGetText();
+                        ImplWriteTextStyleAtom( *mpStrm, EPP_TEXTTYPE_Title, nPObjects, pRule, aExtBu, NULL );
+                        ImplWriteExtParaHeader( aExtBu, nPObjects++, EPP_TEXTTYPE_Title, i + 0x100 );
+                        maTextRuleList.Insert( (void*)pRule, LIST_APPEND );
+                    }
+                }
+                else
+                {
+                    if ( mbEmptyPresObj )
+                        nPObjects++;
+                    else
+                        bOtherThanPlaceHolders = TRUE;  // muss noch auf background und leeren Title/outliner geprueft werden !!!
+                }
+                if ( bOutliner && bTitle && bOtherThanPlaceHolders )
+                    break;
+            }
+        }
+        if ( nPObjects )
+        {
+            sal_uInt32 nOldPos = mpStrm->Tell();
+            mpStrm->Seek( nPOffset );
+            *mpStrm << (sal_uInt32)( ( bOtherThanPlaceHolders ) ? 4 : 0 );
+            *mpStrm << nPObjects;
+            mpStrm->Seek( nOldPos );
+        }
+    }
+    mpPptEscherEx->CloseContainer();    // EPP_SlideListWithText
+
+    mpPptEscherEx->OpenContainer( EPP_SlideListWithText, 2 );   // Animation info fuer die notes
+    for( i = 0; i < mnPages; i++ )
+    {
+        if ( !ImplGetPageByIndex( i, NOTICE ) )
+            return FALSE;
+
+        nShapes = mXShapes->getCount();
+
+        bOtherThanPlaceHolders = FALSE;
+        if ( nShapes )
+        {
+            for ( sal_uInt32 nIndex = 0; ( nIndex < nShapes ) && ( bOtherThanPlaceHolders == FALSE ); nIndex++ )
+            {
+                 if ( ImplGetShapeByIndex( nIndex ) && ( mType != "drawing.Page" ) )
+                    bOtherThanPlaceHolders = TRUE;
+            }
+        }
+        mpPptEscherEx->AddAtom( 20, EPP_SlidePersistAtom );
+        mpPptEscherEx->InsertPersistOffset( EPP_MAINNOTES_PERSIST_KEY | i, mpStrm->Tell() );
+        *mpStrm << (sal_uInt32)0
+                << (sal_uInt32)( ( bOtherThanPlaceHolders ) ? 4 : 0 )
+                << (INT32)0
+                << (INT32)i + 0x100
+                << (sal_uInt32)0;
+    }
+    mpPptEscherEx->CloseContainer();        // EPP_SlideListWithText
+
+    ::com::sun::star::uno::Reference< ::com::sun::star::presentation::XPresentationSupplier >
+        aXPresSupplier( mXModel, ::com::sun::star::uno::UNO_QUERY );            ;
+    if ( aXPresSupplier.is() )
+    {
+        ::com::sun::star::uno::Reference< ::com::sun::star::presentation::XPresentation >
+            aXPresentation( aXPresSupplier->getPresentation() );
+        if ( aXPresentation.is() )
+        {
+            mXPropSet = ::com::sun::star::uno::Reference<
+                ::com::sun::star::beans::XPropertySet >
+                    ( aXPresentation, ::com::sun::star::uno::UNO_QUERY );
+            if ( mXPropSet.is() )
+            {
+                ::rtl::OUString aCustomShow;
+                sal_uInt32  nPenColor = 0x1000000;
+                INT32   nRestartTime = 0x7fffffff;
+                sal_Int16   nStartSlide = 0;
+                sal_Int16   nEndSlide = 0;
+                sal_uInt32  nFlags = 0;             // Bit 0:   Auto advance
+                                                    // Bit 1    Skip builds ( do not allow slide effects )
+                                                    // Bit 2    Use slide range
+                                                    // Bit 3    Use named show
+                                                    // Bit 4    Browse mode on
+                                                    // Bit 5    Kiosk mode on
+                                                    // Bit 7    loop continously
+                                                    // Bit ?    show scrollbar
+
+                if ( ImplGetPropertyValue( String( RTL_CONSTASCII_USTRINGPARAM( "CustomShow" ) ) ) )
+                {
+                    aCustomShow = ( *(::rtl::OUString*)mAny.getValue() );
+                    if ( aCustomShow.getLength() )
+                    {
+                        nFlags |= 8;
+                    }
+                }
+                if ( ( nFlags & 8 ) == 0 )
+                {
+                    if ( ImplGetPropertyValue( String( RTL_CONSTASCII_USTRINGPARAM( "FirstPage" ) ) ) )
+                    {
+                        ::rtl::OUString aSlideName( *(::rtl::OUString*)mAny.getValue() );
+                        ::rtl::OUString* pStr;
+                        for ( pStr = (::rtl::OUString*)maSlideNameList.First(); pStr;
+                                    pStr = (::rtl::OUString*)maSlideNameList.Next(), nStartSlide++ )
+                        {
+                            if ( *pStr == aSlideName )
+                            {
+                                nStartSlide++;
+                                nFlags |= 4;
+                                nEndSlide = (sal_uInt16)mnPages;
+                                break;
+                            }
+                        }
+                        if ( !pStr )
+                            nStartSlide = 0;
+                    }
+                }
+
+//              if ( ImplGetPropertyValue( String( RTL_CONSTASCII_USTRINGPARAM( "DiaName" ) ) ) )
+//              {
+//              }
+//              if ( ImplGetPropertyValue( String( RTL_CONSTASCII_USTRINGPARAM( "IsAlwaysOnTop" ) ) ) )
+//              {
+//              }
+                if ( ImplGetPropertyValue( String( RTL_CONSTASCII_USTRINGPARAM( "IsAutomatic" ) ) ) )
+                {
+                    sal_Bool bBool = sal_False;
+                    mAny >>= bBool;
+                    if ( !bBool )
+                        nFlags |= 1;
+                }
+
+                if ( ImplGetPropertyValue( String( RTL_CONSTASCII_USTRINGPARAM( "IsEndless" ) ) ) ) // muesste eigendlich heissen IsNotEndless !=)"()&
+                {
+                    sal_Bool bBool = sal_False;
+                    mAny >>= bBool;
+                    if ( bBool )
+                        nFlags |= 0x80;
+                }
+                if ( ImplGetPropertyValue( String( RTL_CONSTASCII_USTRINGPARAM( "IsFullScreen" ) ) ) )
+                {
+                    sal_Bool bBool = sal_False;
+                    mAny >>= bBool;
+                    if ( !bBool )
+                        nFlags |= 0x11;
+                }
+//              if ( ImplGetPropertyValue( String( RTL_CONSTASCII_USTRINGPARAM( "IsMouseVisible" ) ) ) )
+//              {
+//              }
+//              if ( ImplGetPropertyValue( String( RTL_CONSTASCII_USTRINGPARAM( "PageRange" ) ) ) )
+//              {
+//              }
+//              if ( ImplGetPropertyValue( String( RTL_CONSTASCII_USTRINGPARAM( "StartWithNavigator" ) ) ) )
+//              {
+//              }
+//              if ( ImplGetPropertyValue( String( RTL_CONSTASCII_USTRINGPARAM( "UsePen" ) ) ) )
+//              {
+//              }
+                mpPptEscherEx->AddAtom( 80, EPP_SSDocInfoAtom, 1 );
+                *mpStrm << nPenColor << nRestartTime << nStartSlide << nEndSlide;
+
+                sal_uInt32 nCustomShowNameLen = aCustomShow.getLength();
+                if ( nCustomShowNameLen > 31 )
+                    nCustomShowNameLen = 31;
+                if ( nCustomShowNameLen )       // named show identifier
+                {
+                    const sal_Unicode* pCustomShow = aCustomShow.getStr();
+                    for ( i = 0; i < nCustomShowNameLen; i++ )
+                    {
+                        *mpStrm << (sal_uInt16)( pCustomShow[ i ] );
+                    }
+                }
+                for ( i = nCustomShowNameLen; i < 32; i++, *mpStrm << (sal_uInt16)0 ) ;
+
+                *mpStrm << nFlags;
+                ::com::sun::star::uno::Reference< ::com::sun::star::presentation::XCustomPresentationSupplier >
+                    aXCPSup( mXModel, ::com::sun::star::uno::UNO_QUERY );
+                if ( aXCPSup.is() )
+                {
+                    ::com::sun::star::uno::Reference< ::com::sun::star::container::XNameContainer >
+                        aXCont( aXCPSup->getCustomPresentations() );
+                    if ( aXCont.is() )
+                    {
+                        ::com::sun::star::uno::Sequence< ::rtl::OUString> aNameSeq( aXCont->getElementNames() );
+                        const ::rtl::OUString* pUString = aNameSeq.getArray();
+                        sal_uInt32 nCount = aNameSeq.getLength();
+                        if ( nCount )
+                        {
+                            mpPptEscherEx->OpenContainer( EPP_NamedShows );
+                            sal_uInt32 nCustomShowIndex = 0;
+                            for( i = 0; i < nCount; i++ )        // Anzahl der Custom Shows
+                            {
+                                if ( pUString[ i ].getLength() )
+                                {
+                                    mpPptEscherEx->OpenContainer( EPP_NamedShow, nCustomShowIndex++ );
+
+                                    sal_uInt32 nNamedShowLen = pUString[ i ].getLength();
+                                    if ( nNamedShowLen > 31 )
+                                        nNamedShowLen = 31;
+                                    mpPptEscherEx->AddAtom( nNamedShowLen << 1, EPP_CString );
+                                    const sal_Unicode* pCustomShowName = pUString[ i ].getStr();
+                                    for ( sal_uInt32 k = 0; k < nNamedShowLen; *mpStrm << (sal_uInt16)( pCustomShowName[ k++ ] ) ) ;
+                                    mAny = aXCont->getByName( pUString[ i ] );
+                                    if ( mAny.getValue() )
+                                    {
+
+                                        ::com::sun::star::uno::Reference< ::com::sun::star::container::XIndexContainer > aXIC;
+                                        if ( mAny >>= aXIC )
+                                        {
+                                            mpPptEscherEx->BeginAtom();
+
+                                            INT32 nSlideCount = aXIC->getCount();
+                                            for ( INT32 j = 0; j < nSlideCount; j++ )   // Anzahl der Slides
+                                            {
+                                                mAny = aXIC->getByIndex( j );
+                                                if ( mAny.getValue() )
+                                                {
+                                                    ::com::sun::star::uno::Reference<
+                                                        ::com::sun::star::drawing::XDrawPage > aXDrawPage;
+                                                    if ( mAny >>= aXDrawPage )
+                                                    {
+                                                        ::com::sun::star::uno::Reference<
+                                                            ::com::sun::star::container::XNamed >
+                                                            aXName( aXDrawPage, ::com::sun::star::uno::UNO_QUERY );
+                                                        if ( aXName.is() )
+                                                        {
+                                                            ::rtl::OUString aSlideName( aXName->getName() );
+                                                            sal_uInt32 nPageNumber = 0;
+                                                            for ( ::rtl::OUString* pSlideName = (::rtl::OUString*)maSlideNameList.First();
+                                                                pSlideName;
+                                                                pSlideName = (::rtl::OUString*)maSlideNameList.Next(), nPageNumber++ )
+                                                            {
+                                                                if ( *pSlideName == aSlideName )
+                                                                {
+                                                                    *mpStrm << (sal_uInt32)( nPageNumber + 0x100 ); // unique slide id
+                                                                    break;
+                                                                }
+                                                            }
+                                                        }
+                                                    }
+                                                }
+                                            }
+                                            mpPptEscherEx->EndAtom( EPP_NamedShowSlides );
+                                        }
+                                    }
+                                    mpPptEscherEx->CloseContainer();            // EPP_NamedShow
+                                }
+                            }
+                            mpPptEscherEx->CloseContainer();                // EPP_NamedShows
+                        }
+                    }
+                }
+            }
+        }
+    }
+    mpPptEscherEx->AddAtom( 0, EPP_EndDocument );
+    mpPptEscherEx->CloseContainer();    // EPP_Document
+    return TRUE;
+};
+
+// ---------------------------------------------------------------------------------------------
+
+sal_Bool PPTWriter::ImplCreateHyperBlob( SvMemoryStream& rStrm )
+{
+    sal_uInt32 nCurrentOfs, nParaOfs, nParaCount = 0;
+// SfxOlePropertySection does this...
+//    rStrm << (sal_uInt32)0x41;      // property type VT_BLOB
+    nParaOfs = rStrm.Tell();
+    rStrm << (sal_uInt32)0;         // property size
+    rStrm << (sal_uInt32)0;         // property count
+
+    for ( EPPTHyperlink* pLink = (EPPTHyperlink*)maHyperlink.First(); pLink; pLink = (EPPTHyperlink*)maHyperlink.Next() )
+    {
+        nParaCount += 6;
+        rStrm   << (sal_uInt32)3    // Type VT_I4
+                << (sal_uInt32)7    // (VTI4 - Private1)
+                << (sal_uInt32)3    // Type VT_I4
+                << (sal_uInt32)6    // (VTI4 - Private2)
+                << (sal_uInt32)3    // Type VT_I4
+                << (sal_uInt32)0;   // (VTI4 - Private3)
+
+        // INFO
+        // HIWORD:  = 0 : do not change anything
+        //          = 1 : replace the hyperlink with the target and subadress in the following two VTLPWSTR
+        //          = 2 : delete the hyperlink
+        // LOWORD:  = 0 : graphic shown as background (link)
+        //          = 1 : graphic shown as shape (link)
+        //          = 2 : graphic is used to fill a shape
+        //          = 3 : graphic used to fill a shape outline (future use)
+        //          = 4 : hyperlink attached to a shape
+        //          = 5 :    "         "      " " (Word) field
+        //          = 6 :    "         "      " " (Excel) range
+        //          = 7 :    "         "      " " (PPT) text range
+        //          = 8 :    "         "      " " (Project) task
+
+        sal_uInt32 nUrlLen = pLink->aURL.Len();
+        const sal_Unicode* pUrl = pLink->aURL.GetBuffer();
+
+        sal_uInt32 nInfo = 7;
+
+        rStrm   << (sal_uInt32)3    // Type VT_I4
+                << nInfo;       // Info
+
+        switch( pLink->nType & 0xff )
+        {
+            case 1 :        // click action to slidenumber
+            {
+                rStrm << (sal_uInt32)0x1f << (sal_uInt32)1 << (sal_uInt32)0;    // path
+                rStrm << (sal_uInt32)0x1f << (sal_uInt32)( nUrlLen + 1 );
+                for ( sal_uInt32 i = 0; i < nUrlLen; i++ )
+                {
+                    rStrm << pUrl[ i ];
+                }
+                rStrm << (sal_uInt16)0;
+            }
+            break;
+            case 2 :
+            {
+                sal_uInt32 i;
+
+                rStrm   << (sal_uInt32)0x1f
+                        << (sal_uInt32)( nUrlLen + 1 );
+                for ( i = 0; i < nUrlLen; i++ )
+                {
+                    rStrm << pUrl[ i ];
+                }
+                if ( ! ( i & 1 ) )
+                    rStrm << (sal_uInt16)0;
+                rStrm   << (sal_uInt16)0
+                        << (sal_uInt32)0x1f
+                        << (sal_uInt32)1
+                        << (sal_uInt32)0;
+            }
+            break;
+        }
+    }
+    nCurrentOfs = rStrm.Tell();
+    rStrm.Seek( nParaOfs );
+    rStrm << (sal_uInt32)( nCurrentOfs - ( nParaOfs + 4 ) );
+    rStrm << nParaCount;
+    rStrm.Seek( nCurrentOfs );
+    return TRUE;
+}
+
+PHLayout& PPTWriter::ImplGetLayout(  const ::com::sun::star::uno::Reference< ::com::sun::star::beans::XPropertySet >& rXPropSet ) const
+{
+    ::com::sun::star::uno::Any aAny;
+    sal_Int16 nLayout = 20;
+    if ( GetPropertyValue( aAny, rXPropSet, String( RTL_CONSTASCII_USTRINGPARAM( "Layout" ) ) ), sal_True )
+        aAny >>= nLayout;
+
+    if ( ( nLayout >= 21 ) && ( nLayout <= 26 ) )   // NOTES _> HANDOUT6
+        nLayout = 20;
+    if ( ( nLayout >= 27 ) && ( nLayout <= 30 ) )   // VERTICAL LAYOUT
+        nLayout -= 6;
+    else if ( nLayout > 30 )
+        nLayout = 20;
+    return pPHLayout[ nLayout ];
+}
+
+
+// ---------------------------------------------------------------------------------------------
+
+sal_Bool PPTWriter::ImplCreateMaster( sal_uInt32 nPageNum )
+{
+    if ( !ImplGetPageByIndex( nPageNum, MASTER ) )
+        return FALSE;
+	ImplSetCurrentStyleSheet( nPageNum );
+
+    if ( !ImplGetPropertyValue( mXPagePropSet, String( RTL_CONSTASCII_USTRINGPARAM( "Background" ) ) ) )                // Backgroundshape laden
+        return FALSE;
+    ::com::sun::star::uno::Reference< ::com::sun::star::beans::XPropertySet > aXBackgroundPropSet;
+    if ( !( mAny >>= aXBackgroundPropSet ) )
+        return FALSE;
+
+    sal_uInt32 nFillColor = 0xffffff;
+    sal_uInt32 nFillBackColor = 0x000000;
+
+    ::com::sun::star::drawing::FillStyle aFS = ::com::sun::star::drawing::FillStyle_NONE;
+    if ( ImplGetPropertyValue( aXBackgroundPropSet, String( RTL_CONSTASCII_USTRINGPARAM( "FillStyle" ) ) ) )
+        mAny >>= aFS;
+    switch ( aFS )
+    {
+        case ::com::sun::star::drawing::FillStyle_GRADIENT :
+        {
+            if ( ImplGetPropertyValue( aXBackgroundPropSet, String( RTL_CONSTASCII_USTRINGPARAM( "FillGradient" ) ) ) )
+            {
+                nFillColor = EscherPropertyContainer::GetGradientColor( (::com::sun::star::awt::Gradient*)mAny.getValue(), 0 );
+                nFillBackColor = EscherPropertyContainer::GetGradientColor( (::com::sun::star::awt::Gradient*)mAny.getValue(), 1 );
+            }
+        }
+        break;
+
+        case ::com::sun::star::drawing::FillStyle_SOLID :
+        {
+            if ( ImplGetPropertyValue( aXBackgroundPropSet, String( RTL_CONSTASCII_USTRINGPARAM( "FillColor" ) ) ) )
+            {
+                nFillColor = mpPptEscherEx->GetColor( *((sal_uInt32*)mAny.getValue()) );
+                nFillBackColor = nFillColor ^ 0xffffff;
+            }
+        }
+		break;
+
+		default:
+			break;
+    }
+
+    mpPptEscherEx->PtReplaceOrInsert( EPP_Persist_MainMaster | nPageNum, mpStrm->Tell() );
+    mpPptEscherEx->OpenContainer( EPP_MainMaster );
+    mpPptEscherEx->AddAtom( 24, EPP_SlideAtom, 2 );
+    *mpStrm << (INT32)EPP_LAYOUT_TITLEANDBODYSLIDE  // slide layout -> title and body slide
+            << (sal_uInt8)1 << (sal_uInt8)2 << (sal_uInt8)0 << (sal_uInt8)0 << (sal_uInt8)0 << (sal_uInt8)0 << (sal_uInt8)0 << (sal_uInt8)0     // placeholderID
+            << (sal_uInt32)0		// master ID ( ist gleich null bei einer masterpage )
+            << (sal_uInt32)0        // notes ID ( ist gleich null wenn keine notizen vorhanden )
+            << (sal_uInt16)0        // Bit 1: Follow master objects, Bit 2: Follow master scheme, Bit 3: Follow master background
+            << (sal_uInt16)0;       // padword
+
+    mpPptEscherEx->AddAtom( 32, EPP_ColorSchemeAtom, 0, 6 );
+    *mpStrm << (sal_uInt32)0xffffff << (sal_uInt32)0x000000 << (sal_uInt32)0x808080 << (sal_uInt32)0x000000 << (sal_uInt32)0x99cc00 << (sal_uInt32)0xcc3333 << (sal_uInt32)0xffcccc << (sal_uInt32)0xb2b2b2;
+    mpPptEscherEx->AddAtom( 32, EPP_ColorSchemeAtom, 0, 6 );
+    *mpStrm << (sal_uInt32)0xff0000 << (sal_uInt32)0xffffff << (sal_uInt32)0x000000 << (sal_uInt32)0x00ffff << (sal_uInt32)0x0099ff << (sal_uInt32)0xffff00 << (sal_uInt32)0x0000ff << (sal_uInt32)0x969696;
+    mpPptEscherEx->AddAtom( 32, EPP_ColorSchemeAtom, 0, 6 );
+    *mpStrm << (sal_uInt32)0xccffff << (sal_uInt32)0x000000 << (sal_uInt32)0x336666 << (sal_uInt32)0x008080 << (sal_uInt32)0x339933 << (sal_uInt32)0x000080 << (sal_uInt32)0xcc3300 << (sal_uInt32)0x66ccff;
+    mpPptEscherEx->AddAtom( 32, EPP_ColorSchemeAtom, 0, 6 );
+    *mpStrm << (sal_uInt32)0xffffff << (sal_uInt32)0x000000 << (sal_uInt32)0x333333 << (sal_uInt32)0x000000 << (sal_uInt32)0xdddddd << (sal_uInt32)0x808080 << (sal_uInt32)0x4d4d4d << (sal_uInt32)0xeaeaea;
+    mpPptEscherEx->AddAtom( 32, EPP_ColorSchemeAtom, 0, 6 );
+    *mpStrm << (sal_uInt32)0xffffff << (sal_uInt32)0x000000 << (sal_uInt32)0x808080 << (sal_uInt32)0x000000 << (sal_uInt32)0x66ccff << (sal_uInt32)0xff0000 << (sal_uInt32)0xcc00cc << (sal_uInt32)0xc0c0c0;
+    mpPptEscherEx->AddAtom( 32, EPP_ColorSchemeAtom, 0, 6 );
+    *mpStrm << (sal_uInt32)0xffffff << (sal_uInt32)0x000000 << (sal_uInt32)0x808080 << (sal_uInt32)0x000000 << (sal_uInt32)0xc0c0c0 << (sal_uInt32)0xff6600 << (sal_uInt32)0x0000ff << (sal_uInt32)0x009900;
+    mpPptEscherEx->AddAtom( 32, EPP_ColorSchemeAtom, 0, 6 );
+    *mpStrm << (sal_uInt32)0xffffff << (sal_uInt32)0x000000 << (sal_uInt32)0x808080 << (sal_uInt32)0x000000 << (sal_uInt32)0xff9933 << (sal_uInt32)0xccff99 << (sal_uInt32)0xcc00cc << (sal_uInt32)0xb2b2b2;
+
+    for ( int nInstance = EPP_TEXTTYPE_Title; nInstance <= EPP_TEXTTYPE_QuarterBody; nInstance++ )
+    {
+        if ( nInstance == EPP_TEXTTYPE_notUsed )
+            continue;
+
+        // the auto color is dependent to the page background,so we have to set a page that is in the right context
+        if ( nInstance == EPP_TEXTTYPE_Notes )
+            ImplGetPageByIndex( 0, NOTICE );
+        else
+            ImplGetPageByIndex( 0, MASTER );
+
+        mpPptEscherEx->BeginAtom();
+
+        sal_Bool bFirst = TRUE;
+        sal_Bool bSimpleText = FALSE;
+
+        *mpStrm << (sal_uInt16)5;                           // paragraph count
+
+        for ( sal_uInt16 nLev = 0; nLev < 5; nLev++ )
+        {
+            if ( nInstance >= EPP_TEXTTYPE_CenterBody )
+            {
+                bFirst = FALSE;
+                bSimpleText = TRUE;
+                *mpStrm << nLev;
+            }
+            mpStyleSheet->mpParaSheet[ nInstance ]->Write( *mpStrm, mpPptEscherEx, nLev, bFirst, bSimpleText, mXPagePropSet );
+            mpStyleSheet->mpCharSheet[ nInstance ]->Write( *mpStrm, mpPptEscherEx, nLev, bFirst, bSimpleText, mXPagePropSet );
+            bFirst = FALSE;
+        }
+        mpPptEscherEx->EndAtom( EPP_TxMasterStyleAtom, 0, nInstance );
+    }
+    ImplGetPageByIndex( nPageNum, MASTER );
+
+    EscherSolverContainer aSolverContainer;
+
+    mpPptEscherEx->OpenContainer( EPP_PPDrawing );
+    mpPptEscherEx->OpenContainer( ESCHER_DgContainer );
+
+	mpPptEscherEx->EnterGroup(0,0);
+    ImplWritePage( pPHLayout[ 0 ], aSolverContainer, MASTER, TRUE );    // Die Shapes der Seite werden im PPT Dok. erzeugt
+    mpPptEscherEx->LeaveGroup();
+
+    ImplWriteBackground( aXBackgroundPropSet );
+
+    aSolverContainer.WriteSolver( *mpStrm );
+
+    mpPptEscherEx->CloseContainer();    // ESCHER_DgContainer
+    mpPptEscherEx->CloseContainer();    // EPP_Drawing
+    mpPptEscherEx->AddAtom( 32, EPP_ColorSchemeAtom, 0, 1 );
+    *mpStrm << (sal_uInt32)0xffffff << (sal_uInt32)0x000000 << (sal_uInt32)0x808080 << (sal_uInt32)0x000000 << (sal_uInt32)0x99cc00 << (sal_uInt32)0xcc3333 << (sal_uInt32)0xffcccc << (sal_uInt32)0xb2b2b2;
+
+	if ( aBuExMasterStream.Tell() )
+    {
+        ImplProgTagContainer( mpStrm, &aBuExMasterStream );
+    }
+    mpPptEscherEx->CloseContainer();    // EPP_MainMaster
+    return TRUE;
+};
+
+// ---------------------------------------------------------------------------------------------
+
+sal_Bool PPTWriter::ImplCreateMainNotes()
+{
+    if ( !ImplGetPageByIndex( 0, NOTICE ) )
+        return FALSE;
+	ImplSetCurrentStyleSheet( 0 );
+
+    ::com::sun::star::uno::Reference< ::com::sun::star::drawing::XMasterPageTarget >
+        aXMasterPageTarget( mXDrawPage, ::com::sun::star::uno::UNO_QUERY );
+
+    if ( !aXMasterPageTarget.is() )
+        return FALSE;
+
+    mXDrawPage = aXMasterPageTarget->getMasterPage();
+    if ( !mXDrawPage.is() )
+        return FALSE;
+
+    mXPropSet = ::com::sun::star::uno::Reference<
+        ::com::sun::star::beans::XPropertySet >
+            ( mXDrawPage, ::com::sun::star::uno::UNO_QUERY );
+    if ( !mXPropSet.is() )
+        return FALSE;
+
+    mXShapes = ::com::sun::star::uno::Reference<
+        ::com::sun::star::drawing::XShapes >
+            ( mXDrawPage, ::com::sun::star::uno::UNO_QUERY );
+    if ( !mXShapes.is() )
+        return FALSE;
+
+    EscherSolverContainer aSolverContainer;
+
+    mpPptEscherEx->PtReplaceOrInsert( EPP_Persist_MainNotes, mpStrm->Tell() );
+    mpPptEscherEx->OpenContainer( EPP_Notes );
+    mpPptEscherEx->AddAtom( 8, EPP_NotesAtom, 1 );
+    *mpStrm << (sal_uInt32)0x80000001                                               // Number that identifies this slide
+            << (sal_uInt32)0;                                                       // follow nothing
+    mpPptEscherEx->OpenContainer( EPP_PPDrawing );
+    mpPptEscherEx->OpenContainer( ESCHER_DgContainer );
+    mpPptEscherEx->EnterGroup(0,0);
+
+    ImplWritePage( pPHLayout[ 20 ], aSolverContainer, NOTICE, TRUE );
+
+    mpPptEscherEx->LeaveGroup();
+    mpPptEscherEx->OpenContainer( ESCHER_SpContainer );
+    mpPptEscherEx->AddShape( ESCHER_ShpInst_Rectangle, 0xc00 );
+    EscherPropertyContainer aPropOpt;
+    aPropOpt.AddOpt( ESCHER_Prop_fillColor, 0xffffff );								// stock valued fill color
+    aPropOpt.AddOpt( ESCHER_Prop_fillBackColor, 0 );
+    aPropOpt.AddOpt( ESCHER_Prop_fillRectRight, 0x68bdde );
+    aPropOpt.AddOpt( ESCHER_Prop_fillRectBottom, 0x8b9f8e );
+    aPropOpt.AddOpt( ESCHER_Prop_fNoFillHitTest, 0x120012 );
+    aPropOpt.AddOpt( ESCHER_Prop_fNoLineDrawDash, 0 );
+    aPropOpt.AddOpt( ESCHER_Prop_bWMode, ESCHER_wDontShow );
+    aPropOpt.AddOpt( ESCHER_Prop_fBackground, 0x10001 );							// if true, this is the background shape
+    aPropOpt.Commit( *mpStrm );
+    mpPptEscherEx->CloseContainer();    // ESCHER_SpContainer
+
+    aSolverContainer.WriteSolver( *mpStrm );
+
+    mpPptEscherEx->CloseContainer();    // ESCHER_DgContainer
+    mpPptEscherEx->CloseContainer();    // EPP_Drawing
+    mpPptEscherEx->AddAtom( 32, EPP_ColorSchemeAtom, 0, 1 );
+    *mpStrm << (sal_uInt32)0xffffff << (sal_uInt32)0x000000 << (sal_uInt32)0x808080 << (sal_uInt32)0x000000 << (sal_uInt32)0x99cc00 << (sal_uInt32)0xcc3333 << (sal_uInt32)0xffcccc << (sal_uInt32)0xb2b2b2;
+    mpPptEscherEx->CloseContainer();    // EPP_Notes
+    return TRUE;
+}
+
+// ---------------------------------------------------------------------------------------------
+
+sal_Bool PPTWriter::ImplCreateSlide( sal_uInt32 nPageNum )
+{
+    ::com::sun::star::uno::Any aAny;
+
+    if ( !ImplGetPageByIndex( nPageNum, NORMAL ) )
+        return FALSE;
+    sal_uInt32 nMasterID = ImplGetMasterIndex( NORMAL );
+	ImplSetCurrentStyleSheet( nMasterID );
+	nMasterID |= 0x80000000;
+
+    ::com::sun::star::uno::Reference< ::com::sun::star::beans::XPropertySet > aXBackgroundPropSet;
+    sal_Bool bHasBackground = GetPropertyValue( aAny, mXPagePropSet, String( RTL_CONSTASCII_USTRINGPARAM( "Background" ) ) );
+    if ( bHasBackground )
+        bHasBackground = ( aAny >>= aXBackgroundPropSet );
+
+	sal_uInt16 nMode = 7;   // Bit 1: Follow master objects, Bit 2: Follow master scheme, Bit 3: Follow master background
+	if ( bHasBackground )
+		nMode &=~4;
+
+/* sj: Don't know what's IsBackgroundVisible for, have to ask cl
+	if ( GetPropertyValue( aAny, mXPagePropSet, String( RTL_CONSTASCII_USTRINGPARAM( "IsBackgroundVisible" ) ) ) )
+	{
+		sal_Bool bBackgroundVisible;
+        if ( aAny >>= bBackgroundVisible )
+		{
+			if ( bBackgroundVisible )
+				nMode &= ~4;
+		}
+	}
+*/
+	if ( GetPropertyValue( aAny, mXPagePropSet, String( RTL_CONSTASCII_USTRINGPARAM( "IsBackgroundObjectsVisible" ) ) ) )
+	{
+		sal_Bool bBackgroundObjectsVisible = sal_False;
+        if ( aAny >>= bBackgroundObjectsVisible )
+		{
+			if ( !bBackgroundObjectsVisible )
+				nMode &= ~1;
+		}
+	}
+
+    const PHLayout& rLayout = ImplGetLayout( mXPagePropSet );
+    mpPptEscherEx->PtReplaceOrInsert( EPP_Persist_Slide | nPageNum, mpStrm->Tell() );
+    mpPptEscherEx->OpenContainer( EPP_Slide );
+    mpPptEscherEx->AddAtom( 24, EPP_SlideAtom, 2 );
+    *mpStrm << rLayout.nLayout;
+    mpStrm->Write( rLayout.nPlaceHolder, 8 );       // placeholderIDs ( 8Stueck )
+    *mpStrm << (sal_uInt32)nMasterID                // master ID ( ist gleich 0x80000000 bei einer masterpage   )
+            << (sal_uInt32)nPageNum + 0x100         // notes ID ( ist gleich null wenn keine notizen vorhanden )
+            << nMode
+            << (sal_uInt16)0;                       // padword
+
+    mnDiaMode = 0;
+    sal_Bool bVisible = sal_True;
+    ::com::sun::star::presentation::FadeEffect eFe = ::com::sun::star::presentation::FadeEffect_NONE;
+
+    if ( GetPropertyValue( aAny, mXPagePropSet, String( RTL_CONSTASCII_USTRINGPARAM( "Visible" ) ) ) )
+        aAny >>= bVisible;
+    if ( GetPropertyValue( aAny, mXPagePropSet, String( RTL_CONSTASCII_USTRINGPARAM( "Change" ) ) ) )
+    {
+        switch ( *(INT32*)aAny.getValue() )
+        {
+            case 1 :        // automatisch
+                mnDiaMode++;
+            case 2 :        // halbautomatisch
+                mnDiaMode++;
+            default :
+            case 0 :        // manuell
+            break;
+        }
+    }
+    if ( GetPropertyValue( aAny, mXPagePropSet, String( RTL_CONSTASCII_USTRINGPARAM( "Effect" ) ) ) )
+        aAny >>= eFe;
+
+    sal_uInt32  nSoundRef = 0;
+    sal_Bool    bIsSound = sal_False;
+	sal_Bool	bStopSound = sal_False;
+	sal_Bool	bLoopSound = sal_False;
+
+	if ( GetPropertyValue( aAny, mXPagePropSet, String( RTL_CONSTASCII_USTRINGPARAM( "Sound" ) ) ) )
+	{
+		rtl::OUString aSoundURL;
+		if ( aAny >>= aSoundURL )
+		{
+	        nSoundRef = maSoundCollection.GetId( aSoundURL );
+			bIsSound = sal_True;
+		}
+		else
+			aAny >>= bStopSound;
+	}
+	if ( GetPropertyValue( aAny, mXPagePropSet, String( RTL_CONSTASCII_USTRINGPARAM( "LoopSound" ) ) ) )
+		aAny >>= bLoopSound;
+
+
+    sal_Bool bNeedsSSSlideInfoAtom = ( bVisible == FALSE )
+                                    || ( mnDiaMode == 2 )
+                                    || ( bIsSound )
+									|| ( bStopSound )
+                                    || ( eFe != ::com::sun::star::presentation::FadeEffect_NONE );
+    if ( bNeedsSSSlideInfoAtom )
+    {
+        sal_uInt8   nDirection = 0;
+        sal_uInt8   nTransitionType = 0;
+        sal_uInt16  nBuildFlags = 1;        // advange by mouseclick
+        INT32       nSlideTime = 0;         // muss noch !!!
+        sal_uInt8   nSpeed = 1;
+
+        if ( GetPropertyValue( aAny, mXPagePropSet, String( RTL_CONSTASCII_USTRINGPARAM( "Speed" ) ) ) )
+        {
+            ::com::sun::star::presentation::AnimationSpeed aAs;
+            aAny >>= aAs;
+            nSpeed = (sal_uInt8)aAs;
+        }
+		sal_Int16 nTT = 0, nTST = 0;
+		if ( GetPropertyValue( aAny, mXPagePropSet, String( RTL_CONSTASCII_USTRINGPARAM( "TransitionType" ) ) )
+			&& ( aAny >>= nTT ) )
+		{
+			if ( GetPropertyValue( aAny, mXPagePropSet, String( RTL_CONSTASCII_USTRINGPARAM( "TransitionSubtype" ) ) )
+				&& ( aAny >>= nTST ) )
+			{
+				switch( nTT )
+				{
+					case animations::TransitionType::FADE :
+					{
+						if ( nTST == animations::TransitionSubType::CROSSFADE )
+							nTransitionType = PPT_TRANSITION_TYPE_SMOOTHFADE;
+						else if ( nTST == animations::TransitionSubType::FADEOVERCOLOR )
+							nTransitionType = PPT_TRANSITION_TYPE_FADE;
+					}
+					break;
+					case PPT_TRANSITION_TYPE_COMB :
+					{
+						nTransitionType = PPT_TRANSITION_TYPE_COMB;
+						if ( nTST == animations::TransitionSubType::COMBVERTICAL )
+							nDirection++;
+					}
+					break;
+					case animations::TransitionType::PUSHWIPE :
+					{
+						nTransitionType = PPT_TRANSITION_TYPE_PUSH;
+						switch( nTST )
+						{
+							case animations::TransitionSubType::FROMRIGHT: nDirection = 0; break;
+							case animations::TransitionSubType::FROMBOTTOM: nDirection = 1; break;
+							case animations::TransitionSubType::FROMLEFT: nDirection = 2; break;
+							case animations::TransitionSubType::FROMTOP: nDirection = 3; break;
+						}
+					}
+					break;
+					case animations::TransitionType::PINWHEELWIPE : 
+					{
+						nTransitionType = PPT_TRANSITION_TYPE_WHEEL;
+						switch( nTST )
+						{
+							case animations::TransitionSubType::ONEBLADE: nDirection = 1; break;
+							case animations::TransitionSubType::TWOBLADEVERTICAL : nDirection = 2; break;
+							case animations::TransitionSubType::THREEBLADE : nDirection = 3; break;
+							case animations::TransitionSubType::FOURBLADE: nDirection = 4; break;
+							case animations::TransitionSubType::EIGHTBLADE: nDirection = 8; break;
+						}
+					}
+					break;
+					case animations::TransitionType::FANWIPE :
+					{
+						nTransitionType = PPT_TRANSITION_TYPE_WEDGE;
+					}
+					break;
+					case animations::TransitionType::ELLIPSEWIPE :
+					{
+						nTransitionType = PPT_TRANSITION_TYPE_CIRCLE;
+					}
+					break;
+					case animations::TransitionType::FOURBOXWIPE :
+					{
+						nTransitionType = PPT_TRANSITION_TYPE_PLUS;
+					}
+					break;
+					case animations::TransitionType::IRISWIPE :
+					{
+						nTransitionType = PPT_TRANSITION_TYPE_DIAMOND;
+					}
+					break;
+				}
+			}
+		}
+		if ( !nTransitionType )
+		{
+			switch ( eFe )
+			{
+				default :
+				case ::com::sun::star::presentation::FadeEffect_RANDOM :
+					nTransitionType = PPT_TRANSITION_TYPE_RANDOM;
+				break;
+
+				case ::com::sun::star::presentation::FadeEffect_HORIZONTAL_STRIPES :
+					nDirection++;
+				case ::com::sun::star::presentation::FadeEffect_VERTICAL_STRIPES :
+					nTransitionType = PPT_TRANSITION_TYPE_BLINDS;
+				break;
+
+				case ::com::sun::star::presentation::FadeEffect_VERTICAL_CHECKERBOARD :
+					nDirection++;
+				case ::com::sun::star::presentation::FadeEffect_HORIZONTAL_CHECKERBOARD :
+					nTransitionType = PPT_TRANSITION_TYPE_CHECKER;
+				break;
+
+				case ::com::sun::star::presentation::FadeEffect_MOVE_FROM_UPPERLEFT :
+					nDirection++;
+				case ::com::sun::star::presentation::FadeEffect_MOVE_FROM_UPPERRIGHT :
+					nDirection++;
+				case ::com::sun::star::presentation::FadeEffect_MOVE_FROM_LOWERLEFT :
+					nDirection++;
+				case ::com::sun::star::presentation::FadeEffect_MOVE_FROM_LOWERRIGHT :
+					nDirection++;
+				case ::com::sun::star::presentation::FadeEffect_MOVE_FROM_TOP :
+					nDirection++;
+				case ::com::sun::star::presentation::FadeEffect_MOVE_FROM_LEFT :
+					nDirection++;
+				case ::com::sun::star::presentation::FadeEffect_MOVE_FROM_BOTTOM :
+					nDirection++;
+				case ::com::sun::star::presentation::FadeEffect_MOVE_FROM_RIGHT :
+					nTransitionType = PPT_TRANSITION_TYPE_COVER;
+				break;
+
+				case ::com::sun::star::presentation::FadeEffect_DISSOLVE :
+					nTransitionType = PPT_TRANSITION_TYPE_DISSOLVE;
+				break;
+
+				case ::com::sun::star::presentation::FadeEffect_VERTICAL_LINES :
+					nDirection++;
+				case ::com::sun::star::presentation::FadeEffect_HORIZONTAL_LINES :
+					nTransitionType = PPT_TRANSITION_TYPE_RANDOM_BARS;
+				break;
+
+				case ::com::sun::star::presentation::FadeEffect_CLOSE_HORIZONTAL :
+					nDirection++;
+				case ::com::sun::star::presentation::FadeEffect_OPEN_HORIZONTAL :
+					nDirection++;
+				case ::com::sun::star::presentation::FadeEffect_CLOSE_VERTICAL :
+					nDirection++;
+				case ::com::sun::star::presentation::FadeEffect_OPEN_VERTICAL :
+					nTransitionType = PPT_TRANSITION_TYPE_SPLIT;
+				break;
+
+				case ::com::sun::star::presentation::FadeEffect_FADE_FROM_UPPERLEFT :
+					nDirection++;
+				case ::com::sun::star::presentation::FadeEffect_FADE_FROM_UPPERRIGHT :
+					nDirection++;
+				case ::com::sun::star::presentation::FadeEffect_FADE_FROM_LOWERLEFT :
+					nDirection++;
+				case ::com::sun::star::presentation::FadeEffect_FADE_FROM_LOWERRIGHT :
+					nDirection += 4;
+					nTransitionType = PPT_TRANSITION_TYPE_STRIPS;
+				break;
+
+				case ::com::sun::star::presentation::FadeEffect_UNCOVER_TO_LOWERRIGHT :
+					nDirection++;
+				case ::com::sun::star::presentation::FadeEffect_UNCOVER_TO_LOWERLEFT :
+					nDirection++;
+				case ::com::sun::star::presentation::FadeEffect_UNCOVER_TO_UPPERRIGHT :
+					nDirection++;
+				case ::com::sun::star::presentation::FadeEffect_UNCOVER_TO_UPPERLEFT :
+					nDirection++;
+				case ::com::sun::star::presentation::FadeEffect_UNCOVER_TO_BOTTOM :
+					nDirection++;
+				case ::com::sun::star::presentation::FadeEffect_UNCOVER_TO_RIGHT :
+					nDirection++;
+				case ::com::sun::star::presentation::FadeEffect_UNCOVER_TO_TOP :
+					nDirection++;
+				case ::com::sun::star::presentation::FadeEffect_UNCOVER_TO_LEFT :
+					nTransitionType = PPT_TRANSITION_TYPE_PULL;
+				break;
+
+				case ::com::sun::star::presentation::FadeEffect_FADE_FROM_TOP :
+					nDirection++;
+				case ::com::sun::star::presentation::FadeEffect_FADE_FROM_LEFT :
+					nDirection++;
+				case ::com::sun::star::presentation::FadeEffect_FADE_FROM_BOTTOM :
+					nDirection++;
+				case ::com::sun::star::presentation::FadeEffect_FADE_FROM_RIGHT :
+					nTransitionType = PPT_TRANSITION_TYPE_WIPE;
+				break;
+
+				case ::com::sun::star::presentation::FadeEffect_ROLL_FROM_TOP :
+					nDirection++;
+				case ::com::sun::star::presentation::FadeEffect_ROLL_FROM_LEFT :
+					nDirection++;
+				case ::com::sun::star::presentation::FadeEffect_ROLL_FROM_BOTTOM :
+					nDirection++;
+				case ::com::sun::star::presentation::FadeEffect_ROLL_FROM_RIGHT :
+					nTransitionType = PPT_TRANSITION_TYPE_WIPE;
+				break;
+
+				case ::com::sun::star::presentation::FadeEffect_FADE_TO_CENTER :
+					nDirection++;
+				case ::com::sun::star::presentation::FadeEffect_FADE_FROM_CENTER :
+					nTransitionType = PPT_TRANSITION_TYPE_ZOOM;
+				break;
+
+				case ::com::sun::star::presentation::FadeEffect_NONE :
+					nDirection = 2;
+				break;
+			}
+		}
+        if ( mnDiaMode == 2 )                                   // automatic ?
+            nBuildFlags |= 0x400;
+        if ( bVisible == FALSE )
+            nBuildFlags |= 4;
+        if ( bIsSound )
+            nBuildFlags |= 16;
+		if ( bLoopSound )
+			nBuildFlags |= 64;
+		if ( bStopSound )
+			nBuildFlags |= 256;
+
+        if ( GetPropertyValue( aAny, mXPagePropSet, String( RTL_CONSTASCII_USTRINGPARAM( "Duration" ) ) ) )// duration of this slide
+            nSlideTime = *(INT32*)aAny.getValue() << 10;        // in ticks
+
+
+        mpPptEscherEx->AddAtom( 16, EPP_SSSlideInfoAtom );
+        *mpStrm << nSlideTime       // standtime in ticks
+                << nSoundRef
+                << nDirection
+                << nTransitionType
+                << nBuildFlags
+                << nSpeed
+                << (sal_uInt8)0 << (sal_uInt8)0 << (sal_uInt8)0;
+    }
+
+	ImplCreateHeaderFooters( mXPagePropSet );
+
+    EscherSolverContainer aSolverContainer;
+    mpPptEscherEx->OpenContainer( EPP_PPDrawing );
+    mpPptEscherEx->OpenContainer( ESCHER_DgContainer );
+    mpPptEscherEx->EnterGroup(0,0);
+    ImplWritePage( rLayout, aSolverContainer, NORMAL, FALSE, nPageNum );    // Die Shapes der Seite werden im PPT Dok. erzeugt
+    mpPptEscherEx->LeaveGroup();
+
+    if ( bHasBackground )
+        ImplWriteBackground( aXBackgroundPropSet );
+    else
+    {
+        mpPptEscherEx->OpenContainer( ESCHER_SpContainer );
+        mpPptEscherEx->AddShape( ESCHER_ShpInst_Rectangle, 0xc00 );             // Flags: Connector | Background | HasSpt
+        EscherPropertyContainer aPropOpt;
+		aPropOpt.AddOpt( ESCHER_Prop_fillRectRight, PPTtoEMU( maDestPageSize.Width ) );
+        aPropOpt.AddOpt( ESCHER_Prop_fillRectBottom, PPTtoEMU( maDestPageSize.Width ) );
+        aPropOpt.AddOpt( ESCHER_Prop_fNoFillHitTest, 0x120012 );
+        aPropOpt.AddOpt( ESCHER_Prop_fNoLineDrawDash, 0x80000 );
+        aPropOpt.AddOpt( ESCHER_Prop_bWMode, ESCHER_wDontShow );
+        aPropOpt.AddOpt( ESCHER_Prop_fBackground, 0x10001 );                // if true, this is the background shape
+        aPropOpt.Commit( *mpStrm );
+        mpPptEscherEx->CloseContainer();    // ESCHER_SpContainer
+    }
+
+    aSolverContainer.WriteSolver( *mpStrm );
+
+    mpPptEscherEx->CloseContainer();    // ESCHER_DgContainer
+    mpPptEscherEx->CloseContainer();    // EPP_Drawing
+    mpPptEscherEx->AddAtom( 32, EPP_ColorSchemeAtom, 0, 1 );
+    *mpStrm << (sal_uInt32)0xffffff << (sal_uInt32)0x000000 << (sal_uInt32)0x808080 << (sal_uInt32)0x000000 << (sal_uInt32)0x99cc00 << (sal_uInt32)0xcc3333 << (sal_uInt32)0xffcccc << (sal_uInt32)0xb2b2b2;
+	
+	if ( mbUseNewAnimations )
+	{
+		SvMemoryStream amsofbtAnimGroup;
+		ppt::AnimationExporter aExporter( aSolverContainer, maSoundCollection );
+		aExporter.doexport( mXDrawPage, amsofbtAnimGroup );
+		sal_uInt32 nmsofbtAnimGroupSize = amsofbtAnimGroup.Tell();
+		if ( nmsofbtAnimGroupSize )
+		{
+			EscherExContainer aProgTags		( *mpStrm, EPP_ProgTags );
+			EscherExContainer aProgBinaryTag( *mpStrm, EPP_ProgBinaryTag );
+			{
+				EscherExAtom aCString( *mpStrm, EPP_CString );
+				*mpStrm << (sal_uInt32)0x5f005f
+						<< (sal_uInt32)0x50005f
+						<< (sal_uInt32)0x540050
+						<< (sal_uInt16)0x31
+						<< (sal_uInt16)0x30;
+			}
+			{
+				EscherExAtom aBinaryTagData( *mpStrm, EPP_BinaryTagData );
+				{
+					{
+						EscherExAtom aMagic2( *mpStrm, 0x2eeb );
+						*mpStrm << (sal_uInt32)0x01c45df9
+								<< (sal_uInt32)0xe1471b30;
+					}
+					{
+						EscherExAtom aMagic( *mpStrm, 0x2b00 );
+						*mpStrm << (sal_uInt32)0;
+					}
+				}
+				mpStrm->Write( amsofbtAnimGroup.GetData(), amsofbtAnimGroup.Tell() );
+				{
+					EscherExContainer aMagic2( *mpStrm, 0x2b02 );
+				}
+			}
+		}
+    }
+	mpPptEscherEx->CloseContainer();    // EPP_Slide
+    return TRUE;
+};
+
+// ---------------------------------------------------------------------------------------------
+
+sal_Bool PPTWriter::ImplCreateNotes( sal_uInt32 nPageNum )
+{
+    if ( !ImplGetPageByIndex( nPageNum, NOTICE ) )
+        return FALSE;
+	ImplSetCurrentStyleSheet( ImplGetMasterIndex( NORMAL ) );
+
+
+    mpPptEscherEx->PtReplaceOrInsert( EPP_Persist_Notes | nPageNum, mpStrm->Tell() );
+    mpPptEscherEx->OpenContainer( EPP_Notes );
+    mpPptEscherEx->AddAtom( 8, EPP_NotesAtom, 1 );
+    *mpStrm << (sal_uInt32)nPageNum + 0x100
+            << (sal_uInt16)3                                        // follow master ....
+            << (sal_uInt16)0;
+
+	ImplCreateHeaderFooters( mXPagePropSet );
+
+    EscherSolverContainer aSolverContainer;
+
+    mpPptEscherEx->OpenContainer( EPP_PPDrawing );
+    mpPptEscherEx->OpenContainer( ESCHER_DgContainer );
+    mpPptEscherEx->EnterGroup(0,0);
+
+    ImplWritePage( pPHLayout[ 20 ], aSolverContainer, NOTICE, FALSE );  // Die Shapes der Seite werden im PPT Dok. erzeugt
+
+    mpPptEscherEx->LeaveGroup();
+    mpPptEscherEx->OpenContainer( ESCHER_SpContainer );
+    mpPptEscherEx->AddShape( ESCHER_ShpInst_Rectangle, 0xc00 ); // Flags: Connector | Background | HasSpt
+    EscherPropertyContainer aPropOpt;
+    aPropOpt.AddOpt( ESCHER_Prop_fillColor, 0xffffff );     // stock valued fill color
+    aPropOpt.AddOpt( ESCHER_Prop_fillBackColor, 0 );
+    aPropOpt.AddOpt( ESCHER_Prop_fillRectRight, 0x8b9f8e );
+    aPropOpt.AddOpt( ESCHER_Prop_fillRectBottom, 0x68bdde );
+    aPropOpt.AddOpt( ESCHER_Prop_fNoFillHitTest, 0x120012 );
+    aPropOpt.AddOpt( ESCHER_Prop_fNoLineDrawDash, 0x80000 );
+    aPropOpt.AddOpt( ESCHER_Prop_bWMode, ESCHER_wDontShow );
+    aPropOpt.AddOpt( ESCHER_Prop_fBackground, 0x10001 );
+    aPropOpt.Commit( *mpStrm );
+    mpPptEscherEx->CloseContainer();    // ESCHER_SpContainer
+
+    aSolverContainer.WriteSolver( *mpStrm );
+
+    mpPptEscherEx->CloseContainer();    // ESCHER_DgContainer
+    mpPptEscherEx->CloseContainer();    // EPP_Drawing
+    mpPptEscherEx->AddAtom( 32, EPP_ColorSchemeAtom, 0, 1 );
+    *mpStrm << (sal_uInt32)0xffffff << (sal_uInt32)0x000000 << (sal_uInt32)0x808080 << (sal_uInt32)0x000000 << (sal_uInt32)0x99cc00 << (sal_uInt32)0xcc3333 << (sal_uInt32)0xffcccc << (sal_uInt32)0xb2b2b2;
+    mpPptEscherEx->CloseContainer();    // EPP_Notes
+    return TRUE;
+};
+
+void PPTWriter::ImplWriteBackground( ::com::sun::star::uno::Reference< ::com::sun::star::beans::XPropertySet > & rXPropSet )
+{
+    //************************ ******
+    //** DEFAULT BACKGROUND SHAPE **
+    //******************************
+
+    sal_uInt32 nFillColor = 0xffffff;
+    sal_uInt32 nFillBackColor = 0;
+
+    mpPptEscherEx->OpenContainer( ESCHER_SpContainer );
+    mpPptEscherEx->AddShape( ESCHER_ShpInst_Rectangle, 0xc00 );                     // Flags: Connector | Background | HasSpt
+    Point aEmptyPoint = Point();
+    Rectangle aRect( aEmptyPoint, Size( 28000, 21000 ) );
+    EscherPropertyContainer aPropOpt( (EscherGraphicProvider&)*mpPptEscherEx, mpPicStrm, aRect );
+    aPropOpt.AddOpt( ESCHER_Prop_fillType, ESCHER_FillSolid );
+    ::com::sun::star::drawing::FillStyle aFS( ::com::sun::star::drawing::FillStyle_NONE );
+    if ( ImplGetPropertyValue( rXPropSet, String( RTL_CONSTASCII_USTRINGPARAM( "FillStyle" ) ) ) )
+        mAny >>= aFS;
+
+    switch( aFS )
+    {
+        case ::com::sun::star::drawing::FillStyle_GRADIENT :
+        {
+            aPropOpt.CreateGradientProperties( rXPropSet );
+            aPropOpt.AddOpt( ESCHER_Prop_fNoFillHitTest, 0x1f001e );
+            aPropOpt.GetOpt( ESCHER_Prop_fillColor, nFillColor );
+            aPropOpt.GetOpt( ESCHER_Prop_fillBackColor, nFillBackColor );
+        }
+        break;
+
+        case ::com::sun::star::drawing::FillStyle_BITMAP :
+            aPropOpt.CreateGraphicProperties( rXPropSet, String( RTL_CONSTASCII_USTRINGPARAM( "FillBitmapURL" ) ), sal_True );
+        break;
+
+        case ::com::sun::star::drawing::FillStyle_HATCH :
+			aPropOpt.CreateGraphicProperties( rXPropSet, String( RTL_CONSTASCII_USTRINGPARAM( "FillHatch" ) ), sal_True );
+        break;
+
+        case ::com::sun::star::drawing::FillStyle_SOLID :
+        {
+            if ( ImplGetPropertyValue( rXPropSet, String( RTL_CONSTASCII_USTRINGPARAM( "FillColor" ) ) ) )
+            {
+                nFillColor = mpPptEscherEx->GetColor( *((sal_uInt32*)mAny.getValue()) );
+                nFillBackColor = nFillColor ^ 0xffffff;
+            }
+        }	// PASSTHROUGH INTENDED
+        case ::com::sun::star::drawing::FillStyle_NONE :
+        default:
+            aPropOpt.AddOpt( ESCHER_Prop_fNoFillHitTest, 0x120012 );
+        break;
+    }
+    aPropOpt.AddOpt( ESCHER_Prop_fillColor, nFillColor );
+    aPropOpt.AddOpt( ESCHER_Prop_fillBackColor, nFillBackColor );
+    aPropOpt.AddOpt( ESCHER_Prop_fillRectRight, PPTtoEMU( maDestPageSize.Width ) );
+    aPropOpt.AddOpt( ESCHER_Prop_fillRectBottom, PPTtoEMU( maDestPageSize.Height ) );
+    aPropOpt.AddOpt( ESCHER_Prop_fNoLineDrawDash, 0x80000 );
+    aPropOpt.AddOpt( ESCHER_Prop_bWMode, ESCHER_bwWhite );
+    aPropOpt.AddOpt( ESCHER_Prop_fBackground, 0x10001 );
+    aPropOpt.Commit( *mpStrm );
+    mpPptEscherEx->CloseContainer();    // ESCHER_SpContainer
+}
+
+void PPTWriter::ImplWriteCString( SvStream& rSt, const String& rString, sal_uInt32 nInstance )
+{
+    sal_uInt32 i, nLen = rString.Len();
+    if ( nLen )
+    {
+        rSt << (sal_uInt32)( ( nInstance << 4 ) | ( EPP_CString << 16 ) )
+            << (sal_uInt32)( nLen << 1 );
+        for ( i = 0; i < nLen; i++ )
+            rSt << rString.GetChar( (sal_uInt16)i );
+    }
+}
+
+void PPTWriter::ImplWriteVBA( SvMemoryStream* pVBA )
+{
+    if ( pVBA )
+    {
+        pVBA->Seek( STREAM_SEEK_TO_END );
+        sal_uInt32 nLen = pVBA->Tell();
+        if ( nLen > 8 )
+        {
+            nLen -= 8;
+            mnVBAOleOfs = mpStrm->Tell();
+            mpPptEscherEx->BeginAtom();
+            mpStrm->Write( (sal_Int8*)pVBA->GetData() + 8, nLen );
+            mpPptEscherEx->EndAtom( EPP_ExOleObjStg, 0, 1 );
+        }
+    }
+}
+
+// ---------------------------------------------------------------------------------------------
+
+void PPTWriter::ImplWriteOLE( sal_uInt32 nCnvrtFlags )
+{
+    PPTExOleObjEntry* pPtr;
+
+    SvxMSExportOLEObjects aOleExport( nCnvrtFlags );
+
+    for ( pPtr = (PPTExOleObjEntry*)maExOleObj.First(); pPtr;
+        pPtr = (PPTExOleObjEntry*)maExOleObj.Next() )
+    {
+        SvMemoryStream* pStrm = NULL;
+        pPtr->nOfsB = mpStrm->Tell();
+        switch ( pPtr->eType )
+        {
+            case NORMAL_OLE_OBJECT :
+            {
+				SdrObject* pSdrObj = GetSdrObjectFromXShape( pPtr->xShape );
+				if ( pSdrObj && pSdrObj->ISA( SdrOle2Obj ) )
+				{
+                    ::uno::Reference < embed::XEmbeddedObject > xObj( ( (SdrOle2Obj*) pSdrObj )->GetObjRef() );
+                    if( xObj.is() )
+					{
+						SvStorageRef xTempStorage( new SvStorage( new SvMemoryStream(), TRUE ) );
+                        aOleExport.ExportOLEObject( xObj, *xTempStorage );
+
+                        //TODO/MBA: testing
+                        String aPersistStream( String::CreateFromAscii( RTL_CONSTASCII_STRINGPARAM( SVEXT_PERSIST_STREAM ) ) );
+                        SvMemoryStream aStream;
+                        SvStorageRef xCleanStorage( new SvStorage( FALSE, aStream ) );
+						xTempStorage->CopyTo( xCleanStorage );
+						// SJ: #99809# create a dummy content stream, the dummy content is necessary for ppt, but not for
+						// doc files, so we can't share code.
+						SotStorageStreamRef xStm = xCleanStorage->OpenSotStream( aPersistStream, STREAM_STD_READWRITE );
+						*xStm	<< (sal_uInt32)0		// no ClipboardId
+								<< (sal_uInt32)4		// no target device
+								<< (sal_uInt32)1		// aspect ratio
+								<< (sal_Int32)-1		// L-Index
+								<< (sal_uInt32)0		// Advanced Flags
+								<< (sal_uInt32)0		// compression
+								<< (sal_uInt32)0		// Size
+								<< (sal_uInt32)0		//  "
+								<< (sal_uInt32)0;
+						pStrm = xCleanStorage->CreateMemoryStream();
+                    }
+                }
+            }
+            break;
+
+            case OCX_CONTROL :
+            {
+                if ( pPtr->xControlModel.is() )
+                {
+                    String aName;
+                    ::com::sun::star::awt::Size aSize;
+                    SvStorageRef xDest( new SvStorage( new SvMemoryStream(), TRUE ) );
+                    sal_Bool bOk = SvxMSConvertOCXControls::WriteOCXStream( xDest, pPtr->xControlModel, aSize, aName );
+                    if ( bOk )
+                        pStrm = xDest->CreateMemoryStream();
+                }
+            }
+        }
+        if ( pStrm )
+        {
+            mpPptEscherEx->BeginAtom();
+            pStrm->Seek( STREAM_SEEK_TO_END );
+			sal_uInt32 npStrmSize = pStrm->Tell();
+            *mpStrm << npStrmSize;					// uncompressed size
+
+#ifdef DBG_EXTRACTOLEOBJECTS
+			SvFileStream aOut( String::CreateFromAscii( "D:\\OUT.OLE" ), STREAM_TRUNC | STREAM_WRITE );
+			pStrm->Seek( 0 );
+			aOut.Write( pStrm->GetData(), npStrmSize );
+#endif
+
+            pStrm->Seek( 0 );
+            ZCodec aZCodec( 0x8000, 0x8000 );
+            aZCodec.BeginCompression();
+            aZCodec.Compress( *pStrm, *mpStrm );
+            aZCodec.EndCompression();
+            delete pStrm;
+            mpPptEscherEx->EndAtom( EPP_ExOleObjStg, 0, 1 );
+        }
+    }
+}
+
+// ---------------------------------------------------------------------------------------------
+// PersistantTable und UserEditAtom schreiben
+
+sal_Bool PPTWriter::ImplWriteAtomEnding()
+{
+
+#define EPP_LastViewTypeNone        0
+#define EPP_LastViewTypeSlideView   1
+#define EPP_LastViewTypeOutlineView 2
+#define EPP_LastViewTypeNotes       3
+
+
+    sal_uInt32  i, nPos, nOfs, nPersistOfs = mpStrm->Tell();
+    sal_uInt32  nPersistEntrys = 0;
+    *mpStrm << (sal_uInt32)0 << (sal_uInt32)0 << (sal_uInt32)0;         // Record Header und ersten Eintrag ueberspringen
+
+    // Document pesist schreiben
+        nPersistEntrys++;
+        *mpStrm << (sal_uInt32)0;
+    // MasterPages persists schreiben
+    for ( i = 0; i < mnMasterPages; i++ )
+    {
+        nOfs = mpPptEscherEx->PtGetOffsetByID( EPP_Persist_MainMaster | i );
+        if ( nOfs )
+        {
+            *mpStrm << nOfs;
+            mpPptEscherEx->InsertAtPersistOffset( EPP_MAINMASTER_PERSIST_KEY | i, ++nPersistEntrys );
+        }
+    }
+    // MainNotesMaster persist schreiben
+    nOfs = mpPptEscherEx->PtGetOffsetByID( EPP_Persist_MainNotes );
+    if ( nOfs )
+    {
+        *mpStrm << nOfs;
+        mpPptEscherEx->InsertAtPersistOffset( EPP_MAINNOTESMASTER_PERSIST_KEY, ++nPersistEntrys );
+    }
+    // Slide persists schreiben -> es gilt hier auch den EPP_SlidePersistAtome mit einem gueltigen wert zu beschreiben
+    for ( i = 0; i < mnPages; i++ )
+    {
+        nOfs = mpPptEscherEx->PtGetOffsetByID( EPP_Persist_Slide | i );
+        if ( nOfs )
+        {
+            *mpStrm << nOfs;
+            mpPptEscherEx->InsertAtPersistOffset( EPP_MAINSLIDE_PERSIST_KEY | i, ++nPersistEntrys );
+        }
+    }
+    // Notes persists schreiben
+    for ( i = 0; i < mnPages; i++ )
+    {
+        nOfs = mpPptEscherEx->PtGetOffsetByID( EPP_Persist_Notes | i );
+        if ( nOfs )
+        {
+            *mpStrm << nOfs;
+            mpPptEscherEx->InsertAtPersistOffset( EPP_MAINNOTES_PERSIST_KEY | i, ++nPersistEntrys );
+        }
+    }
+    // Ole persists
+    PPTExOleObjEntry* pPtr;
+    for ( pPtr = (PPTExOleObjEntry*)maExOleObj.First(); pPtr; pPtr = (PPTExOleObjEntry*)maExOleObj.Next() )
+    {
+        nOfs = mpPptEscherEx->PtGetOffsetByID( EPP_Persist_ExObj );
+        if ( nOfs )
+        {
+            nPersistEntrys++;
+            *mpStrm << pPtr->nOfsB;
+            sal_uInt32 nOldPos, nPersOfs = nOfs + pPtr->nOfsA + 16 + 8;     // 8 bytes atom header, +16 to the persist entry
+            nOldPos = mpStrm->Tell();
+            mpStrm->Seek( nPersOfs );
+            *mpStrm << nPersistEntrys;
+            mpStrm->Seek( nOldPos );
+        }
+    }
+    // VB persist
+    if ( mnVBAOleOfs && mpVBA )
+    {
+        nOfs = mpPptEscherEx->PtGetOffsetByID( EPP_Persist_VBAInfoAtom );
+        if ( nOfs )
+        {
+            nPersistEntrys++;
+            sal_uInt32 n1, n2;
+
+            mpVBA->Seek( 0 );
+            *mpVBA >> n1
+                   >> n2;
+
+            *mpStrm << mnVBAOleOfs;
+            sal_uInt32 nOldPos = mpStrm->Tell();
+            mpStrm->Seek( nOfs );               // Fill the VBAInfoAtom with the correct index to the persisttable
+            *mpStrm << nPersistEntrys
+                    << n1
+                    << 2;
+            mpStrm->Seek( nOldPos );
+
+        }
+    }
+    nPos = mpStrm->Tell();
+    mpStrm->Seek( nPersistOfs );
+    mpPptEscherEx->AddAtom( ( nPersistEntrys + 1 ) << 2, EPP_PersistPtrIncrementalBlock );      // Record Header eintragen
+    *mpStrm << (sal_uInt32)( ( nPersistEntrys << 20 ) | 1 );
+    mpStrm->Seek( nPos );
+
+    *mpCurUserStrm << (sal_uInt32)nPos;             // offset to current edit setzen
+    mpPptEscherEx->AddAtom( 28, EPP_UserEditAtom );
+    *mpStrm << (INT32)0x100                     // last slide ID
+            << (sal_uInt32)0x03000dbc               // minor and major app version that did the save
+            << (sal_uInt32)0                        // offset last save, 0 after a full save
+            << nPersistOfs                      // File offset to persist pointers for this save operation
+            << (sal_uInt32)1                        // Persist reference to the document persist object
+            << (sal_uInt32)nPersistEntrys           // max persists written, Seed value for persist object id management
+            << (sal_Int16)EPP_LastViewTypeSlideView // last view type
+            << (sal_Int16)0x12;                     // padword
+
+    return TRUE;
+}
+
+// ---------------------------------------------------------------------------------------------
+
+PPTExCharSheet::PPTExCharSheet( int nInstance )
+{
+    sal_uInt16 nFontHeight = 24;
+
+    for ( int nDepth = 0; nDepth < 5; nDepth++ )
+    {
+        PPTExCharLevel& rLev = maCharLevel[ nDepth ];
+        switch ( nInstance )
+        {
+            case EPP_TEXTTYPE_Title :
+            case EPP_TEXTTYPE_CenterTitle :
+                nFontHeight = 44;
+            break;
+            case EPP_TEXTTYPE_Body :
+            case EPP_TEXTTYPE_CenterBody :
+            case EPP_TEXTTYPE_HalfBody :
+            case EPP_TEXTTYPE_QuarterBody :
+            {
+                switch ( nDepth )
+                {
+                    case 0 : nFontHeight = 32; break;
+                    case 1 : nFontHeight = 28; break;
+                    case 2 : nFontHeight = 24; break;
+                    default :nFontHeight = 20; break;
+                }
+            }
+            break;
+            case EPP_TEXTTYPE_Notes :
+                nFontHeight = 12;
+            break;
+            case EPP_TEXTTYPE_notUsed :
+            case EPP_TEXTTYPE_Other :
+                nFontHeight = 24;
+            break;
+        }
+        rLev.mnFlags = 0;
+        rLev.mnFont = 0;
+        rLev.mnAsianOrComplexFont = 0xffff;
+        rLev.mnFontHeight = nFontHeight;
+        rLev.mnFontColor = 0;
+        rLev.mnEscapement = 0;
+    }
+}
+
+
+void PPTExCharSheet::SetStyleSheet( const ::com::sun::star::uno::Reference< ::com::sun::star::beans::XPropertySet > & rXPropSet,
+                                    FontCollection& rFontCollection, int nLevel )
+{
+    PortionObj  aPortionObj( rXPropSet, rFontCollection );
+
+    PPTExCharLevel& rLev = maCharLevel[ nLevel ];
+
+    if ( aPortionObj.meCharColor == ::com::sun::star::beans::PropertyState_DIRECT_VALUE )
+        rLev.mnFontColor = aPortionObj.mnCharColor;
+    if ( aPortionObj.meCharEscapement == ::com::sun::star::beans::PropertyState_DIRECT_VALUE )
+        rLev.mnEscapement = aPortionObj.mnCharEscapement;
+    if ( aPortionObj.meCharHeight == ::com::sun::star::beans::PropertyState_DIRECT_VALUE )
+        rLev.mnFontHeight = aPortionObj.mnCharHeight;
+    if ( aPortionObj.meFontName == ::com::sun::star::beans::PropertyState_DIRECT_VALUE )
+        rLev.mnFont = aPortionObj.mnFont;
+    if ( aPortionObj.meAsianOrComplexFont == ::com::sun::star::beans::PropertyState_DIRECT_VALUE )
+        rLev.mnAsianOrComplexFont = aPortionObj.mnAsianOrComplexFont;
+    rLev.mnFlags = aPortionObj.mnCharAttr;
+}
+
+void PPTExCharSheet::Write( SvStream& rSt, PptEscherEx*, sal_uInt16 nLev, sal_Bool, sal_Bool bSimpleText,
+    const ::com::sun::star::uno::Reference< ::com::sun::star::beans::XPropertySet > & rPagePropSet )
+{
+    const PPTExCharLevel& rLev = maCharLevel[ nLev ];
+
+    sal_uInt32 nCharFlags = 0xefffff;
+    if ( bSimpleText )
+        nCharFlags = 0x7ffff;
+
+    rSt << nCharFlags
+        << rLev.mnFlags
+        << rLev.mnFont;
+
+    sal_uInt32 nFontColor = rLev.mnFontColor;
+    if ( nFontColor == COL_AUTO )
+    {
+        sal_Bool bIsDark = sal_False;
+        ::com::sun::star::uno::Any aAny;
+        if ( PropValue::GetPropertyValue( aAny, rPagePropSet, String( RTL_CONSTASCII_USTRINGPARAM( "IsBackgroundDark" ) ), sal_True ) )
+            aAny >>= bIsDark;
+        nFontColor = bIsDark ? 0xffffff : 0x000000;
+    }
+    nFontColor &= 0xffffff;
+    nFontColor |= 0xfe000000;
+    if ( bSimpleText )
+    {
+        rSt << rLev.mnFontHeight
+            << nFontColor;
+    }
+    else
+    {
+        rSt << rLev.mnAsianOrComplexFont
+            << (sal_uInt16)0xffff       // unbekannt
+            << (sal_uInt16)0xffff       // unbekannt
+            << rLev.mnFontHeight
+            << nFontColor
+            << rLev.mnEscapement;
+    }
+}
+
+PPTExParaSheet::PPTExParaSheet( int nInstance, sal_uInt16 nDefaultTab, PPTExBulletProvider& rProv ) :
+    rBuProv     ( rProv ),
+    mnInstance  ( nInstance )
+{
+    sal_Bool bHasBullet = FALSE;
+
+    sal_uInt16 nUpperDist = 0;
+    sal_uInt16 nBulletChar = 0x2022;
+    sal_uInt16 nBulletOfs = 0;
+    sal_uInt16 nTextOfs = 0;
+
+    for ( int nDepth = 0; nDepth < 5; nDepth++ )
+    {
+        PPTExParaLevel& rLev = maParaLevel[ nDepth ];
+        switch ( nInstance )
+        {
+            case EPP_TEXTTYPE_Title :
+            case EPP_TEXTTYPE_CenterTitle :
+            break;
+            case EPP_TEXTTYPE_Body :
+            case EPP_TEXTTYPE_CenterBody :
+            case EPP_TEXTTYPE_HalfBody :
+            case EPP_TEXTTYPE_QuarterBody :
+            {
+                bHasBullet = TRUE;
+                nUpperDist = 0x14;
+            }
+            break;
+            case EPP_TEXTTYPE_Notes :
+                nUpperDist = 0x1e;
+            break;
+
+//          default :
+//          case EPP_TEXTTYPE_notUsed :
+//          case EPP_TEXTTYPE_Other :
+//          break;
+        }
+        switch ( nDepth )
+        {
+            case 0 :
+            {
+                nBulletChar = 0x2022;
+                nBulletOfs = 0;
+                nTextOfs = ( bHasBullet ) ? 0xd8 : 0;
+            }
+            break;
+            case 1 :
+            {
+                nBulletChar = 0x2013;
+                nBulletOfs = 0x120;
+                nTextOfs = 0x1d4;
+            }
+            break;
+            case 2 :
+            {
+                nBulletChar = 0x2022;
+                nBulletOfs = 0x240;
+                nTextOfs = 0x2d0;
+            }
+            break;
+            case 3 :
+            {
+                nBulletChar = 0x2013;
+                nBulletOfs = 0x360;
+                nTextOfs = 0x3f0;
+            }
+            break;
+            case 4 :
+            {
+                nBulletChar = 0xbb;
+                nBulletOfs = 0x480;
+                nTextOfs = 0x510;
+            }
+            break;
+        }
+        rLev.mbIsBullet = bHasBullet;
+        rLev.mnBulletChar = nBulletChar;
+        rLev.mnBulletFont = 0;
+        rLev.mnBulletHeight = 100;
+        rLev.mnBulletColor = 0;
+        rLev.mnAdjust = 0;
+        rLev.mnLineFeed = 100;
+        rLev.mnLowerDist = 0;
+        rLev.mnUpperDist = nUpperDist;
+        rLev.mnTextOfs = nTextOfs;
+        rLev.mnBulletOfs = nBulletOfs;
+        rLev.mnDefaultTab = nDefaultTab;
+        rLev.mnAsianSettings = 2;
+		rLev.mnBiDi = 0;
+
+        rLev.mbExtendedBulletsUsed = FALSE;
+        rLev.mnBulletId = 0xffff;
+        rLev.mnBulletStart = 0;
+        rLev.mnMappedNumType = 0;
+        rLev.mnNumberingType = 0;
+    }
+}
+
+void PPTExParaSheet::SetStyleSheet( const ::com::sun::star::uno::Reference< ::com::sun::star::beans::XPropertySet > & rXPropSet,
+                                        FontCollection& rFontCollection, int nLevel, const PPTExCharLevel& rCharLevel )
+{
+    ParagraphObj aParagraphObj( rXPropSet, rBuProv );
+    aParagraphObj.CalculateGraphicBulletSize( rCharLevel.mnFontHeight );
+    PPTExParaLevel& rLev = maParaLevel[ nLevel ];
+
+    if ( aParagraphObj.meTextAdjust == ::com::sun::star::beans::PropertyState_DIRECT_VALUE )
+        rLev.mnAdjust = aParagraphObj.mnTextAdjust;
+    if ( aParagraphObj.meLineSpacing == ::com::sun::star::beans::PropertyState_DIRECT_VALUE )
+    {
+        sal_Int16 nLineSpacing = aParagraphObj.mnLineSpacing;
+        if ( nLineSpacing > 0 ) // if nLinespacing is < 0 the linespacing is an absolute spacing
+        {
+			sal_Bool bFixedLineSpacing = sal_False;
+			uno::Any aAny = rXPropSet->getPropertyValue( ::rtl::OUString( 
+															 RTL_CONSTASCII_USTRINGPARAM( 
+																 "FontIndependentLineSpacing" ) ) );
+			if( !(aAny >>= bFixedLineSpacing) || !bFixedLineSpacing ) 
+			{
+				const FontCollectionEntry* pDesc = rFontCollection.GetById( rCharLevel.mnFont );
+				if ( pDesc )
+					nLineSpacing = (sal_Int16)( (double)nLineSpacing * pDesc->Scaling + 0.5 );
+			}
+        }
+        else
+        {
+            if ( rCharLevel.mnFontHeight > (sal_uInt16)( ((double)-nLineSpacing) * 0.001 * 72.0 / 2.54 ) ) // 1/100mm to point
+            {
+                const FontCollectionEntry* pDesc = rFontCollection.GetById( rCharLevel.mnFont );
+                if ( pDesc )
+                     nLineSpacing = (sal_Int16)( (double)100.0 * pDesc->Scaling + 0.5 );
+                else
+                    nLineSpacing = 100;
+            }
+            else
+                nLineSpacing = (sal_Int16)( (double)nLineSpacing / 4.40972 );
+        }
+        rLev.mnLineFeed = nLineSpacing;
+    }
+    if ( aParagraphObj.meLineSpacingBottom == ::com::sun::star::beans::PropertyState_DIRECT_VALUE )
+        rLev.mnLowerDist = aParagraphObj.mnLineSpacingBottom;
+    if ( aParagraphObj.meLineSpacingTop == ::com::sun::star::beans::PropertyState_DIRECT_VALUE )
+        rLev.mnUpperDist = aParagraphObj.mnLineSpacingTop;
+    if ( aParagraphObj.meForbiddenRules == ::com::sun::star::beans::PropertyState_DIRECT_VALUE )
+    {
+        rLev.mnAsianSettings &=~1;
+        if ( aParagraphObj.mbForbiddenRules )
+            rLev.mnAsianSettings |= 1;
+    }
+    if ( aParagraphObj.meParagraphPunctation == ::com::sun::star::beans::PropertyState_DIRECT_VALUE )
+    {
+        rLev.mnAsianSettings &=~4;
+        if ( aParagraphObj.mbParagraphPunctation )
+            rLev.mnAsianSettings |= 4;
+    }
+
+	if ( aParagraphObj.meBiDi == ::com::sun::star::beans::PropertyState_DIRECT_VALUE )
+		rLev.mnBiDi = aParagraphObj.mnBiDi;
+
+	rLev.mbIsBullet = aParagraphObj.mbIsBullet; //( ( aParagraphObj.nBulletFlags & 1 ) != 0 );
+
+    if ( !nLevel )
+    {
+        if ( ( aParagraphObj.meBullet ==  ::com::sun::star::beans::PropertyState_DIRECT_VALUE )
+                    && aParagraphObj.bExtendedParameters )
+        {
+            for ( sal_Int16 i = 0; i < 5; i++ )
+            {
+                PPTExParaLevel& rLevel = maParaLevel[ i ];
+                if ( i )
+                    aParagraphObj.ImplGetNumberingLevel( rBuProv, i, FALSE );
+//              rLevel.mbIsBullet = ( ( aParagraphObj.nBulletFlags & 1 ) != 0 );
+                rLevel.mnTextOfs = aParagraphObj.nTextOfs;
+                rLevel.mnBulletOfs = (sal_uInt16)aParagraphObj.nBulletOfs;
+                rLevel.mnBulletChar = aParagraphObj.cBulletId;
+                FontCollectionEntry aFontDescEntry( aParagraphObj.aFontDesc.Name, aParagraphObj.aFontDesc.Family,
+                                                        aParagraphObj.aFontDesc.Pitch, aParagraphObj.aFontDesc.CharSet );
+                rLevel.mnBulletFont = (sal_uInt16)rFontCollection.GetId( aFontDescEntry );
+                rLevel.mnBulletHeight = aParagraphObj.nBulletRealSize;
+                rLevel.mnBulletColor = aParagraphObj.nBulletColor;
+
+                rLevel.mbExtendedBulletsUsed = aParagraphObj.bExtendedBulletsUsed;
+                rLevel.mnBulletId = aParagraphObj.nBulletId;
+                rLevel.mnNumberingType = aParagraphObj.nNumberingType;
+                rLevel.mnBulletStart = aParagraphObj.nStartWith;
+                rLevel.mnMappedNumType = aParagraphObj.nMappedNumType;
+			}
+        }
+    }
+}
+
+void PPTExParaSheet::Write( SvStream& rSt, PptEscherEx*, sal_uInt16 nLev, sal_Bool, sal_Bool bSimpleText,
+    const ::com::sun::star::uno::Reference< ::com::sun::star::beans::XPropertySet > & rPagePropSet )
+{
+    const PPTExParaLevel& rLev = maParaLevel[ nLev ];
+
+    if ( maParaLevel[ 0 ].mbExtendedBulletsUsed || maParaLevel[ 1 ].mbExtendedBulletsUsed ||
+            maParaLevel[ 2 ].mbExtendedBulletsUsed || maParaLevel[ 3 ].mbExtendedBulletsUsed ||
+                maParaLevel[ 4 ].mbExtendedBulletsUsed )
+    {
+        SvStream& rOut = rBuProv.aBuExMasterStream;
+        if ( !nLev )
+        {
+            rOut << (sal_uInt32)( ( EPP_PST_ExtendedParagraphMasterAtom << 16 ) | ( mnInstance << 4 ) )
+                 << (sal_uInt32)( 5 * 16 + 2 )
+                 << (sal_uInt16)5;              // depth
+        }
+        sal_uInt16 nBulletId = rLev.mnBulletId;
+        if ( rLev.mnNumberingType != SVX_NUM_BITMAP )
+            nBulletId = 0xffff;
+        rOut << (sal_uInt32)0x03800000
+             << (sal_uInt16)nBulletId
+             << (sal_uInt32)rLev.mnMappedNumType
+             << (sal_uInt16)rLev.mnBulletStart
+             << (sal_uInt32)0;
+    }
+
+    sal_uInt32 nParaFlags = 0x3ffdff;
+    sal_uInt16 nBulletFlags = ( rLev.mbIsBullet ) ? 0xf : 0xe;
+
+    if ( nLev )
+		nParaFlags &= 0x207fff;
+	if ( bSimpleText )
+		nParaFlags &= 0x7fff;
+    sal_uInt32 nBulletColor = rLev.mnBulletColor;
+    if ( nBulletColor == COL_AUTO )
+    {
+        sal_Bool bIsDark = sal_False;
+        ::com::sun::star::uno::Any aAny;
+        if ( PropValue::GetPropertyValue( aAny, rPagePropSet, String( RTL_CONSTASCII_USTRINGPARAM( "IsBackgroundDark" ) ), sal_True ) )
+            aAny >>= bIsDark;
+        nBulletColor = bIsDark ? 0xffffff : 0x000000;
+    }
+    nBulletColor &= 0xffffff;
+    nBulletColor |= 0xfe000000;
+    rSt << nParaFlags
+        << nBulletFlags
+        << rLev.mnBulletChar
+        << rLev.mnBulletFont
+        << rLev.mnBulletHeight
+        << nBulletColor
+        << rLev.mnAdjust
+        << rLev.mnLineFeed
+        << rLev.mnUpperDist
+        << rLev.mnLowerDist
+        << rLev.mnTextOfs
+        << rLev.mnBulletOfs;
+
+    if ( bSimpleText || nLev )
+	{
+		if ( nParaFlags & 0x200000 )
+			rSt << rLev.mnBiDi;
+	}
+	else
+	{
+		rSt << rLev.mnDefaultTab
+			<< (sal_uInt16)0
+			<< (sal_uInt16)0
+			<< rLev.mnAsianSettings
+			<< rLev.mnBiDi;
+	}
+}
+
+
+PPTExStyleSheet::PPTExStyleSheet( sal_uInt16 nDefaultTab, PPTExBulletProvider& rBuProv )
+{
+    for ( int nInstance = EPP_TEXTTYPE_Title; nInstance <= EPP_TEXTTYPE_QuarterBody; nInstance++ )
+    {
+        mpParaSheet[ nInstance ] = ( nInstance == EPP_TEXTTYPE_notUsed ) ? NULL : new PPTExParaSheet( nInstance, nDefaultTab, rBuProv );
+        mpCharSheet[ nInstance ] = ( nInstance == EPP_TEXTTYPE_notUsed ) ? NULL : new PPTExCharSheet( nInstance );
+    }
+}
+
+PPTExStyleSheet::~PPTExStyleSheet()
+{
+    for ( int nInstance = EPP_TEXTTYPE_Title; nInstance <= EPP_TEXTTYPE_QuarterBody; nInstance++ )
+    {
+        if ( nInstance == EPP_TEXTTYPE_notUsed )
+            continue;
+
+        delete mpParaSheet[ nInstance ];
+        delete mpCharSheet[ nInstance ];
+    }
+}
+
+void PPTExStyleSheet::SetStyleSheet( const ::com::sun::star::uno::Reference< ::com::sun::star::beans::XPropertySet > & rXPropSet,
+                                        FontCollection& rFontCollection, int nInstance, int nLevel )
+{
+    if ( nInstance == EPP_TEXTTYPE_notUsed )
+        return;
+    mpCharSheet[ nInstance ]->SetStyleSheet( rXPropSet, rFontCollection, nLevel );
+    mpParaSheet[ nInstance ]->SetStyleSheet( rXPropSet, rFontCollection, nLevel, mpCharSheet[ nInstance ]->maCharLevel[ nLevel ] );
+}
+
+sal_Bool PPTExStyleSheet::IsHardAttribute( sal_uInt32 nInstance, sal_uInt32 nLevel, PPTExTextAttr eAttr, sal_uInt32 nValue )
+{
+    const PPTExParaLevel& rPara = mpParaSheet[ nInstance ]->maParaLevel[ nLevel ];
+    const PPTExCharLevel& rChar = mpCharSheet[ nInstance ]->maCharLevel[ nLevel ];
+
+    sal_uInt32 nFlag = 0;
+
+    switch ( eAttr )
+    {
+        case ParaAttr_BulletOn : return ( rPara.mbIsBullet ) ? ( nValue ) ? FALSE : TRUE : ( nValue ) ? TRUE : FALSE;
+        case ParaAttr_BuHardFont :
+        case ParaAttr_BulletFont : return ( rPara.mnBulletFont != nValue );
+        case ParaAttr_BuHardColor :
+        case ParaAttr_BulletColor : return ( rPara.mnBulletColor != nValue );
+        case ParaAttr_BuHardHeight :
+        case ParaAttr_BulletHeight : return ( rPara.mnBulletHeight != nValue );
+        case ParaAttr_BulletChar : return ( rPara.mnBulletChar != nValue );
+        case ParaAttr_Adjust : return ( rPara.mnAdjust != nValue );
+        case ParaAttr_LineFeed : return ( rPara.mnLineFeed != nValue );
+        case ParaAttr_UpperDist : return ( rPara.mnUpperDist != nValue );
+        case ParaAttr_LowerDist : return ( rPara.mnLowerDist != nValue );
+        case ParaAttr_TextOfs : return ( rPara.mnTextOfs != nValue );
+        case ParaAttr_BulletOfs : return ( rPara.mnBulletOfs != nValue );
+        case ParaAttr_DefaultTab : return ( rPara.mnDefaultTab != nValue );
+		case ParaAttr_BiDi : return ( rPara.mnBiDi != nValue );
+        case CharAttr_Bold : nFlag = 1; break;
+        case CharAttr_Italic : nFlag = 2; break;
+        case CharAttr_Underline : nFlag = 4; break;
+        case CharAttr_Shadow : nFlag = 16; break;
+        case CharAttr_Strikeout : nFlag = 256; break;
+        case CharAttr_Embossed : nFlag = 512; break;
+        case CharAttr_Font : return ( rChar.mnFont != nValue );
+        case CharAttr_AsianOrComplexFont : return ( rChar.mnAsianOrComplexFont != nValue );
+        case CharAttr_Symbol : return TRUE;
+        case CharAttr_FontHeight : return ( rChar.mnFontHeight != nValue );
+        case CharAttr_FontColor : return ( rChar.mnFontColor != nValue );
+        case CharAttr_Escapement : return ( rChar.mnEscapement != nValue );
+		default:
+			break;
+    };
+    if ( nFlag )
+    {
+        if ( rChar.mnFlags & nFlag )
+            return ( ( nValue & nFlag ) == 0 );
+        else
+            return ( ( nValue & nFlag ) != 0 );
+    }
+    return TRUE;
+}
+
+sal_uInt32 PPTExStyleSheet::SizeOfTxCFStyleAtom() const
+{
+    return 24;
+}
+
+// the TxCFStyleAtom stores the text properties that are used
+// when creating new objects in PowerPoint.
+
+void PPTExStyleSheet::WriteTxCFStyleAtom( SvStream& rSt )
+{
+    const PPTExCharLevel& rCharStyle = mpCharSheet[ EPP_TEXTTYPE_Other ]->maCharLevel[ 0 ];
+    
+    sal_uInt16 nFlags = 0x60        // ??
+                      | 0x02        // fontsize;
+                      | 0x04;       // fontcolor
+
+    sal_uInt32 nCharFlags = rCharStyle.mnFlags;
+    nCharFlags &= CharAttr_Italic | CharAttr_Bold | CharAttr_Underline | CharAttr_Shadow;
+
+    rSt << (sal_uInt32)( EPP_TxCFStyleAtom << 16 )  // recordheader
+        << SizeOfTxCFStyleAtom() - 8
+        << (sal_uInt16)( 0x80 | nCharFlags )
+        << (sal_uInt16)nFlags
+        << (sal_uInt16)nCharFlags
+        << (sal_Int32)-1                            // ?
+        << rCharStyle.mnFontHeight
+        << rCharStyle.mnFontColor;
+}
+
+
+// ---------------------------------------------------------------------------------------------
+
+// ---------------------
+// - exported function -
+// ---------------------
+
+extern "C" SAL_DLLPUBLIC_EXPORT BOOL __LOADONCALLAPI ExportPPT( SvStorageRef& rSvStorage,
+                    ::com::sun::star::uno::Reference< ::com::sun::star::frame::XModel > & rXModel,
+                        ::com::sun::star::uno::Reference< ::com::sun::star::task::XStatusIndicator > & rXStatInd,
+                            SvMemoryStream* pVBA, sal_uInt32 nCnvrtFlags )
+{
+    PPTWriter*  pPPTWriter;
+    BOOL bStatus = FALSE;
+
+    pPPTWriter = new PPTWriter( rSvStorage, rXModel, rXStatInd, pVBA, nCnvrtFlags );
+    if ( pPPTWriter )
+    {
+        bStatus = ( pPPTWriter->IsValid() == TRUE );
+        delete pPPTWriter;
+    }
+
+    return bStatus;
+}
+
diff --git a/sd/source/filter/pptx/pptx-epptso.cxx b/sd/source/filter/pptx/pptx-epptso.cxx
new file mode 100644
index 0000000..08c427f
--- /dev/null
+++ sd/source/filter/pptx/pptx-epptso.cxx
@@ -0,0 +1,5855 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: epptso.cxx,v $
+ * $Revision: 1.107.6.4 $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+
+// MARKER(update_precomp.py): autogen include statement, do not remove
+#include "precompiled_sd.hxx"
+#include <osl/endian.h>
+#include <eppt.hxx>
+#include "epptdef.hxx"
+#ifndef _PptEscherEx_HXX
+#include "escherex.hxx"
+#endif
+#include <tools/poly.hxx>
+#include <vcl/bmpacc.hxx>
+#include <vcl/gradient.hxx>
+#include <vcl/gfxlink.hxx>
+#include <tools/stream.hxx>
+#include <sot/storage.hxx>
+#include <vcl/outdev.hxx>
+#include <vcl/virdev.hxx>
+#include <vcl/gradient.hxx>
+#include <sfx2/app.hxx>
+#include <svtools/languageoptions.hxx>
+//#ifndef _SVX_XIT_HXX
+//#include <svx/xit.hxx>
+//#endif
+#include <svx/svxenum.hxx>
+#include <svx/unoapi.hxx>
+#include <svx/svdoashp.hxx>
+#include <com/sun/star/style/VerticalAlignment.hpp>
+#include <com/sun/star/container/XIndexReplace.hpp>
+#include <com/sun/star/presentation/XPresentationPage.hpp>
+#include <com/sun/star/awt/XFont.hpp>
+#ifndef _COM_SUN_STAR_AWT_XFONTWEIGHT_HPP_
+#include <com/sun/star/awt/FontWeight.hpp>
+#endif
+#ifndef _COM_SUN_STAR_AWT_XFONTUNDERLINE_HPP_
+#include <com/sun/star/awt/FontUnderline.hpp>
+#endif
+#include <com/sun/star/style/ParagraphAdjust.hpp>
+#include <com/sun/star/style/LineSpacing.hpp>
+#include <com/sun/star/style/LineSpacingMode.hpp>
+#ifndef _COM_SUN_STAR_STYLE_XSTYLEFAMILIESSUPPLIER_PP_
+#include <com/sun/star/style/XStyleFamiliesSupplier.hpp>
+#endif
+#include <com/sun/star/style/XStyle.hpp>
+#include <com/sun/star/drawing/PointSequence.hpp>
+#include <com/sun/star/drawing/FlagSequence.hpp>
+#include <com/sun/star/drawing/PolygonFlags.hpp>
+#include <com/sun/star/beans/PropertyValue.hpp>
+#include <com/sun/star/drawing/XControlShape.hpp>
+#include <comphelper/processfactory.hxx>
+#include <com/sun/star/lang/XMultiServiceFactory.hpp>
+#include <com/sun/star/i18n/XBreakIterator.hpp>
+#include <com/sun/star/i18n/XScriptTypeDetector.hpp>
+#include <com/sun/star/i18n/ScriptType.hpp>
+#include <com/sun/star/i18n/ScriptDirection.hpp>
+#include <com/sun/star/embed/Aspects.hpp>
+#include <vcl/cvtgrf.hxx>
+#include <tools/urlobj.hxx>
+#ifndef _CPPUHELPER_EXTRACT_HXX_
+#include <comphelper/extract.hxx>
+#endif
+#ifndef _CPPUHELPER_PROPTYPEHLP_HXX_
+#include <cppuhelper/proptypehlp.hxx>
+#endif
+#ifndef _UCBHELPER_CONTENT_HXX_
+#include <ucbhelper/content.hxx>
+#endif
+#ifndef _UCBHELPER_CONTENTBROKER_HXX_
+#include <ucbhelper/contentbroker.hxx>
+#endif
+#ifndef _TOOLKIT_UNOHLP_HXX
+#include <toolkit/unohlp.hxx>
+#endif
+#include <rtl/crc.h>
+#include <sot/clsids.hxx>
+#include <unotools/ucbstreamhelper.hxx>
+#include <com/sun/star/text/FontRelief.hpp>
+#include <svx/frmdiritem.hxx>
+/*
+#include <svx/outliner.hxx>
+#include <svx/outlobj.hxx>
+#include <svx/svdmodel.hxx>
+*/
+#include <svtools/fltcall.hxx>
+#include <com/sun/star/table/XTable.hpp>
+#include <com/sun/star/table/XMergeableCell.hpp>
+#include <com/sun/star/table/BorderLine.hpp>
+#include <set>
+
+//#include <svx/xbtmpit.hxx>
+
+#include "i18npool/mslangid.hxx"
+
+#include <vos/xception.hxx>
+#ifndef _VOS_NO_NAMESPACE
+using namespace vos;
+#endif
+
+using namespace ::com::sun::star;
+
+////////////////////////////////////////////////////////////////////////////////////////////////////
+
+#define ANSI_CHARSET            0
+#define DEFAULT_CHARSET         1
+#define SYMBOL_CHARSET          2
+#define SHIFTJIS_CHARSET        128
+#define HANGEUL_CHARSET         129
+#define CHINESEBIG5_CHARSET     136
+#define OEM_CHARSET             255
+
+////////////////////////////////////////////////////////////////////////////////////////////////////
+
+/* Font Families */
+#define FF_DONTCARE             0x00
+#define FF_ROMAN                0x10
+#define FF_SWISS                0x20
+#define FF_MODERN               0x30
+#define FF_SCRIPT               0x40
+#define FF_DECORATIVE           0x50
+
+////////////////////////////////////////////////////////////////////////////////////////////////////
+
+#define DEFAULT_PITCH           0x00
+#define FIXED_PITCH             0x01
+#define VARIABLE_PITCH          0x02
+
+// ---------------------------------------------------------------------------------------------
+
+com::sun::star::uno::Reference< com::sun::star::i18n::XBreakIterator > xPPTBreakIter;
+com::sun::star::uno::Reference< com::sun::star::i18n::XScriptTypeDetector > xScriptTypeDetector;
+
+PPTExBulletProvider::PPTExBulletProvider()
+{
+    pGraphicProv = new EscherGraphicProvider( _E_GRAPH_PROV_USE_INSTANCES  | _E_GRAPH_PROV_DO_NOT_ROTATE_METAFILES );
+}
+
+PPTExBulletProvider::~PPTExBulletProvider()
+{
+    delete pGraphicProv;
+}
+
+sal_uInt16 PPTExBulletProvider::GetId( const ByteString& rUniqueId, Size& rGraphicSize )
+{
+    sal_uInt16 nRetValue = 0xffff;
+    sal_uInt32 nId = 0;
+
+    if ( rUniqueId.Len() )
+    {
+		Rectangle       aRect;
+        GraphicObject   aGraphicObject( rUniqueId );
+        Graphic         aMappedGraphic, aGraphic( aGraphicObject.GetGraphic() );
+        Size            aPrefSize( aGraphic.GetPrefSize() );
+        BitmapEx        aBmpEx( aGraphic.GetBitmapEx() );
+
+		if ( rGraphicSize.Width() && rGraphicSize.Height() )
+		{	
+			double          fQ1 = ( (double)aPrefSize.Width() / (double)aPrefSize.Height() );
+			double          fQ2 = ( (double)rGraphicSize.Width() / (double)rGraphicSize.Height() );
+			double          fXScale = 1;
+			double          fYScale = 1;
+
+			if ( fQ1 > fQ2 )
+				fYScale = fQ1 / fQ2;
+			else if ( fQ1 < fQ2 )
+				fXScale = fQ2 / fQ1;
+
+			if ( ( fXScale != 1.0 ) || ( fYScale != 1.0 ) )
+			{
+				aBmpEx.Scale( fXScale, fYScale );
+				Size aNewSize( (sal_Int32)((double)rGraphicSize.Width() / fXScale + 0.5 ),
+								(sal_Int32)((double)rGraphicSize.Height() / fYScale + 0.5 ) );
+
+				rGraphicSize = aNewSize;
+
+				aMappedGraphic = Graphic( aBmpEx );
+				aGraphicObject = GraphicObject( aMappedGraphic );
+			}
+		}
+
+		nId = pGraphicProv->GetBlibID( aBuExPictureStream, aGraphicObject.GetUniqueID(), aRect, NULL, NULL );
+
+        if ( nId && ( nId < 0x10000 ) )
+            nRetValue = (sal_uInt16)nId - 1;
+    }
+    return nRetValue;
+}
+
+// ---------------------------------------------------------------------------------------------
+
+GroupTable::GroupTable() :
+    mnCurrentGroupEntry ( 0 ),
+    mnMaxGroupEntry     ( 0 ),
+    mnGroupsClosed      ( 0 ),
+    mpGroupEntry        ( NULL )
+{
+    ImplResizeGroupTable( 32 );
+}
+
+// ---------------------------------------------------------------------------------------------
+
+GroupTable::~GroupTable()
+{
+    for ( sal_uInt32 i = 0; i < mnCurrentGroupEntry; delete mpGroupEntry[ i++ ] ) ;
+    delete[] mpGroupEntry;
+}
+
+// ---------------------------------------------------------------------------------------------
+
+void GroupTable::ImplResizeGroupTable( sal_uInt32 nEntrys )
+{
+    if ( nEntrys > mnMaxGroupEntry )
+    {
+        mnMaxGroupEntry         = nEntrys;
+        GroupEntry** pTemp = new GroupEntry*[ nEntrys ];
+        for ( sal_uInt32 i = 0; i < mnCurrentGroupEntry; i++ )
+            pTemp[ i ] = mpGroupEntry[ i ];
+        if ( mpGroupEntry )
+            delete[] mpGroupEntry;
+        mpGroupEntry = pTemp;
+    }
+}
+
+// ---------------------------------------------------------------------------------------------
+
+sal_Bool GroupTable::EnterGroup( ::com::sun::star::uno::Reference< ::com::sun::star::container::XIndexAccess >& rXIndexAccessRef )
+{
+    sal_Bool bRet = sal_False;
+    if ( rXIndexAccessRef.is() )
+    {
+        GroupEntry* pNewGroup = new GroupEntry( rXIndexAccessRef );
+        if ( pNewGroup->mnCount )
+        {
+            if ( mnMaxGroupEntry == mnCurrentGroupEntry )
+                ImplResizeGroupTable( mnMaxGroupEntry + 8 );
+            mpGroupEntry[ mnCurrentGroupEntry++ ] = pNewGroup;
+            bRet = sal_True;
+        }
+        else
+            delete pNewGroup;
+    }
+    return bRet;
+}
+
+// ---------------------------------------------------------------------------------------------
+
+sal_uInt32 GroupTable::GetGroupsClosed()
+{
+    sal_uInt32 nRet = mnGroupsClosed;
+    mnGroupsClosed = 0;
+    return nRet;
+}
+
+// ---------------------------------------------------------------------------------------------
+
+void GroupTable::ClearGroupTable()
+{
+    for ( sal_uInt32 i = 0; i < mnCurrentGroupEntry; i++, delete mpGroupEntry[ i ] ) ;
+    mnCurrentGroupEntry = 0;
+}
+
+// ---------------------------------------------------------------------------------------------
+
+void GroupTable::ResetGroupTable( sal_uInt32 nCount )
+{
+    ClearGroupTable();
+    mpGroupEntry[ mnCurrentGroupEntry++ ] = new GroupEntry( nCount );
+}
+
+// ---------------------------------------------------------------------------------------------
+
+sal_Bool GroupTable::GetNextGroupEntry()
+{
+    while ( mnCurrentGroupEntry )
+    {
+        mnIndex = mpGroupEntry[ mnCurrentGroupEntry - 1 ]->mnCurrentPos++;
+
+        if ( mpGroupEntry[ mnCurrentGroupEntry - 1 ]->mnCount > mnIndex )
+            return TRUE;
+
+        delete ( mpGroupEntry[ --mnCurrentGroupEntry ] );
+
+        if ( mnCurrentGroupEntry )
+            mnGroupsClosed++;
+    }
+    return FALSE;
+}
+
+// ---------------------------------------------------------------------------------------------
+
+void GroupTable::SkipCurrentGroup()
+{
+    if ( mnCurrentGroupEntry )
+        delete ( mpGroupEntry[ --mnCurrentGroupEntry ] );
+}
+
+// ---------------------------------------------------------------------------------------------
+
+FontCollectionEntry::~FontCollectionEntry()
+{
+}
+
+// ---------------------------------------------------------------------------------------------
+
+void FontCollectionEntry::ImplInit( const String& rName )
+{
+    String aSubstName( GetSubsFontName( rName, SUBSFONT_ONLYONE | SUBSFONT_MS ) );
+    if ( aSubstName.Len() )
+    {
+        Name = aSubstName;
+        bIsConverted = sal_True;
+    }
+    else
+    {
+        Name = rName;
+        bIsConverted = sal_False;
+    }
+}
+
+FontCollection::~FontCollection()
+{
+    for( void* pStr = List::First(); pStr; pStr = List::Next() )
+        delete (FontCollectionEntry*)pStr;
+    delete pVDev;
+	xPPTBreakIter = NULL;
+	xScriptTypeDetector = NULL;
+}
+
+FontCollection::FontCollection() :
+    pVDev ( NULL )
+{
+	com::sun::star::uno::Reference< com::sun::star::lang::XMultiServiceFactory >
+		xMSF = ::comphelper::getProcessServiceFactory();
+	com::sun::star::uno::Reference< com::sun::star::uno::XInterface >
+		xInterface = xMSF->createInstance( rtl::OUString::createFromAscii( "com.sun.star.i18n.BreakIterator" ) );
+	if ( xInterface.is() )
+		xPPTBreakIter = com::sun::star::uno::Reference< com::sun::star::i18n::XBreakIterator >
+			( xInterface, com::sun::star::uno::UNO_QUERY );
+
+	xInterface = xMSF->createInstance( rtl::OUString::createFromAscii( "com.sun.star.i18n.ScriptTypeDetector" ) );
+	if ( xInterface.is() )
+		xScriptTypeDetector = com::sun::star::uno::Reference< com::sun::star::i18n::XScriptTypeDetector >
+			( xInterface, com::sun::star::uno::UNO_QUERY );
+}
+
+short FontCollection::GetScriptDirection( const String& rString ) const
+{
+	short nRet = com::sun::star::i18n::ScriptDirection::NEUTRAL;
+	if ( xScriptTypeDetector.is() )
+	{
+		const rtl::OUString sT( rString );
+		nRet = xScriptTypeDetector->getScriptDirection( sT, 0, com::sun::star::i18n::ScriptDirection::NEUTRAL );
+	}
+	return nRet;
+}
+
+sal_uInt32 FontCollection::GetId( FontCollectionEntry& rEntry )
+{
+    if( rEntry.Name.Len() )
+    {
+        const sal_uInt32 nFonts = GetCount();
+
+        for( sal_uInt32 i = 0; i < nFonts; i++ )
+        {
+            const FontCollectionEntry* pEntry = GetById( i );
+            if( pEntry->Name == rEntry.Name )
+                return i;
+        }
+		Font aFont;
+		aFont.SetCharSet( rEntry.CharSet );
+		aFont.SetName( rEntry.Original );
+//		aFont.SetFamily( rEntry.Family );
+//		aFont.SetPitch( rEntry.Pitch );
+        aFont.SetHeight( 100 );
+
+        if ( !pVDev )
+            pVDev = new VirtualDevice;
+
+        pVDev->SetFont( aFont );
+		FontMetric aMetric( pVDev->GetFontMetric() );
+
+        sal_uInt16 nTxtHeight = (sal_uInt16)aMetric.GetAscent() + (sal_uInt16)aMetric.GetDescent();
+
+        if ( nTxtHeight )
+        {
+		    double fScaling = (double)nTxtHeight / 120.0;
+            if ( ( fScaling > 0.50 ) && ( fScaling < 1.5 ) )
+                rEntry.Scaling = fScaling;
+        }
+
+        List::Insert( new FontCollectionEntry( rEntry ), LIST_APPEND );
+        return nFonts;
+    }
+    return 0;
+}
+
+const FontCollectionEntry* FontCollection::GetById( sal_uInt32 nId )
+{
+    return (FontCollectionEntry*)List::GetObject( nId );
+}
+
+// ---------------------------------------------------------------------------------------------
+
+sal_uInt32 PPTWriter::ImplVBAInfoContainer( SvStream* pStrm )
+{
+    sal_uInt32 nSize = 28;
+    if ( pStrm )
+    {
+        *pStrm << (sal_uInt32)( 0x1f | ( EPP_VBAInfo << 16 ) )
+               << (sal_uInt32)( nSize - 8 )
+               << (sal_uInt32)( 2 | ( EPP_VBAInfoAtom << 16 ) )
+               << (sal_uInt32)12;
+        mpPptEscherEx->InsertPersistOffset( EPP_Persist_VBAInfoAtom, pStrm->Tell() );
+        *pStrm << (sal_uInt32)0
+               << (sal_uInt32)0
+               << (sal_uInt32)1;
+    }
+    return nSize;
+}
+
+// ---------------------------------------------------------------------------------------------
+
+sal_uInt32 PPTWriter::ImplSlideViewInfoContainer( sal_uInt32 nInstance, SvStream* pStrm )
+{
+    sal_uInt32 nSize = 111;
+    if ( pStrm )
+    {
+        sal_uInt8 bShowGuides = 0;
+        sal_uInt8 bSnapToGrid = 1;
+        sal_uInt8 bSnapToShape = 0;
+
+        sal_Int32 nScaling = 85;
+        sal_Int32 nMasterCoordinate = 0xdda;
+        sal_Int32 nXOrigin = -780;
+        sal_Int32 nYOrigin = -84;
+
+        sal_Int32 nPosition1 = 0x870;
+        sal_Int32 nPosition2 = 0xb40;
+
+        if ( nInstance )
+        {
+            bShowGuides = 1;
+            nScaling = 0x3b;
+            nMasterCoordinate = 0xf0c;
+            nXOrigin = -1752;
+            nYOrigin = -72;
+            nPosition1 = 0xb40;
+            nPosition2 = 0x870;
+        }
+        *pStrm << (sal_uInt32)( 0xf | ( EPP_SlideViewInfo << 16 ) | ( nInstance << 4 ) )
+               << (sal_uInt32)( nSize - 8 )
+               << (sal_uInt32)( EPP_SlideViewInfoAtom << 16 ) << (sal_uInt32)3
+               << bShowGuides << bSnapToGrid << bSnapToShape
+               << (sal_uInt32)( EPP_ViewInfoAtom << 16 ) << (sal_uInt32)52
+               << nScaling << (sal_Int32)100 << nScaling << (sal_Int32)100  // scaling atom - Keeps the current scale
+               << nScaling << (sal_Int32)100 << nScaling << (sal_Int32)100  // scaling atom - Keeps the previous scale
+               << (sal_Int32)0x17ac << nMasterCoordinate// Origin - Keeps the origin in master coordinates
+               << nXOrigin << nYOrigin              // Origin
+               << (sal_uInt8)1                          // Bool1 varScale - Set if zoom to fit is set
+               << (sal_uInt8)0                          // bool1 draftMode - Not used
+               << (sal_uInt16)0                         // padword
+               << (sal_uInt32)( ( 7 << 4 ) | ( EPP_GuideAtom << 16 ) ) << (sal_uInt32)8
+               << (sal_uInt32)0     // Type of the guide. If the guide is horizontal this value is zero. If it's vertical, it's one.
+               << nPosition1    // Position of the guide in master coordinates. X coordinate if it's vertical, and Y coordinate if it's horizontal.
+               << (sal_uInt32)( ( 7 << 4 ) | ( EPP_GuideAtom << 16 ) ) << (sal_uInt32)8
+               << (sal_Int32)1      // Type of the guide. If the guide is horizontal this value is zero. If it's vertical, it's one.
+               << nPosition2;   // Position of the guide in master coordinates. X coordinate if it's vertical, and Y coordinate if it's horizontal.
+    }
+    return nSize;
+}
+
+// ---------------------------------------------------------------------------------------------
+
+sal_uInt32 PPTWriter::ImplOutlineViewInfoContainer( SvStream* pStrm )
+{
+    sal_uInt32 nSize = 68;
+    if ( pStrm )
+    {
+        *pStrm << (sal_uInt32)( 0xf | ( EPP_OutlineViewInfo << 16 ) ) << (sal_uInt32)( nSize - 8 )
+               << (sal_uInt32)( EPP_ViewInfoAtom << 16 ) << (sal_uInt32)52
+               << (sal_Int32)170 << (sal_Int32)200 << (sal_Int32)170 << (sal_Int32)200  // scaling atom - Keeps the current scale
+               << (sal_Int32)170 << (sal_Int32)200 << (sal_Int32)170 << (sal_Int32)200  // scaling atom - Keeps the previous scale
+               << (sal_Int32)0x17ac << 0xdda    // Origin - Keeps the origin in master coordinates
+               << (sal_Int32)-780 << (sal_Int32)-84 // Origin
+               << (sal_uInt8)1                  // bool1 varScale - Set if zoom to fit is set
+               << (sal_uInt8)0                  // bool1 draftMode - Not used
+               << (sal_uInt16)0;                // padword
+    }
+    return nSize;
+}
+
+// ---------------------------------------------------------------------------------------------
+
+sal_uInt32 PPTWriter::ImplProgBinaryTag( SvStream* pStrm )
+{
+    sal_uInt32 nPictureStreamSize, nOutlineStreamSize, nSize = 8;
+
+    nPictureStreamSize = aBuExPictureStream.Tell();
+    if ( nPictureStreamSize )
+        nSize += nPictureStreamSize + 8;
+
+    nOutlineStreamSize = aBuExOutlineStream.Tell();
+    if ( nOutlineStreamSize )
+        nSize += nOutlineStreamSize + 8;
+
+    if ( pStrm )
+    {
+        *pStrm << (sal_uInt32)( EPP_BinaryTagData << 16 ) << (sal_uInt32)( nSize - 8 );
+        if ( nPictureStreamSize )
+        {
+            *pStrm << (sal_uInt32)( 0xf | ( EPP_PST_ExtendedBuGraContainer << 16 ) ) << nPictureStreamSize;
+            pStrm->Write( aBuExPictureStream.GetData(), nPictureStreamSize );
+        }
+        if ( nOutlineStreamSize )
+        {
+            *pStrm << (sal_uInt32)( 0xf | ( EPP_PST_ExtendedPresRuleContainer << 16 ) ) << nOutlineStreamSize;
+            pStrm->Write( aBuExOutlineStream.GetData(), nOutlineStreamSize );
+        }
+    }
+    return nSize;
+}
+
+// ---------------------------------------------------------------------------------------------
+
+sal_uInt32 PPTWriter::ImplProgBinaryTagContainer( SvStream* pStrm, SvMemoryStream* pBinTagStrm )
+{
+    sal_uInt32 nSize = 8 + 8 + 14;
+    if ( pStrm )
+    {
+        *pStrm << (sal_uInt32)( 0xf | ( EPP_ProgBinaryTag << 16 ) ) << (sal_uInt32)0
+               << (sal_uInt32)( EPP_CString << 16 ) << (sal_uInt32)14
+               << (sal_uInt32)0x5f005f << (sal_uInt32)0x50005f
+               << (sal_uInt32)0x540050 << (sal_uInt16)0x39;
+    }
+    if ( pBinTagStrm )
+    {
+        sal_uInt32 nLen = pBinTagStrm->Tell();
+        nSize += nLen + 8;
+        *pStrm << (sal_uInt32)( EPP_BinaryTagData << 16 ) << nLen;
+        pStrm->Write( pBinTagStrm->GetData(), nLen );
+    }
+    else
+        nSize += ImplProgBinaryTag( pStrm );
+
+    if ( pStrm )
+    {
+        pStrm->SeekRel( - ( (sal_Int32)nSize - 4 ) );
+        *pStrm << (sal_uInt32)( nSize - 8 );
+        pStrm->SeekRel( nSize - 8 );
+    }
+    return nSize;
+}
+
+// ---------------------------------------------------------------------------------------------
+
+sal_uInt32 PPTWriter::ImplProgTagContainer( SvStream* pStrm, SvMemoryStream* pBinTagStrm )
+{
+    sal_uInt32 nSize = 0;
+    if ( aBuExPictureStream.Tell() || aBuExOutlineStream.Tell() || pBinTagStrm )
+    {
+        nSize = 8;
+        if ( pStrm )
+        {
+            *pStrm << (sal_uInt32)( 0xf | ( EPP_ProgTags << 16 ) ) << (sal_uInt32)0;
+        }
+        nSize += ImplProgBinaryTagContainer( pStrm, pBinTagStrm );
+        if ( pStrm )
+        {
+            pStrm->SeekRel( - ( (sal_Int32)nSize - 4 ) );
+            *pStrm << (sal_uInt32)( nSize - 8 );
+            pStrm->SeekRel( nSize - 8 );
+        }
+    }
+    return nSize;
+}
+
+// ---------------------------------------------------------------------------------------------
+
+sal_uInt32 PPTWriter::ImplDocumentListContainer( SvStream* pStrm )
+{
+    sal_uInt32 nSize = 8;
+    if ( pStrm )
+    {
+        *pStrm << (sal_uInt32)( ( EPP_List << 16 ) | 0xf ) << (sal_uInt32)0;
+    }
+
+    nSize += ImplVBAInfoContainer( pStrm );
+    nSize += ImplSlideViewInfoContainer( 0, pStrm );
+    nSize += ImplOutlineViewInfoContainer( pStrm );
+    nSize += ImplSlideViewInfoContainer( 1, pStrm );
+    nSize += ImplProgTagContainer( pStrm );
+
+    if ( pStrm )
+    {
+        pStrm->SeekRel( - ( (sal_Int32)nSize - 4 ) );
+        *pStrm << (sal_uInt32)( nSize - 8 );
+        pStrm->SeekRel( nSize - 8 );
+    }
+    return nSize;
+}
+
+// ---------------------------------------------------------------------------------------------
+
+sal_uInt32 PPTWriter::ImplMasterSlideListContainer( SvStream* pStrm )
+{
+    sal_uInt32 i, nSize = 28 * mnMasterPages + 8;
+    if ( pStrm )
+    {
+        *pStrm << (sal_uInt32)( 0x1f | ( EPP_SlideListWithText << 16 ) ) << (sal_uInt32)( nSize - 8 );
+
+        for ( i = 0; i < mnMasterPages; i++ )
+        {
+            *pStrm << (sal_uInt32)( EPP_SlidePersistAtom << 16 ) << (sal_uInt32)20;
+            mpPptEscherEx->InsertPersistOffset( EPP_MAINMASTER_PERSIST_KEY | i, pStrm->Tell() );
+            *pStrm << (sal_uInt32)0                 // psrReference - logical reference to the slide persist object ( EPP_MAINMASTER_PERSIST_KEY )
+                   << (sal_uInt32)0                 // flags - only bit 3 used, if set then slide contains shapes other than placeholders
+                   << (sal_Int32)0                  // numberTexts - number of placeholder texts stored with the persist object. Allows to display outline view without loading the slide persist objects
+                   << (sal_Int32)( 0x80000000 | i ) // slideId - Unique slide identifier, used for OLE link monikers for example
+                   << (sal_uInt32)0;                // reserved, usualy 0
+        }
+    }
+    return nSize;
+}
+
+// ---------------------------------------------------------------------------------------------
+
+sal_uInt32 PPTWriter::ImplInsertBookmarkURL( const String& rBookmarkURL, const sal_uInt32 nType,
+	const String& rStringVer0, const String& rStringVer1, const String& rStringVer2, const String& rStringVer3 )
+{
+    sal_uInt32 nHyperId = ++mnExEmbed;
+    maHyperlink.Insert( new EPPTHyperlink( rBookmarkURL, nType ), LIST_APPEND );
+
+    *mpExEmbed  << (sal_uInt16)0xf
+                << (sal_uInt16)EPP_ExHyperlink
+                << (sal_uInt32)0;
+	sal_uInt32 nHyperSize, nHyperStart = mpExEmbed->Tell();
+    *mpExEmbed  << (sal_uInt16)0
+                << (sal_uInt16)EPP_ExHyperlinkAtom
+                << (sal_uInt32)4
+                << nHyperId;
+
+	sal_uInt16 i, nStringLen;
+	nStringLen = rStringVer0.Len();
+	if ( nStringLen )
+	{
+		*mpExEmbed << (sal_uInt32)( EPP_CString << 16 ) << (sal_uInt32)( nStringLen * 2 );
+		for ( i = 0; i < nStringLen; i++ )
+		{
+			*mpExEmbed << rStringVer0.GetChar( i );
+		}
+	}
+	nStringLen = rStringVer1.Len();
+	if ( nStringLen )
+	{
+		*mpExEmbed << (sal_uInt32)( ( EPP_CString << 16 ) | 0x10 ) << (sal_uInt32)( nStringLen * 2 );
+		for ( i = 0; i < nStringLen; i++ )
+		{
+			*mpExEmbed << rStringVer1.GetChar( i );
+		}
+	}
+	nStringLen = rStringVer2.Len();
+	if ( nStringLen )
+	{
+		*mpExEmbed << (sal_uInt32)( ( EPP_CString << 16 ) | 0x20 ) << (sal_uInt32)( nStringLen * 2 );
+		for ( i = 0; i < nStringLen; i++ )
+		{
+			*mpExEmbed << rStringVer2.GetChar( i );
+		}
+	}
+	nStringLen = rStringVer3.Len();
+	if ( nStringLen )
+	{
+		*mpExEmbed << (sal_uInt32)( ( EPP_CString << 16 ) | 0x30 ) << (sal_uInt32)( nStringLen * 2 );
+		for ( i = 0; i < nStringLen; i++ )
+		{
+			*mpExEmbed << rStringVer3.GetChar( i );
+		}
+	}
+	nHyperSize = mpExEmbed->Tell() - nHyperStart;
+	mpExEmbed->SeekRel( - ( (sal_Int32)nHyperSize + 4 ) );
+	*mpExEmbed  << nHyperSize;
+	mpExEmbed->SeekRel( nHyperSize );
+	return nHyperId;
+}
+
+// ---------------------------------------------------------------------------------------------
+
+sal_Bool PPTWriter::ImplCloseDocument()
+{
+    sal_uInt32 nOfs = mpPptEscherEx->PtGetOffsetByID( EPP_Persist_Document );
+    if ( nOfs )
+    {
+        mpPptEscherEx->PtReplaceOrInsert( EPP_Persist_CurrentPos, mpStrm->Tell() );
+        mpStrm->Seek( nOfs );
+
+		// creating the TxMasterStyleAtom
+		SvMemoryStream aTxMasterStyleAtomStrm( 0x200, 0x200 );
+		{
+			EscherExAtom aTxMasterStyleAtom( aTxMasterStyleAtomStrm, EPP_TxMasterStyleAtom, EPP_TEXTTYPE_Other );
+			aTxMasterStyleAtomStrm << (sal_uInt16)5;		// paragraph count
+			sal_uInt16 nLev;
+			sal_Bool bFirst = sal_True;
+			for ( nLev = 0; nLev < 5; nLev++ )
+			{
+				mpStyleSheet->mpParaSheet[ EPP_TEXTTYPE_Other ]->Write( aTxMasterStyleAtomStrm, mpPptEscherEx, nLev, bFirst, sal_False, mXPagePropSet );
+				mpStyleSheet->mpCharSheet[ EPP_TEXTTYPE_Other ]->Write( aTxMasterStyleAtomStrm, mpPptEscherEx, nLev, bFirst, sal_False, mXPagePropSet );
+				bFirst = sal_False;
+			}
+        }
+
+        mpExEmbed->Seek( STREAM_SEEK_TO_END );
+        sal_uInt32 nExEmbedSize = mpExEmbed->Tell();
+
+        // nEnviroment : Gesamtgroesse des Environment Containers
+        sal_uInt32 nEnvironment = maFontCollection.GetCount() * 76      // 68 bytes pro Fontenityatom und je 8 Bytes fuer die Header
+                                + 8                                     // 1 FontCollection Container
+                                + 20                                    // SrKinsoku Container
+                                + 18                                    // 1 TxSiStyleAtom
+                                + aTxMasterStyleAtomStrm.Tell()			// 1 TxMasterStyleAtom;
+                                + mpStyleSheet->SizeOfTxCFStyleAtom();
+
+        sal_uInt32 nBytesToInsert = nEnvironment + 8;
+
+        if ( nExEmbedSize )
+            nBytesToInsert += nExEmbedSize + 8 + 12;
+
+        nBytesToInsert += maSoundCollection.GetSize();
+        nBytesToInsert += mpPptEscherEx->DrawingGroupContainerSize();
+        nBytesToInsert += ImplMasterSlideListContainer( NULL );
+        nBytesToInsert += ImplDocumentListContainer( NULL );
+
+        // nBytes im Stream einfuegen, und abhaengige Container anpassen
+        mpPptEscherEx->InsertAtCurrentPos( nBytesToInsert, TRUE );
+
+        // CREATE HYPERLINK CONTAINER
+        if ( nExEmbedSize )
+        {
+            *mpStrm << (sal_uInt16)0xf
+                    << (sal_uInt16)EPP_ExObjList
+                    << (sal_uInt32)( nExEmbedSize + 12 )
+                    << (sal_uInt16)0
+                    << (sal_uInt16)EPP_ExObjListAtom
+                    << (sal_uInt32)4
+                    << (sal_uInt32)mnExEmbed;
+            mpPptEscherEx->InsertPersistOffset( EPP_Persist_ExObj, mpStrm->Tell() );
+            mpStrm->Write( mpExEmbed->GetData(), nExEmbedSize );
+        }
+
+        // CREATE ENVIRONMENT
+        *mpStrm << (sal_uInt16)0xf << (sal_uInt16)EPP_Environment << (sal_uInt32)nEnvironment;
+
+        // Open Container ( EPP_SrKinsoku )
+        *mpStrm << (sal_uInt16)0x2f << (sal_uInt16)EPP_SrKinsoku << (sal_uInt32)12;
+        mpPptEscherEx->AddAtom( 4, EPP_SrKinsokuAtom, 0, 3 );
+        *mpStrm << (sal_Int32)0;                        // SrKinsoku Level 0
+
+        // Open Container ( EPP_FontCollection )
+        *mpStrm << (sal_uInt16)0xf << (sal_uInt16)EPP_FontCollection << (sal_uInt32)maFontCollection.GetCount() * 76;
+
+        for ( sal_uInt32 i = 0; i < maFontCollection.GetCount(); i++ )
+        {
+            mpPptEscherEx->AddAtom( 68, EPP_FontEnityAtom, 0, i );
+            const FontCollectionEntry* pDesc = maFontCollection.GetById( i );
+            sal_uInt32 nFontLen = pDesc->Name.Len();
+            if ( nFontLen > 31 )
+                nFontLen = 31;
+            for ( sal_uInt16 n = 0; n < 32; n++ )
+            {
+                sal_Unicode nUniCode = 0;
+                if ( n < nFontLen )
+                    nUniCode = pDesc->Name.GetChar( n );
+                *mpStrm << nUniCode;
+            }
+            sal_uInt8   lfCharSet = ANSI_CHARSET;
+            sal_uInt8   lfClipPrecision = 0;
+            sal_uInt8   lfQuality = 6;
+            sal_uInt8   lfPitchAndFamily = 0;
+
+            if ( pDesc->CharSet == RTL_TEXTENCODING_SYMBOL )
+                lfCharSet = SYMBOL_CHARSET;
+
+            switch( pDesc->Family )
+            {
+                case ::com::sun::star::awt::FontFamily::ROMAN :
+                    lfPitchAndFamily |= FF_ROMAN;
+                break;
+
+                case ::com::sun::star::awt::FontFamily::SWISS :
+                    lfPitchAndFamily |= FF_SWISS;
+                break;
+
+                case ::com::sun::star::awt::FontFamily::MODERN :
+                    lfPitchAndFamily |= FF_MODERN;
+                break;
+
+                case ::com::sun::star::awt::FontFamily::SCRIPT:
+                    lfPitchAndFamily |= FF_SCRIPT;
+                break;
+
+                case ::com::sun::star::awt::FontFamily::DECORATIVE:
+                     lfPitchAndFamily |= FF_DECORATIVE;
+                break;
+
+                default:
+                    lfPitchAndFamily |= FAMILY_DONTKNOW;
+                break;
+            }
+            switch( pDesc->Pitch )
+            {
+                case ::com::sun::star::awt::FontPitch::FIXED:
+                    lfPitchAndFamily |= FIXED_PITCH;
+                break;
+
+                default:
+                    lfPitchAndFamily |= DEFAULT_PITCH;
+                break;
+            }
+            *mpStrm << lfCharSet
+                    << lfClipPrecision
+                    << lfQuality
+                    << lfPitchAndFamily;
+        }
+        mpStyleSheet->WriteTxCFStyleAtom( *mpStrm );        // create style that is used for new standard objects
+        mpPptEscherEx->AddAtom( 10, EPP_TxSIStyleAtom );
+        *mpStrm << (sal_uInt32)7                        // ?
+                << (sal_Int16)2                         // ?
+                << (sal_uInt8)9                         // ?
+                << (sal_uInt8)8                         // ?
+                << (sal_Int16)0;                        // ?
+
+		mpStrm->Write( aTxMasterStyleAtomStrm.GetData(), aTxMasterStyleAtomStrm.Tell() );
+		maSoundCollection.Write( *mpStrm );
+        mpPptEscherEx->WriteDrawingGroupContainer( *mpStrm );
+        ImplMasterSlideListContainer( mpStrm );
+        ImplDocumentListContainer( mpStrm );
+
+        sal_uInt32 nOldPos = mpPptEscherEx->PtGetOffsetByID( EPP_Persist_CurrentPos );
+        if ( nOldPos )
+        {
+            mpStrm->Seek( nOldPos );
+            return TRUE;
+        }
+    }
+    return FALSE;
+}
+
+// ---------------------------------------------------------------------------------------------
+
+sal_Bool PropValue::GetPropertyValue(
+    ::com::sun::star::uno::Any& rAny,
+        const ::com::sun::star::uno::Reference< ::com::sun::star::beans::XPropertySet > & rXPropSet,
+            const String& rString,
+                    sal_Bool bTestPropertyAvailability )
+{
+    sal_Bool bRetValue = sal_True;
+    if ( bTestPropertyAvailability )
+    {
+        bRetValue = sal_False;
+        try
+        {
+            ::com::sun::star::uno::Reference< ::com::sun::star::beans::XPropertySetInfo >
+                aXPropSetInfo( rXPropSet->getPropertySetInfo() );
+            if ( aXPropSetInfo.is() )
+                bRetValue = aXPropSetInfo->hasPropertyByName( rString );
+        }
+        catch( ::com::sun::star::uno::Exception& )
+        {
+            bRetValue = sal_False;
+        }
+    }
+    if ( bRetValue )
+    {
+        try
+        {
+            rAny = rXPropSet->getPropertyValue( rString );
+            if ( !rAny.hasValue() )
+                bRetValue = sal_False;
+        }
+        catch( ::com::sun::star::uno::Exception& )
+        {
+            bRetValue = sal_False;
+        }
+    }
+    return bRetValue;
+}
+
+// ---------------------------------------------------------------------------------------------
+
+::com::sun::star::beans::PropertyState PropValue::GetPropertyState(
+    const ::com::sun::star::uno::Reference< ::com::sun::star::beans::XPropertySet > & rXPropSet,
+        const String& rPropertyName )
+{
+    ::com::sun::star::beans::PropertyState eRetValue = ::com::sun::star::beans::PropertyState_AMBIGUOUS_VALUE;
+    try
+    {
+        ::com::sun::star::uno::Reference< ::com::sun::star::beans::XPropertyState > aXPropState
+                ( rXPropSet, ::com::sun::star::uno::UNO_QUERY );
+        if ( aXPropState.is() )
+            eRetValue = aXPropState->getPropertyState( rPropertyName );
+    }
+    catch( ::com::sun::star::uno::Exception& )
+    {
+        //...
+    }
+    return eRetValue;
+}
+
+// ---------------------------------------------------------------------------------------------
+
+sal_Bool PropValue::ImplGetPropertyValue( const String& rString )
+{
+    return GetPropertyValue( mAny, mXPropSet, rString );
+}
+
+// ---------------------------------------------------------------------------------------------
+
+sal_Bool PropValue::ImplGetPropertyValue( const ::com::sun::star::uno::Reference< ::com::sun::star::beans::XPropertySet > & aXPropSet, const String& rString )
+{
+    return GetPropertyValue( mAny, aXPropSet, rString );
+}
+
+// ---------------------------------------------------------------------------------------------
+
+sal_Bool PropStateValue::ImplGetPropertyValue( const String& rString, sal_Bool bGetPropertyState )
+{
+    ePropState = ::com::sun::star::beans::PropertyState_AMBIGUOUS_VALUE;
+    sal_Bool bRetValue = TRUE;
+#ifdef UNX
+        ::com::sun::star::uno::Reference< ::com::sun::star::beans::XPropertySetInfo >
+            aXPropSetInfo( mXPropSet->getPropertySetInfo() );
+        if ( !aXPropSetInfo.is() )
+            return sal_False;
+#endif
+    try
+    {
+        mAny = mXPropSet->getPropertyValue( rString );
+        if ( !mAny.hasValue() )
+            bRetValue = FALSE;
+        else if ( bGetPropertyState )
+            ePropState = mXPropState->getPropertyState( rString );
+        else
+            ePropState = ::com::sun::star::beans::PropertyState_DIRECT_VALUE;
+    }
+    catch( ::com::sun::star::uno::Exception& )
+    {
+        bRetValue = FALSE;
+    }
+    return bRetValue;
+}
+
+// ---------------------------------------------------------------------------------------------
+
+sal_Bool PPTWriter::ImplInitSOIface()
+{
+    while( TRUE )
+    {
+        mXDrawPagesSupplier = ::com::sun::star::uno::Reference<
+            ::com::sun::star::drawing::XDrawPagesSupplier >
+                ( mXModel, ::com::sun::star::uno::UNO_QUERY );
+        if ( !mXDrawPagesSupplier.is() )
+            break;
+
+        mXMasterPagesSupplier = ::com::sun::star::uno::Reference<
+            ::com::sun::star::drawing::XMasterPagesSupplier >
+                ( mXModel, ::com::sun::star::uno::UNO_QUERY );
+        if ( !mXMasterPagesSupplier.is() )
+            break;
+        mXDrawPages = mXMasterPagesSupplier->getMasterPages();
+        if ( !mXDrawPages.is() )
+            break;
+        mnMasterPages = mXDrawPages->getCount();
+        mXDrawPages = mXDrawPagesSupplier->getDrawPages();
+        if( !mXDrawPages.is() )
+            break;
+        mnPages =  mXDrawPages->getCount();
+        if ( !ImplGetPageByIndex( 0, NORMAL ) )
+            break;
+
+        return TRUE;
+    }
+    return FALSE;
+}
+
+// ---------------------------------------------------------------------------------------------
+
+sal_Bool PPTWriter::ImplSetCurrentStyleSheet( sal_uInt32 nPageNum )
+{
+	sal_Bool bRet = sal_False;
+	if ( nPageNum >= maStyleSheetList.size() )
+		nPageNum = 0;
+	else
+		bRet = sal_True;
+	mpStyleSheet = maStyleSheetList[ nPageNum ];
+	return bRet;
+}
+
+// ---------------------------------------------------------------------------------------------
+
+sal_Bool PPTWriter::ImplGetPageByIndex( sal_uInt32 nIndex, PageType ePageType )
+{
+    while( TRUE )
+    {
+        if ( ePageType != meLatestPageType )
+        {
+            switch( ePageType )
+            {
+                case NORMAL :
+                case NOTICE :
+                {
+                    mXDrawPages = mXDrawPagesSupplier->getDrawPages();
+                    if( !mXDrawPages.is() )
+                        return FALSE;
+                }
+                break;
+
+                case MASTER :
+                {
+                    mXDrawPages = mXMasterPagesSupplier->getMasterPages();
+                    if( !mXDrawPages.is() )
+                        return FALSE;
+                }
+                break;
+				default:
+					break;
+            }
+            meLatestPageType = ePageType;
+        }
+        ::com::sun::star::uno::Any aAny( mXDrawPages->getByIndex( nIndex ) );
+        aAny >>= mXDrawPage;
+        if ( !mXDrawPage.is() )
+            break;
+        if ( ePageType == NOTICE )
+        {
+            ::com::sun::star::uno::Reference< ::com::sun::star::presentation::XPresentationPage >
+                aXPresentationPage( mXDrawPage, ::com::sun::star::uno::UNO_QUERY );
+            if ( !aXPresentationPage.is() )
+                break;
+            mXDrawPage = aXPresentationPage->getNotesPage();
+            if ( !mXDrawPage.is() )
+                break;
+        }
+        mXPagePropSet = ::com::sun::star::uno::Reference< ::com::sun::star::beans::XPropertySet >
+            ( mXDrawPage, ::com::sun::star::uno::UNO_QUERY );
+        if ( !mXPagePropSet.is() )
+            break;
+
+        mXShapes = ::com::sun::star::uno::Reference<
+            ::com::sun::star::drawing::XShapes >
+                ( mXDrawPage, ::com::sun::star::uno::UNO_QUERY );
+        if ( !mXShapes.is() )
+            break;
+
+		/* try to get the "real" background PropertySet. If the normal page is not supporting this property, it is
+		   taken the property from the master */
+		sal_Bool bHasBackground = GetPropertyValue( aAny, mXPagePropSet, String( RTL_CONSTASCII_USTRINGPARAM( "Background" ) ), sal_True );
+		if ( bHasBackground )
+			bHasBackground = ( aAny >>= mXBackgroundPropSet );
+		if ( !bHasBackground )
+		{
+		    ::com::sun::star::uno::Reference< ::com::sun::star::drawing::XMasterPageTarget >
+				aXMasterPageTarget( mXDrawPage, ::com::sun::star::uno::UNO_QUERY );
+		    if ( aXMasterPageTarget.is() )
+			{
+				::com::sun::star::uno::Reference< ::com::sun::star::drawing::XDrawPage > aXMasterDrawPage;
+				aXMasterDrawPage = aXMasterPageTarget->getMasterPage();
+				if ( aXMasterDrawPage.is() )
+				{
+					::com::sun::star::uno::Reference< ::com::sun::star::beans::XPropertySet > aXMasterPagePropSet;
+					aXMasterPagePropSet = ::com::sun::star::uno::Reference< ::com::sun::star::beans::XPropertySet >
+						( aXMasterDrawPage, ::com::sun::star::uno::UNO_QUERY );
+					if ( aXMasterPagePropSet.is() )
+					{
+						sal_Bool bBackground = GetPropertyValue( aAny, aXMasterPagePropSet,
+								String( RTL_CONSTASCII_USTRINGPARAM( "Background" ) ) );
+						if ( bBackground )
+						{
+							aAny >>= mXBackgroundPropSet;
+						}
+					}
+				}
+			}
+		}
+        return TRUE;
+    }
+    return FALSE;
+}
+
+// ---------------------------------------------------------------------------------------------
+
+sal_Bool PPTWriter::ImplGetShapeByIndex( sal_uInt32 nIndex, sal_Bool bGroup )
+{
+    while(TRUE)
+    {
+        if (  ( bGroup == FALSE ) || ( GetCurrentGroupLevel() == 0 ) )
+        {
+            ::com::sun::star::uno::Any aAny( mXShapes->getByIndex( nIndex ) );
+            aAny >>= mXShape;
+        }
+        else
+        {
+            ::com::sun::star::uno::Any aAny( GetCurrentGroupAccess()->getByIndex( GetCurrentGroupIndex() ) );
+            aAny >>= mXShape;
+        }
+        if ( !mXShape.is() )
+            break;
+
+        ::com::sun::star::uno::Any aAny( mXShape->queryInterface( ::getCppuType( (const ::com::sun::star::uno::Reference< ::com::sun::star::beans::XPropertySet >*) 0 ) ));
+        aAny >>= mXPropSet;
+
+        if ( !mXPropSet.is() )
+            break;
+        maPosition = ImplMapPoint( mXShape->getPosition() );
+        maSize = ImplMapSize( mXShape->getSize() );
+        maRect = Rectangle( Point( maPosition.X, maPosition.Y ), Size( maSize.Width, maSize.Height ) );
+        mType = ByteString( String( mXShape->getShapeType() ), RTL_TEXTENCODING_UTF8 );
+        mType.Erase( 0, 13 );                                   // "com.sun.star." entfernen
+        sal_uInt16 nPos = mType.Search( (const char*)"Shape" );
+        mType.Erase( nPos, 5 );
+
+        mbPresObj = mbEmptyPresObj = FALSE;
+        if ( ImplGetPropertyValue( String( RTL_CONSTASCII_USTRINGPARAM( "IsPresentationObject" ) ) ) )
+            mAny >>= mbPresObj;
+
+        if ( mbPresObj && ImplGetPropertyValue( String( RTL_CONSTASCII_USTRINGPARAM( "IsEmptyPresentationObject" ) ) ) )
+            mAny >>= mbEmptyPresObj;
+
+        mnAngle = ( PropValue::GetPropertyValue( aAny,
+            mXPropSet, String( RTL_CONSTASCII_USTRINGPARAM( "RotateAngle" ) ), sal_True ) )
+                ? *((sal_Int32*)aAny.getValue() )
+                : 0;
+
+        return TRUE;
+    }
+    return FALSE;
+}
+
+//  -----------------------------------------------------------------------
+
+sal_uInt32 PPTWriter::ImplGetMasterIndex( PageType ePageType )
+{
+    sal_uInt32 nRetValue = 0;
+    ::com::sun::star::uno::Reference< ::com::sun::star::drawing::XMasterPageTarget >
+        aXMasterPageTarget( mXDrawPage, ::com::sun::star::uno::UNO_QUERY );
+
+    if ( aXMasterPageTarget.is() )
+    {
+        ::com::sun::star::uno::Reference< ::com::sun::star::drawing::XDrawPage >
+            aXDrawPage = aXMasterPageTarget->getMasterPage();
+        if ( aXDrawPage.is() )
+        {
+            ::com::sun::star::uno::Reference< ::com::sun::star::beans::XPropertySet >
+                aXPropertySet( aXDrawPage, ::com::sun::star::uno::UNO_QUERY );
+
+            if ( aXPropertySet.is() )
+            {
+                if ( ImplGetPropertyValue( aXPropertySet, String( RTL_CONSTASCII_USTRINGPARAM( "Number" ) ) ) )
+                    nRetValue |= *(sal_Int16*)mAny.getValue();
+                if ( nRetValue & 0xffff )           // ueberlauf vermeiden
+                    nRetValue--;
+            }
+        }
+    }
+    if ( ePageType == NOTICE )
+        nRetValue += mnMasterPages;
+    return nRetValue;
+}
+
+//  -----------------------------------------------------------------------
+
+sal_Bool PPTWriter::ImplGetStyleSheets()
+{
+    int             nInstance, nLevel;
+    sal_Bool        bRetValue = sal_False;
+	sal_uInt32		nPageNum;
+
+	for ( nPageNum = 0; nPageNum < mnMasterPages; nPageNum++ )
+	{
+		::com::sun::star::uno::Reference< ::com::sun::star::container::XNamed >
+			aXNamed;
+
+		::com::sun::star::uno::Reference< ::com::sun::star::container::XNameAccess >
+			aXNameAccess;
+
+		::com::sun::star::uno::Reference< ::com::sun::star::style::XStyleFamiliesSupplier >
+			aXStyleFamiliesSupplier( mXModel, ::com::sun::star::uno::UNO_QUERY );
+
+		::com::sun::star::uno::Reference< ::com::sun::star::beans::XPropertySet >
+			aXPropSet( mXModel, ::com::sun::star::uno::UNO_QUERY );
+
+		sal_uInt16 nDefaultTab = ( aXPropSet.is() && ImplGetPropertyValue( aXPropSet, String( RTL_CONSTASCII_USTRINGPARAM( "TabStop" ) ) ) )
+			? (sal_uInt16)( *(sal_Int32*)mAny.getValue() / 4.40972 )
+			: 1250;
+
+		maStyleSheetList.push_back( new PPTExStyleSheet( nDefaultTab, (PPTExBulletProvider&)*this ) );
+		ImplSetCurrentStyleSheet( nPageNum );
+		if ( ImplGetPageByIndex( nPageNum, MASTER ) )
+			aXNamed = ::com::sun::star::uno::Reference< ::com::sun::star::container::XNamed >
+						( mXDrawPage, ::com::sun::star::uno::UNO_QUERY );
+
+		if ( aXStyleFamiliesSupplier.is() )
+			aXNameAccess = aXStyleFamiliesSupplier->getStyleFamilies();
+
+		bRetValue = aXNamed.is() && aXNameAccess.is() && aXStyleFamiliesSupplier.is();
+		if  ( bRetValue )
+		{
+			for ( nInstance = EPP_TEXTTYPE_Title; nInstance <= EPP_TEXTTYPE_CenterTitle; nInstance++ )
+			{
+				String aStyle;
+				String aFamily;
+				switch ( nInstance )
+				{
+					case EPP_TEXTTYPE_CenterTitle :
+					case EPP_TEXTTYPE_Title :
+					{
+						aStyle = String( RTL_CONSTASCII_USTRINGPARAM( "title" ) );
+						aFamily = aXNamed->getName();
+					}
+					break;
+					case EPP_TEXTTYPE_Body :
+					{
+						aStyle = String( RTL_CONSTASCII_USTRINGPARAM( "outline1" ) );      // SD_LT_SEPARATOR
+						aFamily = aXNamed->getName();
+					}
+					break;
+					case EPP_TEXTTYPE_Other :
+					{
+						aStyle = String( RTL_CONSTASCII_USTRINGPARAM( "standard" ) );
+						aFamily = String( RTL_CONSTASCII_USTRINGPARAM( "graphics" ) );
+					}
+					break;
+					case EPP_TEXTTYPE_CenterBody :
+					{
+						aStyle = String( RTL_CONSTASCII_USTRINGPARAM( "subtitle" ) );
+						aFamily = aXNamed->getName();
+					}
+					break;
+				}
+				if ( aStyle.Len() && aFamily.Len() )
+				{
+					try
+					{
+						::com::sun::star::uno::Reference< ::com::sun::star::container::XNameAccess >xNameAccess;
+						if ( aXNameAccess->hasByName( aFamily ) )
+						{
+							::com::sun::star::uno::Any aAny( aXNameAccess->getByName( aFamily ) );
+							if( aAny.getValue() && ::cppu::extractInterface( xNameAccess, aAny ) )
+							{
+								::com::sun::star::uno::Reference< ::com::sun::star::container::XNameAccess > aXFamily;
+								if ( aAny >>= aXFamily )
+								{
+									if ( aXFamily->hasByName( aStyle ) )
+									{
+										::com::sun::star::uno::Reference< ::com::sun::star::style::XStyle > xStyle;
+										aAny = aXFamily->getByName( aStyle );
+										if( aAny.getValue() && ::cppu::extractInterface( xStyle, aAny ) )
+										{
+											::com::sun::star::uno::Reference< ::com::sun::star::style::XStyle > aXStyle;
+											aAny >>= aXStyle;
+											::com::sun::star::uno::Reference< ::com::sun::star::beans::XPropertySet >
+												xPropSet( aXStyle, ::com::sun::star::uno::UNO_QUERY );
+											if( xPropSet.is() )
+												mpStyleSheet->SetStyleSheet( xPropSet, maFontCollection, nInstance, 0 );
+											for ( nLevel = 1; nLevel < 5; nLevel++ )
+											{
+												if ( nInstance == EPP_TEXTTYPE_Body )
+												{
+													sal_Unicode cTemp = aStyle.GetChar( aStyle.Len() - 1 );
+													aStyle.SetChar( aStyle.Len() - 1, ++cTemp );
+													if ( aXFamily->hasByName( aStyle ) )
+													{
+														aXFamily->getByName( aStyle ) >>= xStyle;
+														if( xStyle.is() )
+														{
+															::com::sun::star::uno::Reference< ::com::sun::star::beans::XPropertySet >
+																xPropertySet( xStyle, ::com::sun::star::uno::UNO_QUERY );
+															if ( xPropertySet.is() )
+																mpStyleSheet->SetStyleSheet( xPropertySet, maFontCollection, nInstance, nLevel );
+														}
+													}
+												}
+												else
+													mpStyleSheet->SetStyleSheet( xPropSet, maFontCollection, nInstance, nLevel );
+											}
+										}
+									}
+								}
+							}
+						}
+					}
+					catch( ::com::sun::star::uno::Exception& )
+					{
+					//
+					}
+				}
+			}
+			for ( ; nInstance <= EPP_TEXTTYPE_QuarterBody; nInstance++ )
+			{
+
+			}
+		}
+	}
+    return bRetValue;
+}
+
+//  -----------------------------------------------------------------------
+
+void PPTWriter::ImplWriteParagraphs( SvStream& rOut, TextObj& rTextObj )
+{
+    sal_Bool            bFirstParagraph = TRUE;
+    sal_uInt32          nCharCount;
+    sal_uInt32          nPropertyFlags = 0;
+    sal_uInt16          nDepth = 0;
+    sal_Int16           nLineSpacing;
+    int                 nInstance = rTextObj.GetInstance();
+
+    for ( ParagraphObj* pPara = rTextObj.First() ; pPara; pPara = rTextObj.Next(), bFirstParagraph = FALSE )
+    {
+        PortionObj* pPortion = (PortionObj*)pPara->First();
+        nCharCount = pPara->Count();
+
+        nDepth = pPara->nDepth;
+        if ( nDepth > 4)
+            nDepth = 4;
+
+        if ( ( pPara->meTextAdjust == ::com::sun::star::beans::PropertyState_DIRECT_VALUE ) ||
+            ( mpStyleSheet->IsHardAttribute( nInstance, pPara->nDepth, ParaAttr_Adjust, pPara->mnTextAdjust ) ) )
+            nPropertyFlags |= 0x00000800;
+        nLineSpacing = pPara->mnLineSpacing;
+
+        const FontCollectionEntry* pDesc = maFontCollection.GetById( pPortion->mnFont );
+        sal_Int16 nNormalSpacing = 100;
+        if ( !mbFontIndependentLineSpacing && pDesc )
+        {
+            double fN = 100.0;
+            fN *= pDesc->Scaling;
+            nNormalSpacing = (sal_Int16)( fN + 0.5 );
+        }
+        if ( !mbFontIndependentLineSpacing && bFirstParagraph && ( nLineSpacing > nNormalSpacing ) )	// sj: i28747, no replacement for fixed linespacing
+        {
+            nLineSpacing = nNormalSpacing;
+            nPropertyFlags |= 0x00001000;
+        }
+        else
+        {
+            if ( nLineSpacing > 0 )
+            {
+                if ( !mbFontIndependentLineSpacing && pDesc )
+                     nLineSpacing = (sal_Int16)( (double)nLineSpacing * pDesc->Scaling + 0.5 );
+            }
+            else
+            {
+                if ( !pPara->mbFixedLineSpacing && pPortion && pPortion->mnCharHeight > (sal_uInt16)( ((double)-nLineSpacing) * 0.001 * 72.0 / 2.54 ) ) // 1/100mm to point
+                    nLineSpacing = nNormalSpacing;
+                else
+                    nLineSpacing = (sal_Int16)( (double)nLineSpacing / 4.40972 );
+            }
+            if ( ( pPara->meLineSpacing == ::com::sun::star::beans::PropertyState_DIRECT_VALUE ) ||
+                ( mpStyleSheet->IsHardAttribute( nInstance, pPara->nDepth, ParaAttr_LineFeed, nLineSpacing ) ) )
+                nPropertyFlags |= 0x00001000;
+        }
+        if ( ( pPara->meLineSpacingTop == ::com::sun::star::beans::PropertyState_DIRECT_VALUE ) ||
+            ( mpStyleSheet->IsHardAttribute( nInstance, pPara->nDepth, ParaAttr_UpperDist, pPara->mnLineSpacingTop ) ) )
+            nPropertyFlags |= 0x00002000;
+        if ( ( pPara->meLineSpacingBottom == ::com::sun::star::beans::PropertyState_DIRECT_VALUE ) ||
+            ( mpStyleSheet->IsHardAttribute( nInstance, pPara->nDepth, ParaAttr_LowerDist, pPara->mnLineSpacingBottom ) ) )
+            nPropertyFlags |= 0x00004000;
+        if ( ( pPara->meForbiddenRules == ::com::sun::star::beans::PropertyState_DIRECT_VALUE ) ||
+            ( mpStyleSheet->IsHardAttribute( nInstance, pPara->nDepth, ParaAttr_UpperDist, pPara->mbForbiddenRules ) ) )
+            nPropertyFlags |= 0x00020000;
+        if ( ( pPara->meParagraphPunctation == ::com::sun::star::beans::PropertyState_DIRECT_VALUE ) ||
+            ( mpStyleSheet->IsHardAttribute( nInstance, pPara->nDepth, ParaAttr_UpperDist, pPara->mbParagraphPunctation ) ) )
+            nPropertyFlags |= 0x00080000;
+		if ( ( pPara->meBiDi == ::com::sun::star::beans::PropertyState_DIRECT_VALUE ) ||
+			( mpStyleSheet->IsHardAttribute( nInstance, nDepth, ParaAttr_BiDi, pPara->mnBiDi ) ) )
+			nPropertyFlags |= 0x00200000;
+
+
+        sal_Int32 nBuRealSize = pPara->nBulletRealSize;
+        sal_Int16 nBulletFlags = pPara->nBulletFlags;
+
+        if ( pPara->bExtendedParameters )
+            nPropertyFlags |= pPara->nParaFlags;
+        else
+        {
+            nPropertyFlags |= 1;            // turn off bullet explicit
+            nBulletFlags = 0;
+        }
+        FontCollectionEntry aFontDescEntry( pPara->aFontDesc.Name, pPara->aFontDesc.Family, pPara->aFontDesc.Pitch, pPara->aFontDesc.CharSet );
+        sal_uInt16  nFontId = (sal_uInt16)maFontCollection.GetId( aFontDescEntry );
+
+        rOut << nCharCount
+             << nDepth                          // Level
+             << (sal_uInt32)nPropertyFlags;     // Paragraph Attribut Set
+
+        if ( nPropertyFlags & 0xf )
+            rOut << nBulletFlags;
+        if ( nPropertyFlags & 0x80 )
+            rOut << (sal_uInt16)( pPara->cBulletId );
+        if ( nPropertyFlags & 0x10 )
+            rOut << nFontId;
+        if ( nPropertyFlags & 0x40 )
+            rOut << (sal_Int16)nBuRealSize;
+        if ( nPropertyFlags & 0x20 )
+        {
+            sal_uInt32 nBulletColor = pPara->nBulletColor;
+            if ( nBulletColor == COL_AUTO )
+            {
+                sal_Bool bIsDark = sal_False;
+                ::com::sun::star::uno::Any aAny;
+                if ( PropValue::GetPropertyValue( aAny, mXPagePropSet, String( RTL_CONSTASCII_USTRINGPARAM( "IsBackgroundDark" ) ), sal_True ) )
+                    aAny >>= bIsDark;
+                nBulletColor = bIsDark ? 0xffffff : 0x000000;
+            }
+            nBulletColor &= 0xffffff;
+            nBulletColor |= 0xfe000000;
+            rOut << nBulletColor;
+        }
+        if ( nPropertyFlags & 0x00000800 )
+            rOut << (sal_uInt16)( pPara->mnTextAdjust );
+        if ( nPropertyFlags & 0x00001000 )
+            rOut << (sal_uInt16)( nLineSpacing );
+        if ( nPropertyFlags & 0x00002000 )
+            rOut << (sal_uInt16)( pPara->mnLineSpacingTop );
+        if ( nPropertyFlags & 0x00004000 )
+            rOut << (sal_uInt16)( pPara->mnLineSpacingBottom );
+        if ( nPropertyFlags & 0x000e0000 )
+        {
+            sal_uInt16 nAsianSettings = 0;
+            if ( pPara->mbForbiddenRules )
+                nAsianSettings |= 1;
+            if ( pPara->mbParagraphPunctation )
+                nAsianSettings |= 4;
+            rOut << nAsianSettings;
+        }
+		if ( nPropertyFlags & 0x200000 )
+			rOut << pPara->mnBiDi;
+    }
+}
+
+//  -----------------------------------------------------------------------
+
+void PPTWriter::ImplWritePortions( SvStream& rOut, TextObj& rTextObj )
+{
+    sal_uInt32  nPropertyFlags, i = 0;
+    int nInstance = rTextObj.GetInstance();
+
+    for ( ParagraphObj* pPara = rTextObj.First(); pPara; pPara = rTextObj.Next(), i++ )
+    {
+        for ( PortionObj* pPortion = (PortionObj*)pPara->First(); pPortion; pPortion = (PortionObj*)pPara->Next() )
+        {
+            nPropertyFlags = 0;
+            sal_uInt32 nCharAttr = pPortion->mnCharAttr;
+            sal_uInt32 nCharColor = pPortion->mnCharColor;
+
+            if ( nCharColor == COL_AUTO )   // nCharColor depends to the background color
+            {
+                sal_Bool bIsDark = sal_False;
+                ::com::sun::star::uno::Any aAny;
+                if ( PropValue::GetPropertyValue( aAny, mXPagePropSet, String( RTL_CONSTASCII_USTRINGPARAM( "IsBackgroundDark" ) ), sal_True ) )
+                    aAny >>= bIsDark;
+                nCharColor = bIsDark ? 0xffffff : 0x000000;
+            }
+
+            nCharColor &= 0xffffff;
+
+			/* the portion is using the embossed or engraved attribute, which we want to map to the relief feature of PPT.
+			Because the relief feature of PPT is dependent to the background color, such a mapping can not always be used. */
+			if ( nCharAttr & 0x200 )
+			{
+				sal_uInt32 nBackgroundColor = 0xffffff;
+
+				if ( !nCharColor )			// special threatment for
+					nCharColor = 0xffffff;	// black fontcolor
+
+				::com::sun::star::uno::Any aAny;
+				::com::sun::star::drawing::FillStyle aFS( ::com::sun::star::drawing::FillStyle_NONE );
+				if ( PropValue::GetPropertyValue( aAny, mXPropSet, String( RTL_CONSTASCII_USTRINGPARAM( "FillStyle" ) ) ) )
+					aAny >>= aFS;
+				switch( aFS )
+				{
+					case ::com::sun::star::drawing::FillStyle_GRADIENT :
+					{
+						Point aEmptyPoint = Point();
+						Rectangle aRect( aEmptyPoint, Size( 28000, 21000 ) );
+						EscherPropertyContainer aPropOpt( (EscherGraphicProvider&)*mpPptEscherEx, mpPicStrm, aRect );
+						aPropOpt.CreateGradientProperties( mXPropSet );
+						aPropOpt.GetOpt( ESCHER_Prop_fillColor, nBackgroundColor );
+					}
+					break;
+					case ::com::sun::star::drawing::FillStyle_SOLID :
+					{
+						if ( PropValue::GetPropertyValue( aAny, mXPropSet, String( RTL_CONSTASCII_USTRINGPARAM( "FillColor" ) ) ) )
+							nBackgroundColor = mpPptEscherEx->GetColor( *((sal_uInt32*)aAny.getValue()) );
+					}
+					break;
+					case ::com::sun::star::drawing::FillStyle_NONE :
+					{
+						::com::sun::star::uno::Any aBackAny;
+						::com::sun::star::drawing::FillStyle aBackFS( ::com::sun::star::drawing::FillStyle_NONE );
+						if ( PropValue::GetPropertyValue( aBackAny, mXBackgroundPropSet, String( RTL_CONSTASCII_USTRINGPARAM( "FillStyle" ) ) ) )
+							aBackAny >>= aBackFS;
+						switch( aBackFS )
+						{
+							case ::com::sun::star::drawing::FillStyle_GRADIENT :
+							{
+								Point aEmptyPoint = Point();
+								Rectangle aRect( aEmptyPoint, Size( 28000, 21000 ) );
+								EscherPropertyContainer aPropOpt( (EscherGraphicProvider&)*mpPptEscherEx, mpPicStrm, aRect );
+								aPropOpt.CreateGradientProperties( mXBackgroundPropSet );
+								aPropOpt.GetOpt( ESCHER_Prop_fillColor, nBackgroundColor );
+							}
+							break;
+							case ::com::sun::star::drawing::FillStyle_SOLID :
+							{
+								if ( PropValue::GetPropertyValue( aAny, mXBackgroundPropSet, String( RTL_CONSTASCII_USTRINGPARAM( "FillColor" ) ) ) )
+									nBackgroundColor = mpPptEscherEx->GetColor( *((sal_uInt32*)aAny.getValue()) );
+							}
+							break;
+							default:
+								break;
+						}
+					}
+					break;
+					default:
+						break;
+				}
+
+				sal_Int32 nB = nBackgroundColor & 0xff;
+				nB += (sal_uInt8)( nBackgroundColor >> 8  );
+				nB += (sal_uInt8)( nBackgroundColor >> 16 );
+				// if the background color is nearly black, relief can't been used, because the text would not be visible
+				if ( nB < 0x60 || ( nBackgroundColor != nCharColor ) )
+				{
+					nCharAttr &=~ 0x200;
+
+					// now check if the text is part of a group, and if the previous object has the same color than the fontcolor
+					// ( and if fillcolor is not available the background color ), it is sometimes
+					// not possible to export the 'embossed' flag
+					if ( ( GetCurrentGroupLevel() > 0 ) && ( GetCurrentGroupIndex() >= 1 ) )
+					{
+						::com::sun::star::uno::Reference< ::com::sun::star::drawing::XShape	> aGroupedShape( GetCurrentGroupAccess()->getByIndex( GetCurrentGroupIndex() - 1 ), uno::UNO_QUERY );
+						if( aGroupedShape.is() )
+						{
+							::com::sun::star::uno::Reference< ::com::sun::star::beans::XPropertySet > aPropSetOfNextShape
+								( aGroupedShape, ::com::sun::star::uno::UNO_QUERY );
+							if ( aPropSetOfNextShape.is() )
+							{
+								if ( PropValue::GetPropertyValue( aAny, aPropSetOfNextShape,
+													String( RTL_CONSTASCII_USTRINGPARAM( "FillColor" ) ), sal_True ) )
+								{
+									if ( nCharColor == mpPptEscherEx->GetColor( *((sal_uInt32*)aAny.getValue()) ) )
+									{
+										nCharAttr |= 0x200;
+									}
+								}
+							}
+						}
+					}
+				}
+			}
+            nCharColor |= 0xfe000000;
+            if ( nInstance == 4 )                       // special handling for normal textobjects:
+                nPropertyFlags |= nCharAttr & 0x217;    // not all attributes ar inherited
+            else
+            {
+                if ( /* ( pPortion->mnCharAttrHard & 1 ) || */
+                    ( mpStyleSheet->IsHardAttribute( nInstance, pPara->nDepth, CharAttr_Bold, nCharAttr ) ) )
+                    nPropertyFlags |= 1;
+                if ( /* ( pPortion->mnCharAttrHard & 2 ) || */
+                    ( mpStyleSheet->IsHardAttribute( nInstance, pPara->nDepth, CharAttr_Italic, nCharAttr ) ) )
+                    nPropertyFlags |= 2;
+                if ( /* ( pPortion->mnCharAttrHard & 4 ) || */
+                    ( mpStyleSheet->IsHardAttribute( nInstance, pPara->nDepth, CharAttr_Underline, nCharAttr ) ) )
+                    nPropertyFlags |= 4;
+                if ( /* ( pPortion->mnCharAttrHard & 0x10 ) || */
+                    ( mpStyleSheet->IsHardAttribute( nInstance, pPara->nDepth, CharAttr_Shadow, nCharAttr ) ) )
+                    nPropertyFlags |= 0x10;
+                if ( /* ( pPortion->mnCharAttrHard & 0x200 ) || */
+                    ( mpStyleSheet->IsHardAttribute( nInstance, pPara->nDepth, CharAttr_Embossed, nCharAttr ) ) )
+                    nPropertyFlags |= 512;
+            }
+            if ( rTextObj.HasExtendedBullets() )
+            {
+                nPropertyFlags |= ( i & 0x3f ) << 10 ;
+                nCharAttr  |= ( i & 0x3f ) << 10;
+            }
+            if ( ( pPortion->meFontName == ::com::sun::star::beans::PropertyState_DIRECT_VALUE ) ||
+                ( mpStyleSheet->IsHardAttribute( nInstance, pPara->nDepth, CharAttr_Font, pPortion->mnFont ) ) )
+                nPropertyFlags |= 0x00010000;
+            if ( ( pPortion->meAsianOrComplexFont == ::com::sun::star::beans::PropertyState_DIRECT_VALUE ) ||
+                ( mpStyleSheet->IsHardAttribute( nInstance, pPara->nDepth, CharAttr_AsianOrComplexFont, pPortion->mnAsianOrComplexFont ) ) )
+                nPropertyFlags |= 0x00200000;
+            if ( ( pPortion->meCharHeight == ::com::sun::star::beans::PropertyState_DIRECT_VALUE ) ||
+                ( mpStyleSheet->IsHardAttribute( nInstance, pPara->nDepth, CharAttr_FontHeight, pPortion->mnCharHeight ) ) )
+                nPropertyFlags |= 0x00020000;
+            if ( ( pPortion->meCharColor == ::com::sun::star::beans::PropertyState_DIRECT_VALUE ) ||
+                ( mpStyleSheet->IsHardAttribute( nInstance, pPara->nDepth, CharAttr_FontColor, nCharColor & 0xffffff ) ) )
+                nPropertyFlags |= 0x00040000;
+            if ( ( pPortion->meCharEscapement == ::com::sun::star::beans::PropertyState_DIRECT_VALUE ) ||
+                ( mpStyleSheet->IsHardAttribute( nInstance, pPara->nDepth, CharAttr_Escapement, pPortion->mnCharEscapement ) ) )
+                nPropertyFlags |= 0x00080000;
+
+            sal_uInt32 nCharCount = pPortion->Count();
+
+            rOut << nCharCount
+                 << nPropertyFlags;          //PropertyFlags
+
+            if ( nPropertyFlags & 0xffff )
+                rOut << (sal_uInt16)( nCharAttr );
+            if ( nPropertyFlags & 0x00010000 )
+                rOut << pPortion->mnFont;
+            if ( nPropertyFlags & 0x00200000 )
+                rOut << pPortion->mnAsianOrComplexFont;
+            if ( nPropertyFlags & 0x00020000 )
+                rOut << (sal_uInt16)( pPortion->mnCharHeight );
+            if ( nPropertyFlags & 0x00040000 )
+                rOut << (sal_uInt32)nCharColor;
+            if ( nPropertyFlags & 0x00080000 )
+                rOut << pPortion->mnCharEscapement;
+        }
+    }
+}
+
+//  ----------------------------------------------------------------------------------------
+//  laedt und konvertiert text aus shape, ergebnis ist mnTextSize gespeichert;
+sal_Bool PPTWriter::ImplGetText()
+{
+    mnTextSize = 0;
+	mbFontIndependentLineSpacing = sal_False;
+    mXText = ::com::sun::star::uno::Reference<
+        ::com::sun::star::text::XSimpleText >
+            ( mXShape, ::com::sun::star::uno::UNO_QUERY );
+
+    if ( mXText.is() )
+	{
+        mnTextSize = mXText->getString().getLength();
+		::com::sun::star::uno::Any aAny;
+		if ( GetPropertyValue( aAny, mXPropSet, String( RTL_CONSTASCII_USTRINGPARAM( "FontIndependentLineSpacing" ) ) ), sal_True )
+			aAny >>= mbFontIndependentLineSpacing;
+	}
+    return ( mnTextSize != 0 );
+}
+
+//  -----------------------------------------------------------------------
+
+void PPTWriter::ImplFlipBoundingBox( EscherPropertyContainer& rPropOpt )
+{
+    if ( mnAngle < 0 )
+        mnAngle = ( 36000 + mnAngle ) % 36000;
+    else
+        mnAngle = ( 36000 - ( mnAngle % 36000 ) );
+
+    double  fCos = cos( (double)mnAngle * F_PI18000 );
+    double  fSin = sin( (double)mnAngle * F_PI18000 );
+
+    double  fWidthHalf = maRect.GetWidth() / 2;
+    double  fHeightHalf = maRect.GetHeight() / 2;
+
+    double  fXDiff = fCos * fWidthHalf + fSin * (-fHeightHalf);
+    double  fYDiff = - ( fSin * fWidthHalf - fCos * ( -fHeightHalf ) );
+
+    maRect.Move( (sal_Int32)( -( fWidthHalf - fXDiff ) ), (sal_Int32)(  - ( fHeightHalf + fYDiff ) ) );
+    mnAngle *= 655;
+    mnAngle += 0x8000;
+    mnAngle &=~0xffff;                                  // nAngle auf volle Gradzahl runden
+    rPropOpt.AddOpt( ESCHER_Prop_Rotation, mnAngle );
+
+    if ( ( mnAngle >= ( 45 << 16 ) && mnAngle < ( 135 << 16 ) ) ||
+            ( mnAngle >= ( 225 << 16 ) && mnAngle < ( 315 << 16 ) ) )
+    {
+        // In diesen beiden Bereichen steht in PPT gemeinerweise die
+        // BoundingBox bereits senkrecht. Daher muss diese VOR
+        // DER ROTATION flachgelegt werden.
+        ::com::sun::star::awt::Point
+            aTopLeft( (sal_Int32)( maRect.Left() + fWidthHalf - fHeightHalf ), (sal_Int32)( maRect.Top() + fHeightHalf - fWidthHalf ) );
+        Size    aNewSize( maRect.GetHeight(), maRect.GetWidth() );
+        maRect = Rectangle( Point( aTopLeft.X, aTopLeft.Y ), aNewSize );
+    }
+}
+
+//  -----------------------------------------------------------------------
+
+struct FieldEntry
+{
+    sal_uInt32  nFieldType;
+    sal_uInt32  nFieldStartPos;
+    sal_uInt32  nFieldEndPos;
+	String		aRepresentation;
+    String      aFieldUrl;
+
+    FieldEntry( sal_uInt32 nType, sal_uInt32 nStart, sal_uInt32 nEnd )
+    {
+        nFieldType = nType;
+        nFieldStartPos = nStart;
+        nFieldEndPos = nEnd;
+    }
+};
+
+//  -----------------------------------------------------------------------
+
+PortionObj::PortionObj( const ::com::sun::star::uno::Reference< ::com::sun::star::beans::XPropertySet > & rXPropSet,
+                FontCollection& rFontCollection ) :
+    mnCharAttrHard      ( 0 ),
+    mnCharAttr          ( 0 ),
+	mnFont              ( 0 ),
+	mnAsianOrComplexFont( 0xffff ),
+    mnTextSize          ( 0 ),
+	mbLastPortion       ( TRUE ),
+    mpText              ( NULL ),
+    mpFieldEntry        ( NULL )
+{
+    mXPropSet = rXPropSet;
+
+    ImplGetPortionValues( rFontCollection, FALSE );
+}
+
+PortionObj::PortionObj( ::com::sun::star::uno::Reference< ::com::sun::star::text::XTextRange > & rXTextRange,
+                            sal_Bool bLast, FontCollection& rFontCollection ) :
+    mnCharAttrHard          ( 0 ),
+    mnCharAttr              ( 0 ),
+    mnFont                  ( 0 ),
+    mnAsianOrComplexFont    ( 0xffff ),
+	mbLastPortion           ( bLast ),
+    mpText                  ( NULL ),
+    mpFieldEntry            ( NULL )
+{
+    String aString( rXTextRange->getString() );
+    String aURL;
+	BOOL bRTL_endingParen = FALSE;
+
+    mnTextSize = aString.Len();
+    if ( bLast )
+        mnTextSize++;
+
+    if ( mnTextSize )
+    {
+        mpFieldEntry = NULL;
+        sal_uInt32 nFieldType = 0;
+
+        mXPropSet = ::com::sun::star::uno::Reference<
+            ::com::sun::star::beans::XPropertySet >
+                ( rXTextRange, ::com::sun::star::uno::UNO_QUERY );
+        mXPropState = ::com::sun::star::uno::Reference<
+            ::com::sun::star::beans::XPropertyState >
+                ( rXTextRange, ::com::sun::star::uno::UNO_QUERY );
+
+        sal_Bool bPropSetsValid = ( mXPropSet.is() && mXPropState.is() );
+        if ( bPropSetsValid )
+            nFieldType = ImplGetTextField( rXTextRange, mXPropSet, aURL );
+        if ( nFieldType )
+        {
+            mpFieldEntry = new FieldEntry( nFieldType, 0, mnTextSize );
+            if ( ( nFieldType >> 28 == 4 ) )
+			{
+				mpFieldEntry->aRepresentation = aString;
+                mpFieldEntry->aFieldUrl = aURL;
+			}
+        }
+        sal_Bool bSymbol = FALSE;
+
+        if ( bPropSetsValid && ImplGetPropertyValue( String( RTL_CONSTASCII_USTRINGPARAM( "CharFontCharSet" ) ), FALSE ) )
+        {
+            sal_Int16 nCharset;
+            mAny >>= nCharset;
+            if ( nCharset == ::com::sun::star::awt::CharSet::SYMBOL )
+                bSymbol = TRUE;
+        }
+        if ( mpFieldEntry && ( nFieldType & 0x800000 ) )    // placeholder ?
+        {
+            mnTextSize = 1;
+            if ( bLast )
+                mnTextSize++;
+            mpText = new sal_uInt16[ mnTextSize ];
+            mpText[ 0 ] = 0x2a;
+        }
+        else
+        {
+            const sal_Unicode* pText = aString.GetBuffer();
+			// For i39516 - a closing parenthesis that ends an RTL string is displayed backwards by PPT
+			// Solution: add a Unicode Right-to-Left Mark, following the method described in i18024
+			if ( bLast && pText[ aString.Len() - 1 ] == sal_Unicode(')') && rFontCollection.GetScriptDirection( aString ) == com::sun::star::i18n::ScriptDirection::RIGHT_TO_LEFT )
+			{
+				mnTextSize++;
+				bRTL_endingParen = TRUE;
+			}
+            mpText = new sal_uInt16[ mnTextSize ];
+            sal_uInt16 nChar;
+            for ( int i = 0; i < aString.Len(); i++ )
+            {
+                nChar = (sal_uInt16)pText[ i ];
+                if ( nChar == 0xa )
+                    nChar++;
+                else if ( !bSymbol )
+                {
+                    switch ( nChar )
+                    {
+                        // Currency
+                        case 128:   nChar = 0x20AC; break;
+                        // Punctuation and other
+                        case 130:   nChar = 0x201A; break;// SINGLE LOW-9 QUOTATION MARK
+                        case 131:   nChar = 0x0192; break;// LATIN SMALL LETTER F WITH HOOK
+                        case 132:   nChar = 0x201E; break;// DOUBLE LOW-9 QUOTATION MARK
+                                                              // LOW DOUBLE PRIME QUOTATION MARK
+                        case 133:   nChar = 0x2026; break;// HORIZONTAL ELLIPSES
+                        case 134:   nChar = 0x2020; break;// DAGGER
+                        case 135:   nChar = 0x2021; break;// DOUBLE DAGGER
+                        case 136:   nChar = 0x02C6; break;// MODIFIER LETTER CIRCUMFLEX ACCENT
+                        case 137:   nChar = 0x2030; break;// PER MILLE SIGN
+                        case 138:   nChar = 0x0160; break;// LATIN CAPITAL LETTER S WITH CARON
+                        case 139:   nChar = 0x2039; break;// SINGLE LEFT-POINTING ANGLE QUOTATION MARK
+                        case 140:   nChar = 0x0152; break;// LATIN CAPITAL LIGATURE OE
+                        case 142:   nChar = 0x017D; break;// LATIN CAPITAL LETTER Z WITH CARON
+                        case 145:   nChar = 0x2018; break;// LEFT SINGLE QUOTATION MARK
+                                                              // MODIFIER LETTER TURNED COMMA
+                        case 146:   nChar = 0x2019; break;// RIGHT SINGLE QUOTATION MARK
+                                                              // MODIFIER LETTER APOSTROPHE
+                        case 147:   nChar = 0x201C; break;// LEFT DOUBLE QUOTATION MARK
+                                                              // REVERSED DOUBLE PRIME QUOTATION MARK
+                        case 148:   nChar = 0x201D; break;// RIGHT DOUBLE QUOTATION MARK
+                                                              // REVERSED DOUBLE PRIME QUOTATION MARK
+                        case 149:   nChar = 0x2022; break;// BULLET
+                        case 150:   nChar = 0x2013; break;// EN DASH
+                        case 151:   nChar = 0x2014; break;// EM DASH
+                        case 152:   nChar = 0x02DC; break;// SMALL TILDE
+                        case 153:   nChar = 0x2122; break;// TRADE MARK SIGN
+                        case 154:   nChar = 0x0161; break;// LATIN SMALL LETTER S WITH CARON
+                        case 155:   nChar = 0x203A; break;// SINGLE RIGHT-POINTING ANGLE QUOTATION MARK
+                        case 156:   nChar = 0x0153; break;// LATIN SMALL LIGATURE OE
+                        case 158:   nChar = 0x017E; break;// LATIN SMALL LETTER Z WITH CARON
+                        case 159:   nChar = 0x0178; break;// LATIN CAPITAL LETTER Y WITH DIAERESIS
+//                      case 222:   nChar = 0x00B6; break;// PILCROW SIGN / PARAGRAPH SIGN
+                    }
+                }
+                mpText[ i ] = nChar;
+            }
+        }
+		if ( bRTL_endingParen )
+            mpText[ mnTextSize - 2 ] = 0x200F; // Unicode Right-to-Left mark
+
+        if ( bLast )
+            mpText[ mnTextSize - 1 ] = 0xd;
+
+        if ( bPropSetsValid )
+            ImplGetPortionValues( rFontCollection, TRUE );
+    }
+}
+
+PortionObj::PortionObj( PortionObj& rPortionObj )
+: PropStateValue( rPortionObj )
+{
+    ImplConstruct( rPortionObj );
+}
+
+PortionObj::~PortionObj()
+{
+    ImplClear();
+}
+
+void PortionObj::Write( SvStream* pStrm, sal_Bool bLast )
+{
+    sal_uInt32 nCount = mnTextSize;
+    if ( bLast && mbLastPortion )
+        nCount--;
+    for ( sal_uInt32 i = 0; i < nCount; i++ )
+        *pStrm << (sal_uInt16)mpText[ i ];
+}
+
+void PortionObj::ImplGetPortionValues( FontCollection& rFontCollection, sal_Bool bGetPropStateValue )
+{
+
+    sal_Bool bOk = ImplGetPropertyValue( String( RTL_CONSTASCII_USTRINGPARAM( "CharFontName" ) ), bGetPropStateValue );
+    meFontName = ePropState;
+    if ( bOk )
+    {
+        FontCollectionEntry aFontDesc( *(::rtl::OUString*)mAny.getValue() );
+        sal_uInt32  nCount = rFontCollection.GetCount();
+        mnFont = (sal_uInt16)rFontCollection.GetId( aFontDesc );
+        if ( mnFont == nCount )
+        {
+            FontCollectionEntry& rFontDesc = rFontCollection.GetLast();
+            if ( ImplGetPropertyValue( String( RTL_CONSTASCII_USTRINGPARAM( "CharFontCharSet" ) ), sal_False ) )
+                mAny >>= rFontDesc.CharSet;
+            if ( ImplGetPropertyValue( String( RTL_CONSTASCII_USTRINGPARAM( "CharFontFamily" ) ), sal_False ) )
+                mAny >>= rFontDesc.Family;
+            if ( ImplGetPropertyValue( String( RTL_CONSTASCII_USTRINGPARAM( "CharFontPitch" ) ), sal_False ) )
+                mAny >>= rFontDesc.Pitch;
+        }
+    }
+
+	sal_Int16 nScriptType = SvtLanguageOptions::GetScriptTypeOfLanguage( Application::GetSettings().GetLanguage() );
+	if ( mpText && mnTextSize && xPPTBreakIter.is() )
+	{
+		rtl::OUString sT( mpText, mnTextSize );
+		nScriptType = xPPTBreakIter->getScriptType( sT, 0 );
+	}
+	if ( nScriptType != com::sun::star::i18n::ScriptType::COMPLEX )
+	{
+		bOk = ImplGetPropertyValue( String( RTL_CONSTASCII_USTRINGPARAM( "CharFontNameAsian" ) ), bGetPropStateValue );
+		meAsianOrComplexFont = ePropState;
+		if ( bOk )
+		{
+			FontCollectionEntry aFontDesc( *(::rtl::OUString*)mAny.getValue() );
+			sal_uInt32  nCount = rFontCollection.GetCount();
+			mnAsianOrComplexFont = (sal_uInt16)rFontCollection.GetId( aFontDesc );
+			if ( mnAsianOrComplexFont == nCount )
+			{
+				FontCollectionEntry& rFontDesc = rFontCollection.GetLast();
+				if ( ImplGetPropertyValue( String( RTL_CONSTASCII_USTRINGPARAM( "CharFontCharSetAsian" ) ), sal_False ) )
+					mAny >>= rFontDesc.CharSet;
+				if ( ImplGetPropertyValue( String( RTL_CONSTASCII_USTRINGPARAM( "CharFontFamilyAsian" ) ), sal_False ) )
+					mAny >>= rFontDesc.Family;
+				if ( ImplGetPropertyValue( String( RTL_CONSTASCII_USTRINGPARAM( "CharFontPitchAsian" ) ), sal_False ) )
+					mAny >>= rFontDesc.Pitch;
+			}
+		}
+	}
+	else
+	{
+		bOk = ImplGetPropertyValue( String( RTL_CONSTASCII_USTRINGPARAM( "CharFontNameComplex" ) ), bGetPropStateValue );
+		meAsianOrComplexFont = ePropState;
+		if ( bOk )
+		{
+			FontCollectionEntry aFontDesc( *(::rtl::OUString*)mAny.getValue() );
+			sal_uInt32  nCount = rFontCollection.GetCount();
+			mnAsianOrComplexFont = (sal_uInt16)rFontCollection.GetId( aFontDesc );
+			if ( mnAsianOrComplexFont == nCount )
+			{
+				FontCollectionEntry& rFontDesc = rFontCollection.GetLast();
+				if ( ImplGetPropertyValue( String( RTL_CONSTASCII_USTRINGPARAM( "CharFontCharSetComplex" ) ), sal_False ) )
+					mAny >>= rFontDesc.CharSet;
+				if ( ImplGetPropertyValue( String( RTL_CONSTASCII_USTRINGPARAM( "CharFontFamilyComplex" ) ), sal_False ) )
+					mAny >>= rFontDesc.Family;
+				if ( ImplGetPropertyValue( String( RTL_CONSTASCII_USTRINGPARAM( "CharFontPitchComplex" ) ), sal_False ) )
+					mAny >>= rFontDesc.Pitch;
+			}
+		}
+	}
+
+	if ( nScriptType != com::sun::star::i18n::ScriptType::COMPLEX )
+	{
+	    if ( ImplGetPropertyValue( String( RTL_CONSTASCII_USTRINGPARAM( "CharWeight" ) ), bGetPropStateValue ) )
+	    {
+		float fFloat;
+		mAny >>= fFloat;
+		if ( fFloat >= ::com::sun::star::awt::FontWeight::SEMIBOLD )
+		    mnCharAttr |= 1;
+	    }
+	}
+	else
+	{
+	    if ( ImplGetPropertyValue( String( RTL_CONSTASCII_USTRINGPARAM( "CharWeightComplex" ) ), bGetPropStateValue ) )
+	    {
+		float fFloat;
+		mAny >>= fFloat;
+		if ( fFloat >= ::com::sun::star::awt::FontWeight::SEMIBOLD )
+		    mnCharAttr |= 1;
+	    }
+	}
+
+    if ( ePropState == ::com::sun::star::beans::PropertyState_DIRECT_VALUE )
+        mnCharAttrHard |= 1;
+
+	if ( nScriptType != com::sun::star::i18n::ScriptType::COMPLEX )
+	{
+		if ( ImplGetPropertyValue( String( RTL_CONSTASCII_USTRINGPARAM( "CharPosture" ) ), bGetPropStateValue ) )
+		{
+			::com::sun::star::awt::FontSlant aFS;
+			mAny >>= aFS;
+			switch ( aFS )
+			{
+			    case ::com::sun::star::awt::FontSlant_OBLIQUE :
+			    case ::com::sun::star::awt::FontSlant_ITALIC :
+					mnCharAttr |= 2;
+					break;
+				default:
+					break;
+			}
+		}
+	}
+	else
+	{
+		if ( ImplGetPropertyValue( String( RTL_CONSTASCII_USTRINGPARAM( "CharPostureComplex" ) ), bGetPropStateValue ) )
+		{
+			::com::sun::star::awt::FontSlant aFS;
+			mAny >>= aFS;
+			switch ( aFS )
+			{
+			    case ::com::sun::star::awt::FontSlant_OBLIQUE :
+			    case ::com::sun::star::awt::FontSlant_ITALIC :
+					mnCharAttr |= 2;
+					break;
+				default:
+					break;
+			}
+		}
+	}
+
+	if ( ePropState == ::com::sun::star::beans::PropertyState_DIRECT_VALUE )
+        mnCharAttrHard |= 2;
+
+    if ( ImplGetPropertyValue( String( RTL_CONSTASCII_USTRINGPARAM( "CharUnderline" ) ), bGetPropStateValue ) )
+    {
+        sal_Int16 nVal;
+        mAny >>= nVal;
+        switch ( nVal )
+        {
+            case ::com::sun::star::awt::FontUnderline::SINGLE :
+            case ::com::sun::star::awt::FontUnderline::DOUBLE :
+            case ::com::sun::star::awt::FontUnderline::DOTTED :
+                mnCharAttr |= 4;
+        }
+    }
+    if ( ePropState == ::com::sun::star::beans::PropertyState_DIRECT_VALUE )
+        mnCharAttrHard |= 4;
+
+    if ( ImplGetPropertyValue( String( RTL_CONSTASCII_USTRINGPARAM( "CharShadowed" ) ), bGetPropStateValue ) )
+    {
+        sal_Bool bBool;
+        mAny >>= bBool;
+        if ( bBool )
+            mnCharAttr |= 0x10;
+    }
+    if ( ePropState == ::com::sun::star::beans::PropertyState_DIRECT_VALUE )
+        mnCharAttrHard |= 16;
+
+	if ( ImplGetPropertyValue( String( RTL_CONSTASCII_USTRINGPARAM( "CharLocale" ) ), bGetPropStateValue ) )
+	{
+		com::sun::star::lang::Locale eLocale;
+		if ( mAny >>= eLocale )
+			meCharLocale = eLocale;
+	}
+
+    if ( ImplGetPropertyValue( String( RTL_CONSTASCII_USTRINGPARAM( "CharRelief" ) ), bGetPropStateValue ) )
+    {
+        sal_Int16 nVal;
+        mAny >>= nVal;
+        if ( nVal != ::com::sun::star::text::FontRelief::NONE )
+            mnCharAttr |= 512;
+    }
+    if ( ePropState == ::com::sun::star::beans::PropertyState_DIRECT_VALUE )
+        mnCharAttrHard |= 512;
+
+    mnCharHeight = 24;
+    if ( ImplGetPropertyValue( String( RTL_CONSTASCII_USTRINGPARAM( "CharHeight" ) ), bGetPropStateValue ) )
+    {
+        float fVal;
+        mAny >>= fVal;
+        mnCharHeight = (sal_uInt16)( fVal + 0.5 );
+    }
+    meCharHeight = ePropState;
+
+    if ( ImplGetPropertyValue( String( RTL_CONSTASCII_USTRINGPARAM( "CharColor" ) ), bGetPropStateValue ) )
+    {
+        sal_uInt32 nSOColor = *( (sal_uInt32*)mAny.getValue() );
+        mnCharColor = nSOColor & 0xff00ff00;                            // green and hibyte
+        mnCharColor |= (sal_uInt8)( nSOColor ) << 16;                   // red and blue is switched
+        mnCharColor |= (sal_uInt8)( nSOColor >> 16 );
+    }
+    meCharColor = ePropState;
+
+    mnCharEscapement = 0;
+    if ( ImplGetPropertyValue( String( RTL_CONSTASCII_USTRINGPARAM( "CharEscapement" ) ), bGetPropStateValue ) )
+    {
+        mAny >>= mnCharEscapement;
+        if ( mnCharEscapement > 100 )
+            mnCharEscapement = 33;
+        else if ( mnCharEscapement < -100 )
+            mnCharEscapement = -33;
+    }
+    meCharEscapement = ePropState;
+}
+
+void PortionObj::ImplClear()
+{
+    delete (FieldEntry*)mpFieldEntry;
+    delete[] mpText;
+}
+
+void PortionObj::ImplConstruct( PortionObj& rPortionObj )
+{
+    mbLastPortion = rPortionObj.mbLastPortion;
+    mnTextSize = rPortionObj.mnTextSize;
+    mnCharColor = rPortionObj.mnCharColor;
+    mnCharEscapement = rPortionObj.mnCharEscapement;
+    mnCharAttr = rPortionObj.mnCharAttr;
+    mnCharHeight = rPortionObj.mnCharHeight;
+    mnFont = rPortionObj.mnFont;
+    mnAsianOrComplexFont = rPortionObj.mnAsianOrComplexFont;
+
+    if ( rPortionObj.mpText )
+    {
+        mpText = new sal_uInt16[ mnTextSize ];
+        memcpy( mpText, rPortionObj.mpText, mnTextSize << 1 );
+    }
+    else
+        mpText = NULL;
+
+    if ( rPortionObj.mpFieldEntry )
+        mpFieldEntry = new FieldEntry( *( rPortionObj.mpFieldEntry ) );
+    else
+        mpFieldEntry = NULL;
+}
+
+sal_uInt32 PortionObj::ImplCalculateTextPositions( sal_uInt32 nCurrentTextPosition )
+{
+    if ( mpFieldEntry && ( !mpFieldEntry->nFieldStartPos ) )
+    {
+        mpFieldEntry->nFieldStartPos += nCurrentTextPosition;
+        mpFieldEntry->nFieldEndPos += nCurrentTextPosition;
+    }
+    return mnTextSize;
+}
+
+//  -----------------------------------------------------------------------
+// Rueckgabe:                           0 = kein TextField
+//  bit28->31   text field type :
+//                                      1 = Date
+//                                      2 = Time
+//                                      3 = SlideNumber
+//                                      4 = Url
+//										5 = DateTime
+//										6 = header
+//										7 = footer
+//  bit24->27   text field sub type	(optional)
+//     23->     PPT Textfield needs a placeholder
+
+sal_uInt32 PortionObj::ImplGetTextField( ::com::sun::star::uno::Reference< ::com::sun::star::text::XTextRange > & ,
+	const ::com::sun::star::uno::Reference< ::com::sun::star::beans::XPropertySet > & rXPropSet, String& rURL )
+{
+    sal_uInt32 nRetValue = 0;
+    sal_Int32 nFormat;
+	::com::sun::star::uno::Any aAny;
+	if ( GetPropertyValue( aAny, rXPropSet, String( RTL_CONSTASCII_USTRINGPARAM( "TextPortionType" ) ), sal_True ) )
+	{
+		String  aTextFieldType( *(::rtl::OUString*)aAny.getValue() );
+		if ( aTextFieldType == String( RTL_CONSTASCII_USTRINGPARAM( "TextField" ) ) )
+		{
+			if ( GetPropertyValue( aAny, rXPropSet, aTextFieldType, sal_True ) )
+			{
+				::com::sun::star::uno::Reference< ::com::sun::star::text::XTextField > aXTextField;
+				if ( aAny >>= aXTextField )
+				{
+					if ( aXTextField.is() )
+					{
+						::com::sun::star::uno::Reference< ::com::sun::star::beans::XPropertySet >
+							xFieldPropSet( aXTextField, ::com::sun::star::uno::UNO_QUERY );
+						if ( xFieldPropSet.is() )
+						{
+							String aFieldKind( aXTextField->getPresentation( TRUE ) );
+							if ( aFieldKind == String( RTL_CONSTASCII_USTRINGPARAM( "Date" ) ) )
+							{
+								if ( GetPropertyValue( aAny, xFieldPropSet, String( RTL_CONSTASCII_USTRINGPARAM( "IsFix" ) ) ), sal_True )
+								{
+									sal_Bool bBool;
+									aAny >>= bBool;
+									if ( !bBool )  // Fixed DateFields gibt es in PPT nicht
+									{
+										if ( GetPropertyValue( aAny, xFieldPropSet, String( RTL_CONSTASCII_USTRINGPARAM( "Format" ) ) ), sal_True )
+										{
+											nFormat = *(sal_Int32*)aAny.getValue();
+											switch ( nFormat )
+											{
+												default:
+												case 5 :
+												case 4 :
+												case 2 : nFormat = 0; break;
+												case 8 :
+												case 9 :
+												case 3 : nFormat = 1; break;
+												case 7 :
+												case 6 : nFormat = 2; break;
+											}
+											nRetValue |= ( ( ( 1 << 4 ) | nFormat ) << 24 ) | 0x800000;
+										}
+									}
+								}
+							}
+							else if ( aFieldKind == String( RTL_CONSTASCII_USTRINGPARAM( "URL" ) ) )
+							{
+								if ( GetPropertyValue( aAny, xFieldPropSet, String( RTL_CONSTASCII_USTRINGPARAM( "URL" ) ) ), sal_True )
+									rURL = String( *(::rtl::OUString*)aAny.getValue() );
+								nRetValue = 4 << 28;
+							}
+							else if ( aFieldKind == String( RTL_CONSTASCII_USTRINGPARAM( "Page" ) ) )
+							{
+								nRetValue = 3 << 28 | 0x800000;
+							}
+							else if ( aFieldKind == String( RTL_CONSTASCII_USTRINGPARAM( "Pages" ) ) )
+							{
+
+							}
+							else if ( aFieldKind == String( RTL_CONSTASCII_USTRINGPARAM( "Time" ) ) )
+							{
+								if ( GetPropertyValue( aAny, xFieldPropSet, String( RTL_CONSTASCII_USTRINGPARAM( "IsFix" ) ) ), sal_True )
+								{
+									sal_Bool bBool;
+									aAny >>= bBool;
+									if ( !bBool )
+									{
+										if ( GetPropertyValue( aAny, xFieldPropSet, String( RTL_CONSTASCII_USTRINGPARAM( "IsFix" ) ) ), sal_True )
+										{
+											nFormat = *(sal_Int32*)aAny.getValue();
+											nRetValue |= ( ( ( 2 << 4 ) | nFormat ) << 24 ) | 0x800000;
+										}
+									}
+								}
+							}
+							else if ( aFieldKind == String( RTL_CONSTASCII_USTRINGPARAM( "File" ) ) )
+							{
+
+							}
+							else if ( aFieldKind == String( RTL_CONSTASCII_USTRINGPARAM( "Table" ) ) )
+							{
+
+							}
+							else if ( aFieldKind == String( RTL_CONSTASCII_USTRINGPARAM( "ExtTime" ) ) )
+							{
+								if ( GetPropertyValue( aAny, xFieldPropSet, String( RTL_CONSTASCII_USTRINGPARAM( "IsFix" ) ) ), sal_True )
+								{
+									sal_Bool bBool;
+									aAny >>= bBool;
+									if ( !bBool )
+									{
+										if ( GetPropertyValue( aAny, xFieldPropSet, String( RTL_CONSTASCII_USTRINGPARAM( "Format" ) ) ), sal_True )
+										{
+											nFormat = *(sal_Int32*)aAny.getValue();
+											switch ( nFormat )
+											{
+												default:
+												case 6 :
+												case 7 :
+												case 8 :
+												case 2 : nFormat = 12; break;
+												case 3 : nFormat = 9; break;
+												case 5 :
+												case 4 : nFormat = 10; break;
+
+											}
+											nRetValue |= ( ( ( 2 << 4 ) | nFormat ) << 24 ) | 0x800000;
+										}
+									}
+								}
+							}
+							else if ( aFieldKind == String( RTL_CONSTASCII_USTRINGPARAM( "ExtFile" ) ) )
+							{
+
+							}
+							else if ( aFieldKind ==  String( RTL_CONSTASCII_USTRINGPARAM( "Author" ) ) )
+							{
+
+							}
+							else if ( aFieldKind == String( RTL_CONSTASCII_USTRINGPARAM( "DateTime" ) ) )
+							{
+								nRetValue = 5 << 28 | 0x800000;
+							}
+							else if ( aFieldKind == String( RTL_CONSTASCII_USTRINGPARAM( "Header" ) ) )
+							{
+								nRetValue = 6 << 28 | 0x800000;
+							}
+							else if ( aFieldKind == String( RTL_CONSTASCII_USTRINGPARAM( "Footer" ) ) )
+							{
+								nRetValue = 7 << 28 | 0x800000;
+							}
+						}
+					}
+				}
+			}
+		}
+	}
+    return nRetValue;
+}
+
+PortionObj& PortionObj::operator=( PortionObj& rPortionObj )
+{
+    if ( this != &rPortionObj )
+    {
+        ImplClear();
+        ImplConstruct( rPortionObj );
+    }
+    return *this;
+}
+
+//  -----------------------------------------------------------------------
+
+ParagraphObj::ParagraphObj( const ::com::sun::star::uno::Reference< ::com::sun::star::beans::XPropertySet > & rXPropSet,
+                PPTExBulletProvider& rProv ) :
+    maMapModeSrc        ( MAP_100TH_MM ),
+    maMapModeDest       ( MAP_INCH, Point(), Fraction( 1, 576 ), Fraction( 1, 576 ) )
+{
+    mXPropSet = rXPropSet;
+
+    bExtendedParameters = FALSE;
+
+    nDepth = 0;
+    nBulletFlags = 0;
+    nParaFlags = 0;
+
+    ImplGetParagraphValues( rProv, FALSE );
+}
+
+    ParagraphObj::ParagraphObj( ::com::sun::star::uno::Reference< ::com::sun::star::text::XTextContent > & rXTextContent,
+                    ParaFlags aParaFlags, FontCollection& rFontCollection, PPTExBulletProvider& rProv ) :
+    maMapModeSrc        ( MAP_100TH_MM ),
+    maMapModeDest       ( MAP_INCH, Point(), Fraction( 1, 576 ), Fraction( 1, 576 ) ),
+    mbFirstParagraph    ( aParaFlags.bFirstParagraph ),
+    mbLastParagraph     ( aParaFlags.bLastParagraph )
+{
+    bExtendedParameters = FALSE;
+
+    nDepth = 0;
+    nBulletFlags = 0;
+    nParaFlags = 0;
+
+    mXPropSet = ::com::sun::star::uno::Reference<
+        ::com::sun::star::beans::XPropertySet >
+            ( rXTextContent, ::com::sun::star::uno::UNO_QUERY );
+
+    mXPropState = ::com::sun::star::uno::Reference<
+        ::com::sun::star::beans::XPropertyState >
+            ( rXTextContent, ::com::sun::star::uno::UNO_QUERY );
+
+    if ( mXPropSet.is() && mXPropState.is() )
+    {
+        ::com::sun::star::uno::Reference< ::com::sun::star::container::XEnumerationAccess >
+            aXTextPortionEA( rXTextContent, ::com::sun::star::uno::UNO_QUERY );
+        if ( aXTextPortionEA.is() )
+        {
+            ::com::sun::star::uno::Reference< ::com::sun::star::container::XEnumeration >
+                aXTextPortionE( aXTextPortionEA->createEnumeration() );
+            if ( aXTextPortionE.is() )
+            {
+                while ( aXTextPortionE->hasMoreElements() )
+                {
+                    ::com::sun::star::uno::Reference< ::com::sun::star::text::XTextRange > aXCursorText;
+                    ::com::sun::star::uno::Any aAny( aXTextPortionE->nextElement() );
+                    if ( aAny >>= aXCursorText )
+                    {
+                        PortionObj* pPortionObj = new PortionObj( aXCursorText, !aXTextPortionE->hasMoreElements(), rFontCollection );
+                        if ( pPortionObj->Count() )
+                            Insert( pPortionObj, LIST_APPEND );
+                        else
+                            delete pPortionObj;
+                    }
+                }
+            }
+        }
+        ImplGetParagraphValues( rProv, TRUE );//
+    }
+}
+
+ParagraphObj::ParagraphObj( ParagraphObj& rObj )
+: List()
+, PropStateValue()
+, SOParagraph()
+{
+    ImplConstruct( rObj );
+}
+
+ParagraphObj::~ParagraphObj()
+{
+    ImplClear();
+}
+
+void ParagraphObj::Write( SvStream* pStrm )
+{
+    for ( void* pPtr = First(); pPtr; pPtr = Next() )
+        ((PortionObj*)pPtr)->Write( pStrm, mbLastParagraph );
+}
+
+void ParagraphObj::ImplClear()
+{
+    for ( void* pPtr = First(); pPtr; pPtr = Next() )
+        delete (PortionObj*)pPtr;
+}
+
+void ParagraphObj::CalculateGraphicBulletSize( sal_uInt16 nFontHeight )
+{
+    if ( ( (SvxExtNumType)nNumberingType == SVX_NUM_BITMAP ) && ( nBulletId != 0xffff ) )
+    {
+        // calculate the bulletrealsize for this grafik
+        if ( aBuGraSize.Width() && aBuGraSize.Height() )
+        {
+            double fCharHeight = nFontHeight;
+            double fLen = aBuGraSize.Height();
+            fCharHeight = fCharHeight * 0.2540;
+            double fQuo = fLen / fCharHeight;
+            nBulletRealSize = (sal_Int16)( fQuo + 0.5 );
+            if ( (sal_uInt16)nBulletRealSize > 400 )
+                nBulletRealSize = 400;
+        }
+    }
+}
+
+// from sw/source/filter/ww8/wrtw8num.cxx for default bullets to export to MS intact
+static void lcl_SubstituteBullet(String& rNumStr, rtl_TextEncoding& rChrSet, String& rFontName)
+{
+	StarSymbolToMSMultiFont *pConvert = 0;
+	FontFamily eFamily = FAMILY_DECORATIVE;
+
+	if (!pConvert)
+	{
+		pConvert = CreateStarSymbolToMSMultiFont();
+	}    
+	sal_Unicode cChar = rNumStr.GetChar(0);
+	String sFont = pConvert->ConvertChar(cChar);
+	if (sFont.Len())
+	{
+		rNumStr = static_cast< sal_Unicode >(cChar | 0xF000);
+		rFontName = sFont;
+		rChrSet = RTL_TEXTENCODING_SYMBOL;
+	}
+	else if ( (rNumStr.GetChar(0) < 0xE000 || rNumStr.GetChar(0) > 0xF8FF) )
+	{
+		/*
+		Ok we can't fit into a known windows unicode font, but
+		we are not in the private area, so we are a
+		standardized symbol, so turn off the symbol bit and
+		let words own font substitution kick in
+		*/
+		rChrSet = RTL_TEXTENCODING_UNICODE;
+		eFamily = FAMILY_SWISS;
+		rFontName = ::GetFontToken(rFontName, 0);
+	}
+	else
+	{
+		/*
+		Well we don't have an available substition, and we're
+		in our private area, so give up and show a standard
+		bullet symbol
+		*/
+		rFontName.AssignAscii(RTL_CONSTASCII_STRINGPARAM("Wingdings"));
+		rNumStr = static_cast< sal_Unicode >(0x6C);
+     }      
+     delete pConvert;
+}
+
+void ParagraphObj::ImplGetNumberingLevel( PPTExBulletProvider& rBuProv, sal_Int16 nNumberingDepth, sal_Bool bIsBullet, sal_Bool bGetPropStateValue )
+{
+	::com::sun::star::uno::Any aAny;
+	if ( GetPropertyValue( aAny, mXPropSet, String( RTL_CONSTASCII_USTRINGPARAM( "ParaLeftMargin" ) ) ) )
+	{
+		sal_Int32 nVal;
+        if ( aAny >>= nVal )
+			nTextOfs = static_cast< sal_Int16 >( nVal / ( 2540.0 / 576 ) + 0.5 ) ;
+	}
+    if ( GetPropertyValue( aAny, mXPropSet, String( RTL_CONSTASCII_USTRINGPARAM( "ParaFirstLineIndent" ) ) ) )
+	{
+        if ( aAny >>= nBulletOfs )
+			nBulletOfs = static_cast< sal_Int32 >( nBulletOfs / ( 2540.0 / 576 ) + 0.5 );
+	}
+	if ( GetPropertyValue( aAny, mXPropSet, String( RTL_CONSTASCII_USTRINGPARAM( "NumberingIsNumber" ) ) ) )
+		aAny >>= bNumberingIsNumber;
+
+	::com::sun::star::uno::Reference< ::com::sun::star::container::XIndexReplace > aXIndexReplace;
+
+    if ( bIsBullet && ImplGetPropertyValue( String( RTL_CONSTASCII_USTRINGPARAM( "NumberingRules" ) ), bGetPropStateValue ) )
+    {
+        if ( ( mAny >>= aXIndexReplace ) && nNumberingDepth < aXIndexReplace->getCount() )
+        {
+            mAny <<= aXIndexReplace->getByIndex( nNumberingDepth );
+            ::com::sun::star::uno::Sequence< ::com::sun::star::beans::PropertyValue>
+                aPropertySequence( *( ::com::sun::star::uno::Sequence< ::com::sun::star::beans::PropertyValue>*)mAny.getValue() );
+
+            const ::com::sun::star::beans::PropertyValue* pPropValue = aPropertySequence.getArray();
+
+            sal_Int32 nPropertyCount = aPropertySequence.getLength();
+            if ( nPropertyCount )
+            {
+                bExtendedParameters = TRUE;
+                nBulletRealSize = 100;
+                nMappedNumType = 0;
+
+                String aGraphicURL;
+                for ( sal_Int32 i = 0; i < nPropertyCount; i++ )
+                {
+                    const void* pValue = pPropValue[ i ].Value.getValue();
+                    if ( pValue )
+                    {
+                        ::rtl::OUString aPropName( pPropValue[ i ].Name );
+                        if ( aPropName.equalsAsciiL( RTL_CONSTASCII_STRINGPARAM( "NumberingType" ) ) )
+                            nNumberingType = *( (sal_Int16*)pValue );
+                        else if ( aPropName.equalsAsciiL( RTL_CONSTASCII_STRINGPARAM( "Adjust" ) ) )
+                            nHorzAdjust = *( (sal_Int16*)pValue );
+                        else if ( aPropName.equalsAsciiL( RTL_CONSTASCII_STRINGPARAM( "BulletChar" ) ) )
+                        {
+                            String aString( *( (String*)pValue ) );
+                            if ( aString.Len() )
+                                cBulletId = aString.GetChar( 0 );
+                        }
+                        else if ( aPropName.equalsAsciiL( RTL_CONSTASCII_STRINGPARAM( "BulletFont" ) ) )
+                        {
+                            aFontDesc = *( (::com::sun::star::awt::FontDescriptor*)pValue );
+
+                            // Our numbullet dialog has set the wrong textencoding for our "StarSymbol" font,
+                            // instead of a Unicode encoding the encoding RTL_TEXTENCODING_SYMBOL was used.
+                            // Because there might exist a lot of damaged documemts I added this two lines
+                            // which fixes the bullet problem for the export.
+                            if ( aFontDesc.Name.equalsAsciiL( RTL_CONSTASCII_STRINGPARAM( "StarSymbol" ) ) )
+                                aFontDesc.CharSet = RTL_TEXTENCODING_MS_1252;
+
+                        }
+                        else if ( aPropName.equalsAsciiL( RTL_CONSTASCII_STRINGPARAM( "GraphicURL" ) ) )
+                            aGraphicURL = ( *(::rtl::OUString*)pValue );
+                        else if ( aPropName.equalsAsciiL( RTL_CONSTASCII_STRINGPARAM( "GraphicSize" ) ) )
+                        {
+                            if ( pPropValue[ i ].Value.getValueType() == ::getCppuType( (::com::sun::star::awt::Size*)0) ) 
+                            {
+                                // don't cast awt::Size to Size as on 64-bits they are not the same.
+                                ::com::sun::star::awt::Size aSize;
+                                pPropValue[ i ].Value >>= aSize;
+                                aBuGraSize.nA = aSize.Width;
+                                aBuGraSize.nB = aSize.Height;
+                            }
+                        }
+                        else if ( aPropName.equalsAsciiL( RTL_CONSTASCII_STRINGPARAM( "StartWith" ) ) )
+                            nStartWith = *( (sal_Int16*)pValue );
+                        else if ( aPropName.equalsAsciiL( RTL_CONSTASCII_STRINGPARAM( "LeftMargin" ) ) )
+                            nTextOfs = nTextOfs + static_cast< sal_Int16 >( *( (sal_Int32*)pValue ) / ( 2540.0 / 576 ) );
+                        else if ( aPropName.equalsAsciiL( RTL_CONSTASCII_STRINGPARAM( "FirstLineOffset" ) ) )
+                            nBulletOfs += (sal_Int16)( *( (sal_Int32*)pValue ) / ( 2540.0 / 576 ) );
+                        else if ( aPropName.equalsAsciiL( RTL_CONSTASCII_STRINGPARAM( "BulletColor" ) ) )
+                        {
+                            sal_uInt32 nSOColor = *( (sal_uInt32*)pValue );
+                            nBulletColor = nSOColor & 0xff00ff00;                       // green and hibyte
+                            nBulletColor |= (sal_uInt8)( nSOColor ) << 16;              // red
+                            nBulletColor |= (sal_uInt8)( nSOColor >> 16 ) | 0xfe000000; // blue
+                        }
+                        else if ( aPropName.equalsAsciiL( RTL_CONSTASCII_STRINGPARAM( "BulletRelSize" ) ) )
+                        {
+                            nBulletRealSize = *( (sal_Int16*)pValue );
+                            nParaFlags |= 0x40;
+                            nBulletFlags |= 8;
+                        }
+                        else if ( aPropName.equalsAsciiL( RTL_CONSTASCII_STRINGPARAM( "Prefix" ) ) )
+                            sPrefix = ( *(::rtl::OUString*)pValue );
+                        else if  ( aPropName.equalsAsciiL( RTL_CONSTASCII_STRINGPARAM( "Suffix" ) ) )
+                            sSuffix = ( *(::rtl::OUString*)pValue );
+#ifdef DBG_UTIL
+                        else if ( ! (
+                                ( aPropName.equalsAsciiL( RTL_CONSTASCII_STRINGPARAM( "SymbolTextDistance" ) ) )
+                            ||  ( aPropName.equalsAsciiL( RTL_CONSTASCII_STRINGPARAM( "Graphic" ) ) ) ) )
+                        {
+                            DBG_ERROR( "Unbekanntes Property" );
+                        }
+#endif
+                    }
+                }
+
+                if ( aGraphicURL.Len() )
+                {
+					if ( aBuGraSize.Width() && aBuGraSize.Height() )
+					{
+						xub_StrLen nIndex = aGraphicURL.Search( (sal_Unicode)':', 0 );
+						if ( nIndex != STRING_NOTFOUND )
+						{
+							nIndex++;
+							if ( aGraphicURL.Len() > nIndex  )
+							{
+								ByteString aUniqueId( aGraphicURL, nIndex, aGraphicURL.Len() - nIndex, RTL_TEXTENCODING_UTF8 );
+								if ( aUniqueId.Len() )
+								{
+									nBulletId = rBuProv.GetId( aUniqueId, aBuGraSize );
+									if ( nBulletId != 0xffff )
+										bExtendedBulletsUsed = TRUE;
+								}
+							}
+						}
+					}
+					else
+					{
+						nNumberingType = SVX_NUM_NUMBER_NONE;
+					}
+                }
+
+                PortionObj* pPortion = (PortionObj*)First();
+                CalculateGraphicBulletSize( ( pPortion ) ? pPortion->mnCharHeight : 24 );
+
+                switch( (SvxExtNumType)nNumberingType )
+                {
+                    case SVX_NUM_NUMBER_NONE : nParaFlags |= 0xf; break;
+
+                    case SVX_NUM_CHAR_SPECIAL :                           // Bullet
+                    {
+						if ( aFontDesc.Name.equalsIgnoreAsciiCaseAscii("starsymbol") ||
+							aFontDesc.Name.equalsIgnoreAsciiCaseAscii("opensymbol") ) 
+						{
+							String sFontName = aFontDesc.Name;
+							String sNumStr = cBulletId;
+							rtl_TextEncoding eChrSet = aFontDesc.CharSet;
+                            lcl_SubstituteBullet(sNumStr,eChrSet,sFontName);
+							aFontDesc.Name = sFontName;
+							cBulletId = sNumStr.GetChar( 0 );
+							aFontDesc.CharSet = eChrSet;
+						 }
+
+                        if ( aFontDesc.Name.getLength() )
+                        {
+/*
+                            if ( aFontDesc.CharSet != ::com::sun::star::awt::CharSet::SYMBOL )
+                            {
+                                switch ( cBulletId )
+                                {
+                                    // Currency
+                                    case 128:   cBulletId = 0x20AC; break;
+                                    // Punctuation and other
+                                    case 130:   cBulletId = 0x201A; break;// SINGLE LOW-9 QUOTATION MARK
+                                    case 131:   cBulletId = 0x0192; break;// LATIN SMALL LETTER F WITH HOOK
+                                    case 132:   cBulletId = 0x201E; break;// DOUBLE LOW-9 QUOTATION MARK
+                                                                          // LOW DOUBLE PRIME QUOTATION MARK
+                                    case 133:   cBulletId = 0x2026; break;// HORIZONTAL ELLIPSES
+                                    case 134:   cBulletId = 0x2020; break;// DAGGER
+                                    case 135:   cBulletId = 0x2021; break;// DOUBLE DAGGER
+                                    case 136:   cBulletId = 0x02C6; break;// MODIFIER LETTER CIRCUMFLEX ACCENT
+                                    case 137:   cBulletId = 0x2030; break;// PER MILLE SIGN
+                                    case 138:   cBulletId = 0x0160; break;// LATIN CAPITAL LETTER S WITH CARON
+                                    case 139:   cBulletId = 0x2039; break;// SINGLE LEFT-POINTING ANGLE QUOTATION MARK
+                                    case 140:   cBulletId = 0x0152; break;// LATIN CAPITAL LIGATURE OE
+                                    case 142:   cBulletId = 0x017D; break;// LATIN CAPITAL LETTER Z WITH CARON
+                                    case 145:   cBulletId = 0x2018; break;// LEFT SINGLE QUOTATION MARK
+                                                                          // MODIFIER LETTER TURNED COMMA
+                                    case 146:   cBulletId = 0x2019; break;// RIGHT SINGLE QUOTATION MARK
+                                                                          // MODIFIER LETTER APOSTROPHE
+                                    case 147:   cBulletId = 0x201C; break;// LEFT DOUBLE QUOTATION MARK
+                                                                          // REVERSED DOUBLE PRIME QUOTATION MARK
+                                    case 148:   cBulletId = 0x201D; break;// RIGHT DOUBLE QUOTATION MARK
+                                                                          // REVERSED DOUBLE PRIME QUOTATION MARK
+                                    case 149:   cBulletId = 0x2022; break;// BULLET
+                                    case 150:   cBulletId = 0x2013; break;// EN DASH
+                                    case 151:   cBulletId = 0x2014; break;// EM DASH
+                                    case 152:   cBulletId = 0x02DC; break;// SMALL TILDE
+                                    case 153:   cBulletId = 0x2122; break;// TRADE MARK SIGN
+                                    case 154:   cBulletId = 0x0161; break;// LATIN SMALL LETTER S WITH CARON
+                                    case 155:   cBulletId = 0x203A; break;// SINGLE RIGHT-POINTING ANGLE QUOTATION MARK
+                                    case 156:   cBulletId = 0x0153; break;// LATIN SMALL LIGATURE OE
+                                    case 158:   cBulletId = 0x017E; break;// LATIN SMALL LETTER Z WITH CARON
+                                    case 159:   cBulletId = 0x0178; break;// LATIN CAPITAL LETTER Y WITH DIAERESIS
+//                                  case 222:   cBulletId = 0x00B6; break;// PILCROW SIGN / PARAGRAPH SIGN
+                                }
+                            }
+*/
+                            nParaFlags |= 0x90; // wir geben den Font und den Charset vor
+                        }
+                    }
+                    case SVX_NUM_CHARS_UPPER_LETTER :       // zaehlt von a-z, aa - az, ba - bz, ...
+                    case SVX_NUM_CHARS_LOWER_LETTER :
+                    case SVX_NUM_ROMAN_UPPER :
+                    case SVX_NUM_ROMAN_LOWER :
+                    case SVX_NUM_ARABIC :
+                    case SVX_NUM_PAGEDESC :                 // Numerierung aus der Seitenvorlage
+                    case SVX_NUM_BITMAP :
+                    case SVX_NUM_CHARS_UPPER_LETTER_N :     // zaehlt von  a-z, aa-zz, aaa-zzz
+                    case SVX_NUM_CHARS_LOWER_LETTER_N :
+                    {
+                        if ( nNumberingType != SVX_NUM_CHAR_SPECIAL )
+                        {
+                            bExtendedBulletsUsed = TRUE;
+                            if ( nNumberingDepth & 1 )
+                                cBulletId = 0x2013;         // defaulting bullet characters for ppt97
+                            else if ( nNumberingDepth == 4 )
+                                cBulletId = 0xbb;
+                            else
+                                cBulletId = 0x2022;
+
+                            switch( (SvxExtNumType)nNumberingType )
+                            {
+                                case SVX_NUM_CHARS_UPPER_LETTER :
+                                case SVX_NUM_CHARS_UPPER_LETTER_N :
+                                {
+                                    if ( sSuffix == String( RTL_CONSTASCII_USTRINGPARAM( ")" ) ) )
+                                    {
+                                        if ( sPrefix == String( RTL_CONSTASCII_USTRINGPARAM( "(" ) ) )
+                                            nMappedNumType = 0xa0001;   // (A)
+                                        else
+                                            nMappedNumType = 0xb0001;   // A)
+                                    }
+                                    else
+                                        nMappedNumType = 0x10001;       // A.
+                                }
+                                break;
+                                case SVX_NUM_CHARS_LOWER_LETTER :
+                                case SVX_NUM_CHARS_LOWER_LETTER_N :
+                                {
+                                    if ( sSuffix == String( RTL_CONSTASCII_USTRINGPARAM( ")" ) ) )
+                                    {
+                                        if ( sPrefix == String( RTL_CONSTASCII_USTRINGPARAM( "(" ) ) )
+                                            nMappedNumType = 0x80001;   // (a)
+                                        else
+                                            nMappedNumType = 0x90001;   // a)
+                                    }
+                                    else
+                                        nMappedNumType = 0x00001;       // a.
+                                }
+                                break;
+                                case SVX_NUM_ROMAN_UPPER :
+                                {
+                                    if ( sSuffix == String( RTL_CONSTASCII_USTRINGPARAM( ")" ) ) )
+                                    {
+                                        if ( sPrefix == String( RTL_CONSTASCII_USTRINGPARAM( "(" ) ) )
+                                            nMappedNumType = 0xe0001;   // (I)
+                                        else
+                                            nMappedNumType = 0xf0001;   // I)
+                                    }
+                                    else
+                                        nMappedNumType = 0x70001;       // I.
+                                }
+                                break;
+                                case SVX_NUM_ROMAN_LOWER :
+                                {
+                                    if ( sSuffix == String( RTL_CONSTASCII_USTRINGPARAM( ")" ) ) )
+                                    {
+                                        if ( sPrefix == String( RTL_CONSTASCII_USTRINGPARAM( "(" ) ) )
+                                            nMappedNumType = 0x40001;   // (i)
+                                        else
+                                            nMappedNumType = 0x50001;   // i)
+                                    }
+                                    else
+                                        nMappedNumType = 0x60001;       // i.
+                                }
+                                break;
+                                case SVX_NUM_ARABIC :
+                                {
+                                    if ( sSuffix == String( RTL_CONSTASCII_USTRINGPARAM( ")" ) ) )
+                                    {
+                                        if ( sPrefix == String( RTL_CONSTASCII_USTRINGPARAM( "(" ) ) )
+                                            nMappedNumType = 0xc0001;   // (1)
+                                        else
+                                            nMappedNumType = 0x20001;   // 1)
+                                    }
+                                    else
+                                    {
+                                        if ( ! ( sSuffix.Len() + sPrefix.Len() ) )
+                                            nMappedNumType = 0xd0001;   // 1
+                                        else
+                                            nMappedNumType = 0x30001;   // 1.
+                                    }
+                                }
+                                break;
+								default:
+									break;
+                            }
+                        }
+                        nParaFlags |= 0x2f;
+                        nBulletFlags |= 6;
+                        if ( mbIsBullet && bNumberingIsNumber )
+                            nBulletFlags |= 1;
+                    }
+                }
+            }
+        }
+    }
+    nBulletOfs = nTextOfs + nBulletOfs;
+    if ( nBulletOfs < 0 )
+        nBulletOfs = 0;
+}
+
+void ParagraphObj::ImplGetParagraphValues( PPTExBulletProvider& rBuProv, sal_Bool bGetPropStateValue )
+{
+    static String sNumberingLevel   ( RTL_CONSTASCII_USTRINGPARAM( "NumberingLevel" ) );
+
+	::com::sun::star::uno::Any aAny;
+	if ( GetPropertyValue( aAny, mXPropSet, sNumberingLevel, sal_True ) )
+    {
+        if ( bGetPropStateValue )
+            meBullet = GetPropertyState( mXPropSet, sNumberingLevel );
+        nDepth = *( (sal_Int16*)aAny.getValue() );
+
+		if ( nDepth < 0 )
+		{
+			mbIsBullet = sal_False;
+			nDepth = 0;
+		}
+		else
+		{
+			if ( nDepth > 4 )
+				nDepth = 4;
+			mbIsBullet = sal_True;
+		}
+    }
+    else
+	{
+        nDepth = 0;
+		mbIsBullet = sal_False;
+	}
+    ImplGetNumberingLevel( rBuProv, nDepth, mbIsBullet, bGetPropStateValue );
+
+	if ( ImplGetPropertyValue( String( RTL_CONSTASCII_USTRINGPARAM( "ParaTabStops" ) ), bGetPropStateValue ) )
+        maTabStop = *( ::com::sun::star::uno::Sequence< ::com::sun::star::style::TabStop>*)mAny.getValue();
+    sal_Int16 eTextAdjust( ::com::sun::star::style::ParagraphAdjust_LEFT );
+    if ( GetPropertyValue( aAny, mXPropSet, String( RTL_CONSTASCII_USTRINGPARAM( "ParaAdjust" ) ), bGetPropStateValue ) )
+        aAny >>= eTextAdjust;
+    switch ( (::com::sun::star::style::ParagraphAdjust)eTextAdjust )
+    {
+        case ::com::sun::star::style::ParagraphAdjust_CENTER :
+            mnTextAdjust = 1;
+        break;
+        case ::com::sun::star::style::ParagraphAdjust_RIGHT :
+            mnTextAdjust = 2;
+        break;
+        case ::com::sun::star::style::ParagraphAdjust_BLOCK :
+            mnTextAdjust = 3;
+        break;
+        default :
+        case ::com::sun::star::style::ParagraphAdjust_LEFT :
+            mnTextAdjust = 0;
+        break;
+    }
+    meTextAdjust = ePropState;
+
+    if ( ImplGetPropertyValue( String( RTL_CONSTASCII_USTRINGPARAM( "ParaLineSpacing" ) ), bGetPropStateValue ) )
+    {
+        ::com::sun::star::style::LineSpacing aLineSpacing
+            = *( (::com::sun::star::style::LineSpacing*)mAny.getValue() );
+        switch ( aLineSpacing.Mode )
+        {
+            case ::com::sun::star::style::LineSpacingMode::FIX :
+                mnLineSpacing = (sal_Int16)(-( aLineSpacing.Height ) );
+                mbFixedLineSpacing = TRUE;
+                break;
+            case ::com::sun::star::style::LineSpacingMode::MINIMUM :
+            case ::com::sun::star::style::LineSpacingMode::LEADING :
+                mnLineSpacing = (sal_Int16)(-( aLineSpacing.Height ) );
+                mbFixedLineSpacing = FALSE;
+           break;
+
+            case ::com::sun::star::style::LineSpacingMode::PROP :
+            default:
+                mnLineSpacing = (sal_Int16)( aLineSpacing.Height );
+            break;
+        }
+    }
+    meLineSpacing = ePropState;
+
+    if ( ImplGetPropertyValue( String( RTL_CONSTASCII_USTRINGPARAM( "ParaBottomMargin" ) ), bGetPropStateValue ) )
+    {
+        double fSpacing = *( (sal_uInt32*)mAny.getValue() ) + ( 2540.0 / 576.0 ) - 1;
+        mnLineSpacingBottom = (sal_Int16)(-( fSpacing * 576.0 / 2540.0 ) );
+    }
+    meLineSpacingBottom = ePropState;
+
+    if ( ImplGetPropertyValue( String( RTL_CONSTASCII_USTRINGPARAM( "ParaTopMargin" ) ), bGetPropStateValue ) )
+    {
+        double fSpacing = *( (sal_uInt32*)mAny.getValue() ) + ( 2540.0 / 576.0 ) - 1;
+        mnLineSpacingTop = (sal_Int16)(-( fSpacing * 576.0 / 2540.0 ) );
+    }
+    meLineSpacingTop = ePropState;
+
+    if ( ImplGetPropertyValue( String( RTL_CONSTASCII_USTRINGPARAM( "ParaIsForbiddenRules" ) ), bGetPropStateValue ) )
+        mAny >>= mbForbiddenRules;
+    meForbiddenRules = ePropState;
+
+    if ( ImplGetPropertyValue( String( RTL_CONSTASCII_USTRINGPARAM( "ParaIsHangingPunctuation" ) ), bGetPropStateValue ) )
+        mAny >>= mbParagraphPunctation;
+    meParagraphPunctation = ePropState;
+
+	mnBiDi = 0;
+	if ( ImplGetPropertyValue( String( RTL_CONSTASCII_USTRINGPARAM( "WritingMode" ) ), bGetPropStateValue ) )
+	{
+		sal_Int16 nWritingMode;
+		mAny >>= nWritingMode;
+
+		SvxFrameDirection eWritingMode( (SvxFrameDirection)nWritingMode );
+		if ( ( eWritingMode == FRMDIR_HORI_RIGHT_TOP )
+			|| ( eWritingMode == FRMDIR_VERT_TOP_RIGHT ) )
+		{
+			mnBiDi = 1;
+		}
+	}
+	meBiDi = ePropState;
+}
+
+void ParagraphObj::ImplConstruct( ParagraphObj& rParagraphObj )
+{
+    mnTextSize = rParagraphObj.mnTextSize;
+    mnTextAdjust = rParagraphObj.mnTextAdjust;
+    mnLineSpacing = rParagraphObj.mnLineSpacing;
+    mnLineSpacingTop = rParagraphObj.mnLineSpacingTop;
+    mnLineSpacingBottom = rParagraphObj.mnLineSpacingBottom;
+    mbFirstParagraph = rParagraphObj.mbFirstParagraph;
+    mbLastParagraph = rParagraphObj.mbLastParagraph;
+    mbParagraphPunctation = rParagraphObj.mbParagraphPunctation;
+    mbForbiddenRules = rParagraphObj.mbForbiddenRules;
+    mnBiDi = rParagraphObj.mnBiDi;
+
+    for ( void* pPtr = rParagraphObj.First(); pPtr; pPtr = rParagraphObj.Next() )
+        Insert( new PortionObj( *(PortionObj*)pPtr ), LIST_APPEND );
+
+    maTabStop = rParagraphObj.maTabStop;
+    bExtendedParameters = rParagraphObj.bExtendedParameters;
+    nParaFlags = rParagraphObj.nParaFlags;
+    nBulletFlags = rParagraphObj.nBulletFlags;
+    sPrefix = rParagraphObj.sPrefix;
+    sSuffix = rParagraphObj.sSuffix;
+    sGraphicUrl = rParagraphObj.sGraphicUrl;            // String auf eine Graphic
+    aBuGraSize = rParagraphObj.aBuGraSize;
+    nNumberingType = rParagraphObj.nNumberingType;      // in wirlichkeit ist dies ein SvxEnum
+    nHorzAdjust = rParagraphObj.nHorzAdjust;
+    nBulletColor = rParagraphObj.nBulletColor;
+    nBulletOfs = rParagraphObj.nBulletOfs;
+    nStartWith = rParagraphObj.nStartWith;              // Start der nummerierung
+    nTextOfs = rParagraphObj.nTextOfs;
+    nBulletRealSize = rParagraphObj.nBulletRealSize;    // GroessenVerhaeltnis in Proz
+    nDepth = rParagraphObj.nDepth;                      // aktuelle tiefe
+    cBulletId = rParagraphObj.cBulletId;                // wenn Numbering Type == CharSpecial
+    aFontDesc = rParagraphObj.aFontDesc;
+
+    bExtendedBulletsUsed = rParagraphObj.bExtendedBulletsUsed;
+    nBulletId = rParagraphObj.nBulletId;
+}
+
+::com::sun::star::awt::Size ParagraphObj::ImplMapSize( const ::com::sun::star::awt::Size& rSize )
+{
+    Size aSize( OutputDevice::LogicToLogic( Size( rSize.Width, rSize.Height ), maMapModeSrc, maMapModeDest ) );
+    if ( !aSize.Width() )
+        aSize.Width()++;
+    if ( !aSize.Height() )
+        aSize.Height()++;
+    return ::com::sun::star::awt::Size( aSize.Width(), aSize.Height() );
+}
+
+sal_uInt32 ParagraphObj::ImplCalculateTextPositions( sal_uInt32 nCurrentTextPosition )
+{
+    mnTextSize = 0;
+    for ( void* pPtr = First(); pPtr; pPtr = Next() )
+        mnTextSize += ((PortionObj*)pPtr)->ImplCalculateTextPositions( nCurrentTextPosition + mnTextSize );
+    return mnTextSize;
+}
+
+ParagraphObj& ParagraphObj::operator=( ParagraphObj& rParagraphObj )
+{
+    if ( this != &rParagraphObj )
+    {
+        ImplClear();
+        ImplConstruct( rParagraphObj );
+    }
+    return *this;
+}
+
+//  -----------------------------------------------------------------------
+
+ImplTextObj::ImplTextObj( int nInstance )
+{
+    mnRefCount = 1;
+    mnTextSize = 0;
+    mnInstance = nInstance;
+    mpList = new List;
+    mbHasExtendedBullets = FALSE;
+	mbFixedCellHeightUsed = FALSE;
+}
+
+ImplTextObj::~ImplTextObj()
+{
+    for ( ParagraphObj* pPtr = (ParagraphObj*)mpList->First(); pPtr; pPtr = (ParagraphObj*)mpList->Next() )
+        delete pPtr;
+    delete mpList;
+}
+
+TextObj::TextObj( ::com::sun::star::uno::Reference< ::com::sun::star::text::XSimpleText > & rXTextRef,
+            int nInstance, FontCollection& rFontCollection, PPTExBulletProvider& rProv )
+{
+    mpImplTextObj = new ImplTextObj( nInstance );
+
+    ::com::sun::star::uno::Reference< ::com::sun::star::container::XEnumerationAccess >
+        aXTextParagraphEA( rXTextRef, ::com::sun::star::uno::UNO_QUERY );
+
+    if ( aXTextParagraphEA.is()  )
+    {
+        ::com::sun::star::uno::Reference< ::com::sun::star::container::XEnumeration >
+            aXTextParagraphE( aXTextParagraphEA->createEnumeration() );
+        if ( aXTextParagraphE.is() )
+        {
+            ParaFlags aParaFlags;
+            while ( aXTextParagraphE->hasMoreElements() )
+            {
+                ::com::sun::star::uno::Reference< ::com::sun::star::text::XTextContent > aXParagraph;
+                ::com::sun::star::uno::Any aAny( aXTextParagraphE->nextElement() );
+                if ( aAny >>= aXParagraph )
+                {
+                    if ( !aXTextParagraphE->hasMoreElements() )
+                        aParaFlags.bLastParagraph = TRUE;
+                    ParagraphObj* pPara = new ParagraphObj( aXParagraph, aParaFlags, rFontCollection, rProv );
+                    mpImplTextObj->mbHasExtendedBullets |= pPara->bExtendedBulletsUsed;
+                    mpImplTextObj->mpList->Insert( pPara, LIST_APPEND );
+                    aParaFlags.bFirstParagraph = FALSE;
+                }
+            }
+        }
+    }
+    ImplCalculateTextPositions();
+}
+
+TextObj::TextObj( TextObj& rTextObj )
+{
+    mpImplTextObj = rTextObj.mpImplTextObj;
+    mpImplTextObj->mnRefCount++;
+}
+
+TextObj::~TextObj()
+{
+    if ( ! ( --mpImplTextObj->mnRefCount ) )
+        delete mpImplTextObj;
+}
+
+void TextObj::Write( SvStream* pStrm )
+{
+    sal_uInt32 nSize, nPos = pStrm->Tell();
+    *pStrm << (sal_uInt32)( EPP_TextCharsAtom << 16 ) << (sal_uInt32)0;
+    for ( void* pPtr = First(); pPtr; pPtr = Next() )
+        ((ParagraphObj*)pPtr)->Write( pStrm );
+    nSize = pStrm->Tell() - nPos;
+    pStrm->SeekRel( - ( (sal_Int32)nSize - 4 ) );
+    *pStrm << (sal_uInt32)( nSize - 8 );
+    pStrm->SeekRel( nSize - 8 );
+}
+
+void TextObj::ImplCalculateTextPositions()
+{
+    mpImplTextObj->mnTextSize = 0;
+    for ( void* pPtr = First(); pPtr; pPtr = Next() )
+        mpImplTextObj->mnTextSize += ((ParagraphObj*)pPtr)->ImplCalculateTextPositions( mpImplTextObj->mnTextSize );
+}
+
+TextObj& TextObj::operator=( TextObj& rTextObj )
+{
+    if ( this != &rTextObj )
+    {
+        if ( ! ( --mpImplTextObj->mnRefCount ) )
+            delete mpImplTextObj;
+        mpImplTextObj = rTextObj.mpImplTextObj;
+        mpImplTextObj->mnRefCount++;
+    }
+    return *this;
+}
+
+void TextObj::WriteTextSpecInfo( SvStream* pStrm )
+{
+	sal_uInt32 nCharactersLeft( Count() );
+	if ( nCharactersLeft >= 1 )
+	{
+		EscherExAtom aAnimationInfoAtom( *pStrm, EPP_TextSpecInfoAtom, 0, 0 );
+		for ( ParagraphObj* pPtr = static_cast < ParagraphObj * >( First() ); nCharactersLeft && pPtr; pPtr = static_cast< ParagraphObj* >( Next() ) )
+		{
+			for ( PortionObj* pPortion = static_cast< PortionObj* >( pPtr->First() ); nCharactersLeft && pPortion; pPortion = static_cast< PortionObj* >( pPtr->Next() ) )
+			{
+				sal_Int32 nPortionSize = pPortion->mnTextSize >= nCharactersLeft ? nCharactersLeft : pPortion->mnTextSize;
+				sal_Int32 nFlags = 7;
+				nCharactersLeft -= nPortionSize;
+				*pStrm  << static_cast< sal_uInt32 >( nPortionSize )
+						<< nFlags
+						<< static_cast< sal_Int16 >( 1 )	// spellinfo -> needs rechecking
+						<< static_cast< sal_Int16 >( MsLangId::convertLocaleToLanguageWithFallback( pPortion->meCharLocale ) )
+						<< static_cast< sal_Int16 >( 0 );	// alt language
+			}
+		}
+		if ( nCharactersLeft )
+			*pStrm << nCharactersLeft << static_cast< sal_Int32 >( 1 ) << static_cast< sal_Int16 >( 1 );
+
+	}
+}
+
+//  -----------------------------------------------------------------------
+
+void PPTWriter::ImplAdjustFirstLineLineSpacing( TextObj& rTextObj, EscherPropertyContainer& rPropOpt )
+{
+	if ( !mbFontIndependentLineSpacing )
+	{
+		ParagraphObj* pPara = rTextObj.First();
+		if ( pPara )
+		{
+			PortionObj* pPortion = (PortionObj*)pPara->First();
+			if ( pPortion )
+			{
+				sal_Int16 nLineSpacing = pPara->mnLineSpacing;
+				const FontCollectionEntry* pDesc = maFontCollection.GetById( pPortion->mnFont );
+				if ( pDesc )
+					 nLineSpacing = (sal_Int16)( (double)nLineSpacing * pDesc->Scaling + 0.5 );
+
+				if ( ( nLineSpacing > 0 ) && ( nLineSpacing < 100 ) )
+				{
+	/*
+					if ( rxText.is() )
+					{
+						::com::sun::star::uno::Reference< ::com::sun::star::drawing::XShape > xShape( rxText, ::com::sun::star::uno::UNO_QUERY );
+						if ( xShape.is() )
+						{
+							SdrObject* pObj = GetSdrObjectFromXShape( mXShape );
+							if ( pObj )
+							{
+								const OutlinerParaObject* pParaObj = pObj->GetOutlinerParaObject();
+								if ( pParaObj )
+								{
+									SdrModel* pModel = pObj->GetModel();
+									if ( pModel )
+									{
+										Outliner aOutliner( &pModel->GetItemPool(), pParaObj->GetOutlinerMode() );
+										aOutliner.SetText( *pParaObj );
+										ULONG nTextHeight = aOutliner.GetLineHeight( 0, 0 );
+										if ( nTextHeight )
+										{
+										}
+									}
+								}
+							}
+						}
+					}
+	*/
+					double fCharHeight = pPortion->mnCharHeight;
+					fCharHeight *= 2540 / 72;
+					fCharHeight *= 100 - nLineSpacing;
+					fCharHeight /= 100;
+
+					sal_uInt32 nUpperDistance = 0;
+					rPropOpt.GetOpt( ESCHER_Prop_dyTextTop, nUpperDistance );
+					nUpperDistance += static_cast< sal_uInt32 >( fCharHeight * 360.0 );
+					rPropOpt.AddOpt( ESCHER_Prop_dyTextTop, nUpperDistance );
+				}
+			}
+		}
+	}
+}
+
+//  -----------------------------------------------------------------------
+
+void PPTWriter::ImplWriteTextStyleAtom( SvStream& rOut, int nTextInstance, sal_uInt32 nAtomInstance,
+	TextRuleEntry* pTextRule, SvStream& rExtBuStr, EscherPropertyContainer* pPropOpt )
+{
+    PPTExParaSheet& rParaSheet = mpStyleSheet->GetParaSheet( nTextInstance );
+
+    rOut << (sal_uInt32)( ( EPP_TextHeaderAtom << 16 ) | ( nAtomInstance << 4 ) ) << (sal_uInt32)4
+         << nTextInstance;
+
+	if ( mbEmptyPresObj )
+        mnTextSize = 0;
+    if ( !mbEmptyPresObj )
+    {
+        ParagraphObj* pPara;
+        TextObj aTextObj( mXText, nTextInstance, maFontCollection, (PPTExBulletProvider&)*this );
+
+        // leaving out EPP_TextCharsAtom w/o text - still write out
+        // attribute info though
+        if ( mnTextSize )
+            aTextObj.Write( &rOut );
+
+		if ( pPropOpt )
+			ImplAdjustFirstLineLineSpacing( aTextObj, *pPropOpt );
+
+		sal_uInt32 nSize, nPos = rOut.Tell();
+
+        rOut << (sal_uInt32)( EPP_StyleTextPropAtom << 16 ) << (sal_uInt32)0;
+        ImplWriteParagraphs( rOut, aTextObj );
+        ImplWritePortions( rOut, aTextObj );
+        nSize = rOut.Tell() - nPos;
+        rOut.SeekRel( - ( (sal_Int32)nSize - 4 ) );
+        rOut << (sal_uInt32)( nSize - 8 );
+        rOut.SeekRel( nSize - 8 );
+
+        for ( pPara = aTextObj.First(); pPara; pPara = aTextObj.Next() )
+        {
+            for ( PortionObj* pPortion = (PortionObj*)pPara->First(); pPortion; pPortion = (PortionObj*)pPara->Next() )
+            {
+                if ( pPortion->mpFieldEntry )
+                {
+                    const FieldEntry* pFieldEntry = pPortion->mpFieldEntry;
+
+                    switch ( pFieldEntry->nFieldType >> 28 )
+                    {
+                        case 1 :
+                        case 2 :
+                        {
+                            rOut << (sal_uInt32)( EPP_DateTimeMCAtom << 16 ) << (sal_uInt32)8
+                                 << (sal_uInt32)( pFieldEntry->nFieldStartPos )			// TxtOffset auf TxtField;
+                                 << (sal_uInt8)( pFieldEntry->nFieldType & 0xff )		// Type
+                                 << (sal_uInt8)0 << (sal_uInt16)0;						// PadBytes
+                        }
+                        break;
+                        case 3 :
+                        {
+                            rOut << (sal_uInt32)( EPP_SlideNumberMCAtom << 16 ) << (sal_uInt32 ) 4
+                                 << (sal_uInt32)( pFieldEntry->nFieldStartPos );
+                        }
+                        break;
+                        case 4 :
+                        {
+							sal_uInt32 nPageIndex = 0;
+							String aPageUrl;
+							String aEmpty;
+							String aFile( pFieldEntry->aFieldUrl );
+							String aTarget( pFieldEntry->aFieldUrl );
+							INetURLObject aUrl( pFieldEntry->aFieldUrl );
+							if ( INET_PROT_FILE == aUrl.GetProtocol() )
+								aFile = aUrl.PathToFileName();
+							else if ( INET_PROT_SMB == aUrl.GetProtocol() )
+							{
+								// #n382718# (and #n261623#) Convert smb notation to '\\'
+								aFile = aUrl.GetMainURL( INetURLObject::NO_DECODE );
+								aFile = String( aFile.GetBuffer() + 4 ); // skip the 'smb:' part
+								aFile.SearchAndReplaceAll( '/', '\\' );
+								aTarget = aFile;
+							}
+							else if ( pFieldEntry->aFieldUrl.GetChar( 0 ) == '#' )
+							{
+								String aPage( INetURLObject::decode( pFieldEntry->aFieldUrl, '%', INetURLObject::DECODE_WITH_CHARSET ) );
+								aPage.Erase( 0, 1 );
+								for ( String* pStr = (String*)maSlideNameList.First(); pStr; pStr = (String*)maSlideNameList.Next(), nPageIndex++ )
+								{
+									if ( *pStr == aPage )
+									{
+										aPageUrl = UniString::CreateFromInt32( 256 + nPageIndex );
+										aPageUrl.Append( String( RTL_CONSTASCII_USTRINGPARAM( "," ) ) );
+										aPageUrl.Append( String::CreateFromInt32( nPageIndex + 1 ) );
+										aPageUrl.Append( String( RTL_CONSTASCII_USTRINGPARAM( ",Slide " ) ) );
+										aPageUrl.Append( String::CreateFromInt32( nPageIndex + 1 ) );
+									}
+								}
+							}
+							sal_uInt32 nHyperId;
+							if ( aPageUrl.Len() )
+								nHyperId = ImplInsertBookmarkURL( aPageUrl, 1 | ( nPageIndex << 8 ) | ( 1 << 31 ), pFieldEntry->aRepresentation, aEmpty, aEmpty, aPageUrl );
+							else
+								nHyperId = ImplInsertBookmarkURL( pFieldEntry->aFieldUrl, 2 | ( nHyperId << 8 ), aFile, aTarget, aEmpty, aEmpty );
+
+                            rOut << (sal_uInt32)( ( EPP_InteractiveInfo << 16 ) | 0xf ) << (sal_uInt32)24
+                                 << (sal_uInt32)( EPP_InteractiveInfoAtom << 16 ) << (sal_uInt32)16
+                                 << (sal_uInt32)0									// soundref
+                                 << nHyperId										// hyperlink id
+                                 << (sal_uInt8)4									// hyperlink action
+                                 << (sal_uInt8)0                                    // ole verb
+                                 << (sal_uInt8)0                                    // jump
+                                 << (sal_uInt8)0                                    // flags
+                                 << (sal_uInt8)8                                    // hyperlink type ?
+                                 << (sal_uInt8)0 << (sal_uInt8)0 << (sal_uInt8)0
+                                 << (sal_uInt32)( EPP_TxInteractiveInfoAtom << 16 ) << (sal_uInt32)8
+                                 << (sal_uInt32)( pFieldEntry->nFieldStartPos )
+                                 << (sal_uInt32)( pFieldEntry->nFieldEndPos );
+                        }
+						break;
+						case 5 :
+						{
+                            rOut << (sal_uInt32)( EPP_GenericDateMCAtom << 16 ) << (sal_uInt32)4
+                                 << (sal_uInt32)( pFieldEntry->nFieldStartPos );
+						}
+						break;
+						case 6 :
+						{
+                            rOut << (sal_uInt32)( EPP_HeaderMCAtom << 16 ) << (sal_uInt32 ) 4
+                                 << (sal_uInt32)( pFieldEntry->nFieldStartPos );
+						}
+						break;
+						case 7 :
+						{
+                            rOut << (sal_uInt32)( EPP_FooterMCAtom << 16 ) << (sal_uInt32 ) 4
+                                 << (sal_uInt32)( pFieldEntry->nFieldStartPos );
+						}
+						break;
+                        default:
+                        break;
+                    }
+                }
+            }
+        }
+
+		aTextObj.WriteTextSpecInfo( &rOut );
+
+        // Star Office Default TabSizes schreiben ( wenn noetig )
+        pPara = aTextObj.First();
+        if ( pPara )
+        {
+            sal_uInt32  nParaFlags = 0x1f;
+            sal_Int16   nDepth, nMask, nNumberingRule[ 10 ];
+            sal_uInt32  nTextOfs = pPara->nTextOfs;
+            sal_uInt32  nTabs = pPara->maTabStop.getLength();
+            const ::com::sun::star::style::TabStop* pTabStop = ( const ::com::sun::star::style::TabStop* )pPara->maTabStop.getConstArray();
+
+            for ( ; pPara; pPara = aTextObj.Next() )
+            {
+                if ( pPara->bExtendedParameters )
+                {
+                    nDepth = pPara->nDepth;
+                    if ( nDepth < 5 )
+                    {
+                        nMask = 1 << nDepth;
+                        if ( nParaFlags & nMask )
+                        {
+                            nParaFlags &=~ nMask;
+                            if ( ( rParaSheet.maParaLevel[ nDepth ].mnTextOfs != pPara->nTextOfs ) ||
+                                ( rParaSheet.maParaLevel[ nDepth ].mnBulletOfs != pPara->nBulletOfs ) )
+                            {
+                                nParaFlags |= nMask << 16;
+                                nNumberingRule[ nDepth << 1 ] = pPara->nTextOfs;
+                                nNumberingRule[ ( nDepth << 1 ) + 1 ] = (sal_Int16)pPara->nBulletOfs;
+                            }
+                        }
+                    }
+                }
+            }
+            nParaFlags >>= 16;
+
+            sal_uInt32  nDefaultTabSize = ImplMapSize( ::com::sun::star::awt::Size( 2011, 1 ) ).Width;
+            sal_uInt32  nDefaultTabs = abs( maRect.GetWidth() ) / nDefaultTabSize;
+            if ( nTabs )
+                nDefaultTabs -= (sal_Int32)( ( ( pTabStop[ nTabs - 1 ].Position / 4.40972 ) + nTextOfs ) / nDefaultTabSize );
+            if ( (sal_Int32)nDefaultTabs < 0 )
+                nDefaultTabs = 0;
+
+            sal_uInt32 nTabCount = nTabs + nDefaultTabs;
+            sal_uInt32 i, nTextRulerAtomFlags = 0;
+
+            if ( nTabCount )
+                nTextRulerAtomFlags |= 4;
+            if ( nParaFlags )
+                nTextRulerAtomFlags |= ( ( nParaFlags << 3 ) | ( nParaFlags << 8 ) );
+
+            if ( nTextRulerAtomFlags )
+            {
+                SvStream* pRuleOut = &rOut;
+                if ( pTextRule )
+                    pRuleOut = pTextRule->pOut = new SvMemoryStream( 0x100, 0x100 );
+
+                sal_uInt32 nRulePos = pRuleOut->Tell();
+                *pRuleOut << (sal_uInt32)( EPP_TextRulerAtom << 16 ) << (sal_uInt32)0;
+                *pRuleOut << nTextRulerAtomFlags;
+                if ( nTextRulerAtomFlags & 4 )
+                {
+                    *pRuleOut << (sal_uInt16)nTabCount;
+                    for ( i = 0; i < nTabs; i++ )
+                    {
+                        sal_uInt16 nPosition = (sal_uInt16)( ( pTabStop[ i ].Position / 4.40972 ) + nTextOfs );
+                        sal_uInt16 nType;
+                        switch ( pTabStop[ i ].Alignment )
+                        {
+                            case ::com::sun::star::style::TabAlign_DECIMAL :    nType = 3; break;
+                            case ::com::sun::star::style::TabAlign_RIGHT :      nType = 2; break;
+                            case ::com::sun::star::style::TabAlign_CENTER :     nType = 1; break;
+
+                            case ::com::sun::star::style::TabAlign_LEFT :
+                            default:                                            nType = 0;
+                        };
+                        *pRuleOut << nPosition
+                                  << nType;
+                    }
+
+                    sal_uInt32 nWidth = 1;
+                    if ( nTabs )
+                        nWidth += (sal_Int32)( ( ( pTabStop[ nTabs - 1 ].Position / 4.40972 + nTextOfs ) / nDefaultTabSize ) );
+                    nWidth *= nDefaultTabSize;
+                    for ( i = 0; i < nDefaultTabs; i++, nWidth += nDefaultTabSize )
+                        *pRuleOut << nWidth;
+                }
+                for ( i = 0; i < 5; i++ )
+                {
+                    if ( nTextRulerAtomFlags & ( 8 << i ) )
+                        *pRuleOut << nNumberingRule[ i << 1 ];
+                    if ( nTextRulerAtomFlags & ( 256 << i ) )
+                        *pRuleOut << nNumberingRule[ ( i << 1 ) + 1 ];
+                }
+                sal_uInt32 nBufSize = pRuleOut->Tell() - nRulePos;
+                pRuleOut->SeekRel( - ( (sal_Int32)nBufSize - 4 ) );
+                *pRuleOut << (sal_uInt32)( nBufSize - 8 );
+                pRuleOut->SeekRel( nBufSize - 8 );
+            }
+        }
+        if ( aTextObj.HasExtendedBullets() )
+        {
+            ParagraphObj* pBulletPara = aTextObj.First();
+            if ( pBulletPara )
+            {
+                sal_uInt32  nBulletFlags = 0;
+                sal_uInt32  nNumberingType = 0, nPos2 = rExtBuStr.Tell();
+
+                rExtBuStr << (sal_uInt32)( EPP_PST_ExtendedParagraphAtom << 16 ) << (sal_uInt32)0;
+
+                for ( ; pBulletPara; pBulletPara = aTextObj.Next() )
+                {
+                    nBulletFlags = 0;
+                    sal_uInt16 nBulletId = pBulletPara->nBulletId;
+                    if ( pBulletPara->bExtendedBulletsUsed )
+                    {
+                        nBulletFlags = 0x800000;
+                        if ( pBulletPara->nNumberingType != SVX_NUM_BITMAP )
+                            nBulletFlags = 0x3000000;
+                    }
+                    rExtBuStr << (sal_uInt32)nBulletFlags;
+
+                    if ( nBulletFlags & 0x800000 )
+                        rExtBuStr << nBulletId;
+                    if ( nBulletFlags & 0x1000000 )
+                    {
+                        switch( pBulletPara->nNumberingType )
+                        {
+                            case SVX_NUM_NUMBER_NONE :
+                            case SVX_NUM_CHAR_SPECIAL :
+                                nNumberingType = 0;
+                            break;
+                            case SVX_NUM_CHARS_UPPER_LETTER :
+                            case SVX_NUM_CHARS_UPPER_LETTER_N :
+                            case SVX_NUM_CHARS_LOWER_LETTER :
+                            case SVX_NUM_CHARS_LOWER_LETTER_N :
+                            case SVX_NUM_ROMAN_UPPER :
+                            case SVX_NUM_ROMAN_LOWER :
+                            case SVX_NUM_ARABIC :
+                                nNumberingType = pBulletPara->nMappedNumType;
+                            break;
+
+    //                      case SVX_NUM_PAGEDESC :
+                            case SVX_NUM_BITMAP :
+                                nNumberingType = 0;
+                            break;
+
+                        }
+                        rExtBuStr << (sal_uInt32)nNumberingType;
+                    }
+                    if ( nBulletFlags & 0x2000000 )
+                        rExtBuStr << (sal_uInt16)pBulletPara->nStartWith;
+                    rExtBuStr << (sal_uInt32)0 << (sal_uInt32)0;
+                }
+                sal_uInt32 nBulletSize = ( rExtBuStr.Tell() - nPos2 ) - 8;
+                rExtBuStr.SeekRel( - ( (sal_Int32)nBulletSize + 4 ) );
+                rExtBuStr << nBulletSize;
+                rExtBuStr.SeekRel( nBulletSize );
+            }
+        }
+    }
+}
+
+//  -----------------------------------------------------------------------
+
+void PPTWriter::ImplWriteObjectEffect( SvStream& rSt,
+    ::com::sun::star::presentation::AnimationEffect eAe,
+    ::com::sun::star::presentation::AnimationEffect eTe,
+    sal_uInt16 nOrder )
+{
+	EscherExContainer aAnimationInfo( rSt, EPP_AnimationInfo );
+	EscherExAtom aAnimationInfoAtom( rSt, EPP_AnimationInfoAtom, 0, 1 );
+	sal_uInt32  nDimColor = 0x7000000;  // color to use for dimming
+	sal_uInt32  nFlags = 0x4400;        // set of flags that determine type of build
+	sal_uInt32  nSoundRef = 0;          // 0 if storage is from clipboard. Otherwise index(ID) in SoundCollection list.
+	sal_uInt32  nDelayTime = 0;         // delay before playing object
+	sal_uInt16  nSlideCount = 1;        // number of slides to play object
+	UINT8   nBuildType = 1;         // type of build
+	UINT8   nFlyMethod = 0;         // animation effect( fly, zoom, appear, etc )
+	UINT8   nFlyDirection = 0;      // Animation direction( left, right, up, down, etc )
+	UINT8   nAfterEffect = 0;       // what to do after build
+	UINT8   nSubEffect = 0;         // build by word or letter
+	UINT8   nOleVerb = 0;           // Determines object's class (sound, video, other)
+
+	if ( eAe == ::com::sun::star::presentation::AnimationEffect_NONE )
+	{
+		nBuildType = 0;
+		eAe = eTe;
+	}
+	switch ( eAe )
+	{
+		case ::com::sun::star::presentation::AnimationEffect_NONE :
+		break;
+		case ::com::sun::star::presentation::AnimationEffect_FADE_FROM_LEFT :
+		{
+			nFlyDirection = 2;
+			nFlyMethod = 10;
+		}
+		break;
+		case ::com::sun::star::presentation::AnimationEffect_FADE_FROM_TOP :
+		{
+			nFlyDirection = 3;
+			nFlyMethod = 10;
+		}
+		break;
+		case ::com::sun::star::presentation::AnimationEffect_FADE_FROM_RIGHT :
+		{
+			nFlyDirection = 0;
+			nFlyMethod = 10;
+		}
+		break;
+		case ::com::sun::star::presentation::AnimationEffect_FADE_FROM_BOTTOM :
+		{
+			nFlyDirection = 1;
+			nFlyMethod = 10;
+		}
+		break;
+		case ::com::sun::star::presentation::AnimationEffect_FADE_TO_CENTER :
+		{
+			nFlyDirection = 1;
+			nFlyMethod = 11;
+		}
+		break;
+		case ::com::sun::star::presentation::AnimationEffect_FADE_FROM_CENTER :
+		{
+			nFlyDirection = 0;
+			nFlyMethod = 11;
+		}
+		break;
+		case ::com::sun::star::presentation::AnimationEffect_MOVE_FROM_LEFT :
+		{
+			nFlyDirection = 0;
+			nFlyMethod = 12;
+		}
+		break;
+		case ::com::sun::star::presentation::AnimationEffect_MOVE_FROM_TOP :
+		{
+			nFlyDirection = 1;
+			nFlyMethod = 12;
+		}
+		break;
+		case ::com::sun::star::presentation::AnimationEffect_MOVE_FROM_RIGHT :
+		{
+			nFlyDirection = 2;
+			nFlyMethod = 12;
+		}
+		break;
+		case ::com::sun::star::presentation::AnimationEffect_MOVE_FROM_BOTTOM :
+		{
+			nFlyDirection = 3;
+			nFlyMethod = 12;
+		}
+		break;
+		case ::com::sun::star::presentation::AnimationEffect_VERTICAL_STRIPES :
+		{
+			nFlyDirection = 0;
+			nFlyMethod = 2;
+		}
+		break;
+		case ::com::sun::star::presentation::AnimationEffect_HORIZONTAL_STRIPES :
+		{
+			nFlyDirection = 1;
+			nFlyMethod = 2;
+		}
+		break;
+		case ::com::sun::star::presentation::AnimationEffect_CLOCKWISE :
+		{
+			nFlyDirection = 1;
+			nFlyMethod = 3;
+		}
+		break;
+		case ::com::sun::star::presentation::AnimationEffect_COUNTERCLOCKWISE :
+		{
+			nFlyDirection = 0;
+			nFlyMethod = 3;
+		}
+		break;
+		case ::com::sun::star::presentation::AnimationEffect_FADE_FROM_UPPERLEFT :
+		{
+			nFlyDirection = 7;
+			nFlyMethod = 9;
+		}
+		break;
+		case ::com::sun::star::presentation::AnimationEffect_FADE_FROM_UPPERRIGHT :
+		{
+			nFlyDirection = 6;
+			nFlyMethod = 9;
+		}
+		break;
+		case ::com::sun::star::presentation::AnimationEffect_FADE_FROM_LOWERLEFT :
+		{
+			nFlyDirection = 5;
+			nFlyMethod = 9;
+		}
+		break;
+		case ::com::sun::star::presentation::AnimationEffect_FADE_FROM_LOWERRIGHT :
+		{
+			nFlyDirection = 4;
+			nFlyMethod = 9;
+		}
+		break;
+		case ::com::sun::star::presentation::AnimationEffect_CLOSE_VERTICAL :
+		{
+			nFlyDirection = 1;
+			nFlyMethod = 13;
+		}
+		break;
+		case ::com::sun::star::presentation::AnimationEffect_CLOSE_HORIZONTAL :
+		{
+			nFlyDirection = 3;
+			nFlyMethod = 13;
+		}
+		break;
+		case ::com::sun::star::presentation::AnimationEffect_OPEN_VERTICAL :
+		{
+			nFlyDirection = 0;
+			nFlyMethod = 13;
+		}
+		break;
+		case ::com::sun::star::presentation::AnimationEffect_OPEN_HORIZONTAL :
+		{
+			nFlyDirection = 2;
+			nFlyMethod = 13;
+		}
+		break;
+		case ::com::sun::star::presentation::AnimationEffect_PATH :
+		{
+			nFlyDirection = 28;
+			nFlyMethod = 12;
+		}
+		break;
+		case ::com::sun::star::presentation::AnimationEffect_MOVE_TO_LEFT :
+		{
+			nFlyDirection = 0;
+			nFlyMethod = 1;
+		}
+		break;
+		case ::com::sun::star::presentation::AnimationEffect_MOVE_TO_TOP :
+		{
+			nFlyDirection = 0;
+			nFlyMethod = 1;
+		}
+		break;
+		case ::com::sun::star::presentation::AnimationEffect_MOVE_TO_RIGHT :
+		{
+			nFlyDirection = 0;
+			nFlyMethod = 1;
+		}
+		break;
+		case ::com::sun::star::presentation::AnimationEffect_MOVE_TO_BOTTOM :
+		{
+			nFlyDirection = 0;
+			nFlyMethod = 1;
+		}
+		break;
+		case ::com::sun::star::presentation::AnimationEffect_SPIRALIN_LEFT :
+		case ::com::sun::star::presentation::AnimationEffect_SPIRALIN_RIGHT :
+		case ::com::sun::star::presentation::AnimationEffect_SPIRALOUT_LEFT :
+		case ::com::sun::star::presentation::AnimationEffect_SPIRALOUT_RIGHT :
+		{
+			nFlyDirection = 0x1c;
+			nFlyMethod = 0xc;
+		}
+		break;
+		case ::com::sun::star::presentation::AnimationEffect_DISSOLVE :
+		{
+			nFlyDirection = 0;
+			nFlyMethod = 5;
+		}
+		break;
+		case ::com::sun::star::presentation::AnimationEffect_WAVYLINE_FROM_LEFT :
+		{
+			nFlyDirection = 2;
+			nFlyMethod = 10;
+		}
+		break;
+		case ::com::sun::star::presentation::AnimationEffect_WAVYLINE_FROM_TOP :
+		{
+			nFlyDirection = 3;
+			nFlyMethod = 10;
+		}
+		break;
+		case ::com::sun::star::presentation::AnimationEffect_WAVYLINE_FROM_RIGHT :
+		{
+			nFlyDirection = 0;
+			nFlyMethod = 10;
+		}
+		break;
+		case ::com::sun::star::presentation::AnimationEffect_WAVYLINE_FROM_BOTTOM :
+		{
+			nFlyDirection = 1;
+			nFlyMethod = 10;
+		}
+		break;
+		case ::com::sun::star::presentation::AnimationEffect_RANDOM :
+		{
+			nFlyDirection = 0;
+			nFlyMethod = 1;
+		}
+		break;
+		case ::com::sun::star::presentation::AnimationEffect_VERTICAL_LINES :
+		{
+			nFlyDirection = 1;
+			nFlyMethod = 8;
+		}
+		break;
+		case ::com::sun::star::presentation::AnimationEffect_HORIZONTAL_LINES :
+		{
+			nFlyDirection = 0;
+			nFlyMethod = 8;
+		}
+		break;
+		case ::com::sun::star::presentation::AnimationEffect_LASER_FROM_LEFT :
+		{
+			nFlyDirection = 2;
+			nFlyMethod = 10;
+		}
+		break;
+		case ::com::sun::star::presentation::AnimationEffect_LASER_FROM_TOP :
+		{
+			nFlyDirection = 3;
+			nFlyMethod = 10;
+		}
+		break;
+		case ::com::sun::star::presentation::AnimationEffect_LASER_FROM_RIGHT :
+		{
+			nFlyDirection = 0;
+			nFlyMethod = 10;
+		}
+		break;
+		case ::com::sun::star::presentation::AnimationEffect_LASER_FROM_BOTTOM :
+		{
+			nFlyDirection = 1;
+			nFlyMethod = 10;
+		}
+		break;
+		case ::com::sun::star::presentation::AnimationEffect_LASER_FROM_UPPERLEFT :
+		{
+			nFlyDirection = 7;
+			nFlyMethod = 9;
+		}
+		break;
+		case ::com::sun::star::presentation::AnimationEffect_LASER_FROM_UPPERRIGHT :
+		{
+			nFlyDirection = 6;
+			nFlyMethod = 9;
+		}
+		break;
+		case ::com::sun::star::presentation::AnimationEffect_LASER_FROM_LOWERLEFT :
+		{
+			nFlyDirection = 5;
+			nFlyMethod = 9;
+		}
+		break;
+		case ::com::sun::star::presentation::AnimationEffect_LASER_FROM_LOWERRIGHT :
+		{
+			nFlyDirection = 4;
+			nFlyMethod = 9;
+		}
+		break;
+		case ::com::sun::star::presentation::AnimationEffect_APPEAR :
+		break;
+		case ::com::sun::star::presentation::AnimationEffect_HIDE :
+		{
+			nFlyDirection = 0;
+			nFlyMethod = 1;
+		}
+		break;
+		case ::com::sun::star::presentation::AnimationEffect_MOVE_FROM_UPPERLEFT :
+		{
+			nFlyDirection = 4;
+			nFlyMethod = 12;
+		}
+		break;
+		case ::com::sun::star::presentation::AnimationEffect_MOVE_FROM_UPPERRIGHT :
+		{
+			nFlyDirection = 5;
+			nFlyMethod = 12;
+		}
+		break;
+		case ::com::sun::star::presentation::AnimationEffect_MOVE_FROM_LOWERRIGHT :
+		{
+			nFlyDirection = 7;
+			nFlyMethod = 12;
+		}
+		break;
+		case ::com::sun::star::presentation::AnimationEffect_MOVE_FROM_LOWERLEFT :
+		{
+			nFlyDirection = 6;
+			nFlyMethod = 12;
+		}
+		break;
+		case ::com::sun::star::presentation::AnimationEffect_MOVE_TO_UPPERLEFT :
+		case ::com::sun::star::presentation::AnimationEffect_MOVE_TO_UPPERRIGHT :
+		case ::com::sun::star::presentation::AnimationEffect_MOVE_TO_LOWERRIGHT :
+		case ::com::sun::star::presentation::AnimationEffect_MOVE_TO_LOWERLEFT :
+			nAfterEffect |= 2;
+		break;
+		case ::com::sun::star::presentation::AnimationEffect_MOVE_SHORT_FROM_LEFT :
+		case ::com::sun::star::presentation::AnimationEffect_MOVE_SHORT_FROM_UPPERLEFT :
+		{
+			nFlyDirection = 8;
+			nFlyMethod = 12;
+		}
+		break;
+		case ::com::sun::star::presentation::AnimationEffect_MOVE_SHORT_FROM_TOP :
+		case ::com::sun::star::presentation::AnimationEffect_MOVE_SHORT_FROM_UPPERRIGHT :
+		{
+			nFlyDirection = 11;
+			nFlyMethod = 12;
+		}
+		break;
+		case ::com::sun::star::presentation::AnimationEffect_MOVE_SHORT_FROM_RIGHT :
+		case ::com::sun::star::presentation::AnimationEffect_MOVE_SHORT_FROM_LOWERRIGHT :
+		{
+			nFlyDirection = 10;
+			nFlyMethod = 12;
+		}
+		break;
+		case ::com::sun::star::presentation::AnimationEffect_MOVE_SHORT_FROM_BOTTOM :
+		case ::com::sun::star::presentation::AnimationEffect_MOVE_SHORT_FROM_LOWERLEFT :
+		{
+			nFlyDirection = 9;
+			nFlyMethod = 12;
+		}
+		break;
+		case ::com::sun::star::presentation::AnimationEffect_MOVE_SHORT_TO_LEFT :
+		case ::com::sun::star::presentation::AnimationEffect_MOVE_SHORT_TO_UPPERLEFT :
+		case ::com::sun::star::presentation::AnimationEffect_MOVE_SHORT_TO_TOP :
+		case ::com::sun::star::presentation::AnimationEffect_MOVE_SHORT_TO_UPPERRIGHT :
+		case ::com::sun::star::presentation::AnimationEffect_MOVE_SHORT_TO_RIGHT :
+		case ::com::sun::star::presentation::AnimationEffect_MOVE_SHORT_TO_LOWERRIGHT :
+		case ::com::sun::star::presentation::AnimationEffect_MOVE_SHORT_TO_BOTTOM :
+		case ::com::sun::star::presentation::AnimationEffect_MOVE_SHORT_TO_LOWERLEFT :
+			nAfterEffect |= 2;
+		break;
+		case ::com::sun::star::presentation::AnimationEffect_VERTICAL_CHECKERBOARD :
+		{
+			nFlyDirection = 1;
+			nFlyMethod = 3;
+		}
+		break;
+		case ::com::sun::star::presentation::AnimationEffect_HORIZONTAL_CHECKERBOARD :
+		{
+			nFlyDirection = 0;
+			nFlyMethod = 3;
+		}
+		break;
+		case ::com::sun::star::presentation::AnimationEffect_HORIZONTAL_ROTATE :
+		case ::com::sun::star::presentation::AnimationEffect_VERTICAL_ROTATE :
+		{
+			nFlyDirection = 27;
+			nFlyMethod = 12;
+		}
+		break;
+		case ::com::sun::star::presentation::AnimationEffect_HORIZONTAL_STRETCH :
+		case ::com::sun::star::presentation::AnimationEffect_VERTICAL_STRETCH :
+		{
+			nFlyDirection = 22;
+			nFlyMethod = 12;
+		}
+		break;
+		case ::com::sun::star::presentation::AnimationEffect_STRETCH_FROM_LEFT :
+		case ::com::sun::star::presentation::AnimationEffect_STRETCH_FROM_UPPERLEFT :
+		{
+			nFlyDirection = 23;
+			nFlyMethod = 12;
+		}
+		break;
+		case ::com::sun::star::presentation::AnimationEffect_STRETCH_FROM_TOP :
+		case ::com::sun::star::presentation::AnimationEffect_STRETCH_FROM_UPPERRIGHT :
+		{
+			nFlyDirection = 24;
+			nFlyMethod = 12;
+		}
+		break;
+		case ::com::sun::star::presentation::AnimationEffect_STRETCH_FROM_RIGHT :
+		case ::com::sun::star::presentation::AnimationEffect_STRETCH_FROM_LOWERRIGHT :
+		{
+			nFlyDirection = 25;
+			nFlyMethod = 12;
+		}
+		break;
+		case ::com::sun::star::presentation::AnimationEffect_STRETCH_FROM_BOTTOM :
+		case ::com::sun::star::presentation::AnimationEffect_STRETCH_FROM_LOWERLEFT :
+		{
+			nFlyDirection = 26;
+			nFlyMethod = 12;
+		}
+		break;
+		case ::com::sun::star::presentation::AnimationEffect_ZOOM_IN :
+		{
+			nFlyDirection = 16;
+			nFlyMethod = 12;
+		}
+		break;
+		case ::com::sun::star::presentation::AnimationEffect_ZOOM_IN_SMALL :
+		case ::com::sun::star::presentation::AnimationEffect_ZOOM_IN_SPIRAL :
+		{
+			nFlyDirection = 17;
+			nFlyMethod = 12;
+		}
+		break;
+		case ::com::sun::star::presentation::AnimationEffect_ZOOM_OUT :
+		{
+			nFlyDirection = 18;
+			nFlyMethod = 12;
+		}
+		break;
+		case ::com::sun::star::presentation::AnimationEffect_ZOOM_OUT_SMALL :
+		case ::com::sun::star::presentation::AnimationEffect_ZOOM_OUT_SPIRAL :
+		{
+			nFlyDirection = 19;
+			nFlyMethod = 12;
+		}
+		break;
+		case ::com::sun::star::presentation::AnimationEffect_ZOOM_IN_FROM_LEFT :
+		case ::com::sun::star::presentation::AnimationEffect_ZOOM_IN_FROM_UPPERLEFT :
+		case ::com::sun::star::presentation::AnimationEffect_ZOOM_IN_FROM_TOP :
+		case ::com::sun::star::presentation::AnimationEffect_ZOOM_IN_FROM_UPPERRIGHT :
+		case ::com::sun::star::presentation::AnimationEffect_ZOOM_IN_FROM_RIGHT :
+		case ::com::sun::star::presentation::AnimationEffect_ZOOM_IN_FROM_LOWERRIGHT :
+		case ::com::sun::star::presentation::AnimationEffect_ZOOM_IN_FROM_BOTTOM :
+		case ::com::sun::star::presentation::AnimationEffect_ZOOM_IN_FROM_LOWERLEFT :
+		case ::com::sun::star::presentation::AnimationEffect_ZOOM_IN_FROM_CENTER :
+		{
+			nFlyDirection = 16;
+			nFlyMethod = 12;
+		}
+		break;
+		case ::com::sun::star::presentation::AnimationEffect_ZOOM_OUT_FROM_LEFT :
+		case ::com::sun::star::presentation::AnimationEffect_ZOOM_OUT_FROM_UPPERLEFT :
+		case ::com::sun::star::presentation::AnimationEffect_ZOOM_OUT_FROM_TOP :
+		case ::com::sun::star::presentation::AnimationEffect_ZOOM_OUT_FROM_UPPERRIGHT :
+		case ::com::sun::star::presentation::AnimationEffect_ZOOM_OUT_FROM_RIGHT :
+		case ::com::sun::star::presentation::AnimationEffect_ZOOM_OUT_FROM_LOWERRIGHT :
+		case ::com::sun::star::presentation::AnimationEffect_ZOOM_OUT_FROM_BOTTOM :
+		case ::com::sun::star::presentation::AnimationEffect_ZOOM_OUT_FROM_LOWERLEFT :
+		case ::com::sun::star::presentation::AnimationEffect_ZOOM_OUT_FROM_CENTER :
+			nAfterEffect |= 2;
+			break;
+		default:
+			break;
+	}
+	if ( mnDiaMode >= 1 )
+		nFlags |= 4;
+	if ( eTe != ::com::sun::star::presentation::AnimationEffect_NONE )
+		nBuildType = 2;
+	if ( ImplGetPropertyValue( String( RTL_CONSTASCII_USTRINGPARAM( "SoundOn" ) ) ) )
+	{
+		sal_Bool bBool;
+		mAny >>= bBool;
+		if ( bBool )
+		{
+			if ( ImplGetPropertyValue( String( RTL_CONSTASCII_USTRINGPARAM( "Sound" ) ) ) )
+			{
+				nSoundRef = maSoundCollection.GetId( *(::rtl::OUString*)mAny.getValue() );
+				if ( nSoundRef )
+					nFlags |= 0x10;
+			}
+		}
+	}
+	sal_Bool bDimHide = FALSE;
+	sal_Bool bDimPrevious = FALSE;
+	if ( ImplGetPropertyValue( String( RTL_CONSTASCII_USTRINGPARAM( "DimHide" ) ) ) )
+		mAny >>= bDimHide;
+	if ( ImplGetPropertyValue( String( RTL_CONSTASCII_USTRINGPARAM( "DimPrevious" ) ) ) )
+		mAny >>= bDimPrevious;
+	if ( bDimPrevious )
+		nAfterEffect |= 1;
+	if ( bDimHide )
+		nAfterEffect |= 2;
+	if ( ImplGetPropertyValue( String( RTL_CONSTASCII_USTRINGPARAM( "DimColor" ) ) ) )
+		nDimColor = mpPptEscherEx->GetColor( *((sal_uInt32*)mAny.getValue()) ) | 0xfe000000;
+
+	rSt << nDimColor << nFlags << nSoundRef << nDelayTime
+		<< nOrder                                   // order of build ( 1.. )
+		<< nSlideCount << nBuildType << nFlyMethod << nFlyDirection
+		<< nAfterEffect << nSubEffect << nOleVerb
+		<< (sal_uInt16)0;                               // PadWord
+}
+
+//  -----------------------------------------------------------------------
+
+void PPTWriter::ImplWriteClickAction( SvStream& rSt, ::com::sun::star::presentation::ClickAction eCa, sal_Bool bMediaClickAction )
+{
+    sal_uInt32 nSoundRef = 0;   // a reference to a sound in the sound collection, or NULL.
+    sal_uInt32 nHyperLinkID = 0;// a persistent unique identifier to an external hyperlink object (only valid when action == HyperlinkAction).
+    sal_uInt8   nAction = 0;     // Action See Action Table
+    sal_uInt8   nOleVerb = 0;    // OleVerb Only valid when action == OLEAction. OLE verb to use, 0 = first verb, 1 = second verb, etc.
+    sal_uInt8   nJump = 0;       // Jump See Jump Table
+    sal_uInt8   nFlags = 0;      // Bit 1: Animated. If 1, then button is animated
+                            // Bit 2: Stop sound. If 1, then stop current sound when button is pressed.
+                            // Bit 3: CustomShowReturn. If 1, and this is a jump to custom show, then return to this slide after custom show.
+    sal_uInt8   nHyperLinkType = 0;// HyperlinkType a value from the LinkTo enum, such as LT_URL (only valid when action == HyperlinkAction).
+
+    String  aFile;
+
+    /*
+        Action Table:       Action Value
+        NoAction            0
+        MacroAction         1
+        RunProgramAction    2
+        JumpAction          3
+        HyperlinkAction     4
+        OLEAction           5
+        MediaAction         6
+        CustomShowAction    7
+
+        Jump Table:     Jump Value
+        NoJump          0
+        NextSlide,      1
+        PreviousSlide,  2
+        FirstSlide,     3
+        LastSlide,      4
+        LastSlideViewed 5
+        EndShow         6
+    */
+
+	if ( bMediaClickAction )
+		nAction = 6;
+	else switch( eCa )
+    {
+        case ::com::sun::star::presentation::ClickAction_STOPPRESENTATION :
+            nJump += 2;
+        case ::com::sun::star::presentation::ClickAction_LASTPAGE :
+            nJump++;
+        case ::com::sun::star::presentation::ClickAction_FIRSTPAGE :
+            nJump++;
+        case ::com::sun::star::presentation::ClickAction_PREVPAGE :
+            nJump++;
+        case ::com::sun::star::presentation::ClickAction_NEXTPAGE :
+        {
+            nJump++;
+            nAction = 3;
+        }
+        break;
+        case ::com::sun::star::presentation::ClickAction_SOUND :
+        {
+            if ( ImplGetPropertyValue( String( RTL_CONSTASCII_USTRINGPARAM( "Bookmark" ) ) ) )
+                nSoundRef = maSoundCollection.GetId( *(::rtl::OUString*)mAny.getValue() );
+        }
+        break;
+        case ::com::sun::star::presentation::ClickAction_PROGRAM :
+        {
+            if ( ImplGetPropertyValue( String( RTL_CONSTASCII_USTRINGPARAM( "Bookmark" ) ) ) )
+            {
+                INetURLObject aUrl( *(::rtl::OUString*)mAny.getValue() );
+                if ( INET_PROT_FILE == aUrl.GetProtocol() )
+                {
+                    aFile = aUrl.PathToFileName();
+                    nAction = 2;
+                }
+            }
+        }
+        break;
+
+        case ::com::sun::star::presentation::ClickAction_BOOKMARK :
+        {
+            if ( ImplGetPropertyValue( String( RTL_CONSTASCII_USTRINGPARAM( "Bookmark" ) ) ) )
+            {
+                String  aBookmark( *(::rtl::OUString*)mAny.getValue() );
+                sal_uInt32 nIndex = 0;
+                for ( String* pStr = (String*)maSlideNameList.First(); pStr; pStr = (String*)maSlideNameList.Next(), nIndex++ )
+                {
+                    if ( *pStr == aBookmark )
+                    {
+                        // Bookmark ist ein link zu einer Dokumentseite
+                        nAction = 4;
+                        nHyperLinkType = 7;
+
+						String aEmpty;
+						String aHyperString = UniString::CreateFromInt32( 256 + nIndex );
+                        aHyperString.Append( String( RTL_CONSTASCII_USTRINGPARAM( "," ) ) );
+                        aHyperString.Append( String::CreateFromInt32( nIndex + 1 ) );
+                        aHyperString.Append( String( RTL_CONSTASCII_USTRINGPARAM( ",Slide " ) ) );
+                        aHyperString.Append( String::CreateFromInt32( nIndex + 1 ) );
+						nHyperLinkID = ImplInsertBookmarkURL( aHyperString, 1 | ( nIndex << 8 ) | ( 1 << 31 ), aBookmark, aEmpty, aEmpty, aHyperString );
+                    }
+                }
+            }
+        }
+        break;
+
+        case ::com::sun::star::presentation::ClickAction_DOCUMENT :
+		{
+            if ( ImplGetPropertyValue( String( RTL_CONSTASCII_USTRINGPARAM( "Bookmark" ) ) ) )
+            {
+                String aBookmark( *(::rtl::OUString*)mAny.getValue() );
+				if ( aBookmark.Len() )
+				{
+					nAction = 4;
+					nHyperLinkType = 8;
+
+					String aEmpty;
+					String aBookmarkFile( aBookmark );
+		            INetURLObject aUrl( aBookmark );
+			        if ( INET_PROT_FILE == aUrl.GetProtocol() )
+					    aBookmarkFile = aUrl.PathToFileName();
+					nHyperLinkID = ImplInsertBookmarkURL( aBookmark, (sal_uInt32)(2 | ( 1 << 31 )), aBookmarkFile, aBookmark, aEmpty, aEmpty );
+				}
+			}
+		}
+		break;
+
+        case ::com::sun::star::presentation::ClickAction_INVISIBLE :
+        case ::com::sun::star::presentation::ClickAction_VERB :
+        case ::com::sun::star::presentation::ClickAction_VANISH :
+        case ::com::sun::star::presentation::ClickAction_MACRO :
+        default :
+        break;
+    }
+
+    sal_uInt32 nContainerSize = 24;
+    if ( nAction == 2 )
+        nContainerSize += ( aFile.Len() * 2 ) + 8;
+    rSt << (sal_uInt32)( ( EPP_InteractiveInfo << 16 ) | 0xf ) << (sal_uInt32)nContainerSize
+        << (sal_uInt32)( EPP_InteractiveInfoAtom << 16 ) << (sal_uInt32)16
+        << nSoundRef
+        << nHyperLinkID
+        << nAction
+        << nOleVerb
+        << nJump
+        << nFlags
+        << (sal_uInt32)nHyperLinkType;
+
+    if ( nAction == 2 )		// run program Action
+    {
+        sal_uInt16 i, nLen = aFile.Len();
+        rSt << (sal_uInt32)( ( EPP_CString << 16 ) | 0x20 ) << (sal_uInt32)( nLen * 2 );
+        for ( i = 0; i < nLen; i++ )
+            rSt << aFile.GetChar( i );
+    }
+
+    rSt << (sal_uInt32)( ( EPP_InteractiveInfo << 16 ) | 0x1f ) << (sal_uInt32)24   // Mouse Over Action
+        << (sal_uInt32)( EPP_InteractiveInfo << 16 ) << (sal_uInt32)16;
+    for ( int i = 0; i < 4; i++, rSt << (sal_uInt32)0 ) ;
+}
+
+//  -----------------------------------------------------------------------
+
+sal_Bool PPTWriter::ImplGetEffect( const ::com::sun::star::uno::Reference< ::com::sun::star::beans::XPropertySet > & rPropSet,
+                                ::com::sun::star::presentation::AnimationEffect& eEffect,
+                                ::com::sun::star::presentation::AnimationEffect& eTextEffect,
+                                sal_Bool& bIsSound )
+{
+    ::com::sun::star::uno::Any aAny;
+    if ( GetPropertyValue( aAny, rPropSet, String( RTL_CONSTASCII_USTRINGPARAM( "Effect" ) ) ) )
+        aAny >>= eEffect;
+    else
+        eEffect = ::com::sun::star::presentation::AnimationEffect_NONE;
+
+    if ( GetPropertyValue( aAny, rPropSet, String( RTL_CONSTASCII_USTRINGPARAM( "TextEffect" ) ) ) )
+        aAny >>= eTextEffect;
+    else
+        eTextEffect = ::com::sun::star::presentation::AnimationEffect_NONE;
+    if ( GetPropertyValue( aAny, rPropSet, String( RTL_CONSTASCII_USTRINGPARAM( "SoundOn" ) ) ) )
+        aAny >>= bIsSound;
+    else
+        bIsSound = FALSE;
+
+    sal_Bool bHasEffect = ( ( eEffect != ::com::sun::star::presentation::AnimationEffect_NONE )
+                        || ( eTextEffect != ::com::sun::star::presentation::AnimationEffect_NONE )
+                        || bIsSound );
+    return bHasEffect;
+};
+
+//  -----------------------------------------------------------------------
+
+sal_Bool PPTWriter::ImplCreatePresentationPlaceholder( const sal_Bool bMasterPage, const PageType /* ePageType */,
+														const sal_uInt32 nStyleInstance, const sal_uInt8 nPlaceHolderId )
+{
+	sal_Bool bRet = ImplGetText();
+	if ( bRet && bMasterPage )
+	{
+		mpPptEscherEx->OpenContainer( ESCHER_SpContainer );
+		sal_uInt32 nPresShapeID = mpPptEscherEx->GetShapeID();
+		mpPptEscherEx->AddShape( ESCHER_ShpInst_Rectangle, 0xa00, nPresShapeID );// Flags: HaveAnchor | HasSpt
+		EscherPropertyContainer aPropOpt;
+		aPropOpt.AddOpt( ESCHER_Prop_LockAgainstGrouping, 0x50001 );
+		aPropOpt.AddOpt( ESCHER_Prop_lTxid, mnTxId += 0x60 );
+		aPropOpt.AddOpt( ESCHER_Prop_AnchorText, ESCHER_AnchorMiddle );
+		aPropOpt.AddOpt( ESCHER_Prop_fNoFillHitTest, 0x110001 );
+		aPropOpt.AddOpt( ESCHER_Prop_lineColor, 0x8000001 );
+		aPropOpt.AddOpt( ESCHER_Prop_shadowColor, 0x8000002 );
+		aPropOpt.CreateFillProperties( mXPropSet, sal_True );
+		sal_uInt32 nLineFlags = 0x90001;
+		if ( aPropOpt.GetOpt( ESCHER_Prop_fNoLineDrawDash, nLineFlags ) )
+			nLineFlags |= 0x10001;  // draw dashed line if no line
+		aPropOpt.AddOpt( ESCHER_Prop_fNoLineDrawDash, nLineFlags );
+
+		SvMemoryStream  aExtBu( 0x200, 0x200 );
+		SvMemoryStream	aClientTextBox( 0x200, 0x200 );
+        ImplWriteTextStyleAtom( aClientTextBox, nStyleInstance, 0, NULL, aExtBu, &aPropOpt );
+
+		aPropOpt.CreateTextProperties( mXPropSet, mnTxId += 0x60, sal_False, sal_True );
+		aPropOpt.Commit( *mpStrm );
+		mpPptEscherEx->AddAtom( 8, ESCHER_ClientAnchor );
+		*mpStrm << (sal_Int16)maRect.Top() << (sal_Int16)maRect.Left() << (sal_Int16)maRect.Right() << (sal_Int16)maRect.Bottom();      // oben, links, rechts, unten ????
+		mpPptEscherEx->OpenContainer( ESCHER_ClientData );
+		mpPptEscherEx->AddAtom( 8, EPP_OEPlaceholderAtom );
+		*mpStrm << (sal_uInt32)0                // PlacementID
+				<< (sal_uInt8)nPlaceHolderId	// PlaceHolderID
+				<< (sal_uInt8)0					// Size of PlaceHolder ( 0 = FULL, 1 = HALF, 2 = QUARTER )
+				<< (sal_uInt16)0;               // padword
+		mpPptEscherEx->CloseContainer();		// ESCHER_ClientData
+/*
+		if ( aExtBu.Tell() )
+        {
+            if ( !pClientData )
+                pClientData = new SvMemoryStream( 0x200, 0x200 );
+            ImplProgTagContainer( pClientData, &aExtBu );
+        }
+*/
+        if ( aClientTextBox.Tell() )
+        {
+            *mpStrm << (sal_uInt32)( ( ESCHER_ClientTextbox << 16 ) | 0xf )
+                    << (sal_uInt32)aClientTextBox.Tell();
+
+            mpStrm->Write( aClientTextBox.GetData(), aClientTextBox.Tell() );
+        }
+		mpPptEscherEx->CloseContainer();    // ESCHER_SpContainer
+	}
+	else
+		bRet = sal_False;
+	return bRet;
+}
+
+//  -----------------------------------------------------------------------
+
+void PPTWriter::ImplCreateShape( sal_uInt32 nType, sal_uInt32 nFlags, EscherSolverContainer& rSolver )
+{
+    sal_uInt32 nId = mpPptEscherEx->GetShapeID();
+    mpPptEscherEx->AddShape( nType, nFlags, nId );
+    rSolver.AddShape( mXShape, nId );
+}
+
+void PPTWriter::ImplCreateTextShape( EscherPropertyContainer& rPropOpt, EscherSolverContainer& rSolver, sal_Bool bFill )
+{
+    mnTextStyle = EPP_TEXTSTYLE_TEXT;
+    mpPptEscherEx->OpenContainer( ESCHER_SpContainer );
+    ImplCreateShape( ESCHER_ShpInst_TextBox, 0xa00, rSolver );
+    if ( bFill )
+        rPropOpt.CreateFillProperties( mXPropSet, sal_True );
+	if ( ImplGetText() )
+		rPropOpt.CreateTextProperties( mXPropSet, mnTxId += 0x60, sal_False, sal_True );
+}
+
+void PPTWriter::ImplWritePage( const PHLayout& rLayout, EscherSolverContainer& aSolverContainer, PageType ePageType, sal_Bool bMasterPage, int nPageNumber )
+{
+    sal_uInt32  nInstance, nGroups, nShapes, nShapeCount, nPer, nLastPer, nIndices, nGroupLevel = 0, nOlePictureId;
+    sal_uInt16  nEffectCount;
+    ::com::sun::star::awt::Point   aTextRefPoint;
+
+    ResetGroupTable( nShapes = mXShapes->getCount() );
+
+    nIndices = nInstance = nLastPer = nShapeCount = nEffectCount = 0;
+
+    sal_Bool bIsTitlePossible = TRUE;           // bei mehr als einem title geht powerpoint in die knie
+
+    sal_uInt32  nOutlinerCount = 0;             // die gliederungsobjekte muessen dem layout entsprechen,
+    sal_uInt32  nPrevTextStyle = 0;                // es darf nicht mehr als zwei geben
+
+    nOlePictureId = 0;
+
+    sal_Bool bAdditionalText = FALSE;
+
+    SvMemoryStream* pClientTextBox = NULL;
+    SvMemoryStream* pClientData = NULL;
+
+    while( GetNextGroupEntry() )
+    {
+        nShapeCount++;
+
+        nPer = ( 5 * nShapeCount ) / nShapes;
+        if ( nPer != nLastPer )
+        {
+            nLastPer = nPer;
+            sal_uInt32 nValue = mnPagesWritten * 5 + nPer;
+            if ( nValue > mnStatMaxValue )
+                nValue = mnStatMaxValue;
+            if ( mbStatusIndicator && ( nValue > mnLatestStatValue ) )
+            {
+                mXStatusIndicator->setValue( nValue );
+                mnLatestStatValue = nValue;
+            }
+        }
+        nGroups = GetGroupsClosed();
+        for ( sal_uInt32 i = 0; i < nGroups; i++, mpPptEscherEx->LeaveGroup() ) ;
+
+        if ( ImplGetShapeByIndex( GetCurrentGroupIndex(), TRUE ) )
+        {
+            sal_Bool bIsSound;
+			sal_Bool bMediaClickAction = sal_False;
+            ::com::sun::star::presentation::AnimationEffect eAe;
+            ::com::sun::star::presentation::AnimationEffect eTe;
+
+            if ( ImplGetPropertyValue( String( RTL_CONSTASCII_USTRINGPARAM( "PresentationOrder" ) ) ) )
+                nEffectCount = *(sal_uInt16*)mAny.getValue();
+
+            sal_Bool bEffect = ImplGetEffect( mXPropSet, eAe, eTe, bIsSound );
+			::com::sun::star::presentation::ClickAction eCa = ::com::sun::star::presentation::ClickAction_NONE;
+            if ( ImplGetPropertyValue( String( RTL_CONSTASCII_USTRINGPARAM( "OnClick" ) ) ) )
+                mAny >>= eCa;
+
+            sal_Bool bGroup = mType == "drawing.Group";
+            sal_Bool bOpenBezier   = mType == "drawing.OpenBezier";
+            sal_Bool bClosedBezier = mType == "drawing.ClosedBezier";
+            sal_Bool bPolyPolygon  = mType == "drawing.PolyPolygon";
+            sal_Bool bPolyLine = mType == "drawing.PolyLine";
+		
+			List        aAdjustmentList;
+            Rectangle   aPolyBoundRect;
+
+            const ::com::sun::star::awt::Size   aSize100thmm( mXShape->getSize() );
+            const ::com::sun::star::awt::Point  aPoint100thmm( mXShape->getPosition() );
+            Rectangle   aRect100thmm( Point( aPoint100thmm.X, aPoint100thmm.Y ), Size( aSize100thmm.Width, aSize100thmm.Height ) );
+            EscherPropertyContainer aPropOpt( (EscherGraphicProvider&)*mpPptEscherEx, mpPicStrm, aRect100thmm );
+
+            if ( bGroup )
+            {
+                SvMemoryStream* pTmp = NULL;
+                ::com::sun::star::uno::Reference< ::com::sun::star::container::XIndexAccess >
+                    aXIndexAccess( mXShape, ::com::sun::star::uno::UNO_QUERY );
+                if ( EnterGroup( aXIndexAccess ) )
+                {
+                    if ( bEffect && !mbUseNewAnimations )
+                    {
+                        pTmp = new SvMemoryStream( 0x200, 0x200 );
+						ImplWriteObjectEffect( *pTmp, eAe, eTe, ++nEffectCount );
+                    }
+					if ( eCa != ::com::sun::star::presentation::ClickAction_NONE )
+					{
+						if ( !pTmp )
+							pTmp = new SvMemoryStream( 0x200, 0x200 );
+						ImplWriteClickAction( *pTmp, eCa, bMediaClickAction );
+					}
+                    sal_uInt32 nShapeId = mpPptEscherEx->EnterGroup( &maRect, pTmp );
+					aSolverContainer.AddShape( mXShape, nShapeId );
+                    delete pTmp;
+                }
+            }
+            else
+            {
+                sal_Bool bIsFontwork = sal_False;
+				sal_Bool bIsHatching = sal_False;
+                ::com::sun::star::uno::Any aAny;
+				::com::sun::star::drawing::FillStyle eFS;
+                if ( GetPropertyValue( aAny, mXPropSet, String( RTL_CONSTASCII_USTRINGPARAM( "IsFontwork" ) ), sal_True ) )
+                    aAny >>= bIsFontwork;
+				if ( GetPropertyValue( aAny, mXPropSet, String( RTL_CONSTASCII_USTRINGPARAM( "FillStyle" ) ), sal_True ) )
+				{
+					aAny >>= eFS;
+					bIsHatching = eFS == ::com::sun::star::drawing::FillStyle_HATCH;
+				}
+                if ( bIsHatching || bIsFontwork || ( mType == "drawing.Measure" ) || ( mType == "drawing.Caption" ) )
+                {
+                    if ( ImplGetPropertyValue( String( RTL_CONSTASCII_USTRINGPARAM( "BoundRect" ) ) ) )
+                    {
+                        ::com::sun::star::awt::Rectangle aRect( *(::com::sun::star::awt::Rectangle*)mAny.getValue() );
+                        maPosition = ImplMapPoint( ::com::sun::star::awt::Point( aRect.X, aRect.Y ) );
+                        maSize = ImplMapSize( ::com::sun::star::awt::Size( aRect.Width, aRect.Height ) );
+                        maRect = Rectangle( Point( maPosition.X, maPosition.Y ), Size( maSize.Width, maSize.Height ) );
+                    }
+					mType = "drawing.dontknow";
+                }
+            }
+            sal_uInt8 nPlaceHolderAtom = EPP_PLACEHOLDER_NONE;
+
+            mnTextSize = 0;
+            mnTextStyle = EPP_TEXTSTYLE_NORMAL;
+
+            if ( mType == "drawing.Custom" )
+            {
+                mpPptEscherEx->OpenContainer( ESCHER_SpContainer );
+				sal_uInt32 nMirrorFlags;
+				rtl::OUString sCustomShapeType;
+				MSO_SPT eShapeType = aPropOpt.GetCustomShapeType( mXShape, nMirrorFlags, sCustomShapeType );
+				if ( sCustomShapeType.equalsAscii( "col-502ad400" ) || sCustomShapeType.equalsAscii( "col-60da8460" ) )
+				{	// sj: creating metafile for customshapes that can't be saved to ms format properly
+					ImplCreateShape( ESCHER_ShpInst_PictureFrame, 0xa00, aSolverContainer );
+					if ( aPropOpt.CreateGraphicProperties( mXPropSet, String( RTL_CONSTASCII_USTRINGPARAM( "MetaFile" ) ), sal_False ) )
+					{
+						aPropOpt.AddOpt( ESCHER_Prop_LockAgainstGrouping, 0x800080 );
+						SdrObject* pObj = GetSdrObjectFromXShape( mXShape );
+						if ( pObj )
+						{
+							Rectangle aBound = pObj->GetCurrentBoundRect();
+							maPosition = ImplMapPoint( ::com::sun::star::awt::Point( aBound.Left(), aBound.Top() ) );
+					        maSize = ImplMapSize( ::com::sun::star::awt::Size ( aBound.GetWidth(), aBound.GetHeight() ) );
+							maRect = Rectangle( Point( maPosition.X, maPosition.Y ), Size( maSize.Width, maSize.Height ) );
+							mnAngle = 0;
+						}
+					}
+				}
+				else
+				{
+	                ImplCreateShape( eShapeType, nMirrorFlags | 0xa00, aSolverContainer );
+					aPropOpt.CreateCustomShapeProperties( eShapeType, mXShape );
+					aPropOpt.CreateFillProperties( mXPropSet, sal_True );
+					if ( ImplGetText() )
+					{
+						if ( !aPropOpt.IsFontWork() )
+							aPropOpt.CreateTextProperties( mXPropSet, mnTxId += 0x60, sal_True, sal_True );
+					}
+				}
+            }
+            else if ( mType == "drawing.Rectangle" )
+            {
+                sal_Int32 nRadius = 0;
+                mpPptEscherEx->OpenContainer( ESCHER_SpContainer );
+                if ( ImplGetPropertyValue( String( RTL_CONSTASCII_USTRINGPARAM( "CornerRadius" ) ) ) )
+                {
+                    mAny >>= nRadius;
+                    nRadius = ImplMapSize( ::com::sun::star::awt::Size( nRadius, 0 ) ).Width;
+                }
+                if ( nRadius )
+                {
+                    ImplCreateShape( ESCHER_ShpInst_RoundRectangle, 0xa00, aSolverContainer ); // Flags: Connector | HasSpt
+                    sal_Int32 nLenght = maRect.GetWidth();
+                    if ( nLenght > maRect.GetHeight() )
+                        nLenght = maRect.GetHeight();
+                    nLenght >>= 1;
+                    if ( nRadius >= nLenght )
+                        nRadius = 0x2a30;                           // 0x2a30 ist PPTs maximum radius
+                    else
+                        nRadius = ( 0x2a30 * nRadius ) / nLenght;
+                    aPropOpt.AddOpt( ESCHER_Prop_adjustValue, nRadius );
+                }
+                else
+                {
+                    ImplCreateShape( ESCHER_ShpInst_Rectangle, 0xa00, aSolverContainer );          // Flags: Connector | HasSpt
+                }
+                aPropOpt.CreateFillProperties( mXPropSet, sal_True );
+				if ( ImplGetText() )
+					aPropOpt.CreateTextProperties( mXPropSet, mnTxId += 0x60, sal_False, sal_False );
+            }
+            else if ( mType == "drawing.Ellipse" )
+            {
+                ::com::sun::star::drawing::CircleKind  eCircleKind( ::com::sun::star::drawing::CircleKind_FULL );
+                PolyStyle ePolyKind = POLY_CHORD;
+                if ( ImplGetPropertyValue( String( RTL_CONSTASCII_USTRINGPARAM( "CircleKind" ) ) ) )
+                {
+                    mAny >>= eCircleKind;
+                    switch ( eCircleKind )
+                    {
+                        case ::com::sun::star::drawing::CircleKind_SECTION :
+                        {
+                            ePolyKind = POLY_PIE;
+                        }
+                        break;
+                        case ::com::sun::star::drawing::CircleKind_ARC :
+                        {
+                            ePolyKind = POLY_ARC;
+                        }
+                        break;
+
+                        case ::com::sun::star::drawing::CircleKind_CUT :
+                        {
+                            ePolyKind = POLY_CHORD;
+                        }
+                        break;
+
+                        default:
+                            eCircleKind = ::com::sun::star::drawing::CircleKind_FULL;
+                    }
+                }
+                if ( eCircleKind == ::com::sun::star::drawing::CircleKind_FULL )
+                {
+                    mpPptEscherEx->OpenContainer( ESCHER_SpContainer );
+                    ImplCreateShape( ESCHER_ShpInst_Ellipse, 0xa00, aSolverContainer );            // Flags: Connector | HasSpt
+                    aPropOpt.CreateFillProperties( mXPropSet, sal_True );
+					if ( ImplGetText() )
+						aPropOpt.CreateTextProperties( mXPropSet, mnTxId += 0x60, sal_False, sal_False );
+				}
+                else
+                {
+                    sal_Int32 nStartAngle, nEndAngle;
+                    if ( !ImplGetPropertyValue( String( RTL_CONSTASCII_USTRINGPARAM( "CircleStartAngle" ) ) ) )
+                        continue;
+                    nStartAngle = *( (sal_Int32*)mAny.getValue() );
+                    if( !ImplGetPropertyValue( String( RTL_CONSTASCII_USTRINGPARAM( "CircleEndAngle" ) ) ) )
+                        continue;
+                    nEndAngle = *( (sal_Int32*)mAny.getValue() );
+                    ::com::sun::star::awt::Point aPoint( mXShape->getPosition() );
+                    ::com::sun::star::awt::Size  aSize( mXShape->getSize() );
+                    ::com::sun::star::awt::Point aStart, aEnd, aCenter;
+                    Rectangle aRect( Point( aPoint.X, aPoint.Y ), Size( aSize.Width, aSize.Height ) );
+                    aStart.X = (sal_Int32)( ( cos( (double)( nStartAngle * F_PI18000 ) ) * 100.0 ) );
+                    aStart.Y = - (sal_Int32)( ( sin( (double)( nStartAngle * F_PI18000 ) ) * 100.0 ) );
+                    aEnd.X = (sal_Int32)( ( cos( (double)( nEndAngle * F_PI18000 ) ) * 100.0 ) );
+                    aEnd.Y = - (sal_Int32)( ( sin( (double)( nEndAngle * F_PI18000 ) ) * 100.0 ) );
+                    aCenter.X = aPoint.X + ( aSize.Width / 2 );
+                    aCenter.Y = aPoint.Y + ( aSize.Height / 2 );
+                    aStart.X += aCenter.X;
+                    aStart.Y += aCenter.Y;
+                    aEnd.X += aCenter.X;
+                    aEnd.Y += aCenter.Y;
+                    Polygon aPolygon( aRect, Point( aStart.X, aStart.Y ), Point( aEnd.X, aEnd.Y ), ePolyKind );
+					sal_Bool bNeedText = sal_True;
+					if ( mnAngle )
+					{
+						aPolygon.Rotate( aRect.TopLeft(), (sal_uInt16)( mnAngle / 10 ) );
+						if ( ImplGetText() )
+						{
+							mpPptEscherEx->EnterGroup( 0,0 );
+							nGroupLevel = mpPptEscherEx->GetGroupLevel();
+							bNeedText = sal_False;
+							bAdditionalText = TRUE;
+							mnTextSize = 0;
+						}
+						mnAngle = 0;
+					}
+                    mpPptEscherEx->OpenContainer( ESCHER_SpContainer );
+                    ImplCreateShape( ESCHER_ShpInst_NotPrimitive, 0xa00, aSolverContainer );       // Flags: Connector | HasSpt
+                    ::com::sun::star::awt::Rectangle aNewRect;
+                    switch ( ePolyKind )
+                    {
+                        case POLY_PIE :
+                        case POLY_CHORD :
+                        {
+                            if ( aPropOpt.CreatePolygonProperties( mXPropSet, ESCHER_CREATEPOLYGON_POLYPOLYGON, sal_False, aNewRect, &aPolygon ) )
+                                aPropOpt.CreateFillProperties( mXPropSet, sal_True );
+                        }
+                        break;
+
+                        case POLY_ARC :
+                        {
+                            if ( aPropOpt.CreatePolygonProperties( mXPropSet, ESCHER_CREATEPOLYGON_POLYLINE, sal_False, aNewRect, &aPolygon ) )
+                                aPropOpt.CreateLineProperties( mXPropSet, sal_False );
+                        }
+                        break;
+                    }
+                    maRect = ImplMapRectangle( aNewRect );
+                    maPosition = ::com::sun::star::awt::Point( maRect.Left(), maRect.Top() );
+                    maSize = ::com::sun::star::awt::Size( maRect.GetWidth(), maRect.GetHeight() );
+					if ( bNeedText && ImplGetText() )
+						aPropOpt.CreateTextProperties( mXPropSet, mnTxId += 0x60, sal_False, sal_False );
+                }
+            }
+            else if ( mType == "drawing.Control" )
+            {
+                ::com::sun::star::uno::Reference< ::com::sun::star::drawing::XControlShape  >
+                    aXControlShape( mXShape, ::com::sun::star::uno::UNO_QUERY );
+                if ( !aXControlShape.is() )
+                    continue;
+                ::com::sun::star::uno::Reference< ::com::sun::star::awt::XControlModel >
+                    aXControlModel( aXControlShape->getControl() );
+                if ( !aXControlModel.is() )
+                    continue;
+
+				sal_Int64 nAspect = ::com::sun::star::embed::Aspects::MSOLE_CONTENT;
+				try
+				{
+					// try to get the aspect when available
+					::com::sun::star::uno::Reference< ::com::sun::star::beans::XPropertySet >
+						xShapeProps( mXShape, ::com::sun::star::uno::UNO_QUERY_THROW );
+					xShapeProps->getPropertyValue( ::rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "Aspect" ) ) ) >>= nAspect;
+				}
+				catch( ::com::sun::star::uno::Exception& )
+				{}
+
+                *mpExEmbed  << (sal_uInt32)( 0xf | ( EPP_ExControl << 16 ) )
+                            << (sal_uInt32)0;               // Size of this container
+
+                sal_uInt32 nSize, nOldPos = mpExEmbed->Tell();
+
+                sal_uInt32 nPageId = nPageNumber;
+                if ( ePageType == MASTER )
+                    nPageId |= 0x80000000;
+                else
+                    nPageId += 0x100;
+                *mpExEmbed  << (sal_uInt32)( EPP_ExControlAtom << 16 )
+                            << (sal_uInt32)4
+                            << nPageId;
+                PPTExOleObjEntry* pEntry = new PPTExOleObjEntry( OCX_CONTROL, mpExEmbed->Tell() );
+                pEntry->xControlModel = aXControlModel;
+                maExOleObj.Insert( pEntry );
+
+                mnExEmbed++;
+
+                *mpExEmbed  << (sal_uInt32)( 1 | ( EPP_ExOleObjAtom << 16 ) )
+                            << (sal_uInt32)24
+                            << (sal_uInt32)nAspect
+                            << (sal_uInt32)2
+                            << (sal_uInt32)mnExEmbed
+                            << (sal_uInt32)0
+                            << (sal_uInt32)4    // index to the persist table
+                            << (sal_uInt32)0x0012de00;
+
+
+                ::com::sun::star::awt::Size     aSize;
+                String          aControlName;
+                SvStorageRef    xTemp( new SvStorage( new SvMemoryStream(), TRUE ) );
+                if ( SvxMSConvertOCXControls::WriteOCXStream( xTemp, aXControlModel, aSize, aControlName ) )
+                {
+                    String  aUserName( xTemp->GetUserName() );
+                    String  aOleIdentifier;
+                    if ( aUserName.Len() )
+                    {
+                        SvStorageStreamRef xCompObj = xTemp->OpenSotStream(
+                            String( RTL_CONSTASCII_USTRINGPARAM( "\1CompObj" ) ),
+                                STREAM_READ | STREAM_NOCREATE | STREAM_SHARE_DENYALL );
+                        xCompObj->Seek( STREAM_SEEK_TO_END );
+                        sal_uInt32  nStreamLen = xCompObj->Tell();
+                        xCompObj->Seek( 0 );
+                        sal_Int16   nVersion, nByteOrder;
+                        sal_Int32   nWinVersion, nVal, nStringLen;
+                        *xCompObj   >> nVersion
+                                    >> nByteOrder
+                                    >> nWinVersion
+                                    >> nVal;
+                        xCompObj->SeekRel( 16 );    // skipping clsid
+                        *xCompObj   >> nStringLen;
+                        if ( ( xCompObj->Tell() + nStringLen ) < nStreamLen )
+                        {
+                            xCompObj->SeekRel( nStringLen );        // now skipping the UserName;
+                            *xCompObj >> nStringLen;
+                            if ( ( xCompObj->Tell() + nStringLen ) < nStreamLen )
+                            {
+                                xCompObj->SeekRel( nStringLen );    // now skipping the clipboard formatname
+                                *xCompObj   >> nStringLen;
+                                if ( ( nStringLen > 1 ) && ( ( xCompObj->Tell() + nStringLen ) < nStreamLen ) )
+                                {   // i think that the OleIdentifier will follow
+                                    ByteString aTemp;
+                                    sal_Char* p = aTemp.AllocBuffer( (USHORT)(nStringLen - 1) );
+                                    xCompObj->Read( p, nStringLen - 1 );
+                                    aOleIdentifier = String( aTemp, gsl_getSystemTextEncoding() );
+                                }
+                            }
+                        }
+                    }
+                    if ( aControlName.Len() )
+                        ImplWriteCString( *mpExEmbed, aControlName, 1 );
+                    if ( aOleIdentifier.Len() )
+                        ImplWriteCString( *mpExEmbed, aOleIdentifier, 2 );
+                    if ( aUserName.Len() )
+                        ImplWriteCString( *mpExEmbed, aUserName, 3 );
+                }
+                nSize = mpExEmbed->Tell() - nOldPos;
+                mpExEmbed->Seek( nOldPos - 4 );
+                *mpExEmbed << nSize;
+                mpExEmbed->Seek( STREAM_SEEK_TO_END );
+                nOlePictureId = mnExEmbed;
+
+                mpPptEscherEx->OpenContainer( ESCHER_SpContainer );
+                sal_uInt32 nSpFlags = SHAPEFLAG_HAVESPT | SHAPEFLAG_HAVEANCHOR | SHAPEFLAG_OLESHAPE;
+                ImplCreateShape( ESCHER_ShpInst_HostControl, nSpFlags, aSolverContainer );
+                if ( aPropOpt.CreateGraphicProperties( mXPropSet, String( RTL_CONSTASCII_USTRINGPARAM( "MetaFile" ) ), sal_False  ) )
+                    aPropOpt.AddOpt( ESCHER_Prop_LockAgainstGrouping, 0x800080 );
+                aPropOpt.AddOpt( ESCHER_Prop_pictureId, mnExEmbed );
+                aPropOpt.AddOpt( ESCHER_Prop_pictureActive, 0x10000 );
+
+                if ( aControlName.Len() )
+                {
+                    sal_uInt16 i, nBufSize;
+                    nBufSize = ( aControlName.Len() + 1 ) << 1;
+                    sal_uInt8* pBuf = new sal_uInt8[ nBufSize ];
+                    sal_uInt8* pTmp = pBuf;
+                    for ( i = 0; i < aControlName.Len(); i++ )
+                    {
+                        sal_Unicode nUnicode = aControlName.GetChar( i );
+                        *pTmp++ = (sal_uInt8)nUnicode;
+                        *pTmp++ = (sal_uInt8)( nUnicode >> 8 );
+                    }
+                    *pTmp++ = 0;
+                    *pTmp = 0;
+                    aPropOpt.AddOpt( ESCHER_Prop_wzName, TRUE, nBufSize, pBuf, nBufSize );
+                }
+            }
+            else if ( mType == "drawing.Connector" )
+            {
+                sal_uInt16 nSpType, nSpFlags;
+                ::com::sun::star::awt::Rectangle aNewRect;
+                if ( aPropOpt.CreateConnectorProperties( mXShape, aSolverContainer, aNewRect, nSpType, nSpFlags ) == sal_False )
+                    continue;
+
+                maRect = ImplMapRectangle( aNewRect );
+                maPosition = ::com::sun::star::awt::Point( maRect.Left(), maRect.Top() );
+                maSize = ::com::sun::star::awt::Size( maRect.GetWidth(), maRect.GetHeight() );
+
+                mpPptEscherEx->OpenContainer( ESCHER_SpContainer );
+                ImplCreateShape( nSpType, nSpFlags, aSolverContainer );
+            }
+            else if ( mType == "drawing.Measure" )
+            {
+                continue;
+            }
+            else if ( mType == "drawing.Line" )
+            {
+                ::com::sun::star::awt::Rectangle aNewRect;
+                aPropOpt.CreatePolygonProperties( mXPropSet, ESCHER_CREATEPOLYGON_LINE, sal_False, aNewRect, NULL );
+                maRect = ImplMapRectangle( aNewRect );
+                maPosition = ::com::sun::star::awt::Point( maRect.Left(), maRect.Top() );
+                maSize = ::com::sun::star::awt::Size( maRect.GetWidth(), maRect.GetHeight() );
+                if ( ImplGetText() )
+                {
+                    aTextRefPoint = ::com::sun::star::awt::Point( maRect.Left(), maRect.Top() );
+                    mnTextSize = 0;
+                    bAdditionalText = TRUE;
+                    mpPptEscherEx->EnterGroup( &maRect,0 );
+                }
+                mpPptEscherEx->OpenContainer( ESCHER_SpContainer );
+                sal_uInt32 nFlags = 0xa00;                                  // Flags: Connector | HasSpt
+                if ( maRect.Top() > maRect.Bottom() )
+                    nFlags |= 0x80;                                         // Flags: VertMirror
+                if ( maRect.Left() > maRect.Right() )
+                    nFlags |= 0x40;                                         // Flags: HorzMirror
+
+                ImplCreateShape( ESCHER_ShpInst_Line, nFlags, aSolverContainer );
+                aPropOpt.AddOpt( ESCHER_Prop_shapePath, ESCHER_ShapeComplex );
+                aPropOpt.CreateLineProperties( mXPropSet, sal_False );
+                mnAngle = 0;
+            }
+            else if ( bPolyPolygon )
+            {
+                if ( ImplGetText() )
+                {
+                    mpPptEscherEx->EnterGroup( 0,0 );
+                    nGroupLevel = mpPptEscherEx->GetGroupLevel();
+                    bAdditionalText = TRUE;
+                    mnTextSize = 0;
+                }
+                mpPptEscherEx->OpenContainer( ESCHER_SpContainer );
+                ImplCreateShape( ESCHER_ShpInst_NotPrimitive, 0xa00, aSolverContainer );            // Flags: Connector | HasSpt
+                ::com::sun::star::awt::Rectangle aNewRect;
+                aPropOpt.CreatePolygonProperties( mXPropSet, ESCHER_CREATEPOLYGON_POLYPOLYGON, sal_False, aNewRect, NULL );
+                maRect = ImplMapRectangle( aNewRect );
+                maPosition = ::com::sun::star::awt::Point( maRect.Left(), maRect.Top() );
+                maSize = ::com::sun::star::awt::Size( maRect.GetWidth(), maRect.GetHeight() );
+                aPropOpt.CreateFillProperties( mXPropSet, sal_True );
+                mnAngle = 0;
+            }
+            else if ( bPolyLine )
+            {
+                if ( ImplGetText() )
+                {
+                    mpPptEscherEx->EnterGroup( 0,0 );
+                    nGroupLevel = mpPptEscherEx->GetGroupLevel();
+                    bAdditionalText = TRUE;
+                    mnTextSize = 0;
+                }
+                mpPptEscherEx->OpenContainer( ESCHER_SpContainer );
+                ImplCreateShape( ESCHER_ShpInst_NotPrimitive, 0xa00, aSolverContainer );            // Flags: Connector | HasSpt
+                ::com::sun::star::awt::Rectangle aNewRect;
+                aPropOpt.CreatePolygonProperties( mXPropSet, ESCHER_CREATEPOLYGON_POLYLINE, sal_False, aNewRect, NULL );
+                maRect = ImplMapRectangle( aNewRect );
+                maPosition = ::com::sun::star::awt::Point( maRect.Left(), maRect.Top() );
+                maSize = ::com::sun::star::awt::Size( maRect.GetWidth(), maRect.GetHeight() );
+                aPropOpt.CreateLineProperties( mXPropSet, sal_False );
+                mnAngle = 0;
+            }
+            else if ( bOpenBezier )
+            {
+                if ( ImplGetText() )
+                {
+                    mpPptEscherEx->EnterGroup( 0,0 );
+                    nGroupLevel = mpPptEscherEx->GetGroupLevel();
+                    bAdditionalText = TRUE;
+                    mnTextSize = 0;
+                }
+                mpPptEscherEx->OpenContainer( ESCHER_SpContainer );
+                ImplCreateShape( ESCHER_ShpInst_NotPrimitive, 0xa00, aSolverContainer );            // Flags: Connector | HasSpt
+                ::com::sun::star::awt::Rectangle aNewRect;
+                aPropOpt.CreatePolygonProperties( mXPropSet, ESCHER_CREATEPOLYGON_POLYLINE, sal_True, aNewRect, NULL );
+                maRect = ImplMapRectangle( aNewRect );
+                maPosition = ::com::sun::star::awt::Point( maRect.Left(), maRect.Top() );
+                maSize = ::com::sun::star::awt::Size( maRect.GetWidth(), maRect.GetHeight() );
+                aPropOpt.CreateLineProperties( mXPropSet, sal_False );
+                mnAngle = 0;
+            }
+            else if ( bClosedBezier )
+            {
+                if ( ImplGetText() )
+                {
+                    mpPptEscherEx->EnterGroup( 0,0 );
+                    nGroupLevel = mpPptEscherEx->GetGroupLevel();
+                    bAdditionalText = TRUE;
+                    mnTextSize = 0;
+                }
+                mpPptEscherEx->OpenContainer( ESCHER_SpContainer );
+                ImplCreateShape( ESCHER_ShpInst_NotPrimitive, 0xa00, aSolverContainer );            // Flags: Connector | HasSpt
+                ::com::sun::star::awt::Rectangle aNewRect;
+                aPropOpt.CreatePolygonProperties( mXPropSet, ESCHER_CREATEPOLYGON_POLYPOLYGON, sal_True, aNewRect, NULL );
+                maRect = ImplMapRectangle( aNewRect );
+                maPosition = ::com::sun::star::awt::Point( maRect.Left(), maRect.Top() );
+                maSize = ::com::sun::star::awt::Size( maRect.GetWidth(), maRect.GetHeight() );
+                aPropOpt.CreateFillProperties( mXPropSet, sal_True );
+                mnAngle = 0;
+            }
+            else if ( ( mType == "drawing.GraphicObject" ) || ( mType == "presentation.GraphicObject" ) )
+            {
+                mpPptEscherEx->OpenContainer( ESCHER_SpContainer );
+
+                // ein GraphicObject kann auch ein ClickMe Element sein
+                if ( mbEmptyPresObj && ( ePageType == NORMAL ) )
+                {
+                    nPlaceHolderAtom = rLayout.nUsedObjectPlaceHolder;
+                    ImplCreateShape( ESCHER_ShpInst_Rectangle, 0x220, aSolverContainer );           // Flags: HaveAnchor | HaveMaster
+                    aPropOpt.AddOpt( ESCHER_Prop_lTxid, mnTxId += 0x60 );
+                    aPropOpt.AddOpt( ESCHER_Prop_fNoFillHitTest, 0x10001 );
+                    aPropOpt.AddOpt( ESCHER_Prop_fNoLineDrawDash, 0x10001 );
+                    aPropOpt.AddOpt( ESCHER_Prop_hspMaster, mnShapeMasterBody );
+                }
+                else
+                {
+                    mXText = ::com::sun::star::uno::Reference<
+                        ::com::sun::star::text::XSimpleText >
+                            ( mXShape, ::com::sun::star::uno::UNO_QUERY );
+
+                    if ( mXText.is() )
+                        mnTextSize = mXText->getString().getLength();
+
+                    if ( mnTextSize )                                       // graphic object oder Flachenfuellung
+                    {
+						/* SJ #i34951#: because M. documents are not allowing GraphicObjects containing text, we
+						have to create a simpe Rectangle with fill bitmap instead (while not allowing BitmapMode_Repeat).
+						*/
+                        ImplCreateShape( ESCHER_ShpInst_Rectangle, 0xa00, aSolverContainer );       // Flags: Connector | HasSpt
+                        if ( aPropOpt.CreateGraphicProperties( mXPropSet, String( RTL_CONSTASCII_USTRINGPARAM( "GraphicURL" ) ), sal_True, sal_True, sal_False ) )
+                        {
+                            aPropOpt.AddOpt( ESCHER_Prop_WrapText, ESCHER_WrapNone );
+                            aPropOpt.AddOpt( ESCHER_Prop_AnchorText, ESCHER_AnchorMiddle );
+                            aPropOpt.AddOpt( ESCHER_Prop_fNoFillHitTest, 0x140014 );
+                            aPropOpt.AddOpt( ESCHER_Prop_fillBackColor, 0x8000000 );
+                            aPropOpt.AddOpt( ESCHER_Prop_fNoLineDrawDash, 0x80000 );
+                            if ( ImplGetText() )
+								aPropOpt.CreateTextProperties( mXPropSet, mnTxId += 0x60, sal_False, sal_False );
+                        }
+                    }
+                    else
+                    {
+                        ImplCreateShape( ESCHER_ShpInst_PictureFrame, 0xa00, aSolverContainer );
+                        if ( aPropOpt.CreateGraphicProperties( mXPropSet, String( RTL_CONSTASCII_USTRINGPARAM( "GraphicURL" ) ), sal_False, sal_True ) )
+                            aPropOpt.AddOpt( ESCHER_Prop_LockAgainstGrouping, 0x800080 );
+                    }
+                }
+            }
+            else if ( ( mType == "drawing.Text" ) || ( mType == "presentation.Notes" ) )
+            {
+                if ( ( ePageType == NOTICE ) && mbPresObj )
+                {
+					if ( ImplCreatePresentationPlaceholder( bMasterPage, ePageType, EPP_TEXTTYPE_Notes, EPP_PLACEHOLDER_MASTERNOTESBODYIMAGE ) )
+						continue;
+					else
+                        nPlaceHolderAtom = EPP_PLACEHOLDER_NOTESBODY;
+                }
+                ImplCreateTextShape( aPropOpt, aSolverContainer, TRUE );
+            }
+            else if ( mType == "presentation.TitleText" )
+            {
+                if ( mbPresObj )
+                {
+                    if ( ( ePageType == NOTICE ) && mbEmptyPresObj )
+                    {
+                        mpPptEscherEx->OpenContainer( ESCHER_SpContainer );
+                        nPlaceHolderAtom = EPP_PLACEHOLDER_MASTERNOTESBODYIMAGE;
+                        ImplCreateShape( ESCHER_ShpInst_Rectangle, 0x200, aSolverContainer );
+                        aPropOpt.CreateLineProperties( mXPropSet, sal_False );
+                        aPropOpt.AddOpt( ESCHER_Prop_fNoFillHitTest, 0x10001 );
+                    }
+                    else if ( rLayout.bTitlePossible && bIsTitlePossible )
+                    {
+                        bIsTitlePossible = FALSE;
+
+						ImplGetText();
+						TextObj aTextObj( mXText, EPP_TEXTTYPE_Title, maFontCollection, (PPTExBulletProvider&)*this );
+                        if ( ePageType == MASTER )
+						{
+							if ( mnTextSize )
+							{
+								::rtl::OUString aUString( mXText->getString() );
+								sal_uInt16 nChar;
+
+								mpPptEscherEx->OpenContainer( ESCHER_SpContainer );
+								mnShapeMasterTitle = mpPptEscherEx->GetShapeID();
+								mpPptEscherEx->AddShape( ESCHER_ShpInst_Rectangle, 0xa00, mnShapeMasterTitle );// Flags: HaveAnchor | HasSpt
+								EscherPropertyContainer aPropertyOptions;
+								aPropertyOptions.AddOpt( ESCHER_Prop_LockAgainstGrouping, 0x50001 );
+								aPropertyOptions.AddOpt( ESCHER_Prop_lTxid, mnTxId += 0x60 );
+								aPropertyOptions.AddOpt( ESCHER_Prop_AnchorText, ESCHER_AnchorMiddle );
+//								aPropertyOptions.AddOpt( ESCHER_Prop_fillColor, nFillColor );
+//								aPropertyOptions.AddOpt( ESCHER_Prop_fillBackColor, nFillBackColor );
+								aPropertyOptions.AddOpt( ESCHER_Prop_fNoFillHitTest, 0x110001 );
+								aPropertyOptions.AddOpt( ESCHER_Prop_lineColor, 0x8000001 );
+								aPropertyOptions.AddOpt( ESCHER_Prop_shadowColor, 0x8000002 );
+								aPropertyOptions.CreateFillProperties( mXPropSet, sal_True );
+								sal_uInt32 nLineFlags = 0x90001;
+								if ( aPropertyOptions.GetOpt( ESCHER_Prop_fNoLineDrawDash, nLineFlags ) )
+									nLineFlags |= 0x10001;  // draw dashed line if no line
+								aPropertyOptions.AddOpt( ESCHER_Prop_fNoLineDrawDash, nLineFlags );
+								aPropertyOptions.CreateTextProperties( mXPropSet, mnTxId += 0x60, sal_False, sal_True );
+								ImplAdjustFirstLineLineSpacing( aTextObj, aPropOpt );
+								aPropertyOptions.Commit( *mpStrm );
+								mpPptEscherEx->AddAtom( 8, ESCHER_ClientAnchor );
+								*mpStrm << (sal_Int16)maRect.Top() << (sal_Int16)maRect.Left() << (sal_Int16)maRect.Right() << (sal_Int16)maRect.Bottom();      // oben, links, rechts, unten ????
+								mpPptEscherEx->OpenContainer( ESCHER_ClientData );
+								mpPptEscherEx->AddAtom( 8, EPP_OEPlaceholderAtom );
+								*mpStrm << (sal_uInt32)0                                                        // PlacementID
+										<< (sal_uInt8)EPP_PLACEHOLDER_MASTERTITLE                               // PlaceHolderID
+										<< (sal_uInt8)0                                                         // Size of PlaceHolder ( 0 = FULL, 1 = HALF, 2 = QUARTER )
+										<< (sal_uInt16)0;                                                       // padword
+								mpPptEscherEx->CloseContainer();    // ESCHER_ClientData
+								mpPptEscherEx->OpenContainer( ESCHER_ClientTextbox );
+								mpPptEscherEx->AddAtom( 4, EPP_TextHeaderAtom );
+								*mpStrm << (sal_uInt32)EPP_TEXTTYPE_Title;
+								mpPptEscherEx->AddAtom( mnTextSize << 1, EPP_TextCharsAtom );
+								const sal_Unicode* pString = aUString;
+								for ( sal_uInt32 i = 0; i < mnTextSize; i++ )
+								{
+									nChar = pString[ i ];       // 0xa -> 0xb weicher Zeilenumbruch
+									if ( nChar == 0xa )
+										nChar++;                // 0xd -> 0xd harter Zeilenumbruch
+									*mpStrm << nChar;
+								}
+								mpPptEscherEx->AddAtom( 6, EPP_BaseTextPropAtom );
+								*mpStrm << (sal_uInt32)( mnTextSize + 1 ) << (sal_uInt16)0;
+								mpPptEscherEx->AddAtom( 10, EPP_TextSpecInfoAtom );
+								*mpStrm << (sal_uInt32)( mnTextSize + 1 ) << (sal_uInt32)1 << (sal_uInt16)0;
+								mpPptEscherEx->CloseContainer();    // ESCHER_ClientTextBox
+								mpPptEscherEx->CloseContainer();    // ESCHER_SpContainer
+								continue;
+							}
+						}
+						else
+						{
+							mpPptEscherEx->OpenContainer( ESCHER_SpContainer );
+							mnTextStyle = EPP_TEXTSTYLE_TITLE;
+							nPlaceHolderAtom = rLayout.nTypeOfTitle;
+							ImplCreateShape( ESCHER_ShpInst_Rectangle, 0x220, aSolverContainer );          // Flags: HaveAnchor | HaveMaster
+							aPropOpt.AddOpt( ESCHER_Prop_hspMaster, mnShapeMasterTitle );
+							aPropOpt.CreateFillProperties( mXPropSet, sal_True );
+							aPropOpt.CreateTextProperties( mXPropSet, mnTxId += 0x60, sal_False, sal_True );
+							ImplAdjustFirstLineLineSpacing( aTextObj, aPropOpt );
+							if ( mbEmptyPresObj )
+							{
+								sal_uInt32 nNoLineDrawDash = 0;
+								aPropOpt.GetOpt( ESCHER_Prop_fNoLineDrawDash, nNoLineDrawDash );
+								nNoLineDrawDash |= 0x10001;
+								aPropOpt.AddOpt( ESCHER_Prop_fNoLineDrawDash, nNoLineDrawDash );
+							}
+						}
+                    }
+                    else
+                        mbPresObj = FALSE;
+                }
+                if ( !mbPresObj )
+                {
+                    mType = "drawing.Text";
+					ImplCreateTextShape( aPropOpt, aSolverContainer, TRUE );
+                }
+            }
+            else if ( ( mType == "presentation.Outliner" ) || ( mType == "presentation.Subtitle" ) )
+            {
+                if ( mbPresObj )
+                {
+                    nOutlinerCount++;
+                    if ( rLayout.bOutlinerPossible && ( nOutlinerCount == 1 ) ||
+                        ( ( rLayout.bSecOutlinerPossible && ( nOutlinerCount == 2 ) )
+                            && ( nPrevTextStyle == EPP_TEXTSTYLE_BODY ) ) )
+                    {
+						ImplGetText();
+						TextObj aTextObj( mXText, EPP_TEXTTYPE_Body, maFontCollection, (PPTExBulletProvider&)*this );
+                        if ( ePageType == MASTER )
+                        {
+                            nPrevTextStyle = EPP_TEXTSTYLE_TITLE;
+							if ( mnTextSize )
+							{
+								mpPptEscherEx->OpenContainer( ESCHER_SpContainer );
+								mnShapeMasterBody = mpPptEscherEx->GetShapeID();
+								mpPptEscherEx->AddShape( ESCHER_ShpInst_Rectangle, 0xa00, mnShapeMasterBody );  // Flags: HaveAnchor | HasSpt
+								EscherPropertyContainer aPropOpt2;
+								aPropOpt2.AddOpt( ESCHER_Prop_LockAgainstGrouping, 0x50001 );
+								aPropOpt2.AddOpt( ESCHER_Prop_lTxid, mnTxId += 0x60 );
+//								aPropOpt2.AddOpt( ESCHER_Prop_fillColor, nFillColor );
+//								aPropOpt2.AddOpt( ESCHER_Prop_fillBackColor, nFillBackColor );
+								aPropOpt2.AddOpt( ESCHER_Prop_fNoFillHitTest, 0x110001 );
+								aPropOpt2.AddOpt( ESCHER_Prop_lineColor, 0x8000001 );
+								aPropOpt2.AddOpt( ESCHER_Prop_fNoLineDrawDash, 0x90001 );
+								aPropOpt2.AddOpt( ESCHER_Prop_shadowColor, 0x8000002 );
+								aPropOpt2.CreateFillProperties( mXPropSet, sal_True );
+								sal_uInt32 nLineFlags = 0x90001;
+								if ( aPropOpt2.GetOpt( ESCHER_Prop_fNoLineDrawDash, nLineFlags ) )
+									nLineFlags |= 0x10001;  // draw dashed line if no line
+								aPropOpt2.AddOpt( ESCHER_Prop_fNoLineDrawDash, nLineFlags );
+								aPropOpt2.CreateTextProperties( mXPropSet, mnTxId += 0x60, sal_False, sal_True );
+								ImplAdjustFirstLineLineSpacing( aTextObj, aPropOpt2 );
+								aPropOpt2.Commit( *mpStrm );
+								mpPptEscherEx->AddAtom( 8, ESCHER_ClientAnchor );
+								*mpStrm << (sal_Int16)maRect.Top() << (sal_Int16)maRect.Left() << (sal_Int16)maRect.Right() << (sal_Int16)maRect.Bottom();  // oben, links, rechts, unten ????
+								mpPptEscherEx->OpenContainer( ESCHER_ClientData );
+								mpPptEscherEx->AddAtom( 8, EPP_OEPlaceholderAtom );
+								*mpStrm << (sal_uInt32)1                                                        // PlacementID
+										<< (sal_uInt8)EPP_PLACEHOLDER_MASTERBODY                                    // PlaceHolderID
+										<< (sal_uInt8)0                                                         // Size of PlaceHolder ( 0 = FULL, 1 = HALF, 2 = QUARTER )
+										<< (sal_uInt16)0;                                                       // padword
+								mpPptEscherEx->CloseContainer();    // ESCHER_ClientData
+								mpPptEscherEx->OpenContainer( ESCHER_ClientTextbox );       // printf
+								mpPptEscherEx->AddAtom( 4, EPP_TextHeaderAtom );
+								*mpStrm << (sal_uInt32)EPP_TEXTTYPE_Body;
+								mnTextSize = aTextObj.Count();
+								aTextObj.Write( mpStrm );
+								mpPptEscherEx->BeginAtom();
+								for ( ParagraphObj* pPara = aTextObj.First() ; pPara; pPara = aTextObj.Next() )
+								{
+									sal_uInt32 nCharCount = pPara->Count();
+									sal_uInt16 nDepth = pPara->nDepth;
+									if ( nDepth > 4)
+										nDepth = 4;
+
+									*mpStrm << nCharCount
+											<< nDepth;
+								}
+								mpPptEscherEx->EndAtom( EPP_BaseTextPropAtom );
+								mpPptEscherEx->AddAtom( 10, EPP_TextSpecInfoAtom );
+								*mpStrm << (sal_uInt32)( mnTextSize ) << (sal_uInt32)1 << (sal_uInt16)0;
+
+								mpPptEscherEx->CloseContainer();    // ESCHER_ClientTextBox
+								mpPptEscherEx->CloseContainer();    // ESCHER_SpContainer
+							}
+                            continue;
+                        }
+						else
+						{
+							mnTextStyle = EPP_TEXTSTYLE_BODY;
+							nPlaceHolderAtom = rLayout.nTypeOfOutliner;
+							mpPptEscherEx->OpenContainer( ESCHER_SpContainer );
+							ImplCreateShape( ESCHER_ShpInst_Rectangle, 0x220, aSolverContainer );          // Flags: HaveAnchor | HaveMaster
+							aPropOpt.AddOpt( ESCHER_Prop_hspMaster, mnShapeMasterBody );
+							aPropOpt.CreateFillProperties( mXPropSet, sal_True );
+							aPropOpt.CreateTextProperties( mXPropSet, mnTxId += 0x60, sal_False, sal_True );
+							ImplAdjustFirstLineLineSpacing( aTextObj, aPropOpt );
+							if ( mbEmptyPresObj )
+							{
+								sal_uInt32 nNoLineDrawDash = 0;
+								aPropOpt.GetOpt( ESCHER_Prop_fNoLineDrawDash, nNoLineDrawDash );
+								nNoLineDrawDash |= 0x10001;
+								aPropOpt.AddOpt( ESCHER_Prop_fNoLineDrawDash, nNoLineDrawDash );
+							}
+						}
+                    }
+                    else
+                        mbPresObj = FALSE;
+                }
+                if ( !mbPresObj )
+                {
+                    mType = "drawing.Text";
+	                ImplCreateTextShape( aPropOpt, aSolverContainer, TRUE );
+                }
+            }
+            else if ( ( mType == "drawing.Page" ) || ( mType == "presentation.Page" ) )
+            {
+                if ( ( ePageType == NOTICE ) && mbPresObj )
+                {
+					if ( ImplCreatePresentationPlaceholder( bMasterPage, ePageType, EPP_TEXTTYPE_Notes, EPP_PLACEHOLDER_MASTERNOTESSLIDEIMAGE ) )
+						continue;
+					else
+                        nPlaceHolderAtom = EPP_PLACEHOLDER_NOTESSLIDEIMAGE;
+                }
+                ImplCreateTextShape( aPropOpt, aSolverContainer, TRUE );
+            }
+            else if ( mType == "drawing.Frame" )
+            {
+                continue;
+            }
+            else if ( ( mType == "drawing.OLE2" ) || ( mType == "presentation.OLE2" )
+                        || ( mType == "presentation.Chart" ) || ( mType == "presentation.Table" )
+                            || ( mType == "presentation.OrgChart" ) )
+            {
+                mpPptEscherEx->OpenContainer( ESCHER_SpContainer );
+                if ( mbEmptyPresObj && ( ePageType == NORMAL ) )
+                {
+                    nPlaceHolderAtom = rLayout.nUsedObjectPlaceHolder;
+                    ImplCreateShape( ESCHER_ShpInst_Rectangle, 0x220, aSolverContainer );              // Flags: HaveAnchor | HaveMaster
+                    aPropOpt.AddOpt( ESCHER_Prop_lTxid, mnTxId += 0x60 );
+                    aPropOpt.AddOpt( ESCHER_Prop_fNoFillHitTest, 0x10001 );
+                    aPropOpt.AddOpt( ESCHER_Prop_fNoLineDrawDash, 0x10001 );
+                    aPropOpt.AddOpt( ESCHER_Prop_hspMaster, mnShapeMasterBody );
+                }
+                else
+                {
+					*mpExEmbed  << (sal_uInt32)( 0xf | ( EPP_ExEmbed << 16 ) )
+								<< (sal_uInt32)0;               // Size of this container
+
+					sal_uInt32 nSize, nOldPos = mpExEmbed->Tell();
+
+					*mpExEmbed  << (sal_uInt32)( EPP_ExEmbedAtom << 16 )
+								<< (sal_uInt32)8
+								<< (sal_uInt32)0    // follow colorscheme : 0->do not follow
+													//                      1->follow collorscheme
+													//                      2->follow text and background scheme
+								<< (sal_uInt8)1     // (bool)set if embedded server can not be locked
+								<< (sal_uInt8)0     // (bool)do not need to send dimension
+								<< (sal_uInt8)0     // (bool)is object a world table
+								<< (sal_uInt8)0;    // pad byte
+
+					PPTExOleObjEntry* pE = new PPTExOleObjEntry( NORMAL_OLE_OBJECT, mpExEmbed->Tell() );
+					pE->xShape = mXShape;
+					maExOleObj.Insert( pE );
+
+					mnExEmbed++;
+
+					sal_Int64 nAspect = ::com::sun::star::embed::Aspects::MSOLE_CONTENT;
+					try
+					{
+						// try to get the aspect when available
+						::com::sun::star::uno::Reference< ::com::sun::star::beans::XPropertySet >
+							xShapeProps( mXShape, ::com::sun::star::uno::UNO_QUERY_THROW );
+						xShapeProps->getPropertyValue( ::rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "Aspect" ) ) ) >>= nAspect;
+					}
+					catch( ::com::sun::star::uno::Exception& )
+					{}
+
+					*mpExEmbed  << (sal_uInt32)( 1 | ( EPP_ExOleObjAtom << 16 ) )
+								<< (sal_uInt32)24
+								<< (sal_uInt32)nAspect		// Aspect
+								<< (sal_uInt32)0
+								<< (sal_uInt32)mnExEmbed    // index to the persist table
+								<< (sal_uInt32)0            // subtype
+								<< (sal_uInt32)0
+								<< (sal_uInt32)0x0012b600;
+
+//					ImplWriteCString( *mpExEmbed, "Photo Editor Photo", 1 );
+//                  ImplWriteCString( *mpExEmbed, "MSPhotoEd.3", 2 );
+//                  ImplWriteCString( *mpExEmbed, "Microsoft Photo Editor 3.0 Photo", 3 );
+
+					nSize = mpExEmbed->Tell() - nOldPos;
+					mpExEmbed->Seek( nOldPos - 4 );
+					*mpExEmbed << nSize;
+					mpExEmbed->Seek( STREAM_SEEK_TO_END );
+					nOlePictureId = mnExEmbed;
+
+                    sal_uInt32 nSpFlags = 0xa00;
+                    if ( nOlePictureId )
+                        nSpFlags |= 0x10;
+                    ImplCreateShape( ESCHER_ShpInst_PictureFrame, nSpFlags, aSolverContainer );
+                    if ( aPropOpt.CreateOLEGraphicProperties( mXShape ) )
+                        aPropOpt.AddOpt( ESCHER_Prop_LockAgainstGrouping, 0x800080 );
+                    if ( nOlePictureId )
+                        aPropOpt.AddOpt( ESCHER_Prop_pictureId, nOlePictureId );
+                }
+            }
+			else if ( mType == "presentation.Header" )
+			{
+				if ( ImplCreatePresentationPlaceholder( bMasterPage, ePageType, EPP_TEXTTYPE_Other, EPP_PLACEHOLDER_MASTERHEADER ) )
+					continue;
+				else
+				{
+					mbPresObj = sal_False;
+                    mType = "drawing.Text";
+	                ImplCreateTextShape( aPropOpt, aSolverContainer, TRUE );
+                }
+			}
+			else if ( mType == "presentation.Footer" )
+			{
+				if ( ImplCreatePresentationPlaceholder( bMasterPage, ePageType, EPP_TEXTTYPE_Other, EPP_PLACEHOLDER_MASTERFOOTER ) )
+					continue;
+				else
+				{
+					mbPresObj = sal_False;
+                    mType = "drawing.Text";
+	                ImplCreateTextShape( aPropOpt, aSolverContainer, TRUE );
+                }
+			}
+			else if ( mType == "presentation.DateTime" )
+			{
+				if ( ImplCreatePresentationPlaceholder( bMasterPage, ePageType, EPP_TEXTTYPE_Other, EPP_PLACEHOLDER_MASTERDATE ) )
+					continue;
+				else
+				{
+					mbPresObj = sal_False;
+                    mType = "drawing.Text";
+	                ImplCreateTextShape( aPropOpt, aSolverContainer, TRUE );
+                }
+			}
+			else if ( mType == "presentation.SlideNumber" )
+			{
+				if ( ImplCreatePresentationPlaceholder( bMasterPage, ePageType, EPP_TEXTTYPE_Other, EPP_PLACEHOLDER_MASTERSLIDENUMBER ) )
+					continue;
+				else
+				{
+					mbPresObj = sal_False;
+                    mType = "drawing.Text";
+	                ImplCreateTextShape( aPropOpt, aSolverContainer, TRUE );
+                }
+			}
+            else if ( ( (sal_Char)'3' == mType.GetChar( 8 ) ) && ( (char)'D' == mType.GetChar( 9 ) ) )  // drawing.3D
+            {
+                // SceneObject, CubeObject, SphereObject, LatheObject, ExtrudeObject, PolygonObject
+                if ( !ImplGetPropertyValue( String( RTL_CONSTASCII_USTRINGPARAM( "Bitmap" ) ) ) )
+                    continue;
+
+                mpPptEscherEx->OpenContainer( ESCHER_SpContainer );
+                ImplCreateShape( ESCHER_ShpInst_PictureFrame, 0xa00, aSolverContainer );
+
+                if ( aPropOpt.CreateGraphicProperties( mXPropSet, String( RTL_CONSTASCII_USTRINGPARAM( "Bitmap" ) ), sal_False ) )
+                    aPropOpt.AddOpt( ESCHER_Prop_LockAgainstGrouping, 0x800080 );
+            }
+			else if ( mType == "drawing.Media" )
+			{
+				mnAngle = 0;
+                mpPptEscherEx->OpenContainer( ESCHER_SpContainer );
+                ImplCreateShape( ESCHER_ShpInst_PictureFrame, 0xa00, aSolverContainer );
+
+				::com::sun::star::uno::Any aAny;
+				if ( PropValue::GetPropertyValue( aAny, mXPropSet, String( RTL_CONSTASCII_USTRINGPARAM( "MediaURL" ) ), sal_True ) )
+				{	
+					rtl::OUString aMediaURL;
+					if ( (aAny >>= aMediaURL ) &&  aMediaURL.getLength() )
+					{
+						// SJ: creating the Media RefObj
+						sal_uInt32 nRefId = ++mnExEmbed;
+
+						*mpExEmbed  << (sal_uInt16)0xf
+									<< (sal_uInt16)EPP_ExMCIMovie		// PPT_PST_ExAviMovie
+									<< (sal_uInt32)0;
+						sal_uInt32 nSize, nStart = mpExEmbed->Tell();
+						*mpExEmbed  << (sal_uInt16)0
+									<< (sal_uInt16)EPP_ExObjRefAtom
+									<< (sal_uInt32)4
+									<< nRefId;
+						*mpExEmbed  << (sal_uInt16)0xf
+									<< (sal_uInt16)EPP_ExVideo
+									<< (sal_uInt32)0;
+
+						*mpExEmbed	<< (sal_uInt16)0
+									<< (sal_uInt16)EPP_ExMediaAtom
+									<< (sal_uInt32)8
+									<< nRefId
+									<< (sal_uInt16)0
+									<< (sal_uInt16)0x435;
+
+						
+						sal_uInt16 i, nStringLen = (sal_uInt16)aMediaURL.getLength();
+						*mpExEmbed << (sal_uInt32)( EPP_CString << 16 ) << (sal_uInt32)( nStringLen * 2 );
+						for ( i = 0; i < nStringLen; i++ )
+						{
+							sal_Unicode nChar = aMediaURL[ i ];
+							*mpExEmbed << nChar;
+						}
+						nSize = mpExEmbed->Tell() - nStart;
+						mpExEmbed->SeekRel( - ( (sal_Int32)nSize + 4 ) );
+						*mpExEmbed << nSize;	// size of PPT_PST_ExMCIMovie
+						mpExEmbed->SeekRel( 0x10 );
+						nSize -= 20;
+						*mpExEmbed << nSize;	// PPT_PST_ExMediaAtom
+						mpExEmbed->SeekRel( nSize );
+
+	                    if ( !pClientData )
+		                    pClientData = new SvMemoryStream( 0x200, 0x200 );
+						*pClientData << (sal_uInt16)0
+									 << (sal_uInt16)EPP_ExObjRefAtom
+									 << (sal_uInt32)4
+									 << nRefId;
+					}
+				}
+			}
+			else if ( mType == "drawing.Table" )
+			{
+				SvMemoryStream* pTmp = NULL;
+				if ( bEffect && !mbUseNewAnimations )
+				{
+					pTmp = new SvMemoryStream( 0x200, 0x200 );
+					ImplWriteObjectEffect( *pTmp, eAe, eTe, ++nEffectCount );
+				}
+				if ( eCa != ::com::sun::star::presentation::ClickAction_NONE )
+				{
+					if ( !pTmp )
+						pTmp = new SvMemoryStream( 0x200, 0x200 );
+					ImplWriteClickAction( *pTmp, eCa, bMediaClickAction );
+				}
+				ImplCreateTable( mXShape, aSolverContainer, aPropOpt );
+				continue;
+			}
+            else if ( mType == "drawing.dontknow" )
+            {
+                mnAngle = 0;
+                mpPptEscherEx->OpenContainer( ESCHER_SpContainer );
+                ImplCreateShape( ESCHER_ShpInst_PictureFrame, 0xa00, aSolverContainer );
+                if ( aPropOpt.CreateGraphicProperties( mXPropSet, String( RTL_CONSTASCII_USTRINGPARAM( "MetaFile" ) ), sal_False ) )
+                    aPropOpt.AddOpt( ESCHER_Prop_LockAgainstGrouping, 0x800080 );
+            }
+            else
+            {
+                continue;
+            }
+            sal_Int32 nPlacementID = -1;
+
+            sal_Bool bClientData = ( bEffect || ( eCa != ::com::sun::star::presentation::ClickAction_NONE ) ||
+                                        nPlaceHolderAtom || nOlePictureId );
+            if ( bClientData )
+            {
+                if ( nPlaceHolderAtom )
+                {
+                    if ( ( mnTextStyle == EPP_TEXTSTYLE_TITLE ) || ( mnTextStyle == EPP_TEXTSTYLE_BODY ) )
+                        nPlacementID = nIndices++;
+                    else
+                    {
+                        switch ( nPlaceHolderAtom )
+                        {
+                            default :
+                            {
+                                if ( nPlaceHolderAtom < 19 )
+                                    break;
+                            }
+                            case EPP_PLACEHOLDER_NOTESBODY :
+                            case EPP_PLACEHOLDER_MASTERDATE :
+                            case EPP_PLACEHOLDER_NOTESSLIDEIMAGE :
+                            case EPP_PLACEHOLDER_MASTERNOTESBODYIMAGE :
+                                nPlacementID = nIndices++;
+                        }
+                    }
+                    if ( !pClientData )
+                        pClientData = new SvMemoryStream( 0x200, 0x200 );
+
+                    *pClientData << (sal_uInt32)( EPP_OEPlaceholderAtom << 16 ) << (sal_uInt32)8
+                                 << nPlacementID                // PlacementID
+                                 << (sal_uInt8)nPlaceHolderAtom // PlaceHolderID
+                                 << (sal_uInt8)0                // Size of PlaceHolder ( 0 = FULL, 1 = HALF, 2 = QUARTER )
+                                 << (sal_uInt16)0;              // padword
+                }
+                if ( nOlePictureId )
+                {
+                    if ( !pClientData )
+                        pClientData = new SvMemoryStream( 0x200, 0x200 );
+
+                    *pClientData << (sal_uInt32)( EPP_ExObjRefAtom << 16 ) << (sal_uInt32)4
+                                 << nOlePictureId;
+                    nOlePictureId = 0;
+                }
+                if ( bEffect )
+                {
+                    if ( !pClientData )
+                        pClientData = new SvMemoryStream( 0x200, 0x200 );
+
+                    // check if it is sensible to replace the object effect with text effect,
+                    // because in Impress there is the possibility to use a compound effect,
+                    // e.g. the object effect is an AnimationEffect_FADE_FROM_LEFT and the
+                    // text effect is a AnimationEffect_FADE_FROM_TOP, in PowerPoint there
+                    // can be used only one effect
+                    if ( mnTextSize && ( eTe != ::com::sun::star::presentation::AnimationEffect_NONE )
+                        && ( eAe != ::com::sun::star::presentation::AnimationEffect_NONE )
+                            && ( eTe != eAe ) )
+                    {
+                        sal_uInt32 nFillStyleFlags, nLineStyleFlags;
+                        if ( aPropOpt.GetOpt( ESCHER_Prop_fNoFillHitTest, nFillStyleFlags )
+                            && aPropOpt.GetOpt( ESCHER_Prop_fNoLineDrawDash, nLineStyleFlags ) )
+                        {
+                            // there is no fillstyle and also no linestyle
+                            if ( ! ( ( nFillStyleFlags & 0x10 ) + ( nLineStyleFlags & 9 ) ) )
+                                eAe = eTe;
+                        }
+                    }
+					if ( !mbUseNewAnimations  )
+						ImplWriteObjectEffect( *pClientData, eAe, eTe, ++nEffectCount );
+                }
+
+                if ( eCa != ::com::sun::star::presentation::ClickAction_NONE )
+                {
+                    if ( !pClientData )
+                        pClientData = new SvMemoryStream( 0x200, 0x200 );
+                    ImplWriteClickAction( *pClientData, eCa, bMediaClickAction );
+                }
+            }
+            if ( ( mnTextStyle == EPP_TEXTSTYLE_TITLE ) || ( mnTextStyle == EPP_TEXTSTYLE_BODY ) )
+            {
+                if ( !pClientTextBox )
+                    pClientTextBox = new SvMemoryStream( 0x200, 0x200 );
+
+                *pClientTextBox << (sal_uInt32)( EPP_OutlineTextRefAtom << 16 ) << (sal_uInt32)4
+                                << nPlacementID;
+
+                if ( mbEmptyPresObj == FALSE )
+                {
+                    if ( ( ePageType == NORMAL ) && ( bMasterPage == FALSE ) )
+                    {   // try to allocate the textruleratom
+                        TextRuleEntry*  pTextRule = (TextRuleEntry*)maTextRuleList.GetCurObject();
+                        while ( pTextRule )
+                        {
+                            int nRulePage = pTextRule->nPageNumber;
+                            if ( nRulePage > nPageNumber )
+                                break;
+                            else if ( nRulePage < nPageNumber )
+                                pTextRule = (TextRuleEntry*)maTextRuleList.Next();
+                            else
+                            {
+                                SvMemoryStream* pOut = pTextRule->pOut;
+                                if ( pOut )
+                                {
+                                    pClientTextBox->Write( pOut->GetData(), pOut->Tell() );
+                                    delete pOut, pTextRule->pOut = NULL;
+                                }
+                                maTextRuleList.Next();
+                                break;
+                            }
+                        }
+                    }
+                }
+            }
+            else
+            {
+				if ( !aPropOpt.IsFontWork() )
+				{
+					if ( mnTextSize || ( nPlaceHolderAtom == EPP_PLACEHOLDER_MASTERDATE ) || ( nPlaceHolderAtom == EPP_PLACEHOLDER_NOTESBODY ) )
+					{
+						int nInstance2;
+						if ( ( nPlaceHolderAtom == EPP_PLACEHOLDER_MASTERDATE ) || ( nPlaceHolderAtom == EPP_PLACEHOLDER_NOTESBODY ) )
+							nInstance2 = 2;
+						else
+							nInstance2 = EPP_TEXTTYPE_Other;     // Text in a Shape
+
+						if ( !pClientTextBox )
+							pClientTextBox = new SvMemoryStream( 0x200, 0x200 );
+
+						SvMemoryStream  aExtBu( 0x200, 0x200 );
+						ImplWriteTextStyleAtom( *pClientTextBox, nInstance2, 0, NULL, aExtBu, &aPropOpt );
+						if ( aExtBu.Tell() )
+						{
+							if ( !pClientData )
+								pClientData = new SvMemoryStream( 0x200, 0x200 );
+							ImplProgTagContainer( pClientData, &aExtBu );
+						}
+					}
+					else if ( nPlaceHolderAtom >= 19 )
+					{
+						if ( !pClientTextBox )
+							pClientTextBox = new SvMemoryStream( 12 );
+
+						*pClientTextBox << (sal_uInt32)( EPP_TextHeaderAtom << 16 ) << (sal_uInt32)4
+										<< (sal_uInt32)7;
+					}
+				}
+            }
+
+			aPropOpt.CreateShadowProperties( mXPropSet );
+            maRect.Justify();
+            if ( mnAngle )
+                ImplFlipBoundingBox( aPropOpt );
+            aPropOpt.Commit( *mpStrm );
+            mpPptEscherEx->AddClientAnchor( maRect );
+
+			if ( pClientData )
+            {
+                *mpStrm << (sal_uInt32)( ( ESCHER_ClientData << 16 ) | 0xf )
+                        << (sal_uInt32)pClientData->Tell();
+
+                mpStrm->Write( pClientData->GetData(), pClientData->Tell() );
+                delete pClientData, pClientData = NULL;
+            }
+            if ( pClientTextBox )
+            {
+                *mpStrm << (sal_uInt32)( ( ESCHER_ClientTextbox << 16 ) | 0xf )
+                        << (sal_uInt32)pClientTextBox->Tell();
+
+                mpStrm->Write( pClientTextBox->GetData(), pClientTextBox->Tell() );
+                delete pClientTextBox, pClientTextBox = NULL;
+            }
+            mpPptEscherEx->CloseContainer();      // ESCHER_SpContainer
+        }
+        nPrevTextStyle = mnTextStyle;
+
+        if ( bAdditionalText )
+        {
+            bAdditionalText = FALSE;
+
+            ::com::sun::star::uno::Any  aAny;
+            EscherPropertyContainer     aPropOpt;
+            mnAngle = ( PropValue::GetPropertyValue( aAny,
+                mXPropSet, String( RTL_CONSTASCII_USTRINGPARAM( "RotateAngle" ) ), sal_True ) )
+                    ? *((sal_Int32*)aAny.getValue() )
+                    : 0;
+
+            aPropOpt.AddOpt( ESCHER_Prop_fNoLineDrawDash, 0x90000 );
+            aPropOpt.AddOpt( ESCHER_Prop_fNoFillHitTest, 0x100000 );
+            if ( mType == "drawing.Line" )
+            {
+                double fDist = hypot( maRect.GetWidth(), maRect.GetHeight() );
+                maRect = Rectangle( Point( aTextRefPoint.X, aTextRefPoint.Y ),
+                                        Point( (sal_Int32)( aTextRefPoint.X + fDist ), aTextRefPoint.Y - 1 ) );
+                ImplCreateTextShape( aPropOpt, aSolverContainer, FALSE );
+                aPropOpt.AddOpt( ESCHER_Prop_FitTextToShape, 0x60006 );        // Size Shape To Fit Text
+                if ( mnAngle < 0 )
+                    mnAngle = ( 36000 + mnAngle ) % 36000;
+                if ( mnAngle )
+                    ImplFlipBoundingBox( aPropOpt );
+            }
+            else
+            {
+                ImplCreateTextShape( aPropOpt, aSolverContainer, FALSE );
+                if ( mnAngle < 0 )
+                    mnAngle = ( 36000 + mnAngle ) % 36000;
+                else
+                    mnAngle = ( 36000 - ( mnAngle % 36000 ) );
+
+                mnAngle *= 655;
+                mnAngle += 0x8000;
+                mnAngle &=~0xffff;  // nAngle auf volle Gradzahl runden
+                aPropOpt.AddOpt( ESCHER_Prop_Rotation, mnAngle );
+                mpPptEscherEx->SetGroupSnapRect( nGroupLevel, maRect );
+                mpPptEscherEx->SetGroupLogicRect( nGroupLevel, maRect );
+            }
+            if ( !pClientTextBox )
+                pClientTextBox = new SvMemoryStream( 0x200, 0x200 );
+
+            SvMemoryStream  aExtBu( 0x200, 0x200 );
+            ImplWriteTextStyleAtom( *pClientTextBox, EPP_TEXTTYPE_Other, 0, NULL, aExtBu, &aPropOpt );
+
+            aPropOpt.Commit( *mpStrm );
+            mpPptEscherEx->AddClientAnchor( maRect );
+
+            *mpStrm << (sal_uInt32)( ( ESCHER_ClientTextbox << 16 ) | 0xf )
+                    << (sal_uInt32)pClientTextBox->Tell();
+
+            mpStrm->Write( pClientTextBox->GetData(), pClientTextBox->Tell() );
+            delete pClientTextBox, pClientTextBox = NULL;
+
+            mpPptEscherEx->CloseContainer();  // ESCHER_SpContainer
+            mpPptEscherEx->LeaveGroup();
+        }
+    }
+    ClearGroupTable();                              // gruppierungen wegschreiben, sofern noch irgendwelche offen sind, was eigendlich nicht sein sollte
+    nGroups = GetGroupsClosed();
+    for ( sal_uInt32 i = 0; i < nGroups; i++, mpPptEscherEx->LeaveGroup() ) ;
+    mnPagesWritten++;
+}
+
+//  -----------------------------------------------------------------------
+
+::com::sun::star::awt::Point PPTWriter::ImplMapPoint( const ::com::sun::star::awt::Point& rPoint )
+{
+    Point aRet( OutputDevice::LogicToLogic( Point( rPoint.X, rPoint.Y ), maMapModeSrc, maMapModeDest ) );
+    return ::com::sun::star::awt::Point( aRet.X(), aRet.Y() );
+}
+
+//  -----------------------------------------------------------------------
+
+::com::sun::star::awt::Size PPTWriter::ImplMapSize( const ::com::sun::star::awt::Size& rSize )
+{
+    Size aRetSize( OutputDevice::LogicToLogic( Size( rSize.Width, rSize.Height ), maMapModeSrc, maMapModeDest ) );
+
+    if ( !aRetSize.Width() )
+        aRetSize.Width()++;
+    if ( !aRetSize.Height() )
+        aRetSize.Height()++;
+    return ::com::sun::star::awt::Size( aRetSize.Width(), aRetSize.Height() );
+}
+
+//  -----------------------------------------------------------------------
+
+Rectangle PPTWriter::ImplMapRectangle( const ::com::sun::star::awt::Rectangle& rRect )
+{
+    ::com::sun::star::awt::Point    aPoint( rRect.X, rRect.Y );
+    ::com::sun::star::awt::Size     aSize( rRect.Width, rRect.Height );
+    ::com::sun::star::awt::Point    aP( ImplMapPoint( aPoint ) );
+    ::com::sun::star::awt::Size     aS( ImplMapSize( aSize ) );
+    return Rectangle( Point( aP.X, aP.Y ), Size( aS.Width, aS.Height ) );
+}
+
+//  -----------------------------------------------------------------------
+
+struct CellBorder
+{
+	sal_Int32						mnPos;		// specifies the distance to the top/left position of the table
+	sal_Int32						mnLength;
+	table::BorderLine				maCellBorder;
+
+	CellBorder() : mnPos ( 0 ), mnLength( 0 ){};
+};
+
+void PPTWriter::ImplCreateCellBorder( const CellBorder* pCellBorder, sal_Int32 nX1, sal_Int32 nY1, sal_Int32 nX2, sal_Int32 nY2 )
+{
+	sal_Int32 nLineWidth = pCellBorder->maCellBorder.OuterLineWidth + pCellBorder->maCellBorder.InnerLineWidth;
+	if ( nLineWidth )
+	{
+		mnAngle = 0;
+		mpPptEscherEx->OpenContainer( ESCHER_SpContainer );
+		EscherPropertyContainer aPropOptSp;
+
+		sal_uInt32 nId = mpPptEscherEx->GetShapeID();
+		mpPptEscherEx->AddShape( ESCHER_ShpInst_Line, 0xa02, nId );
+		aPropOptSp.AddOpt( ESCHER_Prop_shapePath, ESCHER_ShapeComplex );
+		aPropOptSp.AddOpt( ESCHER_Prop_fNoLineDrawDash, 0xa0008 );
+		aPropOptSp.AddOpt( ESCHER_Prop_fshadowObscured, 0x20000 );
+
+		sal_uInt32 nBorderColor = pCellBorder->maCellBorder.Color & 0xff00;					// green
+		nBorderColor |= static_cast< sal_uInt8 >( pCellBorder->maCellBorder.Color ) << 16;	// red
+		nBorderColor |= static_cast< sal_uInt8 >( pCellBorder->maCellBorder.Color >> 16 );	// blue
+		aPropOptSp.AddOpt( ESCHER_Prop_lineColor, nBorderColor );
+
+		aPropOptSp.AddOpt( ESCHER_Prop_lineWidth, nLineWidth * 360 );
+		aPropOptSp.AddOpt( ESCHER_Prop_fc3DLightFace, 0x80000 );
+		aPropOptSp.Commit( *mpStrm );
+		mpPptEscherEx->AddAtom( 16, ESCHER_ChildAnchor );
+		*mpStrm 	<< nX1
+					<< nY1
+					<< nX2
+					<< nY2;
+		mpPptEscherEx->CloseContainer();
+	}
+}
+
+void PPTWriter::ImplCreateTable( uno::Reference< drawing::XShape >& rXShape, EscherSolverContainer& aSolverContainer,
+								EscherPropertyContainer& aPropOpt )
+{
+	mpPptEscherEx->OpenContainer( ESCHER_SpgrContainer );
+	mpPptEscherEx->OpenContainer( ESCHER_SpContainer );
+	mpPptEscherEx->AddAtom( 16, ESCHER_Spgr, 1 );
+	*mpStrm		<< (INT32)maRect.Left()	// Bounding box fuer die Gruppierten shapes an die sie attached werden
+				<< (INT32)maRect.Top()
+				<< (INT32)maRect.Right()
+				<< (INT32)maRect.Bottom();
+
+	sal_uInt32 nShapeId = mpPptEscherEx->GetShapeID();
+	mpPptEscherEx->AddShape( ESCHER_ShpInst_Min, 0x201, nShapeId );		// Flags: Group | Patriarch
+	aSolverContainer.AddShape( rXShape, nShapeId );
+	EscherPropertyContainer aPropOpt2;
+	try
+	{
+		static const rtl::OUString	sModel( RTL_CONSTASCII_USTRINGPARAM ( "Model" ) );
+		static const rtl::OUString sWidth( RTL_CONSTASCII_USTRINGPARAM ( "Width" ) );
+		static const rtl::OUString sHeight( RTL_CONSTASCII_USTRINGPARAM ( "Height" ) );
+
+		uno::Reference< table::XTable > xTable;
+		if ( mXPropSet->getPropertyValue( sModel ) >>= xTable )
+		{
+			uno::Reference< table::XColumnRowRange > xColumnRowRange( xTable, uno::UNO_QUERY_THROW );
+			uno::Reference< container::XIndexAccess > xColumns( xColumnRowRange->getColumns(), uno::UNO_QUERY_THROW );
+			uno::Reference< container::XIndexAccess > xRows( xColumnRowRange->getRows(), uno::UNO_QUERY_THROW );
+			sal_uInt16 nRowCount = static_cast< sal_uInt16 >( xRows->getCount() );
+			sal_uInt16 nColumnCount = static_cast< sal_uInt16 >( xColumns->getCount() );
+
+			std::vector< std::pair< sal_Int32, sal_Int32 > > aColumns;
+			std::vector< std::pair< sal_Int32, sal_Int32 > > aRows;
+
+			awt::Point aPosition( ImplMapPoint( rXShape->getPosition() ) );
+			sal_uInt32 nPosition = aPosition.X;
+			for ( sal_Int32 x = 0; x < nColumnCount; x++ )
+			{
+				uno::Reference< beans::XPropertySet > xPropSet( xColumns->getByIndex( x ), uno::UNO_QUERY_THROW );
+				awt::Size aS( 0, 0 );
+				xPropSet->getPropertyValue( sWidth ) >>= aS.Width;
+				awt::Size aM( ImplMapSize( aS ) );
+				aColumns.push_back( std::pair< sal_Int32, sal_Int32 >( nPosition, aM.Width ) );
+				nPosition += aM.Width;
+			}
+
+			nPosition = aPosition.Y;
+			for ( sal_Int32 y = 0; y < nRowCount; y++ )
+			{
+				uno::Reference< beans::XPropertySet > xPropSet( xRows->getByIndex( y ), uno::UNO_QUERY_THROW );
+				awt::Size aS( 0, 0 );
+				xPropSet->getPropertyValue( sHeight ) >>= aS.Height;
+				awt::Size aM( ImplMapSize( aS ) );
+				aRows.push_back( std::pair< sal_Int32, sal_Int32 >( nPosition, aM.Height ) );
+				nPosition += aM.Height;
+			}
+
+			if ( nRowCount )
+			{
+				SvMemoryStream aMemStrm;
+				aMemStrm.ObjectOwnsMemory( FALSE );
+				aMemStrm << nRowCount
+						 << nRowCount
+						 << (sal_uInt16)4;
+
+				std::vector< std::pair< sal_Int32, sal_Int32 > >::const_iterator aIter( aRows.begin() );
+				while( aIter != aRows.end() )
+					aMemStrm << (*aIter++).second;
+
+				aPropOpt.AddOpt( ESCHER_Prop_LockAgainstGrouping, 0x1000100 );
+				aPropOpt2.AddOpt( ESCHER_Prop_tableProperties, 1 );
+				aPropOpt2.AddOpt( ESCHER_Prop_tableRowProperties, sal_True, aMemStrm.Tell(), static_cast< sal_uInt8* >( const_cast< void* >( aMemStrm.GetData() ) ), aMemStrm.Tell() );
+				aPropOpt.Commit( *mpStrm );
+				aPropOpt2.Commit( *mpStrm, 3, ESCHER_UDefProp );
+				mpPptEscherEx->AddAtom( 8, ESCHER_ClientAnchor );
+				*mpStrm << (sal_Int16)maRect.Top()
+						<< (sal_Int16)maRect.Left()
+						<< (sal_Int16)( maRect.GetWidth()  + maRect.Left() )
+						<< (sal_Int16)( maRect.GetHeight() + maRect.Top() );
+				mpPptEscherEx->CloseContainer();
+
+
+				uno::Reference< table::XCellRange > xCellRange( xTable, uno::UNO_QUERY_THROW );
+				for( sal_Int32 nRow = 0; nRow < xRows->getCount(); nRow++ )
+				{
+					for( sal_Int32 nColumn = 0; nColumn < xColumns->getCount(); nColumn++ )
+					{
+						uno::Reference< table::XMergeableCell > xCell( xCellRange->getCellByPosition( nColumn, nRow ), uno::UNO_QUERY_THROW );
+						if ( !xCell->isMerged() )
+						{
+							sal_Int32 nLeft   = aColumns[ nColumn ].first;
+							sal_Int32 nTop    = aRows[ nRow ].first;
+							sal_Int32 nRight  = nLeft + aColumns[ nColumn ].second;
+							sal_Int32 nBottom = nTop + aRows[ nRow ].second;
+
+							for ( sal_Int32 nColumnSpan = 1; nColumnSpan < xCell->getColumnSpan(); nColumnSpan++ )
+							{
+								sal_uInt32 nC = nColumnSpan + nColumn;
+								if ( nC < aColumns.size() )
+									nRight += aColumns[ nC ].second;
+								else
+									nRight = maRect.Right();
+							}
+							for ( sal_Int32 nRowSpan = 1; nRowSpan < xCell->getRowSpan(); nRowSpan++ )
+							{
+								sal_uInt32 nR = nRowSpan + nRow;
+								if ( nR < aColumns.size() )
+									nBottom += aRows[ nR ].second;
+								else
+									nBottom = maRect.Bottom();
+							}
+
+							mbFontIndependentLineSpacing = sal_False;
+							mXPropSet = uno::Reference< beans::XPropertySet >( xCell, uno::UNO_QUERY_THROW );
+							mXText = uno::Reference< text::XSimpleText >( xCell, uno::UNO_QUERY_THROW );
+							mnTextSize = mXText->getString().getLength();
+
+							::com::sun::star::uno::Any aAny;
+							if ( GetPropertyValue( aAny, mXPropSet, String( RTL_CONSTASCII_USTRINGPARAM( "FontIndependentLineSpacing" ) ) ), sal_True )
+								aAny >>= mbFontIndependentLineSpacing;
+
+							EscherPropertyContainer aPropOptSp;
+							mpPptEscherEx->OpenContainer( ESCHER_SpContainer );
+							ImplCreateShape( ESCHER_ShpInst_Rectangle, 0xa02, aSolverContainer );          // Flags: Connector | HasSpt | Child
+							aPropOptSp.CreateFillProperties( mXPropSet, sal_True );
+							aPropOptSp.AddOpt( ESCHER_Prop_fNoLineDrawDash, 0x90000 );
+                            aPropOptSp.CreateTextProperties( mXPropSet, mnTxId += 0x60, sal_False, sal_True );
+							aPropOptSp.AddOpt( ESCHER_Prop_WrapText, ESCHER_WrapSquare );
+
+                            SvMemoryStream aClientTextBox( 0x200, 0x200 );
+                            SvMemoryStream  aExtBu( 0x200, 0x200 );
+
+                            ImplWriteTextStyleAtom( aClientTextBox, EPP_TEXTTYPE_Other, 0, NULL, aExtBu, &aPropOptSp );
+
+                            aPropOptSp.Commit( *mpStrm );
+                            mpPptEscherEx->AddAtom( 16, ESCHER_ChildAnchor );
+                            *mpStrm 	<< nLeft
+                                        << nTop
+                                        << nRight
+                                        << nBottom;
+
+                            *mpStrm << (sal_uInt32)( ( ESCHER_ClientTextbox << 16 ) | 0xf )
+                                    << (sal_uInt32)aClientTextBox.Tell();
+
+                            mpStrm->Write( aClientTextBox.GetData(), aClientTextBox.Tell() );
+							mpPptEscherEx->CloseContainer();
+						}
+					}
+				}
+
+				static const rtl::OUString sTopBorder( String( RTL_CONSTASCII_USTRINGPARAM( "TopBorder" ) ) );
+				static const rtl::OUString sBottomBorder( String( RTL_CONSTASCII_USTRINGPARAM( "BottomBorder" ) ) );
+				static const rtl::OUString sLeftBorder( String( RTL_CONSTASCII_USTRINGPARAM( "LeftBorder" ) ) );
+				static const rtl::OUString sRightBorder( String( RTL_CONSTASCII_USTRINGPARAM( "RightBorder" ) ) );	
+				static const rtl::OUString	sDiagonalTLBR( RTL_CONSTASCII_USTRINGPARAM ( "DiagonalTLBR" ) );
+				static const rtl::OUString	sDiagonalBLTR( RTL_CONSTASCII_USTRINGPARAM ( "DiagonalBLTR" ) );
+
+				// creating horz lines
+				sal_Int32 nYPos = ImplMapPoint( rXShape->getPosition() ).Y;
+				for( sal_Int32 nLine = 0; nLine < ( xRows->getCount() + 1 ); nLine++ )
+				{
+					sal_Int32 nXPos = ImplMapPoint( rXShape->getPosition() ).X;
+					std::vector< CellBorder > vCellBorders;
+					for( sal_Int32 nColumn = 0; nColumn < xColumns->getCount(); nColumn++ )
+					{
+						uno::Reference< beans::XPropertySet > xPropSet( xColumns->getByIndex( nColumn ), uno::UNO_QUERY_THROW );
+						awt::Size aS( 0, 0 );
+						xPropSet->getPropertyValue( sWidth ) >>= aS.Width;
+						awt::Size aM( ImplMapSize( aS ) );
+
+						CellBorder aCellBorder;
+						aCellBorder.mnPos = nXPos;
+						aCellBorder.mnLength = aM.Width;
+						if ( nLine < xRows->getCount() )
+						{	// top border
+							uno::Reference< table::XMergeableCell > xCell( xCellRange->getCellByPosition( nColumn, nLine ), uno::UNO_QUERY_THROW );
+							uno::Reference< beans::XPropertySet > xPropSet2( xCell, uno::UNO_QUERY_THROW );
+							table::BorderLine aBorderLine;
+							if ( xPropSet2->getPropertyValue( sTopBorder ) >>= aBorderLine )
+								aCellBorder.maCellBorder = aBorderLine;
+						}
+						if ( nLine )
+						{	// bottom border
+							uno::Reference< table::XMergeableCell > xCell( xCellRange->getCellByPosition( nColumn, nLine - 1 ), uno::UNO_QUERY_THROW );
+							uno::Reference< beans::XPropertySet > xPropSet2( xCell, uno::UNO_QUERY_THROW );
+							table::BorderLine aBorderLine;
+							if ( xPropSet2->getPropertyValue( sBottomBorder ) >>= aBorderLine )
+								aCellBorder.maCellBorder = aBorderLine;
+						}
+						vCellBorders.push_back( aCellBorder );
+						nXPos += aM.Width;
+					}
+					std::vector< CellBorder >::const_iterator aCellBorderIter( vCellBorders.begin() );
+					while( aCellBorderIter != vCellBorders.end() )
+					{
+						ImplCreateCellBorder( &*aCellBorderIter, aCellBorderIter->mnPos, nYPos,
+							static_cast< sal_Int32 >( aCellBorderIter->mnPos + aCellBorderIter->mnLength ), nYPos );
+						aCellBorderIter++;
+					}
+					if ( nLine < xRows->getCount() )
+					{
+						uno::Reference< beans::XPropertySet > xPropSet( xRows->getByIndex( nLine ), uno::UNO_QUERY_THROW );
+						awt::Size aS( 0, 0 );
+						xPropSet->getPropertyValue( sHeight ) >>= aS.Height;
+						awt::Size aM( ImplMapSize( aS ) );
+						nYPos += aM.Height;
+					}
+				}
+
+				// creating vertical lines
+				sal_Int32 nXPos = ImplMapPoint( rXShape->getPosition() ).X;
+				for( sal_Int32 nLine = 0; nLine < ( xColumns->getCount() + 1 ); nLine++ )
+				{
+					nYPos = ImplMapPoint( rXShape->getPosition() ).Y;
+					std::vector< CellBorder > vCellBorders;
+					for( sal_Int32 nRow = 0; nRow < xRows->getCount(); nRow++ )
+					{
+						uno::Reference< beans::XPropertySet > xPropSet( xRows->getByIndex( nRow ), uno::UNO_QUERY_THROW );
+						awt::Size aS( 0, 0 );
+						xPropSet->getPropertyValue( sHeight ) >>= aS.Height;
+						awt::Size aM( ImplMapSize( aS ) );
+
+						CellBorder aCellBorder;
+						aCellBorder.mnPos = nYPos;
+						aCellBorder.mnLength = aM.Height;
+						if ( nLine < xColumns->getCount() )
+						{	// left border
+							uno::Reference< table::XMergeableCell > xCell( xCellRange->getCellByPosition( nLine, nRow ), uno::UNO_QUERY_THROW );
+							uno::Reference< beans::XPropertySet > xCellSet( xCell, uno::UNO_QUERY_THROW );
+							table::BorderLine aBorderLine;
+							if ( xCellSet->getPropertyValue( sLeftBorder ) >>= aBorderLine )
+								aCellBorder.maCellBorder = aBorderLine;
+						}
+						if ( nLine )
+						{	// right border
+							uno::Reference< table::XMergeableCell > xCell( xCellRange->getCellByPosition( nLine - 1, nRow ), uno::UNO_QUERY_THROW );
+							uno::Reference< beans::XPropertySet > xCellSet( xCell, uno::UNO_QUERY_THROW );
+							table::BorderLine aBorderLine;
+							if ( xCellSet->getPropertyValue( sRightBorder ) >>= aBorderLine )
+								aCellBorder.maCellBorder = aBorderLine;
+						}
+						vCellBorders.push_back( aCellBorder );
+						nYPos += aM.Height;
+					}
+					std::vector< CellBorder >::const_iterator aCellBorderIter( vCellBorders.begin() );
+					while( aCellBorderIter != vCellBorders.end() )
+					{
+						ImplCreateCellBorder( &*aCellBorderIter, nXPos, aCellBorderIter->mnPos,
+							nXPos, static_cast< sal_Int32 >( aCellBorderIter->mnPos + aCellBorderIter->mnLength ) );
+						aCellBorderIter++;
+					}
+					if ( nLine < xColumns->getCount() )
+					{
+						uno::Reference< beans::XPropertySet > xPropSet( xColumns->getByIndex( nLine ), uno::UNO_QUERY_THROW );
+						awt::Size aS( 0, 0 );
+						xPropSet->getPropertyValue( sWidth ) >>= aS.Width;
+						awt::Size aM( ImplMapSize( aS ) );
+						nXPos += aM.Width;
+					}
+				}
+			}
+		}
+	}
+	catch( uno::Exception& )
+	{
+	}
+	mpPptEscherEx->CloseContainer();
+}
diff --git a/sd/source/filter/pptx/pptx-escherex.cxx b/sd/source/filter/pptx/pptx-escherex.cxx
new file mode 100644
index 0000000..d1ef92f
--- /dev/null
+++ sd/source/filter/pptx/pptx-escherex.cxx
@@ -0,0 +1,359 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: escherex.cxx,v $
+ * $Revision: 1.13 $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+
+// MARKER(update_precomp.py): autogen include statement, do not remove
+#include "precompiled_sd.hxx"
+
+
+#ifndef _PptEscherEx_HXX
+#include "escherex.hxx"
+#endif
+
+// ---------------------------------------------------------------------------------------------
+// ---------------------------------------------------------------------------------------------
+// ---------------------------------------------------------------------------------------------
+
+PptEscherEx::PptEscherEx( SvStream& rOutStrm, UINT32 nDrawings ) :
+	EscherEx				( rOutStrm, nDrawings )
+{
+	mnFIDCLs = nDrawings;
+	mnCurrentDg	= 0;
+	mnCurrentShapeID = 0;
+	mnTotalShapesDgg = 0;
+	mnCurrentShapeMaximumID = 0;
+}
+
+// ---------------------------------------------------------------------------------------------
+
+sal_uInt32 PptEscherEx::DrawingGroupContainerSize()
+{
+	return ImplDggContainerSize() + 8;
+}
+
+void PptEscherEx::WriteDrawingGroupContainer( SvStream& rSt )
+{
+	UINT32 nSize = DrawingGroupContainerSize();
+	rSt << (sal_uInt32)( 0xf | ( 1035 << 16 ) )		// EPP_PPDrawingGroup
+		<< (sal_uInt32)( nSize - 8 );
+
+	ImplWriteDggContainer( rSt );
+}
+
+// ---------------------------------------------------------------------------------------------
+
+sal_uInt32 PptEscherEx::ImplDggContainerSize()
+{
+	UINT32 nSize;
+
+	nSize  = ImplDggAtomSize();
+	nSize += GetBlibStoreContainerSize();
+	nSize += ImplOptAtomSize();
+	nSize += ImplSplitMenuColorsAtomSize();
+
+	return nSize + 8;
+}
+
+void PptEscherEx::ImplWriteDggContainer( SvStream& rSt )
+{
+	sal_uInt32 nSize = ImplDggContainerSize();
+	if ( nSize )
+	{
+		rSt << (sal_uInt32)( 0xf | ( ESCHER_DggContainer << 16 ) )
+			<< (sal_uInt32)( nSize - 8 );
+
+		ImplWriteDggAtom( rSt );
+		WriteBlibStoreContainer( rSt );
+		ImplWriteOptAtom( rSt );
+		ImplWriteSplitMenuColorsAtom( rSt );
+	}
+}
+
+// ---------------------------------------------------------------------------------------------
+
+sal_uInt32 PptEscherEx::ImplDggAtomSize()
+{
+	return maFIDCLs.Tell() + 24;
+}
+
+void PptEscherEx::ImplWriteDggAtom( SvStream& rSt )
+{
+	sal_uInt32 nSize = ImplDggAtomSize();
+	if ( nSize )
+	{
+		rSt << (sal_uInt32)( ESCHER_Dgg << 16 )
+			<< (sal_uInt32)( nSize - 8 )
+			<< mnCurrentShapeID
+			<< (sal_uInt32)( mnFIDCLs + 1 )
+			<< mnTotalShapesDgg
+			<< mnDrawings;
+
+		rSt.Write( maFIDCLs.GetData(), nSize - 24 );
+	}
+}
+
+// ---------------------------------------------------------------------------------------------
+
+#define ESCHER_OPT_COUNT 6
+
+sal_uInt32 PptEscherEx::ImplOptAtomSize()
+{
+	sal_uInt32 nSize = 0;
+	if ( ESCHER_OPT_COUNT )
+		nSize = ( ESCHER_OPT_COUNT * 6 ) + 8;
+	return nSize;
+}
+
+void PptEscherEx::ImplWriteOptAtom( SvStream& rSt )
+{
+	sal_uInt32 nSize = ImplOptAtomSize();
+	if ( nSize )
+	{
+		rSt << (sal_uInt32)( ( ESCHER_OPT << 16 ) | ( ESCHER_OPT_COUNT << 4 ) | 0x3 )
+			<< (sal_uInt32)( nSize - 8 )
+			<< (sal_uInt16)ESCHER_Prop_fillColor			<< (sal_uInt32)0xffb800
+			<< (sal_uInt16)ESCHER_Prop_fillBackColor		<< (sal_uInt32)0
+			<< (sal_uInt16)ESCHER_Prop_fNoFillHitTest		<< (sal_uInt32)0x00100010
+			<< (sal_uInt16)ESCHER_Prop_lineColor			<< (sal_uInt32)0x8000001
+			<< (sal_uInt16)ESCHER_Prop_fNoLineDrawDash		<< (sal_uInt32)0x00080008
+			<< (sal_uInt16)ESCHER_Prop_shadowColor			<< (sal_uInt32)0x8000002;
+	}
+}
+
+// ---------------------------------------------------------------------------------------------
+
+#define ESCHER_SPLIT_MENU_COLORS_COUNT	4
+
+sal_uInt32 PptEscherEx::ImplSplitMenuColorsAtomSize()
+{
+	sal_uInt32 nSize = 0;
+	if ( ESCHER_SPLIT_MENU_COLORS_COUNT )
+		nSize = ( ESCHER_SPLIT_MENU_COLORS_COUNT << 2 ) + 8;
+	return nSize;
+}
+
+void PptEscherEx::ImplWriteSplitMenuColorsAtom( SvStream& rSt )
+{
+	UINT32 nSize = ImplSplitMenuColorsAtomSize();
+	if ( nSize )
+	{
+		rSt << (sal_uInt32)( ( ESCHER_SplitMenuColors << 16 ) | ( ESCHER_SPLIT_MENU_COLORS_COUNT << 4 ) )
+			<< (sal_uInt32)( nSize - 8 )
+			<< (sal_uInt32)0x08000004
+			<< (sal_uInt32)0x08000001
+			<< (sal_uInt32)0x08000002
+			<< (sal_uInt32)0x100000f7;
+	}
+
+}
+
+// ---------------------------------------------------------------------------------------------
+
+PptEscherEx::~PptEscherEx()
+{
+}
+
+// ---------------------------------------------------------------------------------------------
+
+void PptEscherEx::OpenContainer( UINT16 n_EscherContainer, int nRecInstance )
+{
+	*mpOutStrm << (UINT16)( ( nRecInstance << 4 ) | 0xf  ) << n_EscherContainer << (UINT32)0;
+	mOffsets.push_back( mpOutStrm->Tell() - 4 );
+	mRecTypes.push_back( n_EscherContainer );
+
+	switch( n_EscherContainer )
+	{
+		case ESCHER_DgContainer :
+		{
+			if ( !mbEscherDg )
+			{
+				mbEscherDg = TRUE;
+				mnCurrentDg++;
+				mnTotalShapesDg = 0;
+				mnTotalShapeIdUsedDg = 0;
+				mnCurrentShapeID = ( mnCurrentShapeMaximumID &~0x3ff ) + 0x400;	// eine neue Seite bekommt immer eine neue ShapeId die ein vielfaches von 1024 ist,
+																				// damit ist erste aktuelle Shape ID 0x400
+				AddAtom( 8, ESCHER_Dg, 0, mnCurrentDg );
+				PtReplaceOrInsert( ESCHER_Persist_Dg | mnCurrentDg, mpOutStrm->Tell() );
+				*mpOutStrm << (UINT32)0		// The number of shapes in this drawing
+						   << (UINT32)0;	// The last MSOSPID given to an SP in this DG
+			}
+		}
+		break;
+
+		case ESCHER_SpgrContainer :
+		{
+			if ( mbEscherDg )
+			{
+				mbEscherSpgr = TRUE;
+			}
+		}
+		break;
+
+		case ESCHER_SpContainer :
+		{
+		}
+		break;
+
+		default:
+		break;
+	}
+}
+
+// ---------------------------------------------------------------------------------------------
+
+void PptEscherEx::CloseContainer()
+{
+	/* SJ: #Issue 26747#
+	   not creating group objects with a depth higher than 16, because then
+	   PPT is having a big performance problem when starting a slide show
+	*/
+	if ( ( mRecTypes.back() != ESCHER_SpgrContainer ) || ( mnGroupLevel < 12 ) )
+	{
+		UINT32 nSize, nPos = mpOutStrm->Tell();
+		nSize = ( nPos - mOffsets.back() ) - 4;
+		mpOutStrm->Seek( mOffsets.back() );
+		*mpOutStrm << nSize;
+
+		switch( mRecTypes.back() )
+		{
+			case ESCHER_DgContainer :
+			{
+				if ( mbEscherDg )
+				{
+					mbEscherDg = FALSE;
+					if ( DoSeek( ESCHER_Persist_Dg | mnCurrentDg ) )
+					{
+						// shapeanzahl des drawings setzen
+						mnTotalShapesDgg += mnTotalShapesDg;
+						*mpOutStrm << mnTotalShapesDg << mnCurrentShapeMaximumID;
+
+						if ( !mnTotalShapesDg )
+						{
+							maFIDCLs << (UINT32)0
+									<< (UINT32)0;
+						}
+						else
+						{
+							if ( mnTotalShapeIdUsedDg )
+							{
+								UINT32 i, nFIDCL = ( ( mnTotalShapeIdUsedDg - 1 ) / 0x400 );
+								if ( nFIDCL )
+									mnFIDCLs += nFIDCL;
+								for ( i = 0; i <= nFIDCL; i++ )
+								{
+									maFIDCLs << mnCurrentDg;			// drawing number
+									if ( i < nFIDCL )
+										maFIDCLs << 0x400;
+									else
+									{
+										UINT32 nShapesLeft = mnTotalShapeIdUsedDg % 0x400;
+										if ( !nShapesLeft )
+											nShapesLeft = 0x400;		// shape count in this IDCL
+										maFIDCLs << (UINT32)nShapesLeft;
+									}
+								}
+							}
+						}
+					}
+				}
+			}
+			break;
+
+			case ESCHER_SpgrContainer :
+			{
+				if ( mbEscherSpgr )
+				{
+					mbEscherSpgr = FALSE;
+
+				}
+			}
+			break;
+
+			default:
+			break;
+		}
+		mOffsets.pop_back();
+		mRecTypes.pop_back();
+		mpOutStrm->Seek( nPos );
+	}
+}
+
+// ---------------------------------------------------------------------------------------------
+
+sal_uInt32 PptEscherEx::EnterGroup( Rectangle* pBoundRect, SvMemoryStream* pClientData )
+{
+	sal_uInt32 nShapeId = 0;
+	/* SJ: #Issue 26747#
+	   not creating group objects with a depth higher than 16, because then
+	   PPT is having a big performance problem when starting a slide show
+	*/
+	if ( mnGroupLevel < 12 )
+	{
+		Rectangle aRect;
+		if ( pBoundRect )
+			aRect = *pBoundRect;
+
+		OpenContainer( ESCHER_SpgrContainer );
+		OpenContainer( ESCHER_SpContainer );
+		AddAtom( 16, ESCHER_Spgr, 1 );
+		PtReplaceOrInsert( ESCHER_Persist_Grouping_Snap | mnGroupLevel, mpOutStrm->Tell() );
+		*mpOutStrm	<< (INT32)aRect.Left()	// Bounding box fuer die Gruppierten shapes an die sie attached werden
+					<< (INT32)aRect.Top()
+					<< (INT32)aRect.Right()
+					<< (INT32)aRect.Bottom();
+
+		nShapeId = GetShapeID();
+		if ( !mnGroupLevel )
+			AddShape( ESCHER_ShpInst_Min, 5, nShapeId );					// Flags: Group | Patriarch
+		else
+		{
+			AddShape( ESCHER_ShpInst_Min, 0x201, nShapeId );				// Flags: Group | HaveAnchor
+			AddAtom( 8, ESCHER_ClientAnchor );
+			PtReplaceOrInsert( ESCHER_Persist_Grouping_Logic | mnGroupLevel, mpOutStrm->Tell() );
+			*mpOutStrm << (INT16)aRect.Top() << (INT16)aRect.Left() << (INT16)aRect.Right() << (INT16)aRect.Bottom();
+		}
+		if ( pClientData )
+		{
+			pClientData->Seek( STREAM_SEEK_TO_END );
+			sal_uInt32 nSize = pClientData->Tell();
+			if ( nSize )
+			{
+				*mpOutStrm << (sal_uInt32)( ( ESCHER_ClientData << 16 ) | 0xf )
+						<< nSize;
+				mpOutStrm->Write( pClientData->GetData(), nSize );
+			}
+		}
+		CloseContainer();												// ESCHER_SpContainer
+	}
+	mnGroupLevel++;
+	return nShapeId;
+}
+
+// ---------------------------------------------------------------------------------------------
diff --git a/sd/source/filter/pptx/pptx-pptexanimations.cxx b/sd/source/filter/pptx/pptx-pptexanimations.cxx
new file mode 100644
index 0000000..2b2588a
--- /dev/null
+++ sd/source/filter/pptx/pptx-pptexanimations.cxx
@@ -0,0 +1,2194 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: pptexanimations.cxx,v $
+ * $Revision: 1.15.108.1 $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+
+// MARKER(update_precomp.py): autogen include statement, do not remove
+#include "precompiled_sd.hxx"
+#include <com/sun/star/animations/XAnimationNodeSupplier.hpp>
+#include <com/sun/star/animations/AnimationFill.hpp>
+#include <com/sun/star/animations/AnimationRestart.hpp>
+#include <com/sun/star/animations/Timing.hpp>
+#include <com/sun/star/animations/Event.hpp>
+#include <com/sun/star/animations/AnimationEndSync.hpp>
+#include <com/sun/star/animations/EventTrigger.hpp>
+#include <com/sun/star/presentation/EffectNodeType.hpp>
+#include <com/sun/star/presentation/EffectPresetClass.hpp>
+#include <com/sun/star/animations/AnimationNodeType.hpp>
+#include <com/sun/star/animations/AnimationTransformType.hpp>
+#include <com/sun/star/animations/AnimationCalcMode.hpp>
+#include <com/sun/star/animations/AnimationValueType.hpp>
+#include <com/sun/star/util/XCloneable.hpp>
+#include <com/sun/star/animations/AnimationAdditiveMode.hpp>
+#include <com/sun/star/animations/XAnimateSet.hpp>
+#include <com/sun/star/animations/XAudio.hpp>
+#include <com/sun/star/animations/XTransitionFilter.hpp>
+#include <com/sun/star/animations/XAnimateColor.hpp>
+#include <com/sun/star/animations/XAnimateMotion.hpp>
+#include <com/sun/star/animations/XAnimateTransform.hpp>
+#include <com/sun/star/animations/TransitionType.hpp>
+#include <com/sun/star/animations/TransitionSubType.hpp>
+#include <com/sun/star/animations/ValuePair.hpp>
+#include <com/sun/star/animations/AnimationColorSpace.hpp>
+#include <com/sun/star/beans/NamedValue.hpp>
+#include <com/sun/star/drawing/FillStyle.hpp>
+#include <com/sun/star/drawing/LineStyle.hpp>
+#include <com/sun/star/awt/FontWeight.hpp>
+#include <com/sun/star/awt/FontUnderline.hpp>
+#include <com/sun/star/awt/FontSlant.hpp>
+#include <com/sun/star/container/XEnumerationAccess.hpp>
+#include <com/sun/star/presentation/ParagraphTarget.hpp>
+#include <com/sun/star/text/XSimpleText.hpp>
+#include <com/sun/star/animations/XIterateContainer.hpp>
+#include <com/sun/star/presentation/TextAnimationType.hpp>
+#include <com/sun/star/container/XChild.hpp>
+#include <comphelper/processfactory.hxx>
+#include <rtl/ustrbuf.hxx>
+#ifndef _RTL_MEMORY_H_
+#include <rtl/memory.hxx>
+#endif
+
+#include <vcl/vclenum.hxx>
+#include <svx/svdotext.hxx>
+#include <svx/outlobj.hxx>
+#include <svx/editobj.hxx>
+#include <pptexanimations.hxx>
+#include <osl/endian.h>
+
+#include <algorithm>
+
+using ::std::map;
+using ::rtl::OUString;
+using ::rtl::OUStringBuffer;
+using ::com::sun::star::uno::Any;
+using ::com::sun::star::container::XChild;
+using ::com::sun::star::util::XCloneable;
+using ::com::sun::star::uno::Reference;
+using ::com::sun::star::uno::UNO_QUERY;
+using ::com::sun::star::uno::UNO_QUERY_THROW;
+using ::com::sun::star::uno::Sequence;
+using ::com::sun::star::uno::makeAny;
+using ::com::sun::star::uno::Exception;
+using ::com::sun::star::uno::XInterface;
+using ::com::sun::star::beans::NamedValue;
+using ::com::sun::star::container::XEnumerationAccess;
+using ::com::sun::star::container::XEnumeration;
+using ::com::sun::star::lang::XMultiServiceFactory;
+
+using namespace ::com::sun::star::text;
+using namespace ::com::sun::star::drawing;
+using namespace ::com::sun::star::animations;
+using namespace ::com::sun::star::presentation;
+
+namespace ppt
+{
+
+void ImplTranslateAttribute( rtl::OUString& rString, const TranslateMode eTranslateMode )
+{
+	if ( eTranslateMode != TRANSLATE_NONE )
+	{
+		if ( ( eTranslateMode & TRANSLATE_VALUE ) || ( eTranslateMode & TRANSLATE_ATTRIBUTE ) )
+		{
+			const ImplAttributeNameConversion* p = gImplConversionList;
+			while( p->mpAPIName )
+			{
+				if( rString.compareToAscii( p->mpAPIName ) == 0 )
+					break;
+				p++;
+			}
+			if( p->mpMSName )
+			{
+				if ( eTranslateMode & TRANSLATE_VALUE )
+				{
+					rString = rtl::OUString( (sal_Unicode)'#' );
+					rString += OUString::createFromAscii( p->mpMSName );
+				}
+				else
+					rString = OUString::createFromAscii( p->mpMSName );
+			}
+		}
+		else if ( eTranslateMode & TRANSLATE_MEASURE )
+		{
+			const sal_Char* pDest[] = { "#ppt_x", "#ppt_y", "#ppt_w", "#ppt_h", NULL };
+			const sal_Char* pSource[] = { "x", "y", "width", "height", NULL };
+			sal_Int32 nIndex = 0;
+
+			const sal_Char** ps = pSource;
+			const sal_Char** pd = pDest;
+
+			while( *ps )
+			{
+				const OUString aSearch( OUString::createFromAscii( *ps ) );
+				while( (nIndex = rString.indexOf( aSearch, nIndex )) != -1  )
+				{
+					sal_Int32 nLength = aSearch.getLength();
+					if( nIndex && (rString.getStr()[nIndex-1] == '#' ) )
+					{
+						nIndex--;
+						nLength++;
+					}
+
+					const OUString aNew( OUString::createFromAscii( *pd ) );
+					rString = rString.replaceAt( nIndex, nLength, aNew );
+					nIndex += aNew.getLength();
+				}
+				ps++;
+				pd++;
+			}
+		}
+	}
+}
+
+sal_uInt32 ImplTranslatePresetSubType( const sal_uInt32 nPresetClass, const sal_uInt32 nPresetId, const rtl::OUString& rPresetSubType )
+{
+	sal_uInt32	nPresetSubType = 0;
+	sal_Bool	bTranslated = sal_False;
+
+	if ( ( nPresetClass == (sal_uInt32)EffectPresetClass::ENTRANCE ) || ( nPresetClass == (sal_uInt32)EffectPresetClass::EXIT ) )
+	{
+		if ( nPresetId != 21 )
+		{
+			switch( nPresetId )
+			{
+				case 5 :
+				{
+					if ( rPresetSubType.equalsAsciiL( RTL_CONSTASCII_STRINGPARAM( "downward" ) ) )
+					{
+						nPresetSubType = 5;
+						bTranslated = sal_True;
+					}
+					else if ( rPresetSubType.equalsAsciiL( RTL_CONSTASCII_STRINGPARAM( "across" ) ) )
+					{
+						nPresetSubType = 10;
+						bTranslated = sal_True;
+					}
+				}
+				break;
+				case 17 :
+				{
+					if ( rPresetSubType.equalsAsciiL( RTL_CONSTASCII_STRINGPARAM( "across" ) ) )
+					{
+						nPresetSubType = 10;
+						bTranslated = sal_True;
+					}
+				}
+				break;
+				case 18 :
+				{
+					if ( rPresetSubType.equalsAsciiL( RTL_CONSTASCII_STRINGPARAM( "right-to-top" ) ) )
+					{
+						nPresetSubType = 3;
+						bTranslated = sal_True;
+					}
+					else if ( rPresetSubType.equalsAsciiL( RTL_CONSTASCII_STRINGPARAM( "right-to-bottom" ) ) )
+					{
+						nPresetSubType = 6;
+						bTranslated = sal_True;
+					}
+					else if ( rPresetSubType.equalsAsciiL( RTL_CONSTASCII_STRINGPARAM( "left-to-top" ) ) )
+					{
+						nPresetSubType = 9;
+						bTranslated = sal_True;
+					}
+					else if ( rPresetSubType.equalsAsciiL( RTL_CONSTASCII_STRINGPARAM( "left-to-bottom" ) ) )
+					{
+						nPresetSubType = 12;
+						bTranslated = sal_True;
+					}
+				}
+				break;
+			}
+		}
+		if ( !bTranslated )
+		{
+			const convert_subtype* p = gConvertArray;
+			while( p->mpStrSubType )
+			{
+				if ( rPresetSubType.equalsAscii( p->mpStrSubType ) )
+				{
+					nPresetSubType = p->mnID;
+					bTranslated = sal_True;
+					break;
+				}
+				p++;
+			}
+		}
+	}
+	if ( !bTranslated )
+		nPresetSubType = (sal_uInt32)rPresetSubType.toInt32();
+	return nPresetSubType;
+}
+
+const sal_Char* transition::find( const sal_Int16 nType, const sal_Int16 nSubType, const sal_Bool bDirection )
+{
+	const sal_Char* pRet = NULL;
+	int				nFit = 0;
+
+	const transition* p = gTransitions;
+	while( p->mpName )
+	{
+		int nF = 0;
+		if ( nType == p->mnType )
+			nF += 4;
+		if ( nSubType == p->mnSubType )
+			nF += 2;
+		if ( bDirection == p->mbDirection )
+			nF += 1;
+		if ( nF > nFit )
+		{
+			pRet = p->mpName;
+			nFit = nF;
+		}
+		if ( nFit == 7 )	// maximum
+			break;
+		p++;
+	}
+	return pRet;
+}
+
+SvStream& operator<<(SvStream& rOut, AnimationNode& rNode )
+{
+	rOut << rNode.mnU1;
+	rOut << rNode.mnRestart;
+	rOut << rNode.mnGroupType;
+	rOut << rNode.mnFill;
+	rOut << rNode.mnU3;
+	rOut << rNode.mnU4;
+	rOut << rNode.mnDuration;
+	rOut << rNode.mnNodeType;
+
+	return rOut;
+}
+
+AnimationExporter::AnimationExporter( const EscherSolverContainer& rSolverContainer, ppt::ExSoundCollection& rExSoundCollection ) :
+	mrSolverContainer	( rSolverContainer ), 
+	mrExSoundCollection ( rExSoundCollection ),
+	mnCurrentGroup(0)
+{
+}
+
+// --------------------------------------------------------------------
+
+static sal_Int16 GetFillMode( const Reference< XAnimationNode >& xNode, const sal_Int16 nFillDefault )
+{
+    sal_Int16 nFill = xNode->getFill();
+	if ( ( nFill == AnimationFill::DEFAULT ) ||
+		( nFill == AnimationFill::INHERIT ) )
+	{
+		if ( nFill != AnimationFill::AUTO )
+			nFill = nFillDefault;
+	}
+    if( nFill == AnimationFill::AUTO )
+    {
+		nFill = AnimationFill::REMOVE;
+		sal_Bool bIsIndefiniteTiming = sal_True;
+		Any aAny = xNode->getDuration();
+        if( aAny.hasValue() )
+		{
+			Timing eTiming;
+			if( aAny >>= eTiming )
+				bIsIndefiniteTiming = eTiming == Timing_INDEFINITE;
+		}
+		if ( bIsIndefiniteTiming )
+		{
+			aAny = xNode->getEnd();
+			if( aAny.hasValue() )
+			{
+				Timing eTiming;
+				if( aAny >>= eTiming )
+					bIsIndefiniteTiming = eTiming == Timing_INDEFINITE;
+			}
+			if ( bIsIndefiniteTiming )
+			{
+				if ( !xNode->getRepeatCount().hasValue() )
+				{
+					aAny = xNode->getRepeatDuration();
+					if( aAny.hasValue() )
+					{
+						Timing eTiming;
+						if( aAny >>= eTiming )
+							bIsIndefiniteTiming = eTiming == Timing_INDEFINITE;
+					}
+					if ( bIsIndefiniteTiming )
+						nFill = AnimationFill::FREEZE;
+				}
+			}
+		}
+	}
+    return nFill;
+}
+
+void AnimationExporter::doexport( const Reference< XDrawPage >& xPage, SvStream& rStrm )
+{
+	Reference< XAnimationNodeSupplier > xNodeSupplier( xPage, UNO_QUERY );
+	if( xNodeSupplier.is() )
+	{
+		const Reference< XAnimationNode > xRootNode( xNodeSupplier->getAnimationNode() );
+		if( xRootNode.is() )
+		{
+			processAfterEffectNodes( xRootNode );
+			exportNode( rStrm, xRootNode, NULL, DFF_msofbtAnimGroup, 1, 0, sal_False, AnimationFill::AUTO );
+		}
+	}
+}
+
+void AnimationExporter::processAfterEffectNodes( const Reference< XAnimationNode >& xRootNode )
+{
+	try
+	{
+		Reference< XEnumerationAccess > xEnumerationAccess( xRootNode, UNO_QUERY_THROW );
+		Reference< XEnumeration > xEnumeration( xEnumerationAccess->createEnumeration(), UNO_QUERY_THROW );
+		while( xEnumeration->hasMoreElements() )
+		{
+			Reference< XAnimationNode > xNode( xEnumeration->nextElement(), UNO_QUERY_THROW );
+
+			Reference< XEnumerationAccess > xEnumerationAccess2( xNode, UNO_QUERY );
+			if ( xEnumerationAccess2.is() )
+			{
+				Reference< XEnumeration > xEnumeration2( xEnumerationAccess2->createEnumeration(), UNO_QUERY_THROW );
+				while( xEnumeration2->hasMoreElements() )
+				{
+					Reference< XAnimationNode > xChildNode( xEnumeration2->nextElement(), UNO_QUERY_THROW );
+
+					Reference< XEnumerationAccess > xEnumerationAccess3( xChildNode, UNO_QUERY_THROW );
+					Reference< XEnumeration > xEnumeration3( xEnumerationAccess3->createEnumeration(), UNO_QUERY_THROW );
+					while( xEnumeration3->hasMoreElements() )
+					{
+						Reference< XAnimationNode > xChildNode2( xEnumeration3->nextElement(), UNO_QUERY_THROW );
+
+						Reference< XEnumerationAccess > xEnumerationAccess4( xChildNode2, UNO_QUERY_THROW );
+						Reference< XEnumeration > xEnumeration4( xEnumerationAccess4->createEnumeration(), UNO_QUERY_THROW );
+						while( xEnumeration4->hasMoreElements() )
+						{
+							Reference< XAnimationNode > xChildNode3( xEnumeration4->nextElement(), UNO_QUERY_THROW );
+
+							switch( xChildNode3->getType() )
+							{
+							// found an after effect
+							case AnimationNodeType::SET:
+							case AnimationNodeType::ANIMATECOLOR:
+								{
+									Reference< XAnimationNode > xMaster;
+
+									Sequence< NamedValue > aUserData( xChildNode3->getUserData() );
+									sal_Int32 nLength = aUserData.getLength();
+									const NamedValue* p = aUserData.getConstArray();
+
+									while( nLength-- )
+									{
+										if( p->Name.equalsAscii( "master-element" ) )
+										{
+											p->Value >>= xMaster;
+											break;
+										}
+										p++;
+									}
+
+									AfterEffectNodePtr pAfterEffectNode( new AfterEffectNode( xChildNode3, xMaster ) );
+									maAfterEffectNodes.push_back( pAfterEffectNode );
+								}
+								break;
+							}
+						}
+					}
+				}
+			}
+		}
+	}
+	catch( Exception& e )
+	{
+		(void)e;
+		DBG_ERROR( "(@CL)AnimationExporter::processAfterEffectNodes(), exception cought!" );
+	}
+}
+
+bool AnimationExporter::isAfterEffectNode( const Reference< XAnimationNode >& xNode ) const
+{
+	std::list< AfterEffectNodePtr >::const_iterator aIter( maAfterEffectNodes.begin() );
+	const std::list< AfterEffectNodePtr >::const_iterator aEnd( maAfterEffectNodes.end() );
+	while( aIter != aEnd )
+	{
+		if( (*aIter)->mxNode == xNode )
+			return true;
+		aIter++;
+	}
+
+	return false;
+}
+
+bool AnimationExporter::hasAfterEffectNode( const Reference< XAnimationNode >& xNode, Reference< XAnimationNode >& xAfterEffectNode ) const
+{
+	std::list< AfterEffectNodePtr >::const_iterator aIter( maAfterEffectNodes.begin() );
+	const std::list< AfterEffectNodePtr >::const_iterator aEnd( maAfterEffectNodes.end() );
+	while( aIter != aEnd )
+	{
+		if( (*aIter)->mxMaster == xNode )
+		{
+			xAfterEffectNode = (*aIter)->mxNode;
+			return true;
+		}
+		aIter++;
+	}
+
+	return false;
+}
+
+// check if this group only contain empty groups. this may happen when
+// after effect nodes are not exported at theire original position
+bool AnimationExporter::isEmptyNode( const Reference< XAnimationNode >& xNode ) const
+{
+	if( xNode.is() ) switch( xNode->getType() )
+	{
+	case AnimationNodeType::PAR :
+	case AnimationNodeType::SEQ :
+	case AnimationNodeType::ITERATE :
+		{
+			Reference< XEnumerationAccess > xEnumerationAccess( xNode, UNO_QUERY );
+			if( xEnumerationAccess.is() )
+			{
+				Reference< XEnumeration > xEnumeration( xEnumerationAccess->createEnumeration(), UNO_QUERY );
+				if( xEnumeration.is() )
+				{
+					while( xEnumeration->hasMoreElements() )
+					{
+						Reference< XAnimationNode > xChildNode( xEnumeration->nextElement(), UNO_QUERY );
+						if( xChildNode.is() && !isEmptyNode( xChildNode ) )
+							return false;
+					}
+				}
+			}
+		}
+		break;
+
+	case AnimationNodeType::SET :
+	case AnimationNodeType::ANIMATECOLOR :
+		return isAfterEffectNode( xNode );
+	default:
+		return false;
+	}
+
+	return true;
+}
+
+void AnimationExporter::exportNode( SvStream& rStrm, Reference< XAnimationNode > xNode, const Reference< XAnimationNode >* pParent, const sal_uInt16 nContainerRecType,
+									const sal_uInt16 nInstance, const sal_Int32 nGroupLevel, const sal_Bool bTakeBackInteractiveSequenceTiming, const sal_Int16 nFDef )
+{
+	if( (nGroupLevel == 4) && isEmptyNode( xNode ) )
+		return;
+
+	if ( ( nContainerRecType == DFF_msofbtAnimGroup ) && ( nGroupLevel == 2 ) && isEmptyNode( xNode ) )
+		return;
+
+	if( nContainerRecType == DFF_msofbtAnimGroup )
+		mnCurrentGroup++;
+
+	sal_Bool bTakeBackInteractiveSequenceTimingForChild = sal_False;
+	sal_Int16 nFillDefault = GetFillMode( xNode, nFDef );
+
+	bool bSkipChildren = false;
+	
+	Reference< XAnimationNode > xAudioNode;
+	static sal_uInt32 nAudioGroup;
+
+	{
+		EscherExContainer aContainer( rStrm, nContainerRecType, nInstance );
+		switch( xNode->getType() )
+		{
+			case AnimationNodeType::CUSTOM :
+			{
+				exportAnimNode( rStrm, xNode, pParent, nGroupLevel, nFillDefault );
+				exportAnimPropertySet( rStrm, xNode );
+				exportAnimEvent( rStrm, xNode, 0 );
+				exportAnimValue( rStrm, xNode, sal_False );
+			}
+			break;
+
+			case AnimationNodeType::PAR :
+			{
+				exportAnimNode( rStrm, xNode, pParent, nGroupLevel, nFillDefault );
+				exportAnimPropertySet( rStrm, xNode );
+				sal_Int32 nFlags = nGroupLevel == 2 ? 0x10 : 0;
+				if ( bTakeBackInteractiveSequenceTiming )
+					nFlags |= 0x40;
+				exportAnimEvent( rStrm, xNode, nFlags );
+				exportAnimValue( rStrm, xNode, nGroupLevel == 4 );
+			}
+			break;
+
+			case AnimationNodeType::SEQ :
+			{
+				exportAnimNode( rStrm, xNode, pParent, nGroupLevel, nFillDefault );
+				sal_Int16 nNodeType = exportAnimPropertySet( rStrm, xNode );
+				sal_Int32 nFlags = 12;
+				if ( ( nGroupLevel == 1 ) && ( nNodeType == ::com::sun::star::presentation::EffectNodeType::INTERACTIVE_SEQUENCE ) )
+				{
+					nFlags |= 0x20;
+					bTakeBackInteractiveSequenceTimingForChild = sal_True;
+				}
+				exportAnimAction( rStrm, xNode );
+				exportAnimEvent( rStrm, xNode, nFlags );
+				exportAnimValue( rStrm, xNode, sal_False );
+			}
+			break;
+
+			case AnimationNodeType::ITERATE :
+			{
+				{
+					EscherExAtom aAnimNodeExAtom( rStrm, DFF_msofbtAnimNode );
+					AnimationNode aAnim;
+					rtl_zeroMemory( &aAnim, sizeof( aAnim ) );
+					aAnim.mnGroupType = mso_Anim_GroupType_PAR;
+					aAnim.mnNodeType = 1;
+					// attribute Restart
+					switch( xNode->getRestart() )
+					{
+						default:
+						case AnimationRestart::DEFAULT : aAnim.mnRestart = 0; break;
+						case AnimationRestart::ALWAYS  : aAnim.mnRestart = 1; break;
+						case AnimationRestart::WHEN_NOT_ACTIVE : aAnim.mnRestart = 2; break;
+						case AnimationRestart::NEVER : aAnim.mnRestart = 3; break;
+					}
+					// attribute Fill
+					switch( xNode->getFill() )
+					{
+						default:
+						case AnimationFill::DEFAULT : aAnim.mnFill = 0; break;
+						case AnimationFill::REMOVE : aAnim.mnFill = 1; break;
+						case AnimationFill::FREEZE : aAnim.mnFill = 2; break;
+						case AnimationFill::HOLD : aAnim.mnFill = 3; break;
+						case AnimationFill::TRANSITION : aAnim.mnFill = 4; break;
+					}
+					rStrm << aAnim;
+				}
+				exportIterate( rStrm, xNode );
+				exportAnimPropertySet( rStrm, xNode );
+				exportAnimEvent( rStrm, xNode, 0 );
+				exportAnimValue( rStrm, xNode, sal_False );
+
+	/*
+				EscherExContainer aContainer( rStrm, DFF_msofbtAnimGroup, 1 );
+				exportAnimNode( rStrm, xNode, pParent, nGroupLevel + 1, nFillDefault );
+				exportAnimPropertySet( rStrm, xNode );
+				exportAnimEvent( rStrm, xNode, 0 );
+				exportAnimValue( rStrm, xNode, sal_False );
+	*/
+			}
+			break;
+
+			case AnimationNodeType::ANIMATE :
+			{
+				exportAnimNode( rStrm, xNode, pParent, nGroupLevel, nFillDefault );
+				exportAnimPropertySet( rStrm, xNode );
+				exportAnimEvent( rStrm, xNode, 0 );
+				exportAnimValue( rStrm, xNode, sal_False );
+				exportAnimate( rStrm, xNode );
+			}
+			break;
+
+			case AnimationNodeType::SET :
+			{
+				bool bIsAfterEffectNode( isAfterEffectNode( xNode ) );
+				if( (nGroupLevel != 4) || !bIsAfterEffectNode )
+				{
+					exportAnimNode( rStrm, xNode, pParent, nGroupLevel, nFillDefault );
+					exportAnimPropertySet( rStrm, xNode );
+					exportAnimateSet( rStrm, xNode, bIsAfterEffectNode ? AFTEREFFECT_SET : AFTEREFFECT_NONE );
+					exportAnimEvent( rStrm, xNode, 0 );
+					exportAnimValue( rStrm, xNode, sal_False );
+				}
+				else
+				{
+					bSkipChildren = true;
+				}
+			}
+			break;
+
+			case AnimationNodeType::ANIMATEMOTION :
+			{
+				exportAnimNode( rStrm, xNode, pParent, nGroupLevel, nFillDefault );
+				exportAnimPropertySet( rStrm, xNode );
+				exportAnimateMotion( rStrm, xNode );
+				exportAnimEvent( rStrm, xNode, 0 );
+				exportAnimValue( rStrm, xNode, sal_False );
+			}
+			break;
+
+			case AnimationNodeType::ANIMATECOLOR :
+			{
+				bool bIsAfterEffectNode( isAfterEffectNode( xNode ) );
+				if( (nGroupLevel != 4) || !bIsAfterEffectNode )
+				{
+					if( bIsAfterEffectNode )
+						xNode = createAfterEffectNodeClone( xNode );
+
+					exportAnimNode( rStrm, xNode, pParent, nGroupLevel, nFillDefault );
+					exportAnimPropertySet( rStrm, xNode );
+					exportAnimateColor( rStrm, xNode, bIsAfterEffectNode ? AFTEREFFECT_COLOR : AFTEREFFECT_NONE );
+					exportAnimEvent( rStrm, xNode, 0 );
+					exportAnimValue( rStrm, xNode, sal_False );
+				}
+				else
+				{
+					bSkipChildren = true;
+				}
+			}
+			break;
+
+			case AnimationNodeType::ANIMATETRANSFORM :
+			{
+				exportAnimNode( rStrm, xNode, pParent, nGroupLevel, nFillDefault );
+				exportAnimPropertySet( rStrm, xNode );
+				exportAnimateTransform( rStrm, xNode );
+				exportAnimEvent( rStrm, xNode, 0 );
+				exportAnimValue( rStrm, xNode, sal_False );
+			}
+			break;
+
+			case AnimationNodeType::TRANSITIONFILTER :
+			{
+				exportAnimNode( rStrm, xNode, pParent, nGroupLevel, nFillDefault );
+				exportAnimPropertySet( rStrm, xNode );
+				exportAnimEvent( rStrm, xNode, 0 );
+				exportAnimValue( rStrm, xNode, sal_False );
+				exportTransitionFilter( rStrm, xNode );
+			}
+			break;
+
+			case AnimationNodeType::AUDIO :		// #i58428#
+			{
+				exportAnimNode( rStrm, xNode, pParent, nGroupLevel, nFillDefault );
+				exportAnimPropertySet( rStrm, xNode );
+
+				Reference< XAudio > xAudio( xNode, UNO_QUERY );
+				if( xAudio.is() )
+				{
+					Any aAny( xAudio->getSource() );
+					rtl::OUString aURL;
+
+					if ( ( aAny >>= aURL ) && ( aURL.getLength() ) )
+					{
+						sal_Int32 nU1 = 2;
+						sal_Int32 nTrigger = 3;
+						sal_Int32 nU3 = nAudioGroup;
+						sal_Int32 nBegin = 0;
+						{
+							EscherExContainer aAnimEvent( rStrm, DFF_msofbtAnimEvent, 1 );
+							{
+								EscherExAtom aAnimTrigger( rStrm, DFF_msofbtAnimTrigger );
+								rStrm << nU1 << nTrigger << nU3 << nBegin;
+							}
+						}
+						nU1 = 1;
+						nTrigger = 0xb;
+						nU3 = 0;
+						{
+							EscherExContainer aAnimEvent( rStrm, DFF_msofbtAnimEvent, 2 );
+							{
+								EscherExAtom aAnimTrigger( rStrm, DFF_msofbtAnimTrigger );
+								rStrm << nU1 << nTrigger << nU3 << nBegin;
+							}
+						}
+						EscherExContainer aAnimateTargetElement( rStrm, DFF_msofbtAnimateTargetElement );
+						{
+							sal_uInt32 nRefMode = 3;
+							sal_uInt32 nRefType = 2;
+							sal_uInt32 nRefId = mrExSoundCollection.GetId( aURL );
+							sal_Int32 begin = -1;
+							sal_Int32 end = -1;
+
+							EscherExAtom aAnimReference( rStrm, DFF_msofbtAnimReference );
+							rStrm << nRefMode << nRefType << nRefId << begin << end;
+						}
+					}
+				}
+				exportAnimValue( rStrm, xNode, sal_False );
+			}
+			break;
+		}
+		if( !bSkipChildren )
+		{
+			// export after effect node if one exists for this node
+			Reference< XAnimationNode > xAfterEffectNode;
+			if( hasAfterEffectNode( xNode, xAfterEffectNode ) )
+			{
+				exportNode( rStrm, xAfterEffectNode, &xNode, DFF_msofbtAnimSubGoup, 1, nGroupLevel + 1, bTakeBackInteractiveSequenceTimingForChild, nFillDefault );
+			}
+
+			Reference< XEnumerationAccess > xEnumerationAccess( xNode, UNO_QUERY );
+			if( xEnumerationAccess.is() )
+			{
+				Reference< XEnumeration > xEnumeration( xEnumerationAccess->createEnumeration(), UNO_QUERY );
+				if( xEnumeration.is() )
+				{
+					while( xEnumeration->hasMoreElements() )
+					{
+						Reference< XAnimationNode > xChildNode( xEnumeration->nextElement(), UNO_QUERY );
+						if( xChildNode.is() )
+						{
+							if ( xChildNode->getType() == AnimationNodeType::AUDIO )
+							{
+								xAudioNode = xChildNode;
+								nAudioGroup = mnCurrentGroup;
+							}
+							else
+								exportNode( rStrm, xChildNode, &xNode, DFF_msofbtAnimGroup, 1, nGroupLevel + 1, bTakeBackInteractiveSequenceTimingForChild, nFillDefault );
+						}
+					}
+				}
+			}
+		}
+	}
+	if ( xAudioNode.is() )
+		exportNode( rStrm, xAudioNode, &xNode, DFF_msofbtAnimGroup, 1, nGroupLevel, bTakeBackInteractiveSequenceTimingForChild, nFillDefault );
+
+	if( xNode->getType() == AnimationNodeType::ITERATE )
+		aTarget = Any();
+}
+
+Reference< XAnimationNode > AnimationExporter::createAfterEffectNodeClone( const Reference< XAnimationNode >& xNode ) const
+{
+	try
+	{
+		Reference< ::com::sun::star::util::XCloneable > xClonable( xNode, UNO_QUERY_THROW );
+		Reference< XAnimationNode > xCloneNode( xClonable->createClone(), UNO_QUERY_THROW );
+
+		Any aEmpty;
+		xCloneNode->setBegin( aEmpty );
+
+
+		return xCloneNode;
+	}
+	catch( Exception& e )
+	{
+		(void)e;
+		DBG_ERROR("(@CL)sd::ppt::AnimationExporter::createAfterEffectNodeClone(), could not create clone!" );
+	}
+	return xNode;
+}
+
+void AnimationExporter::exportAnimNode( SvStream& rStrm, const Reference< XAnimationNode >& xNode,
+		const ::com::sun::star::uno::Reference< ::com::sun::star::animations::XAnimationNode >*, const sal_Int32, const sal_Int16 nFillDefault )
+{
+	EscherExAtom	aAnimNodeExAtom( rStrm, DFF_msofbtAnimNode );
+	AnimationNode	aAnim;
+	rtl_zeroMemory( &aAnim, sizeof( aAnim ) );
+
+	// attribute Restart
+	switch( xNode->getRestart() )
+	{
+		default:
+		case AnimationRestart::DEFAULT : aAnim.mnRestart = 0; break;
+		case AnimationRestart::ALWAYS  : aAnim.mnRestart = 1; break;
+		case AnimationRestart::WHEN_NOT_ACTIVE : aAnim.mnRestart = 2; break;
+		case AnimationRestart::NEVER : aAnim.mnRestart = 3; break;
+	}
+
+	// attribute Fill
+//	aAnim.mnFill = GetFillMode( xNode, pParent );
+	switch( nFillDefault )
+	{
+		default:
+		case AnimationFill::DEFAULT : aAnim.mnFill = 0; break;
+		case AnimationFill::REMOVE : aAnim.mnFill = 1; break;
+		case AnimationFill::FREEZE : // aAnim.mnFill = 2; break;
+		case AnimationFill::HOLD :   aAnim.mnFill = 3; break;
+		case AnimationFill::TRANSITION : aAnim.mnFill = 4; break;
+	}
+	// attribute Duration
+	double fDuration = 0.0;
+	com::sun::star::animations::Timing eTiming;
+	if ( xNode->getDuration() >>= eTiming )
+	{
+		if ( eTiming == Timing_INDEFINITE )
+			aAnim.mnDuration = -1;
+	}
+	else if ( xNode->getDuration() >>= fDuration )
+	{
+		aAnim.mnDuration = (sal_Int32)( fDuration * 1000.0 );
+	}
+	else
+		aAnim.mnDuration = -1;
+
+	// NodeType, NodeGroup
+	aAnim.mnNodeType = 1;
+	aAnim.mnGroupType = mso_Anim_GroupType_SEQ;
+	switch( xNode->getType() )
+	{
+		case AnimationNodeType::PAR :		// PASSTROUGH!!! (as it was intended)
+			aAnim.mnGroupType = mso_Anim_GroupType_PAR;
+		case AnimationNodeType::SEQ :
+		{
+			// trying to get the nodetype
+			Sequence< NamedValue > aUserData = xNode->getUserData();
+			if ( aUserData.getLength() )
+			{
+				const NamedValue* p = aUserData.getConstArray();
+				sal_Int32 nLength = aUserData.getLength();
+				while( nLength-- )
+				{	
+					if( p->Name.equalsAsciiL( RTL_CONSTASCII_STRINGPARAM( "node-type" ) ) )
+					{
+						sal_Int16 nType = 0;
+						if ( p->Value >>= nType )
+						{
+							switch( nType )
+							{
+								case ::com::sun::star::presentation::EffectNodeType::TIMING_ROOT : aAnim.mnNodeType = 0x12; break;
+								case ::com::sun::star::presentation::EffectNodeType::MAIN_SEQUENCE : aAnim.mnNodeType = 0x18; break;
+		/*
+								case ::com::sun::star::presentation::EffectNodeType::ON_CLICK :
+								case ::com::sun::star::presentation::EffectNodeType::WITH_PREVIOUS :
+								case ::com::sun::star::presentation::EffectNodeType::AFTER_PREVIOUS :
+								case ::com::sun::star::presentation::EffectNodeType::INTERACTIVE_SEQUENCE :
+								default:
+		*/
+								}
+						}
+						break;
+					}
+				}
+			}
+		}
+		break;
+
+		case AnimationNodeType::ANIMATE :
+		case AnimationNodeType::SET :
+
+		case AnimationNodeType::CUSTOM :
+		case AnimationNodeType::ITERATE :
+		case AnimationNodeType::ANIMATEMOTION :
+		case AnimationNodeType::ANIMATECOLOR :
+		case AnimationNodeType::ANIMATETRANSFORM :
+		{
+			aAnim.mnGroupType = mso_Anim_GroupType_NODE;
+			aAnim.mnNodeType  = mso_Anim_Behaviour_ANIMATION;
+		}
+		break;
+
+		case AnimationNodeType::AUDIO :
+		{
+			aAnim.mnGroupType = mso_Anim_GroupType_MEDIA;
+			aAnim.mnNodeType  = mso_Anim_Behaviour_ANIMATION;
+		}
+		break;
+
+		case AnimationNodeType::TRANSITIONFILTER :
+		{
+			aAnim.mnGroupType = mso_Anim_GroupType_NODE;
+			aAnim.mnNodeType  = mso_Anim_Behaviour_FILTER;
+		}
+		break;
+	}
+	rStrm << aAnim;
+}
+
+sal_Int16 AnimationExporter::exportAnimPropertySet( SvStream& rStrm, const Reference< XAnimationNode >& xNode )
+{
+	sal_Int16 nNodeType = ::com::sun::star::presentation::EffectNodeType::DEFAULT;
+
+	EscherExContainer aAnimPropertySet( rStrm, DFF_msofbtAnimPropertySet );
+	const ::com::sun::star::uno::Any* pAny[ DFF_ANIM_PROPERTY_ID_COUNT ];
+	rtl_zeroMemory( pAny, sizeof( pAny ) );
+
+	Reference< XAnimationNode > xMaster;
+
+	const Any aTrue( makeAny( (sal_Bool)sal_True ) );
+	Any aMasterRel, aOverride, aRunTimeContext;
+
+	// storing user data into pAny, to allow direct access later
+	Sequence< NamedValue > aUserData = xNode->getUserData();
+	if ( aUserData.getLength() )
+	{
+		const NamedValue* p = aUserData.getConstArray();
+		sal_Int32 nLength = aUserData.getLength();
+		while( nLength-- )
+		{	
+			if( p->Name.equalsAsciiL( RTL_CONSTASCII_STRINGPARAM( "node-type" ) ) )
+			{
+				pAny[ DFF_ANIM_NODE_TYPE ] = &(p->Value);
+			}
+			else if ( p->Name.equalsAsciiL( RTL_CONSTASCII_STRINGPARAM( "preset-class" ) ) )
+			{
+				pAny[ DFF_ANIM_PRESET_CLASS ] = &(p->Value);
+			}
+			else if ( p->Name.equalsAsciiL( RTL_CONSTASCII_STRINGPARAM( "preset-id" ) ) )
+			{
+				pAny[ DFF_ANIM_PRESET_ID ] = &(p->Value);
+			}
+			else if ( p->Name.equalsAsciiL( RTL_CONSTASCII_STRINGPARAM( "preset-sub-type" ) ) )
+			{
+				pAny[ DFF_ANIM_PRESET_SUB_TYPE ] = &(p->Value);
+			}
+			else if ( p->Name.equalsAsciiL( RTL_CONSTASCII_STRINGPARAM( "master-element" ) ) )
+			{
+				pAny[ DFF_ANIM_AFTEREFFECT ] = &aTrue;
+				p->Value >>= xMaster;
+			}
+			p++;
+		}
+	}
+
+	// calculate master-rel
+	if( xMaster.is() )
+	{
+		sal_Int32 nMasterRel = 2;
+		Reference< XChild > xNodeChild( xNode, UNO_QUERY );
+		Reference< XChild > xMasterChild( xMaster, UNO_QUERY );
+		if( xNodeChild.is() && xMasterChild.is() && (xNodeChild->getParent() == xMasterChild->getParent() ) )
+			nMasterRel = 0;
+
+		aMasterRel <<= nMasterRel;
+
+		pAny[ DFF_ANIM_MASTERREL ] = &aMasterRel;
+
+		aOverride <<= (sal_Int32)1;
+		pAny[ DFF_ANIM_OVERRIDE ] = &aOverride;
+
+		aRunTimeContext <<= (sal_Int32)1;
+		pAny[ DFF_ANIM_RUNTIMECONTEXT ] = &aRunTimeContext;
+	}
+
+	// the order is important
+	if ( pAny[ DFF_ANIM_NODE_TYPE ] )
+	{
+		if ( *pAny[ DFF_ANIM_NODE_TYPE ] >>= nNodeType )
+		{
+			sal_uInt32 nPPTNodeType = DFF_ANIM_NODE_TYPE_ON_CLICK;
+			switch( nNodeType )
+			{
+				case ::com::sun::star::presentation::EffectNodeType::ON_CLICK : nPPTNodeType = DFF_ANIM_NODE_TYPE_ON_CLICK;	break;
+				case ::com::sun::star::presentation::EffectNodeType::WITH_PREVIOUS : nPPTNodeType = DFF_ANIM_NODE_TYPE_WITH_PREVIOUS; break;
+				case ::com::sun::star::presentation::EffectNodeType::AFTER_PREVIOUS : nPPTNodeType = DFF_ANIM_NODE_TYPE_AFTER_PREVIOUS; break;
+				case ::com::sun::star::presentation::EffectNodeType::MAIN_SEQUENCE : nPPTNodeType = DFF_ANIM_NODE_TYPE_MAIN_SEQUENCE; break;
+				case ::com::sun::star::presentation::EffectNodeType::TIMING_ROOT : nPPTNodeType = DFF_ANIM_NODE_TYPE_TIMING_ROOT; break;
+				case ::com::sun::star::presentation::EffectNodeType::INTERACTIVE_SEQUENCE: nPPTNodeType = DFF_ANIM_NODE_TYPE_INTERACTIVE_SEQ; break;
+			}
+			exportAnimPropertyuInt32( rStrm, DFF_ANIM_NODE_TYPE, nPPTNodeType, TRANSLATE_NONE );
+		}
+	}
+	sal_uInt32 nPresetId = 0;
+    sal_uInt32 nPresetSubType = 0;
+	sal_uInt32 nAPIPresetClass = EffectPresetClass::CUSTOM;
+	sal_uInt32 nPresetClass = DFF_ANIM_PRESS_CLASS_USER_DEFINED;
+	sal_Bool bPresetClass, bPresetId, bPresetSubType;
+	bPresetClass = bPresetId = bPresetSubType = sal_False;
+
+	if ( pAny[ DFF_ANIM_PRESET_CLASS ] )
+	{
+		if ( *pAny[ DFF_ANIM_PRESET_CLASS ] >>= nAPIPresetClass )
+		{
+			sal_uInt8 nPPTPresetClass;
+			switch( nAPIPresetClass )
+			{
+				case EffectPresetClass::ENTRANCE : nPPTPresetClass = DFF_ANIM_PRESS_CLASS_ENTRANCE; break;
+				case EffectPresetClass::EXIT : nPPTPresetClass = DFF_ANIM_PRESS_CLASS_EXIT; break;
+				case EffectPresetClass::EMPHASIS : nPPTPresetClass = DFF_ANIM_PRESS_CLASS_EMPHASIS; break;
+				case EffectPresetClass::MOTIONPATH : nPPTPresetClass = DFF_ANIM_PRESS_CLASS_MOTIONPATH; break;
+				case EffectPresetClass::OLEACTION : nPPTPresetClass = DFF_ANIM_PRESS_CLASS_OLE_ACTION; break;
+				case EffectPresetClass::MEDIACALL : nPPTPresetClass = DFF_ANIM_PRESS_CLASS_MEDIACALL; break;
+				default :
+					nPPTPresetClass = DFF_ANIM_PRESS_CLASS_USER_DEFINED;
+			}
+			nPresetClass = nPPTPresetClass;
+			bPresetClass = sal_True;
+		}
+	}
+	if ( pAny[ DFF_ANIM_PRESET_ID ] )
+	{
+		rtl::OUString sPreset;
+		if ( *pAny[ DFF_ANIM_PRESET_ID ] >>= sPreset )
+		{
+			if ( sPreset.match( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "ppt_" ) ), 0 ) )
+			{
+				sal_Int32 nLast = sPreset.lastIndexOf( '_' );
+				if ( ( nLast != -1 ) && ( ( nLast + 1 ) < sPreset.getLength() ) )
+				{
+					rtl::OUString aNumber( sPreset.copy( nLast + 1 ) );
+					nPresetId = aNumber.toInt32();
+					bPresetId = sal_True;
+				}
+   			}
+			else
+			{
+				const preset_maping* p = gPresetMaping;
+				while( p->mpStrPresetId && ((p->mnPresetClass != (sal_Int32)nAPIPresetClass) || !sPreset.equalsAscii( p->mpStrPresetId )) )
+					p++;
+
+				if( p->mpStrPresetId )
+				{
+					nPresetId = p->mnPresetId;
+					bPresetId = sal_True;
+				}
+			}
+		}
+	}
+
+	if ( pAny[ DFF_ANIM_PRESET_SUB_TYPE ] )
+	{
+		rtl::OUString sPresetSubType;
+		if ( *pAny[ DFF_ANIM_PRESET_SUB_TYPE ] >>= sPresetSubType )
+		{
+			nPresetSubType = ImplTranslatePresetSubType( nPresetClass, nPresetId, sPresetSubType );
+			bPresetSubType = sal_True;
+		}
+	}
+	if ( bPresetId )
+		exportAnimPropertyuInt32( rStrm, DFF_ANIM_PRESET_ID, nPresetId, TRANSLATE_NONE );
+	if ( bPresetSubType )
+		exportAnimPropertyuInt32( rStrm, DFF_ANIM_PRESET_SUB_TYPE, nPresetSubType, TRANSLATE_NONE );
+	if ( bPresetClass )
+		exportAnimPropertyuInt32( rStrm, DFF_ANIM_PRESET_CLASS, nPresetClass, TRANSLATE_NONE );
+
+	if ( pAny[ DFF_ANIM_ID ] )
+	{
+		// TODO DFF_ANIM_ID
+	}
+
+	if ( pAny[ DFF_ANIM_AFTEREFFECT ] )
+	{
+		sal_Bool bAfterEffect = sal_False;
+		if ( *pAny[ DFF_ANIM_AFTEREFFECT ] >>= bAfterEffect )
+			exportAnimPropertyByte( rStrm, DFF_ANIM_AFTEREFFECT, bAfterEffect, TRANSLATE_NONE );
+	}
+
+	if ( pAny[ DFF_ANIM_RUNTIMECONTEXT ] )
+	{
+		sal_Int32 nRunTimeContext = 0;
+		if ( *pAny[ DFF_ANIM_RUNTIMECONTEXT ] >>= nRunTimeContext )
+			exportAnimPropertyuInt32( rStrm, DFF_ANIM_RUNTIMECONTEXT, nRunTimeContext, TRANSLATE_NONE );
+	}
+	if ( pAny[ DFF_ANIM_PATH_EDIT_MODE ] )
+	{
+		// TODO DFF_ANIM_ID
+	}
+
+	if( !xMaster.is() )
+	{
+		Reference< XAnimateColor > xColor( xNode, UNO_QUERY );
+		if( xColor.is() )
+		{
+//			sal_uInt32 nColorSpace = xColor->getColorSpace() == AnimationColorSpace::RGB ? 0 : 1;
+//			exportAnimPropertyuInt32( rStrm, DFF_ANIM_COLORSPACE, nColorSpace, TRANSLATE_NONE );
+			
+			sal_Bool bDirection = !xColor->getDirection();
+			exportAnimPropertyuInt32( rStrm, DFF_ANIM_DIRECTION, bDirection, TRANSLATE_NONE );
+		}
+	}
+
+	if ( pAny[ DFF_ANIM_OVERRIDE ] )
+	{
+		sal_Int32 nOverride = 0;
+		if ( *pAny[ DFF_ANIM_OVERRIDE ] >>= nOverride )
+			exportAnimPropertyuInt32( rStrm, DFF_ANIM_OVERRIDE, nOverride, TRANSLATE_NONE );
+	}
+
+	if ( pAny[ DFF_ANIM_MASTERREL ] )
+	{
+		sal_Int32 nMasterRel = 0;
+		if ( *pAny[ DFF_ANIM_MASTERREL ] >>= nMasterRel )
+			exportAnimPropertyuInt32( rStrm, DFF_ANIM_MASTERREL, nMasterRel, TRANSLATE_NONE );
+	}
+
+/* todo
+	Reference< XAudio > xAudio( xNode, UNO_QUERY );
+	if( xAudio.is() )
+	{
+		sal_Int16 nEndAfterSlide = 0;
+		nEndAfterSlide = xAudio->getEndAfterSlide();
+		exportAnimPropertyuInt32( rStrm, DFF_ANIM_ENDAFTERSLIDE, nEndAfterSlide, TRANSLATE_NONE );
+	}
+*/
+	Reference< XAnimate > xAnim( xNode, UNO_QUERY );
+	if( xAnim.is() )
+	{
+		// TODO: DFF_ANIM_TIMEFILTER
+	}
+	if ( pAny[ DFF_ANIM_EVENT_FILTER ] )
+	{
+		// TODO DFF_ANIM_EVENT_FILTER 
+	}
+	if ( pAny[ DFF_ANIM_VOLUME ] )
+	{
+		// TODO DFF_ANIM_VOLUME 
+	}
+	return nNodeType;
+}
+
+sal_Bool AnimationExporter::exportAnimProperty( SvStream& rStrm, const sal_uInt16 nPropertyId, const ::com::sun::star::uno::Any& rAny, const TranslateMode eTranslateMode )
+{
+	sal_Bool bRet = sal_False;
+	if ( rAny.hasValue() )
+	{
+		switch( rAny.getValueType().getTypeClass() )
+		{
+			case ::com::sun::star::uno::TypeClass_UNSIGNED_SHORT :
+			case ::com::sun::star::uno::TypeClass_SHORT :
+			case ::com::sun::star::uno::TypeClass_UNSIGNED_LONG :
+			case ::com::sun::star::uno::TypeClass_LONG :
+			{
+				sal_Int32 nVal = 0;
+				if ( rAny >>= nVal )
+				{
+					exportAnimPropertyuInt32( rStrm, nPropertyId, nVal, eTranslateMode );
+					bRet = sal_True;
+				}
+			}
+			break;
+
+			case ::com::sun::star::uno::TypeClass_DOUBLE :
+			{
+				double fVal = 0.0;
+				if ( rAny >>= fVal )
+				{
+					exportAnimPropertyFloat( rStrm, nPropertyId, fVal, eTranslateMode );
+					bRet = sal_True;
+				}
+			}
+			break;
+			case ::com::sun::star::uno::TypeClass_FLOAT :
+			{
+				float fVal = 0.0;
+				if ( rAny >>= fVal )
+				{
+					if ( eTranslateMode & TRANSLATE_NUMBER_TO_STRING )
+					{
+						Any aAny;
+						rtl::OUString aNumber( rtl::OUString::valueOf( fVal ) );
+						aAny <<= aNumber;
+						exportAnimPropertyString( rStrm, nPropertyId, aNumber, eTranslateMode );
+					}
+					else
+					{
+						exportAnimPropertyFloat( rStrm, nPropertyId, fVal, eTranslateMode );
+						bRet = sal_True;
+					}
+				}
+			}
+			break;
+			case ::com::sun::star::uno::TypeClass_STRING :
+			{
+				rtl::OUString aStr;
+				if ( rAny >>= aStr )
+				{
+					exportAnimPropertyString( rStrm, nPropertyId, aStr, eTranslateMode );
+					bRet = sal_True;
+				}
+			}
+			break;
+			default:
+				break;
+		}
+	}
+	return bRet;
+}
+void AnimationExporter::exportAnimPropertyString( SvStream& rStrm, const sal_uInt16 nPropertyId, const rtl::OUString& rVal, const TranslateMode eTranslateMode )
+{
+	EscherExAtom aExAtom( rStrm, DFF_msofbtAnimAttributeValue, nPropertyId );
+	sal_uInt8 nType = DFF_ANIM_PROP_TYPE_UNISTRING;
+	rStrm << nType;
+	rtl::OUString aStr( rVal );
+	if ( eTranslateMode != TRANSLATE_NONE )
+		ImplTranslateAttribute( aStr, eTranslateMode );
+	writeZString( rStrm, aStr );
+}
+
+void AnimationExporter::exportAnimPropertyFloat( SvStream& rStrm, const sal_uInt16 nPropertyId, const double& rVal, const TranslateMode )
+{
+	EscherExAtom aExAtom( rStrm, DFF_msofbtAnimAttributeValue, nPropertyId );
+	sal_uInt8 nType = DFF_ANIM_PROP_TYPE_FLOAT;
+	float fFloat = (float)rVal;
+	rStrm << nType
+		  << fFloat;
+}
+
+void AnimationExporter::exportAnimPropertyuInt32( SvStream& rStrm, const sal_uInt16 nPropertyId, const sal_uInt32 nVal, const TranslateMode )
+{
+	EscherExAtom aExAtom( rStrm, DFF_msofbtAnimAttributeValue, nPropertyId );
+	sal_uInt8 nType = DFF_ANIM_PROP_TYPE_INT32 ;
+	rStrm << nType
+		  << nVal;
+}
+
+void AnimationExporter::exportAnimPropertyByte( SvStream& rStrm, const sal_uInt16 nPropertyId, const sal_uInt8 nVal, const TranslateMode )
+{
+	EscherExAtom aExAtom( rStrm, DFF_msofbtAnimAttributeValue, nPropertyId );
+	sal_uInt8 nType = DFF_ANIM_PROP_TYPE_BYTE;
+	rStrm << nType
+		  << nVal;
+}
+
+void AnimationExporter::writeZString( SvStream& rStrm, const rtl::OUString& rVal )
+{
+	sal_Int32 i;
+	for ( i = 0; i < rVal.getLength(); i++ )
+		rStrm << rVal[ i ];
+	rStrm << (sal_Unicode)0;
+}
+
+void AnimationExporter::exportAnimAction( SvStream& rStrm, const Reference< XAnimationNode >& xNode )
+{
+	EscherExAtom aExAtom( rStrm, DFF_msofbtAnimAction );
+
+	sal_Int32 nConcurrent = 1;
+	sal_Int32 nNextAction = 1;
+	sal_Int32 nEndSync = 0;
+	sal_Int32 nU4 = 0;
+	sal_Int32 nU5 = 3;
+
+	sal_Int16 nAnimationEndSync = 0;
+	if ( xNode->getEndSync() >>= nAnimationEndSync )
+	{
+		if ( nAnimationEndSync == AnimationEndSync::ALL )
+			nEndSync = 1;
+	}
+	rStrm << nConcurrent
+		  << nNextAction
+		  << nEndSync
+		  << nU4
+		  << nU5;
+
+}
+
+// nFlags Bit 6 = fixInteractiveSequenceTiming (for child)
+// nFlags Bit 5 = fixInteractiveSequenceTiming (for root)
+// nFlags Bit 4 = first node of main sequence -> begin event next has to be replaced to indefinite
+void AnimationExporter::exportAnimEvent( SvStream& rStrm, const Reference< XAnimationNode >& xNode, const sal_Int32 nFlags )
+{
+	sal_uInt16 i;
+	for ( i = 0; i < 4; i++ )
+	{
+		sal_Int32 nU1 = 0;
+		sal_Int32 nTrigger = 0;
+		sal_Int32 nU3 = 0;
+		sal_Int32 nBegin = 0;
+
+		sal_Bool bCreateEvent = sal_False;
+		Any aSource;
+
+		switch( i )
+		{
+			case 0 : 
+			case 1 :
+			{
+				Any aAny;
+				Event aEvent;
+				com::sun::star::animations::Timing eTiming;
+				if ( i == 0 )
+				{
+					if ( nFlags & 0x20 )
+					{
+						// taking the first child
+						Reference< XEnumerationAccess > xEA( xNode, UNO_QUERY_THROW );
+						Reference< XEnumeration > xE( xEA->createEnumeration(), UNO_QUERY_THROW );
+						if ( xE.is() && xE->hasMoreElements() )
+						{
+//							while( xE->hasMoreElements() )
+							{
+								Reference< XAnimationNode > xClickNode( xE->nextElement(), UNO_QUERY );
+								aAny = xClickNode->getBegin();
+							}
+						}
+					}
+					else if ( nFlags & 0x40 )
+					{
+						// begin has to be replaced with void, so don't do anything
+					}
+					else
+					{
+						aAny = xNode->getBegin();
+						if ( nFlags & 0x10 )	// replace ON_NEXT with IDEFINITE
+						{
+							if ( ( aAny >>= aEvent ) && ( aEvent.Trigger == EventTrigger::ON_NEXT ) )
+							{
+								eTiming = Timing_INDEFINITE;
+								aAny <<= eTiming;
+							}
+						}
+					}
+				}
+				else
+					aAny = xNode->getEnd();
+
+				double fTiming = 0.0;
+				if ( aAny >>= aEvent )
+				{
+					bCreateEvent = sal_True;
+					switch( aEvent.Trigger )
+					{
+						case EventTrigger::NONE : nTrigger = 0; break;
+						case EventTrigger::ON_BEGIN : nTrigger = 1; break;
+						case EventTrigger::ON_END : nTrigger = 2; break;
+						case EventTrigger::BEGIN_EVENT : nTrigger = 3; break;
+						case EventTrigger::END_EVENT : nTrigger = 4; nU1 = 2; nU3 = mnCurrentGroup; break;
+						case EventTrigger::ON_CLICK : nTrigger = 5; break;
+						case EventTrigger::ON_DBL_CLICK : nTrigger = 6; break;
+						case EventTrigger::ON_MOUSE_ENTER : nTrigger = 7; break;
+						case EventTrigger::ON_MOUSE_LEAVE : nTrigger = 8; break;
+						case EventTrigger::ON_NEXT : nTrigger = 9; break;
+						case EventTrigger::ON_PREV : nTrigger = 10; break;
+						case EventTrigger::ON_STOP_AUDIO : nTrigger = 11; break;
+					}
+					if ( aEvent.Offset.hasValue() )
+					{
+						if ( aEvent.Offset >>= eTiming )
+						{
+							if ( eTiming == Timing_INDEFINITE )
+								nBegin = -1;
+						}
+						else if ( aEvent.Offset >>= fTiming )
+							nBegin = (sal_Int32)( fTiming * 1000.0 );
+					}
+					aSource = aEvent.Source;
+				}
+				else if ( aAny >>= eTiming )
+				{
+					bCreateEvent = sal_True;
+					if ( eTiming == Timing_INDEFINITE )
+						nBegin = -1;
+				}
+				else if ( aAny >>= fTiming )
+				{
+					bCreateEvent = sal_True;
+					if ( eTiming == Timing_INDEFINITE )
+						nBegin = (sal_Int32)( fTiming * 1000.0 );
+				}
+			}
+			break;
+
+			case 2 :
+			{
+				if ( nFlags & ( 1 << i ) )
+				{
+					bCreateEvent = sal_True;
+					nU1 = 1;
+					nTrigger = 9;
+				}
+			}
+			break;
+			case 3 :
+			{
+				if ( nFlags & ( 1 << i ) )
+				{
+					bCreateEvent = sal_True;
+					nU1 = 1;
+					nTrigger = 10;
+				}
+			}
+			break;
+		};
+		if ( bCreateEvent )
+		{
+			EscherExContainer aAnimEvent( rStrm, DFF_msofbtAnimEvent, i + 1 );
+			{
+				EscherExAtom aAnimTrigger( rStrm, DFF_msofbtAnimTrigger );
+				rStrm << nU1
+					  << nTrigger
+					  << nU3
+					  << nBegin;
+			}
+			exportAnimateTargetElement( rStrm, aSource, ( nFlags & ( 1 << i ) ) != 0 );
+		}
+	}
+}
+
+Any AnimationExporter::convertAnimateValue( const Any& rSourceValue, const rtl::OUString& rAttributeName ) const
+{
+	rtl::OUString aDest;
+	if ( rAttributeName.equalsAsciiL( RTL_CONSTASCII_STRINGPARAM( "X" ) )
+			|| rAttributeName.equalsAsciiL( RTL_CONSTASCII_STRINGPARAM( "Y" ) )
+			|| rAttributeName.equalsAsciiL( RTL_CONSTASCII_STRINGPARAM( "Width" ) )
+			|| rAttributeName.equalsAsciiL( RTL_CONSTASCII_STRINGPARAM( "Height" ) )
+		)
+	{
+		rtl::OUString aStr;
+		if ( rSourceValue >>= aStr )
+		{
+			ImplTranslateAttribute( aStr, TRANSLATE_MEASURE );
+			aDest += aStr;
+		}
+	}
+	else if ( rAttributeName.equalsAsciiL( RTL_CONSTASCII_STRINGPARAM( "Rotate" ) )			// "r" or "style.rotation" ?
+			|| rAttributeName.equalsAsciiL( RTL_CONSTASCII_STRINGPARAM( "SkewX" ) )
+			|| rAttributeName.equalsAsciiL( RTL_CONSTASCII_STRINGPARAM( "Opacity" ) )
+			|| rAttributeName.equalsAsciiL( RTL_CONSTASCII_STRINGPARAM( "CharHeight" ) )
+		)
+	{
+		double fNumber = 0.0;
+		if ( rSourceValue >>= fNumber )
+			aDest += rtl::OUString::valueOf( fNumber );
+	}
+	else if ( rAttributeName.equalsAsciiL( RTL_CONSTASCII_STRINGPARAM( "Color" ) )
+			|| rAttributeName.equalsAsciiL( RTL_CONSTASCII_STRINGPARAM( "FillColor" ) )		// "Fillcolor" or "FillColor" ?
+			|| rAttributeName.equalsAsciiL( RTL_CONSTASCII_STRINGPARAM( "LineColor" ) )
+			|| rAttributeName.equalsAsciiL( RTL_CONSTASCII_STRINGPARAM( "CharColor" ) )
+		)
+	{
+		sal_Int32 nColor = 0;
+		Sequence< double > aHSL( 3 );
+		rtl::OUString aP( RTL_CONSTASCII_USTRINGPARAM( "," ) );
+		if ( rSourceValue >>= aHSL )
+		{
+			aDest += rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "hsl(" ) );
+			aDest += rtl::OUString::valueOf( (sal_Int32)( aHSL[ 0 ] / ( 360.0 / 255 ) ) );
+			aDest += aP;
+			aDest += rtl::OUString::valueOf( (sal_Int32)( aHSL[ 1 ] * 255.0 ) );
+			aDest += aP;
+			aDest += rtl::OUString::valueOf( (sal_Int32)( aHSL[ 2 ] * 255.0 ) );
+			aDest += rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( ")" ) );
+		}
+		else if ( rSourceValue >>= nColor )
+		{
+			aDest += rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "rgb(" ) );
+			aDest += rtl::OUString::valueOf( (sal_Int32)( (sal_Int8)nColor ) );
+			aDest += aP;
+			aDest += rtl::OUString::valueOf( (sal_Int32)( (sal_Int8)( nColor >> 8 ) ) );
+			aDest += aP;
+			aDest += rtl::OUString::valueOf( (sal_Int32)( (sal_Int8)( nColor >> 16 ) ) );
+			aDest += rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( ")" ) );
+		}
+	}
+	else if ( rAttributeName.equalsAsciiL( RTL_CONSTASCII_STRINGPARAM( "FillStyle" ) ) )
+	{
+		::com::sun::star::drawing::FillStyle eFillStyle;
+		if ( rSourceValue >>= eFillStyle )
+		{
+			if ( eFillStyle == ::com::sun::star::drawing::FillStyle_NONE )
+				aDest += rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "none" ) );	// ?
+			else
+				aDest += rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "solid" ) );
+		}
+	}
+	else if ( rAttributeName.equalsAsciiL( RTL_CONSTASCII_STRINGPARAM( "LineStyle" ) ) )
+	{
+		::com::sun::star::drawing::LineStyle eLineStyle;
+		if ( rSourceValue >>= eLineStyle )
+		{
+			if ( eLineStyle == ::com::sun::star::drawing::LineStyle_NONE )
+				aDest += rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "false" ) );
+			else
+				aDest += rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "true" ) );
+		}
+	}
+	else if ( rAttributeName.equalsAsciiL( RTL_CONSTASCII_STRINGPARAM( "CharWeight" ) ) )
+	{
+		float fFontWeight = 0.0;
+		if ( rSourceValue >>= fFontWeight )
+		{
+			if ( fFontWeight == com::sun::star::awt::FontWeight::BOLD )
+				aDest += rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "bold" ) );
+			else
+				aDest += rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "normal" ) );
+		}
+	}
+	else if ( rAttributeName.equalsAsciiL( RTL_CONSTASCII_STRINGPARAM( "CharUnderline" ) ) )
+	{
+		sal_Int16 nFontUnderline = 0;
+		if ( rSourceValue >>= nFontUnderline )
+		{
+			if ( nFontUnderline == com::sun::star::awt::FontUnderline::NONE )
+				aDest += rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "false" ) );
+			else
+				aDest += rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "true" ) );
+		}
+	}
+	else if ( rAttributeName.equalsAsciiL( RTL_CONSTASCII_STRINGPARAM( "CharPosture" ) ) )
+	{
+		::com::sun::star::awt::FontSlant eFontSlant;
+		if ( rSourceValue >>= eFontSlant )
+		{
+			if ( eFontSlant == com::sun::star::awt::FontSlant_ITALIC )
+				aDest += rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "italic" ) );
+			else
+				aDest += rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "normal" ) );	// ?
+		}
+	}
+	else if ( rAttributeName.equalsAsciiL( RTL_CONSTASCII_STRINGPARAM( "Visibility" ) ) )
+	{
+		sal_Bool bVisible = sal_True;
+		if ( rSourceValue >>= bVisible )
+		{
+			if ( bVisible )
+				aDest += rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "visible" ) );
+			else
+				aDest += rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "hidden" ) );
+		}
+	}
+	Any aRet;
+	if ( aDest.getLength() )
+		aRet <<= aDest;
+	else
+		aRet = rSourceValue;
+	return aRet;
+}
+
+void AnimationExporter::exportAnimateSet( SvStream& rStrm, const Reference< XAnimationNode >& xNode, int nAfterEffectType )
+{
+	Reference< XAnimateSet > xSet( xNode, UNO_QUERY );
+	if( xSet.is() )
+	{
+		EscherExContainer aAnimateSet( rStrm, DFF_msofbtAnimateSet, 0 );
+		{
+			EscherExAtom aAnimateSetData( rStrm, DFF_msofbtAnimateSetData );
+			sal_uInt32 nId1 = 1;			// ??
+			sal_uInt32 nId2 = 1;			// ??
+			rStrm << nId1 << nId2;
+		}
+		Any aConvertedValue( convertAnimateValue( xSet->getTo(), xSet->getAttributeName() ) );
+		if ( aConvertedValue.hasValue() )
+			exportAnimProperty( rStrm, 1, aConvertedValue, TRANSLATE_NONE );
+		exportAnimateTarget( rStrm, xNode, 0, nAfterEffectType );
+	}
+}
+
+sal_uInt32 GetValueTypeForAttributeName( const rtl::OUString& rAttributeName )
+{
+	sal_uInt32 nValueType = 0;
+
+/*
+	AnimationValueType::STRING == 0;
+	AnimationValueType::NUMBER == 1;
+	AnimationValueType::COLOR  == 2;
+*/
+
+	struct Entry
+	{
+		const sal_Char* pName;
+		sal_uInt8		nType;
+	};
+	static const Entry lcl_attributeMap[] =
+    {
+        { "charcolor", 2 },
+        { "charfontname", 0 },
+        { "charheight", 1 },
+        { "charposture", 0 },
+        // TODO(Q1): This should prolly be changed in PPT import
+        // { "charrotation", ATTRIBUTE_CHAR_ROTATION },
+        { "charrotation", 1 },
+        { "charunderline", 0 },
+        { "charweight", 0 },
+        { "color", 2 },
+        { "dimcolor", 2 },
+        { "fillcolor", 2 },
+        { "fillstyle", 0 },
+        { "height", 1 },
+        { "linecolor", 2 },
+        { "linestyle", 0 },
+        { "opacity", 0 },
+        { "rotate", 1 },
+        { "skewx", 1 },
+        { "skewy", 1 },
+        { "visibility", 1 },
+        { "width", 1 },
+        { "x", 1 },
+        { "y", 1 },
+		{ NULL, 0 }
+	};
+	const Entry* pPtr = &lcl_attributeMap[ 0 ];
+	while( pPtr->pName )
+	{
+		if ( rAttributeName.equalsIgnoreAsciiCaseAscii( pPtr->pName ) )
+		{
+			nValueType = pPtr->nType;
+			break;
+		}
+		pPtr++;
+	}
+	DBG_ASSERT( pPtr->pName, "GetValueTypeForAttributeName, unknown property value!" );
+	return nValueType;
+}
+
+void AnimationExporter::exportAnimate( SvStream& rStrm, const Reference< XAnimationNode >& xNode )
+{
+	Reference< XAnimate > xAnimate( xNode, UNO_QUERY );
+	if ( xAnimate.is() )
+	{
+		Any aBy  ( xAnimate->getBy() );
+		Any aFrom( xAnimate->getFrom() );
+		Any aTo  ( xAnimate->getTo() );
+
+		EscherExContainer aContainer( rStrm, DFF_msofbtAnimate, 0 );
+		{
+			EscherExAtom	aAnimateData( rStrm, DFF_msofbtAnimateData );
+			sal_uInt32 nBits = 0x38;
+			sal_Int16 nTmp = xAnimate->getCalcMode();
+			sal_uInt32 nCalcMode = /* (nTmp == AnimationCalcMode::FORMULA) ? 2 : */ (nTmp == AnimationCalcMode::LINEAR) ? 1 : 0;
+			nTmp = xAnimate->getValueType();
+			sal_uInt32 nValueType = GetValueTypeForAttributeName( xAnimate->getAttributeName() );
+
+			if ( aBy.hasValue() )
+				nBits |= 1;
+			if ( aFrom.hasValue() )
+				nBits |= 2;
+			if ( aTo.hasValue() )
+				nBits |= 4;
+
+			rStrm << nCalcMode
+				  << nBits
+				  << nValueType;
+		}
+		if ( aBy.hasValue() )
+			exportAnimProperty( rStrm, 1, aBy, TRANSLATE_NUMBER_TO_STRING | TRANSLATE_MEASURE );
+		if ( aFrom.hasValue() )
+			exportAnimProperty( rStrm, 2, aFrom, TRANSLATE_NUMBER_TO_STRING | TRANSLATE_MEASURE );
+		if ( aTo.hasValue() )
+			exportAnimProperty( rStrm, 3, aTo, TRANSLATE_NUMBER_TO_STRING | TRANSLATE_MEASURE );
+
+		exportAnimateKeyPoints( rStrm, xAnimate );
+		exportAnimateTarget( rStrm, xNode );
+	}
+}
+
+void AnimationExporter::exportAnimateTarget( SvStream& rStrm, const Reference< XAnimationNode >& xNode, const sal_uInt32 nForceAttributeNames, int nAfterEffectType )
+{
+	EscherExContainer aAnimateTarget( rStrm, DFF_msofbtAnimateTarget, 0 );
+	Reference< XAnimate > xAnimate( xNode, UNO_QUERY );
+	if ( xAnimate.is() )
+	{
+		{
+			EscherExAtom aAnimateTargetSettings( rStrm, DFF_msofbtAnimateTargetSettings, 0 );
+			// nBits %0001: additive, %0010: accumulate, %0100: attributeName, %1000: transformtype
+			// nAdditive 0 = base, 1 = sum, 2 = replace, 3 = multiply, 4 = none
+			// nAccumulate 0 = none, 1 = always
+			// nTransformType 0: "property" else "image"
+			sal_uInt32 nBits = 0;
+			sal_uInt32 nAdditive = 0;
+			sal_uInt32 nAccumulate = 0;
+			sal_uInt32 nTransformType = 0;
+			if ( xAnimate.is() )
+			{
+				if ( xAnimate->getAttributeName().getLength() )
+					nBits |= 4;		// what is attributeName ?, maybe this is set if a DFF_msofbtAnimateAttributeNames is written
+				sal_Int16 nAdditiveMode = xAnimate->getAdditive();
+				if ( nAdditiveMode != AnimationAdditiveMode::BASE )
+				{
+					nBits |= 1;
+					switch( nAdditiveMode )
+					{
+						case AnimationAdditiveMode::SUM : nAdditive = 1; break;
+						case AnimationAdditiveMode::REPLACE : nAdditive = 2; break;
+						case AnimationAdditiveMode::MULTIPLY : nAdditive = 3; break;
+						case AnimationAdditiveMode::NONE : nAdditive = 4; break;
+					}
+				}
+				if ( xAnimate->getAccumulate() )
+				{
+					nBits  |= 2;
+					nAccumulate = 1;
+				}
+			}
+			rStrm << nBits
+				<< nAdditive
+				<< nAccumulate
+				<< nTransformType;
+		}
+		if ( xAnimate->getAttributeName().getLength() || nForceAttributeNames )
+		{
+			EscherExContainer aAnimateAttributeNames( rStrm, DFF_msofbtAnimateAttributeNames, 1 );
+			rtl::OUString aAttributeName( xAnimate->getAttributeName() );
+			if ( nForceAttributeNames )
+			{
+				switch( nForceAttributeNames )
+				{
+					case 1 : aAttributeName = rtl::OUString::createFromAscii( "r" ); break;
+				}
+			}
+			sal_Int32 nIndex = 0;
+			do
+			{
+				OUString aToken( aAttributeName.getToken( 0, ';', nIndex ) );
+				exportAnimPropertyString( rStrm, 0, aToken, TRANSLATE_ATTRIBUTE );
+			}
+			while ( nIndex >= 0 );
+		}
+
+		if( nAfterEffectType != AFTEREFFECT_NONE )
+		{
+			EscherExContainer aAnimPropertySet( rStrm, DFF_msofbtAnimPropertySet );
+			exportAnimPropertyuInt32( rStrm, 6, 1, TRANSLATE_NONE );
+			if( nAfterEffectType == AFTEREFFECT_COLOR )
+			{
+				exportAnimPropertyuInt32( rStrm, 4, 0, TRANSLATE_NONE );
+				exportAnimPropertyuInt32( rStrm, 5, 0, TRANSLATE_NONE );
+			}
+		}
+		exportAnimateTargetElement( rStrm, aTarget.hasValue() ? aTarget : xAnimate->getTarget(), sal_False );
+	}
+}
+
+void AnimationExporter::exportAnimateTargetElement( SvStream& rStrm, const Any aAny, const sal_Bool bCreate2b01Atom )
+{
+	Reference< XShape > xShape;
+	aAny >>= xShape;
+	sal_uInt32 nRefMode = 0;	// nRefMode == 2 -> Paragraph
+	sal_Int32 begin = -1;
+	sal_Int32 end = -1;
+
+	if( !xShape.is() )
+	{
+		ParagraphTarget aParaTarget;
+		if( aAny >>= aParaTarget )
+			xShape = aParaTarget.Shape;
+		if ( xShape.is() )
+		{
+			// now calculating the character range for the paragraph
+			sal_Int16 nParagraph = aParaTarget.Paragraph;
+			Reference< XSimpleText > xText( xShape, UNO_QUERY );
+			if ( xText.is() )
+			{
+				nRefMode = 2;
+				Reference< XEnumerationAccess > xTextParagraphEnumerationAccess( xText, UNO_QUERY );
+				if ( xTextParagraphEnumerationAccess.is() )
+				{
+					Reference< XEnumeration > xTextParagraphEnumeration( xTextParagraphEnumerationAccess->createEnumeration() );
+					if ( xTextParagraphEnumeration.is() )
+					{
+						sal_Int16 nCurrentParagraph;
+						begin = end = nCurrentParagraph = 0;
+						while ( xTextParagraphEnumeration->hasMoreElements() )
+						{
+							Reference< XTextRange > xTextRange( xTextParagraphEnumeration->nextElement(), UNO_QUERY );
+							if ( xTextRange.is() )
+							{
+								rtl::OUString aParaText( xTextRange->getString() );
+								sal_Int32 nLength = aParaText.getLength() + 1;
+								end += nLength;
+								if ( nCurrentParagraph == nParagraph )
+									break;
+								nCurrentParagraph++;
+								begin += nLength;
+							}
+						}
+					}
+				}
+			}
+		}
+	}
+	if ( xShape.is() || bCreate2b01Atom )
+	{
+		EscherExContainer aAnimateTargetElement( rStrm, DFF_msofbtAnimateTargetElement );
+		if ( xShape.is() )
+		{
+			EscherExAtom aAnimReference( rStrm, DFF_msofbtAnimReference );
+
+			sal_uInt32 nRefType = 1;	// TODO: nRefType == 2 -> Sound;
+			sal_uInt32 nRefId = ((EscherSolverContainer&)mrSolverContainer).GetShapeId( xShape );
+
+			rStrm << nRefMode
+				  << nRefType
+				  << nRefId
+				  << begin
+				  << end;
+		}
+		if ( bCreate2b01Atom )
+		{
+			EscherExAtom a2b01Atom( rStrm, 0x2b01 );
+			rStrm << (sal_uInt32)1;		// ?
+		}
+	}
+}
+
+void AnimationExporter::exportAnimateKeyPoints( SvStream& rStrm, const Reference< XAnimate >& xAnimate )
+{
+	Sequence< double > aKeyTimes( xAnimate->getKeyTimes() );
+	Sequence< Any > aValues( xAnimate->getValues() );
+	OUString aFormula( xAnimate->getFormula() );
+	if ( aKeyTimes.getLength() )
+	{
+		EscherExContainer aAnimKeyPoints( rStrm, DFF_msofbtAnimKeyPoints );
+		sal_Int32 i;
+		for ( i = 0; i < aKeyTimes.getLength(); i++ )
+		{
+			{
+				EscherExAtom aAnimKeyTime( rStrm, DFF_msofbtAnimKeyTime );
+				sal_Int32 nKeyTime = (sal_Int32)( aKeyTimes[ i ] * 1000.0 );
+				rStrm << nKeyTime;
+			}
+			Any aAny[ 2 ];
+			if ( aValues[ i ].hasValue() )
+			{
+				ValuePair aPair;
+				if ( aValues[ i ] >>= aPair )
+				{
+					aAny[ 0 ] = convertAnimateValue( aPair.First, xAnimate->getAttributeName() );
+					aAny[ 1 ] = convertAnimateValue( aPair.Second, xAnimate->getAttributeName() );
+				}
+				else
+				{
+					aAny[ 0 ] = convertAnimateValue( aValues[ i ], xAnimate->getAttributeName() );
+				}
+				if ( !i && aFormula.getLength() )
+				{
+					ImplTranslateAttribute( aFormula, TRANSLATE_MEASURE );
+					aAny[ 1 ] <<= aFormula;
+				}
+				exportAnimProperty( rStrm, 0, aAny[ 0 ], TRANSLATE_NONE );
+				exportAnimProperty( rStrm, 1, aAny[ 1 ], TRANSLATE_NONE );
+			}
+		}
+	}
+}
+
+void AnimationExporter::exportAnimValue( SvStream& rStrm, const Reference< XAnimationNode >& xNode, const sal_Bool bExportAlways )
+{
+	Any aAny;
+	// repeat count (0)
+	double fRepeat = 0.0;
+	float fRepeatCount = 0.0;
+	com::sun::star::animations::Timing eTiming;
+	aAny = xNode->getRepeatCount();
+	if ( aAny >>= eTiming )
+	{
+		if ( eTiming == Timing_INDEFINITE )
+			fRepeatCount = ((float)3.40282346638528860e+38);
+	}
+	else if ( aAny >>= fRepeat )
+		fRepeatCount = (float)fRepeat;
+	if ( fRepeatCount != 0.0 )
+	{
+		EscherExAtom aExAtom( rStrm, DFF_msofbtAnimValue );
+		sal_uInt32 nType = 0;
+		rStrm << nType
+			  << fRepeatCount;
+	}
+	// accelerate (3)
+	float fAccelerate = (float)xNode->getAcceleration();
+	if ( bExportAlways || ( fAccelerate != 0.0 ) )
+	{
+		EscherExAtom aExAtom( rStrm, DFF_msofbtAnimValue );
+		sal_uInt32 nType = 3;
+		rStrm << nType
+			  << fAccelerate;
+	}
+
+	// decelerate (4)
+	float fDecelerate = (float)xNode->getDecelerate();
+	if ( bExportAlways || ( fDecelerate != 0.0 ) )
+	{
+		EscherExAtom aExAtom( rStrm, DFF_msofbtAnimValue );
+		sal_uInt32 nType = 4;
+		rStrm << nType
+			  << fDecelerate;
+	}
+
+	// autoreverse (5)
+	sal_Bool bAutoReverse = xNode->getAutoReverse();
+	if ( bExportAlways || bAutoReverse )
+	{
+		EscherExAtom aExAtom( rStrm, DFF_msofbtAnimValue );
+		sal_uInt32 nType = 5;
+		sal_uInt32 nVal  = bAutoReverse ? 1 : 0;
+		rStrm << nType
+			  << nVal;
+	}
+}
+
+void AnimationExporter::exportTransitionFilter( SvStream& rStrm, const Reference< XAnimationNode >& xNode )
+{
+	Reference< XTransitionFilter > xFilter( xNode, UNO_QUERY );
+	if ( xFilter.is() )
+	{
+		EscherExContainer aAnimateFilter( rStrm, DFF_msofbtAnimateFilter );
+		{
+			EscherExAtom aAnimateFilterData( rStrm, DFF_msofbtAnimateFilterData );
+			sal_uInt32 nBits = 3;		// bit 0 -> use AnimAttributeValue
+										// bit 1 -> use nTransition
+
+			sal_uInt32 nTransition = xFilter->getMode() ? 0 : 1;
+			rStrm << nBits
+				  << nTransition;
+		}
+		const sal_Char* pFilter = transition::find( xFilter->getTransition(), xFilter->getSubtype(), xFilter->getDirection() );
+		if ( pFilter )
+		{
+			const OUString aStr( OUString::createFromAscii( pFilter ) );
+			exportAnimPropertyString( rStrm, 1, aStr, TRANSLATE_NONE );
+		}
+		exportAnimateTarget( rStrm, xNode );
+	}
+}
+
+void AnimationExporter::exportAnimateMotion( SvStream& rStrm, const Reference< XAnimationNode >& xNode )
+{
+	Reference< XAnimateMotion > xMotion( xNode, UNO_QUERY );
+	if ( xMotion.is() )
+	{
+		EscherExContainer aAnimateMotion( rStrm, DFF_msofbtAnimateMotion );
+		{
+			{	//SJ: Ignored from import filter
+				EscherExAtom aAnimateMotionData( rStrm, DFF_msofbtAnimateMotionData ); 
+				sal_uInt32 nBits = 0x98;
+				sal_uInt32 nOrigin = 0x2;
+				float fByX = 100.0;	// nBits&1
+				float fByY = 100.0; // nBits&1
+				float fFromX = 0.0; // nBits&2
+				float fFromY = 0.0; // nBits&2
+				float fToX = 100.0; // nBits&4
+				float fToY = 100.0; // nBits&4
+				rStrm << nBits << fByX << fByY << fFromX << fFromY << fToX << fToY << nOrigin;
+			}
+/*			?
+			{
+				EscherExAtom aF137( rStrm, 0xf137 );
+			}
+*/
+			OUString aStr;
+			if ( xMotion->getPath() >>= aStr )
+			{
+				if ( aStr.getLength() )
+					exportAnimPropertyString( rStrm, 1, aStr, TRANSLATE_NONE );
+			}
+			exportAnimateTarget( rStrm, xNode );
+		}
+	}
+}
+
+void AnimationExporter::exportAnimateTransform( SvStream& rStrm, const Reference< XAnimationNode >& xNode )
+{
+	Reference< XAnimateTransform > xTransform( xNode, UNO_QUERY );
+	if ( xTransform.is() )
+	{
+		if ( xTransform->getTransformType() ==  AnimationTransformType::SCALE )
+		{
+			EscherExContainer aAnimateScale( rStrm, DFF_msofbtAnimateScale );
+			{
+				EscherExAtom aAnimateScaleData( rStrm, DFF_msofbtAnimateScaleData );
+				sal_uInt32 nBits = 0;
+				sal_uInt32 nZoomContents = 1;
+				float fByX = 100.0;
+				float fByY = 100.0;
+				float fFromX = 0.0;
+				float fFromY = 0.0;
+				float fToX = 100.0;
+				float fToY = 100.0;
+
+				double fX = 0.0, fY = 0.0;
+				ValuePair aPair;
+				if ( xTransform->getBy() >>= aPair )
+				{
+					if ( ( aPair.First >>= fX ) && ( aPair.Second >>= fY ) )
+					{
+						nBits |= 1;
+						fByX = (float)( fX * 100 );
+						fByY = (float)( fY * 100 );
+					}
+				}
+				if ( xTransform->getFrom() >>= aPair )
+				{
+					if ( ( aPair.First >>= fX ) && ( aPair.Second >>= fY ) )
+					{
+						nBits |= 2;
+						fFromX = (float)( fX * 100 );
+						fFromY = (float)( fY * 100 );
+					}
+				}
+				if( xTransform->getTo() >>= aPair )
+				{
+					if ( ( aPair.First >>= fX ) && ( aPair.Second >>= fY ) )
+					{
+						nBits |= 4;
+						fToX = (float)( fX * 100 );
+						fToY = (float)( fY * 100 );
+					}
+				}
+
+				// TODO: ZoomContents:
+				//if( nBits & 8 )
+				//(	fprintf( mpFile, " zoomContents=\"%s\"", nZoomContents ? "true" : "false" );
+
+				rStrm << nBits << fByX << fByY << fFromX << fFromY << fToX << fToY << nZoomContents;
+			}
+			exportAnimateTarget( rStrm, xNode );
+		}
+		else if ( xTransform->getTransformType() ==  AnimationTransformType::ROTATE )
+		{
+			EscherExContainer aAnimateRotation( rStrm, DFF_msofbtAnimateRotation );
+			{
+				EscherExAtom aAnimateRotationData( rStrm, DFF_msofbtAnimateRotationData );
+				sal_uInt32 nBits = 0;
+				sal_uInt32 nU1 = 0;
+				float fBy = 360.0;
+				float fFrom = 0.0;
+				float fTo = 360.0;
+
+				double fVal = 0.0;
+				if ( xTransform->getBy() >>= fVal )
+				{
+					nBits |= 1;
+					fBy = (float)fVal;
+				}
+				if ( xTransform->getFrom() >>= fVal )
+				{
+					nBits |= 2;
+					fFrom = (float)fVal;
+				}
+				if ( xTransform->getTo() >>= fVal )
+				{
+					nBits |= 4;
+					fTo = (float)fVal;
+				}
+				rStrm << nBits << fBy << fFrom << fTo << nU1;
+			}
+			exportAnimateTarget( rStrm, xNode, 1 );
+		}
+	}
+}
+
+sal_Bool AnimationExporter::getColorAny( const Any& rAny, const sal_Int16 nColorSpace, sal_Int32& rMode, sal_Int32& rA, sal_Int32& rB, sal_Int32& rC ) const
+{
+	sal_Bool bIsColor = sal_True;
+
+	rMode = 0;
+	if ( nColorSpace == AnimationColorSpace::HSL )
+		rMode = 1;
+
+	sal_Int32 nColor = 0;
+	Sequence< double > aHSL( 3 );
+	if ( rAny >>= nColor )		// RGB color
+	{
+		rA = (sal_uInt8)( nColor >> 24 );
+		rB = (sal_uInt8)( nColor >> 8 );
+		rC = (sal_uInt8)( nColor );
+	}
+	else if ( rAny >>= aHSL )	// HSL
+	{
+		rA = (sal_Int32) ( aHSL[ 0 ] * 255.0 / 360.0 );
+		rB = (sal_Int32) ( aHSL[ 1 ] * 255.0 );
+		rC = (sal_Int32) ( aHSL[ 2 ] * 255.0 );
+	}
+	else
+		bIsColor = sal_False;
+	return bIsColor;
+}
+
+void AnimationExporter::exportAnimateColor( SvStream& rStrm, const Reference< XAnimationNode >& xNode, int nAfterEffectType )
+{
+	Reference< XAnimateColor > xColor( xNode, UNO_QUERY );
+	if ( xColor.is() )
+	{
+		EscherExContainer aAnimateColor( rStrm, DFF_msofbtAnimateColor );
+		{
+			EscherExAtom aAnimateColorData( rStrm, DFF_msofbtAnimateColorData );
+			sal_uInt32 nBits = 8;
+
+			sal_Int32 nByMode, nByA, nByB, nByC;
+			nByMode = nByA = nByB = nByC = 0;
+
+			sal_Int32 nFromMode, nFromA, nFromB, nFromC;
+			nFromMode = nFromA = nFromB = nFromC = 0;
+
+			sal_Int32 nToMode, nToA, nToB, nToC;
+			nToMode = nToA = nToB = nToC = 0;
+
+			sal_Int16 nColorSpace = xColor->getColorInterpolation();
+
+			Any aAny( xColor->getBy() );
+			if ( aAny.hasValue() )
+			{
+				if ( getColorAny( aAny, nColorSpace, nByMode, nByA, nByB, nByC ) )
+					nBits |= 0x11;
+			}
+			aAny = xColor->getFrom();
+			if ( aAny.hasValue() )
+			{
+				if ( getColorAny( aAny, nColorSpace, nFromMode, nFromA, nFromB, nFromC ) )
+					nBits |= 0x12;
+			}
+			aAny = xColor->getTo();
+			if ( aAny.hasValue() )
+			{
+				if ( getColorAny( aAny, nColorSpace, nToMode, nToA, nToB, nToC ) )
+					nBits |= 0x14;
+			}
+			rStrm   << nBits
+					<< nByMode << nByA << nByB << nByC
+					<< nFromMode << nFromA << nFromB << nFromC
+					<< nToMode << nToA << nToB << nToC;
+		}
+		exportAnimateTarget( rStrm, xNode, 0, nAfterEffectType );
+	}
+}
+
+void AnimationExporter::exportIterate( SvStream& rStrm, const Reference< XAnimationNode >& xNode )
+{
+	Reference< XIterateContainer > xIterate( xNode, UNO_QUERY );
+	if ( xIterate.is() )
+	{
+		EscherExAtom aAnimIteration( rStrm, DFF_msofbtAnimIteration );
+
+		float		fInterval = 10.0;
+		sal_Int32	nTextUnitEffect = 0;
+		sal_Int32	nU1 = 1;
+		sal_Int32	nU2 = 1;
+		sal_Int32	nU3 = 0xe;
+
+		sal_Int16 nIterateType = xIterate->getIterateType();
+		switch( nIterateType )
+		{
+			case TextAnimationType::BY_WORD : nTextUnitEffect = 1; break;
+			case TextAnimationType::BY_LETTER : nTextUnitEffect = 2; break;
+		}
+
+		fInterval = (float)xIterate->getIterateInterval();
+
+		// convert interval from absolute to percentage
+		double fDuration = 0.0;
+
+		Reference< XEnumerationAccess > xEnumerationAccess( xNode, UNO_QUERY );
+		if( xEnumerationAccess.is() )
+		{
+			Reference< XEnumeration > xEnumeration( xEnumerationAccess->createEnumeration(), UNO_QUERY );
+			if( xEnumeration.is() )
+			{
+				while( xEnumeration->hasMoreElements() )
+				{
+					Reference< XAnimate > xChildNode( xEnumeration->nextElement(), UNO_QUERY );
+					if( xChildNode.is() )
+					{
+						double fChildBegin = 0.0;
+						double fChildDuration = 0.0;
+						xChildNode->getBegin() >>= fChildBegin;
+						xChildNode->getDuration() >>= fChildDuration;
+
+						fChildDuration += fChildBegin;
+						if( fChildDuration > fDuration )
+							fDuration = fChildDuration;
+					}
+				}
+			}
+		}
+
+		if( fDuration )
+			fInterval = (float)(100.0 * fInterval / fDuration);
+
+		rStrm << fInterval << nTextUnitEffect << nU1 << nU2 << nU3;
+		aTarget = xIterate->getTarget();
+	}
+}
+
+} // namespace ppt;
+
diff --git a/sd/source/filter/pptx/pptx-pptexsoundcollection.cxx b/sd/source/filter/pptx/pptx-pptexsoundcollection.cxx
new file mode 100644
index 0000000..fe8616c
--- /dev/null
+++ sd/source/filter/pptx/pptx-pptexsoundcollection.cxx
@@ -0,0 +1,232 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: pptexsoundcollection.cxx,v $
+ * $Revision: 1.7 $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+
+// MARKER(update_precomp.py): autogen include statement, do not remove
+#include "precompiled_sd.hxx"
+#include <pptexsoundcollection.hxx>
+#include "epptdef.hxx"
+#include <tools/urlobj.hxx>
+#ifndef _UCBHELPER_CONTENT_HXX_
+#include <ucbhelper/content.hxx>
+#endif
+#ifndef _UCBHELPER_CONTENTBROKER_HXX_
+#include <ucbhelper/contentbroker.hxx>
+#endif
+#ifndef _CPPUHELPER_PROPTYPEHLP_HXX_
+#include <cppuhelper/proptypehlp.hxx>
+#endif
+#include <unotools/ucbstreamhelper.hxx>
+
+namespace ppt
+{
+
+ExSoundEntry::ExSoundEntry( const String& rString )
+:	nFileSize( 0 )
+,	aSoundURL( rString )
+{
+    try
+    {
+        ::ucbhelper::Content aCnt( aSoundURL,
+            ::com::sun::star::uno::Reference< ::com::sun::star::ucb::XCommandEnvironment >() );
+        sal_Int64 nVal = 0;
+        ::cppu::convertPropertyValue( nVal, aCnt.getPropertyValue( ::rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "Size" ) ) ) );
+        nFileSize = (sal_uInt32)nVal;
+    }
+    catch( ::com::sun::star::uno::Exception& )
+    {
+
+    }
+};
+
+String ExSoundEntry::ImplGetName() const
+{
+    INetURLObject aTmp( aSoundURL );
+    return aTmp.GetName();
+}
+
+String ExSoundEntry::ImplGetExtension() const
+{
+    INetURLObject aTmp( aSoundURL );
+    String aExtension( aTmp.GetExtension() );
+    if ( aExtension.Len() )
+        aExtension.Insert( (sal_Unicode)'.', 0 );
+    return aExtension;
+}
+
+sal_Bool ExSoundEntry::IsSameURL( const String& rURL ) const
+{
+    return ( rURL == aSoundURL );
+}
+
+sal_uInt32 ExSoundEntry::GetSize( sal_uInt32 nId ) const
+{
+    String aName( ImplGetName() );
+    String aExtension( ImplGetExtension() );
+
+    sal_uInt32 nSize = 8;                           // SoundContainer Header
+    if ( aName.Len() )                              // String Atom          ( instance 0 - name of sound )
+        nSize += aName.Len() * 2 + 8;
+    if ( aExtension.Len() )                         // String Atom          ( instance 1 - extension of sound )
+        nSize += aExtension.Len() * 2 + 8;
+
+    String aId( String::CreateFromInt32( nId ) );   // String Atom          ( instance 2 - reference id )
+    nSize += 2 * aId.Len() + 8;
+
+    nSize += nFileSize + 8;                         // SoundData Atom
+
+    return nSize;
+}
+
+void ExSoundEntry::Write( SvStream& rSt, sal_uInt32 nId )
+{
+    try
+    {
+        ::ucbhelper::Content aCnt( aSoundURL,
+            ::com::sun::star::uno::Reference< ::com::sun::star::ucb::XCommandEnvironment >() );
+
+        // create SoundContainer
+        rSt << (sal_uInt32)( ( EPP_Sound << 16 ) | 0xf ) << (sal_uInt32)( GetSize( nId ) - 8 );
+
+        String aSoundName( ImplGetName() );
+        sal_uInt16 i, nSoundNameLen = aSoundName.Len();
+        if ( nSoundNameLen )
+        {
+            // name of sound ( instance 0 )
+            rSt << (sal_uInt32)( EPP_CString << 16 ) << (sal_uInt32)( nSoundNameLen * 2 );
+            for ( i = 0; i < nSoundNameLen; i++ )
+                rSt << aSoundName.GetChar( i );
+        }
+        String aExtension( ImplGetExtension() );
+        sal_uInt32 nExtensionLen = aExtension.Len();
+        if ( nExtensionLen )
+        {
+            // extension of sound ( instance 1 )
+            rSt << (sal_uInt32)( ( EPP_CString << 16 ) | 16 ) << (sal_uInt32)( nExtensionLen * 2 );
+            for ( i = 0; i < nExtensionLen; i++ )
+                rSt << aExtension.GetChar( i );
+        }
+        // id of sound ( instance 2 )
+        String aId( String::CreateFromInt32( nId ) );
+        sal_uInt32 nIdLen = aId.Len();
+        rSt << (sal_uInt32)( ( EPP_CString << 16 ) | 32 ) << (sal_uInt32)( nIdLen * 2 );
+        for ( i = 0; i < nIdLen; i++ )
+            rSt << aId.GetChar( i );
+
+        rSt << (sal_uInt32)( EPP_SoundData << 16 ) << (sal_uInt32)( nFileSize );
+        sal_uInt32 nBytesLeft = nFileSize;
+        SvStream* pSourceFile = ::utl::UcbStreamHelper::CreateStream( aSoundURL, STREAM_READ );
+        if ( pSourceFile )
+        {
+            sal_uInt8* pBuf = new sal_uInt8[ 0x10000 ];   // 64 kB  Buffer
+            while ( nBytesLeft )
+            {
+                sal_uInt32 nToDo = ( nBytesLeft > 0x10000 ) ? 0x10000 : nBytesLeft;
+                pSourceFile->Read( pBuf, nToDo );
+                rSt.Write( pBuf, nToDo );
+                nBytesLeft -= nToDo;
+            }
+            delete pSourceFile;
+            delete[] pBuf;
+        }
+    }
+    catch( ::com::sun::star::uno::Exception& )
+    {
+
+    }
+}
+
+ExSoundCollection::~ExSoundCollection()
+{
+    for( void* pPtr = List::First(); pPtr; pPtr = List::Next() )
+        delete (ExSoundEntry*)pPtr;
+}
+
+sal_uInt32 ExSoundCollection::GetId( const String& rString )
+{
+    sal_uInt32 nSoundId = 0;
+    if( rString.Len() )
+    {
+        const sal_uInt32 nSoundCount = Count();
+
+        for( ; nSoundId < nSoundCount; nSoundId++ )
+            if( ImplGetByIndex( nSoundId )->IsSameURL( rString ) )
+                break;
+        if ( nSoundId++ == nSoundCount )
+        {
+            ExSoundEntry* pEntry = new ExSoundEntry( rString );
+            if ( pEntry->GetFileSize() )
+                List::Insert( pEntry, LIST_APPEND );
+            else
+            {
+                nSoundId = 0;   // only insert sounds that are accessible
+                delete pEntry;
+            }
+        }
+    }
+    return nSoundId;
+}
+
+const ExSoundEntry* ExSoundCollection::ImplGetByIndex( sal_uInt32 nIndex ) const
+{
+    return (ExSoundEntry*)List::GetObject( nIndex );
+}
+
+sal_uInt32 ExSoundCollection::GetSize() const
+{
+    sal_uInt32 nSize = 0;
+    sal_uInt32 i, nSoundCount = Count();
+    if ( nSoundCount )
+    {
+        nSize += 8 + 12;    // size of SoundCollectionContainerHeader + SoundCollAtom
+        for ( i = 0; i < nSoundCount; i++ )
+            nSize += ImplGetByIndex( i )->GetSize( i + 1 );
+    }
+    return nSize;
+}
+
+void ExSoundCollection::Write( SvStream& rSt )
+{
+    sal_uInt32 i, nSoundCount = Count();
+    if ( nSoundCount )
+    {
+        // create SoundCollection Container
+        rSt << (sal_uInt16)0xf << (sal_uInt16)EPP_SoundCollection << (sal_uInt32)( GetSize() - 8 );
+
+        // create SoundCollAtom ( reference to the next free SoundId );
+        rSt << (sal_uInt32)( EPP_SoundCollAtom << 16 ) << (sal_uInt32)4 << nSoundCount;
+
+        for ( i = 0; i < nSoundCount; i++ )
+            ((ExSoundEntry*)List::GetObject( i ))->Write( rSt, i + 1 );
+    }
+}
+
+
+} // namespace ppt;
+
diff --git a/sd/util/makefile.mk b/sd/util/makefile.mk
index fb5e7af..08c64d0 100644
--- sd/util/makefile.mk
+++ sd/util/makefile.mk
@@ -270,6 +270,36 @@ SHL5STDLIBS = $(ISDLIB) \
               $(COMPHELPERLIB)    \
               $(I18NISOLANGLIB)
 
+# pptx export library
+SHL6TARGET    = pptx$(DLLPOSTFIX)
+SHL6IMPLIB    = pptxi
+SHL6VERSIONMAP= pptx.map
+SHL6DEF       = $(MISC)$/$(SHL6TARGET).def
+SHL6LIBS      = $(SLB)$/pptx.lib
+SHL6DEPN      = $(SHL1TARGETN)
+DEF6NAME      = $(SHL6TARGET)
+
+SHL6STDLIBS = $(ISDLIB) \
+              $(SVXCORELIB)       \
+              $(SVXMSFILTERLIB)   \
+              $(SFX2LIB)          \
+              $(SVTOOLLIB)        \
+              $(SOTLIB)           \
+              $(GOODIESLIB)       \
+              $(VCLLIB)           \
+              $(SVLLIB)           \
+              $(SOTLIB)           \
+              $(UNOTOOLSLIB)      \
+              $(TOOLSLIB)         \
+              $(UCBHELPERLIB)     \
+              $(CPPUHELPERLIB)    \
+              $(CPPULIB)          \
+              $(SALLIB)           \
+              $(COMPHELPERLIB)    \
+              $(I18NISOLANGLIB)   \
+              $(OOXLIB)           \
+              $(SAXLIB)
+
 # --- Targets -------------------------------------------------------------
 
 .INCLUDE :  target.mk
diff --git a/sd/util/pptx.map b/sd/util/pptx.map
new file mode 100644
index 0000000..e72a8e3
--- /dev/null
+++ sd/util/pptx.map
@@ -0,0 +1,9 @@
+PPTX_1_0 {
+        global:
+                component_getImplementationEnvironment;
+                component_writeInfo;
+                component_getFactory;
+
+        local:
+                *;
+};
