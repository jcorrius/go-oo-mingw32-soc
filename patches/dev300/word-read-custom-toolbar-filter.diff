diff --git svx/inc/svx/mstoolbar.hxx svx/inc/svx/mstoolbar.hxx
new file mode 100644
index 0000000..d78a90d
--- /dev/null
+++ svx/inc/svx/mstoolbar.hxx
@@ -0,0 +1,267 @@
+#ifndef _MSTOOLBAR_HXX
+#define _MSTOOLBAR_HXX
+#include "svx/svxdllapi.h"
+#include <tools/string.hxx>
+#include <sot/storage.hxx>
+#include <ostream>
+#include <memory>
+#include <vector>
+#include <boost/shared_ptr.hpp>
+#include <com/sun/star/frame/XModel.hpp>
+#include <com/sun/star/container/XIndexContainer.hpp>
+#include <com/sun/star/ui/XUIConfigurationManagerSupplier.hpp>
+#include <com/sun/star/graphic/XGraphic.hpp>
+#include <com/sun/star/beans/XPropertySet.hpp>
+#include <vcl/bitmap.hxx>
+
+namespace css = ::com::sun::star;
+
+class TBCHeader;
+
+
+class MSOCommandConvertor
+{
+public:
+    virtual ~MSOCommandConvertor() {}
+    virtual rtl::OUString MSOCommandToOOCommand( sal_Int16 msoCmd ) = 0; 
+    virtual rtl::OUString MSOTCIDToOOCommand( sal_Int16 msoTCID ) = 0; 
+};
+
+
+class SVX_DLLPUBLIC CustomToolBarImportHelper
+{
+    struct iconcontrolitem
+    {
+        rtl::OUString sCommand;
+        css::uno::Reference< css::graphic::XGraphic > image;
+    };
+    std::vector< iconcontrolitem > iconcommands;
+    std::auto_ptr< MSOCommandConvertor > pMSOCmdConvertor;
+    css::uno::Reference< css::ui::XUIConfigurationManagerSupplier > m_xCfgSupp;
+    css::uno::Reference< css::ui::XUIConfigurationManager > m_xAppCfgMgr;
+
+public:
+    CustomToolBarImportHelper( const css::uno::Reference< css::frame::XModel >& rxModel, const css::uno::Reference< css::ui::XUIConfigurationManager >& rxAppCfgMgr );
+
+    void setMSOCommandMap( MSOCommandConvertor* pCnvtr ) { pMSOCmdConvertor.reset( pCnvtr ); }
+    css::uno::Reference< css::ui::XUIConfigurationManager > getCfgManager();
+    css::uno::Reference< css::ui::XUIConfigurationManager > getAppCfgManager();
+
+
+    static css::uno::Any createCommandFromMacro( const rtl::OUString& sCmd );
+
+    void addIcon( const css::uno::Reference< css::graphic::XGraphic >& xImage, const rtl::OUString& sString );
+    void applyIcons();
+    rtl::OUString MSOCommandToOOCommand( sal_Int16 msoCmd );
+    rtl::OUString MSOTCIDToOOCommand( sal_Int16 msoTCID );
+};
+
+class SVX_DLLPUBLIC TBBase
+{
+friend class Indent;
+    static int nIndent; // num spaces to indent before printing 
+protected:
+    void indent_printf(FILE* fp, const char* format, ... );
+    sal_uInt32 nOffSet; // usually for debug we can store the offset in the stream to this record
+public:
+    TBBase() : nOffSet( 0 ) {}
+    virtual ~TBBase(){}
+    rtl::OUString readUnicodeString( SvStream* pS, sal_Int32 nChars );
+
+    virtual bool Read(SvStream *pS) = 0;
+    virtual void Print( FILE* ) {} // #FIXME remove this an implement the debug routines in all the classes below to enable some sort of readable output
+};
+
+class Indent
+{
+public:
+    Indent( bool binit = false ) 
+    { 
+        if ( binit )
+            init();
+        else
+            TBBase::nIndent = TBBase::nIndent + 2; 
+    }
+    ~Indent() { TBBase::nIndent = TBBase::nIndent - 2; }
+    void init() { TBBase::nIndent = 0; }
+};
+
+
+class SVX_DLLPUBLIC WString : public TBBase
+{
+    rtl::OUString sString;
+
+public:
+    WString(){};
+    ~WString(){};
+    bool Read(SvStream *pS);
+    rtl::OUString getString(){ return sString; }
+};
+
+class SVX_DLLPUBLIC TBCExtraInfo : public TBBase
+{
+    WString wstrHelpFile;
+    sal_Int32 idHelpContext;
+    WString wstrTag;
+    WString wstrOnAction;
+    WString wstrParam;
+    sal_Int8 tbcu;
+    sal_Int8 tbmg;
+
+    TBCExtraInfo(const TBCExtraInfo&);
+    TBCExtraInfo& operator = ( const TBCExtraInfo&);
+public:
+    TBCExtraInfo();
+    ~TBCExtraInfo(){}
+    bool Read(SvStream *pS);
+    void Print( FILE* );
+    rtl::OUString getOnAction();
+};
+
+class SVX_DLLPUBLIC TBCGeneralInfo  : public TBBase
+{
+    sal_uInt8 bFlags;
+    WString customText;
+    WString descriptionText;
+    WString tooltip;
+    TBCExtraInfo extraInfo;
+
+public:
+    TBCGeneralInfo();
+    ~TBCGeneralInfo() {}
+    bool Read(SvStream *pS);
+    void Print( FILE* );
+    bool ImportToolBarControlData( std::vector< css::beans::PropertyValue >& );
+};
+
+class SVX_DLLPUBLIC TBCBitMap : public TBBase
+{
+friend class TBCBSpecific; // #FIXME hacky access, need to fix
+    sal_Int32 cbDIB;
+    Bitmap mBitMap;
+    int size;
+public:
+    TBCBitMap();
+    ~TBCBitMap();
+    bool Read(SvStream *pS);
+    void Print( FILE* );
+    Bitmap& getBitMap(); 
+};
+
+class SVX_DLLPUBLIC TBCMenuSpecific : public TBBase
+{
+    sal_Int32 tbid;
+    boost::shared_ptr< WString > name; //exist only if tbid equals 0x00000001
+public:
+    TBCMenuSpecific();
+    ~TBCMenuSpecific(){}
+    bool Read(SvStream *pS);
+    void Print( FILE* );
+};
+
+class SVX_DLLPUBLIC TBCCDData : public TBBase
+{
+    sal_Int16 cwstrItems; //Signed integer that specifies the number of items in wstrList. MUST be positive.
+    std::vector< WString > wstrList;  // Zero-based index array of WString structures. Number of elements MUST be equal to cwstrItems.
+    sal_Int16 cwstrMRU; // Signed integer that specifies the number of most recently used string
+    sal_Int16 iSel ; // Signed integer that specifies the zero-based index of the selected item in the wstrList field. MUST be equal to 0xFFFF (-1) or greater than or equal to 0x0000.
+    sal_Int16 cLines; // Signed integer that specifies the suggested number of lines that the toolbar control will display at any time when displaying the elements of wstrList of available items. 
+    sal_Int16 dxWidth; // Signed integer that specifies the width in pixels that the interior of the dropdown has. This excludes the width of the toolbar control border and scroll bar.
+    WString wstrEdit; //Structure of type WString. Editable text for editable area of the ComboBox toolbar control.
+
+public:
+    TBCCDData();
+    ~TBCCDData();
+    bool Read(SvStream *pS);
+    void Print( FILE* );
+};
+
+class TBCComboDropdownSpecific : public TBBase
+{
+    boost::shared_ptr< TBCCDData > data;
+public:
+    TBCComboDropdownSpecific( const TBCHeader& header );
+    TBCComboDropdownSpecific(){}
+    bool Read(SvStream *pS);
+    void Print( FILE* );
+};
+
+class TBCBSpecific :  public TBBase
+{
+    sal_uInt8 bFlags;
+    boost::shared_ptr< TBCBitMap > icon; // optional
+    boost::shared_ptr< TBCBitMap > iconMask; // optional
+    boost::shared_ptr< sal_uInt16 > iBtnFace; // optional
+    boost::shared_ptr< WString > wstrAcc; // optional
+   
+public:
+    TBCBSpecific();
+    ~TBCBSpecific(){}
+    bool Read(SvStream *pS);
+    void Print( FILE* );
+    // #TODO just add a getGraphic member here
+    TBCBitMap* getIcon();
+    TBCBitMap* getIconMask();
+    sal_uInt16* getBtnFace() { return iBtnFace.get(); }
+};
+
+/* TBCHeader.tct                   controlSpecificInfo type
+
+0x01 (Button control)              TBCBSpecific
+0x10 (ExpandingGrid control)       TBCBSpecific
+0x0A (Popup control)               TBCMenuSpecific
+0x0C (ButtonPopup control)         TBCMenuSpecific
+0x0D (SplitButtonPopup control)    TBCMenuSpecific
+0x0E (SplitButtonMRUPopup control) TBCMenuSpecific
+0x02 (Edit control)                TBCComboDropdow nSpecific
+0x04 (ComboBox control)            TBCComboDropdow nSpecific
+0x14 (GraphicCombo control)        TBCComboDropdow nSpecific
+0x03 (DropDown control)            TBCComboDropdow nSpecific
+0x06 (SplitDropDown control)       TBCComboDropdow nSpecific
+0x09 (GraphicDropDown control)     TBCComboDropdow nSpecific
+0x07 (OCXDropDown control)         controlSpecificInfo MUST NOT exist
+0x0F (Label control)               controlSpecificInfo MUST NOT exist
+0x12 (Grid control)                controlSpecificInfo MUST NOT exist
+0x13 (Gauge control)               controlSpecificInfo MUST NOT exist
+0x16 (ActiveX control)             controlSpecificInfo MUST NOT exist
+
+*/
+class SVX_DLLPUBLIC TBCHeader : public TBBase
+{
+    sal_Int8 bSignature; 
+    sal_Int8 bVersion; 
+    sal_uInt8 bFlagsTCR; 
+    sal_uInt8 tct; 
+    sal_uInt16 tcid;
+    sal_uInt32 tbct;
+    sal_uInt8 bPriority;
+    boost::shared_ptr< sal_uInt16 > width;  //optional
+    boost::shared_ptr< sal_uInt16 > height; //optional
+
+public:
+    TBCHeader();
+    ~TBCHeader();
+    sal_uInt8 getTct() const { return tct; }
+    sal_uInt16 getTcID() const { return tcid; }
+    bool isVisible() { return !( bFlagsTCR & 0x1 ); }
+    bool Read(SvStream *pS);
+    void Print( FILE* );
+    sal_uInt32 getTbct() { return tbct; };
+};
+
+class SVX_DLLPUBLIC TBCData : public TBBase
+{
+    TBCHeader rHeader;
+    TBCGeneralInfo controlGeneralInfo;
+    boost::shared_ptr< TBBase > controlSpecificInfo; // can be one of TBCBSpecific, TBCMenuSpecific or TBCComboDropdow nSpecific depending on the control type specified by TBCHeader.tct 
+    TBCData(const TBCData&);
+    TBCData& operator = ( const TBCData&);
+public:
+    TBCData( const TBCHeader& Header );
+    ~TBCData(){}
+    bool Read(SvStream *pS);
+    void Print( FILE* );
+    bool ImportToolBarControl(  const css::uno::Reference< css::container::XIndexContainer >&, CustomToolBarImportHelper&, std::vector< css::beans::PropertyValue >& );
+};
+
+#endif
diff --git svx/prj/d.lst svx/prj/d.lst
index e32ec30..385a905 100644
--- svx/prj/d.lst
+++ svx/prj/d.lst
@@ -655,5 +655,6 @@ mkdir: %_DEST%\inc%_EXT%\svx\sdr\table
 ..\inc\svx\selectioncontroller.hxx %_DEST%\inc%_EXT%\svx\selectioncontroller.hxx
 ..\inc\svx\helperhittest3d.hxx %_DEST%\inc%_EXT%\svx\helperhittest3d.hxx
 ..\inc\svx\optimprove.hxx %_DEST%\inc%_EXT%\svx\optimprove.hxx
+..\inc\svx\mstoolbar.hxx %_DEST%\inc%_EXT%\svx\mstoolbar.hxx
 
 ..\%__SRC%\bin\*-layout.zip %_DEST%\pck%_EXT%\*.*
diff --git svx/source/msfilter/makefile.mk svx/source/msfilter/makefile.mk
index 8db71d1..768bc0e 100644
--- svx/source/msfilter/makefile.mk
+++ svx/source/msfilter/makefile.mk
@@ -54,7 +54,8 @@ SLOFILES=\
 	$(SLO)$/msocximex.obj	\
 	$(SLO)$/msashape3d.obj	\
 	$(SLO)$/mscodec.obj		\
-	$(SLO)$/msfiltertracer.obj
+	$(SLO)$/msfiltertracer.obj\
+	$(SLO)$/mstoolbar.obj\
 
 EXCEPTIONSFILES= \
 	$(SLO)$/eschesdo.obj	\
@@ -65,7 +66,8 @@ EXCEPTIONSFILES= \
 	$(SLO)$/msocximex.obj	\
 	$(SLO)$/msoleexp.obj	\
 	$(SLO)$/svxmsbas.obj	\
-	$(SLO)$/msfiltertracer.obj
+	$(SLO)$/msfiltertracer.obj\
+	$(SLO)$/mstoolbar.obj\
 
 .INCLUDE :  target.mk
 
diff --git svx/source/msfilter/mstoolbar.cxx svx/source/msfilter/mstoolbar.cxx
new file mode 100644
index 0000000..cb1c4bf
--- /dev/null
+++ svx/source/msfilter/mstoolbar.cxx
@@ -0,0 +1,607 @@
+#include <svx/mstoolbar.hxx>
+#include <rtl/ustrbuf.hxx>
+#include <stdarg.h>
+#include <com/sun/star/ui/XUIConfigurationPersistence.hpp>
+#include <com/sun/star/ui/XImageManager.hpp>
+#include <com/sun/star/ui/ItemType.hpp>
+#include <fstream>
+#include <vcl/graph.hxx>
+#include <vcl/bitmapex.hxx>
+#include <map>
+
+int TBBase::nIndent = 0;
+
+using namespace com::sun::star;
+void CustomToolBarImportHelper::applyIcons()
+{
+    for ( std::vector< iconcontrolitem >::iterator it = iconcommands.begin(); it != iconcommands.end(); ++it )
+    {
+        uno::Sequence< rtl::OUString > commands(1);
+        commands[ 0 ] = it->sCommand;
+        uno::Sequence< uno::Reference< graphic::XGraphic > > images(1);
+        images[ 0 ] = it->image;
+
+        uno::Reference< ui::XImageManager > xImageManager( getCfgManager()->getImageManager(), uno::UNO_QUERY_THROW );
+        // 1 seems to work best for MSO images, otherwise they don't get displayed ( I guess the default size
+        // in ooo is different )
+        xImageManager->insertImages( 1,  commands, images );
+    }
+}
+
+void CustomToolBarImportHelper::addIcon( const uno::Reference< graphic::XGraphic >& xImage, const rtl::OUString& sString )
+{
+    iconcontrolitem item;
+    item.sCommand = sString;
+    item.image = xImage;
+    iconcommands.push_back( item );
+}
+
+CustomToolBarImportHelper::CustomToolBarImportHelper( const uno::Reference< frame::XModel >& rxModel,  const css::uno::Reference< css::ui::XUIConfigurationManager>& rxAppCfgMgr )
+{
+    m_xCfgSupp.set( rxModel, uno::UNO_QUERY_THROW );
+    m_xAppCfgMgr.set( rxAppCfgMgr, uno::UNO_QUERY_THROW );
+}
+
+uno::Reference< ui::XUIConfigurationManager > 
+CustomToolBarImportHelper::getCfgManager()
+{
+    return m_xCfgSupp->getUIConfigurationManager();
+}
+
+uno::Reference< ui::XUIConfigurationManager > 
+CustomToolBarImportHelper::getAppCfgManager()
+{
+    return m_xAppCfgMgr;
+}
+
+uno::Any 
+CustomToolBarImportHelper::createCommandFromMacro( const rtl::OUString& sCmd )
+{
+//"vnd.sun.star.script:Standard.Module1.Main?language=Basic&location=document"    
+    static rtl::OUString part1 = rtl::OUString::createFromAscii( "vnd.sun.star.script:Standard.");
+    static rtl::OUString part2 = rtl::OUString::createFromAscii("?language=Basic&location=document");
+    // create script url
+    rtl::OUString scriptURL = part1 + sCmd + part2;
+    return uno::makeAny( scriptURL );
+}
+
+rtl::OUString CustomToolBarImportHelper::MSOCommandToOOCommand( sal_Int16 msoCmd )
+{
+    rtl::OUString result;
+    if ( pMSOCmdConvertor.get() )
+        result = pMSOCmdConvertor->MSOCommandToOOCommand( msoCmd );
+    return result;
+}
+
+rtl::OUString CustomToolBarImportHelper::MSOTCIDToOOCommand( sal_Int16 msoTCID )
+{
+    rtl::OUString result;
+    if ( pMSOCmdConvertor.get() )
+        result = pMSOCmdConvertor->MSOTCIDToOOCommand( msoTCID );
+    return result;
+}
+
+void
+TBBase::indent_printf( FILE* fp, const char* format, ... )
+{
+   va_list ap;
+   va_start ( ap, format );
+
+   // indent nIndent spaces
+   for ( int i=0; i<nIndent; ++i)
+      fprintf(fp," ");
+   // append the rest of the message
+   vfprintf( fp, format, ap );
+   va_end( ap );
+}
+
+rtl::OUString TBBase::readUnicodeString( SvStream* pS, sal_Int32 nChars )
+{
+    rtl::OUStringBuffer buf(40);
+    for ( sal_Int32 index = 0; index < nChars; ++index )
+    {
+        sal_uInt16 ch = 0;
+        *pS >> ch;
+        sal_Unicode uni = static_cast< sal_Unicode >( ch );
+        buf.append( &uni, 1 );
+    }
+    return buf.makeStringAndClear();
+}
+
+TBCHeader::TBCHeader() : bSignature( 0x3 )
+,bVersion( 0x01 )
+,bFlagsTCR( 0 )
+,tct(0x1) // default to Button
+,tcid(0)
+,tbct(0)
+{
+}
+
+
+TBCHeader::~TBCHeader()
+{
+}
+
+bool TBCHeader::Read( SvStream* pS )
+{
+    OSL_TRACE("TBCHeader::Read() stream pos 0x%x", pS->Tell() );
+    nOffSet = pS->Tell();
+    *pS >> bSignature >> bVersion >> bFlagsTCR >> tct >> tcid >> tbct >> bPriority;
+    //  bit 4 ( from lsb ) 
+    if ( bFlagsTCR & 0x10 )
+    {
+        width.reset( new sal_uInt16 );
+        height.reset( new sal_uInt16 );
+        *pS >> *width >> *height;
+    }
+    return true;
+}
+
+void TBCHeader::Print( FILE* fp )
+{
+    Indent a;
+    indent_printf(fp,"[ 0x%x ] TBCHeader -- dump\n", nOffSet );
+    indent_printf(fp,"  bSignature 0x%xn", bSignature );
+    indent_printf(fp,"  bVersion 0x%x\n", bVersion );
+    indent_printf(fp,"  bFlagsTCR 0x%x\n", bFlagsTCR );
+    indent_printf(fp,"  tct 0x%x\n", tct );
+    indent_printf(fp,"  tcid 0x%x\n", tcid );
+    indent_printf(fp,"  tbct 0x%x\n", static_cast< unsigned int >( tbct ));
+    indent_printf(fp,"  bPriority 0x%x\n", bPriority );
+    if ( width.get() )
+        indent_printf(fp,"  width 0x%d(0x%x)\n", *width, *width);
+    if ( height.get() )
+        indent_printf(fp,"  height 0x%d(0x%x)\n", *height, *height);
+}
+
+TBCData::TBCData( const TBCHeader& Header ) : rHeader( Header )
+{
+}
+
+bool TBCData::Read(SvStream *pS)
+{
+    OSL_TRACE("TBCData::Read() stream pos 0x%x", pS->Tell() );
+    nOffSet = pS->Tell();
+    if ( !controlGeneralInfo.Read(pS) /*|| !controlSpecificInfo.Read(pS)*/ )
+        return false;
+    switch ( rHeader.getTct() )
+    {
+        case 0x01: // (Button control)
+        case 0x10: // (ExpandingGrid control)
+            controlSpecificInfo.reset( new TBCBSpecific() );
+            break;
+        case 0x0A: // (Popup control)
+        case 0x0C: // (ButtonPopup control)
+        case 0x0D: // (SplitButtonPopup control)
+        case 0x0E: // (SplitButtonMRUPopup control)
+            controlSpecificInfo.reset( new TBCMenuSpecific() );
+            break;
+        case 0x02: // (Edit control)
+        case 0x04: // (ComboBox control)
+        case 0x14: // (GraphicCombo control)
+        case 0x03: // (DropDown control)
+        case 0x06: // (SplitDropDown control)
+        case 0x09: // (GraphicDropDown control)
+            controlSpecificInfo.reset( new TBCComboDropdownSpecific( rHeader ) );
+            break;
+        default:
+            break;
+    }
+    if ( controlSpecificInfo.get() )
+        return controlSpecificInfo->Read( pS );
+    return true;
+
+    OSL_TRACE("#FIXME I need to be able to handle different controlSpecificInfo types.");
+    return false;
+}
+
+bool TBCData::ImportToolBarControl( const css::uno::Reference< css::container::XIndexContainer >& /*toolbarcontainer*/, CustomToolBarImportHelper& helper, std::vector< css::beans::PropertyValue >& props )
+{
+    controlGeneralInfo.ImportToolBarControlData( props );
+    beans::PropertyValue aProp;
+    aProp.Name = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Visible") ) ;
+    aProp.Value = uno::makeAny( rHeader.isVisible() ); // where is the visible attribute stored
+
+    if ( rHeader.getTct() == 0x01
+    || rHeader.getTct() == 0x10 )
+    {
+        TBCBSpecific* pSpecificInfo = dynamic_cast< TBCBSpecific* >( controlSpecificInfo.get() );
+        if ( pSpecificInfo )
+        {
+            // if we have a icon then lets  set it for the command ( but I
+            // have a nasty suspicion the toolbar actually needs to be set
+            // up ( and added ) before you can asssign an image :-/
+            rtl::OUString sCommand;
+            for ( std::vector< css::beans::PropertyValue >::iterator it = props.begin(); it != props.end(); ++it )
+            {
+                if ( it->Name.equals( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("CommandURL") ) ) )
+                    it->Value >>= sCommand;
+            }
+            if ( TBCBitMap* pIcon = pSpecificInfo->getIcon() )
+            {
+           
+                BitmapEx aBitEx( pIcon->getBitMap() );
+                if ( pSpecificInfo->getIconMask() )
+                     // according to the spec:
+                     // "the iconMask is white in all the areas in which the icon is
+                     // displayed as transparent and is black in all other areas."
+                     aBitEx = BitmapEx( aBitEx.GetBitmap(), pSpecificInfo->getIconMask()->getBitMap().CreateMask( Color( COL_WHITE ) ) );
+
+                Graphic aGraphic( aBitEx );
+                helper.addIcon( aGraphic.GetXGraphic(), sCommand );
+            }
+            else if ( pSpecificInfo->getBtnFace() )
+            {
+               
+                rtl::OUString sBuiltInCmd = helper.MSOTCIDToOOCommand(  *pSpecificInfo->getBtnFace() );
+                if ( sBuiltInCmd.getLength() )
+                {
+                    uno::Sequence< rtl::OUString> sCmds(1);
+                    sCmds[ 0 ] = sBuiltInCmd;
+                    uno::Reference< ui::XImageManager > xImageManager( helper.getAppCfgManager()->getImageManager(), uno::UNO_QUERY_THROW );
+                    // 0 = default image size
+                    uno::Sequence< uno::Reference< graphic::XGraphic > > sImages = xImageManager->getImages( 0, sCmds );
+                    if ( sImages.getLength() && sImages[0].is() )
+                        helper.addIcon( sImages[0], sCommand );
+                }
+            }
+        }
+    }
+    return true; // just ignore
+}
+
+void TBCData::Print( FILE* fp )
+{
+    Indent a;
+    indent_printf(fp,"[ 0x%x ] TBCData -- dump\n", nOffSet );
+    indent_printf(fp,"  dumping controlGeneralInfo( TBCGeneralInfo )\n");
+    controlGeneralInfo.Print( fp );
+    if ( rHeader.getTct() == 1 )
+    {
+        indent_printf(fp,"  dumping controlSpecificInfo( TBCBSpecificInfo )\n");
+        controlSpecificInfo->Print( fp );
+    }
+}
+
+bool
+WString::Read( SvStream *pS )
+{
+    OSL_TRACE("WString::Read() stream pos 0x%x", pS->Tell() );
+    nOffSet = pS->Tell();
+    sal_Int8 nChars = 0;
+    *pS >> nChars;
+    sString = readUnicodeString( pS, static_cast< sal_Int32 >( nChars  ) );
+    return true;
+}
+
+TBCExtraInfo::TBCExtraInfo() : idHelpContext( 0 )
+{
+}
+
+bool
+TBCExtraInfo::Read( SvStream *pS )
+{
+    OSL_TRACE("TBCExtraInfo::Read() stream pos 0x%x", pS->Tell() );
+    nOffSet = pS->Tell();
+    if( !wstrHelpFile.Read( pS )  )
+        return false;
+
+    *pS >> idHelpContext;
+
+    if ( !wstrTag.Read( pS ) || !wstrOnAction.Read( pS ) || !wstrParam.Read( pS ) )
+        return false;
+
+    *pS >> tbcu >> tbmg;    
+    return true;
+}
+
+void
+TBCExtraInfo::Print( FILE* fp )
+{
+    Indent a;
+    indent_printf( fp, "[ 0x%x ] TBCExtraInfo -- dump\n", nOffSet );
+    indent_printf( fp, "  wstrHelpFile %s\n", 
+        rtl::OUStringToOString( wstrHelpFile.getString(), RTL_TEXTENCODING_UTF8 ).getStr() );
+    indent_printf( fp, "  idHelpContext 0x%x\n", static_cast< unsigned int >( idHelpContext ) );
+    indent_printf( fp, "  wstrTag %s\n", 
+        rtl::OUStringToOString( wstrTag.getString(), RTL_TEXTENCODING_UTF8 ).getStr() );
+    indent_printf( fp, "  wstrOnAction %s\n", 
+        rtl::OUStringToOString( wstrOnAction.getString(), RTL_TEXTENCODING_UTF8 ).getStr() );
+    indent_printf( fp, "  wstrParam %s\n", 
+        rtl::OUStringToOString( wstrParam.getString(), RTL_TEXTENCODING_UTF8 ).getStr() );
+    indent_printf( fp, "  tbcu 0x%x\n", tbcu );
+    indent_printf( fp, "  tbmg 0x%x\n", tbmg );
+    
+}
+
+rtl::OUString
+TBCExtraInfo::getOnAction()
+{
+    return wstrOnAction.getString();
+}
+
+TBCGeneralInfo::TBCGeneralInfo() : bFlags( 0 )
+{
+}
+
+bool TBCGeneralInfo::Read( SvStream *pS )
+{
+    OSL_TRACE("TBCGeneralInfo::Read() stream pos 0x%x", pS->Tell() );
+    nOffSet = pS->Tell();
+    *pS >> bFlags;
+
+    if ( ( bFlags & 0x1 ) && !customText.Read( pS ) )
+        return false;
+    if ( ( bFlags & 0x2 ) && ( !descriptionText.Read( pS ) ||  !tooltip.Read( pS ) ) )
+        return false;
+    if ( ( bFlags & 0x4 ) && !extraInfo.Read( pS ) )
+        return false;
+    return true;
+}
+
+void 
+TBCGeneralInfo::Print( FILE* fp )
+{
+    Indent a;
+    indent_printf( fp, "[ 0x%x ] TBCGeneralInfo -- dump\n", nOffSet );
+    indent_printf( fp, "  bFlags 0x%x\n", bFlags );
+    indent_printf( fp, "  customText %s\n", 
+        rtl::OUStringToOString( customText.getString(), RTL_TEXTENCODING_UTF8 ).getStr() );
+    indent_printf( fp, "  description %s\n", 
+        rtl::OUStringToOString( descriptionText.getString(), RTL_TEXTENCODING_UTF8 ).getStr() );
+    indent_printf( fp, "  tooltip %s\n", 
+        rtl::OUStringToOString( tooltip.getString(), RTL_TEXTENCODING_UTF8 ).getStr() );
+    if ( bFlags & 0x4 ) 
+        extraInfo.Print( fp );
+}
+
+bool 
+TBCGeneralInfo::ImportToolBarControlData( std::vector< beans::PropertyValue >& sControlData )
+{
+    if ( ( bFlags & 0x5 ) )
+    {
+        beans::PropertyValue aProp;
+        // probably access to the header would be a better test than seeing if there is an action, e.g.
+        // if ( rHeader.getTct() == 0x01 && rHeader.getTcID() == 0x01 ) // not defined, probably this is a command
+        if ( extraInfo.getOnAction().getLength() )
+        {
+            aProp.Name = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("CommandURL") );
+            aProp.Value = CustomToolBarImportHelper::createCommandFromMacro( extraInfo.getOnAction() );
+            sControlData.push_back( aProp );
+        }
+
+        aProp.Name = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Label") );
+        aProp.Value = uno::makeAny( customText.getString() );
+        sControlData.push_back( aProp );
+
+        aProp.Name = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Type") );
+        aProp.Value = uno::makeAny( ui::ItemType::DEFAULT ); 
+        sControlData.push_back( aProp );
+
+        aProp.Name = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("HelpURL") );
+        aProp.Value = uno::makeAny( CustomToolBarImportHelper::createCommandFromMacro( tooltip.getString() ) ); 
+        sControlData.push_back( aProp );
+
+        // #TODO find out what is the property for tooltip?
+        sControlData.push_back( aProp );
+/*
+aToolbarItem(0).Name = "CommandURL" wstrOnAction
+aToolbarItem(0).Value = Command
+aToolbarItem(1).Name = "Label"      customText
+aToolbarItem(1).Value = Label
+aToolbarItem(2).Name = "Type"
+aToolbarItem(2).Value = 0
+aToolbarItem(3).Name = "Visible"
+aToolbarItem(3).Value = true        
+*/
+    }
+    return true;
+}
+
+TBCMenuSpecific::TBCMenuSpecific() : tbid( 0 )
+{
+}
+
+bool
+TBCMenuSpecific::Read( SvStream *pS)
+{
+    OSL_TRACE("TBCMenuSpecific::Read() stream pos 0x%x", pS->Tell() );
+    nOffSet = pS->Tell();
+    *pS >> tbid;
+    if ( tbid == 1 ) 
+    {
+        name.reset( new WString() );
+        return name->Read( pS );
+    }
+    return true;
+}
+
+void 
+TBCMenuSpecific::Print( FILE* fp )
+{
+    Indent a;
+    indent_printf( fp, "[ 0x%x ] TBCMenuSpecific -- dump\n", nOffSet );
+    indent_printf( fp, "  tbid 0x%x\n", static_cast< unsigned int >( tbid ) );
+    if ( tbid == 1 )
+        indent_printf( fp, "  name %s", rtl::OUStringToOString( name->getString(), RTL_TEXTENCODING_UTF8 ).getStr() );
+
+}
+
+TBCBSpecific::TBCBSpecific() : bFlags( 0 )
+{
+}
+
+bool TBCBSpecific::Read( SvStream *pS)
+{
+    OSL_TRACE("TBCBSpecific::Read() stream pos 0x%x", pS->Tell() );
+    nOffSet = pS->Tell();
+    *pS >> bFlags;
+
+    // bFlags determines what we read next
+
+    // bFlags.fCustomBitmap = 1 ( 0x8 ) set 
+    if ( bFlags & 0x8 )
+    {
+        icon.reset( new TBCBitMap() );
+        iconMask.reset( new TBCBitMap() );
+        if ( !icon->Read( pS ) || !iconMask->Read( pS ) )
+            return false;
+    }
+    // if bFlags.fCustomBtnFace = 1 ( 0x10 )
+    if ( bFlags & 0x10 )
+    {
+        iBtnFace.reset( new sal_uInt16 );
+        *pS >> *iBtnFace.get();
+    }
+    // if bFlags.fAccelerator equals 1 ( 0x04 )
+    if ( bFlags & 0x04 )
+    {
+        wstrAcc.reset( new WString() );
+        return wstrAcc->Read( pS );
+    }
+    return true;
+}
+
+
+void TBCBSpecific::Print( FILE* fp )
+{
+    Indent a;
+    indent_printf( fp, "[ 0x%x ] TBCBSpecific -- dump\n", nOffSet );
+    indent_printf( fp, "  bFlags 0x%x\n", bFlags );
+    bool bResult = ( icon.get() != NULL );
+    indent_printf( fp, "  icon present? %s\n", bResult ? "true" : "false" );
+    if ( bResult )
+    {
+        Indent b;
+        indent_printf( fp, "  icon: \n");
+        icon->Print( fp ); // will dump size
+    }
+    bResult = ( iconMask.get() != NULL );
+    indent_printf( fp, "  icon mask present? %s\n", bResult ? "true" : "false" );
+    if ( bResult )
+    {
+        Indent c;
+        indent_printf( fp, "  icon mask: \n");
+        iconMask->Print( fp ); // will dump size
+    }
+    if ( iBtnFace.get() )
+    {
+        indent_printf( fp, "  iBtnFace 0x%x\n", *(iBtnFace.get()) );
+    }
+    bResult = ( wstrAcc.get() != NULL );
+    indent_printf( fp, "  option string present? %s ->%s<-\n", bResult ? "true" : "false", bResult ? rtl::OUStringToOString( wstrAcc->getString(), RTL_TEXTENCODING_UTF8 ).getStr() : "N/A" );
+}
+
+TBCBitMap* 
+TBCBSpecific::getIcon()
+{
+    return icon.get();
+}
+
+TBCBitMap* 
+TBCBSpecific::getIconMask()
+{
+    return iconMask.get();
+}
+
+TBCComboDropdownSpecific::TBCComboDropdownSpecific(const TBCHeader& header ) 
+{
+    if ( header.getTcID() == 0x01 )
+        data.reset( new TBCCDData() );
+}
+
+bool TBCComboDropdownSpecific::Read( SvStream *pS)
+{
+    nOffSet = pS->Tell();
+    if ( data.get() )
+        return data->Read( pS );
+    return true;
+}
+
+void TBCComboDropdownSpecific::Print( FILE* fp)
+{
+    Indent a;
+    indent_printf(fp,"[ 0x%x ] TBCComboDropdownSpecific -- dump\n", nOffSet );
+    if ( data.get() )
+        data->Print( fp );
+    else
+        indent_printf(fp," no data " );
+}
+
+TBCCDData::TBCCDData() : cwstrItems( 0 )
+,iSel( 0 )
+,cLines( 0 )
+,dxWidth( 0 )
+{
+}
+
+TBCCDData::~TBCCDData()
+{
+}
+
+bool TBCCDData::Read( SvStream *pS)
+{
+    nOffSet = pS->Tell();
+    *pS >> cwstrItems;
+    if ( cwstrItems )
+    {
+        for( sal_Int32 index=0; index < cwstrItems; ++index )
+        {
+            WString aString;
+            if ( !aString.Read( pS ) )
+                return false;
+            wstrList.push_back( aString );
+        } 
+    }
+    *pS >> cwstrMRU >> iSel >> cLines >> dxWidth;
+
+    return wstrEdit.Read( pS );
+}
+
+void TBCCDData::Print( FILE* fp)
+{
+    Indent a;
+    indent_printf(fp,"[ 0x%x ] TBCCDData -- dump\n", nOffSet );
+    indent_printf(fp,"  cwstrItems items in wstrList 0x%d\n", cwstrItems);
+    for ( sal_Int32 index=0; index < cwstrItems; ++index )
+    {
+        Indent b;
+        indent_printf(fp, "  wstrList[%d] %s", static_cast< int >( index ), rtl::OUStringToOString( wstrList[index].getString(), RTL_TEXTENCODING_UTF8 ).getStr() );
+    }
+    indent_printf(fp,"  cwstrMRU num most recently used string 0x%d item\n", cwstrMRU);
+    indent_printf(fp,"  iSel index of selected item 0x%d item\n", iSel);
+    indent_printf(fp,"  cLines num of suggested lines to display 0x%d", cLines);
+    indent_printf(fp,"  dxWidth width in pixels 0x%d", dxWidth);
+    indent_printf(fp,"  wstrEdit %s", rtl::OUStringToOString( wstrEdit.getString(), RTL_TEXTENCODING_UTF8 ).getStr() );
+}
+
+TBCBitMap::TBCBitMap() : cbDIB( 0 ), size( 0 )
+{
+}
+
+TBCBitMap::~TBCBitMap()
+{
+}
+
+// #FIXME Const-ness
+Bitmap& 
+TBCBitMap::getBitMap()
+{
+    return mBitMap;
+}
+
+bool TBCBitMap::Read( SvStream* pS)
+{
+    OSL_TRACE("TBCBitMap::Read() stream pos 0x%x", pS->Tell() );
+    nOffSet = pS->Tell();
+    *pS >> cbDIB;
+    // cbDIB = sizeOf(biHeader) + sizeOf(colors) + sizeOf(bitmapData) + 10
+    return mBitMap.Read( *pS, FALSE );
+}
+
+void TBCBitMap::Print( FILE* fp )
+{
+    Indent a;
+    indent_printf(fp, "[ 0x%x ] TBCBitMap -- dump\n", nOffSet );
+    indent_printf(fp, "  TBCBitMap size of bitmap data 0x%x\n", static_cast< unsigned int > ( cbDIB ) );
+}
diff --git sw/source/filter/ww8/makefile.mk sw/source/filter/ww8/makefile.mk
index 68f641d..324d18d 100644
--- sw/source/filter/ww8/makefile.mk
+++ sw/source/filter/ww8/makefile.mk
@@ -69,7 +69,8 @@ EXCEPTIONSFILES = \
 		$(SLO)$/writerwordglue.obj \
         $(SLO)$/ww8scan.obj \
         $(SLO)$/WW8TableInfo.obj \
-        $(SLO)$/WW8FFData.obj
+        $(SLO)$/WW8FFData.obj \
+        $(SLO)$/ww8toolbar.obj \
 
 
 SLOFILES =	\
@@ -96,7 +97,9 @@ SLOFILES =	\
 		$(SLO)$/writerhelper.obj \
 		$(SLO)$/writerwordglue.obj \
         $(SLO)$/WW8TableInfo.obj \
-        $(SLO)$/WW8FFData.obj
+        $(SLO)$/WW8FFData.obj \
+        $(SLO)$/ww8toolbar.obj \
+
 
 
 # --- Tagets -------------------------------------------------------
diff --git sw/source/filter/ww8/ww8par.cxx sw/source/filter/ww8/ww8par.cxx
index e1c2fe5..290ffda 100644
--- sw/source/filter/ww8/ww8par.cxx
+++ sw/source/filter/ww8/ww8par.cxx
@@ -132,7 +132,7 @@
 #include <svtools/itemiter.hxx>  //SfxItemIter
 
 #include <stdio.h>
-
+#include "ww8toolbar.hxx"
 #ifdef DEBUG
 #include <iostream>
 #include <dbgoutsw.hxx>
@@ -3988,6 +3988,21 @@ ULONG SwWW8ImplReader::CoreLoad(WW8Glossary *pGloss, const SwPosition &rPos)
             eMode |= nsRedlineMode_t::REDLINE_SHOW_DELETE;
         if (pStg && !pGloss) /*meaningless for a glossary, cmc*/
         {
+            // Read custom toolbars 
+            if ( pWwFib->lcbCmds )
+            {
+                // there is a tgc255 structure
+                long nCur = pTableStream->Tell();
+                Tcg aTCG;
+                pTableStream->Seek( pWwFib->fcCmds ); // point at tgc record
+                if (!aTCG.Read( pTableStream ) )
+                    OSL_TRACE("** Read of Customization data failed!!!! ");
+                pTableStream->Seek( nCur ); // return to previous position, is that necessary?
+#if DEBUG
+                aTCG.Print( stderr );
+#endif
+                aTCG.ImportCustomToolBar( mpDocShell->GetModel() );
+            }
             const SvtFilterOptions* pVBAFlags = SvtFilterOptions::Get();
             maTracer.EnterEnvironment(sw::log::eMacros);
             SvxImportMSVBasic aVBasic(*mpDocShell, *pStg,
diff --git sw/source/filter/ww8/ww8toolbar.cxx sw/source/filter/ww8/ww8toolbar.cxx
new file mode 100644
index 0000000..ac10d7a
--- /dev/null
+++ sw/source/filter/ww8/ww8toolbar.cxx
@@ -0,0 +1,1050 @@
+#include "ww8toolbar.hxx"
+#include <rtl/ustrbuf.hxx>
+#include <stdarg.h>
+#include <com/sun/star/ui/XUIConfigurationPersistence.hpp>
+#include <com/sun/star/ui/XUIConfigurationPersistence.hpp>
+#include <com/sun/star/ui/XModuleUIConfigurationManagerSupplier.hpp>
+#include <com/sun/star/lang/XMultiServiceFactory.hpp>
+#include <com/sun/star/ui/XImageManager.hpp>
+#include <com/sun/star/ui/ItemType.hpp>
+#include <fstream>
+#include <comphelper/processfactory.hxx>
+#include <vcl/graph.hxx>
+#include <map>
+using namespace com::sun::star;
+
+typedef std::map< sal_Int16, rtl::OUString > IdToString;
+
+class MSOWordCommandConvertor : public MSOCommandConvertor
+{
+   IdToString msoToOOcmd;
+   IdToString tcidToOOcmd;
+public:
+    MSOWordCommandConvertor();
+    virtual rtl::OUString MSOCommandToOOCommand( sal_Int16 msoCmd );
+    virtual rtl::OUString MSOTCIDToOOCommand( sal_Int16 key );
+};
+
+MSOWordCommandConvertor::MSOWordCommandConvertor()
+{
+    // mso command id to ooo command string
+    // #FIXME and *HUNDREDS* of id's to added here
+    msoToOOcmd[ 0x20b ] = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM(".uno:CloseDoc") );
+    msoToOOcmd[ 0x50 ] = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM(".uno:Open") );
+
+   // mso tcid to ooo command string
+    // #FIXME and *HUNDREDS* of id's to added here
+   tcidToOOcmd[ 0x9d9 ] = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM(".uno:Print") );
+}
+
+rtl::OUString MSOWordCommandConvertor::MSOCommandToOOCommand( sal_Int16 key )
+{
+    rtl::OUString sResult;
+    IdToString::iterator it = msoToOOcmd.find( key );
+    if ( it != msoToOOcmd.end() )
+        sResult = it->second;
+    return sResult;
+}
+
+rtl::OUString MSOWordCommandConvertor::MSOTCIDToOOCommand( sal_Int16 key )
+{
+    rtl::OUString sResult;
+    IdToString::iterator it = tcidToOOcmd.find( key );
+    if ( it != tcidToOOcmd.end() )
+        sResult = it->second;
+    return sResult;
+}
+
+
+CTBWrapper::CTBWrapper( bool bReadId ) : Tcg255SubStruct( bReadId )
+,reserved2(0)
+,reserved3(0)
+,reserved4(0)
+,reserved5(0)
+,cbTBD(0)
+,cCust(0)
+,cbDTBC(0)
+,rtbdc(0)
+{
+}
+
+CTBWrapper::~CTBWrapper()
+{
+}
+
+bool CTBWrapper::Read( SvStream* pS )
+{
+    OSL_TRACE("CTBWrapper::Read() stream pos 0x%x", pS->Tell() );
+    nOffSet = pS->Tell();
+    Tcg255SubStruct::Read( pS );
+    *pS >> reserved2 >> reserved3 >> reserved4 >> reserved5;
+    *pS >> cbTBD >> cCust >> cbDTBC;
+    if ( cbDTBC )
+    {
+        // cbDTBC is the size in bytes of the TBC array
+        // but the size of a TBC element is dynamic ( and this relates to TBDelta's
+        // which we don't read right now )
+        //pS->SeekRel( cbDTBC );
+        int nStart = pS->Tell();
+
+        int bytesRead = 0;
+        int bytesToRead = cbDTBC - bytesRead; 
+        // cbDTBC specifies the size ( in bytes ) taken by an array ( of unspecified size )
+        // of TBC records ( TBC records have dynamic length, so we need to check our position
+        // after each read )
+        do
+        {
+            TBC aTBC;
+            if ( !aTBC.Read( pS ) )
+                return false;
+            rtbdc.push_back( aTBC );
+            bytesToRead = cbDTBC - ( pS->Tell() - nStart ); 
+        } while ( bytesToRead > 0 );
+    }
+    if ( cCust )
+    {
+        for ( sal_Int32 index = 0; index < cCust; ++index )
+        {
+            Customization aCust;
+            if ( !aCust.Read( pS ) )
+                return false;
+            rCustomizations.push_back( aCust );
+        } 
+    } 
+    return true;
+}
+
+void CTBWrapper::Print( FILE* fp )
+{
+    Indent a;
+    indent_printf(fp,"[ 0x%x ] CTBWrapper - dump\n", nOffSet );
+    bool bRes = ( ch == 0x12 && reserved2 == 0x0 && reserved3 == 0x7 && reserved4 == 0x6 && reserved5 == 0xC );
+    if ( bRes )
+        indent_printf(fp,"  sanity check ( first 8 bytes conform )\n");
+    else 
+    {
+        indent_printf(fp,"    reserved1(0x%x)\n",ch);
+        indent_printf(fp,"    reserved2(0x%x)\n",reserved2);
+        indent_printf(fp,"    reserved3(0x%x)\n",reserved3);
+        indent_printf(fp,"    reserved4(0x%x)\n",reserved4);
+        indent_printf(fp,"    reserved5(0x%x)\n",reserved5);
+        indent_printf(fp,"Quiting dump");
+        return;
+    }
+    indent_printf(fp,"  size of TBDelta structures 0x%x\n", cbTBD );
+    indent_printf(fp,"  cCust: no. of cCust structures 0x%x\n",cCust);
+    indent_printf(fp,"  cbDTBC: no. of bytes in rtbdc array 0x%x\n", static_cast< unsigned int >( cbDTBC ));
+
+    sal_Int32 index = 0;
+
+    for ( std::vector< TBC >::iterator it = rtbdc.begin(); it != rtbdc.end(); ++it, ++index )
+    {
+        indent_printf(fp,"  Dumping rtbdc[%d]\n", static_cast< int >( index ));
+        Indent b;
+        it->Print( fp );
+    }
+
+    index = 0;
+
+    for ( std::vector< Customization >::iterator it = rCustomizations.begin(); it != rCustomizations.end(); ++it, ++index )
+    {
+        indent_printf(fp,"  Dumping custimization [%d]\n", static_cast< int >( index ));
+        Indent c;
+        it->Print(fp);
+    }
+}
+
+bool CTBWrapper::ImportCustomToolBar( const uno::Reference< css::frame::XModel >& rxModel )
+{
+    
+    for ( std::vector< Customization >::iterator it = rCustomizations.begin(); it != rCustomizations.end(); ++it )
+    {
+        uno::Reference< lang::XMultiServiceFactory > xMSF( ::comphelper::getProcessServiceFactory(), uno::UNO_QUERY_THROW );
+        uno::Reference< ui::XModuleUIConfigurationManagerSupplier > xAppCfgSupp( xMSF->createInstance( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "com.sun.star.ui.ModuleUIConfigurationManagerSupplier" ) ) ), uno::UNO_QUERY_THROW ); 
+        CustomToolBarImportHelper helper( rxModel, xAppCfgSupp->getUIConfigurationManager( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("com.sun.star.text.TextDocument" ) ) ) );
+        helper.setMSOCommandMap( new  MSOWordCommandConvertor() );
+        if ( !(*it).ImportCustomToolBar( helper ) )
+            return false;
+    }
+    return false;
+}
+
+Customization::Customization() : tbidForTBD( 0 )
+,reserved1( 0 )
+, ctbds( 0 )
+{
+}
+
+Customization::~Customization()
+{
+}
+
+bool Customization::Read( SvStream *pS)
+{
+    OSL_TRACE("Custimization::Read() stream pos 0x%x", pS->Tell() );
+    nOffSet = pS->Tell();
+    *pS >> tbidForTBD >> reserved1 >> ctbds;
+    if ( tbidForTBD && ctbds )
+    {
+        TBDelta aTBDelta;
+        for ( sal_Int32 index = 0; index < ctbds; ++index )
+        {
+            if (!aTBDelta.Read( pS ) )
+                return false;
+            customizationDataTBDelta.push_back( aTBDelta );
+        }
+    }
+    else
+    {
+        customizationDataCTB.reset( new CTB() );
+        if ( !customizationDataCTB->Read( pS ) )
+                return false;
+    }
+    return true;
+}
+
+void Customization::Print( FILE* fp )
+{
+    Indent a;
+    indent_printf( fp,"[ 0x%x ] Customization -- dump \n", nOffSet );
+    indent_printf( fp,"  tbidForTBD 0x%x ( should be 0 for CTBs )\n", static_cast< unsigned int >( tbidForTBD ));
+    indent_printf( fp,"  reserved1 0x%x \n", reserved1);
+    indent_printf( fp,"  ctbds - number of customisations %d(0x%x) \n", ctbds, ctbds );
+    if ( !tbidForTBD && !ctbds )
+        customizationDataCTB->Print( fp );
+    else
+    {
+        std::vector< TBDelta >::iterator it = customizationDataTBDelta.begin();
+        for ( sal_Int32 index = 0; index < ctbds; ++it,++index )
+            it->Print( fp );
+    }
+    
+}
+
+bool Customization::ImportCustomToolBar( CustomToolBarImportHelper& helper )
+{
+    if ( !customizationDataCTB.get() )
+        return false;
+    return customizationDataCTB->ImportCustomToolBar( helper );
+}
+
+TBDelta::TBDelta() : doprfatendFlags(0)
+,ibts(0)
+,cidNext(0)
+,cid(0)
+,fc(0)
+,cbTBC(0)
+{
+}
+
+bool TBDelta::Read(SvStream *pS)
+{
+    OSL_TRACE("TBDelta::Read() stream pos 0x%x", pS->Tell() );
+    nOffSet = pS->Tell();
+    *pS >> doprfatendFlags >> ibts >> cidNext >> cid >> fc ;
+    *pS >> CiTBDE >> cbTBC;
+    return true;
+}
+
+void TBDelta::Print( FILE* fp )
+{
+    // Like most of the debug output, it's raw and little ( no )
+    // interpretation of the data is output ( e.g. flag values etc. )
+    indent_printf( fp, "[ 0x%x ] TBDelta -- dump\n", nOffSet );
+    indent_printf( fp, " doprfatendFlags 0x%x\n",doprfatendFlags );
+    
+    indent_printf( fp, " ibts 0x%x\n",ibts );
+    indent_printf( fp, " cidNext 0x%x\n", static_cast< unsigned int >( cidNext ) );
+    indent_printf( fp, " cid 0x%x\n", static_cast< unsigned int >( cid ) );
+    indent_printf( fp, " fc 0x%x\n", static_cast< unsigned int >( fc ) );
+    indent_printf( fp, " CiTBDE 0x%x\n",CiTBDE );
+    indent_printf( fp, " cbTBC 0x%x\n", cbTBC );
+}
+
+CTB::CTB() : cbTBData( 0 )
+,iWCTBl( 0 )
+,reserved( 0 )
+,unused( 0 )
+,cCtls( 0 )
+{
+}
+
+CTB::~CTB()
+{
+}
+
+bool CTB::Read( SvStream *pS)
+{
+    OSL_TRACE("CTB::Read() stream pos 0x%x", pS->Tell() );
+    nOffSet = pS->Tell();
+    if ( !name.Read( pS ) )
+        return false;
+    *pS >> cbTBData;
+    // sal_Int32 nTBSize = cbTBData - sizeof(rVisualData) - 12;
+    if ( !tb.Read( pS ) )
+        return false;
+    pS->Read( &rVisualData, sizeof( rVisualData ) );
+
+    *pS >> iWCTBl >> reserved >> unused >> cCtls;
+    
+    if ( cCtls )
+    {
+        for ( sal_Int32 index = 0; index < cCtls; ++index )
+        {
+            TBC aTBC;
+            if ( !aTBC.Read( pS ) )
+                return false;
+            rTBC.push_back( aTBC );
+        }
+    }
+    return true;
+}
+
+void
+CTB::Print( FILE* fp )
+{
+    Indent a;
+    indent_printf(fp, "[ 0x%x ] CTB - dump\n", nOffSet );
+    indent_printf(fp, "  name %s\n", rtl::OUStringToOString( name.getString(), RTL_TEXTENCODING_UTF8 ).getStr() );
+    indent_printf(fp, "  cbTBData size, in bytes, of this structure excluding the name, cCtls, and rTBC fields.  %x\n", static_cast< unsigned int >( cbTBData ) );
+    
+    tb.Print(fp);
+    indent_printf(fp, "  iWCTBl 0x%x reserved 0x%x unused 0x%x cCtls( toolbar controls ) 0x%x \n", static_cast< unsigned int >( iWCTBl ), reserved, unused, static_cast< unsigned int >( cCtls ) );
+    if ( cCtls )
+    {
+        for ( sal_Int32 index = 0; index < cCtls; ++index )
+        {
+        
+            indent_printf(fp, "  dumping toolbar control 0x%x\n", static_cast< unsigned int >( index ) );
+            rTBC[ index ].Print( fp );
+        }
+    }
+}
+
+bool CTB::ImportCustomToolBar( CustomToolBarImportHelper& helper )
+{
+    static rtl::OUString sToolbarPrefix( RTL_CONSTASCII_USTRINGPARAM( "private:resource/toolbar/custom_" ) );
+    
+    // Create default setting
+    uno::Reference< container::XIndexContainer > xIndexContainer( helper.getCfgManager()->createSettings(), uno::UNO_QUERY_THROW );
+    uno::Reference< container::XIndexAccess > xIndexAccess( xIndexContainer, uno::UNO_QUERY_THROW );
+    uno::Reference< beans::XPropertySet > xProps( xIndexContainer, uno::UNO_QUERY_THROW ); 
+
+    // set UI name for toolbar
+    xProps->setPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("UIName") ), uno::makeAny( name.getString() ) ); 
+
+    rtl::OUString sToolBarName = sToolbarPrefix.concat( name.getString() );
+
+    for ( std::vector< TBC >::iterator it =  rTBC.begin(); it != rTBC.end(); ++it )
+    {
+        // createToolBar item for control
+        if ( !it->ImportToolBarControl( xIndexContainer, helper ) )
+            return false;
+    }
+
+    OSL_TRACE("Name of toolbar :-/ %s", rtl::OUStringToOString( sToolBarName, RTL_TEXTENCODING_UTF8 ).getStr() );
+
+    helper.getCfgManager()->insertSettings( sToolBarName, xIndexAccess );
+    helper.applyIcons();
+
+    uno::Reference< ui::XUIConfigurationPersistence > xPersistence( helper.getCfgManager()->getImageManager(), uno::UNO_QUERY_THROW );
+    xPersistence->store();
+
+    xPersistence.set( helper.getCfgManager(), uno::UNO_QUERY_THROW );
+    xPersistence->store();
+    
+    return true;
+}
+
+TB::TB() : bSignature( 0 )
+,bVersion( 0 )
+,cCL( 0 )
+,ltbid( 0 )
+,ltbtr( 0 )
+,cRowsDefault( 0 )
+,bFlags( 0 )
+{
+}
+
+bool TB::Read( SvStream* pS )
+{
+    OSL_TRACE("TB::Read() stream pos 0x%x", pS->Tell() );
+    nOffSet = pS->Tell();
+    *pS >> bSignature >> bVersion >> cCL >> ltbid >> ltbtr >> cRowsDefault >> bFlags;
+    return name.Read( pS );
+}
+
+void TB::Print( FILE* fp )
+{
+    Indent a;
+    indent_printf( fp, "[ 0x%x ] TB -- dump\n", nOffSet );
+    indent_printf( fp, "  bSignature (0x%x), bVersion(0x%x), cCL(0x%x), ltbid(0x%x), cRowsDefault (0x%x), ltbtr(0x%x), bFlags(0x%x)\n", bSignature, bVersion, cCL, static_cast< unsigned int >( ltbid ), static_cast< unsigned int >( ltbtr ), cRowsDefault, bFlags );
+    indent_printf( fp, "  name %s\n", rtl::OUStringToOString( name.getString(), RTL_TEXTENCODING_UTF8 ).getStr() );
+
+}
+
+TBC::TBC()
+{
+}
+
+TBC::~TBC()
+{
+}
+
+bool TBC::Read( SvStream *pS )
+{
+    OSL_TRACE("TBC::Read() stream pos 0x%x", pS->Tell() );
+    nOffSet = pS->Tell();
+    if ( !tbch.Read( pS ) )
+        return false;
+    if ( tbch.getTcID() != 0x1 && tbch.getTcID() != 0x1051 )
+    {
+        cid.reset( new sal_uInt32 );
+        *pS >> *cid;
+    }
+    // MUST exist if tbch.tct is not equal to 0x16
+    if ( tbch.getTct() != 0x16 )
+    {
+        tbcd.reset(  new TBCData( tbch ) );
+        if ( !tbcd->Read( pS ) )
+            return false;
+    }
+    return true;
+}
+
+void TBC::Print( FILE* fp )
+{
+    Indent a;
+    indent_printf(fp,"[ 0x%x ] TBC -- dump\n", nOffSet );
+    indent_printf(fp,"  dumping header ( TBCHeader )\n");
+    tbch.Print( fp );
+    if ( cid.get() )
+        indent_printf(fp,"  cid = 0x%x\n", static_cast< unsigned int >( *cid ) );
+    if ( tbcd.get() )
+    {
+        indent_printf(fp,"  dumping toolbar data TBCData \n");
+        tbcd->Print(fp);
+    }
+}
+
+bool
+TBC::ImportToolBarControl( const css::uno::Reference< css::container::XIndexContainer >& toolbarcontainer, CustomToolBarImportHelper& helper )
+{
+    // cmtFci       0x1 Command based on a built-in command. See CidFci.
+    // cmtMacro     0x2 Macro command. See CidMacro.
+    // cmtAllocated 0x3 Allocated command. See CidAllocated.
+    // cmtNil       0x7 No command. See Cid.
+    bool bBuiltin = false;
+    sal_uInt16 cmdId = 0;
+    if  ( cid.get() )
+    {
+        sal_uInt16 arg2 = ( *( cid.get() ) & 0xFFFF );
+
+        sal_uInt8 cmt = ( arg2 & 0x7 );
+        arg2 = ( arg2 >> 3 );
+
+        switch ( cmt )
+        {
+            case 1:
+                OSL_TRACE("cmt is cmtFci builtin command 0x%x", arg2);
+                bBuiltin = true;
+                cmdId = arg2;
+                break;
+            case 2:
+                OSL_TRACE("cmt is cmtMacro macro 0x%x", arg2);
+                break;
+            case 3:
+                OSL_TRACE("cmt is cmtAllocated [???] 0x%x", arg2);
+                break;
+            case 7:
+                OSL_TRACE("cmt is cmNill no-phing 0x%x", arg2);
+                break;
+            default:
+                OSL_TRACE("illegal 0x%x", cmt);
+                break;
+        }
+    }
+
+    if ( tbcd.get() )
+    {
+        std::vector< css::beans::PropertyValue > props;
+        if ( bBuiltin )
+        {
+            rtl::OUString sCommand = helper.MSOCommandToOOCommand( cmdId );
+            if ( sCommand.getLength() > 0 )
+            {
+                beans::PropertyValue aProp;
+ 
+                aProp.Name = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("CommandURL") );
+                aProp.Value <<= sCommand;
+                props.push_back( aProp ); 
+            }
+         
+        }
+        if ( ! tbcd->ImportToolBarControl( toolbarcontainer, helper, props ) )
+            return false;
+
+
+        uno::Sequence< beans::PropertyValue > sProps( props.size() );
+        beans::PropertyValue* pProp = sProps.getArray();
+   
+        for ( std::vector< css::beans::PropertyValue >::iterator it = props.begin(); it != props.end(); ++it, ++pProp )
+            *pProp = *it;
+
+        toolbarcontainer->insertByIndex( toolbarcontainer->getCount(), uno::makeAny( sProps ) );        
+    }
+    return true;
+}
+
+bool 
+Xst::Read( SvStream* pS )
+{
+    OSL_TRACE("Xst::Read() stream pos 0x%x", pS->Tell() );
+    nOffSet = pS->Tell();
+    sal_Int16 nChars = 0;
+    *pS >> nChars;
+    sString = readUnicodeString( pS, static_cast< sal_Int32 >( nChars  ) );
+    return true;
+}
+
+void
+Xst::Print( FILE* fp )
+{
+    Indent a;
+    indent_printf( fp, "[ 0x%x ] Xst -- dump\n", nOffSet );
+    indent_printf( fp, " %s",  rtl::OUStringToOString( sString, RTL_TEXTENCODING_UTF8 ).getStr() );
+}
+
+Tcg::Tcg() : nTcgVer( 255 )
+{
+}
+
+bool Tcg::Read(SvStream *pS)
+{
+    OSL_TRACE("Tcg::Read() stream pos 0x%x", pS->Tell() );
+    nOffSet = pS->Tell();
+    *pS >> nTcgVer;
+    if ( nTcgVer != (sal_Int8)255 )
+        return false;
+    tcg.reset( new Tcg255() );
+    return tcg->Read( pS );
+}
+
+void Tcg::Print( FILE* fp )
+{
+    Indent a(true);
+    indent_printf(fp, "[ 0x%x ] Tcg - dump %d\n", nOffSet, nTcgVer);
+    indent_printf(fp,"  nTcgVer %d\n", nTcgVer);
+    tcg->Print( fp );
+}
+
+bool Tcg::ImportCustomToolBar( const uno::Reference< frame::XModel >& rxModel )
+{
+    return tcg->ImportCustomToolBar( rxModel );
+}
+
+Tcg255::Tcg255()
+{
+}
+
+Tcg255::~Tcg255()
+{
+    std::vector< Tcg255SubStruct* >::iterator it = rgtcgData.begin();
+    for ( ; it != rgtcgData.end(); ++it )
+        delete *it;
+}
+
+bool Tcg255::processSubStruct( sal_uInt8 nId, SvStream *pS )
+{
+     Tcg255SubStruct* pSubStruct = NULL;
+     switch ( nId )
+     {
+         case 0x1:
+         {
+             pSubStruct = new PlfMcd( false ); // don't read the id
+             break;
+         }
+         case 0x2: 
+         {
+             pSubStruct = new PlfAcd( false );
+             break;
+         }
+         case 0x3: 
+         case 0x4: 
+         {
+             pSubStruct = new PlfKme( false );
+             break;
+         }
+         case 0x10: 
+         {
+             pSubStruct = new TcgSttbf( false );
+             break;
+         }
+         case 0x11: 
+         {
+             pSubStruct = new MacroNames( false );
+             break;
+         }
+         case 0x12: 
+         {
+             pSubStruct = new CTBWrapper( false );
+             break;
+         }
+         default:
+             OSL_TRACE("Unknown id 0x%x",nId);
+             return false;
+    }
+    pSubStruct->ch = nId;
+    if ( !pSubStruct->Read( pS ) )
+        return false;
+    rgtcgData.push_back( pSubStruct );
+    return true;
+}
+
+bool Tcg255::ImportCustomToolBar( const uno::Reference< css::frame::XModel >& rxModel )
+{
+    // Find the CTBWrapper
+    for ( std::vector< Tcg255SubStruct* >::const_iterator it = rgtcgData.begin(); it != rgtcgData.end(); ++it )
+    {
+        if ( (*it)->id() == 0x12 )
+        {
+            // not so great, shouldn't really have to do a horror casting    
+            CTBWrapper* pCTBWrapper =  dynamic_cast< CTBWrapper* > ( *it );
+            if ( pCTBWrapper )
+            {
+                if ( !pCTBWrapper->ImportCustomToolBar( rxModel ) )
+                    return false;
+            }
+        }
+    }
+    return true;
+}
+
+
+bool Tcg255::Read(SvStream *pS)
+{
+    OSL_TRACE("Tcg255::Read() stream pos 0x%x", pS->Tell() );
+    nOffSet = pS->Tell();
+    sal_uInt8 nId = 0; // 
+    *pS >> nId;
+    while (  nId != 0x40  )
+    {
+        if ( !processSubStruct( nId, pS ) )
+            return false;
+        *pS >> nId;
+    } 
+    return true;
+    // Peek at  
+}
+
+void Tcg255::Print( FILE* fp)
+{
+    Indent a;
+    indent_printf(fp, "[ 0x%x ] Tcg255 - dump\n", nOffSet );
+    indent_printf(fp, "  contains %d sub records\n", rgtcgData.size() );
+    std::vector< Tcg255SubStruct* >::iterator it = rgtcgData.begin(); 
+    std::vector< Tcg255SubStruct* >::iterator it_end = rgtcgData.end(); 
+    
+    for( sal_Int32 count = 1; it != it_end ; ++it, ++count )
+    {
+        Indent b;
+        indent_printf(fp, "  [%d] Tcg255SubStruct \n", static_cast< unsigned int >( count ) );
+        (*it)->Print(fp);
+    }
+}
+
+
+Tcg255SubStruct::Tcg255SubStruct( bool bReadId ) : mbReadId( bReadId ), ch(0)
+{
+}
+
+bool Tcg255SubStruct::Read(SvStream *pS)
+{
+    OSL_TRACE("Tcg255SubStruct::Read() stream pos 0x%x", pS->Tell() );
+    nOffSet = pS->Tell();
+    if ( mbReadId )
+        *pS >> ch;
+    return true;
+}
+
+PlfMcd::PlfMcd( bool bReadId ): Tcg255SubStruct( bReadId ), rgmcd( NULL )
+{
+}
+PlfMcd::~PlfMcd()
+{
+    if ( rgmcd )
+        delete[] rgmcd;
+}
+
+bool PlfMcd::Read(SvStream *pS)
+{
+    OSL_TRACE("PffMcd::Read() stream pos 0x%x", pS->Tell() );
+    nOffSet = pS->Tell();
+    Tcg255SubStruct::Read( pS );
+    *pS >> iMac;
+    if ( iMac )
+    { 
+        rgmcd = new MCD[ iMac ];
+        for ( sal_Int32 index = 0; index < iMac; ++index )
+        {
+            if ( !rgmcd[ index ].Read( pS ) )
+                return false; 
+        } 
+    }
+    return true;
+}
+
+void PlfMcd::Print( FILE* fp )
+{
+    Indent a;
+    indent_printf(fp, "[ 0x%x ] PlfMcd ( Tcg255SubStruct ) - dump\n", nOffSet );
+    indent_printf(fp, " contains %d MCD records\n", static_cast<int>( iMac ) );
+    for ( sal_Int32 count=0; count < iMac; ++count )
+    {
+        Indent b;
+        indent_printf(fp, "[%d] MCD\n", static_cast< int >( count ) );
+        rgmcd[ count ].Print( fp );
+    }
+    
+}
+
+PlfAcd::PlfAcd( bool bReadId ) : Tcg255SubStruct( bReadId )
+,iMac(0)
+,rgacd(NULL)
+{
+}
+
+
+PlfAcd::~PlfAcd()
+{
+    if ( rgacd )
+        delete[] rgacd;
+}
+
+bool PlfAcd::Read( SvStream *pS)
+{
+    OSL_TRACE("PffAcd::Read() stream pos 0x%x", pS->Tell() );
+    nOffSet = pS->Tell();
+    Tcg255SubStruct::Read( pS );
+    *pS >> iMac;
+    if ( iMac )
+    {
+        rgacd = new Acd[ iMac ];
+        for ( sal_Int32 index = 0; index < iMac; ++index )
+        {
+            if ( !rgacd[ index ].Read( pS ) ) 
+                return false;
+        }
+    }
+    return true;
+}
+void PlfAcd::Print( FILE* fp )
+{
+    Indent a;
+    indent_printf(fp, "[ 0x%x ] PlfAcd ( Tcg255SubStruct ) - dump\n", nOffSet );
+    indent_printf(fp, " contains %d ACD records\n", static_cast< int >( iMac ) );
+    for ( sal_Int32 count=0; count < iMac; ++count )
+    {
+        Indent b;
+        indent_printf(fp, "[%d] ACD\n", static_cast< int >( count ) );
+        rgacd[ count ].Print( fp );
+    }
+    
+}
+
+PlfKme::PlfKme( bool bReadId ) : Tcg255SubStruct( bReadId )
+,iMac( 0 )
+,rgkme( NULL )
+{
+}
+
+PlfKme::~PlfKme()
+{
+    if ( rgkme )
+        delete[] rgkme;
+}
+
+bool PlfKme::Read(SvStream *pS)
+{
+    OSL_TRACE("PlfKme::Read() stream pos 0x%x", pS->Tell() );
+    nOffSet = pS->Tell();
+    Tcg255SubStruct::Read( pS );
+    *pS >> iMac;
+    if ( iMac )
+    {
+        rgkme = new Kme[ iMac ];
+        for( sal_Int32 index=0; index<iMac; ++index )
+        {
+            if ( !rgkme[ index ].Read( pS ) )
+                return false;
+        }
+    }
+    return true;
+}
+ 
+void PlfKme::Print( FILE* fp )
+{
+    Indent a;
+    indent_printf(fp, "[ 0x%x ] PlfKme ( Tcg255SubStruct ) - dump\n", nOffSet );
+    indent_printf(fp, " contains %d Kme records\n", static_cast< int >( iMac ) );
+    for ( sal_Int32 count=0; count < iMac; ++count )
+    {
+        Indent b;
+        indent_printf(fp, "[%d] Kme\n", static_cast< int >( count ) );
+        rgkme[ count ].Print( fp );
+    }
+    
+}
+
+TcgSttbf::TcgSttbf( bool bReadId ) : Tcg255SubStruct( bReadId )
+{
+}
+
+bool TcgSttbf::Read( SvStream *pS) 
+{
+    OSL_TRACE("TcgSttbf::Read() stream pos 0x%x", pS->Tell() );
+    nOffSet = pS->Tell();
+    Tcg255SubStruct::Read( pS );
+    return sttbf.Read( pS );
+}
+
+void TcgSttbf::Print( FILE* fp )
+{
+    Indent a;
+    indent_printf(fp,"[ 0x%x ] TcgSttbf - dump\n", nOffSet );
+    sttbf.Print( fp );
+}
+
+TcgSttbfCore::TcgSttbfCore() : fExtend( 0 )
+,cData( 0 )
+,cbExtra( 0 )
+,dataItems( NULL )
+{
+}
+
+TcgSttbfCore::~TcgSttbfCore()
+{
+    if ( dataItems )
+        delete[] dataItems;
+}
+
+bool TcgSttbfCore::Read( SvStream* pS )
+{
+    OSL_TRACE("TcgSttbfCore::Read() stream pos 0x%x", pS->Tell() );
+    nOffSet = pS->Tell();
+    *pS >> fExtend >> cData >> cbExtra;
+    if ( cData )
+    {
+        dataItems = new SBBItem[ cData ];
+        for ( sal_Int32 index = 0; index < cData; ++index )
+        {
+            *pS >> dataItems[ index ].cchData;
+            dataItems[ index ].data = readUnicodeString( pS, dataItems[ index ].cchData );
+            *pS >> dataItems[ index ].extraData;
+        }
+    }
+    return true;
+}
+
+void TcgSttbfCore::Print( FILE* fp )
+{
+    Indent a;
+    indent_printf( fp, "[ 0x%x ] TcgSttbfCore - dump\n");
+    indent_printf( fp, " fExtend 0x%x [expected 0xFFFF ]\n", fExtend );
+    indent_printf( fp, " cbExtra 0x%x [expected 0x02 ]\n", cbExtra );
+    indent_printf( fp, " cData no. or string data items %d (0x%x)\n", cData, cData );
+    
+    if ( cData )
+    {
+        for ( sal_Int32 index = 0; index < cData; ++index )
+            indent_printf(fp,"   string dataItem[ %d(0x%x) ] has name %s and if referenced %d times.\n", static_cast< int >( index ), static_cast< unsigned int >( index ), rtl::OUStringToOString( dataItems[ index ].data, RTL_TEXTENCODING_UTF8 ).getStr(), dataItems[ index ].extraData );
+    }
+
+}
+MacroNames::MacroNames( bool bReadId ) : Tcg255SubStruct( bReadId )
+,iMac( 0 )
+,rgNames( NULL )
+{
+}
+
+MacroNames::~MacroNames()
+{
+    if ( rgNames )
+        delete[] rgNames;
+}
+
+bool MacroNames::Read( SvStream *pS)
+{
+    OSL_TRACE("MacroNames::Read() stream pos 0x%x", pS->Tell() );
+    nOffSet = pS->Tell();
+    Tcg255SubStruct::Read( pS );
+    *pS >> iMac;
+    if ( iMac )
+    {
+        rgNames = new MacroName[ iMac ]; 
+        for ( sal_Int32 index = 0; index < iMac; ++index )
+        {
+            if ( !rgNames[ index ].Read( pS ) )
+                return false;
+        }
+    }
+    return true;
+}
+
+void MacroNames::Print( FILE* fp )
+{
+    Indent a;
+    indent_printf(fp, "[ 0x%x ] MacroNames ( Tcg255SubStruct ) - dump\n");
+    indent_printf(fp, " contains %d MacroName records\n", iMac );
+    for ( sal_Int32 count=0; count < iMac; ++count )
+    {
+        Indent b;
+        indent_printf(fp, "[%d] MacroName\n", static_cast<int>( count ) );
+        rgNames[ count ].Print( fp );
+    }
+    
+}
+
+MacroName::MacroName():ibst(0)
+{
+}
+
+
+bool MacroName::Read(SvStream *pS)
+{
+    OSL_TRACE("MacroName::Read() stream pos 0x%x", pS->Tell() );
+    nOffSet = pS->Tell();
+    *pS >> ibst;
+    return xstz.Read( pS );
+}
+
+void MacroName::Print( FILE* fp )
+{
+    Indent a;
+    indent_printf( fp, "[ 0x%x ] MacroName - dump");
+    indent_printf( fp,"  index - 0x%x has associated following record\n", ibst );
+    xstz.Print( fp );
+}
+
+
+
+Xstz::Xstz():chTerm(0)
+{
+}
+
+bool 
+Xstz::Read(SvStream *pS)
+{
+    OSL_TRACE("Xstz::Read() stream pos 0x%x", pS->Tell() );
+    nOffSet = pS->Tell();
+    if ( !xst.Read( pS ) )
+        return false;
+    *pS >> chTerm;
+    if ( chTerm != 0 ) // should be an assert 
+        return false;
+    return true;
+}
+
+void Xstz::Print( FILE* fp )
+{
+    Indent a;
+    indent_printf(fp,"[ 0x%x ] Xstz -- dump\n", nOffSet );
+    indent_printf(fp,"  Xst\n");
+    xst.Print( fp ); 
+    indent_printf(fp,"  chterm 0x%x ( should be zero )\n", chTerm);
+}
+
+Kme::Kme() : reserved1(0)
+,reserved2(0)
+,kcm1(0)
+,kcm2(0)
+,kt(0)
+,param(0)
+{
+}
+
+Kme::~Kme()
+{
+}
+
+bool
+Kme::Read(SvStream *pS)
+{
+    OSL_TRACE("Kme::Read() stream pos 0x%x", pS->Tell() );
+    nOffSet = pS->Tell();
+    *pS >> reserved1 >> reserved2 >> kcm1 >> kcm2 >> param;
+    return true;
+}
+
+void Kme::Print( FILE* fp )
+{
+    Indent a;
+    
+   indent_printf( fp, "[ 0x%x ] Kme - dump\n", nOffSet );
+   indent_printf( fp, " reserved1 0x%x [expected 0x0 ]\n", reserved1 );
+   indent_printf( fp, " reserved2 0x%x [expected 0x0 ]\n", reserved2 );
+   indent_printf( fp, " kcm1 0x%x [shortcut key]\n", kcm1 );
+   indent_printf( fp, " kcm2 0x%x [shortcut key]\n", kcm2 );
+   indent_printf( fp, " kt 0x%x \n", kt );
+   indent_printf( fp, " param 0x%x \n", static_cast< unsigned int >( param ) );
+}
+
+Acd::Acd() : ibst( 0 )
+, fciBasedOnABC( 0 )
+{
+}
+
+bool Acd::Read(SvStream *pS)
+{
+    OSL_TRACE("Acd::Read() stream pos 0x%x", pS->Tell() );
+    nOffSet = pS->Tell();
+    *pS >> ibst >> fciBasedOnABC;
+    return true;
+}
+
+void Acd::Print( FILE* fp )
+{
+    Indent a;
+    indent_printf( fp,"[ 0x%x ] ACD - dump\n", nOffSet );
+    // #TODO flesh out interpretation of these values
+    indent_printf( fp,"  ibst 0x%x\n", ibst);
+    indent_printf( fp,"  fciBaseObABC 0x%x\n", fciBasedOnABC);
+}
+
+MCD::MCD() :  reserved1(0x56)
+,reserved2( 0 )
+,ibst( 0 )
+,ibstName( 0 )
+,reserved3( 0xFFFF )
+,reserved4( 0 )
+,reserved5( 0 )
+,reserved6( 0 )
+,reserved7( 0 )
+{
+}
+
+bool  MCD::Read(SvStream *pS)
+{
+    OSL_TRACE("MCD::Read() stream pos 0x%x", pS->Tell() );
+    nOffSet = pS->Tell();
+    *pS >> reserved1 >> reserved2 >> ibst >> ibstName >> reserved3;
+    *pS >> reserved4 >> reserved5 >> reserved6 >> reserved7;
+    return true;
+}
+
+void MCD::Print( FILE* fp )
+{
+    Indent a;
+    indent_printf( fp, "[ 0x%x ] MCD - dump\n", nOffSet );
+    indent_printf( fp, " reserved1 0x%x [expected 0x56 ]\n", reserved1 );
+    indent_printf( fp, " reserved2 0x%x [expected 0x0 ]\n", reserved2 );
+    indent_printf( fp, " ibst 0x%x specifies macro with MacroName.xstz = 0x%x\n", ibst, ibst );
+    indent_printf( fp, " ibstName 0x%x index into command string table ( TcgSttbf.sttbf )\n", ibstName );
+
+    indent_printf( fp, " reserved3 0x%x [expected 0xFFFF ]\n", reserved3 );
+    indent_printf( fp, " reserved4 0x%x\n", static_cast< unsigned int >( reserved4 ) );
+    indent_printf( fp, " reserved5 0x%x [expected 0x0 ]\n", static_cast< unsigned int >( reserved5 ) );
+    indent_printf( fp, " reserved6 0x%x\n", static_cast< unsigned int >( reserved6 ) );
+    indent_printf( fp, " reserved7 0x%x\n", static_cast< unsigned int >( reserved7 ) );
+}
+
diff --git sw/source/filter/ww8/ww8toolbar.hxx sw/source/filter/ww8/ww8toolbar.hxx
new file mode 100644
index 0000000..188213c
--- /dev/null
+++ sw/source/filter/ww8/ww8toolbar.hxx
@@ -0,0 +1,340 @@
+#ifndef _WW8TOOLBAR_HXX
+#define _WW8TOOLBAR_HXX
+
+#include <svx/mstoolbar.hxx>
+
+namespace css = ::com::sun::star;
+
+class Xst : public TBBase
+{
+    rtl::OUString sString;
+public:
+    Xst(){}
+    bool Read(SvStream *pS);
+    rtl::OUString getString() { return sString; }
+    void Print( FILE* fp );
+};
+
+class TBC : public TBBase
+{
+    TBCHeader tbch;
+    boost::shared_ptr< sal_uInt32 > cid; // optional
+    boost::shared_ptr<TBCData> tbcd;
+public:
+    TBC();
+    ~TBC();
+    bool Read(SvStream *pS);
+    void Print( FILE* );
+    bool ImportToolBarControl( const css::uno::Reference< css::container::XIndexContainer >&, CustomToolBarImportHelper& );
+};
+
+class TB : public TBBase
+{
+    sal_Int8 bSignature; //Signed integer that specifies the toolbar signature number. MUST be 0x02.
+    sal_Int8 bVersion; //Signed integer that specifies the toolbar version number. MUST be 0x01.
+    sal_Int16 cCL; //Signed integer that SHOULD  specify the number of toolbar controls contained in this toolbar.
+    sal_Int32 ltbid; //Signed integer that specifies the toolbar ID. MUST be 0x0001 (custom toolbar ID).
+    sal_uInt32 ltbtr; //Unsigned integer of type TBTRFlags that specifies the toolbar type and toolbar restrictions.
+    sal_uInt16 cRowsDefault; //Unsigned integer that specifies the number of preferred rows for the toolbar when the toolbar is not docked. MUST be less than or equal to 255.
+    sal_uInt16 bFlags; //Unsigned integer of type TBFlags.
+    WString name; //Structure of type WString that specifies the toolbar name.
+    TB(const TB&);
+    TB& operator = ( const TB&);
+public:
+    TB();
+    ~TB(){}
+    bool Read(SvStream *pS);
+    void Print( FILE* );
+};
+
+class CTB : public TBBase
+{
+    Xst name;
+    sal_Int32 cbTBData;
+    TB tb;
+    sal_uInt8 rVisualData[ 100 ];
+    sal_Int32 iWCTBl;
+    sal_uInt16 reserved;
+    sal_uInt16 unused;
+    sal_Int32 cCtls;
+    std::vector< TBC > rTBC;
+
+    CTB(const CTB&);
+    CTB& operator = ( const CTB&);
+public:
+    CTB();
+    ~CTB();
+    bool Read(SvStream *pS);
+    void Print( FILE* fp );
+    bool ImportCustomToolBar( CustomToolBarImportHelper& );
+};
+
+class TBDelta : public TBBase
+{
+    sal_uInt8 doprfatendFlags;
+    sal_uInt8 ibts;
+    sal_Int32 cidNext; 
+    sal_Int32 cid;
+    sal_Int32 fc;
+    sal_uInt16 CiTBDE; // careful of this ( endian matters etc. )
+    sal_uInt16 cbTBC;
+public:
+    TBDelta();
+    ~TBDelta(){}
+    bool Read(SvStream *pS);
+    void Print( FILE* );
+};
+
+class Tcg255SubStruct : public TBBase
+{
+friend class Tcg255;
+    bool mbReadId;
+    Tcg255SubStruct(const Tcg255SubStruct&);
+    Tcg255SubStruct& operator = ( const Tcg255SubStruct&);
+protected:
+    sal_uInt8 ch;
+public:
+    Tcg255SubStruct( bool bReadId );
+    ~Tcg255SubStruct(){}
+    virtual sal_uInt8 id() const { return ch; }
+    bool Read(SvStream *pS);
+};
+
+class Customization : public TBBase
+{
+    sal_Int32 tbidForTBD;
+    sal_uInt16 reserved1;
+    sal_Int16 ctbds;
+
+    boost::shared_ptr< CTB > customizationDataCTB;
+    std::vector< TBDelta > customizationDataTBDelta; 
+    
+public:    
+    Customization();
+    ~Customization();
+    bool Read(SvStream *pS);
+    bool ImportCustomToolBar( CustomToolBarImportHelper& );
+    void Print( FILE* );
+};
+
+class CTBWrapper : public Tcg255SubStruct
+{
+    // reserved1 is the ch field of Tcg255SubStruct
+    sal_uInt16 reserved2;
+    sal_uInt8 reserved3;
+    sal_uInt16 reserved4;
+    sal_uInt16 reserved5;
+
+    sal_Int16 cbTBD;
+    sal_Int16 cCust;
+
+    sal_Int32 cbDTBC;
+
+    std::vector< TBC > rtbdc; // array of TBC's - we don't read these yet 
+    std::vector< Customization > rCustomizations; // array of Customizations
+
+    CTBWrapper(const CTBWrapper&);
+    CTBWrapper& operator = ( const CTBWrapper&);
+public:
+    CTBWrapper( bool bReadId = true );
+    ~CTBWrapper();
+    bool Read(SvStream *pS);
+    bool ImportCustomToolBar( const css::uno::Reference< css::frame::XModel >& rxModel );
+    void Print( FILE* );
+};
+
+class MCD : public TBBase
+{
+    sal_Int8 reserved1; //  A signed integer that MUST be 0x56. 
+    sal_uInt8 reserved2; // MUST be 0.
+    sal_uInt16 ibst; // Unsigned integer that specifies the name of the macro. Macro name is specified by MacroName.xstz of the MacroName entry in the MacroNames such that MacroName.ibst equals ibst. MacroNames MUST contain such an entry.
+    sal_uInt16 ibstName; // An unsigned integer that specifies the index into the Command String Table (TcgSttbf.sttbf) where the macros name and arguments are specified.
+    sal_uInt16 reserved3; // An unsigned integer that MUST be 0xFFFF.
+    sal_uInt32 reserved4; //MUST be ignored. 
+    sal_uInt32 reserved5; //MUST be 0. 
+    sal_uInt32 reserved6; //MUST be ignored. 
+    sal_uInt32 reserved7; //MUST be ignored   
+
+    MCD(const MCD&);
+    MCD& operator = ( const MCD&);
+public:
+    MCD();
+    ~MCD(){}
+    bool Read(SvStream *pS);
+    void Print( FILE* );
+};
+
+class PlfMcd : public Tcg255SubStruct
+{
+    sal_Int32 iMac;
+    MCD* rgmcd; // array of MCD's
+    PlfMcd(const PlfMcd&);
+    PlfMcd& operator = ( const PlfMcd&);
+public:
+    PlfMcd( bool bReadId = true );
+    ~PlfMcd();
+    bool Read(SvStream *pS);
+    void Print( FILE* );
+};
+
+class Acd : public TBBase
+{
+    sal_Int16 ibst;
+    sal_uInt16 fciBasedOnABC; //  fciBasedOn(13 bits) A(1bit)B(1bit)C(1Bit)
+    Acd(const Acd&);
+    Acd& operator = ( const Acd&);
+public:
+    Acd();
+    ~Acd(){}
+    bool Read(SvStream *pS);
+    void Print( FILE* );
+};
+
+class PlfAcd: public Tcg255SubStruct
+{
+    sal_Int32 iMac;
+    Acd* rgacd;
+    PlfAcd(const PlfAcd&);
+    PlfAcd& operator = ( const PlfAcd&);
+public:
+    PlfAcd( bool bReadId = true );
+    ~PlfAcd();
+    bool Read(SvStream *pS);
+    void Print(FILE*);
+};
+
+class Kme : public TBBase
+{
+    sal_Int16 reserved1; //MUST be zero. 
+    sal_Int16 reserved2; //MUST be zero.
+    sal_uInt16 kcm1; //A Kcm that specifies the primary shortcut key.
+    sal_uInt16 kcm2; //A Kcm that specifies the secondary shortcut key, or 0x00FF if there is no secondary shortcut key.
+    sal_uInt16 kt; //A Kt that specifies the type of action to be taken when the key combination is pressed. 
+    sal_uInt32 param; //The meaning of this field depends on the value of kt
+
+    Kme(const Kme&);
+    Kme& operator = ( const Kme&);
+public:
+    Kme();
+    ~Kme();
+    bool Read(SvStream *pS);
+    void Print( FILE* );
+};
+
+class PlfKme : public Tcg255SubStruct
+{
+    sal_Int32 iMac;
+    Kme* rgkme;
+    PlfKme(const PlfKme&);
+    PlfKme& operator = ( const PlfKme&);
+public:
+    PlfKme( bool bReadId = true );
+    ~PlfKme();
+    bool Read(SvStream *pS);
+    void Print( FILE* );
+};
+
+class TcgSttbfCore : public TBBase
+{
+struct SBBItem
+{
+    sal_uInt16 cchData;
+    rtl::OUString data; 
+    sal_uInt16 extraData;
+    SBBItem() : cchData(0), extraData(0){}
+};
+    sal_uInt16 fExtend;
+    sal_uInt16 cData;
+    sal_uInt16 cbExtra;
+    SBBItem* dataItems;
+    TcgSttbfCore(const TcgSttbfCore&);
+    TcgSttbfCore& operator = ( const TcgSttbfCore&);
+public:
+    TcgSttbfCore();
+    ~TcgSttbfCore();
+    bool Read(SvStream *pS);
+    void Print( FILE* fp );
+};
+
+class TcgSttbf : public Tcg255SubStruct
+{
+    TcgSttbfCore sttbf;
+    TcgSttbf(const TcgSttbf&);
+    TcgSttbf& operator = ( const TcgSttbf&);
+public:
+    TcgSttbf( bool bReadId = true );
+    ~TcgSttbf(){}
+    bool Read(SvStream *pS);
+    void Print( FILE* fp );
+};
+
+class Xstz : public TBBase
+{
+    Xst xst; //An Xst specifying the string with its pre-pended length. 
+    sal_uInt16 chTerm;
+
+    Xstz(const Xstz&);
+    Xstz& operator = ( const Xstz&);
+public:
+    Xstz();
+    ~Xstz(){}
+    bool Read(SvStream *pS);
+    void Print( FILE* fp );
+};
+
+class MacroName : public TBBase
+{
+    sal_uInt16 ibst; //An unsigned integer that specifies the index of the current entry in the macro name table. MUST NOT be the same as the index of any other entry.
+    Xstz xstz;
+    MacroName(const MacroName&);
+    MacroName& operator = ( const MacroName&);
+public:
+    MacroName();
+    ~MacroName(){}
+    bool Read(SvStream *pS);
+    void Print( FILE* );
+};
+
+class MacroNames : public Tcg255SubStruct
+{
+    sal_uInt16 iMac; //An unsigned integer that specifies the number of MacroName structures in rgNames.
+    MacroName* rgNames;
+
+    MacroNames(const MacroNames&);
+    MacroNames& operator = ( const MacroNames&);
+public:
+    MacroNames( bool bReadId = true );
+    ~MacroNames();
+    bool Read(SvStream *pS);
+    void Print( FILE* );
+};
+
+class Tcg255 : public TBBase
+{
+    std::vector< Tcg255SubStruct* > rgtcgData; // array of sub structures
+    Tcg255(const Tcg255&);
+    Tcg255& operator = ( const Tcg255&);
+    bool processSubStruct( sal_uInt8 nId, SvStream*  );
+public:
+    Tcg255();
+    ~Tcg255();
+    bool Read(SvStream *pS);
+    void Print( FILE* );
+    bool ImportCustomToolBar( const css::uno::Reference< css::frame::XModel >& rxModel );
+};
+
+class Tcg: public TBBase
+{
+    sal_Int8 nTcgVer; 
+    std::auto_ptr< Tcg255 > tcg;
+    Tcg(const Tcg&);
+    Tcg& operator = ( const Tcg&);
+public:
+    Tcg();
+    ~Tcg(){}
+    bool Read(SvStream *pS);
+    bool ImportCustomToolBar( const css::uno::Reference< css::frame::XModel >& rxModel );
+    void Print( FILE* );
+};
+
+#endif
diff --git vcl/source/gdi/bitmap2.cxx vcl/source/gdi/bitmap2.cxx
index 5e931a7..7c5be41 100644
--- vcl/source/gdi/bitmap2.cxx
+++ vcl/source/gdi/bitmap2.cxx
@@ -49,6 +49,7 @@
 
 #define DIBCOREHEADERSIZE			( 12UL )
 #define DIBINFOHEADERSIZE			( sizeof( DIBInfoHeader ) )
+#define BITMAPINFOHEADER                        0x28
 #define SETPIXEL4( pBuf, nX, cChar )( (pBuf)[ (nX) >> 1 ] |= ( (nX) & 1 ) ? ( cChar ): (cChar) << 4 );
 
 // ----------------------
@@ -308,16 +309,32 @@ BOOL Bitmap::ImplReadDIBInfoHeader( SvStream& rIStm, DIBInfoHeader& rHeader, sal
 	rIStm >> rHeader.nSize;
 
 	// BITMAPCOREHEADER
+	sal_Int16 nTmp16 = 0;
+	sal_uInt8 nTmp8 = 0;
 	if ( rHeader.nSize == DIBCOREHEADERSIZE )
 	{
-		sal_Int16 nTmp16;
 
 		rIStm >> nTmp16; rHeader.nWidth = nTmp16;
 		rIStm >> nTmp16; rHeader.nHeight = nTmp16;
 		rIStm >> rHeader.nPlanes;
 		rIStm >> rHeader.nBitCount;
 	}
-	else
+	else if ( rHeader.nSize == BITMAPINFOHEADER )
+	{
+		rIStm >> nTmp16; rHeader.nWidth = nTmp16;
+		rIStm >> nTmp16; rHeader.nHeight = nTmp16;
+		rIStm >> nTmp8; rHeader.nPlanes = nTmp8;
+		rIStm >> nTmp8; rHeader.nBitCount = nTmp8;
+		rIStm >> nTmp16; rHeader.nSizeImage = nTmp16;
+		rIStm >> nTmp16; rHeader.nCompression = nTmp16;
+		if ( !rHeader.nSizeImage ) // uncompressed?
+			rHeader.nSizeImage = ((rHeader.nWidth * rHeader.nBitCount + 31) & ~31) / 8 * rHeader.nHeight;
+		rIStm >> rHeader.nXPelsPerMeter;
+		rIStm >> rHeader.nYPelsPerMeter;
+		rIStm >> rHeader.nColsUsed;
+		rIStm >> rHeader.nColsImportant;
+	}
+        else
 	{
 		// unknown Header
 		if( rHeader.nSize < DIBINFOHEADERSIZE )
