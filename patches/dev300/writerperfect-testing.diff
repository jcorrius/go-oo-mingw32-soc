diff -u -r -N writerperfect//prj/build.lst writerperfect//prj/build.lst
--- writerperfect//prj/build.lst	2008-11-17 22:06:28.000000000 +0100
+++ writerperfect//prj/build.lst	2008-11-17 23:37:06.000000000 +0100
@@ -1,4 +1,4 @@
-wp      writerperfect : LIBWPG:libwpg LIBWPS:libwps LIBWPD:libwpd sot comphelper xmloff NULL
+wp      writerperfect : LIBWPG:libwpg LIBWPS:libwps LIBWPD:libwpd sot comphelper xmloff sfx2 NULL
 wp	writerperfect			usr1	-	all	wp_mkout NULL
 wp	writerperfect\source\stream	nmake	-	all	wp_stream NULL
 wp	writerperfect\source\filter	nmake	-	all	wp_filter NULL
diff -u -r -N writerperfect//source/filter/DocumentCollector.cxx writerperfect//source/filter/DocumentCollector.cxx
--- writerperfect//source/filter/DocumentCollector.cxx	2008-11-17 22:06:28.000000000 +0100
+++ writerperfect//source/filter/DocumentCollector.cxx	2008-11-17 23:30:51.000000000 +0100
@@ -39,6 +39,8 @@
 
 #include "DocumentCollector.hxx"
 #include "DocumentElement.hxx"
+#include "DocumentHandler.hxx"
+#include "InternalHandler.hxx"
 #include "TextRunStyle.hxx"
 #include "FontStyle.hxx"
 #include "ListStyle.hxx"
@@ -47,6 +49,7 @@
 #include "TableStyle.hxx"
 #include "FilterInternal.hxx"
 #include "WriterProperties.hxx"
+#include "OdgExporter.hxx"
 
 _WriterDocumentState::_WriterDocumentState() :
 	mbFirstElement(true),
@@ -54,27 +57,40 @@
 	mbListElementOpenedAtCurrentLevel(false),
 	mbTableCellOpened(false),
 	mbHeaderRow(false),
-	mbInNote(false)
+	mbInNote(false),
+	mbInTextBox(false),
+	mbInFrame(false)
 {
 }
 
-DocumentCollector::DocumentCollector(WPSInputStream *pInput, DocumentHandler *pHandler) :
-        mpInput(pInput),
-        mpHandler(pHandler),
+_WriterListState::_WriterListState() :
+	mpCurrentListStyle(NULL),
+	miCurrentListLevel(0),
+	miLastListLevel(0),
+	miLastListNumber(0),
+	mbListContinueNumbering(false),
+	mbListElementParagraphOpened(false),
+	mbListElementOpened()
+{
+}
+
+DocumentCollector::DocumentCollector(WPXInputStream *pInput, DocumentHandlerInterface *pHandler) :
+	mpInput(pInput),
+	mpHandler(pHandler),
 	mbUsed(false),
+	mWriterDocumentStates(),
+	mWriterListStates(),
 	mfSectionSpaceAfter(0.0f),
 	miNumListStyles(0),
 	mpCurrentContentElements(&mBodyElements),
 	mpCurrentPageSpan(NULL),
 	miNumPageStyles(0),
-	mpCurrentListStyle(NULL),
-	miCurrentListLevel(0),
-	miLastListLevel(0),
-	miLastListNumber(0),
-	mbListContinueNumbering(false),
-	mbListElementOpened(false),
-	mbListElementParagraphOpened(false)
+	miObjectNumber(0),
+	mbIsFlatXML(true),
+	mpPassword(NULL)
 {
+	mWriterDocumentStates.push(WriterDocumentState());
+	mWriterListStates.push(WriterListState());
 }
 
 DocumentCollector::~DocumentCollector()
@@ -91,18 +107,18 @@
 	mbUsed = true;
 
 	// parse & write
-        // WLACH_REFACTORING: Remove these args..
  	if (!parseSourceDocument(*mpInput))
 		return false;
 	if (!_writeTargetDocument(mpHandler))
 		return false;
 
+
  	// clean up the mess we made
  	WRITER_DEBUG_MSG(("WriterWordPerfect: Cleaning up our mess..\n"));
 
 	WRITER_DEBUG_MSG(("Destroying the body elements\n"));
 	for (std::vector<DocumentElement *>::iterator iterBody = mBodyElements.begin(); iterBody != mBodyElements.end(); iterBody++) {
-		delete((*iterBody));
+		delete (*iterBody);
 		(*iterBody) = NULL;
 	}
 
@@ -115,97 +131,118 @@
 
 	WRITER_DEBUG_MSG(("Destroying the rest of the styles elements\n"));
 	for (std::map<WPXString, ParagraphStyle *, ltstr>::iterator iterTextStyle = mTextStyleHash.begin(); iterTextStyle != mTextStyleHash.end(); iterTextStyle++) {
-		delete iterTextStyle->second;
+		delete (iterTextStyle->second);
 	}
 	for (std::map<WPXString, SpanStyle *, ltstr>::iterator iterSpanStyle = mSpanStyleHash.begin(); iterSpanStyle != mSpanStyleHash.end(); iterSpanStyle++) {
-		delete iterSpanStyle->second;
+		delete(iterSpanStyle->second);
 	}
 
 	for (std::map<WPXString, FontStyle *, ltstr>::iterator iterFont = mFontHash.begin(); iterFont != mFontHash.end(); iterFont++) {
-		delete iterFont->second;
+		delete(iterFont->second);
 	}
 
 	for (std::vector<ListStyle *>::iterator iterListStyles = mListStyles.begin(); iterListStyles != mListStyles.end(); iterListStyles++) {
-		delete (*iterListStyles);
+		delete(*iterListStyles);
 	}
 	for (std::vector<SectionStyle *>::iterator iterSectionStyles = mSectionStyles.begin(); iterSectionStyles != mSectionStyles.end(); iterSectionStyles++) {
-		delete (*iterSectionStyles);
+		delete(*iterSectionStyles);
 	}
 	for (std::vector<TableStyle *>::iterator iterTableStyles = mTableStyles.begin(); iterTableStyles != mTableStyles.end(); iterTableStyles++) {
-		delete (*iterTableStyles);
+		delete((*iterTableStyles));
 	}
 
 	for (std::vector<PageSpan *>::iterator iterPageSpans = mPageSpans.begin(); iterPageSpans != mPageSpans.end(); iterPageSpans++) {
-		delete (*iterPageSpans);
+		delete(*iterPageSpans);
+	}
+	for (std::vector<DocumentElement *>::iterator iterFrameStyles = mFrameStyles.begin(); iterFrameStyles != mFrameStyles.end(); iterFrameStyles++) {
+		delete(*iterFrameStyles);
+	}
+	for (std::vector<DocumentElement *>::iterator iterFrameAutomaticStyles = mFrameAutomaticStyles.begin();
+		iterFrameAutomaticStyles != mFrameAutomaticStyles.end(); iterFrameAutomaticStyles++) {
+		delete(*iterFrameAutomaticStyles);
+	}
+	for (std::vector<DocumentElement *>::iterator iterMetaData = mMetaData.begin(); iterMetaData != mMetaData.end(); iterMetaData++) {
+		delete(*iterMetaData);
 	}
 
  	return true;
 }
 
-void DocumentCollector::_writeDefaultStyles(DocumentHandler *pHandler)
+void DocumentCollector::_writeDefaultStyles(DocumentHandlerInterface *pHandler)
 {
-	TagOpenElement stylesOpenElement("office:styles");
-	stylesOpenElement.write(pHandler);
+	TagOpenElement("office:styles").write(pHandler);
 
 	TagOpenElement defaultParagraphStyleOpenElement("style:default-style");
 	defaultParagraphStyleOpenElement.addAttribute("style:family", "paragraph");
 	defaultParagraphStyleOpenElement.write(pHandler);
 
-	TagOpenElement defaultParagraphStylePropertiesOpenElement("style:properties");
-	defaultParagraphStylePropertiesOpenElement.addAttribute("style:family", "paragraph");
-	defaultParagraphStylePropertiesOpenElement.addAttribute("style:tab-stop-distance", "0.5inch");
+	TagOpenElement defaultParagraphStylePropertiesOpenElement("style:paragraph-properties");
+	defaultParagraphStylePropertiesOpenElement.addAttribute("style:tab-stop-distance", "0.5in");
 	defaultParagraphStylePropertiesOpenElement.write(pHandler);
-	TagCloseElement defaultParagraphStylePropertiesCloseElement("style:properties");
+	TagCloseElement defaultParagraphStylePropertiesCloseElement("style:paragraph-properties");
 	defaultParagraphStylePropertiesCloseElement.write(pHandler);
 
-	TagCloseElement defaultParagraphStyleCloseElement("style:default-style");
-	defaultParagraphStyleCloseElement.write(pHandler);
+	pHandler->endElement("style:default-style");
+
+	TagOpenElement defaultTableRowStyleOpenElement("style:default-style");
+	defaultTableRowStyleOpenElement.addAttribute("style:family", "table-row");
+	defaultTableRowStyleOpenElement.write(pHandler);
+
+	TagOpenElement defaultTableRowPropertiesOpenElement("style:table-row-properties");
+	defaultTableRowPropertiesOpenElement.addAttribute("fo:keep-together", "auto");
+	defaultTableRowPropertiesOpenElement.write(pHandler);
+
+	pHandler->endElement("style:table-row-properties");
+	pHandler->endElement("style:default-style");
 
 	TagOpenElement standardStyleOpenElement("style:style");
-        standardStyleOpenElement.addAttribute("style:name", "Standard");
-        standardStyleOpenElement.addAttribute("style:family", "paragraph");
-        standardStyleOpenElement.addAttribute("style:class", "text");
-        standardStyleOpenElement.write(pHandler);
-        TagCloseElement standardStyleCloseElement("style:style");
-        standardStyleCloseElement.write(pHandler);
-
-        TagOpenElement textBodyStyleOpenElement("style:style");
-        textBodyStyleOpenElement.addAttribute("style:name", "Text Body");
-        textBodyStyleOpenElement.addAttribute("style:family", "paragraph");
-        textBodyStyleOpenElement.addAttribute("style:parent-style-name", "Standard");
-        textBodyStyleOpenElement.addAttribute("style:class", "text");
-        textBodyStyleOpenElement.write(pHandler);
-        TagCloseElement textBodyStyleCloseElement("style:style");
-        textBodyStyleCloseElement.write(pHandler);
-
-        TagOpenElement tableContentsStyleOpenElement("style:style");
-        tableContentsStyleOpenElement.addAttribute("style:name", "Table Contents");
-        tableContentsStyleOpenElement.addAttribute("style:family", "paragraph");
-        tableContentsStyleOpenElement.addAttribute("style:parent-style-name", "Text Body");
-        tableContentsStyleOpenElement.addAttribute("style:class", "extra");
-        tableContentsStyleOpenElement.write(pHandler);
-        TagCloseElement tableContentsStyleCloseElement("style:style");
-        tableContentsStyleCloseElement.write(pHandler);
-
-        TagOpenElement tableHeadingStyleOpenElement("style:style");
-        tableHeadingStyleOpenElement.addAttribute("style:name", "Table Heading");
-        tableHeadingStyleOpenElement.addAttribute("style:family", "paragraph");
-        tableHeadingStyleOpenElement.addAttribute("style:parent-style-name", "Table Contents");
-        tableHeadingStyleOpenElement.addAttribute("style:class", "extra");
-        tableHeadingStyleOpenElement.write(pHandler);
-        TagCloseElement tableHeadingStyleCloseElement("style:style");
-        tableHeadingStyleCloseElement.write(pHandler);
-
-	TagCloseElement stylesCloseElement("office:styles");
-	stylesCloseElement.write(pHandler);
+	standardStyleOpenElement.addAttribute("style:name", "Standard");
+	standardStyleOpenElement.addAttribute("style:family", "paragraph");
+	standardStyleOpenElement.addAttribute("style:class", "text");
+	standardStyleOpenElement.write(pHandler);
+
+	pHandler->endElement("style:style");
+
+	TagOpenElement textBodyStyleOpenElement("style:style");
+	textBodyStyleOpenElement.addAttribute("style:name", "Text_Body");
+	textBodyStyleOpenElement.addAttribute("style:display-name", "Text Body");
+	textBodyStyleOpenElement.addAttribute("style:family", "paragraph");
+	textBodyStyleOpenElement.addAttribute("style:parent-style-name", "Standard");
+	textBodyStyleOpenElement.addAttribute("style:class", "text");
+	textBodyStyleOpenElement.write(pHandler);
+
+	pHandler->endElement("style:style");
 
+	TagOpenElement tableContentsStyleOpenElement("style:style");
+	tableContentsStyleOpenElement.addAttribute("style:name", "Table_Contents");
+	tableContentsStyleOpenElement.addAttribute("style:display-name", "Table Contents");
+	tableContentsStyleOpenElement.addAttribute("style:family", "paragraph");
+	tableContentsStyleOpenElement.addAttribute("style:parent-style-name", "Text_Body");
+	tableContentsStyleOpenElement.addAttribute("style:class", "extra");
+	tableContentsStyleOpenElement.write(pHandler);
+
+	pHandler->endElement("style:style");
+
+	TagOpenElement tableHeadingStyleOpenElement("style:style");
+	tableHeadingStyleOpenElement.addAttribute("style:name", "Table_Heading");
+	tableHeadingStyleOpenElement.addAttribute("style:display-name", "Table Heading");
+	tableHeadingStyleOpenElement.addAttribute("style:family", "paragraph");
+	tableHeadingStyleOpenElement.addAttribute("style:parent-style-name", "Table_Contents");
+	tableHeadingStyleOpenElement.addAttribute("style:class", "extra");
+	tableHeadingStyleOpenElement.write(pHandler);
+
+	pHandler->endElement("style:style");
+
+	for (std::vector<DocumentElement *>::const_iterator iter = mFrameStyles.begin();
+		iter != mFrameStyles.end(); iter++)
+		(*iter)->write(pHandler);
+
+	pHandler->endElement("office:styles");
 }
 
-void DocumentCollector::_writeMasterPages(DocumentHandler *pHandler)
+void DocumentCollector::_writeMasterPages(DocumentHandlerInterface *pHandler)
 {
-        WPXPropertyList xBlankAttrList;
-
-	pHandler->startElement("office:master-styles", xBlankAttrList);
+	TagOpenElement("office:master-styles").write(mpHandler);
 	int pageNumber = 1;
 	for (unsigned int i=0; i<mPageSpans.size(); i++)
 	{
@@ -217,99 +254,118 @@
 	pHandler->endElement("office:master-styles");
 }
 
-void DocumentCollector::_writePageMasters(DocumentHandler *pHandler)
+void DocumentCollector::_writePageLayouts(DocumentHandlerInterface *pHandler)
 {
 	for (unsigned int i=0; i<mPageSpans.size(); i++)
 	{
-		mPageSpans[i]->writePageMaster(i, pHandler);
+		mPageSpans[i]->writePageLayout(i, pHandler);
 	}
 }
 
-bool DocumentCollector::_writeTargetDocument(DocumentHandler *pHandler)
-{        
+bool DocumentCollector::_writeTargetDocument(DocumentHandlerInterface *pHandler)
+{
 	WRITER_DEBUG_MSG(("WriterWordPerfect: Document Body: Printing out the header stuff..\n"));
-	WPXPropertyList xBlankAttrList;
 
 	WRITER_DEBUG_MSG(("WriterWordPerfect: Document Body: Start Document\n"));
 	mpHandler->startDocument();
 
 	WRITER_DEBUG_MSG(("WriterWordPerfect: Document Body: preamble\n"));
-        WPXPropertyList docContentPropList;
-	docContentPropList.insert("xmlns:office", "http://openoffice.org/2000/office");
-	docContentPropList.insert("xmlns:style", "http://openoffice.org/2000/style");
-	docContentPropList.insert("xmlns:text", "http://openoffice.org/2000/text");
-	docContentPropList.insert("xmlns:table", "http://openoffice.org/2000/table");
-	docContentPropList.insert("xmlns:draw", "http://openoffice.org/2000/draw");
-	docContentPropList.insert("xmlns:fo", "http://www.w3.org/1999/XSL/Format");
+	WPXPropertyList docContentPropList;
+	docContentPropList.insert("xmlns:office", "urn:oasis:names:tc:opendocument:xmlns:office:1.0");
+	docContentPropList.insert("xmlns:meta", "urn:oasis:names:tc:opendocument:xmlns:meta:1.0");
+	docContentPropList.insert("xmlns:dc", "http://purl.org/dc/elements/1.1/");
+	docContentPropList.insert("xmlns:config", "urn:oasis:names:tc:opendocument:xmlns:config:1.0");
+	docContentPropList.insert("xmlns:text", "urn:oasis:names:tc:opendocument:xmlns:text:1.0");
+	docContentPropList.insert("xmlns:table", "urn:oasis:names:tc:opendocument:xmlns:table:1.0");
+	docContentPropList.insert("xmlns:draw", "urn:oasis:names:tc:opendocument:xmlns:drawing:1.0");
+	docContentPropList.insert("xmlns:fo", "urn:oasis:names:tc:opendocument:xmlns:xsl-fo-compatible:1.0");
 	docContentPropList.insert("xmlns:xlink", "http://www.w3.org/1999/xlink");
 	docContentPropList.insert("xmlns:number", "http://openoffice.org/2000/datastyle");
-	docContentPropList.insert("xmlns:svg", "http://www.w3.org/2000/svg");
-	docContentPropList.insert("xmlns:chart", "http://openoffice.org/2000/chart");
-	docContentPropList.insert("xmlns:dr3d", "http://openoffice.org/2000/dr3d");
+	docContentPropList.insert("xmlns:svg", "urn:oasis:names:tc:opendocument:xmlns:svg-compatible:1.0");
+	docContentPropList.insert("xmlns:chart", "urn:oasis:names:tc:opendocument:xmlns:chart:1.0");
+	docContentPropList.insert("xmlns:dr3d", "urn:oasis:names:tc:opendocument:xmlns:dr3d:1.0");
 	docContentPropList.insert("xmlns:math", "http://www.w3.org/1998/Math/MathML");
-	docContentPropList.insert("xmlns:form", "http://openoffice.org/2000/form");
-	docContentPropList.insert("xmlns:script", "http://openoffice.org/2000/script");
-	docContentPropList.insert("office:class", "text");
+	docContentPropList.insert("xmlns:form", "urn:oasis:names:tc:opendocument:xmlns:form:1.0");
+	docContentPropList.insert("xmlns:script", "urn:oasis:names:tc:opendocument:xmlns:script:1.0");
+	docContentPropList.insert("xmlns:style", "urn:oasis:names:tc:opendocument:xmlns:style:1.0");
 	docContentPropList.insert("office:version", "1.0");
-        mpHandler->startElement("office:document-content", docContentPropList);
+	if (mbIsFlatXML)
+	{
+		docContentPropList.insert("office:mimetype", "application/vnd.oasis.opendocument.text");
+		mpHandler->startElement("office:document", docContentPropList);
+	}
+	else
+		mpHandler->startElement("office:document-content", docContentPropList);
+
+	// write out the metadata
+	TagOpenElement("office:meta").write(mpHandler);
+	for (std::vector<DocumentElement *>::const_iterator iterMetaData = mMetaData.begin(); iterMetaData != mMetaData.end(); iterMetaData++) {
+		(*iterMetaData)->write(mpHandler);
+	}
+	mpHandler->endElement("office:meta");
 
 	// write out the font styles
-	mpHandler->startElement("office:font-decls", xBlankAttrList);
+	TagOpenElement("office:font-face-decls").write(mpHandler);
 	for (std::map<WPXString, FontStyle *, ltstr>::iterator iterFont = mFontHash.begin(); iterFont != mFontHash.end(); iterFont++) {
 		iterFont->second->write(mpHandler);
 	}
-	TagOpenElement symbolFontOpen("style:font-decl");
+	TagOpenElement symbolFontOpen("style:font-face");
 	symbolFontOpen.addAttribute("style:name", "StarSymbol");
-	symbolFontOpen.addAttribute("fo:font-family", "StarSymbol");
+	symbolFontOpen.addAttribute("svg:font-family", "StarSymbol");
 	symbolFontOpen.addAttribute("style:font-charset", "x-symbol");
 	symbolFontOpen.write(mpHandler);
-        mpHandler->endElement("style:font-decl");
-
-	mpHandler->endElement("office:font-decls");
+	mpHandler->endElement("style:font-face");
 
+	mpHandler->endElement("office:font-face-decls");
 
  	WRITER_DEBUG_MSG(("WriterWordPerfect: Document Body: Writing out the styles..\n"));
 
 	// write default styles
 	_writeDefaultStyles(mpHandler);
 
-	mpHandler->startElement("office:automatic-styles", xBlankAttrList);
+	TagOpenElement("office:automatic-styles").write(mpHandler);
 
-	for (std::map<WPXString, ParagraphStyle *, ltstr>::iterator iterTextStyle = mTextStyleHash.begin(); 
-             iterTextStyle != mTextStyleHash.end(); iterTextStyle++) 
-        {
+	for (std::vector<DocumentElement *>::const_iterator iterFrameAutomaticStyles = mFrameAutomaticStyles.begin();
+		iterFrameAutomaticStyles != mFrameAutomaticStyles.end(); iterFrameAutomaticStyles++)
+	{
+		(*iterFrameAutomaticStyles)->write(pHandler);
+	}
+
+	for (std::map<WPXString, ParagraphStyle *, ltstr>::const_iterator iterTextStyle = mTextStyleHash.begin(); 
+	     iterTextStyle != mTextStyleHash.end(); iterTextStyle++) 
+	{
 		// writing out the paragraph styles
 		if (strcmp((iterTextStyle->second)->getName().cstr(), "Standard")) 
-                {
+		{
 			// don't write standard paragraph "no styles" style
 			(iterTextStyle->second)->write(pHandler);
 		}
 	}
 
-        // span styles..
-	for (std::map<WPXString, SpanStyle *, ltstr>::iterator iterSpanStyle = mSpanStyleHash.begin(); 
-             iterSpanStyle != mSpanStyleHash.end(); iterSpanStyle++) 
-        {
-                (iterSpanStyle->second)->write(pHandler);
+	// span styles..
+	for (std::map<WPXString, SpanStyle *, ltstr>::const_iterator iterSpanStyle = mSpanStyleHash.begin(); 
+	     iterSpanStyle != mSpanStyleHash.end(); iterSpanStyle++) 
+	{
+		(iterSpanStyle->second)->write(pHandler);
 	}
 
  	// writing out the sections styles
-	for (std::vector<SectionStyle *>::iterator iterSectionStyles = mSectionStyles.begin(); iterSectionStyles != mSectionStyles.end(); iterSectionStyles++) {
+	for (std::vector<SectionStyle *>::const_iterator iterSectionStyles = mSectionStyles.begin(); iterSectionStyles != mSectionStyles.end(); iterSectionStyles++) {
 		(*iterSectionStyles)->write(pHandler);
 	}
 
 	// writing out the lists styles
-	for (std::vector<ListStyle *>::iterator iterListStyles = mListStyles.begin(); iterListStyles != mListStyles.end(); iterListStyles++) {
+	for (std::vector<ListStyle *>::const_iterator iterListStyles = mListStyles.begin(); iterListStyles != mListStyles.end(); iterListStyles++) {
 		(*iterListStyles)->write(pHandler);
 	}
 
  	// writing out the table styles
-	for (std::vector<TableStyle *>::iterator iterTableStyles = mTableStyles.begin(); iterTableStyles != mTableStyles.end(); iterTableStyles++) {
+	for (std::vector<TableStyle *>::const_iterator iterTableStyles = mTableStyles.begin(); iterTableStyles != mTableStyles.end(); iterTableStyles++) {
 		(*iterTableStyles)->write(pHandler);
 	}
 
 	// writing out the page masters
-	_writePageMasters(pHandler);
+	_writePageLayouts(pHandler);
 
 
 	pHandler->endElement("office:automatic-styles");
@@ -318,15 +374,20 @@
 
  	WRITER_DEBUG_MSG(("WriterWordPerfect: Document Body: Writing out the document..\n"));
  	// writing out the document
-	pHandler->startElement("office:body", xBlankAttrList);
+	TagOpenElement("office:body").write(mpHandler);
+	TagOpenElement("office:text").write(mpHandler);
 
-	for (std::vector<DocumentElement *>::iterator iterBodyElements = mBodyElements.begin(); iterBodyElements != mBodyElements.end(); iterBodyElements++) {
+	for (std::vector<DocumentElement *>::const_iterator iterBodyElements = mBodyElements.begin(); iterBodyElements != mBodyElements.end(); iterBodyElements++) {
 		(*iterBodyElements)->write(pHandler);
 	}
  	WRITER_DEBUG_MSG(("WriterWordPerfect: Document Body: Finished writing all doc els..\n"));
 
+	pHandler->endElement("office:text");
 	pHandler->endElement("office:body");
-	pHandler->endElement("office:document-content");
+	if (mbIsFlatXML)
+		pHandler->endElement("office:document");
+	else
+		pHandler->endElement("office:document-content");
 
 	pHandler->endDocument();
 
@@ -336,32 +397,32 @@
 
 WPXString propListToStyleKey(const WPXPropertyList & xPropList)
 {
-        WPXString sKey;
-        WPXPropertyList::Iter i(xPropList);
-        for (i.rewind(); i.next(); )
-        {
-                WPXString sProp;
-                sProp.sprintf("[%s:%s]", i.key(), i()->getStr().cstr());
-                sKey.append(sProp);
-        }
+	WPXString sKey;
+	WPXPropertyList::Iter i(xPropList);
+	for (i.rewind(); i.next(); )
+	{
+		WPXString sProp;
+		sProp.sprintf("[%s:%s]", i.key(), i()->getStr().cstr());
+		sKey.append(sProp);
+	}
 
-        return sKey;
+	return sKey;
 }
 
 WPXString getParagraphStyleKey(const WPXPropertyList & xPropList, const WPXPropertyListVector & xTabStops)
 {
-        WPXString sKey = propListToStyleKey(xPropList);
-        
-        WPXString sTabStops;
-        sTabStops.sprintf("[num-tab-stops:%i]", xTabStops.count());
-        WPXPropertyListVector::Iter i(xTabStops);
-        for (i.rewind(); i.next();)
-        {
-                sTabStops.append(propListToStyleKey(i()));
-        }
-        sKey.append(sTabStops);
+	WPXString sKey = propListToStyleKey(xPropList);
+
+	WPXString sTabStops;
+	sTabStops.sprintf("[num-tab-stops:%i]", xTabStops.count());
+	WPXPropertyListVector::Iter i(xTabStops);
+	for (i.rewind(); i.next();)
+	{
+		sTabStops.append(propListToStyleKey(i()));
+	}
+	sKey.append(sTabStops);
 
-        return sKey;
+	return sKey;
 }
 
 // _allocateFontName: add a (potentially mapped) font style to the hash if it's not already there, do nothing otherwise
@@ -374,11 +435,29 @@
 	}
 }
 
+void DocumentCollector::setDocumentMetaData(const WPXPropertyList &propList)
+{
+        WPXPropertyList::Iter i(propList);
+        for (i.rewind(); i.next(); )
+        {
+                // filter out libwpd elements
+                if (strncmp(i.key(), "libwpd", 6) != 0 && strncmp(i.key(), "dcterms", 7) != 0)
+		{
+			mMetaData.push_back(new TagOpenElement(i.key()));
+			WPXString sStringValue(i()->getStr(), true);
+			mMetaData.push_back(new CharDataElement(sStringValue.cstr()));
+			mMetaData.push_back(new TagCloseElement(i.key()));
+		}
+        }
+
+}
+
 void DocumentCollector::openPageSpan(const WPXPropertyList &propList)
 {
 	PageSpan *pPageSpan = new PageSpan(propList);
 	mPageSpans.push_back(pPageSpan);
 	mpCurrentPageSpan = pPageSpan;
+	miNumPageStyles++;
 }
 
 void DocumentCollector::openHeader(const WPXPropertyList &propList)
@@ -386,9 +465,9 @@
 	std::vector<DocumentElement *> * pHeaderFooterContentElements = new std::vector<DocumentElement *>;
 
 	if (propList["libwpd:occurence"]->getStr() == "even")
-                mpCurrentPageSpan->setHeaderLeftContent(pHeaderFooterContentElements);
-        else
-                mpCurrentPageSpan->setHeaderContent(pHeaderFooterContentElements);
+		mpCurrentPageSpan->setHeaderLeftContent(pHeaderFooterContentElements);
+	else
+		mpCurrentPageSpan->setHeaderContent(pHeaderFooterContentElements);
 
 	mpCurrentContentElements = pHeaderFooterContentElements;
 }
@@ -403,9 +482,9 @@
 	std::vector<DocumentElement *> * pHeaderFooterContentElements = new std::vector<DocumentElement *>;
 
 	if (propList["libwpd:occurence"]->getStr() == "even")
-                mpCurrentPageSpan->setFooterLeftContent(pHeaderFooterContentElements);
-        else
-                mpCurrentPageSpan->setFooterContent(pHeaderFooterContentElements);
+		mpCurrentPageSpan->setFooterLeftContent(pHeaderFooterContentElements);
+	else
+		mpCurrentPageSpan->setFooterContent(pHeaderFooterContentElements);
 
 	mpCurrentContentElements = pHeaderFooterContentElements;
 }
@@ -417,7 +496,7 @@
 
 void DocumentCollector::openSection(const WPXPropertyList &propList, const WPXPropertyListVector &columns)
 {
-        int iNumColumns = columns.count();
+	int iNumColumns = columns.count();
 	float fSectionMarginLeft = 0.0f;
 	float fSectionMarginRight = 0.0f;
 	if (propList["fo:margin-left"])
@@ -427,38 +506,33 @@
 
 	if (iNumColumns > 1 || fSectionMarginLeft != 0 || fSectionMarginRight != 0)
 	{
-		mfSectionSpaceAfter = propList["fo:margin-bottom"]->getFloat();
+		if (propList["fo:margin-bottom"])
+			mfSectionSpaceAfter = propList["fo:margin-bottom"]->getFloat();
+		else if (propList["libwpd:margin-bottom"])
+			mfSectionSpaceAfter =  propList["libwpd:margin-bottom"]->getFloat();
+
 		WPXString sSectionName;
 		sSectionName.sprintf("Section%i", mSectionStyles.size());
-		
+
 		SectionStyle *pSectionStyle = new SectionStyle(propList, columns, sSectionName.cstr());
 		mSectionStyles.push_back(pSectionStyle);
-		
+
 		TagOpenElement *pSectionOpenElement = new TagOpenElement("text:section");
 		pSectionOpenElement->addAttribute("text:style-name", pSectionStyle->getName());
 		pSectionOpenElement->addAttribute("text:name", pSectionStyle->getName());
-		mpCurrentContentElements->push_back(static_cast<DocumentElement *>(pSectionOpenElement));
+		mpCurrentContentElements->push_back(pSectionOpenElement);
 	}
 	else
-		mWriterDocumentState.mbInFakeSection = true;
+		mWriterDocumentStates.top().mbInFakeSection = true;
 }
 
 void DocumentCollector::closeSection()
 {
-	if (!mWriterDocumentState.mbInFakeSection)
-		mpCurrentContentElements->push_back(static_cast<DocumentElement *>(new TagCloseElement("text:section")));
+	if (!mWriterDocumentStates.top().mbInFakeSection)
+		mpCurrentContentElements->push_back(new TagCloseElement("text:section"));
 	else
-		mWriterDocumentState.mbInFakeSection = false;
+		mWriterDocumentStates.top().mbInFakeSection = false;
 
-	// open as many paragraphs as needed to simulate section space after
-	// WLACH_REFACTORING: disable this for now..
-	#if 0
-	for (float f=0.0f; f<mfSectionSpaceAfter; f+=1.0f) {
-		vector<WPXTabStop> dummyTabStops;
-		openParagraph(WPX_PARAGRAPH_JUSTIFICATION_LEFT, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, dummyTabStops, false, false);
-		closeParagraph();
-	}
-	#endif
 	mfSectionSpaceAfter = 0.0f;
 }
 
@@ -466,11 +540,11 @@
 {
 	// FIXMENOW: What happens if we open a footnote inside a table? do we then inherit the footnote's style
 	// from "Table Contents"
-	
+
 	WPXPropertyList *pPersistPropList = new WPXPropertyList(propList);
 	ParagraphStyle *pStyle = NULL;
 
-	if (mWriterDocumentState.mbFirstElement && mpCurrentContentElements == &mBodyElements)
+	if (mWriterDocumentStates.top().mbFirstElement && mpCurrentContentElements == &mBodyElements)
 	{
 		// we don't have to go through the fuss of determining if the paragraph style is 
 		// unique in this case, because if we are the first document element, then we
@@ -482,31 +556,35 @@
 		sName.sprintf("FS");
 
 		WPXString sParagraphHashKey("P|FS");
-		pPersistPropList->insert("style:master-page-name", "Page Style 1");
-                pStyle = new ParagraphStyle(pPersistPropList, tabStops, sName);
+		pPersistPropList->insert("style:master-page-name", "Page_Style_1");
+		pStyle = new ParagraphStyle(pPersistPropList, tabStops, sName);
 		mTextStyleHash[sParagraphHashKey] = pStyle;
-		mWriterDocumentState.mbFirstElement = false;
+		mWriterDocumentStates.top().mbFirstElement = false;
  	}
 	else
 	{
-		if (mWriterDocumentState.mbTableCellOpened)
+//		WPXString sPageStyleName;
+//		sPageStyleName.sprintf("Page_Style_%i", miNumPageStyles);
+//		pPersistPropList->insert("style:master-page-name", sPageStyleName);
+		if (mWriterDocumentStates.top().mbTableCellOpened)
 		{
-			if (mWriterDocumentState.mbHeaderRow)
-				pPersistPropList->insert("style:parent-style-name", "Table Heading");
+			if (mWriterDocumentStates.top().mbHeaderRow)
+				pPersistPropList->insert("style:parent-style-name", "Table_Heading");
 			else
-				pPersistPropList->insert("style:parent-style-name", "Table Contents");
+				pPersistPropList->insert("style:parent-style-name", "Table_Contents");
 		}
 		else
 			pPersistPropList->insert("style:parent-style-name", "Standard");
 
-                WPXString sKey = getParagraphStyleKey(*pPersistPropList, tabStops);
+		WPXString sKey = getParagraphStyleKey(*pPersistPropList, tabStops);
 
-		if (mTextStyleHash.find(sKey) == mTextStyleHash.end()) {
+		if (mTextStyleHash.find(sKey) == mTextStyleHash.end())
+		{
 			WPXString sName;
 			sName.sprintf("S%i", mTextStyleHash.size()); 
-			
+
 			pStyle = new ParagraphStyle(pPersistPropList, tabStops, sName);
-	
+
 			mTextStyleHash[sKey] = pStyle;
 		}
 		else
@@ -518,56 +596,56 @@
 	// create a document element corresponding to the paragraph, and append it to our list of document elements
 	TagOpenElement *pParagraphOpenElement = new TagOpenElement("text:p");
 	pParagraphOpenElement->addAttribute("text:style-name", pStyle->getName());
-	mpCurrentContentElements->push_back(static_cast<DocumentElement *>(pParagraphOpenElement));
+	mpCurrentContentElements->push_back(pParagraphOpenElement);
 }
 
 void DocumentCollector::closeParagraph()
 {
-	mpCurrentContentElements->push_back(static_cast<DocumentElement *>(new TagCloseElement("text:p")));
+	mpCurrentContentElements->push_back(new TagCloseElement("text:p"));
 }
 
 void DocumentCollector::openSpan(const WPXPropertyList &propList)
 {
-        if (propList["style:font-name"])
-                _allocateFontName(propList["style:font-name"]->getStr());
+	if (propList["style:font-name"])
+		_allocateFontName(propList["style:font-name"]->getStr());
 	WPXString sSpanHashKey = propListToStyleKey(propList);
 	WRITER_DEBUG_MSG(("WriterWordPerfect: Span Hash Key: %s\n", sSpanHashKey.cstr()));
 
 	// Get the style
-        WPXString sName;
+	WPXString sName;
 	if (mSpanStyleHash.find(sSpanHashKey) == mSpanStyleHash.end())
-        {
+	{
 		// allocate a new paragraph style
 		sName.sprintf("Span%i", mSpanStyleHash.size());
-		SpanStyle *pStyle = new SpanStyle(sName.cstr(), propList);                
+		SpanStyle *pStyle = new SpanStyle(sName.cstr(), propList);
 
 		mSpanStyleHash[sSpanHashKey] = pStyle;
 	}
 	else 
-        {
+	{
 		sName.sprintf("%s", mSpanStyleHash.find(sSpanHashKey)->second->getName().cstr());
 	}
 
 	// create a document element corresponding to the paragraph, and append it to our list of document elements
 	TagOpenElement *pSpanOpenElement = new TagOpenElement("text:span");
 	pSpanOpenElement->addAttribute("text:style-name", sName.cstr());
-	mpCurrentContentElements->push_back(static_cast<DocumentElement *>(pSpanOpenElement));
+	mpCurrentContentElements->push_back(pSpanOpenElement);
 }
 
 void DocumentCollector::closeSpan()
 {
-	mpCurrentContentElements->push_back(static_cast<DocumentElement *>(new TagCloseElement("text:span")));
+	mpCurrentContentElements->push_back(new TagCloseElement("text:span"));
 }
 
 void DocumentCollector::defineOrderedListLevel(const WPXPropertyList &propList)
 {
-        int id = 0;
-        if (propList["libwpd:id"])
-                id = propList["libwpd:id"]->getInt();
+	int id = 0;
+	if (propList["libwpd:id"])
+		id = propList["libwpd:id"]->getInt();
 
  	OrderedListStyle *pOrderedListStyle = NULL;
-	if (mpCurrentListStyle && mpCurrentListStyle->getListID() == id)
-		pOrderedListStyle = static_cast<OrderedListStyle *>(mpCurrentListStyle); // FIXME: using a dynamic cast here causes oo to crash?!
+	if (mWriterListStates.top().mpCurrentListStyle && mWriterListStates.top().mpCurrentListStyle->getListID() == id)
+		pOrderedListStyle = static_cast<OrderedListStyle *>(mWriterListStates.top().mpCurrentListStyle); // FIXME: using a dynamic cast here causes oo to crash?!
 
 	// this rather appalling conditional makes sure we only start a new list (rather than continue an old
 	// one) if: (1) we have no prior list OR (2) the prior list is actually definitively different
@@ -575,168 +653,174 @@
 	// is starting a new list at level 1 (and only level 1)
 	if (pOrderedListStyle == NULL || pOrderedListStyle->getListID() != id  ||
 	    (propList["libwpd:level"] && propList["libwpd:level"]->getInt()==1 && 
-             (propList["text:start-value"] && (unsigned int)(propList["text:start-value"]->getInt()) != (miLastListNumber+1))))
+	     (propList["text:start-value"] && (unsigned)propList["text:start-value"]->getInt() != (mWriterListStates.top().miLastListNumber+1))))
 	{
 		WRITER_DEBUG_MSG(("Attempting to create a new ordered list style (listid: %i)\n", id));
 		WPXString sName;
 		sName.sprintf("OL%i", miNumListStyles);
 		miNumListStyles++;
-		pOrderedListStyle = new OrderedListStyle(sName.cstr(), propList["libwpd:id"]->getInt());
-		mListStyles.push_back(static_cast<ListStyle *>(pOrderedListStyle));
-		mpCurrentListStyle = static_cast<ListStyle *>(pOrderedListStyle);
-		mbListContinueNumbering = false;
-		miLastListNumber = 0;
+		pOrderedListStyle = new OrderedListStyle(sName.cstr(), id);
+		mListStyles.push_back(pOrderedListStyle);
+		mWriterListStates.top().mpCurrentListStyle = pOrderedListStyle;
+		mWriterListStates.top().mbListContinueNumbering = false;
+		mWriterListStates.top().miLastListNumber = 0;
 	}
 	else
-		mbListContinueNumbering = true;
+		mWriterListStates.top().mbListContinueNumbering = true;
 
 	// Iterate through ALL list styles with the same WordPerfect list id and define a level if it is not already defined
 	// This solves certain problems with lists that start and finish without reaching certain levels and then begin again
 	// and reach those levels. See gradguide0405_PC.wpd in the regression suite
 	for (std::vector<ListStyle *>::iterator iterOrderedListStyles = mListStyles.begin(); iterOrderedListStyles != mListStyles.end(); iterOrderedListStyles++)
 	{
-		if ((* iterOrderedListStyles)->getListID() == propList["libwpd:id"]->getInt())
+		if ((* iterOrderedListStyles)->getListID() == id)
 			(* iterOrderedListStyles)->updateListLevel((propList["libwpd:level"]->getInt() - 1), propList);
 	}
 }
 
 void DocumentCollector::defineUnorderedListLevel(const WPXPropertyList &propList)
 {
-        int id = 0;
-        if (propList["libwpd:id"])
-                id = propList["libwpd:id"]->getInt();
+	int id = 0;
+	if (propList["libwpd:id"])
+		id = propList["libwpd:id"]->getInt();
 
  	UnorderedListStyle *pUnorderedListStyle = NULL;
-	if (mpCurrentListStyle && mpCurrentListStyle->getListID() == id)
-		pUnorderedListStyle = static_cast<UnorderedListStyle *>(mpCurrentListStyle); // FIXME: using a dynamic cast here causes oo to crash?!
+	if (mWriterListStates.top().mpCurrentListStyle && mWriterListStates.top().mpCurrentListStyle->getListID() == id)
+		pUnorderedListStyle = static_cast<UnorderedListStyle *>(mWriterListStates.top().mpCurrentListStyle); // FIXME: using a dynamic cast here causes oo to crash?!
 
 	if (pUnorderedListStyle == NULL) {
 		WRITER_DEBUG_MSG(("Attempting to create a new unordered list style (listid: %i)\n", id));
 		WPXString sName;
 		sName.sprintf("UL%i", miNumListStyles);
+		miNumListStyles++;
 		pUnorderedListStyle = new UnorderedListStyle(sName.cstr(), id);
-		mListStyles.push_back(static_cast<ListStyle *>(pUnorderedListStyle));
-		mpCurrentListStyle = static_cast<ListStyle *>(pUnorderedListStyle);
+		mListStyles.push_back(pUnorderedListStyle);
+		mWriterListStates.top().mpCurrentListStyle = pUnorderedListStyle;
 	}
 
 	// See comment in DocumentCollector::defineOrderedListLevel
 	for (std::vector<ListStyle *>::iterator iterUnorderedListStyles = mListStyles.begin(); iterUnorderedListStyles != mListStyles.end(); iterUnorderedListStyles++)
 	{
-		if ((* iterUnorderedListStyles)->getListID() == propList["libwpd:id"]->getInt())
+		if ((* iterUnorderedListStyles)->getListID() == id)
 			(* iterUnorderedListStyles)->updateListLevel((propList["libwpd:level"]->getInt() - 1), propList);
 	}
 }
 
 void DocumentCollector::openOrderedListLevel(const WPXPropertyList & /* propList */)
 {
-	miCurrentListLevel++;
-	TagOpenElement *pListLevelOpenElement = new TagOpenElement("text:ordered-list");
+	if (mWriterListStates.top().mbListElementParagraphOpened)
+	{
+		mpCurrentContentElements->push_back(new TagCloseElement("text:p"));
+		mWriterListStates.top().mbListElementParagraphOpened = false;
+	}
+	TagOpenElement *pListLevelOpenElement = new TagOpenElement("text:list");
 	_openListLevel(pListLevelOpenElement);
 
-	if (mbListContinueNumbering) {
+	if (mWriterListStates.top().mbListContinueNumbering) {
 		pListLevelOpenElement->addAttribute("text:continue-numbering", "true");
 	}
 
-	mpCurrentContentElements->push_back(static_cast<DocumentElement *>(pListLevelOpenElement));
+	mpCurrentContentElements->push_back(pListLevelOpenElement);
 }
 
 void DocumentCollector::openUnorderedListLevel(const WPXPropertyList & /* propList */)
 {
-	miCurrentListLevel++;
-	TagOpenElement *pListLevelOpenElement = new TagOpenElement("text:unordered-list");
+	if (mWriterListStates.top().mbListElementParagraphOpened)
+	{
+		mpCurrentContentElements->push_back(new TagCloseElement("text:p"));
+		mWriterListStates.top().mbListElementParagraphOpened = false;
+	}
+	TagOpenElement *pListLevelOpenElement = new TagOpenElement("text:list");
 	_openListLevel(pListLevelOpenElement);
 
-	mpCurrentContentElements->push_back(static_cast<DocumentElement *>(pListLevelOpenElement));
+	mpCurrentContentElements->push_back(pListLevelOpenElement);
 }
 
 void DocumentCollector::_openListLevel(TagOpenElement *pListLevelOpenElement)
 {
-  	if (!mbListElementOpened && miCurrentListLevel > 1)
-  	{
-  		mpCurrentContentElements->push_back(static_cast<DocumentElement *>(new TagOpenElement("text:list-item")));
-  	}
-	else if (mbListElementParagraphOpened)
+	if (!mWriterListStates.top().mbListElementOpened.empty() &&
+		!mWriterListStates.top().mbListElementOpened.top())
 	{
-		mpCurrentContentElements->push_back(static_cast<DocumentElement *>(new TagCloseElement("text:p")));
-		mbListElementParagraphOpened = false;
+		mpCurrentContentElements->push_back(new TagOpenElement("text:list-item"));
+		mWriterListStates.top().mbListElementOpened.top() = true;
 	}
 
-	if (miCurrentListLevel==1) {
-		pListLevelOpenElement->addAttribute("text:style-name", mpCurrentListStyle->getName());
+	mWriterListStates.top().mbListElementOpened.push(false);
+	if (mWriterListStates.top().mbListElementOpened.size() == 1) {
+		pListLevelOpenElement->addAttribute("text:style-name", mWriterListStates.top().mpCurrentListStyle->getName());
 	}
-
-	mbListElementOpened = false;
 }
 
 void DocumentCollector::closeOrderedListLevel()
 {
-	_closeListLevel("ordered-list");
+	_closeListLevel();
 }
 
 void DocumentCollector::closeUnorderedListLevel()
 {
-	_closeListLevel("unordered-list");
+	_closeListLevel();
 }
 
-void DocumentCollector::_closeListLevel(const char *szListType)
+void DocumentCollector::_closeListLevel()
 {
-	if (mbListElementOpened)
-		mpCurrentContentElements->push_back(static_cast<DocumentElement *>(new TagCloseElement("text:list-item")));
-
-	miCurrentListLevel--;
+	if (mWriterListStates.top().mbListElementOpened.top())
+	{
+		mpCurrentContentElements->push_back(new TagCloseElement("text:list-item"));
+		mWriterListStates.top().mbListElementOpened.top() = false;
+	}
 
-	WPXString sCloseElement;
-	sCloseElement.sprintf("text:%s", szListType);
-	mpCurrentContentElements->push_back(static_cast<DocumentElement *>(new TagCloseElement(sCloseElement.cstr())));
+	mpCurrentContentElements->push_back(new TagCloseElement("text:list"));
 
-	if (miCurrentListLevel > 0)
-		mpCurrentContentElements->push_back(static_cast<DocumentElement *>(new TagCloseElement("text:list-item")));
-	mbListElementOpened = false;
+	if (!mWriterListStates.top().mbListElementOpened.empty())
+	{
+		mWriterListStates.top().mbListElementOpened.pop();
+	}
 }
 
 void DocumentCollector::openListElement(const WPXPropertyList &propList, const WPXPropertyListVector &tabStops)
 {
-	miLastListLevel = miCurrentListLevel;
-	if (miCurrentListLevel == 1)
-		miLastListNumber++;
+	mWriterListStates.top().miLastListLevel = mWriterListStates.top().miCurrentListLevel;
+	if (mWriterListStates.top().miCurrentListLevel == 1)
+		mWriterListStates.top().miLastListNumber++;
 
-	if (mbListElementOpened)
-		mpCurrentContentElements->push_back(static_cast<DocumentElement *>(new TagCloseElement("text:list-item")));
+	if (mWriterListStates.top().mbListElementOpened.top())
+	{
+		mpCurrentContentElements->push_back(new TagCloseElement("text:list-item"));
+		mWriterListStates.top().mbListElementOpened.top() = false;
+	}
 
 	ParagraphStyle *pStyle = NULL;
 
 	WPXPropertyList *pPersistPropList = new WPXPropertyList(propList);
-	pPersistPropList->insert("style:list-style-name", mpCurrentListStyle->getName());
+	pPersistPropList->insert("style:list-style-name", mWriterListStates.top().mpCurrentListStyle->getName());
 	pPersistPropList->insert("style:parent-style-name", "Standard");
 
-        WPXString sKey = getParagraphStyleKey(*pPersistPropList, tabStops);
+	WPXString sKey = getParagraphStyleKey(*pPersistPropList, tabStops);
 
-        if (mTextStyleHash.find(sKey) == mTextStyleHash.end()) 
-        {
-                WPXString sName;
-                sName.sprintf("S%i", mTextStyleHash.size()); 
-		
-                pStyle = new ParagraphStyle(pPersistPropList, tabStops, sName);
-                
-                mTextStyleHash[sKey] = pStyle;
-        }
-        else
-        {
-                pStyle = mTextStyleHash[sKey];
-                delete pPersistPropList;
-        }
+	if (mTextStyleHash.find(sKey) == mTextStyleHash.end()) 
+	{
+		WPXString sName;
+		sName.sprintf("S%i", mTextStyleHash.size()); 
 
-	TagOpenElement *pOpenListElement = new TagOpenElement("text:list-item");
-	TagOpenElement *pOpenListElementParagraph = new TagOpenElement("text:p");
+		pStyle = new ParagraphStyle(pPersistPropList, tabStops, sName);
+
+		mTextStyleHash[sKey] = pStyle;
+	}
+	else
+	{
+		pStyle = mTextStyleHash[sKey];
+		delete pPersistPropList;
+	}
+
+	mpCurrentContentElements->push_back(new TagOpenElement("text:list-item"));
 
+	TagOpenElement *pOpenListElementParagraph = new TagOpenElement("text:p");
 	pOpenListElementParagraph->addAttribute("text:style-name", pStyle->getName());
+	mpCurrentContentElements->push_back(pOpenListElementParagraph);
 
-	mpCurrentContentElements->push_back(static_cast<DocumentElement *>(pOpenListElement));
-	mpCurrentContentElements->push_back(static_cast<DocumentElement *>(pOpenListElementParagraph));
-		
-	mbListElementOpened = true;
-	mbListElementParagraphOpened = true;
-	mbListContinueNumbering = false;
+	mWriterListStates.top().mbListElementOpened.top() = true;
+	mWriterListStates.top().mbListElementParagraphOpened = true;
+	mWriterListStates.top().mbListContinueNumbering = false;
 }
 
 void DocumentCollector::closeListElement()
@@ -745,183 +829,234 @@
 	// could contain another list level in OOo's implementation of lists). that is done in the closeListLevel
 	// code (or when we open another list element)
 
-	if (mbListElementParagraphOpened)
+	if (mWriterListStates.top().mbListElementParagraphOpened)
 	{
-		mpCurrentContentElements->push_back(static_cast<DocumentElement *>(new TagCloseElement("text:p")));
-		mbListElementParagraphOpened = false;
+		mpCurrentContentElements->push_back(new TagCloseElement("text:p"));
+		mWriterListStates.top().mbListElementParagraphOpened = false;
 	}
 }
 
 void DocumentCollector::openFootnote(const WPXPropertyList &propList)
 {
-	TagOpenElement *pOpenFootNote = new TagOpenElement("text:footnote");
+	mWriterListStates.push(WriterListState());
+	TagOpenElement *pOpenFootNote = new TagOpenElement("text:note");
+	pOpenFootNote->addAttribute("text:note-class", "footnote");
 	if (propList["libwpd:number"])
 	{
 		WPXString tmpString("ftn");
 		tmpString.append(propList["libwpd:number"]->getStr());
 		pOpenFootNote->addAttribute("text:id", tmpString);
 	}
-	mpCurrentContentElements->push_back(static_cast<DocumentElement *>(pOpenFootNote));
+	mpCurrentContentElements->push_back(pOpenFootNote);
+
+	mpCurrentContentElements->push_back(new TagOpenElement("text:note-citation"));
+	if (propList["libwpd:number"])
+		mpCurrentContentElements->push_back(new CharDataElement(propList["libwpd:number"]->getStr().cstr()));
+	mpCurrentContentElements->push_back(new TagCloseElement("text:note-citation"));
+
+	mpCurrentContentElements->push_back(new TagOpenElement("text:note-body"));
 
-	mpCurrentContentElements->push_back(static_cast<DocumentElement *>(new TagOpenElement("text:footnote-citation")));
-        if (propList["libwpd:number"])
-                mpCurrentContentElements->push_back(static_cast<DocumentElement *>(new CharDataElement(propList["libwpd:number"]->getStr().cstr())));
-	mpCurrentContentElements->push_back(static_cast<DocumentElement *>(new TagCloseElement("text:footnote-citation")));
-
-	mpCurrentContentElements->push_back(static_cast<DocumentElement *>(new TagOpenElement("text:footnote-body")));
-	
-	mWriterDocumentState.mbInNote = true;
+	mWriterDocumentStates.top().mbInNote = true;
 }
 
 void DocumentCollector::closeFootnote()
 {
-	mWriterDocumentState.mbInNote = false;
+	mWriterDocumentStates.top().mbInNote = false;
+	if (mWriterListStates.size() > 1)
+		mWriterListStates.pop();
 
-	mpCurrentContentElements->push_back(static_cast<DocumentElement *>(new TagCloseElement("text:footnote-body")));
-	mpCurrentContentElements->push_back(static_cast<DocumentElement *>(new TagCloseElement("text:footnote")));
+	mpCurrentContentElements->push_back(new TagCloseElement("text:note-body"));
+	mpCurrentContentElements->push_back(new TagCloseElement("text:note"));
 }
 
 void DocumentCollector::openEndnote(const WPXPropertyList &propList)
 {
-	TagOpenElement *pOpenEndNote = new TagOpenElement("text:endnote");
+	mWriterListStates.push(WriterListState());
+	TagOpenElement *pOpenEndNote = new TagOpenElement("text:note");
+	pOpenEndNote->addAttribute("text:note-class", "endnote");
 	if (propList["libwpd:number"])
 	{
 		WPXString tmpString("edn");
 		tmpString.append(propList["libwpd:number"]->getStr());
 		pOpenEndNote->addAttribute("text:id", tmpString);
 	}
-	mpCurrentContentElements->push_back(static_cast<DocumentElement *>(pOpenEndNote));
+	mpCurrentContentElements->push_back(pOpenEndNote);
 
-	mpCurrentContentElements->push_back(static_cast<DocumentElement *>(new TagOpenElement("text:endnote-citation")));
-        if (propList["libwpd:number"])
-                mpCurrentContentElements->push_back(static_cast<DocumentElement *>(new CharDataElement(propList["libwpd:number"]->getStr().cstr())));
-	mpCurrentContentElements->push_back(static_cast<DocumentElement *>(new TagCloseElement("text:endnote-citation")));
+	mpCurrentContentElements->push_back(new TagOpenElement("text:note-citation"));
+	if (propList["libwpd:number"])
+		mpCurrentContentElements->push_back(new CharDataElement(propList["libwpd:number"]->getStr().cstr()));
+	mpCurrentContentElements->push_back(new TagCloseElement("text:note-citation"));
 
-	mpCurrentContentElements->push_back(static_cast<DocumentElement *>(new TagOpenElement("text:endnote-body")));
+	mpCurrentContentElements->push_back(new TagOpenElement("text:note-body"));
 
+	mWriterDocumentStates.top().mbInNote = true;
 }
+
 void DocumentCollector::closeEndnote()
 {
-	mpCurrentContentElements->push_back(static_cast<DocumentElement *>(new TagCloseElement("text:endnote-body")));
-	mpCurrentContentElements->push_back(static_cast<DocumentElement *>(new TagCloseElement("text:endnote")));
+	mWriterDocumentStates.top().mbInNote = false;
+	if (mWriterListStates.size() > 1)
+		mWriterListStates.pop();
+
+	mpCurrentContentElements->push_back(new TagCloseElement("text:note-body"));
+	mpCurrentContentElements->push_back(new TagCloseElement("text:note"));
 }
 
-void DocumentCollector::openTable(const WPXPropertyList &propList, const WPXPropertyListVector &columns)
+void DocumentCollector::openComment(const WPXPropertyList & /* propList */)
 {
-	WPXString sTableName;
-	sTableName.sprintf("Table%i", mTableStyles.size());
+	mWriterListStates.push(WriterListState());
+	mpCurrentContentElements->push_back(new TagOpenElement("office:annotation"));
 
-	// FIXME: we base the table style off of the page's margin left, ignoring (potential) wordperfect margin
-	// state which is transmitted inside the page. could this lead to unacceptable behaviour?
-        // WLACH_REFACTORING: characterize this behaviour, probably should nip it at the bud within libwpd
-	TableStyle *pTableStyle = new TableStyle(propList, columns, sTableName.cstr());
+	mWriterDocumentStates.top().mbInNote = true;
+}
+
+void DocumentCollector::closeComment()
+{
+	mWriterDocumentStates.top().mbInNote = false;
+	if (mWriterListStates.size() > 1)
+		mWriterListStates.pop();
 
-	if (mWriterDocumentState.mbFirstElement && mpCurrentContentElements == &mBodyElements)
+	mpCurrentContentElements->push_back(new TagCloseElement("office:annotation"));
+}
+
+void DocumentCollector::openTable(const WPXPropertyList &propList, const WPXPropertyListVector &columns)
+{
+	if (!mWriterDocumentStates.top().mbInNote)
 	{
-		WPXString sMasterPageName("Page Style 1");
-		pTableStyle->setMasterPageName(sMasterPageName);
-		mWriterDocumentState.mbFirstElement = false;
-	}
+		WPXString sTableName;
+		sTableName.sprintf("Table%i", mTableStyles.size());
 
-	mTableStyles.push_back(pTableStyle);
+		// FIXME: we base the table style off of the page's margin left, ignoring (potential) wordperfect margin
+		// state which is transmitted inside the page. could this lead to unacceptable behaviour?
+		// WLACH_REFACTORING: characterize this behaviour, probably should nip it at the bud within libwpd
+		TableStyle *pTableStyle = new TableStyle(propList, columns, sTableName.cstr());
 
-	mpCurrentTableStyle = pTableStyle;
+		if (mWriterDocumentStates.top().mbFirstElement && mpCurrentContentElements == &mBodyElements)
+		{
+			WPXString sMasterPageName("Page_Style_1");
+			pTableStyle->setMasterPageName(sMasterPageName);
+			mWriterDocumentStates.top().mbFirstElement = false;
+		}
 
-	TagOpenElement *pTableOpenElement = new TagOpenElement("table:table");
+		mTableStyles.push_back(pTableStyle);
 
-	pTableOpenElement->addAttribute("table:name", sTableName.cstr());
-	pTableOpenElement->addAttribute("table:style-name", sTableName.cstr());
-	mpCurrentContentElements->push_back(static_cast<DocumentElement *>(pTableOpenElement));
+		mpCurrentTableStyle = pTableStyle;
 
-	for (int i=0; i<pTableStyle->getNumColumns(); i++) 
-        {
-		TagOpenElement *pTableColumnOpenElement = new TagOpenElement("table:table-column");
-		WPXString sColumnStyleName;
-		sColumnStyleName.sprintf("%s.Column%i", sTableName.cstr(), (i+1));
-		pTableColumnOpenElement->addAttribute("table:style-name", sColumnStyleName.cstr());
-		mpCurrentContentElements->push_back(pTableColumnOpenElement);
+		TagOpenElement *pTableOpenElement = new TagOpenElement("table:table");
 
-		TagCloseElement *pTableColumnCloseElement = new TagCloseElement("table:table-column");
-		mpCurrentContentElements->push_back(pTableColumnCloseElement);
+		pTableOpenElement->addAttribute("table:name", sTableName.cstr());
+		pTableOpenElement->addAttribute("table:style-name", sTableName.cstr());
+		mpCurrentContentElements->push_back(pTableOpenElement);
+
+		for (int i=0; i<pTableStyle->getNumColumns(); i++) 
+		{
+			TagOpenElement *pTableColumnOpenElement = new TagOpenElement("table:table-column");
+			WPXString sColumnStyleName;
+			sColumnStyleName.sprintf("%s.Column%i", sTableName.cstr(), (i+1));
+			pTableColumnOpenElement->addAttribute("table:style-name", sColumnStyleName.cstr());
+			mpCurrentContentElements->push_back(pTableColumnOpenElement);
+
+			TagCloseElement *pTableColumnCloseElement = new TagCloseElement("table:table-column");
+			mpCurrentContentElements->push_back(pTableColumnCloseElement);
+		}
 	}
 }
 
 void DocumentCollector::openTableRow(const WPXPropertyList &propList)
 {
-	if (propList["libwpd:is-header-row"] && (propList["libwpd:is-header-row"]->getInt()))
+	if (!mWriterDocumentStates.top().mbInNote)
 	{
-		mpCurrentContentElements->push_back(static_cast<DocumentElement *>(new TagOpenElement("table:table-header-rows")));
-		mWriterDocumentState.mbHeaderRow = true;
-	}
+		if (propList["libwpd:is-header-row"] && (propList["libwpd:is-header-row"]->getInt()))
+		{
+			mpCurrentContentElements->push_back(new TagOpenElement("table:table-header-rows"));
+			mWriterDocumentStates.top().mbHeaderRow = true;
+		}
 
-	WPXString sTableRowStyleName;
-	sTableRowStyleName.sprintf("%s.Row%i", mpCurrentTableStyle->getName().cstr(), mpCurrentTableStyle->getNumTableRowStyles());
-	TableRowStyle *pTableRowStyle = new TableRowStyle(propList, sTableRowStyleName.cstr());
-	mpCurrentTableStyle->addTableRowStyle(pTableRowStyle);
-	
-	TagOpenElement *pTableRowOpenElement = new TagOpenElement("table:table-row");
-	pTableRowOpenElement->addAttribute("table:style-name", sTableRowStyleName);
-	mpCurrentContentElements->push_back(static_cast<DocumentElement *>(pTableRowOpenElement));
+		WPXString sTableRowStyleName;
+		sTableRowStyleName.sprintf("%s.Row%i", mpCurrentTableStyle->getName().cstr(), mpCurrentTableStyle->getNumTableRowStyles());
+		TableRowStyle *pTableRowStyle = new TableRowStyle(propList, sTableRowStyleName.cstr());
+		mpCurrentTableStyle->addTableRowStyle(pTableRowStyle);
+
+		TagOpenElement *pTableRowOpenElement = new TagOpenElement("table:table-row");
+		pTableRowOpenElement->addAttribute("table:style-name", sTableRowStyleName);
+		mpCurrentContentElements->push_back(pTableRowOpenElement);
+	}
 }
 
 void DocumentCollector::closeTableRow()
 {
-	mpCurrentContentElements->push_back(static_cast<DocumentElement *>(new TagCloseElement("table:table-row")));
-	if (mWriterDocumentState.mbHeaderRow)
+	if (!mWriterDocumentStates.top().mbInNote)
 	{
-		mpCurrentContentElements->push_back(static_cast<DocumentElement *>(new TagCloseElement("table:table-header-rows")));
-		mWriterDocumentState.mbHeaderRow = false;
+		mpCurrentContentElements->push_back(new TagCloseElement("table:table-row"));
+		if (mWriterDocumentStates.top().mbHeaderRow)
+		{
+			mpCurrentContentElements->push_back(new TagCloseElement("table:table-header-rows"));
+			mWriterDocumentStates.top().mbHeaderRow = false;
+		}
 	}
 }
 
 void DocumentCollector::openTableCell(const WPXPropertyList &propList)
 {
-	WPXString sTableCellStyleName;
-	sTableCellStyleName.sprintf( "%s.Cell%i", mpCurrentTableStyle->getName().cstr(), mpCurrentTableStyle->getNumTableCellStyles());
-	TableCellStyle *pTableCellStyle = new TableCellStyle(propList, sTableCellStyleName.cstr());
-	mpCurrentTableStyle->addTableCellStyle(pTableCellStyle);
-
-	TagOpenElement *pTableCellOpenElement = new TagOpenElement("table:table-cell");
-	pTableCellOpenElement->addAttribute("table:style-name", sTableCellStyleName);
-	if (propList["table:number-columns-spanned"])
-                pTableCellOpenElement->addAttribute("table:number-columns-spanned", 
-                                                    propList["table:number-columns-spanned"]->getStr().cstr());
-        if (propList["table:number-rows-spanned"])
-                pTableCellOpenElement->addAttribute("table:number-rows-spanned",
-                                                    propList["table:number-rows-spanned"]->getStr().cstr());
-	pTableCellOpenElement->addAttribute("table:value-type", "string");
-	mpCurrentContentElements->push_back(static_cast<DocumentElement *>(pTableCellOpenElement));
+	if (!mWriterDocumentStates.top().mbInNote)
+	{
+		WPXString sTableCellStyleName;
+		sTableCellStyleName.sprintf( "%s.Cell%i", mpCurrentTableStyle->getName().cstr(), mpCurrentTableStyle->getNumTableCellStyles());
+		TableCellStyle *pTableCellStyle = new TableCellStyle(propList, sTableCellStyleName.cstr());
+		mpCurrentTableStyle->addTableCellStyle(pTableCellStyle);
+
+		TagOpenElement *pTableCellOpenElement = new TagOpenElement("table:table-cell");
+		pTableCellOpenElement->addAttribute("table:style-name", sTableCellStyleName);
+		if (propList["table:number-columns-spanned"])
+			pTableCellOpenElement->addAttribute("table:number-columns-spanned", 
+							    propList["table:number-columns-spanned"]->getStr().cstr());
+		if (propList["table:number-rows-spanned"])
+			pTableCellOpenElement->addAttribute("table:number-rows-spanned",
+							    propList["table:number-rows-spanned"]->getStr().cstr());
+		// pTableCellOpenElement->addAttribute("table:value-type", "string");
+		mpCurrentContentElements->push_back(pTableCellOpenElement);
 
-	mWriterDocumentState.mbTableCellOpened = true;
+		mWriterDocumentStates.top().mbTableCellOpened = true;
+	}
 }
 
 void DocumentCollector::closeTableCell()
 {
-	mpCurrentContentElements->push_back(static_cast<DocumentElement *>(new TagCloseElement("table:table-cell")));
-	mWriterDocumentState.mbTableCellOpened = false;
+	if (!mWriterDocumentStates.top().mbInNote)
+	{
+		mpCurrentContentElements->push_back(new TagCloseElement("table:table-cell"));
+		mWriterDocumentStates.top().mbTableCellOpened = false;
+	}
 }
 
 void DocumentCollector::insertCoveredTableCell(const WPXPropertyList & /* propList */)
 {
-	mpCurrentContentElements->push_back(static_cast<DocumentElement *>(new TagOpenElement("table:covered-table-cell")));
-	mpCurrentContentElements->push_back(static_cast<DocumentElement *>(new TagCloseElement("table:covered-table-cell")));
+	if (!mWriterDocumentStates.top().mbInNote)
+	{
+		mpCurrentContentElements->push_back(new TagOpenElement("table:covered-table-cell"));
+		mpCurrentContentElements->push_back(new TagCloseElement("table:covered-table-cell"));
+	}
 }
 
 void DocumentCollector::closeTable()
 {
-	mpCurrentContentElements->push_back(static_cast<DocumentElement *>(new TagCloseElement("table:table")));
+	if (!mWriterDocumentStates.top().mbInNote)
+	{
+		mpCurrentContentElements->push_back(new TagCloseElement("table:table"));
+	}
 }
 
+
 void DocumentCollector::insertTab()
 {
-	mpCurrentContentElements->push_back(static_cast<DocumentElement *>(new TagOpenElement("text:tab-stop")));
-	mpCurrentContentElements->push_back(static_cast<DocumentElement *>(new TagCloseElement("text:tab-stop")));
+	mpCurrentContentElements->push_back(new TagOpenElement("text:tab"));
+	mpCurrentContentElements->push_back(new TagCloseElement("text:tab"));
 }
 
 void DocumentCollector::insertLineBreak()
 {
-	mpCurrentContentElements->push_back(static_cast<DocumentElement *>(new TagOpenElement("text:line-break")));
-	mpCurrentContentElements->push_back(static_cast<DocumentElement *>(new TagCloseElement("text:line-break")));
+	mpCurrentContentElements->push_back(new TagOpenElement("text:line-break"));
+	mpCurrentContentElements->push_back(new TagCloseElement("text:line-break"));
 }
 
 void DocumentCollector::insertText(const WPXString &text)
@@ -929,3 +1064,223 @@
 	DocumentElement *pText = new TextElement(text);
 	mpCurrentContentElements->push_back(pText);
 }
+
+void DocumentCollector::openFrame(const WPXPropertyList &propList)
+{
+	mWriterListStates.push(WriterListState());
+
+	// First, let's create a Frame Style for this box
+	TagOpenElement *frameStyleOpenElement = new TagOpenElement("style:style");
+	WPXString frameStyleName;
+	frameStyleName.sprintf("GraphicFrame_%i", miObjectNumber);
+	frameStyleOpenElement->addAttribute("style:name", frameStyleName);
+	frameStyleOpenElement->addAttribute("style:family", "graphic");
+
+	mFrameStyles.push_back(frameStyleOpenElement);
+
+	TagOpenElement *frameStylePropertiesOpenElement = new TagOpenElement("style:graphic-properties");
+
+	if (propList["text:anchor-type"])
+		frameStylePropertiesOpenElement->addAttribute("text:anchor-type", propList["text:anchor-type"]->getStr());
+	else
+		frameStylePropertiesOpenElement->addAttribute("text:anchor-type","paragraph");
+
+	if (propList["text:anchor-page-number"])
+		frameStylePropertiesOpenElement->addAttribute("text:anchor-page-number", propList["text:anchor-page-number"]->getStr());
+
+	if (propList["svg:x"])
+		frameStylePropertiesOpenElement->addAttribute("svg:x", propList["svg:x"]->getStr());
+
+	if (propList["svg:y"])
+		frameStylePropertiesOpenElement->addAttribute("svg:y", propList["svg:y"]->getStr());
+
+	if (propList["svg:width"])
+		frameStylePropertiesOpenElement->addAttribute("svg:width", propList["svg:width"]->getStr());
+
+	if (propList["svg:height"])
+		frameStylePropertiesOpenElement->addAttribute("svg:height", propList["svg:height"]->getStr());
+
+	if (propList["style:rel-width"])
+		frameStylePropertiesOpenElement->addAttribute("style:rel-width", propList["style:rel-width"]->getStr());
+
+	if (propList["style:rel-height"])
+		frameStylePropertiesOpenElement->addAttribute("style:rel-height", propList["style:rel-height"]->getStr());
+
+	if (propList["fo:max-width"])
+		frameStylePropertiesOpenElement->addAttribute("fo:max-width", propList["fo:max-width"]->getStr());
+
+	if (propList["fo:max-height"])
+		frameStylePropertiesOpenElement->addAttribute("fo:max-height", propList["fo:max-height"]->getStr());
+
+	if (propList["style:wrap"])
+		frameStylePropertiesOpenElement->addAttribute("style:wrap", propList["style:wrap"]->getStr());
+ 
+	mFrameStyles.push_back(frameStylePropertiesOpenElement);
+
+	mFrameStyles.push_back(new TagCloseElement("style:graphic-properties"));
+
+	mFrameStyles.push_back(new TagCloseElement("style:style"));
+
+	// Now, let's create an automatic style for this frame
+	TagOpenElement *frameAutomaticStyleElement = new TagOpenElement("style:style");
+	WPXString frameAutomaticStyleName;
+	frameAutomaticStyleName.sprintf("fr%i", miObjectNumber);
+	frameAutomaticStyleElement->addAttribute("style:name", frameAutomaticStyleName);
+	frameAutomaticStyleElement->addAttribute("style:family", "graphic");
+	frameAutomaticStyleElement->addAttribute("style:parent-style-name", frameStyleName);
+
+	mFrameAutomaticStyles.push_back(frameAutomaticStyleElement);
+
+	TagOpenElement *frameAutomaticStylePropertiesElement = new TagOpenElement("style:graphic-properties");
+	if (propList["style:horizontal-pos"])
+		frameAutomaticStylePropertiesElement->addAttribute("style:horizontal-pos", propList["style:horizontal-pos"]->getStr());
+	else
+		frameAutomaticStylePropertiesElement->addAttribute("style:horizontal-pos", "left");
+
+	if (propList["style:horizontal-rel"])
+		frameAutomaticStylePropertiesElement->addAttribute("style:horizontal-rel", propList["style:horizontal-rel"]->getStr());
+	else
+		frameAutomaticStylePropertiesElement->addAttribute("style:horizontal-rel", "paragraph");
+
+	if (propList["style:vertical-pos"])
+		frameAutomaticStylePropertiesElement->addAttribute("style:vertical-pos", propList["style:vertical-pos"]->getStr());
+	else
+		frameAutomaticStylePropertiesElement->addAttribute("style:vertical-pos", "top");
+
+	if (propList["style:vertical-rel"])
+		frameAutomaticStylePropertiesElement->addAttribute("style:vertical-rel", propList["style:vertical-rel"]->getStr());
+	else
+		frameAutomaticStylePropertiesElement->addAttribute("style:vertical-rel", "page-content");
+
+	if (propList["fo:max-width"])
+		frameAutomaticStylePropertiesElement->addAttribute("fo:max-width", propList["fo:max-width"]->getStr());
+
+	if (propList["fo:max-height"])
+		frameAutomaticStylePropertiesElement->addAttribute("fo:max-height", propList["fo:max-height"]->getStr());
+
+	if (propList["style:wrap"])
+		frameAutomaticStylePropertiesElement->addAttribute("style:wrap", propList["style:wrap"]->getStr());
+ 
+	frameAutomaticStylePropertiesElement->addAttribute("draw:ole-draw-aspect", "1");
+
+	mFrameAutomaticStyles.push_back(frameAutomaticStylePropertiesElement);
+
+	mFrameAutomaticStyles.push_back(new TagCloseElement("style:graphic-properties"));
+
+	mFrameAutomaticStyles.push_back(new TagCloseElement("style:style"));
+
+	// And write the frame itself
+	TagOpenElement *drawFrameOpenElement = new TagOpenElement("draw:frame");
+
+	drawFrameOpenElement->addAttribute("draw:style-name", frameAutomaticStyleName);
+	WPXString objectName;
+	objectName.sprintf("Object%i", miObjectNumber++);
+	drawFrameOpenElement->addAttribute("draw:name", objectName);
+	if (propList["text:anchor-type"])
+		drawFrameOpenElement->addAttribute("text:anchor-type", propList["text:anchor-type"]->getStr());
+	else
+		drawFrameOpenElement->addAttribute("text:anchor-type","paragraph");
+
+	if (propList["text:anchor-page-number"])
+		drawFrameOpenElement->addAttribute("text:anchor-page-number", propList["text:anchor-page-number"]->getStr());
+
+	if (propList["svg:x"])
+		drawFrameOpenElement->addAttribute("svg:x", propList["svg:x"]->getStr());
+
+	if (propList["svg:y"])
+		drawFrameOpenElement->addAttribute("svg:y", propList["svg:y"]->getStr());
+
+	if (propList["svg:width"])
+		drawFrameOpenElement->addAttribute("svg:width", propList["svg:width"]->getStr());
+
+	if (propList["svg:height"])
+		drawFrameOpenElement->addAttribute("svg:height", propList["svg:height"]->getStr());
+
+	if (propList["style:rel-width"])
+		drawFrameOpenElement->addAttribute("style:rel-width", propList["style:rel-width"]->getStr());
+
+	if (propList["style:rel-height"])
+		drawFrameOpenElement->addAttribute("style:rel-height", propList["style:rel-height"]->getStr());
+
+	mpCurrentContentElements->push_back(drawFrameOpenElement);
+
+	mWriterDocumentStates.top().mbInFrame = true;
+}
+
+void DocumentCollector::closeFrame()
+{
+	if (mWriterListStates.size() > 1)
+		mWriterListStates.pop();
+
+	mpCurrentContentElements->push_back(new TagCloseElement("draw:frame"));
+
+	mWriterDocumentStates.top().mbInFrame = false;
+}
+
+void DocumentCollector::insertBinaryObject(const WPXPropertyList &propList, const WPXBinaryData &object)
+{
+	if (!object.size())
+		return;
+	if (!mWriterDocumentStates.top().mbInFrame) // Embedded objects without a frame simply don't make sense for us
+		return;
+	if (!propList["libwpd:mimetype"])
+		return;
+
+	if (propList["libwpd:mimetype"]->getStr() == "image/x-wpg")
+	{
+		std::vector<DocumentElement *> tmpContentElements;
+		InternalHandler tmpHandler(&tmpContentElements);
+		OdgExporter exporter(&tmpHandler, true);
+		
+		libwpg::WPGFileFormat fileFormat = libwpg::WPG_AUTODETECT;
+		
+		if (!libwpg::WPGraphics::isSupported(const_cast<WPXInputStream *>(object.getDataStream())))
+			fileFormat = libwpg::WPG_WPG1;
+
+		if (libwpg::WPGraphics::parse(const_cast<WPXInputStream *>(object.getDataStream()), &exporter, fileFormat) && !tmpContentElements.empty())
+		{
+			mpCurrentContentElements->push_back(new TagOpenElement("draw:object"));
+			for (std::vector<DocumentElement *>::const_iterator iter = tmpContentElements.begin(); iter != tmpContentElements.end(); iter++)
+				mpCurrentContentElements->push_back(*iter);
+			mpCurrentContentElements->push_back(new TagCloseElement("draw:object"));
+		}
+	}
+	else
+	{
+		mpCurrentContentElements->push_back(new TagOpenElement("draw:image"));
+		
+		mpCurrentContentElements->push_back(new TagOpenElement("office:binary-data"));
+		
+		WPXString binaryBase64Data = object.getBase64Data();
+		
+		mpCurrentContentElements->push_back(new CharDataElement(binaryBase64Data.cstr()));
+		
+		mpCurrentContentElements->push_back(new TagCloseElement("office:binary-data"));
+		
+		mpCurrentContentElements->push_back(new TagCloseElement("draw:image"));
+	}
+}
+
+void DocumentCollector::openTextBox(const WPXPropertyList & /* propList */)
+{
+	if (!mWriterDocumentStates.top().mbInFrame) // Text box without a frame simply doesn't make sense for us
+		return;
+	mWriterListStates.push(WriterListState());
+	mWriterDocumentStates.push(WriterDocumentState());
+	mpCurrentContentElements->push_back(new TagOpenElement("draw:text-box"));
+	mWriterDocumentStates.top().mbInTextBox = true;
+	mWriterDocumentStates.top().mbFirstElement = false;
+}
+
+void DocumentCollector::closeTextBox()
+{
+	if (!mWriterDocumentStates.top().mbInTextBox)
+		return;
+	if (mWriterListStates.size() > 1)
+		mWriterListStates.pop();
+	if (mWriterDocumentStates.size() > 1)
+		mWriterDocumentStates.pop();
+
+	mpCurrentContentElements->push_back(new TagCloseElement("draw:text-box"));
+}
+
diff -u -r -N writerperfect//source/filter/DocumentCollector.hxx writerperfect//source/filter/DocumentCollector.hxx
--- writerperfect//source/filter/DocumentCollector.hxx	2008-11-17 22:06:28.000000000 +0100
+++ writerperfect//source/filter/DocumentCollector.hxx	2008-11-17 23:31:21.000000000 +0100
@@ -45,8 +45,9 @@
 #include <stack>
 #include <string.h>
 
+#include "DocumentHandlerInterface.hxx"
+
 class DocumentElement;
-class DocumentHandler;
 class TagOpenElement;
 class FontStyle;
 class ListStyle;
@@ -61,33 +62,50 @@
 struct _WriterDocumentState
 {
 	_WriterDocumentState();
-
+		
 	bool mbFirstElement;
 	bool mbInFakeSection;
 	bool mbListElementOpenedAtCurrentLevel;
 	bool mbTableCellOpened;
 	bool mbHeaderRow;
 	bool mbInNote;
+	bool mbInTextBox;
+	bool mbInFrame;
+};
+
+// list state
+typedef struct _WriterListState WriterListState;
+struct _WriterListState
+{
+	_WriterListState();
+
+	ListStyle *mpCurrentListStyle;
+	unsigned int miCurrentListLevel;
+	unsigned int miLastListLevel;
+	unsigned int miLastListNumber;
+	bool mbListContinueNumbering;
+	bool mbListElementParagraphOpened;
+	std::stack<bool> mbListElementOpened;
 };
 
 enum WriterListType { unordered, ordered };
 
 struct ltstr
 {
-  bool operator()(const WPXString & s1, const WPXString & s2) const
-  {
-    return strcmp(s1.cstr(), s2.cstr()) < 0;
-  }
+	bool operator()(const WPXString & s1, const WPXString & s2) const
+	{
+		return strcmp(s1.cstr(), s2.cstr()) < 0;
+	}
 };
 
-class DocumentCollector : public WPXHLListenerImpl
+class DocumentCollector : public WPXDocumentInterface
 {
 public:
-	DocumentCollector(WPSInputStream *pInput, DocumentHandler *pHandler);
+	DocumentCollector(WPXInputStream *pInput, DocumentHandlerInterface *pHandler);
 	virtual ~DocumentCollector();
 	bool filter();
 
- 	virtual void setDocumentMetaData(const WPXPropertyList & /* propList */) {}
+ 	virtual void setDocumentMetaData(const WPXPropertyList &propList);
 	virtual void startDocument() {}
 	virtual void endDocument() {}
 
@@ -126,6 +144,10 @@
 	virtual void closeFootnote();
 	virtual void openEndnote(const WPXPropertyList &propList);
 	virtual void closeEndnote();
+	virtual void openComment(const WPXPropertyList &propList);
+	virtual void closeComment();
+	virtual void openTextBox(const WPXPropertyList &propList);
+	virtual void closeTextBox();
 
  	virtual void openTable(const WPXPropertyList &propList, const WPXPropertyListVector &columns);
  	virtual void openTableRow(const WPXPropertyList &propList);
@@ -134,25 +156,33 @@
 	virtual void closeTableCell();
 	virtual void insertCoveredTableCell(const WPXPropertyList &propList);
  	virtual void closeTable();
-	virtual bool parseSourceDocument(WPSInputStream &input) = 0;
+
+	virtual void openFrame(const WPXPropertyList & propList);
+	virtual void closeFrame();
+	
+	virtual void insertBinaryObject(const WPXPropertyList &propList, const WPXBinaryData &object);
+
+	virtual bool parseSourceDocument(WPXInputStream &input) = 0;
 
 protected:
 	void _resetDocumentState();
-	bool _writeTargetDocument(DocumentHandler *pHandler);
-	void _writeDefaultStyles(DocumentHandler *pHandler);
-	void _writeMasterPages(DocumentHandler *pHandler);
-	void _writePageMasters(DocumentHandler *pHandler);
+	bool _writeTargetDocument(DocumentHandlerInterface *pHandler);
+	void _writeDefaultStyles(DocumentHandlerInterface *pHandler);
+	void _writeMasterPages(DocumentHandlerInterface *pHandler);
+	void _writePageLayouts(DocumentHandlerInterface *pHandler);
 	void _allocateFontName(const WPXString &);
 
 private:
 	void _openListLevel(TagOpenElement *pListLevelOpenElement);
-	void _closeListLevel(const char *szListType);
+	void _closeListLevel();
 
-        WPSInputStream *mpInput;
-        DocumentHandler *mpHandler;
+	WPXInputStream *mpInput;
+	DocumentHandlerInterface *mpHandler;
 	bool mbUsed; // whether or not it has been before (you can only use me once!)
 
-	WriterDocumentState mWriterDocumentState;
+	std::stack<WriterDocumentState> mWriterDocumentStates;
+	
+	std::stack<WriterListState> mWriterListStates;
 
 	// paragraph styles
 	std::map<WPXString, ParagraphStyle *, ltstr> mTextStyleHash;
@@ -169,10 +199,18 @@
 
 	// table styles
 	std::vector<TableStyle *> mTableStyles;
+	
+	// frame styles
+	std::vector<DocumentElement *> mFrameStyles;
+	
+	std::vector<DocumentElement *> mFrameAutomaticStyles;
+	
+	// metadata
+	std::vector<DocumentElement *> mMetaData;
 
 	// list styles
 	unsigned int miNumListStyles;
-
+	
 	// style elements
 	std::vector<DocumentElement *> mStylesElements;
 	// content elements
@@ -185,18 +223,18 @@
 	PageSpan *mpCurrentPageSpan;
 	int miNumPageStyles;
 
-	// list styles / state
-	ListStyle *mpCurrentListStyle;
-	unsigned int miCurrentListLevel;
-	unsigned int miLastListLevel;
-	unsigned int miLastListNumber;
+	// list styles
 	std::vector<ListStyle *> mListStyles;
-	bool mbListContinueNumbering;
-	bool mbListElementOpened;
-	bool mbListElementParagraphOpened;
+	
+	// object state
+	unsigned miObjectNumber;
 
 	// table state
 	TableStyle *mpCurrentTableStyle;
+
+	const bool mbIsFlatXML;
+	
+	const char * mpPassword;
 };
 
 #endif
diff -u -r -N writerperfect//source/filter/DocumentElement.cxx writerperfect//source/filter/DocumentElement.cxx
--- writerperfect//source/filter/DocumentElement.cxx	2008-11-17 22:06:28.000000000 +0100
+++ writerperfect//source/filter/DocumentElement.cxx	2008-11-17 22:07:19.000000000 +0100
@@ -26,6 +26,7 @@
  */
 
 #include "DocumentElement.hxx"
+#include "DocumentHandler.hxx"
 #include "FilterInternal.hxx"
 #include <string.h>
 
@@ -36,7 +37,7 @@
 	WRITER_DEBUG_MSG(("%s\n", msTagName.cstr()));
 }
 
-void TagOpenElement::write(DocumentHandler *pHandler) const
+void TagOpenElement::write(DocumentHandlerInterface *pHandler) const
 {
 	pHandler->startElement(getTagName().cstr(), maAttrList);
 }
@@ -51,14 +52,14 @@
         maAttrList.insert(szAttributeName, sAttributeValue);
 }
 
-void TagCloseElement::write(DocumentHandler *pHandler) const
+void TagCloseElement::write(DocumentHandlerInterface *pHandler) const
 {
 	WRITER_DEBUG_MSG(("TagCloseElement: write (%s)\n", getTagName().cstr()));
 
 	pHandler->endElement(getTagName().cstr());
 }
 
-void CharDataElement::write(DocumentHandler *pHandler) const
+void CharDataElement::write(DocumentHandlerInterface *pHandler) const
 {
 	WRITER_DEBUG_MSG(("TextElement: write\n"));
 	pHandler->characters(msData);
@@ -71,8 +72,10 @@
 
 // write: writes a text run, appropriately converting spaces to <text:s>
 // elements
-void TextElement::write(DocumentHandler *pHandler) const
+void TextElement::write(DocumentHandlerInterface *pHandler) const
 {
+	if (msTextBuf.len() <= 0)
+		return;
 	WPXPropertyList xBlankAttrList;
         
 	WPXString sTemp;
diff -u -r -N writerperfect//source/filter/DocumentElement.hxx writerperfect//source/filter/DocumentElement.hxx
--- writerperfect//source/filter/DocumentElement.hxx	2008-11-17 22:06:28.000000000 +0100
+++ writerperfect//source/filter/DocumentElement.hxx	2008-11-17 22:07:19.000000000 +0100
@@ -21,36 +21,31 @@
  *
  */
 
-/* "This product is not manufactured, approved, or supported by
+/* "This product is not manufactured, approved, or supported by 
  * Corel Corporation or Corel Corporation Limited."
  */
 
 #ifndef _DOCUMENTELEMENT_H
 #define _DOCUMENTELEMENT_H
-#if defined _MSC_VER
-#pragma warning( push, 1 )
-#endif
 #include <libwpd/libwpd.h>
 #include <libwpd/WPXProperty.h>
 #include <libwpd/WPXString.h>
-#if defined _MSC_VER
-#pragma warning( pop )
-#endif
 #include <vector>
 
-#include "DocumentHandler.hxx"
+#include "DocumentHandlerInterface.hxx"
 
 class DocumentElement
 {
-public:
+public:	
 	virtual ~DocumentElement() {}
-	virtual void write(DocumentHandler *pHandler) const = 0;
+	virtual void write(DocumentHandlerInterface *pHandler) const = 0;
 	virtual void print() const {}
 };
 
 class TagElement : public DocumentElement
 {
 public:
+	virtual ~TagElement() {}
 	TagElement(const char *szTagName) : msTagName(szTagName) {}
 	const WPXString & getTagName() const { return msTagName; }
 	virtual void print() const;
@@ -62,9 +57,9 @@
 {
 public:
 	TagOpenElement(const char *szTagName) : TagElement(szTagName) {}
-	~TagOpenElement() {}
+	virtual ~TagOpenElement() {}
 	void addAttribute(const char *szAttributeName, const WPXString &sAttributeValue);
-	virtual void write(DocumentHandler *pHandler) const;
+	virtual void write(DocumentHandlerInterface *pHandler) const;
 	virtual void print () const;
 private:
 	WPXPropertyList maAttrList;
@@ -74,14 +69,16 @@
 {
 public:
 	TagCloseElement(const char *szTagName) : TagElement(szTagName) {}
-	virtual void write(DocumentHandler *pHandler) const;
+	virtual ~TagCloseElement() {}
+	virtual void write(DocumentHandlerInterface *pHandler) const;
 };
 
 class CharDataElement : public DocumentElement
 {
 public:
 	CharDataElement(const char *sData) : DocumentElement(), msData(sData) {}
-	virtual void write(DocumentHandler *pHandler) const;
+	virtual ~CharDataElement() {}
+	virtual void write(DocumentHandlerInterface *pHandler) const;
 private:
 	WPXString msData;
 };
@@ -90,10 +87,11 @@
 {
 public:
 	TextElement(const WPXString & sTextBuf);
-	virtual void write(DocumentHandler *pHandler) const;
+	virtual ~TextElement() {}
+	virtual void write(DocumentHandlerInterface *pHandler) const;
 
 private:
 	WPXString msTextBuf;
 };
-
+ 
 #endif
diff -u -r -N writerperfect//source/filter/DocumentHandler.hxx writerperfect//source/filter/DocumentHandler.hxx
--- writerperfect//source/filter/DocumentHandler.hxx	2008-11-17 22:06:28.000000000 +0100
+++ writerperfect//source/filter/DocumentHandler.hxx	2008-11-17 22:07:19.000000000 +0100
@@ -11,10 +11,12 @@
 #pragma warning( pop )
 #endif
 
+#include "DocumentHandlerInterface.hxx"
+
 using com::sun::star::uno::Reference;
 using com::sun::star::xml::sax::XDocumentHandler;
 
-class DocumentHandler
+class DocumentHandler: public DocumentHandlerInterface
 {
 public:
         DocumentHandler(Reference < XDocumentHandler > &xHandler);
diff -u -r -N writerperfect//source/filter/DocumentHandlerInterface.hxx writerperfect//source/filter/DocumentHandlerInterface.hxx
--- writerperfect//source/filter/DocumentHandlerInterface.hxx	1970-01-01 01:00:00.000000000 +0100
+++ writerperfect//source/filter/DocumentHandlerInterface.hxx	2008-11-17 22:07:19.000000000 +0100
@@ -0,0 +1,45 @@
+/*
+ * Copyright (C) 2004 William Lachance (wlach@interlog.com)
+ * Copyright (C) 2004 Net Integration Technologies (http://www.net-itech.com)
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
+ * 02111-1307, USA.
+ *
+ *  Contributor(s): Martin Gallwey (gallwey@sun.com)
+ *
+ */
+
+/* "This product is not manufactured, approved, or supported by
+ * Corel Corporation or Corel Corporation Limited."
+ */
+#ifndef _DOCUMENTHANDLERINTERFACE_H
+#define _DOCUMENTHANDLERINTERFACE_H
+#include <libwpd/libwpd.h>
+#include <libwpd/WPXProperty.h>
+#include <libwpd/WPXString.h>
+
+class DocumentHandlerInterface
+{
+public:
+	DocumentHandlerInterface() {};
+	virtual ~DocumentHandlerInterface() {};
+	
+        virtual void startDocument() = 0;
+        virtual void endDocument() = 0;
+        virtual void startElement(const char *psName, const WPXPropertyList &xPropList) = 0;
+        virtual void endElement(const char *psName) = 0;
+        virtual void characters(const WPXString &sCharacters) = 0;
+};
+#endif
diff -u -r -N writerperfect//source/filter/FontStyle.cxx writerperfect//source/filter/FontStyle.cxx
--- writerperfect//source/filter/FontStyle.cxx	2008-11-17 22:06:28.000000000 +0100
+++ writerperfect//source/filter/FontStyle.cxx	2008-11-17 22:07:19.000000000 +0100
@@ -29,7 +29,7 @@
 #include "DocumentElement.hxx"
 
 FontStyle::FontStyle(const char *psName, const char *psFontFamily) : Style(psName),
-	msFontFamily(psFontFamily),
+	msFontFamily(psFontFamily, true),
 	msFontPitch(IMP_DEFAULT_FONT_PITCH)
 {
 }
@@ -38,13 +38,13 @@
 {
 }
 
-void FontStyle::write(DocumentHandler *pHandler) const
+void FontStyle::write(DocumentHandlerInterface *pHandler) const
 {        
-	TagOpenElement styleOpen("style:font-decl");
+	TagOpenElement styleOpen("style:font-face");
 	styleOpen.addAttribute("style:name", getName());
-	styleOpen.addAttribute("fo:font-family", msFontFamily);
-	styleOpen.addAttribute("style:font-pitch", msFontPitch);
+	styleOpen.addAttribute("svg:font-family", msFontFamily);
+//	styleOpen.addAttribute("style:font-pitch", msFontPitch);
 	styleOpen.write(pHandler);
-	TagCloseElement styleClose("style:font-decl");
+	TagCloseElement styleClose("style:font-face");
 	styleClose.write(pHandler);
 }
diff -u -r -N writerperfect//source/filter/FontStyle.hxx writerperfect//source/filter/FontStyle.hxx
--- writerperfect//source/filter/FontStyle.hxx	2008-11-17 22:06:28.000000000 +0100
+++ writerperfect//source/filter/FontStyle.hxx	2008-11-17 22:07:19.000000000 +0100
@@ -21,28 +21,23 @@
  *
  */
 
-/* "This product is not manufactured, approved, or supported by
+/* "This product is not manufactured, approved, or supported by 
  * Corel Corporation or Corel Corporation Limited."
  */
 #ifndef _FONTSTYLE_H
 #define _FONTSTYLE_H
-#if defined _MSC_VER
-#pragma warning( push, 1 )
-#endif
 #include <libwpd/libwpd.h>
-#if defined _MSC_VER
-#pragma warning( pop )
-#endif
 
 #include "Style.hxx"
 #include "WriterProperties.hxx"
+#include "DocumentHandlerInterface.hxx"
 
 class FontStyle : public Style
 {
 public:
 	FontStyle(const char *psName, const char *psFontFamily);
 	~FontStyle();
-	virtual void write(DocumentHandler *pHandler) const;
+	virtual void write(DocumentHandlerInterface *pHandler) const;
 	const WPXString &getFontFamily() const { return msFontFamily; }
 
 private:
diff -u -r -N writerperfect//source/filter/GraphicsStyle.cxx writerperfect//source/filter/GraphicsStyle.cxx
--- writerperfect//source/filter/GraphicsStyle.cxx	1970-01-01 01:00:00.000000000 +0100
+++ writerperfect//source/filter/GraphicsStyle.cxx	2008-11-17 22:07:19.000000000 +0100
@@ -0,0 +1,40 @@
+/* GraphicsStyle:
+ *
+ * Copyright (C) 2007 Fridrich Strba .strba@bluewin.ch)
+ * 
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ *
+ * For further information visit http://libwpd.sourceforge.net
+ *
+ */
+
+/* "This product is not manufactured, approved, or supported by 
+ * Corel Corporation or Corel Corporation Limited."
+ */
+#include "GraphicsStyle.hxx"
+#include "WriterProperties.hxx"
+#include "DocumentElement.hxx"
+
+GraphicsStyle::GraphicsStyle(const char *psName) : Style(psName)
+{
+}
+
+GraphicsStyle::~GraphicsStyle() 
+{
+}
+
+void GraphicsStyle::write(DocumentHandlerInterface * /* pHandler */) const
+{        
+}
diff -u -r -N writerperfect//source/filter/GraphicsStyle.hxx writerperfect//source/filter/GraphicsStyle.hxx
--- writerperfect//source/filter/GraphicsStyle.hxx	1970-01-01 01:00:00.000000000 +0100
+++ writerperfect//source/filter/GraphicsStyle.hxx	2008-11-17 22:07:19.000000000 +0100
@@ -0,0 +1,40 @@
+/* GraphicsStyle:
+ *
+ * Copyright (C) 2007 Fridrich Strba .strba@bluewin.ch)
+ * 
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ *
+ * For further information visit http://libwpd.sourceforge.net
+ *
+ */
+
+/* "This product is not manufactured, approved, or supported by 
+ * Corel Corporation or Corel Corporation Limited."
+ */
+#ifndef _GRAPHICSSTYLE_H
+#define _GRAPHICSSTYLE_H
+
+#include "Style.hxx"
+#include "WriterProperties.hxx"
+#include "DocumentHandlerInterface.hxx"
+
+class GraphicsStyle : public Style
+{
+public:
+	GraphicsStyle(const char *psName);
+	~GraphicsStyle();
+	virtual void write(DocumentHandlerInterface *pHandler) const;
+};
+#endif
diff -u -r -N writerperfect//source/filter/InternalHandler.cxx writerperfect//source/filter/InternalHandler.cxx
--- writerperfect//source/filter/InternalHandler.cxx	1970-01-01 01:00:00.000000000 +0100
+++ writerperfect//source/filter/InternalHandler.cxx	2008-11-17 22:07:19.000000000 +0100
@@ -0,0 +1,54 @@
+/*
+ * Copyright (C) 2007 Fridrich Strba .strba@bluewin.ch)
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
+ * 02111-1307, USA.
+ */
+
+/* "This product is not manufactured, approved, or supported by
+ * Corel Corporation or Corel Corporation Limited."
+ */
+ 
+#include "InternalHandler.hxx"
+
+#include <string.h>
+
+InternalHandler::InternalHandler(std::vector<DocumentElement *> *elements):
+	mpElements(elements)
+{
+}
+
+void InternalHandler::startElement(const char *psName, const WPXPropertyList &xPropList)
+{
+	TagOpenElement	*element = new TagOpenElement(psName);
+	WPXPropertyList::Iter i(xPropList);
+	for (i.rewind(); i.next(); )
+	{
+		// filter out libwpd elements
+		if (strncmp(i.key(), "libwpd", 6) != 0)
+			element->addAttribute(i.key(), i()->getStr());
+	}
+	mpElements->push_back(element);
+}
+
+void InternalHandler::endElement(const char *psName)
+{
+	mpElements->push_back(new TagCloseElement(psName));
+}
+
+void InternalHandler::characters(const WPXString &sCharacters)
+{
+	mpElements->push_back(new CharDataElement(sCharacters.cstr()));
+}
diff -u -r -N writerperfect//source/filter/InternalHandler.hxx writerperfect//source/filter/InternalHandler.hxx
--- writerperfect//source/filter/InternalHandler.hxx	1970-01-01 01:00:00.000000000 +0100
+++ writerperfect//source/filter/InternalHandler.hxx	2008-11-17 22:07:19.000000000 +0100
@@ -0,0 +1,46 @@
+/*
+ * Copyright (C) 2007 Fridrich Strba .strba@bluewin.ch)
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
+ * 02111-1307, USA.
+ */
+
+/* "This product is not manufactured, approved, or supported by
+ * Corel Corporation or Corel Corporation Limited."
+ */
+ 
+#ifndef _INTERNALHANDLER_H
+#define _INTERNALHANDLER_H
+#include <libwpd/libwpd.h>
+#include <libwpd/WPXProperty.h>
+#include <libwpd/WPXString.h>
+#include "DocumentElement.hxx"
+#include "DocumentHandlerInterface.hxx"
+
+class InternalHandler : public DocumentHandlerInterface
+{
+public:
+	InternalHandler(std::vector<DocumentElement *> *elements);
+	~InternalHandler() {};
+	
+	void startDocument() {};
+	void endDocument() {};
+	void startElement(const char *psName, const WPXPropertyList &xPropList);
+	void endElement(const char *psName);
+	void characters(const WPXString &sCharacters);
+private:
+	std::vector<DocumentElement *> *mpElements;
+};
+#endif
diff -u -r -N writerperfect//source/filter/ListStyle.cxx writerperfect//source/filter/ListStyle.cxx
--- writerperfect//source/filter/ListStyle.cxx	2008-11-17 22:06:28.000000000 +0100
+++ writerperfect//source/filter/ListStyle.cxx	2008-11-17 22:07:19.000000000 +0100
@@ -29,7 +29,7 @@
 #include "DocumentElement.hxx"
 
 OrderedListLevelStyle::OrderedListLevelStyle(const WPXPropertyList &xPropList) : 
-        mPropList(xPropList)
+	mPropList(xPropList)
 {
 }
 
@@ -41,34 +41,44 @@
 	    setListLevel(iLevel, new OrderedListLevelStyle(xPropList));
 }
 
-void OrderedListLevelStyle::write(DocumentHandler *pHandler, int iLevel) const
+void OrderedListLevelStyle::write(DocumentHandlerInterface *pHandler, int iLevel) const
 {
 	WPXString sLevel;
 	sLevel.sprintf("%i", (iLevel+1));
 
 	TagOpenElement listLevelStyleOpen("text:list-level-style-number");
 	listLevelStyleOpen.addAttribute("text:level", sLevel);
-	listLevelStyleOpen.addAttribute("text:style-name", "Numbering Symbols");
-        if (mPropList["style:num-prefix"])
-                listLevelStyleOpen.addAttribute("style:num-prefix", mPropList["style:num-prefix"]->getStr());
-        if (mPropList["style:num-suffix"])
-                listLevelStyleOpen.addAttribute("style:num-suffix", mPropList["style:num-suffix"]->getStr());
-        if (mPropList["style:num-format"])
-                listLevelStyleOpen.addAttribute("style:num-format", mPropList["style:num-format"]->getStr());
-        if (mPropList["text:start-value"])
-                listLevelStyleOpen.addAttribute("text:start-value", mPropList["text:start-value"]->getStr());
+	listLevelStyleOpen.addAttribute("text:style-name", "Numbering_Symbols");
+	if (mPropList["style:num-prefix"])
+	{
+		WPXString sEscapedString(mPropList["style:num-prefix"]->getStr(), true);
+		listLevelStyleOpen.addAttribute("style:num-prefix", sEscapedString);
+	}
+	if (mPropList["style:num-suffix"])
+	{
+		WPXString sEscapedString(mPropList["style:num-suffix"]->getStr(), true);
+		listLevelStyleOpen.addAttribute("style:num-suffix", sEscapedString);
+	}
+	if (mPropList["style:num-format"])
+		listLevelStyleOpen.addAttribute("style:num-format", mPropList["style:num-format"]->getStr());
+	if (mPropList["text:start-value"])
+		// odf as to the version 1.1 does require the text:start-value to be a positive integer, means > 0
+		if (mPropList["text:start-value"]->getInt() > 0)
+			listLevelStyleOpen.addAttribute("text:start-value", mPropList["text:start-value"]->getStr());
+		else
+			listLevelStyleOpen.addAttribute("text:start-value", "1");
 	listLevelStyleOpen.write(pHandler);
 
-	TagOpenElement stylePropertiesOpen("style:properties");
-        if (mPropList["text:space-before"])
-                stylePropertiesOpen.addAttribute("text:space-before", mPropList["text:space-before"]->getStr());
-	if (mPropList["text:min-label-width"])
+	TagOpenElement stylePropertiesOpen("style:list-level-properties");
+	if (mPropList["text:space-before"] && mPropList["text:space-before"]->getFloat() > 0.0f)
+		stylePropertiesOpen.addAttribute("text:space-before", mPropList["text:space-before"]->getStr());
+	if (mPropList["text:min-label-width"] && mPropList["text:min-label-width"]->getFloat() > 0.0f)
 		stylePropertiesOpen.addAttribute("text:min-label-width", mPropList["text:min-label-width"]->getStr());
-	if (mPropList["text:min-label-distance"])
+	if (mPropList["text:min-label-distance"] && mPropList["text:min-label-distance"]->getFloat() > 0.0f)
 		stylePropertiesOpen.addAttribute("text:min-label-distance", mPropList["text:min-label-distance"]->getStr());
 	stylePropertiesOpen.write(pHandler);
 
-	pHandler->endElement("style:properties");
+	pHandler->endElement("style:list-level-properties");
 	pHandler->endElement("text:list-level-style-number");
 }
 
@@ -85,29 +95,38 @@
 		setListLevel(iLevel, new UnorderedListLevelStyle(xPropList));
 }
 
-void UnorderedListLevelStyle::write(DocumentHandler *pHandler, int iLevel) const
+void UnorderedListLevelStyle::write(DocumentHandlerInterface *pHandler, int iLevel) const
 {
 	WPXString sLevel;
 	sLevel.sprintf("%i", (iLevel+1));
 	TagOpenElement listLevelStyleOpen("text:list-level-style-bullet");
 	listLevelStyleOpen.addAttribute("text:level", sLevel);
-	listLevelStyleOpen.addAttribute("text:style-name", "Bullet Symbols");
-	listLevelStyleOpen.addAttribute("style:num-suffice", ".");
-        if (mPropList["text:bullet-char"])
-                listLevelStyleOpen.addAttribute("text:bullet-char", mPropList["text:bullet-char"]->getStr());
+	listLevelStyleOpen.addAttribute("text:style-name", "Bullet_Symbols");
+	if (mPropList["text:bullet-char"] && (mPropList["text:bullet-char"]->getStr().len()))
+	{
+		// The following is needed because the odf format does not accept bullet chars longer than one character
+		WPXString::Iter i(mPropList["text:bullet-char"]->getStr()); i.rewind();
+		WPXString sEscapedString(".");
+		if (i.next())
+			sEscapedString = WPXString(i(), true);
+		listLevelStyleOpen.addAttribute("text:bullet-char", sEscapedString);
+		
+	}
+	else
+		listLevelStyleOpen.addAttribute("text:bullet-char", ".");
 	listLevelStyleOpen.write(pHandler);
 
-	TagOpenElement stylePropertiesOpen("style:properties");
-        if (mPropList["text:space-before"])
-                stylePropertiesOpen.addAttribute("text:space-before", mPropList["text:space-before"]->getStr());
-	if (mPropList["text:min-label-width"])
+	TagOpenElement stylePropertiesOpen("style:list-level-properties");
+	if (mPropList["text:space-before"] && mPropList["text:space-before"]->getFloat() > 0.0f)
+		stylePropertiesOpen.addAttribute("text:space-before", mPropList["text:space-before"]->getStr());
+	if (mPropList["text:min-label-width"] && mPropList["text:min-label-width"]->getFloat() > 0.0f)
 		stylePropertiesOpen.addAttribute("text:min-label-width", mPropList["text:min-label-width"]->getStr());
-	if (mPropList["text:min-label-distance"])
+	if (mPropList["text:min-label-distance"] && mPropList["text:min-label-distance"]->getFloat() > 0.0f)
 		stylePropertiesOpen.addAttribute("text:min-label-distance", mPropList["text:min-label-distance"]->getStr());
 	stylePropertiesOpen.addAttribute("style:font-name", "OpenSymbol");
 	stylePropertiesOpen.write(pHandler);
 
-	pHandler->endElement("style:properties");
+	pHandler->endElement("style:list-level-properties");
 	pHandler->endElement("text:list-level-style-bullet");
 }
 
@@ -146,7 +165,7 @@
 		mppListLevels[iLevel] = iListLevelStyle;
 }
 
-void ListStyle::write(DocumentHandler *pHandler) const
+void ListStyle::write(DocumentHandlerInterface *pHandler) const
 {
 	TagOpenElement listStyleOpenElement("text:list-style");
 	listStyleOpenElement.addAttribute("style:name", getName());
diff -u -r -N writerperfect//source/filter/ListStyle.hxx writerperfect//source/filter/ListStyle.hxx
--- writerperfect//source/filter/ListStyle.hxx	2008-11-17 22:06:28.000000000 +0100
+++ writerperfect//source/filter/ListStyle.hxx	2008-11-17 22:07:19.000000000 +0100
@@ -21,23 +21,18 @@
  *
  */
 
-/* "This product is not manufactured, approved, or supported by
+/* "This product is not manufactured, approved, or supported by 
  * Corel Corporation or Corel Corporation Limited."
  */
 #ifndef _LISTSTYLE_H
 #define _LISTSTYLE_H
-#if defined _MSC_VER
-#pragma warning( push, 1 )
-#endif
 #include <libwpd/libwpd.h>
-#if defined _MSC_VER
-#pragma warning( pop )
-#endif
 
 #define WP6_NUM_LIST_LEVELS 8 // see WP6FileStructure.h (we shouldn't need to reference this)
 
 #include "Style.hxx"
 #include "WriterProperties.hxx"
+#include "DocumentHandlerInterface.hxx"
 
 class DocumentElement;
 
@@ -45,14 +40,14 @@
 {
 public:
 	virtual ~ListLevelStyle() {};
-	virtual void write(DocumentHandler *pHandler, int iLevel) const = 0;
+	virtual void write(DocumentHandlerInterface *pHandler, int iLevel) const = 0;
 };
 
 class OrderedListLevelStyle : public ListLevelStyle
 {
 public:
 	OrderedListLevelStyle(const WPXPropertyList &xPropList);
-	void write(DocumentHandler *pHandler, int iLevel) const;
+	void write(DocumentHandlerInterface *pHandler, int iLevel) const;
 private:
         WPXPropertyList mPropList;
 };
@@ -61,7 +56,7 @@
 {
 public:
 	UnorderedListLevelStyle(const WPXPropertyList &xPropList);
-	void write(DocumentHandler *pHandler, int iLevel) const;
+	void write(DocumentHandlerInterface *pHandler, int iLevel) const;
 private:
         WPXPropertyList mPropList;
 };
@@ -72,7 +67,7 @@
 	ListStyle(const char *psName, const int iListID);
 	virtual ~ListStyle();
 	virtual void updateListLevel(const int iLevel, const WPXPropertyList &xPropList) = 0;
-	virtual void write(DocumentHandler *pHandler) const;
+	virtual void write(DocumentHandlerInterface *pHandler) const;
 	int getListID() const { return miListID; }
 	bool isListLevelDefined(int iLevel) const;
 
diff -u -r -N writerperfect//source/filter/makefile.mk writerperfect//source/filter/makefile.mk
--- writerperfect//source/filter/makefile.mk	2008-11-17 22:06:28.000000000 +0100
+++ writerperfect//source/filter/makefile.mk	2008-11-17 22:07:19.000000000 +0100
@@ -10,6 +10,10 @@
 INCPRE+=$(LIBWPD_CFLAGS)
 .ENDIF
 
+.IF "$(SYSTEM_LIBWPG)" == "YES"
+INCPRE+=$(LIBWPG_CFLAGS)
+.ENDIF
+
 .IF "$(SYSTEM_LIBWPS)" == "YES"
 INCPRE+=$(LIBWPS_CFLAGS)
 .ENDIF
@@ -18,14 +22,17 @@
 INCPRE+= -I..
 
 SLOFILES= \
-	$(SLO)$/DocumentElement.obj		\
-	$(SLO)$/FontStyle.obj			\
-	$(SLO)$/ListStyle.obj			\
-	$(SLO)$/DocumentHandler.obj		\
-	$(SLO)$/PageSpan.obj			\
-	$(SLO)$/SectionStyle.obj		\
-	$(SLO)$/TableStyle.obj			\
-	$(SLO)$/TextRunStyle.obj 		\
-	$(SLO)$/DocumentCollector.obj
+	$(SLO)$/DocumentCollector.obj \
+	$(SLO)$/DocumentElement.obj \
+	$(SLO)$/DocumentHandler.obj \
+	$(SLO)$/FontStyle.obj \
+	$(SLO)$/GraphicsStyle.obj \
+	$(SLO)$/InternalHandler.obj \
+	$(SLO)$/ListStyle.obj \
+	$(SLO)$/OdgExporter.obj \
+	$(SLO)$/PageSpan.obj \
+	$(SLO)$/SectionStyle.obj \
+	$(SLO)$/TableStyle.obj \
+	$(SLO)$/TextRunStyle.obj
 
 .INCLUDE :  target.mk
diff -u -r -N writerperfect//source/filter/OdgExporter.cxx writerperfect//source/filter/OdgExporter.cxx
--- writerperfect//source/filter/OdgExporter.cxx	1970-01-01 01:00:00.000000000 +0100
+++ writerperfect//source/filter/OdgExporter.cxx	2008-11-17 22:07:19.000000000 +0100
@@ -0,0 +1,647 @@
+/* libwpg
+ * Copyright (C) 2006 Ariya Hidayat (ariya@kde.org)
+ * Copyright (C) 2006 Fridrich Strba .strba@bluewin.ch)
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the 
+ * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, 
+ * Boston, MA  02111-1301 USA
+ *
+ * For further information visit http://libwpg.sourceforge.net
+ */
+
+/* "This product is not manufactured, approved, or supported by
+ * Corel Corporation or Corel Corporation Limited."
+ */
+
+#include "OdgExporter.hxx"
+#include "DocumentElement.hxx"
+#include "DocumentHandlerInterface.hxx"
+#include <locale.h>
+#include <math.h>
+#include <string>
+
+#ifndef M_PI
+#define M_PI 3.14159265358979323846
+#endif
+
+OdgExporter::OdgExporter(DocumentHandlerInterface *pHandler, const bool isFlatXML):
+	mpHandler(pHandler),
+	mxFillRule(AlternatingFill),
+	miGradientIndex(1),
+	miDashIndex(1), 
+	miGraphicsStyleIndex(1),
+	mfWidth(0.0f),
+	mfHeight(0.0f),
+	mbIsFlatXML(isFlatXML)
+{
+}
+
+OdgExporter::~OdgExporter()
+{
+
+	for (std::vector<DocumentElement *>::iterator iterBody = mBodyElements.begin(); iterBody != mBodyElements.end(); iterBody++)
+	{
+		delete (*iterBody);
+		(*iterBody) = NULL;
+	}
+
+	for (std::vector<DocumentElement *>::iterator iterGraphicsAutomaticStyles = mGraphicsAutomaticStyles.begin();
+		iterGraphicsAutomaticStyles != mGraphicsAutomaticStyles.end(); iterGraphicsAutomaticStyles++)
+	{
+		delete((*iterGraphicsAutomaticStyles));
+	}
+
+	for (std::vector<DocumentElement *>::iterator iterGraphicsStrokeDashStyles = mGraphicsStrokeDashStyles.begin();
+		iterGraphicsStrokeDashStyles != mGraphicsStrokeDashStyles.end(); iterGraphicsStrokeDashStyles++)
+	{
+		delete((*iterGraphicsStrokeDashStyles));
+	}
+
+	for (std::vector<DocumentElement *>::iterator iterGraphicsGradientStyles = mGraphicsGradientStyles.begin();
+		iterGraphicsGradientStyles != mGraphicsGradientStyles.end(); iterGraphicsGradientStyles++)
+	{
+		delete((*iterGraphicsGradientStyles));
+	}
+}
+
+void OdgExporter::startGraphics(double width, double height)
+{
+	miGradientIndex = 1;
+	miDashIndex = 1;
+	miGraphicsStyleIndex = 1;
+	mfWidth = width;
+	mfHeight = height;
+
+	mpHandler->startDocument();
+	TagOpenElement tmpOfficeDocumentContent("office:document");
+	tmpOfficeDocumentContent.addAttribute("xmlns:office", "urn:oasis:names:tc:opendocument:xmlns:office:1.0");
+	tmpOfficeDocumentContent.addAttribute("xmlns:style", "urn:oasis:names:tc:opendocument:xmlns:style:1.0");
+	tmpOfficeDocumentContent.addAttribute("xmlns:text", "urn:oasis:names:tc:opendocument:xmlns:text:1.0");
+	tmpOfficeDocumentContent.addAttribute("xmlns:draw", "urn:oasis:names:tc:opendocument:xmlns:drawing:1.0");
+	tmpOfficeDocumentContent.addAttribute("xmlns:dc", "http://purl.org/dc/elements/1.1/");
+	tmpOfficeDocumentContent.addAttribute("xmlns:svg", "urn:oasis:names:tc:opendocument:xmlns:svg-compatible:1.0");
+	tmpOfficeDocumentContent.addAttribute("xmlns:fo", "urn:oasis:names:tc:opendocument:xmlns:xsl-fo-compatible:1.0");
+	tmpOfficeDocumentContent.addAttribute("xmlns:config", "urn:oasis:names:tc:opendocument:xmlns:config:1.0");
+	tmpOfficeDocumentContent.addAttribute("xmlns:ooo", "http://openoffice.org/2004/office");
+	tmpOfficeDocumentContent.addAttribute("office:version", "1.0");
+	if (mbIsFlatXML)
+		tmpOfficeDocumentContent.addAttribute("office:mimetype", "application/vnd.oasis.opendocument.graphics");	
+	tmpOfficeDocumentContent.write(mpHandler);
+	
+	TagOpenElement("office:settings").write(mpHandler);
+	
+	TagOpenElement configItemSetOpenElement("config:config-item-set");
+	configItemSetOpenElement.addAttribute("config:name", "ooo:view-settings");
+	configItemSetOpenElement.write(mpHandler);
+	
+	TagOpenElement configItemOpenElement("config:config-item");
+
+	configItemOpenElement.addAttribute("config:name", "VisibleAreaTop");
+	configItemOpenElement.addAttribute("config:type", "int");
+	configItemOpenElement.write(mpHandler);
+	mpHandler->characters("0");
+	mpHandler->endElement("config:config-item");
+	
+	configItemOpenElement.addAttribute("config:name", "VisibleAreaLeft");
+	configItemOpenElement.addAttribute("config:type", "int");
+	configItemOpenElement.write(mpHandler);
+	mpHandler->characters("0");
+	mpHandler->endElement("config:config-item");
+	
+	configItemOpenElement.addAttribute("config:name", "VisibleAreaWidth");
+	configItemOpenElement.addAttribute("config:type", "int");
+	configItemOpenElement.write(mpHandler);
+	WPXString sWidth; sWidth.sprintf("%li", (unsigned long)(2540 * width));
+	mpHandler->characters(sWidth);
+	mpHandler->endElement("config:config-item");
+	
+	configItemOpenElement.addAttribute("config:name", "VisibleAreaHeight");
+	configItemOpenElement.addAttribute("config:type", "int");
+	configItemOpenElement.write(mpHandler);
+	WPXString sHeight; sHeight.sprintf("%li", (unsigned long)(2540 * height));
+	mpHandler->characters(sHeight);
+	mpHandler->endElement("config:config-item");
+	
+	mpHandler->endElement("config:config-item-set");
+	
+	mpHandler->endElement("office:settings");
+}
+
+void OdgExporter::endGraphics()
+{
+	TagOpenElement("office:styles").write(mpHandler);
+
+	for (std::vector<DocumentElement *>::const_iterator iterGraphicsStrokeDashStyles = mGraphicsStrokeDashStyles.begin();
+		iterGraphicsStrokeDashStyles != mGraphicsStrokeDashStyles.end(); iterGraphicsStrokeDashStyles++)
+	{
+		(*iterGraphicsStrokeDashStyles)->write(mpHandler);
+	}
+
+	for (std::vector<DocumentElement *>::const_iterator iterGraphicsGradientStyles = mGraphicsGradientStyles.begin();
+		iterGraphicsGradientStyles != mGraphicsGradientStyles.end(); iterGraphicsGradientStyles++)
+	{
+		(*iterGraphicsGradientStyles)->write(mpHandler);
+	}
+	
+	mpHandler->endElement("office:styles");
+	
+	TagOpenElement("office:automatic-styles").write(mpHandler);
+
+	// writing out the graphics automatic styles
+	for (std::vector<DocumentElement *>::iterator iterGraphicsAutomaticStyles = mGraphicsAutomaticStyles.begin();
+		iterGraphicsAutomaticStyles != mGraphicsAutomaticStyles.end(); iterGraphicsAutomaticStyles++)
+	{
+		(*iterGraphicsAutomaticStyles)->write(mpHandler);
+	}
+
+	TagOpenElement tmpStylePageLayoutOpenElement("style:page-layout");
+	tmpStylePageLayoutOpenElement.addAttribute("style:name", "PM0");
+	tmpStylePageLayoutOpenElement.write(mpHandler);
+
+	TagOpenElement tmpStylePageLayoutPropertiesOpenElement("style:page-layout-properties");
+	tmpStylePageLayoutPropertiesOpenElement.addAttribute("fo:margin-top", "0in");
+	tmpStylePageLayoutPropertiesOpenElement.addAttribute("fo:margin-bottom", "0in");
+	tmpStylePageLayoutPropertiesOpenElement.addAttribute("fo:margin-left", "0in");
+	tmpStylePageLayoutPropertiesOpenElement.addAttribute("fo:margin-right", "0in");
+	WPXString sValue;
+	sValue = doubleToString(mfWidth); sValue.append("in");
+	tmpStylePageLayoutPropertiesOpenElement.addAttribute("fo:page-width", sValue);
+	sValue = doubleToString(mfHeight); sValue.append("in");
+	tmpStylePageLayoutPropertiesOpenElement.addAttribute("fo:page-height", sValue);
+	tmpStylePageLayoutPropertiesOpenElement.addAttribute("style:print-orientation", "portrait");
+	tmpStylePageLayoutPropertiesOpenElement.write(mpHandler);
+
+	mpHandler->endElement("style:page-layout-properties");
+
+	mpHandler->endElement("style:page-layout");
+
+	TagOpenElement tmpStyleStyleOpenElement("style:style");
+	tmpStyleStyleOpenElement.addAttribute("style:name", "dp1");
+	tmpStyleStyleOpenElement.addAttribute("style:family", "drawing-page");
+	tmpStyleStyleOpenElement.write(mpHandler);
+
+	TagOpenElement tmpStyleDrawingPagePropertiesOpenElement("style:drawing-page-properties");
+	// tmpStyleDrawingPagePropertiesOpenElement.addAttribute("draw:background-size", "border");
+	tmpStyleDrawingPagePropertiesOpenElement.addAttribute("draw:fill", "none");
+	tmpStyleDrawingPagePropertiesOpenElement.write(mpHandler);
+
+	mpHandler->endElement("style:drawing-page-properties");
+
+	mpHandler->endElement("style:style");
+	
+	mpHandler->endElement("office:automatic-styles");
+
+
+	TagOpenElement("office:master-styles").write(mpHandler);
+
+	TagOpenElement tmpStyleMasterPageOpenElement("style:master-page");
+	tmpStyleMasterPageOpenElement.addAttribute("style:name", "Default");
+	tmpStyleMasterPageOpenElement.addAttribute("style:page-layout-name", "PM0");
+	tmpStyleMasterPageOpenElement.addAttribute("draw:style-name", "dp1");
+	tmpStyleMasterPageOpenElement.write(mpHandler);
+
+	mpHandler->endElement("style:master-page");
+
+	mpHandler->endElement("office:master-styles");
+
+	TagOpenElement("office:body").write(mpHandler);
+
+	TagOpenElement("office:drawing").write(mpHandler);
+
+	TagOpenElement tmpDrawPageOpenElement("draw:page");
+	tmpDrawPageOpenElement.addAttribute("draw:name", "page1");
+	tmpDrawPageOpenElement.addAttribute("draw:style-name", "dp1");
+	tmpDrawPageOpenElement.addAttribute("draw:master-page-name", "Default");
+	tmpDrawPageOpenElement.write(mpHandler);
+
+	for (std::vector<DocumentElement *>::const_iterator bodyIter = mBodyElements.begin();
+		bodyIter != mBodyElements.end(); bodyIter++)
+	{
+		(*bodyIter)->write(mpHandler);
+	}	
+
+	mpHandler->endElement("draw:page");
+	mpHandler->endElement("office:drawing");
+	mpHandler->endElement("office:body");
+	mpHandler->endElement("office:document");
+
+	mpHandler->endDocument();
+}
+
+void OdgExporter::setPen(const libwpg::WPGPen& pen)
+{
+	mxPen = pen;
+}
+
+void OdgExporter::setBrush(const libwpg::WPGBrush& brush)
+{
+	mxBrush = brush;
+}
+
+void OdgExporter::setFillRule(FillRule rule)
+{
+	mxFillRule = rule;
+}
+
+void OdgExporter::startLayer(unsigned int /* id */)
+{
+}
+
+void OdgExporter::endLayer(unsigned int)
+{
+}
+
+void OdgExporter::drawRectangle(const libwpg::WPGRect& rect, double rx, double /* ry */)
+{
+	writeGraphicsStyle();
+	TagOpenElement *pDrawRectElement = new TagOpenElement("draw:rect");
+	WPXString sValue;
+	sValue.sprintf("gr%i", miGraphicsStyleIndex-1);
+	pDrawRectElement->addAttribute("draw:style-name", sValue);
+	sValue = doubleToString(rect.x1); sValue.append("in");
+	pDrawRectElement->addAttribute("svg:x", sValue);
+	sValue = doubleToString(rect.y1); sValue.append("in");
+	pDrawRectElement->addAttribute("svg:y", sValue);
+	sValue = doubleToString(rect.width()); sValue.append("in");
+	pDrawRectElement->addAttribute("svg:width", sValue);
+	sValue = doubleToString(rect.height()); sValue.append("in");
+	pDrawRectElement->addAttribute("svg:height", sValue);
+	sValue = doubleToString(rx); sValue.append("in");
+	// FIXME: what to do when rx != ry ?
+	pDrawRectElement->addAttribute("draw:corner-radius", sValue);
+	mBodyElements.push_back(pDrawRectElement);
+	mBodyElements.push_back(new TagCloseElement("draw:rect"));	
+}
+
+void OdgExporter::drawEllipse(const libwpg::WPGPoint& center, double rx, double ry, double rotation, const libwpg::WPGPoint& from, const libwpg::WPGPoint& to)
+{
+	writeGraphicsStyle();
+	TagOpenElement *pDrawEllipseElement = new TagOpenElement("draw:ellipse");
+	WPXString sValue;
+	sValue.sprintf("gr%i", miGraphicsStyleIndex-1);
+	pDrawEllipseElement->addAttribute("draw:style-name", sValue);
+	sValue = doubleToString(2 * rx); sValue.append("in");
+	pDrawEllipseElement->addAttribute("svg:width", sValue);
+	sValue = doubleToString(2 * ry); sValue.append("in");
+	pDrawEllipseElement->addAttribute("svg:height", sValue);
+	if (rotation != 0.0)
+	{
+		while(rotation < -180)
+			rotation += 360;
+		while(rotation > 180)
+			rotation -= 360;
+		double radrotation = rotation*M_PI/180.0;
+		double deltax = sqrt(pow(rx, 2.0) + pow(ry, 2.0))*cos(atan(ry/rx) - radrotation ) - rx;
+		double deltay = sqrt(pow(rx, 2.0) + pow(ry, 2.0))*sin(atan(ry/rx) - radrotation ) - ry;
+		sValue = "rotate("; sValue.append(doubleToString(radrotation)); sValue.append(") ");
+		sValue.append("translate("); sValue.append(doubleToString(center.x - rx - deltax)); sValue.append("in, "); sValue.append(doubleToString(center.y - ry - deltay)); sValue.append("in)");
+		pDrawEllipseElement->addAttribute("svg:transform", sValue);
+	}
+	else
+	{
+		sValue = doubleToString(center.x-rx); sValue.append("in");
+		pDrawEllipseElement->addAttribute("svg:x", sValue);
+		sValue = doubleToString(center.y-ry); sValue.append("in");
+		pDrawEllipseElement->addAttribute("svg:y", sValue);
+	}
+	mBodyElements.push_back(pDrawEllipseElement);
+	mBodyElements.push_back(new TagCloseElement("draw:ellipse"));
+}
+
+void OdgExporter::drawPolyline(const libwpg::WPGPointArray& vertices)
+{
+	drawPolySomething(vertices, false);
+}
+
+void OdgExporter::drawPolygon(const libwpg::WPGPointArray& vertices)
+{
+	drawPolySomething(vertices, true);
+}
+
+void OdgExporter::drawPolySomething(const libwpg::WPGPointArray& vertices, bool isClosed)
+{
+	if(vertices.count() < 2)
+		return;
+
+	if(vertices.count() == 2)
+	{
+		const libwpg::WPGPoint& p1 = vertices[0];
+		const libwpg::WPGPoint& p2 = vertices[1];
+
+		writeGraphicsStyle();
+		TagOpenElement *pDrawLineElement = new TagOpenElement("draw:line");
+		WPXString sValue;
+		sValue.sprintf("gr%i", miGraphicsStyleIndex-1);
+		pDrawLineElement->addAttribute("draw:style-name", sValue);
+		pDrawLineElement->addAttribute("draw:text-style-name", "P1");
+		pDrawLineElement->addAttribute("draw:layer", "layout");
+		sValue = doubleToString(p1.x); sValue.append("in");
+		pDrawLineElement->addAttribute("svg:x1", sValue);
+		sValue = doubleToString(p1.y); sValue.append("in");
+		pDrawLineElement->addAttribute("svg:y1", sValue);
+		sValue = doubleToString(p2.x); sValue.append("in");
+		pDrawLineElement->addAttribute("svg:x2", sValue);
+		sValue = doubleToString(p2.y); sValue.append("in");
+		pDrawLineElement->addAttribute("svg:y2", sValue);
+		mBodyElements.push_back(pDrawLineElement);
+		mBodyElements.push_back(new TagCloseElement("draw:line"));
+	}
+	else
+	{
+		// draw as path
+		libwpg::WPGPath path;
+		path.moveTo(vertices[0]);
+		for(unsigned long ii = 1; ii < vertices.count(); ii++)
+			path.lineTo(vertices[ii]);
+		path.closed = isClosed;
+		drawPath(path);
+	}
+}
+
+void OdgExporter::drawPath(const libwpg::WPGPath& path)
+{
+	if(path.count() == 0)
+		return;
+
+	// try to find the bounding box
+	// this is simple convex hull technique, the bounding box might not be
+	// accurate but that should be enough for this purpose
+	libwpg::WPGPoint p = path.element(0).point;
+	libwpg::WPGPoint q = path.element(0).point;
+	for(unsigned k = 0; k < path.count(); k++)
+	{
+		libwpg::WPGPathElement element = path.element(k);
+		p.x = (p.x > element.point.x) ? element.point.x : p.x; 
+		p.y = (p.y > element.point.y) ? element.point.y : p.y; 
+		q.x = (q.x < element.point.x) ? element.point.x : q.x; 
+		q.y = (q.y < element.point.y) ? element.point.y : q.y; 
+		if(element.type == libwpg::WPGPathElement::CurveToElement)
+		{
+			p.x = (p.x > element.extra1.x) ? element.extra1.x : p.x; 
+			p.y = (p.y > element.extra1.y) ? element.extra1.y : p.y; 
+			q.x = (q.x < element.extra1.x) ? element.extra1.x : q.x; 
+			q.y = (q.y < element.extra1.y) ? element.extra1.y : q.y; 
+			p.x = (p.x > element.extra2.x) ? element.extra2.x : p.x; 
+			p.y = (p.y > element.extra2.y) ? element.extra2.y : p.y; 
+			q.x = (q.x < element.extra2.x) ? element.extra2.x : q.x; 
+			q.y = (q.y < element.extra2.y) ? element.extra2.y : q.y; 
+		}
+	}
+	double vw = q.x - p.x;
+	double vh = q.y - p.y;
+		
+	writeGraphicsStyle();
+
+	TagOpenElement *pDrawPathElement = new TagOpenElement("draw:path");
+	WPXString sValue;
+	sValue.sprintf("gr%i", miGraphicsStyleIndex-1);
+	pDrawPathElement->addAttribute("draw:style-name", sValue);
+	pDrawPathElement->addAttribute("draw:text-style-name", "P1");
+	pDrawPathElement->addAttribute("draw:layer", "layout");
+	sValue = doubleToString(p.x); sValue.append("in");
+	pDrawPathElement->addAttribute("svg:x", sValue);
+	sValue = doubleToString(p.y); sValue.append("in");
+	pDrawPathElement->addAttribute("svg:y", sValue);
+	sValue = doubleToString(vw); sValue.append("in");
+	pDrawPathElement->addAttribute("svg:width", sValue);
+	sValue = doubleToString(vh); sValue.append("in");
+	pDrawPathElement->addAttribute("svg:height", sValue);
+	sValue.sprintf("%i %i %i %i", 0, 0, (unsigned)(vw*2540), (unsigned)(vh*2540));
+	pDrawPathElement->addAttribute("svg:viewBox", sValue);
+
+    sValue.clear();
+	for(unsigned i = 0; i < path.count(); i++)
+	{
+		libwpg::WPGPathElement element = path.element(i);
+		libwpg::WPGPoint point = element.point;
+        WPXString sElement;
+		switch(element.type)
+		{
+			// 2540 is 2.54*1000, 2.54 in = 1 inch
+			case libwpg::WPGPathElement::MoveToElement:
+			    sElement.sprintf("M%i %i", (unsigned)((point.x-p.x)*2540), (unsigned)((point.y-p.y)*2540));
+				break;
+				
+			case libwpg::WPGPathElement::LineToElement:
+			    sElement.sprintf("L%i %i", (unsigned)((point.x-p.x)*2540), (unsigned)((point.y-p.y)*2540));
+				break;
+			
+			case libwpg::WPGPathElement::CurveToElement:
+                sElement.sprintf("C%i %i %i %i %i %i", (unsigned)((element.extra1.x-p.x)*2540),
+                (int)((element.extra1.y-p.y)*2540), (unsigned)((element.extra2.x-p.x)*2540),
+                (int)((element.extra2.y-p.y)*2540), (unsigned)((point.x-p.x)*2540), (unsigned)((point.y-p.y)*2540));
+				break;
+			
+			default:
+				break;
+		}
+		sValue.append(sElement);
+	}
+    if(path.closed)
+		sValue.append(" Z");
+	pDrawPathElement->addAttribute("svg:d", sValue);
+	mBodyElements.push_back(pDrawPathElement);
+	mBodyElements.push_back(new TagCloseElement("draw:path"));
+}
+
+void OdgExporter::drawBitmap(const libwpg::WPGBitmap& bitmap)
+{
+	TagOpenElement *pDrawFrameElement = new TagOpenElement("draw:frame");
+	WPXString sValue;
+	sValue = doubleToString(bitmap.rect.x1); sValue.append("in");
+	pDrawFrameElement->addAttribute("svg:x", sValue);
+	sValue = doubleToString(bitmap.rect.y1); sValue.append("in");
+	pDrawFrameElement->addAttribute("svg:y", sValue);
+	sValue = doubleToString(bitmap.rect.height()); sValue.append("in");
+	pDrawFrameElement->addAttribute("svg:height", sValue);
+	sValue = doubleToString(bitmap.rect.width()); sValue.append("in");
+	pDrawFrameElement->addAttribute("svg:width", sValue);
+	mBodyElements.push_back(pDrawFrameElement);
+	
+	mBodyElements.push_back(new TagOpenElement("draw:image"));
+	
+	mBodyElements.push_back(new TagOpenElement("office:binary-data"));
+	
+	libwpg::WPGString base64Binary;
+	bitmap.generateBase64DIB(base64Binary);
+	mBodyElements.push_back(new CharDataElement(base64Binary.cstr()));
+	
+	mBodyElements.push_back(new TagCloseElement("office:binary-data"));
+	
+	mBodyElements.push_back(new TagCloseElement("draw:image"));
+	
+	mBodyElements.push_back(new TagCloseElement("draw:frame"));
+}
+
+void OdgExporter::drawImageObject(const libwpg::WPGBinaryData& binaryData)
+{
+	if (binaryData.mimeType.length() <= 0)
+		return;
+	TagOpenElement *pDrawFrameElement = new TagOpenElement("draw:frame");
+	WPXString sValue;
+	sValue = doubleToString(binaryData.rect.x1); sValue.append("in");
+	pDrawFrameElement->addAttribute("svg:x", sValue);
+	sValue = doubleToString(binaryData.rect.y1); sValue.append("in");
+	pDrawFrameElement->addAttribute("svg:y", sValue);
+	sValue = doubleToString(binaryData.rect.height()); sValue.append("in");
+	pDrawFrameElement->addAttribute("svg:height", sValue);
+	sValue = doubleToString(binaryData.rect.width()); sValue.append("in");
+	pDrawFrameElement->addAttribute("svg:width", sValue);
+	mBodyElements.push_back(pDrawFrameElement);
+	
+	mBodyElements.push_back(new TagOpenElement("draw:image"));
+	
+	mBodyElements.push_back(new TagOpenElement("office:binary-data"));
+	
+	libwpg::WPGString base64Binary = binaryData.getBase64Data();
+	mBodyElements.push_back(new CharDataElement(base64Binary.cstr()));
+	
+	mBodyElements.push_back(new TagCloseElement("office:binary-data"));
+	
+	mBodyElements.push_back(new TagCloseElement("draw:image"));
+	
+	mBodyElements.push_back(new TagCloseElement("draw:frame"));
+}
+
+void OdgExporter::writeGraphicsStyle()
+{
+	if(!mxPen.solid && (mxPen.dashArray.count() >=2 ) )
+	{
+		// ODG only supports dashes with the same length of spaces inbetween
+		// here we take the first space and assume everything else the same
+		// note that dash length is written in percentage ?????????????????
+		double distance = mxPen.dashArray.at(1);
+		TagOpenElement *pDrawStrokeDashElement = new TagOpenElement("draw:stroke-dash");
+		pDrawStrokeDashElement->addAttribute("draw:style", "rect");
+		WPXString sValue;
+		sValue.sprintf("Dash_%i", miDashIndex++);
+		pDrawStrokeDashElement->addAttribute("draw:name", sValue);
+		sValue = doubleToString(distance); sValue.append("in");
+		pDrawStrokeDashElement->addAttribute("draw:distance", sValue);
+		WPXString sName;
+		// We have to find out how to do this intelligently, since the ODF is allowing only
+		// two pairs draw:dots1 draw:dots1-length and draw:dots2 draw:dots2-length
+		for(unsigned i = 0; i < mxPen.dashArray.count()/2 && i < 2; i++)
+		{
+			sName.sprintf("draw:dots%i", i+1);
+			pDrawStrokeDashElement->addAttribute(sName.cstr(), "1");
+			sName.sprintf("draw:dots%i-length", i+1);
+			sValue = doubleToString(mxPen.dashArray.at(i*2)); sValue.append("in");
+			pDrawStrokeDashElement->addAttribute(sName.cstr(), sValue);
+		}
+		mGraphicsStrokeDashStyles.push_back(pDrawStrokeDashElement);
+		mGraphicsStrokeDashStyles.push_back(new TagCloseElement("draw:stroke-dash"));
+	}
+
+	if(mxBrush.style == libwpg::WPGBrush::Gradient)
+	{
+		TagOpenElement *pDrawGradientElement = new TagOpenElement("draw:gradient");
+		pDrawGradientElement->addAttribute("draw:style", "linear");
+		WPXString sValue;
+		sValue.sprintf("Gradient_%i", miGradientIndex++);
+		pDrawGradientElement->addAttribute("draw:name", sValue);
+
+		// ODG angle unit is 0.1 degree
+		double angle = -mxBrush.gradient.angle();
+		while(angle < 0)
+			angle += 360;
+		while(angle > 360)
+			angle -= 360;
+
+		sValue.sprintf("%i", (unsigned)(angle*10));
+		pDrawGradientElement->addAttribute("draw:angle", sValue);
+
+		libwpg::WPGColor startColor = mxBrush.gradient.stopColor(0);
+		libwpg::WPGColor stopColor = mxBrush.gradient.stopColor(1);
+		sValue.sprintf("#%.2x%.2x%.2x", (startColor.red & 0xff), (startColor.green & 0xff), (startColor.blue & 0xff));
+		pDrawGradientElement->addAttribute("draw:start-color", sValue);
+		sValue.sprintf("#%.2x%.2x%.2x", (stopColor.red & 0xff), (stopColor.green & 0xff), (stopColor.blue & 0xff));
+		pDrawGradientElement->addAttribute("draw:end-color", sValue);
+		pDrawGradientElement->addAttribute("draw:start-intensity", "100%");
+		pDrawGradientElement->addAttribute("draw:end-intensity", "100%");
+		pDrawGradientElement->addAttribute("draw:border", "0%");
+		mGraphicsGradientStyles.push_back(pDrawGradientElement);
+		mGraphicsGradientStyles.push_back(new TagCloseElement("draw:gradient"));
+	}
+
+	TagOpenElement *pStyleStyleElement = new TagOpenElement("style:style");
+	WPXString sValue;
+	sValue.sprintf("gr%i",  miGraphicsStyleIndex);
+	pStyleStyleElement->addAttribute("style:name", sValue);
+	pStyleStyleElement->addAttribute("style:family", "graphic");
+	pStyleStyleElement->addAttribute("style:parent-style-name", "standard");
+	mGraphicsAutomaticStyles.push_back(pStyleStyleElement);
+
+	TagOpenElement *pStyleGraphicsPropertiesElement = new TagOpenElement("style:graphic-properties");
+
+	if(mxPen.width > 0.0)
+	{
+		sValue = doubleToString(mxPen.width); sValue.append("in");
+		pStyleGraphicsPropertiesElement->addAttribute("svg:stroke-width", sValue);
+
+		sValue.sprintf("#%.2x%.2x%.2x", (mxPen.foreColor.red & 0xff),
+			(mxPen.foreColor.green & 0xff), (mxPen.foreColor.blue & 0xff));
+		pStyleGraphicsPropertiesElement->addAttribute("svg:stroke-color", sValue);
+
+		if(!mxPen.solid)
+		{
+			pStyleGraphicsPropertiesElement->addAttribute("draw:stroke", "dash");
+			sValue.sprintf("Dash_%i", miDashIndex-1);
+			pStyleGraphicsPropertiesElement->addAttribute("draw:stroke-dash", sValue);
+		}
+	}
+	else
+		pStyleGraphicsPropertiesElement->addAttribute("draw:stroke", "none");
+
+	if(mxBrush.style == libwpg::WPGBrush::NoBrush)
+		pStyleGraphicsPropertiesElement->addAttribute("draw:fill", "none");
+
+	if(mxBrush.style == libwpg::WPGBrush::Solid)
+	{
+		pStyleGraphicsPropertiesElement->addAttribute("draw:fill", "solid");
+		sValue.sprintf("#%.2x%.2x%.2x", (mxBrush.foreColor.red & 0xff),
+			(mxBrush.foreColor.green & 0xff), (mxBrush.foreColor.blue & 0xff));
+		pStyleGraphicsPropertiesElement->addAttribute("draw:fill-color", sValue);
+	}
+
+	if(mxBrush.style == libwpg::WPGBrush::Gradient)
+	{
+		pStyleGraphicsPropertiesElement->addAttribute("draw:fill", "gradient");
+		sValue.sprintf("Gradient_%i", miGradientIndex-1);
+		pStyleGraphicsPropertiesElement->addAttribute("draw:fill-gradient-name", sValue);
+	}
+
+	mGraphicsAutomaticStyles.push_back(pStyleGraphicsPropertiesElement);
+	mGraphicsAutomaticStyles.push_back(new TagCloseElement("style:graphic-properties"));
+
+	mGraphicsAutomaticStyles.push_back(new TagCloseElement("style:style"));
+	miGraphicsStyleIndex++;
+}
+
+WPXString OdgExporter::doubleToString(const double value)
+{
+	WPXString tempString;
+	tempString.sprintf("%.4f", value);
+	std::string decimalPoint(localeconv()->decimal_point);
+	if ((decimalPoint.size() == 0) || (decimalPoint == "."))
+		return tempString;
+	std::string stringValue(tempString.cstr());
+	if (!stringValue.empty())
+	{
+		std::string::size_type pos;
+		while ((pos = stringValue.find(decimalPoint)) != std::string::npos)
+			stringValue.replace(pos,decimalPoint.size(),".");
+	}
+	return WPXString(stringValue.c_str());
+}
diff -u -r -N writerperfect//source/filter/OdgExporter.hxx writerperfect//source/filter/OdgExporter.hxx
--- writerperfect//source/filter/OdgExporter.hxx	1970-01-01 01:00:00.000000000 +0100
+++ writerperfect//source/filter/OdgExporter.hxx	2008-11-17 22:07:19.000000000 +0100
@@ -0,0 +1,89 @@
+/* libwpg
+ * Copyright (C) 2006 Ariya Hidayat (ariya@kde.org)
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the 
+ * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, 
+ * Boston, MA  02111-1301 USA
+ *
+ * For further information visit http://libwpg.sourceforge.net
+ */
+
+/* "This product is not manufactured, approved, or supported by
+ * Corel Corporation or Corel Corporation Limited."
+ */
+
+#ifndef __ODGEXPORTER_HXX__
+#define __ODGEXPORTER_HXX__
+
+#include <iostream>
+#include <sstream>
+#include <string>
+
+#include <libwpd/WPXString.h>
+#include <libwpg/libwpg.h>
+#include "DocumentElement.hxx"
+#include "DocumentHandlerInterface.hxx"
+
+class OdgExporter : public libwpg::WPGPaintInterface {
+public:
+	OdgExporter(DocumentHandlerInterface *pHandler, const bool isFlatXML = false);
+	~OdgExporter();
+
+	void startGraphics(double width, double height);
+	void endGraphics();
+	void startLayer(unsigned int id);
+	void endLayer(unsigned int id);
+	void startEmbeddedGraphics( double /* width */, double /* height */ ) {}
+	void endEmbeddedGraphics() {}
+
+	void setPen(const libwpg::WPGPen& pen);
+	void setBrush(const libwpg::WPGBrush& brush);
+	void setFillRule(FillRule rule);
+
+	void drawRectangle(const libwpg::WPGRect& rect, double rx, double ry);
+	void drawEllipse(const libwpg::WPGPoint& center, double rx, double ry, double rotation, const libwpg::WPGPoint& from, const libwpg::WPGPoint& to);
+	void drawPolyline(const libwpg::WPGPointArray& vertices);
+	void drawPolygon(const libwpg::WPGPointArray& vertices);
+	void drawPath(const libwpg::WPGPath& path);
+	void drawBitmap(const libwpg::WPGBitmap& bitmap);
+	void drawImageObject(const libwpg::WPGBinaryData& binaryData);
+
+private:
+	void writeGraphicsStyle();
+	WPXString doubleToString(const double value);
+	void drawPolySomething(const libwpg::WPGPointArray& vertices, bool isClosed);
+	
+	// body elements
+	std::vector <DocumentElement *> mBodyElements;
+
+	// graphics styles
+	std::vector<DocumentElement *> mGraphicsStrokeDashStyles;
+	std::vector<DocumentElement *> mGraphicsGradientStyles;
+	std::vector<DocumentElement *> mGraphicsAutomaticStyles;
+
+	DocumentHandlerInterface *mpHandler;
+
+	libwpg::WPGPen mxPen;
+	libwpg::WPGBrush mxBrush;
+	FillRule mxFillRule;
+	int miGradientIndex;
+	int miDashIndex;
+	int miGraphicsStyleIndex;
+	double mfWidth;
+	double mfHeight;
+
+	const bool mbIsFlatXML;
+};
+
+#endif // __ODGEXPORTER_HXX__
diff -u -r -N writerperfect//source/filter/PageSpan.cxx writerperfect//source/filter/PageSpan.cxx
--- writerperfect//source/filter/PageSpan.cxx	2008-11-17 22:06:28.000000000 +0100
+++ writerperfect//source/filter/PageSpan.cxx	2008-11-17 22:07:19.000000000 +0100
@@ -87,39 +87,38 @@
         return 0; // should never happen
 }
 
-void PageSpan::writePageMaster(const int iNum, DocumentHandler *pHandler) const
+void PageSpan::writePageLayout(const int iNum, DocumentHandlerInterface *pHandler) const
 {
         WPXPropertyList propList;
         
-	WPXString sPageMasterName; 
-        sPageMasterName.sprintf("PM%i", iNum /* +2 */);
-        propList.insert("style:name", sPageMasterName);
-
-	pHandler->startElement("style:page-master", propList);
+	WPXString sPageLayoutName; 
+        sPageLayoutName.sprintf("PM%i", iNum+2);
+        propList.insert("style:name", sPageLayoutName);
+	pHandler->startElement("style:page-layout", propList);
 
 	WPXPropertyList tempPropList = mxPropList;
 	if (!tempPropList["style:writing-mode"])
 		tempPropList.insert("style:writing-mode", WPXString("lr-tb"));
 	if (!tempPropList["style:footnote-max-height"])
-		tempPropList.insert("style:footnote-max-height", WPXString("0inch"));
-        pHandler->startElement("style:properties", tempPropList);
+		tempPropList.insert("style:footnote-max-height", WPXString("0in"));
+        pHandler->startElement("style:page-layout-properties", tempPropList);
 	
 	WPXPropertyList footnoteSepPropList;
-	footnoteSepPropList.insert("style:width", WPXString("0.0071inch"));
-	footnoteSepPropList.insert("style:distance-before-sep", WPXString("0.0398inch"));
-	footnoteSepPropList.insert("style:distance-after-sep", WPXString("0.0398inch"));
+	footnoteSepPropList.insert("style:width", WPXString("0.0071in"));
+	footnoteSepPropList.insert("style:distance-before-sep", WPXString("0.0398in"));
+	footnoteSepPropList.insert("style:distance-after-sep", WPXString("0.0398in"));
 	footnoteSepPropList.insert("style:adjustment", WPXString("left"));
 	footnoteSepPropList.insert("style:rel-width", WPXString("25%"));
 	footnoteSepPropList.insert("style:color", WPXString("#000000"));
 	pHandler->startElement("style:footnote-sep", footnoteSepPropList);
 	
 	pHandler->endElement("style:footnote-sep");
-        pHandler->endElement("style:properties");
-        pHandler->endElement("style:page-master");
+        pHandler->endElement("style:page-layout-properties");
+        pHandler->endElement("style:page-layout");
 }
 
-void PageSpan::writeMasterPages(const int iStartingNum, const int iPageMasterNum, const bool bLastPageSpan, 
-                                DocumentHandler *pHandler) const
+void PageSpan::writeMasterPages(const int iStartingNum, const int iPageLayoutNum, const bool bLastPageSpan, 
+                                DocumentHandlerInterface *pHandler) const
 {
 	int iSpan = 0;
 	(bLastPageSpan) ? iSpan = 1 : iSpan = getSpan();
@@ -127,38 +126,66 @@
 	for (int i=iStartingNum; i<(iStartingNum+iSpan); i++)
 	{
 		TagOpenElement masterPageOpen("style:master-page");
-		WPXString sMasterPageName;
-		sMasterPageName.sprintf("Page Style %i", i);
-		WPXString sPageMasterName;
-		sPageMasterName.sprintf("PM%i", iPageMasterNum /* +2 */);
+		WPXString sMasterPageName, sMasterPageDisplayName;
+		sMasterPageName.sprintf("Page_Style_%i", i);
+		sMasterPageDisplayName.sprintf("Page Style %i", i);
+		WPXString sPageLayoutName;
 		WPXPropertyList propList;
+		sPageLayoutName.sprintf("PM%i", iPageLayoutNum+2);
                 propList.insert("style:name", sMasterPageName);
-		propList.insert("style:page-master-name", sPageMasterName);
+		propList.insert("style:display-name", sMasterPageDisplayName);
+		propList.insert("style:page-layout-name", sPageLayoutName);
 		if (!bLastPageSpan)
 		{
 			WPXString sNextMasterPageName;
-			sNextMasterPageName.sprintf("Page Style %i", (i+1));
+			sNextMasterPageName.sprintf("Page_Style_%i", (i+1));
                         propList.insert("style:next-style-name", sNextMasterPageName);
 		}
                 pHandler->startElement("style:master-page", propList);
 
 		if (mpHeaderContent)
+		{
 			_writeHeaderFooter("style:header", *mpHeaderContent, pHandler);
-		if (mpHeaderLeftContent)
+			pHandler->endElement("style:header");
+			if (mpHeaderLeftContent)
+			{
+				_writeHeaderFooter("style:header-left", *mpHeaderLeftContent, pHandler);
+				pHandler->endElement("style:header-left");
+			}
+		}
+		else if (mpHeaderLeftContent)
+		{
+			TagOpenElement("style:header").write(pHandler);
+			pHandler->endElement("style:header");
 			_writeHeaderFooter("style:header-left", *mpHeaderLeftContent, pHandler);
+			pHandler->endElement("style:header-left");
+		}
+			
 		if (mpFooterContent)
+		{
 			_writeHeaderFooter("style:footer", *mpFooterContent, pHandler);
-		if (mpFooterLeftContent)
+			pHandler->endElement("style:footer");
+			if (mpFooterLeftContent)
+			{
+				_writeHeaderFooter("style:footer-left", *mpFooterLeftContent, pHandler);
+				pHandler->endElement("style:footer-left");
+			}
+		}
+		else if (mpFooterLeftContent)
+		{
+			TagOpenElement("style:footer").write(pHandler);
+			pHandler->endElement("style:footer");
 			_writeHeaderFooter("style:footer-left", *mpFooterLeftContent, pHandler);
+			pHandler->endElement("style:footer-left");
+		}
 
                 pHandler->endElement("style:master-page");
 	}
-
 }
 
 void PageSpan::_writeHeaderFooter(const char *headerFooterTagName,
 				  const std::vector<DocumentElement *> & headerFooterContent,
-				  DocumentHandler *pHandler) const
+				  DocumentHandlerInterface *pHandler) const
 {
 	TagOpenElement headerFooterOpen(headerFooterTagName);
 	headerFooterOpen.write(pHandler);
@@ -167,7 +194,4 @@
 	     iter++) {
 		(*iter)->write(pHandler);
 	}
-	TagCloseElement headerFooterClose(headerFooterTagName);
-	headerFooterClose.write(pHandler);
 }
-
diff -u -r -N writerperfect//source/filter/PageSpan.hxx writerperfect//source/filter/PageSpan.hxx
--- writerperfect//source/filter/PageSpan.hxx	2008-11-17 22:06:28.000000000 +0100
+++ writerperfect//source/filter/PageSpan.hxx	2008-11-17 22:07:19.000000000 +0100
@@ -26,25 +26,20 @@
  */
 #ifndef _PAGESPAN_H
 #define _PAGESPAN_H
-#if defined _MSC_VER
-#pragma warning( push, 1 )
-#endif
 #include <libwpd/libwpd.h>
-#if defined _MSC_VER
-#pragma warning( pop )
-#endif
 #include <vector>
 
+#include "DocumentHandlerInterface.hxx"
+
 class DocumentElement;
-class DocumentHandler;
 
 class PageSpan
 {
 public:
 	PageSpan(const WPXPropertyList &xPropList);
 	virtual ~PageSpan();
-	void writePageMaster(const int iNum, DocumentHandler *pHandler) const;
-	void writeMasterPages(const int iStartingNum, const int iPageMasterNum, const bool bLastPageSpan, DocumentHandler *pHandler) const;
+	void writePageLayout(const int iNum, DocumentHandlerInterface *pHandler) const;
+	void writeMasterPages(const int iStartingNum, const int iPageLayoutNum, const bool bLastPageSpan, DocumentHandlerInterface *pHandler) const;
 	int getSpan() const;
 
 	const std::vector<DocumentElement *> * getHeaderContent() const { return mpHeaderContent; }
@@ -54,7 +49,7 @@
 	void setFooterLeftContent(std::vector<DocumentElement *> * pFooterContent) { mpFooterLeftContent = pFooterContent; }
 protected:
 	void _writeHeaderFooter(const char *headerFooterTagName, const std::vector<DocumentElement *> & headerFooterContent,
-				DocumentHandler *pHandler) const;
+				DocumentHandlerInterface *pHandler) const;
 private:
         WPXPropertyList mxPropList;
 	std::vector<DocumentElement *> * mpHeaderContent;
diff -u -r -N writerperfect//source/filter/SectionStyle.cxx writerperfect//source/filter/SectionStyle.cxx
--- writerperfect//source/filter/SectionStyle.cxx	2008-11-17 22:06:28.000000000 +0100
+++ writerperfect//source/filter/SectionStyle.cxx	2008-11-17 22:07:19.000000000 +0100
@@ -33,7 +33,7 @@
 
 #ifdef _MSC_VER
 double rint(double x);
-#endif /* _MSC_VER */
+#endif /* _WIN32 */
 
 SectionStyle::SectionStyle(const WPXPropertyList &xPropList, 
                            const WPXPropertyListVector &xColumns, 
@@ -44,7 +44,7 @@
 {
 }
 
-void SectionStyle::write(DocumentHandler *pHandler) const
+void SectionStyle::write(DocumentHandlerInterface *pHandler) const
 {
 	TagOpenElement styleOpen("style:style");
 	styleOpen.addAttribute("style:name", getName());
@@ -53,15 +53,15 @@
 
 	// if the number of columns is <= 1, we will never come here. This is only an additional check
 	// style properties
-	pHandler->startElement("style:properties", mPropList);
+	pHandler->startElement("style:section-properties", mPropList);
 
 	// column properties
 	WPXPropertyList columnProps;
 
 	if (mColumns.count() > 1)
 	{		
-                columnProps.insert("fo:column-count", (int)mColumns.count());
-                pHandler->startElement("style:columns", columnProps);
+		columnProps.insert("fo:column-count", (int)mColumns.count());
+ 		pHandler->startElement("style:columns", columnProps);
 	
                 WPXPropertyListVector::Iter i(mColumns);
                 for (i.rewind(); i.next();)
@@ -80,7 +80,7 @@
 	pHandler->endElement("style:columns");
 
 		
-	pHandler->endElement("style:properties");
+	pHandler->endElement("style:section-properties");
 
 	pHandler->endElement("style:style");
 }
diff -u -r -N writerperfect//source/filter/SectionStyle.hxx writerperfect//source/filter/SectionStyle.hxx
--- writerperfect//source/filter/SectionStyle.hxx	2008-11-17 22:06:28.000000000 +0100
+++ writerperfect//source/filter/SectionStyle.hxx	2008-11-17 22:07:19.000000000 +0100
@@ -21,19 +21,13 @@
  *
  */
 
-/* "This product is not manufactured, approved, or supported by
+/* "This product is not manufactured, approved, or supported by 
  * Corel Corporation or Corel Corporation Limited."
  */
 #ifndef _SECTIONSTYLE_H
 #define _SECTIONSTYLE_H
-#if defined _MSC_VER
-#pragma warning( push, 1 )
-#endif
 #include <libwpd/libwpd.h>
 #include <libwpd/WPXPropertyListVector.h>
-#if defined _MSC_VER
-#pragma warning( pop )
-#endif
 
 #include "Style.hxx"
 #include "WriterProperties.hxx"
@@ -43,10 +37,10 @@
 {
 public:
 	SectionStyle(const WPXPropertyList &xPropList, const WPXPropertyListVector &xColumns, const char *psName);
-	virtual void write(DocumentHandler *pHandler) const;
+	virtual void write(DocumentHandlerInterface *pHandler) const;
 
 private:
-        WPXPropertyList mPropList;
+	WPXPropertyList mPropList;
 	WPXPropertyListVector mColumns;
 };
 #endif
diff -u -r -N writerperfect//source/filter/Style.hxx writerperfect//source/filter/Style.hxx
--- writerperfect//source/filter/Style.hxx	2008-11-17 22:06:28.000000000 +0100
+++ writerperfect//source/filter/Style.hxx	2008-11-17 22:07:19.000000000 +0100
@@ -21,19 +21,13 @@
  *
  */
 
-/* "This product is not manufactured, approved, or supported by
+/* "This product is not manufactured, approved, or supported by 
  * Corel Corporation or Corel Corporation Limited."
  */
 
 #ifndef _STYLE_H
 #define _STYLE_H
-#if defined _MSC_VER
-#pragma warning( push, 1 )
-#endif
 #include <libwpd/libwpd.h>
-#if defined _MSC_VER
-#pragma warning( pop )
-#endif
 #include "DocumentElement.hxx"
 
 class TopLevelElementStyle
@@ -54,7 +48,7 @@
 	Style(const WPXString &psName) : msName(psName) {}
 	virtual ~Style() {}
 
-	virtual void write(DocumentHandler * /* pHandler */) const {};
+	virtual void write(DocumentHandlerInterface * /* pHandler */) const {};
 	const WPXString &getName() const { return msName; }
 
  private:
diff -u -r -N writerperfect//source/filter/TableStyle.cxx writerperfect//source/filter/TableStyle.cxx
--- writerperfect//source/filter/TableStyle.cxx	2008-11-17 22:06:28.000000000 +0100
+++ writerperfect//source/filter/TableStyle.cxx	2008-11-17 22:07:19.000000000 +0100
@@ -27,7 +27,6 @@
  * Corel Corporation or Corel Corporation Limited."
  */
 #include <math.h>
-#include <string.h>
 #include "FilterInternal.hxx"
 #include "TableStyle.hxx"
 #include "DocumentElement.hxx"
@@ -36,13 +35,15 @@
 #include <minmax.h>
 #endif
 
+#include <string.h>
+
 TableCellStyle::TableCellStyle(const WPXPropertyList &xPropList, const char *psName) :
 	Style(psName),
         mPropList(xPropList)
 {
 }
 
-void TableCellStyle::write(DocumentHandler *pHandler) const
+void TableCellStyle::write(DocumentHandlerInterface *pHandler) const
 {
 	TagOpenElement styleOpen("style:style");
 	styleOpen.addAttribute("style:name", getName());
@@ -58,9 +59,9 @@
                 if (strlen(i.key()) > 2 && strncmp(i.key(), "fo", 2) == 0)
                         stylePropList.insert(i.key(), i()->clone());
         }
-        stylePropList.insert("fo:padding", "0.0382inch");
-        pHandler->startElement("style:properties", stylePropList);
-	pHandler->endElement("style:properties");
+        stylePropList.insert("fo:padding", "0.0382in");
+        pHandler->startElement("style:table-cell-properties", stylePropList);
+	pHandler->endElement("style:table-cell-properties");
 
 	pHandler->endElement("style:style");	
 }
@@ -71,20 +72,21 @@
 {
 }
 
-void TableRowStyle::write(DocumentHandler *pHandler) const
+void TableRowStyle::write(DocumentHandlerInterface *pHandler) const
 {
 	TagOpenElement styleOpen("style:style");
 	styleOpen.addAttribute("style:name", getName());
 	styleOpen.addAttribute("style:family", "table-row");
 	styleOpen.write(pHandler);
 	
-        TagOpenElement stylePropertiesOpen("style:properties");
+        TagOpenElement stylePropertiesOpen("style:table-row-properties");
         if (mPropList["style:min-row-height"])
                 stylePropertiesOpen.addAttribute("style:min-row-height", mPropList["style:min-row-height"]->getStr());
         else if (mPropList["style:row-height"])
                 stylePropertiesOpen.addAttribute("style:row-height", mPropList["style:row-height"]->getStr());
+	stylePropertiesOpen.addAttribute("fo:keep-together", "auto");
         stylePropertiesOpen.write(pHandler);
-        pHandler->endElement("style:properties");
+        pHandler->endElement("style:table-row-properties");
 	
 	pHandler->endElement("style:style");		
 }
@@ -105,10 +107,9 @@
 		delete(*iterTableCellStyles);
 	for (TRSVIter iterTableRowStyles = mTableRowStyles.begin() ; iterTableRowStyles != mTableRowStyles.end(); iterTableRowStyles++)
 		delete(*iterTableRowStyles);
-
 }
 
-void TableStyle::write(DocumentHandler *pHandler) const
+void TableStyle::write(DocumentHandlerInterface *pHandler) const
 {
 	TagOpenElement styleOpen("style:style");
 	styleOpen.addAttribute("style:name", getName());
@@ -117,7 +118,7 @@
 		styleOpen.addAttribute("style:master-page-name", getMasterPageName()->cstr());
 	styleOpen.write(pHandler);
 
-	TagOpenElement stylePropertiesOpen("style:properties");
+	TagOpenElement stylePropertiesOpen("style:table-properties");
         if (mPropList["table:align"])
                 stylePropertiesOpen.addAttribute("table:align", mPropList["table:align"]->getStr());
 	if (mPropList["fo:margin-left"])
@@ -130,23 +131,23 @@
 		stylePropertiesOpen.addAttribute("fo:break-before", mPropList["fo:break-before"]->getStr());
 	stylePropertiesOpen.write(pHandler);
 
-	pHandler->endElement("style:properties");
+	pHandler->endElement("style:table-properties");
 
 	pHandler->endElement("style:style");
 		
 	int i=1;
-        WPXPropertyListVector::Iter j(mColumns);
+	WPXPropertyListVector::Iter j(mColumns);
 	for (j.rewind(); j.next();)
 	{
-		TagOpenElement styleNestedOpen("style:style");
+		TagOpenElement styleOpen2("style:style");
 		WPXString sColumnName;
 		sColumnName.sprintf("%s.Column%i", getName().cstr(), i);
-		styleNestedOpen.addAttribute("style:name", sColumnName);
-		styleNestedOpen.addAttribute("style:family", "table-column");
-		styleNestedOpen.write(pHandler);
+		styleOpen2.addAttribute("style:name", sColumnName);
+		styleOpen2.addAttribute("style:family", "table-column");
+		styleOpen2.write(pHandler);
 
-                pHandler->startElement("style:properties", j());
-		pHandler->endElement("style:properties");
+		pHandler->startElement("style:table-column-properties", j());
+		pHandler->endElement("style:table-column-properties");
 
 		pHandler->endElement("style:style");
 
diff -u -r -N writerperfect//source/filter/TableStyle.hxx writerperfect//source/filter/TableStyle.hxx
--- writerperfect//source/filter/TableStyle.hxx	2008-11-17 22:06:28.000000000 +0100
+++ writerperfect//source/filter/TableStyle.hxx	2008-11-17 22:07:19.000000000 +0100
@@ -38,15 +38,16 @@
 
 #include "Style.hxx"
 #include "WriterProperties.hxx"
+#include "DocumentHandlerInterface.hxx"
 
 class DocumentElement;
-class DocumentHandler;
 
 class TableCellStyle : public Style
 {
 public:
+	virtual ~TableCellStyle() {};
 	TableCellStyle(const WPXPropertyList &xPropList, const char *psName);
-	virtual void write(DocumentHandler *pHandler) const;
+	virtual void write(DocumentHandlerInterface *pHandler) const;
 private:
         WPXPropertyList mPropList;
 };
@@ -54,8 +55,9 @@
 class TableRowStyle : public Style
 {
 public:
+	virtual ~TableRowStyle() {};
 	TableRowStyle(const WPXPropertyList &propList, const char *psName);
-	virtual void write(DocumentHandler *pHandler) const;
+	virtual void write(DocumentHandlerInterface *pHandler) const;
 private:
         WPXPropertyList mPropList;
 };
@@ -64,8 +66,8 @@
 {
 public:
 	TableStyle(const WPXPropertyList &xPropList, const WPXPropertyListVector &columns, const char *psName);
-	~TableStyle();
-	virtual void write(DocumentHandler *pHandler) const;
+	virtual ~TableStyle();
+	virtual void write(DocumentHandlerInterface *pHandler) const;
 	int getNumColumns() const { return mColumns.count(); }
 	void addTableCellStyle(TableCellStyle *pTableCellStyle) { mTableCellStyles.push_back(pTableCellStyle); }
 	int getNumTableCellStyles() { return mTableCellStyles.size(); }
diff -u -r -N writerperfect//source/filter/TextRunStyle.cxx writerperfect//source/filter/TextRunStyle.cxx
--- writerperfect//source/filter/TextRunStyle.cxx	2008-11-17 22:06:28.000000000 +0100
+++ writerperfect//source/filter/TextRunStyle.cxx	2008-11-17 22:07:19.000000000 +0100
@@ -50,91 +50,95 @@
 	delete mpPropList;
 }
 
-void ParagraphStyle::write(DocumentHandler *pHandler) const
+void ParagraphStyle::write(DocumentHandlerInterface *pHandler) const
 {
 	WRITER_DEBUG_MSG(("Writing a paragraph style..\n"));
 
-        WPXPropertyList propList;
+	WPXPropertyList propList;
 	propList.insert("style:name", msName.cstr());
 	propList.insert("style:family", "paragraph");
 	propList.insert("style:parent-style-name", (*mpPropList)["style:parent-style-name"]->getStr());
 	if ((*mpPropList)["style:master-page-name"])
 		propList.insert("style:master-page-name", (*mpPropList)["style:master-page-name"]->getStr());
-        pHandler->startElement("style:style", propList);
+	pHandler->startElement("style:style", propList);
 
-        propList.clear();
-	WPXPropertyList::Iter k((*mpPropList));
-	for (k.rewind(); k.next(); )
-	{
-                if (strcmp(k.key(), "style:list-style-name") == 0)
-                        propList.insert("style:list-style-name", k()->getStr());
-		if (strcmp(k.key(), "fo:margin-left") == 0)
-			propList.insert("fo:margin-left", k()->getStr());
-		if (strcmp(k.key(), "fo:margin-right") == 0)
-			propList.insert("fo:margin-right", k()->getStr());
-		if (strcmp(k.key(), "fo:text-indent") == 0)
-			propList.insert("fo:text-indent", k()->getStr());
-		if (strcmp(k.key(), "fo:margin-top") == 0)
-			propList.insert("fo:margin-top", k()->getStr());
-		if (strcmp(k.key(), "fo:margin-bottom") == 0)
+	propList.clear();
+	WPXPropertyList::Iter i((*mpPropList));
+	for (i.rewind(); i.next(); )
+	{
+#if 0
+		if (strcmp(i.key(), "style:list-style-name") == 0)
+			propList.insert("style:list-style-name", i()->getStr());
+#endif
+		if (strcmp(i.key(), "fo:margin-left") == 0)
+			propList.insert("fo:margin-left", i()->getStr());
+		if (strcmp(i.key(), "fo:margin-right") == 0)
+			propList.insert("fo:margin-right", i()->getStr());
+		if (strcmp(i.key(), "fo:text-indent") == 0)
+			propList.insert("fo:text-indent", i()->getStr());
+		if (strcmp(i.key(), "fo:margin-top") == 0)
+			propList.insert("fo:margin-top", i()->getStr());
+		if (strcmp(i.key(), "fo:margin-bottom") == 0)
 		{
-			if (k()->getFloat() > 0.0f)
-				propList.insert("fo:margin-bottom", k()->getStr());
+			if (i()->getFloat() > 0.0f)
+				propList.insert("fo:margin-bottom", i()->getStr());
 			else
 				propList.insert("fo:margin-bottom", 0.0f);
 		}
-		if (strcmp(k.key(), "fo:line-height") == 0)
-			propList.insert("fo:line-height", k()->getStr());
-		if (strcmp(k.key(), "fo:break-before") == 0) 
-			propList.insert("fo:break-before", k()->getStr());
-		if (strcmp(k.key(), "fo:text-align") == 0) 
-			propList.insert("fo:text-align", k()->getStr());
-                if (strcmp(k.key(), "fo:text-align-last") == 0)
-                        propList.insert("fo:text-align-last", k()->getStr());
+		if (strcmp(i.key(), "fo:line-height") == 0)
+			propList.insert("fo:line-height", i()->getStr());
+		if (strcmp(i.key(), "fo:break-before") == 0) 
+			propList.insert("fo:break-before", i()->getStr());
+		if (strcmp(i.key(), "fo:text-align") == 0) 
+			propList.insert("fo:text-align", i()->getStr());
+		if (strcmp(i.key(), "fo:text-align-last") == 0)
+			propList.insert("fo:text-align-last", i()->getStr());
 	}
 	
 	propList.insert("style:justify-single-word", "false");
-	pHandler->startElement("style:properties", propList);
+	pHandler->startElement("style:paragraph-properties", propList);
 
-        if (mxTabStops.count() > 0) 
-        {
-                TagOpenElement tabListOpen("style:tab-stops");
-                tabListOpen.write(pHandler);
-                WPXPropertyListVector::Iter i(mxTabStops);
-                for (i.rewind(); i.next();)
-                {
-                        TagOpenElement tabStopOpen("style:tab-stop");
-                        
-                        WPXPropertyList::Iter j(i());
-                        for (j.rewind(); j.next(); )
-                        {
-                                tabStopOpen.addAttribute(j.key(), j()->getStr().cstr());			
-                        }
-                        tabStopOpen.write(pHandler);
-                        pHandler->endElement("style:tab-stop");
-                }
-                pHandler->endElement("style:tab-stops");
-        }
+	if (mxTabStops.count() > 0) 
+	{
+		TagOpenElement tabListOpen("style:tab-stops");
+		tabListOpen.write(pHandler);
+		WPXPropertyListVector::Iter i2(mxTabStops);
+		for (i2.rewind(); i2.next();)
+		{
+			if (i2()["style:position"] && i2()["style:position"]->getFloat() < 0)
+				continue;
+			TagOpenElement tabStopOpen("style:tab-stop");
+			
+			WPXPropertyList::Iter j(i2());
+			for (j.rewind(); j.next(); )
+			{
+				tabStopOpen.addAttribute(j.key(), j()->getStr().cstr());			
+			}
+			tabStopOpen.write(pHandler);
+			pHandler->endElement("style:tab-stop");
+		}
+		pHandler->endElement("style:tab-stops");
+	}
 
-	pHandler->endElement("style:properties");
+	pHandler->endElement("style:paragraph-properties");
 	pHandler->endElement("style:style");
 }
 
 SpanStyle::SpanStyle(const char *psName, const WPXPropertyList &xPropList) :
 	Style(psName),
-        mPropList(xPropList)
+	mPropList(xPropList)
 {
 }
 
-void SpanStyle::write(DocumentHandler *pHandler) const 
+void SpanStyle::write(DocumentHandlerInterface *pHandler) const 
 {
 	WRITER_DEBUG_MSG(("Writing a span style..\n"));
-        WPXPropertyList styleOpenList;    
+	WPXPropertyList styleOpenList;    
 	styleOpenList.insert("style:name", getName());
 	styleOpenList.insert("style:family", "text");
-        pHandler->startElement("style:style", styleOpenList);
+	pHandler->startElement("style:style", styleOpenList);
 
-        WPXPropertyList propList(mPropList);    
+	WPXPropertyList propList(mPropList);    
 
 	if (mPropList["style:font-name"])
 	{
@@ -144,8 +148,13 @@
 
 	if (mPropList["fo:font-size"])
 	{
-		propList.insert("style:font-size-asian", mPropList["fo:font-size"]->getStr());
-		propList.insert("style:font-size-complex", mPropList["fo:font-size"]->getStr());
+		if (mPropList["fo:font-size"]->getFloat() > 0.0f)
+		{
+			propList.insert("style:font-size-asian", mPropList["fo:font-size"]->getStr());
+			propList.insert("style:font-size-complex", mPropList["fo:font-size"]->getStr());
+		}
+		else
+			propList.remove("fo:font-size");
 	}
 	
 	if (mPropList["fo:font-weight"])
@@ -160,8 +169,8 @@
 		propList.insert("style:font-style-complex", mPropList["fo:font-style"]->getStr());
 	}
 
-        pHandler->startElement("style:properties", propList);
+	pHandler->startElement("style:text-properties", propList);
 
-	pHandler->endElement("style:properties");
+	pHandler->endElement("style:text-properties");
 	pHandler->endElement("style:style");
 }
diff -u -r -N writerperfect//source/filter/TextRunStyle.hxx writerperfect//source/filter/TextRunStyle.hxx
--- writerperfect//source/filter/TextRunStyle.hxx	2008-11-17 22:06:28.000000000 +0100
+++ writerperfect//source/filter/TextRunStyle.hxx	2008-11-17 22:07:19.000000000 +0100
@@ -29,26 +29,19 @@
 
 #ifndef _TEXTRUNSTYLE_H
 #define _TEXTRUNSTYLE_H
-#if defined _MSC_VER
-#pragma warning( push, 1 )
-#endif
 #include <libwpd/libwpd.h>
-#if defined _MSC_VER
-#pragma warning( pop )
-#endif
 
 #include "Style.hxx"
 
 class TagOpenElement;
 class DocumentElement;
-class DocumentHandler;
 
 class ParagraphStyle
 {
 public:
 	ParagraphStyle(WPXPropertyList *propList, const WPXPropertyListVector &tabStops, const WPXString &sName);
 	virtual ~ParagraphStyle();
-	virtual void write(DocumentHandler *pHandler) const;
+	virtual void write(DocumentHandlerInterface *pHandler) const;
 	WPXString getName() const { return msName; }
 private:
 	WPXPropertyList *mpPropList;
@@ -61,7 +54,7 @@
 {
 public:
 	SpanStyle(const char *psName, const WPXPropertyList &xPropList);
-	virtual void write(DocumentHandler *pHandler) const;
+	virtual void write(DocumentHandlerInterface *pHandler) const;
 
 private:
         WPXPropertyList mPropList;
diff -u -r -N writerperfect//source/filter/WriterProperties.hxx writerperfect//source/filter/WriterProperties.hxx
--- writerperfect//source/filter/WriterProperties.hxx	2008-11-17 22:06:28.000000000 +0100
+++ writerperfect//source/filter/WriterProperties.hxx	2008-11-17 22:07:19.000000000 +0100
@@ -32,5 +32,4 @@
 #define IMP_DEFAULT_FONT_NAME "Times New Roman"
 #define IMP_DEFAULT_FONT_SIZE 12.0f
 #define IMP_DEFAULT_FONT_PITCH "variable"
-#define IMP_DEFAULT_FONT_COLOR (new RGBSColor(0x00,0x00,0x00,0x64))
 #endif
diff -u -r -N writerperfect//source/stream/WPXSvStream.cxx writerperfect//source/stream/WPXSvStream.cxx
--- writerperfect//source/stream/WPXSvStream.cxx	2008-11-17 22:06:28.000000000 +0100
+++ writerperfect//source/stream/WPXSvStream.cxx	2008-11-17 22:07:19.000000000 +0100
@@ -9,7 +9,7 @@
 using namespace ::com::sun::star::io;
 
 WPXSvInputStream::WPXSvInputStream( Reference< XInputStream > xStream ) :
-		WPSInputStream(),
+		WPXInputStream(),
 		mxChildStorage(),
 		mxChildStream(),
 		mxStream(xStream),
@@ -41,7 +41,7 @@
 {
 }
 
-const uint8_t * WPXSvInputStream::read(size_t numBytes, size_t &numBytesRead)
+const unsigned char * WPXSvInputStream::read(size_t numBytes, size_t &numBytesRead)
 {
 	numBytesRead = 0;
 
@@ -52,7 +52,7 @@
 	if (numBytesRead == 0)
 		return 0;
 
-	return (const uint8_t *)maData.getConstArray();
+	return (const unsigned char *)maData.getConstArray();
 }
 
 long WPXSvInputStream::tell()
@@ -167,8 +167,3 @@
 	else
 		return 0;
 }
-
-WPXInputStream * WPXSvInputStream::getDocumentOLEStream()
-{
-	return getDocumentOLEStream( "PerfectOffice_MAIN" );
-}
diff -u -r -N writerperfect//source/stream/WPXSvStream.h writerperfect//source/stream/WPXSvStream.h
--- writerperfect//source/stream/WPXSvStream.h	2008-11-17 22:06:28.000000000 +0100
+++ writerperfect//source/stream/WPXSvStream.h	2008-11-17 22:07:19.000000000 +0100
@@ -12,13 +12,12 @@
 #if defined _MSC_VER
 #pragma warning( push, 1 )
 #endif
-#include <libwps/WPSStream.h>
-#include <libwpd/WPXStream.h>
+#include <libwpd-stream/WPXStream.h>
 #if defined _MSC_VER
 #pragma warning( pop )
 #endif
 
-class WPXSvInputStream : public WPSInputStream
+class WPXSvInputStream : public WPXInputStream
 {
 public:
 	WPXSvInputStream( ::com::sun::star::uno::Reference<
@@ -26,10 +25,9 @@
 	virtual ~WPXSvInputStream();
 
 	virtual bool isOLEStream();
-	virtual WPXInputStream * getDocumentOLEStream();
 	virtual WPXInputStream * getDocumentOLEStream(const char *name);
 
-	virtual const uint8_t *read(size_t numBytes, size_t &numBytesRead);
+	virtual const unsigned char *read(size_t numBytes, size_t &numBytesRead);
 	virtual int seek(long offset, WPX_SEEK_TYPE seekType);
 	virtual long tell();
 	virtual bool atEOS();
diff -u -r -N writerperfect//source/wpdimp/makefile.mk writerperfect//source/wpdimp/makefile.mk
--- writerperfect//source/wpdimp/makefile.mk	2008-11-17 22:06:28.000000000 +0100
+++ writerperfect//source/wpdimp/makefile.mk	2008-11-17 22:07:19.000000000 +0100
@@ -10,6 +10,10 @@
 INCPRE+=$(LIBWPD_CFLAGS)
 .ENDIF
 
+.IF "$(SYSTEM_LIBWPG)" == "YES"
+INCPRE+=$(LIBWPG_CFLAGS)
+.ENDIF
+
 .IF "$(SYSTEM_LIBWPS)" == "YES"
 INCPRE+=$(LIBWPS_CFLAGS)
 .ENDIF
diff -u -r -N writerperfect//source/wpdimp/WordPerfectCollector.cxx writerperfect//source/wpdimp/WordPerfectCollector.cxx
--- writerperfect//source/wpdimp/WordPerfectCollector.cxx	2008-11-17 22:06:28.000000000 +0100
+++ writerperfect//source/wpdimp/WordPerfectCollector.cxx	2008-11-17 22:07:19.000000000 +0100
@@ -35,8 +35,9 @@
 #pragma warning( pop )
 #endif
 
-WordPerfectCollector::WordPerfectCollector(WPSInputStream *pInput, DocumentHandler *pHandler) :
-	DocumentCollector(pInput, pHandler)
+WordPerfectCollector::WordPerfectCollector(WPXInputStream *pInput, DocumentHandlerInterface *pHandler, const rtl::OString& password) :
+	DocumentCollector(pInput, pHandler),
+	maUtf8Password(password)
 {
 }
 
@@ -44,9 +45,13 @@
 {
 }
 
-bool WordPerfectCollector::parseSourceDocument(WPSInputStream &input)
+bool WordPerfectCollector::parseSourceDocument(WPXInputStream &input)
 {
-        WPDResult result = WPDocument::parse(&input, static_cast<WPXHLListenerImpl *>(this));
+        WPDResult result;
+		if (maUtf8Password.getLength())
+			result = WPDocument::parse(&input, static_cast<WPXDocumentInterface *>(this), maUtf8Password.getStr());
+		else
+			result = WPDocument::parse(&input, static_cast<WPXDocumentInterface *>(this), NULL);
         if (result != WPD_OK)
                 return false;
 
diff -u -r -N writerperfect//source/wpdimp/WordPerfectCollector.hxx writerperfect//source/wpdimp/WordPerfectCollector.hxx
--- writerperfect//source/wpdimp/WordPerfectCollector.hxx	2008-11-17 22:06:28.000000000 +0100
+++ writerperfect//source/wpdimp/WordPerfectCollector.hxx	2008-11-17 22:07:19.000000000 +0100
@@ -30,12 +30,16 @@
 #define _WORDPERFECTCOLLECTOR_HXX
 
 #include "filter/DocumentCollector.hxx"
+#include "filter/DocumentHandlerInterface.hxx"
+#include <rtl/ustring.hxx>
 
 class WordPerfectCollector : public DocumentCollector
 {
 public:
-	WordPerfectCollector(WPSInputStream *pInput, DocumentHandler *pHandler);
+	WordPerfectCollector(WPXInputStream *pInput, DocumentHandlerInterface *pHandler, const rtl::OString& password);
 	virtual ~WordPerfectCollector();
-	bool parseSourceDocument(WPSInputStream &pInput);
+	bool parseSourceDocument(WPXInputStream &pInput);
+private:
+	rtl::OString maUtf8Password;
 };
 #endif
diff -u -r -N writerperfect//source/wpdimp/WordPerfectImportFilter.cxx writerperfect//source/wpdimp/WordPerfectImportFilter.cxx
--- writerperfect//source/wpdimp/WordPerfectImportFilter.cxx	2008-11-17 22:06:28.000000000 +0100
+++ writerperfect//source/wpdimp/WordPerfectImportFilter.cxx	2008-11-17 22:07:19.000000000 +0100
@@ -29,27 +29,19 @@
  */
 
 #include <osl/diagnose.h>
-#ifndef _RTL_TENCINFO_H_
 #include <rtl/tencinfo.h>
-#endif
 #include <com/sun/star/lang/XMultiServiceFactory.hpp>
-#include <com/sun/star/io/XInputStream.hpp>
 #include <com/sun/star/xml/sax/XAttributeList.hpp>
 #include <com/sun/star/xml/sax/XDocumentHandler.hpp>
 #include <com/sun/star/xml/sax/InputSource.hpp>
 #include <com/sun/star/xml/sax/XParser.hpp>
-
-#ifndef _COM_SUN_STAR_UCB_XCOMMANDENVIRONMENT_HPP
+#include <com/sun/star/ui/dialogs/ExecutableDialogResults.hpp>
 #include <com/sun/star/ucb/XCommandEnvironment.hpp>
-#endif
 
-#ifndef _ATTRLIST_HPP_
 #include <xmloff/attrlist.hxx>
-#endif
-#ifndef _XMLKYWD_HPP
 #include <xmloff/xmlkywd.hxx>
-#endif
 #include <ucbhelper/content.hxx>
+#include <sfx2/passwd.hxx>
 
 #include "filter/FilterInternal.hxx"
 #include "filter/DocumentHandler.hxx"
@@ -98,7 +90,6 @@
 	throw (RuntimeException)
 {
 	WRITER_DEBUG_MSG(("WordPerfectImportFilter::importImpl: Got here!\n"));
-
 	sal_Int32 nLength = aDescriptor.getLength();
 	const PropertyValue * pValue = aDescriptor.getConstArray();
 	OUString sURL;
@@ -115,24 +106,49 @@
 	    OSL_ASSERT( 0 );
 	    return sal_False;
 	}
-	OString sFileName;
-	sFileName = OUStringToOString(sURL, RTL_TEXTENCODING_INFO_ASCII);
+
+	WPXSvInputStream input( xInputStream );
+
+#if 1
+	OString aUtf8Passwd;
+
+	WPDConfidence confidence = WPDocument::isFileFormatSupported(&input);
+
+	if (WPD_CONFIDENCE_SUPPORTED_ENCRYPTION == confidence)
+	{
+		int unsuccessfulAttempts = 0;
+		while (true )
+		{
+			SfxPasswordDialog aPasswdDlg( 0 );
+			aPasswdDlg.SetMinLen(0);
+			if(!aPasswdDlg.Execute())
+				return sal_False;
+			String aPasswd = aPasswdDlg.GetPassword();
+			OUString aUniPasswd(aPasswd.GetBuffer() /*, aPasswd.Len(), RTL_TEXTENCODING_UCS2 */);
+			aUtf8Passwd = OUStringToOString(aUniPasswd, RTL_TEXTENCODING_UTF8);
+			if (WPD_PASSWORD_MATCH_OK == WPDocument::verifyPassword(&input, aUtf8Passwd.getStr()))
+				break;
+			else
+				unsuccessfulAttempts++;
+			if (unsuccessfulAttempts == 3) // timeout after 3 password atempts
+				return sal_False;
+		}
+	}
+#endif
 
 	// An XML import service: what we push sax messages to..
-	OUString sXMLImportService ( RTL_CONSTASCII_USTRINGPARAM ( "com.sun.star.comp.Writer.XMLImporter" ) );
+	OUString sXMLImportService ( RTL_CONSTASCII_USTRINGPARAM ( "com.sun.star.comp.Writer.XMLOasisImporter" ) );
 	uno::Reference < XDocumentHandler > xInternalHandler( mxMSF->createInstance( sXMLImportService ), UNO_QUERY );
 
 	// The XImporter sets up an empty target document for XDocumentHandler to write to.. 
 	uno::Reference < XImporter > xImporter(xInternalHandler, UNO_QUERY);
 	xImporter->setTargetDocument(mxDoc);
 
-        // OO Document Handler: abstract class to handle document SAX messages, concrete implementation here
-        // writes to in-memory target doc
-        DocumentHandler xHandler(xInternalHandler);
-
-	WPXSvInputStream input( xInputStream );
+	// OO Document Handler: abstract class to handle document SAX messages, concrete implementation here
+	// writes to in-memory target doc
+	DocumentHandler xHandler(xInternalHandler);
 
-	WordPerfectCollector collector(&input, &xHandler);
+	WordPerfectCollector collector(&input, &xHandler, aUtf8Passwd);
 	collector.filter();
 
 	return true;
@@ -204,9 +220,9 @@
 	if (input.atEOS())
         return ::rtl::OUString();
 
-	confidence = WPDocument::isFileFormatSupported(&input, false);
+	confidence = WPDocument::isFileFormatSupported(&input);
 
-	if (confidence == WPD_CONFIDENCE_EXCELLENT)
+	if (confidence == WPD_CONFIDENCE_EXCELLENT || confidence == WPD_CONFIDENCE_SUPPORTED_ENCRYPTION)
 		sTypeName = OUString( RTL_CONSTASCII_USTRINGPARAM ( "writer_WordPerfect_Document" ) );
 
     if (sTypeName.getLength())
@@ -263,11 +279,10 @@
 	throw (RuntimeException)
 {
 	Sequence < OUString > aRet(2);
-//	Sequence < OUString > aRet(1);
-        OUString* pArray = aRet.getArray();
-        pArray[0] =  OUString ( RTL_CONSTASCII_USTRINGPARAM ( SERVICE_NAME1 ) );
+	OUString* pArray = aRet.getArray();
+	pArray[0] =  OUString ( RTL_CONSTASCII_USTRINGPARAM ( SERVICE_NAME1 ) );
 	pArray[1] =  OUString ( RTL_CONSTASCII_USTRINGPARAM ( SERVICE_NAME2 ) ); 
-        return aRet;
+	return aRet;
 }
 #undef SERVICE_NAME2
 #undef SERVICE_NAME1
@@ -294,3 +309,125 @@
 {
     return WordPerfectImportFilter_getSupportedServiceNames();
 }
+
+
+WordPerfectImportFilterDialog::WordPerfectImportFilterDialog(const ::com::sun::star::uno::Reference<com::sun::star::lang::XMultiServiceFactory > &r ) :
+    mxMSF( r ) {}
+
+WordPerfectImportFilterDialog::~WordPerfectImportFilterDialog()
+{
+}
+
+void SAL_CALL WordPerfectImportFilterDialog::setTitle( const ::rtl::OUString& )
+            throw (::com::sun::star::uno::RuntimeException)
+{
+}
+
+sal_Int16 SAL_CALL WordPerfectImportFilterDialog::execute()
+            throw (::com::sun::star::uno::RuntimeException)
+{
+	WPXSvInputStream input( mxInputStream );
+
+	OString aUtf8Passwd;
+
+	WPDConfidence confidence = WPDocument::isFileFormatSupported(&input);
+
+	if (WPD_CONFIDENCE_SUPPORTED_ENCRYPTION == confidence)
+	{
+		int unsuccessfulAttempts = 0;
+		while (true )
+		{
+			SfxPasswordDialog aPasswdDlg(0);
+			aPasswdDlg.SetMinLen(0);
+			if(!aPasswdDlg.Execute())
+				return com::sun::star::ui::dialogs::ExecutableDialogResults::CANCEL;
+			msPassword = ::rtl::OUString(aPasswdDlg.GetPassword().GetBuffer());
+			aUtf8Passwd = OUStringToOString(msPassword, RTL_TEXTENCODING_UTF8);
+			if (WPD_PASSWORD_MATCH_OK == WPDocument::verifyPassword(&input, aUtf8Passwd.getStr()))
+				break;
+			else
+				unsuccessfulAttempts++;
+			if (unsuccessfulAttempts == 3) // timeout after 3 password atempts
+				return com::sun::star::ui::dialogs::ExecutableDialogResults::CANCEL;
+		}
+	}
+	return com::sun::star::ui::dialogs::ExecutableDialogResults::OK;
+}
+
+uno::Sequence<beans::PropertyValue> SAL_CALL WordPerfectImportFilterDialog::getPropertyValues() throw(uno::RuntimeException)
+{
+    uno::Sequence<beans::PropertyValue> aRet(1);
+	beans::PropertyValue* pArray = aRet.getArray();
+
+    pArray[0].Name = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Password") );
+    pArray[0].Value <<= msPassword;
+
+	return aRet;
+}
+
+void SAL_CALL WordPerfectImportFilterDialog::setPropertyValues( const uno::Sequence<beans::PropertyValue>& aProps)
+					throw(beans::UnknownPropertyException, beans::PropertyVetoException,
+							lang::IllegalArgumentException, lang::WrappedTargetException, uno::RuntimeException)
+{
+    const beans::PropertyValue* pPropArray = aProps.getConstArray();
+	long nPropCount = aProps.getLength();
+	for (long i = 0; i < nPropCount; i++)
+	{
+		const beans::PropertyValue& rProp = pPropArray[i];
+        ::rtl::OUString aPropName = rProp.Name;
+
+		if ( aPropName == ::rtl::OUString(RTL_CONSTASCII_USTRINGPARAM("Password")) )
+            rProp.Value >>= msPassword;
+        else if ( aPropName.equalsAscii( "InputStream" ) )
+			rProp.Value >>= mxInputStream;
+	}
+}
+
+
+// XServiceInfo
+OUString SAL_CALL WordPerfectImportFilterDialog::getImplementationName(  )
+    throw (RuntimeException)
+{
+    return WordPerfectImportFilterDialog_getImplementationName();
+}
+
+sal_Bool SAL_CALL WordPerfectImportFilterDialog::supportsService( const OUString& rServiceName )
+    throw (RuntimeException)
+{
+    return WordPerfectImportFilterDialog_supportsService( rServiceName );
+}
+
+Sequence< OUString > SAL_CALL WordPerfectImportFilterDialog::getSupportedServiceNames(  )
+    throw (RuntimeException)
+{
+    return WordPerfectImportFilterDialog_getSupportedServiceNames();
+}
+
+OUString WordPerfectImportFilterDialog_getImplementationName ()
+    throw (RuntimeException)
+{
+    return OUString ( RTL_CONSTASCII_USTRINGPARAM ( "com.sun.star.comp.Writer.WordPerfectImportFilterDialog" ) );
+}
+
+#define SERVICE_NAME "com.sun.star.ui.dialogs.FilterOptionsDialog"
+sal_Bool SAL_CALL WordPerfectImportFilterDialog_supportsService( const OUString& ServiceName )
+    throw (RuntimeException)
+{
+    return ( ServiceName.equalsAsciiL( RTL_CONSTASCII_STRINGPARAM ( SERVICE_NAME ) ) );
+}
+
+Sequence< OUString > SAL_CALL WordPerfectImportFilterDialog_getSupportedServiceNames(  )
+    throw (RuntimeException)
+{
+    Sequence < OUString > aRet(1);
+    OUString* pArray = aRet.getArray();
+    pArray[0] =  OUString ( RTL_CONSTASCII_USTRINGPARAM ( SERVICE_NAME ) );
+    return aRet;
+}
+#undef SERVICE_NAME
+
+uno::Reference< XInterface > SAL_CALL WordPerfectImportFilterDialog_createInstance( const uno::Reference< XMultiServiceFactory > & rSMgr)
+    throw( Exception )
+{
+    return (cppu::OWeakObject*) new WordPerfectImportFilterDialog( rSMgr );
+}
diff -u -r -N writerperfect//source/wpdimp/WordPerfectImportFilter.hxx writerperfect//source/wpdimp/WordPerfectImportFilter.hxx
--- writerperfect//source/wpdimp/WordPerfectImportFilter.hxx	2008-11-17 22:06:28.000000000 +0100
+++ writerperfect//source/wpdimp/WordPerfectImportFilter.hxx	2008-11-17 22:07:19.000000000 +0100
@@ -32,9 +32,13 @@
 #include <com/sun/star/document/XFilter.hpp>
 #include <com/sun/star/document/XImporter.hpp>
 #include <com/sun/star/document/XExtendedFilterDetection.hpp>
+#include <com/sun/star/beans/XPropertyAccess.hpp>
+#include <com/sun/star/ui/dialogs/XExecutableDialog.hpp>
 #include <com/sun/star/lang/XInitialization.hpp>
 #include <com/sun/star/lang/XServiceInfo.hpp>
 #include <com/sun/star/xml/sax/XDocumentHandler.hpp>
+#include <com/sun/star/io/XInputStream.hpp>
+#include <cppuhelper/implbase3.hxx>
 #include <cppuhelper/implbase5.hxx>
 
 enum FilterType 
@@ -112,4 +116,60 @@
 SAL_CALL WordPerfectImportFilter_createInstance( const ::com::sun::star::uno::Reference< ::com::sun::star::lang::XMultiServiceFactory > & rSMgr)
 	throw ( ::com::sun::star::uno::Exception );
 
+
+class WordPerfectImportFilterDialog : public cppu::WeakImplHelper3 <
+		com::sun::star::ui::dialogs::XExecutableDialog,
+		com::sun::star::lang::XServiceInfo,
+		com::sun::star::beans::XPropertyAccess
+>
+{
+    ::com::sun::star::uno::Reference< ::com::sun::star::lang::XMultiServiceFactory > mxMSF;
+	::rtl::OUString msPassword;
+	::com::sun::star::uno::Reference< ::com::sun::star::io::XInputStream > mxInputStream;
+
+    ~WordPerfectImportFilterDialog();
+
+	// XExecutableDialog
+       virtual void SAL_CALL setTitle( const ::rtl::OUString& aTitle )
+            throw (::com::sun::star::uno::RuntimeException);
+       virtual sal_Int16 SAL_CALL execute()
+            throw (::com::sun::star::uno::RuntimeException);
+
+    // XServiceInfo
+        virtual ::rtl::OUString SAL_CALL getImplementationName(  )
+            throw (::com::sun::star::uno::RuntimeException);
+        virtual sal_Bool SAL_CALL supportsService( const ::rtl::OUString& ServiceName )
+            throw (::com::sun::star::uno::RuntimeException);
+        virtual ::com::sun::star::uno::Sequence< ::rtl::OUString > SAL_CALL getSupportedServiceNames(  )
+            throw (::com::sun::star::uno::RuntimeException);
+
+	// XPropertyAccess
+		virtual ::com::sun::star::uno::Sequence< ::com::sun::star::beans::PropertyValue >
+							SAL_CALL getPropertyValues() throw (::com::sun::star::uno::RuntimeException);
+		virtual void SAL_CALL	setPropertyValues( const ::com::sun::star::uno::Sequence<
+									::com::sun::star::beans::PropertyValue >& aProps )
+								throw (::com::sun::star::beans::UnknownPropertyException,
+										::com::sun::star::beans::PropertyVetoException,
+										::com::sun::star::lang::IllegalArgumentException,
+										::com::sun::star::lang::WrappedTargetException,
+										::com::sun::star::uno::RuntimeException);
+
+public:
+	WordPerfectImportFilterDialog(const ::com::sun::star::uno::Reference<com::sun::star::lang::XMultiServiceFactory > &r );
+
+};
+
+::rtl::OUString WordPerfectImportFilterDialog_getImplementationName()
+    throw ( ::com::sun::star::uno::RuntimeException );
+
+sal_Bool SAL_CALL WordPerfectImportFilterDialog_supportsService( const ::rtl::OUString& ServiceName )
+    throw ( ::com::sun::star::uno::RuntimeException );
+
+::com::sun::star::uno::Sequence< ::rtl::OUString > SAL_CALL WordPerfectImportFilterDialog_getSupportedServiceNames(  )
+    throw ( ::com::sun::star::uno::RuntimeException );
+
+::com::sun::star::uno::Reference< ::com::sun::star::uno::XInterface >
+SAL_CALL WordPerfectImportFilterDialog_createInstance( const ::com::sun::star::uno::Reference< ::com::sun::star::lang::XMultiServiceFactory > & rSMgr)
+    throw ( ::com::sun::star::uno::Exception );
+
 #endif
diff -u -r -N writerperfect//source/wpdimp/wpft_genericfilter.cxx writerperfect//source/wpdimp/wpft_genericfilter.cxx
--- writerperfect//source/wpdimp/wpft_genericfilter.cxx	2008-11-17 22:06:28.000000000 +0100
+++ writerperfect//source/wpdimp/wpft_genericfilter.cxx	2008-11-17 22:07:19.000000000 +0100
@@ -55,14 +55,22 @@
 		{
             sal_Int32 nPos = 0;
             Reference< XRegistryKey > xNewKey(
-				reinterpret_cast< XRegistryKey * >( pRegistryKey )->createKey( WordPerfectImportFilter_getImplementationName() ) ); 
+				reinterpret_cast< XRegistryKey * >( pRegistryKey )->createKey( WordPerfectImportFilter_getImplementationName() ) );
             xNewKey = xNewKey->createKey( OUString::createFromAscii( "/UNO/SERVICES" ) );
-			
+
 			const Sequence< OUString > & rSNL = WordPerfectImportFilter_getSupportedServiceNames();
 			const OUString * pArray = rSNL.getConstArray();
 			for ( nPos = rSNL.getLength(); nPos--; )
 				xNewKey->createKey( pArray[nPos] );
+#if 0
+			xNewKey = reinterpret_cast< XRegistryKey * >( pRegistryKey )->createKey( WordPerfectImportFilterDialog_getImplementationName() );
+            xNewKey = xNewKey->createKey( OUString::createFromAscii( "/UNO/SERVICES" ) );
 
+			const Sequence< OUString > & rSNL2 = WordPerfectImportFilterDialog_getSupportedServiceNames();
+			pArray = rSNL2.getConstArray();
+			for ( nPos = rSNL2.getLength(); nPos--; )
+				xNewKey->createKey( pArray[nPos] );
+#endif
 			return sal_True;
 		}
 		catch (InvalidRegistryException &)
@@ -85,14 +93,29 @@
 			reinterpret_cast< XMultiServiceFactory * >( pServiceManager ),
 			OUString::createFromAscii( pImplName ),
 			WordPerfectImportFilter_createInstance, WordPerfectImportFilter_getSupportedServiceNames() ) );
-		
+
+		if (xFactory.is())
+		{
+			xFactory->acquire();
+			pRet = xFactory.get();
+		}
+	}
+#if 0
+	else if ( pServiceManager && implName.equals(WordPerfectImportFilterDialog_getImplementationName()) )
+	{
+		Reference< XSingleServiceFactory > xFactory( createSingleFactory(
+			reinterpret_cast< XMultiServiceFactory * >( pServiceManager ),
+			OUString::createFromAscii( pImplName ),
+			WordPerfectImportFilterDialog_createInstance, WordPerfectImportFilterDialog_getSupportedServiceNames() ) );
+
 		if (xFactory.is())
 		{
 			xFactory->acquire();
 			pRet = xFactory.get();
 		}
 	}
-	
+#endif
+
 	return pRet;
 }
 }
diff -u -r -N writerperfect//source/wpgimp/makefile.mk writerperfect//source/wpgimp/makefile.mk
--- writerperfect//source/wpgimp/makefile.mk	2008-11-17 22:06:28.000000000 +0100
+++ writerperfect//source/wpgimp/makefile.mk	2008-11-17 22:07:19.000000000 +0100
@@ -12,12 +12,6 @@
 INCPRE+=$(SOLARVER)$/$(UPD)$/$(INPATH)$/inc$/libwpd
 .ENDIF
 
-.IF "$(SYSTEM_LIBWPS)" == "YES"
-INCPRE+=$(LIBWPS_CFLAGS)
-.ELSE
-INCPRE+=$(SOLARVER)$/$(UPD)$/$(INPATH)$/inc$/libwps
-.ENDIF
-
 .IF "$(SYSTEM_LIBWPG)" == "YES"
 INCPRE+=$(LIBWPG_CFLAGS)
 .ELSE
@@ -28,7 +22,6 @@
 INCPRE+= -I..
 
 SLOFILES= \
-    $(SLO)$/OdgExporter.obj  \
     $(SLO)$/WPGImportFilter.obj \
 	$(SLO)$/wpgimport_genericfilter.obj		
 
diff -u -r -N writerperfect//source/wpgimp/WPGImportFilter.cxx writerperfect//source/wpgimp/WPGImportFilter.cxx
--- writerperfect//source/wpgimp/WPGImportFilter.cxx	2008-11-17 22:06:28.000000000 +0100
+++ writerperfect//source/wpgimp/WPGImportFilter.cxx	2008-11-17 22:07:19.000000000 +0100
@@ -75,7 +75,7 @@
 #endif
 
 #include "filter/DocumentHandler.hxx"
-#include "OdgExporter.hxx"
+#include "filter/OdgExporter.hxx"
 #include "WPGImportFilter.hxx"
 #include "stream/WPXSvStream.h"
 
@@ -148,16 +148,6 @@
 
 	WPXInputStream* input = new WPXSvInputStream( xInputStream );
 
-	if (input->isOLEStream())
-	{
-		WPXInputStream* olestream = input->getDocumentOLEStream();
-		if (olestream)
-		{
-			delete input;
-			input = olestream;
-		}
-	}
-
 	OdgExporter exporter(&xHandler);
 	bool tmpParseResult = libwpg::WPGraphics::parse(input, &exporter);
 	if (input)
@@ -207,16 +197,6 @@
     
 	WPXInputStream* input = new WPXSvInputStream( xInputStream );
 
-	if (input->isOLEStream())
-	{
-		WPXInputStream* olestream = input->getDocumentOLEStream();
-		if (olestream)
-		{
-			delete input;
-			input = olestream;
-		}
-	}
-
 	if (libwpg::WPGraphics::isSupported(input))
 		sTypeName = OUString( RTL_CONSTASCII_USTRINGPARAM ( "draw_WordPerfect_Graphics" ) );
 
diff -u -r -N writerperfect//source/wpsimp/MSWorksCollector.cxx writerperfect//source/wpsimp/MSWorksCollector.cxx
--- writerperfect//source/wpsimp/MSWorksCollector.cxx	2008-11-17 22:06:28.000000000 +0100
+++ writerperfect//source/wpsimp/MSWorksCollector.cxx	2008-11-17 22:07:19.000000000 +0100
@@ -29,7 +29,7 @@
 #include "MSWorksCollector.hxx"
 #include <libwps/WPSDocument.h>
 
-MSWorksCollector::MSWorksCollector(WPSInputStream *pInput, DocumentHandler *pHandler) :
+MSWorksCollector::MSWorksCollector(WPXInputStream *pInput, DocumentHandlerInterface *pHandler) :
 	DocumentCollector(pInput, pHandler)
 {
 }
@@ -38,9 +38,9 @@
 {
 }
 
-bool MSWorksCollector::parseSourceDocument(WPSInputStream &input)
+bool MSWorksCollector::parseSourceDocument(WPXInputStream &input)
 {
-        WPSResult result = WPSDocument::parse(&input, static_cast<WPXHLListenerImpl *>(this));
+        WPSResult result = WPSDocument::parse(&input, static_cast<WPXDocumentInterface *>(this));
         if (result != WPS_OK)
                 return false;
 
diff -u -r -N writerperfect//source/wpsimp/MSWorksCollector.hxx writerperfect//source/wpsimp/MSWorksCollector.hxx
--- writerperfect//source/wpsimp/MSWorksCollector.hxx	2008-11-17 22:06:28.000000000 +0100
+++ writerperfect//source/wpsimp/MSWorksCollector.hxx	2008-11-17 22:07:19.000000000 +0100
@@ -30,12 +30,13 @@
 #define _MSWORKSCOLLECTOR_HXX
 
 #include "filter/DocumentCollector.hxx"
+#include "filter/DocumentHandlerInterface.hxx"
 
 class MSWorksCollector : public DocumentCollector
 {
 public:
-	MSWorksCollector(WPSInputStream *pInput, DocumentHandler *pHandler);
+	MSWorksCollector(WPXInputStream *pInput, DocumentHandlerInterface *pHandler);
 	virtual ~MSWorksCollector();
-	bool parseSourceDocument(WPSInputStream &input);
+	bool parseSourceDocument(WPXInputStream &input);
 };
 #endif
diff -u -r -N writerperfect//source/wpsimp/MSWorksImportFilter.cxx writerperfect//source/wpsimp/MSWorksImportFilter.cxx
--- writerperfect//source/wpsimp/MSWorksImportFilter.cxx	2008-11-17 22:06:28.000000000 +0100
+++ writerperfect//source/wpsimp/MSWorksImportFilter.cxx	2008-11-17 22:07:19.000000000 +0100
@@ -127,7 +127,7 @@
 	sFileName = OUStringToOString(sURL, RTL_TEXTENCODING_INFO_ASCII);
 	
 	// An XML import service: what we push sax messages to..
-	OUString sXMLImportService ( RTL_CONSTASCII_USTRINGPARAM ( "com.sun.star.comp.Writer.XMLImporter" ) );
+	OUString sXMLImportService ( RTL_CONSTASCII_USTRINGPARAM ( "com.sun.star.comp.Writer.XMLOasisImporter" ) );
 	Reference < XDocumentHandler > xInternalHandler( mxMSF->createInstance( sXMLImportService ), UNO_QUERY );
 
 	// The XImporter sets up an empty target document for XDocumentHandler to write to.. 
@@ -212,7 +212,7 @@
 	if (input.atEOS())
         return ::rtl::OUString();
 
-	confidence = WPSDocument::isFileFormatSupported(&input, false);
+	confidence = WPSDocument::isFileFormatSupported(&input);
 
 	if ((confidence == WPS_CONFIDENCE_EXCELLENT) || (confidence == WPS_CONFIDENCE_GOOD))
 		sTypeName = OUString( RTL_CONSTASCII_USTRINGPARAM ( "writer_MS_Works_Document" ) );
diff -u -r -N writerperfect//util/makefile.mk writerperfect//util/makefile.mk
--- writerperfect//util/makefile.mk	2008-11-17 22:06:28.000000000 +0100
+++ writerperfect//util/makefile.mk	2008-11-17 22:07:19.000000000 +0100
@@ -44,6 +44,8 @@
 	$(SOTLIB) \
 	$(SO2LIB) \
 	$(SVTOOLLIB) \
+	$(SFXLIB) \
+	$(VCLLIB) \
 	$(UNOTOOLSLIB) \
 	$(TOOLSLIB) \
 	$(COMPHELPERLIB) \
@@ -52,7 +54,8 @@
 	$(CPPULIB) \
 	$(SALLIB) \
 	$(XMLOFFLIB) \
-	$(LIBWPD)
+	$(LIBWPD) \
+	$(LIBWPG)
 
 SHL1TARGET = wpft$(DLLPOSTFIX)
 SHL1IMPLIB = i$(SHL1TARGET)
@@ -81,7 +84,8 @@
 	$(SALLIB) \
 	$(XMLOFFLIB) \
 	$(LIBWPS) \
-	$(LIBWPD)
+	$(LIBWPD) \
+	$(LIBWPG)
 
 SHL2TARGET = msworks$(DLLPOSTFIX)
 SHL2IMPLIB = i$(SHL2TARGET)
