diff -urNp lotuswordpro.bak/source/filter/bencont.cxx lotuswordpro/source/filter/bencont.cxx
--- lotuswordpro.bak/source/filter/bencont.cxx	1970-01-01 08:00:00.000000000 +0800
+++ lotuswordpro/source/filter/bencont.cxx	2008-10-22 11:42:29.000000000 +0800
@@ -0,0 +1,716 @@
+/*************************************************************************
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: IBM Corporation
+ *
+ *  Copyright: 2008 by IBM Corporation
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+#include "first.hxx"
+#include "assert.h"
+#include <stdio.h>
+#include <sot/storinfo.hxx>
+namespace OpenStormBento
+{
+
+// String definitions
+const char gsBenMagicBytes[] = BEN_MAGIC_BYTES;
+
+/**
+*	New bento container from file stream
+*	@param	pointer to length of bento file
+*	@param	pointer to pointer of Bento Container object
+*	@return	error code
+*/
+ULONG BenOpenContainer(LwpSvStream * pStream, pLtcBenContainer * ppContainer) 
+{
+	BenError Err;
+
+	*ppContainer = NULL;
+
+	if (NULL == pStream)
+	{
+		return BenErr_ContainerWithNoObjects;
+	}
+	
+	pLtcBenContainer pContainer = new LtcBenContainer(pStream);
+	if ((Err = pContainer->Open()) != BenErr_OK) // delete two inputs
+	{
+		delete pContainer;
+		return BenErr_InvalidTOC;
+	}
+
+	*ppContainer = pContainer;
+	return BenErr_OK;
+}
+BenError
+LtcBenContainer::Close()
+{
+	return BenErr_OK;
+}
+
+LtcBenContainer::~LtcBenContainer()
+{
+	Close();
+}
+
+BenError
+LtcBenContainer::Open() // delete two inputs
+{
+	BenError Err;
+	CBenTOCReader TOCReader(this);
+	if ((Err = TOCReader.ReadLabelAndTOC()) != BenErr_OK)
+	{
+		return Err;
+	}
+	return BenErr_OK;
+}
+
+void
+LtcBenContainer::Release()
+{
+	delete this;
+}
+
+BenError
+LtcBenContainer::RegisterPropertyName(const char * sPropertyName,
+  pCBenPropertyName * ppPropertyName)
+{
+	pCBenNamedObjectListElmt pPrevNamedObjectListElmt;
+	pCBenNamedObject pNamedObject = FindNamedObject(&cNamedObjects,
+	  sPropertyName, &pPrevNamedObjectListElmt);
+
+	if (pNamedObject != NULL)
+	{
+		if (! pNamedObject->IsPropertyName())
+			return BenErr_NameConflict;
+		else *ppPropertyName = (pCBenPropertyName) pNamedObject;
+	}
+	else
+	{
+		pCBenIDListElmt pPrevObject;
+		if (FindID(&cObjects, cNextAvailObjectID, &pPrevObject) != NULL)
+			return BenErr_DuplicateObjectID;
+	
+		*ppPropertyName = new CBenPropertyName(this, cNextAvailObjectID,
+		  (pCBenObject) pPrevObject, sPropertyName, pPrevNamedObjectListElmt);
+		++cNextAvailObjectID;
+	}
+
+	return BenErr_OK;
+}
+
+BenError
+LtcBenContainer::RegisterTypeName(const char * sTypeName,
+  pCBenTypeName * ppTypeName)
+{
+	pCBenNamedObjectListElmt pPrevNamedObjectListElmt;
+	pCBenNamedObject pNamedObject = FindNamedObject(&cNamedObjects, sTypeName,
+	  &pPrevNamedObjectListElmt);
+
+	if (pNamedObject != NULL)
+	{
+		if (! pNamedObject->IsTypeName())
+			return BenErr_NameConflict;
+		else *ppTypeName = (pCBenTypeName) pNamedObject;
+	}
+	else
+	{
+		pCBenIDListElmt pPrevObject;
+		if (FindID(&cObjects, cNextAvailObjectID, &pPrevObject) != NULL)
+			return BenErr_DuplicateObjectID;
+
+		*ppTypeName = new CBenTypeName(this, cNextAvailObjectID,
+		  (pCBenObject) pPrevObject, sTypeName, pPrevNamedObjectListElmt);
+		++cNextAvailObjectID;
+	}
+
+	return BenErr_OK;
+}
+
+BenError
+LtcBenContainer::NewObject(pCBenObject * ppBenObject)
+{
+	pCBenIDListElmt pPrev;
+	if (FindID(&cObjects, cNextAvailObjectID, &pPrev) != NULL)
+		return BenErr_DuplicateObjectID;
+
+	*ppBenObject = new CBenObject(this, cNextAvailObjectID, pPrev);
+
+	++cNextAvailObjectID;
+	return BenErr_OK;
+}
+
+pCBenObject
+LtcBenContainer::GetNextObject(pCBenObject pCurrObject)
+{
+	return (pCBenObject) cObjects.GetNextOrNULL(pCurrObject);
+}
+
+pCBenObject
+LtcBenContainer::FindNextObjectWithProperty(pCBenObject pCurrObject,
+  BenObjectID PropertyID)
+{
+	while ((pCurrObject = GetNextObject(pCurrObject)) != NULL)
+		if (pCurrObject->UseProperty(PropertyID) != NULL)
+			return pCurrObject;
+
+	return NULL;
+}
+
+pCBenObject
+LtcBenContainer::FindObject(BenObjectID ObjectID)
+{
+	return (pCBenObject) FindID(&cObjects, ObjectID, NULL);
+}
+
+/**
+*	Construction
+*	@param	Bento file stream pointer
+*	@return	
+*/
+LtcBenContainer::LtcBenContainer(LwpSvStream * pStream) 
+{ 
+	cpStream = pStream; 		
+	pStream->Seek(STREAM_SEEK_TO_END);
+	m_ulLength = pStream->Tell();
+	pStream->Seek(STREAM_SEEK_TO_BEGIN);
+} 
+
+/**
+*	Read buffer fro bento file with specified buffer
+*	@date	07/05/2004
+*	@param	buffer pointer
+*	@param  buffer size
+*	@param	number of bytes read
+*	@return	BenError
+*/
+BenError LtcBenContainer::Read(BenDataPtr pBuffer, unsigned long MaxSize,
+  unsigned long * pAmtRead)
+{ 
+	*pAmtRead = cpStream->Read(pBuffer, MaxSize); 
+	return BenErr_OK;
+}
+/**
+*	Read buffer from bento file with specified size
+*	@date	07/05/2004
+*	@param	buffer pointer
+*	@param	number of bytes to be read
+*	@return	BenError
+*/
+BenError LtcBenContainer::ReadKnownSize(BenDataPtr pBuffer, unsigned long Amt)
+{ 
+	ULONG ulLength;
+	ulLength = cpStream->Read(pBuffer, Amt); 
+	if(ulLength == Amt)
+	{
+		return BenErr_OK;
+	}
+	return BenErr_ReadPastEndOfContainer;
+}
+/**
+*	Seek to position from the beginning of the bento file
+*	@date	07/05/2004
+*	@param	position in container file from beginning
+*	@return	BenError
+*/
+BenError LtcBenContainer::SeekToPosition(BenContainerPos Pos)
+{ 
+	cpStream->Seek(Pos); 
+  	return BenErr_OK; 
+}
+/**
+*	Seek to position compare to end of bento file
+*	@date	07/05/2004
+*	@param	position in container file from end
+*	@return	BenError
+*/
+BenError LtcBenContainer::SeekFromEnd(long Offset)
+{
+	cpStream->Seek(STREAM_SEEK_TO_END);
+	cpStream->SeekRel(Offset);
+	
+  	return BenErr_OK; 
+}
+/**
+*	Get position in the bento file
+*	@date	07/05/2004
+*	@param	pointer of current position in container file from end
+*	@return	BenError
+*/
+BenError LtcBenContainer::GetPosition(BenContainerPos * pPosition)
+{ 
+	*pPosition = cpStream->Tell();
+	return BenErr_OK;
+}
+/**
+*	Find the next value stream with property name
+*	@date	07/05/2004
+*	@param	string of property name
+*	@param	current value stream pointer with the property name
+*	@return	next value stream pointer with the property names
+*/
+LtcUtBenValueStream * LtcBenContainer::FindNextValueStreamWithPropertyName(const char * sPropertyName, LtcUtBenValueStream * pCurrentValueStream)
+{
+	CBenPropertyName * pPropertyName;
+	RegisterPropertyName(sPropertyName, &pPropertyName);		// Get property name object
+
+	if (NULL == pPropertyName)
+		return NULL;											// Property not exist
+
+	// Get current object
+	CBenObject * pObj = NULL;
+	if (pCurrentValueStream != NULL)
+	{
+		pObj = pCurrentValueStream->GetValue()->GetProperty()->GetBenObject();	
+	}
+
+	
+	pObj =FindNextObjectWithProperty(pObj, pPropertyName->GetID());	// Get next object with same property name
+	if (NULL == pObj)
+		return NULL;
+
+	CBenValue * pValue;
+	LtcUtBenValueStream * pValueStream;
+
+	pValue = pObj->UseValue(pPropertyName->GetID());
+
+	pValueStream = new LtcUtBenValueStream(pValue);
+
+	return pValueStream;
+}
+
+/**
+*	Find the unique value stream with property name
+*	@date	07/05/2004
+*	@param	string of property name
+*	@return	the only value stream pointer with the property names
+*/
+LtcUtBenValueStream * LtcBenContainer::FindValueStreamWithPropertyName(const char * sPropertyName)
+{
+	return FindNextValueStreamWithPropertyName(sPropertyName, NULL);
+}
+/**
+*	Find the unique value stream with property name and Object ID
+*	@date	10/24/2005
+*	@param	object ID
+*	@param	string of property name
+*	@return	the only value stream pointer with the property names
+*/
+LtcUtBenValueStream * LtcBenContainer::FindObjectValueStreamWithObjectIDAndProperty(BenObjectID ObjectID, const char * sPropertyName)
+{
+	CBenPropertyName * pPropertyName;
+	RegisterPropertyName(sPropertyName, &pPropertyName);		// Get property name object
+	if (NULL == pPropertyName)
+		return NULL;											// Property not exist
+	// Get current object
+	CBenObject * pObj = NULL;
+	pObj = FindObject(ObjectID); // Get object with object ID
+	if (NULL == pObj)
+		return NULL;
+	CBenValue * pValue;
+	LtcUtBenValueStream * pValueStream;
+	pValue = pObj->UseValue(pPropertyName->GetID());
+	pValueStream = new LtcUtBenValueStream(pValue);
+	return pValueStream;
+}
+/**
+*	<description>
+*	@date	07/05/2004
+*	@param	pointer to length of bento file
+*	@return	BenError
+*/
+BenError LtcBenContainer::GetSize(ULONG * pLength)
+{
+	*pLength = m_ulLength;
+	return BenErr_OK;
+}
+
+sal_uInt32 GetSvStreamSize(SvStream * pStream)
+{
+	sal_uInt32 nCurPos = pStream->Tell();
+	pStream->Seek(STREAM_SEEK_TO_END);
+	sal_uInt32 ulLength = pStream->Tell();
+	pStream->Seek(nCurPos);
+	
+	return ulLength;
+}
+/**
+*	Find hazily according to part of property name
+*	@date	01/31/2005
+*	@param	
+*	@return	the value stream pointers vector with the property names
+*/
+BenError LtcBenContainer::CreateGraphicStreams(std::vector<SvStream *> * pStreamVector)
+{
+	/* traverse all named objects to find all the graphic property names */
+	CBenObject * pObj= NULL;
+	char *pName;
+	std::vector<std::string> aGrPropertyVector ;
+	while(pObj = GetNextObject(pObj) )
+	{
+		if(pObj->IsNamedObject())
+		{
+			CBenNamedObject * pNamedObj = static_cast<CBenNamedObject *>(pObj);
+			if(!pNamedObj->IsPropertyName())
+				continue;
+			
+			// Gr2E,41FDD458-S
+			// Gr2E,41FDD458-D
+			pName = const_cast<char *>(pNamedObj->GetName());
+			if ( (pName[0] == 'G')
+			&& (pName[1] == 'r')	
+			&&( (pName[14] == 'D') || (pName[14] == 'S') ) )
+			{
+				aGrPropertyVector.push_back(std::string(pName));
+			}
+		}
+	}
+
+	/* traverse the found properties and construct the stream vectors */
+	std::vector<std::string>::iterator itor;
+	for (itor = aGrPropertyVector.begin(); itor != aGrPropertyVector.end(); itor ++)
+	{
+		// get property names with suffix of S&D
+		char sSName[32], sDName[32];
+		strcpy(sSName, itor->c_str());
+		strcpy(sDName, itor->c_str());
+		sSName[14] = 'S';
+		sDName[14] = 'D';
+
+		// erase strings in vector
+		std::vector<std::string>::iterator itorSearch;
+		for (itorSearch = aGrPropertyVector.begin(); itorSearch != aGrPropertyVector.end(); itorSearch ++)
+		{
+			if( (*itorSearch == sSName) || (*itorSearch == sDName) )
+			{
+				std::vector<std::string>::iterator itorDel = itorSearch;
+				aGrPropertyVector.erase(itorDel);
+			}
+		}
+
+		// get S&D's stream and merge them together
+		{
+			SvStream *pD = NULL, *pS = NULL;
+
+			pS = FindValueStreamWithPropertyName(sSName);
+			assert(pS != NULL);
+			pD = FindValueStreamWithPropertyName(sDName);
+			assert(pD != NULL);
+
+			sal_uInt32 nDLen = GetSvStreamSize(pD);
+			sal_uInt32 nLen = GetSvStreamSize(pS) + nDLen;
+			assert(nLen > 0);
+			char * pBuf = new char[nLen];
+			assert(pBuf != NULL);
+			char * pPointer = pBuf;
+			pD->Read(pPointer, nDLen);
+			pPointer += nDLen;
+			pS->Read(pPointer, nLen - nDLen);
+
+			delete pS;
+			delete pD;
+
+			SvMemoryStream * pStream = new SvMemoryStream(pBuf, nLen, STREAM_READ);
+			assert(pStream != NULL);
+			
+			pStreamVector->push_back(pStream);
+		}
+	}
+
+	aGrPropertyVector.clear();
+	return BenErr_OK;
+}
+
+/**
+*	Find hazily according to object ID
+*	@date	01/31/2005
+*	@param	pObjectname - format as "GrXX,XXXXXXXX" wherein XX is high part of object ID, and XXXXXXXX is low part
+*	@return	the value stream pointers  with the property names
+*/
+BenError LtcBenContainer::CreateGraphicStream(SvStream * &pStream, const char *pObjectName)
+{
+	if (!pObjectName)
+	{
+		pStream = NULL;
+		return BenErr_NamedObjectError;
+	}
+	// construct the string of property name
+	char sSName[64]="";
+	char sDName[64]="";
+
+	sprintf(sSName, "%s-S", pObjectName);
+	sprintf(sDName, "%s-D", pObjectName);
+
+	/* traverse the found properties and construct the stream vectors */
+	SvMemoryStream * pMemStream = NULL;
+	// get S&D's stream and merge them together
+	SvStream *pD = NULL, *pS = NULL;
+
+	pS = FindValueStreamWithPropertyName(sSName);
+	pD = FindValueStreamWithPropertyName(sDName);
+
+
+	sal_uInt32 nDLen = 0;
+	if(pD)
+	{
+		nDLen = GetSvStreamSize(pD);
+	}
+	sal_uInt32 nLen = nDLen;
+	if(pS)
+	{
+		nLen += GetSvStreamSize(pS) ;
+	}
+	
+	assert(nLen > 0);
+	char * pBuf = new char[nLen];
+	assert(pBuf != NULL);
+	char * pPointer = pBuf;
+	if(pD)
+	{
+		pD->Read(pPointer, nDLen);
+		delete pD;
+	}
+	pPointer += nDLen;
+	if(pS)
+	{
+		pS->Read(pPointer, nLen - nDLen);
+		delete pS;
+	}	
+
+	pMemStream = new SvMemoryStream(pBuf, nLen, STREAM_READ);
+	assert(pMemStream != NULL);
+	
+	pStream = pMemStream;
+	return BenErr_OK;
+}
+/**
+*	Find ole object stream according to object name
+*	@date	10/24/2005
+*	@param	
+*	@return	the value ole storage stream pointers
+*/
+#include <tools/globname.hxx>
+SotStorageStreamRef LtcBenContainer::ConvertAswStorageToOLE2Stream(const char * sObjectName)
+{
+	SotStorageStreamRef xOleObjStm;
+	
+	SvStream* pOleStorageStream = NULL;
+	//Get Ole Storage stream
+	AswEntry aEntry;
+	pOleStorageStream = FindOLEStorageStreamWithObjectName(sObjectName, aEntry);
+	
+	if( !pOleStorageStream )
+		return xOleObjStm;
+	//Find it, create Ole stream
+	//xOleObjStm = new SotStorageStream(String::CreateFromAscii( RTL_CONSTASCII_STRINGPARAM( "Ole-Object" ) ));
+	xOleObjStm = new SotStorageStream(String());
+	if( xOleObjStm->GetError() )
+		return xOleObjStm;
+	xOleObjStm->SetBufferSize( 0xff00 );
+	
+	SotStorageRef xOleObjStor = new SotStorage( *xOleObjStm );
+	if( xOleObjStor->GetError() )
+		return xOleObjStm;
+	//Set class id	
+	ClsId aClsId = aEntry.GetClassId();
+	SvGlobalName aGName( aClsId.n1, aClsId.n2, aClsId.n3, aClsId.n4,
+						aClsId.n5, aClsId.n6,aClsId.n7,aClsId.n8,
+						aClsId.n9,aClsId.n10,aClsId.n11);
+	xOleObjStor->SetClass( aGName, 0, String());
+	
+	xOleObjStor->SetVersion( SOFFICE_FILEFORMAT_60 );
+	std::string aOleStreamName("OleStream");
+	sal_uInt32 nDLen = 0;
+	nDLen = GetSvStreamSize(pOleStorageStream);
+	for(sal_uInt32 nIndex = 0; nIndex < nDLen / ASWENTRY_SIZE; nIndex ++)
+	{
+		AswEntry aOleEntry;
+		ReadAswEntry(pOleStorageStream, aOleEntry);
+		if(aOleEntry.GetType()== BEN_STGTY_STREAM)
+		{
+			SvStream* pOleStream = FindObjectValueStreamWithObjectIDAndProperty(aOleEntry.GetObjectID(),  aOleStreamName.c_str());			
+			if(pOleStream)
+			{
+				String strName;
+				aOleEntry.GetName(strName);
+				SotStorageStreamRef xStm = xOleObjStor->OpenSotStream( strName );
+				if( xStm->GetError() )
+					break;
+				xStm->SetBufferSize( 8192 );
+				(*pOleStream) >> (*xStm);
+				xStm->Commit();
+				delete pOleStream;
+				pOleStream = NULL;
+			}				
+		}			
+	}
+	xOleObjStor->Commit();
+	xOleObjStm->Commit();	
+	
+	return xOleObjStm;
+}
+/**
+*	Find ole object storage stream data according to object name
+*	@date	10/24/2005
+*	@param	
+*	@return	the value ole storage stream data pointers
+*/
+LtcUtBenValueStream* LtcBenContainer::FindOLEStorageStreamWithObjectName(const char * sObjectName, AswEntry& rEntry)
+{
+	if (!sObjectName)
+		return NULL;	
+	
+	//Find OleRootStorage stream
+	std::string aRootStroageName("OleRootStorage");
+	std::string aOleStroageName("OleStorage");
+	LtcUtBenValueStream* pRootStream = NULL;
+	pRootStream = FindValueStreamWithPropertyName(aRootStroageName.c_str());
+	if(!pRootStream)
+		return NULL;
+	//Read root storage data and find the ole storage object id according to the object name	
+	sal_uInt32 nDLen = 0;
+	nDLen = GetSvStreamSize(pRootStream);
+	for(sal_uInt32 nIndex = 0; nIndex < nDLen / ASWENTRY_SIZE; nIndex ++)
+	{
+		//Get entry
+		ReadAswEntry(pRootStream, rEntry);
+		String sObjName;
+		rEntry.GetName(sObjName);
+		if(sObjName.EqualsAscii(sObjectName))
+		{
+			//Find it
+			delete pRootStream;		
+			return FindObjectValueStreamWithObjectIDAndProperty(rEntry.GetObjectID(),  aOleStroageName.c_str());			
+		}			
+	}
+	
+	// Not find
+	if(pRootStream)
+	{
+		delete pRootStream;
+	}
+	
+	return NULL;
+}
+void LtcBenContainer::ReadAswEntry(SvStream * pStream, AswEntry & rEntry)
+{
+	char* pBuf = new char[ASWENTRY_SIZE];
+	pStream->Read(pBuf, ASWENTRY_SIZE);
+	rEntry.Load(pBuf);
+	delete[] pBuf;
+}
+////////////////////////////////////////////////////////////////////
+//classs AswEntry
+AswEntry::AswEntry()
+{
+	Init();
+}
+void AswEntry::Init()
+{
+	memset( this, 0, sizeof (AswEntry));
+}
+void  AswEntry::SetName( const String& rName )
+{
+	int i;
+	for( i = 0; i < rName.Len() && i < 68; i++ )
+       	 nName[ i ] = rName.GetChar( i );
+	while( i < 68 )
+	      nName[ i++ ] = 0;     
+}
+void AswEntry::GetName(String & rName) const
+{
+	rName =  nName;
+}
+void AswEntry::Store( void* pTo )
+{
+	SvMemoryStream r( (sal_Char *)pTo, ASWENTRY_SIZE, STREAM_WRITE );
+	for( short i = 0; i < 68; i++ )
+		r << nName[ i ];			// 00 name as WCHAR		
+	 r<< nMtime[ 0 ] 						// 42 entry type
+	  << nMtime[ 1 ]						// 43 0 or 1 (tree balance?)
+	  << nCtime[ 0 ]						// 44 left node entry
+	  << nCtime[ 1 ]						// 48 right node entry
+	  << nAtime[ 0 ]						// 44 left node entry
+	  << nAtime[ 1 ];						// 48 right node entry	  
+	  r.Write(&aClsId ,16);						// 50 class ID (optional)
+	  r<< nStatebits						// 60 state flags(?)
+	  << nType
+	  << nObjectIDRef				// 64 modification time
+	  << nMversion				// 6C creation and access time
+	  << nLversion 				// 6C creation and access time
+	  << nReserved[ 0 ]						// 74 starting block (either direct or translated)
+	  << nReserved[ 1 ];						// 78 file size
+}
+void AswEntry::Load( const void* pFrom )
+{
+	SvMemoryStream r( (sal_Char *)pFrom, ASWENTRY_SIZE, STREAM_WRITE );
+	for( short i = 0; i < 68; i++ )
+		r >> nName[ i ];			// 00 name as WCHAR		
+	 r>> nMtime[ 0 ] 						// 42 entry type
+	  >> nMtime[ 1 ]						// 43 0 or 1 (tree balance?)
+	  >> nCtime[ 0 ]						// 44 left node entry
+	  >> nCtime[ 1 ]						// 48 right node entry
+	  >> nAtime[ 0 ]						// 44 left node entry
+	  >> nAtime[ 1 ];						// 48 right node entry	  
+	  r.Read(&aClsId,16);						// 50 class ID (optional)
+	  r>> nStatebits						// 60 state flags(?)
+	  >> nType
+	  >> nObjectIDRef				// 64 modification time
+	  >> nMversion				// 6C creation and access time
+	  >> nLversion 				// 6C creation and access time
+	  >> nReserved[ 0 ]						// 74 starting block (either direct or translated)
+	  >> nReserved[ 1 ];						// 78 file size
+}
+void AswEntry::SetClassId( const ClsId& r )
+{
+	memcpy( &aClsId, &r, sizeof( ClsId ) );
+}
+///////////////////////////////////////////////////////////////////
+}// end namespace OpenStormBento
diff -urNp lotuswordpro.bak/source/filter/benlist.cxx lotuswordpro/source/filter/benlist.cxx
--- lotuswordpro.bak/source/filter/benlist.cxx	1970-01-01 08:00:00.000000000 +0800
+++ lotuswordpro/source/filter/benlist.cxx	2008-10-22 11:42:29.000000000 +0800
@@ -0,0 +1,121 @@
+/*************************************************************************
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: IBM Corporation
+ *
+ *  Copyright: 2008 by IBM Corporation
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+#include "first.hxx"
+namespace OpenStormBento
+{
+
+pCBenNamedObject
+FindNamedObject(pCUtList pList, const char * sName,
+  pCBenNamedObjectListElmt * ppPrev)
+{
+	pCUtListElmt pTerminating = pList->GetTerminating();
+	for (pCUtListElmt pCurr = pList->GetLast(); pCurr != pTerminating;
+	  pCurr = pCurr->GetPrev())
+	{
+		pCBenNamedObjectListElmt pCurrNamedObjectListElmt =
+		  (pCBenNamedObjectListElmt) pCurr;
+
+		
+		//Old code
+//		int Comp = strcmp(sName, pCurrNamedObjectListElmt->GetNamedObject()->
+//		  GetName());
+		int Comp = strcmp(sName, pCurrNamedObjectListElmt->GetNamedObject()->
+		  GetNameCStr());
+		
+
+		if (Comp == 0)
+			return pCurrNamedObjectListElmt->GetNamedObject();
+		else if (Comp < 0)
+			continue;
+		else
+		{
+			if (ppPrev != NULL)
+				*ppPrev = pCurrNamedObjectListElmt;
+			return NULL;
+		}
+	}
+
+	if (ppPrev != NULL)
+		*ppPrev = (pCBenNamedObjectListElmt) pTerminating;
+	return NULL;
+}
+
+// Assume list is of BenIDListElmt list elements, sorted by ID
+pCBenIDListElmt
+FindID(pCUtList pList, BenObjectID ObjectID, pCBenIDListElmt * ppPrev)
+{
+	pCUtListElmt pTerminating = pList->GetTerminating();
+	for (pCUtListElmt pCurr = pList->GetLast(); pCurr != pTerminating;
+	  pCurr = pCurr->GetPrev())
+	{
+		pCBenIDListElmt pCurrIDListElmt = (pCBenIDListElmt) pCurr;
+
+		if (ObjectID == pCurrIDListElmt->GetID())
+			return pCurrIDListElmt;
+		else if (ObjectID < pCurrIDListElmt->GetID())
+			continue;
+		else
+		{
+			if (ppPrev != NULL)
+				*ppPrev = pCurrIDListElmt;
+			return NULL;
+		}
+	}
+
+	if (ppPrev != NULL)
+		*ppPrev = (pCBenIDListElmt) pTerminating;
+	return NULL;
+}
+} //end namespace OpenStormBento
diff -urNp lotuswordpro.bak/source/filter/benname.cxx lotuswordpro/source/filter/benname.cxx
--- lotuswordpro.bak/source/filter/benname.cxx	1970-01-01 08:00:00.000000000 +0800
+++ lotuswordpro/source/filter/benname.cxx	2008-10-22 11:42:29.000000000 +0800
@@ -0,0 +1,91 @@
+/*************************************************************************
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: IBM Corporation
+ *
+ *  Copyright: 2008 by IBM Corporation
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+#include "first.hxx"
+namespace OpenStormBento
+{
+#if 0
+CBenNamedObject::CBenNamedObject(pLtcBenContainer pContainer,
+  BenObjectID ObjectID, pCBenObject pPrevObject, const char * sName,
+  pCBenNamedObjectListElmt pPrevNamedObjectListElmt) :
+  CBenObject(pContainer, ObjectID, pPrevObject), csName(sName),
+  cNameListElmt(this, pPrevNamedObjectListElmt)
+{
+}
+#endif
+	// changed by  to remove warning 2004-06-24
+CBenNamedObject::CBenNamedObject(pLtcBenContainer pContainer,
+  BenObjectID ObjectID, pCBenObject pPrevObject, const char * sName,
+  pCBenNamedObjectListElmt pPrevNamedObjectListElmt) :
+  CBenObject(pContainer, ObjectID, pPrevObject), csName(sName),
+  cNameListElmt( pPrevNamedObjectListElmt)
+{
+	cNameListElmt.SetNamedObject(this);
+}
+
+UtBool CBenNamedObject::IsNamedObject()
+{ return UT_TRUE; }
+
+UtBool CBenNamedObject::IsPropertyName()
+{ return UT_FALSE; }
+
+UtBool CBenNamedObject::IsTypeName()
+{ return UT_FALSE; }
+
+UtBool CBenPropertyName::IsPropertyName()
+{ return UT_TRUE; }
+
+UtBool CBenTypeName::IsTypeName()
+{ return UT_TRUE; }
+} // end namespace OpenStormBento
diff -urNp lotuswordpro.bak/source/filter/benobj.cxx lotuswordpro/source/filter/benobj.cxx
--- lotuswordpro.bak/source/filter/benobj.cxx	1970-01-01 08:00:00.000000000 +0800
+++ lotuswordpro/source/filter/benobj.cxx	2008-10-22 11:42:29.000000000 +0800
@@ -0,0 +1,128 @@
+/*************************************************************************
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: IBM Corporation
+ *
+ *  Copyright: 2008 by IBM Corporation
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+#include "first.hxx"
+namespace OpenStormBento
+{
+
+UtBool
+CBenObject::IsNamedObject()
+{
+	return UT_FALSE;
+}
+
+pCBenProperty
+CBenObject::GetNextProperty(pCBenProperty pCurrProperty)
+{
+	return (pCBenProperty) cProperties.GetNextOrNULL(pCurrProperty);
+}
+
+pCBenProperty
+CBenObject::UseProperty(BenObjectID PropertyID)
+{
+	pCBenIDListElmt pPrev;
+	return (pCBenProperty) FindID(&cProperties, PropertyID, &pPrev);
+}
+
+void
+CBenObject::DeleteProperty(pCBenProperty pProperty)
+{
+	delete pProperty;
+}
+
+pCBenValue
+CBenObject::UseValue(BenObjectID PropertyID)
+{
+	pCBenProperty pProperty = UseProperty(PropertyID);
+	if (pProperty == NULL)
+		return NULL;
+	return pProperty->UseValue();
+}
+
+pCBenValue
+CBenObject::UseValueWithPropertyName(const char * sPropertyName)
+{
+	pCBenPropertyName pPropertyName;
+	if (GetContainer()->RegisterPropertyName(sPropertyName, &pPropertyName)
+	  != BenErr_OK)
+		return NULL;
+
+	return UseValue(pPropertyName->GetID());
+}
+
+pCBenValue
+CBenObject::UseSingleValue()
+{
+	if (cProperties.IsEmpty() || cProperties.ContainsAtLeastTwoItems())
+		return NULL;
+	pCBenProperty pProperty = (pCBenProperty) cProperties.GetFirst();
+	return pProperty->UseValue();
+}
+
+BenError
+CBenObject::NewValue(BenObjectID PropertyID, BenObjectID TypeID, pCBenValue *
+  ppValue)
+{
+	pCBenIDListElmt pPrevProperty;
+	pCBenProperty pProperty = (pCBenProperty) FindID(&cProperties,
+	  PropertyID, &pPrevProperty);
+	if (pProperty != NULL)
+		return BenErr_PropertyAlreadyExists;
+
+	pProperty = new CBenProperty(this, PropertyID, TypeID, pPrevProperty);
+	*ppValue = pProperty->UseValue();
+
+	return BenErr_OK;
+}
+}// end namespace OpenStormBento
diff -urNp lotuswordpro.bak/source/filter/bento.hxx lotuswordpro/source/filter/bento.hxx
--- lotuswordpro.bak/source/filter/bento.hxx	1970-01-01 08:00:00.000000000 +0800
+++ lotuswordpro/source/filter/bento.hxx	2008-10-22 11:42:29.000000000 +0800
@@ -0,0 +1,567 @@
+/*************************************************************************
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: IBM Corporation
+ *
+ *  Copyright: 2008 by IBM Corporation
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+#ifndef BENTO_H
+#define BENTO_H
+
+#include <string>
+#include	<vector>
+#include "lwpsvstream.hxx"
+
+#define BEN_CC __stdcall
+#ifdef COMP_BENTO
+#define BEN_EXPORT __declspec(dllexport)
+#else
+#define BEN_EXPORT
+#endif
+
+using namespace std;
+
+#include "ut.hxx"
+#include "utlist.hxx"
+// removed for WordPro filter,  2005-01-27
+//#include <scerrors.hxx>		// error code defined for SC
+//#include <filter.hxx>			// error code defined for SC filters
+#include <tools/stream.hxx>	// SvStream definition
+#include <sot/storage.hxx>	// SotStorageStream definition, add by  10/24/2005
+
+namespace OpenStormBento
+{
+
+#define BEN_CURR_MAJOR_VERSION 2
+#define BEN_CURR_MINOR_VERSION 0
+#define BEN_MAGIC_BYTES_SIZE 8
+#define BEN_LABEL_SIZE 24
+
+#define BEN_MAGIC_BYTES "\xA4""CM""\xA5""Hdr""\xD7"
+//For Ole2DirectoryStruct, Add by  10/24/2005
+#define BEN_STGTY_STORAGE    1
+#define BEN_STGTY_STREAM   2
+#define ASWENTRY_SIZE	204
+struct ClsId
+{
+	INT32	n1;
+	INT16	n2, n3;
+	UINT8	n4, n5, n6, n7, n8, n9, n10, n11;
+};
+class AswEntry	//total length: 204
+{
+	UINT16	nName[ 68 ];		//Name of IStorage or IStream referenced by this entry, length = 136
+	INT32	nMtime[ 2 ];
+	INT32	nCtime[ 2 ];
+	INT32	nAtime[ 2 ];	
+	ClsId	aClsId;			//CLSID from OLE 2 IStorage::SetClass call
+	UINT32	nStatebits;		//State bits from OLE 2 IStorage::SetStateBits call
+	UINT32	nType;			// STGTY_STORAGE: 1 or STGTY_STREAM:2,
+	UINT32	nObjectIDRef;		//Persistent Bento reference to Bento object for this IStorage or IStream
+	UINT32	nMversion;
+	UINT32	nLversion;
+	UINT32	nReserved[2];		//skip 16 char	
+public:
+	AswEntry();
+	void	Init();						// initialize the data
+	void SetName( const String& );	// store a name (ASCII, up to 32 chars)
+	void	GetName( String& rName ) const;	
+	void	Load( const void* );
+	void Store( void* );
+	UINT32 GetType() const		{ return  nType;	}
+	void	SetType( UINT32 t )	{ nType = t;}
+	const   ClsId& GetClassId() const  	{ return aClsId;}
+	void	SetClassId( const ClsId& );
+	void SetObjectID(UINT32 id) { nObjectIDRef = id;}
+	UINT32 GetObjectID() const { return nObjectIDRef;}
+};
+//End by 
+
+enum BenError
+{
+	BenErr_OK = 0,
+	BenErr_NameConflict = 1,
+	BenErr_DuplicateObjectID = 2,
+	BenErr_UnknownBentoFormatVersion = 3,
+	BenErr_NamedObjectError = 4,
+	BenErr_NamedObjectIllegalValue = 5,
+	BenErr_InvalidTOC = 6,
+	BenErr_64BitOffsetNotSupported = 7,
+	BenErr_ReadPastEndOfTOC = 8,
+	BenErr_ContainerWithNoObjects = 9,
+	BenErr_ObjectWithNoProperties = 10,
+	BenErr_PropertyWithNoValues = 11,
+	BenErr_IllegalInMemoryTOC = 12,
+	BenErr_PropertyAlreadyExists = 13,
+	BenErr_UnexpectedEndOfFile = 14,
+	BenErr_InvalidWriteOffset = 15,
+	BenErr_InvalidImmediateWrite = 16,
+	BenErr_TOCSeedError = 17,
+	BenErr_ReadPastEndOfContainer = 18,
+	BenErr_DuplicateName = 19,
+	BenErr_BadReferencedList = 20,
+	BenErr_IllegalContinuedImmediate = 21,
+	BenErr_NotBentoContainer = 22,
+	BenErr_PropertyWithMoreThanOneValue = 23
+
+	// IMPORTANT - UtStream errors (UtErr_....) are also valid Bento
+	// errors.  They have codes of 100 and higher.  When, say, a Bento
+	// container open fails due to an access violation (somebody else, say,
+	// has it open exclusive), will get a UtErr code.  If define own
+	// subclass of UtStream (custom handler), can define own error codes--
+	// those should start at 200
+};
+/*
+ * These two functions are useless in SODC
+ *
+inline UtError BenToUtError(BenError Err)
+{
+	if (Err == 0 || Err >= 100)
+		return (UtError) Err;
+	else return UtErr_Fail;
+}
+
+inline BenError UtToBenError(UtError Err)
+{ UT_ASSERT(Err == 0 || Err >= 100); return (BenError) Err; }
+enum BenSeekMode {
+	BenSeek_FromStart = 1,
+	BenSeek_FromCurr = 2,
+	BenSeek_FromEnd = 3
+};
+*/
+
+UtDefClassP(LtcBenContainer);
+UtDefClassP(CBenIDListElmt);
+UtDefClassP(CBenObject);
+UtDefClassP(CBenProperty);
+UtDefClassP(CBenReference);
+UtDefClassP(CBenValue);
+UtDefClassP(CBenValueSegment);
+UtDefClassP(CBenNamedObjectListElmt);
+UtDefClassP(CBenNamedObject);
+UtDefClassP(CBenPropertyName);
+UtDefClassP(CBenTypeName);
+
+typedef unsigned char BenByte;
+typedef unsigned short BenWord;
+typedef unsigned long BenDWord;
+typedef void * BenDataPtr;
+typedef const void  * BenConstDataPtr;
+
+typedef unsigned long BenContainerPos;
+typedef unsigned long BenObjectID;
+typedef unsigned long BenGeneration;
+
+ULONG BenOpenContainer(LwpSvStream * pStream, pLtcBenContainer * ppContainer);
+
+class CBenIDListElmt : public CUtListElmt
+{
+public: // Internal methods
+	CBenIDListElmt(BenObjectID ID, pCBenIDListElmt pPrev) : CUtListElmt(pPrev)
+	  { cID = ID; } 
+	CBenIDListElmt(BenObjectID ID) { cID = ID; } 
+	BenObjectID GetID() { return cID; }
+
+private: // Data
+	BenObjectID cID;
+};
+
+class CBenNamedObjectListElmt : public CUtListElmt
+{
+public: // Methods
+	// added by  to remove warning 2004-06-24
+	CBenNamedObjectListElmt(pCBenNamedObjectListElmt pPrev) : CUtListElmt(pPrev)
+	  { cpNamedObject = NULL; }
+	void SetNamedObject(pCBenNamedObject pObj)
+	{
+		cpNamedObject = pObj;
+	}
+	
+	CBenNamedObjectListElmt(pCBenNamedObject pNamedObject,
+	  pCBenNamedObjectListElmt pPrev) : CUtListElmt(pPrev)
+	  { cpNamedObject = pNamedObject; }
+	pCBenNamedObject GetNamedObject() { return cpNamedObject; }
+
+private: // Data
+	pCBenNamedObject cpNamedObject;
+};
+
+class LtcUtBenValueStream : public SvStream
+{
+public:
+	LtcUtBenValueStream(pCBenValue pValue);
+	~LtcUtBenValueStream();
+
+public: // Overridden methods
+#if 0 // Deleted by  2004-06-16
+	UtError Open(UtBool /* OpenNew */, UtStrmOpenFlags /* Flags */);
+	UtError Close();
+	UtError Seek(long Offset, UtSeekMode Mode);
+	UtError GetPosition(unsigned long * pPosition);
+	UtError GetSize(unsigned long * pSize);
+	UtError Read(UtStrmDataPtr pBuffer, unsigned long MaxSize,
+	  unsigned long * pAmtRead);
+	UtError Write(UtConstStrmDataPtr pBuffer, unsigned long Size,
+	  unsigned long * pAmtWritten);
+	UtError Flush();
+#endif
+	
+	/* added by  */
+	CBenValue * GetValue(){ return cpValue; };
+	ULONG GetSize() { return m_ulValueLength; };
+protected: // Overridden methods
+
+	virtual ULONG	GetData( void* pData, ULONG nSize );
+	virtual ULONG	PutData( const void* pData, ULONG nSize );
+	virtual ULONG	SeekPos( ULONG nPos );
+	virtual void	SetSize( ULONG nSize );
+	virtual void	FlushData();
+	
+#if 0// Deleted by  2004-06-16
+	UtError TruncateSize(unsigned long Size);
+#endif
+private: // Data
+	pCBenValue cpValue;
+	unsigned long cCurrentPosition;
+	
+	ULONG m_ulValueLength;		// Added by , sum of length of all sub-valuesegments
+//	void	GetAmountLeft(ULONG * pAmtLeft);	useless in SODC
+};
+
+class LtcBenContainer
+{
+public:
+	BenError Open();
+	void Release(); // Deletes container object--last call
+	BenError Close();
+	BenError RegisterTypeName(const char * sTypeName,
+	  pCBenTypeName * ppTypeName);
+	BenError RegisterPropertyName(const char * sPropertyName,
+	  pCBenPropertyName * ppPropertyName);
+	// Pass NULL to begin iteration.  Done when returns NULL.
+	// Objects are returned in order of increasing ID
+	pCBenObject GetNextObject(pCBenObject pCurrObject);
+	pCBenObject FindObject(BenObjectID ObjectID);
+	pCBenObject FindNextObjectWithProperty(pCBenObject pCurrObject,
+	  BenObjectID PropertyID);
+	BenError BEN_EXPORT NewObject(pCBenObject * ppBenObject);
+
+public: // Internal methods
+	LtcBenContainer(LwpSvStream * pStream);
+	~LtcBenContainer();
+
+	BenError Read(BenDataPtr pBuffer, unsigned long MaxSize,
+	  unsigned long * pAmtRead);
+	BenError ReadKnownSize(BenDataPtr pBuffer, unsigned long Amt);	
+	BenError SeekToPosition(BenContainerPos Pos);
+	BenError SeekFromEnd(long Offset);
+	
+	BenError GetPosition(BenContainerPos * pPosition);
+	
+	BenObjectID GetNextAvailObjectID() { return cNextAvailObjectID; }
+	void SetNextAvailObjectID(BenObjectID ID) { cNextAvailObjectID = ID; }
+	pCUtList GetObjects() { return &cObjects; }
+	pCUtList GetNamedObjects() { return &cNamedObjects; }
+
+	// Added by  2004-06-10
+	LtcUtBenValueStream * FindNextValueStreamWithPropertyName(const char * sPropertyName, LtcUtBenValueStream * pCurrentValueStream);
+	LtcUtBenValueStream * FindValueStreamWithPropertyName(const char * sPropertyName);
+	LtcUtBenValueStream * FindObjectValueStreamWithObjectIDAndProperty(BenObjectID ObjectID, const char * sPropertyName);
+	BenError CreateGraphicStreams(std::vector<SvStream *> * pStreamVector)	;
+	BenError CreateGraphicStream(SvStream * &pStream,  const char *pObjectName);
+	//Add by  10/24/2005	
+	SotStorageStreamRef ConvertAswStorageToOLE2Stream(const char * sObjectName);
+	LtcUtBenValueStream * FindOLEStorageStreamWithObjectName(const char * sObjectName, AswEntry& rDirStruct);	
+	void ReadAswEntry(SvStream * pStream, AswEntry& rEntry);
+
+	BenError GetSize(ULONG * pLength);
+	LwpSvStream * GetStream() 
+	{
+		return cpStream;
+	};
+private: // Data
+	CUtOwningList cObjects;
+	CUtList cNamedObjects;
+	LwpSvStream * cpStream;
+	ULONG m_ulLength; 	// Added for TOCRead.cpp
+	BenObjectID cNextAvailObjectID; // for new object
+};
+
+class CBenObject : public CBenIDListElmt
+{
+public:
+	pCBenProperty GetNextProperty(pCBenProperty pCurrProperty);
+	pCBenProperty UseProperty(BenObjectID PropertyID);
+	void DeleteProperty(pCBenProperty pProperty);
+	pCBenValue UseValue(BenObjectID PropertyID);
+	pCBenValue UseSingleValue();
+	// Inefficient to use this method if will use property multiple times--
+	// instead register property and call UseProperty with property ID
+	pCBenValue UseValueWithPropertyName(const char * sPropertyName);
+	virtual UtBool IsNamedObject();
+	pLtcBenContainer GetContainer() { return cpContainer; }
+	BenObjectID GetObjectID() { return GetID(); }
+	BenError BEN_EXPORT NewValue(BenObjectID PropertyID, BenObjectID TypeID,
+	  pCBenValue * ppValue);
+public: // Internal methods
+	CBenObject(pLtcBenContainer pContainer, BenObjectID ObjectID,
+	  pCBenIDListElmt pPrev) : CBenIDListElmt(ObjectID, pPrev)
+	  { cpContainer = pContainer; }
+	pCUtList GetProperties() { return &cProperties; }
+
+private: // Data
+	pLtcBenContainer cpContainer;
+	CUtOwningList cProperties;
+};
+
+class CBenValue : public CBenIDListElmt
+{
+public:
+	unsigned long GetValueSize();
+	BenError ReadValueData(BenDataPtr pBuffer,
+	  unsigned long Offset, unsigned long MaxSize, unsigned long * pAmtRead);
+	BenError ReadValueDataKnownSize(BenDataPtr pBuffer,
+	  unsigned long Offset, unsigned long Amt);
+
+	BenError BEN_EXPORT WriteValueData(BenConstDataPtr pBuffer,
+	  unsigned long Offset, unsigned long Size);
+	BenError BEN_EXPORT WriteValueData(BenConstDataPtr pBuffer,
+	  unsigned long Offset, unsigned long Size, unsigned long * pAmtWritten);
+	BenError BEN_EXPORT WriteImmediateValueData(BenConstDataPtr pBuffer,
+	  unsigned short Size);
+	BenError BEN_EXPORT TruncateValueSize(unsigned long NewSize);
+	BenError BEN_EXPORT NewReference(BenObjectID ReferencedObjectID,
+	  pCBenReference pReference);
+	BenObjectID BEN_EXPORT GetReferencedObject(pCBenReference pReference);
+
+	
+	pCBenProperty BEN_EXPORT GetProperty() { return cpProperty; }
+	
+public: // Internal methods
+	// added by  to remove WARNING 2004-06-24
+	CBenValue(BenObjectID TypeID):CBenIDListElmt(TypeID)
+	{
+		cpProperty = NULL;
+		cpReferencedList = NULL;
+	}
+
+	void SetProperty(pCBenProperty pProperty)
+	{
+		cpProperty = pProperty;
+	}
+	
+	CBenValue(pCBenProperty pProperty, BenObjectID TypeID) :
+	  CBenIDListElmt(TypeID)
+	{
+		cpProperty = pProperty;
+		cpReferencedList = NULL;
+	}
+	BenObjectID GetTypeNameID() { return GetID(); }
+	inline pCBenValueSegment GetNextValueSegment(pCBenValueSegment
+	  pCurrValueSegment);
+	inline pLtcBenContainer GetContainer();
+	pCUtList GetValueSegments() { return &cValueSegments; }
+	BenObjectID GetReferencedListID();
+	// Currently, no generation support
+	BenGeneration GetGeneration() { return 1; }
+
+private: // Data
+	pCBenProperty cpProperty;
+	CUtOwningList cValueSegments;
+	pCBenValue cpReferencedList;
+	unsigned long cReferencedObjectsSize;
+};
+
+class CBenProperty : public CBenIDListElmt
+{
+public:
+	// In the Apple Bento, a property can have multiple values, each of a
+	// different type.  But we never use it that way, so in this code a
+	// property has exactly one value
+
+	pCBenValue UseValue() { return &cValue; }
+	pCBenObject GetBenObject() { return cpObject; }
+	pLtcBenContainer GetContainer() { return GetBenObject()->GetContainer(); }
+
+public: // Internal methods
+#if 0
+	CBenProperty(pCBenObject pObject, BenObjectID PropertyID,
+	  BenObjectID TypeID, pCBenIDListElmt pPrevProperty) :
+	  CBenIDListElmt(PropertyID, pPrevProperty), cValue(this, TypeID)
+	  { cpObject = pObject; }
+#endif
+	// changed by  to remove WARNING here 2004-06-24
+	CBenProperty(pCBenObject pObject, BenObjectID PropertyID,
+	  BenObjectID TypeID, pCBenIDListElmt pPrevProperty) :
+	  CBenIDListElmt(PropertyID, pPrevProperty), cValue(TypeID)
+	{ 
+		cpObject = pObject; 
+		cValue.SetProperty(this);
+	}
+
+BenObjectID GetPropertyNameID() { return GetID(); }
+
+private: // Data
+	pCBenObject cpObject;
+	CBenValue cValue;
+};
+
+// In our implementation, reference is always just the object ID for the
+// object referenced (but you shouldn't assume that)
+#define BEN_REFERENCE_SIZE 4
+
+class CBenReference
+{
+public: // Methods
+	BenByte * GetData() { return cData; }
+
+private: // Data
+	BenByte cData[BEN_REFERENCE_SIZE];
+};
+
+class CBenValueSegment : public CUtListElmt
+{
+public: // Internal methods
+	CBenValueSegment(pCBenValue pValue, BenContainerPos Pos,
+	  unsigned long Size) : CUtListElmt(pValue->GetValueSegments())
+	  { cpValue = pValue; cImmediate = UT_FALSE; cPos = Pos;
+	  cSize = Size; }
+	CBenValueSegment(pCBenValue pValue, BenConstDataPtr pImmData,
+	  unsigned short Size) : CUtListElmt(pValue->GetValueSegments())
+	  { cpValue = pValue; cImmediate = UT_TRUE;
+	  UtHugeMemcpy(cImmData, pImmData, Size); cSize = Size; }
+	CBenValueSegment(BenContainerPos Pos, unsigned long Size)
+	  { cpValue = NULL; cImmediate = UT_FALSE; cPos = Pos;
+	  cSize = Size; }
+	CBenValueSegment(BenConstDataPtr pImmData, unsigned short Size)
+	  { cpValue = NULL; cImmediate = UT_TRUE;
+	  UtHugeMemcpy(cImmData, pImmData, Size); cSize = Size; }
+	UtBool IsLast()
+	{
+		return cpValue == NULL || cpValue->GetValueSegments()->GetLast() ==
+		  this;
+	}
+	UtBool IsImmediate() { return cImmediate; }
+	BenContainerPos GetPosition() { return cPos; }
+	unsigned long GetSize() { return cSize; }
+	void SetSize(unsigned long Size) { cSize = Size; }
+	BenByte * GetImmediateData() { return cImmData; }
+
+private: // Data
+	pCBenValue cpValue;
+	UtBool cImmediate;
+	union
+	{
+		BenContainerPos cPos;
+		BenByte cImmData[4];
+	};
+	unsigned long cSize;
+};
+
+inline pCBenValueSegment CBenValue::GetNextValueSegment(pCBenValueSegment
+  pCurrValueSegment)
+{ return (pCBenValueSegment) cValueSegments.GetNextOrNULL(pCurrValueSegment); }
+
+inline pLtcBenContainer CBenValue::GetContainer()
+{ return GetProperty()->GetContainer(); }
+
+class CBenNamedObject : public CBenObject
+{
+public: // Methods
+	virtual UtBool IsNamedObject();
+	virtual UtBool IsPropertyName();
+	virtual UtBool IsTypeName();
+
+public: // Internal methods
+	CBenNamedObject(pLtcBenContainer pContainer, BenObjectID ObjectID,
+	pCBenObject pPrevObject, const char * sName,
+	pCBenNamedObjectListElmt pPrevNamedObjectListElmt);
+	const char * GetName() { return csName.data(); }
+
+	
+	const char * GetNameCStr() { return csName.c_str(); }
+	
+
+	void SetPosition(BenContainerPos Pos) { cPos = Pos; }
+	BenContainerPos GetPosition(void) { return cPos; }
+	size_t GetLength(void) { return csName.length()+ 1; }
+	pCBenNamedObjectListElmt GetNameListElmt() { return &cNameListElmt; }
+
+private: // Data
+	string csName;
+	CBenNamedObjectListElmt cNameListElmt;
+	BenContainerPos cPos;
+};
+
+class CBenPropertyName : public CBenNamedObject
+{
+public: // Internal methods
+	CBenPropertyName(pLtcBenContainer pContainer, BenObjectID ObjectID,
+	pCBenObject pPrevObject, const char * sName,
+	pCBenNamedObjectListElmt pPrevNamedObjectListElmt) :
+	CBenNamedObject(pContainer, ObjectID, pPrevObject, sName,
+	pPrevNamedObjectListElmt) { ; }
+	virtual UtBool IsPropertyName();
+};
+
+class CBenTypeName : public CBenNamedObject
+{
+public: // Internal methods
+	CBenTypeName(pLtcBenContainer pContainer, BenObjectID ObjectID,
+	pCBenObject pPrevObject, const char * sName,
+	pCBenNamedObjectListElmt pPrevNamedObjectListElmt) :
+	CBenNamedObject(pContainer, ObjectID, pPrevObject, sName,
+	pPrevNamedObjectListElmt) { ; }
+	virtual UtBool IsTypeName();
+};
+
+
+} // end namespace OpenStormBento
+#endif
diff -urNp lotuswordpro.bak/source/filter/bentoid.hxx lotuswordpro/source/filter/bentoid.hxx
--- lotuswordpro.bak/source/filter/bentoid.hxx	1970-01-01 08:00:00.000000000 +0800
+++ lotuswordpro/source/filter/bentoid.hxx	2008-10-22 11:42:29.000000000 +0800
@@ -0,0 +1,110 @@
+/*************************************************************************
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: IBM Corporation
+ *
+ *  Copyright: 2008 by IBM Corporation
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+#ifndef BENTOID_H
+#define BENTOID_H
+
+namespace OpenStormBento
+{
+
+#define BEN_OBJID_TOC 1 // TOC object ID
+#define BEN_PROPID_TOC_SEED 2 // TOC object starting seed
+#define BEN_PROPID_TOC_MIN_SEED 3 // TOC object minimum seed
+#define BEN_PROPID_TOC_OBJECT 4 // TOC object
+#define BEN_PROPID_TOC_CONTAINER 5 // TOC object entire container
+#define BEN_PROPID_TOC_DELETED 6 // TOC object amount deleted
+#define BEN_TYPEID_TOC_TYPE	19 // TOC object property value type
+#define BEN_OBJID_WRITEABLE 20 // Predefined ID's below this value will be
+							   // written to container TOC.  Predefined IDs
+							   // above this are not written
+#define BEN_TYPEID_7_BIT_ASCII 21 // 7-bit ASCII
+#define BEN_PROPID_GLOBAL_TYPE_NAME 23 // Global type name
+#define BEN_PROPID_GLOBAL_PROPERTY_NAME 24 // Global property name
+#define BEN_PROPID_OBJ_REFERENCES 31 // Referenced objects from an object
+#define BEN_TYPEID_OBJ_REFERENCES_DATA 32 // Reference data
+#define BEN_OBJID_MIN_GENERAL_ID 100 // Min object ID for general std objects
+
+#define BEN_NEW_OBJECT 1 // object + property + type
+#define BEN_NEW_PROPERTY 2 // property + type
+#define BEN_NEW_TYPE 3 // type
+#define BEN_EXPLICIT_GEN 4 // generation
+
+#define BEN_SEGMENT_CODE_START 5
+#define BEN_OFFSET4_LEN4 5 // 4-byte offset + 4-byte length
+#define BEN_CONT_OFFSET4_LEN4 6 // continued 4-byte offset + 4-byte length
+#define BEN_OFFSET8_LEN4 7 // 8-byte offset + 4-byte length
+#define BEN_CONT_OFFSET8_LEN4 8 // continued 8-byte offset + 4-byte length
+#define BEN_IMMEDIATE0 9 // immediate (length = 0)
+#define BEN_IMMEDIATE1 10 // immediate (length = 1)
+#define BEN_IMMEDIATE2 11 // immediate (length = 2)
+#define BEN_IMMEDIATE3 12 // immediate (length = 3)
+#define BEN_IMMEDIATE4 13 // immediate (length = 4)
+#define BEN_CONT_IMMEDIATE4 14 // continued immediate (length = 4)
+#define BEN_SEGMENT_CODE_END 14
+
+#define BEN_REFERENCE_LIST_ID 15 // references recording object ID
+#define BEN_RESERVED4B 16
+#define BEN_RESERVED4C 17
+#define BEN_RESERVED8A 18 // reserved for future use of 8 byte entry
+#define BEN_RESERVED8B 19 // reserved for future use of 8 byte entry
+#define BEN_RESERVED8C 20 // reserved for future use of 8 byte entry
+#define BEN_RESERVED12A 21 // reserved for future use of 12 byte entry
+#define BEN_RESERVED12B 22 // reserved for future use of 12 byte entry
+#define BEN_RESERVED12C 23 // reserved for future use of 12 byte entry
+#define BEN_END_OF_BUFFER 24 // end of current buffer, go to next
+#define BEN_READ_PAST_END_OF_TOC 50 // Our code
+#define BEN_NOOP 0xFF
+
+}// end OpenStormBento namespace
+#endif
diff -urNp lotuswordpro.bak/source/filter/benval.cxx lotuswordpro/source/filter/benval.cxx
--- lotuswordpro.bak/source/filter/benval.cxx	1970-01-01 08:00:00.000000000 +0800
+++ lotuswordpro/source/filter/benval.cxx	2008-10-22 11:42:29.000000000 +0800
@@ -0,0 +1,348 @@
+/*************************************************************************
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: IBM Corporation
+ *
+ *  Copyright: 2008 by IBM Corporation
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+#include "first.hxx"
+#include "assert.h"
+namespace OpenStormBento
+{
+
+unsigned long
+CBenValue::GetValueSize()
+{
+	unsigned long Size = 0;
+	pCBenValueSegment pCurr = NULL;
+	while ((pCurr = GetNextValueSegment(pCurr)) != NULL)
+		Size += pCurr->GetSize();
+	return Size;
+}
+
+BenError
+CBenValue::ReadValueData(BenDataPtr pReadBuffer, unsigned long Offset,
+  unsigned long Amt, unsigned long * pAmtRead)
+{
+	BenError Err;
+	unsigned long SegOffset = 0;
+	*pAmtRead = 0;
+	pCBenValueSegment pCurrSeg = NULL;
+	pLtcBenContainer pContainer = GetContainer();
+	BenByteDataPtr pBuffer = (BenByteDataPtr) pReadBuffer;
+
+	/// pReadBuffer -- pointer to buffer of read result, allocated outside this function
+	/// Offset          -- read buffer's start offset address, relative value in the whole value stream
+	/// Amt             -- read buffer's size
+	/// pAmtRead    -- return the actual read size
+
+	/// SegOffset     -- current segment's start address offset, relative value in the whole value stream
+	
+	while ((pCurrSeg = GetNextValueSegment(pCurrSeg)) != NULL)
+	{
+		if (Amt == 0)   			/// whole buffer is full now, so return
+			return BenErr_OK;
+
+		if (SegOffset <= Offset && Offset < SegOffset + pCurrSeg->GetSize()) /// begin at current segment
+		{
+			unsigned long OffsetIntoSeg = Offset - SegOffset;  /// relative value in this value segment stream
+
+			unsigned long AmtThisSeg = UtMin(Amt, pCurrSeg->GetSize() -
+			  OffsetIntoSeg);				/// size read in this segment, it's minimal value between Amt & 
+			  							/// remain part from OffsetIntoSeg to the end of this segment
+			
+			unsigned long AmtReadThisSeg; /// actual read size in this segment
+			if (pCurrSeg->IsImmediate())
+			{
+				UtHugeMemcpy(pBuffer, pCurrSeg->GetImmediateData() +
+				  OffsetIntoSeg, AmtThisSeg);
+				AmtReadThisSeg = AmtThisSeg;
+			}
+			else
+			{
+				if ((Err = pContainer->SeekToPosition(pCurrSeg->GetPosition() +
+			  	  OffsetIntoSeg)) != BenErr_OK)
+			  		return Err;
+
+				if ((Err = pContainer->Read(pBuffer, AmtThisSeg,
+				  &AmtReadThisSeg)) != BenErr_OK)
+			  		return Err;
+			}
+
+			*pAmtRead += AmtReadThisSeg;
+
+			if (AmtThisSeg != AmtReadThisSeg)
+				return BenErr_UnexpectedEndOfFile;
+
+			pBuffer += AmtReadThisSeg;
+			Offset += AmtReadThisSeg;
+			Amt -= AmtReadThisSeg;
+		}
+
+		SegOffset += pCurrSeg->GetSize();
+	}
+	return BenErr_OK;
+}
+
+BenError
+CBenValue::ReadValueDataKnownSize(BenDataPtr pBuffer, unsigned long Offset,
+  unsigned long Amt)
+{
+	unsigned long AmtRead;
+	BenError Err = ReadValueData(pBuffer, Offset, Amt, &AmtRead);
+
+	if (Err == UtErr_OK && AmtRead != Amt)
+		Err = (BenError) UtErr_Fail;
+
+	return Err;
+}
+
+BenError
+CBenValue::WriteValueData(BenConstDataPtr pWriteBuffer, unsigned long Offset,
+  unsigned long Amt, unsigned long * pAmtWritten)
+{
+#if 0// Deleted by  2004-06-16
+	unsigned long AmtWritten;
+	if (pAmtWritten == NULL)
+		pAmtWritten = &AmtWritten;
+
+	*pAmtWritten = 0;
+
+	if (Amt == 0)
+		return BenErr_OK;
+
+	unsigned long SegOffset = 0;
+	pCBenValueSegment pCurrSeg = NULL;
+	BenError Err;
+	pLtcBenContainer pContainer = GetContainer();
+	BenConstByteDataPtr pBuffer = (BenConstByteDataPtr) pWriteBuffer;
+
+	while ((pCurrSeg = GetNextValueSegment(pCurrSeg)) != NULL)
+	{
+		if (Amt == 0)
+			return BenErr_OK;
+
+		if (SegOffset <= Offset && Offset < SegOffset + pCurrSeg->GetSize())
+		{
+			unsigned long OffsetIntoSeg = Offset - SegOffset;
+
+			unsigned long AmtThisSeg = UtMin(Amt, pCurrSeg->GetSize() -
+			  OffsetIntoSeg);
+
+			if (pCurrSeg->IsImmediate())
+			{
+				UtHugeMemcpy(pCurrSeg->GetImmediateData() + OffsetIntoSeg,
+				  pBuffer, AmtThisSeg);
+				*pAmtWritten += AmtThisSeg;
+			}
+			else
+			{
+				if ((Err = pContainer->SeekToPosition(pCurrSeg->GetPosition()
+			  	  + OffsetIntoSeg)) != BenErr_OK)
+			  		return Err;
+
+				unsigned long AmtWrittenThisWrite;
+				Err = pContainer->Write(pBuffer, AmtThisSeg,
+				  &AmtWrittenThisWrite);
+				*pAmtWritten += AmtWrittenThisWrite;
+				if (Err != BenErr_OK)
+					return Err;
+			}
+
+			pBuffer += AmtThisSeg;
+			Offset += AmtThisSeg;
+			Amt -= AmtThisSeg;
+		}
+
+		SegOffset += pCurrSeg->GetSize();
+	}
+
+	if (Offset > SegOffset)
+	{
+		assert(! "Write past end of value");
+		return BenErr_InvalidWriteOffset;
+	}
+
+	if (Amt == 0)
+		return BenErr_OK;
+
+	if ((Err = pContainer->SeekFromEnd(0)) != BenErr_OK)
+		return Err;
+
+	BenContainerPos EndFilePos;
+	if ((Err = pContainer->GetPosition(&EndFilePos)) != BenErr_OK)
+		return Err;
+
+	unsigned long AmtWrittenThisWrite;
+	Err = pContainer->Write(pBuffer, Amt, &AmtWrittenThisWrite);
+	*pAmtWritten += AmtWrittenThisWrite;
+	if (Err != BenErr_OK)
+		return Err;
+
+	pCBenValueSegment pLastSeg = (pCBenValueSegment) (
+	  cValueSegments.GetLast() == cValueSegments.GetTerminating() ?
+	  NULL : cValueSegments.GetLast() );
+	if (pLastSeg != NULL && ! pLastSeg->IsImmediate() &&
+	  pLastSeg->GetPosition() + pLastSeg->GetSize() == EndFilePos)
+		pLastSeg->SetSize(pLastSeg->GetSize() + Amt);
+	else new CBenValueSegment(this, EndFilePos, Amt);
+#endif
+	return BenErr_OK;
+}
+
+BenError
+CBenValue::TruncateValueSize(unsigned long NewSize)
+{
+	unsigned long SegOffset = 0;
+
+	pCBenValueSegment pCurrSeg = GetNextValueSegment(NULL);
+	while (pCurrSeg != NULL)
+	{
+		pCBenValueSegment pNextSeg = GetNextValueSegment(pCurrSeg);
+
+		long SegSize = UtMin((long) pCurrSeg->GetSize(), (long) NewSize -
+		  (long) SegOffset);
+
+		if (SegSize <= 0)
+			delete pCurrSeg;
+		else pCurrSeg->SetSize(SegSize);
+
+		SegOffset += SegSize;
+		pCurrSeg = pNextSeg;
+	}
+
+	return BenErr_OK;
+}
+
+BenError
+CBenValue::WriteValueData(BenConstDataPtr pWriteBuffer, unsigned long Offset,
+  unsigned long Amt)
+{
+	unsigned long AmtWritten;
+	return WriteValueData(pWriteBuffer, Offset, Amt, &AmtWritten);
+}
+
+BenError
+CBenValue::WriteImmediateValueData(BenConstDataPtr pBuffer,
+  unsigned short Size)
+{
+	// Only one write can be an immediate value in current implementation
+	if (cValueSegments.GetFirst() != cValueSegments.GetTerminating() ||
+	  Size > 4)
+		return BenErr_InvalidImmediateWrite;
+
+	if (Size == 0)
+		return BenErr_OK;
+
+	new CBenValueSegment(this, pBuffer, Size);
+	return BenErr_OK;
+}
+
+BenError
+CBenValue::NewReference(BenObjectID ReferencedObjectID, pCBenReference
+  pReference)
+{
+	BenError Err;
+
+	if (cpReferencedList == NULL)
+	{
+		pLtcBenContainer pContainer = cpProperty->GetContainer();
+
+		pCBenObject pNewObject;
+		if ((Err = pContainer->NewObject(&pNewObject)) != BenErr_OK)
+			return Err;
+
+		pCBenValue pNewValue;
+		if ((Err = pNewObject->NewValue(BEN_PROPID_OBJ_REFERENCES,
+		  BEN_TYPEID_OBJ_REFERENCES_DATA, &pNewValue)) != BenErr_OK)
+		{
+			delete pNewObject;
+			return Err;
+		}
+
+		cpReferencedList = pNewValue;
+		cReferencedObjectsSize = 0;
+	}
+
+	BenByte Buffer[8];
+	UtPutIntelDWord(Buffer, ReferencedObjectID);
+	UtPutIntelDWord(Buffer + 4, ReferencedObjectID);
+
+	UtPutIntelDWord(pReference->GetData(), ReferencedObjectID);
+
+	if ((Err = cpReferencedList->WriteValueData(Buffer,
+	  cReferencedObjectsSize, 8)) != BenErr_OK)
+		return Err;
+
+	cReferencedObjectsSize += 8;
+	return BenErr_OK;
+}
+
+BenObjectID
+CBenValue::GetReferencedObject(pCBenReference pReference)
+{
+	return UtGetIntelDWord(pReference->GetData());
+}
+
+BenObjectID
+CBenValue::GetReferencedListID()
+{
+	if (cpReferencedList != NULL)
+		return cpReferencedList->GetProperty()->GetBenObject()->GetID();
+	else 
+	{
+#ifdef BENUTIL_SUPPORT
+		return cReferencedListID;
+#else
+		return 0;
+#endif
+	}
+}
+}//end namespace OpenStormBento
diff -urNp lotuswordpro.bak/source/filter/explode.cxx lotuswordpro/source/filter/explode.cxx
--- lotuswordpro.bak/source/filter/explode.cxx	1970-01-01 08:00:00.000000000 +0800
+++ lotuswordpro/source/filter/explode.cxx	2008-10-22 11:42:29.000000000 +0800
@@ -0,0 +1,648 @@
+/*************************************************************************
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: IBM Corporation
+ *
+ *  Copyright: 2008 by IBM Corporation
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+#include <assert.h>
+#include "explode.hxx"
+#include <math.h>
+	const static char Tree1String[][32] = {
+		"101",
+		"11",
+	       "100", 
+		"011", 
+		"0101",
+		"0100",
+		"0011",
+		"00101",
+		"00100",
+		"00011",
+		"00010",
+		"000011",
+		"000010",
+		"000001",
+		"0000001",
+		"0000000",
+	};
+
+	const static char Tree2String[][32] = {
+		"11"    ,
+		"1011"  ,
+	       "1010"  ,
+		"10011"  ,
+		"10010"  ,
+		"10001"  ,
+		"10000"  ,
+		"011111"  ,
+		"011110"  ,
+		"011101"  ,
+		"011100"  ,
+		"011011"  ,
+		"011010"  ,
+		"011001"  ,
+		"011000"  ,
+		"010111"  ,
+		"010110" ,
+		"010101" ,
+		"010100" ,
+		"010011" ,
+		"010010" ,
+		"010001" ,
+		"0100001" ,
+		"0100000" ,
+		"0011111" ,
+		"0011110" ,
+		"0011101" ,
+		"0011100" ,
+		"0011011" ,
+		"0011010" ,
+		"0011001" ,
+		"0011000" ,
+		"0010111" ,
+		"0010110" ,
+		"0010101" ,
+		"0010100" ,
+		"0010011" ,
+		"0010010" ,
+		"0010001" ,
+		"0010000" ,
+		"0001111" ,
+		"0001110" ,
+		"0001101" ,
+		"0001100" ,
+		"0001011" ,
+		"0001010" ,
+		"0001001" ,
+		"0001000" ,
+		"00001111",
+		"00001110",
+		"00001101",
+		"00001100",
+		"00001011",
+		"00001010",
+		"00001001",
+		"00001000",
+		"00000111",
+		"00000110",
+		"00000101",
+		"00000100",
+		"00000011",
+		"00000010",
+		"00000001",
+		"00000000",
+	};
+
+Decompression::Decompression(SvStream * pInStream, SvStream * pOutStream):
+	m_pInStream(pInStream), m_pOutStream(pOutStream), m_pBuffer(m_Buffer), m_nOutputBufferPos(0),
+		m_nBitsLeft(0), m_nBytesLeft(0), m_nCurrent4Byte(0)
+{
+	if (!m_pInStream || !m_pOutStream )
+	{
+		assert(sal_False);
+	}
+	ConstructTree1();
+	ConstructTree2();
+	fillArray();
+}
+/**
+ * @descr	read specified bits from input stream
+ * @argument iCount - number of bits to be read, less than 31
+ * @argument nBits - bits read
+ * @return 	0 - read OK, otherwise error
+ */
+sal_uInt32 Decompression::ReadBits(sal_uInt16 iCount, sal_uInt32 & nBits) 
+{
+	if ( (iCount == 0) || (iCount > 32 ) )
+	{
+		return 1;
+	}
+	
+	sal_uInt32 val = 0;		/* bit accumulator */
+
+	/* load at least need bits into val */
+	val = m_nCurrent4Byte;
+	while (m_nBitsLeft < iCount) 
+	{
+		if (m_nBytesLeft == 0) 
+		{
+			m_nBytesLeft = m_pInStream->Read(m_Buffer, CHUNK);
+			m_pBuffer = m_Buffer;
+			if (m_nBytesLeft == 0)  return 1; 
+	        }
+		val |= (sal_uInt32)(*m_pBuffer++) << m_nBitsLeft;		/* load eight bits */
+		m_nBytesLeft --;
+		m_nBitsLeft += 8;
+	}
+
+	/* drop need bits and update buffer, always zero to seven bits left */
+	m_nCurrent4Byte = val >> iCount;
+	m_nBitsLeft -= iCount;
+
+	/* return need bits, zeroing the bits above that */
+	nBits = val & ((1 << iCount) - 1);
+
+	return 0;	
+} 
+/**
+ * @descr	decompress input and write output
+ * @return 	0 - read OK, otherwise error
+ */
+sal_Int32 Decompression::explode()
+{
+	/* The first 2 bytes are parameters */
+	sal_uInt32 P1;
+	if (0 != ReadBits(8, P1))/* 0 or 1 */
+		return -1;
+	
+	/* I think this means 0=binary and 1=ascii file, but in RESOURCEs I saw always 0 */
+	if (P1 >= 1) // changed per 's review comments
+		return -1;
+	
+	sal_uInt32 P2;
+	if (0 != ReadBits(8, P2))
+		return -1;
+	
+	/* must be 4,5 or 6 and it is a parameter for the decompression algorithm */
+	if (P2 < 4 || P2 > 6) 
+		return -2;
+
+	m_nOutputBufferPos = 0;
+	/* Now, a bit stream follows, which is decoded as described below: */
+	/*  The algorithm terminates as soon as it runs out of bits. */
+	while(sal_True)
+	{
+		// read 1 bit (take bits from the lowest value (LSB) to the MSB i.e. bit 0, bit 1 etc ...)
+		sal_uInt32 iBit;
+		if (0 != ReadBits(1, iBit))
+			break;
+		if ( 0 == (iBit & 0x01) )
+		{
+			//if the bit is 0 read 8 bits and write it to the output as it is.
+			sal_uInt32 symbol;
+			if (0 != ReadBits(8, symbol))
+				break;
+			m_Output[m_nOutputBufferPos++] = (sal_uInt8)symbol;
+			if (m_nOutputBufferPos == MAXWIN) 
+			{
+				m_pOutStream->Write(m_Output, m_nOutputBufferPos);
+				m_nOutputBufferPos = 0;
+			}
+			continue;
+		}
+		// if the bit is 1 we have here a length/distance pair:
+		// -decode a number with Hufmman Tree #1; variable bit length, result is 0x00 .. 0x0F -> L1
+		sal_uInt32 L1 = Decode(m_Tree1);
+		sal_uInt32 Length;
+		if (L1 <= 7)
+		{
+			//if L1 <= 7:
+			//           LENGTH = L1 + 2
+			Length = L1 + 2;
+		}
+		else
+		{
+			// if L1 > 7
+			//            read more (L1-7) bits -> L2
+			//             LENGTH = L2 + M[L1-7] + 2
+			sal_uInt32 L2;
+			if (0 != ReadBits((sal_uInt16)(L1 - 7), L2))
+				break;
+			Length = L2 + 2 + m_iArrayOfM[L1 -7];
+		}
+		if (Length == 519)
+		{
+			// end of compressed data
+			break;
+		}
+		
+		// - decode another number with Hufmann Tree #2 giving result 0x00..0x3F -> D1
+		sal_uInt32 D1 = Decode(m_Tree2);
+		sal_uInt32 D2;
+		if (Length == 2)
+		{
+			//       if LENGTH == 2
+			//              D1 = D1 << 2
+			//              read 2 bits -> D2
+			D1 = D1 << 2;
+			if (0 != ReadBits(2, D2))
+				break;
+		}
+		else
+		{
+			//        else
+			//               D1 = D1 << P2  // the parameter 2
+			//               read P2 bits -> D2
+			D1 = D1 << P2;
+			if (0 != ReadBits((sal_uInt16)P2, D2))
+				break;
+		}
+		// DISTANCE = (D1 | D2) + 1			
+		sal_uInt32 distance = (D1 | D2) + 1;
+
+	        // - now copy LENGTH bytes from (output_ptr-DISTANCE) to output_ptr		
+	        // write current buffer to output
+		m_pOutStream->Write(m_Output, m_nOutputBufferPos);
+		m_nOutputBufferPos = 0;
+
+		// remember current position
+		sal_uInt32 nOutputPos = m_pOutStream->Tell();
+		if (distance > nOutputPos)
+			return -3; // format error
+
+		m_pOutStream->Flush();
+		// point back to copy position and read bytes
+		m_pOutStream->SeekRel((long)-distance);
+		sal_uInt8 sTemp[MAXWIN];
+		sal_uInt32 nRead = distance > Length? Length:distance;
+		m_pOutStream->Read(sTemp, nRead);
+		if (nRead != Length)
+		{
+			// fill the buffer with read content repeatly until full
+			for (sal_uInt32 i=nRead; i<Length; i++)
+			{
+				sTemp[i] = sTemp[i-nRead];
+			}
+		}
+
+		// restore output stream position
+		m_pOutStream->Seek(nOutputPos);
+		
+	       // write current buffer to output
+		m_pOutStream->Write(sTemp, Length);
+	}
+	return 0;
+}
+/**
+ * @descr	bits to string
+ * @return 	
+ */
+void Decompression::ToString(sal_uInt32 nBits, sal_Char *pChar, sal_uInt32 nLen)
+{
+	sal_uInt32 nBit;
+	for (sal_uInt32 i=nLen; i > 0; i--)
+	{
+		nBit = (nBits >> (i -1) ) & 0x01;
+		pChar[nLen - i]  = nBit ? '1':'0';
+	}
+	pChar[nLen] = '\0';
+	return;
+}
+
+/**
+ * @descr	decode tree 1 for length
+ * @return 	the decoded value
+ */
+sal_uInt32 Decompression::Decode(HuffmanTreeNode * pRoot)
+{
+	sal_uInt32 nRet;
+	sal_uInt32 nRead, nReadAlready;
+	
+	if( 0 != ReadBits(1, nReadAlready))
+		return 0; // something wrong
+
+	for (sal_uInt16 i=2; i <= 8; i++)
+	{
+		if ( 0 != ReadBits(1, nRead))
+			return 0; // something wrong
+			
+		nReadAlready  = (nReadAlready << 1) | (nRead & 0x01);
+
+		sal_Char sCode[16];
+		ToString(nReadAlready, sCode, i);
+		nRet = pRoot->QueryValue(sCode);	
+		if (nRet != 0xffffffff)
+		{
+			break;
+		}
+	}
+	return nRet;
+}
+/**
+ * @descr	construct tree 1 for length
+ * @return 	
+ */
+void Decompression::ConstructTree1()
+{	// Huffman Tree #1
+	// The first huffman tree (the Section called Decompression algorithm HUFFMAN) contains the length values. It is described by the following table: 
+	// value (hex)	code (binary)
+	// 0	101
+	// 1	11
+	// 2	100
+	// 3	011
+	// 4	0101
+	// 5	0100
+	// 6	0011
+	// 7	0010 1
+	// 8	0010 0
+	// 9	0001 1
+	// a	0001 0
+	// b	0000 11
+	// c	0000 10
+	// d	0000 01
+	// e	0000 001
+	// f	0000 000
+	m_Tree1 = new HuffmanTreeNode();
+	for (sal_uInt32 i=0; i< 16; i++)
+	{
+	    m_Tree1->InsertNode(i, Tree1String[i]);
+	}
+	/*
+	m_Tree1->InsertNode(0,   "101");
+	m_Tree1->InsertNode(1,   "11");
+	m_Tree1->InsertNode(2,   "100");
+	m_Tree1->InsertNode(3,   "011");
+	m_Tree1->InsertNode(4,   "0101");
+	m_Tree1->InsertNode(5,   "0100");
+	m_Tree1->InsertNode(6,   "0011");
+	m_Tree1->InsertNode(7,   "00101");
+	m_Tree1->InsertNode(8,   "00100");
+	m_Tree1->InsertNode(9,   "00011");
+	m_Tree1->InsertNode(10, "00010");
+	m_Tree1->InsertNode(11, "000011");
+	m_Tree1->InsertNode(12, "000010");
+	m_Tree1->InsertNode(13, "000001");
+	m_Tree1->InsertNode(14, "0000001");
+	m_Tree1->InsertNode(15, "0000000");
+	*/
+}
+/**
+ * @descr	construct tree 2 for distance
+ * @return 	
+ */
+void Decompression::ConstructTree2()
+{
+
+	m_Tree2 = new HuffmanTreeNode();
+	for (sal_uInt32 i=0; i< 64; i++)
+	{
+	    m_Tree2->InsertNode(i, Tree2String[i]);
+	}
+#if 0
+	m_Tree2 = new HuffmanTreeNode();
+    //Huffman Tree #2
+    //The second huffman code tree contains the distance values. It can be built from the following table:
+    //value (hex) code (binary)
+    //00  11
+    //01  1011
+    //02  1010
+    //03  1001 1
+    //04  1001 0
+    //05  1000 1
+    //06  1000 0
+    //07  0111 11
+    //08  0111 10
+    //09  0111 01
+    //0a  0111 00
+    //0b  0110 11
+    //0c  0110 10
+    //0d  0110 01
+    //0e  0110 00
+    //0f  0101 11
+	m_Tree2->InsertNode(0x0,   "11");
+	m_Tree2->InsertNode(0x1,   "1011");
+	m_Tree2->InsertNode(0x2,   "1010");
+	m_Tree2->InsertNode(0x3,   "10011");
+	m_Tree2->InsertNode(0x4,   "10010");
+	m_Tree2->InsertNode(0x5,   "10001");
+	m_Tree2->InsertNode(0x6,   "10000");
+	m_Tree2->InsertNode(0x7,   "011111");
+	m_Tree2->InsertNode(0x8,   "011110");
+	m_Tree2->InsertNode(0x9,   "011101");
+	m_Tree2->InsertNode(0x0a,  "011100");
+	m_Tree2->InsertNode(0x0b,  "011011");
+	m_Tree2->InsertNode(0x0c,  "011010");
+	m_Tree2->InsertNode(0x0d,  "011001");
+	m_Tree2->InsertNode(0x0e,  "011000");
+	m_Tree2->InsertNode(0x0f,  "010111");
+	//10  0101 10
+	//11  0101 01
+	//12  0101 00
+	//13  0100 11
+	//14  0100 10
+	//15  0100 01
+	//16  0100 001
+	//17  0100 000
+	//18  0011 111
+	//19  0011 110
+	// 1a  0011 101
+	// 1b  0011 100
+	// 1c  0011 011
+	// 1d  0011 010
+	// 1e  0011 001
+	// 1f  0011 000
+	m_Tree2->InsertNode(0x10,   "010110");
+	m_Tree2->InsertNode(0x11,   "010101");
+	m_Tree2->InsertNode(0x12,   "010100");
+	m_Tree2->InsertNode(0x13,   "010011");
+	m_Tree2->InsertNode(0x14,   "010010");
+	m_Tree2->InsertNode(0x15,   "010001");
+	m_Tree2->InsertNode(0x16,   "0100001");
+	m_Tree2->InsertNode(0x17,   "0100000");
+	m_Tree2->InsertNode(0x18,   "0011111");
+	m_Tree2->InsertNode(0x19,   "0011110");
+	m_Tree2->InsertNode(0x1a,   "0011101");
+	m_Tree2->InsertNode(0x1b,   "0011100");
+	m_Tree2->InsertNode(0x1c,   "0011011");
+	m_Tree2->InsertNode(0x1d,   "0011010");
+	m_Tree2->InsertNode(0x1e,   "0011001");
+	m_Tree2->InsertNode(0x1f,   "0011000");
+    //20  0010 111
+    //21  0010 110
+    //22  0010 101
+    //23  0010 100
+    //24  0010 011
+    //25  0010 010
+    //26  0010 001
+    //27  0010 000
+    //28  0001 111
+    //29  0001 110
+    // 2a  0001 101
+    // 2b  0001 100
+    // 2c  0001 011
+    // 2d  0001 010
+    // 2e  0001 001
+    // 2f  0001 000
+	m_Tree2->InsertNode(0x20,   "0010111");
+	m_Tree2->InsertNode(0x21,   "0010110");
+	m_Tree2->InsertNode(0x22,   "0010101");
+	m_Tree2->InsertNode(0x23,   "0010100");
+	m_Tree2->InsertNode(0x24,   "0010011");
+	m_Tree2->InsertNode(0x25,   "0010010");
+	m_Tree2->InsertNode(0x26,   "0010001");
+	m_Tree2->InsertNode(0x27,   "0010000");
+	m_Tree2->InsertNode(0x28,   "0001111");
+	m_Tree2->InsertNode(0x29,   "0001110");
+	m_Tree2->InsertNode(0x2a,   "0001101");
+	m_Tree2->InsertNode(0x2b,   "0001100");
+	m_Tree2->InsertNode(0x2c,   "0001011");
+	m_Tree2->InsertNode(0x2d,   "0001010");
+	m_Tree2->InsertNode(0x2e,   "0001001");
+	m_Tree2->InsertNode(0x2f,   "0001000");
+    //30  0000 1111
+    //31  0000 1110
+    //32  0000 1101
+    //33  0000 1100
+    //34  0000 1011
+    //35  0000 1010
+    //36  0000 1001
+    //37  0000 1000
+    //38  0000 0111
+    //39  0000 0110
+    // 3a  0000 0101
+    // 3b  0000 0100
+    // 3c  0000 0011
+    // 3d  0000 0010
+    // 3e  0000 0001
+    // 3f  0000 0000
+	m_Tree2->InsertNode(0x30,   "00001111");
+	m_Tree2->InsertNode(0x31,   "00001110");
+	m_Tree2->InsertNode(0x32,   "00001101");
+	m_Tree2->InsertNode(0x33,   "00001100");
+	m_Tree2->InsertNode(0x34,   "00001011");
+	m_Tree2->InsertNode(0x35,   "00001010");
+	m_Tree2->InsertNode(0x36,   "00001001");
+	m_Tree2->InsertNode(0x37,   "00001000");
+	m_Tree2->InsertNode(0x38,   "00000111");
+	m_Tree2->InsertNode(0x39,   "00000110");
+	m_Tree2->InsertNode(0x3a,   "00000101");
+	m_Tree2->InsertNode(0x3b,   "00000100");
+	m_Tree2->InsertNode(0x3c,   "00000011");
+	m_Tree2->InsertNode(0x3d,   "00000010");
+	m_Tree2->InsertNode(0x3e,   "00000001");
+	m_Tree2->InsertNode(0x3f,   "00000000");
+#endif	
+    //where bits should be read from the left to the right.
+}
+/**
+ * @descr	
+ * @return 	
+ */
+void Decompression::fillArray()
+{
+	m_iArrayOfM[0] = 7;
+	for (int i=1; i < 16; i++)
+	{
+		double dR = 2.0;
+		m_iArrayOfM[i]  = m_iArrayOfM[i - 1]+ (sal_uInt32)pow(dR, i-1);//2
+	}
+}
+
+HuffmanTreeNode::HuffmanTreeNode(sal_uInt32 nValue , HuffmanTreeNode * pLeft , HuffmanTreeNode * pRight ) 
+{
+	value = nValue;
+	left = pLeft; 
+	right = pRight;
+}
+HuffmanTreeNode::~HuffmanTreeNode() 
+{
+	if (left)
+	{
+		delete left;
+		left = NULL;
+	}
+	if (right)
+	{
+		delete right;
+		right = NULL;
+	}		
+}
+
+HuffmanTreeNode * HuffmanTreeNode::InsertNode(sal_uInt32 nValue, const sal_Char * pInCode)
+{
+	HuffmanTreeNode *pNew = new HuffmanTreeNode(nValue);
+	sal_Char pCode[32];
+		strcpy(pCode, pInCode );
+
+	// query its parents
+	sal_Char cLast = pCode[strlen(pCode) - 1];
+	pCode[strlen(pCode) - 1] = '\0';
+	HuffmanTreeNode * pParent = QueryNode(pCode);
+	if (!pParent)
+	{
+		pParent = InsertNode(0xffffffff, pCode);
+	}
+	if (cLast == '0')
+		pParent->left = pNew;
+	else // (cChar == '1')
+		pParent->right = pNew;
+
+	return pNew;
+}
+HuffmanTreeNode * HuffmanTreeNode::QueryNode(const sal_Char * pCode)
+{
+	sal_uInt32 nLen = strlen(pCode);
+
+	HuffmanTreeNode * pNode = this; // this is the root 
+	for(sal_uInt32 i=0; i<nLen && pNode; i++)
+	{
+		sal_Char cChar= pCode[i];
+		if (cChar == '0')
+		{
+			pNode = pNode->left;
+		}
+		else // (cChar == '1')
+		{
+			pNode = pNode->right;
+		}
+	}
+	return pNode;
+}
+
+sal_uInt32 HuffmanTreeNode::QueryValue(const sal_Char * pCode)
+{
+	HuffmanTreeNode * pNode =QueryNode(pCode);
+	if (pNode)
+		return pNode->value;
+
+	return 0xffffffff;
+}
+
diff -urNp lotuswordpro.bak/source/filter/explode.hxx lotuswordpro/source/filter/explode.hxx
--- lotuswordpro.bak/source/filter/explode.hxx	1970-01-01 08:00:00.000000000 +0800
+++ lotuswordpro/source/filter/explode.hxx	2008-10-22 11:42:29.000000000 +0800
@@ -0,0 +1,125 @@
+/*************************************************************************
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: IBM Corporation
+ *
+ *  Copyright: 2008 by IBM Corporation
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+#ifndef _EXPLODE_HXX_
+#define _EXPLODE_HXX_
+
+#include <tools/stream.hxx>
+
+class HuffmanTreeNode
+{
+public:
+	HuffmanTreeNode * left;
+	HuffmanTreeNode * right;
+	sal_uInt32 value;
+	
+	HuffmanTreeNode(sal_uInt32 value = 0xffffffff, HuffmanTreeNode * left = NULL, HuffmanTreeNode * right = NULL) ;
+	~HuffmanTreeNode() ;	
+	HuffmanTreeNode * InsertNode(sal_uInt32 nValue, const sal_Char * pInCode);
+	HuffmanTreeNode * QueryNode(const sal_Char *pCode);
+	sal_uInt32 QueryValue(const sal_Char *pCode);
+};
+
+
+/**
+ * @brief
+ * define the function type for input read, output write
+ */
+#define CHUNK 16384
+#define MAXWIN 4096		/* maximum window size */
+class Decompression
+{
+public:
+	Decompression(SvStream * pInStream, SvStream * pOutStream);
+	~Decompression()
+	{
+		delete m_Tree1;
+		delete m_Tree2;
+	};
+	/**
+	 * @brief
+	 * decompress from instream to outstream
+	 */
+	sal_Int32 explode();
+	sal_uInt32 ReadBits(sal_uInt16 iCount, sal_uInt32 & nBits) ;
+	sal_uInt32 Decode(HuffmanTreeNode * pRoot);
+
+	/**
+	 * @brief
+	 * compressed/decompressed stream
+	 */
+	SvStream *m_pInStream;
+	SvStream *m_pOutStream;
+
+	sal_uInt32 m_nCurrent4Byte;   // bit buffer
+	sal_uInt32 m_nBitsLeft;		// number of bits remained in bit buffer
+
+	sal_uInt8 m_Buffer[CHUNK];	// input byte buffer
+	sal_uInt8 *m_pBuffer;			// pointer to input buffer
+	sal_uInt32 m_nBytesLeft;		// number of bytes remained in byte buffer	
+
+	sal_uInt8 m_Output[MAXWIN];	// output byte buffer
+	sal_uInt32 m_nOutputBufferPos;	// pointer to output buffer
+
+	sal_uInt32 m_iArrayOfM[16];
+
+
+	HuffmanTreeNode *m_Tree1, *m_Tree2;
+
+	void ConstructTree1();
+	void ConstructTree2();
+	void fillArray();
+	void ToString(sal_uInt32 nBits, sal_Char *pChar, sal_uInt32 nLen);
+};
+#endif
diff -urNp lotuswordpro.bak/source/filter/first.hxx lotuswordpro/source/filter/first.hxx
--- lotuswordpro.bak/source/filter/first.hxx	1970-01-01 08:00:00.000000000 +0800
+++ lotuswordpro/source/filter/first.hxx	2008-10-22 11:42:29.000000000 +0800
@@ -0,0 +1,81 @@
+/*************************************************************************
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: IBM Corporation
+ *
+ *  Copyright: 2008 by IBM Corporation
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+#ifndef FIRST_HXX
+#define FIRST_HXX
+
+//#include "utfirst.h"					// Deleted by  2004-06-16
+#include "bento.hxx"		// Public header
+
+//#define ASSERT(cond) UT_ASSERT(cond) 		// Deleted by  2004-06-16
+namespace OpenStormBento
+{
+// String constants
+extern const char gsBenMagicBytes[];
+
+typedef BenByte * BenByteDataPtr;
+typedef const BenByte * BenConstByteDataPtr;
+
+pCBenNamedObject FindNamedObject(pCUtList pList, const char * sName,
+  pCBenNamedObjectListElmt * ppPrev);
+
+pCBenIDListElmt FindID(pCUtList pList, BenObjectID ObjectID,
+  pCBenIDListElmt * ppPrev);
+} // end namespace
+
+// Private headers
+#include "bentoid.hxx"
+#include "tocread.hxx"
+//#include "tocwrite.h"				// Deleted by  2004-06-16
+#endif
diff -urNp lotuswordpro.bak/source/filter/localtime.cxx lotuswordpro/source/filter/localtime.cxx
--- lotuswordpro.bak/source/filter/localtime.cxx	1970-01-01 08:00:00.000000000 +0800
+++ lotuswordpro/source/filter/localtime.cxx	2008-10-22 12:00:18.000000000 +0800
@@ -0,0 +1,189 @@
+/*************************************************************************
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: IBM Corporation
+ *
+ *  Copyright: 2008 by IBM Corporation
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+#include "localtime.hxx"
+#include <unicode/timezone.h>
+//End by 
+const long DAY_SEC =24 * 60 * 60;
+const long YEAR_SEC = 365 * DAY_SEC;
+const long FOURYEAR_SEC = 4 * YEAR_SEC + DAY_SEC;
+const long LONG_MAX=2147483647;
+const long TIMEZONE = -28800;
+//01-01-70 was a Thursday
+const long BASE_DOW = 4;
+
+long _lpdays[] = {-1, 30, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365};
+
+long _days[] = {-1, 30, 58, 89, 119, 150, 180, 211, 242, 272, 303, 333, 364};
+
+bool LtgGmTime(long rtime,LtTm& rtm)
+{
+	if (rtime < 0)
+	{
+		return false;
+	}
+	//is-current-year-a-leap-year flag
+	int islpyr = 0;
+	
+	long tmptim;
+	long caltim = rtime;
+	tmptim = (long)(caltim / FOURYEAR_SEC);
+	caltim -= ((long)tmptim * FOURYEAR_SEC);
+
+	//
+	//Determine which year of the interval
+	//
+	// 1970, 1974, 1978,...,etc.
+	tmptim = (tmptim * 4) + 70;
+	
+	if (caltim >= YEAR_SEC)
+	{
+		//1971, 1975, 1979,...,etc.
+		tmptim++;
+		caltim -= YEAR_SEC;
+
+		if ( caltim >= YEAR_SEC ) 
+		{
+			// 1972, 1976, 1980,...,etc.
+			tmptim++;
+			caltim -= YEAR_SEC;
+			
+			//Note, it takes 366 days-worth of seconds to get past a leap year.
+			if (caltim >= (YEAR_SEC + DAY_SEC)) 
+			{
+				//1973, 1977, 1981,...,etc.
+				tmptim++;
+				caltim -= (YEAR_SEC + DAY_SEC);
+			}
+			else
+			{
+				//In a leap year after all, set the flag.
+				islpyr++;
+			}
+		}
+	}
+	
+	//
+	//tmptim now holds the value for tm_year. caltim now holds the
+	//number of elapsed seconds since the beginning of that year.
+	//
+	rtm.tm_year = tmptim;
+	//
+	//Determine days since January 1 (0 - 365). This is the tm_yday value.
+	//Leave caltim with number of elapsed seconds in that day.
+	//
+	rtm.tm_yday = (long)(caltim / DAY_SEC);
+	caltim -= (long)(rtm.tm_yday) * DAY_SEC;
+	//
+	//Determine months since January (0 - 11) and day of month (1 - 31)
+	//
+	long* mdays;
+	if ( islpyr )
+	{
+		mdays = _lpdays;
+	}
+	else
+	{
+		mdays = _days;
+	}
+
+	for ( tmptim = 1 ; mdays[tmptim] < rtm.tm_yday ; tmptim++ ) ;
+
+	rtm.tm_mon = --tmptim;
+
+	rtm.tm_mday = rtm.tm_yday - mdays[tmptim];
+
+	//
+	//Determine days since Sunday (0 - 6)
+	//
+	rtm.tm_wday = ((long)(rtime / DAY_SEC) + BASE_DOW) % 7;
+	//
+	//Determine hours since midnight (0 - 23), minutes after the hour
+	//(0 - 59), and seconds after the minute (0 - 59).
+	//
+	rtm.tm_hour = (long)(caltim / 3600);
+	caltim -= (long)rtm.tm_hour * 3600;
+
+	rtm.tm_min = (long)(caltim / 60);
+	rtm.tm_sec = (long)(caltim - (rtm.tm_min) * 60);
+
+	rtm.tm_isdst = 0;
+
+	//
+	//
+	//
+	//adjust year & month
+	rtm.tm_year += 1900;
+	++(rtm.tm_mon);
+	
+	return true;
+
+};
+bool LtgLocalTime(long rtime,LtTm& rtm)
+{
+	long ltime;
+	if (rtime < 0)
+	{
+		return false;
+	}
+
+	if ((rtime > 3 * DAY_SEC)&&(rtime < LONG_MAX - 3 * DAY_SEC))
+	{
+		TimeZone* pLocalZone = TimeZone::createDefault();
+		long offset = (pLocalZone->getRawOffset())/1000;
+		ltime = rtime + offset;
+		return LtgGmTime(ltime,rtm);
+	}
+	return false;
+};
diff -urNp lotuswordpro.bak/source/filter/localtime.hxx lotuswordpro/source/filter/localtime.hxx
--- lotuswordpro.bak/source/filter/localtime.hxx	1970-01-01 08:00:00.000000000 +0800
+++ lotuswordpro/source/filter/localtime.hxx	2008-10-22 11:57:59.000000000 +0800
@@ -0,0 +1,73 @@
+/*************************************************************************
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: IBM Corporation
+ *
+ *  Copyright: 2008 by IBM Corporation
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+#ifndef _LWPTIME_HXX_
+#define _LWPTIME_HXX_
+
+struct LtTm 
+{
+	long tm_sec;     /* seconds after the minute - [0,59] */
+	long tm_min;     /* minutes after the hour - [0,59] */
+	long tm_hour;    /* hours since midnight - [0,23] */
+	long tm_mday;    /* day of the month - [1,31] */
+	long tm_mon;     /* months since January - [0,11] */
+	long tm_year;    /* years since 1900 */
+	long tm_wday;    /* days since Sunday - [0,6] */
+	long tm_yday;    /* days since January 1 - [0,365] */
+	long tm_isdst;   /* daylight savings time flag */
+};
+bool LtgGmTime(long rtime,LtTm& rtm);
+bool LtgLocalTime(long rtime,LtTm& rtm);
+
+#endif
diff -urNp lotuswordpro.bak/source/filter/lwp9reader.cxx lotuswordpro/source/filter/lwp9reader.cxx
--- lotuswordpro.bak/source/filter/lwp9reader.cxx	1970-01-01 08:00:00.000000000 +0800
+++ lotuswordpro/source/filter/lwp9reader.cxx	2008-10-22 11:42:29.000000000 +0800
@@ -0,0 +1,291 @@
+/*************************************************************************
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: IBM Corporation
+ *
+ *  Copyright: 2008 by IBM Corporation
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+#ifndef _LWP9READER_HXX
+#include "lwp9reader.hxx"
+#endif
+#include "lwpglobalmgr.hxx"
+#include "lwpunoheader.hxx"
+#include "lwparrowstyles.hxx"
+#include "lwpobjhdr.hxx"
+#include "lwpdoc.hxx"
+#include "xfilter/xfstylemanager.hxx"
+#include "lwpdocdata.hxx"
+#include "lwpbookmarkmgr.hxx"
+#include "lwpchangemgr.hxx"
+#include <tools/stream.hxx>
+
+Lwp9Reader::Lwp9Reader (LwpSvStream* pInputStream, IXFStream* pStream)
+	: m_pDocStream(pInputStream), m_pStream(pStream), m_LwpFileHdr()
+{}
+
+/**
+ * @descr	The entrance of Word Pro 9 import filter.  
+ **/
+void Lwp9Reader::Read()
+{
+	LwpGlobalMgr* pGlobal = LwpGlobalMgr::GetInstance(m_pDocStream);
+	m_pObjMgr = pGlobal->GetLwpObjFactory();
+
+	//Commented out  by , 10/26/2005
+	//Read Ole object in LwpOleObject::XFConverter to support Ole in Linux
+	//ReadOleObjects();
+	
+	ReadFileHeader();
+	//Does not support Word Pro 96 and previous versions
+	if(LwpFileHeader::m_nFileRevision>=0x000B)
+	{
+		ReadIndex();
+		ParseDocument();
+	}
+	LwpGlobalMgr::DeleteInstance();
+}
+
+/**
+ * @descr	Read the OLE objects.  
+ */
+void Lwp9Reader::ReadOleObjects() 	
+{
+#if 0
+#ifdef WIN32
+	if(m_pObjMgr)
+	{
+		// Get the buffer of the whole file
+		LwpSvStream* pRawStream = m_pDocStream;
+		sal_Int64 nCurPos = pRawStream->Tell();
+		sal_uInt32 nSize = static_cast<sal_uInt32>(pRawStream->Seek(STREAM_SEEK_TO_END));
+		BYTE* pBuf = new BYTE[nSize];
+
+		if(pBuf == NULL)				// this buffer may be too big
+		{
+			assert(sal_False);
+			return;
+		}
+		pRawStream->Seek(STREAM_SEEK_TO_BEGIN);
+		pRawStream->Read(pBuf,nSize);
+		pRawStream->Seek(nCurPos);
+
+		// Break the buffer into separate objects by ASWAN lib
+		BYTE* pOut = NULL;
+		sal_uInt32 nWritten;
+		CBenStorageConverter benConverter;
+		benConverter.Convert(pBuf, nSize, (void**)&pOut, &nWritten);
+		delete[] pBuf;
+
+		if (NULL != pOut)
+		{
+			SvStream* pMemStream = new SvMemoryStream(pOut, nWritten, STREAM_READ|STREAM_WRITE);
+			SvStorageRef objStor = new SvStorage(pMemStream, true);	// 	set true to let SvStorage free the memstream.
+			m_pObjMgr->SetOleObjInfo(objStor);
+		}
+		
+	}
+#endif
+#endif
+}
+/**
+ * @descr	Read the LWP7 object.  
+ */
+void Lwp9Reader::ReadFileHeader() 	
+{
+	m_pDocStream->Seek(LwpSvStream::LWP_STREAM_BASE);
+
+	//Remember to initialize the LwpFileHeader::m_nFileRevision first.
+	LwpFileHeader::m_nFileRevision = 0;
+	
+	LwpObjectHeader objHdr;
+	objHdr.Read(*m_pDocStream);
+	sal_Int64 pos = m_pDocStream->Tell();
+	m_LwpFileHdr.Read(m_pDocStream);		
+	m_pDocStream->Seek(pos+objHdr.GetSize());
+		
+}
+
+/**
+ * @descr  Read the index objects at the end of the WordProData stream
+ */
+void Lwp9Reader::ReadIndex() 
+{
+	sal_Int64 oldpos = m_pDocStream->Tell();
+	sal_uInt32 rootoffset = m_LwpFileHdr.GetRootIndexOffset();
+	m_pDocStream->Seek(rootoffset + LwpSvStream::LWP_STREAM_BASE);
+	m_pObjMgr->ReadIndex(m_pDocStream);
+	m_pDocStream->Seek(oldpos);
+}
+
+/**
+ * @descr	Read all objects
+ * 		This function is  replaced by the read on demand model
+ *		Reserverd for future use
+*/
+void Lwp9Reader::DumpAllObjects()
+{
+	sal_Int64 nFileSize = GetFileSize();
+	sal_Int64 nFilePos = m_pDocStream->Tell();
+
+	while(true)
+	{
+		LwpObjectHeader objHdr;
+		objHdr.Read(*m_pDocStream);
+		nFilePos = m_pDocStream->Tell();
+		//Stop when reaching the index object
+		if(objHdr.GetTag() >= VO_ROOTLEAFOBJINDEX)
+		{
+			break;
+		}
+		//Stop when the length exceeds the file length
+		if(nFilePos + objHdr.GetSize() > nFileSize)
+		{
+			assert(false);
+			break;
+		}
+		m_pObjMgr->CreateObject(objHdr.GetTag(), objHdr);
+		m_pDocStream->Seek(nFilePos+objHdr.GetSize());
+	}
+}
+
+/**
+ * @descr	Get file size
+*/
+sal_Int64 Lwp9Reader::GetFileSize()
+{
+	sal_Int64 pos = m_pDocStream->Tell();
+	m_pDocStream->Seek(0);
+	
+	sal_Int64 size = m_pDocStream->Seek( STREAM_SEEK_TO_END);
+	m_pDocStream->Seek(pos);
+	return(size);
+}
+
+/**
+ * @descr		Parse all document content
+*/
+void Lwp9Reader::ParseDocument()
+{	
+	WriteDocHeader();
+
+	//Get root document
+	LwpDocument* doc = static_cast<LwpDocument*> ( m_LwpFileHdr.GetDocID()->obj() );
+
+	//Parse Doc Data
+	LwpDocData *pDocData = static_cast<LwpDocData*>((doc->GetDocData())->obj());
+	if (pDocData!=NULL)
+	{
+		pDocData->Parse(m_pStream);
+	}
+		
+	//Register Styles
+	RegisteArrowStyles();
+	doc->RegisterStyle();
+	XFStyleManager* pXFStyleManager = LwpGlobalMgr::GetInstance()->GetXFStyleManager();
+	pXFStyleManager->ToXml(m_pStream);
+
+	//Parse document content
+	m_pStream->GetAttrList()->Clear();
+	m_pStream->StartElement( A2OUSTR("office:body") );
+	
+	//Parse change list, add by 
+	LwpGlobalMgr* pGlobal = LwpGlobalMgr::GetInstance(); 
+	LwpChangeMgr* pChangeMgr = pGlobal->GetLwpChangeMgr();
+	pChangeMgr->ConvertAllChange(m_pStream);
+	
+	doc->Parse(m_pStream);
+	m_pStream->EndElement(::rtl::OUString::createFromAscii("office:body"));
+	
+	WriteDocEnd();
+}
+
+/**
+ * @descr 	Write xml document header
+ */
+void Lwp9Reader::WriteDocHeader()
+{
+	m_pStream->StartDocument();
+
+	IXFAttrList *pAttrList = m_pStream->GetAttrList();
+
+	pAttrList->AddAttribute( A2OUSTR("xmlns:office"), A2OUSTR("http://openoffice.org/2000/office") );
+	pAttrList->AddAttribute( A2OUSTR("xmlns:style"), A2OUSTR("http://openoffice.org/2000/style") );
+	pAttrList->AddAttribute( A2OUSTR("xmlns:text"), A2OUSTR("http://openoffice.org/2000/text") );
+	pAttrList->AddAttribute( A2OUSTR("xmlns:table"), A2OUSTR("http://openoffice.org/2000/table") );
+	pAttrList->AddAttribute( A2OUSTR("xmlns:draw"), A2OUSTR("http://openoffice.org/2000/drawing") );
+
+	pAttrList->AddAttribute( A2OUSTR("xmlns:fo"), A2OUSTR("http://www.w3.org/1999/XSL/Format") );
+	pAttrList->AddAttribute( A2OUSTR("xmlns:xlink"), A2OUSTR("http://www.w3.org/1999/xlink") );
+	pAttrList->AddAttribute( A2OUSTR("xmlns:number"), A2OUSTR("http://openoffice.org/2000/datastyle") );
+	pAttrList->AddAttribute( A2OUSTR("xmlns:svg"), A2OUSTR("http://www.w3.org/2000/svg") );
+	pAttrList->AddAttribute( A2OUSTR("xmlns:chart"), A2OUSTR("http://openoffice.org/2000/chart") );
+
+	pAttrList->AddAttribute( A2OUSTR("xmlns:dr3d"), A2OUSTR("http://openoffice.org/2000/dr3d") );
+	pAttrList->AddAttribute( A2OUSTR("xmlns:math"), A2OUSTR("http://www.w3.org/1998/Math/MathML") );
+	pAttrList->AddAttribute( A2OUSTR("xmlns:form"), A2OUSTR("http://openoffice.org/2000/form") );
+	pAttrList->AddAttribute( A2OUSTR("xmlns:script"), A2OUSTR("http://openoffice.org/2000/script") );
+	pAttrList->AddAttribute( A2OUSTR("xmlns:dc"), A2OUSTR("http://purl.org/dc/elements/1.1/") );
+
+	pAttrList->AddAttribute( A2OUSTR("xmlns:meta"), A2OUSTR("http://openoffice.org/2000/meta") );
+	pAttrList->AddAttribute( A2OUSTR("office:class"), A2OUSTR("text"));
+	pAttrList->AddAttribute( A2OUSTR("office:version"), A2OUSTR("1.0"));
+	
+	m_pStream->StartElement( ::rtl::OUString::createFromAscii("office:document") );
+	pAttrList->Clear();
+
+}
+/**
+ * @descr 	Write xml document end
+ */
+void Lwp9Reader::WriteDocEnd()
+{
+	m_pStream->EndElement(::rtl::OUString::createFromAscii("office:document"));
+	m_pStream->EndDocument();
+}
diff -urNp lotuswordpro.bak/source/filter/lwp9reader.hxx lotuswordpro/source/filter/lwp9reader.hxx
--- lotuswordpro.bak/source/filter/lwp9reader.hxx	1970-01-01 08:00:00.000000000 +0800
+++ lotuswordpro/source/filter/lwp9reader.hxx	2008-10-22 11:42:29.000000000 +0800
@@ -0,0 +1,89 @@
+/*************************************************************************
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: IBM Corporation
+ *
+ *  Copyright: 2008 by IBM Corporation
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+#ifndef _LWP9READER_HXX
+#define _LWP9READER_HXX
+
+#include "lwpheader.hxx"
+#include "lwpunoheader.hxx"
+#include "lwpsvstream.hxx"
+#include "lwpfilehdr.hxx"
+#include "lwpobjfactory.hxx"
+#include "xfilter/ixfstream.hxx"
+/**
+ * @brief	Reader framework class for Lotus Word Pro 9 file
+*/
+class Lwp9Reader
+{
+	public:
+		Lwp9Reader(LwpSvStream* InputStream, IXFStream* pStream);
+		~Lwp9Reader(){};
+	private:
+		LwpSvStream*	m_pDocStream;
+		IXFStream* m_pStream;
+		LwpObjectFactory* m_pObjMgr;
+		LwpFileHeader m_LwpFileHdr; 			//LWP7 object
+	protected:
+		sal_Int64 GetFileSize();
+		void ReadFileHeader();
+		void ReadIndex();
+		void DumpAllObjects();
+		void ParseDocument();
+		void WriteDocHeader();
+		void WriteDocEnd();	
+		void ReadOleObjects();
+	public:		
+		void Read();
+};
+#endif
diff -urNp lotuswordpro.bak/source/filter/lwparrowstyles.hxx lotuswordpro/source/filter/lwparrowstyles.hxx
--- lotuswordpro.bak/source/filter/lwparrowstyles.hxx	1970-01-01 08:00:00.000000000 +0800
+++ lotuswordpro/source/filter/lwparrowstyles.hxx	2008-10-22 11:42:29.000000000 +0800
@@ -0,0 +1,101 @@
+/*************************************************************************
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: IBM Corporation
+ *
+ *  Copyright: 2008 by IBM Corporation
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+#ifndef		_LWPARROWSTYLES_HXX
+#define		_LWPARROWSTYLES_HXX
+
+#include	"xfilter/xfarrowstyle.hxx"
+#include	"xfilter/xfstylemanager.hxx"
+#include	"lwpglobalmgr.hxx"
+
+/**
+ * @descr	Registe arrow styles that are not directly support by SODC.
+ *	There are three kinds,revsered arrow,revered concave arrow and revsered
+ *	line arrow. this function should be called before the three arrows be used.
+ */
+void	RegisteArrowStyles()
+{
+	XFStyleManager* pXFStyleManager = LwpGlobalMgr::GetInstance()->GetXFStyleManager();
+	if (!pXFStyleManager)
+		return;
+	//reversed arrow:
+	XFArrowStyle *pArrowStyle100 = new XFArrowStyle();
+	pArrowStyle100->SetArrowName( A2OUSTR("arrow100") );
+	pArrowStyle100->SetViewbox(A2OUSTR("0 0 140 200"));
+	pArrowStyle100->SetSVGPath(A2OUSTR("M0 180 L70 0 L140 180 L120 180 L70 30 L20 180 L0 180"));
+	pXFStyleManager->AddStyle(pArrowStyle100);
+	
+	//reversed arrow:
+	XFArrowStyle *pArrowStyle1 = new XFArrowStyle();
+	pArrowStyle1->SetArrowName( A2OUSTR("reverse arrow") );
+	pArrowStyle1->SetViewbox(A2OUSTR("0 0 140 200"));
+	pArrowStyle1->SetSVGPath(A2OUSTR("M0 0 L70 200 L140 0"));
+	pXFStyleManager->AddStyle(pArrowStyle1);
+
+	//reversed concave arrow
+	XFArrowStyle *pArrowStyle2 = new XFArrowStyle();
+	pArrowStyle2->SetArrowName( A2OUSTR("reverse concave arrow") );
+	pArrowStyle2->SetViewbox(A2OUSTR("0 0 140 200"));
+	pArrowStyle2->SetSVGPath(A2OUSTR("M0 0 L80 200 L160 0 L80 100"));
+	pXFStyleManager->AddStyle(pArrowStyle2);
+
+	//reversed line arrow
+	XFArrowStyle *pArrowStyle3 = new XFArrowStyle();
+	pArrowStyle3->SetArrowName( A2OUSTR("reverse line arrow") );
+	pArrowStyle3->SetViewbox(A2OUSTR("0 0 140 200"));
+	pArrowStyle3->SetSVGPath(A2OUSTR("M0 0 L70 200 L140 0L110 0 L70 160 L20 0 L0 0"));
+	pXFStyleManager->AddStyle(pArrowStyle3);
+}
+
+#endif
\ No newline at end of file
diff -urNp lotuswordpro.bak/source/filter/lwpatomholder.cxx lotuswordpro/source/filter/lwpatomholder.cxx
--- lotuswordpro.bak/source/filter/lwpatomholder.cxx	1970-01-01 08:00:00.000000000 +0800
+++ lotuswordpro/source/filter/lwpatomholder.cxx	2008-10-22 11:42:29.000000000 +0800
@@ -0,0 +1,109 @@
+/*************************************************************************
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: IBM Corporation
+ *
+ *  Copyright: 2008 by IBM Corporation
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+#include "lwpatomholder.hxx"
+#include "lwptools.hxx"
+#include <osl/thread.h>
+#include <rtl/textenc.h>
+
+LwpAtomHolder::LwpAtomHolder()
+	: m_nAtom(0), m_nAssocAtom(0)
+{}
+
+LwpAtomHolder::~LwpAtomHolder()
+{}
+/**
+ * @descr		read atomholder from object stream
+ *			the default encoding used in Word Pro is 1252
+*/
+void LwpAtomHolder::Read(LwpObjectStream *pStrm)
+{
+	//Refered to lwp: file40.cpp, QuickReadAtomHolder()
+
+	sal_uInt16 len, diskSize;
+	pStrm->QuickRead(&diskSize, sizeof(diskSize));
+	pStrm->QuickRead(&len, sizeof(len));	
+	
+	if (len == 0 || diskSize == 0) {
+		m_nAtom = BAD_ATOM;
+		m_nAssocAtom = BAD_ATOM;
+		return; 
+	}
+	m_nAtom = m_nAssocAtom = len;
+	
+	//rtl_TextEncoding rEncode =  gsl_getSystemTextEncoding();
+	rtl_TextEncoding rEncode =  RTL_TEXTENCODING_MS_1252;
+	len = LwpTools::QuickReadUnicode(pStrm, m_String, diskSize-sizeof(diskSize), rEncode);
+}
+/**
+ * @descr		skip the atom holder in object stream
+*/
+void LwpAtomHolder::Skip(LwpObjectStream *pStrm)
+{
+	sal_uInt16 holdersize;
+	pStrm->QuickRead(&holdersize, sizeof(holdersize));
+	pStrm->SeekRel(holdersize);
+	m_nAtom = m_nAssocAtom = BAD_ATOM;
+}
+/**
+ * @descr		read path atom
+ *			No use now for lwp filter, just skip the atom
+*/	
+void LwpAtomHolder::ReadPathAtom(LwpObjectStream *pStrm)
+{
+	//Refered to lwp: file40.cpp, QuickReadPathAtom()
+	// TODO:  Read the data. Now just skip it. The method to skip is same as above.
+	Skip(pStrm);	
+}
+
diff -urNp lotuswordpro.bak/source/filter/lwpatomholder.hxx lotuswordpro/source/filter/lwpatomholder.hxx
--- lotuswordpro.bak/source/filter/lwpatomholder.hxx	1970-01-01 08:00:00.000000000 +0800
+++ lotuswordpro/source/filter/lwpatomholder.hxx	2008-10-22 11:42:29.000000000 +0800
@@ -0,0 +1,86 @@
+/*************************************************************************
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: IBM Corporation
+ *
+ *  Copyright: 2008 by IBM Corporation
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+#ifndef _LWPATOMHOLDER_HXX
+#define _LWPATOMHOLDER_HXX
+
+#include "lwpheader.hxx"
+#include "lwpdefs.hxx"
+#include "lwpobjstrm.hxx"
+/**
+ * @brief	AtomHolder class of Word Pro to hold a string
+*/
+class LwpAtomHolder
+{
+public:
+	LwpAtomHolder();
+	~LwpAtomHolder();
+private:
+	sal_Int32	m_nAtom;
+	sal_Int32	m_nAssocAtom;
+	OUString m_String;
+	//OUString m_UniString;			//no use temporarily
+public:
+	void Read(LwpObjectStream *pStrm);	
+	void ReadPathAtom(LwpObjectStream *pStrm);	
+	void Skip(LwpObjectStream *pStrm);
+	OUString str(){return m_String;}
+	inline sal_Bool HasValue();
+};
+inline sal_Bool LwpAtomHolder::HasValue()
+{
+	return (m_nAtom != BAD_ATOM);
+}
+
+#endif
diff -urNp lotuswordpro.bak/source/filter/lwpbackgroundoverride.hxx lotuswordpro/source/filter/lwpbackgroundoverride.hxx
--- lotuswordpro.bak/source/filter/lwpbackgroundoverride.hxx	1970-01-01 08:00:00.000000000 +0800
+++ lotuswordpro/source/filter/lwpbackgroundoverride.hxx	2008-10-22 11:42:29.000000000 +0800
@@ -0,0 +1,91 @@
+/*************************************************************************
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: IBM Corporation
+ *
+ *  Copyright: 2008 by IBM Corporation
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+#ifndef		_LWPBACKGROUNDOVERRIDE_HXX
+#define		_LWPBACKGROUNDOVERRIDE_HXX
+
+
+#include	"lwpoverride.hxx"
+#include	"lwpbackgroundstuff.hxx"
+
+class LwpObjectStream;
+class LwpBackgroundOverride : public LwpOverride
+{
+	
+public:
+	LwpBackgroundOverride(){};
+	virtual ~LwpBackgroundOverride(){}
+	
+	
+public:
+	virtual void Read(LwpObjectStream *pStrm)
+	{
+		if (pStrm->QuickReadBool())
+		{
+			ReadCommon(pStrm);
+			
+			m_aStuff.Read(pStrm);
+		}
+		
+		pStrm->SkipExtra();
+	}
+
+	LwpColor GetBackColor(){ return m_aStuff.m_aFillColor; }
+	LwpBackgroundStuff* GetBGStuff() { return &m_aStuff; }
+	
+private:	
+	LwpBackgroundStuff	m_aStuff;
+};
+
+#endif
\ No newline at end of file
diff -urNp lotuswordpro.bak/source/filter/lwpbackgroundstuff.cxx lotuswordpro/source/filter/lwpbackgroundstuff.cxx
--- lotuswordpro.bak/source/filter/lwpbackgroundstuff.cxx	1970-01-01 08:00:00.000000000 +0800
+++ lotuswordpro/source/filter/lwpbackgroundstuff.cxx	2008-10-22 11:42:29.000000000 +0800
@@ -0,0 +1,183 @@
+/*************************************************************************
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: IBM Corporation
+ *
+ *  Copyright: 2008 by IBM Corporation
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+/**
+ * @file 
+ * For LWP filter architecture prototype
+ *  Implemention of class LwpBackgroundStuff.
+ */
+
+#include "lwpbackgroundstuff.hxx"
+#include "lwppttntbl.hxx"
+#include "xfilter/xfbgimage.hxx"
+
+#include "tools/stream.hxx"
+#include "vcl/bmpacc.hxx"
+#include "svx/xbitmap.hxx"
+
+
+void LwpBackgroundStuff::Read(LwpObjectStream* pStrm)
+{
+	pStrm->QuickRead(&m_nID, sizeof(m_nID));
+	m_aFillColor.Read(pStrm);
+	m_aPatternColor.Read(pStrm);
+	pStrm->SkipExtra();
+}
+
+void LwpBackgroundStuff::GetPattern(sal_uInt16 btPttnIndex, sal_uInt8* pPttnArray)
+{
+	if (btPttnIndex > 71)
+	{
+		assert(false);
+		return;
+	}
+	if (pPttnArray)
+	{
+		assert((2 < btPttnIndex) && (btPttnIndex < 72));
+		sal_uInt8* pTempArray = s_pLwpPatternTab[btPttnIndex];
+		for(sal_uInt8 i = 0; i < 32; i++)
+		{
+			pPttnArray[i] = (i%4 == 0) ? pTempArray[7-i/4] : 0;
+		}
+	}
+}
+
+LwpColor* LwpBackgroundStuff::GetFillColor()
+{
+	if (m_nID == BACK_PATTERN)
+	{
+		return &m_aPatternColor;
+	}
+	
+	return &m_aFillColor;
+}
+
+XFBGImage* LwpBackgroundStuff::GetFillPattern()
+{
+	// not pattern fill?
+	if (!this->IsPatternFill())
+	{
+		return NULL;
+	}
+
+	// get pattern array from pattern table
+	sal_uInt8* pPttnArray = new sal_uInt8 [32];
+	this->GetPattern(m_nID, pPttnArray);
+
+	// create bitmap object from the pattern array
+	Bitmap aBmp( Size(8, 8), 1 );
+	BitmapWriteAccess* pWA = aBmp.AcquireWriteAccess();
+	sal_uInt8* pBuf = pWA->GetBuffer();
+	memcpy(pBuf, pPttnArray, 32);
+	aBmp.ReleaseAccess(pWA);
+
+	if (pPttnArray)
+	{
+		delete [] pPttnArray;
+		pPttnArray = NULL;
+	}
+
+	// create XOBitmap object from bitmap object
+	XOBitmap aXOBitmap;
+	aXOBitmap.SetBitmap( aBmp );
+	aXOBitmap.Bitmap2Array();
+	aXOBitmap.SetBitmapType( XBITMAP_8X8 );
+
+	// set back/fore-ground colors
+	if (m_aFillColor.IsValidColor() && m_aPatternColor.IsValidColor())
+	{
+		Color aBackColor(static_cast<sal_uInt8>(m_aFillColor.GetRed()),
+			static_cast<sal_uInt8>(m_aFillColor.GetGreen()),
+			static_cast<sal_uInt8>(m_aFillColor.GetBlue()));
+		Color aForeColor(static_cast<sal_uInt8>(m_aPatternColor.GetRed()),
+			static_cast<sal_uInt8>(m_aPatternColor.GetGreen()),
+			static_cast<sal_uInt8>(m_aPatternColor.GetBlue()));
+		
+		if( aXOBitmap.GetBackgroundColor() == COL_BLACK )
+		{
+			aXOBitmap.SetPixelColor( aBackColor );
+			aXOBitmap.SetBackgroundColor( aForeColor );
+		}
+		else
+		{
+			aXOBitmap.SetPixelColor( aForeColor );
+			aXOBitmap.SetBackgroundColor( aBackColor );
+		}
+	}
+
+	// transfer image data from XOBitmap->SvStream->BYTE-Array
+	SvMemoryStream aPicMemStream;
+	aXOBitmap.Array2Bitmap();
+	aXOBitmap.GetBitmap().Write(aPicMemStream);
+	sal_uInt32 nSize = aPicMemStream.GetSize();
+	sal_uInt8* pImageBuff = new sal_uInt8 [nSize];
+	memcpy(pImageBuff, aPicMemStream.GetData(), nSize);
+
+	// create XFBGImage object.
+	XFBGImage* pXFBGImage = new XFBGImage();
+	pXFBGImage->SetImageData(pImageBuff, nSize);
+	
+	if (pImageBuff)
+	{
+		delete [] pImageBuff;
+		pImageBuff = NULL;
+	}
+
+	
+	pXFBGImage->SetRepeate();
+	// end of add
+	
+	return pXFBGImage;
+}
+
diff -urNp lotuswordpro.bak/source/filter/lwpbackgroundstuff.hxx lotuswordpro/source/filter/lwpbackgroundstuff.hxx
--- lotuswordpro.bak/source/filter/lwpbackgroundstuff.hxx	1970-01-01 08:00:00.000000000 +0800
+++ lotuswordpro/source/filter/lwpbackgroundstuff.hxx	2008-10-22 11:42:29.000000000 +0800
@@ -0,0 +1,169 @@
+/*************************************************************************
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: IBM Corporation
+ *
+ *  Copyright: 2008 by IBM Corporation
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+/*************************************************************************
+* @file 
+* Backgound object of Wordpro.
+************************************************************************/
+/*************************************************************************
+* Change History
+* 2005-01-12 Create and implement.
+************************************************************************/
+#ifndef		_LWPBACKGROUNDSTUFF_HXX
+#define		_LWPBACKGROUNDSTUFF_HXX
+#include	"lwpcolor.hxx"
+
+/* background patterns */
+#define BACK_TRANSPARENT	0
+#define BACK_FILL			1
+#define BACK_PATTERN		2
+#define BACK_10PCTDOTS		3
+#define BACK_30PCTDOTS		4
+#define BACK_50PCTDOTS		5
+#define BACK_75PCTDOTS		6
+#define BACK_90PCTDOTS		7
+#define BACK_90PCTINVDOTS	8
+#define BACK_75PCTINVDOTS	9
+#define BACK_50PCTINVDOTS	10
+#define BACK_30PCTINVDOTS	11
+#define BACK_10PCTINVDOTS	12
+#define BACK_MARBLES		13
+#define BACK_STARRYNIGHT	14
+#define BACK_DIAGTHICK		15
+#define BACK_DIAGTHIN		16
+#define BACK_DIAGDOUBLE		17
+#define BACK_DIAGDOUBLENARROW 18
+#define BACK_DIAGTRIPLE		19
+#define BACK_DIAGSINGLEWIDE	20
+#define BACK_DIAGTHICKINV	21
+#define BACK_DIAGTHININV	22
+#define BACK_DIAGDOUBLEINV	23
+#define BACK_DIAGDOUBLENARROWINV 24
+#define BACK_DIAGTRIPLEINV		25
+#define BACK_DIAGSINGLEWIDEINV	26
+#define BACK_CHAINLINKSMALLINV	27
+#define BACK_CHAINLINKSMALL		28
+#define BACK_CHAINLINKMEDIUM	29
+#define BACK_CHAINLINKLARGE		30
+#define BACK_HORZSTRIPE1		31
+#define BACK_HORZSTRIPE2		32
+#define BACK_HORZSTRIPE3		33
+#define BACK_HORZSTRIPE4		34
+#define BACK_VERTSTRIPE1		35
+#define BACK_VERTSTRIPE2		36
+#define BACK_VERTSTRIPE3		37
+#define BACK_VERTSTRIPE4		38
+#define BACK_GRIDSMALL			39
+#define BACK_GRIDMEDIUM			40
+#define BACK_GRIDLARGE			41
+#define BACK_BOXDOT				42
+#define BACK_GOLFGREEN			43
+#define BACK_DITZ				44
+#define BACK_HORZWEAVE			45
+#define BACK_APPLEPIE			46
+#define BACK_BRICK				47
+#define BACK_DIAGBRICK			48
+#define BACK_CHECKER1			49
+#define BACK_CHECKER2			50
+#define BACK_CHECKER3			51
+#define BACK_CHECKER4			52
+#define BACK_CHECKER5			53
+#define BACK_SNOWFLAKE			54
+#define BACK_MARGARITA			55
+#define BACK_SIDEHARP			56
+#define BACK_SCALES				57
+#define BACK_TAYLOR				58
+#define BACK_BUBBLES			59
+#define BACK_ARGYLE				60
+#define BACK_INDIAN1			61
+#define BACK_INDIAN3			62
+#define BACK_PEACHPIE			63
+#define BACK_GRADIENT1			64
+#define BACK_GRADIENT2			65
+#define BACK_GRADIENT3			66
+#define BACK_GRADIENT4			67
+#define BACK_GRADIENT5			68
+#define BACK_GRADIENT6			69
+#define BACK_GRADIENT7			70
+#define BACK_GRADIENT8			71
+
+class XFBGImage;
+class LwpBackgroundStuff
+{
+public:
+	LwpBackgroundStuff()
+	{
+		m_nID = 0;
+	}
+
+private:
+	void GetPattern(sal_uInt16 btPttnIndex, sal_uInt8* pPttnArray);
+	
+public:
+	void	Read(LwpObjectStream *pStrm);
+	LwpColor* GetFillColor();
+	XFBGImage* GetFillPattern();
+	
+	inline sal_Bool IsTransparent() {return (m_nID == BACK_TRANSPARENT);}
+	inline sal_Bool IsPatternFill() { return (sal_Bool)(m_nID > 2 && m_nID < 72); }
+	
+	friend class LwpBackgroundOverride;
+private:
+	sal_uInt16	m_nID;
+	LwpColor	m_aFillColor;
+	LwpColor	m_aPatternColor;
+};
+
+#endif
+
diff -urNp lotuswordpro.bak/source/filter/lwpbasetype.cxx lotuswordpro/source/filter/lwpbasetype.cxx
--- lotuswordpro.bak/source/filter/lwpbasetype.cxx	1970-01-01 08:00:00.000000000 +0800
+++ lotuswordpro/source/filter/lwpbasetype.cxx	2008-10-22 11:42:29.000000000 +0800
@@ -0,0 +1,93 @@
+/*************************************************************************
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: IBM Corporation
+ *
+ *  Copyright: 2008 by IBM Corporation
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+#include "lwpbasetype.hxx"
+/**
+ * @descr		read PonoseNumber from object stream
+*/
+void LwpPanoseNumber::Read(LwpObjectStream *pStrm)
+{
+	pStrm->QuickRead(&m_nFamilyType, sizeof(m_nFamilyType));
+	pStrm->QuickRead(&m_nSerifStyle, sizeof(m_nSerifStyle));
+	pStrm->QuickRead(&m_nWeight, sizeof(m_nWeight));	
+	pStrm->QuickRead(&m_nProportion, sizeof(m_nProportion));
+	pStrm->QuickRead(&m_nContrast, sizeof(m_nContrast));
+	pStrm->QuickRead(&m_nStrokeVariation, sizeof(m_nStrokeVariation));	
+	pStrm->QuickRead(&m_nArmStyle, sizeof(m_nArmStyle));
+	pStrm->QuickRead(&m_nLetterform, sizeof(m_nLetterform));
+	pStrm->QuickRead(&m_nMidline, sizeof(m_nMidline));	
+	pStrm->QuickRead(&m_nXHeight, sizeof(m_nXHeight));
+
+}
+LwpPoint::LwpPoint()
+{
+	Reset();
+}
+/**
+ * @descr		read point from object stream
+*/
+void LwpPoint::Read(LwpObjectStream *pStrm)
+{
+	pStrm->QuickRead(&m_nX, sizeof(m_nX));
+	pStrm->QuickRead(&m_nY, sizeof(m_nY));
+}
+/**
+ * @descr		reset to zero
+*/
+void LwpPoint::Reset()
+{
+	m_nX=0L;
+	m_nY=0L;
+}
+
diff -urNp lotuswordpro.bak/source/filter/lwpbasetype.hxx lotuswordpro/source/filter/lwpbasetype.hxx
--- lotuswordpro.bak/source/filter/lwpbasetype.hxx	1970-01-01 08:00:00.000000000 +0800
+++ lotuswordpro/source/filter/lwpbasetype.hxx	2008-10-22 11:42:29.000000000 +0800
@@ -0,0 +1,117 @@
+/*************************************************************************
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: IBM Corporation
+ *
+ *  Copyright: 2008 by IBM Corporation
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+/*************************************************************************
+ * @file 
+ *  basic classes for Word Pro filter, 
+ *  PanoseNumber, Point
+ ************************************************************************/
+/*************************************************************************
+ * Change History
+ Jan 2005			Created
+ ************************************************************************/
+
+ 
+#ifndef _LWPBASETYPE_HXX
+#define _LWPBASETYPE_HXX
+
+#include "lwpobjstrm.hxx"
+#include "lwpheader.hxx"
+
+/**
+ * @brief	used for lwpfont for font description
+*/
+class LwpPanoseNumber
+{
+public:
+	LwpPanoseNumber(){};
+	~LwpPanoseNumber(){};
+public:
+	void Read(LwpObjectStream *pStrm);
+private:
+	sal_uInt8 m_nFamilyType;
+	sal_uInt8 m_nSerifStyle;
+   	sal_uInt8 m_nWeight;
+   	sal_uInt8 m_nProportion;
+   	sal_uInt8 m_nContrast;
+   	sal_uInt8 m_nStrokeVariation;
+   	sal_uInt8 m_nArmStyle;
+   	sal_uInt8 m_nLetterform;
+   	sal_uInt8 m_nMidline;
+   	sal_uInt8 m_nXHeight;
+};
+/**
+ * @brief	point class
+*/
+class LwpPoint
+{
+public:
+	LwpPoint();
+	void Read(LwpObjectStream *pStrm);
+	void Reset();
+	inline const sal_Int32 GetX();
+	inline const sal_Int32 GetY();
+	inline void SetX(sal_Int32 nX);
+	inline void SetY(sal_Int32 nY);
+protected:
+	sal_Int32 m_nX;
+	sal_Int32 m_nY;
+};
+
+const sal_Int32 LwpPoint::GetX(){return m_nX;}
+const sal_Int32 LwpPoint::GetY(){return m_nY;}
+void LwpPoint::SetX(sal_Int32 nX){m_nX = nX;}
+void LwpPoint::SetY(sal_Int32 nY){m_nY = nY;}
+
+#endif
diff -urNp lotuswordpro.bak/source/filter/lwpbookmarkmgr.cxx lotuswordpro/source/filter/lwpbookmarkmgr.cxx
--- lotuswordpro.bak/source/filter/lwpbookmarkmgr.cxx	1970-01-01 08:00:00.000000000 +0800
+++ lotuswordpro/source/filter/lwpbookmarkmgr.cxx	2008-10-22 11:42:29.000000000 +0800
@@ -0,0 +1,112 @@
+/*************************************************************************
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: IBM Corporation
+ *
+ *  Copyright: 2008 by IBM Corporation
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+#include "lwpbookmarkmgr.hxx"
+
+void LwpBookmarkMgr::AddXFBookmarkStart(OUString sName,XFBookmarkStart* pMark)
+{
+	std::map<OUString,XFBookmarkStart*>::iterator iter;
+	iter = m_MapStart.find(sName);
+	if (iter == m_MapStart.end())//not find
+	{
+		m_MapStart[sName] = pMark;
+	}
+	else //have exist the same bookmark name
+	{
+		XFBookmarkStart* pFind = iter->second;
+		OUString totalName = pFind->GetDivision() + A2OUSTR(":");
+		totalName += pFind->GetName();
+		pFind->SetName(totalName);
+		m_MapStart[totalName] = pFind;
+		m_MapStart[sName] = pMark;
+	}
+}
+void LwpBookmarkMgr::AddXFBookmarkEnd(OUString sName,XFBookmarkEnd* pMark)
+{
+	std::map<OUString,XFBookmarkEnd*>::iterator iter;
+	iter = m_MapEnd.find(sName);
+	if (iter == m_MapEnd.end())//not find
+	{
+		m_MapEnd[sName] = pMark;
+	}
+	else //have exist the same bookmark name
+	{
+		XFBookmarkEnd* pFind = iter->second;
+		OUString totalName = pFind->GetDivision() + A2OUSTR(":");
+		totalName += pFind->GetName();
+		pFind->SetName(totalName);
+		m_MapEnd[totalName] = pFind;
+		m_MapEnd[sName] = pMark;
+	}
+}
+sal_Bool LwpBookmarkMgr::FindBookmark(OUString sName)
+{
+	std::map<OUString,XFBookmarkStart*>::iterator iter;
+	iter = m_MapStart.find(sName);
+	if (iter != m_MapStart.end())
+		return sal_True;
+	else 
+		return sal_False;
+}
+
+LwpBookmarkMgr::LwpBookmarkMgr()
+{
+	m_MapStart.clear();
+	m_MapEnd.clear();
+}
+LwpBookmarkMgr::~LwpBookmarkMgr()
+{
+	m_MapStart.clear();
+	m_MapEnd.clear();
+}
diff -urNp lotuswordpro.bak/source/filter/lwpbookmarkmgr.hxx lotuswordpro/source/filter/lwpbookmarkmgr.hxx
--- lotuswordpro.bak/source/filter/lwpbookmarkmgr.hxx	1970-01-01 08:00:00.000000000 +0800
+++ lotuswordpro/source/filter/lwpbookmarkmgr.hxx	2008-10-22 11:42:29.000000000 +0800
@@ -0,0 +1,84 @@
+/*************************************************************************
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: IBM Corporation
+ *
+ *  Copyright: 2008 by IBM Corporation
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+/*************************************************************************
+ * @file 
+ *  For LWP filter architecture prototype
+ ************************************************************************/
+/*************************************************************************
+ * Change History
+ May 2005			Created
+ ************************************************************************/
+#ifndef _LWPBOOKMARKMGR_HXX_
+#define _LWPBOOKMARKMGR_HXX_
+
+#include "lwpfilehdr.hxx"
+#include <map>
+
+#include "xfilter/xfbookmark.hxx"
+
+class LwpBookmarkMgr
+{
+public:	
+	void AddXFBookmarkEnd(OUString sName,XFBookmarkEnd* pMark);
+	void AddXFBookmarkStart(OUString sName,XFBookmarkStart* pMark);
+	sal_Bool FindBookmark(OUString sName);
+	~LwpBookmarkMgr();
+	LwpBookmarkMgr();
+private:
+	std::map<OUString,XFBookmarkStart*> m_MapStart;
+	std::map<OUString,XFBookmarkEnd*> m_MapEnd;
+};
+
+#endif
\ No newline at end of file
diff -urNp lotuswordpro.bak/source/filter/lwpborderstuff.cxx lotuswordpro/source/filter/lwpborderstuff.cxx
--- lotuswordpro.bak/source/filter/lwpborderstuff.cxx	1970-01-01 08:00:00.000000000 +0800
+++ lotuswordpro/source/filter/lwpborderstuff.cxx	2008-10-22 11:42:29.000000000 +0800
@@ -0,0 +1,247 @@
+/*************************************************************************
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: IBM Corporation
+ *
+ *  Copyright: 2008 by IBM Corporation
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+/*************************************************************************
+* @file 
+* Border stuff of Wordpro.
+************************************************************************/
+/*************************************************************************
+* Change History
+* 2005-01-11  Create and implement.
+* 2005-01-17  Add Get** functions.
+************************************************************************/
+#include	"lwpborderstuff.hxx"
+#include	"lwpstyledef.hxx"
+#include	"lwpfilehdr.hxx"
+#include	"lwptools.hxx"
+
+LwpBorderStuff::LwpBorderStuff()
+{
+	m_nSides = 0;
+	m_nValid = 0;
+
+	m_nBoderGroupIDLeft = 0;
+	m_nBoderGroupIDRight = 0;
+	m_nBoderGroupIDTop = 0;
+	m_nBoderGroupIDBottom = 0;
+	
+	m_nGroupIndent = 0;
+	
+	m_nWidthLeft = 0;
+	m_nWidthTop = 0;
+	m_nWidthRight = 0;
+	m_nWidthBottom = 0;
+}
+
+void	LwpBorderStuff::Read(LwpObjectStream *pStrm)
+{
+	pStrm->QuickRead(&m_nSides, sizeof(m_nSides) );
+	if( m_nSides&LEFT )
+	{
+		pStrm->QuickRead(&m_nBoderGroupIDLeft, sizeof(m_nBoderGroupIDLeft));
+		pStrm->QuickRead(&m_nWidthLeft, sizeof(m_nWidthLeft));
+		m_aColorLeft.Read(pStrm);
+		
+		if( LwpFileHeader::m_nFileRevision < 0x000b )
+		{
+			pStrm->SeekRel(8);
+		}
+	}
+	
+	if( m_nSides&RIGHT )
+	{
+		pStrm->QuickRead(&m_nBoderGroupIDRight, sizeof(m_nBoderGroupIDRight));
+		pStrm->QuickRead(&m_nWidthRight, sizeof(m_nWidthRight));
+		m_aColorRight.Read(pStrm);
+		
+		if( LwpFileHeader::m_nFileRevision < 0x000b )
+		{
+			pStrm->SeekRel(8);
+		}
+	}
+	
+	if( m_nSides&TOP )
+	{
+		pStrm->QuickRead(&m_nBoderGroupIDTop, sizeof(m_nBoderGroupIDTop));
+		pStrm->QuickRead(&m_nWidthTop, sizeof(m_nWidthTop));
+		m_aColorTop.Read(pStrm);
+		
+		if( LwpFileHeader::m_nFileRevision < 0x000b )
+		{
+			pStrm->SeekRel(8);
+		}
+	}
+	
+	if( m_nSides&BOTTOM )
+	{
+		pStrm->QuickRead(&m_nBoderGroupIDBottom, sizeof(m_nBoderGroupIDBottom));
+		pStrm->QuickRead(&m_nWidthBottom, sizeof(m_nWidthBottom));
+		m_aColorBottom.Read(pStrm);
+		
+		if( LwpFileHeader::m_nFileRevision < 0x000b )
+		{
+			pStrm->SeekRel(8);
+		}
+	}
+	
+	pStrm->QuickRead( &m_nGroupIndent, sizeof(m_nGroupIndent) );
+	pStrm->QuickRead( &m_nValid, sizeof(m_nValid) );
+	pStrm->SkipExtra();
+	
+	if( LwpFileHeader::m_nFileRevision < 0x0010 )
+	{
+		if( m_nBoderGroupIDLeft&EXTERNAL_ID )
+		{
+			m_nBoderGroupIDLeft = BGRP_SOLID;
+		}
+		if( m_nBoderGroupIDRight&EXTERNAL_ID )
+		{
+			m_nBoderGroupIDRight = BGRP_SOLID;
+		}
+		if( m_nBoderGroupIDTop&EXTERNAL_ID )
+		{
+			m_nBoderGroupIDTop = BGRP_SOLID;
+		}
+		if( m_nBoderGroupIDBottom&EXTERNAL_ID )
+		{
+			m_nBoderGroupIDBottom = BGRP_SOLID;
+		}
+	}
+}
+
+sal_Bool	LwpBorderStuff::HasSide(sal_uInt16 side)
+{
+	return m_nSides&side;
+}
+
+sal_uInt16	LwpBorderStuff::GetSideType(sal_uInt16 side)
+{
+	switch(side)
+	{
+	case LEFT:
+		return m_nBoderGroupIDLeft;
+		break;
+	case RIGHT:
+		return m_nBoderGroupIDRight;
+		break;
+	case TOP:
+		return m_nBoderGroupIDTop;
+		break;
+	case BOTTOM:
+		return m_nBoderGroupIDBottom;
+		break;
+	}
+}
+
+LwpColor	LwpBorderStuff::GetSideColor(sal_uInt16 side)
+{
+	switch(side)
+	{
+	case LEFT:
+		return m_aColorLeft;
+		break;
+	case RIGHT:
+		return m_aColorRight;
+		break;
+	case TOP:
+		return m_aColorTop;
+		break;
+	case BOTTOM:
+		return m_aColorBottom;
+		break;
+	}
+}
+
+float	LwpBorderStuff::GetSideWidth(sal_uInt16 side)
+{
+	switch(side)
+	{
+	case LEFT:
+		return LwpTools::ConvertToMetric(LwpTools::ConvertFromUnits(m_nWidthLeft));
+		break;
+	case RIGHT:
+		return LwpTools::ConvertToMetric(LwpTools::ConvertFromUnits(m_nWidthRight));
+		break;
+	case TOP:
+		return LwpTools::ConvertToMetric(LwpTools::ConvertFromUnits(m_nWidthTop));
+		break;
+	case BOTTOM:
+		return LwpTools::ConvertToMetric(LwpTools::ConvertFromUnits(m_nWidthBottom));
+		break;
+	}
+}
+
+void LwpBorderStuff::operator = (const LwpBorderStuff& rOther)
+{
+	m_nSides = rOther.m_nSides;
+	m_nValid = rOther.m_nValid;
+
+	m_nBoderGroupIDLeft = rOther.m_nBoderGroupIDLeft;
+	m_nBoderGroupIDRight = rOther.m_nBoderGroupIDRight;
+	m_nBoderGroupIDTop = rOther.m_nBoderGroupIDTop;
+	m_nBoderGroupIDBottom = rOther.m_nBoderGroupIDBottom;
+
+	m_nGroupIndent = rOther.m_nGroupIndent;
+
+	m_nWidthLeft = rOther.m_nWidthLeft;
+	m_nWidthTop = rOther.m_nWidthTop;
+	m_nWidthRight = rOther.m_nWidthRight;
+	m_nWidthBottom = rOther.m_nWidthBottom;
+
+	m_aColorLeft = rOther.m_aColorLeft;
+	m_aColorRight = rOther.m_aColorRight;
+	m_aColorTop = rOther.m_aColorTop;
+	m_aColorBottom = rOther.m_aColorBottom;
+}
+
diff -urNp lotuswordpro.bak/source/filter/lwpborderstuff.hxx lotuswordpro/source/filter/lwpborderstuff.hxx
--- lotuswordpro.bak/source/filter/lwpborderstuff.hxx	1970-01-01 08:00:00.000000000 +0800
+++ lotuswordpro/source/filter/lwpborderstuff.hxx	2008-10-22 11:42:29.000000000 +0800
@@ -0,0 +1,119 @@
+/*************************************************************************
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: IBM Corporation
+ *
+ *  Copyright: 2008 by IBM Corporation
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+/*************************************************************************
+* @file 
+* Border stuff of Wordpro.
+************************************************************************/
+/*************************************************************************
+* Change History
+* 2005-01-11 Create and implement.
+************************************************************************/
+#ifndef		_LWPBORDERSTUFF_HXX
+#define		_LWPBORDERSTUFF_HXX
+
+#include	"lwpcolor.hxx"
+
+class LwpBorderStuff
+{
+public:
+	LwpBorderStuff();
+	
+	enum BorderType
+	{
+		NOSIDE = 0,
+		LEFT = 1,
+		RIGHT = 2,
+		TOP = 4,
+		BOTTOM = 8,
+		ALLSIDE = 15,
+		TEMPORARY = 0xff00
+	};
+
+public:
+	void	Read(LwpObjectStream *pStrm);
+
+	sal_uInt16	GetSide(){ return m_nSides; }
+	sal_Bool	HasSide(sal_uInt16 side);
+	sal_uInt16	GetSideType(sal_uInt16 side);
+	LwpColor	GetSideColor(sal_uInt16 side);
+	float		GetSideWidth(sal_uInt16 side);
+	//add by , 01/26/2004
+	void operator = (const LwpBorderStuff& rOther);
+	//end
+	friend class LwpParaBorderOverride;
+private:
+	sal_uInt16		m_nSides;
+	sal_uInt16		m_nValid;
+
+	sal_uInt16		m_nBoderGroupIDLeft;
+	sal_uInt16		m_nBoderGroupIDRight;
+	sal_uInt16		m_nBoderGroupIDTop;
+	sal_uInt16		m_nBoderGroupIDBottom;
+
+	sal_Int32		m_nGroupIndent;
+
+	sal_Int32		m_nWidthLeft;
+	sal_Int32		m_nWidthTop;
+	sal_Int32		m_nWidthRight;
+	sal_Int32		m_nWidthBottom;
+
+	LwpColor		m_aColorLeft;
+	LwpColor		m_aColorRight;
+	LwpColor		m_aColorTop;
+	LwpColor		m_aColorBottom;
+
+};
+
+#endif
diff -urNp lotuswordpro.bak/source/filter/lwpbreaksoverride.cxx lotuswordpro/source/filter/lwpbreaksoverride.cxx
--- lotuswordpro.bak/source/filter/lwpbreaksoverride.cxx	1970-01-01 08:00:00.000000000 +0800
+++ lotuswordpro/source/filter/lwpbreaksoverride.cxx	2008-10-22 11:42:29.000000000 +0800
@@ -0,0 +1,280 @@
+/*************************************************************************
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: IBM Corporation
+ *
+ *  Copyright: 2008 by IBM Corporation
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+/*************************************************************************
+* @file 
+* Breaks override of Wordpro.
+************************************************************************/
+/*************************************************************************
+* Change History
+* 2005-01-12 Create and implement.
+************************************************************************/
+#include	"lwpbreaksoverride.hxx"
+#include	"lwpobjstrm.hxx"
+#include	"lwpatomholder.hxx"
+
+
+LwpBreaksOverride::LwpBreaksOverride()
+{
+	m_pNextStyle = new LwpAtomHolder();
+}
+
+LwpBreaksOverride::~LwpBreaksOverride()
+{
+	if( m_pNextStyle )
+		delete m_pNextStyle;
+}
+
+void	LwpBreaksOverride::Read(LwpObjectStream *pStrm)
+{
+	if (pStrm->QuickReadBool())
+	{
+		ReadCommon(pStrm);
+		
+		m_pNextStyle->Read(pStrm);
+	}
+	
+	pStrm->SkipExtra();
+}
+
+//add by , 01/28/2005
+void LwpBreaksOverride::Override(LwpBreaksOverride* pOther)
+{
+	if (m_nApply & BO_PAGEBEFORE)
+	{
+		if (IsPageBreakBeforeOverridden())
+		{
+			pOther->OverridePageBreakBefore(IsPageBreakBefore());
+		}
+		else
+		{
+			pOther->RevertPageBreakBefore();
+		}
+	}
+	if (m_nApply & BO_PAGEAFTER)
+	{
+		if (IsPageBreakAfterOverridden())
+		{
+			pOther->OverridePageBreakAfter(IsPageBreakAfter());
+		}
+		else
+		{
+			pOther->RevertPageBreakAfter();
+		}
+	}
+	if (m_nApply & BO_KEEPTOGETHER)
+	{
+		if (IsPageBreakWithinOverridden())
+		{
+			pOther->OverridePageBreakWithin(IsPageBreakWithin());
+		}
+		else
+		{
+			pOther->RevertPageBreakWithin();
+		}
+	}
+	if (m_nApply & BO_COLBEFORE)
+	{
+		if (IsColumnBreakBeforeOverridden())
+		{
+			pOther->OverrideColumnBreakBefore(IsColumnBreakBefore());
+		}
+		else
+		{
+			pOther->RevertColumnBreakBefore();
+		}
+	}
+	if (m_nApply & BO_COLAFTER)
+	{
+		if (IsColumnBreakAfterOverridden())
+		{
+			pOther->OverrideColumnBreakAfter(IsColumnBreakAfter());
+		}
+		else
+		{
+			pOther->RevertColumnBreakAfter();
+		}
+	}
+	if (m_nApply & BO_KEEPPREV)
+	{
+		if (IsKeepWithPreviousOverridden())
+		{
+			pOther->OverrideKeepWithPrevious(IsKeepWithPrevious());
+		}
+		else
+		{
+			pOther->RevertKeepWithPrevious();
+		}
+	}
+	if (m_nApply & BO_KEEPNEXT)
+	{
+		if (IsKeepWithNextOverridden())
+		{
+			pOther->OverrideKeepWithNext(IsKeepWithNext());
+		}
+		else
+		{
+			pOther->RevertKeepWithNext();
+		}
+	}
+	if (m_nApply & BO_USENEXTSTYLE)
+	{
+		if (IsUseNextStyleOverridden())
+		{
+			pOther->OverrideUseNextStyle(IsUseNextStyle());
+		}
+		else
+		{
+			pOther->RevertUseNextStyle();
+		}
+	}
+}
+
+void LwpBreaksOverride::operator=(const LwpOverride& rOther)
+{
+	LwpOverride::operator=(rOther);
+
+	// copy m_pNextStyle...
+}
+
+void LwpBreaksOverride::OverridePageBreakBefore(sal_Bool bVal)
+{
+	if(bVal)
+	{
+		LwpOverride::Override(BO_PAGEBEFORE, STATE_ON);
+	}
+	else
+	{
+		LwpOverride::Override(BO_PAGEBEFORE, STATE_OFF);
+	}
+}
+void LwpBreaksOverride::OverridePageBreakAfter(sal_Bool bVal)
+{
+	if(bVal)
+	{
+		LwpOverride::Override(BO_PAGEAFTER, STATE_ON);
+	}
+	else
+	{
+		LwpOverride::Override(BO_PAGEAFTER, STATE_OFF);
+	}
+}
+void LwpBreaksOverride::OverridePageBreakWithin(sal_Bool bVal)
+{
+	// Note the flipped logic
+	if(!bVal)
+	{
+		LwpOverride::Override(BO_KEEPTOGETHER, STATE_ON);
+	}
+	else
+	{
+		LwpOverride::Override(BO_KEEPTOGETHER, STATE_OFF);
+	}
+}
+void LwpBreaksOverride::OverrideColumnBreakBefore(sal_Bool bVal)
+{
+	if(bVal)
+	{
+		LwpOverride::Override(BO_COLBEFORE, STATE_ON);
+	}
+	else
+	{
+		LwpOverride::Override(BO_COLBEFORE, STATE_OFF);
+	}
+}
+void LwpBreaksOverride::OverrideColumnBreakAfter(sal_Bool bVal)
+{
+	if(bVal)
+	{
+		LwpOverride::Override(BO_COLAFTER, STATE_ON);
+	}
+	else
+	{
+		LwpOverride::Override(BO_COLAFTER, STATE_OFF);
+	}
+}
+void LwpBreaksOverride::OverrideKeepWithNext(sal_Bool bVal)
+{
+	if(bVal)
+	{
+		LwpOverride::Override(BO_KEEPNEXT, STATE_ON);
+	}
+	else
+	{
+		LwpOverride::Override(BO_KEEPNEXT, STATE_OFF);
+	}
+}
+void LwpBreaksOverride::OverrideKeepWithPrevious(sal_Bool bVal)
+{
+	if(bVal)
+	{
+		LwpOverride::Override(BO_KEEPPREV, STATE_ON);
+	}
+	else
+	{
+		LwpOverride::Override(BO_KEEPPREV, STATE_OFF);
+	}
+}
+void LwpBreaksOverride::OverrideUseNextStyle(sal_Bool bVal)
+{
+	if(bVal)
+	{
+		LwpOverride::Override(BO_USENEXTSTYLE, STATE_ON);
+	}
+	else
+	{
+		LwpOverride::Override(BO_USENEXTSTYLE, STATE_OFF);
+	}
+}
+//end add
diff -urNp lotuswordpro.bak/source/filter/lwpbreaksoverride.hxx lotuswordpro/source/filter/lwpbreaksoverride.hxx
--- lotuswordpro.bak/source/filter/lwpbreaksoverride.hxx	1970-01-01 08:00:00.000000000 +0800
+++ lotuswordpro/source/filter/lwpbreaksoverride.hxx	2008-10-22 11:42:29.000000000 +0800
@@ -0,0 +1,248 @@
+/*************************************************************************
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: IBM Corporation
+ *
+ *  Copyright: 2008 by IBM Corporation
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+/*************************************************************************
+* @file 
+* Breaks override of Wordpro.
+************************************************************************/
+/*************************************************************************
+* Change History
+* 2005-01-12 Create and implement.
+************************************************************************/
+#ifndef		_LWPBREAKSOVERRIDE_HXX
+#define		_LWPBREAKSOVERRIDE_HXX
+
+#include	"lwpoverride.hxx"
+
+class LwpObjectStream;
+class LwpAtomHolder;
+class LwpBreaksOverride : public LwpOverride
+{
+
+public:
+	LwpBreaksOverride();
+	virtual ~LwpBreaksOverride();
+
+	enum
+	{
+		BO_PAGEBEFORE	= 0x01,	// page break before this style
+		BO_PAGEAFTER	= 0x02,	// page break after this style
+		BO_KEEPTOGETHER	= 0x04,
+		BO_COLBEFORE	= 0x08,	// col break before this style
+		BO_COLAFTER		= 0x10,	// col break after this style
+		BO_KEEPPREV		= 0x20,	// not with-PAGE BEF, COL BEF or WITHIN
+		BO_KEEPNEXT		= 0x40,	// not with-PAGE AFT, COL AFT or WITHIN
+		BO_USENEXTSTYLE	= 0x80,	// use next style name
+		BO_NEXTSTYLE	= 0x100	// next style name
+	};
+public:
+	virtual void Read(LwpObjectStream *pStrm);
+
+	//add by , 01/28/2005
+	void Override(LwpBreaksOverride* pOther);
+
+	void operator=(const LwpOverride& rOther);
+	
+	inline sal_Bool IsPageBreakBefore();
+	inline sal_Bool IsPageBreakAfter();
+	inline sal_Bool IsPageBreakWithin();
+	inline sal_Bool IsColumnBreakBefore();
+	inline sal_Bool IsColumnBreakAfter();
+	inline sal_Bool IsKeepWithNext();
+	inline sal_Bool IsKeepWithPrevious();
+	inline sal_Bool IsUseNextStyle();
+
+	inline sal_Bool IsPageBreakBeforeOverridden();
+	inline sal_Bool IsPageBreakAfterOverridden();
+	inline sal_Bool IsPageBreakWithinOverridden();
+	inline sal_Bool IsColumnBreakBeforeOverridden();
+	inline sal_Bool IsColumnBreakAfterOverridden();
+	inline sal_Bool IsKeepWithNextOverridden();
+	inline sal_Bool IsKeepWithPreviousOverridden();
+	inline sal_Bool IsUseNextStyleOverridden();
+
+	inline void RevertPageBreakBefore();
+	inline void RevertPageBreakAfter();
+	inline void RevertPageBreakWithin();
+	inline void RevertColumnBreakBefore();
+	inline void RevertColumnBreakAfter();
+	inline void RevertKeepWithNext();
+	inline void RevertKeepWithPrevious();
+	inline void RevertUseNextStyle();
+
+
+	void OverridePageBreakBefore(sal_Bool bVal);
+	void OverridePageBreakAfter(sal_Bool bVal);
+	void OverridePageBreakWithin(sal_Bool bVal);
+	void OverrideColumnBreakBefore(sal_Bool bVal);
+	void OverrideColumnBreakAfter(sal_Bool bVal);
+	void OverrideKeepWithNext(sal_Bool bVal);
+	void OverrideKeepWithPrevious(sal_Bool bVal);
+	void OverrideUseNextStyle(sal_Bool bVal);
+	
+	
+	inline LwpAtomHolder* GetNextStyle();
+	//end add
+	
+private:
+	LwpAtomHolder		*m_pNextStyle;
+};
+
+inline sal_Bool LwpBreaksOverride::IsPageBreakBefore()
+{
+	return (sal_Bool)((m_nValues & BO_PAGEBEFORE) != 0);
+}
+
+inline sal_Bool LwpBreaksOverride::IsPageBreakAfter()
+{
+	return (sal_Bool)((m_nValues & BO_PAGEAFTER) != 0);
+}
+inline sal_Bool LwpBreaksOverride::IsPageBreakWithin()
+{
+	return (sal_Bool)((m_nValues & BO_KEEPTOGETHER) != 0);
+}
+inline sal_Bool LwpBreaksOverride::IsColumnBreakBefore()
+{
+	return (sal_Bool)((m_nValues & BO_COLBEFORE) != 0);
+}
+inline sal_Bool LwpBreaksOverride::IsColumnBreakAfter()
+{
+	return (sal_Bool)((m_nValues & BO_COLAFTER) != 0);
+}
+inline sal_Bool LwpBreaksOverride::IsKeepWithNext()
+{
+	return (sal_Bool)((m_nValues & BO_KEEPNEXT) != 0);
+}
+inline sal_Bool LwpBreaksOverride::IsKeepWithPrevious()
+{
+	return (sal_Bool)((m_nValues & BO_KEEPPREV) != 0);
+}
+inline sal_Bool LwpBreaksOverride::IsUseNextStyle()
+{
+	return (sal_Bool)((m_nValues & BO_USENEXTSTYLE) != 0);
+}
+
+inline sal_Bool LwpBreaksOverride::IsPageBreakBeforeOverridden()
+{
+	return (sal_Bool)((m_nOverride& BO_PAGEBEFORE) != 0);
+}
+inline sal_Bool LwpBreaksOverride::IsPageBreakAfterOverridden()
+{
+	return (sal_Bool)((m_nOverride& BO_PAGEAFTER) != 0);
+}
+inline sal_Bool LwpBreaksOverride::IsPageBreakWithinOverridden()
+{
+	return (sal_Bool)((m_nOverride& BO_KEEPTOGETHER) != 0);
+}
+inline sal_Bool LwpBreaksOverride::IsColumnBreakBeforeOverridden()
+{
+	return (sal_Bool)((m_nOverride& BO_COLBEFORE) != 0);
+}
+inline sal_Bool LwpBreaksOverride::IsColumnBreakAfterOverridden()
+{
+	return (sal_Bool)((m_nOverride& BO_COLAFTER) != 0);
+}
+inline sal_Bool LwpBreaksOverride::IsKeepWithNextOverridden()
+{
+	return (sal_Bool)((m_nOverride& BO_KEEPNEXT) != 0);
+}
+inline sal_Bool LwpBreaksOverride::IsKeepWithPreviousOverridden()
+{
+	return (sal_Bool)((m_nOverride& BO_KEEPPREV) != 0);
+}
+inline sal_Bool LwpBreaksOverride::IsUseNextStyleOverridden()
+{
+	return (sal_Bool)((m_nOverride& BO_USENEXTSTYLE) != 0);
+}
+
+inline void LwpBreaksOverride::RevertPageBreakBefore()
+{
+	LwpOverride::Override(BO_PAGEBEFORE, STATE_STYLE);
+}
+inline void LwpBreaksOverride::RevertPageBreakAfter()
+{
+	LwpOverride::Override(BO_PAGEAFTER, STATE_STYLE);
+}
+inline void LwpBreaksOverride::RevertPageBreakWithin()
+{
+	LwpOverride::Override(BO_KEEPTOGETHER, STATE_STYLE);
+}
+inline void LwpBreaksOverride::RevertColumnBreakBefore()
+{
+	LwpOverride::Override(BO_COLBEFORE, STATE_STYLE);
+}
+inline void LwpBreaksOverride::RevertColumnBreakAfter()
+{
+	LwpOverride::Override(BO_COLAFTER, STATE_STYLE);
+}
+inline void LwpBreaksOverride::RevertKeepWithNext()
+{
+	LwpOverride::Override(BO_KEEPNEXT, STATE_STYLE);
+}
+inline void LwpBreaksOverride::RevertKeepWithPrevious()
+{
+	LwpOverride::Override(BO_KEEPPREV, STATE_STYLE);
+}
+inline void LwpBreaksOverride::RevertUseNextStyle()
+{
+	LwpOverride::Override(BO_USENEXTSTYLE, STATE_STYLE);
+}
+
+inline LwpAtomHolder* LwpBreaksOverride::GetNextStyle()
+{
+	return m_pNextStyle;
+}
+
+
+#endif
diff -urNp lotuswordpro.bak/source/filter/lwpbulletstylemgr.cxx lotuswordpro/source/filter/lwpbulletstylemgr.cxx
--- lotuswordpro.bak/source/filter/lwpbulletstylemgr.cxx	1970-01-01 08:00:00.000000000 +0800
+++ lotuswordpro/source/filter/lwpbulletstylemgr.cxx	2008-10-22 11:42:29.000000000 +0800
@@ -0,0 +1,590 @@
+/*************************************************************************
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: IBM Corporation
+ *
+ *  Copyright: 2008 by IBM Corporation
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+/*************************************************************************
+ * @file 
+ *  For LWP filter architecture prototype
+ ************************************************************************/
+/*************************************************************************
+ * Change History
+ Jan 2005			Created
+ ************************************************************************/
+#include "lwpbulletstylemgr.hxx"
+#include "lwpdoc.hxx"
+#include "lwpstory.hxx"
+#include "lwpdivinfo.hxx"
+#include "lwppara.hxx"
+#include "lwpsilverbullet.hxx"
+#include "lwptools.hxx"
+#include "lwpparaproperty.hxx"
+#include "xfilter/xfliststyle.hxx"
+#include "xfilter/xfstylemanager.hxx"
+#include "xfilter/xflist.hxx"
+#include "lwpglobalmgr.hxx"
+
+LwpBulletStyleMgr::LwpBulletStyleMgr() :
+m_pBulletList(NULL), m_bContinue(sal_True), m_bIsBulletSkipped(sal_False), m_nCurrentPos(0xFF)
+{
+}
+
+LwpBulletStyleMgr::~LwpBulletStyleMgr()
+{
+	if (m_pBulletList)
+	{
+		delete m_pBulletList;
+	}
+
+	m_vIDsPairList.clear();
+	m_vStyleNameList.clear();
+}
+
+/**
+ * @short   Register bullet style to style-list. The function only register the bullet and single customized numbering
+ *		not inluding the numbering sequence.
+ * @param   pPara pointer to the current paragraph which has a bullet/numbering.
+ * @param   pBullOver pointer to the bulletoverride of current paragraph.
+ * @param   pIndent pointer to the indentoverride of current paragraph.
+ */
+rtl::OUString LwpBulletStyleMgr::RegisterBulletStyle(LwpPara* pPara, LwpBulletOverride* pBullOver, 
+	LwpIndentOverride* pIndent)
+{
+	if(!pPara || !pIndent || !pBullOver)
+	{
+//		assert(false);
+		return rtl::OUString::createFromAscii("");
+	}
+
+	LwpSilverBullet* pSilverBullet = pPara->GetSilverBullet();
+	if (!pSilverBullet)
+	{
+		assert(false);
+		return rtl::OUString::createFromAscii("");
+	}
+	
+	LwpPara* pBulletPara = pSilverBullet->GetBulletPara();
+	if (!pBulletPara)
+	{
+		assert(false);
+		return rtl::OUString::createFromAscii("");
+	}
+
+	LwpParaProperty* pProp = pPara->GetProperty(PP_LOCAL_INDENT);
+	LwpParaIndentProperty* pIndentProp = NULL;
+	LwpObjectID aIndentID;
+	if (pProp)
+	{
+		pIndentProp = static_cast<LwpParaIndentProperty*>(pProp);
+		aIndentID = pIndentProp->GetIndentID();
+	}
+	 
+	LwpObjectID aBulletID = pBullOver->GetSilverBullet();
+	LwpBulletOverride aBulletOver = *pBullOver;
+	
+	sal_uInt16 nNameIndex = 0;
+	std::vector <OverridePair>::iterator iter;
+	for(iter = m_vIDsPairList.begin(); iter != m_vIDsPairList.end(); iter++)
+	{
+		if (iter->first.GetSilverBullet() == aBulletID && iter->second == aIndentID
+			&& iter->first.IsRightAligned() == pBullOver->IsRightAligned())
+		{
+			return m_vStyleNameList[nNameIndex];				
+		}
+		else
+		{
+			nNameIndex++;
+		}
+	}
+
+	m_vIDsPairList.push_back(std::make_pair(aBulletOver, aIndentID));
+	rtl::OUString aStyleName;
+	
+	LwpFribPtr* pBulletParaFribs = pBulletPara->GetFribs();
+	sal_Bool bIsNumbering = (sal_Bool)(pBulletParaFribs->HasFrib(FRIB_TAG_PARANUMBER) != 0);
+	
+	enumXFAlignType eAlign = enumXFAlignStart;
+	if (pBullOver->IsRightAligned())
+	{
+		eAlign = enumXFAlignEnd;
+	}
+
+	XFListStyle* pListStyle = new XFListStyle();
+	XFStyleManager* pXFStyleMgr = LwpGlobalMgr::GetInstance()->GetXFStyleManager();
+
+	if (!bIsNumbering)
+	{
+		for (sal_uInt8 nC = 1; nC < 11; nC++)
+		{
+			pListStyle->SetListBullet(nC, pSilverBullet->GetBulletChar(), pSilverBullet->GetBulletFontName(),
+				pSilverBullet->GetPrefix(), pSilverBullet->GetSuffix());
+
+			if (pIndent->GetMRest() > 0.001)
+			{
+				pListStyle->SetListPosition(nC, 0.0, 
+					LwpTools::ConvertToMetric(LwpTools::ConvertFromUnits(pIndent->GetMRest())), 0.0, eAlign);
+			}
+			else
+			{
+				pListStyle->SetListPosition(nC, 0.0, 
+					0.0, LwpTools::ConvertToMetric(LwpTools::ConvertFromUnits(pIndent->GetMFirst())), eAlign);	
+			}
+		}
+
+		aStyleName = pXFStyleMgr->AddStyle(pListStyle)->GetStyleName();
+	}
+	else
+	{
+		rtl::OUString aPrefix = rtl::OUString::createFromAscii("");
+
+		LwpFrib* pFrib = pBulletParaFribs->HasFrib(FRIB_TAG_DOCVAR);
+		LwpFribDocVar* pDocVarFrib = NULL;
+		if (pFrib)
+		{
+			pDocVarFrib = static_cast<LwpFribDocVar*>(pFrib);
+//				ModifierInfo* pInfo = pDocVarFrib->GetModifiers();
+			switch (pDocVarFrib->GetType())
+			{
+			case 0x000D: // division name
+				aPrefix = this->GetDivisionName();
+				break;
+			case 0x000E: // section name
+				aPrefix = this->GetSectionName(pPara);
+				break;
+			}
+		}
+		ParaNumbering aParaNumbering;
+		pBulletPara->GetParaNumber(1, &aParaNumbering);
+		LwpFribParaNumber* pParaNumber = aParaNumbering.pParaNumber;
+		if (pParaNumber)
+		{
+			for (sal_uInt8 nPos = 1; nPos < 10; nPos++)
+			{
+				aPrefix = rtl::OUString::createFromAscii("");
+				if (pParaNumber->GetStyleID() != NUMCHAR_other)
+				{
+					XFNumFmt aFmt;
+					if (aParaNumbering.pPrefix)
+					{
+						aPrefix += aParaNumbering.pPrefix->GetText();
+//							aFmt.SetPrefix(aParaNumbering.pPrefix->GetText() + aAdditionalInfoName);
+					}
+
+					rtl::OUString aNumber = LwpSilverBullet::GetNumCharByStyleID(pParaNumber);
+					if (pParaNumber->GetStyleID() == NUMCHAR_01 || pParaNumber->GetStyleID() == NUMCHAR_Chinese4)
+					{
+						aPrefix += rtl::OUString::createFromAscii("0");
+					}
+					aFmt.SetPrefix(aPrefix);
+					
+					aFmt.SetFormat(aNumber);
+
+					if (aParaNumbering.pSuffix)
+					{
+						aFmt.SetSuffix(aParaNumbering.pSuffix->GetText());
+					}
+
+					//set numbering format into the style-list.
+					pListStyle->SetListNumber(nPos, aFmt, pParaNumber->GetStart()+1);
+					
+				}
+				else
+				{
+					rtl::OUString aPrefix, aSuffix;
+					if (aParaNumbering.pPrefix)
+					{
+						aPrefix = aParaNumbering.pPrefix->GetText();
+					}
+					if (aParaNumbering.pSuffix)
+					{
+						aSuffix = aParaNumbering.pSuffix->GetText();
+					}
+
+					pListStyle->SetListBullet(nPos, LwpSilverBullet::GetNumCharByStyleID(pParaNumber).toChar(), 
+						rtl::OUString::createFromAscii("Times New Roman"), aPrefix, aSuffix);
+				}
+				
+				pListStyle->SetListPosition(nPos, 0.0, 0.635, 0.0);
+			}
+			aStyleName = pXFStyleMgr->AddStyle(pListStyle)->GetStyleName();
+			}
+
+	}
+
+	m_vStyleNameList.push_back(aStyleName);
+	return aStyleName;
+
+}
+
+/**
+ * @short   No use now.
+ * @param   rContent
+ * @param   nFontID
+ * @param   pIndent
+ */
+/*rtl::OUString LwpBulletStyleMgr::RegisterBulletStyle(const rtl::OUString& rContent, sal_uInt32 nFontID, LwpIndentOverride* pIndent)
+{
+	if (!pIndent)
+	{
+		assert(false);
+	}
+
+	if (!m_pFoundry)
+	{
+		return rtl::OUString::createFromAscii("");
+	}
+	LwpFontManager* pFontMgr = m_pFoundry->GetFontManger();
+
+	rtl::OUString aFontName = pFontMgr->GetNameByID(nFontID);
+	UChar32 cBulletChar = rContent.toChar();
+	rtl::OUString aSuffix = rContent.copy(1);
+	XFListStyle* pListStyle = new XFListStyle();
+	XFStyleManager* pXFStyleMgr = XFStyleManager::Instance();
+
+	for (sal_uInt8 nC = 1; nC < 11; nC++)
+	{
+		pListStyle->SetListBullet(nC, cBulletChar, aFontName, rtl::OUString::createFromAscii(""), aSuffix);
+
+		if (pIndent->GetMRest() > 0.001)
+		{
+			pListStyle->SetListPosition(nC, 0.0, 
+				LwpTools::ConvertToMetric(LwpTools::ConvertFromUnits(pIndent->GetMRest())), 0.0);
+		}
+		else
+		{
+			pListStyle->SetListPosition(nC, 0.0, 
+				0.0, LwpTools::ConvertToMetric(LwpTools::ConvertFromUnits(pIndent->GetMFirst())));	
+		}
+	}
+	return pXFStyleMgr->AddStyle(pListStyle);
+}*/
+
+/**
+ * @short   No use now.
+ * @param   pListStyle
+ * @param   pXFStyleMgr
+ */
+/*void LwpBulletStyleMgr::CreateNewListStyle(XFListStyle*& pListStyle, XFStyleManager* pXFStyleMgr)
+{
+	pListStyle = new XFListStyle();
+	m_aBulletStyleList.push_back(pListStyle);
+	m_aCurrentStyleName = pXFStyleMgr->AddStyle(pListStyle);
+}*/
+
+/**
+ * @short   No use now.
+ * @param   pSilverBullet
+ * @param   nLevel
+ */
+/*rtl::OUString LwpBulletStyleMgr::AddStyleToList(LwpSilverBullet* pSilverBullet, sal_uInt16 nLevel)
+{
+	XFListStyle* pListStyle = NULL;
+	XFStyleManager* pXFStyleMgr = XFStyleManager::Instance();
+	
+	if (m_aBulletStyleList.empty())
+	{
+	//	pListStyle = new XFListStyle();
+	//	m_aBulletStyleList.push_back(pListStyle);
+	//	m_aCurrentStyleName = pXFStyleMgr->AddStyle(pListStyle);
+	//	this->CreateNewListStyle(pListStyle, pXFStyleMgr);
+		if (pSilverBullet->IsBulletOrdered())
+		{
+			m_strCurrentNumberingName = pSilverBullet->GetNumberingName();
+		}
+		else
+		{
+			m_nCurrentChar = pSilverBullet->GetBulletChar();
+			m_strCurrentFontName = pSilverBullet->GetBulletFontName();
+		}
+	}
+	else if (nLevel == 1)
+	{
+		if (pSilverBullet->IsBulletOrdered())
+		{
+			if (m_strCurrentNumberingName == pSilverBullet->GetNumberingName())
+			{
+				pListStyle = m_aBulletStyleList.back();
+			}
+			else
+			{
+				this->CreateNewListStyle(pListStyle, pXFStyleMgr);
+			}
+		}
+		else
+		{
+			if ((m_nCurrentChar == pSilverBullet->GetBulletChar()) &&
+				(m_strCurrentFontName == pSilverBullet->GetBulletFontName()))
+			{
+				pListStyle = m_aBulletStyleList.back();
+			}
+			else
+			{
+				this->CreateNewListStyle(pListStyle, pXFStyleMgr);
+			}
+		}
+	}
+	else
+	{
+		pListStyle = m_aBulletStyleList.back();
+	}
+	
+	if (pSilverBullet->IsBulletOrdered())
+	{
+//		pListStyle->SetListNumber(int level, XFNumFmt & fmt, sal_Int16 start);
+	}
+	else
+	{
+		pListStyle->SetListBullet(nLevel, pSilverBullet->GetBulletChar(), pSilverBullet->GetBulletFontName(),
+			pSilverBullet->GetPrefix(), pSilverBullet->GetSuffix());
+	}
+
+	return m_aCurrentStyleName;
+}*/
+
+/**
+ * @short   Output bullet list header, such as <text:ordered-list> and <text:list-item>
+ * @param   pOutputStream pointer of XFstream to be written in.
+ * @param   bIsOrdered if the list if ordered or not.
+ * @param   rStyleName style name of the list
+ * @param   nLevel level of the paragraph
+ */
+void LwpBulletStyleMgr::OutputBulletListHeader(IXFStream* pOutputStream, sal_Bool bIsOrdered,
+		const rtl::OUString& rStyleName, sal_Int16 nLevel, sal_Bool bIsBulletSkiped)
+{
+	if (nLevel == 0)
+	{
+		return;
+	}
+
+	m_bIsBulletSkipped = bIsBulletSkiped;
+	
+	if (m_pBulletList)
+	{
+		delete m_pBulletList;
+	}
+
+	m_pBulletList = new XFList();
+
+	//todo: need judge here.
+	sal_Bool bContinue = m_bContinue;
+	
+	if (bIsOrdered)
+	{
+		m_pBulletList->SetOrdered(sal_True);
+	}
+	else
+	{
+		bContinue = sal_False;
+		m_pBulletList->SetOrdered(sal_False);
+	}
+	m_pBulletList->SetStyleName(rStyleName);
+//	if (nLevels < 0)
+//	{
+//		m_pBulletList->StartList(pOutputStream);
+//	}
+//	else
+//	{
+		for (sal_uInt8 nC = 0; nC < nLevel; nC++)
+		{
+			//continue numbering
+			if (nC == nLevel-1)
+			{
+				m_pBulletList->StartList(pOutputStream, bContinue);
+			}
+			else
+			{
+				m_pBulletList->StartList(pOutputStream);
+			}
+			if ((nC == nLevel-1) && bIsBulletSkiped)
+			{
+				XFList::StartListHeader(pOutputStream);
+			}
+			else
+			{
+				XFList::StartListItem(pOutputStream);
+			}
+		}
+//	}
+}
+
+#include "xfilter/xflistitem.hxx"
+//Create nested XFList and XFItems and then add it to XFContentContainer(pCont)
+//Return the inner XFItem created.
+XFContentContainer* LwpBulletStyleMgr::AddBulletList(
+		XFContentContainer* pCont, sal_Bool bIsOrdered,
+		const rtl::OUString& rStyleName, sal_Int16 nLevel, sal_Bool bIsBulletSkiped)
+{
+	assert(nLevel>0);
+
+	m_bIsBulletSkipped = bIsBulletSkiped;
+	
+	//todo: need judge here.
+	sal_Bool bContinue = m_bContinue;
+
+	XFList* theList;
+	XFList* prevList = NULL;
+	XFListItem* theItem;
+	XFListItem* InnerItem = NULL;
+	for (sal_Int8 nC = nLevel-1; nC >= 0; nC--)
+	{
+		theList = new XFList();
+		theItem = new XFListItem();
+		theList->Add(theItem);
+
+		if (bIsOrdered)
+		{
+			theList->SetOrdered(sal_True);
+		}
+		else
+		{
+			bContinue = sal_False;
+			theList->SetOrdered(sal_False);
+		}
+		
+		if (nC == nLevel-1)
+		{
+			theList->SetContinueNumber(bContinue);
+		}
+		//Add the outer list to pCont
+		if (nC == 0)
+		{
+			theList->SetStyleName(rStyleName);
+			pCont->Add(theList);
+		}
+
+		if ((nC == nLevel-1) && bIsBulletSkiped)
+		{
+			theItem->SetIsHeader(sal_True);
+			
+			theList->SetContinueNumber(sal_True);
+			// end of add
+		}
+		
+		if(nC == nLevel-1)
+		{
+			InnerItem = theItem;
+		}
+		
+		if(prevList)
+		{
+			theItem->Add(prevList);
+		}
+		prevList = theList;
+	}
+	return InnerItem;
+}
+
+/**
+ * @short   Output bullet list header, such as </text:ordered-list> and </text:list-item>
+ * @param   pOutputStream pointer of XFstream to be written in.
+ * @param   nLevel level of the paragraph
+ */
+void LwpBulletStyleMgr::OutputBulletListTail(IXFStream* pOutputStream, sal_uInt16 nLevel)
+{
+	if ( !m_pBulletList )
+	{
+		return;
+	}
+
+	for (sal_uInt8 nC = 0; nC < nLevel; nC++)
+	{
+		if (m_bIsBulletSkipped)
+		{
+			XFList::EndListHeader(pOutputStream);
+			m_bIsBulletSkipped = sal_False;
+		}
+		else
+		{
+			XFList::EndListItem(pOutputStream);
+		}
+		m_pBulletList->EndList(pOutputStream);
+	}
+}
+
+rtl::OUString LwpBulletStyleMgr::GetDivisionName()
+{
+	if (!m_pFoundry)
+	{
+		return rtl::OUString::createFromAscii("");
+	}
+
+	rtl::OUString aRet = rtl::OUString::createFromAscii("");
+	
+	LwpDocument* pDoc = m_pFoundry->GetDocument();
+	if (pDoc)
+	{
+		LwpObjectID* pID = pDoc->GetDivInfoID();
+		if (!pID->IsNull())
+		{
+			aRet = static_cast<LwpDivInfo*>(pID->obj(VO_DIVISIONINFO))->GetDivName();
+		}
+	}
+
+	return aRet;
+}
+
+rtl::OUString LwpBulletStyleMgr::GetSectionName(LwpPara* pPara)
+{
+	LwpObjectID* pStoryID = pPara->GetStoryID();
+	if (pStoryID->IsNull())
+	{
+		return rtl::OUString::createFromAscii("");
+	}
+
+	LwpStory* pStory = static_cast<LwpStory*>(pStoryID->obj(VO_STORY));
+	if (!pStory)
+	{
+		return rtl::OUString::createFromAscii("");
+	}
+
+	return pStory->GetSectionName();
+}
diff -urNp lotuswordpro.bak/source/filter/lwpbulletstylemgr.hxx lotuswordpro/source/filter/lwpbulletstylemgr.hxx
--- lotuswordpro.bak/source/filter/lwpbulletstylemgr.hxx	1970-01-01 08:00:00.000000000 +0800
+++ lotuswordpro/source/filter/lwpbulletstylemgr.hxx	2008-10-22 11:42:29.000000000 +0800
@@ -0,0 +1,168 @@
+/*************************************************************************
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: IBM Corporation
+ *
+ *  Copyright: 2008 by IBM Corporation
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+/*************************************************************************
+ * @file 
+ *  For LWP filter architecture prototype
+ ************************************************************************/
+/*************************************************************************
+ * Change History
+ Jan 2005			Created
+ ************************************************************************/
+#ifndef _LWPBULLETSTYLEMGR_HXX
+#define _LWPBULLETSTYLEMGR_HXX
+
+#include "lwpheader.hxx"
+#include "lwpfoundry.hxx"
+#include "lwpobjid.hxx"
+#include "lwpnumberingoverride.hxx"
+#include <utility> 
+#include "xfilter/xfcontentcontainer.hxx"
+
+class XFListStyle;
+class XFList;
+class LwpPara;
+class LwpSilverBullet;
+class XFStyleManager;
+class LwpIndentOverride;
+class LwpBulletOverride;
+class LwpFribParaNumber;
+
+class LwpBulletStyleMgr
+{
+public:
+	LwpBulletStyleMgr();
+	virtual ~LwpBulletStyleMgr();
+	rtl::OUString RegisterBulletStyle(LwpPara* pPara, LwpBulletOverride* pBullOver, 
+		LwpIndentOverride* pIndent);
+//	rtl::OUString RegisterBulletStyle(const rtl::OUString& rContent, sal_uInt32 nFontID, LwpIndentOverride* pIndent);
+//	rtl::OUString AddStyleToList(LwpSilverBullet* pSilverBullet, sal_uInt16 nLevel);
+	inline void SetFoundry(LwpFoundry* pFoundry);
+	inline void SetContinueFlag(sal_Bool bFlag);
+	void OutputBulletListHeader(IXFStream* pOutputStream, sal_Bool bIsOrdered,
+		const rtl::OUString& rStyleName, sal_Int16 nLevel, sal_Bool bIsBulletSkiped);
+	//Added by Helen
+	XFContentContainer* AddBulletList(XFContentContainer* pCont, sal_Bool bIsOrdered,
+		const rtl::OUString& rStyleName, sal_Int16 nLevel, sal_Bool bIsBulletSkiped);
+	//End of Add
+	void OutputBulletListTail(IXFStream* pOutputStream, sal_uInt16 nLevel);
+	inline void SetCurrentPos(sal_uInt16 nNewPos);
+	inline void SetCurrentSilverBullet(const LwpObjectID& rNewID);
+	inline LwpObjectID GetCurrentSilverBullet();
+	inline sal_uInt16 GetCurrentPos() const;
+	inline void SetCurrentNumOver(const LwpNumberingOverride& rOther);
+	inline LwpNumberingOverride* GetCurrentNumOver();
+
+private:
+//	void CreateNewListStyle(XFListStyle*& pListStyle, XFStyleManager* pXFStyleMgr);
+	rtl::OUString GetDivisionName();
+	rtl::OUString GetSectionName(LwpPara* pPara);
+
+private:
+//	std::vector <XFListStyle*> m_aBulletStyleList;
+	typedef std::pair<LwpBulletOverride, LwpObjectID> OverridePair;
+	std::vector <rtl::OUString> m_vStyleNameList;
+	std::vector <OverridePair> m_vIDsPairList;
+	rtl::OUString m_aCurrentStyleName;
+	LwpFoundry* m_pFoundry;
+	XFList* m_pBulletList;
+//	UChar32 m_nCurrentChar;
+//	rtl::OUString m_strCurrentFontName;
+//	rtl::OUString m_strCurrentNumberingName;
+	sal_Bool m_bContinue;
+	sal_Bool m_bIsBulletSkipped;
+	LwpObjectID m_aCurrentNumberingID;
+	LwpNumberingOverride m_aCurrentNumOverride;
+	sal_uInt16 m_nCurrentPos;
+
+};
+
+inline void LwpBulletStyleMgr::SetFoundry(LwpFoundry* pFoundry)
+{
+	m_pFoundry = pFoundry;
+}
+inline void LwpBulletStyleMgr::SetContinueFlag(sal_Bool bFlag)
+{
+	m_bContinue = bFlag;
+}
+
+inline void LwpBulletStyleMgr::SetCurrentPos(sal_uInt16 nNewPos)
+{
+	m_nCurrentPos = nNewPos;
+}
+inline void LwpBulletStyleMgr::SetCurrentSilverBullet(const LwpObjectID& rNewID)
+{
+	m_aCurrentNumberingID = rNewID;
+}
+
+inline LwpObjectID LwpBulletStyleMgr::GetCurrentSilverBullet()
+{
+	return m_aCurrentNumberingID;
+}
+
+inline sal_uInt16 LwpBulletStyleMgr::GetCurrentPos() const
+{
+	return m_nCurrentPos;
+}
+
+inline void LwpBulletStyleMgr::SetCurrentNumOver(const LwpNumberingOverride& rOther)
+{
+	m_aCurrentNumOverride = rOther;
+}
+inline LwpNumberingOverride* LwpBulletStyleMgr::GetCurrentNumOver()
+{
+	return &m_aCurrentNumOverride;
+}
+
+#endif
diff -urNp lotuswordpro.bak/source/filter/lwpcelllayout.cxx lotuswordpro/source/filter/lwpcelllayout.cxx
--- lotuswordpro.bak/source/filter/lwpcelllayout.cxx	1970-01-01 08:00:00.000000000 +0800
+++ lotuswordpro/source/filter/lwpcelllayout.cxx	2008-10-22 11:42:29.000000000 +0800
@@ -0,0 +1,956 @@
+/*************************************************************************
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: IBM Corporation
+ *
+ *  Copyright: 2008 by IBM Corporation
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+/**
+ * @file 
+ *  For LWP filter architecture prototype - cell layouts
+ */
+/*************************************************************************
+ * Change History
+ April 2005		 	Created
+ ************************************************************************/
+#include "lwpcelllayout.hxx"
+#include "lwpfoundry.hxx"
+#include "lwpobjfactory.hxx"
+#include "lwptblcell.hxx"
+#include "lwptblformula.hxx"
+#include "lwpholder.hxx"
+#include "lwpnumericfmt.hxx"
+#include "lwptable.hxx"
+#include "lwpglobalmgr.hxx"
+
+#include "xfilter/xfstylemanager.hxx"
+#include "xfilter/xfcell.hxx"
+#include "xfilter/xfcellstyle.hxx"
+#include "xfilter/xfcolstyle.hxx"
+
+LwpCellLayout::LwpCellLayout(LwpObjectHeader &objHdr, LwpSvStream* pStrm)
+	: LwpMiddleLayout(objHdr, pStrm)
+{}
+
+LwpCellLayout::~LwpCellLayout()
+{}
+
+/**
+ * @short   Get table layout pointer, if default cell layout, return NULL
+ * @param LwpTableLayout *
+ * @return 
+ */
+LwpTableLayout * LwpCellLayout::GetTableLayout()
+{
+	LwpRowLayout * pRow = static_cast<LwpRowLayout *>(GetParent()->obj());
+	if(!pRow)
+	{
+		return NULL;
+	}
+	LwpTableLayout * pTableLayout = pRow->GetParentTableLayout();
+	return pTableLayout;
+}
+/**
+ * @short   Get table pointer, if default cell layout, return NULL
+ * @param LwpTable *
+ * @return 
+ */
+LwpTable * LwpCellLayout::GetTable()
+{
+	LwpTableLayout * pTableLayout = GetTableLayout();
+	if(!pTableLayout)
+	{
+		return NULL;
+	}
+	LwpTable *pTable = pTableLayout->GetTable();
+	return pTable;
+}
+/**
+ * @short   Set current cell layout to cell layout map
+ * @param 
+ * @return 
+ */
+void LwpCellLayout::SetCellMap()
+{
+	// this function is called from LwpTableLayout, so it can't be NULL
+	GetTableLayout()->SetWordProCellMap(crowid, ccolid, this);
+}
+/**
+ * @short  Get actual width of this cell layout
+ * @param 
+ * @return width (cm)
+ */
+double LwpCellLayout::GetActualWidth()
+{
+	//Get table layout
+	LwpTableLayout * pTableLayout = GetTableLayout();
+
+	if (pTableLayout == NULL)
+	{
+		return GetGeometryWidth();
+	}
+
+	OUString strColStyle = pTableLayout->GetColumnWidth(ccolid);
+	
+	XFStyleManager* pXFStyleManager = LwpGlobalMgr::GetInstance()->GetXFStyleManager();
+	XFColStyle *pStyle = static_cast<XFColStyle *>(pXFStyleManager->FindStyle(strColStyle));
+	if(pStyle)
+	{
+		return pStyle->GetWidth();
+	}
+
+	return GetGeometryWidth();
+}
+
+/**
+ * @short   Apply padding to cell style
+ * @param pCellStyle - pointer of XFCellStyle
+ * @return 
+ */
+void LwpCellLayout::ApplyPadding(XFCellStyle *pCellStyle)
+{
+	double fLeft = GetMarginsValue(MARGIN_LEFT);
+	double fRight = GetMarginsValue(MARGIN_RIGHT);
+	double fTop = GetMarginsValue(MARGIN_TOP);
+	double fBottom = GetMarginsValue(MARGIN_BOTTOM);
+	pCellStyle->SetPadding((float)fLeft,(float)fRight,(float)fTop,(float)fBottom);
+}
+/**
+ * @short   Apply border to cell style according to cell position, default cell layout won't use this function
+ * @param 
+ * @return pCellStyle - pointer of XFCellStyle
+ */
+void LwpCellLayout::ApplyBorders(XFCellStyle *pCellStyle)
+{
+	// judge cell border type
+	LwpCellBorderType eType = GetCellBorderType(crowid, ccolid, GetTableLayout());
+
+	// get left cell and judge if neighbour border is different
+	XFBorders * pBorders = GetXFBorders();
+	if(!pBorders)
+	{
+		return;
+	}
+
+	switch (eType)
+	{
+	case enumNoBottomBorder:
+		pBorders->SetWidth(enumXFBorderBottom, 0);
+		break;
+	case enumNoLeftBorder:
+		pBorders->SetWidth(enumXFBorderLeft, 0);
+		break;
+	case enumNoLeftNoBottomBorder:
+		pBorders->SetWidth(enumXFBorderBottom, 0);
+		pBorders->SetWidth(enumXFBorderLeft, 0);
+		break;
+	case enumWholeBorder:
+		break;
+	default:
+		assert(sal_False);
+	}
+	pCellStyle->SetBorders(pBorders);
+}
+/**
+ * @short   Apply watermark to cell style
+ * @param pCellStyle - pointer of XFCellStyle
+ * @return 
+ */
+void LwpCellLayout::ApplyWatermark(XFCellStyle *pCellStyle)
+{
+	XFBGImage* pBGImage = GetXFBGImage();
+	if(pBGImage)
+	{
+		pCellStyle->SetBackImage(pBGImage);
+	}
+}
+
+/**
+ * @short   Apply pattern fill to cell style
+ * @param pCellStyle - pointer of XFCellStyle
+ * @return 
+ */
+void LwpCellLayout::ApplyPatternFill(XFCellStyle* pCellStyle)
+{
+	XFBGImage* pXFBGImage = this->GetFillPattern();
+	if (pXFBGImage)
+	{
+		pCellStyle->SetBackImage(pXFBGImage);
+	}
+}
+
+/**
+ * @short   Apply background to cell style
+ * @param pCellStyle - pointer of XFCellStyle
+ * @return 
+ */
+void LwpCellLayout::ApplyBackGround(XFCellStyle* pCellStyle)
+{
+	if (this->IsPatternFill())
+	{
+		ApplyPatternFill(pCellStyle);
+	}
+	else
+	{
+		ApplyBackColor(pCellStyle);
+	}
+}
+/**
+ * @short   Apply back color to cell style
+ * @param pCellStyle - pointer of XFCellStyle
+ * @return 
+ */
+void LwpCellLayout::ApplyBackColor(XFCellStyle *pCellStyle)
+{
+	LwpColor* pColor = GetBackColor();
+	if(pColor && pColor->IsValidColor())
+	{
+		XFColor aXFColor(pColor->To24Color());
+		pCellStyle->SetBackColor(aXFColor);
+	}	
+}
+/**
+ * @short   register style of cell layout
+ * @param pCellStyle The style of the cell, which would be applied to the cell.
+ * @return 
+ */
+void LwpCellLayout::ApplyFmtStyle(XFCellStyle *pCellStyle)
+{
+	LwpLayoutNumerics* pLayoutNumerics =(LwpLayoutNumerics*)cLayNumerics.obj();
+	if (!pLayoutNumerics)
+	{
+		// if current layout doesn't have format, go to based on layout
+		LwpCellLayout* pCellLayout = (LwpCellLayout*)m_BasedOnStyle.obj();
+		if (pCellLayout)
+		{
+			pLayoutNumerics = (LwpLayoutNumerics*)pCellLayout->GetNumericsObject()->obj();
+		}
+	}
+
+	// apply format style
+	if (pLayoutNumerics)
+	{
+		XFStyle* pStyle = pLayoutNumerics->Convert();
+		if (pStyle)
+		{
+			XFStyleManager* pXFStyleManager = LwpGlobalMgr::GetInstance()->GetXFStyleManager();
+			m_NumfmtName = pXFStyleManager->AddStyle(pStyle)->GetStyleName();
+			pCellStyle->SetDataStyle(m_NumfmtName);//modified by ,2005/11/30
+		}
+	}
+	
+	return;
+}
+/**
+ * @short   get style name according to cell position, only table default cells use this function
+ * @param	nRow - default cell position row number
+ * @param	nCol - default cell position col number
+ * @return 	OUString - registered cell style name
+ */
+OUString LwpCellLayout::GetCellStyleName(sal_uInt16 nRow, sal_uInt16 nCol, LwpTableLayout * pTableLayout)
+{
+	// judge cell border type
+	LwpCellBorderType eType = GetCellBorderType(nRow, nCol, pTableLayout);
+	return m_CellStyleNames[eType];
+}
+/**
+*	Make the XFCell
+*	@date	03/26/2005
+*	@param	aTableID - ID of the table which this cell belongs to 
+*	@param	bIsTopRow - whether current cell is top row
+*	@param	bIsRightCol - whether current cell is the rightest column
+*	@return	XFCell*
+*/
+XFCell* LwpCellLayout::ConvertCell(LwpObjectID aTableID, sal_uInt16 nRow, sal_uInt16 nCol)
+{
+	// if cell layout is aTableID's default cell layout
+	// it can't have any content, bypass these code
+	LwpTable * pTable = static_cast<LwpTable *>(aTableID.obj());
+	if (!pTable)
+	{
+		assert(sal_False);
+		return NULL;
+	}
+	XFCell * pXFCell = new XFCell();
+	OUString aStyleName = m_StyleName;
+	
+	// if cell layout is aTableID's default cell layout
+	// we should judt its style by current positon
+	if (*pTable->GetDefaultCellStyle() == *GetObjectID())
+	{
+		aStyleName = GetCellStyleName(nRow, nCol, pTable->GetTableLayout());
+	}
+
+	// content of cell
+	LwpStory* pStory =(LwpStory*) m_Content.obj();
+	if (pStory)
+	{
+		pStory->XFConvert(pXFCell);
+	}
+
+	ApplyProtect(pXFCell, aTableID);
+	pXFCell->SetStyleName(aStyleName);
+	return pXFCell;
+}
+
+LwpPara* LwpCellLayout::GetLastParaOfPreviousStory()
+{
+	LwpObjectID* pPreStoryID = this->GetPreviousCellStory();
+	if (pPreStoryID && !(pPreStoryID->IsNull()))
+	{
+		LwpStory* pPreStory = static_cast<LwpStory*>(pPreStoryID->obj(VO_STORY));
+		return static_cast<LwpPara*>(pPreStory->GetLastPara()->obj(VO_PARA));
+	}
+	else
+	{
+		return NULL;
+	}
+}
+
+/**
+ * @short    Get previous cell which used for bullet inside cell
+ * @param   
+ * @return   LwpObjectID * - object ID of cell content story
+ */
+LwpObjectID * LwpCellLayout::GetPreviousCellStory()
+{
+	LwpTable *pTable = GetTable();
+	if (!pTable)
+	{
+		assert(sal_False);
+		return NULL;
+	}
+	sal_uInt16 nRow = crowid;
+	sal_uInt16 nCol = ccolid;
+	
+	// if table is reset paragraph in columns, get cell on the top side of current cell
+	if (pTable->IsNumberDown())
+	{
+		if (nRow == 0)
+		{
+			return NULL;
+		}
+		nRow -=1;
+	}
+	else
+	{
+		// if not, get cell on the left side of current cell
+		if (nCol == 0)
+		{
+			if (nRow == 0)
+			{
+				return NULL;
+			}
+			else
+			{
+				nRow--;
+				nCol = pTable->GetColumn() - 1;
+			}
+		}
+		else
+		{
+			nCol -=1;
+		}
+	}
+
+	// get the object id pointer of previous cell story
+	LwpTableLayout * pTableLayout = GetTableLayout();
+	if (!pTableLayout)
+	{
+		assert(sal_False);
+		return NULL;
+	}
+	return pTableLayout->SearchCellStoryMap(nRow, nCol);
+}
+
+/**
+ * @short   judge border type by cell neighbour
+ * @param nRow
+ * @param nCol
+ * @param pTableLayout 
+ * @return   LwpCellBorderType
+ */
+LwpCellBorderType LwpCellLayout::GetCellBorderType(sal_uInt16 nRow, sal_uInt16 nCol, LwpTableLayout * pTableLayout)
+{
+	if (!pTableLayout)
+	{
+		assert(sal_False);
+		return enumWholeBorder;
+	}
+
+	// get left cell and judge if neighbour border is different
+	XFBorders * pBorders = GetXFBorders();
+	if(!pBorders)
+	{
+		return enumWholeBorder;
+	}
+	XFBorder *pLeftBorder = pBorders->GetLeft();
+	XFBorder *pBottomBorder = pBorders->GetBottom();
+	sal_Bool bNoLeftBorder = sal_False;
+	sal_Bool bNoBottomBorder = sal_False;
+	
+	LwpCellLayout * pLeftNeighbour = GetCellByRowCol(nRow, GetLeftColID(nCol), pTableLayout);
+	if (pLeftNeighbour)
+	{
+		XFBorders * pNeighbourBorders = pLeftNeighbour->GetXFBorders();
+		if (pNeighbourBorders)
+		{
+			XFBorder * pRightBorder = pNeighbourBorders->GetRight();
+			if (*pLeftBorder == *pRightBorder)
+			{
+				// for these 2 types cell, left border should be ignored for sake of avoiding duplication border
+				// but if left border is different with right border of left cell
+				// we should not ignored it
+				bNoLeftBorder = sal_True;
+			}
+			delete pNeighbourBorders;
+		}
+		
+	}
+
+	LwpCellLayout * pBelowNeighbour = GetCellByRowCol(GetBelowRowID(nRow), nCol, pTableLayout);
+	if (pBelowNeighbour) //&& (eType == enumRightNotLastCellBorder || eType ==  enumLeftNotLastCellBorder) )
+	{
+		XFBorders * pBelowBorders = pBelowNeighbour->GetXFBorders();
+		if (pBelowBorders)
+		{
+			XFBorder * pTopBorder = pBelowBorders->GetTop();
+			if (*pTopBorder == *pBottomBorder)
+			{
+				// for these 2 types cell, bottom border should be ignored for sake of avoiding duplication border
+				// but if bottom border is different with right border of left cell
+				// we should not ignored it
+				bNoBottomBorder = sal_True;
+			}
+			delete pBelowBorders;
+		}
+	}
+
+	delete pBorders;
+	
+	if (bNoBottomBorder)
+	{
+		if (bNoLeftBorder)
+		{
+			return enumNoLeftNoBottomBorder;
+		}
+		return enumNoBottomBorder;
+	}
+	if (bNoLeftBorder)
+	{
+		return enumNoLeftBorder;
+	}
+	return enumWholeBorder;
+}
+
+/**
+ * @short   Get neighbour cell by specifying ROW+COL
+ * @param   nRow
+ * @param   nCol
+ * @return   LwpCellLayout *
+ */
+LwpCellLayout * LwpCellLayout::GetCellByRowCol(sal_uInt16 nRow, sal_uInt16 nCol, LwpTableLayout * pTableLayout)
+{
+	return pTableLayout->GetCellByRowCol(nRow, nCol);
+}
+/**
+ * @short   Register table's default cell layout
+ * @param 
+ * @return 
+ */
+void LwpCellLayout::RegisterDefaultCell()
+{
+	XFStyleManager* pXFStyleManager = LwpGlobalMgr::GetInstance()->GetXFStyleManager();
+	for (sal_uInt16 eLoop = enumWholeBorder; eLoop < enumCellBorderTopLimit; eLoop++)
+	{
+		// register cell style
+		XFCellStyle *pCellStyle = new XFCellStyle();
+
+		ApplyPadding(pCellStyle);
+		ApplyBackColor(pCellStyle);
+		ApplyWatermark(pCellStyle);
+		ApplyFmtStyle(pCellStyle);
+		pCellStyle->SetAlignType(enumXFAlignNone, GetVerticalAlignmentType());
+
+		XFBorders * pBorders = GetXFBorders();
+		if (pBorders)
+		{
+			switch(eLoop)
+			{
+			case enumNoBottomBorder:
+				// _
+				//| |
+				//
+				// remove bottom line
+				pBorders->SetWidth(enumXFBorderBottom, 0);
+				break;
+			case enumNoLeftNoBottomBorder:
+				// _
+				//  |
+				//
+				// remove left and bottom
+				pBorders->SetWidth(enumXFBorderLeft, 0);
+				pBorders->SetWidth(enumXFBorderBottom, 0);
+				break;
+			case enumWholeBorder:
+				//--
+				//||
+				//--
+				// nothing to remove
+				break;
+			case enumNoLeftBorder:
+				// 
+				//| |
+				//--
+				// remove left line
+				pBorders->SetWidth(enumXFBorderLeft, 0);
+				break;
+			default:
+				assert(sal_False);
+			}
+			pCellStyle->SetBorders(pBorders);
+		}
+		m_CellStyleNames[eLoop] = pXFStyleManager->AddStyle(pCellStyle)->GetStyleName();
+	}	
+}
+/**
+ * @short    Register 4 types of cell style and register content styles
+ * @param   
+ * @param   
+ * @param   
+ * @return   
+ */
+void LwpCellLayout::RegisterStyle()
+{
+	LwpVirtualLayout * pParent = static_cast<LwpVirtualLayout *>(GetParent()->obj());
+	if (!pParent || pParent->GetLayoutType() != LWP_ROW_LAYOUT)
+	{
+		// default cell layout, we must register 4 styles for it
+		RegisterDefaultCell();
+		return;
+	}
+	
+	// register cell style
+	XFCellStyle *pCellStyle = new XFCellStyle();
+
+	ApplyPadding(pCellStyle);
+//	ApplyBackColor(pCellStyle);
+	ApplyBackGround(pCellStyle);
+	ApplyWatermark(pCellStyle);
+	ApplyFmtStyle(pCellStyle);
+	ApplyBorders(pCellStyle);
+	
+	pCellStyle->SetAlignType(enumXFAlignNone, GetVerticalAlignmentType());
+	
+	XFStyleManager* pXFStyleManager = LwpGlobalMgr::GetInstance()->GetXFStyleManager();
+	m_StyleName = pXFStyleManager->AddStyle(pCellStyle)->GetStyleName();
+
+	// content object register styles
+	LwpObject * pObj = m_Content.obj();
+	if (pObj)
+	{
+		pObj->SetFoundry(m_pFoundry);
+		pObj->RegisterStyle();
+	}
+
+	//register child layout style
+	RegisterChildStyle();
+	/*
+	LwpVirtualLayout* pLayout = static_cast<LwpVirtualLayout*>(GetChildHead()->obj());
+	while(pLayout)
+	{		
+		pLayout->SetFoundry(m_pFoundry);
+		pLayout->RegisterStyle();
+		pLayout = static_cast<LwpVirtualLayout*>(pLayout->GetNext()->obj());
+	}
+	*/
+}
+/**
+ * @short   Read cell layout
+ * @param 
+ * @return 
+ */
+void LwpCellLayout::Read()
+{
+	LwpObjectStream* pStrm = m_pObjStrm;
+	
+	LwpMiddleLayout::Read();
+
+	// before the layout hierarchy rework
+	if (LwpFileHeader::m_nFileRevision  < 0x000b)
+	{
+		assert(sal_False);
+	}
+	else
+	{
+		crowid = pStrm->QuickReaduInt16();
+		ccolid = (sal_uInt8) pStrm->QuickReaduInt16();	// written as a lushort
+
+		sal_uInt16 type;
+
+		type = pStrm->QuickReaduInt16();
+		pStrm->SkipExtra();
+		cType = (LeaderDotType)type;
+
+		cLayNumerics.ReadIndexed(pStrm);
+		cLayDiagonalLine.ReadIndexed(pStrm);
+
+		pStrm->SkipExtra();
+	}
+}
+/**
+ * @short   Get leader char
+ * @param none
+ * @return char ascii, if none, return 0
+ */
+sal_uInt8 LwpCellLayout::GetLeaderChar()
+{
+	switch(cType)
+	{
+	case LDT_NONE:
+		return 0;
+	case LDT_DOTS:
+		return '.';
+	case LDT_DASHES:
+		return '-';
+	case LDT_UNDERSCORES:
+		return '_';
+	default:
+		assert(sal_False);
+	}
+	return 0;
+}
+/**
+*	Apply protect attribute to cell of table
+*	@date	04/04/2005
+*	@param	aTableID - ID of the table which the cell belongs to
+*	@param	
+*	@return	XFCell*
+*/
+void LwpCellLayout::ApplyProtect(XFCell * pCell, LwpObjectID aTableID)
+{
+	sal_Bool bProtected = sal_False;
+	// judge current cell
+	if (IsProtected())
+	{
+		bProtected = sal_True;
+	}
+	else 
+	{
+		// judge base on 
+		LwpCellLayout * pBase = static_cast<LwpCellLayout *>(m_BasedOnStyle.obj());
+		if (pBase && pBase->IsProtected())
+		{
+			bProtected = sal_True;
+		}
+		else
+		{
+			// judge whole table
+			LwpTable * pTable = static_cast<LwpTable *>(aTableID.obj());
+			LwpTableLayout * pTableLayout = static_cast<LwpTableLayout *>(pTable->GetTableLayout());	
+			LwpSuperTableLayout * pSuper = pTableLayout->GetSuperTableLayout();
+			if (pSuper && pSuper->IsProtected())
+			{
+				bProtected = sal_True;
+			}
+		}
+	}
+	
+	pCell->SetProtect(bProtected);
+}
+
+
+LwpConnectedCellLayout::LwpConnectedCellLayout(LwpObjectHeader &objHdr, LwpSvStream* pStrm)
+	: LwpCellLayout(objHdr, pStrm)
+{}
+
+LwpConnectedCellLayout::~LwpConnectedCellLayout()
+{}
+/**
+ * @short   Set current connected cell layout to cell layout map
+ * @param pCellLayoutMap - cell layout map reference
+ * @return 
+ */
+void LwpConnectedCellLayout::SetCellMap()
+{
+	// this function is called from LwpTableLayout, so it can't be NULL
+	LwpTableLayout * pTableLayout = GetTableLayout();
+	sal_uInt16 nRowSpan = m_nRealrowspan;
+
+	for (sal_uInt16 iLoop = 0; iLoop < nRowSpan; iLoop ++)
+	{
+		for (sal_uInt16 jLoop = 0; jLoop < cnumcols; jLoop ++)
+			pTableLayout->SetWordProCellMap(iLoop + crowid, jLoop + ccolid, this);
+	}
+}
+
+/**
+ * @short   judge border type by cell neighbour
+ * @param nRow
+ * @param nCol
+ * @param pTableLayout 
+ * @return   LwpCellBorderType
+ */
+LwpCellBorderType LwpConnectedCellLayout::GetCellBorderType(sal_uInt16 nRow, sal_uInt16 nCol, LwpTableLayout * pTableLayout)
+{
+	if (!pTableLayout)
+	{
+		assert(sal_False);
+		return enumWholeBorder;
+	}
+
+	sal_uInt16 nRowSpan = m_nRealrowspan;
+
+	// get left cell and judge if neighbour border is different
+	XFBorders * pBorders = GetXFBorders();
+	if(!pBorders)
+	{
+		return enumWholeBorder;
+	}
+	XFBorder *pLeftBorder = pBorders->GetLeft();
+	XFBorder *pBottomBorder = pBorders->GetBottom();
+	sal_Bool bNoLeftBorder = sal_True;
+	sal_Bool bNoBottomBorder = sal_True;
+
+	if (nCol == 0)
+	{
+		bNoLeftBorder = sal_False;
+	}
+	else
+	{
+		for (sal_uInt16 iLoop=0; iLoop < nRowSpan; iLoop++)
+		{
+			LwpCellLayout * pLeftNeighbour = GetCellByRowCol(nRow+iLoop, GetLeftColID(nCol), pTableLayout);
+			if (pLeftNeighbour)
+			{
+				XFBorders * pNeighbourBorders = pLeftNeighbour->GetXFBorders();
+				if (pNeighbourBorders)
+				{
+					XFBorder * pRightBorder = pNeighbourBorders->GetRight();
+					if (*pLeftBorder != *pRightBorder)
+					{
+						// if left border is different with right border of left cell
+						// we should not ignored it
+						bNoLeftBorder = sal_False;
+						break;
+					}
+					delete pNeighbourBorders;
+				}
+			}
+		}
+	}
+
+	if ( (nRow + nRowSpan) == pTableLayout->GetTable()->GetRow() )
+	{
+		bNoBottomBorder = sal_False;
+	}
+	else
+	{
+		for (sal_uInt16 iLoop = 0; iLoop < cnumcols; iLoop ++)
+		{
+			LwpCellLayout * pBelowNeighbour = GetCellByRowCol(nRow + nRowSpan, nCol+iLoop, pTableLayout);
+			if (pBelowNeighbour) 
+			{
+				XFBorders * pBelowBorders = pBelowNeighbour->GetXFBorders();
+				if (pBelowBorders)
+				{
+					XFBorder * pTopBorder = pBelowBorders->GetTop();
+					if (*pTopBorder != *pBottomBorder)
+					{
+						// if bottom border is different with right border of left cell
+						// we should not ignored it
+						bNoBottomBorder = sal_False;
+						break;
+					}
+					delete pBelowBorders;
+				}	
+			}
+		}
+	}	
+	delete pBorders;
+	
+	if (bNoBottomBorder)
+	{
+		if (bNoLeftBorder)
+		{
+			return enumNoLeftNoBottomBorder;
+		}
+		return enumNoBottomBorder;
+	}
+	if (bNoLeftBorder)
+	{
+		return enumNoLeftBorder;
+	}
+	return enumWholeBorder;
+}
+/**
+ * @short   Read connected cell layout
+ * @param 
+ * @return 
+ */
+void LwpConnectedCellLayout::Read()
+{
+	LwpCellLayout::Read();
+	sal_uInt16 numcols;
+
+	cnumrows = m_pObjStrm->QuickReaduInt16();
+	numcols = m_pObjStrm->QuickReaduInt16();		// written as a lushort
+	cnumcols = (sal_uInt8)numcols;
+	
+	m_nRealrowspan = cnumrows;
+	m_nRealcolspan = cnumcols;
+	
+	m_pObjStrm->SkipExtra();
+}
+XFCell* LwpConnectedCellLayout::ConvertCell(LwpObjectID aTableID, sal_uInt16 nRow, sal_uInt16 nCol)
+{
+	XFCell * pXFCell = LwpCellLayout::ConvertCell(aTableID, nRow, nCol);
+	pXFCell->SetColumnSpaned(cnumcols);
+//	if(!m_bSplitFlag)
+//	{			
+//	}
+	return pXFCell;
+}
+/**
+ * @short   parse connected cell layout
+ * @param pOutputStream - output stream
+ * @return 
+ */
+ void  LwpConnectedCellLayout::Parse(IXFStream* pOutputStream)
+{
+}
+
+LwpHiddenCellLayout::LwpHiddenCellLayout(LwpObjectHeader &objHdr, LwpSvStream* pStrm)
+	: LwpCellLayout(objHdr, pStrm)
+{}
+
+LwpHiddenCellLayout::~LwpHiddenCellLayout()
+{}
+/**
+ * @short   Set current hidden cell layout to cell layout map
+ * @param 
+ * @return 
+ */
+void LwpHiddenCellLayout::SetCellMap()
+{
+	return;
+}
+/**
+ * @short   Read hidden cell layout
+ * @param 
+ * @return 
+ */
+void LwpHiddenCellLayout::Read()
+{
+	LwpCellLayout::Read();
+	
+	cconnectedlayout.ReadIndexed(m_pObjStrm);
+	m_pObjStrm->SkipExtra();
+
+}
+/**
+ * @short   Convert hidden cell layout
+ * @param aTableID - Object ID of table
+ * @return XFCell * - pointer to converted cell
+ */
+
+XFCell* LwpHiddenCellLayout::ConvertCell(LwpObjectID aTableID, sal_uInt16 nRow, sal_uInt16 nCol)
+{
+	if (!cconnectedlayout.obj())
+		return NULL;
+	LwpConnectedCellLayout* pConnCell = static_cast<LwpConnectedCellLayout* >(cconnectedlayout.obj());
+
+	if (nRow < (pConnCell->GetNumrows()+pConnCell->GetRowID()))
+		return NULL;
+	// if the hidden cell should be displayed for limit of SODC
+	// use the default cell layout
+	XFCell* pXFCell = NULL;
+	LwpTable *pTable = static_cast<LwpTable *>(aTableID.obj());
+	if (pTable)
+	{
+		LwpCellLayout *pDefault = static_cast<LwpCellLayout *>(pTable->GetDefaultCellStyle()->obj());
+		if (pDefault)
+		{
+			pXFCell = pDefault->ConvertCell(aTableID, nRow, nCol);
+		}
+		else
+		{
+			pXFCell = pConnCell->ConvertCell(aTableID, nRow, nCol);
+		}
+		pXFCell->SetColumnSpaned(pConnCell->GetNumcols());
+	}
+	else
+	{
+		assert(sal_False);
+	}
+	return pXFCell;
+}
+/**
+ * @short   parse hidden cell layout
+ * @param pOutputStream - output stream
+ * @return 
+ */
+ void  LwpHiddenCellLayout::Parse(IXFStream* pOutputStream)
+{
+}
+
+
+LwpParallelColumnsBlock::LwpParallelColumnsBlock(LwpObjectHeader &objHdr, LwpSvStream* pStrm):LwpCellLayout(objHdr, pStrm)
+{}
+
+LwpParallelColumnsBlock::~LwpParallelColumnsBlock()
+{}
+
+void LwpParallelColumnsBlock::Read()
+{
+	LwpCellLayout::Read();
+	m_pObjStrm->SkipExtra();
+}
+
diff -urNp lotuswordpro.bak/source/filter/lwpcelllayout.hxx lotuswordpro/source/filter/lwpcelllayout.hxx
--- lotuswordpro.bak/source/filter/lwpcelllayout.hxx	1970-01-01 08:00:00.000000000 +0800
+++ lotuswordpro/source/filter/lwpcelllayout.hxx	2008-10-22 11:42:29.000000000 +0800
@@ -0,0 +1,209 @@
+/*************************************************************************
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: IBM Corporation
+ *
+ *  Copyright: 2008 by IBM Corporation
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+/**
+ * @file 
+ *  For LWP filter architecture prototype - cell layouts
+ */
+/*************************************************************************
+ * Change History
+ Mar 2005		 	Created
+ ************************************************************************/
+#ifndef _LWPCELLLAYOUT_HXX
+#define _LWPCELLLAYOUT_HXX
+#include <vector>
+#include <map>
+#include "lwplayout.hxx"
+#include "lwptablelayout.hxx"
+
+typedef enum 
+{
+	enumWholeBorder = 0,
+	enumNoLeftBorder,
+	enumNoBottomBorder,
+	enumNoLeftNoBottomBorder,
+	enumCellBorderTopLimit = 4,
+} LwpCellBorderType;
+
+
+class XFCell;
+class XFCellStyle;
+class LwpCellList;
+class LwpTable;
+class LwpTableLayout;
+/**
+ * @brief
+ * VO_CELLLAYOUT object
+ */
+class LwpCellLayout : public LwpMiddleLayout
+{
+public:
+	LwpCellLayout(LwpObjectHeader &objHdr, LwpSvStream* pStrm);
+	virtual ~LwpCellLayout();
+	virtual LWP_LAYOUT_TYPE GetLayoutType () { return LWP_CELL_LAYOUT;}
+	virtual XFCell* ConvertCell(LwpObjectID aTableID, sal_uInt16 nRow, sal_uInt16 nCol);
+	sal_uInt16 GetRowID(){return crowid;};
+	sal_uInt8 GetColID(){return ccolid;};
+	void RegisterStyle();
+	LwpObjectID * GetNumericsObject() {return &cLayNumerics;};
+	LwpObjectID * GetPreviousCellStory();
+	virtual LwpPara* GetLastParaOfPreviousStory();
+	LwpTableLayout * GetTableLayout();
+	virtual void SetCellMap(void);
+	double GetActualWidth();
+	sal_uInt8 GetLeaderChar();
+	OUString GetNumfmtName(){return m_NumfmtName;}
+protected:
+	void Read();	
+//	LwpTableLayout * GetTableLayout();
+	LwpTable * GetTable();
+	void ApplyPadding(XFCellStyle* pCellStyle);
+	void ApplyBorders(XFCellStyle* pCellStyle);
+	// add by , 06/03/2005
+	void ApplyPatternFill(XFCellStyle* pCellStyle);
+ 	void ApplyBackGround(XFCellStyle* pCellStyle);
+	// end add
+	void ApplyBackColor(XFCellStyle* pCellStyle);
+	void ApplyWatermark(XFCellStyle* pCellStyle);
+	void ApplyProtect(XFCell * pCell, LwpObjectID aTableID);
+	void ApplyFmtStyle(XFCellStyle *pCellStyle);
+	OUString GetCellStyleName(sal_uInt16 nRow, sal_uInt16 nCol, LwpTableLayout * pTableLayout);
+	void RegisterDefaultCell();
+	virtual LwpCellBorderType GetCellBorderType(sal_uInt16 nRow, sal_uInt16 nCol, LwpTableLayout * pTableLayout);
+	LwpCellLayout * GetCellByRowCol(sal_uInt16 nRow, sal_uInt16 nCol, LwpTableLayout * pTableLayout);
+	virtual sal_uInt16 GetLeftColID(sal_uInt16 nCol){return nCol - 1; };
+	virtual sal_uInt16 GetBelowRowID(sal_uInt16 nRow){return nRow + 1; };
+
+	sal_uInt16 crowid;
+	sal_uInt8	ccolid;
+	LwpObjectID cLayNumerics;
+	LwpObjectID cLayDiagonalLine;
+	
+	enum LeaderDotType
+	{
+		LDT_NONE = 0,
+		LDT_DOTS = 1,
+		LDT_DASHES = 2,
+		LDT_UNDERSCORES = 3
+	};
+	LeaderDotType cType;
+	OUString m_CellStyleNames[enumCellBorderTopLimit];
+
+	OUString m_NumfmtName;//Add by , to support number color,2005/11/30
+private:
+	LwpCellList* GetCellList(LwpFoundry* pFoundry, LwpObjectID aTableID, sal_uInt16 nRow, sal_uInt8 nCol);
+};
+
+/**
+ * @brief
+ * VO_HIDDENCELLLAYOUT object
+ */
+class LwpHiddenCellLayout : public LwpCellLayout
+{
+public:
+	LwpHiddenCellLayout(LwpObjectHeader &objHdr, LwpSvStream* pStrm);
+	virtual ~LwpHiddenCellLayout();
+	virtual LWP_LAYOUT_TYPE GetLayoutType () { return LWP_HIDDEN_CELL_LAYOUT;}
+	virtual void Parse(IXFStream* pOutputStream);
+	virtual XFCell* ConvertCell(LwpObjectID aTableID, sal_uInt16 nRow, sal_uInt16 nCol);
+	void RegisterStyle(){};
+	virtual void SetCellMap(void);
+protected:
+	void Read();	
+	LwpObjectID cconnectedlayout;
+};
+
+/**
+ * @brief
+ * VO_CONNECTEDCELLLAYOUT object
+ */
+class LwpConnectedCellLayout : public LwpCellLayout
+{
+public:
+	LwpConnectedCellLayout(LwpObjectHeader &objHdr, LwpSvStream* pStrm);
+	virtual ~LwpConnectedCellLayout();
+	virtual LWP_LAYOUT_TYPE GetLayoutType () { return LWP_CONNECTED_CELL_LAYOUT;}
+	virtual void Parse(IXFStream* pOutputStream);
+	virtual XFCell* ConvertCell(LwpObjectID aTableID, sal_uInt16 nRow, sal_uInt16 nCol);
+	sal_uInt16 GetNumrows(){return m_nRealrowspan;}
+	sal_uInt8 GetNumcols(){return m_nRealcolspan;}
+	virtual void SetCellMap(void);
+	void SetNumrows(sal_uInt16 nVal){m_nRealrowspan = nVal;}
+	void SetNumcols(sal_uInt8 nVal){m_nRealcolspan = nVal;}	
+protected:
+	void Read();	
+	virtual sal_uInt16 GetBelowRowID(sal_uInt16 nRow){return nRow + m_nRealrowspan; };
+	virtual LwpCellBorderType GetCellBorderType(sal_uInt16 nRow, sal_uInt16 nCol, LwpTableLayout * pTableLayout);
+	sal_uInt16	cnumrows;
+	sal_uInt8		cnumcols;
+//	sal_Bool m_bSplitFlag;
+	sal_uInt16	m_nRealrowspan;
+	sal_uInt8	m_nRealcolspan;	
+};
+/**
+ * @brief
+ * VO_PCOLBLOCK object
+ */
+
+class LwpParallelColumnsBlock : public LwpCellLayout
+{
+public:
+	LwpParallelColumnsBlock(LwpObjectHeader &objHdr, LwpSvStream* pStrm);
+	virtual ~LwpParallelColumnsBlock();
+protected:
+	void Read();	
+
+};
+
+#endif
diff -urNp lotuswordpro.bak/source/filter/lwpchangemgr.cxx lotuswordpro/source/filter/lwpchangemgr.cxx
--- lotuswordpro.bak/source/filter/lwpchangemgr.cxx	1970-01-01 08:00:00.000000000 +0800
+++ lotuswordpro/source/filter/lwpchangemgr.cxx	2008-10-22 11:42:29.000000000 +0800
@@ -0,0 +1,384 @@
+/*************************************************************************
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: IBM Corporation
+ *
+ *  Copyright: 2008 by IBM Corporation
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+/*************************************************************************
+ * @file 
+ *  For LWP filter architecture prototype
+ ************************************************************************/
+/*************************************************************************
+ * Change History
+ Jun 2005			Created
+ ************************************************************************/
+#include "lwpchangemgr.hxx"
+#include <rtl/ustring.hxx>
+#include "lwppara.hxx"
+#include "lwpfribheader.hxx"
+#include "lwpfribptr.hxx"
+#include "lwpfrib.hxx"
+#include "lwpstory.hxx"
+#include "lwpfribsection.hxx"
+#include "lwpsection.hxx"
+#include "lwpfribbreaks.hxx"
+#include "lwpfribframe.hxx"
+#include "lwpfribtable.hxx"
+#include "lwphyperlinkmgr.hxx"
+#include "lwpfootnote.hxx"
+#include "lwpnotes.hxx"
+#include "lwpfribmark.hxx"
+#include "xfilter/xftextspan.hxx"
+#include "xfilter/xftextcontent.hxx"
+#include "xfilter/xftabstop.hxx"
+#include "xfilter/xflinebreak.hxx"
+#include "xfilter/xfstylemanager.hxx"
+#include "xfilter/xfhyperlink.hxx"
+
+LwpChangeMgr::LwpChangeMgr()
+{
+	m_nCounter = 0;
+	m_DocFribMap.clear();
+	m_HeadFootFribMap.clear();	
+	m_pFribMap = &m_DocFribMap;
+	m_ChangeList.clear();
+}
+LwpChangeMgr::~LwpChangeMgr()
+{
+	m_pFribMap=NULL;
+	m_DocFribMap.clear();
+	m_HeadFootFribMap.clear();
+	m_ChangeList.clear();
+}
+
+void LwpChangeMgr::AddChangeFrib(LwpFrib* pFrib)
+{
+	m_nCounter++;
+	OUString sID = A2OUSTR("ct")+ Int32ToOUString(m_nCounter);
+	m_pFribMap->insert(std::pair<LwpFrib*,OUString>(pFrib,sID));
+}
+
+OUString LwpChangeMgr::GetChangeID(LwpFrib* pFrib)
+{
+	std::map<LwpFrib*,OUString>::iterator iter;
+	iter = m_pFribMap->find(pFrib);
+	if (iter == m_pFribMap->end())
+		return A2OUSTR("");
+	else
+		return iter->second;
+}
+
+void LwpChangeMgr::ConvertAllChange(IXFStream* pStream)
+{
+	std::map<LwpFrib*,OUString>::iterator iter;
+	for (iter=m_DocFribMap.begin();iter !=m_DocFribMap.end();iter++)
+	{
+		if (iter->first->GetRevisionType() == LwpFrib::REV_INSERT)
+		{
+			XFChangeInsert* pInsert = new XFChangeInsert;
+			pInsert->SetChangeID(iter->second);
+			pInsert->SetEditor(iter->first->GetEditor());			
+			m_ChangeList.push_back(pInsert);	
+		}
+		else if (iter->first->GetRevisionType() == LwpFrib::REV_DELETE)
+		{
+			XFChangeDelete* pDelete = new XFChangeDelete;
+			pDelete->SetChangeID(iter->second);
+			pDelete->SetEditor(iter->first->GetEditor());
+///			ConvertFribContent(pDelete,iter->first); //delete tmp,note by ,2005/7/1
+			m_ChangeList.push_back(pDelete);
+		}
+	}
+	
+	std::vector<XFChangeRegion*>::iterator iter1;
+	pStream->GetAttrList()->Clear();
+	if (m_ChangeList.size() == 0)
+			return;
+//Add by ,for disable change tracking,2005/11/21
+	pStream->GetAttrList()->AddAttribute( A2OUSTR("text:track-changes"),A2OUSTR("false"));
+//Add end			
+	pStream->StartElement( A2OUSTR("text:tracked-changes") );
+	for (iter1=m_ChangeList.begin();iter1 !=m_ChangeList.end();iter1++)
+		(*iter1)->ToXml(pStream);
+
+	pStream->EndElement(A2OUSTR("text:tracked-changes"));	
+	
+//	m_DocFribMap.clear();
+	
+	for (iter1=m_ChangeList.begin();iter1 !=m_ChangeList.end();iter1++)
+	{
+		delete *iter1;
+		*iter1=NULL;
+	}
+	m_ChangeList.clear();		
+}
+void LwpChangeMgr::SetHeadFootFribMap(sal_Bool bFlag)
+{
+	if (bFlag == sal_True)
+		m_pFribMap = &m_HeadFootFribMap;
+	else
+	{
+		m_HeadFootFribMap.clear();
+		m_pFribMap = &m_DocFribMap;
+	}
+}
+
+void LwpChangeMgr::SetHeadFootChange(XFContentContainer* pCont)
+{
+	std::map<LwpFrib*,OUString>::iterator iter;
+	XFChangeList* pChangeList = new XFChangeList;
+	
+	for (iter=m_HeadFootFribMap.begin();iter !=m_HeadFootFribMap.end();iter++)
+	{
+		if (iter->first->GetRevisionType() == LwpFrib::REV_INSERT)
+		{
+			XFChangeInsert* pInsert = new XFChangeInsert;
+			pInsert->SetChangeID(iter->second);
+			pInsert->SetEditor(iter->first->GetEditor());
+			pChangeList->Add(pInsert);	
+		}
+		else if (iter->first->GetRevisionType() == LwpFrib::REV_DELETE)
+		{
+			XFChangeDelete* pDelete = new XFChangeDelete;
+			pDelete->SetChangeID(iter->second);
+			pDelete->SetEditor(iter->first->GetEditor());
+			pChangeList->Add(pDelete);
+		}
+	}
+	
+	pCont->Add(pChangeList);
+	
+//	m_HeadFootFribMap.clear();
+}
+
+void LwpChangeMgr::ConvertFribContent(XFContentContainer* pCont, LwpFrib* pFrib)
+{
+	XFParagraph* pXFPara = new XFParagraph;
+	LwpPara* pPara = pFrib->GetMyPara();
+	if (pPara)
+		pXFPara->SetStyleName(pPara->GetStyleName());
+		
+        switch(pFrib->GetType())//copy code from class lwpfribptr
+        {
+	    case FRIB_TAG_TEXT:
+		{
+			LwpFribText* textFrib= static_cast<LwpFribText*>(pFrib);
+			textFrib->XFConvert(pXFPara,pPara->GetStory());
+		}
+		    break;
+		case FRIB_TAG_TAB:
+		{
+			LwpFribTab* tabFrib = static_cast<LwpFribTab*>(pFrib);
+			if (pFrib->m_ModFlag)
+			{	
+				XFTextSpan *pSpan = new XFTextSpan();
+				pSpan->SetStyleName(tabFrib->GetStyleName());
+				XFTabStop *pTab = new XFTabStop();
+				pSpan->Add(pTab);               
+				pXFPara->Add(pSpan); 
+			}    
+			else
+			{
+				XFTabStop *pTab = new XFTabStop();
+				pXFPara->Add(pTab);               
+			}	
+		}	    
+		    break;
+/*		case FRIB_TAG_SECTION:
+		{
+			delete pXFPara;
+			LwpFribSection* pSectionFrib = static_cast<LwpFribSection*>(pFrib);			
+			pSectionFrib->ParseSection();	
+		}
+		break;
+		case FRIB_TAG_PAGEBREAK:
+		{
+			LwpFribPageBreak* pPageBreak = static_cast<LwpFribPageBreak*>(pFrib);
+			LwpPageLayout* pLayout = static_cast<LwpPageLayout*>(pPageBreak->GetLayout()->obj());
+			if(pLayout)
+			{							
+				pPageBreak->ParseLayout();
+			}
+			else
+			{
+				if (pPageBreak->IsLastFrib() == sal_True)
+				{
+					pXFPara->SetStyleName( pPageBreak->GetStyleName() );
+				}
+				else
+				{
+					//parse pagebreak
+					XFParagraph *pNewPara = new XFParagraph();
+					pNewPara->SetStyleName(pFrib->GetStyleName());	
+					pPara->AddXFContent(pNewPara);
+				}
+			}		
+		}
+			break;
+		case FRIB_TAG_COLBREAK:
+		{
+			XFParagraph *pNewPara = new XFParagraph();
+			pNewPara->SetStyleName(pFrib->GetStyleName());	
+			pPara->AddXFContent(pNewPara);
+		}
+			break;	
+*/		case FRIB_TAG_LINEBREAK:
+		{
+			XFLineBreak *pLineBreak = new XFLineBreak();
+			pXFPara->Add(pLineBreak);  			
+		}
+			break;	
+		case FRIB_TAG_UNICODE: //fall through
+		case FRIB_TAG_UNICODE2: //fall through
+		case FRIB_TAG_UNICODE3: //fall through
+		{
+			LwpFribUnicode* unicodeFrib= static_cast<LwpFribUnicode*>(pFrib);
+			unicodeFrib->XFConvert(pXFPara,pPara->GetStory());
+		}
+			break;
+		case FRIB_TAG_HARDSPACE:
+		{
+			rtl::OUString sHardSpace(sal_Unicode(0x00a0));
+			LwpHyperlinkMgr* pHyperlink = 
+					pPara->GetStory()->GetHyperlinkMgr();
+			if (pHyperlink->GetHyperlinkFlag())
+				pFrib->ConvertHyperLink(pXFPara,pHyperlink,sHardSpace);
+			else
+				pFrib->ConvertChars(pXFPara,sHardSpace);
+		}
+			break;
+		case FRIB_TAG_SOFTHYPHEN:
+		{
+			rtl::OUString sSoftHyphen(sal_Unicode(0x00ad));
+			pFrib->ConvertChars(pXFPara,sSoftHyphen);
+		}
+			break;
+/*		case FRIB_TAG_FRAME:
+		{
+			LwpFribFrame* frameFrib= static_cast<LwpFribFrame*>(pFrib);
+			LwpObject* pLayout = frameFrib->GetLayout();
+			if (pLayout->GetTag() == VO_DROPCAPLAYOUT)
+			{
+				pPara->GetFoundry()->GetDropcapMgr()->SetXFPara(pXFPara); 
+				//LwpObject* pDropCap = frameFrib->GetLayout();
+				//pDropCap ->XFConvert(m_pXFPara);
+			}
+			//pLayout->XFConvert(m_pXFPara);
+			frameFrib->XFConvert(pXFPara);
+		}
+			break;
+*/		case FRIB_TAG_CHBLOCK:
+		{
+			LwpFribCHBlock* chbFrib = static_cast<LwpFribCHBlock*>(pFrib);
+			chbFrib->XFConvert(pXFPara,pPara->GetStory());
+		}
+			break;
+/*		case FRIB_TAG_TABLE:
+		{
+			LwpFribTable* tableFrib = static_cast<LwpFribTable*>(pFrib);
+			//tableFrib->XFConvert(m_pPara->GetXFContainer());
+			tableFrib->XFConvert(pXFPara);
+		}
+			break;
+*/		case FRIB_TAG_BOOKMARK:
+		{
+			LwpFribBookMark* bookmarkFrib = static_cast<LwpFribBookMark*>(pFrib);
+			bookmarkFrib->XFConvert(pXFPara);
+		}
+		break;	
+		case FRIB_TAG_FOOTNOTE:
+		{			
+			LwpFribFootnote* pFootnoteFrib = static_cast<LwpFribFootnote*>(pFrib);
+			pFootnoteFrib->XFConvert(pXFPara); 
+			break;
+		}
+		case FRIB_TAG_FIELD:
+		{
+			LwpFribField* fieldFrib = static_cast<LwpFribField*>(pFrib);
+			fieldFrib->XFConvert(pXFPara); 		
+			break;
+		}
+		case FRIB_TAG_NOTE:
+		{
+			LwpFribNote* pNoteFrib = static_cast<LwpFribNote*>(pFrib);
+			pNoteFrib->XFConvert(pXFPara); 
+			break;
+		}
+		case FRIB_TAG_PAGENUMBER:
+		{
+			LwpFribPageNumber* pagenumFrib = static_cast<LwpFribPageNumber*>(pFrib);
+			pagenumFrib->XFConvert(pXFPara); 
+			break;
+		}
+		case FRIB_TAG_DOCVAR:
+		{
+			LwpFribDocVar* docFrib = static_cast<LwpFribDocVar*>(pFrib);
+			docFrib->XFConvert(pXFPara); 
+			break;
+		}
+		case FRIB_TAG_RUBYMARKER:
+		{
+			LwpFribRubyMarker* rubyFrib = static_cast<LwpFribRubyMarker*>(pFrib);
+			rubyFrib->XFConvert(pXFPara); 
+			break;
+		}
+		case FRIB_TAG_RUBYFRAME:
+		{
+			LwpFribRubyFrame* rubyfrmeFrib = static_cast<LwpFribRubyFrame*>(pFrib);
+			rubyfrmeFrib->XFConvert(pXFPara); 
+			break;
+		}
+		default :
+			break;
+	}	
+	pCont->Add(pXFPara);
+}
+
diff -urNp lotuswordpro.bak/source/filter/lwpchangemgr.hxx lotuswordpro/source/filter/lwpchangemgr.hxx
--- lotuswordpro.bak/source/filter/lwpchangemgr.hxx	1970-01-01 08:00:00.000000000 +0800
+++ lotuswordpro/source/filter/lwpchangemgr.hxx	2008-10-22 11:42:29.000000000 +0800
@@ -0,0 +1,95 @@
+/*************************************************************************
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: IBM Corporation
+ *
+ *  Copyright: 2008 by IBM Corporation
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+/*************************************************************************
+ * @file 
+ *  For LWP filter architecture prototype
+ ************************************************************************/
+/*************************************************************************
+ * Change History
+ Jun 2005			Created
+ ************************************************************************/
+#ifndef _LWPCHANGEMGR_HXX_
+#define _LWPCHANGEMGR_HXX_
+
+#include <map>
+#include <vector>
+#include "lwpfrib.hxx"
+#include "lwpobjstrm.hxx"
+#include "lwpbasetype.hxx"
+#include "lwpoverride.hxx"
+#include "lwpfoundry.hxx"
+#include "xfilter/xfchange.hxx"
+#include "xfilter/xfcontentcontainer.hxx"
+
+class LwpChangeMgr
+{
+public:	
+	void AddChangeFrib(LwpFrib* pFrib);
+	OUString GetChangeID(LwpFrib* pFrib);
+	void ConvertAllChange(IXFStream* pStream);
+	void SetHeadFootFribMap(sal_Bool bFlag);
+	void SetHeadFootChange(XFContentContainer* pCont);		
+	~LwpChangeMgr();
+	LwpChangeMgr();
+private:
+	std::map<LwpFrib*,OUString>* m_pFribMap;
+	std::map<LwpFrib*,OUString> m_DocFribMap;
+	std::map<LwpFrib*,OUString> m_HeadFootFribMap;	
+	std::vector<XFChangeRegion*> m_ChangeList;
+	sal_uInt32 m_nCounter;	
+	void ConvertFribContent(XFContentContainer* pCont, LwpFrib* pFrib);
+};
+
+#endif
\ No newline at end of file
diff -urNp lotuswordpro.bak/source/filter/lwpcharacterstyle.cxx lotuswordpro/source/filter/lwpcharacterstyle.cxx
--- lotuswordpro.bak/source/filter/lwpcharacterstyle.cxx	1970-01-01 08:00:00.000000000 +0800
+++ lotuswordpro/source/filter/lwpcharacterstyle.cxx	2008-10-22 11:42:29.000000000 +0800
@@ -0,0 +1,207 @@
+/*************************************************************************
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: IBM Corporation
+ *
+ *  Copyright: 2008 by IBM Corporation
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+/*************************************************************************
+ * @file 
+ *  For LWP filter architecture prototype
+ ************************************************************************/
+/*************************************************************************
+ * Change History
+ Jan 2005			Created
+ ************************************************************************/
+ 
+#include "lwpcharacterstyle.hxx"
+#include "lwpfilehdr.hxx"
+#include "lwptools.hxx"
+#include "lwpoverride.hxx"
+#include "lwpatomholder.hxx"
+#include "lwpfont.hxx"
+#include "lwpfoundry.hxx"
+#include "lwpcharborderoverride.hxx"
+
+/*class LwpTextStyle*/
+LwpTextStyle::LwpTextStyle(LwpObjectHeader& objHdr, LwpSvStream* pStrm)
+	: LwpDLNFPVList(objHdr, pStrm),
+	m_nFontID(0), m_nFinalFontID(0), m_nCSFlags(0), m_nUseCount(0),
+	m_pDescription(new LwpAtomHolder), m_pLangOverride(new LwpTextLanguageOverride),
+	m_pTxtAttrOverride(new LwpTextAttributeOverride),
+	m_pCharacterBorderOverride(new LwpCharacterBorderOverride),
+	m_pAmikakeOverride(new LwpAmikakeOverride),
+	m_nStyleDefinition(0), m_nKey(0)
+{
+}
+
+void LwpTextStyle::Read()
+{
+	LwpDLNFPVList::Read();
+	ReadCommon();
+}
+
+LwpTextStyle::~LwpTextStyle()
+{
+	if (m_pDescription)
+	{
+		delete m_pDescription;
+	}
+	if (m_pLangOverride)
+	{
+		delete m_pLangOverride;
+	}
+	if (m_pTxtAttrOverride)
+	{
+		delete m_pTxtAttrOverride;
+	}
+	if (m_pCharacterBorderOverride)
+	{
+		delete m_pCharacterBorderOverride;
+	}
+	if (m_pAmikakeOverride)
+	{
+		delete m_pAmikakeOverride;
+	}
+}
+
+void LwpTextStyle::ReadCommon()
+{
+	m_pObjStrm->QuickRead(&m_nFontID, 4);
+	m_pObjStrm->QuickRead(&m_nFinalFontID, 4);
+	m_pObjStrm->QuickRead(&m_nCSFlags, 2);
+	m_pObjStrm->QuickRead(&m_nUseCount, 4);
+
+	m_pDescription->Read(m_pObjStrm);
+
+	m_pLangOverride->Read(m_pObjStrm);
+	m_pTxtAttrOverride->Read(m_pObjStrm);
+//#ifdef AMIKAKE
+	if (LwpFileHeader::m_nFileRevision < 0x000B)
+	{
+		m_pCharacterBorderOverride->Read(m_pObjStrm);
+		m_pAmikakeOverride->Read(m_pObjStrm);
+	}
+	else
+	{
+		m_CharacterBorder.ReadIndexed(m_pObjStrm);
+		m_Amikake.ReadIndexed(m_pObjStrm);
+	}
+//#endif
+	sal_uInt16 nCount = 6;
+	if (LwpFileHeader::m_nFileRevision > 0x0005)
+	{
+		m_pObjStrm->QuickRead(&nCount, 2);
+	}
+	
+	m_FaceStyle.ReadIndexed(m_pObjStrm);
+
+	if (nCount > 1)
+	{
+		m_SizeStyle.ReadIndexed(m_pObjStrm);
+		m_AttributeStyle.ReadIndexed(m_pObjStrm);
+		m_FontStyle.ReadIndexed(m_pObjStrm);
+		m_CharacterBorderStyle.ReadIndexed(m_pObjStrm);
+		m_AmikakeStyle.ReadIndexed(m_pObjStrm);
+	}
+
+	if (m_pObjStrm->CheckExtra())
+	{
+		m_pObjStrm->QuickRead(&m_nStyleDefinition, 4);
+
+		if (m_pObjStrm->CheckExtra())
+		{
+			m_pObjStrm->QuickRead(&m_nKey, 2);
+			m_pObjStrm->SkipExtra();
+		}
+	}
+
+}
+
+#include "xfilter/xfparastyle.hxx"
+#include "xfilter/xffont.hxx"
+
+void LwpTextStyle::RegisterStyle()
+{
+	if (!m_pFoundry)
+	{
+		assert(false);
+		return;
+	}
+
+	XFTextStyle* pStyle = new XFTextStyle();
+
+	//Set name
+	OUString styleName = GetName()->str();
+	pStyle->SetStyleName(styleName);
+	
+	//Create font
+	LwpFontManager* pFontMgr = m_pFoundry->GetFontManger();
+	XFFont* pFont = pFontMgr->CreateFont(m_nFinalFontID);
+	pStyle->SetFont(pFont);
+
+	//Set other properties if needed
+
+	//Add style
+	LwpStyleManager* pStyleMgr = m_pFoundry->GetStyleManager();
+	pStyleMgr->AddStyle(*GetObjectID(), pStyle);	
+
+}
+
+/*class LwpCharacterStyle*/
+LwpCharacterStyle::LwpCharacterStyle(LwpObjectHeader& objHdr, LwpSvStream* pStrm) :
+LwpTextStyle(objHdr, pStrm)
+{
+}
+
+void LwpCharacterStyle::Read()
+{
+	LwpTextStyle::Read();
+}
diff -urNp lotuswordpro.bak/source/filter/lwpcharacterstyle.hxx lotuswordpro/source/filter/lwpcharacterstyle.hxx
--- lotuswordpro.bak/source/filter/lwpcharacterstyle.hxx	1970-01-01 08:00:00.000000000 +0800
+++ lotuswordpro/source/filter/lwpcharacterstyle.hxx	2008-10-22 11:42:29.000000000 +0800
@@ -0,0 +1,137 @@
+/*************************************************************************
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: IBM Corporation
+ *
+ *  Copyright: 2008 by IBM Corporation
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+/*************************************************************************
+ * @file 
+ *  For LWP filter architecture prototype
+ ************************************************************************/
+/*************************************************************************
+ * Change History
+ Jan 2005			Created
+ ************************************************************************/
+#ifndef _LWPCHARACTERSTYLE_HXX
+#define _LWPCHARACTERSTYLE_HXX
+
+#include "lwpobj.hxx"
+#include "lwpdlvlist.hxx"
+
+
+class LwpAtomHolder;
+class LwpTextLanguageOverride;
+class LwpTextAttributeOverride;
+class LwpCharacterBorderOverride;
+class LwpAmikakeOverride;
+
+class LwpTextStyle : public LwpDLNFPVList
+{
+public:
+	LwpTextStyle(LwpObjectHeader& objHdr, LwpSvStream* pStrm);
+
+	virtual ~LwpTextStyle();
+
+	inline sal_uInt32 GetFinalFontID() const;
+
+	virtual void RegisterStyle();
+	
+protected:
+	void ReadCommon();
+	void Read();
+
+protected:
+
+	sal_uInt32		m_nFontID;
+	sal_uInt32		m_nFinalFontID;
+	sal_uInt16		m_nCSFlags;
+	sal_uInt32		m_nUseCount;
+
+	LwpAtomHolder*					m_pDescription;
+	LwpTextLanguageOverride*		m_pLangOverride;
+	LwpTextAttributeOverride*		m_pTxtAttrOverride;
+	
+	LwpCharacterBorderOverride*		m_pCharacterBorderOverride;
+	LwpAmikakeOverride*				m_pAmikakeOverride;
+
+	LwpObjectID		m_CharacterBorder;
+	LwpObjectID		m_Amikake;
+	LwpObjectID		m_FaceStyle;
+
+	LwpObjectID		m_SizeStyle;
+	LwpObjectID		m_AttributeStyle;
+	LwpObjectID		m_FontStyle;
+	LwpObjectID		m_CharacterBorderStyle;
+	LwpObjectID		m_AmikakeStyle;
+	
+	sal_uInt32		m_nStyleDefinition;
+//	sal_uInt16		m_nBasedOnCount;
+	sal_uInt16		m_nKey;
+
+};
+
+inline sal_uInt32 LwpTextStyle::GetFinalFontID() const
+{
+	return m_nFinalFontID;
+}
+
+class LwpCharacterStyle : public LwpTextStyle
+{
+public:
+	LwpCharacterStyle(LwpObjectHeader& objHdr, LwpSvStream* pStrm);
+
+	void Read();
+	
+private:
+
+};
+
+#endif
diff -urNp lotuswordpro.bak/source/filter/lwpcharborderoverride.cxx lotuswordpro/source/filter/lwpcharborderoverride.cxx
--- lotuswordpro.bak/source/filter/lwpcharborderoverride.cxx	1970-01-01 08:00:00.000000000 +0800
+++ lotuswordpro/source/filter/lwpcharborderoverride.cxx	2008-10-22 11:42:29.000000000 +0800
@@ -0,0 +1,148 @@
+/*************************************************************************
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: IBM Corporation
+ *
+ *  Copyright: 2008 by IBM Corporation
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+/*************************************************************************
+ * @file 
+ *  For LWP filter architecture prototype
+ ************************************************************************/
+/*************************************************************************
+ * Change History
+ Jan 2005			Created
+ ************************************************************************/
+ 
+#include "lwpcharborderoverride.hxx"
+#include "lwpborderstuff.hxx"
+#include "lwpmargins.hxx"
+
+LwpCharacterBorderOverride::LwpCharacterBorderOverride() :
+m_pBorderStuff(new LwpBorderStuff), m_pMargins(new LwpMargins)
+{
+}
+
+LwpCharacterBorderOverride::~LwpCharacterBorderOverride()
+{
+	if (m_pBorderStuff)
+	{
+		delete m_pBorderStuff;
+	}
+	if (m_pMargins)
+	{
+		delete m_pMargins;
+	}
+}
+
+void LwpCharacterBorderOverride::Read(LwpObjectStream* pStrm)
+{
+	if (pStrm->QuickReadBool())
+	{
+		ReadCommon(pStrm);
+		m_pBorderStuff->Read(pStrm);
+		m_pMargins->Read(pStrm);
+		pStrm->QuickRead(&m_nAboveWidth, 4);
+		pStrm->QuickRead(&m_nBelowWidth, 4);
+	}
+
+	pStrm->SkipExtra();
+}
+
+void LwpCharacterBorderOverride::Override(LwpCharacterBorderOverride* pOther)
+{
+	if (m_nApply & PBO_STUFF)
+	{
+		if (this->IsBorderStuffOverridden())
+		{
+			pOther->OverrideBorderStuff(m_pBorderStuff);
+		}
+		else
+		{
+			pOther->RevertBorderStuff();
+		}
+	}
+
+	if (m_nApply & PBO_MARGINS)
+	{
+		if (this->IsMarginsOverridden())
+		{
+			pOther->OverrideMargins(m_pMargins);
+		}
+		else
+		{
+			pOther->RevertMargins();
+		}
+	}
+
+	if (m_nApply & PBO_ABOVE)
+	{
+		if (this->IsAboveWidthOverridden())
+		{
+			pOther->OverrideAboveWidth(m_nAboveWidth);
+		}
+		else
+		{
+			pOther->RevertAboveWidth();
+		}
+	}
+
+	if (m_nApply & PBO_BELOW)
+	{
+		if (this->IsBelowWidthOverridden())
+		{
+			pOther->OverrideBelowWidth(m_nBelowWidth);
+		}
+		else
+		{
+			pOther->RevertBelowWidth();
+		}
+	}
+}
\ No newline at end of file
diff -urNp lotuswordpro.bak/source/filter/lwpcharborderoverride.hxx lotuswordpro/source/filter/lwpcharborderoverride.hxx
--- lotuswordpro.bak/source/filter/lwpcharborderoverride.hxx	1970-01-01 08:00:00.000000000 +0800
+++ lotuswordpro/source/filter/lwpcharborderoverride.hxx	2008-10-22 11:42:29.000000000 +0800
@@ -0,0 +1,195 @@
+/*************************************************************************
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: IBM Corporation
+ *
+ *  Copyright: 2008 by IBM Corporation
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+/*************************************************************************
+ * @file 
+ *  For LWP filter architecture prototype
+ ************************************************************************/
+/*************************************************************************
+ * Change History
+ Jan 2005			Created
+ ************************************************************************/
+ 
+#ifndef _LWPCHARBORDEROVERRIDE_HXX
+#define _LWPCHARBORDEROVERRIDE_HXX
+
+#include "lwpoverride.hxx"
+
+class LwpBorderStuff;
+class LwpMargins;
+class LwpCharacterBorderOverride : public LwpOverride
+{
+public:
+	LwpCharacterBorderOverride();
+
+	virtual ~LwpCharacterBorderOverride();
+
+	void Read(LwpObjectStream* pStrm);
+
+	void Override(LwpCharacterBorderOverride* pOther);
+	
+	inline LwpBorderStuff* GetBorderStuff();
+	inline LwpMargins* GetMargins();
+	inline sal_Int32 GetAboveWidth() const;
+	inline sal_Int32 GetBelowWidth() const;
+
+	inline sal_Bool IsBorderStuffOverridden();
+	inline sal_Bool IsMarginsOverridden();
+	inline sal_Bool IsAboveWidthOverridden();
+	inline sal_Bool IsBelowWidthOverridden();
+
+	inline void OverrideBorderStuff(LwpBorderStuff* pOther);
+	inline void OverrideMargins(LwpMargins* pOther);
+	inline void OverrideAboveWidth(sal_Int32 nNewWidth);
+	inline void OverrideBelowWidth(sal_uInt32 nNewWidth);
+
+	inline void RevertBorderStuff();
+	inline void RevertMargins();
+	inline void RevertAboveWidth();
+	inline void RevertBelowWidth();
+	
+private:
+	LwpBorderStuff*	m_pBorderStuff;
+	LwpMargins*		m_pMargins;
+	sal_Int32		m_nAboveWidth;
+	sal_Int32		m_nBelowWidth;
+
+	enum
+	{
+		PBO_STUFF		= 0x01,
+		PBO_MARGINS 	= 0x04,
+		PBO_ABOVE		= 0x40,
+		PBO_BELOW		= 0x80
+	};
+};
+
+inline LwpMargins* LwpCharacterBorderOverride::GetMargins()
+{
+	return m_pMargins;
+}
+
+inline LwpBorderStuff* LwpCharacterBorderOverride::GetBorderStuff()
+{
+	return m_pBorderStuff;
+}
+
+inline sal_Int32 LwpCharacterBorderOverride::GetAboveWidth() const
+{
+	return m_nAboveWidth;
+}
+
+inline sal_Int32 LwpCharacterBorderOverride::GetBelowWidth() const
+{
+	return m_nBelowWidth;
+}
+
+inline sal_Bool LwpCharacterBorderOverride::IsBorderStuffOverridden()
+{
+	return (sal_Bool)((m_nOverride & PBO_STUFF) != 0);
+}
+
+inline sal_Bool LwpCharacterBorderOverride::IsMarginsOverridden()
+{
+	return (sal_Bool)((m_nOverride & PBO_MARGINS) != 0);
+}
+
+inline sal_Bool LwpCharacterBorderOverride::IsAboveWidthOverridden()
+{
+	return (sal_Bool)((m_nOverride & PBO_ABOVE) != 0);
+}
+
+inline sal_Bool LwpCharacterBorderOverride::IsBelowWidthOverridden()
+{
+	return (sal_Bool)((m_nOverride & PBO_BELOW) != 0);
+}
+
+inline void LwpCharacterBorderOverride::OverrideBorderStuff(LwpBorderStuff* pOther)
+{
+	m_pBorderStuff = pOther;
+	LwpOverride::Override(PBO_STUFF, STATE_ON);
+}
+inline void LwpCharacterBorderOverride::OverrideMargins(LwpMargins* pOther)
+{
+	m_pMargins = pOther;
+	LwpOverride::Override(PBO_MARGINS, STATE_ON);
+}
+inline void LwpCharacterBorderOverride::OverrideAboveWidth(sal_Int32 nNewWidth)
+{
+	m_nAboveWidth = nNewWidth;
+	LwpOverride::Override(PBO_ABOVE, STATE_ON);
+}
+inline void LwpCharacterBorderOverride::OverrideBelowWidth(sal_uInt32 nNewWidth)
+{
+	m_nBelowWidth = nNewWidth;
+	LwpOverride::Override(PBO_BELOW, STATE_ON);
+}
+
+inline void LwpCharacterBorderOverride::RevertBorderStuff()
+{
+	LwpOverride::Override(PBO_STUFF, STATE_STYLE);
+}
+inline void LwpCharacterBorderOverride::RevertMargins()
+{
+	LwpOverride::Override(PBO_MARGINS, STATE_STYLE);
+}
+inline void LwpCharacterBorderOverride::RevertAboveWidth()
+{
+	LwpOverride::Override(PBO_ABOVE, STATE_STYLE);
+}
+inline void LwpCharacterBorderOverride::RevertBelowWidth()
+{
+	LwpOverride::Override(PBO_BELOW, STATE_STYLE);
+}
+	
+#endif
diff -urNp lotuswordpro.bak/source/filter/lwpcharsetmgr.cxx lotuswordpro/source/filter/lwpcharsetmgr.cxx
--- lotuswordpro.bak/source/filter/lwpcharsetmgr.cxx	1970-01-01 08:00:00.000000000 +0800
+++ lotuswordpro/source/filter/lwpcharsetmgr.cxx	2008-10-22 11:42:29.000000000 +0800
@@ -0,0 +1,119 @@
+/*************************************************************************
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: IBM Corporation
+ *
+ *  Copyright: 2008 by IBM Corporation
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+/*************************************************************************
+ * @file 
+ *  For LWP filter architecture prototype
+ ************************************************************************/
+/*************************************************************************
+ * Change History
+ Jan 2005			Created
+ ************************************************************************/
+#include "lwpcharsetmgr.hxx"
+//Added by yanjun for SS migration : 2007-12-21
+#include "rtl/textenc.h"
+//End
+LwpCharSetMgr* LwpCharSetMgr::Instance = NULL;
+
+LwpCharSetMgr* LwpCharSetMgr::GetInstance()
+{
+   if (Instance == NULL) 
+       Instance = new LwpCharSetMgr;
+   return Instance;
+}
+
+void LwpCharSetMgr::SetCodePageMap()
+{//sal_uInt16 wordproCode,rtl_TextEncoding encoding, tmp hardcoding, 1-18
+/*	m_CodePageMap[256] =  
+	m_CodePageMap[259] = 
+	m_CodePageMap[819] = 
+	m_CodePageMap[921] =*/
+	m_CodePageMap[437]  = RTL_TEXTENCODING_ASCII_US;
+	m_CodePageMap[850]  = RTL_TEXTENCODING_IBM_850;  
+	//m_CodePageMap[851]  = RTL_TEXTENCODING_IBM_851; 
+	m_CodePageMap[852]  = RTL_TEXTENCODING_IBM_852;  
+	m_CodePageMap[857]  = RTL_TEXTENCODING_IBM_857; 
+	m_CodePageMap[860]  = RTL_TEXTENCODING_IBM_860; 
+	m_CodePageMap[863]  = RTL_TEXTENCODING_IBM_863;
+	m_CodePageMap[865]  = RTL_TEXTENCODING_IBM_865;
+	m_CodePageMap[866]  = RTL_TEXTENCODING_IBM_866; 
+	m_CodePageMap[869]  = RTL_TEXTENCODING_IBM_869; 	
+	m_CodePageMap[874]  = RTL_TEXTENCODING_MS_874;//thai
+	m_CodePageMap[932]  = RTL_TEXTENCODING_MS_932; //japanese
+	m_CodePageMap[936]  = RTL_TEXTENCODING_MS_936; //chinese simple	
+	m_CodePageMap[949]  = RTL_TEXTENCODING_MS_949;//korean
+	m_CodePageMap[950]  = RTL_TEXTENCODING_BIG5;//chinese traditional
+	m_CodePageMap[1250] = RTL_TEXTENCODING_MS_1250;//Central European
+	m_CodePageMap[1252] = RTL_TEXTENCODING_MS_1252;	
+	m_CodePageMap[1251] = RTL_TEXTENCODING_MS_1251; //ukrainian belarusian macedonian russian
+	m_CodePageMap[1253] = RTL_TEXTENCODING_MS_1253;//greek   
+	m_CodePageMap[1254] = RTL_TEXTENCODING_MS_1254;//Turkish
+	m_CodePageMap[1255] = RTL_TEXTENCODING_MS_1255;//hebrew	
+	m_CodePageMap[1256] = RTL_TEXTENCODING_MS_1256;//arabic	 
+	m_CodePageMap[1257] = RTL_TEXTENCODING_MS_1257;//estonian	 			
+}
+
+rtl_TextEncoding LwpCharSetMgr::GetTextCharEncoding(sal_uInt16 wordproCode)
+{
+    std::map<sal_uInt16,rtl_TextEncoding>::iterator 
+                                             pos = m_CodePageMap.find(wordproCode);
+    if (pos != m_CodePageMap.end())
+        return m_CodePageMap[wordproCode];
+    return GetTextCharEncoding();
+}
+
+rtl_TextEncoding LwpCharSetMgr::GetTextCharEncoding()
+{
+    return RTL_TEXTENCODING_MS_1252;//here should be a default value,1252 or get from platform,  1-18
+}
diff -urNp lotuswordpro.bak/source/filter/lwpcharsetmgr.hxx lotuswordpro/source/filter/lwpcharsetmgr.hxx
--- lotuswordpro.bak/source/filter/lwpcharsetmgr.hxx	1970-01-01 08:00:00.000000000 +0800
+++ lotuswordpro/source/filter/lwpcharsetmgr.hxx	2008-10-22 11:42:29.000000000 +0800
@@ -0,0 +1,87 @@
+/*************************************************************************
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: IBM Corporation
+ *
+ *  Copyright: 2008 by IBM Corporation
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+/*************************************************************************
+ * @file 
+ *  For LWP filter architecture prototype
+ ************************************************************************/
+/*************************************************************************
+ * Change History
+ Jan 2005			Created
+ ************************************************************************/
+#ifndef _LWPCHARSETMGR_HXX
+#define _LWPCHARSETMGR_HXX
+
+#include "lwpfilehdr.hxx"
+#include <map>
+//#include <pair>
+
+class LwpCharSetMgr
+{
+public:
+    LwpCharSetMgr(){SetCodePageMap();};
+    ~LwpCharSetMgr(){};
+    static LwpCharSetMgr* GetInstance();
+    void SetCodePageMap();
+	rtl_TextEncoding	GetTextCharEncoding(sal_uInt16 wordproCode);
+	rtl_TextEncoding	GetTextCharEncoding();		
+private:
+	std::map<sal_uInt16,rtl_TextEncoding> m_CodePageMap;
+	static LwpCharSetMgr* Instance;
+};
+
+
+
+#endif
+
diff -urNp lotuswordpro.bak/source/filter/lwpchartstreamtools.cxx lotuswordpro/source/filter/lwpchartstreamtools.cxx
--- lotuswordpro.bak/source/filter/lwpchartstreamtools.cxx	1970-01-01 08:00:00.000000000 +0800
+++ lotuswordpro/source/filter/lwpchartstreamtools.cxx	2008-10-22 11:42:29.000000000 +0800
@@ -0,0 +1,360 @@
+/*************************************************************************
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: IBM Corporation
+ *
+ *  Copyright: 2008 by IBM Corporation
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+/*****************************************************************************
+* Change History
+* <<Date>> <<Name of editor>> <<Description>>
+2005/2		draft code for implementation of chart stream helpers
+****************************************************************************/
+
+/**
+ * @file 
+ *  For LWP filter architecture prototype
+*/
+
+#include "lwpchartstreamtools.hxx"
+#include "xfilter/xfdrawchart.hxx"
+#include "xfilter/xfparagraph.hxx"
+
+#include <com/sun/star/xml/sax/SAXParseException.hpp>
+
+/**
+* @short   Get the chart stream from bento layer
+* @descr   
+* @param   pDocStream	the document stream
+* @param   pChartName	The name of the requested chart stream
+* @return  pStream		The chart stream, may be  NULL
+*/
+SvStream* LwpChartStreamTools::GetChartStream(LwpSvStream* pDocStream, const char* pChartName)
+{
+	// if small file, use the compressed stream for BENTO
+	LwpSvStream *pSvStream = pDocStream->GetCompressedStream() ?  pDocStream->GetCompressedStream(): pDocStream;
+
+	SvStream* pStream = NULL;
+	pSvStream->Seek(0);
+	OpenStormBento::LtcBenContainer* pContainer = NULL;;
+	ULONG nRet = OpenStormBento::BenOpenContainer(pSvStream,&pContainer);
+	if ( 0==nRet )
+	{
+		pStream = pContainer->FindValueStreamWithPropertyName(pChartName);
+	}
+	return pStream;
+}
+
+/**
+* @short   Output the chart into output stream
+* @param   aChartRect	the rectangle of the chart
+* @param   pXChartStrm	Chart stream 
+* @param   pOutputStream the output stream	
+*/
+void LwpChartStreamTools::OutputChart(XFRect aChartRect, IXFContent* pXChartStrm, IXFStream* pOutputStream)
+{
+	XFDrawChart* pXChart = new XFDrawChart;
+	pXChart->SetPosition(aChartRect);
+	pXChart->Add(pXChartStrm);
+
+	//write to xml
+	XFParagraph xpara;
+	xpara.Add(pXChart);
+	xpara.ToXml(pOutputStream);
+}
+
+void LwpChartStreamTools::OutputChart(XFRect aChartRect, IXFContent* pXChartStrm, XFContentContainer* pCont, OUString strStyleName)
+{
+	XFDrawChart* pXChart = new XFDrawChart;
+	pXChart->SetStyleName( strStyleName);
+	pXChart->SetPosition(aChartRect);
+	pXChart->SetAnchorType(enumXFAnchorFrame);
+	pXChart->Add(pXChartStrm);
+	
+	pCont->Add(pXChart);
+
+	//write to xml
+	/*XFParagraph*  pPara = new XFParagraph();
+	pPara->Add(pXChart);
+	pCont->Add(pPara);
+	*/
+}
+
+/**
+* @short   Get the stream length
+* @param   pStream	the stream 
+* @param   the stream length
+*/
+INT32 LwpChartStreamTools::GetStreamLen(SvStream* pStream)
+{
+	UINT32 nPos = pStream->Tell();
+	pStream->Seek(STREAM_SEEK_TO_END);
+	INT32 nStrmLen = pStream->Tell();
+	pStream->Seek(nPos);
+	return nStrmLen;
+}
+
+/**
+* @short   Make the chart storage object
+* @param   pStream	the chart stream
+* @param   aChartRect	the rectangle of the chart 
+* @param   xIPObj	[out]the inplace object
+* @param   xStorage	[out]the storage object of the chart
+*/
+#include "lwpchartwrapper.hxx"
+void LwpChartStreamTools::MakeChartStorage( SvStream* pStream, Rectangle aChartRect, SvInPlaceObjectRef& xIPObj, SvStorageRef& xStorage)
+{
+	//			SfxItemSet aItemSet( rDoc.GetAttrPool()); //Style of chart area
+	INT32 nStrmLen = GetStreamLen(pStream);
+	LtcLwpChartWrapper aChart(pStream,nStrmLen);
+	aChart.CreateChart(aChartRect,xIPObj,xStorage);
+	aChart.Read();
+}
+
+/**
+* @short   Translate the storage to XML stream
+* @param   xStorage	[out]the storage object of a chart 
+* @param   xIPObj	[in]the inplace object
+*/
+#include "schxmlwrapper.hxx"
+void LwpChartStreamTools::ChartToXML(SvStorageRef xStorage, SvInPlaceObjectRef xIPObj)
+{
+	xStorage->SetVersion( SOFFICE_FILEFORMAT_60 );
+
+	SfxInPlaceObjectRef aSfxObj( xIPObj );
+	SfxObjectShell* pSh = aSfxObj->GetObjectShell();
+	::com::sun::star::uno::Reference< ::com::sun::star::frame::XModel > xModel = pSh->GetModel();
+
+	SchXMLWrapper aFilter( xModel, *xStorage, sal_False );
+
+	// update user info before writing
+	pSh->UpdateDocInfoForSave();
+
+	aFilter.Export();
+}
+
+//void LwpChartStreamTools::ChartToXML(SvStorageRef xStorage, SvInPlaceObjectRef xIPObj)
+//{
+//	xStorage->SetVersion( SOFFICE_FILEFORMAT_60 );
+//
+//	SfxInPlaceObjectRef aSfxObj( xIPObj );
+//	SfxObjectShell* pSh = aSfxObj->GetObjectShell();
+//	pSh->Save();
+//}
+
+/**
+* @short	Get the xml stream from the storage
+* @param	xStorage	the storage object
+* @param	aStrmName	the stream name
+*/
+SvStorageStreamRef LwpChartStreamTools::GetStream(SvStorageRef xStorage, String aStrmName)
+{
+	SvStorageStreamRef rStream;
+	if( ! xStorage->IsStream( aStrmName) )
+	{
+		assert(false);
+	}
+	else
+	{
+		rStream = xStorage->OpenStream( aStrmName, STREAM_READ | STREAM_NOCREATE );
+	}
+	return rStream;
+}
+
+/**
+* @short	Dump the xml stream into a file
+*/
+void LwpChartStreamTools::DumpStream(SvStorageStreamRef rStream, char* aName)
+{
+	INT32 nLen = GetStreamLen(&rStream);
+	char* pBuf = new char[nLen]; 
+	rStream->Read(pBuf, nLen);
+	std::ofstream aFile(aName, ios_base::out);
+	aFile.write(pBuf,nLen);
+	rStream->Seek(0);
+}
+
+/**
+* @short	Get the name of chart stream
+* @param	pID	the id of the VO_Graphic object, which map to a chart stream.
+* @return	the name of the chart stream
+*/
+const char* LwpChartStreamTools::GetChartName(LwpObjectID* pID)
+{
+#define MAX_STREAMORSTORAGENAME 32 //The value is got from wordpro source
+	static char pChartName[MAX_STREAMORSTORAGENAME];
+
+	char aGrStrmPrefix[] = "Gr";
+	char aDataStrmSuffix[] = "-D";
+
+	sprintf( (char*)pChartName,"%s%lX,%lX%s", aGrStrmPrefix,pID->GetHigh(),
+		pID->GetLow(),aDataStrmSuffix);
+
+	return pChartName;
+}
+
+/**
+* @short   Parse the chart stream in Bento layer.
+* @descr   
+* @param   pOutputStream the pointer to IXFStream, which output the xml content. 
+* @return  
+* @todo any error code return are needed?
+*/
+void LwpChartStreamTools::ParseChart(	LwpSvStream* pDocStream,
+										LwpObjectID* pID,
+										Rectangle aRectIn100thMM,
+										XFRect aRectInCM,
+										IXFStream* pOutputStream)
+{
+	XFChartStream* pXFChartStrm = new XFChartStream;
+
+	try
+	{
+		//GetChartName
+		const char* pChartName = GetChartName(pID);
+
+		//Get chart stream
+		SvStream* pStream = GetChartStream( pDocStream, pChartName );
+		if (!pStream)
+		{
+			assert(false);
+			return;
+		}
+
+		SvInPlaceObjectRef xIPObj;
+		SvStorageRef xStorage;
+
+		MakeChartStorage( pStream, aRectIn100thMM, xIPObj, xStorage);
+		ChartToXML(xStorage, xIPObj);
+//		SvStorageStreamRef rStyleStream = GetStream(xStorage,String::CreateFromAscii( "styles.xml" ));
+		SvStorageStreamRef rCntStream = GetStream(xStorage,String::CreateFromAscii( "content.xml" ));
+//		DumpStream(rCntStream,"d:\\allinone.xml");
+		if (rCntStream.Is())
+		{
+			pXFChartStrm->SetChartStream(rCntStream);
+		}
+
+		OutputChart( aRectInCM, pXFChartStrm, pOutputStream);
+
+		delete pStream;
+	}
+	catch (com::sun::star::xml::sax::SAXParseException&) {
+		assert(false);
+	}
+	catch( com::sun::star::xml::sax::SAXException& )
+	{
+		assert(false);
+	}
+	catch( com::sun::star::io::IOException&)
+	{
+		assert(false);
+	}
+	catch( com::sun::star::uno::Exception&)
+	{
+		assert(false);
+	}
+}
+
+void LwpChartStreamTools::ParseChart(	LwpSvStream* pDocStream,
+										LwpObjectID* pID,
+										Rectangle aRectIn100thMM,
+										XFRect aRectInCM,
+										XFContentContainer* pCont,
+										OUString strStyleName)
+{
+	XFChartStream* pXFChartStrm = new XFChartStream;
+
+	try
+	{
+		//GetChartName
+		const char* pChartName = GetChartName(pID);
+
+		//Get chart stream
+		SvStream* pStream = GetChartStream( pDocStream, pChartName );
+		if (!pStream)
+		{
+			assert(false);
+			return;
+		}
+
+		SvInPlaceObjectRef xIPObj;
+		SvStorageRef xStorage;
+
+		MakeChartStorage( pStream, aRectIn100thMM, xIPObj, xStorage);
+		ChartToXML(xStorage, xIPObj);
+//		SvStorageStreamRef rStyleStream = GetStream(xStorage,String::CreateFromAscii( "styles.xml" ));
+		SvStorageStreamRef rCntStream = GetStream(xStorage,String::CreateFromAscii( "content.xml" ));
+//		DumpStream(rCntStream,"d:\\allinone.xml");
+		if (rCntStream.Is())
+		{
+			pXFChartStrm->SetChartStream(rCntStream);
+		}
+
+		OutputChart( aRectInCM, pXFChartStrm, pCont, strStyleName);
+
+		delete pStream;
+	}
+	catch (com::sun::star::xml::sax::SAXParseException& ) {
+		assert(false);
+	}
+	catch( com::sun::star::xml::sax::SAXException& )
+	{
+		assert(false);
+	}
+	catch( com::sun::star::io::IOException&)
+	{
+		assert(false);
+	}
+	catch( com::sun::star::uno::Exception&)
+	{
+		assert(false);
+	}
+}
+
diff -urNp lotuswordpro.bak/source/filter/lwpchartstreamtools.hxx lotuswordpro/source/filter/lwpchartstreamtools.hxx
--- lotuswordpro.bak/source/filter/lwpchartstreamtools.hxx	1970-01-01 08:00:00.000000000 +0800
+++ lotuswordpro/source/filter/lwpchartstreamtools.hxx	2008-10-22 11:42:29.000000000 +0800
@@ -0,0 +1,150 @@
+/*************************************************************************
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: IBM Corporation
+ *
+ *  Copyright: 2008 by IBM Corporation
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+/*****************************************************************************
+* Change History
+* <<Date>> <<Name of editor>> <<Description>>
+2005/2		draft code for chart stream helpers
+****************************************************************************/
+
+/**
+ * @file 
+ *  For LWP filter architecture prototype
+*/
+
+#ifndef LWPCHARTSTREAMTOOLS_HXX_
+#define LWPCHARTSTREAMTOOLS_HXX_
+
+#include <tools/stream.hxx>
+#include "bento.hxx"
+#include <tools/gen.hxx>
+#include <so3/ipobj.hxx>
+
+#include "lwpobjid.hxx"
+#include "lwpobjfactory.hxx"
+
+//For sax parser
+#ifndef _COM_SUN_STAR_XML_SAX_INPUTSOURCE_HPP_
+#include <com/sun/star/xml/sax/InputSource.hpp>
+#endif
+
+#ifndef _COM_SUN_STAR_XML_SAX_XDTDHANDLER_HPP_
+#include <com/sun/star/xml/sax/XDTDHandler.hpp>
+#endif
+
+#ifndef _COM_SUN_STAR_XML_SAX_XPARSER_HPP_
+#include <com/sun/star/xml/sax/XParser.hpp>
+#endif
+
+#ifndef _COMPHELPER_PROCESSFACTORY_HXX_
+#include <comphelper/processfactory.hxx>
+#endif
+
+//using namespace ::com::sun::star;
+using namespace ::rtl;
+using namespace comphelper;
+
+#include "xfilter/xfchartxmlhandler.hxx"
+#include "xfilter/xfrect.hxx"
+class IXFContent;
+
+/**
+* @brief
+* tools class for chart stream process
+*/
+
+class LwpChartStreamTools
+{
+public:
+	static SvStream* GetChartStream(LwpSvStream* pDocStream, const char* pChartName);
+
+	static void OutputChart(XFRect aChartRect, IXFContent* pXChartStrm, IXFStream* pOutputStream);
+
+	//Added by  for XFConvert refactor, 03/31/2005	
+	static void OutputChart(XFRect aChartRect, IXFContent* pXChartStrm, XFContentContainer* pCont, OUString strStyleName);
+	//End of Add
+
+	static INT32 GetStreamLen(SvStream* pStream);
+
+	static void MakeChartStorage(	SvStream* pStream, 
+		Rectangle aChartRect, 
+		SvInPlaceObjectRef& xIPObj,
+		SvStorageRef& xStorage);
+
+	static void ChartToXML(SvStorageRef xStorage, SvInPlaceObjectRef xIPObj);
+
+	static SvStorageStreamRef GetStream(SvStorageRef xStorage, String aStrmName);
+
+	static void DumpStream(SvStorageStreamRef rStream, char* aName);
+
+	static const char* GetChartName(LwpObjectID* pID);
+
+public:
+	static void ParseChart(	LwpSvStream* pDocStream, 
+							LwpObjectID* pID, 
+							Rectangle aRectIn100thMM,
+							XFRect aRectInCM,
+							IXFStream* pOutputStream);
+	//Added by  for XFConvert refactor, 03/31/2005
+	static void ParseChart(	LwpSvStream* pDocStream, 
+							LwpObjectID* pID, 
+							Rectangle aRectIn100thMM,
+							XFRect aRectInCM,
+							XFContentContainer* pCont,
+							OUString strStyleName);
+	//End of Add
+};
+
+#endif
+
diff -urNp lotuswordpro.bak/source/filter/lwpchartwrapper.cxx lotuswordpro/source/filter/lwpchartwrapper.cxx
--- lotuswordpro.bak/source/filter/lwpchartwrapper.cxx	1970-01-01 08:00:00.000000000 +0800
+++ lotuswordpro/source/filter/lwpchartwrapper.cxx	2008-10-22 11:42:29.000000000 +0800
@@ -0,0 +1,93 @@
+/*************************************************************************
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: IBM Corporation
+ *
+ *  Copyright: 2008 by IBM Corporation
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+
+#include "lwpchartwrapper.hxx"
+#include <sschart/charttools.hxx>
+using namespace NAME_CHART;
+
+LtcLwpChartWrapper::LtcLwpChartWrapper(SvStream* pStream,UINT32 nStrmLen)
+{
+	m_pImpChart.reset(new LtcImpChart(pStream,nStrmLen) );
+
+	m_spDatahandler.reset(new ltcDataWindowHandler());
+	m_pImpChart->SetData(m_spDatahandler);
+}
+
+sal_Bool LtcLwpChartWrapper::Read()
+{
+	sal_Bool bRet = sal_False;
+	m_pImpChart->SetStrmOffset(0);
+	chtFltError eRet = m_pImpChart->Read();
+	if (eChtERR_OK==eRet)
+	{
+		bRet = sal_True;
+	}
+	return bRet;
+}
+
+void LtcLwpChartWrapper::CreateChart(Rectangle aChartRect,SvInPlaceObjectRef& xIPObj,SvStorageRef& xStorage)
+{
+	m_pImpChart->CreateChartObj(aChartRect, xIPObj, xStorage);
+}
+
+//////////////////////////////////////////////////////////////////////////
+void LtcLwpChartDataHandler::ApplyAreaStyle()
+{
+	CHART_TYPE eChartType = GetChartType();
+	if ( eChartType==RADAR || eChartType==RADAR_AREA )
+	{
+		LtcChartTools::ApplyRadarDefaultArea(this,m_xChartDoc);
+	}
+}
diff -urNp lotuswordpro.bak/source/filter/lwpchartwrapper.hxx lotuswordpro/source/filter/lwpchartwrapper.hxx
--- lotuswordpro.bak/source/filter/lwpchartwrapper.hxx	1970-01-01 08:00:00.000000000 +0800
+++ lotuswordpro/source/filter/lwpchartwrapper.hxx	2008-10-22 11:42:29.000000000 +0800
@@ -0,0 +1,79 @@
+/*************************************************************************
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: IBM Corporation
+ *
+ *  Copyright: 2008 by IBM Corporation
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+#ifndef LWPCHARTWRAPPER_HXX_
+#define LWPCHARTWRAPPER_HXX_
+
+#include <sschart/ltcimpchart.hxx>
+#include <boost/shared_ptr.hpp>
+
+class LtcLwpChartWrapper 
+{
+public:
+	LtcLwpChartWrapper(SvStream* pStream,UINT32 nStrmLen);
+	sal_Bool Read();
+	void CreateChart(Rectangle aChartRect,SvInPlaceObjectRef& xIPObj,SvStorageRef& xStorage);
+
+private:
+	auto_ptr<NAME_CHART::LtcImpChart> m_pImpChart;
+	boost::shared_ptr<NAME_CHART::ltcDataWindowHandler> m_spDatahandler;
+};
+
+class LtcLwpChartDataHandler: public NAME_CHART::ltcDataWindowHandler
+{
+public:
+	void ApplyAreaStyle();
+};
+
+#endif
diff -urNp lotuswordpro.bak/source/filter/lwpcolor.cxx lotuswordpro/source/filter/lwpcolor.cxx
--- lotuswordpro.bak/source/filter/lwpcolor.cxx	1970-01-01 08:00:00.000000000 +0800
+++ lotuswordpro/source/filter/lwpcolor.cxx	2008-10-22 11:42:29.000000000 +0800
@@ -0,0 +1,149 @@
+/*************************************************************************
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: IBM Corporation
+ *
+ *  Copyright: 2008 by IBM Corporation
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+/*************************************************************************
+ * @file 
+ *  For LWP filter architecture prototype
+ ************************************************************************/
+/*************************************************************************
+ * Change History
+ Jan 2005			Created
+ ************************************************************************/
+
+#include "lwpcolor.hxx"
+/**
+ * @descr		read color and then resolve the RGB values
+*/
+void LwpColor::Read(LwpObjectStream *pStrm)
+{
+	pStrm->QuickRead(&m_nRed, sizeof(m_nRed));
+	pStrm->QuickRead(&m_nGreen, sizeof(m_nGreen));
+	pStrm->QuickRead(&m_nBlue, sizeof(m_nBlue));		
+	pStrm->QuickRead(&m_nExtra, sizeof(m_nExtra));
+	ResolveRGB();
+}
+
+/**
+ * @descr		return the BGR format
+*/
+sal_uInt32 LwpColor::To24Color()
+{
+	return ((m_nRed >> 8) | 
+				(m_nGreen & 0xFF00) |
+				(static_cast<sal_uInt32>((m_nBlue & 0xFF00) << 8)));
+}
+/**
+ * @descr		resolver RGB values per the extra bytes
+*/
+void LwpColor::ResolveRGB()
+{
+	switch(m_nExtra)
+	{
+		case AGLRGB_RGB:
+			break;
+		case AGLRGB_RED:
+			m_nRed = 0xFFFF;
+			m_nGreen = 0x0000;
+			m_nBlue = 0x0000;
+			break;
+		case AGLRGB_GREEN:
+			m_nRed = 0x0000;
+			m_nGreen = 0xFFFF;
+			m_nBlue = 0x0000;
+			break;
+		case AGLRGB_BLUE:
+			m_nRed = 0x0000;
+			m_nGreen = 0x0000;
+			m_nBlue = 0xFFFF;
+			break;
+		case AGLRGB_BLACK:
+			m_nRed = 0x0000;
+			m_nGreen = 0x0000;
+			m_nBlue = 0x0000;
+			break;
+		case AGLRGB_WHITE:
+			m_nRed = 0xFFFF;
+			m_nGreen = 0xFFFF;
+			m_nBlue = 0xFFFF;
+			break;
+		case AGLRGB_GRAY:
+			m_nRed = 0x8080;
+			m_nGreen = 0x8080;
+			m_nBlue = 0x8080;
+			break;			
+		case AGLRGB_LTGRAY:
+			m_nRed = 0xC0C0;
+			m_nGreen = 0xC0C0;
+			m_nBlue = 0xC0C0;
+			break;			
+		case AGLRGB_DKGRAY:
+			m_nRed = 0x4040;
+			m_nGreen = 0x4040;
+			m_nBlue = 0x4040;
+			break;			
+		case AGLRGB_INVALID:
+		case AGLRGB_TRANSPARENT:
+		default:
+			m_nRed = 0;
+			m_nGreen = 0;
+			m_nBlue = 0;
+		}
+}
+void LwpColor::operator = (const LwpColor& rOther)
+{
+	m_nRed = rOther.m_nRed;
+	m_nGreen = rOther.m_nGreen;
+	m_nBlue = rOther.m_nBlue;
+	m_nExtra = rOther.m_nExtra;
+}
diff -urNp lotuswordpro.bak/source/filter/lwpcolor.hxx lotuswordpro/source/filter/lwpcolor.hxx
--- lotuswordpro.bak/source/filter/lwpcolor.hxx	1970-01-01 08:00:00.000000000 +0800
+++ lotuswordpro/source/filter/lwpcolor.hxx	2008-10-22 11:42:29.000000000 +0800
@@ -0,0 +1,130 @@
+/*************************************************************************
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: IBM Corporation
+ *
+ *  Copyright: 2008 by IBM Corporation
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+/*************************************************************************
+ * @file 
+ *  For LWP filter architecture prototype
+ ************************************************************************/
+/*************************************************************************
+ * Change History
+ Jan 2005			Created
+ ************************************************************************/
+
+#ifndef _LWPCOLOR_HXX
+#define _LWPCOLOR_HXX
+
+#include "lwpobjstrm.hxx"
+#include "lwpheader.hxx"
+/**
+ * @brief	lwpcolor class
+ * 		(red, green, blue, extra)
+*/
+class LwpColor
+{
+public:
+	LwpColor():m_nRed(0), m_nGreen(0), m_nBlue(0), m_nExtra(0){};
+	~LwpColor(){};
+public:
+	void Read(LwpObjectStream *pStrm);
+	sal_uInt16 GetRed();
+	sal_uInt16 GetGreen();
+	sal_uInt16 GetBlue();
+	BOOL IsValidColor();
+	sal_uInt32 To24Color();
+	//add by , 01/26/2005
+	void operator = (const LwpColor& rOther);
+	//end
+	sal_Bool IsTransparent();
+private:
+	sal_uInt16 m_nRed;			// When extra is AGLRGB_INDEX, m_nRed holds the
+	sal_uInt16 m_nGreen;		// hi 16 bits and m_nGreen holds the lo 16 bits of
+	sal_uInt16 m_nBlue;		// the 32-bit LUT index.
+	sal_uInt16 m_nExtra;
+	enum ColorOverride {
+		  AGLRGB_RGB = 0,
+		  AGLRGB_BLACK = 1,
+		  AGLRGB_WHITE = 2,
+		  AGLRGB_GRAY = 3,
+		  AGLRGB_LTGRAY = 4,
+		  AGLRGB_DKGRAY = 5,
+		  AGLRGB_RED = 6,
+		  AGLRGB_GREEN = 7,
+		  AGLRGB_BLUE = 8,
+		  AGLRGB_INDEX = 98,
+		  AGLRGB_INVALID = 99,
+		  AGLRGB_TRANSPARENT = 100
+	};
+	void ResolveRGB();
+};
+inline sal_uInt16 LwpColor::GetRed()
+{
+	return m_nRed;
+}
+inline sal_uInt16 LwpColor::GetGreen()
+{
+	return m_nGreen;
+}
+inline sal_uInt16 LwpColor::GetBlue()
+{
+	return m_nBlue;
+}
+inline BOOL LwpColor::IsValidColor()
+{
+	return ((m_nExtra!=AGLRGB_INVALID) && (m_nExtra!=AGLRGB_TRANSPARENT));
+}
+inline sal_Bool LwpColor::IsTransparent()
+{
+	return (m_nExtra==AGLRGB_TRANSPARENT);
+}
+#endif
diff -urNp lotuswordpro.bak/source/filter/lwpcontent.cxx lotuswordpro/source/filter/lwpcontent.cxx
--- lotuswordpro.bak/source/filter/lwpcontent.cxx	1970-01-01 08:00:00.000000000 +0800
+++ lotuswordpro/source/filter/lwpcontent.cxx	2008-10-22 11:42:29.000000000 +0800
@@ -0,0 +1,154 @@
+/*************************************************************************
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: IBM Corporation
+ *
+ *  Copyright: 2008 by IBM Corporation
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+/*************************************************************************
+ * @file 
+ *  For LWP filter architecture prototype
+ ************************************************************************/
+/*************************************************************************
+ * Change History
+ Jan 2005			Created
+ ************************************************************************/
+
+#include "lwpstory.hxx"
+#include "lwpfilehdr.hxx"
+#include "lwpholder.hxx"
+
+LwpHeadContent::LwpHeadContent(LwpObjectHeader &objHdr, LwpSvStream* pStrm)
+	: LwpContent(objHdr, pStrm)
+{}
+
+
+void LwpHeadContent::Read()
+{
+	LwpContent::Read();
+	m_pObjStrm->SkipExtra();
+}
+
+LwpContent::LwpContent(LwpObjectHeader &objHdr, LwpSvStream* pStrm)
+	: LwpDLNFVList(objHdr, pStrm)
+{}
+void LwpContent::Read()
+{
+	LwpDLNFVList::Read();
+
+	LwpObjectStream* pStrm = m_pObjStrm;
+	
+	m_LayoutsWithMe.Read(pStrm);
+	//sal_uInt16 nFlagsSkip;
+	//pStrm->QuickRead(&nFlagsSkip, sizeof(nFlagsSkip));
+	pStrm->QuickRead(&m_nFlags, sizeof(m_nFlags));
+	m_nFlags &= ~(CF_CHANGED | CF_DISABLEVALUECHECKING);
+	//LwpAtomHolder ClassName;
+	//ClassName.Read(pStrm);
+	m_ClassName.Read(pStrm);
+	
+	LwpObjectID SkipID;
+	if(LwpFileHeader::m_nFileRevision >= 0x0006)
+	{
+		//SkipID.ReadIndexed(pStrm);
+		//SkipID.ReadIndexed(pStrm);
+		m_NextEnumerated.ReadIndexed(pStrm);
+		m_PreviousEnumerated.ReadIndexed(pStrm);
+	}
+
+	if (LwpFileHeader::m_nFileRevision >= 0x0007)
+	{
+		if(LwpFileHeader::m_nFileRevision < 0x000B)
+		{
+			SkipID.ReadIndexed(pStrm);
+			pStrm->SkipExtra();
+		}
+		else
+		{
+			sal_uInt8 HasNotify;
+			pStrm->QuickRead(&HasNotify, sizeof(HasNotify));
+			if(HasNotify)
+			{
+				SkipID.ReadIndexed(pStrm);
+				pStrm->SkipExtra();
+			}
+		}
+	}
+
+	pStrm->SkipExtra();
+}
+
+LwpVirtualLayout* LwpContent::GetLayout(LwpVirtualLayout* pStartLayout)
+{
+	return m_LayoutsWithMe.GetLayout(pStartLayout);
+}
+
+sal_Bool LwpContent::HasNonEmbeddedLayouts()
+{
+	LwpVirtualLayout* pLayout = NULL;
+	while(pLayout = GetLayout(pLayout))
+	{
+		if(!pLayout->NoContentReference())
+			return sal_True;
+	}
+	return sal_False;
+}
+
+sal_Bool LwpContent::IsStyleContent()
+{
+	LwpVirtualLayout* pLayout = NULL;
+	while(pLayout = GetLayout(pLayout))
+	{
+		if(pLayout->IsStyleLayout())
+			return sal_True;
+	}
+	return sal_False;
+}
+
diff -urNp lotuswordpro.bak/source/filter/lwpcontent.hxx lotuswordpro/source/filter/lwpcontent.hxx
--- lotuswordpro.bak/source/filter/lwpcontent.hxx	1970-01-01 08:00:00.000000000 +0800
+++ lotuswordpro/source/filter/lwpcontent.hxx	2008-10-22 11:42:29.000000000 +0800
@@ -0,0 +1,158 @@
+/*************************************************************************
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: IBM Corporation
+ *
+ *  Copyright: 2008 by IBM Corporation
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+/*************************************************************************
+ * @file 
+ *  LwpContent, LwpHeadContent: base class for Word Pro content object
+ ************************************************************************/
+/*************************************************************************
+ * Change History
+ Jan 2005			Created
+ ************************************************************************/
+
+#ifndef _LWPCONTENT_HXX
+#define _LWPCONTENT_HXX
+
+#include "lwpheader.hxx"
+#include "lwpobj.hxx"
+#include "lwpatomholder.hxx"
+#include "lwplayout.hxx"
+#include "lwphyperlinkmgr.hxx"
+/**
+ * @brief
+ * Base class of all Lwp content objects
+ */
+class LwpContent : public LwpDLNFVList
+{
+public:
+	LwpContent(LwpObjectHeader &objHdr, LwpSvStream* pStrm);
+	virtual ~LwpContent(){};
+protected:
+	LwpAssociatedLayouts m_LayoutsWithMe;
+	sal_uInt16 m_nFlags;
+	LwpAtomHolder m_ClassName;
+	LwpObjectID m_NextEnumerated;
+	LwpObjectID m_PreviousEnumerated;
+	/* Flag bits */
+	enum
+	{
+		CF_CHANGED				=	0x0001,
+		CF_MODIFIED				=	0x0004,
+		CF_LOCAL				=	0x0008,
+		CF_INFOOTNOTE			= 	0x0010,
+		CF_METACHANGED			=	0x0020,
+		CF_PRIVATE				=	0x0040,
+		CF_DEACTIVATED			=	0x0080,
+		CF_VALUECHANGED			=	0x0100,
+		CF_DISABLEVALUECHECKING	=	0x0200,
+		CF_DONTNOTIFYDOCUMENT	=	0x0400,		// for numeric formatting
+		CF_ISOVERRIDE			=	0x0800,
+		CF_ISBULLET				=	0x1000,
+		CF_CONTINUEDON			=	0x2000,
+		CF_CONTINUEDFROM		=	0x4000,
+
+		// Bits that should be transferred when we duplicate a content
+		CF_COPYMASK				= (CF_MODIFIED | CF_PRIVATE)
+	};
+protected:
+	void Read();
+public:
+	inline LwpAssociatedLayouts* GetLayoutsWithMe();
+	LwpVirtualLayout* GetLayout(LwpVirtualLayout* pStartLayout);
+	inline sal_Bool IsActive();
+	virtual sal_Bool IsTable();
+	inline OUString GetClassName();
+	inline LwpContent* GetNextEnumerated();
+	sal_Bool HasNonEmbeddedLayouts();
+	sal_Bool IsStyleContent();
+};
+
+LwpAssociatedLayouts* LwpContent::GetLayoutsWithMe()
+{
+	return &m_LayoutsWithMe;
+}
+
+inline sal_Bool LwpContent::IsActive()
+{
+	return !(m_nFlags & CF_DEACTIVATED);
+}
+
+inline sal_Bool LwpContent::IsTable()
+{
+	return sal_False;
+}
+
+inline OUString LwpContent::GetClassName()
+{
+	return m_ClassName.str();
+}
+
+inline LwpContent* LwpContent::GetNextEnumerated()
+{
+	return static_cast<LwpContent*>(m_NextEnumerated.obj());
+}
+/**
+ * @brief
+ * Head object of content list
+ */
+class LwpHeadContent : public LwpContent
+{
+public:
+	LwpHeadContent(LwpObjectHeader &objHdr, LwpSvStream* pStrm);
+	virtual ~LwpHeadContent(){};
+protected:
+	void Read();	
+};
+
+#endif
diff -urNp lotuswordpro.bak/source/filter/lwpdefobj.cxx lotuswordpro/source/filter/lwpdefobj.cxx
--- lotuswordpro.bak/source/filter/lwpdefobj.cxx	1970-01-01 08:00:00.000000000 +0800
+++ lotuswordpro/source/filter/lwpdefobj.cxx	2008-10-22 11:42:29.000000000 +0800
@@ -0,0 +1,88 @@
+/*************************************************************************
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: IBM Corporation
+ *
+ *  Copyright: 2008 by IBM Corporation
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+/*************************************************************************
+ * @file 
+ *  For LWP filter architecture prototype
+ ************************************************************************/
+/*************************************************************************
+ * Change History
+ Jan 2005			Created
+ ************************************************************************/
+
+#include "lwpdefobj.hxx"
+
+LwpDefaultObject::LwpDefaultObject(LwpObjectHeader &objHdr, LwpSvStream* pStrm)
+	:LwpObject(objHdr, pStrm),m_DataBuffer(NULL)
+{}
+
+LwpDefaultObject::~LwpDefaultObject()
+{
+	if(m_DataBuffer) 
+	{
+		delete [] m_DataBuffer;
+		m_DataBuffer = NULL;
+	}
+}
+
+void LwpDefaultObject::Read()
+{
+	if(m_DataBuffer)
+	{
+		delete [] m_DataBuffer;
+		m_DataBuffer = NULL;		
+	}
+	m_DataBuffer = new sal_uInt8[m_ObjHdr.GetSize()];
+	m_pObjStrm->QuickRead(m_DataBuffer, m_ObjHdr.GetSize());
+}
diff -urNp lotuswordpro.bak/source/filter/lwpdefobj.hxx lotuswordpro/source/filter/lwpdefobj.hxx
--- lotuswordpro.bak/source/filter/lwpdefobj.hxx	1970-01-01 08:00:00.000000000 +0800
+++ lotuswordpro/source/filter/lwpdefobj.hxx	2008-10-22 11:42:29.000000000 +0800
@@ -0,0 +1,81 @@
+/*************************************************************************
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: IBM Corporation
+ *
+ *  Copyright: 2008 by IBM Corporation
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+/*************************************************************************
+ * @file 
+ *  For LWP filter architecture prototype
+ ************************************************************************/
+/*************************************************************************
+ * Change History
+ Jan 2005			Created
+ ************************************************************************/
+
+#ifndef LWPDEFAULTOBJECT_HXX_
+#define LWPDEFAULTOBJECT_HXX_
+
+#include "lwpobj.hxx"
+#include "lwpheader.hxx"
+
+class LwpDefaultObject : public LwpObject
+{
+public:
+	LwpDefaultObject(LwpObjectHeader &objHdr, LwpSvStream* pStrm);
+	~LwpDefaultObject();
+private:
+	sal_uInt8 *m_DataBuffer;
+public:
+	//inline sal_uInt8* GetBuffer(){return m_DataBuffer;}
+	void Read();
+};
+#endif
diff -urNp lotuswordpro.bak/source/filter/lwpdefs.hxx lotuswordpro/source/filter/lwpdefs.hxx
--- lotuswordpro.bak/source/filter/lwpdefs.hxx	1970-01-01 08:00:00.000000000 +0800
+++ lotuswordpro/source/filter/lwpdefs.hxx	2008-10-22 11:42:29.000000000 +0800
@@ -0,0 +1,423 @@
+/*************************************************************************
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: IBM Corporation
+ *
+ *  Copyright: 2008 by IBM Corporation
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+/*************************************************************************
+ * @file 
+ *  definitions for all object types VO_TYPE
+ ************************************************************************/
+/*************************************************************************
+ * Change History
+ Jan 2005			Created
+ ************************************************************************/
+
+#ifndef _LWPDEFS_HXX
+#define _LWPDEFS_HXX
+
+#define BAD_OFFSET 0xFFFFFFFFUL
+#define BAD_ATOM ((sal_Int32)(-1))				// Invalid Atom ID
+
+//Please remove the item from the commented defines after you add the tag to the following enum.
+enum VO_TYPE
+{
+	VO_PARA = 0,
+	VO_DOCUMENT = 5,
+	VO_STORY = 13,
+	VO_VERQTR = 40,
+	VO_HEADCONTENT = 47,
+	VO_HEADLAYOUT = 142,
+	VO_PAGELAYOUT	= 143,	
+	VO_DOCSOCK = 155,
+	VO_DIVISIONINFO = 7,
+	VO_HEADHOLDER	 = 90,
+	VO_DIVOPTS	= 176,
+	VO_DOCDATA = 137,
+	VO_HEADERLAYOUT = 139,
+	VO_FOOTERLAYOUT =  140,
+	VO_FRAMELAYOUT	= 141,
+	VO_TOCSUPERTABLELAYOUT = 149,
+	VO_TOCLEVELDATA =	171,
+	VO_LAYOUTGEOMETRY	= 185,
+	VO_LAYOUTSCALE	= 186,
+	VO_LAYOUTMARGINS = 187,
+	VO_LAYOUTCOLUMNS = 188,
+	VO_LAYOUTBORDERSTUFF = 189,
+	VO_LAYOUTGUTTERSTUFF = 190,
+	VO_LAYOUTBACKGROUNDSTUFF = 191,
+	VO_LAYOUTJOINSTUFF = 192,
+	VO_LAYOUTSHADOW = 193,
+	VO_LAYOUTNUMERICS = 194,
+	 VO_LAYOUTRELATIVITY	 = 195,	
+	VO_LAYOUTEXTERNALBORDERSTUFF = 219,
+	VO_GRAPHIC = 41,
+	VO_VERGTR =	205,
+
+	//  01/12/2005
+	VO_PARASTYLE = 23,
+	VO_CHARACTERSTYLE = 106,
+	VO_SILVERBULLET = 127,
+	VO_ALIGNMENTPIECE = 196,
+	VO_INDENTPIECE = 197,
+	VO_SPACINGPIECE = 199,
+	VO_CHARBORDERPIECE = 202,
+	VO_AMIKAKEPIECE = 203,
+	// end
+	
+	// start
+	VO_TABRACK = 38,
+	VO_PARABORDERPIECE = 198,
+	VO_BREAKSPIECE = 200,
+	VO_NUMBERINGPIECE = 201,
+	VO_TABPIECE	= 204,
+	VO_PARABACKGROUNDPIECE = 218,
+	// end
+	// 02/01/2005
+	VO_SECTION = 136,
+	VO_INDEXSECTION = 48,
+	VO_HEADTAILHOLDER = 169,
+	VO_PAGEHINT	= 10,
+	VO_OBJECTHOLDER = 98,
+	VO_POBJECTHOLDER = 133,
+	//  added for OLE
+	VO_OLEOBJECT = 54,
+	// end OLE
+
+	//  added for table
+	VO_TABLE =				17,
+	VO_CELLLAYOUT	=		18,
+	VO_SUPERTABLELAYOUT	=	109,
+	VO_TABLELAYOUT	=		31,
+	VO_SUPERTABLE		=	115,
+	VO_ROWLAYOUT		=	32,
+	VO_ROWLIST			=	76,
+	VO_CELLLIST		=	74,
+	VO_NUMERICVALUE	=	123,
+	VO_FORMULAINFO	=	82,
+	VO_COLUMNLAYOUT	=	35,
+	VO_TABLERANGE		=	66,
+	VO_CELLRANGE		=	67,
+	VO_FOLDER			=	75,
+	VO_DEPENDENT		=	77,
+	VO_CONNECTEDCELLLAYOUT =	28,
+	VO_HIDDENCELLLAYOUT	=	29,
+	VO_TABLEHEADINGLAYOUT =	117,
+	VO_ROWHEADINGLAYOUT	=	118,
+	VO_TABLEHEADING	=		209,
+	VO_TABLEHINT		=	19,
+	// end table
+
+	//add by  
+	VO_DROPCAPLAYOUT = 217,
+	VO_CHBLKMARKER	= 94,
+	VO_PROPLIST = 165,
+	VO_BOOKMARK = 64,
+	VO_FIELDMARKER = 87,
+	//add end
+
+	//for footnote
+	VO_FOOTNOTE = 53,
+	VO_FOOTNOTEOPTS = 177,
+	VO_FOOTNOTELAYOUT = 65,
+	VO_FNROWLAYOUT = 59,
+	VO_FNCELLLAYOUT = 61,
+	VO_ENDNOTELAYOUT = 138,
+	VO_ENSUPERTABLELAYOUT = 113,
+	VO_FNSUPERTABLELAYOUT = 111,
+	VO_FOOTNOTETABLE = 58,
+	VO_CONTONLAYOUT = 145,
+	VO_CONTFROMLAYOUT = 146,
+
+	//for frame group
+	VO_GROUPLAYOUT = 108,
+	VO_GROUPFRAME = 173,
+
+	//For index manager
+	VO_ROOTLEAFOBJINDEX = 0xFFFB,		// Root Index with no kids	
+	VO_ROOTOBJINDEX = 0xFFFC,			// Root Index with kids
+	
+	//Add new type of index 
+	VO_OBJINDEX = 0xFFFD,				// Obj Index with kids
+	
+	VO_LEAFOBJINDEX	 = 0xFFFE	,		// Leaf Index
+
+	VO_LISTLIST = 100,
+
+	//For comment notes
+	VO_NOTELAYOUT = 159,
+	VO_NOTEHEADERLAYOUT = 178,
+	VO_NOTETEXTLAYOUT = 166,
+	VO_VPLAYOUT = 132,
+
+	// for parallel column
+	VO_SUPERPARALLELCOLUMNLAYOUT =	174,
+	VO_PCOLLAYOUT	=		206,
+	VO_PCOLBLOCK	=		207,
+	VO_PARALLELCOLUMNS	=	163,
+	
+	//for ruby mark
+	VO_RUBYMARKER	= 179,
+	VO_RUBYLAYOUT = 180,
+	
+	VO_GLOSSARY = 157,
+	VO_SUPERGLOSSARYLAYOUT = 175,
+	//for default tab distance
+	VO_VERDOCUMENT = 161,
+
+	
+	//The last one
+	VO_INVALID = -1
+};
+
+/*	
+	static const VO_OBJINDEX	= 0xFFFD	;			// Intermediate Level Index
+*/
+/*
+#define	VO_LAYOUT				1
+#define	VO_NOTIFY				2
+#define VO_LINE					3
+#define VO_PRESENT				4
+#define VO_PAGECONTAINER 		6
+#define VO_COLUMN				8
+#define VO_CELLGADGET			9
+#define VO_PAGEHINT				10
+#define VO_PANE					11
+#define VO_SUBPAGECONTAINER		12
+#define VO_TABSEG				14
+#define VO_FRAMECONTAINER 		15
+#define VO_LINEHINT				16
+#define	VO_TABLE				17
+#define VO_CELLLAYOUT			18
+#define VO_TABLEHINT			19
+#define VO_CELLCONTAINER		20
+#define VO_TABLECONTAINER		21
+#define VO_ROWCONTAINER			22
+
+#define VO_COVERCELLCONTAINER	24
+#define VO_HIDDENCELLCONTAINER	25
+#define VO_SPACESHAPE			26
+#define VO_TABLEHEADINGCONTAINER	27
+#define VO_CONNECTEDCELLLAYOUT	28
+#define VO_HIDDENCELLLAYOUT		29
+#define VO_SUPERLINE			30
+#define VO_TABLELAYOUT			31
+#define VO_ROWLAYOUT			32
+#define VO_TABLEROWCACHE		33
+#define VO_TABLECOLUMNCACHE		34
+#define VO_COLUMNLAYOUT			35
+#define VO_HANDLENODE			36
+#define VO_FORMATLISTNODE		37
+
+#define VO_TEMPPAGEHINT			39
+
+#define VO_COLLAPSEGADGET       42
+#define VO_PERMISSIVELAYOUT     43
+#define VO_ELEVATORGADGET		44
+#define VO_STORYMARKER			45
+#define VO_HEADCONTAINER		46
+
+
+#define	VO_NAMEDOUTLINESEQ		49
+#define VO_VIEWPORTCONTAINER	50
+#define VO_PRESENTATIONINFO		51
+#define VO_OBJECTINDEX			52
+
+#define VO_OLEOBJECT            54
+#define VO_FOOTNOTECONTAINER    55
+#define VO_LITTLEPAGEGADGET		56
+#define VO_OUTLINEBUTTONGADGET	57
+
+#define VO_FNROWLAYOUT			59
+#define VO_FNROWCONTAINER		60
+#define VO_FNCELLLAYOUT			61
+#define VO_FNCELLCONTAINER		62
+#define VO_3DBUTTONGADGET		63
+#define VO_BOOKMARK				64
+
+#define VO_TABLERANGE			66
+#define VO_CELLRANGE			67
+#define VO_REVLINEGADGET		68
+#define VO_REVCHARGADGET		69
+#define VO_SCROLLBUTTONGADGET	70
+#define VO_VSCROLLBARGADGET		71
+#define VO_HSCROLLBARGADGET		72
+#define VO_SCROLLBARGADGET		73
+#define VO_CELLLIST				74
+#define VO_FOLDER				75
+#define VO_ROWLIST				76
+#define VO_DEPENDENT			77
+#define VO_NUMBERHINT			78
+#define VO_MARKER				79
+#define VO_NOTEGADGET			80
+#define VO_DDELINK				81
+#define VO_FORMULAINFO			82
+#define VO_THUMBGADGET			83
+#define VO_GHOSTTHUMBGADGET		84
+#define VO_BOOKMARKGADGET		85
+#define VO_LINKGADGET			86
+
+#define VO_CHECKPOINT			88
+#define VO_STORYCHECKPOINT		89
+
+#define VO_TABLEMARKER			91
+#define VO_TABLECHECKPOINT		92
+#define VO_FOOTNOTELISTLIST		93
+#define VO_CHBLKMARKER			94
+#define VO_ROWGADGET			95
+#define VO_COLUMNGADGET			96
+#define VO_CORNERGADGET			97
+
+#define VO_GRAPHICOLECHECKPOINT	99
+
+#define VO_DEMANDLOADER			101
+#define VO_COLUMNSIZEGADGET		102
+#define VO_ROWSIZEGADGET		103
+#define VO_CELLMOVEGADGET		104
+#define VO_CELLSELECTIONGADGET	105
+#define VO_CHARACTERSTYLE		106
+#define VO_GROUPCONTAINER		107
+
+#define VO_SUPERTABLELAYOUT		109
+#define VO_SUPERTABLECONTAINER	110
+
+#define VO_FNSUPERTABLECONTAINER	112
+
+#define VO_ENSUPERTABLECONTAINER	114
+#define VO_SUPERTABLE			115
+#define VO_ROWCOLUMNSIZEGADGET	116
+#define VO_TABLEHEADINGLAYOUT	117
+#define VO_ROWHEADINGLAYOUT		118
+#define VO_TOMBSTONE			119
+#define VO_CAPTION				120
+#define VO_VERCONTROL			121
+#define VO_ANCHORGADGET			122
+#define VO_NUMERICVALUE			123
+#define VO_TEXTVALUE			124
+#define VO_REFERENCEVALUE		125
+#define VO_DLTREENODE			126
+
+#define VO_PARADATAHOLDER		128
+#define VO_NOTIFYPERSISTENT		129
+#define VO_TYPVERCONTROL		130
+#define VO_USRVERCONTROL		131
+#define VO_POBJECTHOLDER		133
+#define VO_CELLNUMBERHINT		134
+#define VO_STXINFO				135		// SmarText object
+
+
+
+
+
+
+
+#define VO_MARKERLIST			144
+
+#define VO_NAMEDVERCONTROL		147
+#define VO_DIRTBAG				148
+
+#define VO_OBJPTRHOLDER			150
+#define VO_COLUMNWIDTHCACHE		151
+#define VO_NOTIFYLISTHOLDER		152
+#define VO_OBJECTHOLDERNV		153
+#define VO_BASELINEGADGET		154
+
+#define VO_DLVOLISTHEADHOLDER	156
+#define VO_DELETEDTEXTGADGET	158
+
+#define VO_FOOTNOTESEEN			160
+
+#define VO_OUTLINESEQITEM		162
+
+#define VO_CHBGADGET			164
+#define VO_PROPLIST				165
+#define VO_STXMANAGER			167		// SmarText object
+#define VO_STXLINK				168		// SmarText object
+
+#define VO_VERPTR				170
+
+#define VO_VERDOCINFO			172
+
+
+#ifdef RUBY
+
+#define VO_RUBYGADGET			181
+#endif
+#define VO_OLEGADGET			182
+#define VO_AMIASWPSEUDOOBJHOLDER 183
+#define VO_LONGHOLDER			184
+
+
+#define VO_REVA_MAXTYPES		186
+
+
+
+#define VO_CONNECTEDBLOCK		208
+#define VO_TABLEHEADING			209
+#define VO_BOOKMARKMARKERLIST	210
+#define VO_FIELDMARKERLIST		211
+#define VO_CHBMARKERLIST		212
+#define VO_DDEMARKERLIST		213
+#define VO_RUBYMARKERLIST		214
+#ifdef RUBY
+#define VO_RUBYMARKERGADGET		215
+#endif
+#define VO_DROPCAPCONTAINER		216
+
+
+
+#define VO_LAYOUTEXTERNALJOINSTUFF		220
+
+
+#define VO_OBJINDEX				0xFFFD			// Intermediate Level Index
+*/
+
+#endif
diff -urNp lotuswordpro.bak/source/filter/lwpdivinfo.cxx lotuswordpro/source/filter/lwpdivinfo.cxx
--- lotuswordpro.bak/source/filter/lwpdivinfo.cxx	1970-01-01 08:00:00.000000000 +0800
+++ lotuswordpro/source/filter/lwpdivinfo.cxx	2008-10-22 11:42:29.000000000 +0800
@@ -0,0 +1,174 @@
+/*************************************************************************
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: IBM Corporation
+ *
+ *  Copyright: 2008 by IBM Corporation
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+/*************************************************************************
+ * @file 
+ *  For LWP filter architecture prototype
+ ************************************************************************/
+/*************************************************************************
+ * Change History
+ Jan 2005			Created
+ ************************************************************************/
+
+#include "lwpdivinfo.hxx"
+#include "lwpobjstrm.hxx"
+#include "lwpfilehdr.hxx"
+#include "lwpholder.hxx"
+#include "lwppagehint.hxx"
+
+LwpDivInfo::LwpDivInfo(LwpObjectHeader& objHdr, LwpSvStream* pStrm)
+	: LwpObject(objHdr, pStrm)
+{}
+
+LwpDivInfo::~LwpDivInfo(){}
+
+void LwpDivInfo::Read()
+{
+
+	SkipFront();
+	m_ParentID.ReadIndexed(m_pObjStrm);
+	if (LwpFileHeader::m_nFileRevision < 0x0006)
+	{
+		m_pObjStrm->SkipExtra();
+	}
+	m_Name.Read(m_pObjStrm);
+	if (LwpFileHeader::m_nFileRevision < 0x0006)
+	{
+		m_pObjStrm->SkipExtra();
+	}
+
+	m_LayoutID.ReadIndexed(m_pObjStrm);
+	m_pObjStrm->QuickRead(&m_nFlags, sizeof(m_nFlags));	
+	if (LwpFileHeader::m_nFileRevision < 0x0010)  // In 98, graphic links count too
+	{
+		if ((m_nFlags & DI_ANYOLEDDELINKS) == 0)
+			m_nFlags &= ~DI_KNOWIFANYOLEDDELINKS;
+	}
+
+	m_ExternalName.Read(m_pObjStrm);
+	m_ExternalType.Read(m_pObjStrm);
+	m_ClassName.Read(m_pObjStrm);
+	m_InitialLayoutID.ReadIndexed(m_pObjStrm);
+
+	m_pObjStrm->QuickRead(&m_nPageNoStyle, sizeof(m_nPageNoStyle));	
+	m_TabColor.Read(m_pObjStrm);
+
+	// read filler page stuff
+	m_FillerPageTextID.ReadIndexed(m_pObjStrm);
+
+	// read external file object stuff
+	sal_uInt16 type;
+	m_pObjStrm->QuickRead(&type, sizeof(type));		
+	//cpExternalFile = LNULL;
+
+	assert(type==0);
+	m_pObjStrm->SkipExtra();
+	
+}
+
+void LwpDivInfo::SkipFront()
+{
+	LwpObjectID toSkip;
+
+	toSkip.ReadIndexed(m_pObjStrm); // skip ListNext;
+	if (LwpFileHeader::m_nFileRevision < 0x0006)
+	{
+		m_pObjStrm->SkipExtra();
+	}
+ 	toSkip.ReadIndexed(m_pObjStrm);	// skip ListPrevious;
+	if (LwpFileHeader::m_nFileRevision < 0x0006)
+	{
+		m_pObjStrm->SkipExtra();
+	}
+	toSkip.ReadIndexed(m_pObjStrm);	// skip Head;
+	if (LwpFileHeader::m_nFileRevision < 0x0006)
+	{
+		toSkip.ReadIndexed(m_pObjStrm);	//skip tail
+		m_pObjStrm->SkipExtra();
+	}
+}
+
+void LwpDivInfo::GetNumberOfPages(sal_uInt16 & nPageno)
+{
+	if(IsGotoable())
+	{
+		if (IsOleDivision())
+		{
+			//not support now
+			return;
+		}
+		else
+		{
+			nPageno += GetMaxNumberOfPages();
+		}
+	}
+}
+
+sal_uInt16 LwpDivInfo::GetMaxNumberOfPages()
+{
+	LwpDocument* pDiv = GetDivision();
+	if(!pDiv)
+		return 0;
+	LwpDLVListHeadTailHolder* pHeadTail = static_cast<LwpDLVListHeadTailHolder*>(pDiv->GetPageHintsID()->obj());
+	if(pHeadTail)
+	{
+		LwpPageHint* pPageHint =static_cast<LwpPageHint*>(pHeadTail->GetTail()->obj());
+		if(pPageHint && !pPageHint->GetPageLayoutID()->IsNull())
+		{
+			return pPageHint->GetPageNumber();
+		}
+	}
+	
+	return 0;
+}
diff -urNp lotuswordpro.bak/source/filter/lwpdivinfo.hxx lotuswordpro/source/filter/lwpdivinfo.hxx
--- lotuswordpro.bak/source/filter/lwpdivinfo.hxx	1970-01-01 08:00:00.000000000 +0800
+++ lotuswordpro/source/filter/lwpdivinfo.hxx	2008-10-22 11:42:29.000000000 +0800
@@ -0,0 +1,166 @@
+/*************************************************************************
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: IBM Corporation
+ *
+ *  Copyright: 2008 by IBM Corporation
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+/*************************************************************************
+ * @file 
+ *  For LWP filter architecture prototype
+ ************************************************************************/
+/*************************************************************************
+ * Change History
+ Jan 2005			Created
+ ************************************************************************/
+
+#ifndef _LWPDIVINFO_HXX
+#define _LWPDIVINFO_HXX
+
+#include "lwpobj.hxx"
+#include "lwpobjid.hxx"
+#include "lwpatomholder.hxx"
+#include "lwpcolor.hxx"
+#include "lwpheader.hxx"
+#include "lwpdoc.hxx"
+
+#define STR_OleDivisionClassName	"OLEDivision"
+
+
+class LwpDivInfo : public LwpObject
+{
+public:
+	LwpDivInfo(LwpObjectHeader& objHdr, LwpSvStream* pStrm);
+	~LwpDivInfo();
+	LwpObjectID* GetInitialLayoutID(){ return &m_InitialLayoutID;}
+	LwpObjectID* GetFillerPageTextID(){ return &m_FillerPageTextID;}
+	// add by  ,03/14/2004
+	rtl::OUString GetDivName() { return m_Name.str(); }
+	// end add
+
+	rtl::OUString GetClassName() { return m_ClassName.str(); }
+	inline sal_Bool HasContents();
+	inline sal_Bool IsOleDivision();
+	inline sal_Bool IsScrollable();
+	inline sal_Bool IsGotoable();
+	inline LwpDocument* GetDivision();
+	void GetNumberOfPages(sal_uInt16& nPageno);
+	sal_uInt16 GetMaxNumberOfPages();
+	LwpAtomHolder* GetExternalName(){return &m_ExternalName;};
+protected:
+	void Read();
+private:
+	LwpObjectID m_ParentID;
+	LwpAtomHolder m_Name;	
+	LwpObjectID m_LayoutID;
+	sal_uInt16 m_nFlags;
+	LwpAtomHolder m_ExternalName;
+	LwpAtomHolder m_ExternalType;
+	LwpAtomHolder m_ClassName;
+	LwpObjectID m_InitialLayoutID;
+	//pCDLVOListHeadHolder cPresInfo;
+
+	sal_uInt16 m_nPageNoStyle;
+	LwpColor m_TabColor;
+	LwpObjectID m_FillerPageTextID;
+	
+	enum
+	{
+		DI_SCROLLABLE = 0x01,
+		DI_HASCONTENTS = 0x02,
+		DI_EXPANDED = 0x04,
+		DI_SHOWSTAB = 0x08,
+
+		DI_MUDPUPPY = 0x10,
+		DI_NOTDELETABLE = 0x20,
+		DI_BEGINGROUP = 0x40,
+		DI_GROUP = 0x80,
+
+		DI_ENDGROUP = 0x100,
+		DI_SUPPRESS_FILLER_PAGE_HEADERS = 0x200,
+		DI_EXTERNALFILE = 0x400,
+		DI_FIXED = 0x800,
+
+		DI_KNOWIFANYOLEDDELINKS = 0x1000,
+		DI_ANYOLEDDELINKS = 0x2000
+	};
+
+	void SkipFront();
+
+};
+
+inline sal_Bool LwpDivInfo::HasContents()
+{
+	return (m_nFlags & DI_HASCONTENTS) ? sal_True : sal_False;
+}
+
+inline sal_Bool LwpDivInfo::IsOleDivision()
+{
+	OUString strClassName = GetClassName();
+	if (strClassName.equals(A2OUSTR(STR_OleDivisionClassName)))
+		return sal_True;
+	return sal_False;
+}
+
+inline sal_Bool LwpDivInfo::IsScrollable()
+{
+	return (m_nFlags & DI_SCROLLABLE) ? sal_True : sal_False;
+}
+
+inline sal_Bool LwpDivInfo::IsGotoable()
+{
+	return HasContents() && (IsScrollable() || IsOleDivision());
+}
+
+inline LwpDocument* LwpDivInfo::GetDivision()
+{
+	return static_cast<LwpDocument*>(m_ParentID.obj());
+}
+#endif
diff -urNp lotuswordpro.bak/source/filter/lwpdivopts.cxx lotuswordpro/source/filter/lwpdivopts.cxx
--- lotuswordpro.bak/source/filter/lwpdivopts.cxx	1970-01-01 08:00:00.000000000 +0800
+++ lotuswordpro/source/filter/lwpdivopts.cxx	2008-10-22 11:42:29.000000000 +0800
@@ -0,0 +1,135 @@
+/*************************************************************************
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: IBM Corporation
+ *
+ *  Copyright: 2008 by IBM Corporation
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+/*************************************************************************
+ * @file 
+ *  For LWP filter architecture prototype
+ ************************************************************************/
+/*************************************************************************
+ * Change History
+ Jan 2005			Created
+ ************************************************************************/
+
+#include "lwpdivopts.hxx"
+#include "lwpfilehdr.hxx"
+
+LwpHyphenOptions::LwpHyphenOptions()
+{}
+
+LwpHyphenOptions::~LwpHyphenOptions()
+{}
+
+void LwpHyphenOptions::Read(LwpObjectStream *pStrm)
+{
+	pStrm->QuickRead(&m_nFlags, sizeof(m_nFlags));
+	pStrm->QuickRead(&m_nZoneBefore, sizeof(m_nZoneBefore));
+	pStrm->QuickRead(&m_nZoneAfter, sizeof(m_nZoneAfter));
+	pStrm->QuickRead(&m_nMaxLines, sizeof(m_nMaxLines));
+	pStrm->SkipExtra();
+}
+
+
+
+LwpTextLanguage::LwpTextLanguage(){};
+LwpTextLanguage::~LwpTextLanguage(){}
+
+void LwpTextLanguage::Read(LwpObjectStream *pStrm)
+{
+	pStrm->QuickRead(&m_nLanguage, sizeof(m_nLanguage));
+	pStrm->SkipExtra();
+
+	if( LwpFileHeader::m_nFileRevision <= 0x0a)
+		m_nLanguage = ConvertFrom96(m_nLanguage);
+}
+
+sal_uInt16 LwpTextLanguage::ConvertFrom96(sal_uInt16 orgLang)
+{
+	// Reading a Word Pro 96 into Word Pro 97
+	switch (orgLang)
+	{
+		case 0x2809U:						// AMI_MEDICAL 96
+			orgLang = 0x8409U;				//0x8409U		97
+			break;
+		case 0x2C09U:				   		// AMI_BRMEDICAL 96
+			orgLang = 0x8809U; 				// 0x8809U       97
+			break;
+		case 0x3409U:						// AMI_BRITISHMEDIZE 96
+			orgLang = 0x8C09U;  				// 0x8C09U           97
+			break;
+		case 0x3009U:						// AMI_BRITISHIZE 96
+			orgLang = 0x1009U; 				// 0x1009U        97
+			break;
+		case 0x819U: 						// AMI_RUSSIANIO  96
+			orgLang = 0x8419U;		  		// 0x8419U		  97
+			break;
+	}
+	return orgLang;
+}
+
+LwpDivisionOptions::LwpDivisionOptions(LwpObjectHeader& objHdr, LwpSvStream* pStrm)
+	: LwpObject(objHdr, pStrm)
+{}
+
+LwpDivisionOptions::~LwpDivisionOptions()
+{}
+
+void LwpDivisionOptions::Read()
+{
+	m_HyphOpts.Read(m_pObjStrm);
+	m_pObjStrm->QuickRead(&m_nOptionFlag, sizeof(m_nOptionFlag));
+	m_Lang.Read(m_pObjStrm);
+	m_pObjStrm->SkipExtra();
+}
+
+
diff -urNp lotuswordpro.bak/source/filter/lwpdivopts.hxx lotuswordpro/source/filter/lwpdivopts.hxx
--- lotuswordpro.bak/source/filter/lwpdivopts.hxx	1970-01-01 08:00:00.000000000 +0800
+++ lotuswordpro/source/filter/lwpdivopts.hxx	2008-10-22 11:42:29.000000000 +0800
@@ -0,0 +1,120 @@
+/*************************************************************************
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: IBM Corporation
+ *
+ *  Copyright: 2008 by IBM Corporation
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+/*************************************************************************
+ * @file 
+ *  For LWP filter architecture prototype
+ ************************************************************************/
+/*************************************************************************
+ * Change History
+ Jan 2005			Created
+ ************************************************************************/
+
+#ifndef _LWPDIVISIONOPTIONS_HXX
+#define _LWPDIVISIONOPTIONS_HXX
+
+#include "lwpobj.hxx"
+#include "lwpobjid.hxx"
+#include "lwpatomholder.hxx"
+#include "lwpcolor.hxx"
+#include "lwpheader.hxx"
+
+class LwpHyphenOptions
+{
+public:
+	LwpHyphenOptions();
+	~LwpHyphenOptions();
+	void Read(LwpObjectStream *pStrm);
+private:
+	sal_uInt16 m_nFlags;
+	sal_uInt16 m_nZoneBefore;
+	sal_uInt16 m_nZoneAfter;
+	sal_uInt16 m_nMaxLines;	
+};
+
+
+/* 
+Text languange.
+This class which holds identifiers for language and dialect.
+DESCRIPTION	You can mark text as being a certain language. When we spell
+	check or grammar check we'll use this info to determine which dictionary
+	to use.
+	The only reserved value is 0, which means "default language". The
+	default language is specified by the document.
+*/
+class LwpTextLanguage
+{
+public:
+	LwpTextLanguage();
+	~LwpTextLanguage();
+	void Read(LwpObjectStream *pStrm);
+private:
+	sal_uInt16 ConvertFrom96(sal_uInt16 orgLang);
+	sal_uInt16 m_nLanguage;	
+};
+
+
+class LwpDivisionOptions : public LwpObject
+{
+public:
+	LwpDivisionOptions(LwpObjectHeader& objHdr, LwpSvStream* pStrm);
+	~LwpDivisionOptions();
+protected:
+	void Read();
+private:
+	LwpHyphenOptions m_HyphOpts;
+	sal_uInt16 m_nOptionFlag;
+	LwpTextLanguage m_Lang;
+};
+#endif
diff -urNp lotuswordpro.bak/source/filter/lwpdllist.cxx lotuswordpro/source/filter/lwpdllist.cxx
--- lotuswordpro.bak/source/filter/lwpdllist.cxx	1970-01-01 08:00:00.000000000 +0800
+++ lotuswordpro/source/filter/lwpdllist.cxx	2008-10-22 11:42:29.000000000 +0800
@@ -0,0 +1,99 @@
+/*************************************************************************
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: IBM Corporation
+ *
+ *  Copyright: 2008 by IBM Corporation
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+/*************************************************************************
+ * @file 
+ *  double linked class implementation
+ ************************************************************************/
+/*************************************************************************
+ * Change History
+ Jan 2005			Created
+ ************************************************************************/
+
+#include "lwpdllist.hxx"
+
+LwpDLList::LwpDLList(LwpDLList* Next, LwpDLList* Previous)
+{
+	insert(Next, Previous);
+}
+
+LwpDLList::LwpDLList(void)
+{
+	m_pNext = m_pPrevious = NULL;
+}
+
+void
+LwpDLList::insert(LwpDLList* Next,LwpDLList* Previous)
+{
+	if (Next)
+		Next->SetPrevious(this);
+	if (Previous)
+        Previous->SetNext(this);
+	m_pNext = Next;
+	m_pPrevious = Previous;
+}
+
+LwpDLList::~LwpDLList(void)
+{
+	remove();
+}
+
+void LwpDLList::remove()
+{
+	/* fix up other links */
+	if(m_pPrevious)
+		m_pPrevious->SetNext(m_pNext);
+	if(m_pNext)
+		m_pNext->SetPrevious(m_pPrevious);
+}
diff -urNp lotuswordpro.bak/source/filter/lwpdllist.hxx lotuswordpro/source/filter/lwpdllist.hxx
--- lotuswordpro.bak/source/filter/lwpdllist.hxx	1970-01-01 08:00:00.000000000 +0800
+++ lotuswordpro/source/filter/lwpdllist.hxx	2008-10-22 11:42:29.000000000 +0800
@@ -0,0 +1,104 @@
+/*************************************************************************
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: IBM Corporation
+ *
+ *  Copyright: 2008 by IBM Corporation
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+/*************************************************************************
+ * @file 
+ *  double linked list
+ ************************************************************************/
+/*************************************************************************
+ * Change History
+ Jan 2005			Created
+ ************************************************************************/
+
+#ifndef _LWPDLLIST_HXX_
+#define _LWPDLLIST_HXX_
+#include "lwpheader.hxx"
+class LwpDLList
+{
+public:
+	LwpDLList(LwpDLList*,LwpDLList*);
+	LwpDLList(void);
+	virtual ~LwpDLList();
+	void insert(LwpDLList*, LwpDLList*);
+	void remove(void);
+	LwpDLList* GetNext(void);
+	LwpDLList* GetPrevious(void);
+	void SetNext(LwpDLList*);
+	void SetPrevious(LwpDLList*);
+private:
+	LwpDLList* m_pNext;
+	LwpDLList* m_pPrevious;
+};
+
+inline LwpDLList* LwpDLList::GetNext(void)
+{
+	return m_pNext;
+}
+
+inline void LwpDLList::SetNext(LwpDLList* Next)
+{
+	m_pNext = Next;
+}
+
+inline LwpDLList* LwpDLList::GetPrevious(void)
+{
+	return m_pPrevious;
+}
+
+inline void LwpDLList::SetPrevious(LwpDLList* Previous)
+{
+	m_pPrevious = Previous;
+}
+
+#endif
diff -urNp lotuswordpro.bak/source/filter/lwpdlvlist.cxx lotuswordpro/source/filter/lwpdlvlist.cxx
--- lotuswordpro.bak/source/filter/lwpdlvlist.cxx	1970-01-01 08:00:00.000000000 +0800
+++ lotuswordpro/source/filter/lwpdlvlist.cxx	2008-10-22 11:42:29.000000000 +0800
@@ -0,0 +1,185 @@
+/*************************************************************************
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: IBM Corporation
+ *
+ *  Copyright: 2008 by IBM Corporation
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+/*************************************************************************
+ * @file 
+ *  list class implementation
+ ************************************************************************/
+/*************************************************************************
+ * Change History
+ Jan 2005			Created
+ ************************************************************************/
+
+#include "lwpdlvlist.hxx"
+#include "lwpfilehdr.hxx"
+#include "lwpproplist.hxx"
+
+LwpDLVList::LwpDLVList(LwpObjectHeader &objHdr, LwpSvStream* pStrm)
+	: LwpObject(objHdr, pStrm)
+{}
+/**
+ * @descr		Read LwpDLVList data from object stream
+ **/
+void LwpDLVList::Read()
+{
+	LwpObjectStream* pObjStrm = m_pObjStrm;
+	m_ListNext.ReadIndexed(pObjStrm);
+	if( LwpFileHeader::m_nFileRevision < 0x0006 )
+		pObjStrm->SkipExtra();
+
+	m_ListPrevious.ReadIndexed(pObjStrm);
+	if( LwpFileHeader::m_nFileRevision < 0x0006 )
+		pObjStrm->SkipExtra();
+
+}
+LwpDLNFVList::LwpDLNFVList(LwpObjectHeader &objHdr, LwpSvStream* pStrm)
+		: LwpDLVList(objHdr, pStrm)
+{}
+/**
+ * @descr		Read LwpDLNFVList data from object stream
+ **/
+void LwpDLNFVList::Read()
+{
+	LwpDLVList::Read();
+
+	LwpObjectStream* pObjStrm = m_pObjStrm;
+		
+	m_ChildHead.ReadIndexed(pObjStrm);
+	if( LwpFileHeader::m_nFileRevision < 0x0006 || !m_ChildHead.IsNull() )
+		m_ChildTail.ReadIndexed(pObjStrm);
+	if( LwpFileHeader::m_nFileRevision < 0x0006 )
+		pObjStrm->SkipExtra();
+
+	m_Parent.ReadIndexed(pObjStrm);
+	if( LwpFileHeader::m_nFileRevision < 0x0006 )
+		pObjStrm->SkipExtra();
+
+	ReadName(pObjStrm);	
+}
+/**
+ * @descr		Read name of LwpDLNFVList from object stream
+ **/
+void LwpDLNFVList::ReadName(LwpObjectStream* pObjStrm)
+{
+	m_Name.Read(pObjStrm);
+	if( LwpFileHeader::m_nFileRevision < 0x0006 )
+		pObjStrm->SkipExtra();
+}
+/**
+ * @descr		ctor of LwpDLNFPVList from object stream
+ *			Note that m_bHasProperties is initialized to true
+ **/
+LwpDLNFPVList::LwpDLNFPVList(LwpObjectHeader &objHdr, LwpSvStream* pStrm)
+	: LwpDLNFVList(objHdr, pStrm),
+	m_bHasProperties(sal_True),m_pPropList(NULL)
+{}
+/**
+ * @descr		Read name of LwpDLNFVList from object stream
+ **/
+void LwpDLNFPVList::Read()
+{
+	LwpDLNFVList::Read();
+
+	LwpObjectStream* pObjStrm = m_pObjStrm;
+	ReadPropertyList(pObjStrm);
+	pObjStrm->SkipExtra();
+}
+/**
+ * @descr		Read property list
+ **/
+void LwpDLNFPVList::ReadPropertyList(LwpObjectStream* pObjStrm)
+{
+	if( LwpFileHeader::m_nFileRevision >= 0x0000B)
+	{
+		pObjStrm->QuickRead(&m_bHasProperties, sizeof(m_bHasProperties));
+		if (m_bHasProperties)
+		{
+			m_pPropList = new LwpPropList;
+			m_pPropList->Read(pObjStrm);
+		}
+	}
+}
+/**
+ * @descr		release property list
+ **/
+LwpDLNFPVList::~LwpDLNFPVList()
+{
+	if(m_pPropList)
+	{
+		delete m_pPropList;
+	}
+}
+
+/**
+ * @descr		Read head id and tail id
+ **/
+void LwpDLVListHeadTail::Read(LwpObjectStream* pObjStrm)
+{
+	m_ListHead.ReadIndexed(pObjStrm);
+	if( (LwpFileHeader::m_nFileRevision < 0x0006) || !m_ListHead.IsNull())
+	{
+		m_ListTail.ReadIndexed(pObjStrm);
+	}
+	if( LwpFileHeader::m_nFileRevision < 0x0006)
+	{
+		pObjStrm->SkipExtra();
+	}
+}
+/**
+ * @descr		Read head id
+ **/
+void LwpDLVListHead::Read(LwpObjectStream* pObjStrm)
+{
+	m_objHead.ReadIndexed(pObjStrm);
+}
diff -urNp lotuswordpro.bak/source/filter/lwpdlvlist.hxx lotuswordpro/source/filter/lwpdlvlist.hxx
--- lotuswordpro.bak/source/filter/lwpdlvlist.hxx	1970-01-01 08:00:00.000000000 +0800
+++ lotuswordpro/source/filter/lwpdlvlist.hxx	2008-10-22 11:42:29.000000000 +0800
@@ -0,0 +1,205 @@
+/*************************************************************************
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: IBM Corporation
+ *
+ *  Copyright: 2008 by IBM Corporation
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+/*************************************************************************
+ * @file 
+ *  list related class
+ ************************************************************************/
+/*************************************************************************
+ * Change History
+ Jan 2005			Created
+ ************************************************************************/
+
+#ifndef LWPDLVLIST_HXX_
+#define LWPDLVLIST_HXX_
+
+#include "lwpatomholder.hxx"
+#include "lwpobj.hxx"
+/**
+ * @brief	Double Linked Virtual List
+*/
+class LwpDLVList : public LwpObject
+{
+public:
+	LwpDLVList(LwpObjectHeader &objHdr, LwpSvStream* pStrm);
+	virtual ~LwpDLVList(){};
+protected:
+	LwpObjectID m_ListPrevious;
+	LwpObjectID m_ListNext;
+protected:
+	void Read();	
+public:
+	inline LwpObjectID* GetNext();
+	inline LwpObjectID* GetPrevious();
+};
+LwpObjectID* LwpDLVList::GetNext()
+{
+	return &m_ListNext;
+}
+LwpObjectID* LwpDLVList::GetPrevious()
+{ 
+	return &m_ListPrevious;
+}
+/**
+ * @brief	Double Linked Named Family Virtual List
+*/
+class LwpDLNFVList : public LwpDLVList
+{
+public:
+	LwpDLNFVList(LwpObjectHeader &objHdr, LwpSvStream* pStrm);
+	virtual ~LwpDLNFVList(){};
+protected:
+	LwpObjectID m_ChildHead;	
+	LwpObjectID m_ChildTail;	
+	LwpObjectID m_Parent;
+	LwpAtomHolder m_Name;
+protected:
+	void Read();
+	void ReadName(LwpObjectStream* pObjStrm);		
+public:
+	// 01/17/2005
+	inline LwpAtomHolder* GetName();
+	//end
+	inline LwpObjectID* GetChildHead();
+	inline LwpObjectID* GetChildTail();
+	inline LwpObjectID* GetParent();
+};
+
+LwpAtomHolder* LwpDLNFVList::GetName()
+{
+	return &m_Name;
+}
+
+LwpObjectID* LwpDLNFVList::GetChildHead()
+{
+	return &m_ChildHead;
+}
+
+LwpObjectID* LwpDLNFVList::GetChildTail()
+{
+	return &m_ChildTail;
+}
+
+LwpObjectID* LwpDLNFVList::GetParent()
+{ 
+	return &m_Parent;
+}
+
+class LwpPropList;
+/**
+ * @brief	Double Linked Named Family Properties Virtual List
+*/
+class LwpDLNFPVList : public LwpDLNFVList
+{
+public:
+	LwpDLNFPVList(LwpObjectHeader &objHdr, LwpSvStream* pStrm);
+	virtual ~LwpDLNFPVList();
+protected:
+	sal_Bool m_bHasProperties;
+	LwpPropList* m_pPropList;
+protected:
+	void Read();
+	void ReadPropertyList(LwpObjectStream* pObjStrm);
+public:
+	inline LwpPropList* GetPropList();
+};
+
+LwpPropList* LwpDLNFPVList::GetPropList()
+{
+	return m_pPropList;
+}
+
+/**
+ * @brief	Double Linked Virtual List Head Tail
+*/
+class LwpDLVListHeadTail
+{
+public:
+	LwpDLVListHeadTail(){};
+	void Read(LwpObjectStream* pObjStrm);
+private:
+	LwpObjectID m_ListHead;
+	LwpObjectID m_ListTail;
+public:
+	inline LwpObjectID* GetHead();
+	inline LwpObjectID* GetTail();
+};
+LwpObjectID* LwpDLVListHeadTail::GetHead()
+{
+	return &m_ListHead;
+}
+LwpObjectID* LwpDLVListHeadTail::GetTail()
+{
+	return &m_ListTail;
+}
+
+/**
+ * @brief	Double Linked Virtual List Head
+*/
+class LwpDLVListHead
+{
+public:
+	LwpDLVListHead(){};
+	~LwpDLVListHead(){};
+	void Read(LwpObjectStream* pObjStrm);
+	inline LwpObjectID* GetFirst();
+protected:
+	LwpObjectID m_objHead;//LwpDLVList
+};
+LwpObjectID* LwpDLVListHead::GetFirst()
+{
+	return &m_objHead;
+}
+
+#endif
diff -urNp lotuswordpro.bak/source/filter/lwpdoc.cxx lotuswordpro/source/filter/lwpdoc.cxx
--- lotuswordpro.bak/source/filter/lwpdoc.cxx	1970-01-01 08:00:00.000000000 +0800
+++ lotuswordpro/source/filter/lwpdoc.cxx	2008-10-22 11:42:29.000000000 +0800
@@ -0,0 +1,830 @@
+/*************************************************************************
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: IBM Corporation
+ *
+ *  Copyright: 2008 by IBM Corporation
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+#include "lwpglobalmgr.hxx"
+#include "lwpdoc.hxx"
+#include "lwpfootnote.hxx"
+#include "lwppagehint.hxx"
+#include "lwpdivinfo.hxx"
+#include "lwpholder.hxx"
+#include "lwpparastyle.hxx"
+#include "lwpstory.hxx"
+#include "lwppara.hxx"
+#include "lwpsilverbullet.hxx"
+#include "lwplayout.hxx"
+#include "lwppagelayout.hxx"
+#include "xfilter/xfstylemanager.hxx"
+#ifndef _OSL_THREAD_H_
+#include <osl/thread.h>
+#endif
+
+LwpDocument::LwpDocument(LwpObjectHeader& objHdr, LwpSvStream* pStrm)
+	: LwpDLNFPVList(objHdr, pStrm), m_pLnOpts(NULL)
+{}
+
+LwpDocument::~LwpDocument()
+{
+	if(m_pLnOpts)
+	{
+		delete m_pLnOpts;
+	}
+	if(m_pFoundry)
+	{
+		delete m_pFoundry;
+	}
+}
+/**
+ * @descr	Read VO_Document from object stream
+ **/
+void LwpDocument::Read()
+{
+	LwpDLNFPVList::Read();
+		
+	ReadPlug();
+	
+	m_pObjStrm->QuickRead(&m_nPersistentFlags, sizeof(m_nPersistentFlags)); 
+
+	//Skip the SortOption and UIDocument
+	{
+		LwpSortOption m_DocSort( m_pObjStrm );
+		LwpUIDocument m_UIDoc( m_pObjStrm );
+	}
+
+	m_pLnOpts = new LwpLineNumberOptions(m_pObjStrm);	
+	
+	//Skip LwpUserDictFiles
+	{
+		LwpUserDictFiles m_UsrDicts( m_pObjStrm );
+	}
+
+	if( !IsChildDoc())
+	{
+		//Skip LwpPrinterInfo
+		LwpPrinterInfo m_PrtInfo( m_pObjStrm );
+	}
+	
+	m_pFoundry = new LwpFoundry(m_pObjStrm, this);
+	
+	m_DivOpts.ReadIndexed(m_pObjStrm);
+
+	if(!IsChildDoc())
+	{
+		m_FootnoteOpts.ReadIndexed(m_pObjStrm);
+		m_DocData.ReadIndexed(m_pObjStrm);
+	}
+	else
+	{
+		//Skip the docdata used in old version
+		LwpObjectID dummyDocData;
+		dummyDocData.ReadIndexed(m_pObjStrm);
+	}
+	m_DivInfo.ReadIndexed(m_pObjStrm);
+	m_Epoch.Read(m_pObjStrm);
+	m_WYSIWYGPageHints.ReadIndexed(m_pObjStrm);
+	m_VerDoc.ReadIndexed(m_pObjStrm);
+	m_STXInfo.ReadIndexed(m_pObjStrm);
+}
+
+/**
+ * @descr	Read plug related data from m_pObjStram
+ **/
+void LwpDocument::ReadPlug()
+{
+	m_DocSockID.ReadIndexed(m_pObjStrm);
+	m_pObjStrm->QuickRead(&m_nFlags, sizeof(m_nFlags));
+	m_pObjStrm->SkipExtra();
+}
+
+/**
+ * @descr	Parse obj to IXFStream
+ **/
+void LwpDocument::Parse(IXFStream* pOutputStream)
+{
+	//check the name and skip script division
+	if (!IsSkippedDivision())
+	{
+		//the frames which anchor are to page must output before other contents
+		ParseFrameInPage(pOutputStream);
+		ParseDocContent(pOutputStream);
+	}
+
+	LwpObject* pDocSock = GetSocket()->obj( VO_DOCSOCK );
+	if(pDocSock!=NULL)
+	{
+		pDocSock->Parse(pOutputStream);
+	}
+}
+
+sal_Bool LwpDocument::IsSkippedDivision()
+{
+	OUString sDivName;
+	sal_uInt8 ret = sal_False;
+	LwpDivInfo* pDiv = static_cast<LwpDivInfo*>(GetDivInfoID()->obj(VO_DIVISIONINFO));
+	if (pDiv == NULL)
+		return sal_True;
+	sDivName = pDiv->GetDivName();
+	if (sDivName.getLength()>0 && !pDiv->IsGotoable())//including toa,scripts division
+		return sal_True;
+	//skip endnote division
+	OUString strClassName = pDiv->GetClassName();
+	if (strClassName.equals(A2OUSTR(STR_DivisionEndnote)) 
+		|| strClassName.equals(A2OUSTR(STR_DivisionGroupEndnote))
+		|| strClassName.equals(A2OUSTR(STR_DocumentEndnote)))
+	{
+		LwpPageLayout* pPageLayout =static_cast<LwpPageLayout*>(pDiv->GetInitialLayoutID()->obj(VO_PAGELAYOUT));
+		if(pPageLayout)
+		{
+			LwpStory* pStory = static_cast<LwpStory*>(pPageLayout->GetContent()->obj(VO_STORY));
+			if(pStory)
+			{
+				//This judgement maybe have problem. If there is only one para in the story,
+				//this endnote division has no other contents except endnote table.
+				LwpObjectID* pFirst = pStory->GetFirstPara();
+				LwpObjectID* pLast = pStory->GetLastPara();
+				if(*pFirst == *pLast)
+					ret = sal_True;
+			}
+		}
+	}
+	return ret;
+}
+
+/**
+ * @descr  Register all styles in this division
+ */
+void LwpDocument::RegisterStyle()
+{
+	RegisterDefaultParaStyles();
+	RegisterGraphicsStyles();
+	RegisterBulletStyles();
+
+	RegisterTextStyles();
+	RegisterLayoutStyles();
+	RegisterStylesInPara();
+
+	RegisterLinenumberStyles();
+	RegisterFootnoteStyles();
+	
+	//Register styles in other document connected with this document: next doc, children doc
+	LwpObject* pDocSock = GetSocket()->obj();
+	if(pDocSock!=NULL)
+	{
+		pDocSock->RegisterStyle();
+	}
+}
+/**
+ * @descr  Register all named para styles
+ */
+void LwpDocument::RegisterTextStyles()
+{
+	//Register all text styles: para styles, character styles
+	LwpDLVListHeadHolder* pParaStyleHolder = static_cast<LwpDLVListHeadHolder*>(m_pFoundry->GetTextStyleHead()->obj());
+	if(pParaStyleHolder) 
+	{
+		LwpTextStyle* pParaStyle = static_cast<LwpTextStyle*> (pParaStyleHolder->GetHeadID()->obj());
+		while(pParaStyle)
+		{
+			pParaStyle->SetFoundry(m_pFoundry);
+			pParaStyle->RegisterStyle();
+			pParaStyle = static_cast<LwpParaStyle*>(pParaStyle->GetNext()->obj());
+		}
+	}
+	ChangeStyleName();//add by ,for click here block,05/5/26
+}
+/**
+ * @descr  Register all layouts styles (page master and master page) 
+ * 		 All para styles used in master page (header and footer) are registered and then showed
+ */
+void LwpDocument::RegisterLayoutStyles()
+{
+	//Register all layout styles, before register all styles in para	
+	m_pFoundry->RegisterAllLayouts();	
+	
+	//set initial pagelayout in story for parsing pagelayout
+	LwpDivInfo* pDivInfo = static_cast<LwpDivInfo*> (m_DivInfo.obj( VO_DIVISIONINFO));
+	LwpPageLayout* pPageLayout = NULL;
+	if(pDivInfo)
+	{
+		pPageLayout =static_cast<LwpPageLayout*>(pDivInfo->GetInitialLayoutID()->obj(VO_PAGELAYOUT));
+		if(pPageLayout)
+		{
+			//In Ole division, the content of pagelayout is VO_OLEOBJECT
+			LwpStory* pStory = static_cast<LwpStory*>(pPageLayout->GetContent()->obj(VO_STORY));
+			if(pStory)
+			{
+				//add all the pagelayout in order into the pagelayout list;				
+				pStory->SortPageLayout();
+				pStory->SetCurrentLayout(pPageLayout);				
+			}
+		}
+	}
+}
+/**
+ * @descr  Register all styles used in para
+ */
+void LwpDocument::RegisterStylesInPara()
+{
+	//Register all automatic styles in para
+	LwpHeadContent* pContent = static_cast<LwpHeadContent*> (m_pFoundry->GetContentManager()->GetContentList()->obj());
+	if(pContent)
+	{
+		LwpStory* pStory = static_cast<LwpStory*>(pContent->GetChildHead()->obj(VO_STORY));
+		while(pStory)
+		{
+			//Register the child para
+			pStory->SetFoundry(m_pFoundry);
+			pStory->RegisterStyle();
+			pStory = static_cast<LwpStory*>(pStory->GetNext()->obj(VO_STORY));
+		}
+	}
+}
+/**
+ * @descr  Register all bullet styles used in this division
+ */
+void LwpDocument::RegisterBulletStyles()
+{
+	//Register bullet styles
+	LwpDLVListHeadHolder* mBulletHead = static_cast<LwpDLVListHeadHolder*> 
+				(m_pFoundry->GetBulletManagerID()->obj(VO_HEADHOLDER));
+	if( mBulletHead ) 
+	{
+		LwpSilverBullet* pBullet = static_cast<LwpSilverBullet*>
+							(mBulletHead->GetHeadID()->obj());
+		while(pBullet)
+		{
+			pBullet->SetFoundry(m_pFoundry);
+			pBullet->RegisterStyle();
+			pBullet = static_cast<LwpSilverBullet*> (pBullet->GetNext()->obj());
+		}
+	}	
+}
+/**
+ * @descr  Register all styles used in VO_Graphic
+ */
+void LwpDocument::RegisterGraphicsStyles()
+{
+	//Register all graphics styles, the first object should register the next;	
+	LwpObject* pGraphic = m_pFoundry->GetGraphicListHead()->obj(VO_GRAPHIC);
+	if(pGraphic)
+	{
+		pGraphic->SetFoundry(m_pFoundry);
+		pGraphic->RegisterStyle();
+	}
+}
+/**
+ * @descr  Register line number styles
+ */
+void LwpDocument::RegisterLinenumberStyles()
+{
+	if (!m_pLnOpts)
+		return;
+	m_pLnOpts->RegisterStyle();
+}
+
+/**
+* @descr   Register footnote/endnote configuration for the entire document
+*/
+void LwpDocument::RegisterFootnoteStyles()
+{
+	//Register footnote and endnote configuration for the entire document
+	if(!m_FootnoteOpts.IsNull())
+	{
+		LwpFootnoteOptions* pFootnoteOpts = static_cast<LwpFootnoteOptions*>(m_FootnoteOpts.obj());
+		if (pFootnoteOpts)
+		{
+			pFootnoteOpts->SetMasterPage(A2OUSTR("Endnote"));
+			pFootnoteOpts->RegisterStyle();
+		}
+	}
+	//Register endnote page style for endnote configuration, use the last division that has endnote for the endnote page style
+	//This page style must register after its division default styles have registered
+	LwpDocument* pEndnoteDiv = GetLastDivisionThatHasEndnote();
+	if(this == pEndnoteDiv)
+	{
+		LwpDLVListHeadTailHolder* pHeadTail = static_cast<LwpDLVListHeadTailHolder*>(GetPageHintsID()->obj());
+		if(pHeadTail)
+		{
+			LwpPageHint* pPageHint =static_cast<LwpPageHint*>(pHeadTail->GetTail()->obj());
+			if(pPageHint && !pPageHint->GetPageLayoutID()->IsNull())
+			{
+				LwpPageLayout* pPageLayout = static_cast<LwpPageLayout*>(pPageHint->GetPageLayoutID()->obj());
+				if(pPageLayout)
+				{
+					pPageLayout->SetFoundry(GetFoundry());
+					pPageLayout->RegisterEndnoteStyle();
+				}
+			}
+		}
+	}
+}
+
+/**
+* @descr   Register default para styles
+*/
+#include "lwpverdocument.hxx"
+void LwpDocument::RegisterDefaultParaStyles()
+{
+	if(!IsChildDoc())
+	{
+		//Get First Division
+		//LwpDocument* pFirstDoc = GetFirstDivision();
+		LwpDocument* pFirstDoc = GetFirstDivisionWithContentsThatIsNotOLE();
+		if(pFirstDoc)
+		{
+			LwpVerDocument* pVerDoc = static_cast<LwpVerDocument*>(pFirstDoc->GetVerDoc()->obj());
+			if(pVerDoc)
+			{
+				pVerDoc->RegisterStyle();
+			}
+		}
+		
+	}
+}
+
+/**
+ * @descr  Parse content in this division to IXFStream
+ * LwpDocument->LwpDivInfo->LwpPageLayout.Parse()
+ */
+void LwpDocument::ParseDocContent(IXFStream* pOutputStream)
+{
+	//Parse content in PageLayout
+	LwpDivInfo* pDivInfo = static_cast<LwpDivInfo*> (m_DivInfo.obj());
+	if(pDivInfo==NULL) return;
+
+	LwpObject* pLayoutObj = pDivInfo->GetInitialLayoutID()->obj();
+	if(pLayoutObj==NULL) 
+	{
+		//Cause crash when parsing master document, master document not supported now.
+		//ParseMasterDoc(pOutputStream);
+		return;
+	}
+	pLayoutObj->SetFoundry(m_pFoundry);
+	pLayoutObj->Parse(pOutputStream);
+}
+/**
+ * @descr  Parse master doc in this division to IXFStream
+ * 
+ */
+void LwpDocument::ParseMasterDoc(IXFStream* pOutputStream)
+{
+	LwpDivInfo* pDivInfo = static_cast<LwpDivInfo*> (m_DivInfo.obj());
+	if(pDivInfo==NULL) return;
+	LwpAtomHolder* pExternal = pDivInfo->GetExternalName();
+	if(pExternal && pExternal->HasValue())
+	{
+		OUString linkedfilepath = pExternal->str();
+		OUString fileURL = LwpTools::convertToFileUrl(OUStringToOString(linkedfilepath, osl_getThreadTextEncoding()));
+		XFSection* pSection  = new XFSection();
+		pSection->SetSourceLink( fileURL);
+		pSection->ToXml(pOutputStream);
+		delete pSection;
+	}
+}
+/**
+ * @descr	 Get the footnoteoptions from the root document
+ */
+LwpObjectID* LwpDocument::GetValidFootnoteOpts()
+{	
+	LwpDocument* pRoot = GetRootDocument();
+	if(pRoot)
+	{
+		return pRoot->GetFootnoteOpts();
+	}
+	return NULL;
+}
+
+/**
+ * @descr	 Get the endnote type
+ */
+sal_uInt16 LwpDocument::GetEndnoteType()
+{
+	LwpDivInfo* pDivInfo =static_cast<LwpDivInfo*>(GetDivInfoID()->obj());
+	if (!pDivInfo) 
+		return FN_DONTCARE;
+	OUString strClassName = pDivInfo->GetClassName();
+	if (strClassName.equals(A2OUSTR(STR_DivisionEndnote)))
+		return FN_DIVISION_SEPARATE;
+	if (strClassName.equals(A2OUSTR(STR_DivisionGroupEndnote)))
+		return FN_DIVISIONGROUP_SEPARATE;
+	if (strClassName.equals(A2OUSTR(STR_DocumentEndnote)))
+		return FN_DOCUMENT_SEPARATE;
+	return FN_DONTCARE;
+}
+/**
+ * @descr	 	Get previous division
+ */
+LwpDocument* LwpDocument::GetPreviousDivision()
+{
+	LwpDocSock* pDocSock = static_cast<LwpDocSock*>(GetSocket()->obj());
+	if(pDocSock)
+	{
+		return static_cast<LwpDocument*>(pDocSock->GetPrevious()->obj());
+	}
+	return NULL;
+}
+/**
+ * @descr	 Get next division
+ */
+ LwpDocument* LwpDocument::GetNextDivision()
+{
+	LwpDocSock* pDocSock = static_cast<LwpDocSock*>(GetSocket()->obj());
+	if(pDocSock)
+	{
+		return static_cast<LwpDocument*>(pDocSock->GetNext()->obj());
+	}
+	return NULL;
+}
+/**
+ * @descr	 Get parent division
+ */
+ LwpDocument* LwpDocument::GetParentDivision()
+{
+	LwpDocSock* pDocSock = static_cast<LwpDocSock*>(GetSocket()->obj());
+	if(pDocSock)
+	{
+		return static_cast<LwpDocument*>(pDocSock->GetParent()->obj());
+	}
+	return NULL;
+}
+/**
+ * @descr	 Get previous division in group, copy from lwp source code
+ */
+ LwpDocument* LwpDocument::GetPreviousInGroup()
+{
+	LwpDocument* pPrev = NULL;
+
+	for (pPrev = GetPreviousDivision(); pPrev; pPrev = pPrev->GetPreviousDivision())
+	{
+		LwpDivInfo* pDivInfo =static_cast<LwpDivInfo*>(pPrev->GetDivInfoID()->obj());
+		if(pDivInfo && pDivInfo->HasContents())
+			return pPrev;
+	}		
+	return NULL;
+}
+/**
+ * @descr	 	Get previous division in group, copy from lwp source code
+ */
+ LwpDocument* LwpDocument::GetNextInGroup()
+{
+	LwpDocument* pNext = NULL;
+
+	for (pNext = GetNextDivision(); pNext; pNext = pNext->GetNextDivision())
+	{
+		LwpDivInfo* pDivInfo =static_cast<LwpDivInfo*>(pNext->GetDivInfoID()->obj());
+		if(pDivInfo && pDivInfo->HasContents())
+			return pNext;
+	}
+	
+	return NULL;
+}
+/**
+ * @descr	 Get previous division which has contents, copy from lwp source code
+ */
+ LwpDocument* LwpDocument::GetPreviousDivisionWithContents()
+{
+	if(GetPreviousDivision())
+	{
+		LwpDocument* pDoc = GetPreviousDivision()->GetLastDivisionWithContents();		
+		if (pDoc)
+			return pDoc;
+	}
+	if(GetParentDivision())
+		return GetParentDivision()->GetPreviousDivisionWithContents();
+	return NULL;
+}
+ /**
+ * @descr	 Get last division which has contents, copy from lwp source code
+ */
+ LwpDocument* LwpDocument::GetLastDivisionWithContents()
+{	
+	LwpDivInfo* pDivInfo =static_cast<LwpDivInfo*>(GetDivInfoID()->obj());
+	if(pDivInfo && pDivInfo->HasContents())
+	{
+		return this;
+	}
+
+	LwpDocument* pDivision = GetLastDivision();
+	LwpDocument* pContentDivision = NULL;
+
+	while(pDivision)
+	{
+		pContentDivision = pDivision->GetLastDivisionWithContents();
+		if(pContentDivision)
+		{
+			return pContentDivision;
+		}
+		pDivision = pDivision->GetPreviousDivision();
+	}
+	
+	return NULL;
+}
+ /**
+ * @descr	 Get last division in group  which has contents, copy from lwp source code
+ */
+ LwpDocument* LwpDocument::GetLastInGroupWithContents()
+{
+	LwpDocument* pLast = NULL;
+	LwpDocument* pNext = this;
+	
+	while (pNext)
+	{
+		LwpDivInfo* pDivInfo =static_cast<LwpDivInfo*>(pNext->GetDivInfoID()->obj());
+		if (pDivInfo && pDivInfo->HasContents())
+			pLast = pNext;
+		pNext = pNext->GetNextInGroup();
+	}
+	if (pLast)
+		return pLast;
+	return NULL;
+}
+  /**
+ * @descr	 Get last division
+ */
+ LwpDocument* LwpDocument::GetLastDivision()
+{
+	LwpDocSock* pDocSock = static_cast<LwpDocSock*>(GetSocket()->obj());
+	if(pDocSock)
+		return static_cast<LwpDocument*>(pDocSock->GetChildTail()->obj());
+	return NULL;
+}
+
+  /**
+ * @descr	 Get first division
+ */
+ LwpDocument* LwpDocument::GetFirstDivision()
+{
+	LwpDocSock* pDocSock = static_cast<LwpDocSock*>(GetSocket()->obj());
+	if(pDocSock)
+		return static_cast<LwpDocument*>(pDocSock->GetChildHead()->obj());
+	return NULL;
+}
+  
+ /**
+ * @descr	 Get root document
+ */
+ LwpDocument* LwpDocument::GetRootDocument()
+{
+	LwpDocument* pRoot = this;
+	while(pRoot)
+	{
+		if(!pRoot->IsChildDoc())
+			return pRoot;
+		pRoot = pRoot->GetParentDivision();
+	}
+	return NULL;
+}
+  /**
+ * @descr	 Get first division with contents that is not ole, copy from lwp-source code
+ */
+ LwpDocument* LwpDocument::GetFirstDivisionWithContentsThatIsNotOLE()
+{
+	LwpDivInfo* pDivInfo =static_cast<LwpDivInfo*>(GetDivInfoID()->obj());
+	if(pDivInfo && pDivInfo->HasContents()
+		&& !pDivInfo->IsOleDivision())
+		return this;
+
+	LwpDocument* pDivision = GetFirstDivision();
+	
+	LwpDocument*  pContentDivision = NULL;
+
+	while (pDivision)
+	{
+		pContentDivision = pDivision->GetFirstDivisionWithContentsThatIsNotOLE();
+		if(pContentDivision)
+			return pContentDivision;
+		pDivision = pDivision->GetNextDivision();
+	}
+	return NULL;
+}
+ /**
+ * @descr	 Get last division that has endnote
+ */
+ LwpDocument* LwpDocument::GetLastDivisionThatHasEndnote()
+{
+	LwpDocument* pRoot = GetRootDocument();
+	LwpDocument *pLastDoc = pRoot->GetLastDivisionWithContents();
+	while(pLastDoc)
+	{
+		if(pLastDoc->GetEnSuperTableLayout())
+			return pLastDoc;
+		pLastDoc = pLastDoc->GetPreviousDivisionWithContents();
+	}
+	return NULL;
+	
+}
+ /**
+ * @descr	 Get endnote supertable layout, every division has only one endnote supertable layout.
+ */
+ LwpVirtualLayout* LwpDocument::GetEnSuperTableLayout()
+{
+	LwpHeadLayout* pHeadLayout =static_cast<LwpHeadLayout*>(GetFoundry()->GetLayout()->obj());
+	if(pHeadLayout)
+	{
+		return pHeadLayout->FindEnSuperTableLayout();
+	}
+	return NULL;
+}
+
+/**
+ * @descr	 Get the numbers of page  before pEndDivision, copy from lwp source code
+ */
+ sal_Bool LwpDocument::GetNumberOfPages(LwpDocument* pEndDivision, sal_uInt16& nCount)
+{
+	if(this == pEndDivision)
+		return sal_True;
+
+	LwpDivInfo* pDivInfo = static_cast<LwpDivInfo*>(m_DivInfo.obj());
+	if(pDivInfo)
+	{
+		pDivInfo->GetNumberOfPages(nCount);
+	}
+
+	LwpDocument* pDivision = GetFirstDivision();
+	while(pDivision)
+	{
+		if(pDivision->GetNumberOfPages(pEndDivision,nCount))
+			return sal_True;
+		pDivision = pDivision->GetNextDivision();
+		
+	}
+	return sal_False;
+}
+/**
+ * @descr	 Get the numbers of page  before curruent division
+ */
+sal_uInt16 LwpDocument::GetNumberOfPagesBefore()
+{
+	sal_uInt16 nPageNumber = 0;
+	LwpDocument* pRoot = GetRootDocument();
+	if(pRoot)
+		pRoot->GetNumberOfPages(this,nPageNumber);
+	return nPageNumber;		
+}
+ /**
+ * @descr	 Get the numbers of page before this division
+ */
+ sal_uInt16 LwpDocument::GetMaxNumberOfPages()
+{
+	sal_uInt16 nPageNumber = 0;
+	MaxNumberOfPages(nPageNumber);
+	return nPageNumber;
+}
+ /**
+ * @descr	 Get Max number of pages
+ */
+ void  LwpDocument::MaxNumberOfPages(sal_uInt16& nNumPages)
+{
+	LwpDocument* pDivision = GetFirstDivision();
+
+	LwpDivInfo* pDivInfo = static_cast<LwpDivInfo*>(m_DivInfo.obj());
+	if(pDivInfo)
+		nNumPages += pDivInfo->GetMaxNumberOfPages();
+	while(pDivision)
+	{
+		pDivision->MaxNumberOfPages(nNumPages);
+		pDivision = pDivision->GetNextDivision();
+	}	
+}
+  /**
+ * @descr	 Parse the frame which anchor is to page before parse other contents,
+ *			This method is called when the document is root document.
+ */
+void LwpDocument::ParseFrameInPage(IXFStream * pOutputStream)
+{
+	if(IsChildDoc())
+		return;
+	
+	XFContentContainer* pXFContainer = new XFContentContainer;
+	
+	XFConvertFrameInPage(pXFContainer);
+	
+	pXFContainer->ToXml(pOutputStream);
+	delete pXFContainer;
+	pXFContainer = NULL;
+}
+ /**
+ * @descr	 Parse the frame which anchor is to page in the entire document
+ */
+void LwpDocument::XFConvertFrameInPage(XFContentContainer * pCont)
+{
+	LwpDocument* pDivision = GetFirstDivision();
+	
+	LwpDivInfo* pDivInfo = static_cast<LwpDivInfo*> (GetDivInfoID()->obj());		
+	if(pDivInfo)
+	{
+		LwpPageLayout*  pPageLayout =static_cast<LwpPageLayout*>(pDivInfo->GetInitialLayoutID()->obj());
+		if(pPageLayout)
+		{
+			LwpStory* pStory = static_cast<LwpStory*>(pPageLayout->GetContent()->obj());
+			if(pStory)
+				pStory->XFConvertFrameInPage(pCont);
+		}
+	}
+	while(pDivision)
+	{
+		pDivision->XFConvertFrameInPage(pCont);
+		pDivision = pDivision->GetNextDivision();
+	}
+}
+ /**
+ * @descr	 change click here to placeholder
+ */
+void LwpDocument::ChangeStyleName()
+{
+	XFStyleManager* pXFStyleManager = LwpGlobalMgr::GetInstance()->GetXFStyleManager();
+	XFTextStyle* pStyle =  static_cast<XFTextStyle*>(pXFStyleManager->FindStyle(A2OUSTR("ClickHere")));
+	if (pStyle)
+	{
+		pStyle->SetStyleName(A2OUSTR("Placeholder"));
+	}
+}
+LwpDocSock::LwpDocSock(LwpObjectHeader& objHdr, LwpSvStream* pStrm)
+	:LwpDLNFVList(objHdr, pStrm)
+{}
+
+ /**
+ * @descr	 read VO_DOCSOCK from file	
+ */
+void LwpDocSock::Read()
+{
+	LwpDLNFVList::Read();
+	m_Doc.ReadIndexed(m_pObjStrm);
+	m_pObjStrm->SkipExtra();
+}
+ /**
+ * @descr	 register styles in documents plugged
+ */
+void LwpDocSock::RegisterStyle()
+{
+	LwpObject* pDoc = GetNext()->obj();
+	if(pDoc)
+		pDoc->RegisterStyle();
+
+	pDoc = GetChildHead()->obj();
+	if(pDoc) 
+		pDoc->RegisterStyle();
+}
+ /**
+ * @descr	 parse contents of documents plugged
+ */
+void LwpDocSock::Parse(IXFStream* pOutputStream)
+{
+	LwpObject* pDoc = GetChildHead()->obj();
+	if(pDoc) 
+		pDoc->Parse(pOutputStream);
+
+	pDoc = GetNext()->obj();
+	if(pDoc)
+		pDoc->Parse(pOutputStream);
+}
diff -urNp lotuswordpro.bak/source/filter/lwpdocdata.cxx lotuswordpro/source/filter/lwpdocdata.cxx
--- lotuswordpro.bak/source/filter/lwpdocdata.cxx	1970-01-01 08:00:00.000000000 +0800
+++ lotuswordpro/source/filter/lwpdocdata.cxx	2008-10-22 11:56:02.000000000 +0800
@@ -0,0 +1,395 @@
+/*************************************************************************
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: IBM Corporation
+ *
+ *  Copyright: 2008 by IBM Corporation
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+#include "lwpdocdata.hxx"
+#include "xfilter/xfofficemeta.hxx"
+#include "localtime.hxx"
+#include	<rtl/ustrbuf.hxx>
+#include "lwpfilehdr.hxx"
+#include "lwpglobalmgr.hxx"
+
+//std::map<sal_uInt16,LwpEditorAttr*> LwpDocData::m_EditorAttrMap;
+
+LwpDocData::LwpDocData(LwpObjectHeader &objHdr, LwpSvStream* pStrm)
+	:LwpObject(objHdr, pStrm)//m_pEditorAttrList(0)
+{}
+
+LwpDocData::~LwpDocData()
+{
+}
+void LwpDocData::SkipExtra(LwpSvStream* pStream)
+{
+	sal_uInt16 extra;
+	pStream->Read(&extra,2);
+	while(extra != 0)
+	{
+		pStream->SeekRel(extra);
+		pStream->Read(&extra,2);
+	}
+}
+void LwpDocData::SkipAtomHandler(LwpSvStream* pStream)
+{
+	sal_uInt16 disksize;
+	sal_uInt16 len;
+	pStream->Read(&disksize,2);
+	pStream->Read(&len,2);
+	if(len)pStream->SeekRel(disksize-2);
+}
+void LwpDocData::Read()
+{
+	//XFDateTime
+	//////////////////////////////////////////////////////////////////////////
+	//doc options
+	//cOptionFlag
+	m_DocOptions.nOptionFlag = m_pObjStrm->QuickReaduInt16();
+	//cEncrypt1Password
+	m_DocOptions.encrypt1password.Read(m_pObjStrm);
+	//cEncrypt2Password
+	m_DocOptions.encrypt2password.Read(m_pObjStrm);
+	//cCharecterSet
+	m_DocOptions.characterSet.Read(m_pObjStrm);
+	//cGrammerSet
+	m_DocOptions.grammerSet.Read(m_pObjStrm);
+	//cShowMarginMarks
+	m_DocOptions.nMarginMarks = m_pObjStrm->QuickReaduInt16();
+	//cMarginMarksLocation
+	m_DocOptions.nMarginMarksLocation = m_pObjStrm->QuickReaduInt16();
+	//cMarginMarksChar
+	m_DocOptions.nMarginMarksChar = m_pObjStrm->QuickReaduInt16();
+	m_pObjStrm->SkipExtra();
+	//////////////////////////////////////////////////////////////////////////
+	//doc info
+	//cDescription
+	m_DocInfo.description.Read(m_pObjStrm);
+	//cKeyWord
+	m_DocInfo.keywords.Read(m_pObjStrm);
+	//cCreatedBy
+	m_DocInfo.createdBy.Read(m_pObjStrm);
+	//cCreationTime
+	m_DocInfo.nCreationTime = m_pObjStrm->QuickReadInt32();
+	LtgLocalTime(m_DocInfo.nCreationTime,m_nCreationTime);
+	//cLastRevisionTime
+	m_DocInfo.nLastRevisionTime = m_pObjStrm->QuickReadInt32();
+	LtgLocalTime(m_DocInfo.nLastRevisionTime,m_nLastRevisionTime);
+	//cTotalEditTime
+	m_DocInfo.nTotalEditTime = m_pObjStrm->QuickReadInt32();
+
+	m_nTotalEditTime.tm_hour = m_DocInfo.nTotalEditTime / 60;
+	m_nTotalEditTime.tm_min = m_DocInfo.nTotalEditTime % 60;
+	m_nTotalEditTime.tm_sec = 0;
+	//cpVerDocInfo
+	m_DocInfo.cpVerDocInfo.ReadIndexed(m_pObjStrm);
+
+	//EditorList
+	m_DocInfo.nNumEditedBy = m_pObjStrm->QuickReaduInt16();
+	LwpAtomHolder* pCDLNList = new LwpAtomHolder[m_DocInfo.nNumEditedBy];
+	LwpAtomHolder* pEditorList = new LwpAtomHolder[m_DocInfo.nNumEditedBy];
+    sal_uInt16 i = 0;
+	for ( i = 0; i < m_DocInfo.nNumEditedBy; i++)
+	{
+		//CDLNList
+		pCDLNList[i].Read(m_pObjStrm);	//cName
+		m_pObjStrm->SkipExtra();
+		//CEditedBy
+		pEditorList[i].Read(m_pObjStrm);	//cName
+		m_pObjStrm->SkipExtra();
+	}
+
+	m_pObjStrm->SkipExtra();
+
+	delete [] pCDLNList;
+	delete [] pEditorList;
+	//////////////////////////////////////////////////////////////////////////
+	//doc control
+	//cGreeting
+	m_DocControl.cGreeting.Read(m_pObjStrm);
+	//cFlags
+	m_DocControl.nFlags = m_pObjStrm->QuickReaduInt16();
+
+	//cDocControlProtection
+	m_DocControl.nDocControlProtection = m_pObjStrm->QuickReaduInt16();
+	//Len
+	m_DocControl.nLen1 = m_pObjStrm->QuickReaduInt16();
+	//skip doc control password string
+	m_pObjStrm->SeekRel(m_DocControl.nLen1);
+
+	//cFileProtection
+	m_DocControl.nFileProtection = m_pObjStrm->QuickReaduInt16();
+	//Len
+	m_DocControl.nLen2 = m_pObjStrm->QuickReaduInt16();
+	//skip file password string
+	m_pObjStrm->SeekRel(m_DocControl.nLen2);
+
+	//cAutoVersioning
+	m_DocControl.nAutoVersioning = m_pObjStrm->QuickReaduInt16();
+	//cDocControlOnlyEditor
+	m_DocControl.cDocControlOnlyEditor.Read(m_pObjStrm);
+	//cEditorVerification
+	m_DocControl.nEditorVerification = m_pObjStrm->QuickReaduInt16();
+
+	m_pObjStrm->SkipExtra();
+	//////////////////////////////////////////////////////////////////////////
+	//editor list
+	//numeditors
+	sal_uInt16 numeditors = m_pObjStrm->QuickReaduInt16();
+	LwpGlobalMgr* pGlobal = LwpGlobalMgr::GetInstance();
+
+	for (i = 0;i<numeditors;i++)
+	{
+		LwpEditorAttr* pEditorAttr = new LwpEditorAttr;
+		//cName
+		pEditorAttr->cName.Read(m_pObjStrm);
+		//cInitials
+		pEditorAttr->cInitials.Read(m_pObjStrm);
+		//cHiLite
+		pEditorAttr->cHiLiteColor.Read(m_pObjStrm);
+		
+		//cID
+		pEditorAttr->nID = m_pObjStrm->QuickReaduInt16();
+
+		//cInsFontOver
+		//CFontAttributeOverride --cAttrBits
+		pEditorAttr->cInsFontOver.cFontAttributeOverride.cAttrBits = m_pObjStrm->QuickReaduInt16();
+		//CFontAttributeOverride --cAttrOverrideBits
+		pEditorAttr->cInsFontOver.cFontAttributeOverride.cAttrOverrideBits = m_pObjStrm->QuickReaduInt16();
+		//CFontAttributeOverride --cAttrApplyBits
+		pEditorAttr->cInsFontOver.cFontAttributeOverride.cAttrApplyBits = m_pObjStrm->QuickReaduInt16();
+		//CFontAttributeOverride --cAttrOverrideBits2
+		pEditorAttr->cInsFontOver.cFontAttributeOverride.cAttrOverrideBits2 = m_pObjStrm->QuickReaduInt8();
+		//CFontAttributeOverride --cAttrApplyBits2
+		pEditorAttr->cInsFontOver.cFontAttributeOverride.cAttrApplyBits2 = m_pObjStrm->QuickReaduInt8();
+		//CFontAttributeOverride --cCase
+		pEditorAttr->cInsFontOver.cFontAttributeOverride.cCase = m_pObjStrm->QuickReaduInt8();
+		//CFontAttributeOverride --cUnder
+		pEditorAttr->cInsFontOver.cFontAttributeOverride.cUnder = m_pObjStrm->QuickReaduInt8();
+		m_pObjStrm->SkipExtra();
+		//CFontDescriptionOverrideBase--cOverrideBits
+		pEditorAttr->cInsFontOver.cFontDescriptionOverrideBase.cOverrideBits = m_pObjStrm->QuickReaduInt8();
+		//CFontDescriptionOverrideBase--cApplyBits
+		pEditorAttr->cInsFontOver.cFontDescriptionOverrideBase.cApplyBits = m_pObjStrm->QuickReaduInt8();
+		//CFontDescriptionOverrideBase--cPointSize
+		pEditorAttr->cInsFontOver.cFontDescriptionOverrideBase.cPointSize = m_pObjStrm->QuickReadInt32();
+		//CFontDescriptionOverrideBase--cOverstrike
+		pEditorAttr->cInsFontOver.cFontDescriptionOverrideBase.cOverstrike = m_pObjStrm->QuickReaduInt8();
+		//CFontDescriptionOverrideBase--cTightness
+		pEditorAttr->cInsFontOver.cFontDescriptionOverrideBase.cTightness = m_pObjStrm->QuickReaduInt16();
+		//CFontDescriptionOverrideBase--cColor
+		pEditorAttr->cInsFontOver.cFontDescriptionOverrideBase.cColor.Read(m_pObjStrm);
+
+		//CFontDescriptionOverrideBase--cBackgroundColor
+		pEditorAttr->cInsFontOver.cFontDescriptionOverrideBase.cBackgroundColor.Read(m_pObjStrm);
+		
+		m_pObjStrm->SkipExtra();
+		//cFaceName
+		pEditorAttr->cInsFontOver.cFaceName.Read(m_pObjStrm);
+		//cAltFaceName
+		pEditorAttr->cInsFontOver.cAltFaceName.Read(m_pObjStrm);
+		m_pObjStrm->SkipExtra();
+
+		//cDelFontOver
+		//CFontAttributeOverride --cAttrBits
+		pEditorAttr->cDelFontOver.cFontAttributeOverride.cAttrBits = m_pObjStrm->QuickReaduInt16();
+		//CFontAttributeOverride --cAttrOverrideBits
+		pEditorAttr->cDelFontOver.cFontAttributeOverride.cAttrOverrideBits = m_pObjStrm->QuickReaduInt16();
+		//CFontAttributeOverride --cAttrApplyBits
+		pEditorAttr->cDelFontOver.cFontAttributeOverride.cAttrApplyBits = m_pObjStrm->QuickReaduInt16();
+		//CFontAttributeOverride --cAttrOverrideBits2
+		pEditorAttr->cDelFontOver.cFontAttributeOverride.cAttrOverrideBits2 = m_pObjStrm->QuickReaduInt8();
+		//CFontAttributeOverride --cAttrApplyBits2
+		pEditorAttr->cDelFontOver.cFontAttributeOverride.cAttrApplyBits2 = m_pObjStrm->QuickReaduInt8();
+		//CFontAttributeOverride --cCase
+		pEditorAttr->cDelFontOver.cFontAttributeOverride.cCase = m_pObjStrm->QuickReaduInt8();
+		//CFontAttributeOverride --cUnder
+		pEditorAttr->cDelFontOver.cFontAttributeOverride.cUnder = m_pObjStrm->QuickReaduInt8();
+		m_pObjStrm->SkipExtra();
+		//CFontDescriptionOverrideBase--cOverrideBits
+		pEditorAttr->cDelFontOver.cFontDescriptionOverrideBase.cOverrideBits = m_pObjStrm->QuickReaduInt8();
+		//CFontDescriptionOverrideBase--cApplyBits
+		pEditorAttr->cDelFontOver.cFontDescriptionOverrideBase.cApplyBits = m_pObjStrm->QuickReaduInt8();
+		//CFontDescriptionOverrideBase--cPointSize
+		pEditorAttr->cDelFontOver.cFontDescriptionOverrideBase.cPointSize = m_pObjStrm->QuickReadInt32();
+		//CFontDescriptionOverrideBase--cOverstrike
+		pEditorAttr->cDelFontOver.cFontDescriptionOverrideBase.cOverstrike = m_pObjStrm->QuickReaduInt8();
+		//CFontDescriptionOverrideBase--cTightness
+		pEditorAttr->cDelFontOver.cFontDescriptionOverrideBase.cTightness = m_pObjStrm->QuickReaduInt16();
+		//CFontDescriptionOverrideBase--cColor
+		pEditorAttr->cDelFontOver.cFontDescriptionOverrideBase.cColor.Read(m_pObjStrm);
+
+		//CFontDescriptionOverrideBase--cBackgroundColor
+		pEditorAttr->cDelFontOver.cFontDescriptionOverrideBase.cBackgroundColor.Read(m_pObjStrm);
+	
+		m_pObjStrm->SkipExtra();
+		//cFaceName
+		pEditorAttr->cDelFontOver.cFaceName.Read(m_pObjStrm);
+		//cAltFaceName
+		pEditorAttr->cDelFontOver.cAltFaceName.Read(m_pObjStrm);
+		m_pObjStrm->SkipExtra();
+		
+		//cAbilities
+		pEditorAttr->nAbilities = m_pObjStrm->QuickReaduInt16();
+		//cLocks
+		pEditorAttr->nLocks = m_pObjStrm->QuickReaduInt16();
+		//cSuggestions
+		pEditorAttr->nSuggestions = m_pObjStrm->QuickReaduInt16();
+		
+		//cDelTextAttr
+		//m_pEditorAttrList[i].cDelTextAttr.Read(m_pObjStrm);
+		if (m_pObjStrm->QuickReadBool())
+		{
+			pEditorAttr->cDelTextAttr.cOverride.cValues = m_pObjStrm->QuickReaduInt16();
+			pEditorAttr->cDelTextAttr.cOverride.cOverride = m_pObjStrm->QuickReaduInt16();
+			pEditorAttr->cDelTextAttr.cOverride.cApply = m_pObjStrm->QuickReaduInt16();
+			m_pObjStrm->SkipExtra();
+			pEditorAttr->cDelTextAttr.cHideLevels = m_pObjStrm->QuickReaduInt16();
+
+			if (LwpFileHeader::m_nFileRevision>= 0x000b)
+			{
+				pEditorAttr->cDelTextAttr.cBaselineOffset = m_pObjStrm->QuickReadInt32();
+			}
+			else
+			{
+				pEditorAttr->cDelTextAttr.cBaselineOffset = 0;
+			}
+		}
+		m_pObjStrm->SkipExtra();
+
+		m_pObjStrm->SkipExtra();
+		
+		pGlobal->SetEditorAttrMap(pEditorAttr->nID, pEditorAttr);
+	}
+}
+rtl::OUString	LwpDocData::DateTimeToOUString(LtTm& dt)
+{
+	rtl::OUStringBuffer	buf;
+	buf.append((sal_Int32)dt.tm_year);
+	buf.append( A2OUSTR("-") );
+	buf.append((sal_Int32)dt.tm_mon);
+	buf.append( A2OUSTR("-") );
+	buf.append((sal_Int32)dt.tm_mday);
+	buf.append( A2OUSTR("T") );
+	buf.append((sal_Int32)dt.tm_hour);
+	buf.append( A2OUSTR(":") );
+	buf.append((sal_Int32)dt.tm_min);
+	buf.append( A2OUSTR(":") );
+	buf.append((sal_Int32)dt.tm_sec);
+	buf.append( A2OUSTR(".") );
+	buf.append((sal_Int32)0);
+
+	return buf.makeStringAndClear();
+}
+rtl::OUString	LwpDocData::TimeToOUString(LtTm& dt)
+{
+	//PT3H43M44S
+	rtl::OUStringBuffer	buf;
+	buf.append( A2OUSTR("PT") );
+	buf.append((sal_Int32)dt.tm_hour);
+	buf.append( A2OUSTR("H") );
+	buf.append((sal_Int32)dt.tm_min);
+	buf.append( A2OUSTR("M") );
+	buf.append((sal_Int32)dt.tm_sec);
+	buf.append( A2OUSTR("S") );
+
+	return buf.makeStringAndClear();
+}
+void LwpDocData::Parse(IXFStream *pOutputStream)
+{
+	//<!DOCTYPE office:document-meta PUBLIC "-//OpenOffice.org//DTD OfficeDocument 1.0//EN" "office.dtd">
+	//<office:document-meta xmlns:office="http://openoffice.org/2000/office" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:meta="http://openoffice.org/2000/meta" office:version="1.0">
+	//</office:document-meta>
+	XFOfficeMeta xfMeta;
+	xfMeta.SetCreator(m_DocInfo.createdBy.str());
+	xfMeta.SetDescription(m_DocInfo.description.str());
+	xfMeta.SetKeywords(m_DocInfo.keywords.str());
+	xfMeta.SetCreationTime(DateTimeToOUString(m_nCreationTime));
+	xfMeta.SetLastTime(DateTimeToOUString(m_nLastRevisionTime));
+	xfMeta.SetEditTime(TimeToOUString(m_nTotalEditTime));
+	xfMeta.ToXml(pOutputStream);
+}
+/*
+OUString LwpDocData::GetEditorName(sal_uInt8 nID)
+{
+	std::map<sal_uInt16,LwpEditorAttr*>::iterator iter;
+	iter = m_EditorAttrMap.find(nID);
+	if (iter != m_EditorAttrMap.end())
+		return iter->second->cName.str();
+	return A2OUSTR("");
+}
+
+XFColor LwpDocData::GetHighLightColor(sal_uInt8 nID)
+{
+	std::map<sal_uInt16,LwpEditorAttr*>::iterator iter;
+
+	iter = m_EditorAttrMap.find(nID);
+	if (iter != m_EditorAttrMap.end())
+	{
+		LwpColor aLwpColor = iter->second->cHiLiteColor;
+		XFColor aColor(aLwpColor.GetRed(),aLwpColor.GetGreen(),aLwpColor.GetBlue());
+		return aColor;
+	}
+	else
+	{
+		XFColor aColor(255,255,0);//yellow
+		return aColor;
+	}
+}
+void LwpDocData::Reset()
+{
+	std::map<sal_uInt16,LwpEditorAttr*>::iterator iter;
+	for (iter =m_EditorAttrMap.begin();iter != m_EditorAttrMap.end(); iter++)
+	{
+		delete iter->second;
+		iter->second = NULL;
+	}
+	m_EditorAttrMap.clear();
+}*/
diff -urNp lotuswordpro.bak/source/filter/lwpdocdata.hxx lotuswordpro/source/filter/lwpdocdata.hxx
--- lotuswordpro.bak/source/filter/lwpdocdata.hxx	1970-01-01 08:00:00.000000000 +0800
+++ lotuswordpro/source/filter/lwpdocdata.hxx	2008-10-22 11:42:29.000000000 +0800
@@ -0,0 +1,191 @@
+/*************************************************************************
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: IBM Corporation
+ *
+ *  Copyright: 2008 by IBM Corporation
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+#ifndef LWPDOCDATA_HXX_
+#define LWPDOCDATA_HXX_
+#include "lwpobj.hxx"
+#include "lwpatomholder.hxx"
+#include "localtime.hxx"
+#include "lwpcolor.hxx"
+#include "xfilter/xfcolor.hxx"
+#include <map>
+
+struct LwpDocOptions
+{
+	sal_uInt16 nOptionFlag;
+	LwpAtomHolder encrypt1password;
+	LwpAtomHolder encrypt2password;
+	LwpAtomHolder characterSet;
+	LwpAtomHolder grammerSet;
+	sal_uInt16 nMarginMarks;
+	sal_uInt16 nMarginMarksLocation;
+	sal_uInt16 nMarginMarksChar;
+};
+struct LwpDocInfo
+{
+	LwpAtomHolder description;
+	LwpAtomHolder keywords;
+	LwpAtomHolder createdBy;
+	sal_Int32 nCreationTime;
+	sal_Int32 nLastRevisionTime;
+	sal_Int32 nTotalEditTime;
+	LwpObjectID cpVerDocInfo;
+	sal_uInt16 nNumEditedBy;
+	//skip editor list
+};
+struct LwpDocControl
+{
+	LwpAtomHolder cGreeting;
+	sal_uInt16 nFlags;
+	sal_uInt16 nDocControlProtection;
+	sal_uInt16 nLen1;
+	//skip doc control password string
+	sal_uInt16 nFileProtection;
+	sal_uInt16 nLen2;
+	//skip file password string
+	sal_uInt16 nAutoVersioning;
+	LwpAtomHolder cDocControlOnlyEditor;
+	sal_uInt16 nEditorVerification;
+};
+struct lcolor
+{
+		sal_uInt16 cred;		// When extra is AGLRGB_INDEX, cred holds the
+		sal_uInt16 cgreen;		// hi 16 bits and cgreen holds the lo 16 bits of
+		sal_uInt16 cblue;		// the 32-bit LUT index.
+		sal_uInt16 cextra;
+};
+struct LwpFontDescriptionOverrideBase
+{
+	sal_uInt8 cOverrideBits;
+	sal_uInt8 cApplyBits;
+	sal_Int32 cPointSize;
+	sal_uInt8 cOverstrike;
+	sal_uInt16 cTightness;
+	//lcolor cColor;
+	//lcolor cBackgroundColor;
+	LwpColor cColor;
+	LwpColor cBackgroundColor;
+};
+struct LwpFontAttributeOverride
+{
+	sal_uInt16 cAttrBits;
+	sal_uInt16 cAttrOverrideBits;
+	sal_uInt16 cAttrApplyBits;
+	sal_uInt8 cAttrOverrideBits2;
+	sal_uInt8 cAttrApplyBits2;
+	sal_uInt8 cCase;
+	sal_uInt8 cUnder;
+};
+struct LwpFontDescriptionOverride
+{
+	LwpFontAttributeOverride cFontAttributeOverride;
+	LwpFontDescriptionOverrideBase cFontDescriptionOverrideBase;
+	LwpAtomHolder cFaceName;
+	LwpAtomHolder cAltFaceName;
+};
+struct LwpOverrideOg
+{
+	sal_uInt16 cValues;
+	sal_uInt16 cOverride;
+	sal_uInt16 cApply;
+};
+struct LwpTextAttributeOverrideOg
+{
+	LwpOverrideOg cOverride;
+	sal_uInt16 cHideLevels;
+	sal_Int32 cBaselineOffset;
+};
+struct LwpEditorAttr
+{
+	LwpAtomHolder cName;
+	LwpAtomHolder cInitials;
+	LwpColor cHiLiteColor;
+	sal_uInt16 nID;
+	LwpFontDescriptionOverride cInsFontOver;
+	LwpFontDescriptionOverride cDelFontOver;
+	sal_uInt16 nAbilities;
+	sal_uInt16 nLocks;
+	sal_uInt16 nSuggestions;
+	LwpTextAttributeOverrideOg cDelTextAttr;
+};
+class LwpDocData : public LwpObject
+{
+public:
+	LwpDocData(LwpObjectHeader &objHdr, LwpSvStream* pStrm);
+	~LwpDocData();
+private:
+	LwpDocOptions m_DocOptions;
+	LwpDocInfo m_DocInfo;
+	LwpDocControl m_DocControl;
+//	static std::map<sal_uInt16,LwpEditorAttr*> m_EditorAttrMap;
+private:
+	LtTm m_nCreationTime;
+	LtTm m_nLastRevisionTime;
+	LtTm m_nTotalEditTime;
+private:
+	void SkipExtra(LwpSvStream* pStream);
+	void SkipAtomHandler(LwpSvStream* pStream);
+	rtl::OUString DateTimeToOUString(LtTm& dt);
+	rtl::OUString TimeToOUString(LtTm& dt);
+	
+public:
+	//inline sal_uInt8* GetBuffer(){return m_DataBuffer;}
+	void Read();
+	void Parse(IXFStream *pOutputStream);
+//	LwpEditorAttr* GetEditorList(){return m_pEditorAttrList;}
+	//static OUString GetEditorName(sal_uInt8 nID);
+	//static XFColor GetHighLightColor(sal_uInt8 nID);	
+	//static void Reset();
+};
+#endif
diff -urNp lotuswordpro.bak/source/filter/lwpdoc.hxx lotuswordpro/source/filter/lwpdoc.hxx
--- lotuswordpro.bak/source/filter/lwpdoc.hxx	1970-01-01 08:00:00.000000000 +0800
+++ lotuswordpro/source/filter/lwpdoc.hxx	2008-10-22 11:42:29.000000000 +0800
@@ -0,0 +1,248 @@
+/*************************************************************************
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: IBM Corporation
+ *
+ *  Copyright: 2008 by IBM Corporation
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+/*************************************************************************
+ * @file 
+ *  LwpDocument header file
+ ************************************************************************/
+/*************************************************************************
+ * Change History
+ Jan 2005			Created
+ Jun 2005			Code cleaning by change some members to local variables in Read()
+ ************************************************************************/
+
+#ifndef _LWPDOCUMENT_HXX
+#define _LWPDOCUMENT_HXX
+
+
+#include "lwpobj.hxx"
+#include "lwpsortopt.hxx"
+#include "lwpuidoc.hxx"
+#include "lwplnopts.hxx"
+#include "lwpusrdicts.hxx"
+#include "lwpprtinfo.hxx"
+#include "lwpdlvlist.hxx"
+#include "lwpheader.hxx"
+#include "lwpfoundry.hxx"
+
+class IXFStream;
+class LwpVirtualLayout;
+/**
+ * @brief	Document object, represent document and division
+*/
+class LwpDocument : public LwpDLNFPVList
+{
+public:
+	LwpDocument(LwpObjectHeader &objHdr, LwpSvStream* pStrm);
+	~LwpDocument();
+
+private: 
+	//Data members in file format
+	LwpObjectID m_DocSockID;
+	sal_uInt16 m_nFlags;
+	sal_uInt32 m_nPersistentFlags;
+	enum
+	{
+		DOC_PROTECTED = 0x00000004UL,
+		/*#define DOC_USECONTENTS		0x00000008UL
+		#define DOC_LOCKREVISIONS		0x00000200UL			
+		#define DOC_LOCAL				0x00000400UL
+		*/
+		DOC_CHILDDOC =	0x00000800UL
+		/*#define DOC_DOPREVIEW			0x02000000UL
+		#define DOC_REBUILDENDNOTES		0x04000000UL
+		#define DOC_FILEPROTECTION		0x10000000UL
+		#define DOC_PERSISTENTBITS	(DOC_PROTECTED | DOC_USECONTENTS | DOC_LOCKREVISIONS | DOC_LOCAL | DOC_CHILDDOC | DOC_DOPREVIEW | DOC_REBUILDENDNOTES | DOC_FILEPROTECTION)
+		*/
+	};
+
+	//Code cleaning by change some members to local variables in Read()
+	//Reserve the comments for future use
+	//LwpSortOption* m_pDocSort;
+	//LwpUIDocument* m_pUIDoc;
+	LwpLineNumberOptions* m_pLnOpts;	
+	//LwpUserDictFiles* m_pUsrDicts;
+	//LwpPrinterInfo* m_pPrtInfo;
+	
+	LwpObjectID m_DivOpts;
+	LwpObjectID m_FootnoteOpts;
+	LwpObjectID m_DocData;
+	LwpObjectID m_DivInfo;
+	LwpAtomHolder m_Epoch;
+	
+	LwpObjectID m_WYSIWYGPageHints;
+	LwpObjectID m_VerDoc;
+	LwpObjectID m_STXInfo;
+
+protected:
+	void Read();	
+	void ReadPlug();
+	void ParseDocContent(IXFStream* pOutputStream);
+	void RegisterTextStyles();
+	void RegisterLayoutStyles();
+	
+	void RegisterStylesInPara();
+	void RegisterBulletStyles();
+	void RegisterGraphicsStyles();
+	void RegisterLinenumberStyles();
+	void RegisterFootnoteStyles();	
+	void RegisterDefaultParaStyles();
+	void ParseMasterDoc(IXFStream* pOutputStream);
+
+public:
+	void Parse(IXFStream* pOutputStream);
+	void RegisterStyle();
+	
+	inline sal_Bool IsChildDoc();
+	inline sal_Bool HonorProtection();
+	inline LwpObjectID* GetContentList();
+	inline LwpObjectID* GetDocData();
+	inline LwpObjectID* GetSocket();
+	
+	inline LwpFoundry* GetFoundry();
+	inline LwpObjectID* GetDivInfoID();
+	inline LwpObjectID* GetPageHintsID();
+	inline LwpObjectID* GetFootnoteOpts();
+	inline LwpObjectID* GetVerDoc();
+	LwpObjectID* GetValidFootnoteOpts();
+
+	sal_uInt16 GetEndnoteType();
+	LwpDocument* GetPreviousDivision();
+	LwpDocument* GetNextDivision();
+	LwpDocument* GetParentDivision();
+	LwpDocument* GetPreviousInGroup();
+
+	LwpDocument* GetNextInGroup();
+	LwpDocument* GetPreviousDivisionWithContents();
+	LwpDocument* GetLastDivisionWithContents();
+	LwpDocument* GetLastInGroupWithContents();
+	LwpDocument* GetRootDocument();
+	LwpDocument* GetFirstDivisionWithContentsThatIsNotOLE();
+	LwpDocument* GetLastDivisionThatHasEndnote();
+
+	LwpDocument* GetLastDivision();
+	LwpDocument* GetFirstDivision();
+	LwpVirtualLayout* GetEnSuperTableLayout();	
+	sal_Bool GetNumberOfPages(LwpDocument* pEndDivision, sal_uInt16& nCount);
+	sal_uInt16 GetMaxNumberOfPages();
+
+	sal_uInt16 GetNumberOfPagesBefore();
+	void ParseFrameInPage(IXFStream* pOutputStream);	
+
+private:
+	void MaxNumberOfPages(sal_uInt16& nNumPages);
+	void XFConvertFrameInPage(XFContentContainer* pCont);
+	void ChangeStyleName();
+	sal_Bool IsSkippedDivision();//add by 
+};
+
+inline sal_Bool LwpDocument::IsChildDoc()
+{
+	return (sal_Bool) ((m_nPersistentFlags & DOC_CHILDDOC) ? TRUE : FALSE);
+}
+inline sal_Bool LwpDocument::HonorProtection()
+{
+	return m_nPersistentFlags & DOC_PROTECTED ? sal_True : sal_False;
+}
+inline LwpObjectID* LwpDocument::GetContentList()
+{ 
+	return(m_pFoundry->GetContentManager()->GetContentList());
+}
+inline LwpObjectID* LwpDocument::GetSocket() 
+{
+	return &m_DocSockID;
+}
+inline LwpFoundry* LwpDocument::GetFoundry()
+{
+	return m_pFoundry;
+}
+inline LwpObjectID* LwpDocument::GetDivInfoID()
+{
+	return &m_DivInfo;
+}
+inline LwpObjectID* LwpDocument::GetPageHintsID()
+{
+	return &m_WYSIWYGPageHints;
+}
+inline LwpObjectID* LwpDocument::GetFootnoteOpts()
+{ 
+	return &m_FootnoteOpts;
+}
+inline LwpObjectID* LwpDocument::GetDocData()
+{
+	return &m_DocData;
+}
+inline LwpObjectID* LwpDocument::GetVerDoc()
+{
+	return &m_VerDoc;
+}
+
+/**
+ * @brief	DocumentSock object, divisions are embedded by document socket object
+*/
+class LwpDocSock : public LwpDLNFVList
+{
+public:
+	LwpDocSock(LwpObjectHeader &objHdr, LwpSvStream* pStrm);
+	~LwpDocSock(){};
+private:
+	LwpObjectID m_Doc;	
+protected:
+	void Read();	
+public:
+	void RegisterStyle();
+	void Parse(IXFStream* pOutputStream);
+};
+
+#endif
diff -urNp lotuswordpro.bak/source/filter/lwpdrawobj.cxx lotuswordpro/source/filter/lwpdrawobj.cxx
--- lotuswordpro.bak/source/filter/lwpdrawobj.cxx	1970-01-01 08:00:00.000000000 +0800
+++ lotuswordpro/source/filter/lwpdrawobj.cxx	2008-10-22 11:42:29.000000000 +0800
@@ -0,0 +1,1552 @@
+/*************************************************************************
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: IBM Corporation
+ *
+ *  Copyright: 2008 by IBM Corporation
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+/**
+ * @file 
+ * Implementation file of LwpDrawObjcts and associated class like LwpDrawGroup, LwpDrawRectange
+ *	and so on.
+ */
+#include "lwpglobalmgr.hxx"
+#include "lwpdrawobj.hxx"
+#include "lwptools.hxx"
+#include <tools/stream.hxx>
+
+#include "xfilter/xfframe.hxx"
+
+#include "xfilter/xfstylemanager.hxx"
+#include "xfilter/xfdrawstyle.hxx"
+#include "xfilter/xftextstyle.hxx"
+#include "xfilter/xfparastyle.hxx"
+#include "xfilter/xfimagestyle.hxx"
+#include "xfilter/xftextboxstyle.hxx"
+#include "xfilter/xfparagraph.hxx"
+#include "xfilter/xftextspan.hxx"
+#include "xfilter/xffont.hxx"
+
+#include "xfilter/xfdrawrect.hxx"
+#include "xfilter/xfdrawpath.hxx"
+#include "xfilter/xfdrawline.hxx"
+#include "xfilter/xfdrawpolygon.hxx"
+#include "xfilter/xfdrawellipse.hxx"
+#include "xfilter/xfdrawcircle.hxx"
+#include "xfilter/xfimage.hxx"
+
+#include "lwpcharsetmgr.hxx"
+#include "lwpsdwrect.hxx"
+
+/**
+ * @descr   Constructor of class LwpDrawObj
+ * @param   pStream   The memory stream which contains the lwp-sdw draw objects
+ */
+LwpDrawObj::LwpDrawObj(SvStream * pStream, DrawingOffsetAndScale* pTransData) :
+m_pStream(pStream), m_pTransData(pTransData), m_eType(OT_UNDEFINED)
+{
+	this->ReadObjHeaderRecord();
+}
+
+/**
+ * @descr   read the header record data of lwp-sdw-object
+ */
+void LwpDrawObj::ReadObjHeaderRecord()
+{
+	//flags
+	m_pStream->SeekRel(1);
+
+	//record Length
+	m_pStream->Read(&m_aObjHeader.nRecLen, sizeof(m_aObjHeader.nRecLen));
+
+	//boundrect
+	m_pStream->Read(&m_aObjHeader.nLeft, sizeof(m_aObjHeader.nLeft)); 
+	m_pStream->Read(&m_aObjHeader.nTop, sizeof(m_aObjHeader.nTop)); 
+	m_pStream->Read(&m_aObjHeader.nRight, sizeof(m_aObjHeader.nRight)); 
+	m_pStream->Read(&m_aObjHeader.nBottom, sizeof(m_aObjHeader.nBottom)); 
+	
+	//nextObj, prevObj
+	m_pStream->SeekRel(4);
+}
+
+/**
+ * @descr   read the style of closed lwp-sdw-object like: rectangle, ellipse and so on.
+ */
+void LwpDrawObj::ReadClosedObjStyle()
+{
+	if ((m_eType != OT_POLYGON) && (m_eType != OT_TEXTART))
+	{
+		m_pStream->SeekRel(8);
+	}
+
+	m_pStream->Read(&m_aClosedObjStyleRec.nLineWidth, sizeof(m_aClosedObjStyleRec.nLineWidth));
+	m_pStream->Read(&m_aClosedObjStyleRec.nLineStyle, sizeof(m_aClosedObjStyleRec.nLineStyle));
+
+	// pen color
+	m_pStream->Read(&m_aClosedObjStyleRec.aPenColor.nR, 1);
+	m_pStream->Read(&m_aClosedObjStyleRec.aPenColor.nG, 1);
+	m_pStream->Read(&m_aClosedObjStyleRec.aPenColor.nB, 1);
+	m_pStream->Read(&m_aClosedObjStyleRec.aPenColor.unused, 1);
+
+	// foreground color
+	m_pStream->Read(&m_aClosedObjStyleRec.aForeColor.nR, 1);
+	m_pStream->Read(&m_aClosedObjStyleRec.aForeColor.nG, 1);
+	m_pStream->Read(&m_aClosedObjStyleRec.aForeColor.nB, 1);
+	m_pStream->Read(&m_aClosedObjStyleRec.aForeColor.unused, 1);
+
+	// background color
+	m_pStream->Read(&m_aClosedObjStyleRec.aBackColor.nR, 1);
+	m_pStream->Read(&m_aClosedObjStyleRec.aBackColor.nG, 1);
+	m_pStream->Read(&m_aClosedObjStyleRec.aBackColor.nB, 1);
+	m_pStream->Read(&m_aClosedObjStyleRec.aBackColor.unused, 1);
+
+	// fill style
+	m_pStream->Read(&m_aClosedObjStyleRec.nFillType, sizeof(m_aClosedObjStyleRec.nFillType));
+	m_pStream->Read(m_aClosedObjStyleRec.pFillPattern, sizeof(m_aClosedObjStyleRec.pFillPattern));
+}
+
+/**
+ * @descr   set fill style of drawing objects
+ * @param   pStyle   pointer of the drawing xfstyle.
+ */
+void LwpDrawObj::SetFillStyle(XFDrawStyle* pStyle)
+{
+	if (!pStyle)
+	{
+		assert(false);
+		return;
+	}
+	
+	XFColor aForeColor(m_aClosedObjStyleRec.aForeColor.nR,
+		m_aClosedObjStyleRec.aForeColor.nG, m_aClosedObjStyleRec.aForeColor.nB);
+	XFColor aBackColor(m_aClosedObjStyleRec.aBackColor.nR,
+		m_aClosedObjStyleRec.aBackColor.nG, m_aClosedObjStyleRec.aBackColor.nB);
+	
+	switch (m_aClosedObjStyleRec.nFillType)
+	{
+	default: //fall through!
+	case FT_TRANSPARENT:
+		{
+			// set fill style : none
+			break;
+		}
+	case FT_SOLID:
+		{
+			pStyle->SetAreaColor(aForeColor);
+			break;
+		}
+	case FT_HORZHATCH:
+		{
+			pStyle->SetAreaColor(aBackColor);
+			pStyle->SetAreaLineStyle(enumXFAreaLineSingle, 0, 0.12, aForeColor);
+			break;
+		}
+	case FT_VERTHATCH:
+		{
+			pStyle->SetAreaColor(aBackColor);
+			pStyle->SetAreaLineStyle(enumXFAreaLineSingle, 90, 0.12, aForeColor);
+			break;
+		}
+	case FT_FDIAGHATCH:
+		{
+			pStyle->SetAreaColor(aBackColor);
+			pStyle->SetAreaLineStyle(enumXFAreaLineSingle, 135, 0.09, aForeColor);
+			break;
+		}
+	case FT_BDIAGHATCH:
+		{
+			pStyle->SetAreaColor(aBackColor);
+			pStyle->SetAreaLineStyle(enumXFAreaLineSingle, 45, 0.09, aForeColor);
+			break;
+		}
+	case FT_CROSSHATCH:
+		{
+			pStyle->SetAreaColor(aBackColor);
+			pStyle->SetAreaLineStyle(enumXFAreaLineCrossed, 0, 0.12, aForeColor);
+			break;
+		}
+	case FT_DIAGCROSSHATCH:
+		{
+			pStyle->SetAreaColor(aBackColor);
+			pStyle->SetAreaLineStyle(enumXFAreaLineCrossed, 45, 0.095, aForeColor);			
+			break;
+		}
+	}
+}
+
+/**
+ * @descr   set line/border style of drawing objects.
+ * @param   pStyle   pointer of the drawing xfstyle.
+ * @param   nWidth   width of line/border.
+ * @param   nLineStyle   flag of line/border style: none, dot or solid.
+ * @param   rColor   color of line/border.
+ */
+void LwpDrawObj::SetLineStyle(XFDrawStyle* pStyle, sal_uInt8 nWidth, sal_uInt8 nLineStyle,
+	const SdwColor& rColor)
+{
+	if (!pStyle)
+	{
+		assert(false);
+		return;
+	}
+	if (nWidth == 0)
+	{
+		nLineStyle = LS_NULL;
+	}
+	
+	if (nLineStyle == LS_NULL)
+	{
+		// set stroke:none
+		return;
+	}
+
+	if (nLineStyle == LS_DOT)
+	{
+		pStyle->SetLineDashStyle(enumXFLineDash, 1, 1, 0.05, 0.05, 0.05);
+	}
+
+	// line width
+	double fWidth = (double)nWidth/TWIPS_PER_CM;
+
+	// line color
+	XFColor aXFColor(rColor.nR, rColor.nG, rColor.nB);
+	
+	pStyle->SetLineStyle(fWidth, aXFColor);
+}
+
+/**
+ * @descr   set position of a drawing object in the frame.
+ * @param   pObj   pointer of the xf-drawing object
+ */
+void LwpDrawObj::SetPosition(XFFrame* pObj)
+{
+	double fOffsetX = 0.00, fOffsetY = 0.00;
+	double fScaleX = 1.00, fScaleY = 1.00;
+	if (m_pTransData)
+	{
+		fOffsetX = m_pTransData->fOffsetX;
+		fOffsetY = m_pTransData->fOffsetY;
+		fScaleX = m_pTransData->fScaleX;
+		fScaleY = m_pTransData->fScaleY;
+	}
+	
+	pObj->SetPosition((double)m_aObjHeader.nLeft/TWIPS_PER_CM * fScaleX+ fOffsetX,
+		(double)m_aObjHeader.nTop/TWIPS_PER_CM * fScaleY + fOffsetY,
+		(double)(m_aObjHeader.nRight-m_aObjHeader.nLeft)/TWIPS_PER_CM * fScaleX,
+		(double)(m_aObjHeader.nBottom-m_aObjHeader.nTop)/TWIPS_PER_CM * fScaleY);
+}
+
+/**
+ * @descr   set arrowhead of a xf-drawing object. only opened drawing objects can be assigned arrowheads
+ * @param   pOpenedObjStyle   the xf-drawing object which will be set arrowhead.
+ * @param   nArrowFlag   arrowhead flags of the object.
+ */
+void LwpDrawObj::SetArrowHead(XFDrawStyle* pOpenedObjStyle, sal_uInt8 nArrowFlag, sal_uInt8 nLineWidth)
+{
+	// no arrowhead
+	if (!nArrowFlag)
+	{
+		return;
+	}
+
+	if (!pOpenedObjStyle)
+	{
+		assert(false);
+		return;
+	}
+
+	// arrowhead flag of an object's start side
+	sal_uInt8 nLeftArrow = nArrowFlag & 0x0F;
+
+	// arrowhead flag of an object's end side
+	sal_uInt8 nRightArrow = (nArrowFlag & 0xF0) >> 4;
+
+	double fWidth_inch = (double)nLineWidth/TWIPS_PER_CM;
+	double fArrowSize_inch = fWidth_inch + 0.08;
+	double fArrowSize = fArrowSize_inch * CM_PER_INCH;
+
+	if (nLeftArrow)
+	{
+		pOpenedObjStyle->SetArrowStart( this->GetArrowName(nLeftArrow), fArrowSize, sal_True);
+	}
+	if (nRightArrow)
+	{
+		pOpenedObjStyle->SetArrowEnd( this->GetArrowName(nRightArrow), fArrowSize, sal_True);
+	}
+	
+}
+
+/**
+ * @descr   get arrow style name according to the flag.
+ * @param   nArrowStyle   style of the arrowhead.
+ * @return   nWhichSide   style name of the arrowhead.
+ */
+rtl::OUString LwpDrawObj::GetArrowName(sal_uInt8 nArrowStyle)
+{
+	// style name of arrowhead
+	rtl::OUString aArrowName;
+	
+	switch(nArrowStyle)
+	{
+	default:
+	case AH_ARROW_FULLARROW:
+		aArrowName = rtl::OUString::createFromAscii("Symmetric arrow");
+		break;
+	case AH_ARROW_HALFARROW:
+		aArrowName = rtl::OUString::createFromAscii("Arrow concave");
+		break;
+	case AH_ARROW_LINEARROW:
+		aArrowName = rtl::OUString::createFromAscii("arrow100");
+		break;
+	case AH_ARROW_INVFULLARROW:
+		aArrowName = rtl::OUString::createFromAscii("reverse arrow");
+		break;
+	case AH_ARROW_INVHALFARROW:
+		aArrowName = rtl::OUString::createFromAscii("reverse concave arrow");
+		break;
+	case AH_ARROW_INVLINEARROW:
+		aArrowName = rtl::OUString::createFromAscii("reverse line arrow");
+		break;
+	case AH_ARROW_TEE:
+		aArrowName = rtl::OUString::createFromAscii("Dimension lines");
+		break;
+	case AH_ARROW_SQUARE:
+		aArrowName = rtl::OUString::createFromAscii("Square");
+		break;
+	case AH_ARROW_CIRCLE:
+		aArrowName = rtl::OUString::createFromAscii("Circle");
+		break;
+	}
+
+	return aArrowName;
+}
+
+/**
+ * @descr   template method of creating drawing object from Lwp-Model to XF-Model
+ * @return   pointer of the drawing object of XF-Model.
+ */
+XFFrame* LwpDrawObj::CreateXFDrawObject()
+{
+	// read records
+	this->Read();
+
+	// register style
+	rtl::OUString aStyleName = this->RegisterStyle();
+
+	// create XF-Objects
+	XFFrame* pXFObj = NULL;
+	if (m_pTransData
+		&& FABS(m_pTransData->fOffsetX - m_pTransData->fLeftMargin) < THRESHOLD
+		&& FABS(m_pTransData->fOffsetY - m_pTransData->fTopMargin) < THRESHOLD
+		&& FABS(m_pTransData->fScaleX - 1.0) < THRESHOLD
+		&& FABS(m_pTransData->fScaleY - 1.0) < THRESHOLD)
+	{
+		pXFObj = this->CreateStandardDrawObj(aStyleName);
+	}
+	else
+	{
+		pXFObj = this->CreateDrawObj(aStyleName);
+	}
+
+	// set anchor type
+	if (pXFObj)
+	{
+		pXFObj->SetAnchorType(enumXFAnchorFrame);
+	}
+	
+	return pXFObj;
+}
+
+/**
+ * @descr   Constructor of class LwpDrawLine
+ * @param   pStream   The memory stream which contains the lwp-sdw draw objects
+ */
+LwpDrawLine::LwpDrawLine(SvStream * pStream, DrawingOffsetAndScale* pTransData)
+: LwpDrawObj(pStream, pTransData)
+{
+}
+
+/**
+ * @descr   reading function of class LwpDrawLine
+ */
+void LwpDrawLine::Read()
+{
+	m_pStream->Read(&m_aLineRec.nStartX, sizeof(m_aLineRec.nStartX)); 
+	m_pStream->Read(&m_aLineRec.nStartY, sizeof(m_aLineRec.nStartY)); 
+	m_pStream->Read(&m_aLineRec.nEndX, sizeof(m_aLineRec.nEndX)); 
+	m_pStream->Read(&m_aLineRec.nEndY, sizeof(m_aLineRec.nEndY)); 
+	m_pStream->Read(&m_aLineRec.nLineWidth, sizeof(m_aLineRec.nLineWidth)); 
+	m_pStream->Read(&m_aLineRec.nLineEnd,sizeof(m_aLineRec.nLineEnd)); 
+	m_pStream->Read(&m_aLineRec.nLineStyle, sizeof(m_aLineRec.nLineStyle));
+
+	m_pStream->Read(&m_aLineRec.aPenColor.nR, 1);
+	m_pStream->Read(&m_aLineRec.aPenColor.nG, 1);
+	m_pStream->Read(&m_aLineRec.aPenColor.nB, 1);
+	m_pStream->Read(&m_aLineRec.aPenColor.unused, 1);
+}
+
+rtl::OUString LwpDrawLine::RegisterStyle()
+{
+	XFDrawStyle* pStyle = new XFDrawStyle();
+
+	// set line style
+	this->SetLineStyle(pStyle, m_aLineRec.nLineWidth, m_aLineRec.nLineStyle, m_aLineRec.aPenColor);
+
+	// set arrow head
+	this->SetArrowHead(pStyle, m_aLineRec.nLineEnd, m_aLineRec.nLineWidth);
+	
+	XFStyleManager* pXFStyleManager = LwpGlobalMgr::GetInstance()->GetXFStyleManager();
+	return pXFStyleManager->AddStyle(pStyle)->GetStyleName();
+
+}
+
+XFFrame* LwpDrawLine::CreateDrawObj(const rtl::OUString& rStyleName )
+{
+	XFDrawPath* pLine = new XFDrawPath();
+	pLine->MoveTo(XFPoint((double)(m_aLineRec.nStartX)/TWIPS_PER_CM * m_pTransData->fScaleX,
+		(double)(m_aLineRec.nStartY)/TWIPS_PER_CM * m_pTransData->fScaleY));
+	pLine->LineTo(XFPoint((double)(m_aLineRec.nEndX)/TWIPS_PER_CM * m_pTransData->fScaleX,
+		(double)(m_aLineRec.nEndY)/TWIPS_PER_CM * m_pTransData->fScaleY));
+	this->SetPosition(pLine);
+	
+	pLine->SetStyleName(rStyleName);
+
+	return pLine;
+}
+
+XFFrame* LwpDrawLine::CreateStandardDrawObj(const  OUString& rStyleName)
+{
+	XFDrawLine* pLine = new XFDrawLine();
+	pLine->SetStartPoint((double)(m_aLineRec.nStartX)/TWIPS_PER_CM,(double)(m_aLineRec.nStartY)/TWIPS_PER_CM);
+	pLine->SetEndPoint((double)(m_aLineRec.nEndX)/TWIPS_PER_CM,(double)(m_aLineRec.nEndY)/TWIPS_PER_CM);
+
+	pLine->SetStyleName(rStyleName);
+	return pLine;
+}
+
+/**
+ * @descr   Constructor of class LwpDrawPolyLine
+ * @param   pStream   The memory stream which contains the lwp-sdw draw objects
+ */
+LwpDrawPolyLine::LwpDrawPolyLine(SvStream * pStream, DrawingOffsetAndScale* pTransData)
+: LwpDrawObj(pStream, pTransData), m_pVector(NULL)
+{
+}
+LwpDrawPolyLine::~LwpDrawPolyLine()
+{
+	if (m_pVector)
+	{
+		delete [] m_pVector;
+		m_pVector = NULL;
+	}
+}
+
+/**
+ * @descr   reading function of class LwpDrawPolyLine
+ */
+void LwpDrawPolyLine::Read()
+{
+		m_pStream->Read(&m_aPolyLineRec.nLineWidth, 1); 
+		m_pStream->Read(&m_aPolyLineRec.nLineEnd, 1); 
+		m_pStream->Read(&m_aPolyLineRec.nLineStyle, 1); 
+		m_pStream->Read(&m_aPolyLineRec.aPenColor.nR, 1);
+		m_pStream->Read(&m_aPolyLineRec.aPenColor.nG, 1);
+		m_pStream->Read(&m_aPolyLineRec.aPenColor.nB, 1);
+		m_pStream->Read(&m_aPolyLineRec.aPenColor.unused, 1);
+		m_pStream->Read(&m_aPolyLineRec.nNumPoints, 2); 
+
+		m_pVector= new SdwPoint [m_aPolyLineRec.nNumPoints];
+
+		for (sal_uInt16 nC = 0; nC < m_aPolyLineRec.nNumPoints; nC++)
+		{
+			m_pStream->Read(&m_pVector[nC].x,2); 
+			m_pStream->Read(&m_pVector[nC].y,2); 
+		}
+}
+
+rtl::OUString LwpDrawPolyLine::RegisterStyle()
+{
+	XFDrawStyle* pStyle = new XFDrawStyle();
+
+	// set line style
+	this->SetLineStyle(pStyle, m_aPolyLineRec.nLineWidth, m_aPolyLineRec.nLineStyle,
+		m_aPolyLineRec.aPenColor);
+
+	// set arrow head
+	this->SetArrowHead(pStyle, m_aPolyLineRec.nLineEnd, m_aPolyLineRec.nLineWidth);
+	
+	XFStyleManager* pXFStyleManager = LwpGlobalMgr::GetInstance()->GetXFStyleManager();
+	return pXFStyleManager->AddStyle(pStyle)->GetStyleName();
+}
+
+XFFrame* LwpDrawPolyLine::CreateDrawObj(const rtl::OUString& rStyleName )
+{
+	XFDrawPath* pPolyline = new XFDrawPath();
+	pPolyline->MoveTo(XFPoint((double)m_pVector[0].x/TWIPS_PER_CM * m_pTransData->fScaleX,
+			(double)m_pVector[0].y/TWIPS_PER_CM * m_pTransData->fScaleY));
+	for (sal_uInt8 nC = 1; nC < m_aPolyLineRec.nNumPoints; nC++)
+	{
+		pPolyline->LineTo(XFPoint((double)m_pVector[nC].x/TWIPS_PER_CM * m_pTransData->fScaleX,
+			(double)m_pVector[nC].y/TWIPS_PER_CM * m_pTransData->fScaleY));
+	}
+	this->SetPosition(pPolyline);
+	
+	pPolyline->SetStyleName(rStyleName);
+	
+	return pPolyline;
+}
+
+XFFrame* LwpDrawPolyLine::CreateStandardDrawObj(const  OUString& rStyleName)
+{
+	XFDrawPolyline* pPolyline = new XFDrawPolyline();
+	for (sal_uInt8 nC = 0; nC < m_aPolyLineRec.nNumPoints; nC++)
+	{
+		pPolyline->AddPoint((double)m_pVector[nC].x/TWIPS_PER_CM,
+			(double)m_pVector[nC].y/TWIPS_PER_CM);
+	}
+
+	pPolyline->SetStyleName(rStyleName);
+
+	return pPolyline;
+}
+
+/**
+ * @descr   Constructor of class LwpDrawPolygon
+ * @param   pStream   The memory stream which contains the lwp-sdw draw objects
+ */
+LwpDrawPolygon::LwpDrawPolygon(SvStream * pStream, DrawingOffsetAndScale* pTransData)
+: LwpDrawObj(pStream, pTransData)
+{
+}
+LwpDrawPolygon::~LwpDrawPolygon()
+{
+	if (m_pVector)
+	{
+		delete m_pVector;
+		m_pVector = NULL;
+	}
+}
+
+/**
+ * @descr   reading function of class LwpDrawPolygon
+ */
+void LwpDrawPolygon::Read()
+{
+	this->ReadClosedObjStyle();
+	m_pStream->Read(&m_nNumPoints, sizeof(m_nNumPoints));
+
+	m_pVector = new SdwPoint [m_nNumPoints];
+
+	for (sal_uInt16 nC = 0; nC < m_nNumPoints; nC++)
+	{
+		m_pStream->Read(&m_pVector[nC].x, 2); 
+		m_pStream->Read(&m_pVector[nC].y, 2); 
+	}
+}
+
+rtl::OUString LwpDrawPolygon::RegisterStyle()
+{
+	XFDrawStyle* pStyle = new XFDrawStyle();
+
+	// set line style
+	this->SetLineStyle(pStyle, m_aClosedObjStyleRec.nLineWidth, m_aClosedObjStyleRec.nLineStyle,
+		m_aClosedObjStyleRec.aPenColor);
+
+	// set fill style
+	this->SetFillStyle(pStyle);
+
+	XFStyleManager* pXFStyleManager = LwpGlobalMgr::GetInstance()->GetXFStyleManager();
+	return pXFStyleManager->AddStyle(pStyle)->GetStyleName();
+}
+
+XFFrame* LwpDrawPolygon::CreateDrawObj(const rtl::OUString& rStyleName)
+{
+	XFDrawPath* pPolygon = new XFDrawPath();
+	pPolygon->MoveTo(XFPoint((double)m_pVector[0].x/TWIPS_PER_CM * m_pTransData->fScaleX,
+			(double)m_pVector[0].y/TWIPS_PER_CM * m_pTransData->fScaleY));
+	for (sal_uInt16 nC = 1; nC < m_nNumPoints; nC++)
+	{
+		pPolygon->LineTo(XFPoint((double)m_pVector[nC].x/TWIPS_PER_CM * m_pTransData->fScaleX,
+			(double)m_pVector[nC].y/TWIPS_PER_CM * m_pTransData->fScaleY));
+	}
+	pPolygon->ClosePath();
+	this->SetPosition(pPolygon);
+	pPolygon->SetStyleName(rStyleName);
+
+	return pPolygon;
+}
+
+XFFrame* LwpDrawPolygon::CreateStandardDrawObj(const  OUString& rStyleName)
+{
+	XFDrawPolygon* pPolygon = new XFDrawPolygon();
+	for (sal_uInt16 nC = 0; nC < m_nNumPoints; nC++)
+	{
+		pPolygon->AddPoint((double)m_pVector[nC].x/TWIPS_PER_CM,
+			(double)m_pVector[nC].y/TWIPS_PER_CM);
+	}
+
+	pPolygon->SetStyleName(rStyleName);
+
+	return pPolygon;
+}
+
+/**
+ * @descr   Constructor of class LwpDrawRectangle
+ * @param   pStream   The memory stream which contains the lwp-sdw draw objects
+ */
+LwpDrawRectangle::LwpDrawRectangle(SvStream * pStream, DrawingOffsetAndScale* pTransData)
+: LwpDrawObj(pStream, pTransData)
+{
+}
+
+/**
+ * @descr   reading function of class LwpDrawRectangle
+ */
+void LwpDrawRectangle::Read()
+{
+	this->ReadClosedObjStyle();
+	
+
+	sal_uInt8 nPointsCount;
+	if (m_eType == OT_RNDRECT)
+	{
+		nPointsCount = 16;
+		m_pStream->SeekRel(4); // corner points
+	}
+	else
+	{
+		nPointsCount = 4;
+	}
+	
+	for (sal_uInt8 nC = 0; nC < nPointsCount; nC++)
+	{
+		m_pStream->Read(&m_aVector[nC].x,2); 
+		m_pStream->Read(&m_aVector[nC].y,2); 
+	}
+}
+
+rtl::OUString LwpDrawRectangle::RegisterStyle()
+{
+	XFDrawStyle* pStyle = new XFDrawStyle();
+
+	// set line style
+	this->SetLineStyle(pStyle, m_aClosedObjStyleRec.nLineWidth, m_aClosedObjStyleRec.nLineStyle,
+		m_aClosedObjStyleRec.aPenColor);
+
+	// set fill style
+	this->SetFillStyle(pStyle);
+	
+	XFStyleManager* pXFStyleManager = LwpGlobalMgr::GetInstance()->GetXFStyleManager();
+	return pXFStyleManager->AddStyle(pStyle)->GetStyleName();
+}
+
+XFFrame* LwpDrawRectangle::CreateDrawObj(const rtl::OUString& rStyleName)
+{
+	if (m_eType == OT_RNDRECT)
+	{
+		return this->CreateRoundedRect(rStyleName);
+	}
+	else
+	{
+		XFDrawPath* pRect = new XFDrawPath();
+		pRect->MoveTo(XFPoint((double)m_aVector[0].x/TWIPS_PER_CM * m_pTransData->fScaleX,
+			(double)m_aVector[0].y/TWIPS_PER_CM * m_pTransData->fScaleY));
+		for (sal_uInt8 nC = 1; nC < 4; nC++)
+		{
+			pRect->LineTo(XFPoint((double)m_aVector[nC].x/TWIPS_PER_CM * m_pTransData->fScaleX,
+				(double)m_aVector[nC].y/TWIPS_PER_CM * m_pTransData->fScaleY));
+		}
+		pRect->LineTo(XFPoint((double)m_aVector[0].x/TWIPS_PER_CM * m_pTransData->fScaleX,
+				(double)m_aVector[0].y/TWIPS_PER_CM * m_pTransData->fScaleY));		
+		pRect->ClosePath(sal_True);
+		this->SetPosition(pRect);
+
+		pRect->SetStyleName(rStyleName);
+
+		return pRect;
+	}
+}
+
+XFFrame* LwpDrawRectangle::CreateRoundedRect(const rtl::OUString& rStyleName)
+{
+	XFDrawPath* pRoundedRect = new XFDrawPath();
+	pRoundedRect->MoveTo(XFPoint((double)m_aVector[0].x/TWIPS_PER_CM * m_pTransData->fScaleX,
+	(double)m_aVector[0].y/TWIPS_PER_CM * m_pTransData->fScaleY));
+
+	sal_uInt8 nPtIndex = 1;
+	for (sal_uInt8 nC = 0; nC < 7; nC++)
+	{
+		if (nC%2 == 0)
+		{
+			XFPoint aCtrl1((double)m_aVector[nPtIndex].x/TWIPS_PER_CM * m_pTransData->fScaleX,
+				(double)m_aVector[nPtIndex].y/TWIPS_PER_CM * m_pTransData->fScaleY);
+			nPtIndex++;
+			XFPoint aCtrl2((double)m_aVector[nPtIndex].x/TWIPS_PER_CM * m_pTransData->fScaleX,
+				(double)m_aVector[nPtIndex].y/TWIPS_PER_CM * m_pTransData->fScaleY);
+			nPtIndex++;
+			XFPoint aDest((double)m_aVector[nPtIndex].x/TWIPS_PER_CM * m_pTransData->fScaleX,
+				(double)m_aVector[nPtIndex].y/TWIPS_PER_CM * m_pTransData->fScaleY);
+			nPtIndex++;
+			
+			pRoundedRect->CurveTo(aDest, aCtrl1, aCtrl2);
+		}
+		else
+		{
+			XFPoint aDest((double)m_aVector[nPtIndex].x/TWIPS_PER_CM * m_pTransData->fScaleX,
+				(double)m_aVector[nPtIndex].y/TWIPS_PER_CM * m_pTransData->fScaleY);
+			nPtIndex++;
+			
+			pRoundedRect->LineTo(aDest);
+		}
+	}
+
+	pRoundedRect->LineTo(XFPoint((double)m_aVector[0].x/TWIPS_PER_CM * m_pTransData->fScaleX,
+				(double)m_aVector[0].y/TWIPS_PER_CM * m_pTransData->fScaleY));
+	pRoundedRect->ClosePath(sal_True);
+	this->SetPosition(pRoundedRect);
+
+	pRoundedRect->SetStyleName(rStyleName);
+
+	return pRoundedRect;
+}
+
+XFFrame* LwpDrawRectangle::CreateStandardDrawObj(const  OUString& rStyleName)
+{
+	if (m_eType == OT_RNDRECT)
+	{
+		return this->CreateRoundedRect(rStyleName);
+	}
+	else
+	{
+		XFDrawRect* pRect = new XFDrawRect();
+		double fStartX, fStartY, fWidth, fHeight;
+		double fRotAngle = 0.0;
+		SdwRectangle aSdwRect;
+		Rectangle aOriginalRect;
+		Point aPt0, aPt1, aPt2, aPt3;
+
+		aPt0.setX(m_aVector[0].x); aPt0.setY(m_aVector[0].y);
+		aPt1.setX(m_aVector[1].x); aPt1.setY(m_aVector[1].y);
+		aPt2.setX(m_aVector[2].x); aPt2.setY(m_aVector[2].y);
+		aPt3.setX(m_aVector[3].x); aPt3.setY(m_aVector[3].y);
+
+		aSdwRect = SdwRectangle(aPt0, aPt1, aPt2, aPt3);
+		if (aSdwRect.IsRectRotated())
+		{
+			aOriginalRect = aSdwRect.GetOriginalRect();
+			fRotAngle = aSdwRect.GetRotationAngle();
+		}
+		else
+		{
+			aOriginalRect = Rectangle(aPt0, aPt2);
+		}
+
+		fStartX = aOriginalRect.TopLeft().X();
+		fStartY = aOriginalRect.TopLeft().Y();
+		fWidth = aOriginalRect.GetWidth();
+		fHeight = aOriginalRect.GetHeight();
+
+		pRect->SetStartPoint(XFPoint(fStartX/TWIPS_PER_CM + m_pTransData->fOffsetX,
+			fStartY/TWIPS_PER_CM + m_pTransData->fOffsetY));
+		pRect->SetSize(fWidth/TWIPS_PER_CM, fHeight/TWIPS_PER_CM);
+
+		if (aSdwRect.IsRectRotated())
+		{
+			pRect->SetRotate( fRotAngle / PI * 180);// aXFCenter);
+		}
+
+		pRect->SetStyleName(rStyleName);
+
+		return pRect;
+	}
+}
+
+/**
+ * @descr   Constructor of class LwpDrawEllipse
+ * @param   pStream   The memory stream which contains the lwp-sdw draw objects
+ */
+LwpDrawEllipse::LwpDrawEllipse(SvStream * pStream, DrawingOffsetAndScale* pTransData)
+: LwpDrawObj(pStream, pTransData)
+{
+}
+
+/**
+ * @descr   reading function of class LwpDrawEllipse
+ */
+void LwpDrawEllipse::Read()
+{
+	this->ReadClosedObjStyle();
+	
+	for (sal_uInt8 nC = 0; nC < 13; nC++)
+	{
+		m_pStream->Read(&m_aVector[nC].x,2); 
+		m_pStream->Read(&m_aVector[nC].y,2); 
+	}
+}
+
+rtl::OUString LwpDrawEllipse::RegisterStyle()
+{
+	XFDrawStyle* pStyle = new XFDrawStyle();
+
+	// set line style
+	this->SetLineStyle(pStyle, m_aClosedObjStyleRec.nLineWidth, m_aClosedObjStyleRec.nLineStyle,
+		m_aClosedObjStyleRec.aPenColor);
+
+	// set fill style
+	this->SetFillStyle(pStyle);
+
+	XFStyleManager* pXFStyleManager = LwpGlobalMgr::GetInstance()->GetXFStyleManager();
+	return pXFStyleManager->AddStyle(pStyle)->GetStyleName();
+}
+
+XFFrame* LwpDrawEllipse::CreateDrawObj(const rtl::OUString& rStyleName )
+{
+	XFDrawPath* pEllipse = new XFDrawPath();
+	pEllipse->MoveTo(XFPoint((double)m_aVector[0].x/TWIPS_PER_CM * m_pTransData->fScaleX,
+		(double)m_aVector[0].y/TWIPS_PER_CM * m_pTransData->fScaleY));
+	sal_uInt8 nPtIndex = 1;
+	for (sal_uInt8 nC = 0; nC < 4; nC++)
+	{
+		XFPoint aCtrl1((double)m_aVector[nPtIndex].x/TWIPS_PER_CM * m_pTransData->fScaleX,
+		(double)m_aVector[nPtIndex].y/TWIPS_PER_CM * m_pTransData->fScaleY);
+		nPtIndex++;
+		XFPoint aCtrl2((double)m_aVector[nPtIndex].x/TWIPS_PER_CM * m_pTransData->fScaleX,
+		(double)m_aVector[nPtIndex].y/TWIPS_PER_CM * m_pTransData->fScaleY);
+		nPtIndex++;
+		XFPoint aDest((double)m_aVector[nPtIndex].x/TWIPS_PER_CM * m_pTransData->fScaleX,
+		(double)m_aVector[nPtIndex].y/TWIPS_PER_CM * m_pTransData->fScaleY);
+		nPtIndex++;
+
+		pEllipse->CurveTo(aDest, aCtrl1, aCtrl2);
+	}
+	pEllipse->ClosePath(sal_True);
+	this->SetPosition(pEllipse);
+
+	pEllipse->SetStyleName(rStyleName);
+
+	return pEllipse;
+}
+
+XFFrame* LwpDrawEllipse::CreateStandardDrawObj(const  OUString& rStyleName)
+{
+	return this->CreateDrawObj(rStyleName);
+}
+
+/**
+ * @descr   Constructor of class LwpDrawArc
+ * @param   pStream   The memory stream which contains the lwp-sdw draw objects
+ */
+LwpDrawArc::LwpDrawArc(SvStream * pStream, DrawingOffsetAndScale* pTransData)
+: LwpDrawObj(pStream, pTransData)
+{
+}
+
+/**
+ * @descr   reading function of class LwpDrawArc
+ */
+void LwpDrawArc::Read()
+{
+	m_pStream->SeekRel(16);// arcRect, startPt, endPt
+
+	m_pStream->Read(&m_aArcRec.nLineWidth, sizeof(m_aArcRec.nLineWidth));
+	m_pStream->Read(&m_aArcRec.nLineStyle, sizeof(m_aArcRec.nLineStyle));
+	m_pStream->Read(&m_aArcRec.aPenColor.nR, 1);
+	m_pStream->Read(&m_aArcRec.aPenColor.nG, 1);
+	m_pStream->Read(&m_aArcRec.aPenColor.nB, 1);
+	m_pStream->Read(&m_aArcRec.aPenColor.unused, 1);
+	m_pStream->Read(&m_aArcRec.nLineEnd, sizeof(m_aArcRec.nLineEnd));
+	
+	for (sal_uInt8 nC = 0; nC < 4; nC++)
+	{
+		m_pStream->Read(&m_aVector[nC].x,2); 
+		m_pStream->Read(&m_aVector[nC].y,2); 
+	}
+}
+
+rtl::OUString LwpDrawArc::RegisterStyle()
+{
+	XFDrawStyle* pStyle = new XFDrawStyle();
+
+	// set line style
+	this->SetLineStyle(pStyle, m_aArcRec.nLineWidth, m_aArcRec.nLineStyle,
+		m_aArcRec.aPenColor);
+
+	// set arrow head
+	this->SetArrowHead(pStyle, m_aArcRec.nLineEnd, m_aArcRec.nLineWidth);
+
+	XFStyleManager* pXFStyleManager = LwpGlobalMgr::GetInstance()->GetXFStyleManager();
+	return pXFStyleManager->AddStyle(pStyle)->GetStyleName();
+}
+
+XFFrame* LwpDrawArc::CreateDrawObj(const rtl::OUString& rStyleName )
+{
+	XFDrawPath* pArc = new XFDrawPath();
+	pArc->MoveTo(XFPoint((double)m_aVector[0].x/TWIPS_PER_CM * m_pTransData->fScaleX,
+		(double)m_aVector[0].y/TWIPS_PER_CM * m_pTransData->fScaleY));
+	XFPoint aDest((double)m_aVector[3].x/TWIPS_PER_CM * m_pTransData->fScaleX,
+		(double)m_aVector[3].y/TWIPS_PER_CM * m_pTransData->fScaleY);
+	XFPoint aCtl1((double)m_aVector[1].x/TWIPS_PER_CM * m_pTransData->fScaleX,
+		(double)m_aVector[1].y/TWIPS_PER_CM * m_pTransData->fScaleY);
+	XFPoint aCtl2((double)m_aVector[2].x/TWIPS_PER_CM* m_pTransData->fScaleX,
+		(double)m_aVector[2].y/TWIPS_PER_CM * m_pTransData->fScaleY);
+	pArc->CurveTo(aDest, aCtl1, aCtl2);
+//	pArc->CurveTo(XFPoint((double)m_aVector[3].x/TWIPS_PER_CM, (double)m_aVector[3].y/TWIPS_PER_CM),
+//		XFPoint((double)m_aVector[1].x/TWIPS_PER_CM, (double)m_aVector[1].y/TWIPS_PER_CM),
+//		XFPoint((double)m_aVector[2].x/TWIPS_PER_CM, (double)m_aVector[2].y/TWIPS_PER_CM));
+	this->SetPosition(pArc);
+
+	pArc->SetStyleName(rStyleName);
+	
+	return pArc;
+}
+
+XFFrame* LwpDrawArc::CreateStandardDrawObj(const  OUString& rStyleName)
+{
+	return this->CreateDrawObj(rStyleName);
+}
+
+/**
+ * @descr   Constructor of class LwpDrawTextBox
+ * @param   pStream   The memory stream which contains the lwp-sdw draw objects
+ */
+LwpDrawTextBox::LwpDrawTextBox(SvStream* pStream) : LwpDrawObj(pStream)
+{
+}
+
+LwpDrawTextBox::~LwpDrawTextBox()
+{
+	if (m_aTextRec.pTextString)
+	{
+		delete [] m_aTextRec.pTextString;
+		m_aTextRec.pTextString = NULL;
+	}
+}
+
+void LwpDrawTextBox::SetFontStyle(XFFont* pFont, SdwTextBoxRecord* pRec)
+{
+	// color
+	XFColor aXFColor(pRec->aTextColor.nR, pRec->aTextColor.nG,
+			pRec->aTextColor.nB);
+	pFont->SetColor(aXFColor);
+	//size
+	pFont->SetFontSize(pRec->nTextSize/20);
+	// bold
+	pFont->SetBold((sal_Bool)((pRec->nTextAttrs & TA_BOLD) != 0));
+	// italic
+	pFont->SetItalic((sal_Bool)((pRec->nTextAttrs & TA_ITALIC) != 0));
+	// strike-through
+	if (pRec->nTextAttrs & TA_STRIKETHRU)
+	{
+		pFont->SetCrossout(enumXFCrossoutSignel);
+	}
+	else
+	{
+		pFont->SetCrossout(enumXFCrossoutNone);
+	}
+	// underline
+	if (pRec->nTextAttrs & TA_UNDERLINE)
+	{
+		pFont->SetUnderline(enumXFUnderlineSingle);
+	}
+	else if (pRec->nTextAttrs & TA_WORDUNDERLINE)
+	{
+		pFont->SetUnderline(enumXFUnderlineSingle, sal_True);
+	}
+	else if (pRec->nTextAttrs & TA_DOUBLEUNDER)
+	{
+		pFont->SetUnderline(enumXFUnderlineDouble);
+	}
+	else
+	{
+		pFont->SetUnderline(enumXFUnderlineNone);
+	}
+	// small-caps
+	if (pRec->nTextAttrs & TA_SMALLCAPS)
+	{
+		pFont->SetTransform(enumXFTransformSmallCaps);
+	}
+}
+
+/**
+ * @descr   reading function of class LwpDrawTextBox
+ */
+void LwpDrawTextBox::Read()
+{
+	m_pStream->Read(&m_aVector.x, 2);
+	m_pStream->Read(&m_aVector.y, 2);
+	m_pStream->Read(&m_aTextRec.nTextWidth, sizeof(m_aTextRec.nTextWidth));
+
+	if (m_aTextRec.nTextWidth == 0)
+	{
+		m_aTextRec.nTextWidth = 1;
+	}
+
+	m_pStream->Read(&m_aTextRec.nTextHeight, sizeof(m_aTextRec.nTextHeight));
+	m_pStream->Read(m_aTextRec.tmpTextFaceName, DRAW_FACESIZE);
+	m_pStream->SeekRel(1);// PitchAndFamily
+
+	m_pStream->Read(&m_aTextRec.nTextSize, sizeof(m_aTextRec.nTextSize));
+
+	bool TextSizeIsCellHeight = true;
+	if (m_aTextRec.nTextSize < 0)
+	{
+		TextSizeIsCellHeight = false;
+		m_aTextRec.nTextSize = -m_aTextRec.nTextSize;
+	}
+
+	//color
+	m_pStream->Read(&m_aTextRec.aTextColor.nR, 1); 
+	m_pStream->Read(&m_aTextRec.aTextColor.nG, 1); 
+	m_pStream->Read(&m_aTextRec.aTextColor.nB, 1);
+	m_pStream->Read(&m_aTextRec.aTextColor.unused, 1); 
+
+	m_pStream->Read(&m_aTextRec.nTextAttrs, sizeof(m_aTextRec.nTextAttrs));
+	m_pStream->Read(&m_aTextRec.nTextCharacterSet, sizeof(m_aTextRec.nTextCharacterSet));
+	m_pStream->Read(&m_aTextRec.nTextRotation, sizeof(m_aTextRec.nTextRotation));
+	m_pStream->Read(&m_aTextRec.nTextExtraSpacing, sizeof(m_aTextRec.nTextExtraSpacing));
+
+	/*#ifdef JAPANESE_ENABLED //For Amipro Support KOBA-WADA
+		lubyte compText[3];
+		lsshort TextLength;
+		lubyte * pTextString;
+		cBinaryData.GetUBytes(compText, 2);
+		compText[2] = '\0';
+		if (compText[0] == 0 && compText[1] == 0 && recLen > 105 )
+		{
+			// AmiPro R3.1J's extended text object format
+			TextLength = recLen - 71 - 34;
+			cBinaryData.SkipUBytes(32);
+
+			pTextString = new lubyte[TextLength];
+
+			LASSERT(pTextString != LNULL);
+
+			cBinaryData.GetUBytes(pTextString, TextLength);
+		}
+		else
+		{
+			// AmiPro R3.X original text object format
+
+			// some draw files in version 1.2 have an extra byte following '\0'.
+			// can't rely on that, so read in the whole string into memory.
+			TextLength = recLen - 71;
+			pTextString = new lubyte[TextLength];
+
+			LASSERT(pTextString != LNULL);
+
+			strcpy((char *)pTextString, (const char *)compText);
+			cBinaryData.GetUBytes(pTextString + 2, TextLength - 2);
+		}
+#else*/
+		// some draw files in version 1.2 have an extra byte following '\0'.
+		// can't rely on that, so read in the whole string into memory.
+
+		// the 71 is the fixed length before text content in textbox record
+		sal_Int16 TextLength = m_aObjHeader.nRecLen - 71;
+		m_aTextRec.pTextString = new sal_uInt8 [TextLength];
+
+		m_pStream->Read(m_aTextRec.pTextString, TextLength);
+
+//#endif // AmiPro
+	
+}
+
+rtl::OUString LwpDrawTextBox::RegisterStyle()
+{
+	XFParaStyle* pStyle = new XFParaStyle();
+
+	// font style
+	// the pFont need to be deleted myself?
+	XFFont* pFont = new XFFont();
+
+	rtl_TextEncoding aEncoding =  RTL_TEXTENCODING_MS_1252;
+	rtl::OUString aFontName = rtl::OUString((sal_Char*)m_aTextRec.tmpTextFaceName,
+		strlen((char*)m_aTextRec.tmpTextFaceName), aEncoding);
+	pFont->SetFontName(aFontName);
+
+	this->SetFontStyle(pFont, &m_aTextRec);
+
+	pStyle->SetFont(pFont);
+	
+	XFStyleManager* pXFStyleManager = LwpGlobalMgr::GetInstance()->GetXFStyleManager();
+	return pXFStyleManager->AddStyle(pStyle)->GetStyleName();
+}
+
+XFFrame* LwpDrawTextBox::CreateDrawObj(const rtl::OUString& rStyleName )
+{
+	XFFrame* pTextBox = new XFFrame(sal_True);
+/*	this->SetPosition(pTextBox);
+	XFRect aBoundRect((double)m_aObjHeader.nLeft/TWIPS_PER_CM, (double)m_aObjHeader.nTop/TWIPS_PER_CM,
+		(double)(m_aObjHeader.nRight-m_aObjHeader.nLeft)/TWIPS_PER_CM, (double)(m_aObjHeader.nBottom-m_aObjHeader.nTop)/TWIPS_PER_CM);
+	pTextBox->SetPosition(aBoundRect);*/
+
+	sal_Int16 TextLength = m_aObjHeader.nRecLen - 71;
+	rtl_TextEncoding aEncoding;
+	if (!m_aTextRec.nTextCharacterSet)
+	{
+		aEncoding = gsl_getSystemTextEncoding();
+	}
+	else
+	{
+		// temporary code, need to create Encoding from the value of nTextCharacterSet
+		aEncoding = LwpCharSetMgr::GetInstance()->GetTextCharEncoding();
+	}
+
+//	XFTextSpan* pTextSpan = new XFTextSpan();
+//	pTextSpan->SetText(rtl::OUString((sal_Char*)m_aTextRec.pTextString, (TextLength-2), aEncoding));
+//	pTextSpan->SetStyleName(rStyleName);
+
+	XFParagraph* pXFPara = new XFParagraph();
+	pXFPara->Add(rtl::OUString((sal_Char*)m_aTextRec.pTextString, (TextLength-2), aEncoding));
+	pXFPara->SetStyleName(rStyleName);
+
+	pTextBox->Add(pXFPara);
+	this->SetPosition(pTextBox);
+
+	/*
+	XFFrameStyle* pBoxStyle = new XFFrameStyle();
+	pBoxStyle->SetYPosType(enumXFFrameYPosFromTop, enumXFFrameYRelFrame);
+	pBoxStyle->SetXPosType(enumXFFrameXPosFromLeft, enumXFFrameXRelFrame);
+	pBoxStyle->SetPadding(0.0, 0.0, 0.0, 0.0);
+	*/
+	XFTextBoxStyle* pBoxStyle = new XFTextBoxStyle();
+	
+	XFStyleManager* pXFStyleManager = LwpGlobalMgr::GetInstance()->GetXFStyleManager();
+	OUString sName = pXFStyleManager->AddStyle(pBoxStyle)->GetStyleName();
+	pTextBox->SetStyleName(sName);
+	
+	//todo: add the interface for rotating textbox
+//	if (m_aTextRec.nTextRotation)
+//	{
+//		double fAngle = double(3600-m_aTextRec.nTextRotation)/10;
+//		pTextBox->SetRotate(fAngle);
+//	}
+	
+	return pTextBox;
+}
+
+XFFrame* LwpDrawTextBox::CreateStandardDrawObj(const  OUString& rStyleName)
+{
+	return this->CreateDrawObj(rStyleName);
+}
+
+/**
+ * @descr   Constructor of class LwpDrawTextBox
+ * @param   pStream   The memory stream which contains the lwp-sdw draw objects
+ */
+LwpDrawTextArt::LwpDrawTextArt(SvStream* pStream, DrawingOffsetAndScale* pTransData)
+: LwpDrawObj(pStream, pTransData)
+{
+}
+
+LwpDrawTextArt::~LwpDrawTextArt()
+{
+	if (m_aTextArtRec.aPath[0].pPts)
+	{
+		delete [] m_aTextArtRec.aPath[0].pPts;
+		m_aTextArtRec.aPath[0].pPts = NULL;
+	}
+	if (m_aTextArtRec.aPath[1].pPts)
+	{
+		delete [] m_aTextArtRec.aPath[1].pPts;
+		m_aTextArtRec.aPath[1].pPts = NULL;
+	}
+	if (m_aTextArtRec.pTextString)
+	{
+		delete [] m_aTextArtRec.pTextString;
+		m_aTextArtRec.pTextString = NULL;
+	}
+
+}
+
+void LwpDrawTextArt::CreateFWPath(XFDrawPath* pPath)
+{
+	sal_Int16 nX, nY;
+	nX = (m_aTextArtRec.aPath[0].pPts[0].x + m_aTextArtRec.aPath[1].pPts[0].x) / 2;
+	nY = (m_aTextArtRec.aPath[0].pPts[0].y + m_aTextArtRec.aPath[1].pPts[0].y) / 2;
+	XFPoint aStart((double)nX/TWIPS_PER_CM * m_pTransData->fScaleX,
+		(double)nY/TWIPS_PER_CM * m_pTransData->fScaleY);
+	pPath->MoveTo(aStart);
+
+	sal_uInt8 nPtIndex = 1;
+	for (sal_uInt8 nC = 1; nC <= m_aTextArtRec.aPath[0].n; nC++)
+	{
+		nX = (m_aTextArtRec.aPath[0].pPts[nPtIndex].x + m_aTextArtRec.aPath[1].pPts[nPtIndex].x) / 2;
+		nY = (m_aTextArtRec.aPath[0].pPts[nPtIndex].y + m_aTextArtRec.aPath[1].pPts[nPtIndex].y) / 2;
+		XFPoint aCtrl1((double)nX/TWIPS_PER_CM * m_pTransData->fScaleX,
+			(double)nY/TWIPS_PER_CM * m_pTransData->fScaleY);
+
+		nPtIndex++;
+		nX = (m_aTextArtRec.aPath[0].pPts[nPtIndex].x + m_aTextArtRec.aPath[1].pPts[nPtIndex].x) / 2;
+		nY = (m_aTextArtRec.aPath[0].pPts[nPtIndex].y + m_aTextArtRec.aPath[1].pPts[nPtIndex].y) / 2;
+		XFPoint aCtrl2((double)nX/TWIPS_PER_CM * m_pTransData->fScaleX,
+			(double)nY/TWIPS_PER_CM * m_pTransData->fScaleY);
+
+		nPtIndex++;
+		nX = (m_aTextArtRec.aPath[0].pPts[nPtIndex].x + m_aTextArtRec.aPath[1].pPts[nPtIndex].x) / 2;
+		nY = (m_aTextArtRec.aPath[0].pPts[nPtIndex].y + m_aTextArtRec.aPath[1].pPts[nPtIndex].y) / 2;
+		XFPoint aDest((double)nX/TWIPS_PER_CM * m_pTransData->fScaleX,
+			(double)nY/TWIPS_PER_CM * m_pTransData->fScaleY);
+
+		pPath->CurveTo(aDest, aCtrl1, aCtrl2);
+	}
+}
+
+void LwpDrawTextArt::Read()
+{
+	for (sal_uInt8 nC = 0; nC < 4; nC++)
+	{
+		m_pStream->Read(&m_aVector[nC].x, 2);
+		m_pStream->Read(&m_aVector[nC].y, 2);		
+	}
+
+	this->ReadClosedObjStyle();
+	m_aTextArtRec.aTextColor = m_aClosedObjStyleRec.aForeColor;
+	
+	m_pStream->Read(&m_aTextArtRec.nIndex, 1);
+	m_pStream->Read(&m_aTextArtRec.nRotation, 2);
+
+	sal_uInt16 nPointNumber;
+	sal_Int16 nX, nY;
+	m_pStream->Read(&nPointNumber, 2);
+	m_aTextArtRec.aPath[0].n = nPointNumber;
+	m_aTextArtRec.aPath[0].pPts = new SdwPoint [nPointNumber*3+1];
+    sal_uInt16 nPt = 0;
+	for ( nPt = 0; nPt <= nPointNumber*3; nPt++)
+	{
+		m_pStream->Read(&nX, 2);
+		m_pStream->Read(&nY, 2);
+		m_aTextArtRec.aPath[0].pPts[nPt].x = nX;
+		m_aTextArtRec.aPath[0].pPts[nPt].y = nY;
+	}
+
+	m_pStream->Read(&nPointNumber, 2);
+	m_aTextArtRec.aPath[1].n = nPointNumber;
+	m_aTextArtRec.aPath[1].pPts = new SdwPoint [nPointNumber*3+1];
+	for (nPt = 0; nPt <= nPointNumber*3; nPt++)
+	{
+		m_pStream->Read(&nX, 2);
+		m_pStream->Read(&nY, 2);
+		m_aTextArtRec.aPath[1].pPts[nPt].x = nX;
+		m_aTextArtRec.aPath[1].pPts[nPt].y = nY;
+	}
+
+	m_pStream->SeekRel(1);
+
+	m_pStream->Read(m_aTextArtRec.tmpTextFaceName, DRAW_FACESIZE);
+	m_pStream->SeekRel(1);// PitchAndFamily
+
+	m_pStream->Read(&m_aTextArtRec.nTextSize, sizeof(m_aTextArtRec.nTextSize));
+	bool TextSizeIsCellHeight = true;
+	if (m_aTextArtRec.nTextSize < 0)
+	{
+		TextSizeIsCellHeight = false;
+		m_aTextArtRec.nTextSize = -m_aTextArtRec.nTextSize;
+	}
+
+	m_pStream->Read(&m_aTextArtRec.nTextAttrs, sizeof(m_aTextArtRec.nTextAttrs));
+	m_pStream->Read(&m_aTextArtRec.nTextCharacterSet, sizeof(m_aTextArtRec.nTextCharacterSet));
+//	m_pStream->Read(&m_aTextArtRec.nTextRotation, sizeof(m_aTextArtRec.nTextRotation));
+	m_aTextArtRec.nTextRotation = 0;
+	m_pStream->Read(&m_aTextArtRec.nTextExtraSpacing, sizeof(m_aTextArtRec.nTextExtraSpacing));
+
+	const sal_uInt16 nTextArtFixedLength = 105;
+	m_aTextArtRec.nTextLen = m_aObjHeader.nRecLen - nTextArtFixedLength
+													- (m_aTextArtRec.aPath[0].n*3 + 1)*4
+													- (m_aTextArtRec.aPath[1].n*3 + 1)*4;
+
+	m_aTextArtRec.pTextString = new sal_uInt8 [m_aTextArtRec.nTextLen];
+	m_pStream->Read(m_aTextArtRec.pTextString, m_aTextArtRec.nTextLen);
+	m_aTextArtRec.pTextString[m_aTextArtRec.nTextLen-1] = 0;
+
+}
+
+rtl::OUString LwpDrawTextArt::RegisterStyle()
+{
+	XFParaStyle* pStyle = new XFParaStyle();
+
+	// font style
+	// the pFont need to be deleted myself?
+	XFFont* pFont = new XFFont();
+
+	rtl_TextEncoding aEncoding =  RTL_TEXTENCODING_MS_1252;
+	rtl::OUString aFontName = rtl::OUString((sal_Char*)m_aTextArtRec.tmpTextFaceName,
+		strlen((char*)m_aTextArtRec.tmpTextFaceName), aEncoding);
+	pFont->SetFontName(aFontName);
+
+	LwpDrawTextBox::SetFontStyle(pFont, &m_aTextArtRec);
+
+	pStyle->SetFont(pFont);
+	
+	XFStyleManager* pXFStyleManager = LwpGlobalMgr::GetInstance()->GetXFStyleManager();
+	return pXFStyleManager->AddStyle(pStyle)->GetStyleName();
+}
+
+XFFrame* LwpDrawTextArt::CreateDrawObj(const rtl::OUString& rStyleName) 
+{
+	XFFrame* pRetObj = NULL;
+	XFDrawStyle* pStyle = new XFDrawStyle();
+
+	pRetObj = new XFDrawPath();
+	XFDrawPath* pFWPath = static_cast<XFDrawPath*>(pRetObj);
+	this->CreateFWPath(pFWPath);
+	pStyle->SetFontWorkStyle(0, enumXFFWSlantY, enumXFFWAdjustAutosize);
+
+	this->SetPosition(pRetObj);
+
+	rtl_TextEncoding aEncoding;
+	if (!m_aTextArtRec.nTextCharacterSet)
+	{
+		aEncoding = gsl_getSystemTextEncoding();
+	}
+	else
+	{
+		// temporary code, need to create Encoding from the value of nTextCharacterSet
+		aEncoding = LwpCharSetMgr::GetInstance()->GetTextCharEncoding();
+	}
+
+	XFParagraph* pXFPara = new XFParagraph();
+	pXFPara->Add(rtl::OUString((sal_Char*)m_aTextArtRec.pTextString, (m_aTextArtRec.nTextLen-1), aEncoding));
+	pXFPara->SetStyleName(rStyleName);
+	pRetObj->Add(pXFPara);
+
+	XFStyleManager* pXFStyleManager = LwpGlobalMgr::GetInstance()->GetXFStyleManager();
+	pRetObj->SetStyleName(pXFStyleManager->AddStyle(pStyle)->GetStyleName());
+
+	return pRetObj;
+}
+
+XFFrame* LwpDrawTextArt::CreateStandardDrawObj(const rtl::OUString& rStyleName )
+{
+	return this->CreateDrawObj(rStyleName);
+}
+
+
+/**
+ * @descr   Constructor of class LwpDrawMetafile
+ * @param   pStream   The memory stream which contains the lwp-sdw draw objects
+ */
+LwpDrawMetafile::LwpDrawMetafile(SvStream* pStream) : LwpDrawObj(pStream)
+{
+}
+
+/**
+ * @descr   reading function of class LwpDrawMetafile
+ */
+void LwpDrawMetafile::Read()
+{
+	m_pStream->SeekRel(m_aObjHeader.nRecLen -16); 
+}
+
+/**
+ * @descr   Constructor of class LwpDrawBitmap
+ * @param   pStream   The memory stream which contains the lwp-sdw draw objects
+ */
+LwpDrawBitmap::LwpDrawBitmap(SvStream* pStream) : LwpDrawObj(pStream), m_pImageData(NULL)
+{
+}
+
+LwpDrawBitmap::~LwpDrawBitmap()
+{
+	if (m_pImageData)
+	{
+		delete [] m_pImageData;
+		m_pImageData = NULL;
+	}
+}
+
+/**
+ * @descr   reading function of class LwpDrawBitmap
+ */
+void LwpDrawBitmap::Read()
+{
+	m_pStream->Read(&m_aBmpRec.nTranslation, sizeof(m_aBmpRec.nTranslation));
+	m_pStream->Read(&m_aBmpRec.nRotation, sizeof(m_aBmpRec.nRotation));
+
+	// 20 == length of draw-specific fields.
+	// 14 == length of bmp file header.
+	m_aBmpRec.nFileSize = m_aObjHeader.nRecLen - 20 + 14;
+	m_pImageData = new sal_uInt8 [m_aBmpRec.nFileSize];
+
+	BmpInfoHeader2 aInfoHeader2;
+	m_pStream->Read(&aInfoHeader2.nHeaderLen, 4);
+	
+	sal_uInt32 N;
+	sal_uInt32 rgbTableSize;
+
+	if (aInfoHeader2.nHeaderLen == sizeof(BmpInfoHeader))
+	{
+		m_pStream->Read(&aInfoHeader2.nWidth, 2);
+		m_pStream->Read(&aInfoHeader2.nHeight, 2);
+		m_pStream->Read(&aInfoHeader2.nPlanes, 2);
+		m_pStream->Read(&aInfoHeader2.nBitCount, 2);
+
+		N = aInfoHeader2.nPlanes * aInfoHeader2.nBitCount;
+		if (N == 24)
+		{
+			rgbTableSize = 0;
+		}
+		else
+		{
+			rgbTableSize = 3 * (1 << N);
+		}
+	}
+	else
+	{
+		m_pStream->Read(&aInfoHeader2.nWidth, 4);
+		m_pStream->Read(&aInfoHeader2.nHeight, 4);
+		m_pStream->Read(&aInfoHeader2.nPlanes, 2);
+		m_pStream->Read(&aInfoHeader2.nBitCount, 2);
+		N = aInfoHeader2.nPlanes * aInfoHeader2.nBitCount;
+		if (N == 24)
+		{
+			rgbTableSize = 0;
+		}
+		else
+		{
+			rgbTableSize = 4 * (1 << N);
+		}
+
+	}
+
+	sal_uInt32 nOffBits = 14 + aInfoHeader2.nHeaderLen + rgbTableSize;
+	m_pImageData[0] = 'B';
+	m_pImageData[1] = 'M';
+	m_pImageData[2] = (sal_uInt8)m_aBmpRec.nFileSize;
+	m_pImageData[3] = (sal_uInt8)(m_aBmpRec.nFileSize >> 8);
+	m_pImageData[4] = (sal_uInt8)(m_aBmpRec.nFileSize >> 16);
+	m_pImageData[5] = (sal_uInt8)(m_aBmpRec.nFileSize >> 24);
+	m_pImageData[6] = 0;
+	m_pImageData[7] = 0;
+	m_pImageData[8] = 0;
+	m_pImageData[9] = 0;
+	m_pImageData[10] = (sal_uInt8)nOffBits;
+	m_pImageData[11] = (sal_uInt8)(nOffBits >> 8);
+	m_pImageData[12] = (sal_uInt8)(nOffBits >> 16);
+	m_pImageData[13] = (sal_uInt8)(nOffBits >> 24);
+
+	sal_uInt32 nDIBRemaining;
+	sal_uInt8* pPicData = m_pImageData;
+	if (aInfoHeader2.nHeaderLen== sizeof(BmpInfoHeader))
+	{
+		m_pImageData[14] = (sal_uInt8)aInfoHeader2.nHeaderLen;
+		m_pImageData[15] = (sal_uInt8)(aInfoHeader2.nHeaderLen >> 8);
+		m_pImageData[16] = (sal_uInt8)(aInfoHeader2.nHeaderLen >> 16);
+		m_pImageData[17] = (sal_uInt8)(aInfoHeader2.nHeaderLen >> 24);
+		m_pImageData[18] = (sal_uInt8)aInfoHeader2.nWidth;
+		m_pImageData[19] = (sal_uInt8)(aInfoHeader2.nWidth >> 8);
+		m_pImageData[20] = (sal_uInt8)aInfoHeader2.nHeight;
+		m_pImageData[21] = (sal_uInt8)(aInfoHeader2.nHeight >> 8);
+		m_pImageData[22] = (sal_uInt8)aInfoHeader2.nPlanes;
+		m_pImageData[23] = (sal_uInt8)(aInfoHeader2.nPlanes >> 8);
+		m_pImageData[24] = (sal_uInt8)aInfoHeader2.nBitCount;
+		m_pImageData[25] = (sal_uInt8)(aInfoHeader2.nBitCount >> 8);
+
+		nDIBRemaining = m_aBmpRec.nFileSize - 26;
+		pPicData += 26*sizeof(sal_uInt8);
+	}
+	else
+	{
+		m_pImageData[14] = (sal_uInt8)aInfoHeader2.nHeaderLen;
+		m_pImageData[15] = (sal_uInt8)(aInfoHeader2.nHeaderLen >> 8);
+		m_pImageData[16] = (sal_uInt8)(aInfoHeader2.nHeaderLen >> 16);
+		m_pImageData[17] = (sal_uInt8)(aInfoHeader2.nHeaderLen >> 24);
+		m_pImageData[18] = (sal_uInt8)aInfoHeader2.nWidth;
+		m_pImageData[19] = (sal_uInt8)(aInfoHeader2.nWidth >> 8);
+		m_pImageData[20] = (sal_uInt8)(aInfoHeader2.nWidth >> 16);
+		m_pImageData[21] = (sal_uInt8)(aInfoHeader2.nWidth >> 24);
+		m_pImageData[22] = (sal_uInt8)aInfoHeader2.nHeight;
+		m_pImageData[23] = (sal_uInt8)(aInfoHeader2.nHeight >> 8);
+		m_pImageData[24] = (sal_uInt8)(aInfoHeader2.nHeight >> 16);
+		m_pImageData[25] = (sal_uInt8)(aInfoHeader2.nHeight >> 24);
+		m_pImageData[26] = (sal_uInt8)aInfoHeader2.nPlanes;
+		m_pImageData[27] = (sal_uInt8)(aInfoHeader2.nPlanes >> 8);
+		m_pImageData[28] = (sal_uInt8)aInfoHeader2.nBitCount;
+		m_pImageData[29] = (sal_uInt8)(aInfoHeader2.nBitCount >> 8);
+
+		nDIBRemaining = m_aBmpRec.nFileSize - 30;
+		pPicData += 30*sizeof(sal_uInt8);
+	}
+
+	m_pStream->Read(pPicData, nDIBRemaining);
+
+/*	FILE* pStream;
+	pStream = fopen( "drawing_test.bmp", "w+" );
+	fwrite(m_pImageData, sizeof(sal_uInt8), m_aBmpRec.nFileSize, pStream);
+	fclose( pStream );
+*/
+}
+
+rtl::OUString LwpDrawBitmap::RegisterStyle()
+{
+	XFImageStyle* pBmpStyle = new XFImageStyle();
+	pBmpStyle->SetYPosType(enumXFFrameYPosFromTop, enumXFFrameYRelFrame);
+	pBmpStyle->SetXPosType(enumXFFrameXPosFromLeft, enumXFFrameXRelFrame);
+	
+	XFStyleManager* pXFStyleManager = LwpGlobalMgr::GetInstance()->GetXFStyleManager();
+	return pXFStyleManager->AddStyle(pBmpStyle)->GetStyleName();
+}
+
+XFFrame* LwpDrawBitmap::CreateDrawObj(const rtl::OUString& rStyleName)
+{
+	XFImage* pImage = new XFImage();
+	pImage->SetImageData(m_pImageData, m_aBmpRec.nFileSize);
+	this->SetPosition(pImage);
+
+	pImage->SetStyleName(rStyleName);
+		
+	return pImage;
+}
+
+XFFrame* LwpDrawBitmap::CreateStandardDrawObj(const  OUString& rStyleName)
+{
+	return this->CreateDrawObj(rStyleName);
+}
+
diff -urNp lotuswordpro.bak/source/filter/lwpdrawobj.hxx lotuswordpro/source/filter/lwpdrawobj.hxx
--- lotuswordpro.bak/source/filter/lwpdrawobj.hxx	1970-01-01 08:00:00.000000000 +0800
+++ lotuswordpro/source/filter/lwpdrawobj.hxx	2008-10-22 11:42:29.000000000 +0800
@@ -0,0 +1,376 @@
+/*************************************************************************
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: IBM Corporation
+ *
+ *  Copyright: 2008 by IBM Corporation
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+/**
+ * @file 
+  * The file declares the LwpDrawObjcts and associated class like LwpDrawGroup, LwpDrawRectange
+ *	and so on.
+ */
+
+#ifndef _LWPDRAWOBJ_HXX
+#define _LWPDRAWOBJ_HXX
+
+#include "lwpsdwdrawheader.hxx"
+
+class SvStream;
+class XFFrame;
+class XFDrawStyle;
+
+/**
+ * @brief
+ * Lwp-base-draw object. 
+ */
+class LwpDrawObj
+{
+protected:
+	DrawObjectType m_eType;
+	SvStream* m_pStream;
+	SdwDrawObjHeader m_aObjHeader;
+	SdwClosedObjStyleRec m_aClosedObjStyleRec;
+	DrawingOffsetAndScale* m_pTransData;
+
+public:
+	LwpDrawObj(SvStream* pStream, DrawingOffsetAndScale* pTransData = NULL);
+	virtual ~LwpDrawObj() {};
+	
+private:
+	void ReadObjHeaderRecord();
+
+protected:
+	void ReadClosedObjStyle();
+	void SetFillStyle(XFDrawStyle* pStyle);
+	void SetLineStyle(XFDrawStyle* pStyle, sal_uInt8 nWidth, sal_uInt8 nLineStyle,
+		const SdwColor& rColor);
+	void SetPosition(XFFrame* pObj);
+	void SetArrowHead(XFDrawStyle* pOpenedObjStyle, sal_uInt8 nArrowFlag, sal_uInt8 nLineWidth);
+	rtl::OUString GetArrowName(sal_uInt8 nArrowStyle);
+	
+protected:
+	/**
+	 * @descr	read out the record of a draw object.
+	 */
+	virtual void Read() = 0;
+
+	/**
+	 * @descr	register styles of a draw object according to the saved records data.
+	 * @return	the style name which has been registered.
+	 */
+	virtual rtl::OUString RegisterStyle() = 0;
+
+	/**
+	 * @descr	create XF-draw object and assign the style name to it.
+	 * @param	style name.
+	 * @return	pointer of the created XF-draw object.
+	 */
+	virtual XFFrame* CreateDrawObj(const rtl::OUString& rStyleName) = 0;
+
+	/**
+	 * @descr	create XF-draw object and assign the style name to it.
+	 * @param	style name.
+	 * @return	pointer of the created XF-draw object.
+	 */
+	virtual XFFrame* CreateStandardDrawObj(const rtl::OUString& rStyleName) = 0;
+
+public:
+	/**
+	 * @descr	create a completed XF-draw object(read data, register styles and create XF-draw object)
+	 * @return	pointer of the created competed XF-draw object.
+	 */
+	XFFrame* CreateXFDrawObject();
+
+	/**
+	 * @param	type of the object.
+	 * @descr	set the type to the draw object.
+	 */
+	inline void SetObjectType(DrawObjectType eType) { m_eType = eType; }
+
+	/**
+	 * @descr	get the type of the draw object.
+	 * @return	the type of the object.
+	 */
+	inline  DrawObjectType GetObjectType() const { return m_eType; }
+};
+
+
+/**
+ * @brief
+ * Lwp-draw-group object.
+ */
+class LwpDrawGroup : public LwpDrawObj
+{
+public:
+	LwpDrawGroup(SvStream* pStream) : LwpDrawObj(pStream) {}
+	virtual ~LwpDrawGroup() {}
+	
+protected:
+	virtual void Read() {}
+	virtual rtl::OUString RegisterStyle() { return rtl::OUString::createFromAscii(""); }
+	virtual XFFrame* CreateDrawObj(const rtl::OUString& rStyleName) { return NULL; }
+	virtual XFFrame* CreateStandardDrawObj(const rtl::OUString& rStyleName) { return NULL; }
+};
+
+
+/**
+ * @brief
+ * Lwp-draw-line object. 
+ */
+class LwpDrawLine : public LwpDrawObj
+{
+private:
+	SdwLineRecord m_aLineRec;
+
+public:
+	LwpDrawLine(SvStream * pStream, DrawingOffsetAndScale* pTransData);
+	virtual ~LwpDrawLine() {};
+
+protected:
+	virtual void Read();
+	virtual rtl::OUString RegisterStyle();
+	virtual XFFrame* CreateDrawObj(const rtl::OUString& rStyleName);
+	virtual XFFrame* CreateStandardDrawObj(const rtl::OUString& rStyleName);
+};
+
+/**
+ * @brief
+ * Lwp-draw-polyline object.
+ */
+class LwpDrawPolyLine : public LwpDrawObj
+{
+private:
+	SdwPolyLineRecord m_aPolyLineRec;
+	SdwPoint* m_pVector;
+
+public:
+	LwpDrawPolyLine(SvStream * pStream, DrawingOffsetAndScale* pTransData);
+	virtual ~LwpDrawPolyLine();
+
+protected:
+	virtual void Read();
+	virtual rtl::OUString RegisterStyle();
+	virtual XFFrame* CreateDrawObj(const rtl::OUString& rStyleName);
+	virtual XFFrame* CreateStandardDrawObj(const rtl::OUString& rStyleName);
+};
+
+
+ /**
+ * @brief
+ * Lwp-draw-polygon object. 
+ */
+class LwpDrawPolygon : public LwpDrawObj
+{
+private:
+	sal_uInt16 m_nNumPoints;
+	SdwPoint* m_pVector;
+	
+public:
+	LwpDrawPolygon(SvStream * pStream, DrawingOffsetAndScale* pTransData);
+	virtual ~LwpDrawPolygon();
+
+protected:
+	virtual void Read();
+	virtual rtl::OUString RegisterStyle();
+	virtual XFFrame* CreateDrawObj(const rtl::OUString& rStyleName);
+	virtual XFFrame* CreateStandardDrawObj(const rtl::OUString& rStyleName);
+};
+
+/**
+ * @brief
+ * Lwp-draw-rectangle(rounded-corner rectangle) object. 
+ */
+class LwpDrawRectangle : public LwpDrawObj
+{
+private:
+	SdwPoint m_aVector[16];
+
+public:
+	LwpDrawRectangle(SvStream* pStream, DrawingOffsetAndScale* pTransData);
+	virtual ~LwpDrawRectangle(){}
+
+protected:
+	virtual void Read();
+	virtual rtl::OUString RegisterStyle();
+	virtual XFFrame* CreateDrawObj(const rtl::OUString& rStyleName);
+	virtual XFFrame* CreateStandardDrawObj(const rtl::OUString& rStyleName);
+
+private:
+	XFFrame* CreateRoundedRect(const rtl::OUString& rStyleName);
+};
+
+/**
+ * @brief
+ * Lwp-draw-ellipse object. 
+ */
+class LwpDrawEllipse : public LwpDrawObj
+{
+private:
+	SdwPoint m_aVector[13];
+
+public:
+	LwpDrawEllipse(SvStream * pStream, DrawingOffsetAndScale* pTransData);
+	virtual ~LwpDrawEllipse(){};
+
+protected:
+	virtual void Read();
+	virtual rtl::OUString RegisterStyle();
+	virtual XFFrame* CreateDrawObj(const rtl::OUString& rStyleName);
+	virtual XFFrame* CreateStandardDrawObj(const rtl::OUString& rStyleName);
+};
+
+
+/**
+ * @brief
+ * Lwp-draw-arc object. 
+ */
+class LwpDrawArc : public LwpDrawObj
+{
+private:
+	SdwArcRecord m_aArcRec;
+	SdwPoint m_aVector[4];
+	
+public:
+	LwpDrawArc(SvStream * pStream, DrawingOffsetAndScale* pTransData);
+	virtual ~LwpDrawArc() {};
+
+protected:
+	virtual void Read();
+	virtual rtl::OUString RegisterStyle();
+	virtual XFFrame* CreateDrawObj(const rtl::OUString& rStyleName);
+	virtual XFFrame* CreateStandardDrawObj(const rtl::OUString& rStyleName);
+};
+
+/**
+ * @brief
+ * Lwp-draw-textbox object. 
+ */
+class  XFFont;
+class LwpDrawTextBox : public LwpDrawObj
+{
+private:
+	SdwTextBoxRecord m_aTextRec;
+	SdwPoint m_aVector;
+
+public:
+	LwpDrawTextBox(SvStream* pStream);
+	virtual ~LwpDrawTextBox();
+	static void SetFontStyle(XFFont* pFont, SdwTextBoxRecord* pRec);
+	
+protected:
+	virtual void Read();
+	virtual rtl::OUString RegisterStyle();
+	virtual XFFrame* CreateDrawObj(const rtl::OUString& rStyleName);
+	virtual XFFrame* CreateStandardDrawObj(const rtl::OUString& rStyleName);
+};
+
+/**
+ * @brief
+ * Lwp-draw-curved-text object. 
+ */
+class XFDrawPath;
+class LwpDrawTextArt : public LwpDrawObj
+{
+private:
+	SdwTextArt m_aTextArtRec;
+	SdwPoint m_aVector[4];
+
+private:
+	void CreateFWPath(XFDrawPath* pPath);
+	
+public:
+	LwpDrawTextArt(SvStream* pStream, DrawingOffsetAndScale* pTransData);
+	virtual ~LwpDrawTextArt();
+	
+protected:
+	virtual void Read();
+	virtual rtl::OUString RegisterStyle();
+	virtual XFFrame* CreateDrawObj(const rtl::OUString& rStyleName);
+	virtual XFFrame* CreateStandardDrawObj(const rtl::OUString& rStyleName);
+};
+
+/**
+ * @brief
+ * Lwp-draw-metafile object.  
+ */
+class LwpDrawMetafile : public LwpDrawObj
+{
+public:
+	LwpDrawMetafile(SvStream* pStream);
+	virtual ~LwpDrawMetafile() {}
+
+protected:
+	virtual void Read();
+	virtual rtl::OUString RegisterStyle() {return rtl::OUString::createFromAscii("");}
+	virtual XFFrame* CreateDrawObj(const rtl::OUString& rStyleName){return NULL;}
+	virtual XFFrame* CreateStandardDrawObj(const rtl::OUString& rStyleName){return NULL;}
+};
+
+/**
+ * @brief
+ * Lwp-draw-bitmap object.
+ */
+class LwpDrawBitmap : public LwpDrawObj
+{
+private:
+	SdwBmpRecord m_aBmpRec;
+	sal_uInt8* m_pImageData;
+public:
+	LwpDrawBitmap(SvStream* pStream);
+	virtual ~LwpDrawBitmap();
+
+protected:
+	virtual void Read();
+	virtual rtl::OUString RegisterStyle();
+	virtual XFFrame* CreateDrawObj(const rtl::OUString& rStyleName);
+	virtual XFFrame* CreateStandardDrawObj(const rtl::OUString& rStyleName);
+};
+#endif
diff -urNp lotuswordpro.bak/source/filter/lwpdropcapmgr.cxx lotuswordpro/source/filter/lwpdropcapmgr.cxx
--- lotuswordpro.bak/source/filter/lwpdropcapmgr.cxx	1970-01-01 08:00:00.000000000 +0800
+++ lotuswordpro/source/filter/lwpdropcapmgr.cxx	2008-10-22 11:42:29.000000000 +0800
@@ -0,0 +1,82 @@
+/*************************************************************************
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: IBM Corporation
+ *
+ *  Copyright: 2008 by IBM Corporation
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+/*************************************************************************
+ * @file 
+ *  For LWP filter architecture prototype
+ ************************************************************************/
+/*************************************************************************
+ * Change History
+ Mar 2005		 	reated
+ ************************************************************************/
+#include "lwpdropcapmgr.hxx"
+
+LwpDropcapMgr::LwpDropcapMgr()
+{
+	m_pXFPara = NULL;
+}
+
+LwpDropcapMgr::~LwpDropcapMgr()
+{
+}
+
+void LwpDropcapMgr::SetXFPara(XFParagraph* pXFPara)
+{
+	m_pXFPara = pXFPara;
+}
+
+XFParagraph* LwpDropcapMgr::GetXFPara()
+{
+	return m_pXFPara;
+}
\ No newline at end of file
diff -urNp lotuswordpro.bak/source/filter/lwpdropcapmgr.hxx lotuswordpro/source/filter/lwpdropcapmgr.hxx
--- lotuswordpro.bak/source/filter/lwpdropcapmgr.hxx	1970-01-01 08:00:00.000000000 +0800
+++ lotuswordpro/source/filter/lwpdropcapmgr.hxx	2008-10-22 11:42:29.000000000 +0800
@@ -0,0 +1,79 @@
+/*************************************************************************
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: IBM Corporation
+ *
+ *  Copyright: 2008 by IBM Corporation
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+/*************************************************************************
+ * @file 
+ *  For LWP filter architecture prototype
+ ************************************************************************/
+/*************************************************************************
+ * Change History
+ Mar 2005		 	created
+ ************************************************************************/
+
+#ifndef _LWPDROPCAPMGR_HXX
+#define _LWPDROPCAPMGR_HXX
+
+#include "xfilter/xfparagraph.hxx"
+
+class LwpDropcapMgr
+{
+public:
+	LwpDropcapMgr();
+	~LwpDropcapMgr();
+	void SetXFPara(XFParagraph* pXFPara);
+	XFParagraph* GetXFPara();
+private:
+	XFParagraph* m_pXFPara;
+};
+#endif
\ No newline at end of file
diff -urNp lotuswordpro.bak/source/filter/lwpfilehdr.cxx lotuswordpro/source/filter/lwpfilehdr.cxx
--- lotuswordpro.bak/source/filter/lwpfilehdr.cxx	1970-01-01 08:00:00.000000000 +0800
+++ lotuswordpro/source/filter/lwpfilehdr.cxx	2008-10-22 11:42:29.000000000 +0800
@@ -0,0 +1,84 @@
+/*************************************************************************
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: IBM Corporation
+ *
+ *  Copyright: 2008 by IBM Corporation
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+#include "lwpfilehdr.hxx"
+#include "lwpdefs.hxx"
+
+//Word Pro 96: 0x0a, 
+sal_uInt16 LwpFileHeader::m_nFileRevision = 0;
+
+LwpFileHeader::LwpFileHeader()
+	:m_nAppRevision(0),
+	m_nAppReleaseNo(0), m_nRequiredAppRevision(0), m_nRequiredFileRevision(0),
+	m_cDocumentID(), m_nRootIndexOffset(0)
+{}
+/**
+ * @descr  read file header object from svstream
+  */
+sal_uInt32 LwpFileHeader::Read(LwpSvStream *pStrm)
+{
+	sal_uInt32 len = 0;
+	len += pStrm->Read(&m_nAppRevision, sizeof(m_nAppRevision));
+	len += pStrm->Read(&m_nFileRevision, sizeof(m_nFileRevision));
+	len += pStrm->Read(&m_nAppReleaseNo, sizeof(m_nAppReleaseNo));
+	len += pStrm->Read(&m_nRequiredAppRevision, sizeof(m_nRequiredAppRevision));
+	len += pStrm->Read(&m_nRequiredFileRevision, sizeof(m_nRequiredFileRevision));
+	len += m_cDocumentID.Read(pStrm);
+	if (m_nFileRevision < 0x000B)
+		m_nRootIndexOffset = BAD_OFFSET;
+	else
+		len += pStrm->Read(&m_nRootIndexOffset, sizeof(m_nRootIndexOffset));
+	return(len);
+}
+
diff -urNp lotuswordpro.bak/source/filter/lwpfilehdr.hxx lotuswordpro/source/filter/lwpfilehdr.hxx
--- lotuswordpro.bak/source/filter/lwpfilehdr.hxx	1970-01-01 08:00:00.000000000 +0800
+++ lotuswordpro/source/filter/lwpfilehdr.hxx	2008-10-22 11:42:29.000000000 +0800
@@ -0,0 +1,89 @@
+/*************************************************************************
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: IBM Corporation
+ *
+ *  Copyright: 2008 by IBM Corporation
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+#ifndef _LWPFILEHEADER_HXX
+#define _LWPFILEHEADER_HXX
+
+#include "lwpobjid.hxx"
+/**
+ * @brief		LWP7 object
+*/
+class LwpFileHeader
+{
+public:
+	LwpFileHeader();
+	~LwpFileHeader(){};
+private: //data member
+	sal_uInt16 m_nAppRevision;			
+	sal_uInt16 m_nAppReleaseNo;
+	sal_uInt16 m_nRequiredAppRevision;
+	sal_uInt16 m_nRequiredFileRevision;
+	LwpObjectID m_cDocumentID;		
+	sal_uInt32 m_nRootIndexOffset;
+public:
+	static sal_uInt16 m_nFileRevision;
+	sal_uInt32 Read(LwpSvStream *pStrm);
+	sal_uInt32 GetRootIndexOffset();
+	LwpObjectID* GetDocID();
+};
+inline sal_uInt32 LwpFileHeader::GetRootIndexOffset()
+{
+	return m_nRootIndexOffset;
+}
+inline LwpObjectID* LwpFileHeader::GetDocID() 
+{
+	return &m_cDocumentID;
+}
+
+#endif
diff -urNp lotuswordpro.bak/source/filter/lwpfilter.cxx lotuswordpro/source/filter/lwpfilter.cxx
--- lotuswordpro.bak/source/filter/lwpfilter.cxx	1970-01-01 08:00:00.000000000 +0800
+++ lotuswordpro/source/filter/lwpfilter.cxx	2008-10-22 11:42:29.000000000 +0800
@@ -0,0 +1,593 @@
+/*************************************************************************
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: IBM Corporation
+ *
+ *  Copyright: 2008 by IBM Corporation
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+/*************************************************************************
+ * @file 
+ * Circle object.
+ ************************************************************************/
+/*************************************************************************
+ * Change History
+ * 2005-1-17  create this file.
+ ************************************************************************/
+#include "lwpfilter.hxx"
+#include "lwpresource.hxx"
+//for sax stream
+#include "xfilter/xfsaxstream.hxx"
+#include "xfilter/xffilestream.hxx"
+//for file parser
+#include "lwp9reader.hxx"
+#include "lwpsvstream.hxx"
+//for container reset
+#include "xfilter/xffontfactory.hxx"
+#include "xfilter/xfstylemanager.hxx"
+
+#include <osl/file.h>
+#include <osl/file.hxx>
+#include <vcl/svapp.hxx>
+//#include <vcl/vclasynload.hxx>
+#include <xmloff/attrlist.hxx>
+#include <com/sun/star/io/IOException.hpp>
+#include <com/sun/star/frame/XDesktop.hpp>
+#include <com/sun/star/frame/XController.hpp>
+#include <com/sun/star/text/XTextDocument.hpp>
+#include <com/sun/star/text/XText.hpp>
+
+#include <tools/stream.hxx>
+#include <sfx2/docfile.hxx>
+
+using namespace ::cppu;
+using namespace ::com::sun::star::lang;
+using namespace ::com::sun::star::frame;
+using namespace ::com::sun::star::text;
+using namespace ::com::sun::star::io;
+using namespace ::com::sun::star::registry;
+using namespace ::com::sun::star::document;
+using namespace ::com::sun::star::beans;
+using namespace ::com::sun::star::xml::sax;
+using namespace ::com::sun::star;
+using ::rtl::OUString;
+using ::com::sun::star::uno::Sequence;
+
+sal_Bool IsWordproFile( uno::Reference<XInputStream>& rInputStream);
+sal_Bool IsWordproFile(rtl::OUString file);
+
+LWPFilterReader::LWPFilterReader()
+{
+}
+
+LWPFilterReader::~LWPFilterReader()
+{
+}
+
+sal_Bool LWPFilterReader::filter( const Sequence< PropertyValue >& aDescriptor )
+    throw( RuntimeException )
+{		
+	uno::Reference< XInputStream> xInputStream;
+	::rtl::OUString	sURL;
+    for( sal_Int32 i = 0; i < aDescriptor.getLength(); i++ )
+	{
+		if( aDescriptor[i].Name == OUString::createFromAscii( "InputStream" ) )
+			aDescriptor[i].Value >>= xInputStream;
+		if( aDescriptor[i].Name == OUString::createFromAscii( "URL" ) )
+			aDescriptor[i].Value >>= sURL;
+	}
+
+    if ( !xInputStream.is() )
+    {
+        OSL_ASSERT( 0 );
+        return sal_False;
+    }
+
+    OString sFileName;
+    sFileName = ::rtl::OUStringToOString(sURL, RTL_TEXTENCODING_INFO_ASCII);
+
+    SvFileStream inputStream( sURL, STREAM_READ );
+    if ( inputStream.IsEof() || ( inputStream.GetError() != SVSTREAM_OK ) )
+        return sal_False;
+	
+    
+    return (ReadWordproFile( &inputStream ,m_DocumentHandler) == 0);
+}
+
+void LWPFilterReader::cancel() throw (com::sun::star::uno::RuntimeException)
+{
+}
+
+uno::Reference< XInterface > LWPFilterImportFilter_CreateInstance(
+    const uno::Reference< XMultiServiceFactory >& rSMgr ) throw( Exception )
+{
+    LWPFilterImportFilter *p = new LWPFilterImportFilter( rSMgr );
+
+    return uno::Reference< XInterface > ( (OWeakObject* )p );
+}
+
+Sequence< OUString > LWPFilterImportFilter::getSupportedServiceNames_Static( void ) throw ()
+{
+    Sequence< OUString > aRet(1);
+    aRet.getArray()[0] = LWPFilterImportFilter::getImplementationName_Static();
+    return aRet;
+}
+
+LWPFilterImportFilter::LWPFilterImportFilter( const uno::Reference< XMultiServiceFactory >& xFact )
+{
+    //OUString sService = OUString( SwXMLImport_getImplementationName ); //STR_WRITER_IMPORTER_NAME
+
+    try 
+	{
+        uno::Reference< XDocumentHandler > xDoc( xFact->createInstance( OUString::createFromAscii( STR_WRITER_IMPORTER_NAME ) ), UNO_QUERY );
+
+        LWPFilterReader *p = new LWPFilterReader;
+        p->setDocumentHandler( xDoc );
+        
+        uno::Reference< XImporter > xImporter = uno::Reference< XImporter >( xDoc, UNO_QUERY );
+        rImporter = xImporter;
+        uno::Reference< XFilter > xFilter = uno::Reference< XFilter >( p );
+        rFilter = xFilter;
+    }
+    catch( Exception & )
+    {
+       exit( 1 );
+    }
+}
+
+LWPFilterImportFilter::~LWPFilterImportFilter()
+{
+}
+
+sal_Bool LWPFilterImportFilter::filter( const Sequence< PropertyValue >& aDescriptor )
+    throw( RuntimeException )
+{
+    sal_Bool ret =  rFilter->filter( aDescriptor );
+
+    return ret;
+}
+
+void LWPFilterImportFilter::cancel() throw (::com::sun::star::uno::RuntimeException)
+{
+    rFilter->cancel();
+}
+
+void LWPFilterImportFilter::setTargetDocument( const uno::Reference< XComponent >& xDoc )
+    throw( IllegalArgumentException, RuntimeException )
+{
+    rImporter->setTargetDocument( xDoc );
+}
+
+OUString LWPFilterImportFilter::getImplementationName_Static() throw()
+{
+    return OUString::createFromAscii( STR_IMPLEMENTATION_NAME );
+}
+
+OUString LWPFilterImportFilter::getImplementationName() throw()
+{
+    return OUString::createFromAscii( STR_IMPLEMENTATION_NAME );
+}
+
+sal_Bool LWPFilterImportFilter::supportsService( const OUString& ServiceName ) throw()
+{
+    Sequence< OUString > aSNL = getSupportedServiceNames();
+    const OUString *pArray = aSNL.getConstArray();
+
+    for ( sal_Int32 i = 0; i < aSNL.getLength(); i++ )
+	{
+        if ( pArray[i] == ServiceName ) return sal_True;
+	}
+
+    return sal_False;
+}
+
+Sequence< OUString> LWPFilterImportFilter::getSupportedServiceNames( void ) throw()
+{
+    Sequence< OUString > seq(1);
+    seq.getArray()[0] = OUString::createFromAscii( STR_SERVICE_NAME );
+    return seq;
+}
+
+
+::rtl::OUString SAL_CALL LWPFilterImportFilter::detect( ::com::sun::star::uno::Sequence< ::com::sun::star::beans::PropertyValue >& aDescriptor ) 
+		throw (::com::sun::star::uno::RuntimeException)
+{
+	rtl::OUString	ret;	
+    rtl::OUString aTypeName;            // a name describing the type (from MediaDescriptor, usually from flat detection)
+   	// opening as template is done when a parameter tells to do so and a template filter can be detected
+    // (otherwise no valid filter would be found) or if the detected filter is a template filter and
+	// there is no parameter that forbids to open as template
+	sal_Bool bOpenAsTemplate = sal_False;   
+	sal_Int32 nPropertyCount = aDescriptor.getLength();  
+	 for( sal_Int32 nProperty=0; nProperty<nPropertyCount; ++nProperty )
+	{  
+		if( aDescriptor[nProperty].Name == OUString(RTL_CONSTASCII_USTRINGPARAM("TypeName")) )
+		{
+			aDescriptor[nProperty].Value >>= aTypeName;            
+		}       
+		else if( aDescriptor[nProperty].Name == OUString(RTL_CONSTASCII_USTRINGPARAM("AsTemplate")) )
+		{
+			bOpenAsTemplate = sal_True; 
+		}               
+	}
+
+    for( sal_Int32 i = 0; i < aDescriptor.getLength(); i++ )
+	{
+		OUString strTemp;
+		aDescriptor[i].Value >>= strTemp;
+        if( aDescriptor[i].Name == OUString::createFromAscii( "InputStream" ) )
+		{
+            uno::Reference< XInputStream> rInputStream;
+            aDescriptor[i].Value >>= rInputStream;
+            //
+            // TRANSFORM IMPLEMENTATION HERE!!!!!!
+            // and call m_DocumentHandler's SAX mDochods
+            //	
+			if( IsWordproFile(rInputStream) )
+			{
+				if( aTypeName == OUString(RTL_CONSTASCII_USTRINGPARAM("wordpro_template")) )
+				{
+					if(!bOpenAsTemplate)
+					{
+						aDescriptor.realloc( nPropertyCount + 1 );
+						aDescriptor[nPropertyCount].Name = ::rtl::OUString::createFromAscii("AsTemplate");
+						aDescriptor[nPropertyCount].Value <<= sal_True;	
+					}
+					return OUString::createFromAscii("wordpro_template");
+				}
+				else
+				{
+					return OUString::createFromAscii("wordpro");
+				}
+			}				
+			return ret;
+        }
+		else if( aDescriptor[i].Name == OUString::createFromAscii( "URL" ) )
+		{
+            		OUString		sURL;
+			OUString		sFileName;
+
+		    	aDescriptor[i].Value >>= sURL;
+			/*		
+			osl::FileBase::RC rc = osl::FileBase::getSystemPathFromFileURL( sURL, sFileName );				
+			if(rc != osl::FileBase::E_None)
+			{
+				SAXException except;
+				except.Message = OUString( RTL_CONSTASCII_USTRINGPARAM( "GDocting system path from URL failed!"));
+				throw except;
+			}
+			*/
+			//end with .lwp:
+			if( IsWordproFile(sURL) )
+			{
+				if( aTypeName == OUString(RTL_CONSTASCII_USTRINGPARAM("wordpro_template")) )
+				{
+					if(!bOpenAsTemplate)
+					{
+						aDescriptor.realloc( nPropertyCount + 1 );
+						aDescriptor[nPropertyCount].Name = ::rtl::OUString::createFromAscii("AsTemplate");
+						aDescriptor[nPropertyCount].Value <<= sal_True;
+					}
+					return OUString::createFromAscii("wordpro_template");
+				}
+				else
+				{
+					return OUString::createFromAscii("wordpro");
+				}				
+			}
+			return ret;
+        }
+	}
+	return ret;
+}
+#if 0
+EXTERN_C void SAL_CALL 
+component_getImplementationEnvironment(const sal_Char** ppEnvTypeName, uno_Environment** ppEnv)
+{
+	*ppEnvTypeName = CPPU_CURRENT_LANGUAGE_BINDING_NAME;
+}
+	
+EXTERN_C sal_Bool SAL_CALL 
+component_writeInfo(void* pServiceManager, void* pRegistryKey)
+{
+	if (pRegistryKey)
+	{
+		try 
+		{
+			uno::Reference< XRegistryKey > xKey( reinterpret_cast<XRegistryKey*>(pRegistryKey) );
+			
+			uno::Reference< XRegistryKey > xNewKey = xKey->createKey( OUString::createFromAscii( IMPLEMENTATION_NAME ) );
+			xNewKey = xNewKey->createKey( OUString::createFromAscii( "/UNO/SERVICES" ) );
+			
+			xNewKey->createKey( OUString::createFromAscii( STR_SERVICE_NAME ) );
+			
+			return sal_True;
+		}
+		catch (InvalidRegistryException &)
+		{
+			OSL_ENSURE( sal_False, "### InvalidRegistryException!" );
+		}
+	}
+	return sal_False;
+}
+
+EXTERN_C void* SAL_CALL 
+component_getFactory(const sal_Char* pImplName, void* pServiceManager, void* pRegistryKey)
+{
+	void * pRet = 0;
+
+	if(pServiceManager )
+	{
+		uno::Reference< XSingleServiceFactory > xRet;
+		uno::Reference< XMultiServiceFactory > xSMgr = reinterpret_cast< XMultiServiceFactory * > ( pServiceManager );
+        
+		OUString aImplementationName = OUString::createFromAscii( pImplName );
+        
+		if(aImplementationName == OUString::createFromAscii( STR_IMPLEMENTATION_NAME ) )
+		{
+			xRet = createSingleFactory( xSMgr, aImplementationName,
+				LWPFilterImportFilter_CreateInstance,
+				LWPFilterImportFilter::getSupportedServiceNames_Static() );
+		}
+		if (xRet.is())
+		{
+			xRet->acquire();
+			pRet = xRet.get();
+		}
+	}
+
+	return pRet;
+}
+#endif
+
+ /**
+ * @descr	decompressed small file
+ * @param	pCompressed - real file stream
+ * @param	pDecompressed - file decompressed, create inside, caller should delete it
+ * @return	success - sal_True, fail - sal_False
+ */
+#include "bento.hxx"
+using namespace OpenStormBento;
+#include "explode.hxx"
+ sal_Bool Decompress(SvStream *pCompressed, SvStream * & pDecompressed)
+{
+	pCompressed->Seek(0);
+	pDecompressed = new SvMemoryStream(4096, 4096);
+	unsigned char buffer[512];
+	pCompressed->Read(buffer, 16);
+	pDecompressed->Write(buffer, 16);
+
+	LwpSvStream * pLwpStream = new LwpSvStream(pCompressed);
+	LtcBenContainer* pBentoContainer;
+	ULONG ulRet = BenOpenContainer(pLwpStream, &pBentoContainer);
+	LtcUtBenValueStream * pWordProData = (LtcUtBenValueStream *)pBentoContainer->FindValueStreamWithPropertyName("WordProData");
+	
+	// decompressing
+	Decompression decompress(pWordProData, pDecompressed);
+	if (0!= decompress.explode())
+	{
+		delete pDecompressed;
+		pDecompressed = NULL;
+		delete pWordProData;
+		delete pLwpStream;
+		return sal_False;
+	}
+
+	sal_uInt32 nPos = pWordProData->GetSize();
+	nPos += 0x10;
+
+	pCompressed->Seek(nPos);
+	while (sal_uInt32 iRead = pCompressed->Read(buffer, 512))
+	{
+		pDecompressed->Write(buffer, iRead);
+	}
+
+	delete pWordProData;
+	delete pLwpStream;
+	return sal_True;
+}
+
+ /**
+ * @descr	Get LwpSvStream, if small file, both compressed/decompressed stream
+ *                  Otherwise, only normal stream
+ * @param	pStream - real file stream
+ * @param	 LwpSvStream * , created inside, deleted outside
+ * @param      sal_Bool, sal_True - 
+ */
+ sal_Bool GetLwpSvStream(SvStream *pStream, LwpSvStream * & pLwpSvStream)
+{
+	SvStream * pDecompressed = NULL;
+	
+	sal_uInt32 nTag;
+	pStream->Seek(0x10);
+	pStream->Read(&nTag, sizeof(nTag));
+	if (nTag != 0x3750574c) // "LWP7"
+	{
+		// small file, needs decompression
+		if (!Decompress(pStream, pDecompressed))
+		{
+			pLwpSvStream = NULL;
+			return sal_True;
+		}
+		pStream->Seek(0);
+		pDecompressed->Seek(0);
+	}
+
+	pLwpSvStream = NULL;
+	sal_Bool bCompressed = sal_False;
+	if (pDecompressed)
+	{
+		LwpSvStream *pOriginalLwpSvStream = new LwpSvStream(pStream);
+		pLwpSvStream  = new LwpSvStream(pDecompressed, pOriginalLwpSvStream);
+		bCompressed = sal_True;
+	}
+	else
+	{
+		pLwpSvStream  = new LwpSvStream(pStream);
+	}
+	return bCompressed;
+}
+int ReadWordproFile(SvStream* pStream, uno::Reference<XDocumentHandler>& xHandler)
+{
+	try
+	{
+		LwpSvStream *pLwpSvStream = NULL;
+		SvStream * pDecompressed = NULL;
+		if ( GetLwpSvStream(pStream, pLwpSvStream) && pLwpSvStream)
+		{
+			pDecompressed = pLwpSvStream->GetStream();
+		}
+		if (!pLwpSvStream)
+		{
+			// nothing returned, fail when uncompressing
+			return 1;
+		}
+		
+		IXFStream *pStrm = new XFSaxStream(xHandler);
+		Lwp9Reader reader(pLwpSvStream, pStrm);	
+		//Reset all static objects,because this function may be called many times.
+		XFGlobalReset();
+		reader.Read();
+
+		// added by 
+		
+		if (pDecompressed)
+		{
+			delete pDecompressed;
+			LwpSvStream * pTemp = pLwpSvStream->GetCompressedStream();
+			delete pTemp;
+		}
+		delete pLwpSvStream;
+		// end added by 
+
+		delete pStrm;
+		return 0;
+	}
+	catch (...)
+	{
+		return 1;
+	}
+	return 1;
+}
+
+void ErrorMsg(int iErrCode)
+{
+	
+}
+
+/**
+ * @descr		Compare if pBuf equals with the first 16 bytes
+ * @param	pBuf that contains the file data
+ * @return		if equals with the Word Pro characteristic strings
+ */
+sal_Bool IsWordProStr(const sal_Int8 *pBuf)
+{
+	sal_Bool bRet = sal_True;
+	const sal_Int8 pLotusLwp[] = 
+	{ 
+		0x57, 0x6F, 0x72, 0x64, 
+		0x50, 0x72, 0x6F
+#if 0
+		, 0, 
+		0, 0, 0, 0,
+		0, 0, 0, 0
+#endif
+	};
+	for(int i=0; i<sizeof(pLotusLwp); i++)
+	{
+		if( pBuf[i] != pLotusLwp[i] ) 
+		{
+			bRet = sal_False;
+		}
+	}
+	return bRet;
+}
+
+sal_Bool IsWordproFile(rtl::OUString file)
+{
+	sal_Bool bRet = sal_False;
+	SfxMedium aMedium( file, STREAM_STD_READ, FALSE);
+	SvStream* pStm = aMedium.GetInStream();
+
+	if(pStm)
+	{
+		sal_Int8 buf[16];
+		bRet = sal_True;
+		sal_Int32	nRead = -1;
+		
+		pStm->SetNumberFormatInt( NUMBERFORMAT_INT_LITTLEENDIAN );
+		pStm->Seek(STREAM_SEEK_TO_BEGIN);
+		nRead = pStm->Read(buf, sizeof(buf));
+		if( nRead< sizeof(buf) )
+			bRet = sal_False;
+		else
+			bRet = IsWordProStr(buf);
+	}
+	return bRet;
+}
+
+
+sal_Bool IsWordproFile( uno::Reference<XInputStream>& rInputStream)
+{
+	Sequence<sal_Int8> aData;
+	sal_Int32	nRead = -1;
+	sal_Bool bRet = sal_False;
+	
+	nRead = rInputStream->readBytes(aData,16);
+	if( nRead != 16 )
+	{
+		bRet = sal_False;
+	}
+	else
+	{
+		const sal_Int8 *data = aData.getConstArray();
+		bRet = IsWordProStr(data);
+	}
+	return bRet;
+}
diff -urNp lotuswordpro.bak/source/filter/lwpfilter.hxx lotuswordpro/source/filter/lwpfilter.hxx
--- lotuswordpro.bak/source/filter/lwpfilter.hxx	1970-01-01 08:00:00.000000000 +0800
+++ lotuswordpro/source/filter/lwpfilter.hxx	2008-10-22 11:42:29.000000000 +0800
@@ -0,0 +1,185 @@
+/*************************************************************************
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: IBM Corporation
+ *
+ *  Copyright: 2008 by IBM Corporation
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+/*************************************************************************
+ * @file 
+ * Circle object.
+ ************************************************************************/
+/*************************************************************************
+ * Change History
+ * 2005-01-17  create this file.
+ ************************************************************************/
+#ifndef	_LWPFILTER_HXX
+#define	_LWPFILTER_HXX
+
+#include <cppuhelper/implbase1.hxx>
+#include <cppuhelper/implbase4.hxx>
+#include <cppuhelper/factory.hxx>
+
+#include <com/sun/star/document/XFilter.hpp>
+#include <com/sun/star/document/XImporter.hpp>
+#include <com/sun/star/xml/sax/XDocumentHandler.hpp>
+#include <com/sun/star/xml/sax/SAXException.hpp>
+#include <com/sun/star/lang/XServiceInfo.hpp>
+#include <com/sun/star/io/XInputStream.hpp>
+#include <com/sun/star/document/XExtendedFilterDetection.hpp>
+#include <com/sun/star/text/XTextDocument.hpp>
+#include <tools/stream.hxx>
+
+using namespace ::rtl;
+using namespace ::cppu;
+using namespace ::com::sun::star::lang;
+using namespace ::com::sun::star::io;
+using namespace ::com::sun::star::registry;
+using namespace ::com::sun::star::document;
+using namespace ::com::sun::star::beans;
+using namespace ::com::sun::star::xml::sax;
+using namespace ::com::sun::star::uno;
+using namespace ::com::sun::star::text;
+using namespace ::com::sun::star;
+
+#define EXTERN_C extern "C"
+
+/**
+ * @brief
+ * Implements the XFilter interface.
+ * This is not the entry for the filter, but a proto of LwpFilterImportFilter.
+ */
+class LWPFilterReader : public WeakImplHelper1< XFilter >
+{
+public:
+    LWPFilterReader();
+    ~LWPFilterReader();
+
+public:
+	/**
+	 * @descr	loading the file. It's call be SfxObejctShell::ImportFrom.
+	 * @param	aDescriptor the parameters include file URL or XInputStream obejct, from which the filter can
+	 *			get which file to import.
+	 */
+    virtual sal_Bool SAL_CALL filter( const Sequence< PropertyValue >& aDescriptor )
+        throw( RuntimeException );
+
+	/**
+	 * @descr	stop loading the file.
+	 */
+	virtual void SAL_CALL cancel() throw (com::sun::star::uno::RuntimeException);
+
+	/**
+	 * @descr	get the XDocumentHandler interface.
+	 */
+    void setDocumentHandler( uno::Reference< XDocumentHandler >& xHandler )
+	{
+        m_DocumentHandler = xHandler;
+    }
+
+private:
+	uno::Reference< XDocumentHandler > m_DocumentHandler;
+};
+
+/**
+ * @brief
+ * Main entry for the xml filter framework.
+ * It's called by SfxObjectShell::ImportFrom.
+ */
+class LWPFilterImportFilter : public WeakImplHelper4< XFilter, XImporter, XServiceInfo, XExtendedFilterDetection >
+{
+public:
+    LWPFilterImportFilter( const uno::Reference< XMultiServiceFactory >& xFact );
+    ~LWPFilterImportFilter();
+
+public:
+    static Sequence< OUString > getSupportedServiceNames_Static( void ) throw();
+
+    static OUString getImplementationName_Static() throw();
+public:
+    /**
+	 * @descr	see LWPFilterReader::filter.
+     */
+    virtual sal_Bool SAL_CALL filter( const Sequence< PropertyValue >& aDescriptor )
+        throw( RuntimeException );
+
+	/**
+	 * @descr	see LWPFilterReader::cancel.
+     */
+    virtual void SAL_CALL cancel() throw (com::sun::star::uno::RuntimeException);
+
+    // XImporter
+    virtual void SAL_CALL setTargetDocument( const uno::Reference< XComponent >& xDoc)
+        throw( IllegalArgumentException, RuntimeException );
+
+    // XServiceInfo
+    OUString SAL_CALL getImplementationName() throw ();
+
+    Sequence< OUString > SAL_CALL getSupportedServiceNames(void) throw ();
+
+    sal_Bool SAL_CALL supportsService(const OUString& ServiceName) throw ();
+
+	/**
+	 * @descr	function of interface XExtendedFilterDetection. If this interface is registed, it will be called whenever
+	 *			a file is to be loaded. 
+	 */
+	virtual ::rtl::OUString SAL_CALL detect( ::com::sun::star::uno::Sequence< ::com::sun::star::beans::PropertyValue >& Descriptor ) throw (::com::sun::star::uno::RuntimeException);
+
+public:
+    uno::Reference< XFilter > rFilter;
+    uno::Reference< XImporter > rImporter;
+};
+
+int		ReadWordproFile(String& strName,uno::Reference<XDocumentHandler>& XDoc);
+//test code
+int		ReadWordproFile(SvStream* pStream, uno::Reference<XDocumentHandler>& XDoc);
+
+#endif
+
diff -urNp lotuswordpro.bak/source/filter/lwpfnlayout.cxx lotuswordpro/source/filter/lwpfnlayout.cxx
--- lotuswordpro.bak/source/filter/lwpfnlayout.cxx	1970-01-01 08:00:00.000000000 +0800
+++ lotuswordpro/source/filter/lwpfnlayout.cxx	2008-10-22 11:42:29.000000000 +0800
@@ -0,0 +1,395 @@
+/*************************************************************************
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: IBM Corporation
+ *
+ *  Copyright: 2008 by IBM Corporation
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+/**
+ * @file 
+ *  For LWP filter architecture prototype - footnote layouts
+ */
+/*************************************************************************
+ * Change History
+ Mar 2005		 	Created
+ ************************************************************************/
+
+#include "lwpfnlayout.hxx"
+
+LwpFootnoteLayout::LwpFootnoteLayout(LwpObjectHeader &objHdr, LwpSvStream *pStrm)
+	:LwpTableLayout(objHdr, pStrm)
+{
+}
+
+LwpFootnoteLayout::~LwpFootnoteLayout()
+{}
+
+/**
+ * @descr  Read object info
+ */
+void LwpFootnoteLayout::Read()
+{
+	LwpTableLayout::Read();
+	m_pObjStrm->SkipExtra();
+}
+
+/**
+ * @descr  Do nothing
+ */
+void LwpFootnoteLayout::RegisterStyle()
+{
+}
+
+/**
+ * @descr  Do nothing
+ */
+void LwpFootnoteLayout::XFConvert(XFContentContainer * pCont)
+{
+}
+
+LwpFnRowLayout::LwpFnRowLayout(LwpObjectHeader &objHdr, LwpSvStream *pStrm)
+	:LwpRowLayout(objHdr, pStrm)
+{
+}
+
+LwpFnRowLayout::~LwpFnRowLayout()
+{}
+
+/**
+ * @descr  Read object info
+ */
+void LwpFnRowLayout::Read()
+{
+	LwpRowLayout::Read();
+	m_pObjStrm->SkipExtra();
+}
+
+/**
+ * @descr  Register footnote/endnote contents style
+ */
+void LwpFnRowLayout::RegisterStyle()
+{
+	// register cells' style
+	LwpObjectID *pCellID= GetChildHead();
+	LwpCellLayout * pCellLayout = static_cast<LwpCellLayout *>(pCellID->obj());
+
+	while(pCellLayout)
+	{
+		pCellLayout->SetFoundry(m_pFoundry);
+		pCellLayout->RegisterStyle();
+		pCellID = pCellLayout->GetNext();
+		pCellLayout = static_cast<LwpCellLayout *>(pCellID->obj()); 
+	}
+}
+
+/**
+ * @descr  Do nothing
+ */
+void LwpFnRowLayout::XFConvert(XFContentContainer * pCont)
+{
+}
+
+LwpFnCellLayout::LwpFnCellLayout(LwpObjectHeader &objHdr, LwpSvStream *pStrm)
+	:LwpCellLayout(objHdr, pStrm)
+{
+}
+
+LwpFnCellLayout::~LwpFnCellLayout()
+{}
+
+/**
+ * @descr  Read object info
+ */
+void LwpFnCellLayout::Read()
+{
+	LwpCellLayout::Read();
+	m_pObjStrm->SkipExtra();
+}
+
+/**
+ * @descr  Register footnote/endnote contents style
+ */
+void LwpFnCellLayout::RegisterStyle()
+{
+	// content object register styles
+	LwpObject * pObj = m_Content.obj();
+	if (pObj)
+	{
+		pObj->SetFoundry(m_pFoundry);
+		pObj->RegisterStyle();
+	}
+}
+
+/**
+ * @descr  Do nothing
+ */
+void LwpFnCellLayout::XFConvert(XFContentContainer * pCont)
+{
+}
+
+LwpEndnoteLayout::LwpEndnoteLayout(LwpObjectHeader &objHdr, LwpSvStream *pStrm)
+	:LwpTableLayout(objHdr, pStrm)
+{
+}
+
+LwpEndnoteLayout::~LwpEndnoteLayout()
+{}
+
+/**
+ * @descr  Read object info
+ */
+void LwpEndnoteLayout::Read()
+{
+	LwpTableLayout::Read();
+	m_pObjStrm->SkipExtra();
+}
+
+/**
+ * @descr  Register footnote/endnote contents style
+ */
+void LwpEndnoteLayout::RegisterStyle()
+{
+	// register style of rows
+	LwpObjectID *pRowID = GetChildHead();
+	LwpRowLayout * pRowLayout = static_cast<LwpRowLayout *>(pRowID->obj());
+	while (pRowLayout)
+	{
+		pRowLayout->SetFoundry(m_pFoundry);
+		pRowLayout->RegisterStyle();		
+		
+		pRowID = pRowLayout->GetNext();
+		pRowLayout = static_cast<LwpRowLayout *>(pRowID->obj());
+	}
+}
+
+/**
+ * @descr  Do nothing
+ */
+void LwpEndnoteLayout::XFConvert(XFContentContainer * pCont)
+{
+}
+
+LwpEnSuperTableLayout::LwpEnSuperTableLayout(LwpObjectHeader &objHdr, LwpSvStream *pStrm)
+	:LwpSuperTableLayout(objHdr, pStrm)
+{
+}
+
+LwpEnSuperTableLayout::~LwpEnSuperTableLayout()
+{}
+
+/**
+ * @descr  Read object info
+ */
+void LwpEnSuperTableLayout::Read()
+{
+	LwpSuperTableLayout::Read();
+	m_pObjStrm->SkipExtra();
+}
+
+void LwpEnSuperTableLayout::RegisterStyle()
+{
+	// if this layout is style of real table entry
+	LwpVirtualLayout* pTableLayout = GetMainTableLayout();
+	if (pTableLayout != NULL)
+	{
+		pTableLayout->SetFoundry(m_pFoundry);
+		pTableLayout->RegisterStyle();;
+	}
+}
+
+/**
+ * @descr  Do nothing
+ */
+void LwpEnSuperTableLayout::XFConvert(XFContentContainer * pCont)
+{
+}
+
+/**
+ * @short   Get child endnote layout
+ * @return pointer to endnote layout
+ */
+ LwpVirtualLayout* LwpEnSuperTableLayout::GetMainTableLayout()
+{
+	LwpObjectID *pID = GetChildTail();
+
+	while(pID && !pID->IsNull())
+	{
+		LwpVirtualLayout * pLayout = static_cast<LwpVirtualLayout *>(pID->obj());
+		if(!pLayout)
+		{
+			break;
+		}
+		if (pLayout && pLayout->GetLayoutType() == LWP_ENDNOTE_LAYOUT)
+		{
+			return pLayout;
+		}
+		pID = pLayout->GetPrevious();
+	}
+
+	return NULL;
+}
+
+LwpFnSuperTableLayout::LwpFnSuperTableLayout(LwpObjectHeader &objHdr, LwpSvStream *pStrm)
+	:LwpEnSuperTableLayout(objHdr, pStrm)
+{
+}
+
+LwpFnSuperTableLayout::~LwpFnSuperTableLayout()
+{}
+
+/**
+ * @descr  Read object info
+ */
+void LwpFnSuperTableLayout::Read()
+{
+	LwpEnSuperTableLayout::Read();
+	m_pObjStrm->SkipExtra();
+}
+
+/**
+ * @descr  Do nothing
+ */
+void LwpFnSuperTableLayout::RegisterStyle()
+{
+}
+
+/**
+ * @descr  Do nothing
+ */
+void LwpFnSuperTableLayout::XFConvert(XFContentContainer * pCont)
+{
+}
+
+/**
+ * @short   Get child footnote layout
+ * @return pointer to footnote layout
+ */
+LwpVirtualLayout* LwpFnSuperTableLayout::GetMainTableLayout()
+{
+	LwpObjectID *pID = GetChildTail();
+
+	while(pID && !pID->IsNull())
+	{
+		LwpVirtualLayout * pLayout = static_cast<LwpVirtualLayout *>(pID->obj());
+		if(!pLayout)
+		{
+			break;
+		}
+		if (pLayout && pLayout->GetLayoutType() == LWP_FOOTNOTE_LAYOUT)
+		{
+			return pLayout;
+		}
+		pID = pLayout->GetPrevious();
+	}
+
+	return NULL;
+}
+
+LwpContFromLayout::LwpContFromLayout(LwpObjectHeader &objHdr, LwpSvStream *pStrm)
+	:LwpPlacableLayout(objHdr, pStrm)
+{
+}
+
+LwpContFromLayout::~LwpContFromLayout()
+{}
+
+/**
+ * @descr  Read object info
+ */
+void LwpContFromLayout::Read()
+{
+	LwpPlacableLayout::Read();
+	m_pObjStrm->SkipExtra();
+}
+
+/**
+ * @descr  Do nothing
+ */
+void LwpContFromLayout::RegisterStyle()
+{
+}
+
+/**
+ * @descr  Do nothing
+ */
+void LwpContFromLayout::XFConvert(XFContentContainer * pCont)
+{
+}
+
+LwpContOnLayout::LwpContOnLayout(LwpObjectHeader &objHdr, LwpSvStream *pStrm)
+	:LwpPlacableLayout(objHdr, pStrm)
+{
+}
+
+LwpContOnLayout::~LwpContOnLayout()
+{}
+
+/**
+ * @descr  Read object info
+ */
+void LwpContOnLayout::Read()
+{
+	LwpPlacableLayout::Read();
+	m_pObjStrm->SkipExtra();
+}
+
+/**
+ * @descr  Do nothing
+ */
+void LwpContOnLayout::RegisterStyle()
+{
+}
+
+/**
+ * @descr  Do nothing
+ */
+void LwpContOnLayout::XFConvert(XFContentContainer * pCont)
+{
+}
diff -urNp lotuswordpro.bak/source/filter/lwpfnlayout.hxx lotuswordpro/source/filter/lwpfnlayout.hxx
--- lotuswordpro.bak/source/filter/lwpfnlayout.hxx	1970-01-01 08:00:00.000000000 +0800
+++ lotuswordpro/source/filter/lwpfnlayout.hxx	2008-10-22 11:42:29.000000000 +0800
@@ -0,0 +1,195 @@
+/*************************************************************************
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: IBM Corporation
+ *
+ *  Copyright: 2008 by IBM Corporation
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+/**
+ * @file 
+ *  For LWP filter architecture prototype - footnote layouts
+ */
+/*************************************************************************
+ * Change History
+ Mar 2005		 	Created
+ ************************************************************************/
+#ifndef _LWP_FNLAYOUT_HXX
+#define _LWP_FNLAYOUT_HXX
+
+#include "lwptablelayout.hxx"
+
+/**
+ * @brief	VO_FOOTNOTELAYOUT object
+ * 
+*/
+class LwpFootnoteLayout : public LwpTableLayout
+{
+public:
+	LwpFootnoteLayout(LwpObjectHeader &objHdr, LwpSvStream* pStrm);
+	virtual ~LwpFootnoteLayout();
+	void RegisterStyle();
+	virtual void XFConvert(XFContentContainer * pCont);
+	virtual LWP_LAYOUT_TYPE GetLayoutType () { return LWP_FOOTNOTE_LAYOUT;}
+protected:
+	void Read();
+};
+
+/**
+ * @brief	VO_FNROWLAYOUT object
+ * 
+*/
+class LwpFnRowLayout : public LwpRowLayout
+{
+public:
+	LwpFnRowLayout(LwpObjectHeader &objHdr, LwpSvStream* pStrm);
+	virtual ~LwpFnRowLayout();
+	void RegisterStyle();
+	virtual void XFConvert(XFContentContainer * pCont);
+	virtual LWP_LAYOUT_TYPE GetLayoutType () { return LWP_FOOTNOTE_ROW_LAYOUT;}
+protected:
+	void Read();
+};
+
+/**
+ * @brief	VO_FNCELLLAYOUT object
+ * 
+*/
+class LwpFnCellLayout : public LwpCellLayout
+{
+public:
+	LwpFnCellLayout(LwpObjectHeader &objHdr, LwpSvStream* pStrm);
+	virtual ~LwpFnCellLayout();
+	void RegisterStyle();
+	virtual void XFConvert(XFContentContainer * pCont);
+	virtual LWP_LAYOUT_TYPE GetLayoutType () { return LWP_FOOTNOTE_CELL_LAYOUT;}
+protected:
+	void Read();
+};
+
+/**
+ * @brief	VO_ENDNOTELAYOUT object
+ * 
+*/
+class LwpEndnoteLayout : public LwpTableLayout
+{
+public:
+	LwpEndnoteLayout(LwpObjectHeader &objHdr, LwpSvStream* pStrm);
+	virtual ~LwpEndnoteLayout();
+	void RegisterStyle();
+	virtual void XFConvert(XFContentContainer * pCont);
+	virtual LWP_LAYOUT_TYPE GetLayoutType () { return LWP_ENDNOTE_LAYOUT;}
+protected:
+	void Read();
+};
+
+/**
+ * @brief	VO_ENSUPERTABLELAYOUT object
+ * 
+*/
+class LwpEnSuperTableLayout : public LwpSuperTableLayout
+{
+public:
+	LwpEnSuperTableLayout(LwpObjectHeader &objHdr, LwpSvStream* pStrm);
+	virtual ~LwpEnSuperTableLayout();
+	void RegisterStyle();	
+	void XFConvert(XFContentContainer* pCont);
+	virtual LWP_LAYOUT_TYPE GetLayoutType () { return LWP_ENDNOTE_SUPERTABLE_LAYOUT;}	
+	virtual LwpVirtualLayout* GetMainTableLayout();
+protected:
+	void Read();
+};
+
+/**
+ * @brief	VO_FNSUPERTABLELAYOUT object
+ * 
+*/
+class LwpFnSuperTableLayout : public LwpEnSuperTableLayout
+{
+public:
+	LwpFnSuperTableLayout(LwpObjectHeader &objHdr, LwpSvStream* pStrm);
+	virtual ~LwpFnSuperTableLayout();
+	void RegisterStyle();	
+	void XFConvert(XFContentContainer* pCont);
+	virtual LWP_LAYOUT_TYPE GetLayoutType () { return LWP_FOOTNOTE_SUPERTABLE_LAYOUT;}
+	virtual LwpVirtualLayout* GetMainTableLayout();
+protected:
+	void Read();
+};
+
+/**
+ * @brief	VO_CONTFROMLAYOUT object
+ * 
+*/
+class LwpContFromLayout : public LwpPlacableLayout
+{
+public:
+	LwpContFromLayout(LwpObjectHeader &objHdr, LwpSvStream* pStrm);
+	virtual ~LwpContFromLayout();
+	void RegisterStyle();	
+	void XFConvert(XFContentContainer* pCont);
+protected:
+	void Read();
+};
+
+/**
+ * @brief	VO_CONTONLAYOUT object
+ * 
+*/
+class LwpContOnLayout : public LwpPlacableLayout
+{
+public:
+	LwpContOnLayout(LwpObjectHeader &objHdr, LwpSvStream* pStrm);
+	virtual ~LwpContOnLayout();
+	void RegisterStyle();	
+	void XFConvert(XFContentContainer* pCont);
+protected:
+	void Read();
+};
+#endif
diff -urNp lotuswordpro.bak/source/filter/lwpfont.cxx lotuswordpro/source/filter/lwpfont.cxx
--- lotuswordpro.bak/source/filter/lwpfont.cxx	1970-01-01 08:00:00.000000000 +0800
+++ lotuswordpro/source/filter/lwpfont.cxx	2008-10-22 11:42:29.000000000 +0800
@@ -0,0 +1,556 @@
+/*************************************************************************
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: IBM Corporation
+ *
+ *  Copyright: 2008 by IBM Corporation
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+#include "lwpglobalmgr.hxx"
+#include "lwpfont.hxx"
+#include "xfilter/xfstylemanager.hxx"
+#include "xfilter/xffontfactory.hxx"
+
+void LwpFontAttrEntry::Read(LwpObjectStream *pStrm)
+{
+	pStrm->QuickRead(&m_nAttrBits, sizeof(m_nAttrBits));
+	pStrm->QuickRead(&m_nAttrOverrideBits, sizeof(m_nAttrOverrideBits));
+	pStrm->QuickRead(&m_nAttrApplyBits, sizeof(m_nAttrApplyBits));	
+	pStrm->QuickRead(&m_nAttrOverrideBits2, sizeof(m_nAttrOverrideBits2));
+	pStrm->QuickRead(&m_nAttrApplyBits2, sizeof(m_nAttrApplyBits2));
+	pStrm->QuickRead(&m_nCase, sizeof(m_nCase));	
+	pStrm->QuickRead(&m_nUnder, sizeof(m_nUnder));
+	pStrm->SkipExtra();
+}
+
+#include "xfilter/xfdefs.hxx"
+void LwpFontAttrEntry::Override( XFFont*pFont )
+{
+	if (IsBoldOverridden())
+		pFont->SetBold(Is(BOLD));
+
+	if (IsItalicOverridden())
+		pFont->SetItalic(Is(ITALIC));
+
+	if (IsStrikeThruOverridden())
+	{
+		if(Is(STRIKETHRU))
+		{
+			pFont->SetCrossout(enumXFCrossoutSignel);
+		}
+		else
+		{
+			pFont->SetCrossout(enumXFCrossoutNone);
+		}
+	}
+
+	if (IsSuperOverridden())
+	{
+		if(Is(SUPERSCRIPT))
+			pFont->SetPosition(TRUE);
+	}
+
+	if (IsSubOverridden())
+	{
+		if(Is(SUBSCRIPT))
+			pFont->SetPosition(FALSE);
+	}
+
+	if (IsUnderlineOverridden())
+	{
+		switch(m_nUnder)
+		{
+			case UNDER_SINGLE:
+				pFont->SetUnderline(enumXFUnderlineSingle);
+				break;
+			case UNDER_DOUBLE:
+				pFont->SetUnderline(enumXFUnderlineDouble);
+				break;
+			case UNDER_WORD_SINGLE:
+				pFont->SetUnderline(enumXFUnderlineSingle, true);
+				break;
+			case UNDER_WORD_DOUBLE:
+				pFont->SetUnderline(enumXFUnderlineSingle, true);
+				break;
+			case UNDER_DONTCARE:	//fall through
+			case UNDER_OFF:			//fall through
+			case UNDER_STYLE:		//fall through		
+			default:
+				break;
+				//do nothing;
+		}
+	}
+
+	if (IsCaseOverridden())
+	{
+		switch(m_nCase)
+		{
+		case CASE_UPPER:
+			pFont->SetTransform(enumXFTransformUpper);
+			break;		
+		case CASE_LOWER:
+			pFont->SetTransform(enumXFTransformLower);
+			break;		
+		case CASE_NORMAL:
+			pFont->SetTransform(enumXFTransformNone);
+			break;		
+		case CASE_INITCAPS:
+			pFont->SetTransform(enumXFTransformCapitalize);
+			break;
+		case CASE_STYLE:		//fall through
+		case CASE_DONTCARE:	//fall through
+		default:
+			//do nothing
+			;
+		}
+	}
+
+	//Please note that, put the SmallCaps setting after the case setting, 
+	//for SmallCaps has higher priority than LowerCase but low
+	if (IsSmallCapsOverridden())
+	{
+		if( pFont->GetTransform()!=enumXFTransformUpper )	//SmallCaps should not override upper case
+		{
+			if(Is(SMALLCAPS))
+				pFont->SetTransform(enumXFTransformSmallCaps);
+		}
+	}
+
+	// TODO: tightness
+	//if (IsTightnessOverridden())
+	//	pFont->SetTightness(cTightness);*/
+}
+
+BOOL LwpFontAttrEntry::Is(sal_uInt16 Attr)
+{
+	return (0 != (m_nAttrBits & Attr));
+}
+
+BOOL LwpFontAttrEntry::IsBoldOverridden()
+{
+	return (0 != (m_nAttrOverrideBits & BOLD));
+}
+
+BOOL LwpFontAttrEntry::IsItalicOverridden()
+{
+	return (0 != (m_nAttrOverrideBits & ITALIC));
+}
+BOOL LwpFontAttrEntry::IsStrikeThruOverridden()
+{
+	return (0 != (m_nAttrOverrideBits & STRIKETHRU));
+}
+BOOL LwpFontAttrEntry::IsSmallCapsOverridden()
+{
+	return (0 != (m_nAttrOverrideBits & SMALLCAPS));
+}
+BOOL LwpFontAttrEntry::IsSuperOverridden()
+{
+	return (0 != (m_nAttrOverrideBits & SUPERSCRIPT));
+
+}
+BOOL LwpFontAttrEntry::IsSubOverridden()
+{
+	return (0 != (m_nAttrOverrideBits & SUBSCRIPT));
+
+}
+
+BOOL LwpFontAttrEntry::IsSuperSubOverridden()
+{
+	return (0 != (m_nAttrOverrideBits
+		& (SUPERSCRIPT | SUBSCRIPT)));
+}
+
+BOOL LwpFontAttrEntry::IsUnderlineOverridden()
+{
+	return (0 != (m_nAttrOverrideBits2 & UNDER));
+}
+BOOL LwpFontAttrEntry::IsCaseOverridden()
+{
+	return (0 != (m_nAttrOverrideBits2 & CASE));
+}
+
+void LwpFontTableEntry::Read(LwpObjectStream *pStrm) 
+{
+	m_WindowsFaceName.Read(pStrm);
+
+	// use the m_WindowsFaceName to set the m_FaceName temporarily
+	m_FaceName = m_WindowsFaceName;
+
+	//Skip the panoseNumber
+	//m_PanoseNumber.Read(pStrm);
+	LwpPanoseNumber thePanoseToSkip;
+	thePanoseToSkip.Read(pStrm);
+
+	pStrm->SkipExtra();
+
+	RegisterFontDecl();
+}
+
+OUString LwpFontTableEntry::GetFaceName()
+{
+	return (m_WindowsFaceName.str());
+}
+
+void LwpFontTableEntry::RegisterFontDecl()
+{
+	if(m_FaceName.str().getLength()==0) return;
+	XFStyleManager* pXFStyleManager = LwpGlobalMgr::GetInstance()->GetXFStyleManager();
+	XFFontDecl aFontDecl1( m_FaceName.str(), m_FaceName.str(), false );
+	pXFStyleManager->AddFontDecl(aFontDecl1);
+}
+
+LwpFontTable::LwpFontTable()
+	: m_pFontEntries(NULL)
+{}
+
+void LwpFontTable::Read(LwpObjectStream *pStrm) 
+{
+	m_pFontEntries = NULL;
+	pStrm->QuickRead(&m_nCount, sizeof(m_nCount));
+	if(m_nCount>0)
+	{
+		m_pFontEntries = new LwpFontTableEntry[m_nCount];
+		for(sal_uInt16 i=0; i<m_nCount; i++)
+		{
+			m_pFontEntries[i].Read(pStrm);
+		}
+	}
+	pStrm->SkipExtra();
+}
+
+OUString LwpFontTable::GetFaceName(sal_uInt16 index) //index: start from 1
+{
+	assert(index>0);
+	if (index < 1)//add by , for fix crash,2005/12/20
+		return OUString::createFromAscii("");//add end
+	return m_pFontEntries[index-1].GetFaceName();
+}
+
+LwpFontTable::~LwpFontTable()
+{
+	if(m_pFontEntries)
+	{
+		delete [] m_pFontEntries;
+		m_pFontEntries = NULL;
+	}
+}
+
+void LwpFontNameEntry::Read(LwpObjectStream *pStrm) 
+{
+	//Read CFontDescriptionOverrideBase
+	pStrm->QuickRead(&m_nOverrideBits, sizeof(m_nOverrideBits));
+	pStrm->QuickRead(&m_nApplyBits, sizeof(m_nApplyBits));
+	pStrm->QuickRead(&m_nPointSize, sizeof(m_nPointSize));
+	pStrm->QuickRead(&m_nOverstrike, sizeof(m_nOverstrike));
+	pStrm->QuickRead(&m_nTightness, sizeof(m_nTightness));
+	m_Color.Read(pStrm);
+	m_BackColor.Read(pStrm);	
+	pStrm->SkipExtra();
+
+	//Read data of LwpFontNameEntry
+	pStrm->QuickRead(&m_nFaceName, sizeof(m_nFaceName));
+	pStrm->QuickRead(&m_nAltFaceName, sizeof(m_nAltFaceName));	
+	pStrm->SkipExtra();	
+}
+#include "xfilter/xfcolor.hxx"
+void LwpFontNameEntry::Override(XFFont* pFont)
+{
+	if (IsPointSizeOverridden())
+		pFont->SetFontSize(static_cast<sal_uInt8>(m_nPointSize/65536L));
+
+	if (IsColorOverridden() && m_Color.IsValidColor())
+	{
+		XFColor aColor(m_Color.To24Color());
+		pFont->SetColor(aColor);
+	}
+		
+
+	if (IsBackgroundColorOverridden() )
+	{
+		if (m_BackColor.IsValidColor())
+		{
+			XFColor aColor(m_BackColor.To24Color());
+			pFont->SetBackColor( aColor );
+		}
+		else if (m_BackColor.IsTransparent())
+		{
+			pFont->SetBackColorTransparent();
+		}
+	}		
+
+	// TODO: tightness
+	//if (IsTightnessOverridden())
+	//	pFont->SetTightness(cTightness);
+}
+
+BOOL LwpFontNameEntry::IsFaceNameOverridden()
+{
+	return (0 != (m_nOverrideBits & FACENAME));
+}
+
+BOOL LwpFontNameEntry::IsAltFaceNameOverridden()
+{
+	return (0 != (m_nOverrideBits & ALTFACENAME));
+}
+
+BOOL LwpFontNameEntry::IsPointSizeOverridden()
+{
+	return (0 != (m_nOverrideBits & POINTSIZE));
+}
+
+BOOL LwpFontNameEntry::IsColorOverridden()
+{
+	return (0 != (m_nOverrideBits & COLOR));
+}
+
+BOOL LwpFontNameEntry::IsBackgroundColorOverridden()
+{
+	return (0 != (m_nOverrideBits & BKCOLOR));
+}
+
+BOOL LwpFontNameEntry::IsTightnessOverridden()
+{
+	return (0 != (m_nOverrideBits & TIGHTNESS));
+}
+
+BOOL LwpFontNameEntry::IsAnythingOverridden()
+{
+	return (0 != (m_nOverrideBits & ALL_BITS));
+}
+
+
+LwpFontNameManager::LwpFontNameManager()
+	:m_pFontNames(NULL)
+{}
+
+LwpFontNameManager::~LwpFontNameManager()
+{
+	if(m_pFontNames)
+	{
+		delete [] m_pFontNames;
+		m_pFontNames = NULL;
+	}
+}
+
+void LwpFontNameManager::Read(LwpObjectStream *pStrm) 
+{
+	pStrm->QuickRead(&m_nCount, sizeof(m_nCount));
+	if(m_nCount>0)
+	{
+		m_pFontNames = new LwpFontNameEntry[m_nCount];
+		for(sal_uInt16 i=0; i<m_nCount; i++)
+		{
+			m_pFontNames[i].Read(pStrm);
+		}
+	}
+	m_FontTbl.Read(pStrm);
+	pStrm->SkipExtra();
+}
+
+void	LwpFontNameManager::Override(sal_uInt16 index, XFFont* pFont)
+	//index: start from 1
+{
+	if(index<1) return;
+	m_pFontNames[index-1].Override(pFont);
+	if(m_pFontNames[index-1].IsFaceNameOverridden())
+		pFont->SetFontName(m_FontTbl.GetFaceName(m_pFontNames[index-1].GetFaceID()));
+	if(m_pFontNames[index-1].IsAltFaceNameOverridden())
+		pFont->SetFontNameAsia(m_FontTbl.GetFaceName(m_pFontNames[index-1].GetAltFaceID()));	
+}
+OUString LwpFontNameManager::GetNameByIndex(sal_uInt16 index)
+{
+	sal_uInt16 nameindex = m_pFontNames[index-1].GetFaceID();
+	return (m_FontTbl.GetFaceName(nameindex));
+}
+
+/*void LwpFontNameManager::Override(sal_uInt16 baseID, sal_uInt16 overID, XFFont* pFont)
+{
+	//Override
+	m_pFontNames[overID-1]. Override(&m_pFontNames[baseID-1], pFont);
+}
+
+void LwpFontAttrManager::Override(sal_uInt16 baseID, sal_uInt16 overID, XFFont*pFont)
+{
+	m_pFontAttrs[overID-1]. Override(&m_pFontAttrs[baseID-1], pFont);
+}*/
+
+void LwpFontAttrManager::Read(LwpObjectStream *pStrm) {
+	pStrm->QuickRead(&m_nCount, sizeof(m_nCount));
+	m_pFontAttrs = new LwpFontAttrEntry[m_nCount];
+	
+	for(sal_uInt16 i=0; i<m_nCount; i++)
+	{
+		m_pFontAttrs[i].Read(pStrm);
+	}
+	pStrm->SkipExtra();
+}
+
+void	LwpFontAttrManager::Override(sal_uInt16 index, XFFont* pFont)
+	//index: start from 1
+{
+	if(index<1) return;
+	m_pFontAttrs[index-1].Override(pFont);
+}
+
+LwpFontAttrManager::~LwpFontAttrManager()
+{
+	if(m_pFontAttrs)
+		delete []m_pFontAttrs;
+}
+
+void LwpFontManager::Read(LwpObjectStream *pStrm) 
+{
+	m_FNMgr.Read(pStrm);
+	m_AttrMgr.Read(pStrm);
+	pStrm->SkipExtra();
+
+}
+
+#include "xfilter/xftextstyle.hxx"
+
+/*
+VO_PARASTYLE call this method to add its style to XFStyleManager based on the fontID
+1. Construct the text style based on the fontID
+2. Add the style to XFStyleManager, and return the <office:styles> style name
+3. Add it to LwpParaStyleMap.
+Note: A temporary method for only font support phase. The next AddStyle should be used later.
+// To be replaced by LwpStyleManager::AddStyle() and the following CreateFont()
+*/
+/*void LwpFontManager::AddStyle(LwpObjectID styleObjID, sal_uInt32 fontID, OUString styleName)
+{
+	XFTextStyle* pStyle = new XFTextStyle();		//to be deleted by XFStyleManager
+	AddStyle(styleObjID, fontID, styleName, pStyle);
+}*/
+
+/*
+VO_PARASTYLE/VO_CHARACTERSTYLE call this method to add its style to XFStyleManager based on the fontID
+1. Construct the text style based on the fontID
+2. Add the style to XFStyleManager, and return the <office:styles> style name
+3. Add it to LwpParaStyleMap.
+Prerequisite: pStyle has been created and the paragraph properties has been set to it.
+//To be replaced by LwpStyleManager::AddStyle() and the following CreateFont()
+*/
+/*void LwpFontManager::AddStyle(LwpObjectID styleObjID, sal_uInt32 fontID, OUString styleName, XFTextStyle* pStyle)
+{
+	assert(pStyle);
+	XFFont* pFont = CreateFont(fontID);
+	pStyle->SetFont(pFont);
+	pStyle->SetStyleName(styleName);
+	XFStyleManager::AddStyle(pStyle);
+	m_StyleList.insert(LwpParaStyleMap::value_type(styleObjID, styleName));	
+}*/
+
+/*
+Create XFFont based on the fotID
+*/
+XFFont* LwpFontManager::CreateFont(sal_uInt32 fontID)
+{
+	XFFont* pFont = new XFFont();
+	SetDfltFont(pFont);	
+	m_FNMgr.Override(GetFontNameIndex(fontID), pFont);
+	m_AttrMgr.Override(GetFontAttrIndex(fontID), pFont);
+	return pFont;
+}
+
+/*
+Called XFFont based on the override result of two font ids.
+Refer to CFontManager::OverrideID
+*/
+//OUString LwpFontManager::GetOverrideStyle(sal_uInt32 fontID, sal_uInt32 overID)
+XFFont* LwpFontManager::CreateOverrideFont(sal_uInt32 fontID, sal_uInt32 overID)
+{
+	XFFont* pFont = new XFFont();	//To be deleted by XFFontFactory
+	SetDfltFont(pFont);
+	if(fontID)
+	{
+		Override(fontID, pFont);
+	}
+	if(overID)
+	{
+		Override(overID, pFont);
+	}
+	return pFont;
+}
+
+void LwpFontManager::Override(sal_uInt32 fontID, XFFont* pFont)
+{
+	m_FNMgr.Override(GetFontNameIndex(fontID), pFont);
+	m_AttrMgr.Override(GetFontAttrIndex(fontID), pFont);
+}
+
+
+/*
+Called by VO_PARA to get style name based on the Para Style ID
+1) Get style from LwpParaStyleMap based on the LwpObjectID of VO_PARASTYLE.
+2) Prerequisite: VO_PARASTYLE should call AddStyle first.
+3) Return empty string if no style found.
+//To be replaced by OUString LwpStyleManager::GetStyle(const LwpObjectID &styleID)
+*/
+/*OUString LwpFontManager::GetParaStyle(const LwpObjectID &styleID)
+{
+	LwpParaStyleMap::const_iterator it =  m_StyleList.find(styleID);
+	if (it != m_StyleList.end()) { 
+		return((*it).second);
+	}
+	return OUString();
+}*/
+
+void LwpFontManager::SetDfltFont(XFFont* pFont)
+{
+	// TODO:  Set default XFFont values in lwp filter
+	//color:black, background color: transparent, Orientation: left to right, top to bottom, others: 0
+	//Refer to CFontDescription::CFontDescription(void)
+	//Did not find anything special
+	//pFont->SetColor(XFColor(0,0,0));
+}
+
+OUString LwpFontManager::GetNameByID(sal_uInt32 fontID)
+{
+	return ( m_FNMgr.GetNameByIndex(GetFontNameIndex(fontID)) );//use font id for bullet? note by ,2005/7/5
+}
diff -urNp lotuswordpro.bak/source/filter/lwpfont.hxx lotuswordpro/source/filter/lwpfont.hxx
--- lotuswordpro.bak/source/filter/lwpfont.hxx	1970-01-01 08:00:00.000000000 +0800
+++ lotuswordpro/source/filter/lwpfont.hxx	2008-10-22 11:42:29.000000000 +0800
@@ -0,0 +1,283 @@
+/*************************************************************************
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: IBM Corporation
+ *
+ *  Copyright: 2008 by IBM Corporation
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+/*************************************************************************
+ * @file 
+ *  Font manager related classes header file
+ *  LwpFontTableEntry, LwpFontTable, LwpFontNameEntry, 
+ * LwpFontAttrEntry, LwpFontNameManager,LwpFontAttrManager,
+ * LwpFontManager
+ ************************************************************************/
+/*************************************************************************
+ * Change History
+ Jan 2005			Created
+ ************************************************************************/
+
+#ifndef _LWPFONT_HXX
+#define _LWPFONT_HXX
+
+#include "lwpheader.hxx"
+#include "lwpobjstrm.hxx"
+#include "lwpatomholder.hxx"
+#include "lwpcolor.hxx"
+#include "lwpbasetype.hxx"
+#include "lwpobj.hxx"
+#include "xfilter/xffont.hxx"
+#include "xfilter/xftextstyle.hxx"
+
+class LwpFontTableEntry
+{
+public:
+	LwpFontTableEntry(){};
+	~LwpFontTableEntry(){};
+public:
+	void Read(LwpObjectStream *pStrm);
+	OUString GetFaceName();
+private:
+	LwpAtomHolder m_WindowsFaceName;	//font face name under windows
+	LwpAtomHolder m_FaceName;			//font face name
+	void RegisterFontDecl();
+	 //Not useful now, so skip
+	//LwpPanoseNumber m_PanoseNumber; 
+};
+
+class LwpFontTable
+{
+public:
+	LwpFontTable();
+	~LwpFontTable();
+public:
+	void Read(LwpObjectStream *pStrm);
+	OUString GetFaceName(sal_uInt16 index); //index: start from 1
+//	void RegisterFontDecls();
+private:
+	sal_uInt16 m_nCount;
+	LwpFontTableEntry* m_pFontEntries;
+};
+
+
+class LwpFontNameEntry
+{
+public:
+	LwpFontNameEntry(){};
+	~LwpFontNameEntry(){};
+public:
+	void Read(LwpObjectStream *pStrm);
+	inline sal_uInt16 GetFaceID(){return m_nFaceName;};
+	inline sal_uInt16 GetAltFaceID(){return m_nAltFaceName;};	
+	void Override(XFFont* pFont);
+	inline BOOL IsFaceNameOverridden();
+	inline BOOL IsAltFaceNameOverridden();
+private:
+	//Data of CFontDescriptionOverrideBase
+	sal_uInt8 m_nOverrideBits;
+	sal_uInt8 m_nApplyBits;
+	sal_uInt32 m_nPointSize;
+	sal_uInt16 m_nOverstrike;
+	sal_uInt16 m_nTightness;
+	LwpColor m_Color;
+	LwpColor m_BackColor;
+	//Data of LwpFontNameEntry
+	sal_uInt16 m_nFaceName; //CFontTableID
+	sal_uInt16 m_nAltFaceName; //CFontTableID
+	enum
+	{
+		POINTSIZE		= 0x01,
+		COLOR			= 0x02,
+		OVERSTRIKE		= 0x04,
+		TIGHTNESS		= 0x08,
+		FACENAME		= 0x10,
+		BKCOLOR			= 0x20,
+		ALTFACENAME		= 0x40,
+		ALL_BITS		= (POINTSIZE | COLOR | OVERSTRIKE
+							| ALTFACENAME
+							| TIGHTNESS | FACENAME | BKCOLOR)
+	};
+
+	inline BOOL IsPointSizeOverridden();
+	inline BOOL IsColorOverridden();
+	inline BOOL IsBackgroundColorOverridden();
+	inline BOOL IsTightnessOverridden();
+	inline BOOL IsAnythingOverridden();	
+};
+
+class LwpFontNameManager
+{
+public:
+	LwpFontNameManager();
+	~LwpFontNameManager();
+	OUString GetNameByIndex(sal_uInt16 index);
+private:
+	sal_uInt16 m_nCount;
+	LwpFontNameEntry* m_pFontNames;
+	LwpFontTable m_FontTbl;
+
+public:
+	void Read(LwpObjectStream *pStrm);
+	void	Override(sal_uInt16 index, XFFont* pFont);
+};
+
+class LwpFontAttrEntry
+{
+public:
+	LwpFontAttrEntry(){};
+	~LwpFontAttrEntry(){};
+public:
+	void Read(LwpObjectStream *pStrm);
+	void Override(XFFont*pFont);
+private:
+	sal_uInt16 m_nAttrBits;
+	sal_uInt16 m_nAttrOverrideBits;
+	sal_uInt16 m_nAttrApplyBits;
+	sal_uInt8 m_nAttrOverrideBits2;
+	sal_uInt8 m_nAttrApplyBits2;
+	sal_uInt8 m_nCase;
+	sal_uInt8 m_nUnder;	
+	enum
+	{
+		BOLD			= 0x0001,
+		ITALIC			= 0x0002,
+		STRIKETHRU		= 0x0004,
+
+		SUPERSCRIPT	= 0x0100,
+		SUBSCRIPT		= 0x0200,
+
+		SMALLCAPS		= 0x0400,
+
+		ALL_ATTRS		= BOLD | ITALIC | STRIKETHRU
+						| SUPERSCRIPT | SUBSCRIPT
+						| SMALLCAPS,
+
+		CASE_DONTCARE	= 0,
+		CASE_NORMAL	= 1,
+		CASE_UPPER		= 2,
+		CASE_LOWER	= 3,
+		CASE_INITCAPS	= 4,
+		CASE_STYLE		= 7,
+
+		UNDER_DONTCARE	= 0,
+		UNDER_OFF			= 1,
+		UNDER_SINGLE		= 2,
+		UNDER_DOUBLE		= 3,
+		UNDER_WORD_SINGLE	= 4,
+		UNDER_WORD_DOUBLE	= 5,
+		UNDER_STYLE			= 7,
+
+		CASE	= 0x01,
+		UNDER	= 0x02,
+		ALL_ATTRS2			= CASE | UNDER
+	};
+	BOOL Is(sal_uInt16 Attr);
+	BOOL IsBoldOverridden();
+	BOOL IsItalicOverridden();	
+	BOOL IsStrikeThruOverridden();
+	BOOL IsSmallCapsOverridden();
+	BOOL IsSuperOverridden();
+	BOOL IsSubOverridden();
+	BOOL IsSuperSubOverridden();
+	BOOL IsUnderlineOverridden();
+	BOOL IsCaseOverridden();	
+
+};
+
+class LwpFontAttrManager
+{
+public:
+	LwpFontAttrManager():m_pFontAttrs(NULL){};
+	~LwpFontAttrManager();
+public:
+	void Read(LwpObjectStream *pStrm);
+	void Override(sal_uInt16 index, XFFont*pFont);
+private:
+	sal_uInt16 m_nCount;	
+	LwpFontAttrEntry* m_pFontAttrs;
+};
+
+class LwpFontManager
+{
+public:
+	LwpFontManager(){};
+	~LwpFontManager(){};
+private:
+	LwpFontNameManager m_FNMgr;
+	LwpFontAttrManager m_AttrMgr;
+	sal_uInt32 m_nDlfTxtStyleFontID;
+
+public:
+	void Read(LwpObjectStream *pStrm);
+	XFFont* CreateOverrideFont(sal_uInt32 fontID, sal_uInt32 overID);	
+	XFFont*  CreateFont(sal_uInt32 fontID);
+	OUString GetNameByID(sal_uInt32 fontID);
+	//void AddStyle(LwpObjectID styleObjID, sal_uInt32 fontID, OUString styleName);
+	//void AddStyle(LwpObjectID styleObjID, sal_uInt32 fontID, OUString styleName, XFTextStyle* pStyle);
+	//OUString GetOverrideStyle(sal_uInt32 fontID, sal_uInt32 overID);
+	
+private:
+	void Override(sal_uInt32 fontID, XFFont* pFont);
+	inline sal_uInt16 GetFontNameIndex(sal_uInt32 fontID);
+	inline sal_uInt16 GetFontAttrIndex(sal_uInt32 fontID);
+	void SetDfltFont(XFFont* pFont);
+};
+
+sal_uInt16 LwpFontManager::GetFontNameIndex(sal_uInt32 fontID)
+{
+	return static_cast<sal_uInt16>((fontID>>16)&0xFFFF);
+}
+
+sal_uInt16 LwpFontManager::GetFontAttrIndex(sal_uInt32 fontID)
+{
+	return static_cast<sal_uInt16>(fontID);
+}
+
+#endif
diff -urNp lotuswordpro.bak/source/filter/lwpfootnote.cxx lotuswordpro/source/filter/lwpfootnote.cxx
--- lotuswordpro.bak/source/filter/lwpfootnote.cxx	1970-01-01 08:00:00.000000000 +0800
+++ lotuswordpro/source/filter/lwpfootnote.cxx	2008-10-22 11:42:29.000000000 +0800
@@ -0,0 +1,595 @@
+/*************************************************************************
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: IBM Corporation
+ *
+ *  Copyright: 2008 by IBM Corporation
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+/**
+ * @file 
+ *  footnote
+ */
+/*************************************************************************
+ * Change History
+ Mar 2005		 	Created
+ ************************************************************************/
+#include "lwpfootnote.hxx"
+#include "lwpstory.hxx"
+#include "xfilter/xffootnote.hxx"
+#include "xfilter/xfendnote.hxx"
+#include "xfilter/xffootnoteconfig.hxx"
+#include "xfilter/xfendnoteconfig.hxx"
+#include "xfilter/xfstylemanager.hxx"
+#include "xfilter/xftextspan.hxx"
+#include "lwppara.hxx"
+#include "lwpdoc.hxx"
+#include "lwpfnlayout.hxx"
+#include "lwpglobalmgr.hxx"
+
+LwpFribFootnote::LwpFribFootnote(LwpPara* pPara ):LwpFrib(pPara)
+{
+}
+
+/**
+ * @descr  read footnote frib information
+ */
+void LwpFribFootnote::Read(LwpObjectStream *pObjStrm, sal_uInt16 len)
+{
+	m_Footnote.ReadIndexed(pObjStrm);
+}
+
+/**
+ * @descr  Register footnote style by calling LwpFootnote::RegisterStyle()
+ */
+void LwpFribFootnote::RegisterStyle()
+{	
+	LwpFootnote* pFootnote = GetFootnote();
+	if(pFootnote)
+	{
+		//register footnote number font style
+		LwpFrib::RegisterStyle(m_pPara->GetFoundry());
+		//register footnote content style
+		pFootnote->SetFoundry(m_pPara->GetFoundry());
+		pFootnote->RegisterStyle();
+	}
+}
+
+/**
+ * @descr  Parse footnote  by calling LwpFootnote::XFConvert()
+ */
+void LwpFribFootnote::XFConvert(XFContentContainer* pCont)
+{
+	LwpFootnote* pFootnote = GetFootnote();
+	if(pFootnote)
+	{
+		XFContentContainer* pContent = NULL;
+		if(pFootnote->GetType() == FN_FOOTNOTE)
+		{
+			pContent = new XFFootNote();				
+		}
+		else
+		{
+			pContent = new XFEndNote();				
+		}
+		pFootnote->XFConvert(pContent);		
+		if(m_ModFlag)
+		{	
+			//set footnote number font style
+			XFTextSpan *pSpan = new XFTextSpan();
+			pSpan->SetStyleName(GetStyleName());
+			//add the xffootnote into the content container
+			pSpan->Add(pContent);
+			pCont->Add(pSpan); 
+		}   
+		else
+		{
+			pCont->Add(pContent);
+		}
+	}	
+}
+
+/**
+ * @descr  Get foonote object
+ */
+LwpFootnote* LwpFribFootnote::GetFootnote()
+{
+	return static_cast<LwpFootnote*>(m_Footnote.obj());	
+}
+
+
+LwpFootnote::LwpFootnote(LwpObjectHeader &objHdr, LwpSvStream *pStrm)
+	: LwpOrderedObject(objHdr, pStrm)
+{
+}
+
+LwpFootnote::~LwpFootnote()
+{
+
+}
+
+/**
+ * @descr  Read foonote object
+ */
+void LwpFootnote::Read()
+{
+	LwpOrderedObject::Read();
+	m_pObjStrm->QuickRead(&m_nType, sizeof(m_nType));
+	m_pObjStrm->QuickRead(&m_nRow, sizeof(m_nRow));
+	m_Content.ReadIndexed(m_pObjStrm);
+	m_pObjStrm->SkipExtra();
+}
+
+/**
+ * @descr  Register footnote style
+ */
+void LwpFootnote::RegisterStyle()
+{	
+	//Only register footnote contents style,
+	//Endnote contents style registers in LwpEnSuperTableLayout::RegisterStyle
+	if(m_nType == FN_FOOTNOTE)
+	{
+		LwpContent* pContent = FindFootnoteContent();
+		if(pContent)
+		{
+			pContent->SetFoundry(m_pFoundry);
+			pContent->RegisterStyle();
+		}
+	}	
+}
+
+/**
+ * @descr  Parse footnote
+ */
+void LwpFootnote::XFConvert(XFContentContainer * pCont)
+{
+	LwpContent* pContent = FindFootnoteContent();
+	if(pContent)
+	{
+		pContent->XFConvert(pCont);
+	}
+}
+
+/**
+ * @descr  Get endnote cell layout which contains current endnote content
+ */
+LwpCellLayout* LwpFootnote::GetCellLayout()
+{
+	LwpEnSuperTableLayout* pEnSuperLayout = FindFootnoteTableLayout();
+	if(pEnSuperLayout)
+	{
+		LwpTableLayout* pTableLayout = static_cast<LwpTableLayout*>(pEnSuperLayout->GetMainTableLayout());
+		if(pTableLayout)
+		{
+			LwpRowLayout* pRowLayout = pTableLayout->GetRowLayout(m_nRow);
+			if(pRowLayout)
+			{
+				return static_cast<LwpCellLayout*>(pRowLayout->GetChildHead()->obj());
+			}
+		}
+	}
+	return NULL;
+}
+/**
+ * @descr  Get endnote supertable layout which contains current endnote content, not used now
+ */
+LwpEnSuperTableLayout* LwpFootnote::GetEnSuperTableLayout()
+{
+	LwpDocument* pDivision = GetFootnoteTableDivision();
+	if(pDivision)
+		return static_cast<LwpEnSuperTableLayout*>(pDivision->GetEnSuperTableLayout());
+	return NULL;
+}
+
+/**
+ * @descr  Get division which footnote table contains current footnote content, copy from lwp source code
+ */
+LwpDocument* LwpFootnote::GetFootnoteTableDivision()
+{
+	if(!m_pFoundry)
+		return NULL;
+	
+	LwpDocument* pPrev =NULL;
+	LwpDocument* pDivision = NULL;
+	LwpDocument* pFootnoteDivision =NULL;	
+	
+	// Make sure the footnote does belong to some division
+	// The division might not have a DivisionInfo if it's being Destruct()ed
+	pPrev = m_pFoundry->GetDocument();
+	pFootnoteDivision = pPrev;
+	if (!pPrev || pPrev->GetDivInfoID()->IsNull())
+		return NULL;
+	
+	switch (m_nType)
+	{
+		case FN_FOOTNOTE:
+		{
+			// Footnotes always use the source division
+			return pFootnoteDivision;
+		}			
+		case FN_DIVISION:
+		{
+			// Start with the footnote's division
+			pDivision = pPrev;
+			break;
+		}
+		case FN_DIVISION_SEPARATE:
+		{
+			// It had better be the next division
+			pDivision = pPrev->GetNextDivision();
+			break;
+		}
+		case FN_DIVISIONGROUP:
+		case FN_DIVISIONGROUP_SEPARATE:
+		{
+			pDivision = pPrev->GetLastInGroupWithContents();
+			pPrev = pDivision;
+			break;
+		}
+		case FN_DOCUMENT:
+		case FN_DOCUMENT_SEPARATE:
+		{
+			pDivision = pFootnoteDivision->GetRootDocument();
+			if (pDivision)
+				pDivision = pDivision->GetLastDivisionWithContents();
+			pPrev = pDivision;
+			break;
+		}
+			
+	}
+
+	// Make sure we're using the proper endnote division, if it's separate
+	if (m_nType & FN_MASK_SEPARATE)
+		pDivision = GetEndnoteDivision(pDivision);
+	// Don't use a division that's specifically for endnotes
+	else
+	{
+		while (pDivision)
+		{
+			if (pDivision->GetEndnoteType() == FN_DONTCARE)
+				break;
+			if (m_nType == FN_DIVISIONGROUP)
+				pDivision = pDivision->GetPreviousInGroup();
+			else
+				pDivision = pDivision->GetPreviousDivisionWithContents();
+		}
+	}
+	if (pDivision)
+		return pDivision;	
+	return NULL;
+}
+
+/**
+ * @descr  Get division which endnote table contains current endnote content, copy from lwp source code
+ */
+LwpDocument* LwpFootnote::GetEndnoteDivision(LwpDocument* pPossible)
+{
+	LwpDocument*  pDivision = pPossible;
+	sal_uInt16 nDivType;
+
+	// In case we have multiple endnote divisions, walk backwards until
+	// we find one.	
+	while (pDivision)
+	{
+		// Do we already have the right division?
+		nDivType = pDivision->GetEndnoteType();
+		if (nDivType == m_nType)
+			return pDivision;
+		// When we hit the first non-endnote division, stop looking.
+		// -- SDC 10/8/96
+		if (nDivType == FN_DONTCARE)
+			break;
+		pDivision = pDivision->GetPreviousDivision();
+	}
+	return NULL;
+}
+
+/**
+ * @descr  Get footnote table class name
+ */
+OUString LwpFootnote::GetTableClass()
+{
+	OUString strClassName;
+	switch (GetType() & FN_MASK_BASE)
+	{
+		case FN_BASE_FOOTNOTE:
+		{
+			strClassName = A2OUSTR(STR_DivisionFootnote);
+			break;
+		}
+		case FN_BASE_DOCUMENT:
+		{
+			strClassName = A2OUSTR(STR_DocumentEndnote);
+			break;
+		}
+		case FN_BASE_DIVISION:
+		{
+			strClassName = A2OUSTR(STR_DivisionEndnote);
+			break;
+		}
+		case FN_BASE_DIVISIONGROUP:
+		{
+			strClassName = A2OUSTR(STR_DivisionGroupEndnote);
+			break;
+		}
+	}
+	return strClassName;
+}
+
+/**
+ * @descr  Find footnote tablelayout, copy from lwp source code
+ */
+LwpEnSuperTableLayout* LwpFootnote::FindFootnoteTableLayout()
+{
+	LwpDocument* pDivision = GetFootnoteTableDivision();
+	if(!pDivision)
+		return NULL;
+
+	LwpFoundry* pFoundry = pDivision->GetFoundry();
+	OUString strClassName = GetTableClass();
+	if(strClassName.getLength() ==0 )
+		return NULL;
+
+	LwpContent* pContent = NULL;
+	
+	while ((pContent = pFoundry->EnumContents(pContent)) != NULL)
+		if (pContent->IsTable() && (strClassName.equals(pContent->GetClassName())) &&
+			pContent->IsActive() && pContent->GetLayout(NULL))
+		{
+			// Found it!
+			return (LwpEnSuperTableLayout *)
+				((LwpTable*)pContent)->GetSuperTableLayout();
+		}
+	
+	return NULL;
+}
+
+/**
+ * @descr  Find footnote table, not used now
+ */
+LwpTable* LwpFootnote::FindFootnoteTable()
+{
+	LwpEnSuperTableLayout* pLayout = FindFootnoteTableLayout();
+	//if (!ShouldBeInTable(Footnote)) return NULL;
+	return GetFootnoteTable(pLayout);
+}
+
+/**
+ * @descr  Find footnote table, not used now
+ */
+LwpTable* LwpFootnote::GetFootnoteTable(LwpEnSuperTableLayout * pLayout)
+{
+	if(pLayout)
+	{
+		LwpEndnoteLayout* pEndnoteLayout = static_cast<LwpEndnoteLayout*>(pLayout->GetMainTableLayout());
+		if(pEndnoteLayout)
+			return static_cast<LwpTable*>(pEndnoteLayout->GetContent()->obj());
+	}
+	return NULL;
+}
+
+/**
+ * @descr  Find footnote contents
+ */
+LwpContent* LwpFootnote::FindFootnoteContent()
+{
+	LwpContent* pContent = static_cast<LwpContent*>(m_Content.obj());
+	//if the content has layout, the content has footnote contents;
+	//or looking for the celllayout and return the footnote contents.
+	if(pContent && pContent->GetLayout(NULL))
+		return pContent;
+
+	LwpCellLayout* pCellLayout = GetCellLayout();
+	if(pCellLayout)
+	{
+		pContent =static_cast<LwpContent*>(pCellLayout->GetContent()->obj());
+	}
+
+	return pContent;		
+}
+
+LwpFootnoteTable::LwpFootnoteTable(LwpObjectHeader &objHdr, LwpSvStream *pStrm)
+	: LwpTable(objHdr, pStrm)
+{
+}
+
+void LwpFootnoteTable::Read()
+{
+	LwpTable::Read();
+	m_pObjStrm->SkipExtra();
+}
+
+/**
+ * @descr  Read footnote number options information
+ */
+void LwpFootnoteNumberOptions::Read(LwpObjectStream *pObjStrm)
+{
+	pObjStrm->QuickRead(&m_nFlag, sizeof(m_nFlag));
+	pObjStrm->QuickRead(&m_nStartingNumber, sizeof(m_nStartingNumber));
+	m_LeadingText.Read(pObjStrm);
+	m_TrailingText.Read(pObjStrm);
+	pObjStrm->SkipExtra();
+}
+
+/**
+ * @descr  Read footnote seperator options information
+ */
+void LwpFootnoteSeparatorOptions::Read(LwpObjectStream *pObjStrm)
+{
+	pObjStrm->QuickRead(&m_nFlag, sizeof(m_nFlag));
+	pObjStrm->QuickRead(&m_nLength, sizeof(m_nLength));
+	pObjStrm->QuickRead(&m_nIndent, sizeof(m_nIndent));
+	pObjStrm->QuickRead(&m_nAbove, sizeof(m_nAbove));
+	pObjStrm->QuickRead(&m_nBelow, sizeof(m_nBelow));
+	m_BorderStuff.Read(pObjStrm);
+	pObjStrm->SkipExtra();
+
+}
+
+
+LwpFootnoteOptions::LwpFootnoteOptions(LwpObjectHeader &objHdr, LwpSvStream *pStrm)
+	: LwpObject(objHdr, pStrm)
+{
+}
+
+LwpFootnoteOptions::~LwpFootnoteOptions()
+{
+
+}
+
+/**
+ * @descr  Register footnote options object
+ */
+void LwpFootnoteOptions::Read()
+{
+	m_pObjStrm->QuickRead(&m_nFlag, sizeof(m_nFlag));
+	m_FootnoteNumbering.Read(m_pObjStrm);
+	m_EndnoteDivisionNumbering.Read(m_pObjStrm);
+	m_EndnoteDivisionGroupNumbering.Read(m_pObjStrm);
+	m_EndnoteDocNumbering.Read(m_pObjStrm);
+	m_FootnoteSeparator.Read(m_pObjStrm);
+	m_FootnoteContinuedSeparator.Read(m_pObjStrm);	
+	m_ContinuedOnMessage.Read(m_pObjStrm);
+	m_ContinuedFromMessage.Read(m_pObjStrm);
+	m_pObjStrm->SkipExtra();	
+}
+
+/**
+ * @descr  Register footnote options style
+ */
+void LwpFootnoteOptions::RegisterStyle()
+{
+	RegisterFootnoteStyle();
+	RegisterEndnoteStyle();
+}
+
+/**
+ * @descr  Register footnote configuration information
+ */
+void LwpFootnoteOptions::RegisterFootnoteStyle()
+{
+	XFFootnoteConfig* pFootnoteConfig = new XFFootnoteConfig();
+	pFootnoteConfig->SetStartValue(m_FootnoteNumbering.GetStartingNumber() -1);
+	pFootnoteConfig->SetNumPrefix(m_FootnoteNumbering.GetLeadingText());
+	pFootnoteConfig->SetNumSuffix(m_FootnoteNumbering.GetTrailingText());	
+	if(m_FootnoteNumbering.GetReset() == LwpFootnoteNumberOptions::RESET_PAGE)
+	{
+		pFootnoteConfig->SetRestartOnPage();
+	}
+	if(GetContinuedFrom())
+	{
+		pFootnoteConfig->SetMessageFrom(GetContinuedFromMessage());
+	}
+	if(GetContinuedOn())
+	{
+		pFootnoteConfig->SetMessageOn(GetContinuedOnMessage());
+	}
+
+	pFootnoteConfig->SetMasterPage( m_strMasterPage);
+	XFStyleManager* pXFStyleManager = LwpGlobalMgr::GetInstance()->GetXFStyleManager();
+	pXFStyleManager->SetFootnoteConfig(pFootnoteConfig);
+	
+}
+
+/**
+ * @descr  Register endnote configuration information
+ */
+void LwpFootnoteOptions::RegisterEndnoteStyle()
+{
+	XFEndnoteConfig* pEndnoteConfig = new XFEndnoteConfig();	
+	pEndnoteConfig->SetStartValue(m_EndnoteDocNumbering.GetStartingNumber() -1);
+	OUString message = m_EndnoteDocNumbering.GetLeadingText();
+	if(message.getLength() == 0)
+	{
+		message = A2OUSTR("[");//default prefix
+	}
+	pEndnoteConfig->SetNumPrefix(message);
+	message = m_EndnoteDocNumbering.GetTrailingText();
+	if(message.getLength() == 0)
+	{
+		message = A2OUSTR("]");//default suffix
+	}
+	pEndnoteConfig->SetNumSuffix(message);
+	if(m_EndnoteDocNumbering.GetReset() == LwpFootnoteNumberOptions::RESET_PAGE)
+	{
+		pEndnoteConfig->SetRestartOnPage();
+	}
+	
+	pEndnoteConfig->SetMasterPage( m_strMasterPage);
+	
+	XFStyleManager* pXFStyleManager = LwpGlobalMgr::GetInstance()->GetXFStyleManager();
+	pXFStyleManager->SetEndnoteConfig(pEndnoteConfig);
+}
+
+
+/**
+ * @descr  Get continue on message
+ */
+OUString LwpFootnoteOptions::GetContinuedOnMessage()
+{
+	if(m_ContinuedOnMessage.HasValue())
+	{
+		return m_ContinuedOnMessage.str();
+	}
+	// else reture defauls message
+	return A2OUSTR(STRID_FOOTCONTINUEDON);
+}
+
+/**
+ * @descr  Get continue from message
+ */
+OUString LwpFootnoteOptions::GetContinuedFromMessage()
+{
+	if(m_ContinuedFromMessage.HasValue())
+	{
+		return m_ContinuedFromMessage.str();
+	}
+	// else reture defauls message
+	return A2OUSTR(STRID_FOOTCONTINUEDFROM);
+}
diff -urNp lotuswordpro.bak/source/filter/lwpfootnote.hxx lotuswordpro/source/filter/lwpfootnote.hxx
--- lotuswordpro.bak/source/filter/lwpfootnote.hxx	1970-01-01 08:00:00.000000000 +0800
+++ lotuswordpro/source/filter/lwpfootnote.hxx	2008-10-22 11:42:29.000000000 +0800
@@ -0,0 +1,285 @@
+/*************************************************************************
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: IBM Corporation
+ *
+ *  Copyright: 2008 by IBM Corporation
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+/**
+ * @file 
+ *  footnote
+ */
+/*************************************************************************
+ * Change History
+ Mar 2005		 	Created
+ ************************************************************************/
+#ifndef _LWPFRIBFOOTNOTE_HXX_
+#define _LWPFRIBFOOTNOTE_HXX_
+
+#include "lwpfrib.hxx"
+#include "lwpobj.hxx"
+#include "lwpsection.hxx"
+#include "lwpborderstuff.hxx"
+
+// Footnote types are built up from these numbers
+#define FN_MASK_ENDNOTE			0x80
+#define FN_MASK_SEPARATE		0x40
+#define FN_MASK_DEACTIVATED		0x20
+#define FN_MASK_BASE			(0x0f | FN_MASK_ENDNOTE)
+#define FN_BASE_DONTCARE		0
+#define FN_BASE_FOOTNOTE		1
+#define FN_BASE_DIVISION		(2 | FN_MASK_ENDNOTE)
+#define FN_BASE_DIVISIONGROUP	(3 | FN_MASK_ENDNOTE)
+#define FN_BASE_DOCUMENT		(4 | FN_MASK_ENDNOTE)
+
+// Here are the real footnote types
+#define FN_DONTCARE					(FN_BASE_DONTCARE)
+#define FN_FOOTNOTE					(FN_BASE_FOOTNOTE)
+#define FN_DIVISION					(FN_BASE_DIVISION)
+#define FN_DIVISION_SEPARATE		(FN_BASE_DIVISION | FN_MASK_SEPARATE)
+#define FN_DIVISIONGROUP			(FN_BASE_DIVISIONGROUP)
+#define FN_DIVISIONGROUP_SEPARATE	(FN_BASE_DIVISIONGROUP | FN_MASK_SEPARATE)
+#define FN_DOCUMENT					(FN_BASE_DOCUMENT)
+#define FN_DOCUMENT_SEPARATE 		(FN_BASE_DOCUMENT | FN_MASK_SEPARATE)
+#define STRID_FOOTCONTINUEDFROM		"Continued from previous page..."
+#define STRID_FOOTCONTINUEDON		"Continued on next page..."
+//Footnote table types, the string may have to do with local language
+#define STR_DivisionFootnote			"DivisionFootnote"
+#define STR_DivisionEndnote			"DivisionEndnote"
+#define STR_DivisionGroupEndnote	"DivisionGroupEndnote"
+#define STR_DocumentEndnote		"DocumentEndnote"
+
+/**
+ * @brief	Footnote frib object
+*/
+class LwpFootnote;
+class LwpFribFootnote: public LwpFrib
+{
+
+public:
+	LwpFribFootnote(LwpPara* pPara );
+	~LwpFribFootnote(){};
+	void Read(LwpObjectStream* pObjStrm, sal_uInt16 len);
+	void RegisterStyle();
+	void XFConvert(XFContentContainer* pCont);
+	LwpFootnote* GetFootnote();
+	
+private:	
+	LwpObjectID m_Footnote;		
+};
+
+/**
+ * @brief	VO_FOOTNOTE object
+*/
+class LwpSuperTableLayout;
+class LwpEnSuperTableLayout;
+class LwpFnSuperTableLayout;
+class LwpCellLayout;
+class LwpDocument;
+class LwpTable;
+class LwpFootnote : public LwpOrderedObject
+{
+public:
+	LwpFootnote(LwpObjectHeader &objHdr, LwpSvStream* pStrm);	
+	~LwpFootnote();
+	void RegisterStyle();	
+	void XFConvert(XFContentContainer * pCont);	
+protected:
+	void Read();		
+private:
+	sal_uInt16 m_nType;
+	sal_uInt16 m_nRow;
+	LwpObjectID m_Content;
+public:
+	sal_uInt16 GetType(){ return m_nType;}	
+private:
+	LwpCellLayout* GetCellLayout();	
+	LwpEnSuperTableLayout* GetEnSuperTableLayout();
+	LwpDocument* GetFootnoteTableDivision();
+	LwpDocument* GetEndnoteDivision(LwpDocument* pPossible);	
+	LwpEnSuperTableLayout* FindFootnoteTableLayout();
+	LwpTable* FindFootnoteTable();
+	LwpTable* GetFootnoteTable(LwpEnSuperTableLayout* pLayout);
+	LwpContent* FindFootnoteContent();
+	OUString GetTableClass();
+};
+
+/**
+ * @brief VO_FOOTNOTETABLE object
+*/
+#include "lwptable.hxx"
+class LwpFootnoteTable : public LwpTable
+{
+public:
+	LwpFootnoteTable(LwpObjectHeader &objHdr, LwpSvStream* pStrm);	
+	~LwpFootnoteTable(){};	
+protected:
+	void Read();	
+};
+
+/**
+ * @brief footnote number options information
+*/
+class LwpFootnoteNumberOptions
+{
+public:
+	LwpFootnoteNumberOptions(){};
+	~LwpFootnoteNumberOptions(){};
+	void Read(LwpObjectStream* pObjStrm);
+private:
+	sal_uInt16 m_nFlag;
+	sal_uInt16 m_nStartingNumber;
+	LwpAtomHolder m_LeadingText;
+	LwpAtomHolder m_TrailingText;
+public:
+	enum // for flag
+	{
+		RESET_DOCUMENT	= 0x00,		// i.e., never reset the numbering
+		RESET_PAGE	= 0x01,
+		RESET_DIVISION	= 0x02,
+		RESET_DIVISIONGROUP	= 0x04,
+		RESET_MASK = (RESET_PAGE | RESET_DIVISION | RESET_DIVISIONGROUP |
+			RESET_DOCUMENT),
+		SUPERSCRIPT_REFERENCE 	= 0x10
+	}; 	
+public:
+	sal_uInt16 GetStartingNumber(){ return m_nStartingNumber;}
+	OUString GetLeadingText(){ return m_LeadingText.str();}
+	OUString GetTrailingText(){ return m_TrailingText.str();}
+	sal_uInt16 GetReset(){ return static_cast<sal_uInt16>(m_nFlag & RESET_MASK);}
+};
+
+/**
+ * @brief footnote separator options information
+*/
+class LwpFootnoteSeparatorOptions
+{
+public:
+	LwpFootnoteSeparatorOptions(){};
+	~LwpFootnoteSeparatorOptions(){};
+	void Read(LwpObjectStream* pObjStrm);
+private:
+	sal_uInt16 m_nFlag;
+	sal_uInt32 m_nLength;
+	sal_uInt32 m_nIndent;
+	sal_uInt32 m_nAbove;
+	sal_uInt32 m_nBelow;
+	LwpBorderStuff m_BorderStuff;
+public:
+	enum // for flag
+	{
+		HAS_SEPARATOR	= 0x01,
+		CUSTOM_LENGTH	= 0x02
+	}; 
+public:
+	sal_uInt32 GetFlag(){ return m_nFlag;}
+	sal_uInt32 GetLength(){ return m_nLength;}
+	sal_uInt32 GetIndent(){ return m_nIndent;}
+	sal_uInt32 GetAbove(){ return m_nAbove;}
+	sal_uInt32 GetBelow(){ return m_nBelow;}
+	LwpBorderStuff* GetBorderStuff(){ return &m_BorderStuff;}
+	sal_Bool HasCustomLength(){ return (m_nFlag & CUSTOM_LENGTH) != 0;}
+	sal_Bool HasSeparator(){ return (m_nFlag & HAS_SEPARATOR) != 0;}
+	float GetTopBorderWidth(){ return m_BorderStuff.GetSideWidth(LwpBorderStuff::TOP);}
+	LwpColor GetTopBorderColor(){ return m_BorderStuff.GetSideColor(LwpBorderStuff::TOP);}
+};
+
+/**
+ * @brief	VO_FOOTNOTEOPTS object
+*/
+class LwpFootnoteOptions : public LwpObject
+{
+public:
+	LwpFootnoteOptions(LwpObjectHeader &objHdr, LwpSvStream* pStrm);	
+	~LwpFootnoteOptions();
+	void RegisterStyle();		
+protected:
+	void Read();
+	void RegisterFootnoteStyle();
+	void RegisterEndnoteStyle();
+private:
+	sal_uInt16 m_nFlag;
+	LwpFootnoteNumberOptions m_FootnoteNumbering;
+	LwpFootnoteNumberOptions m_EndnoteDivisionNumbering;
+	LwpFootnoteNumberOptions m_EndnoteDivisionGroupNumbering;
+	LwpFootnoteNumberOptions m_EndnoteDocNumbering;
+	LwpFootnoteSeparatorOptions m_FootnoteSeparator;
+	LwpFootnoteSeparatorOptions m_FootnoteContinuedSeparator;	
+	LwpAtomHolder m_ContinuedOnMessage;
+	LwpAtomHolder m_ContinuedFromMessage;
+	OUString m_strMasterPage;
+	enum
+	{
+		FO_REPEAT 			= 0x0001,
+		FO_CONTINUEFROM 	= 0x0002,
+		FO_CONTINUEON 		= 0x0004,
+		FO_ON_CENTER		= 0x0008,
+		FO_ON_RIGHT			= 0x0010,
+		FO_ON_ALIGNMASK		= FO_ON_CENTER | FO_ON_RIGHT,
+		FO_FROM_CENTER		= 0x0020,
+		FO_FROM_RIGHT		= 0x0040,
+		FO_FROM_ALIGNMASK	= FO_FROM_CENTER | FO_FROM_RIGHT
+	};
+
+public:
+	LwpFootnoteNumberOptions* GetFootnoteNumbering(){ return &m_FootnoteNumbering;}
+	LwpFootnoteNumberOptions* GetEndnoteDivisionNumbering(){ return &m_EndnoteDivisionNumbering;}
+	LwpFootnoteNumberOptions* GetEndnoteDivisionGroupNumbering(){ return &m_EndnoteDivisionGroupNumbering;}
+	LwpFootnoteNumberOptions* GetEndnoteDocNumbering(){ return &m_EndnoteDocNumbering;}
+	LwpFootnoteSeparatorOptions* GetFootnoteSeparator(){ return &m_FootnoteSeparator;}
+	LwpFootnoteSeparatorOptions* GetFootnoteContinuedSeparator(){ return &m_FootnoteContinuedSeparator;}	
+	sal_Bool GetContinuedFrom(){ return ((m_nFlag & FO_CONTINUEFROM) != 0);}
+	sal_Bool GetContinuedOn(){ return ((m_nFlag & FO_CONTINUEON) != 0);}
+	OUString GetContinuedOnMessage();	
+	OUString GetContinuedFromMessage();
+	void SetMasterPage(OUString strMasterPage){ m_strMasterPage = strMasterPage;}
+};
+
+#endif
diff -urNp lotuswordpro.bak/source/filter/lwpfoundry.cxx lotuswordpro/source/filter/lwpfoundry.cxx
--- lotuswordpro.bak/source/filter/lwpfoundry.cxx	1970-01-01 08:00:00.000000000 +0800
+++ lotuswordpro/source/filter/lwpfoundry.cxx	2008-10-22 11:42:29.000000000 +0800
@@ -0,0 +1,580 @@
+/*************************************************************************
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: IBM Corporation
+ *
+ *  Copyright: 2008 by IBM Corporation
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+/*************************************************************************
+ * @file 
+ *  For LWP filter architecture prototype
+ ************************************************************************/
+/*************************************************************************
+ * Change History
+ Jan 2005			Created
+ ************************************************************************/
+
+#include "lwpfoundry.hxx"
+#include "lwpfilehdr.hxx"
+#include "lwpdoc.hxx"
+#include "lwpmarker.hxx"
+#include "lwpholder.hxx"
+#include "lwpbulletstylemgr.hxx"
+#include "lwpcontent.hxx"
+#include "lwpvpointer.hxx"
+#include "lwpsection.hxx"
+#include "lwpcharacterstyle.hxx"
+#include "lwpglobalmgr.hxx"
+
+LwpFoundry::LwpFoundry(LwpObjectStream *pStrm, LwpDocument* pDoc)
+	: m_pDoc(pDoc), m_pPieceMgr(NULL), m_pStyleMgr(NULL)
+{
+	Read(pStrm);
+	m_pDropcapMgr = new LwpDropcapMgr;
+	m_pBulletStyleMgr = new LwpBulletStyleMgr();
+	m_pBulletStyleMgr->SetFoundry(this);
+}
+
+LwpFoundry::~LwpFoundry()
+{
+	if(m_pPieceMgr)
+	{
+		delete m_pPieceMgr;
+	}
+	if(m_pStyleMgr)
+	{
+		delete m_pStyleMgr;
+	}
+	if (m_pDropcapMgr)
+		delete m_pDropcapMgr;
+	if (m_pBulletStyleMgr)
+	{
+		delete m_pBulletStyleMgr;
+	}
+}
+
+void LwpFoundry::Read(LwpObjectStream *pStrm) 
+{
+	if (!m_pDoc->IsChildDoc())
+	{
+		m_VerMgr.Read(pStrm);
+	}
+	m_ObjMgr.Read(pStrm);
+
+	m_MarkerHead.ReadIndexed(pStrm);
+	m_FootnoteMgr.ReadIndexed(pStrm);
+	
+	m_NumMgr.Read(pStrm);
+	m_BulMgr.Read(pStrm);
+
+	m_SectionList.Read(pStrm);
+	m_Layout.ReadIndexed(pStrm);
+	
+	ReadStyles(pStrm);
+
+	m_BookMarkHead.ReadIndexed(pStrm);
+	m_DdeLinkHead.ReadIndexed(pStrm);
+	m_DirtBagHead.ReadIndexed(pStrm);		
+	m_NamedOutlineSeqHead.ReadIndexed(pStrm);		
+
+	m_EnumLayoutHead.ReadIndexed(pStrm);		
+	m_EnumLayoutTail.ReadIndexed(pStrm);
+	m_NamedObjects.ReadIndexed(pStrm);	
+
+	pStrm->QuickRead(&m_nLastClickHere, sizeof(m_nLastClickHere));
+	m_SmartTextMgr.ReadIndexed(pStrm);
+
+	m_ContentMgr.Read(pStrm);
+	m_FontMgr.Read(pStrm);
+
+	if (!m_pDoc->IsChildDoc() && LwpFileHeader::m_nFileRevision >= 0x000B)
+	{
+		m_pPieceMgr = new LwpPieceManager();
+
+		m_pPieceMgr->Read(pStrm);
+	}
+
+	if( LwpFileHeader::m_nFileRevision >= 0x000B)
+	{
+		m_DftDropCapStyle.ReadIndexed(pStrm);
+	}
+	if( LwpFileHeader::m_nFileRevision >= 0x000F)	
+	{
+		m_DftHeaderStyle.ReadIndexed(pStrm);
+		m_DftFooterStyle.ReadIndexed(pStrm);		
+	}
+	pStrm->SkipExtra();
+
+	m_pStyleMgr = new LwpStyleManager();
+	m_pStyleMgr->SetFoundry(this);
+}
+
+
+void LwpFoundry::ReadStyles(LwpObjectStream *pStrm)
+{
+	m_TextStyle.ReadIndexed(pStrm);
+	m_DefaultTextStyle.ReadIndexed(pStrm);
+	m_DefaultClickStyle.ReadIndexed(pStrm);
+	m_PageStyle.ReadIndexed(pStrm);
+	m_FrameStyle.ReadIndexed(pStrm);
+
+	m_TableStyle.ReadIndexed(pStrm);
+	m_CellStyle.ReadIndexed(pStrm);
+	m_DftFrameStyle.ReadIndexed(pStrm);
+	m_DftPageStyle.ReadIndexed(pStrm);
+	m_DftTableStyle.ReadIndexed(pStrm);
+
+	m_DftCellStyle.ReadIndexed(pStrm);
+	m_DftColumnStyle.ReadIndexed(pStrm);
+	m_DftLeftColumnStyle.ReadIndexed(pStrm);
+	m_DftRighColumnStyle.ReadIndexed(pStrm);
+
+}
+
+#include "xfilter/xfstylemanager.hxx"
+#include "lwplayout.hxx"
+
+void LwpFoundry::RegisterAllLayouts()
+{
+	//Register CellStyle
+	LwpObject* pStyle = m_CellStyle.obj();
+	if( pStyle )
+	{
+		pStyle->SetFoundry(this);
+		pStyle->RegisterStyle();
+	}
+	
+	//register content page layout list: Layout
+	 pStyle = m_Layout.obj();
+	if( pStyle )
+	{
+		pStyle->SetFoundry(this);
+		pStyle->RegisterStyle();
+	}
+
+	//Register page style layout list: PageStyle, such as "Default Page"
+	pStyle = m_PageStyle.obj();
+	if( pStyle )
+	{
+		pStyle->SetFoundry(this);
+		pStyle->RegisterStyle();
+	}
+
+	//Register FrameStyle
+	pStyle = m_FrameStyle.obj();
+	if( pStyle )
+	{
+		pStyle->SetFoundry(this);
+		pStyle->RegisterStyle();
+	}
+
+}
+
+LwpBookMark* LwpFoundry::GetBookMark(LwpObjectID objMarker)
+{
+	LwpDLVListHeadHolder* pHeadHolder= static_cast
+					<LwpDLVListHeadHolder*>(m_BookMarkHead.obj());
+	LwpObjectID* pObjID = pHeadHolder->GetHeadID();
+	LwpBookMark* pBookMark;
+	if (pObjID)
+		pBookMark = static_cast<LwpBookMark*>(pObjID->obj());
+	else
+		return NULL;
+		
+	while (pBookMark)
+	{
+		if (pBookMark->IsRightMarker(objMarker))
+			return pBookMark;
+		pObjID = pBookMark->GetNext();
+		if (pObjID)
+			pBookMark = static_cast<LwpBookMark*>(pObjID->obj());
+		else
+			return NULL;		
+	}
+	return NULL;
+}
+
+sal_Bool LwpFoundry::FindBookMarkByName(OUString sName)
+{
+	LwpDLVListHeadHolder* pHeadHolder= static_cast
+					<LwpDLVListHeadHolder*>(m_BookMarkHead.obj());
+	LwpObjectID* pObjID = pHeadHolder->GetHeadID();
+	LwpBookMark* pBookMark;
+	if (pObjID)
+		pBookMark = static_cast<LwpBookMark*>(pObjID->obj());
+	else
+		return NULL;
+		
+	while (pBookMark)
+	{
+		if (pBookMark->IsRightName(sName))
+			return sal_True;
+		pObjID = pBookMark->GetNext();
+		if (pObjID)
+			pBookMark = static_cast<LwpBookMark*>(pObjID->obj());
+		else
+			return sal_False;		
+	}
+	return sal_False;	
+}
+
+/**
+* @descr: 	Get next content
+* 
+*/
+LwpContent* LwpFoundry::EnumContents(LwpContent * pContent)
+{
+	return GetContentManager()->EnumContents(pContent);
+}
+
+/**
+* @descr: 	Get next section
+* 
+*/
+LwpSection* LwpFoundry::EnumSections(LwpSection * pSection)
+{
+	return static_cast<LwpSection*>(m_SectionList.Enumerate(pSection));	
+}
+
+/**
+* @descr: 	Get default text style id
+* 
+*/
+LwpObjectID * LwpFoundry::GetDefaultTextStyle() 
+{
+	LwpVersionedPointer * pPointer = static_cast<LwpVersionedPointer *>(m_DefaultTextStyle.obj());
+	if (!pPointer)
+		return NULL;
+
+	return pPointer->GetPointer();
+}
+
+/**
+* @descr: 	Get paragraph style object id according to its style name
+* 
+*/
+LwpObjectID * LwpFoundry::FindParaStyleByName(OUString name)
+{
+	//Register all text styles: para styles, character styles
+	LwpDLVListHeadHolder* pParaStyleHolder = static_cast<LwpDLVListHeadHolder*>(GetTextStyleHead()->obj());
+	if(pParaStyleHolder) 
+	{
+		LwpTextStyle* pParaStyle = static_cast<LwpTextStyle*> (pParaStyleHolder->GetHeadID()->obj());
+		while(pParaStyle)
+		{
+			OUString strName = pParaStyle->GetName()->str();
+			if(strName == name)
+				return pParaStyle->GetObjectID();
+			pParaStyle = static_cast<LwpTextStyle*>(pParaStyle->GetNext()->obj());
+		}
+	}
+
+	return NULL;
+}
+
+/**
+* @descr: 	Get style name registed according the original style name
+* 
+*/
+OUString LwpFoundry::FindActuralStyleName(OUString name)
+{
+	LwpObjectID* pID = FindParaStyleByName(name);
+	if(pID)
+	{
+		IXFStyle* pStyle = GetStyleManager()->GetStyle(*pID);
+		if(pStyle)
+		{
+			return pStyle->GetStyleName();
+		}
+	}
+
+	return name;
+}
+
+void LwpVersionManager::Read(LwpObjectStream *pStrm) 
+{
+	// TODO: skip the data for prototype
+	Skip(pStrm);
+}
+
+void LwpVersionManager::Skip(LwpObjectStream *pStrm) 
+{
+
+	sal_uInt32 cNextUserVersionID;
+	pStrm->QuickRead(&cNextUserVersionID, sizeof(cNextUserVersionID));
+
+	sal_uInt16 Count;
+	pStrm->QuickRead(&Count, sizeof(Count));
+
+	sal_uInt32 tag;
+	while(Count--)
+	{
+		pStrm->QuickRead(&tag, sizeof(tag));
+		USHORT len;
+		switch(tag)
+		{
+			case TAG_USER_VERSION:
+				// TODO: skip the CUserVersionControl
+				pStrm->QuickRead(&len, sizeof(len));
+				pStrm->SeekRel(len);				
+				//pStrm->SkipExtra(); //The length has included the extra
+				break;
+
+			default:
+				pStrm->QuickRead(&len, sizeof(USHORT));
+				pStrm->SeekRel(len);				
+				pStrm->SkipExtra();
+				break;
+		}
+	}
+	pStrm->SkipExtra();
+}
+
+void LwpObjectManager::Read(LwpObjectStream *pStrm) 
+{
+
+	LwpObjectID dummy;
+	dummy.Read(pStrm);
+	// TODO: judge if we need to set the cDelta by the dummy id
+	
+	m_Division.ReadIndexed(pStrm);
+	pStrm->SkipExtra();
+}
+
+void LwpNumberManager::Read(LwpObjectStream *pStrm) 
+{
+	m_TableRange.ReadIndexed(pStrm);
+	pStrm->SkipExtra();
+}
+
+void LwpBulletManager::Read(LwpObjectStream *pStrm) 
+{
+	m_Head.ReadIndexed(pStrm);
+	pStrm->SkipExtra();
+}
+
+void LwpContentManager::Read(LwpObjectStream *pStrm) 
+{
+	m_ContentList.ReadIndexed(pStrm);
+
+	// TODO:  to judge the file revision
+	
+	m_EnumHead.ReadIndexed(pStrm);
+	m_EnumTail.ReadIndexed(pStrm);
+
+	m_OleObjCount.ReadIndexed(pStrm);		
+
+	if( LwpFileHeader::m_nFileRevision >= 0x000B)
+	{
+		m_GrapHead.ReadIndexed(pStrm);		
+		m_GrapTail.ReadIndexed(pStrm);	
+		m_OleHead.ReadIndexed(pStrm);		
+		m_OleTail.ReadIndexed(pStrm);	
+	}
+	
+	pStrm->SkipExtra();
+}
+
+/**
+* @descr: 	Get next content
+* 
+*/
+LwpContent* LwpContentManager::EnumContents(LwpContent* pContent)
+{
+	if(pContent)
+		return pContent->GetNextEnumerated();
+	LwpVersionedPointer* pPointer = static_cast<LwpVersionedPointer*>(m_EnumHead.obj());
+	return pPointer ? static_cast<LwpContent*>(pPointer->GetPointer()->obj()) : NULL;
+}
+
+void LwpPieceManager::Read(LwpObjectStream *pStrm) 
+{
+	m_GeometryPieceList.ReadIndexed(pStrm);
+	m_ScalePieceList.ReadIndexed(pStrm);
+	m_MarginsPieceList.ReadIndexed(pStrm);
+	m_ColumnsPieceList.ReadIndexed(pStrm);
+	m_BorderStuffPieceList.ReadIndexed(pStrm);
+
+	m_GutterStuffPieceList.ReadIndexed(pStrm);
+	m_BackgroundStuffPieceList.ReadIndexed(pStrm);
+	m_JoinStuffPieceList.ReadIndexed(pStrm);
+	m_ShadowPieceList.ReadIndexed(pStrm);
+	m_NumericsPieceList.ReadIndexed(pStrm);
+
+	m_RelativityPieceList.ReadIndexed(pStrm);
+	m_AlignmentPieceList.ReadIndexed(pStrm);
+	m_IndentPieceList.ReadIndexed(pStrm);
+	m_ParaBorderPieceList.ReadIndexed(pStrm);
+	m_SpacingPieceList.ReadIndexed(pStrm);
+
+	m_BreaksPieceList.ReadIndexed(pStrm);
+	m_NumberingPieceList.ReadIndexed(pStrm);
+	m_TabPieceList.ReadIndexed(pStrm);
+	m_CharacterBorderPieceList.ReadIndexed(pStrm);
+	m_AmikakePieceList.ReadIndexed(pStrm);
+
+	if(pStrm->CheckExtra())
+	{
+		m_ParaBackgroundPieceList.ReadIndexed(pStrm);
+		m_ExternalBorderStuffPieceList.ReadIndexed(pStrm);
+		m_ExternalJoinStuffPieceList.ReadIndexed(pStrm);
+		pStrm->SkipExtra();
+	}
+}
+
+void LwpOrderedObjectManager::Read(LwpObjectStream *pStrm) 
+{
+	m_Head.ReadIndexed(pStrm);
+}
+
+/**
+* @descr: 	Get next orderedobject, copy from lwp source code
+* 
+*/
+LwpOrderedObject* LwpOrderedObjectManager::Enumerate(LwpOrderedObject * pLast)
+{
+	// If Last has a next, return it.
+	if(pLast && !pLast->GetNext()->IsNull())
+		return static_cast<LwpOrderedObject*>(pLast->GetNext()->obj());
+
+	LwpListList* pList = NULL;
+	if(pLast)
+	{
+		// We're at the end of Last's list (not Liszt's list).
+		// Start with the next active list
+		pList = static_cast<LwpListList*>(pLast->GetListList()->obj());
+		pList= GetNextActiveListList(pList);
+	}
+	else
+	{
+		// Start with the first active ListList
+		pList = GetNextActiveListList(NULL);
+	}
+
+	if(pList)
+	{
+		return static_cast<LwpOrderedObject*>(pList->GetHead()->obj());
+	}
+	
+	return NULL;
+}
+
+/**
+* @descr: 	Get next listlist object, copy from lwp source code
+* 
+*/
+LwpListList* LwpOrderedObjectManager::GetNextActiveListList(LwpListList * pLast)
+{
+	LwpListList* pList = NULL;
+	LwpContent* pContent = NULL;
+	if(pLast)
+		pList = static_cast<LwpListList*>(pLast->GetNext()->obj());
+	else
+	{
+		LwpDLVListHeadHolder* pHeadHolder= static_cast<LwpDLVListHeadHolder*>(m_Head.obj());
+		if(pHeadHolder)
+		{
+			pList = static_cast<LwpListList*>(pHeadHolder->GetHeadID()->obj());			
+		}
+	}
+
+	while(pList)
+	{
+		pContent = static_cast<LwpContent*>(pList->GetObject()->obj());
+		if(pContent && pContent->HasNonEmbeddedLayouts() &&
+			!pContent->IsStyleContent())
+			return pList;
+		pList = static_cast<LwpListList*>(pList->GetNext()->obj());
+	}
+	return NULL;
+}
+
+LwpStyleManager::LwpStyleManager()
+{}
+
+LwpStyleManager::~LwpStyleManager()
+{
+	m_StyleList.clear();
+}
+
+
+#include "xfilter/xfstylemanager.hxx"
+/*
+VO_PARASTYLE/VO_CHARACTERSTYLE call this method to add its created style to XFStyleManager
+1. Add the style to XFStyleManager, and return the <office:styles> style name
+2. Add it to LwpParaStyleMap.
+Prerequisite: pStyle has been created and all properties has been set to it.
+Return the XFStyle* added by XFStyleManager
+*/
+IXFStyle* LwpStyleManager::AddStyle(LwpObjectID styleObjID, IXFStyle* pStyle)
+{
+	assert(pStyle);
+	//pStyle may change if same style is found in XFStyleManager
+	XFStyleManager* pXFStyleManager = LwpGlobalMgr::GetInstance()->GetXFStyleManager();
+	pStyle = pXFStyleManager->AddStyle(pStyle);
+	m_StyleList.insert(LwpStyleMap::value_type(styleObjID, pStyle));
+	return pStyle;
+}
+
+/*
+Called by VO_PARA  or other objects to get style name based on the Style object ID
+1) Get style from LwpParaStyleMap based on the LwpObjectID of VO_PARASTYLE.
+Prerequisite: VO_PARASTYLE/VO_CHARACTERSTYLE should call AddStyle first.
+Return empty string if no style found.
+*/
+IXFStyle* LwpStyleManager::GetStyle(const LwpObjectID &styleObjID)
+{
+	LwpStyleMap::const_iterator it =  m_StyleList.find(styleObjID);
+	if (it != m_StyleList.end()) { 
+		return((*it).second);
+	}
+	return NULL;
+}
+
diff -urNp lotuswordpro.bak/source/filter/lwpfoundry.hxx lotuswordpro/source/filter/lwpfoundry.hxx
--- lotuswordpro.bak/source/filter/lwpfoundry.hxx	1970-01-01 08:00:00.000000000 +0800
+++ lotuswordpro/source/filter/lwpfoundry.hxx	2008-10-22 11:42:29.000000000 +0800
@@ -0,0 +1,326 @@
+/*************************************************************************
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: IBM Corporation
+ *
+ *  Copyright: 2008 by IBM Corporation
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+/*************************************************************************
+ * @file 
+ *  For LWP filter architecture prototype
+ ************************************************************************/
+/*************************************************************************
+ * Change History
+ Jan 2005			Created
+ ************************************************************************/
+
+#ifndef _LWPFOUNDRY_HXX
+#define _LWPFOUNDRY_HXX
+
+#include "lwpheader.hxx"
+
+#ifndef _LWPOBJECTID_HXX
+#include "lwpobjid.hxx"
+#endif
+
+#ifndef _LWPOBJECTSTREAM_HXX
+#include "lwpobjstrm.hxx"
+#endif
+
+#include "lwpcolor.hxx"
+#include "lwpbasetype.hxx"
+#include "lwpfont.hxx"
+#include "lwpdropcapmgr.hxx"
+class LwpDocument;
+class LwpBookMark;
+
+#include <vector>
+#define TAG_USER_VERSION	0x72655655UL		// "UVer"
+
+
+class LwpVersionManager
+{
+public:
+	LwpVersionManager(){};
+	~LwpVersionManager(){};
+public:
+	void Read(LwpObjectStream *pStrm);
+	void Skip(LwpObjectStream *pStrm);
+};
+
+class LwpObjectManager
+{
+public:
+	LwpObjectManager(){};
+	~LwpObjectManager(){};
+private:
+	LwpObjectID m_Division;
+public:
+	void Read(LwpObjectStream *pStrm);
+};
+
+class LwpNumberManager
+{
+public:
+	LwpNumberManager(){};
+	~LwpNumberManager(){};
+private:
+	LwpObjectID m_TableRange;
+public:
+	void Read(LwpObjectStream *pStrm);
+	LwpObjectID GetTableRangeID(){ return m_TableRange;}
+};
+
+class LwpBulletManager
+{
+public:
+	LwpBulletManager(){};
+	~LwpBulletManager(){};
+private:
+	LwpObjectID m_Head;
+public:
+	void Read(LwpObjectStream *pStrm);
+	LwpObjectID* GetHeadID() { return &m_Head;}
+};
+
+class LwpContent;
+class LwpContentManager
+{
+public:
+	LwpContentManager(){};
+	~LwpContentManager(){};
+private:
+	LwpObjectID m_ContentList;
+	LwpObjectID m_EnumHead;
+	LwpObjectID m_EnumTail;
+	LwpObjectID m_OleObjCount;
+	sal_uInt32 m_oldOleObjCount;
+
+	LwpObjectID m_GrapHead;
+	LwpObjectID m_GrapTail;
+	LwpObjectID m_OleHead;
+	LwpObjectID m_OleTail;	
+public:
+	inline LwpObjectID* GetContentList() { return &m_ContentList; }
+	inline LwpObjectID* GetGraphicListHead() { return &m_GrapHead; }
+	LwpContent* EnumContents(LwpContent* pContent);
+	
+public:
+	void Read(LwpObjectStream *pStrm);
+};
+
+class LwpPieceManager
+{
+public:
+	LwpPieceManager(){};
+	~LwpPieceManager(){};
+private:
+	LwpObjectID m_GeometryPieceList;
+	LwpObjectID m_ScalePieceList;
+	LwpObjectID m_MarginsPieceList;
+	LwpObjectID m_ColumnsPieceList;
+	LwpObjectID m_BorderStuffPieceList;
+	LwpObjectID m_GutterStuffPieceList;
+	LwpObjectID m_BackgroundStuffPieceList;
+	LwpObjectID m_JoinStuffPieceList;		
+	LwpObjectID m_ShadowPieceList;
+	LwpObjectID m_NumericsPieceList;
+	LwpObjectID m_RelativityPieceList;
+	LwpObjectID m_AlignmentPieceList;
+	LwpObjectID m_IndentPieceList;
+	LwpObjectID m_ParaBorderPieceList;
+	LwpObjectID m_SpacingPieceList;
+	LwpObjectID m_BreaksPieceList;		
+	LwpObjectID m_NumberingPieceList;
+	LwpObjectID m_TabPieceList;
+	LwpObjectID m_CharacterBorderPieceList;
+	LwpObjectID m_AmikakePieceList;
+
+	LwpObjectID m_ParaBackgroundPieceList;
+	LwpObjectID m_ExternalBorderStuffPieceList;
+	LwpObjectID m_ExternalJoinStuffPieceList;
+
+public:
+	void Read(LwpObjectStream *pStrm);
+};
+
+class LwpOrderedObject;
+class LwpListList;
+class LwpOrderedObjectManager
+{
+public:
+	LwpOrderedObjectManager(){};
+	~LwpOrderedObjectManager(){};
+protected:
+	LwpObjectID m_Head;
+public:
+	void Read(LwpObjectStream *pStrm);
+	LwpObjectID* GetHeadID() { return &m_Head;};
+	LwpOrderedObject* Enumerate(LwpOrderedObject* pLast);
+protected:
+	LwpListList* GetNextActiveListList(LwpListList* pLast);
+};
+
+class LwpStyleManager;
+class LwpSection;
+class LwpBulletStyleMgr;
+class LwpFoundry
+{
+public:
+	LwpFoundry( LwpObjectStream *pStrm, LwpDocument* pDoc );
+	~LwpFoundry();
+	void Read(LwpObjectStream *pStrm);
+	void RegisterAllLayouts();
+private:
+	LwpDocument* m_pDoc;
+private: //file members
+	LwpVersionManager m_VerMgr;
+	LwpObjectManager m_ObjMgr;
+	LwpObjectID m_MarkerHead;
+	LwpObjectID m_FootnoteMgr;
+	LwpNumberManager m_NumMgr;
+	LwpBulletManager m_BulMgr;
+	LwpOrderedObjectManager m_SectionList;
+
+	LwpObjectID m_Layout;	//The head layout
+	LwpObjectID m_TextStyle;
+	LwpObjectID m_DefaultTextStyle;
+	LwpObjectID m_DefaultClickStyle;
+	LwpObjectID m_PageStyle;
+	LwpObjectID m_FrameStyle;
+	LwpObjectID m_TableStyle;
+	LwpObjectID m_CellStyle;	
+	LwpObjectID m_DftFrameStyle;	
+	LwpObjectID m_DftPageStyle;	
+	LwpObjectID m_DftTableStyle;	
+	LwpObjectID m_DftCellStyle;	
+	LwpObjectID m_DftColumnStyle;		
+	LwpObjectID m_DftLeftColumnStyle;		
+	LwpObjectID m_DftRighColumnStyle;	
+	
+	LwpObjectID m_BookMarkHead;
+	LwpObjectID m_DdeLinkHead;
+	LwpObjectID m_DirtBagHead;
+	LwpObjectID m_NamedOutlineSeqHead;
+	LwpObjectID m_EnumLayoutHead;
+	LwpObjectID m_EnumLayoutTail;
+		
+	LwpObjectID m_NamedObjects;
+	sal_uInt32 m_nLastClickHere;
+
+	LwpObjectID m_SmartTextMgr;	
+
+	LwpContentManager m_ContentMgr;
+	LwpFontManager m_FontMgr;
+	LwpPieceManager* m_pPieceMgr;
+
+	LwpObjectID m_DftDropCapStyle;
+	LwpObjectID m_DftHeaderStyle;
+		
+	LwpObjectID m_DftFooterStyle;
+private:
+	void ReadStyles(LwpObjectStream *pStrm);
+public:
+	inline LwpContentManager* GetContentManager() { return &m_ContentMgr; }
+	inline LwpObjectID* GetGraphicListHead() { return m_ContentMgr.GetGraphicListHead(); }
+	inline LwpFontManager* GetFontManger() { return &m_FontMgr;}
+	inline LwpObjectID* GetTextStyleHead()  { return &m_TextStyle;} 
+	inline LwpObjectID* GetLayout() {return &m_Layout;}
+	inline LwpObjectID* GetBulletManagerID() { return m_BulMgr.GetHeadID();}
+	inline LwpDocument* GetDocument(){ return m_pDoc;}
+	inline LwpNumberManager* GetNumberManager() { return &m_NumMgr;}
+	LwpObjectID * GetDefaultTextStyle() ;
+private:
+	LwpStyleManager* m_pStyleMgr;
+	LwpDropcapMgr* m_pDropcapMgr;
+	LwpBulletStyleMgr* m_pBulletStyleMgr;
+public:
+	inline LwpStyleManager* GetStyleManager() { return m_pStyleMgr;}
+	LwpBookMark* GetBookMark(LwpObjectID objMarker);
+	sal_Bool FindBookMarkByName(OUString sName);
+	LwpDropcapMgr* GetDropcapMgr(){return m_pDropcapMgr;}
+	LwpContent* EnumContents(LwpContent* pContent);
+	LwpSection* EnumSections(LwpSection* pSection);
+	LwpBulletStyleMgr* GetBulletStyleMgr(){return m_pBulletStyleMgr;}
+
+	LwpObjectID* FindParaStyleByName(OUString name);
+	OUString FindActuralStyleName(OUString name);
+};
+
+class LwpStyleManager
+{
+public:
+	LwpStyleManager();
+	~LwpStyleManager();
+private:
+	LwpFoundry* m_pFoundry;
+	struct hashFunc
+	{
+			size_t operator()( const LwpObjectID& rName ) const
+			{
+				return rName.HashCode();
+			}
+	};
+	struct eqFunc
+	{
+			bool operator()( const LwpObjectID& rKey1, const LwpObjectID& rKey2 ) const
+			{
+				return(rKey1==rKey2);
+			}
+	};		
+
+	typedef std::hash_map<LwpObjectID, IXFStyle*, hashFunc, eqFunc> LwpStyleMap;
+	LwpStyleMap m_StyleList;
+public:
+	void SetFoundry(LwpFoundry* pFoundry){m_pFoundry = pFoundry;}
+	IXFStyle* AddStyle(LwpObjectID styleObjID, IXFStyle* pStyle);
+	IXFStyle* GetStyle(const LwpObjectID &styleObjID);
+};
+#endif
diff -urNp lotuswordpro.bak/source/filter/lwpframelayout.cxx lotuswordpro/source/filter/lwpframelayout.cxx
--- lotuswordpro.bak/source/filter/lwpframelayout.cxx	1970-01-01 08:00:00.000000000 +0800
+++ lotuswordpro/source/filter/lwpframelayout.cxx	2008-10-22 11:42:29.000000000 +0800
@@ -0,0 +1,1281 @@
+/*************************************************************************
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: IBM Corporation
+ *
+ *  Copyright: 2008 by IBM Corporation
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+/*************************************************************************
+ * @file 
+ *  the class for VO_FrameLayout
+ ************************************************************************/
+/*************************************************************************
+ * Change History
+Mar 2005			Created
+ ************************************************************************/
+#include "lwpframelayout.hxx"
+#include "lwppara.hxx"
+#include "xfilter/xfstylemanager.hxx"
+#include "xfilter/xfparagraph.hxx"
+#include	"xfilter/xffloatframe.hxx"
+#include "xfilter/xfrubystyle.hxx"
+#include "lwppagelayout.hxx"
+#include "lwpoleobject.hxx"
+#include "lwptablelayout.hxx"
+#include "lwpgrfobj.hxx"
+#include "lwpglobalmgr.hxx"
+
+LwpFrame::LwpFrame(LwpPlacableLayout* pLayout):m_pLayout(pLayout)
+{
+}
+
+LwpFrame::~LwpFrame()
+{
+}
+/**
+* @descr:  parse frame
+* @param:  register frame style
+* @param:  pFrameStyle - Frame Style object 
+*
+*/
+void  LwpFrame::RegisterStyle(XFFrameStyle* pFrameStyle)
+{	
+	ApplyWrapType(pFrameStyle);
+	ApplyMargins(pFrameStyle);
+	ApplyPadding(pFrameStyle);
+	ApplyBorders(pFrameStyle);
+	ApplyColumns(pFrameStyle);
+	ApplyShadow(pFrameStyle);
+	ApplyBackGround(pFrameStyle);
+	ApplyWatermark(pFrameStyle);
+//	ApplyBackColor(pFrameStyle);
+	ApplyProtect(pFrameStyle);
+	ApplyTextDir(pFrameStyle);
+	ApplyPosType(pFrameStyle);
+
+	pFrameStyle->SetStyleName(m_pLayout->GetName()->str());
+	XFStyleManager* pXFStyleManager = LwpGlobalMgr::GetInstance()->GetXFStyleManager();
+	m_StyleName = pXFStyleManager->AddStyle(pFrameStyle)->GetStyleName();
+	m_pLayout->SetStyleName(m_StyleName);
+}
+/**
+* @descr:  parse frame and set frame properties
+* @param:   pXFFrame - XFFrame object
+* @param:  nPageNo - the page number that the frame anchors 
+*
+*/
+ void LwpFrame::Parse(XFFrame* pXFFrame, sal_Int32 nPageNo)
+ {	
+	//set the frame style name
+	pXFFrame->SetStyleName(m_StyleName);
+	
+	//SetAnchorType and position,if it's page anchor,set the page number.
+	ParseAnchorType(pXFFrame);
+	if(nPageNo>0)
+	{
+		pXFFrame->SetAnchorPage(nPageNo);
+	}
+		
+	//Set frame Name
+	OUString aFrameName = m_pLayout->GetName()->str();
+	if(aFrameName.getLength())
+	{
+		//cause the bug of SODC, the linkframe name can not be "Frame1", so I change the frame name
+		/*if(aFrameName.equals(A2OUSTR("Frame1")))
+		{
+			aFrameName = A2OUSTR("Frame1_COPY");
+		}
+		pXFFrame->SetName(aFrameName);*/
+		pXFFrame->SetName(m_StyleName);
+	}	
+	
+	LwpLayoutGeometry* pLayoutGeo = m_pLayout->GetGeometry();	
+	//Set frame Width and height	
+	if(pLayoutGeo)
+	{
+		double fWidth = m_pLayout->GetWidth();
+		double fHeight = m_pLayout->GetHeight();
+		
+		pXFFrame->SetWidth( fWidth );
+		pXFFrame->SetHeight( fHeight );
+
+		//Get content obj;
+		LwpObject* pObj = m_pLayout->GetContent()->obj();		
+		if(m_pLayout->IsGroupHead()&&(m_pLayout->IsMinimumHeight()))
+		{
+			//process grouplayout height. there is problems now
+			pXFFrame->SetHeight( fHeight );
+		}
+		/*
+		else if(m_pLayout->IsFitGraphic() && pObj && pObj->GetTag() == VO_GRAPHIC)
+		{			
+			//If is graphic, get original size and set it;
+			LwpGraphicObject* pGrpObj = static_cast<LwpGraphicObject*>(pObj);
+			long nHeight =0, nWidth =0;
+			pGrpObj->GetGrafOrgSize(nWidth, nHeight);
+			//add margins to the width and height;
+			fWidth = (double)nWidth/TWIPS_PER_CM + m_pLayout->GetMarginsValue(MARGIN_LEFT) + m_pLayout->GetMarginsValue(MARGIN_RIGHT);
+			fHeight = (double)nHeight/TWIPS_PER_CM + m_pLayout->GetMarginsValue(MARGIN_TOP) + m_pLayout->GetMarginsValue(MARGIN_BOTTOM);			
+			pXFFrame->SetWidth(fWidth);
+			pXFFrame->SetHeight(fHeight);			
+		}
+		*/
+		else if(m_pLayout->IsAutoGrow())
+		{			
+			pXFFrame->SetMinHeight( fHeight );
+		}
+	}
+	
+	if(m_pLayout->IsFrame())
+	{
+		//Set frame link. Only frame layout has this feature
+		LwpFrameLayout* pLayout= static_cast<LwpFrameLayout*>(m_pLayout);
+		pXFFrame->SetNextLink(pLayout->GetNextLinkName());		
+	}
+	
+ }
+/**
+* @descr:  parse frame relative to page, frame or cell
+* @param:   pCont - content container which contains the frame 
+* 		
+*/
+ void LwpFrame::XFConvert(XFContentContainer* pCont)
+ {		
+	 //parse the frame which anchor to page
+	LwpVirtualLayout* pParent = m_pLayout->GetParentLayout();
+	if(pParent->IsPage()&& pParent->GetParentLayout()->IsPage())
+	{
+		//for mirror page, problems exist if the parent layout is header or footer layout, 
+		pParent = pParent->GetParentLayout();
+	}
+	if(m_pLayout->IsAnchorPage()&& pParent->IsPage())
+	{
+		//get parent layout			
+		if(m_pLayout->IsUseOnPage())
+		{
+			sal_Int32 nPageNo = pParent->GetPageNumber(m_pLayout->GetUsePage());
+			if(nPageNo>0)
+				m_pLayout->XFConvertFrame(pCont, nPageNo);			
+		}
+		else if(m_pLayout->IsUseOnAllPages())
+		{
+			sal_Int32 nFirst = pParent->GetPageNumber(FIRST_LAYOUTPAGENO);
+			sal_Int32 nLast = pParent->GetPageNumber(LAST_LAYOUTPAGENO);
+			if(nLast > 0)
+				m_pLayout->XFConvertFrame(pCont, nFirst, nLast, sal_True);
+				
+		}
+		else if(m_pLayout->IsUseOnAllOddPages()||m_pLayout->IsUseOnAllEvenPages())
+		{
+			sal_Int32 nFirst = pParent->GetPageNumber(FIRST_LAYOUTPAGENO);			
+			sal_Int32 nLast = pParent->GetPageNumber(LAST_LAYOUTPAGENO);
+			if(nLast > 0)
+			{
+				sal_uInt16 first = static_cast<sal_uInt16>(nFirst);
+				if((m_pLayout->IsUseOnAllOddPages() && !LwpTools::IsOddNumber(first))
+				|| (m_pLayout->IsUseOnAllEvenPages() && !LwpTools::IsEvenNumber(first)))
+					nFirst++;
+				if(nFirst <= nLast)
+				{
+					m_pLayout->XFConvertFrame(pCont, nFirst, nLast, sal_False);	
+				}
+			}
+		}		
+	}
+	else
+	{
+		m_pLayout->XFConvertFrame(pCont);
+	}
+	
+ }
+/**
+* @descr:  set frame wrap type style
+* @param:  pFrameStyle - Frame Style object 
+* 		
+*/
+void LwpFrame::ApplyWrapType(XFFrameStyle *pFrameStyle)
+{	
+	enumXFWrap eWrap = enumXFWrapNone;
+	switch(m_pLayout->GetWrapType())
+	{
+		case LwpPlacableLayout::LAY_WRAP_AROUND:	//fall throught
+		case LwpPlacableLayout::LAY_WRAP_IRREG_BIGGEST:
+		{
+			//In SODC, if Optimal wrap type is used and the distance between the frame object 
+			//and page margins is less than 2cm, the text is not wraped. While there is no this feature in Word Pro
+			//So the optimal wrap type is translated to left side or right side wrap type according to the distance 
+			//between the frame object and page margins
+
+			eWrap = enumXFWrapBest;
+			LwpMiddleLayout* pParent = static_cast<LwpMiddleLayout*>(m_pLayout->GetContainerLayout());
+			if(pParent)
+			{
+				if(IsLeftWider())
+					eWrap = enumXFWrapLeft;
+				else
+					eWrap = enumXFWrapRight;
+			}			
+			break;
+		}
+		case LwpPlacableLayout::LAY_NO_WRAP_BESIDE:
+		{
+			eWrap = enumXFWrapNone;
+			break;
+		}
+		case LwpPlacableLayout::LAY_NO_WRAP_AROUND:
+		{
+			eWrap = enumXFWrapRunThrough;
+			if(!m_pLayout->GetBackColor() && !m_pLayout->GetWaterMarkLayout())
+			{
+				//pFrameStyle->SetBackGround(sal_True);
+				XFColor aXFColor(0xffffff);	//white color
+				pFrameStyle->SetBackColor(aXFColor);
+				pFrameStyle->SetTransparency(100);	//transparency
+			}			
+			break;
+		}
+		case LwpPlacableLayout::LAY_WRAP_LEFT:		//fall throught
+		case LwpPlacableLayout::LAY_WRAP_IRREG_LEFT:
+		{
+			eWrap = enumXFWrapLeft;
+			break;
+		}
+		case LwpPlacableLayout::LAY_WRAP_RIGHT:	//fall throught
+		case LwpPlacableLayout::LAY_WRAP_IRREG_RIGHT:
+		{
+			eWrap = enumXFWrapRight;
+			break;
+		}
+		case LwpPlacableLayout::LAY_WRAP_BOTH:	//fall throught
+		case LwpPlacableLayout::LAY_WRAP_IRREG_BOTH:
+		{
+			eWrap = enumXFWrapParallel;
+			break;
+		}
+		default:
+			break;
+	}
+
+	//If it is the type of with para above, wrap type is enumXFWrapNone
+	if(m_pLayout->GetRelativeType()==LwpLayoutRelativityGuts::LAY_INLINE_NEWLINE)
+	{
+		eWrap = enumXFWrapNone;
+	}
+	
+	pFrameStyle->SetWrapType(eWrap);
+}
+/**
+* @descr:   set frame margins style
+* @param:  pFrameStyle - Frame Style object 
+* 		
+*/
+void LwpFrame::ApplyMargins(XFFrameStyle *pFrameStyle)
+{
+	double fLeft	= m_pLayout->GetExtMarginsValue(MARGIN_LEFT);
+	double fRight	= m_pLayout->GetExtMarginsValue(MARGIN_RIGHT);
+	double fTop	= m_pLayout->GetExtMarginsValue(MARGIN_TOP);
+	double fBottom	= m_pLayout->GetExtMarginsValue(MARGIN_BOTTOM);	
+	pFrameStyle->SetMargins(fLeft,fRight,fTop,fBottom);
+}
+/**
+* @descr:  set padding border style
+* @param:  pFrameStyle - Frame Style object 
+* 		
+*/
+void LwpFrame::ApplyPadding(XFFrameStyle *pFrameStyle)
+{	
+	double fLeft	= m_pLayout->GetMarginsValue(MARGIN_LEFT);
+	double fRight	= m_pLayout->GetMarginsValue(MARGIN_RIGHT);
+	double fTop	= m_pLayout->GetMarginsValue(MARGIN_TOP);
+	double fBottom	= m_pLayout->GetMarginsValue(MARGIN_BOTTOM);
+	pFrameStyle->SetPadding(fLeft,fRight,fTop,fBottom);
+}
+/**
+* @descr:  set frame border style
+* @param:  pFrameStyle - Frame Style object 
+* 		
+*/
+void LwpFrame::ApplyBorders(XFFrameStyle *pFrameStyle)
+{
+	XFBorders* pBordres = m_pLayout->GetXFBorders();
+	if(pBordres)
+	{
+		pFrameStyle->SetBorders(pBordres);
+	}
+}
+/**
+* @descr:  set frame colums style
+* @param:  pFrameStyle - Frame Style object 
+* 		
+*/
+void LwpFrame::ApplyColumns(XFFrameStyle *pFrameStyle)
+{
+	XFColumns* pColumns = m_pLayout->GetXFColumns();
+	if(pColumns)
+	{
+		pFrameStyle->SetColumns(pColumns);
+	}	
+}
+/**
+* @descr:  set frame shadow style
+* @param:  pFrameStyle - Frame Style object 
+* 		
+*/
+void LwpFrame::ApplyShadow(XFFrameStyle* pFrameStyle)
+{
+	XFShadow* pXFShadow = m_pLayout->GetXFShadow();
+	if(pXFShadow)
+	{
+		pFrameStyle->SetShadow(pXFShadow);
+	}
+}
+/**
+* @descr:  set frame back color style
+* @param:  pFrameStyle - Frame Style object 
+* 		
+*/
+void LwpFrame::ApplyBackColor(XFFrameStyle* pFrameStyle)
+{
+	LwpColor* pColor = m_pLayout->GetBackColor();
+	if(pColor)
+	{
+		XFColor aXFColor(pColor->To24Color());
+		pFrameStyle->SetBackColor(aXFColor);
+	}	
+}
+/**
+* @descr:  set frame protect style
+* @param:  pFrameStyle - Frame Style object 
+* 		
+*/
+void LwpFrame::ApplyProtect(XFFrameStyle* pFrameStyle)
+{
+	if(m_pLayout->IsProtected())
+	{
+		pFrameStyle->SetProtect(sal_True,sal_True,sal_True);
+	}
+}
+/**
+* @descr:  set frame text direction style
+* @param:  pFrameStyle - Frame Style object 
+* 		
+*/
+void LwpFrame::ApplyTextDir(XFFrameStyle* pFrameStyle)
+{
+	pFrameStyle->SetTextDir(m_pLayout->GetTextDirection());
+}
+/**
+* @descr:  set frame position type style
+* @param:  pFrameStyle - Frame Style object 
+* 		
+*/
+void LwpFrame::ApplyPosType(XFFrameStyle* pFrameStyle)
+{
+	enumXFFrameXPos eXPos = enumXFFrameXPosCenter;
+	enumXFFrameXRel eXRel = enumXFFrameXRelPara;
+	enumXFFrameYPos eYPos = enumXFFrameYPosMiddle;
+	enumXFFrameYRel eYRel = enumXFFrameYRelPara;
+	sal_uInt8 nType = m_pLayout->GetRelativeType();
+	switch(nType)
+	{
+		case LwpLayoutRelativityGuts::LAY_PARENT_RELATIVE://fall throught
+		case LwpLayoutRelativityGuts::LAY_CONTENT_RELATIVE:
+		{
+			//anchor to page, frame and cell
+			eXPos = enumXFFrameXPosFromLeft;
+			eXRel = enumXFFrameXRelPage;
+			//set vertical position			
+			if(m_pLayout->IsAnchorPage())//in page 
+			{
+				LwpVirtualLayout* pContainer = m_pLayout->GetContainerLayout();
+				if(pContainer && (pContainer->IsHeader() || pContainer->IsFooter()))
+				{
+					//Only anchor to para, the frame can display in header and footer of each page
+					eYPos = enumXFFrameYPosFromTop;	//from top
+					eYRel = enumXFFrameYRelPara; //from margin
+				}
+				else
+				{
+					eYPos = enumXFFrameYPosFromTop;
+					eYRel = enumXFFrameYRelPage;
+				}
+			}
+			if(m_pLayout->IsAnchorFrame()) //in frame
+			{
+				eYPos = enumXFFrameYPosFromTop;
+				eYRel = enumXFFrameYRelPage;
+			}
+			if(m_pLayout->IsAnchorCell()) 
+			{
+				//SODC has no this type, simulate this feature 				
+				eYPos = enumXFFrameYPosFromTop;	//from top
+				eYRel = enumXFFrameYRelPara; //from margin
+			}	
+			break;
+		}		
+		case LwpLayoutRelativityGuts::LAY_PARA_RELATIVE:	//same page as text
+		{
+			eXPos = enumXFFrameXPosFromLeft;
+			eXRel = enumXFFrameXRelPage;
+			eYPos = enumXFFrameYPosBelow;	//below
+			eYRel = enumXFFrameYRelChar; //from char
+			//set vertical position
+			LwpVirtualLayout* pContainer = m_pLayout->GetContainerLayout();
+			if(pContainer && pContainer->IsPage())//in page 
+			{
+				//eYPos = enumXFFrameYPosFromTop;
+				//eYRel = enumXFFrameYRelPage;
+				eYPos = enumXFFrameYPosBelow;
+				eYRel = enumXFFrameYRelChar;
+			}
+			else if(pContainer && pContainer->IsFrame()) //in frame
+			{
+				eYPos = enumXFFrameYPosFromTop;
+				eYRel = enumXFFrameYRelPage;
+			}
+			else 
+			{				
+				eYPos = enumXFFrameYPosFromTop;	//from top
+				eYRel = enumXFFrameYRelPara; //from margin
+			}		
+			break;
+		}
+		case LwpLayoutRelativityGuts::LAY_INLINE:	//in text
+		{
+			eXPos = enumXFFrameXPosFromLeft;	//need not be set
+			eXRel = enumXFFrameXRelParaContent;	//need not be set
+			eYPos = enumXFFrameYPosTop;	//should be from top
+			eYRel = enumXFFrameYRelBaseLine;
+			sal_Int32 nOffset = m_pLayout->GetBaseLineOffset();
+			if(nOffset>0)
+			{					
+				eYPos = enumXFFrameYPosFromTop;			
+			}
+			break;
+		}
+		case LwpLayoutRelativityGuts::LAY_INLINE_NEWLINE:	//with para above
+		{
+			eXPos = enumXFFrameXPosFromLeft;
+			eXRel = enumXFFrameXRelParaContent;
+			//eYPos = enumXFFrameYPosTop;
+			eYPos = enumXFFrameYPosBottom;
+			eYRel = enumXFFrameYRelParaContent;
+			break;
+		}
+		case LwpLayoutRelativityGuts::LAY_INLINE_VERTICAL:	//in text - vertical
+		{
+			eXPos = enumXFFrameXPosFromLeft;
+			eXRel = enumXFFrameXRelPage;
+			eYPos = enumXFFrameYPosFromTop;	//should be below position
+			eYRel = enumXFFrameYRelChar;
+			break;
+		}
+		default:
+			break;
+	}
+	
+	pFrameStyle->SetXPosType(eXPos,eXRel);
+	pFrameStyle->SetYPosType(eYPos,eYRel);
+}
+/**
+* @descr:  set frame watermark style
+* @param:  pFrameStyle - Frame Style object 
+* 		
+*/
+void LwpFrame::ApplyWatermark(XFFrameStyle *pFrameStyle)
+{
+	XFBGImage* pBGImage = m_pLayout->GetXFBGImage();
+	if(pBGImage)
+	{
+		pFrameStyle->SetBackImage(pBGImage);
+		//set watermark transparent
+		 LwpMiddleLayout* pLay = static_cast<LwpMiddleLayout*>(m_pLayout->GetWaterMarkLayout());
+		 LwpBackgroundStuff* pBackgroundStuff = pLay->GetBackgroundStuff();
+		 if(pBackgroundStuff && !pBackgroundStuff->IsTransparent())
+		 {
+		 	pFrameStyle->SetTransparency(100);
+		 }
+	 }
+}
+
+/**
+ * @short   Apply pattern fill to frame style
+ * @param pFrameStyle - pointer of XFFrameStyle
+ * @return 
+ */
+void LwpFrame::ApplyPatternFill(XFFrameStyle* pFrameStyle)
+{
+	XFBGImage* pXFBGImage = m_pLayout->GetFillPattern();
+	if (pXFBGImage)
+	{
+		pFrameStyle->SetBackImage(pXFBGImage);
+	}
+}
+
+/**
+ * @short   Apply background to frame style
+ * @param pFrameStyle - pointer of XFFrameStyle
+ * @return 
+ */
+void LwpFrame::ApplyBackGround(XFFrameStyle* pFrameStyle)
+{
+	if (!m_pLayout)
+	{
+		return;
+	}
+
+	if (m_pLayout->IsPatternFill())
+	{
+		ApplyPatternFill(pFrameStyle);
+	}
+	else
+	{
+		ApplyBackColor(pFrameStyle);
+	}
+}
+
+/**
+* @descr:  set frame size, anchor type, anchored page number
+* @param:  pXFFrame - XFFrame  object 
+* 		
+*/
+void LwpFrame::ParseAnchorType(XFFrame *pXFFrame)
+{
+	//set position
+	double fXOffset = 0;
+	double fYOffset = 0;
+	//page number
+	sal_uInt16 nPageNum = 0;
+	//set anchor type
+	enumXFAnchor eAnchor = enumXFAnchorNone;
+
+	LwpLayoutGeometry* pLayoutGeo = m_pLayout->GetGeometry();	
+	if(pLayoutGeo)
+	{
+		LwpPoint aPoint = pLayoutGeo->GetOrigin();
+		fXOffset = LwpTools::ConvertFromUnitsToMetric(aPoint.GetX());
+		fYOffset = LwpTools::ConvertFromUnitsToMetric(aPoint.GetY());
+	}
+	//set anchor type
+	eAnchor = enumXFAnchorNone;
+	sal_uInt8 nType = m_pLayout->GetRelativeType();
+	switch(nType)
+	{
+		case LwpLayoutRelativityGuts::LAY_PARENT_RELATIVE://fall throught
+		case LwpLayoutRelativityGuts::LAY_CONTENT_RELATIVE:
+		{			
+			//anchor to page, frame and cell
+			if(m_pLayout->IsAnchorPage())//in page 
+			{
+				LwpVirtualLayout* pContainer = m_pLayout->GetContainerLayout();
+				if(pContainer && (pContainer->IsHeader() || pContainer->IsFooter()))
+				{
+					eAnchor = enumXFAnchorPara;
+					fYOffset -= pContainer->GetMarginsValue(MARGIN_TOP);
+				}
+				else
+					eAnchor = enumXFAnchorPage;				
+			}
+			if(m_pLayout->IsAnchorFrame()) //in frame
+			{
+				eAnchor = enumXFAnchorFrame;	
+			}
+			if(m_pLayout->IsAnchorCell())	//in cell
+			{
+				//eAnchor = enumXFAnchorChar;	
+				eAnchor = enumXFAnchorPara;
+				LwpMiddleLayout* pContainer = static_cast<LwpMiddleLayout*>(m_pLayout->GetContainerLayout());
+				if(pContainer)
+				{
+					fYOffset -= pContainer->GetMarginsValue(MARGIN_TOP);
+				}
+			}
+			break;
+		}		
+		case LwpLayoutRelativityGuts::LAY_PARA_RELATIVE:	//same page as text
+		{
+			eAnchor = enumXFAnchorChar;			
+			LwpVirtualLayout* pContainer = m_pLayout->GetContainerLayout();
+			if(pContainer && pContainer->IsPage())//in page 
+			{
+				//eAnchor = enumXFAnchorPage;
+				eAnchor = enumXFAnchorChar;// to character
+			}
+			else if(pContainer && pContainer->IsFrame()) //in frame
+			{
+				eAnchor = enumXFAnchorFrame;	
+			}
+			else if(pContainer && pContainer->IsCell()) //in cell
+			{
+				//eAnchor = enumXFAnchorChar;
+				eAnchor = enumXFAnchorPara;
+				fYOffset -= pContainer->GetMarginsValue(MARGIN_TOP);				
+			}
+			else if(pContainer && (pContainer->IsHeader() || pContainer->IsFooter()))//in header or footer
+			{
+				eAnchor = enumXFAnchorPara;
+				fYOffset -= pContainer->GetMarginsValue(MARGIN_TOP);
+			}
+			break;
+		}
+		case LwpLayoutRelativityGuts::LAY_INLINE:	//in text
+		{
+			eAnchor = enumXFAnchorAsChar;
+			sal_Int32 nOffset = m_pLayout->GetBaseLineOffset();
+			if(nOffset>0 && pLayoutGeo)
+			{					
+				//experiential value
+				fYOffset =-(m_pLayout->GetGeometryHeight()+2*m_pLayout->GetExtMarginsValue(MARGIN_BOTTOM)-LwpTools::ConvertFromUnitsToMetric(nOffset));
+			}
+			break;
+		}
+		case LwpLayoutRelativityGuts::LAY_INLINE_NEWLINE:	//with para above
+		{
+			eAnchor = enumXFAnchorPara;
+			break;
+		}
+		case LwpLayoutRelativityGuts::LAY_INLINE_VERTICAL:	//in text - vertical
+		{
+			eAnchor = enumXFAnchorChar;
+			//set vertical position
+			double offset = 0;
+			
+			//because of the different feature between Word Pro and SODC, I simulate the vertical base offset
+			//between anchor and frame orgin using the font height.			
+			//LwpPara* pPara = static_cast<LwpPara*>(m_pLayout->GetPosition()->obj());
+			XFFont* pFont = m_pLayout->GetFont();
+			if(pFont)
+			{
+				offset = (double)(pFont->GetFontSize())*CM_PER_INCH/POINTS_PER_INCH;
+			}
+			fYOffset = offset-fYOffset;
+			break;
+		}
+		default:
+			break;
+	}
+	
+	pXFFrame->SetX(fXOffset);
+	pXFFrame->SetY(fYOffset);
+	pXFFrame->SetAnchorPage(nPageNum);
+	pXFFrame->SetAnchorType(eAnchor);
+}
+
+/**
+ * @descr Calculate the distance between the frame object and the page margins. 
+ * 		 And determine which side(left or right) is wider
+ */
+sal_Bool LwpFrame::IsLeftWider()
+{
+	//LwpMiddleLayout* pParent = static_cast<LwpMiddleLayout*>(m_pLayout->GetContainerLayout());
+	LwpVirtualLayout* pParent = static_cast<LwpVirtualLayout*>(m_pLayout->GetContainerLayout());
+	if(pParent)
+	{		
+		LwpPoint aPoint = m_pLayout->GetOrigin();
+		double fXOffset = LwpTools::ConvertFromUnitsToMetric(aPoint.GetX());	
+		double fWidth = m_pLayout->GetWidth();
+		double fWrapLeft = m_pLayout->GetExtMarginsValue(MARGIN_LEFT);
+		double fWrapRight = m_pLayout->GetExtMarginsValue(MARGIN_RIGHT);
+
+		//LwpPoint aParentPoint = pParent->GetOrigin();
+		//double fParentXOffset = LwpTools::ConvertFromUnitsToMetric(aParentPoint.GetX());
+		double fParentWidth = pParent->GetWidth();
+		if(pParent->IsCell())
+		{
+			//Get actual width of this cell layout
+			fParentWidth = static_cast<LwpCellLayout*>(pParent)->GetActualWidth();
+		}
+		double fParentMarginLeft = pParent->GetMarginsValue(MARGIN_LEFT);
+		double fParentMarginRight = pParent->GetMarginsValue(MARGIN_RIGHT);
+		
+		double fLeft = fXOffset - fWrapLeft -fParentMarginLeft;
+		double fRight = fParentWidth - fParentMarginRight -(fXOffset + fWidth + fWrapRight);
+		if(fLeft > fRight)
+			return sal_True;		
+	}
+	return sal_False;
+}
+
+LwpFrameLink::LwpFrameLink()
+{}
+
+LwpFrameLink::~LwpFrameLink()
+{}
+
+/**
+ * @descr frame link information
+ * 		
+ */
+void LwpFrameLink::Read(LwpObjectStream* pStrm)
+{
+	m_PreviousLayout.ReadIndexed(pStrm);
+	m_NextLayout.ReadIndexed(pStrm);
+	pStrm->SkipExtra();
+}
+
+LwpFrameLayout::LwpFrameLayout(LwpObjectHeader &objHdr, LwpSvStream* pStrm)
+	: LwpPlacableLayout(objHdr, pStrm), m_pFrame(NULL)
+{
+	
+}
+
+LwpFrameLayout::~LwpFrameLayout()
+{
+	if(m_pFrame)
+	{
+		delete m_pFrame;
+		m_pFrame = NULL;
+	}
+}
+
+/**
+ * @descr read frame layout object
+ * 		
+ */
+void LwpFrameLayout::Read()
+{
+	LwpPlacableLayout::Read();
+	if(LwpFileHeader::m_nFileRevision >= 0x000B)
+	{
+		if(m_pObjStrm->QuickReaduInt16())
+		{
+			m_Link.Read(m_pObjStrm);
+		}
+	}
+	m_pObjStrm->SkipExtra();
+}
+
+/**
+ * @descr create a xfframe and add into content container
+ * @param:  pCont - content container that contains the frame. 
+ * 		
+ */
+ void LwpFrameLayout::XFConvert(XFContentContainer* pCont)
+ {
+	if(m_pFrame)
+	{
+		//parse the frame which anchor to paragraph
+		if(IsRelativeAnchored())
+		{
+			XFConvertFrame(pCont);
+		}
+		else
+		{
+			m_pFrame->XFConvert(pCont);
+		}
+		
+	}
+ }
+/**
+ * @descr create a xfframe and add into content container, called by XFConvert
+ * @param:  pCont - content container that contains the frame. 
+ * @param:  nPageNo - the page number that the frame anchors
+ * 		
+ */
+void LwpFrameLayout::XFConvertFrame(XFContentContainer* pCont, sal_Int32 nStart , sal_Int32 nEnd, sal_Bool bAll )
+{
+	if(m_pFrame)
+	{
+		XFFrame* pXFFrame = NULL;
+		if(nEnd < nStart)
+		{
+			pXFFrame = new XFFrame();
+		}
+		else
+		{
+			pXFFrame = new XFFloatFrame(nStart, nEnd, bAll);
+		}
+	
+		m_pFrame->Parse(pXFFrame, nStart);
+		//if it is a link frame, parse contents only once
+		if(!HasPreviousLinkLayout())
+		{
+			LwpObject* content = m_Content.obj();
+			if (content)
+			{
+				content->XFConvert(pXFFrame);			
+				//set frame size according to ole size
+				ApplyGraphicSize(pXFFrame);
+			}
+		}
+		pCont ->Add(pXFFrame);
+	}
+}
+/**
+ * @descr register frame style
+ * 		
+ */
+void  LwpFrameLayout::RegisterStyle()
+{
+	//if it is for water mark, don't register style
+	if(IsForWaterMark())
+	{
+		return;
+	}
+	//register frame style
+	XFFrameStyle* pFrameStyle = new XFFrameStyle();
+	m_pFrame = new LwpFrame(this);
+	m_pFrame->RegisterStyle(pFrameStyle);	
+	
+	//register content style
+	LwpObject* content = m_Content.obj();
+	if (content)
+	{				
+		content->SetFoundry(m_pFoundry);
+		content->RegisterStyle();
+	}
+
+	//register child frame style	
+	RegisterChildStyle();
+	
+	
+}
+/**
+ * @descr get the name of the frame that current frame links
+ * 		
+ */
+OUString LwpFrameLayout::GetNextLinkName()
+{
+	OUString aName;
+	LwpObjectID* pObjectID = m_Link.GetNextLayout();
+	if(!pObjectID->IsNull())
+	{
+		LwpLayout* pLayout = static_cast<LwpLayout*>(pObjectID->obj());		
+		aName = pLayout->GetName()->str();
+		//for division name confict
+		if(pLayout->GetStyleName().getLength() > 0)
+			aName = pLayout->GetStyleName();
+	}
+	return aName;
+}
+/**
+ * @descr whether current frame is linked by other frame
+ * 		
+ */
+sal_Bool LwpFrameLayout::HasPreviousLinkLayout()
+{
+	LwpObjectID* pObjectID = m_Link.GetPreviousLayout();
+	if(pObjectID->IsNull())
+		return sal_False;
+	return sal_True;		
+}
+/**
+ * @descr whether current frame is for water mark. Problem maybe exsits by this method, must be tracking
+ * 		
+ */
+ sal_Bool LwpFrameLayout::IsForWaterMark()
+{
+	if(m_nBuoyancy >=LAY_BUOYLAYER)
+	{
+		if(!m_Content.IsNull() && (m_Content.obj()->GetTag()==VO_GRAPHIC) )
+		{
+			return sal_True;
+		}
+	}
+	return sal_False;	
+}
+
+/**
+ * @descr Get frame width
+ * 		
+ */
+double LwpFrameLayout::GetWidth()
+{
+	double fWidth = LwpMiddleLayout::GetWidth();
+	if(IsInlineToMargin() && IsAutoGrowWidth())
+	{
+		//for text field entry when choosing maximize field length
+		fWidth = GetMaxWidth();
+	}
+	return fWidth;
+}
+
+/**
+ * @descr Get frame width when the text field chooses maximize field length
+ * 		
+ */
+double LwpFrameLayout::GetMaxWidth()
+{
+	double fActualWidth = 0;
+	LwpMiddleLayout* pParent = static_cast<LwpMiddleLayout*>(GetContainerLayout());
+	if(pParent)
+	{		
+		LwpPoint aPoint = GetOrigin();
+		double fXOffset = LwpTools::ConvertFromUnitsToMetric(aPoint.GetX());										
+		double fWrapRight = GetExtMarginsValue(MARGIN_RIGHT);
+
+		//Get parent layout width
+		double fParentWidth = pParent->GetWidth();
+		if(pParent->IsCell())
+		{
+			//Get actual width of this cell layout
+			fParentWidth = static_cast<LwpCellLayout*>(pParent)->GetActualWidth();
+		}
+
+		double fParentMarginRight = 0;
+		sal_uInt8 nType = GetRelativeType();
+		if(nType == LwpLayoutRelativityGuts::LAY_INLINE
+			|| nType == LwpLayoutRelativityGuts::LAY_INLINE_NEWLINE )
+		{
+			fParentMarginRight = pParent->GetMarginsValue(MARGIN_RIGHT);
+		}
+		
+		fActualWidth = fParentWidth - fXOffset - fParentMarginRight - fWrapRight;		
+	}
+
+	return fActualWidth;
+}
+
+/**
+ * @descr Set frame size according to graphic size
+ * 		
+ */
+void LwpFrameLayout::ApplyGraphicSize(XFFrame * pXFFrame)
+{
+	LwpObject* content = m_Content.obj();
+	if(content && (content->GetTag() == VO_GRAPHIC 
+				|| content->GetTag() == VO_OLEOBJECT ))
+	{
+		LwpGraphicOleObject* pGraOle = static_cast<LwpGraphicOleObject*>(content);
+		//Get frame geometry size
+		double fWidth = 0;
+		double fHeight = 0;
+		pGraOle->GetGrafScaledSize(fWidth, fHeight);
+		if( IsFitGraphic())
+		{
+			//graphic scaled sze
+			fWidth += GetMarginsValue(MARGIN_LEFT) + GetMarginsValue(MARGIN_RIGHT);
+			fHeight += GetMarginsValue(MARGIN_TOP) + GetMarginsValue(MARGIN_BOTTOM);			
+		}
+		else if(IsAutoGrowDown() || IsAutoGrowUp())
+		{			
+			fWidth = GetWidth();
+			fHeight += GetMarginsValue(MARGIN_TOP) + GetMarginsValue(MARGIN_BOTTOM);
+		}
+		else if( IsAutoGrowLeft() || IsAutoGrowRight())
+		{
+			fHeight = GetHeight();
+			fWidth += GetMarginsValue(MARGIN_LEFT) + GetMarginsValue(MARGIN_RIGHT);
+		}		
+		else
+		{
+			fWidth = GetWidth();
+			fHeight = GetHeight();
+		}
+		pXFFrame->SetWidth(fWidth);
+		pXFFrame->SetHeight(fHeight);
+	}
+}
+
+LwpGroupLayout::LwpGroupLayout(LwpObjectHeader &objHdr, LwpSvStream* pStrm)
+	: LwpPlacableLayout(objHdr, pStrm),m_pFrame(NULL)
+{
+	 
+}
+
+LwpGroupLayout::~LwpGroupLayout()
+{
+	if(m_pFrame)
+	{
+		delete m_pFrame;
+		m_pFrame = NULL;
+	}
+}
+/**
+ * @descr read group layout object
+ * 		
+ */
+void LwpGroupLayout::Read()
+{
+	LwpPlacableLayout::Read();	
+	m_pObjStrm->SkipExtra();
+}
+/**
+ * @descr register group frame style
+ * 		
+ */
+void LwpGroupLayout::RegisterStyle()
+{
+	//register frame style
+	XFFrameStyle* pFrameStyle = new XFFrameStyle();
+	m_pFrame = new LwpFrame(this);
+	m_pFrame->RegisterStyle(pFrameStyle);
+
+	//register child frame style
+	RegisterChildStyle();
+	/*
+	LwpVirtualLayout* pLayout = static_cast<LwpVirtualLayout*>(GetChildHead()->obj());
+	while(pLayout)
+	{		
+		pLayout->SetFoundry(m_pFoundry);
+		pLayout->RegisterStyle();
+		pLayout = static_cast<LwpVirtualLayout*>(pLayout->GetNext()->obj());
+	}
+	*/
+}
+/**
+ * @descr create a xfframe and add into content container
+ * @param:  pCont - content container that contains the frame. 
+ * 		
+ */
+void LwpGroupLayout::XFConvert(XFContentContainer *pCont)
+{
+	if(m_pFrame)
+	{
+		//parse the frame which anchor to paragraph
+		if(IsRelativeAnchored())
+		{
+			XFConvertFrame(pCont);
+		}
+		else
+		{
+			m_pFrame->XFConvert(pCont);
+		}
+		
+	}
+}
+/**
+ * @descr create a xfframe and add into content container, called by XFConvert
+ * @param:  pCont - content container that contains the frame. 
+ * @param:  nPageNo - the page number that the frame anchors
+ * 		
+ */
+void LwpGroupLayout::XFConvertFrame(XFContentContainer* pCont, sal_Int32 nStart , sal_Int32 nEnd, sal_Bool bAll)
+{
+	if(m_pFrame)
+	{
+		XFFrame* pXFFrame = NULL;
+		if(nEnd < nStart)
+		{
+			pXFFrame = new XFFrame();
+		}
+		else
+		{
+			pXFFrame = new XFFloatFrame(nStart, nEnd, bAll);
+		}
+	
+		m_pFrame->Parse(pXFFrame, nStart);
+		
+		//add child frame into group	
+		LwpVirtualLayout* pLayout = static_cast<LwpVirtualLayout*>(GetChildHead()->obj());
+		while(pLayout)
+		{		
+			pLayout->XFConvert(pXFFrame);
+			pLayout = static_cast<LwpVirtualLayout*>(pLayout->GetNext()->obj());
+		}
+
+		pCont ->Add(pXFFrame);
+	}
+}
+
+LwpGroupFrame::LwpGroupFrame(LwpObjectHeader &objHdr, LwpSvStream* pStrm)
+	:LwpContent(objHdr, pStrm)
+{}
+
+LwpGroupFrame::~LwpGroupFrame()
+{}
+
+void LwpGroupFrame::Read()
+{
+	LwpContent::Read();
+	m_pObjStrm->SkipExtra();
+
+}
+ void  LwpGroupFrame::RegisterStyle()
+{
+}
+void LwpGroupFrame::XFConvert(XFContentContainer* pCont)
+{
+}
+
+LwpDropcapLayout::LwpDropcapLayout(LwpObjectHeader &objHdr, LwpSvStream* pStrm)
+	: LwpFrameLayout(objHdr, pStrm)
+{
+	m_nChars = 1;
+	m_nLines = 3;
+}
+
+void LwpDropcapLayout::Read()
+{
+	LwpFrameLayout::Read();
+	m_nLines = m_pObjStrm->QuickReaduInt16();
+	m_pObjStrm->SeekRel(1);
+	m_pObjStrm->SkipExtra();	
+}
+
+void LwpDropcapLayout::Parse(IXFStream* pOutputStream)
+{
+	LwpStory* pStory = static_cast<LwpStory*>(m_Content.obj(VO_STORY));
+	if (!pStory)
+		return;
+	LwpObject* pPara = pStory->GetFirstPara()->obj(VO_PARA);
+	if(pPara)
+	{
+		pPara->SetFoundry(m_pFoundry);
+		pPara->Parse(pOutputStream); 
+	}
+}
+
+void LwpDropcapLayout::XFConvert(XFContentContainer* pCont)
+{
+	LwpStory* pStory = static_cast<LwpStory*>(m_Content.obj(VO_STORY));
+	if (pStory)
+	{
+		pStory->SetFoundry(m_pFoundry);
+		pStory->XFConvert(pCont);
+	}
+}
+
+LwpStory* LwpDropcapLayout::GetContentStory()
+{
+	return static_cast<LwpStory*>(m_Content.obj(VO_STORY));
+}
+
+void LwpDropcapLayout::RegisterStyle(LwpFoundry* pFoundry)
+{
+	LwpStory* pStory = GetContentStory();
+	if (pStory)
+	{
+		pStory->SetDropcapFlag(sal_True);
+		pStory->SetFoundry(pFoundry);
+		LwpPara* pPara = static_cast<LwpPara*>(pStory->GetFirstPara()->obj());
+		while(pPara)
+		{
+			pPara->SetFoundry(pFoundry);
+			pPara->RegisterStyle();
+			pPara = static_cast<LwpPara*>(pPara->GetNext()->obj());
+		}
+	}	
+}
+
+/**
+ * @descr  do nothing
+ * 		
+ */
+void LwpDropcapLayout::RegisterStyle()
+{
+}
+
+LwpRubyLayout::LwpRubyLayout(LwpObjectHeader &objHdr, LwpSvStream* pStrm)
+	: LwpFrameLayout(objHdr, pStrm)
+{
+}
+
+void LwpRubyLayout::Read()
+{
+	LwpFrameLayout::Read();
+	m_nPlacement = m_pObjStrm->QuickReaduInt8();
+	m_nAlignment = m_pObjStrm->QuickReaduInt8();;
+	m_nStateFlag = m_pObjStrm->QuickReaduInt16();;
+	m_nXOffset = m_pObjStrm->QuickReadInt32();
+	m_nYOffset = m_pObjStrm->QuickReadInt32();	
+	m_objRubyMarker.ReadIndexed(m_pObjStrm);
+	m_pObjStrm->SkipExtra();	
+}
+
+LwpRubyMarker* LwpRubyLayout::GetMarker()
+{
+	return static_cast<LwpRubyMarker*>(m_objRubyMarker.obj(VO_RUBYMARKER));
+}
+
+LwpStory* LwpRubyLayout::GetContentStory()
+{
+	return static_cast<LwpStory*>(m_Content.obj(VO_STORY));
+}
+
+void LwpRubyLayout::ConvertContentText()
+{
+	LwpStory* pStory = GetContentStory();
+	LwpRubyMarker* pMarker = GetMarker();
+	if (pStory && pMarker)
+		pMarker->SetRubyText(pStory->GetContentText(sal_True));
+}
+
+void LwpRubyLayout::RegisterStyle()
+{
+	LwpRubyMarker* pMarker = GetMarker();
+	
+	XFRubyStyle* pRubyStyle = new XFRubyStyle;
+	
+	enumXFRubyPosition eType = enumXFRubyLeft;
+	if (m_nAlignment == LEFT)
+	{
+		eType = enumXFRubyLeft;
+	}
+	else if(m_nAlignment == RIGHT)
+	{
+		eType =  enumXFRubyRight;
+	}
+	else if(m_nAlignment == CENTER)
+	{
+		eType =  enumXFRubyCenter;
+	}
+	pRubyStyle->SetAlignment(eType);
+	
+	eType = enumXFRubyTop;
+	if (m_nPlacement == TOP)
+	{
+		eType = enumXFRubyTop;
+	}
+	else if(m_nPlacement == BOTTOM)
+	{
+		eType =  enumXFRubyBottom;
+	}
+	pRubyStyle->SetPosition(eType);
+	
+	XFStyleManager* pXFStyleManager = LwpGlobalMgr::GetInstance()->GetXFStyleManager();
+	OUString rubyStyle = pXFStyleManager->AddStyle(pRubyStyle)->GetStyleName();
+	pMarker->SetRubyStyleName(rubyStyle);
+	
+	LwpStory* pStory = GetContentStory();
+	pStory->SetFoundry(m_pFoundry);
+	OUString textStyle = pStory->RegisterFirstFribStyle();
+	pMarker->SetTextStyleName(textStyle);
+}
diff -urNp lotuswordpro.bak/source/filter/lwpframelayout.hxx lotuswordpro/source/filter/lwpframelayout.hxx
--- lotuswordpro.bak/source/filter/lwpframelayout.hxx	1970-01-01 08:00:00.000000000 +0800
+++ lotuswordpro/source/filter/lwpframelayout.hxx	2008-10-22 11:42:29.000000000 +0800
@@ -0,0 +1,240 @@
+/*************************************************************************
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: IBM Corporation
+ *
+ *  Copyright: 2008 by IBM Corporation
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+/*************************************************************************
+ * @file 
+ *  the class for VO_FrameLayout
+ ************************************************************************/
+/*************************************************************************
+ * Change History
+Mar 2005			Created
+ ************************************************************************/
+
+#ifndef _LWPFRAMELAYOUT_HXX
+#define _LWPFRAMELAYOUT_HXX
+
+#include "lwplayout.hxx"
+#include "lwpstory.hxx"
+#include "lwpmarker.hxx"
+/**
+ * @brief		For register frame style and parse frame   
+ * 
+ */
+
+class LwpFrame
+{
+public:
+	LwpFrame(LwpPlacableLayout* pLayout);
+	~LwpFrame();
+	void RegisterStyle(XFFrameStyle* pFrameStyle);
+	void Parse(XFFrame* pXFFrame, sal_Int32 nPageNo = 0);
+	void XFConvert(XFContentContainer* pCont);	
+private:
+	void ApplyWrapType(XFFrameStyle* pFrameStyle);
+	void ApplyMargins(XFFrameStyle* pFrameStyle);
+	void ApplyPadding(XFFrameStyle* pFrameStyle);
+	void ApplyBorders(XFFrameStyle* pFrameStyle);
+	void ApplyColumns(XFFrameStyle* pFrameStyle);
+	void ApplyShadow(XFFrameStyle* pFrameStyle);
+	void ApplyBackColor(XFFrameStyle* pFrameStyle);
+	void ApplyProtect(XFFrameStyle* pFrameStyle);
+	void ApplyTextDir(XFFrameStyle* pFrameStyle);
+	void ApplyPosType(XFFrameStyle* pFrameStyle);
+	void ApplyWatermark(XFFrameStyle* pFrameStyle);
+	// add by , 06/01/2005
+	void ApplyPatternFill(XFFrameStyle* pFrameStyle);
+ 	void ApplyBackGround(XFFrameStyle* pFrameStyle);
+	// end add
+	void ParseAnchorType(XFFrame* pXFFrame);	
+	sal_Bool IsLeftWider();	
+private:
+	LwpPlacableLayout* m_pLayout;
+	OUString m_StyleName;
+};
+
+/**
+ * @brief		Frame link information
+ * 
+ */
+class LwpFrameLink
+{
+public:
+	LwpFrameLink();
+	~LwpFrameLink();
+	void Read(LwpObjectStream* pStrm);
+	LwpObjectID* GetNextLayout(){ return &m_NextLayout;}
+	LwpObjectID* GetPreviousLayout(){ return &m_PreviousLayout;}
+private:
+	LwpObjectID m_PreviousLayout;
+	LwpObjectID m_NextLayout;
+};
+
+/**
+ * @brief		VO_FRAMELAYOUT object 
+ * 
+ */
+class LwpFrameLayout: public LwpPlacableLayout
+{
+public:
+	LwpFrameLayout(LwpObjectHeader &objHdr, LwpSvStream* pStrm);
+	virtual ~LwpFrameLayout();
+	virtual LWP_LAYOUT_TYPE GetLayoutType () { return LWP_FRAME_LAYOUT;}	
+	virtual void RegisterStyle();	
+	virtual void XFConvert(XFContentContainer* pCont);
+	void XFConvertFrame(XFContentContainer* pCont, sal_Int32 nStart = 0, sal_Int32 nEnd = 0, sal_Bool bAll = sal_False);
+	OUString GetNextLinkName();	
+	sal_Bool HasPreviousLinkLayout();
+	sal_Bool IsForWaterMark();
+	double GetWidth();
+	void ApplyGraphicSize(XFFrame* pXFFrame);
+protected:
+	void Read();
+private:
+	double GetMaxWidth();
+	
+private:
+	LwpFrameLink m_Link;	
+	LwpFrame* m_pFrame;
+};
+
+/**
+ * @brief		VO_GROUPLAYOUT object , information for frame group layout
+ * 
+ */
+class LwpGroupLayout: public LwpPlacableLayout
+{
+public:
+	LwpGroupLayout(LwpObjectHeader &objHdr, LwpSvStream* pStrm);
+	virtual ~LwpGroupLayout();
+	virtual LWP_LAYOUT_TYPE GetLayoutType () { return LWP_GROUP_LAYOUT;}	
+	virtual void RegisterStyle();	
+	virtual void XFConvert(XFContentContainer* pCont);
+	void XFConvertFrame(XFContentContainer* pCont, sal_Int32 nStart = 0, sal_Int32 nEnd = 0, sal_Bool bAll = sal_False);
+protected:
+	void Read();
+private:
+	LwpFrame* m_pFrame;
+
+};
+
+/**
+ * @brief		VO_GROUPFRAME object , information for frame group contents
+ * 
+ */
+class LwpGroupFrame: public LwpContent
+{
+public:
+	LwpGroupFrame(LwpObjectHeader &objHdr, LwpSvStream* pStrm);
+	~LwpGroupFrame();
+	virtual void RegisterStyle();
+	virtual void XFConvert(XFContentContainer* pCont);	
+protected:	
+	void Read();	
+};
+
+class LwpStory;
+class LwpFoundry;
+class LwpDropcapLayout : public LwpFrameLayout
+{
+public:
+	LwpDropcapLayout(LwpObjectHeader &objHdr, LwpSvStream* pStrm);
+	virtual ~LwpDropcapLayout(){};
+	virtual LWP_LAYOUT_TYPE GetLayoutType () { return LWP_DROPCAP_LAYOUT;}
+	virtual void Parse(IXFStream* pOutputStream);
+	virtual void XFConvert(XFContentContainer* pCont);
+	sal_uInt16 GetLines(){return m_nLines;}
+	void SetChars(sal_uInt32 nChars){ m_nChars += nChars;}
+	sal_uInt32 GetChars() const {return m_nChars;}
+	LwpStory* GetContentStory();
+	void RegisterStyle(LwpFoundry* pFoundry);
+	void RegisterStyle();
+protected:
+	void Read();
+private:
+	sal_uInt16 m_nLines;	
+	sal_uInt32 m_nChars;	
+};
+
+class LwpRubyLayout : public LwpFrameLayout
+{
+public:
+	LwpRubyLayout(LwpObjectHeader &objHdr, LwpSvStream* pStrm);
+	virtual ~LwpRubyLayout(){};
+	LwpRubyMarker* GetMarker();
+	void ConvertContentText();
+	LwpStory* GetContentStory();
+	sal_uInt8 GetPosition(){return m_nPlacement;}
+	sal_uInt8 GetAlignment(){return m_nAlignment;}
+	void RegisterStyle();
+	enum{
+	LEFT = 4,
+	RIGHT = 5,
+	CENTER = 2,
+	TOP = 1,
+	BOTTOM = 3
+	};
+protected:
+	void Read();
+private:
+	sal_uInt8 m_nPlacement;
+	sal_uInt8 m_nAlignment;
+	sal_uInt16 m_nStateFlag;
+	sal_Int32 m_nXOffset;
+	sal_Int32 m_nYOffset;	
+	LwpObjectID m_objRubyMarker;
+	sal_Int32 m_nBodyX;
+	sal_Int32 m_nBodyWidth;		
+};
+
+#endif
diff -urNp lotuswordpro.bak/source/filter/lwpfribbreaks.cxx lotuswordpro/source/filter/lwpfribbreaks.cxx
--- lotuswordpro.bak/source/filter/lwpfribbreaks.cxx	1970-01-01 08:00:00.000000000 +0800
+++ lotuswordpro/source/filter/lwpfribbreaks.cxx	2008-10-22 11:42:29.000000000 +0800
@@ -0,0 +1,165 @@
+/*************************************************************************
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: IBM Corporation
+ *
+ *  Copyright: 2008 by IBM Corporation
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+/*************************************************************************
+ * @file 
+ *  For LWP filter architecture prototype
+ ************************************************************************/
+/*************************************************************************
+ * Change History
+ Jan 2005			Created
+ ************************************************************************/
+#include "lwpfribbreaks.hxx"
+#include "lwpstory.hxx"
+#include "xfilter/xfstylemanager.hxx"
+#include "xfilter/xfsectionstyle.hxx"
+#include "lwpsection.hxx"
+#include "xfilter/xfsection.hxx"
+#include "lwpglobalmgr.hxx"
+
+void LwpFribColumnBreak::RegisterBreakStyle(LwpPara * pPara)
+{
+//    XFParaStyle* pBaseStyle = static_cast<XFParaStyle*>(pFoundry->GetStyleManager()->GetStyle(styleID)); 
+	XFParaStyle* pBaseStyle =  pPara->GetXFParaStyle();
+	if (pBaseStyle == NULL) return;
+//    m_StyleName = pBaseStyle->GetStyleName();
+    
+	XFParaStyle* pOverStyle = new XFParaStyle;
+	*pOverStyle = *pBaseStyle;
+	pOverStyle->SetStyleName(A2OUSTR(""));
+	
+	//Old code
+	//if (static_cast<LwpStory*>(pPara->GetStoryID()->obj())
+	//	->GetCurrentLayout()->GetNumCols() == 1)
+	//New code
+	LwpStory* pStory = static_cast<LwpStory*>(pPara->GetStoryID()->obj());
+	LwpPageLayout* pCurLayout = pStory ? pStory->GetCurrentLayout() : NULL;
+	if( pCurLayout && (pCurLayout->GetNumCols() == 1) )
+	
+	{
+//		if (!GetNext() || GetNext()->GetType()==FRIB_TAG_EOP)
+			pOverStyle->SetBreaks(enumXFBreakBefPage);    	
+//		else
+//			pOverStyle->SetBreaks(enumXFBreakBefPage);	
+	}
+	else
+	{
+		if (!GetNext() || GetNext()->GetType()==FRIB_TAG_EOP)
+			pOverStyle->SetBreaks(enumXFBreakAftColumn);    	
+		else
+			pOverStyle->SetBreaks(enumXFBreakBefColumn);	
+	}
+	XFStyleManager* pXFStyleManager = LwpGlobalMgr::GetInstance()->GetXFStyleManager();  
+	m_StyleName = pXFStyleManager->AddStyle(pOverStyle)->GetStyleName();	  	
+}
+
+LwpFribPageBreak::LwpFribPageBreak( LwpPara* pPara )
+	: LwpFrib(pPara), m_pMasterPage(NULL),m_bLastFrib(sal_False)
+{
+}
+
+LwpFribPageBreak::~LwpFribPageBreak()
+{
+	if(m_pMasterPage)
+	{
+		delete m_pMasterPage;
+		m_pMasterPage = NULL;
+	}
+}
+
+void LwpFribPageBreak::Read(LwpObjectStream * pObjStrm, sal_uInt16 len)
+{
+	m_Layout.ReadIndexed(pObjStrm);
+}
+
+
+void LwpFribPageBreak::RegisterBreakStyle(LwpPara* pPara)
+{
+	XFParaStyle* pBaseStyle =  pPara->GetXFParaStyle();
+	if (pBaseStyle == NULL) return;	
+	
+	LwpPageLayout* pLayout = static_cast<LwpPageLayout*>(m_Layout.obj());
+	if(pLayout)
+	{
+		m_pMasterPage = new LwpMasterPage(pPara, pLayout);
+		m_pMasterPage->RegisterMasterPage(this);
+		return;
+	}	
+
+	XFParaStyle* pOverStyle = new XFParaStyle;
+    *pOverStyle = *pBaseStyle;
+    pOverStyle->SetStyleName(A2OUSTR(""));
+    pOverStyle->SetMasterPage(pBaseStyle->GetMasterPage());
+    
+    if (!GetNext() || GetNext()->GetType()==FRIB_TAG_EOP)
+    	m_bLastFrib = sal_True;
+    else
+    	m_bLastFrib = sal_False;    		
+    	
+    if (m_bLastFrib == sal_True)
+    	pOverStyle->SetBreaks(enumXFBreakAftPage);    	
+    else
+    	pOverStyle->SetBreaks(enumXFBreakBefPage);
+
+	XFStyleManager* pXFStyleManager = LwpGlobalMgr::GetInstance()->GetXFStyleManager();
+    m_StyleName = pXFStyleManager->AddStyle(pOverStyle)->GetStyleName();
+}
+
+void LwpFribPageBreak::ParseLayout()
+{
+	if(m_pMasterPage)
+	{
+		m_pMasterPage->ParseSection(this);
+	}
+}
diff -urNp lotuswordpro.bak/source/filter/lwpfribbreaks.hxx lotuswordpro/source/filter/lwpfribbreaks.hxx
--- lotuswordpro.bak/source/filter/lwpfribbreaks.hxx	1970-01-01 08:00:00.000000000 +0800
+++ lotuswordpro/source/filter/lwpfribbreaks.hxx	2008-10-22 11:42:29.000000000 +0800
@@ -0,0 +1,104 @@
+/*************************************************************************
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: IBM Corporation
+ *
+ *  Copyright: 2008 by IBM Corporation
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+/*************************************************************************
+ * @file 
+ *  For LWP filter architecture prototype
+ ************************************************************************/
+/*************************************************************************
+ * Change History
+ Jan 2005			Created
+ ************************************************************************/
+#ifndef _LWPFRIBBREAKS_HXX_
+#define _LWPFRIBBREAKS_HXX_
+
+#include "lwpfrib.hxx"
+#include "xfilter/xfparastyle.hxx"
+#include "lwppara.hxx"
+#include "lwpfribsection.hxx"
+
+class LwpFribPageBreak: public LwpFrib
+{
+public:
+	LwpFribPageBreak( LwpPara* pPara );
+	~LwpFribPageBreak();
+	void Read(LwpObjectStream* pObjStrm, sal_uInt16 len);
+	void RegisterBreakStyle(LwpPara* pPara);
+	void ParseLayout();
+	LwpObjectID* GetLayout(){return &m_Layout;}
+	sal_Bool IsLastFrib(){return m_bLastFrib;}
+
+private:
+	LwpObjectID m_Layout;	
+	sal_Bool m_bLastFrib;
+
+	LwpMasterPage* m_pMasterPage;
+};
+
+class LwpFribLineBreak: public LwpFrib
+{
+public:
+	LwpFribLineBreak( LwpPara* pPara ) : LwpFrib(pPara){};
+	~LwpFribLineBreak(){};
+};
+
+class LwpFribColumnBreak: public LwpFrib
+{
+public:
+	LwpFribColumnBreak( LwpPara* pPara ) : LwpFrib(pPara){};
+	~LwpFribColumnBreak(){};
+	void RegisterBreakStyle(LwpPara* pPara);	
+};
+
+#endif
diff -urNp lotuswordpro.bak/source/filter/lwpfrib.cxx lotuswordpro/source/filter/lwpfrib.cxx
--- lotuswordpro.bak/source/filter/lwpfrib.cxx	1970-01-01 08:00:00.000000000 +0800
+++ lotuswordpro/source/filter/lwpfrib.cxx	2008-10-22 11:42:29.000000000 +0800
@@ -0,0 +1,463 @@
+/*************************************************************************
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: IBM Corporation
+ *
+ *  Copyright: 2008 by IBM Corporation
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+/*************************************************************************
+ * @file 
+ *  For LWP filter architecture prototype
+ ************************************************************************/
+/*************************************************************************
+ * Change History
+ Jan 2005			Created
+ ************************************************************************/
+#include "lwpfrib.hxx"
+#include "lwpcharsetmgr.hxx"
+#include "lwpsection.hxx"
+#include "lwphyperlinkmgr.hxx"
+#include "xfilter/xfhyperlink.hxx"
+#include "xfilter/xfstylemanager.hxx"
+#include "xfilter/xfsection.hxx"
+#include "xfilter/xfsectionstyle.hxx"
+#include "xfilter/xftextspan.hxx"
+#include "xfilter/xftextcontent.hxx"
+#include "lwpfribheader.hxx"
+#include "lwpfribtext.hxx"
+#include "lwpfribtable.hxx"
+#include "lwpfribbreaks.hxx"
+#include "lwpfribframe.hxx"
+#include "lwpfribsection.hxx"
+#include "lwpcharacterstyle.hxx"
+#include "lwpfootnote.hxx"
+#include "lwpnotes.hxx"
+#include "lwpfribmark.hxx"
+#include "lwpchangemgr.hxx"
+#include "lwpdocdata.hxx"
+#include "lwpglobalmgr.hxx"
+
+LwpFrib::LwpFrib(LwpPara* pPara)
+	: m_pPara(pPara), m_pNext(NULL)
+{
+	m_ModFlag = sal_False;
+	m_pModifiers = NULL;
+	m_bRevisionFlag = sal_False;
+}
+
+LwpFrib::~LwpFrib()
+{
+	if(m_pModifiers)
+		delete m_pModifiers;
+}
+
+LwpFrib* LwpFrib::CreateFrib(LwpPara* pPara, LwpObjectStream* pObjStrm, sal_uInt8 fribtag,sal_uInt8 editID)
+{
+	//Read Modifier
+	ModifierInfo* pModInfo = NULL;
+	if(fribtag & FRIB_TAG_MODIFIER)
+	{
+		pModInfo  = new ModifierInfo();
+		pModInfo->CodePage = 0;
+		pModInfo->FontID = 0;
+		pModInfo->RevisionFlag = sal_False;
+		pModInfo->HasCharStyle = sal_False;
+		pModInfo->HasLangOverride = sal_False;
+		pModInfo->HasHighLight = sal_False;		
+		ReadModifiers( pObjStrm, pModInfo );
+	}
+
+	//Read frib data
+	LwpFrib* newFrib = NULL;
+	sal_uInt16 friblen = pObjStrm->QuickReaduInt16();
+	sal_uInt8 fribtype = fribtag&~FRIB_TAG_TYPEMASK; 
+	switch(fribtype)
+	{
+		case FRIB_TAG_INVALID:	//fall through
+		case FRIB_TAG_EOP:		//fall through
+		default:
+			newFrib = new LwpFrib(pPara);
+			break;
+		case FRIB_TAG_TEXT:
+		{
+			newFrib = new LwpFribText (pPara, fribtag & FRIB_TAG_NOUNICODE);
+			break;
+		}
+		case FRIB_TAG_TABLE:
+			newFrib = new LwpFribTable(pPara);
+			break;
+		case FRIB_TAG_TAB:
+			newFrib = new LwpFribTab(pPara);
+			break;
+		case FRIB_TAG_PAGEBREAK:
+			newFrib = new LwpFribPageBreak(pPara);
+			break;
+		case FRIB_TAG_FRAME:
+			newFrib = new LwpFribFrame(pPara);
+			break;
+		case FRIB_TAG_FOOTNOTE:
+		    newFrib = new LwpFribFootnote(pPara);
+		    break;
+		case FRIB_TAG_COLBREAK:
+			newFrib = new LwpFribColumnBreak(pPara);
+			break;
+		case FRIB_TAG_LINEBREAK:
+			newFrib = new LwpFribLineBreak(pPara);
+			break;
+		case FRIB_TAG_HARDSPACE:
+			newFrib = new LwpFribHardSpace(pPara);
+			break;
+		case FRIB_TAG_SOFTHYPHEN:
+			newFrib = new LwpFribSoftHyphen(pPara);
+			break;
+		case FRIB_TAG_PARANUMBER:
+			newFrib = new LwpFribParaNumber(pPara);
+			break;
+		case FRIB_TAG_UNICODE: //fall through
+		case FRIB_TAG_UNICODE2: //fall through
+		case FRIB_TAG_UNICODE3: //fall through		
+			newFrib = new LwpFribUnicode(pPara);
+			break;
+		case FRIB_TAG_NOTE:
+			newFrib = new  LwpFribNote(pPara);
+			break;
+/*		case FRIB_TAG_KANJI:
+			#ifdef KANJI
+		    newFrib = new CFribHelperKanji;
+		    #else
+		    newFrib = new CFribHelperUnicode;
+		    #endif
+		    break;
+		case FRIB_TAG_HKATAKANA:
+			#ifdef KANJI
+		    newFrib = new CFribHelperHKatakana;
+		    #else
+		    newFrib = new CFribHelperUnicode;
+		    #endif
+		    break;
+		case FRIB_TAG_SEPARATOR:
+		    newFrib = new CFribHelperSeparator;
+		    break;*/
+		case FRIB_TAG_SECTION:
+			newFrib = new LwpFribSection(pPara);
+			break;
+/*		case FRIB_TAG_TOMBSTONE:
+		    newFrib = new CFribHelperTombstone;
+		    break;
+		case FRIB_TAG_SPECIALTAB:
+		    newFrib = new CFribHelperSpecialTab;
+		    break;
+		case FRIB_TAG_PAGENUMBER:
+		    newFrib = new CFribHelperPageNumber;
+		    break;
+*/		case FRIB_TAG_PAGENUMBER:
+		    newFrib = new LwpFribPageNumber(pPara);
+		    break;
+		case FRIB_TAG_DOCVAR:
+			newFrib = new LwpFribDocVar(pPara);
+			break;
+		case FRIB_TAG_BOOKMARK:
+		    newFrib = new LwpFribBookMark(pPara);
+		    break;
+/*		case FRIB_TAG_DOCVAR:
+		    newFrib = new CFribHelperBookmark;
+		    break;
+		case FRIB_TAG_DDE:
+		    newFrib = new CFribHelperDDE;
+		    break;
+*/		case FRIB_TAG_FIELD:
+			newFrib = new LwpFribField(pPara);
+			break;
+		case FRIB_TAG_CHBLOCK:
+			newFrib = new LwpFribCHBlock(pPara);
+			break;
+/*		case FRIB_TAG_FLOWBREAK:
+		    newFrib = new CFribHelperFlowBreak;
+		    break;
+#ifdef RUBY*/
+		case FRIB_TAG_RUBYMARKER:
+		    newFrib = new LwpFribRubyMarker(pPara);
+		    break;
+		case FRIB_TAG_RUBYFRAME:
+		    newFrib = new LwpFribRubyFrame(pPara);
+		    break;
+/*#endif
+*/
+	}
+
+	//Do not know why the fribTag judgement is necessary, to be checked with 
+	if ( fribtag & FRIB_TAG_MODIFIER )
+	{
+		newFrib->SetModifiers(pModInfo);
+	}	    
+
+	newFrib->SetType(fribtype);
+	newFrib->SetEditor(editID);
+	newFrib->Read(pObjStrm, friblen);
+	return newFrib;
+}
+
+void LwpFrib::Read(LwpObjectStream* pObjStrm, sal_uInt16 len)
+{
+	pObjStrm->SeekRel(len);
+}
+
+void LwpFrib::SetModifiers(ModifierInfo* pModifiers)
+{
+	if (pModifiers)
+	{
+		m_pModifiers = pModifiers;
+		m_ModFlag = sal_True;
+		if (pModifiers->RevisionFlag)
+		{
+			m_bRevisionFlag = sal_True;
+			m_nRevisionType = pModifiers->RevisionType;
+		}
+	}
+}
+
+void LwpFrib::RegisterStyle(LwpFoundry* pFoundry)
+{ 
+	if (!m_pModifiers) 
+		return;
+	if (!m_pModifiers->FontID && !m_pModifiers->HasCharStyle && !m_pModifiers->HasHighLight)
+	{
+		m_ModFlag = sal_False;
+		return;
+	}
+    //we only read four modifiers, in these modifiers,CodePage and LangOverride are not styles,
+    //so we can only handle fontid and characstyle, if others ,we should not reg style
+    //note by ,1-27
+	XFFont* pFont; 
+	XFTextStyle* pStyle = NULL;
+	m_StyleName = A2OUSTR("");
+	XFStyleManager* pXFStyleManager = LwpGlobalMgr::GetInstance()->GetXFStyleManager();   
+	if (m_pModifiers->HasCharStyle)
+	{	
+		XFTextStyle* pNamedStyle = static_cast<XFTextStyle*>
+                                (pFoundry->GetStyleManager()->GetStyle(m_pModifiers->CharStyleID));
+		if (m_pModifiers->FontID)
+		{
+			pStyle = new XFTextStyle();   
+			*pStyle = *pNamedStyle;
+			LwpCharacterStyle* pCharStyle = static_cast<LwpCharacterStyle*>(m_pModifiers->CharStyleID.obj());
+ 			
+ 			pStyle->SetStyleName(A2OUSTR(""));
+			pFont = pFoundry->GetFontManger()->CreateOverrideFont(pCharStyle->GetFinalFontID(),m_pModifiers->FontID);
+			pStyle->SetFont(pFont);
+			m_StyleName = pXFStyleManager->AddStyle(pStyle)->GetStyleName();	        	
+        	}
+		else	
+			m_StyleName =  pNamedStyle->GetStyleName();
+	}
+	else
+	{
+		if (m_pModifiers->FontID)
+		{
+			pStyle = new XFTextStyle(); 
+			pFont = pFoundry->GetFontManger()->CreateFont(m_pModifiers->FontID);
+			pStyle->SetFont(pFont);
+			m_StyleName = pXFStyleManager->AddStyle(pStyle)->GetStyleName();	        		 	                
+		}
+	}
+
+	if (m_pModifiers->HasHighLight)
+	{		
+		XFColor  aColor = GetHighLightColor();//right yellow
+		if (pStyle)//change the style directly
+			pStyle->GetFont()->SetBackColor(aColor);
+		else //register a new style
+		{
+			pStyle = new XFTextStyle();
+			
+			if (m_StyleName.getLength()>0)
+			{        	
+				XFTextStyle* pOldStyle = pXFStyleManager->FindTextStyle(m_StyleName);
+				*pStyle = *pOldStyle;
+				pStyle->GetFont()->SetBackColor(aColor);				
+			}
+			else
+			{
+				pFont = new XFFont;
+				pFont->SetBackColor(aColor);
+				pStyle->SetFont(pFont);
+			}
+			m_StyleName = pXFStyleManager->AddStyle(pStyle)->GetStyleName();	
+		}	 
+	}
+}
+
+void LwpFrib::ReadModifiers(LwpObjectStream* pObjStrm,ModifierInfo* pModInfo)
+{
+	sal_uInt8 Modifier;
+	sal_uInt8 len;
+//	sal_Bool ModifyFlag = sal_False;
+
+	for(;;)
+	{
+		// Get the modifier type
+		pObjStrm->QuickRead(&Modifier, sizeof(Modifier));			
+
+		// Stop when we hit the last modifier
+		if (Modifier == FRIB_MTAG_NONE)
+			break;
+//        ModifyFlag = sal_True;
+		// Get the modifier length
+		pObjStrm->QuickRead(&len, sizeof(len));
+
+		switch (Modifier)
+		{
+			case FRIB_MTAG_FONT:
+				pObjStrm->QuickRead(&pModInfo->FontID,len);
+				break;
+			case FRIB_MTAG_CHARSTYLE:
+			    pModInfo->HasCharStyle = sal_True;
+				pModInfo->CharStyleID.ReadIndexed(pObjStrm);
+				break;
+			case FRIB_MTAG_LANGUAGE:
+				pModInfo->HasLangOverride = sal_True;
+			    pModInfo->Language.Read(pObjStrm);
+				break;		
+			case FRIB_MTAG_CODEPAGE:
+			    pObjStrm->QuickRead(&pModInfo->CodePage,len);
+			    break;
+			//add by , 02/22/2005
+			case FRIB_MTAG_ATTRIBUTE:
+				pModInfo->aTxtAttrOverride.Read(pObjStrm);
+				if (pModInfo->aTxtAttrOverride.IsHighLight())
+					pModInfo->HasHighLight = sal_True;	
+				break;
+			//end add
+			case FRIB_MTAG_REVISION:
+				pModInfo->RevisionType = pObjStrm->QuickReaduInt8();
+				pModInfo->RevisionFlag = sal_True;
+				break;
+			default:
+				pObjStrm->SeekRel(len);
+				break;
+		}
+		// TODO: read the modifier data
+	//	pObjStrm->SeekRel(len);
+
+	}
+
+}
+
+//do nothing
+//void LwpFrib::Parse(IXFStream* pOutputStream)
+//{}
+
+/**
+*  @descr:   Whether there are other fribs following current frib.
+*  @return:  Ture if having following fribs, or false.
+*/
+sal_Bool LwpFrib::HasNextFrib()
+{
+	if (!GetNext() || GetNext()->GetType()==FRIB_TAG_EOP)
+		return sal_False;
+	return sal_True;
+}
+
+void LwpFrib::ConvertChars(XFContentContainer* pXFPara,OUString text)
+{
+	if (m_ModFlag)
+	{	
+		OUString strStyleName = GetStyleName();
+		XFTextSpan *pSpan = new XFTextSpan(text,strStyleName);
+		pXFPara->Add(pSpan); 
+	}    
+	else
+	{
+		XFTextContent *pSpan = new XFTextContent();
+		pSpan->SetText(text);
+		pXFPara->Add(pSpan);               
+	}
+}
+
+void LwpFrib::ConvertHyperLink(XFContentContainer* pXFPara,LwpHyperlinkMgr* pHyperlink,OUString text)
+{
+	XFHyperlink* pHyper = new XFHyperlink;
+	pHyper->SetHRef(pHyperlink->GetHyperlink());
+	pHyper->SetText(text);
+	pHyper->SetStyleName(GetStyleName());
+	pXFPara->Add(pHyper); 	
+}
+
+/**
+*  @descr:   Get the current frib font style
+*  @return:  XFFont pointer
+*/
+XFFont* LwpFrib::GetFont()
+{
+	XFFont* pFont = NULL;
+	if(m_pModifiers&&m_pModifiers->FontID)
+	{
+		LwpFoundry* pFoundry = m_pPara->GetFoundry();
+		pFont = pFoundry->GetFontManger()->CreateFont(m_pModifiers->FontID);
+	}
+	else
+	{
+		XFParaStyle* pXFParaStyle = m_pPara->GetXFParaStyle();
+		pFont = pXFParaStyle->GetFont();
+	}
+	return pFont;
+}
+
+OUString LwpFrib::GetEditor()
+{
+	LwpGlobalMgr* pGlobal = LwpGlobalMgr::GetInstance();
+	return pGlobal->GetEditorName(m_nEditor);
+}
+
+XFColor LwpFrib::GetHighLightColor()
+{
+	LwpGlobalMgr* pGlobal = LwpGlobalMgr::GetInstance();
+	return pGlobal->GetHighLightColor(m_nEditor);
+}
diff -urNp lotuswordpro.bak/source/filter/lwpfribframe.cxx lotuswordpro/source/filter/lwpfribframe.cxx
--- lotuswordpro.bak/source/filter/lwpfribframe.cxx	1970-01-01 08:00:00.000000000 +0800
+++ lotuswordpro/source/filter/lwpfribframe.cxx	2008-10-22 11:42:29.000000000 +0800
@@ -0,0 +1,236 @@
+/*************************************************************************
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: IBM Corporation
+ *
+ *  Copyright: 2008 by IBM Corporation
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+/**
+ * @file 
+ *  For LWP filter architecture prototype - footnote
+ */
+/*************************************************************************
+ * Change History
+ Mar 2005		Created
+ ************************************************************************/
+#include "lwpfribframe.hxx"
+#include "xfilter/xfstylemanager.hxx"
+#include "lwpglobalmgr.hxx"
+#include "xfilter/xfchange.hxx"
+/**
+ * @short:   Read frame frib
+ * @param:   
+ * @param:   
+ */
+ 
+void LwpFribFrame::Read(LwpObjectStream* pObjStrm, sal_uInt16 len)
+{
+	m_objLayout.ReadIndexed(pObjStrm);	
+}
+
+/**
+*  @descr:  Get the layout object which the frib points to
+*
+*/
+LwpObject* LwpFribFrame::GetLayout()
+{
+	return m_objLayout.obj();
+}
+
+/**
+*  @descr:  register frame style
+*  @param:   pFoundry - current foundry pointer
+*
+*/
+void LwpFribFrame::RegisterStyle(LwpFoundry* pFoundry)
+{
+	if (m_objLayout.obj()->GetTag() == VO_DROPCAPLAYOUT)
+	{
+		static_cast<LwpDropcapLayout*>(m_objLayout.obj())->RegisterStyle(pFoundry);
+	}
+	else
+	{
+		//register frame style, , 04/07/2005
+		LwpPlacableLayout* pLayout = static_cast<LwpPlacableLayout*>(m_objLayout.obj());
+		pLayout->SetFoundry(pFoundry);
+		pLayout->RegisterStyle();
+		
+		//register next frib text style
+		sal_uInt8 nType = pLayout->GetRelativeType();
+		if(LwpLayoutRelativityGuts::LAY_INLINE_NEWLINE == nType
+			&& HasNextFrib())
+		{
+			XFParaStyle* pOldStyle = m_pPara->GetXFParaStyle();	
+			if (pOldStyle->GetMasterPage().getLength() == 0)
+				m_StyleName = pOldStyle->GetStyleName();
+			else			
+			{
+				XFParaStyle* pParaStyle = new XFParaStyle;
+				*pParaStyle = *(pOldStyle);
+				XFStyleManager* pXFStyleManager = LwpGlobalMgr::GetInstance()->GetXFStyleManager();  
+				m_StyleName = pXFStyleManager->AddStyle(pParaStyle)->GetStyleName();
+			}		
+		}
+		//remember the current paragraph font size which will be used in parsing frame
+		pLayout->SetFont(GetFont());
+	}
+}
+void LwpFribFrame::SetParaDropcap(LwpPara* pPara)
+{
+	if (m_objLayout.obj()->GetTag() == VO_DROPCAPLAYOUT)
+	{
+		pPara->SetParaDropcap(sal_True);
+		pPara->SetDropcapLayout(static_cast<LwpDropcapLayout*>(m_objLayout.obj()));
+	}
+	else
+		pPara->SetParaDropcap(sal_False);
+}
+
+/**
+*  @descr:  convert frame
+*
+*/
+void LwpFribFrame::XFConvert(XFContentContainer* pCont)
+{
+	XFContentContainer* pXFContentContainer = pCont;
+	LwpVirtualLayout* pLayout = static_cast<LwpVirtualLayout*>(GetLayout());
+	sal_uInt8 nType = pLayout->GetRelativeType();	
+	if( LwpLayoutRelativityGuts::LAY_PARA_RELATIVE == nType)
+	{		
+		LwpVirtualLayout* pContainerLayout = pLayout->GetContainerLayout();
+		if(pContainerLayout && pContainerLayout->IsFrame())
+		{
+			//same page as text and in frame			
+			pXFContentContainer = m_pPara->GetXFContainer();
+		}
+		else if(pContainerLayout && pContainerLayout->IsCell())
+		{
+			//same page as text and in cell, get the first xfpara			
+			XFContentContainer* pXFFirtPara = static_cast<XFContentContainer*>(pCont->FindFirstContent(enumXFContentPara));
+			if(pXFFirtPara)
+				pXFContentContainer = pXFFirtPara;
+		}		
+	}
+	OUString sChangeID;
+	if(m_bRevisionFlag)
+	{
+		LwpGlobalMgr* pGlobal = LwpGlobalMgr::GetInstance(); 
+		LwpChangeMgr* pChangeMgr = pGlobal->GetLwpChangeMgr();
+		sChangeID = pChangeMgr->GetChangeID(this);
+		if (sChangeID.getLength())
+		{
+			XFChangeStart* pChangeStart = new XFChangeStart;
+			pChangeStart->SetChangeID(sChangeID);
+			pXFContentContainer->Add(pChangeStart);
+		}
+	}
+	
+	pLayout->XFConvert(pXFContentContainer);
+	
+	if(m_bRevisionFlag)
+	{
+		if (sChangeID.getLength())
+		{
+			XFChangeEnd* pChangeEnd = new XFChangeEnd;
+			pChangeEnd->SetChangeID(sChangeID);
+			pXFContentContainer->Add(pChangeEnd);
+		}
+	}
+
+	if(LwpLayoutRelativityGuts::LAY_INLINE_NEWLINE == nType
+		&& HasNextFrib())
+	{
+		XFParagraph* pXFPara = new XFParagraph();
+		pXFPara->SetStyleName(m_StyleName);
+		m_pPara->AddXFContent(pXFPara);
+		m_pPara->GetFribs()->SetXFPara(pXFPara);
+	}
+	
+}
+
+/**
+ *  @descr:  Read Ruby frame
+ *
+ */
+void LwpFribRubyFrame::Read(LwpObjectStream* pObjStrm, sal_uInt16 len)
+{
+	m_objLayout.ReadIndexed(pObjStrm);	
+}
+/**
+ *  @descr:  Register Ruby frame style
+ *
+ */
+void LwpFribRubyFrame::RegisterStyle(LwpFoundry* pFoundry)
+{
+	LwpRubyLayout* pLayout = GetLayout();
+	if (pLayout)
+	{	
+		pLayout->SetFoundry(pFoundry);	
+		pLayout->RegisterStyle();
+	}
+}
+/**
+ *  @descr:  convert Ruby frame
+ *
+ */
+void LwpFribRubyFrame::XFConvert(XFContentContainer* pCont)
+{
+	LwpRubyLayout* pLayout = GetLayout();
+	if (pLayout)
+	{
+		pLayout->ConvertContentText();
+	}
+}
+
+LwpRubyLayout* LwpFribRubyFrame::GetLayout()
+{
+	return static_cast<LwpRubyLayout*>(m_objLayout.obj());
+}
+
diff -urNp lotuswordpro.bak/source/filter/lwpfribframe.hxx lotuswordpro/source/filter/lwpfribframe.hxx
--- lotuswordpro.bak/source/filter/lwpfribframe.hxx	1970-01-01 08:00:00.000000000 +0800
+++ lotuswordpro/source/filter/lwpfribframe.hxx	2008-10-22 11:42:29.000000000 +0800
@@ -0,0 +1,97 @@
+/*************************************************************************
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: IBM Corporation
+ *
+ *  Copyright: 2008 by IBM Corporation
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+/**
+ * @file 
+ *  For LWP filter architecture prototype - footnote
+ */
+/*************************************************************************
+ * Change History
+ Mar 2005		Created
+ ************************************************************************/
+#ifndef _LWPFRIBFRAME_HXX_
+#define _LWPFRIBFRAME_HXX_
+#include "lwpfrib.hxx"
+#include "lwplayout.hxx"
+#include "lwppara.hxx"
+#include "lwpframelayout.hxx"
+
+class LwpFribFrame : public LwpFrib
+{
+public:
+	LwpFribFrame( LwpPara* pPara) : LwpFrib(pPara){};
+	~LwpFribFrame(){};
+	void Read(LwpObjectStream* pObjStrm, sal_uInt16 len);		
+	LwpObject* GetLayout();	
+	void RegisterStyle(LwpFoundry* pFoundry);
+	void SetParaDropcap(LwpPara* pPara);
+	void XFConvert(XFContentContainer* pCont);
+private:
+	LwpObjectID m_objLayout;
+};
+
+class LwpFribRubyFrame : public LwpFrib
+{
+public:
+	LwpFribRubyFrame( LwpPara* pPara) : LwpFrib(pPara){};
+	~LwpFribRubyFrame(){};
+	void Read(LwpObjectStream* pObjStrm, sal_uInt16 len);		
+	LwpRubyLayout* GetLayout();	
+	void RegisterStyle(LwpFoundry* pFoundry);
+	void XFConvert(XFContentContainer* pCont);
+private:
+	LwpObjectID m_objLayout;
+};
+
+#endif
diff -urNp lotuswordpro.bak/source/filter/lwpfribheader.hxx lotuswordpro/source/filter/lwpfribheader.hxx
--- lotuswordpro.bak/source/filter/lwpfribheader.hxx	1970-01-01 08:00:00.000000000 +0800
+++ lotuswordpro/source/filter/lwpfribheader.hxx	2008-10-22 11:42:29.000000000 +0800
@@ -0,0 +1,135 @@
+/*************************************************************************
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: IBM Corporation
+ *
+ *  Copyright: 2008 by IBM Corporation
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+#ifndef _LWPFRIBHEADER_HXX
+#define _LWPFRIBHEADER_HXX 
+
+#define FRIB_TAG_NOUNICODE 0x40	// Don't xlate text to/from Unicode
+#define FRIB_TAG_MODIFIER 0x80	// This frib has a modifier on it
+#define FRIB_TAG_TYPEMASK (FRIB_TAG_NOUNICODE | FRIB_TAG_MODIFIER)
+
+#define FRIB_TAG_ELVIS			0		// "EOP dammit" tag
+
+#define FRIB_MTAG_NONE			0
+#define FRIB_MTAG_FONT			1
+#define FRIB_MTAG_REVISION		2
+#define FRIB_MTAG_CHARSTYLE		3
+#define FRIB_MTAG_ATTRIBUTE		4
+#define FRIB_MTAG_LANGUAGE		5
+#define FRIB_MTAG_CHARBORDER	6
+#define FRIB_MTAG_AMIKAKE		7
+#define FRIB_MTAG_CODEPAGE		8
+#define FRIB_MTAG_STXLINK		9		// SmarText; do not #ifdef out
+
+#define FT_MAXIMUM		30
+
+#define DOC_BADFILEPARAHINTS 0x00800000UL
+
+/* Registration definitions */
+enum
+{
+	FS_RIGHTSIDE	= 0x00,
+	FS_LEFTSIDE		= 0x10
+};
+/* Mode definitions */
+enum
+{
+	FS_REGISTERSELF	= 0x20,
+	FS_READING		= 0x40
+};
+
+enum
+{
+	FRIB_TAG_INVALID,		// FT_INVALID
+	FRIB_TAG_EOP,			// FT_EOP
+	FRIB_TAG_TEXT,			// FT_TEXT
+	FRIB_TAG_TABLE,			// FT_TABLE
+	FRIB_TAG_TAB,			// FT_TAB
+	FRIB_TAG_PAGEBREAK,		// FT_PAGEBREAK
+	FRIB_TAG_FRAME,			// FT_FRAME
+	FRIB_TAG_FOOTNOTE,		// FT_FOOTNOTE
+	FRIB_TAG_COLBREAK,		// FT_COLBREAK
+	FRIB_TAG_LINEBREAK,		// FT_LINEBREAK
+	FRIB_TAG_HARDSPACE,		// FT_HARDSPACE
+	FRIB_TAG_SOFTHYPHEN,	// FT_SOFTHYPHEN
+	FRIB_TAG_PARANUMBER,	// FT_PARANUMBER
+	FRIB_TAG_UNICODE,		// FT_UNICODE
+#ifdef KANJI
+	FRIB_TAG_KANJI,			// FT_KANJI
+	FRIB_TAG_HKATAKANA,		// FT_HKATAKANA
+#else
+	FRIB_TAG_UNICODE2,		// FT_UNICODE
+	FRIB_TAG_UNICODE3,		// FT_UNICODE
+#endif
+	FRIB_TAG_SEPARATOR,		// FT_SEPARATOR
+	FRIB_TAG_SECTION,		// FT_SECTION
+	FRIB_TAG_TOMBSTONE,		// FT_TOMBSTONE
+	FRIB_TAG_SPECIALTAB,	// FT_SPECIALTAB
+	FRIB_TAG_PAGENUMBER,	// FT_PAGENUMBER
+	FRIB_TAG_NOTE,			// FT_NOTE
+	FRIB_TAG_DOCVAR,		// FT_DOCVAR
+	FRIB_TAG_BOOKMARK,		// FT_BOOKMARK
+	FRIB_TAG_DDE,			// FT_DDE
+	FRIB_TAG_FIELD,			// FT_FIELD
+	FRIB_TAG_CHBLOCK,		// FT_CHBLOCK
+//#ifdef RUBY
+	FRIB_TAG_FLOWBREAK,		// FT_FLOWBREAK
+	FRIB_TAG_RUBYMARKER,	// FT_RUBYMARKER
+	FRIB_TAG_RUBYFRAME		// FT_RUBYFRAME
+//#else
+//	FRIB_TAG_FLOWBREAK		// FT_FLOWBREAK	
+//#endif
+};
+
+#endif
diff -urNp lotuswordpro.bak/source/filter/lwpfrib.hxx lotuswordpro/source/filter/lwpfrib.hxx
--- lotuswordpro.bak/source/filter/lwpfrib.hxx	1970-01-01 08:00:00.000000000 +0800
+++ lotuswordpro/source/filter/lwpfrib.hxx	2008-10-22 11:42:29.000000000 +0800
@@ -0,0 +1,139 @@
+/*************************************************************************
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: IBM Corporation
+ *
+ *  Copyright: 2008 by IBM Corporation
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+/*************************************************************************
+ * @file 
+ *  For LWP filter architecture prototype
+ ************************************************************************/
+/*************************************************************************
+ * Change History
+ Jan 2005			Created
+ ************************************************************************/
+#ifndef _LWPFRIB_HXX_
+#define _LWPFRIB_HXX_
+#include "lwpobjid.hxx"
+#include "lwpobjstrm.hxx"
+#include "lwpbasetype.hxx"
+#include "lwpoverride.hxx"
+#include "lwpfoundry.hxx"
+#include "xfilter/xfcolor.hxx"
+
+struct ModifierInfo
+{
+    sal_uInt32 FontID;
+    LwpObjectID CharStyleID;
+    LwpTextLanguageOverride Language;
+	//add by , 02/22/2005
+	LwpTextAttributeOverride aTxtAttrOverride;
+	//end add
+    sal_uInt16 CodePage;
+    sal_Bool HasCharStyle;
+    sal_Bool HasLangOverride;
+    sal_Bool HasHighLight;
+    sal_uInt8 RevisionType;
+    sal_Bool RevisionFlag;
+};
+
+class LwpPara;
+class LwpHyperlinkMgr;
+class LwpFrib
+{
+public:
+	LwpFrib(LwpPara* pPara);
+	~LwpFrib();
+	static LwpFrib* CreateFrib(LwpPara* pPara, LwpObjectStream* pObjStrm, sal_uInt8 fribtag, sal_uInt8 editID);
+	virtual void Read(LwpObjectStream* pObjStrm, sal_uInt16 len);
+//	virtual void Parse(IXFStream* pOutputStream);
+	LwpFrib* GetNext(){return m_pNext;}
+	void SetNext(LwpFrib* next){m_pNext = next;}
+	sal_uInt8 GetType() { return m_nFribType;}
+	void SetType(sal_uInt8 type) { m_nFribType = type;}
+	void SetEditor(sal_uInt8 editor) { m_nEditor = editor;}	
+	OUString GetEditor();
+	XFColor GetHighLightColor();
+protected:
+	LwpPara* m_pPara;
+	LwpFrib* m_pNext;
+	sal_uInt8 m_nFribType;
+	ModifierInfo* m_pModifiers;
+	rtl::OUString m_StyleName;
+public:
+	sal_Bool m_ModFlag;
+	rtl::OUString GetStyleName(){return m_StyleName;}//add by  1-10
+//	void SetStyle(LwpFoundry* pFoundry);
+	sal_Bool IsModified(){return m_ModFlag;};
+	void SetModifiers(ModifierInfo* pModifiers);
+	ModifierInfo* GetModifiers(){return m_pModifiers;};
+	virtual void RegisterStyle(LwpFoundry* pFoundry);
+	sal_Bool HasNextFrib();
+	void ConvertChars(XFContentContainer* pXFPara,OUString text);
+	void ConvertHyperLink(XFContentContainer* pXFPara,LwpHyperlinkMgr* pHyperlink,OUString text);
+	XFFont* GetFont();
+	
+	sal_uInt8 GetRevisionType(){return m_nRevisionType;}
+	sal_Bool GetRevisionFlag(){return m_bRevisionFlag;}
+	enum{
+		REV_INSERT =0,
+		REV_DELETE = 1,
+	};
+	LwpPara* GetMyPara(){return m_pPara;}
+private:
+	static void ReadModifiers(LwpObjectStream* pObjStrm,ModifierInfo* pModInfo);
+protected:
+	sal_uInt8 m_nRevisionType;
+	sal_Bool m_bRevisionFlag;
+	sal_uInt8 m_nEditor;
+};
+
+#endif
diff -urNp lotuswordpro.bak/source/filter/lwpfribmark.cxx lotuswordpro/source/filter/lwpfribmark.cxx
--- lotuswordpro.bak/source/filter/lwpfribmark.cxx	1970-01-01 08:00:00.000000000 +0800
+++ lotuswordpro/source/filter/lwpfribmark.cxx	2008-10-22 11:42:29.000000000 +0800
@@ -0,0 +1,1462 @@
+/*************************************************************************
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: IBM Corporation
+ *
+ *  Copyright: 2008 by IBM Corporation
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+/*************************************************************************
+ * @file 
+ *  For LWP filter architecture prototype
+ ************************************************************************/
+/*************************************************************************
+ * Change History
+ May 2005			Created
+ ************************************************************************/
+ 
+#include "lwpfribmark.hxx"
+#include "lwptools.hxx"
+#include "lwpglobalmgr.hxx"
+#include "lwpdoc.hxx"
+#include "lwpdivinfo.hxx"
+#include "xfilter/xfstylemanager.hxx"
+#include "xfilter/xftextspan.hxx"
+#include "xfilter/xfbookmark.hxx"
+#include "xfilter/xfentry.hxx"
+#include "xfilter/xftextcontent.hxx"
+#include "xfilter/xfcrossref.hxx"
+#include "xfilter/xfdocfield.hxx"
+#include "xfilter/xfdatestyle.hxx"
+#include "xfilter/xftimestyle.hxx"
+#include "xfilter/xfdate.hxx"
+#include "xfilter/xfruby.hxx"
+#include "lwpchangemgr.hxx"
+#include "xfilter/xfchange.hxx"
+
+/**
+ * @short:   Read hyperlink frib and Click here block
+ * @param:   
+ * @param:   
+ */
+void LwpFribCHBlock::Read(LwpObjectStream* pObjStrm, sal_uInt16 len)
+{
+	m_objMarker.ReadIndexed(pObjStrm);
+	m_nType = pObjStrm->QuickReaduInt8();
+}
+
+LwpCHBlkMarker* LwpFribCHBlock::GetMarker()
+{
+	return static_cast<LwpCHBlkMarker*>(m_objMarker.obj());	
+}
+
+void LwpFribCHBlock::XFConvert(XFContentContainer* pXFPara,LwpStory* pStory)
+{
+	sal_uInt8 type = GetType();
+	if (!pStory)
+		return;
+	LwpCHBlkMarker* pMarker = GetMarker();
+	
+	if (!pMarker)
+		return;
+	sal_uInt16 nAction = pMarker->GetAction();
+	if (nAction == LwpCHBlkMarker::CLICKHERE_CHBEHAVIORINTERNETLINK)//hyperlink
+	{
+		LwpHyperlinkMgr* pHyperlink = pStory->GetHyperlinkMgr();
+		if (type == MARKER_START)
+		{
+			if (pHyperlink)
+			{
+				pHyperlink->SetHyperlinkFlag(sal_True);
+				pHyperlink->SetHyperlink(pMarker->GetNamedProperty(A2OUSTR("URL")));
+			}
+		}
+		else if (type == MARKER_END)//or none
+		{
+			pHyperlink->SetHyperlinkFlag(sal_False);				
+		}
+	}
+	else//click here block
+	{
+		pMarker->ConvertCHBlock(pXFPara,type);
+	}
+}
+/**
+ * @short:   register bookmark frib
+ * @param:   
+ * @param:   
+ */
+void  LwpFribBookMark::RegisterStyle(LwpFoundry* pFoundry)
+{
+	OUString name;
+	LwpBookMark* pBook = pFoundry->GetBookMark(GetMarkerID());
+	if (pBook)
+		name = pBook->GetName();
+	
+	OUString sDivision;	
+	LwpDocument* pDoc = pFoundry->GetDocument();
+	if (pDoc)
+	{
+		LwpObjectID* pID = pDoc->GetDivInfoID();
+		if (!pID->IsNull())
+		{
+			sDivision = static_cast<LwpDivInfo*>(pID->obj(VO_DIVISIONINFO))->GetDivName();
+		}
+	}
+		
+	sal_uInt8 type = GetType();
+
+	LwpGlobalMgr* pGlobal = LwpGlobalMgr::GetInstance(); 
+	LwpBookmarkMgr* pMarkMgr = pGlobal->GetLwpBookmarkMgr();
+	if (type == MARKER_START)
+	{
+		XFBookmarkStart* pMarkStart = new XFBookmarkStart;
+		pMarkStart->SetDivision(sDivision);
+		pMarkStart->SetName(name);		
+		pMarkMgr->AddXFBookmarkStart(name,pMarkStart);//add to map
+		m_pStart = pMarkStart;
+	}
+	else if(type == MARKER_END)
+	{
+		XFBookmarkEnd* pMarkEnd = new XFBookmarkEnd;
+		pMarkEnd->SetDivision(sDivision);
+		pMarkEnd->SetName(name);
+		pMarkMgr->AddXFBookmarkEnd(name,pMarkEnd);	//add to map
+		m_pEnd = pMarkEnd;
+	}	
+}
+ 
+LwpFribBookMark::LwpFribBookMark(LwpPara* pPara ) : LwpFrib(pPara),m_pStart(NULL),m_pEnd(NULL)
+{
+}
+						
+/**
+ * @short:   Read bookmark frib
+ * @param:   
+ * @param:   
+ */
+void LwpFribBookMark::Read(LwpObjectStream* pObjStrm, sal_uInt16 len)
+{
+	m_objMarker.ReadIndexed(pObjStrm);
+	m_nType = pObjStrm->QuickReaduInt8();
+}
+/**
+ * @short:   convert bookmark frib
+ * @param:   
+ * @param:   
+ */
+void LwpFribBookMark::XFConvert(XFContentContainer* pXFPara)
+{
+	sal_uInt8 type = GetType();
+			
+	if (type == MARKER_START && m_pStart)
+	{
+		pXFPara->Add(m_pStart);	
+	}
+	else if(type == MARKER_END && m_pEnd)
+	{
+		pXFPara->Add(m_pEnd);	
+	}
+}
+
+/**
+ * @short:   Read index entry frib
+ * @param:   
+ * @param:   
+ */
+LwpFribField::LwpFribField( LwpPara* pPara ) : LwpFrib(pPara)
+{
+	m_TimeStyle = A2OUSTR("");
+	
+	m_nSubType = 0;//datetime/crossref/other
+	m_sFormula = A2OUSTR("");
+	
+	m_nCrossRefType = 0;
+	m_nDateTimeType = 0;	
+}
+
+void LwpFribField::Read(LwpObjectStream* pObjStrm, sal_uInt16 len)
+{
+	m_objMarker.ReadIndexed(pObjStrm);
+	m_nType = pObjStrm->QuickReaduInt8();
+}
+
+LwpFieldMark* LwpFribField::GetMarker()
+{
+	return static_cast<LwpFieldMark*>(m_objMarker.obj());	
+}
+
+void LwpFribField::XFConvert(XFContentContainer* pXFPara)
+{	
+	LwpFieldMark* pFieldMark = GetMarker();
+	if (!pFieldMark)
+		return;
+	
+	sal_uInt8 type = GetType();
+	sal_uInt16 fieldType = pFieldMark->GetFieldType();
+	
+	OUString sChangeID;
+	if(pFieldMark->GetRevisionFlag())
+	{
+		LwpGlobalMgr* pGlobal = LwpGlobalMgr::GetInstance(); 
+		LwpChangeMgr* pChangeMgr = pGlobal->GetLwpChangeMgr();
+		sChangeID = pChangeMgr->GetChangeID(pFieldMark->GetStartFrib());
+	}
+	
+	CheckFieldType(pFieldMark);
+	//end marker
+	if (type == MARKER_END)
+	{
+		if (pFieldMark->GetStart() == sal_False)
+			return;
+		if (pFieldMark->IsFormulaInsert())
+		{
+			XFTextContent *pSpan = new XFTextContent();
+			pSpan->SetText(A2OUSTR(">"));
+			pXFPara->Add(pSpan);   
+		}
+		if (fieldType == LwpFieldMark::FLD_FIELD)
+		{
+			if (m_nSubType == SUBFIELD_DATETIME)
+			{
+				ConvertDateTimeEnd(pXFPara,pFieldMark);	
+			}
+			else if (m_nSubType == SUBFIELD_CROSSREF)
+			{
+				ConvertCrossRefEnd(pXFPara,pFieldMark);
+			}
+			else if (m_nSubType == SUBFIELD_DOCPOWER)
+			{
+				ConvertDocFieldEnd(pXFPara,pFieldMark);
+			}
+		}
+		if(pFieldMark->GetRevisionFlag() && sChangeID.getLength())
+		{
+			XFChangeEnd* pChangeEnd = new XFChangeEnd;
+			pChangeEnd->SetChangeID(sChangeID);
+			pXFPara->Add(pChangeEnd);
+		}
+			
+		return;
+	}
+	
+	//start marker
+	if(pFieldMark->GetRevisionFlag() &&  sChangeID.getLength())
+	{
+		XFChangeStart* pChangeStart = new XFChangeStart;
+		pChangeStart->SetChangeID(sChangeID);
+		pXFPara->Add(pChangeStart);
+	}
+	
+	if (fieldType == LwpFieldMark::FLD_INDEX)
+	{
+		OUString sKey1,sKey2;
+		pFieldMark->ParseIndex(sKey1,sKey2);
+		if (sKey1.getLength()>0)
+		{
+			XFEntry* pEntry = new XFEntry;
+			pEntry->SetEntryType(enumXFEntryAlphabetical);
+			pEntry->SetKey(sKey1,sKey2);
+			pXFPara->Add(pEntry);
+		}
+	}
+	else if (fieldType == LwpFieldMark::FLD_TOC)
+	{
+		OUString sLevel,sText;
+		pFieldMark->ParseTOC(sLevel,sText);
+		if (sLevel.getLength()>0 && sText.getLength()>0)
+		{
+			XFEntry* pEntry = new XFEntry;
+			pEntry->SetEntryType(enumXFEntryTOC);
+			pEntry->SetStringValue(sText);
+			pEntry->SetOutlineLevel(sLevel.toInt32(10));
+			pXFPara->Add(pEntry);
+		}
+	}
+	else if (fieldType == LwpFieldMark::FLD_FIELD)
+	{	
+		sal_uInt8 nDatetype;
+		OUString sFormula;
+		sal_Bool bIsDateTime = pFieldMark->IsDateTimeField(nDatetype,sFormula);
+		
+		if (m_nSubType == SUBFIELD_DATETIME)//date time
+		{
+			ConvertDateTimeStart(pXFPara,pFieldMark);
+		}
+		else if (m_nSubType == SUBFIELD_CROSSREF)//cross ref
+		{
+			ConvertCrossRefStart(pXFPara,pFieldMark);
+		}
+		else if (m_nSubType == SUBFIELD_DOCPOWER)
+		{
+			ConvertDocFieldStart(pXFPara,pFieldMark);
+		}
+	}
+		
+	if (pFieldMark->IsFormulaInsert())
+	{
+		XFTextContent *pSpan = new XFTextContent();
+		pSpan->SetText(A2OUSTR("<"));
+		pXFPara->Add(pSpan);  
+	}
+	
+	pFieldMark->SetStart(sal_True);
+}
+
+void LwpFribField::RegisterStyle(LwpFoundry* pFoundry)
+{
+	LwpFrib::RegisterStyle(pFoundry);
+	LwpFieldMark* pFieldMark = GetMarker();
+	if (!pFieldMark)
+		return;
+	
+	sal_uInt8 type = GetType();
+	sal_uInt16 fieldType = pFieldMark->GetFieldType();
+
+	if (type == MARKER_START && fieldType == LwpFieldMark::FLD_FIELD)
+	{	
+		RegisterTimeField(pFieldMark);
+	}
+	
+	if (type == MARKER_START && m_bRevisionFlag)
+	{
+		LwpGlobalMgr* pGlobal = LwpGlobalMgr::GetInstance(); 
+		LwpChangeMgr* pChangeMgr = pGlobal->GetLwpChangeMgr();
+		pChangeMgr->AddChangeFrib(this);
+		pFieldMark->SetStartFrib(this);
+		pFieldMark->SetRevisionFlag(sal_True);		
+	}	
+}
+
+void LwpFribField::RegisterTimeField(LwpFieldMark* pFieldMark)
+{
+	OUString sFormula = pFieldMark->GetFormula();//now bookmark maybe not all register to bookmarkmgr,
+	if (sFormula == A2OUSTR("TotalEditingTime"))//so check field type now is not correct.
+		RegisterTotalTimeStyle();
+	else
+	{
+		sal_Int32 index;
+		sal_Unicode ch1(0x0020);//space	
+		OUString tag;	
+		index = sFormula.indexOf(ch1,0);
+		if (index < 0)
+			return;
+	
+		tag = sFormula.copy(0,index);
+		if (tag == A2OUSTR("Now()") || tag == A2OUSTR("CreateDate") ||  tag == A2OUSTR("EditDate"))
+			RegisterDateTimeStyle(sFormula.copy(index+1,sFormula.getLength()-index-1));
+	}
+}
+
+void LwpFribField::RegisterTotalTimeStyle()
+{
+	XFTimeStyle* pTimeStyle = new XFTimeStyle;//use the default format
+	pTimeStyle->SetTruncate(sal_False);	
+	pTimeStyle->AddMinute();
+	XFStyleManager* pXFStyleManager = LwpGlobalMgr::GetInstance()->GetXFStyleManager(); 
+	m_TimeStyle = pXFStyleManager->AddStyle(pTimeStyle)->GetStyleName();
+}
+
+void LwpFribField::RegisterDateTimeStyle(OUString sFormula)
+{
+	XFDateStyle* pDateStyle = NULL;
+	XFTimeStyle* pTimeStyle = NULL;
+//DATE	
+	if (sFormula.getLength()<2)
+		return;
+	if (sFormula[1] == 'F')
+	{
+		if (sFormula == A2OUSTR("%FLSystemShortDate"))
+		{
+			pDateStyle = LwpTools::GetSystemDateStyle(sal_False);
+		}
+		else if (sFormula == A2OUSTR("%FLSystemLongDate"))
+		{
+			pDateStyle = LwpTools::GetSystemDateStyle(sal_True);		
+		}	
+		else if (sFormula == A2OUSTR("%FLISODate1") || sFormula == A2OUSTR("%FLYYYY/MM/DD") )
+		{
+			pDateStyle = new XFDateStyle;
+			pDateStyle->AddYear();
+			pDateStyle->AddText(A2OUSTR("/"));		
+			pDateStyle->AddMonth();
+			pDateStyle->AddText(A2OUSTR("/"));
+			pDateStyle->AddMonthDay();		
+		}
+		else if (sFormula == A2OUSTR("%FLISODate2") || sFormula == A2OUSTR("%FLYYYY/MM/DD HH:mm:SS") )
+		{
+			pDateStyle = new XFDateStyle;
+			pDateStyle->AddYear();
+			pDateStyle->AddText(A2OUSTR("/"));		
+			pDateStyle->AddMonth();
+			pDateStyle->AddText(A2OUSTR("/"));
+			pDateStyle->AddMonthDay();
+			pDateStyle->AddText(A2OUSTR(" "));			
+			pDateStyle->AddHour();
+			pDateStyle->AddText(A2OUSTR(":"));
+			pDateStyle->AddMinute();
+			pDateStyle->AddText(A2OUSTR(":"));
+			pDateStyle->AddSecond(sal_True,0);			
+		}
+		else if (sFormula == A2OUSTR("%FLM/D/YY"))
+		{
+			pDateStyle = new XFDateStyle;
+			pDateStyle->AddMonth(sal_False);
+			pDateStyle->AddText(A2OUSTR("/"));
+			pDateStyle->AddMonthDay(sal_False);
+			pDateStyle->AddText(A2OUSTR("/"));	
+			pDateStyle->AddYear(sal_False);
+		}
+		else if (sFormula == A2OUSTR("%FLMonth D, YYYY"))
+		{
+			pDateStyle = new XFDateStyle;
+			pDateStyle->AddMonth(sal_True,sal_True);
+			pDateStyle->AddText(A2OUSTR(" "));
+			pDateStyle->AddMonthDay(sal_False);
+			pDateStyle->AddText(A2OUSTR(", "));	
+			pDateStyle->AddYear();	
+		}
+		else if (sFormula == A2OUSTR("%FLWeekday, Month D, YYYY"))
+		{	
+			pDateStyle = new XFDateStyle;
+			pDateStyle->AddWeekDay();
+			pDateStyle->AddText(A2OUSTR(", "));
+			pDateStyle->AddMonth(sal_True,sal_True);	
+			pDateStyle->AddText(A2OUSTR(" "));		
+			pDateStyle->AddMonthDay(sal_False);
+			pDateStyle->AddText(A2OUSTR(", "));	
+			pDateStyle->AddYear();		
+		}
+		else if (sFormula == A2OUSTR("%FLMn D, YYYY"))
+		{
+			pDateStyle = new XFDateStyle;
+			pDateStyle->AddMonth(sal_False,sal_True);
+			pDateStyle->AddText(A2OUSTR(" "));
+			pDateStyle->AddMonthDay(sal_False);
+			pDateStyle->AddText(A2OUSTR(", "));	
+			pDateStyle->AddYear();	
+		}
+		else if (sFormula == A2OUSTR("%FLWday, Mn D, YYYY"))
+		{
+			pDateStyle = new XFDateStyle;
+			pDateStyle->AddWeekDay(sal_False);
+			pDateStyle->AddText(A2OUSTR(", "));
+			pDateStyle->AddMonth(sal_False,sal_True);	
+			pDateStyle->AddText(A2OUSTR(" "));		
+			pDateStyle->AddMonthDay(sal_False);
+			pDateStyle->AddText(A2OUSTR(", "));	
+			pDateStyle->AddYear();		
+		}
+		else if (sFormula == A2OUSTR("%FLMn D"))
+		{
+			pDateStyle = new XFDateStyle;
+			pDateStyle->AddMonth(sal_False,sal_True);
+			pDateStyle->AddText(A2OUSTR(" "));
+			pDateStyle->AddMonthDay(sal_False);		
+		}
+		else if (sFormula == A2OUSTR("%FLWeekday, Mn D"))
+		{
+			pDateStyle = new XFDateStyle;
+			pDateStyle->AddWeekDay();
+			pDateStyle->AddText(A2OUSTR(", "));
+			pDateStyle->AddMonth(sal_False,sal_True);	
+			pDateStyle->AddText(A2OUSTR(" "));		
+			pDateStyle->AddMonthDay(sal_False);	
+		}
+		else if (sFormula == A2OUSTR("%FLMn D, YY"))
+		{
+			pDateStyle = new XFDateStyle;
+			pDateStyle->AddMonth(sal_False,sal_True);	
+			pDateStyle->AddText(A2OUSTR(" "));		
+			pDateStyle->AddMonthDay(sal_False);
+			pDateStyle->AddText(A2OUSTR(", "));	
+			pDateStyle->AddYear(sal_False);				
+		}
+		else if (sFormula == A2OUSTR("%FLM/D"))
+		{
+			pDateStyle = new XFDateStyle;
+			pDateStyle->AddMonth(sal_False);
+			pDateStyle->AddText(A2OUSTR("/"));
+			pDateStyle->AddMonthDay(sal_False);		
+		}
+		else if (sFormula == A2OUSTR("%FLM/YY"))
+		{
+			pDateStyle = new XFDateStyle;
+			pDateStyle->AddMonth(sal_False);
+			pDateStyle->AddText(A2OUSTR("/"));
+			pDateStyle->AddYear(sal_False);		
+		}
+		else if (sFormula == A2OUSTR("%FLMn YY"))
+		{
+			pDateStyle = new XFDateStyle;
+			pDateStyle->AddMonth(sal_False,sal_True);	
+			pDateStyle->AddText(A2OUSTR(" "));			
+			pDateStyle->AddYear(sal_False);				
+		}
+		else if (sFormula == A2OUSTR("%FLWeekday"))
+		{
+			pDateStyle = new XFDateStyle;
+			pDateStyle->AddWeekDay();
+		}
+		else if (sFormula == A2OUSTR("%FLWday"))
+		{
+			pDateStyle = new XFDateStyle;
+			pDateStyle->AddWeekDay(sal_False);
+		}
+		else if (sFormula == A2OUSTR("%FLMonth"))
+		{
+			pDateStyle = new XFDateStyle;
+			pDateStyle->AddMonth(sal_True,sal_True);		
+		}
+		else if (sFormula == A2OUSTR("%FLMn"))
+		{
+			pDateStyle = new XFDateStyle;
+			pDateStyle->AddMonth(sal_False,sal_True);
+		}
+		else if (sFormula == A2OUSTR("%FLD"))
+		{
+			pDateStyle = new XFDateStyle;
+			pDateStyle->AddMonthDay(sal_False);		
+		}
+		else if (sFormula == A2OUSTR("%FLM"))
+		{
+			pDateStyle = new XFDateStyle;
+			pDateStyle->AddMonth(sal_False);	
+		}
+		else if (sFormula == A2OUSTR("%FLYYYY")	)
+		{
+			pDateStyle = new XFDateStyle;
+			pDateStyle->AddYear();		
+		}
+		else if (sFormula == A2OUSTR("%FLYY"))
+		{
+			pDateStyle = new XFDateStyle;
+			pDateStyle->AddYear(sal_False);		
+		}
+		//chinese version begin
+		else if (sFormula == A2OUSTR("%FLYY/M/D"))
+		{
+			pDateStyle = new XFDateStyle;
+			pDateStyle->AddYear(sal_False);
+			pDateStyle->AddText(A2OUSTR("-"));
+			pDateStyle->AddMonth(sal_False);
+			pDateStyle->AddText(A2OUSTR("-"));
+			pDateStyle->AddMonthDay(sal_False);		
+		}
+		else if(sFormula == A2OUSTR("%FLYYYY Month D"))	
+		{
+			pDateStyle = new XFDateStyle;
+			pDateStyle->AddYear();
+			pDateStyle->AddText(A2OUSTR(" "));
+			pDateStyle->AddMonth(sal_True,sal_True);
+			pDateStyle->AddText(A2OUSTR(" "));
+			pDateStyle->AddMonthDay(sal_False);	
+		}
+		else if(sFormula == A2OUSTR("%FLWeekday, YYYY Month D"))	
+		{
+			pDateStyle = new XFDateStyle;
+			pDateStyle->AddWeekDay();	
+			pDateStyle->AddText(A2OUSTR(","));			
+			pDateStyle->AddYear();
+			pDateStyle->AddText(A2OUSTR(" "));
+			pDateStyle->AddMonth(sal_True,sal_True);
+			pDateStyle->AddText(A2OUSTR(" "));
+			pDateStyle->AddMonthDay(sal_False);	
+		}		
+		else if(sFormula == A2OUSTR("%FLYYYY Mn D"))	
+		{
+			pDateStyle = new XFDateStyle;			
+			pDateStyle->AddYear();
+			pDateStyle->AddText(A2OUSTR(" "));
+			pDateStyle->AddMonth(sal_False,sal_True);
+			pDateStyle->AddText(A2OUSTR(" "));
+			pDateStyle->AddMonthDay(sal_False);	
+		}
+		else if(sFormula == A2OUSTR("%FLWday, YYYY Mn D"))	
+		{
+			pDateStyle = new XFDateStyle;
+			pDateStyle->AddWeekDay(sal_False);	
+			pDateStyle->AddText(A2OUSTR(","));			
+			pDateStyle->AddYear();
+			pDateStyle->AddText(A2OUSTR(" "));
+			pDateStyle->AddMonth(sal_True,sal_True);
+			pDateStyle->AddText(A2OUSTR(" "));
+			pDateStyle->AddMonthDay(sal_False);	
+		}	
+		//next 2 are the same with english version	
+		else if (sFormula == A2OUSTR("%FLYY Mn D"))
+		{
+			pDateStyle = new XFDateStyle;			
+			pDateStyle->AddYear(sal_False);
+			pDateStyle->AddText(A2OUSTR(" "));
+			pDateStyle->AddMonth(sal_False,sal_True);
+			pDateStyle->AddText(A2OUSTR(" "));
+			pDateStyle->AddMonthDay(sal_False);		
+		}
+		else if (sFormula == A2OUSTR("%FLYY/M"))
+		{
+			pDateStyle = new XFDateStyle;
+			pDateStyle->AddMonth(sal_False);
+			pDateStyle->AddText(A2OUSTR("-"));
+			pDateStyle->AddMonth(sal_False);	
+		}
+		else if (sFormula == A2OUSTR("%FLYY Mn"))
+		{
+			pDateStyle = new XFDateStyle;
+			pDateStyle->AddMonth(sal_False);
+			pDateStyle->AddText(A2OUSTR(" "));
+			pDateStyle->AddMonth(sal_False,sal_True);	
+		}
+		else if (sFormula == A2OUSTR("%FLeeeeoa") || sFormula == A2OUSTR("%FLffffooaa") || sFormula == A2OUSTR("%FLEEEEOA"))
+		{
+			pDateStyle = new XFDateStyle;
+	//		OUString lang = OUString::createFromAscii("zh-CN");
+	//		pDateStyle->SetLanguage( lang);
+			rtl::OUString sText;
+			pDateStyle->AddYear();
+			sText = rtl::OUString(0x5e74);
+			pDateStyle->AddText(sText);	
+			pDateStyle->AddMonth(sal_False);
+			sText = rtl::OUString(0x6708);
+			pDateStyle->AddText(sText);
+			pDateStyle->AddMonthDay(sal_False);
+			sText = rtl::OUString(0x65e5);	
+			pDateStyle->AddText(sText);
+		}
+		else if (sFormula == A2OUSTR("%FLoa") || sFormula == A2OUSTR("%FLooaa") || sFormula == A2OUSTR("%FLOA") )
+		{
+			pDateStyle = new XFDateStyle;
+			OUString sText;
+			pDateStyle->AddMonth(sal_False);
+			sText = rtl::OUString(0x6708);
+			pDateStyle->AddText(sText);
+			pDateStyle->AddMonthDay(sal_False);
+			sText = rtl::OUString(0x65e5);	
+			pDateStyle->AddText(sText);
+		}
+		else if (sFormula == A2OUSTR("%FLYYYY/M/D") || sFormula == A2OUSTR("%FLGGGG/od/ad"))
+		{
+			pDateStyle = new XFDateStyle;
+			pDateStyle->AddYear();
+			pDateStyle->AddText(A2OUSTR("-"));
+			pDateStyle->AddMonth(sal_False);
+			pDateStyle->AddText(A2OUSTR("-"));
+			pDateStyle->AddMonthDay(sal_False);			
+		}
+		else if (sFormula == A2OUSTR("%FLYY.M.D") )
+		{
+			pDateStyle = new XFDateStyle;
+			pDateStyle->AddYear(sal_False);
+			pDateStyle->AddText(A2OUSTR("."));
+			pDateStyle->AddMonth(sal_False);
+			pDateStyle->AddText(A2OUSTR("."));
+			pDateStyle->AddMonthDay(sal_False);	
+		}
+		//chinese version end
+		//other version begin
+		else if (sFormula == A2OUSTR("%FLWeekday, Month DD, YYYY") )
+		{
+			pDateStyle = new XFDateStyle;
+			pDateStyle->AddWeekDay();
+			pDateStyle->AddText(A2OUSTR(", "));
+			pDateStyle->AddMonth(sal_True,sal_True);	
+			pDateStyle->AddText(A2OUSTR(" "));		
+			pDateStyle->AddMonthDay();
+			pDateStyle->AddText(A2OUSTR(", "));	
+			pDateStyle->AddYear();		
+		}
+		else if (sFormula == A2OUSTR("%FLYYYY/MM/DD") )
+		{
+			pDateStyle = new XFDateStyle;
+			pDateStyle->AddWeekDay();
+			pDateStyle->AddText(A2OUSTR(", "));
+			pDateStyle->AddMonth(sal_True,sal_True);	
+			pDateStyle->AddText(A2OUSTR(" "));		
+			pDateStyle->AddMonthDay();
+			pDateStyle->AddText(A2OUSTR(", "));	
+			pDateStyle->AddYear();		
+		}
+		else if (sFormula == A2OUSTR("%FLD/M/YY") )
+		{
+			pDateStyle = new XFDateStyle;
+			pDateStyle->AddMonthDay(sal_False);
+			pDateStyle->AddText(A2OUSTR("/"));
+			pDateStyle->AddMonth(sal_False);			
+			pDateStyle->AddText(A2OUSTR("/"));	
+			pDateStyle->AddYear(sal_False);
+		}
+		else if (sFormula == A2OUSTR("%FLD Month YYYY"))
+		{
+			pDateStyle = new XFDateStyle;
+			pDateStyle->AddMonthDay(sal_False);			
+			pDateStyle->AddText(A2OUSTR(" "));
+			pDateStyle->AddMonth(sal_True,sal_True);
+			pDateStyle->AddText(A2OUSTR(" "));	
+			pDateStyle->AddYear();	
+		}
+		else if (sFormula == A2OUSTR("%FLDD Month YYYY"))
+		{
+			pDateStyle = new XFDateStyle;
+			pDateStyle->AddMonthDay();			
+			pDateStyle->AddText(A2OUSTR(" "));
+			pDateStyle->AddMonth(sal_True,sal_True);
+			pDateStyle->AddText(A2OUSTR(" "));	
+			pDateStyle->AddYear();	
+		}
+		else if (sFormula == A2OUSTR("%FLWeekday, D Month YYYY"))
+		{	
+			pDateStyle = new XFDateStyle;
+			pDateStyle->AddWeekDay();
+			pDateStyle->AddText(A2OUSTR(", "));
+			pDateStyle->AddMonthDay(sal_False);	
+			pDateStyle->AddText(A2OUSTR(" "));		
+			pDateStyle->AddMonth(sal_True,sal_True);
+			pDateStyle->AddText(A2OUSTR(" "));	
+			pDateStyle->AddYear();		
+		}
+		else if (sFormula == A2OUSTR("%FLWeekday, DD Month YYYY"))
+		{	
+			pDateStyle = new XFDateStyle;
+			pDateStyle->AddWeekDay();
+			pDateStyle->AddText(A2OUSTR(", "));
+			pDateStyle->AddMonthDay();	
+			pDateStyle->AddText(A2OUSTR(" "));		
+			pDateStyle->AddMonth(sal_True,sal_True);
+			pDateStyle->AddText(A2OUSTR(" "));	
+			pDateStyle->AddYear();		
+		}	
+		else if (sFormula == A2OUSTR("%FLD Mn YYYY"))
+		{
+			pDateStyle = new XFDateStyle;
+			pDateStyle->AddMonthDay(sal_False);
+			pDateStyle->AddText(A2OUSTR(" "));
+			pDateStyle->AddMonth(sal_False,sal_True);
+			pDateStyle->AddText(A2OUSTR(" "));	
+			pDateStyle->AddYear();	
+		}
+		else if (sFormula == A2OUSTR("%FLWday, D Mn YYYY"))
+		{
+			pDateStyle = new XFDateStyle;
+			pDateStyle->AddWeekDay(sal_False);
+			pDateStyle->AddText(A2OUSTR(", "));
+			pDateStyle->AddMonthDay(sal_False);
+			pDateStyle->AddText(A2OUSTR(" "));	
+			pDateStyle->AddMonth(sal_False,sal_True);	
+			pDateStyle->AddText(A2OUSTR(" "));		
+			pDateStyle->AddYear();		
+		}
+		else if (sFormula == A2OUSTR("%FLWday, DD Mn YYYY"))
+		{
+			pDateStyle = new XFDateStyle;
+			pDateStyle->AddWeekDay(sal_False);
+			pDateStyle->AddText(A2OUSTR(", "));
+			pDateStyle->AddMonthDay();
+			pDateStyle->AddText(A2OUSTR(" "));	
+			pDateStyle->AddMonth(sal_False,sal_True);	
+			pDateStyle->AddText(A2OUSTR(" "));		
+			pDateStyle->AddYear();		
+		}
+		else if (sFormula == A2OUSTR("%FLD Mn"))
+		{
+			pDateStyle = new XFDateStyle;
+			pDateStyle->AddMonthDay(sal_False);
+			pDateStyle->AddText(A2OUSTR(" "));
+			pDateStyle->AddMonth(sal_False,sal_True);		
+		}
+		else if (sFormula == A2OUSTR("%FLDD Mn"))
+		{
+			pDateStyle = new XFDateStyle;
+			pDateStyle->AddMonthDay();
+			pDateStyle->AddText(A2OUSTR(" "));
+			pDateStyle->AddMonth(sal_False,sal_True);		
+		}
+		else if (sFormula == A2OUSTR("%FLWeekday, D Mn"))
+		{
+			pDateStyle = new XFDateStyle;
+			pDateStyle->AddWeekDay();
+			pDateStyle->AddText(A2OUSTR(", "));
+			pDateStyle->AddMonthDay(sal_False);	
+			pDateStyle->AddText(A2OUSTR(" "));		
+			pDateStyle->AddMonth(sal_False,sal_True);
+		}
+		else if (sFormula == A2OUSTR("%FLWeekday, DD Mn"))
+		{
+			pDateStyle = new XFDateStyle;
+			pDateStyle->AddWeekDay();
+			pDateStyle->AddText(A2OUSTR(", "));
+			pDateStyle->AddMonthDay();	
+			pDateStyle->AddText(A2OUSTR(" "));		
+			pDateStyle->AddMonth(sal_False,sal_True);
+		}
+		else if (sFormula == A2OUSTR("%FLD Mn YY"))
+		{
+			pDateStyle = new XFDateStyle;
+			pDateStyle->AddMonthDay(sal_False);
+			pDateStyle->AddText(A2OUSTR(" "));
+			pDateStyle->AddMonth(sal_False,sal_True);	
+			pDateStyle->AddText(A2OUSTR(" "));			
+			pDateStyle->AddYear(sal_False);				
+		}
+		else if (sFormula == A2OUSTR("%FLDD Mn YY"))
+		{
+			pDateStyle = new XFDateStyle;
+			pDateStyle->AddMonthDay();
+			pDateStyle->AddText(A2OUSTR(" "));
+			pDateStyle->AddMonth(sal_False,sal_True);	
+			pDateStyle->AddText(A2OUSTR(" "));			
+			pDateStyle->AddYear(sal_False);				
+		}
+		else if (sFormula == A2OUSTR("%FLD/M"))
+		{
+			pDateStyle = new XFDateStyle;
+			pDateStyle->AddMonthDay(sal_False);
+			pDateStyle->AddText(A2OUSTR("/"));
+			pDateStyle->AddMonth(sal_False);		
+		}
+		else if (sFormula == A2OUSTR("%FLDD/MM"))
+		{
+			pDateStyle = new XFDateStyle;
+			pDateStyle->AddMonthDay();
+			pDateStyle->AddText(A2OUSTR("/"));
+			pDateStyle->AddMonth();		
+		}
+		else if(sFormula == A2OUSTR("%FLDD/MM/YY"))
+		{
+			pDateStyle = new XFDateStyle;
+			pDateStyle->AddMonthDay();
+			pDateStyle->AddText(A2OUSTR("/"));
+			pDateStyle->AddMonth();
+			pDateStyle->AddText(A2OUSTR("/"));			
+			pDateStyle->AddYear(sal_False);		
+		}
+		else if (sFormula == A2OUSTR("%FLMM/YY"))
+		{
+			pDateStyle = new XFDateStyle;
+			pDateStyle->AddMonth();
+			pDateStyle->AddText(A2OUSTR("/"));
+			pDateStyle->AddYear(sal_False);		
+		}
+		//other version end
+	//TIME	
+		else if (sFormula == A2OUSTR("%FLSystemTime"))
+		{
+			pTimeStyle = LwpTools::GetSystemTimeStyle();		
+		}
+		else if (sFormula == A2OUSTR("%FLISOTime1") || sFormula == A2OUSTR("%FLH:mm:SS"))
+		{
+			pTimeStyle = new XFTimeStyle;
+			pTimeStyle->AddHour();
+			pTimeStyle->AddText(A2OUSTR(":"));
+			pTimeStyle->AddMinute();
+			pTimeStyle->AddText(A2OUSTR(":"));
+			pTimeStyle->AddSecond(sal_True,0);		
+		}
+		else if (sFormula == A2OUSTR("%FLH:mm ampm"))
+		{
+			pTimeStyle = new XFTimeStyle;
+			pTimeStyle->AddHour(sal_False);
+			pTimeStyle->AddText(A2OUSTR(":"));
+			pTimeStyle->AddMinute();
+			pTimeStyle->AddText(A2OUSTR(" "));
+			pTimeStyle->SetAmPm(sal_True);			
+		}
+		else if (sFormula == A2OUSTR("%FLH:mm"))
+		{
+			pTimeStyle = new XFTimeStyle;
+			pTimeStyle->AddHour(sal_False);
+			pTimeStyle->AddText(A2OUSTR(":"));
+			pTimeStyle->AddMinute();		
+		}
+		else if (sFormula == A2OUSTR("%FLH:mm:SS ampm"))
+		{
+			pTimeStyle = new XFTimeStyle;
+			pTimeStyle->AddHour(sal_False);
+			pTimeStyle->AddText(A2OUSTR(":"));
+			pTimeStyle->AddMinute();
+			pTimeStyle->AddText(A2OUSTR(":"));
+			pTimeStyle->AddSecond(sal_True,0);
+			pTimeStyle->AddText(A2OUSTR(" "));
+			pTimeStyle->SetAmPm(sal_True);			
+		}
+		else if (sFormula == A2OUSTR("%FLH:mm:SS"))
+		{
+			pTimeStyle = new XFTimeStyle;
+			pTimeStyle->AddHour(sal_False);
+			pTimeStyle->AddText(A2OUSTR(":"));
+			pTimeStyle->AddMinute();
+			pTimeStyle->AddText(A2OUSTR(":"));
+			pTimeStyle->AddSecond(sal_True,0);		
+		}
+		else if (sFormula == A2OUSTR("%FLH ampm"))
+		{
+			pTimeStyle = new XFTimeStyle;
+			pTimeStyle->AddHour(sal_False);
+			pTimeStyle->AddText(A2OUSTR(" "));
+			pTimeStyle->SetAmPm(sal_True);		
+		}
+		else if (sFormula == A2OUSTR("%FLH"))
+		{
+			pTimeStyle = new XFTimeStyle;
+			pTimeStyle->AddHour(sal_False);
+		}
+		else if (sFormula == A2OUSTR("%FLmm"))
+		{
+			pTimeStyle = new XFTimeStyle;
+			pTimeStyle->AddMinute();		
+		}
+		else if (sFormula == A2OUSTR("%FLSS"))
+		{
+			pTimeStyle = new XFTimeStyle;
+			pTimeStyle->AddSecond(sal_True,0);		
+		}
+		else if (sFormula == A2OUSTR("%FLampm"))
+		{
+			pTimeStyle = new XFTimeStyle;
+			pTimeStyle->SetAmPm(sal_True);			
+		}
+		//chinese version begin
+		else	 if (sFormula == A2OUSTR("%FLjF") || sFormula == A2OUSTR("%FLJFF") 
+			|| sFormula == A2OUSTR("%FLjjF") || sFormula == A2OUSTR("%FLJJFF ") )
+		{
+			pTimeStyle = new XFTimeStyle;
+			pTimeStyle->AddHour(sal_False);
+			rtl::OUString sText;
+			sText = rtl::OUString(0x70b9);
+			pTimeStyle->AddText(sText);		
+			pTimeStyle->AddMinute(sal_False);
+			sText = rtl::OUString(0x5206);
+			pTimeStyle->AddText(sText);				
+		}	
+		else if (sFormula == A2OUSTR("%FLjjjF") || sFormula == A2OUSTR("%FLJJJFF") )
+		{
+			pTimeStyle = new XFTimeStyle;
+			pTimeStyle->SetAmPm(sal_True);	
+			pTimeStyle->AddHour(sal_False);
+			rtl::OUString sText;
+			sText = rtl::OUString(0x70b9);
+			pTimeStyle->AddText(sText);		
+			pTimeStyle->AddMinute(sal_False);
+			sText = rtl::OUString(0x5206);
+			pTimeStyle->AddText(sText);			
+		}
+		//chinese version end
+		//other version begin
+		else if (sFormula == A2OUSTR("%FLHH:mm ampm"))
+		{
+			pTimeStyle = new XFTimeStyle;
+			pTimeStyle->AddHour();
+			pTimeStyle->AddText(A2OUSTR(":"));
+			pTimeStyle->AddMinute();
+			pTimeStyle->AddText(A2OUSTR(" "));
+			pTimeStyle->SetAmPm(sal_True);			
+		}
+		else if (sFormula == A2OUSTR("%FLHH ampm"))
+		{
+			pTimeStyle = new XFTimeStyle;
+			pTimeStyle->AddHour();
+			pTimeStyle->AddText(A2OUSTR(" "));
+			pTimeStyle->SetAmPm(sal_True);		
+		}
+		else if (sFormula == A2OUSTR("%FLHH:mm:SS ampm"))
+		{
+			pTimeStyle = new XFTimeStyle;
+			pTimeStyle->AddHour();
+			pTimeStyle->AddText(A2OUSTR(":"));
+			pTimeStyle->AddMinute();
+			pTimeStyle->AddText(A2OUSTR(":"));
+			pTimeStyle->AddSecond(sal_True,0);
+			pTimeStyle->AddText(A2OUSTR(" "));
+			pTimeStyle->SetAmPm(sal_True);			
+		}
+		else if (sFormula == A2OUSTR("%FLHH:mm"))
+		{
+			pTimeStyle = new XFTimeStyle;
+			pTimeStyle->AddHour();
+			pTimeStyle->AddText(A2OUSTR(":"));
+			pTimeStyle->AddMinute();		
+		}
+		else if (sFormula == A2OUSTR("%FLHH:mm:SS"))
+		{
+			pTimeStyle = new XFTimeStyle;
+			pTimeStyle->AddHour();
+			pTimeStyle->AddText(A2OUSTR(":"));
+			pTimeStyle->AddMinute();
+			pTimeStyle->AddText(A2OUSTR(":"));
+			pTimeStyle->AddSecond(sal_True,0);		
+		}
+		//other version end
+	}
+	else if(sFormula[1] == 'D')
+	{
+		if (sFormula == A2OUSTR("%Da"))
+		{
+			pDateStyle = LwpTools::GetSystemDateStyle(sal_False);	
+		}
+		else if (sFormula == A2OUSTR("%DB") || sFormula == A2OUSTR("%Db"))
+		{
+			pDateStyle = new XFDateStyle;
+			pDateStyle->AddMonth(sal_True,sal_True);
+			pDateStyle->AddText(A2OUSTR(" "));
+			pDateStyle->AddMonthDay(sal_False);
+			pDateStyle->AddText(A2OUSTR(", "));	
+			pDateStyle->AddYear();			
+		}
+		else if (sFormula == A2OUSTR("%Dc") || sFormula == A2OUSTR("%DC"))
+		{
+			pDateStyle = new XFDateStyle;
+			pDateStyle->AddMonthDay(sal_False);
+			pDateStyle->AddText(A2OUSTR(" "));				
+			pDateStyle->AddMonth(sal_True,sal_True);
+			pDateStyle->AddText(A2OUSTR(" "));	
+			pDateStyle->AddYear();		
+		}
+		else if (sFormula == A2OUSTR("%Dd") || sFormula == A2OUSTR("%DD"))
+		{
+			pDateStyle = new XFDateStyle;
+			pDateStyle->AddWeekDay();
+			pDateStyle->AddText(A2OUSTR(", "));
+			pDateStyle->AddMonth(sal_True,sal_True);	
+			pDateStyle->AddText(A2OUSTR(" "));		
+			pDateStyle->AddMonthDay(sal_False);
+			pDateStyle->AddText(A2OUSTR(", "));	
+			pDateStyle->AddYear();		
+		}
+		else if (sFormula == A2OUSTR("%DE") || sFormula == A2OUSTR("%De"))
+		{
+			pDateStyle = new XFDateStyle;
+			pDateStyle->AddMonth(sal_True,sal_True);
+			pDateStyle->AddText(A2OUSTR(" "));				
+			pDateStyle->AddMonthDay(sal_False);		
+		}
+		else if (sFormula == A2OUSTR("%Df") || sFormula == A2OUSTR("%DF"))
+		{
+			pDateStyle = new XFDateStyle;
+			pDateStyle->AddWeekDay();
+			pDateStyle->AddText(A2OUSTR(" "));
+			pDateStyle->AddMonth(sal_True,sal_True);	
+			pDateStyle->AddText(A2OUSTR(" "));		
+			pDateStyle->AddMonthDay(sal_False);			
+		}
+		else if (sFormula == A2OUSTR("%Dg"))
+		{
+			pDateStyle = new XFDateStyle;
+			pDateStyle->AddMonth(sal_False);	
+			pDateStyle->AddText(A2OUSTR("/"));		
+			pDateStyle->AddMonthDay(sal_False);			
+		}
+		else if (sFormula == A2OUSTR("%Dh"))
+		{
+			pDateStyle = new XFDateStyle;
+			pDateStyle->AddMonth(sal_False);	
+			pDateStyle->AddText(A2OUSTR("/"));		
+			pDateStyle->AddMonthDay(sal_False);
+			pDateStyle->AddText(A2OUSTR("/"));		
+			pDateStyle->AddYear();						
+		}
+		else if (sFormula == A2OUSTR("%Di") || sFormula == A2OUSTR("%DI"))
+		{
+			pDateStyle = new XFDateStyle;
+			pDateStyle->AddMonthDay(sal_False);
+			pDateStyle->AddText(A2OUSTR("."));
+			pDateStyle->AddMonth(sal_True,sal_True);				
+		}
+		else if (sFormula == A2OUSTR("%Dj") || sFormula == A2OUSTR("%DJ"))
+		{
+			pDateStyle = new XFDateStyle;
+			pDateStyle->AddMonthDay(sal_False);
+			pDateStyle->AddText(A2OUSTR("."));
+			pDateStyle->AddMonth(sal_True,sal_True);
+			pDateStyle->AddText(A2OUSTR(" "));		
+			pDateStyle->AddYear();						
+		}
+		else if (sFormula == A2OUSTR("%Dk") || sFormula == A2OUSTR("%DK"))
+		{
+			pDateStyle = new XFDateStyle;
+			pDateStyle->AddYear();	
+			pDateStyle->AddText(A2OUSTR(" "));						
+			pDateStyle->AddMonth(sal_True,sal_True);
+			pDateStyle->AddText(A2OUSTR(" "));		
+			pDateStyle->AddMonthDay(sal_False);
+		}
+		else if (sFormula == A2OUSTR("%DL") || sFormula == A2OUSTR("%Dl"))
+		{
+			pDateStyle = new XFDateStyle;
+			pDateStyle->AddMonth(sal_True,sal_True);
+			pDateStyle->AddText(A2OUSTR(","));
+			pDateStyle->AddYear();						
+		}
+		else if (sFormula == A2OUSTR("%Dm"))
+		{
+			pDateStyle = new XFDateStyle;
+			pDateStyle->AddMonthDay();
+			pDateStyle->AddText(A2OUSTR("/"));						
+			pDateStyle->AddMonth();
+			pDateStyle->AddText(A2OUSTR("/"));
+			pDateStyle->AddYear();		
+		}
+	}
+	else if (sFormula[1] == 'T')
+	{
+		if (sFormula == A2OUSTR("%T1"))
+		{
+			pTimeStyle = new XFTimeStyle;
+			pTimeStyle->AddHour();
+			pTimeStyle->AddText(A2OUSTR(":"));
+			pTimeStyle->AddMinute();							
+		}
+		else if (sFormula == A2OUSTR("%T2") || sFormula == A2OUSTR("%T6")
+		 || sFormula == A2OUSTR("%T4") || sFormula == A2OUSTR("%T8") )
+		{
+			pTimeStyle = new XFTimeStyle;
+			pTimeStyle->AddHour(sal_False);
+			pTimeStyle->AddText(A2OUSTR(":"));
+			pTimeStyle->AddMinute();
+			pTimeStyle->AddText(A2OUSTR(":"));
+			pTimeStyle->SetAmPm(sal_True);		
+		}
+		else if (sFormula == A2OUSTR("%T3") || sFormula == A2OUSTR("%T7") 
+		 || sFormula == A2OUSTR("%T5") || sFormula == A2OUSTR("%T9"))
+		{
+			pTimeStyle = new XFTimeStyle;
+			pTimeStyle->AddHour();
+			pTimeStyle->AddText(A2OUSTR(":"));
+			pTimeStyle->AddMinute();
+			pTimeStyle->AddText(A2OUSTR(":"));
+			pTimeStyle->SetAmPm(sal_True);		
+		}			
+	}
+	XFStyleManager* pXFStyleManager = LwpGlobalMgr::GetInstance()->GetXFStyleManager();  
+	if (pDateStyle)
+		m_TimeStyle = pXFStyleManager->AddStyle(pDateStyle)->GetStyleName();
+	if (pTimeStyle)
+		m_TimeStyle = pXFStyleManager->AddStyle(pTimeStyle)->GetStyleName();	
+}
+
+void LwpFribField::CheckFieldType(LwpFieldMark* pFieldMark)
+{
+	sal_uInt8 nType;
+	OUString sFormula;
+	if (pFieldMark->IsDateTimeField(nType,sFormula))
+	{
+		m_nDateTimeType = nType;
+		m_sFormula = sFormula;
+		m_nSubType = SUBFIELD_DATETIME;
+	}
+	else if (pFieldMark->IsCrossRefField(nType,sFormula))
+	{
+		m_nCrossRefType = nType;
+		m_sFormula = sFormula;
+		m_nSubType = SUBFIELD_CROSSREF;
+	}
+	else if (pFieldMark->IsDocPowerField(nType,sFormula))
+	{	
+		m_nDocPowerType = nType;
+		m_nSubType = SUBFIELD_DOCPOWER;
+	}
+	else
+	{
+		m_nSubType = SUBFIELD_INVALID;
+	}
+}
+
+void LwpFribField::ConvertDocFieldStart(XFContentContainer* pXFPara,LwpFieldMark* pFieldMark)
+{
+	XFContent* pContent = NULL;
+	switch(m_nDocPowerType)
+	{
+		case LwpFieldMark::DOC_DESCRIPTION:
+		{
+			pContent = new XFDescriptionStart;
+			break;
+		}
+		case LwpFieldMark::DOC_NUMPAGES:
+		{
+			pContent = new XFPageCountStart;
+			break;			
+		}
+		case LwpFieldMark::DOC_NUMWORDS:
+		{
+			pContent = new XFWordCountStart;
+			break;
+		}
+		case LwpFieldMark::DOC_NUMCHARS:
+		{
+			pContent = new XFCharCountStart;
+			break;
+		}
+//		case LwpFieldMark::DOC_TOTALTIME:
+//		{
+//			pContent = new XFTotalEditTimeStart;
+//			pContent->SetStyleName(m_TimeStyle);			
+//			break;
+//		}
+	}
+	if (pContent)
+	{
+		if (m_ModFlag)//(m_pModifiers)
+		{
+			XFTextSpanStart* pSpan = new XFTextSpanStart;
+			pSpan->SetStyleName(GetStyleName());
+			pSpan->Add(pContent); 
+			pXFPara->Add(pSpan);	
+			pFieldMark->SetStyleFlag(sal_True);				
+		}
+		else
+			pXFPara->Add(pContent);	
+	}
+}
+
+void LwpFribField::ConvertDocFieldEnd(XFContentContainer* pXFPara,LwpFieldMark* pFieldMark)
+{
+	XFContent* pContent = NULL;
+	switch(m_nDocPowerType)
+	{
+		case LwpFieldMark::DOC_DESCRIPTION:
+		{
+			pContent = new XFDescriptionEnd;
+			break;
+		}
+		case LwpFieldMark::DOC_NUMPAGES:
+		{
+			pContent = new XFPageCountEnd;
+			break;			
+		}
+		case LwpFieldMark::DOC_NUMWORDS:
+		{
+			pContent = new XFWordCountEnd;
+			break;
+		}
+		case LwpFieldMark::DOC_NUMCHARS:
+		{
+			pContent = new XFCharCountEnd;
+			break;
+		}
+//		case LwpFieldMark::DOC_TOTALTIME:
+//		{
+//			pContent = new XFTotalEditTimeEnd;
+//			break;
+//		}
+	}
+	if (pContent)
+	{
+		if (pFieldMark->GetStyleFlag())
+		{
+			XFTextSpanEnd* pSpan = new XFTextSpanEnd;
+			pSpan->Add(pContent); 
+			pXFPara->Add(pSpan);				
+		}
+		else
+			pXFPara->Add(pContent);	
+	}	
+}
+
+void LwpFribField::ConvertDateTimeStart(XFContentContainer* pXFPara,LwpFieldMark* pFieldMark)
+{
+	XFContent* pContent = NULL;	
+	switch(m_nDateTimeType)
+	{
+	case LwpFieldMark::DATETIME_NOW:
+	{
+		pContent = new XFDateStart;
+		pContent->SetStyleName(m_TimeStyle);		
+		break;
+	}
+	case LwpFieldMark::DATETIME_CREATE:
+	{
+		pContent = new XFCreateTimeStart;
+		pContent->SetStyleName(m_TimeStyle);
+		break;				
+	}
+	case LwpFieldMark::DATETIME_LASTEDIT:
+	{
+		pContent = new XFLastEditTimeStart;
+		pContent->SetStyleName(m_TimeStyle);
+		break;				
+	}
+	case LwpFieldMark::DATETIME_TOTALTIME:
+	{
+		pContent = new XFTotalEditTimeStart;
+		pContent->SetStyleName(m_TimeStyle);										
+		break;
+	}
+	default:
+		break;
+	}
+	if (pContent)
+	{
+		if (m_ModFlag)//(m_pModifiers)
+		{
+			XFTextSpanStart* pSpan = new XFTextSpanStart;
+			pSpan->SetStyleName(GetStyleName());
+			pSpan->Add(pContent); 
+			pXFPara->Add(pSpan);
+			pFieldMark->SetStyleFlag(sal_True);
+		}
+		else
+			pXFPara->Add(pContent);	
+	}		
+	
+}
+
+void LwpFribField::ConvertDateTimeEnd(XFContentContainer* pXFPara,LwpFieldMark* pFieldMark)
+{
+	XFContent* pContent = NULL;
+	switch(m_nDateTimeType)
+	{
+		case LwpFieldMark::DATETIME_NOW:
+		{
+			pContent = new XFDateEnd;		
+			break;
+		}
+		case LwpFieldMark::DATETIME_CREATE:
+		{
+			pContent = new XFCreateTimeEnd;
+			break;				
+		}
+		case LwpFieldMark::DATETIME_LASTEDIT:
+		{
+			pContent = new XFLastEditTimeEnd;
+			break;				
+		}
+		case LwpFieldMark::DATETIME_TOTALTIME:
+		{
+			pContent = new XFTotalEditTimeEnd;						
+			break;
+		}
+	}
+	if (pContent)
+	{
+		if (pFieldMark->GetStyleFlag())
+		{
+			XFTextSpanEnd* pSpan = new XFTextSpanEnd;
+			pSpan->Add(pContent); 
+			pXFPara->Add(pSpan);			
+		}
+		else
+			pXFPara->Add(pContent);			
+	}	
+}
+
+void LwpFribField::ConvertCrossRefStart(XFContentContainer* pXFPara,LwpFieldMark* pFieldMark)
+{
+	XFCrossRefStart* pRef = new XFCrossRefStart;
+	pRef->SetRefType(m_nCrossRefType);
+	pRef->SetMarkName(m_sFormula);
+//	pFieldMark->SetStart(sal_True);//for some disnormal cases
+	if (m_ModFlag)
+	{
+		XFTextSpanStart* pSpan = new XFTextSpanStart;
+		pSpan->SetStyleName(GetStyleName());
+		pSpan->Add(pRef); 
+		pXFPara->Add(pSpan);		
+		pFieldMark->SetStyleFlag(sal_True);		
+	}
+	else
+		pXFPara->Add(pRef);		
+}
+
+void LwpFribField::ConvertCrossRefEnd(XFContentContainer* pXFPara,LwpFieldMark* pFieldMark)
+{
+	XFCrossRefEnd* pRef = new XFCrossRefEnd;
+	if (pFieldMark->GetStyleFlag())
+	{
+		XFTextSpanEnd* pSpan = new XFTextSpanEnd;
+		pSpan->Add(pRef); 
+		pXFPara->Add(pSpan);				
+	}
+	else
+		pXFPara->Add(pRef);	
+}
+
+LwpFribRubyMarker::LwpFribRubyMarker( LwpPara* pPara ): LwpFrib(pPara)
+{	
+}
+
+LwpRubyMarker* LwpFribRubyMarker::GetMarker()
+{
+	return static_cast<LwpRubyMarker*>(m_objMarker.obj(VO_RUBYMARKER));
+}
+
+void LwpFribRubyMarker::Read(LwpObjectStream* pObjStrm, sal_uInt16 len)
+{
+	m_objMarker.ReadIndexed(pObjStrm);
+	m_nType = pObjStrm->QuickReaduInt8();
+}
+
+void LwpFribRubyMarker::XFConvert(XFContentContainer* pXFPara)
+{
+	sal_uInt8 type = GetType();
+	LwpRubyMarker* pMarker = GetMarker();
+	
+	if (type == MARKER_START)
+	{
+		XFRubyStart* pRubyStart = new XFRubyStart;
+		if (pMarker)
+		{
+			pRubyStart->SetStyleName(pMarker->GetRubyStyleName());	
+		}
+		pXFPara->Add(pRubyStart);		
+	}
+	else if(type == MARKER_END)
+	{
+		XFRubyEnd* pRubyEnd = new XFRubyEnd;
+		if (pMarker)
+		{
+			pRubyEnd->SetText(pMarker->GetRubyText());
+			pRubyEnd->SetStyleName(pMarker->GetTextStyleName());			
+		}
+		pXFPara->Add(pRubyEnd);
+	}
+}
+
+void LwpFribRubyMarker::RegisterStyle(LwpFoundry* pFoundry)
+{
+}
+
+					
diff -urNp lotuswordpro.bak/source/filter/lwpfribmark.hxx lotuswordpro/source/filter/lwpfribmark.hxx
--- lotuswordpro.bak/source/filter/lwpfribmark.hxx	1970-01-01 08:00:00.000000000 +0800
+++ lotuswordpro/source/filter/lwpfribmark.hxx	2008-10-22 11:42:29.000000000 +0800
@@ -0,0 +1,165 @@
+/*************************************************************************
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: IBM Corporation
+ *
+ *  Copyright: 2008 by IBM Corporation
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+/*************************************************************************
+ * @file 
+ *  For LWP filter architecture prototype
+ ************************************************************************/
+/*************************************************************************
+ * Change History
+ May 2005			Created
+ ************************************************************************/
+ 
+
+#ifndef _LWPFRIBMARKER_HXX_
+#define _LWPFRIBMARKER_HXX_
+
+#include "lwpfrib.hxx"
+#include "lwpstory.hxx"
+#include "lwpmarker.hxx"
+#include "xfilter/xftextspan.hxx"
+#include "xfilter/xfbookmark.hxx"
+
+class LwpFribCHBlock : public LwpFrib
+{
+public:
+	LwpFribCHBlock( LwpPara* pPara ) : LwpFrib(pPara){};
+	~LwpFribCHBlock(){};
+	void Read(LwpObjectStream* pObjStrm, sal_uInt16 len);
+	LwpCHBlkMarker* GetMarker();
+	sal_uInt8 GetType(){return m_nType;}
+	enum{MARKER_START=1,MARKER_END,MARKER_NONE};	
+	void XFConvert(XFContentContainer* pXFPara,LwpStory* pStory);
+private:
+	sal_uInt8 m_nType;
+	LwpObjectID m_objMarker;
+};
+
+class LwpFribBookMark : public LwpFrib
+{
+public:
+	LwpFribBookMark( LwpPara* pPara );
+	~LwpFribBookMark(){};
+	void Read(LwpObjectStream* pObjStrm, sal_uInt16 len);
+	LwpObjectID GetMarkerID(){return m_objMarker;}
+	sal_uInt8 GetType(){return m_nType;}
+	enum{MARKER_START=1,MARKER_END,MARKER_NONE};
+	void XFConvert(XFContentContainer* pXFPara);
+	void RegisterStyle(LwpFoundry* pFoundry);
+private:
+	sal_uInt8 m_nType;
+	LwpObjectID m_objMarker;
+	XFBookmarkStart* m_pStart;
+	XFBookmarkEnd* m_pEnd;	
+};
+
+class LwpFribField : public LwpFrib
+{
+public:
+	LwpFribField( LwpPara* pPara );
+	~LwpFribField(){};
+	void Read(LwpObjectStream* pObjStrm, sal_uInt16 len);
+	LwpFieldMark* GetMarker();
+	sal_uInt8 GetType(){return m_nType;}
+	enum{MARKER_START=1,MARKER_END,MARKER_NONE};
+	void XFConvert(XFContentContainer* pXFPara);
+	void RegisterStyle(LwpFoundry* pFoundry);
+	enum{
+		SUBFIELD_INVALID = 0,
+		SUBFIELD_DATETIME = 1,
+		SUBFIELD_CROSSREF = 2,
+		SUBFIELD_DOCPOWER = 3,
+	};
+private:
+	sal_uInt8 m_nType;
+	LwpObjectID m_objMarker;
+	OUString m_TimeStyle;
+	
+	sal_uInt8 m_nSubType;//datetime/crossref/other
+	OUString m_sFormula;
+	
+	sal_uInt8 m_nCrossRefType;
+	sal_uInt8 m_nDateTimeType;
+	sal_uInt8 m_nDocPowerType;
+	
+	void RegisterTimeField(LwpFieldMark* pFieldMark);	
+	void RegisterDateTimeStyle(OUString sFormula);
+	void RegisterTotalTimeStyle();
+	void CheckFieldType(LwpFieldMark* pFieldMark);
+	void ConvertDocFieldStart(XFContentContainer* pXFPara,LwpFieldMark* pFieldMark);
+	void ConvertDocFieldEnd(XFContentContainer* pXFPara,LwpFieldMark* pFieldMark);
+	void ConvertDateTimeStart(XFContentContainer* pXFPara,LwpFieldMark* pFieldMark);
+	void ConvertDateTimeEnd(XFContentContainer* pXFPara,LwpFieldMark* pFieldMark);
+	void ConvertCrossRefEnd(XFContentContainer* pXFPara,LwpFieldMark* pFieldMark);
+	void ConvertCrossRefStart(XFContentContainer* pXFPara,LwpFieldMark* pFieldMark);
+};
+
+class LwpFribRubyMarker : public LwpFrib
+{
+public:
+	LwpFribRubyMarker( LwpPara* pPara );
+	~LwpFribRubyMarker(){};
+	void Read(LwpObjectStream* pObjStrm, sal_uInt16 len);
+	LwpRubyMarker* GetMarker();
+	sal_uInt8 GetType(){return m_nType;}
+	enum{MARKER_START=1,MARKER_END,MARKER_NONE};
+	void XFConvert(XFContentContainer* pXFPara);
+	void RegisterStyle(LwpFoundry* pFoundry);
+private:
+	sal_uInt8 m_nType;
+	LwpObjectID m_objMarker;	
+};
+
+#endif
+
diff -urNp lotuswordpro.bak/source/filter/lwpfribptr.cxx lotuswordpro/source/filter/lwpfribptr.cxx
--- lotuswordpro.bak/source/filter/lwpfribptr.cxx	1970-01-01 08:00:00.000000000 +0800
+++ lotuswordpro/source/filter/lwpfribptr.cxx	2008-10-22 11:42:29.000000000 +0800
@@ -0,0 +1,689 @@
+/*************************************************************************
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: IBM Corporation
+ *
+ *  Copyright: 2008 by IBM Corporation
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+/*************************************************************************
+ * @file 
+ *  For LWP filter architecture prototype
+ ************************************************************************/
+/*************************************************************************
+ * Change History
+ Jan 2005			Created
+ ************************************************************************/
+ 
+#include "lwpfribptr.hxx"
+
+#include "lwpfribheader.hxx"
+#include "lwpfribtext.hxx"
+#include "lwppara.hxx"
+#include "lwpstory.hxx"
+#include "xfilter/xftextspan.hxx"
+#include "xfilter/xftextcontent.hxx"
+#include "xfilter/xftabstop.hxx"
+#include "xfilter/xflinebreak.hxx"
+#include "lwpfribsection.hxx"
+#include "lwpsection.hxx"
+#include "lwpfribbreaks.hxx"
+#include "lwpfribframe.hxx"
+#include "lwpfribtable.hxx"
+#include "xfilter/xfstylemanager.hxx"
+#include "lwphyperlinkmgr.hxx"
+#include "xfilter/xfhyperlink.hxx"
+#include "lwpfootnote.hxx"
+#include "lwpnotes.hxx"
+#include "lwpfribmark.hxx"
+#include "xfilter/xfchange.hxx"
+#include "lwpchangemgr.hxx"
+#include "lwpglobalmgr.hxx"
+
+
+LwpFribPtr::LwpFribPtr()
+	: m_pFribs(NULL),m_pPara(NULL),m_pXFPara(NULL)
+{}
+
+LwpFribPtr::~LwpFribPtr()
+{
+	LwpFrib* pNextFrib = m_pFribs;
+	LwpFrib* pCurFrib = m_pFribs;
+	while(pCurFrib)
+	{
+		pNextFrib = pCurFrib -> GetNext();
+		delete pCurFrib;
+		pCurFrib = pNextFrib;
+	}
+}
+
+void LwpFribPtr::ReadPara(LwpObjectStream* pObjStrm)
+{
+	sal_uInt8 FribTag=0;
+	sal_uInt8 FribType;
+	sal_uInt8 FribEditor;
+	BOOL ProblemFrib;
+
+	LwpFrib* pCurFrib = m_pFribs = NULL;
+	for(;;)
+	{
+		ProblemFrib = FALSE;
+		// Get the frib type
+		pObjStrm->QuickRead(&FribTag, sizeof(FribTag));
+
+		FribType = FribTag & ~FRIB_TAG_TYPEMASK;
+		
+		// Stop when we hit Elvis
+		if (FribType == FRIB_TAG_ELVIS)
+			break;
+
+		// skip the editor ID
+		//pObjStrm->SeekRel(sizeof(sal_uInt8));
+ 		pObjStrm->QuickRead(&FribEditor, sizeof(FribEditor));
+		if( FribType != FT_MAXIMUM )
+		{
+			LwpFrib* pFrib = LwpFrib::CreateFrib( m_pPara, pObjStrm, FribTag,FribEditor);
+			if(!m_pFribs)
+			{
+				m_pFribs = pFrib;
+			}
+			if(pCurFrib)
+			{
+				pCurFrib->SetNext(pFrib);
+			}
+			else//frist frib in the para,add by  2/1
+			{
+				if (pFrib->GetType() == FRIB_TAG_TEXT)
+				{
+					LwpFribText* pText = static_cast<LwpFribText*>(pFrib);
+					if (pFrib->GetModifiers())
+						m_pPara->SetFirstFrib(pText->GetText(),pText->GetModifiers()->FontID);
+					else
+						m_pPara->SetFirstFrib(pText->GetText(),0);					
+				}
+			}
+			pCurFrib = pFrib;
+		}
+		else
+			ProblemFrib = TRUE;
+	}
+}
+
+/*String LwpFribPtr::GetText()
+{
+	LwpFrib* pFrib = m_pFribs;
+	String content;
+	while(pFrib)
+	{
+		if(pFrib->GetType() == FRIB_TAG_TEXT)
+		{
+			content+= static_cast<LwpFribText*>(pFrib)->GetText();	
+		}
+		pFrib = pFrib->GetNext();
+	}
+	return (content);
+}*/
+
+#include "lwpdropcapmgr.hxx"
+void LwpFribPtr::XFConvert()
+{  	            
+	LwpFrib* pFrib = m_pFribs;
+	while(pFrib)
+	{
+		sal_uInt8 nFribType = pFrib->GetType();
+		sal_Bool bRevisionFlag = pFrib->GetRevisionFlag();
+		sal_uInt8 nRevisionType;
+		OUString sChangeID;
+		if (bRevisionFlag)
+		{
+			if ( nFribType!= FRIB_TAG_TABLE && nFribType != FRIB_TAG_FIELD 
+					&& nFribType != FRIB_TAG_FRAME)
+			{
+				nRevisionType = pFrib->GetRevisionType();
+				LwpGlobalMgr* pGlobal = LwpGlobalMgr::GetInstance(); 
+				LwpChangeMgr* pChangeMgr = pGlobal->GetLwpChangeMgr();
+				sChangeID = pChangeMgr->GetChangeID(pFrib);
+				if (sChangeID.getLength())
+				{	
+				///	if (nRevisionType == LwpFrib::REV_INSERT)
+				///	{
+						XFChangeStart* pChangeStart = new XFChangeStart;
+						pChangeStart->SetChangeID(sChangeID);
+						m_pXFPara->Add(pChangeStart);
+				///	}
+				///	else if (nRevisionType == LwpFrib::REV_DELETE)
+				///	{
+				///		XFChange* pChange = new XFChange;
+				///		pChange->SetChangeID(sChangeID);
+				///		m_pXFPara->Add(pChange);
+				///		pFrib = pFrib->GetNext();
+				///		continue;
+				///	}
+				}
+			}
+		}
+	
+        	switch(nFribType)
+        	{
+		case FRIB_TAG_TEXT:
+		{
+			LwpFribText* textFrib= static_cast<LwpFribText*>(pFrib);
+			textFrib->XFConvert(m_pXFPara,m_pPara->GetStory());
+		}
+		    break;
+		case FRIB_TAG_TAB:
+		{
+			LwpFribTab* tabFrib = static_cast<LwpFribTab*>(pFrib);
+			if (pFrib->m_ModFlag)
+			{	
+				XFTextSpan *pSpan = new XFTextSpan();
+				pSpan->SetStyleName(tabFrib->GetStyleName());
+				XFTabStop *pTab = new XFTabStop();
+				pSpan->Add(pTab);               
+				m_pXFPara->Add(pSpan); 
+			}    
+			else
+			{
+				XFTabStop *pTab = new XFTabStop();
+				m_pXFPara->Add(pTab);               
+			}	
+		}	    
+		    break;
+		case FRIB_TAG_SECTION:
+		{
+			LwpFribSection* pSectionFrib = static_cast<LwpFribSection*>(pFrib);			
+			pSectionFrib->ParseSection();	
+		}
+		break;
+
+		case FRIB_TAG_PAGEBREAK:
+		{
+			LwpFribPageBreak* pPageBreak = static_cast<LwpFribPageBreak*>(pFrib);
+			LwpPageLayout* pLayout = static_cast<LwpPageLayout*>(pPageBreak->GetLayout()->obj());
+			if(pLayout)
+			{							
+				pPageBreak->ParseLayout();
+			}
+			else
+			{
+				if (pPageBreak->IsLastFrib() == sal_True)
+				{
+					m_pXFPara->SetStyleName( pPageBreak->GetStyleName() );
+				}
+				else
+				{
+					//parse pagebreak
+					XFParagraph *pPara = new XFParagraph();
+					pPara->SetStyleName(pFrib->GetStyleName());	
+					SetXFPara(pPara);
+					m_pPara->AddXFContent(pPara);
+				}
+			}		
+		}
+			break;
+		case FRIB_TAG_COLBREAK:
+		{
+			XFParagraph *pPara = new XFParagraph();
+			pPara->SetStyleName(pFrib->GetStyleName());	
+			SetXFPara(pPara);
+			m_pPara->AddXFContent(pPara);
+		}
+			break;	
+		case FRIB_TAG_LINEBREAK:
+		{
+			XFLineBreak *pLineBreak = new XFLineBreak();
+			m_pXFPara->Add(pLineBreak);  			
+		}
+			break;	
+		case FRIB_TAG_UNICODE: //fall through
+		case FRIB_TAG_UNICODE2: //fall through
+		case FRIB_TAG_UNICODE3: //fall through
+		{
+			LwpFribUnicode* unicodeFrib= static_cast<LwpFribUnicode*>(pFrib);
+			unicodeFrib->XFConvert(m_pXFPara,m_pPara->GetStory());
+		}
+			break;
+		case FRIB_TAG_HARDSPACE:
+		{
+			rtl::OUString sHardSpace(sal_Unicode(0x00a0));
+			LwpHyperlinkMgr* pHyperlink = 
+					m_pPara->GetStory()->GetHyperlinkMgr();
+			if (pHyperlink->GetHyperlinkFlag())
+				pFrib->ConvertHyperLink(m_pXFPara,pHyperlink,sHardSpace);
+			else
+				pFrib->ConvertChars(m_pXFPara,sHardSpace);
+		}
+			break;
+		case FRIB_TAG_SOFTHYPHEN:
+		{
+			rtl::OUString sSoftHyphen(sal_Unicode(0x00ad));
+			pFrib->ConvertChars(m_pXFPara,sSoftHyphen);
+		}
+			break;
+		case FRIB_TAG_FRAME:
+		{
+			LwpFribFrame* frameFrib= static_cast<LwpFribFrame*>(pFrib);
+			LwpObject* pLayout = frameFrib->GetLayout();
+			if (pLayout->GetTag() == VO_DROPCAPLAYOUT)
+			{
+				m_pPara->GetFoundry()->GetDropcapMgr()->SetXFPara(m_pXFPara); 
+				//LwpObject* pDropCap = frameFrib->GetLayout();
+				//pDropCap ->XFConvert(m_pXFPara);
+			}
+			//pLayout->XFConvert(m_pXFPara);
+			frameFrib->XFConvert(m_pXFPara);
+		}
+			break;
+		case FRIB_TAG_CHBLOCK:
+		{
+			LwpFribCHBlock* chbFrib = static_cast<LwpFribCHBlock*>(pFrib);
+			chbFrib->XFConvert(m_pXFPara,m_pPara->GetStory());
+		}
+			break;
+		case FRIB_TAG_TABLE:
+		{
+			LwpFribTable* tableFrib = static_cast<LwpFribTable*>(pFrib);
+			//tableFrib->XFConvert(m_pPara->GetXFContainer());
+			tableFrib->XFConvert(m_pXFPara);
+		}
+			break;
+		case FRIB_TAG_BOOKMARK:
+		{
+			LwpFribBookMark* bookmarkFrib = static_cast<LwpFribBookMark*>(pFrib);
+			bookmarkFrib->XFConvert(m_pXFPara);
+		}
+		break;	
+		case FRIB_TAG_FOOTNOTE:
+		{			
+			LwpFribFootnote* pFootnoteFrib = static_cast<LwpFribFootnote*>(pFrib);
+			pFootnoteFrib->XFConvert(m_pXFPara); 
+			break;
+		}
+		case FRIB_TAG_FIELD:
+		{
+			LwpFribField* fieldFrib = static_cast<LwpFribField*>(pFrib);
+			fieldFrib->XFConvert(m_pXFPara); 		
+			break;
+		}
+		case FRIB_TAG_NOTE:
+		{
+			LwpFribNote* pNoteFrib = static_cast<LwpFribNote*>(pFrib);
+			pNoteFrib->XFConvert(m_pXFPara); 
+			break;
+		}
+		case FRIB_TAG_PAGENUMBER:
+		{
+			LwpFribPageNumber* pagenumFrib = static_cast<LwpFribPageNumber*>(pFrib);
+			pagenumFrib->XFConvert(m_pXFPara); 
+			break;
+		}
+		case FRIB_TAG_DOCVAR:
+		{
+			LwpFribDocVar* docFrib = static_cast<LwpFribDocVar*>(pFrib);
+			docFrib->XFConvert(m_pXFPara); 
+			break;
+		}
+		case FRIB_TAG_RUBYMARKER:
+		{
+			LwpFribRubyMarker* rubyFrib = static_cast<LwpFribRubyMarker*>(pFrib);
+			rubyFrib->XFConvert(m_pXFPara); 
+			break;
+		}
+		case FRIB_TAG_RUBYFRAME:
+		{
+			LwpFribRubyFrame* rubyfrmeFrib = static_cast<LwpFribRubyFrame*>(pFrib);
+			rubyfrmeFrib->XFConvert(m_pXFPara); 
+			break;
+		}
+		default :
+			break;
+		}
+
+		if (bRevisionFlag )//&& pFrib->GetRevisionType() == LwpFrib::REV_INSERT)
+		{
+			if (nFribType!= FRIB_TAG_TABLE && nFribType != FRIB_TAG_FIELD 
+					&& nFribType != FRIB_TAG_FRAME)
+			{
+				if (sChangeID.getLength())
+				{
+					XFChangeEnd* pChangeEnd = new XFChangeEnd;
+					pChangeEnd->SetChangeID(sChangeID);
+					m_pXFPara->Add(pChangeEnd);
+				}
+			}
+		}		
+		pFrib = pFrib->GetNext();
+	}
+
+}
+
+void LwpFribPtr::FindLayouts()
+{
+	LwpFrib* pFrib = m_pFribs;
+	while(pFrib)
+	{
+		switch(pFrib->GetType())
+        {
+			case FRIB_TAG_SECTION:
+			{
+				LwpFribSection* pSectionFrib = static_cast<LwpFribSection*>(pFrib);
+				LwpSection* pSection = pSectionFrib->GetSection();				
+				if(pSection)
+				{
+					LwpPageLayout* pLayout = pSection->GetPageLayout();
+					if(pLayout)
+					{
+						LwpLayout::UseWhenType eSectionType = pLayout->GetUseWhenType();
+						if(eSectionType==LwpLayout::StartWithinColume)
+						{
+							//StartWithinColume type not support now
+							break;
+						}
+						LwpStory* pStory = static_cast<LwpStory*>(m_pPara->GetStoryID()->obj());
+						pStory->AddPageLayout(pSection->GetPageLayout());
+					}
+				}
+				
+				break;
+			}
+			case FRIB_TAG_PAGEBREAK:
+			{
+				LwpFribPageBreak* pPageBreak = static_cast<LwpFribPageBreak*>(pFrib);
+				LwpPageLayout* pLayout = static_cast<LwpPageLayout*>(pPageBreak->GetLayout()->obj());
+				if(pLayout)
+				{
+					LwpStory* pStory = static_cast<LwpStory*>(m_pPara->GetStoryID()->obj());
+					pStory->AddPageLayout(pLayout);
+				}
+				break;
+			}
+			default:
+				break;
+		}
+		pFrib = pFrib->GetNext();
+	}
+}
+/**************************************************************************
+ * @descr:  Whether has a frib which type is nType
+ * @param:   
+ * @param:   
+ * @return:  
+**************************************************************************/
+LwpFrib* LwpFribPtr::HasFrib(sal_uInt8 nType)
+{
+	LwpFrib* pFrib = m_pFribs;
+	while(pFrib)
+	{
+		if(pFrib->GetType()==nType)
+		{
+			return pFrib;
+		}
+		pFrib = pFrib->GetNext();
+	}
+	return NULL;
+}
+
+void LwpFribPtr::GatherAllText()
+{
+	LwpFrib* pFrib = m_pFribs;
+	while(pFrib)
+	{
+        switch(pFrib->GetType())
+        {
+		case FRIB_TAG_TEXT:
+		{
+			OUString sText = static_cast<LwpFribText*>(pFrib)->GetText();
+			m_pPara->SetAllText(sText);
+			break;
+		}
+		case FRIB_TAG_UNICODE: //fall through
+		case FRIB_TAG_UNICODE2: //fall through
+		case FRIB_TAG_UNICODE3: //fall through	:
+		{
+			OUString sText = static_cast<LwpFribText*>(pFrib)->GetText();
+			m_pPara->SetAllText(sText);	
+			break;
+		}
+		default :
+			break;
+	}		
+		pFrib = pFrib->GetNext();	
+	}
+}
+
+void LwpFribPtr::RegisterStyle()
+{ 
+	LwpFrib* pFrib = m_pFribs;
+	while(pFrib)
+	{
+        switch(pFrib->GetType())
+        {
+		case FRIB_TAG_TEXT:
+		{
+			pFrib->RegisterStyle(m_pPara->GetFoundry());
+			OUString sText = static_cast<LwpFribText*>(pFrib)->GetText();
+			ProcessDropcap(m_pPara->GetStory(), pFrib,sText.getLength());
+			break;
+		}
+		case FRIB_TAG_TAB:
+			pFrib->RegisterStyle(m_pPara->GetFoundry());		
+		    break;
+		case FRIB_TAG_SECTION:
+			{
+				//section registerstyle here;
+				LwpFribSection* pSectionFrib = static_cast<LwpFribSection*>(pFrib);
+				pSectionFrib->RegisterSectionStyle();
+				//for bullet
+				pSectionFrib->SetSectionName();				
+			}			
+			break;
+		case FRIB_TAG_PAGEBREAK:
+		{
+			LwpFribPageBreak* breakFrib = static_cast<LwpFribPageBreak*>(pFrib);
+			breakFrib->RegisterBreakStyle(m_pPara);
+		}	
+			break;
+		case FRIB_TAG_COLBREAK:
+		{
+			LwpFribColumnBreak* breakFrib = static_cast<LwpFribColumnBreak*>(pFrib);
+			breakFrib->RegisterBreakStyle(m_pPara);				
+		}
+			break;
+		case FRIB_TAG_UNICODE: //fall through
+		case FRIB_TAG_UNICODE2: //fall through
+		case FRIB_TAG_UNICODE3: //fall through	:
+		{
+			pFrib->RegisterStyle(m_pPara->GetFoundry());	
+			OUString sText = static_cast<LwpFribUnicode*>(pFrib)->GetText();
+			ProcessDropcap(m_pPara->GetStory(), pFrib,sText.getLength());	
+		    break;
+		}
+		case FRIB_TAG_HARDSPACE:
+			pFrib->RegisterStyle(m_pPara->GetFoundry());
+			ProcessDropcap(m_pPara->GetStory(),pFrib,1);			
+			break;
+		case FRIB_TAG_SOFTHYPHEN:
+			pFrib->RegisterStyle(m_pPara->GetFoundry());
+			break;
+		case FRIB_TAG_FRAME:
+		{
+			LwpFribFrame* frameFrib = static_cast<LwpFribFrame*>(pFrib);
+			frameFrib->SetParaDropcap(m_pPara); 
+			frameFrib->RegisterStyle(m_pPara->GetFoundry());
+			//register framelayout style, ,03/09/2005
+			//frameFrib->GetLayout()->RegisterStyle();
+                }
+                	break;  
+                case FRIB_TAG_CHBLOCK:
+                	break;
+                case FRIB_TAG_TABLE:
+                {
+                	LwpFribTable* tableFrib = static_cast<LwpFribTable*>(pFrib);
+                	tableFrib->RegisterStyle();
+                }
+                	break;
+		case FRIB_TAG_FOOTNOTE:	
+		{
+			LwpFribFootnote* pFribFootnote = static_cast<LwpFribFootnote*>(pFrib);
+			pFribFootnote->RegisterStyle();
+		}					
+			break;
+		case FRIB_TAG_NOTE:
+		{
+			LwpFribNote* pNoteFrib = static_cast<LwpFribNote*>(pFrib);
+			pNoteFrib->RegisterStyle(); 
+			break;
+		}
+		case FRIB_TAG_PAGENUMBER:
+		{
+			pFrib->RegisterStyle(m_pPara->GetFoundry());
+			break;
+		}
+		case FRIB_TAG_DOCVAR:
+		{
+			LwpFribDocVar* docFrib = static_cast<LwpFribDocVar*>(pFrib);
+			docFrib->RegisterStyle(m_pPara->GetFoundry()); 
+			break;
+		}
+		case FRIB_TAG_FIELD:
+		{
+			LwpFribField* fieldFrib = static_cast<LwpFribField*>(pFrib);
+			fieldFrib->RegisterStyle(m_pPara->GetFoundry());  		
+			break;
+		}
+		case FRIB_TAG_BOOKMARK:
+		{
+			LwpFribBookMark* bookmarkFrib = static_cast<LwpFribBookMark*>(pFrib);
+			bookmarkFrib->RegisterStyle(m_pPara->GetFoundry());			
+			break;
+		}
+		case FRIB_TAG_RUBYFRAME:
+		{
+			LwpFribRubyFrame* rubyfrmeFrib = static_cast<LwpFribRubyFrame*>(pFrib);
+			rubyfrmeFrib->RegisterStyle(m_pPara->GetFoundry()); 
+			break;
+		}
+		default :
+			break;
+		}
+		if (pFrib->GetRevisionFlag() && pFrib->GetType()!= FRIB_TAG_FIELD)
+		{
+			LwpGlobalMgr* pGlobal = LwpGlobalMgr::GetInstance(); 
+			LwpChangeMgr* pChangeMgr = pGlobal->GetLwpChangeMgr();
+			pChangeMgr->AddChangeFrib(pFrib);
+		}
+			
+		pFrib = pFrib->GetNext();
+	}
+}
+
+void LwpFribPtr::ProcessDropcap(LwpStory* pStory,LwpFrib* pFrib,sal_uInt32 nLen)
+{
+	if (pStory)
+	{
+		if (pStory->GetDropcapFlag() == sal_True)
+		{
+			XFStyleManager* pXFStyleManager = LwpGlobalMgr::GetInstance()->GetXFStyleManager();
+			XFTextStyle* pFribStyle = pXFStyleManager->FindTextStyle(pFrib->GetStyleName());
+			pFribStyle->GetFont()->SetFontSize(0);
+
+			LwpObject*  pObj= pStory->GetLayoutsWithMe()->GetOnlyLayout()->obj();
+			if (pObj)
+				static_cast<LwpDropcapLayout*>(pObj)->SetChars(nLen);
+		}		
+	}
+}
+/**
+ * @descr:  If the position of pPreLayout is earlier than pNextLayout, return true, or return false, defalut return true
+ * 
+*/
+sal_Bool LwpFribPtr::ComparePagePosition(LwpVirtualLayout* pPreLayout, LwpVirtualLayout* pNextLayout)
+{
+	if(!pPreLayout || !pNextLayout)
+		return sal_True;
+	
+	LwpFrib* pFrib = m_pFribs;
+	LwpVirtualLayout* pLayout = NULL;
+	while(pFrib)
+	{
+		switch(pFrib->GetType())
+        	{
+			case FRIB_TAG_SECTION:
+			{
+				LwpFribSection* pSectionFrib = static_cast<LwpFribSection*>(pFrib);
+				LwpSection* pSection = pSectionFrib->GetSection();				
+				if(pSection)
+				{
+					pLayout = pSection->GetPageLayout();
+				}
+				
+				break;
+			}
+			case FRIB_TAG_PAGEBREAK:
+			{
+				LwpFribPageBreak* pPageBreak = static_cast<LwpFribPageBreak*>(pFrib);				
+				pLayout = static_cast<LwpVirtualLayout*>(pPageBreak->GetLayout()->obj());				
+				break;
+			}
+			default:
+				break;
+		}
+
+		if(pLayout)
+		{
+			if(pPreLayout == pLayout)
+				return sal_True;
+			if(pNextLayout == pLayout)
+				return sal_False;
+		}				
+		pFrib = pFrib->GetNext();
+	}
+
+	return sal_True;
+}
diff -urNp lotuswordpro.bak/source/filter/lwpfribptr.hxx lotuswordpro/source/filter/lwpfribptr.hxx
--- lotuswordpro.bak/source/filter/lwpfribptr.hxx	1970-01-01 08:00:00.000000000 +0800
+++ lotuswordpro/source/filter/lwpfribptr.hxx	2008-10-22 11:42:29.000000000 +0800
@@ -0,0 +1,100 @@
+/*************************************************************************
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: IBM Corporation
+ *
+ *  Copyright: 2008 by IBM Corporation
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+/*************************************************************************
+ * @file 
+ *  For LWP filter architecture prototype
+ ************************************************************************/
+/*************************************************************************
+ * Change History
+ Jan 2005			Created
+ ************************************************************************/
+
+#ifndef _LWPFRIBPTR_HXX_
+#define _LWPFRIBPTR_HXX_
+
+#include "lwpobjstrm.hxx"
+#include "lwpfrib.hxx"
+#include "lwpstory.hxx"
+#include "xfilter/xfparagraph.hxx"
+
+class LwpPara;
+class LwpFribPtr
+{
+public:
+	LwpFribPtr();
+	~LwpFribPtr();
+	void ReadPara(LwpObjectStream* pObjStrm);
+private:
+//	void ReadModifiers(LwpObjectStream* pObjStrm,ModifierInfo* pModInfo);
+	LwpFrib* m_pFribs;
+	XFParagraph* m_pXFPara;//for parse ,add by 1-17	//Current XFPara used for frib parsing
+	LwpPara* m_pPara;//for get foundry, add by 1-17
+	void ProcessDropcap(LwpStory* pStory,LwpFrib* pFrib,sal_uInt32 nLen);
+public:
+//	String GetText();
+	void XFConvert();
+	void SetXFPara(XFParagraph* Para){m_pXFPara = Para;};
+	XFParagraph* GetXFPara(){return m_pXFPara;};
+	void SetPara(LwpPara* para){m_pPara=para;};
+	LwpPara* GetPara(){return m_pPara;};
+	void RegisterStyle();	
+	void FindLayouts();// for register pagelayout, add by , 02/20/2005
+	LwpFrib* GetFribs(){return m_pFribs;}
+	LwpFrib* HasFrib(sal_uInt8 nType);
+	sal_Bool ComparePagePosition(LwpVirtualLayout* pPreLayout, LwpVirtualLayout* pNextLayout);
+	void GatherAllText();
+};
+
+#endif
diff -urNp lotuswordpro.bak/source/filter/lwpfribsection.cxx lotuswordpro/source/filter/lwpfribsection.cxx
--- lotuswordpro.bak/source/filter/lwpfribsection.cxx	1970-01-01 08:00:00.000000000 +0800
+++ lotuswordpro/source/filter/lwpfribsection.cxx	2008-10-22 11:42:29.000000000 +0800
@@ -0,0 +1,470 @@
+/*************************************************************************
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: IBM Corporation
+ *
+ *  Copyright: 2008 by IBM Corporation
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+/*************************************************************************
+ * @file 
+ *  the class for section frib and process section and page layout
+ ************************************************************************/
+/*************************************************************************
+ * Change History
+Jan 2005		Created
+ ************************************************************************/
+#include "lwpfribsection.hxx"
+#include "lwpfribbreaks.hxx"
+#include "lwpstory.hxx"
+#include "lwpsection.hxx"
+#include "xfilter/xfstylemanager.hxx"
+#include "xfilter/xfsectionstyle.hxx"
+#include "xfilter/xfsection.hxx"
+#include "xfilter/xfindex.hxx"
+#include "lwpfribptr.hxx"
+#include "lwpglobalmgr.hxx"
+
+LwpFribSection::LwpFribSection(LwpPara *pPara)
+	 : LwpFrib(pPara),m_pMasterPage(NULL)
+{
+		
+}
+
+LwpFribSection::~LwpFribSection()
+{
+	if(m_pMasterPage)
+	{
+		delete m_pMasterPage;
+		m_pMasterPage = NULL;
+	}
+}
+
+/**
+ * @descr:	Read section frib information   
+ * 
+ */
+void LwpFribSection::Read(LwpObjectStream *pObjStrm, sal_uInt16 len)
+{
+	m_Section.ReadIndexed(pObjStrm);
+}
+
+/**
+ * @descr:	Get section pointer  
+ * 
+ */
+LwpSection* LwpFribSection::GetSection()
+{
+	return static_cast<LwpSection*>(m_Section.obj());
+}
+
+/**
+ * @descr:	Register section style 
+ * 
+ */
+void LwpFribSection::RegisterSectionStyle()
+{	
+	LwpPageLayout* pLayout = GetPageLayout();
+	if(pLayout)
+	{
+		m_pMasterPage = new LwpMasterPage(m_pPara, pLayout);	
+		m_pMasterPage->RegisterMasterPage(this);		
+	}
+}
+
+/**
+ * @descr:	Register section style 
+ * 
+ */
+void LwpFribSection::SetSectionName()
+{
+	LwpSection* pSection = GetSection();
+	if(pSection)
+	{
+		LwpStory* pStory = static_cast<LwpStory*>(m_pPara->GetStoryID()->obj());
+		pStory->SetSectionName(pSection->GetSectionName());
+	}	
+}
+
+/**
+ * @descr:	Get page layout that current section points
+ * 
+ */
+LwpPageLayout* LwpFribSection::GetPageLayout()
+{				
+	if(GetSection())
+		return GetSection()->GetPageLayout();	
+	return NULL;	
+}
+
+/**
+ * @descr:	XFConvert section
+ * 
+ */
+void LwpFribSection::ParseSection()
+{	
+	LwpPageLayout* pLayout = GetPageLayout();
+	if(pLayout)
+	{
+		// StartWithinColume not support now
+		LwpLayout::UseWhenType eSectionType = pLayout->GetUseWhenType();
+		if(eSectionType==LwpLayout::StartWithinColume)
+		{
+			return;
+		}
+		if(m_pMasterPage)
+		{
+			m_pMasterPage->ParseSection(this);
+		}
+	}
+	else
+	{
+		LwpStory* pStory = static_cast<LwpStory*> ( m_pPara->GetStoryID()->obj() );
+		if (m_Section.obj()->GetTag() == VO_INDEXSECTION)
+		{
+			sal_Bool bRunin = sal_False;
+			sal_Bool bSeparator = sal_False;
+			//create a new section and add it to container
+			XFIndex* pIndex = new XFIndex;
+			pIndex->SetIndexType(enumXFIndexAlphabetical);
+			/*
+			LwpIndexSection* pIndexSection = static_cast<LwpIndexSection*>(m_Section.obj());
+			if (pIndexSection->IsFormatRunin())
+				bRunin = sal_True;
+			if (pIndexSection->IsFormatSeparator())
+				bSeparator = sal_True;
+			pIndex->SetDefaultAlphaIndex(A2OUSTR(""),bRunin,bSeparator);
+			*/
+			SetDefaultAlphaIndex(pIndex);
+					
+			pStory->AddXFContent( pIndex );	
+			m_pPara->SetXFContainer( pIndex );						
+		}
+		else
+		{
+			XFContentContainer* pContent = pStory->GetXFContent();	
+			m_pPara->SetXFContainer( pContent );	
+		}
+	}	
+}
+
+void LwpFribSection::SetDefaultAlphaIndex(XFIndex * pXFIndex)
+{
+	LwpFoundry* pFoundry = m_pPara->GetFoundry();
+	OUString styleName = pFoundry->FindActuralStyleName(A2OUSTR("Separator"));	
+	
+	LwpIndexSection* pIndexSection = static_cast<LwpIndexSection*>(m_Section.obj());
+	XFIndexTemplate * pTemplateSep = new XFIndexTemplate();
+	if (pIndexSection->IsFormatSeparator())
+	{
+		pXFIndex->SetSeparator(sal_True);
+		pTemplateSep->AddEntry(enumXFIndexTemplateText,A2OUSTR(""));
+	}
+	//pXFIndex->AddTemplate(A2OUSTR("separator"),A2OUSTR("Separator"),pTemplateSep);
+	pXFIndex->AddTemplate(A2OUSTR("separator"),styleName,pTemplateSep);
+
+	
+	styleName = pFoundry->FindActuralStyleName(A2OUSTR("Primary"));
+	
+	XFIndexTemplate * pTemplate1 = new XFIndexTemplate();
+	pTemplate1->AddEntry(enumXFIndexTemplateText,A2OUSTR(""));
+	pTemplate1->AddEntry(enumXFIndexTemplateTab,A2OUSTR(""));
+	pTemplate1->AddEntry(enumXFIndexTemplatePage,A2OUSTR(""));					
+	//pXFIndex->AddTemplate(Int32ToOUString(1),A2OUSTR("Primary"),pTemplate1);
+	pXFIndex->AddTemplate(Int32ToOUString(1),styleName,pTemplate1);
+	
+	XFIndexTemplate * pTemplate2 = new XFIndexTemplate();
+	pTemplate2->AddEntry(enumXFIndexTemplateText,A2OUSTR(""));
+	pTemplate2->AddEntry(enumXFIndexTemplateTab,A2OUSTR(""));
+	pTemplate2->AddEntry(enumXFIndexTemplatePage,A2OUSTR(""));	
+	XFIndexTemplate * pTemplate3 = new XFIndexTemplate();
+	pTemplate3->AddEntry(enumXFIndexTemplateText,A2OUSTR(""));
+	pTemplate3->AddEntry(enumXFIndexTemplateTab,A2OUSTR(""));
+	pTemplate3->AddEntry(enumXFIndexTemplatePage,A2OUSTR(""));
+		
+	if (pIndexSection->IsFormatRunin())
+	{
+		//pXFIndex->AddTemplate(Int32ToOUString(2),A2OUSTR("Primary"),pTemplate2);			
+		//pXFIndex->AddTemplate(Int32ToOUString(3),A2OUSTR("Primary"),pTemplate3);
+		pXFIndex->AddTemplate(Int32ToOUString(2),styleName,pTemplate2);			
+		pXFIndex->AddTemplate(Int32ToOUString(3),styleName,pTemplate3);
+	}
+	else
+	{
+		//pXFIndex->AddTemplate(Int32ToOUString(2),A2OUSTR("Secondary"),pTemplate2);			
+		//pXFIndex->AddTemplate(Int32ToOUString(3),A2OUSTR("Secondary"),pTemplate3);	
+		styleName = pFoundry->FindActuralStyleName(A2OUSTR("Secondary"));
+		pXFIndex->AddTemplate(Int32ToOUString(2),styleName,pTemplate2);			
+		pXFIndex->AddTemplate(Int32ToOUString(3),styleName,pTemplate3);	
+	}
+}
+
+
+LwpMasterPage::LwpMasterPage(LwpPara* pPara, LwpPageLayout* pLayout)
+	:m_pPara(pPara),m_pLayout(pLayout),m_bNewSection(sal_False)
+{
+}
+
+/**
+ * @descr:	Register master page style for para style and register section style if necessary
+ * 
+ */
+sal_Bool LwpMasterPage::RegisterMasterPage(LwpFrib* pFrib)
+{	
+	//if there is no other frib after current firb, register master page in starting para of next page
+	if(IsNextPageType()&&(!pFrib->HasNextFrib()))
+	{
+		LwpStory* pStory = static_cast<LwpStory*>(m_pPara->GetStoryID()->obj());
+		pStory->SetCurrentLayout(m_pLayout);
+		RegisterFillerPageStyle();
+		return sal_False;
+	}	
+
+	m_bNewSection = sal_False;
+	//sal_Bool bSectionColumns = sal_False;
+
+	XFParaStyle* pOverStyle = new XFParaStyle;
+	*pOverStyle = *(m_pPara->GetXFParaStyle());
+	pOverStyle->SetStyleName(A2OUSTR(""));
+	
+	LwpLayout::UseWhenType eUserType = m_pLayout->GetUseWhenType();	
+	switch(eUserType)
+	{
+		case LwpLayout::StartWithinColume://not support now
+		{
+			m_bNewSection = sal_False;
+			break;
+		}
+		case LwpLayout::StartWithinPage:
+		{				
+			m_bNewSection = sal_True;
+			//bSectionColumns = sal_True;
+			break;
+		}
+		case LwpLayout::StartOnNextPage:	//fall throught
+		case LwpLayout::StartOnOddPage:	//fall throught
+		case LwpLayout::StartOnEvenPage:
+		{							
+			LwpStory* pStory = static_cast<LwpStory*>(m_pPara->GetStoryID()->obj());
+			pStory->SetCurrentLayout(m_pLayout);
+			//get odd page layout when the current pagelayout is mirror
+			m_pLayout = pStory->GetCurrentLayout();
+			m_bNewSection = IsNeedSection();	
+			//bSectionColumns = m_bNewSection;
+			pOverStyle->SetMasterPage( m_pLayout->GetStyleName());
+			RegisterFillerPageStyle();
+			break;
+		}			
+		default:
+			break;
+	}		
+	
+	//register tab style;
+	LwpStory* pStory = static_cast<LwpStory*>(m_pPara->GetStoryID()->obj());
+	pStory->SetTabLayout(m_pLayout);
+	m_pPara->RegisterTabStyle(pOverStyle);
+	
+	XFStyleManager* pXFStyleManager = LwpGlobalMgr::GetInstance()->GetXFStyleManager();
+	m_StyleName = pXFStyleManager->AddStyle(pOverStyle)->GetStyleName();
+	//register section style here		
+	if(m_bNewSection)
+	{
+		XFSectionStyle* pSectStyle= new XFSectionStyle();		
+		//set margin
+		LwpStory* pStory = static_cast<LwpStory*>(m_pPara->GetStoryID()->obj());
+		if(pStory)
+		{
+			LwpPageLayout* pCurrentLayout = pStory->GetCurrentLayout();
+			double fLeft = m_pLayout->GetMarginsValue(MARGIN_LEFT)- pCurrentLayout->GetMarginsValue(MARGIN_LEFT);
+			double fRight = m_pLayout->GetMarginsValue(MARGIN_RIGHT)- pCurrentLayout->GetMarginsValue(MARGIN_RIGHT);
+			pSectStyle->SetMarginLeft(fLeft);
+			pSectStyle->SetMarginRight(fRight);
+		}
+
+		//if(bSectionColumns)
+		//{
+			//set columns
+			XFColumns* pColumns = m_pLayout->GetXFColumns();
+			if(pColumns)
+			{
+				pSectStyle->SetColumns(pColumns);
+			}
+		//}
+		m_SectionStyleName = pXFStyleManager->AddStyle(pSectStyle)->GetStyleName();
+	}
+	return sal_False;			
+}
+
+/**
+ * @descr:	Whether it need create a new section
+ * 
+ */
+sal_Bool LwpMasterPage::IsNeedSection()
+{
+	sal_Bool bNewSection = sal_False;
+	//get story
+	LwpStory* pStory = static_cast<LwpStory*>(m_pPara->GetStoryID()->obj());	
+	//if pagelayout is modified, register the pagelayout
+	if(pStory->IsPMModified())
+	{
+		bNewSection = pStory->IsNeedSection();		
+	}
+	return bNewSection;
+}
+
+/**
+ * @descr:	Create XFSection if necessary
+ * 
+ */
+XFSection* LwpMasterPage::CreateXFSection()
+{	
+	if(m_bNewSection)
+	{							
+		//new a section
+		XFSection* pXFSection = new XFSection();		
+		pXFSection->SetStyleName(m_SectionStyleName);
+		return pXFSection;
+	}
+	return NULL;
+}
+
+/**
+ * @descr:	Parse section
+ * 
+ */
+void LwpMasterPage::ParseSection(LwpFrib* pFrib)
+{
+	LwpFribPtr* pFribPtr = m_pPara->GetFribs();
+	//XFParagraph * pXFPara = pFribPtr->GetXFPara();
+
+	//parse fillerpage text
+	if(m_pLayout->HasFillerPageText(m_pPara->GetFoundry()))
+	{
+		XFParagraph *pPara = new XFParagraph();
+		pPara->SetStyleName(GetFillerPageStyleName());	
+		m_pPara->AddXFContent(pPara);
+		pFribPtr->SetXFPara(pPara);
+
+		m_pLayout->ConvertFillerPageText(m_pPara->GetXFContainer());
+	}			
+	//create a new section and add it to container
+	XFContentContainer* pContent = CreateXFSection();
+	if(pContent)
+	{
+		LwpStory* pStory = static_cast<LwpStory*> ( m_pPara->GetStoryID()->obj() );
+		//delete the additional blank para, 06/28/2005		
+		XFParagraph* pCurrPara = pFribPtr->GetXFPara();
+		if(!pCurrPara->HasContents())
+		{
+			XFContentContainer* pCurrContainer = m_pPara->GetXFContainer();
+			if(pFrib->HasNextFrib() && (pCurrContainer->GetLastContent() == pCurrPara))
+			{
+				pCurrContainer->RemoveLastContent();
+			}
+		}		
+		//end,06/28/2005
+		pStory->AddXFContent( pContent );
+	}
+	else
+	{
+		LwpStory* pStory = static_cast<LwpStory*> ( m_pPara->GetStoryID()->obj() );
+		pContent = pStory->GetXFContent();
+	}
+	if(pContent)
+	{
+		m_pPara->SetXFContainer( pContent );		
+	}
+	//out put the contents after the section frib in the same para.
+	if(pFrib->HasNextFrib())
+	{
+		XFParagraph *pNextPara = new XFParagraph();
+		pNextPara->SetStyleName(GetStyleName());		
+		m_pPara->AddXFContent(pNextPara);
+		pFribPtr->SetXFPara(pNextPara);
+	}
+	
+}
+
+/**
+ * @descr:	Register filler page text style
+ * 
+ */
+void LwpMasterPage::RegisterFillerPageStyle()
+{
+	LwpLayout::UseWhenType eUserType = m_pLayout->GetUseWhenType();
+	if(eUserType==LwpLayout::StartOnOddPage
+			||eUserType==LwpLayout::StartOnEvenPage)
+	{			
+		if(m_pLayout->HasFillerPageText(m_pPara->GetFoundry()))
+		{
+			XFParaStyle* pPagebreakStyle = new XFParaStyle;
+			*pPagebreakStyle = *(m_pPara->GetXFParaStyle());
+			pPagebreakStyle->SetStyleName(A2OUSTR(""));
+			pPagebreakStyle->SetBreaks(enumXFBreakAftPage); 
+			XFStyleManager* pXFStyleManager = LwpGlobalMgr::GetInstance()->GetXFStyleManager(); 			
+			m_FillerPageStyleName= pXFStyleManager->AddStyle(pPagebreakStyle)->GetStyleName();
+		}
+	}
+}
+
+/**
+ * @descr:	Whether the layout is next page type
+ * 
+ */
+sal_Bool LwpMasterPage::IsNextPageType()
+{
+	LwpLayout::UseWhenType eUserType = m_pLayout->GetUseWhenType();
+	if(eUserType == LwpLayout::StartOnNextPage 
+		|| eUserType == LwpLayout::StartOnOddPage 
+		|| eUserType == LwpLayout::StartOnEvenPage )
+	{
+		return sal_True;
+	}
+	return sal_False;
+}
diff -urNp lotuswordpro.bak/source/filter/lwpfribsection.hxx lotuswordpro/source/filter/lwpfribsection.hxx
--- lotuswordpro.bak/source/filter/lwpfribsection.hxx	1970-01-01 08:00:00.000000000 +0800
+++ lotuswordpro/source/filter/lwpfribsection.hxx	2008-10-22 11:42:29.000000000 +0800
@@ -0,0 +1,131 @@
+/*************************************************************************
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: IBM Corporation
+ *
+ *  Copyright: 2008 by IBM Corporation
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+/*************************************************************************
+ * @file 
+ *  the class for section frib and process section and page layout
+ ************************************************************************/
+/*************************************************************************
+ * Change History
+Jan 2005		Created
+ ************************************************************************/
+#ifndef _LWPFRIBSECTION_HXX_
+#define _LWPFRIBSECTION_HXX_
+#include "lwpfrib.hxx"
+#include "lwppara.hxx"
+
+/**
+ * @brief		Process page layout for inserting pagelayout or section
+ * 
+ */
+class LwpMasterPage
+{
+public:
+	LwpMasterPage(LwpPara* pPara, LwpPageLayout* pLayout);
+	~LwpMasterPage(){};	
+
+public:
+	//for page layout register and parse	
+	sal_Bool RegisterMasterPage(LwpFrib* pFrib);
+	void RegisterFillerPageStyle();	
+	void ParseSection(LwpFrib* pFrib);
+	XFSection* CreateXFSection();
+
+	sal_Bool IsNewSection(){return m_bNewSection;}
+	OUString GetSectionStyleName(){return m_SectionStyleName;}
+	OUString GetStyleName(){ return m_StyleName;}	
+	OUString GetFillerPageStyleName(){ return m_FillerPageStyleName;}
+	sal_Bool IsNextPageType();
+
+private:	
+	sal_Bool IsNeedSection();
+
+private:
+	sal_Bool m_bNewSection;	
+	OUString m_FillerPageStyleName;
+	OUString m_SectionStyleName;
+	OUString m_StyleName; //master page style name
+	
+	LwpPara* m_pPara;
+	LwpPageLayout* m_pLayout;
+};
+
+/**
+ * @brief		FRIB_TAB_SECTION object
+ * 
+ */
+class LwpSection;
+class XFIndex;
+class LwpFribSection: public LwpFrib
+{
+public:
+	LwpFribSection(LwpPara* pPara );
+	~LwpFribSection();
+	void Read(LwpObjectStream* pObjStrm, sal_uInt16 len);
+	LwpSection * GetSection();		
+	void RegisterSectionStyle();
+	//Modified by Helen for XFConvert refactor
+	void ParseSection();
+	//End of modification
+	void SetSectionName();
+
+	LwpPageLayout* GetPageLayout();
+private:
+	void SetDefaultAlphaIndex(XFIndex* pXFIndex);
+
+private:	
+	LwpObjectID m_Section;
+	LwpMasterPage* m_pMasterPage;
+};
+#endif
diff -urNp lotuswordpro.bak/source/filter/lwpfribtable.cxx lotuswordpro/source/filter/lwpfribtable.cxx
--- lotuswordpro.bak/source/filter/lwpfribtable.cxx	1970-01-01 08:00:00.000000000 +0800
+++ lotuswordpro/source/filter/lwpfribtable.cxx	2008-10-22 11:42:29.000000000 +0800
@@ -0,0 +1,173 @@
+/*************************************************************************
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: IBM Corporation
+ *
+ *  Copyright: 2008 by IBM Corporation
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+#include "lwpfribtable.hxx"
+#include "lwppara.hxx"
+#include "lwptablelayout.hxx"
+#include "lwpchangemgr.hxx"
+#include "lwpglobalmgr.hxx"
+#include "xfilter/xfstylemanager.hxx"
+#include "xfilter/xfchange.hxx"
+/**
+ * @short:   Read table frib
+ * @param:   
+ * @param:   
+ */
+
+void LwpFribTable::Read(LwpObjectStream* pObjStrm, sal_uInt16 len)
+{
+	m_objTable.ReadIndexed(pObjStrm);
+}
+
+LwpSuperTableLayout* LwpFribTable::GetSuperTable()
+{
+	return static_cast<LwpSuperTableLayout*>(m_objTable.obj());
+}
+
+void LwpFribTable::RegisterStyle()
+{
+	GetSuperTable()->RegisterStyle();
+	XFParaStyle* pOldStyle = m_pPara->GetXFParaStyle();
+	if(HasNextFrib())
+	{
+		if (pOldStyle->GetMasterPage().getLength() == 0)
+			m_StyleName = pOldStyle->GetStyleName();
+		else			
+		{
+			XFParaStyle* pParaStyle = new XFParaStyle;
+			*pParaStyle = *(pOldStyle);
+			XFStyleManager* pXFStyleManager = LwpGlobalMgr::GetInstance()->GetXFStyleManager(); 	
+			m_StyleName = pXFStyleManager->AddStyle(pParaStyle)->GetStyleName();
+		}
+	}	
+}
+
+void LwpFribTable::Parse(IXFStream* pOutputStream)
+{
+	GetSuperTable()->Parse(pOutputStream);
+}
+
+void LwpFribTable::XFConvert(XFContentContainer* pCont)
+{
+	XFContentContainer* pXFContentContainer = pCont;
+	LwpSuperTableLayout* pSuper = GetSuperTable();
+	sal_uInt8 nType = pSuper->GetRelativeType();	
+	LwpVirtualLayout* pContainer = pSuper->GetContainerLayout();
+	if (!pContainer)
+		return;
+	if ( LwpLayoutRelativityGuts::LAY_INLINE_NEWLINE == nType 
+		&& !pContainer->IsCell())
+	{		
+		pXFContentContainer = m_pPara->GetXFContainer();
+		//delete the additional blank para, 06/28/2005		
+		XFParagraph* pCurrPara = m_pPara->GetFribs()->GetXFPara();
+		if(!pCurrPara->HasContents())
+		{			
+			if(pXFContentContainer->GetLastContent() == pCurrPara)
+			{
+				pXFContentContainer->RemoveLastContent();
+			}
+		}		
+		//end,06/28/2005
+	}
+	else if( LwpLayoutRelativityGuts::LAY_PARA_RELATIVE == nType)
+	{
+		//same page as text and in frame		
+		if(pContainer->IsFrame())
+		{			
+			pXFContentContainer = m_pPara->GetXFContainer();
+		}
+		else if(pContainer->IsCell())
+		{
+			//same page as text and in cell, get the first xfpara			
+			XFContentContainer* pXFFirtPara = static_cast<XFContentContainer*>(pCont->FindFirstContent(enumXFContentPara));
+			if(pXFFirtPara)
+				pXFContentContainer = pXFFirtPara;
+		}	
+	}
+	OUString sChangeID;
+	if(m_bRevisionFlag)
+	{
+		LwpGlobalMgr* pGlobal = LwpGlobalMgr::GetInstance(); 
+		LwpChangeMgr* pChangeMgr = pGlobal->GetLwpChangeMgr();
+		sChangeID = pChangeMgr->GetChangeID(this);
+		if (sChangeID.getLength())
+		{
+			XFChangeStart* pChangeStart = new XFChangeStart;
+			pChangeStart->SetChangeID(sChangeID);
+			pXFContentContainer->Add(pChangeStart);
+		}
+	}
+	pSuper->XFConvert(pXFContentContainer);
+	
+	if(m_bRevisionFlag)
+	{
+		if (sChangeID.getLength())
+		{
+			XFChangeEnd* pChangeEnd = new XFChangeEnd;
+			pChangeEnd->SetChangeID(sChangeID);
+			pXFContentContainer->Add(pChangeEnd);
+		}
+	}
+
+	if(LwpLayoutRelativityGuts::LAY_INLINE_NEWLINE == nType
+		&& HasNextFrib())
+	{
+		XFParagraph* pXFPara = new XFParagraph();
+		pXFPara->SetStyleName(m_StyleName);
+		m_pPara->AddXFContent(pXFPara);
+		m_pPara->GetFribs()->SetXFPara(pXFPara);
+	}
+	
+}
diff -urNp lotuswordpro.bak/source/filter/lwpfribtable.hxx lotuswordpro/source/filter/lwpfribtable.hxx
--- lotuswordpro.bak/source/filter/lwpfribtable.hxx	1970-01-01 08:00:00.000000000 +0800
+++ lotuswordpro/source/filter/lwpfribtable.hxx	2008-10-22 11:42:29.000000000 +0800
@@ -0,0 +1,74 @@
+/*************************************************************************
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: IBM Corporation
+ *
+ *  Copyright: 2008 by IBM Corporation
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+#ifndef _LWPFRIBTABLE_HXX_
+#define _LWPFRIBTABLE_HXX_
+
+#include "lwpfrib.hxx"
+
+class LwpSuperTableLayout;
+class LwpFribTable : public LwpFrib
+{
+public:
+	LwpFribTable( LwpPara* pPara ) : LwpFrib(pPara){};
+	~LwpFribTable(){};
+	void Read(LwpObjectStream* pObjStrm, sal_uInt16 len);
+	LwpSuperTableLayout* GetSuperTable();
+	void RegisterStyle();
+	void Parse(IXFStream* pOutputStream);	
+	virtual void XFConvert(XFContentContainer* pCont);
+private:
+	LwpObjectID m_objTable;
+};
+#endif
diff -urNp lotuswordpro.bak/source/filter/lwpfribtext.cxx lotuswordpro/source/filter/lwpfribtext.cxx
--- lotuswordpro.bak/source/filter/lwpfribtext.cxx	1970-01-01 08:00:00.000000000 +0800
+++ lotuswordpro/source/filter/lwpfribtext.cxx	2008-10-22 11:42:29.000000000 +0800
@@ -0,0 +1,496 @@
+/*************************************************************************
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: IBM Corporation
+ *
+ *  Copyright: 2008 by IBM Corporation
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+/*************************************************************************
+ * @file 
+ *  For LWP filter architecture prototype
+ ************************************************************************/
+/*************************************************************************
+ * Change History
+ Jan 2005			Created
+ ************************************************************************/
+#include "lwpglobalmgr.hxx"
+#include "lwpfribtext.hxx"
+#include "lwpcharsetmgr.hxx"
+#include "lwphyperlinkmgr.hxx"
+#include "lwptools.hxx"
+#include "xfilter/xfstylemanager.hxx"
+#include "xfilter/xftextspan.hxx"
+#include "xfilter/xfbookmark.hxx"
+#include "xfilter/xfentry.hxx"
+#include "xfilter/xftextcontent.hxx"
+#include "xfilter/xfcrossref.hxx"
+#include "xfilter/xfpagenumber.hxx"
+#include "xfilter/xfdocfield.hxx"
+#include "xfilter/xfdatestyle.hxx"
+#include "xfilter/xftimestyle.hxx"
+#include "xfilter/xfdate.hxx"
+#include "xfilter/xfannotation.hxx"
+
+LwpFribText::LwpFribText( LwpPara *pPara, sal_Bool bNoUnicode )
+	: LwpFrib(pPara), m_bNoUnicode(bNoUnicode)
+{};
+
+void LwpFribText::Read(LwpObjectStream* pObjStrm, sal_uInt16 len)
+{
+	if( len>=1 )
+	{
+		rtl_TextEncoding rEncode;
+		if(m_bNoUnicode)
+		{
+			rEncode = RTL_TEXTENCODING_ISO_8859_1;
+		}
+		else
+		{
+			if (m_pModifiers && m_pModifiers->CodePage) 
+				rEncode = LwpCharSetMgr::GetInstance()->
+				                              GetTextCharEncoding(m_pModifiers->CodePage);
+			else
+				rEncode = LwpCharSetMgr::GetInstance()->GetTextCharEncoding();
+		}
+		LwpTools::QuickReadUnicode(pObjStrm, m_Content, len, rEncode);
+	}
+}
+
+void LwpFribText::XFConvert(XFContentContainer* pXFPara,LwpStory* pStory)
+{
+	if (!pStory)
+		return;
+	LwpHyperlinkMgr* pHyperlink = pStory->GetHyperlinkMgr();
+	if (pHyperlink->GetHyperlinkFlag())
+		LwpFrib::ConvertHyperLink(pXFPara,pHyperlink,GetText());
+	else
+		LwpFrib::ConvertChars(pXFPara,GetText());
+}
+
+/**
+ * @short:   Reading mothed of paranumber frib.
+ * @param:   pObjStrm wordpro object stream.
+ * @param:   len length of the frib
+ */
+void LwpFribParaNumber::Read(LwpObjectStream* pObjStrm, sal_uInt16 len)
+{
+	pObjStrm->QuickRead(&m_nStyleID, sizeof(m_nStyleID));
+	pObjStrm->QuickRead(&m_nNumberChar, sizeof(m_nNumberChar));
+	pObjStrm->QuickRead(&m_nLevel, sizeof(m_nLevel));
+	pObjStrm->QuickRead(&m_nStart, sizeof(m_nStart));
+}
+
+/**
+ * @short:   default constructor of LwpFribDocVar
+ */
+LwpFribDocVar::LwpFribDocVar(LwpPara* pPara)
+	: LwpFrib(pPara), m_nType(0), m_pName(new LwpAtomHolder)
+{
+}
+/**
+ * @short:   destructor of LwpFribDocVar
+ */
+LwpFribDocVar::~LwpFribDocVar()
+{
+	if (m_pName)
+	{
+		delete m_pName;
+		m_pName = NULL;
+	}
+}
+/**
+ * @short:   Reading mothed of document variable frib.
+ * @param:   pObjStrm wordpro object stream.
+ * @param:   len length of the frib
+ */
+void LwpFribDocVar::Read(LwpObjectStream* pObjStrm, sal_uInt16 len)
+{
+	pObjStrm->QuickRead(&m_nType, sizeof(m_nType));
+	m_pName->Read(pObjStrm);
+}
+
+/**
+ * @short:   register style for doc field (text style,date style)
+ * @param:   
+ * @param:   
+ */
+void LwpFribDocVar::RegisterStyle(LwpFoundry* pFoundry)
+{
+	LwpFrib::RegisterStyle(pFoundry);
+	
+	switch(m_nType)
+	{
+	case DATECREATED:
+	case DATELASTREVISION:
+	{		
+//		m_TimeStyle = LwpTools::RegisterDefaultTimeStyle();
+		RegisterDefaultTimeStyle();		
+	}
+		break;
+	case TOTALEDITTIME:
+		RegisterTotalTimeStyle();
+		break;
+	default:
+		break;				
+	}	
+}
+
+/**
+ * @short:   register default time style for doc field
+ * @param:   
+ * @param:   
+ */
+void LwpFribDocVar::RegisterDefaultTimeStyle()
+{
+	XFDateStyle* pDateStyle = new XFDateStyle;//use the default format
+	
+	pDateStyle->AddMonth();
+	pDateStyle->AddText(A2OUSTR("/"));
+	pDateStyle->AddMonthDay();
+	pDateStyle->AddText(A2OUSTR("/"));	
+	pDateStyle->AddYear();
+	pDateStyle->AddText(A2OUSTR(","));
+	pDateStyle->AddHour();
+	pDateStyle->AddText(A2OUSTR(":"));
+	pDateStyle->AddMinute();
+	pDateStyle->AddText(A2OUSTR(":"));
+	pDateStyle->AddSecond(sal_True,0);			
+
+	XFStyleManager* pXFStyleManager = LwpGlobalMgr::GetInstance()->GetXFStyleManager(); 	
+	m_TimeStyle = pXFStyleManager->AddStyle(pDateStyle)->GetStyleName();
+}
+void LwpFribDocVar::RegisterTotalTimeStyle()
+{
+	XFTimeStyle* pTimeStyle = new XFTimeStyle;//use the default format
+	pTimeStyle->SetTruncate(sal_False);	
+	pTimeStyle->AddMinute();
+	XFStyleManager* pXFStyleManager = LwpGlobalMgr::GetInstance()->GetXFStyleManager(); 	
+	m_TimeStyle = pXFStyleManager->AddStyle(pTimeStyle)->GetStyleName();
+}
+
+/**
+ * @short:   convert the doc info field
+ * @param:   
+ * @param:   
+ */
+void LwpFribDocVar::XFConvert(XFContentContainer* pXFPara)
+{
+	XFContent* pContent=NULL;
+	switch(m_nType)
+	{
+	case FILENAME:
+	{
+		pContent = new XFFileName;
+		static_cast<XFFileName*>(pContent)->SetType(A2OUSTR("FileName"));
+		break;
+	}
+	case PATH:
+	{
+		pContent = new XFFileName;
+		static_cast<XFFileName*>(pContent)->SetType(A2OUSTR("Path"));
+		break;
+	}
+	case DESCRIPTION:
+		pContent = new XFDescription;
+		break;
+	case DATECREATED:
+	{
+		pContent = new XFCreateTime;
+		pContent->SetStyleName(m_TimeStyle);
+		break;
+	}
+	case DATELASTREVISION:
+	{
+		pContent = new XFLastEditTime;
+		pContent->SetStyleName(m_TimeStyle);
+		break;
+	}
+	case NUMPAGES:
+		pContent = new XFPageCount;
+		break;
+	case NUMWORDS:
+		pContent = new XFWordCount;
+		break;		
+	case NUMCHARS:
+		pContent = new XFCharCount;
+		break;
+	case TOTALEDITTIME:
+	{
+		pContent = new XFTotalEditTime;
+		pContent->SetStyleName(m_TimeStyle);
+		break;
+	}
+	case KEYWORDS:
+		pContent = new XFKeywords;
+		break;
+	case CREATEDBY:
+		pContent = new XFInitialCreator;
+		break;
+	case DOCSIZE:
+	{
+/*		pContent = new XFAnnotation;
+		XFTextContent* pSpan = new XFTextContent();
+		pSpan->SetText(A2OUSTR("Document Size is Here"));
+		XFParagraph* pPara = new XFParagraph;
+		pPara->Add(pSpan);
+		static_cast<XFAnnotation*>(pContent)->Add(pPara);
+		break;
+*/
+		OUString text = A2OUSTR("<Document Size>");
+		LwpFrib::ConvertChars(pXFPara,text);
+		return;
+	}
+	case SMARTMASTER:
+	{
+		OUString text = A2OUSTR("<Smart master>");
+		LwpFrib::ConvertChars(pXFPara,text);		
+		return;
+	}
+	case DIVISIONNAME:
+	{
+		OUString text = A2OUSTR("<Division name>");
+		LwpFrib::ConvertChars(pXFPara,text);		
+		return;
+	}
+	case SECTIONNAME:
+	{
+		OUString text = A2OUSTR("<Section name>");
+		LwpFrib::ConvertChars(pXFPara,text);		
+		return;
+	}
+	case VERSIONCREATEBY:
+	{
+		OUString text = A2OUSTR("<Version Creat by>");
+		LwpFrib::ConvertChars(pXFPara,text);		
+		return;
+	}
+	case VERSIONCREATEDATE:
+	{
+		OUString text = A2OUSTR("<Version Creat date>");
+		LwpFrib::ConvertChars(pXFPara,text);		
+		return;
+	}
+	case VERSIONOTHEREDITORS:
+	{
+		OUString text = A2OUSTR("<Version other Editors>");
+		LwpFrib::ConvertChars(pXFPara,text);		
+		return;
+	}
+	case VERSIONNAME:
+	{
+		OUString text = A2OUSTR("<Version Name>");
+		LwpFrib::ConvertChars(pXFPara,text);		
+		return;
+	}
+	case VERSIONNUMBER:
+	{
+		OUString text = A2OUSTR("<Version Numbers>");
+		LwpFrib::ConvertChars(pXFPara,text);		
+		return;
+	}
+	case ALLVERSIONNAME:
+	{
+		OUString text = A2OUSTR("<All Version Name>");
+		LwpFrib::ConvertChars(pXFPara,text);		
+		return;
+	}
+	case VERSIONREMARK:
+	{
+		OUString text = A2OUSTR("<Version Remark>");
+		LwpFrib::ConvertChars(pXFPara,text);		
+		return;
+	}
+	case DOCUMENTCATEGORY:
+	{
+		OUString text = A2OUSTR("<Document Category>");
+		LwpFrib::ConvertChars(pXFPara,text);		
+		return;
+	}
+	case VERSIONLASTDATE:
+	{
+		OUString text = A2OUSTR("<Version Last Modify Date>");
+		LwpFrib::ConvertChars(pXFPara,text);		
+		return;
+	}
+	case VERSIONLASTEDITOR:
+	{
+		OUString text = A2OUSTR("<Version Last Editor>");
+		LwpFrib::ConvertChars(pXFPara,text);		
+		return;
+	}
+	case LASTEDIT:
+	{
+		OUString text = A2OUSTR("<Last Editor>");
+		LwpFrib::ConvertChars(pXFPara,text);		
+		return;
+	}
+	case OTHEREDITORS:
+	{
+		OUString text = A2OUSTR("<Other Editors>");
+		LwpFrib::ConvertChars(pXFPara,text);		
+		return;
+	}
+	case NUMOFREVISION:
+	{
+		OUString text = A2OUSTR("<Number of Revision>");
+		LwpFrib::ConvertChars(pXFPara,text);		
+		return;
+	}
+	default:
+		return;		
+	}
+	if (m_ModFlag)//(m_pModifiers)
+	{
+		XFTextSpan *pSpan = new XFTextSpan;
+		pSpan->SetStyleName(GetStyleName());
+		pSpan->Add(pContent);
+		pXFPara->Add(pSpan); 
+	}
+	else
+		pXFPara->Add(pContent);		
+		
+}
+/**
+ * @short:   Read unicode
+ * @param:   
+ * @param:   
+ */
+void LwpFribUnicode::Read(LwpObjectStream* pObjStrm, sal_uInt16 len)
+{
+	if(len>1)
+	{
+	    rtl_TextEncoding rEncode;
+
+		if (m_pModifiers && m_pModifiers->CodePage)
+		        rEncode = LwpCharSetMgr::GetInstance()->
+		                                  GetTextCharEncoding(m_pModifiers->CodePage);
+		else
+		        rEncode = LwpCharSetMgr::GetInstance()->GetTextCharEncoding();
+		
+		LwpTools::QuickReadUnicode(pObjStrm, m_Content, len, rEncode);
+
+	}
+	else
+		pObjStrm->SeekRel(len);
+}
+
+void LwpFribUnicode::XFConvert(XFContentContainer* pXFPara,LwpStory* pStory)
+{
+	if (!pStory)
+		return;
+	LwpHyperlinkMgr* pHyperlink = pStory->GetHyperlinkMgr();
+	if (pHyperlink->GetHyperlinkFlag())
+		LwpFrib::ConvertHyperLink(pXFPara,pHyperlink,GetText());
+	else
+		LwpFrib::ConvertChars(pXFPara,GetText());
+}
+
+/**
+ * @short:   Read page number
+ * @param:   
+ * @param:   
+ */
+void LwpFribPageNumber::Read(LwpObjectStream* pObjStrm, sal_uInt16 len)
+{	
+	m_nNumStyle = pObjStrm->QuickReaduInt16();
+	m_aBefText.Read(pObjStrm);
+	m_aAfterText.Read(pObjStrm);
+	m_nStartNum = pObjStrm->QuickReaduInt16();
+	m_nStartOnPage = pObjStrm->QuickReaduInt16();
+	m_nFlag = pObjStrm->QuickReaduInt16();
+}
+
+void LwpFribPageNumber::XFConvert(XFContentContainer* pXFPara)
+{
+	if (m_nNumStyle == 0x0)
+		return;
+	XFPageNumber* pNum = new XFPageNumber;
+//	pNum->SetSelect(A2OUSTR("current"));
+	switch(m_nNumStyle)
+	{
+	case 0x01:
+		pNum->SetNumFmt(A2OUSTR("1"));
+		break;
+	case 0x02:
+		pNum->SetNumFmt(A2OUSTR("A"));
+		break;
+	case 0x03:
+		pNum->SetNumFmt(A2OUSTR("a"));
+		break;
+	case 0x04:
+		pNum->SetNumFmt(A2OUSTR("I"));
+		break;
+	case 0x05:
+		pNum->SetNumFmt(A2OUSTR("i"));
+		break;
+	}
+	OUString styleName = GetStyleName();
+	if (m_aBefText.str().getLength()>0)
+	{
+		OUString textStr = m_aBefText.str();
+		XFTextSpan *pBef = new XFTextSpan(textStr,styleName);
+		pXFPara->Add(pBef); 
+	}
+	if (m_ModFlag)//(m_pModifiers)
+	{
+		XFTextSpan *pSpan = new XFTextSpan;
+		pSpan->SetStyleName(styleName);
+		pSpan->Add(pNum);
+		pXFPara->Add(pSpan); 
+	}
+	else
+		pXFPara->Add(pNum);
+	if (m_aAfterText.str().getLength()>0)
+	{
+		OUString textStr = m_aAfterText.str();
+		XFTextSpan *pAfter = new XFTextSpan(textStr,styleName);
+		pXFPara->Add(pAfter); 
+	}	
+}
diff -urNp lotuswordpro.bak/source/filter/lwpfribtext.hxx lotuswordpro/source/filter/lwpfribtext.hxx
--- lotuswordpro.bak/source/filter/lwpfribtext.hxx	1970-01-01 08:00:00.000000000 +0800
+++ lotuswordpro/source/filter/lwpfribtext.hxx	2008-10-22 11:42:29.000000000 +0800
@@ -0,0 +1,230 @@
+/*************************************************************************
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: IBM Corporation
+ *
+ *  Copyright: 2008 by IBM Corporation
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+/*************************************************************************
+ * @file 
+ *  For LWP filter architecture prototype
+ ************************************************************************/
+/*************************************************************************
+ * Change History
+ Jan 2005			Created
+ ************************************************************************/
+#ifndef _LWPFRIBTEXT_HXX_
+#define _LWPFRIBTEXT_HXX_
+
+#include "lwpfrib.hxx"
+#include "lwpstory.hxx"
+class LwpFribText : public LwpFrib
+{
+public:
+	LwpFribText( LwpPara* pPara, sal_Bool bNoUnicode=false);
+	~LwpFribText(){};
+	void Read(LwpObjectStream* pObjStrm, sal_uInt16 len);
+	void XFConvert(XFContentContainer* pXFPara,LwpStory* pStory);
+private:
+	OUString m_Content;
+	sal_Bool m_bNoUnicode;
+public:
+	OUString GetText(){return m_Content;}
+};
+
+class LwpFribHardSpace : public LwpFrib
+{
+public:
+	LwpFribHardSpace( LwpPara* pPara ) : LwpFrib(pPara){};
+	~LwpFribHardSpace(){};
+};
+
+class LwpFribSoftHyphen : public LwpFrib
+{
+public:
+	LwpFribSoftHyphen( LwpPara* pPara ) : LwpFrib(pPara){};
+	~LwpFribSoftHyphen(){};
+};
+
+//add by , 02/03/2005
+class LwpFribParaNumber : public LwpFrib
+{
+public:
+	LwpFribParaNumber( LwpPara* pPara ) : LwpFrib(pPara), 
+		m_nStyleID(0), m_nNumberChar(0), m_nLevel(1), m_nStart(0){};
+	void Read(LwpObjectStream* pObjStrm, sal_uInt16 len);
+
+	inline sal_uInt16 GetStyleID() const;
+
+	inline sal_uInt16 GetNumberChar() const;
+
+	inline sal_uInt16 GetLevel() const;
+
+	inline sal_uInt16 GetStart() const;
+	
+private:
+	sal_uInt16 m_nStyleID;
+	sal_uInt16 m_nNumberChar;
+	sal_uInt16 m_nLevel;
+	sal_uInt16 m_nStart;
+};
+inline sal_uInt16 LwpFribParaNumber::GetStyleID() const
+{
+	return m_nStyleID;
+}
+inline sal_uInt16 LwpFribParaNumber::GetNumberChar() const
+{
+	return m_nNumberChar;
+}
+inline sal_uInt16 LwpFribParaNumber::GetLevel() const
+{
+	return m_nLevel;
+}
+inline sal_uInt16 LwpFribParaNumber::GetStart() const
+{
+	return m_nStart;
+}
+
+class LwpFribDocVar : public LwpFrib
+{
+public:
+	LwpFribDocVar( LwpPara* pPara );
+	
+	~LwpFribDocVar();
+	
+	void Read(LwpObjectStream* pObjStrm, sal_uInt16 len);
+	
+	void RegisterStyle(LwpFoundry* pFoundry);//add by ,05/5/27
+	
+	void XFConvert(XFContentContainer* pXFPara);//add by ,05/5/27
+	
+//	inline sal_uInt16 GetType() const;
+	
+	enum {
+		FILENAME = 0x02,	
+		PATH = 0x03,
+		SMARTMASTER = 0x04,
+		DESCRIPTION = 0x05,
+		DATECREATED = 0x06,
+		DATELASTREVISION = 0x07,
+		TOTALEDITTIME = 0x08,
+		NUMPAGES= 0x09,
+		NUMWORDS= 0x0a,
+		NUMCHARS = 0x0b,
+		DOCSIZE = 0x0c,	
+		DIVISIONNAME = 0x0d,
+		SECTIONNAME = 0x0e,
+		VERSIONCREATEBY = 0x0f,
+		VERSIONCREATEDATE = 0x10,
+		VERSIONOTHEREDITORS = 0x11,		
+		VERSIONNAME = 0x12,
+		VERSIONNUMBER = 0x13,	
+		ALLVERSIONNAME = 0x14,	
+		VERSIONREMARK = 0x15,
+		DOCUMENTCATEGORY = 0x16,
+		VERSIONLASTDATE = 0x17,
+		VERSIONLASTEDITOR = 0x18,		
+		KEYWORDS = 0x19,
+		CREATEDBY = 0x1a,
+		LASTEDIT = 0x1b,
+		OTHEREDITORS = 0x1c,
+		NUMOFREVISION = 0x1d,
+		};
+	
+private:
+	sal_uInt16 m_nType;
+	LwpAtomHolder* m_pName;
+	OUString m_TimeStyle;
+	void RegisterDefaultTimeStyle();
+	void RegisterTotalTimeStyle();
+};
+//inline sal_uInt16 LwpFribDocVar::GetType() const
+//{
+//	return m_nType;
+//}
+
+class LwpFribTab : public LwpFrib
+{
+public:
+	LwpFribTab( LwpPara* pPara ) : LwpFrib(pPara){};
+	~LwpFribTab(){};
+};
+
+class LwpFribUnicode: public LwpFrib
+{
+public:
+	LwpFribUnicode( LwpPara* pPara ) : LwpFrib(pPara){};
+	~LwpFribUnicode(){};
+	void Read(LwpObjectStream* pObjStrm, sal_uInt16 len);
+	void XFConvert(XFContentContainer* pXFPara,LwpStory* pStory);
+private:
+	OUString m_Content;
+public:
+	OUString GetText(){return m_Content;}
+};
+
+class LwpFribPageNumber : public LwpFrib
+{
+public:
+	LwpFribPageNumber(LwpPara* pPara) : LwpFrib(pPara), 
+		m_nNumStyle(0), m_nStartNum(1), m_nStartOnPage(1), m_nFlag(0){};
+	~LwpFribPageNumber(){};
+	void Read(LwpObjectStream* pObjStrm, sal_uInt16 len);
+	void XFConvert(XFContentContainer* pXFPara);
+private:
+ 	sal_uInt16 m_nNumStyle;
+	LwpAtomHolder m_aBefText;
+	LwpAtomHolder m_aAfterText;
+	sal_uInt16 m_nStartNum;
+	sal_uInt16 m_nStartOnPage;
+	sal_uInt16 m_nFlag;
+};
+
+#endif
diff -urNp lotuswordpro.bak/source/filter/lwpglobalmgr.cxx lotuswordpro/source/filter/lwpglobalmgr.cxx
--- lotuswordpro.bak/source/filter/lwpglobalmgr.cxx	1970-01-01 08:00:00.000000000 +0800
+++ lotuswordpro/source/filter/lwpglobalmgr.cxx	2008-10-22 11:42:29.000000000 +0800
@@ -0,0 +1,166 @@
+/*************************************************************************
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: IBM Corporation
+ *
+ *  Copyright: 2008 by IBM Corporation
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+#include "lwpglobalmgr.hxx"
+#ifndef _OSL_THREAD_H_
+#include <osl/thread.h>
+#endif
+std::map< sal_uInt32,LwpGlobalMgr* > LwpGlobalMgr::m_ThreadMap;
+LwpGlobalMgr::LwpGlobalMgr(LwpSvStream* pSvStream)
+{
+	if (pSvStream)
+		m_pObjFactory = new LwpObjectFactory(pSvStream);
+	else
+		m_pObjFactory = NULL;
+	m_pBookmarkMgr = new LwpBookmarkMgr;
+	m_pChangeMgr = new LwpChangeMgr;
+	m_pXFFontFactory = new XFFontFactory;
+	m_pXFStyleManager = new XFStyleManager;
+}
+
+LwpGlobalMgr::~LwpGlobalMgr()
+{
+	if (m_pObjFactory)
+	{
+		delete m_pObjFactory;
+		m_pObjFactory = NULL;
+	}
+	if (m_pBookmarkMgr)
+	{
+		delete m_pBookmarkMgr;
+		m_pBookmarkMgr = NULL;
+	}
+	if (m_pChangeMgr)
+	{
+		delete m_pChangeMgr;
+		m_pChangeMgr = NULL;
+	}
+	if (m_pXFFontFactory)
+	{
+		delete m_pXFFontFactory;
+		m_pXFFontFactory = NULL;
+	}
+	if (m_pXFStyleManager)
+	{
+		delete m_pXFStyleManager;
+		m_pXFStyleManager = NULL;
+	}
+	std::map<sal_uInt16,LwpEditorAttr*>::iterator iter;
+	for (iter =m_EditorAttrMap.begin();iter != m_EditorAttrMap.end(); iter++)
+	{
+		delete iter->second;
+		iter->second = NULL;
+	}
+	m_EditorAttrMap.clear();
+}
+
+LwpGlobalMgr* LwpGlobalMgr::GetInstance(LwpSvStream* pSvStream)
+{
+	sal_uInt32 nThreadID = osl_getThreadIdentifier((void*)0);
+	std::map< sal_uInt32,LwpGlobalMgr* >::iterator iter;
+	iter = m_ThreadMap.find(nThreadID);
+	if (iter == m_ThreadMap.end())
+	{
+		LwpGlobalMgr* pInstance = new LwpGlobalMgr(pSvStream);
+		m_ThreadMap[nThreadID] = pInstance;
+		return pInstance;
+	}
+	else
+		return iter->second;
+}
+
+void LwpGlobalMgr::DeleteInstance()
+{
+	sal_uInt32 nThreadID = osl_getThreadIdentifier((void*)0);
+	std::map< sal_uInt32,LwpGlobalMgr* >::iterator iter;
+	iter = m_ThreadMap.find(nThreadID);
+	if (iter != m_ThreadMap.end())
+	{
+		delete iter->second;
+		iter->second = NULL;
+		m_ThreadMap.erase(iter);
+	}
+}
+
+void LwpGlobalMgr::SetEditorAttrMap(sal_uInt16 nID, LwpEditorAttr* pAttr)
+{
+	m_EditorAttrMap[nID] = pAttr;
+}
+
+rtl::OUString LwpGlobalMgr::GetEditorName(sal_uInt8 nID)
+{
+	std::map<sal_uInt16,LwpEditorAttr*>::iterator iter;
+	iter = m_EditorAttrMap.find(nID);
+	if (iter != m_EditorAttrMap.end())
+		return iter->second->cName.str();
+	return A2OUSTR("");
+}
+
+XFColor LwpGlobalMgr::GetHighLightColor(sal_uInt8 nID)
+{
+	std::map<sal_uInt16,LwpEditorAttr*>::iterator iter;
+
+	iter = m_EditorAttrMap.find(nID);
+	if (iter != m_EditorAttrMap.end())
+	{
+		LwpColor aLwpColor = iter->second->cHiLiteColor;
+		XFColor aColor(aLwpColor.GetRed(),aLwpColor.GetGreen(),aLwpColor.GetBlue());
+		return aColor;
+	}
+	else
+	{
+		XFColor aColor(255,255,0);//yellow
+		return aColor;
+	}
+}
\ No newline at end of file
diff -urNp lotuswordpro.bak/source/filter/lwpglobalmgr.hxx lotuswordpro/source/filter/lwpglobalmgr.hxx
--- lotuswordpro.bak/source/filter/lwpglobalmgr.hxx	1970-01-01 08:00:00.000000000 +0800
+++ lotuswordpro/source/filter/lwpglobalmgr.hxx	2008-10-22 11:42:29.000000000 +0800
@@ -0,0 +1,103 @@
+/*************************************************************************
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: IBM Corporation
+ *
+ *  Copyright: 2008 by IBM Corporation
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+/*************************************************************************
+ * @file 
+ *  For LWP filter architecture prototype
+ ************************************************************************/
+/*************************************************************************
+ * Change History
+ Nov 2005			Created
+ ************************************************************************/
+#ifndef _LWPGLOBALMGR_HXX_
+#define _LWPGLOBALMGR_HXX_
+
+#include <map>
+#include "lwpheader.hxx"
+#include "lwpsvstream.hxx"
+#include "lwpobjfactory.hxx"
+#include "lwpbookmarkmgr.hxx"
+#include "lwpchangemgr.hxx"
+#include "xfilter/xffontfactory.hxx"
+#include "xfilter/xfstylemanager.hxx"
+#include "lwpdocdata.hxx"
+#include "xfilter/xfcolor.hxx"
+
+class LwpGlobalMgr
+{
+public:		
+	~LwpGlobalMgr();
+	static LwpGlobalMgr* GetInstance(LwpSvStream* pSvStream=NULL);	
+	static void DeleteInstance();
+	LwpObjectFactory* GetLwpObjFactory(){return m_pObjFactory;}
+	LwpBookmarkMgr* GetLwpBookmarkMgr(){return m_pBookmarkMgr;}
+	LwpChangeMgr* GetLwpChangeMgr(){return m_pChangeMgr;}
+	XFFontFactory* GetXFFontFactory(){return m_pXFFontFactory;}
+	XFStyleManager* GetXFStyleManager(){return m_pXFStyleManager;}
+	void SetEditorAttrMap(sal_uInt16 nID, LwpEditorAttr* pAttr);
+	OUString GetEditorName(sal_uInt8 nID);
+	XFColor GetHighLightColor(sal_uInt8 nID);
+private:
+	LwpGlobalMgr(LwpSvStream* pSvStream);
+private:
+	static std::map< sal_uInt32,LwpGlobalMgr* > m_ThreadMap;
+	LwpObjectFactory* m_pObjFactory;
+	LwpBookmarkMgr* m_pBookmarkMgr;
+	LwpChangeMgr* m_pChangeMgr;
+	XFFontFactory* m_pXFFontFactory;
+	XFStyleManager* m_pXFStyleManager;	
+	std::map< sal_uInt16,LwpEditorAttr* > m_EditorAttrMap;
+};
+
+#endif
\ No newline at end of file
diff -urNp lotuswordpro.bak/source/filter/lwpgrfobj.cxx lotuswordpro/source/filter/lwpgrfobj.cxx
--- lotuswordpro.bak/source/filter/lwpgrfobj.cxx	1970-01-01 08:00:00.000000000 +0800
+++ lotuswordpro/source/filter/lwpgrfobj.cxx	2008-10-22 11:42:29.000000000 +0800
@@ -0,0 +1,843 @@
+/*************************************************************************
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: IBM Corporation
+ *
+ *  Copyright: 2008 by IBM Corporation
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+/*****************************************************************************
+* Change History
+* 2005/2  draft code for chart
+****************************************************************************/
+
+/**
+ * @file 
+ *  For LWP filter architecture prototype
+*/
+#include <stdio.h>
+#include "lwp9reader.hxx"
+#include "lwpgrfobj.hxx"
+#include "lwpsdwfileloader.hxx"
+#include "bento.hxx"
+
+#include "lwpglobalmgr.hxx"
+#include "xfilter/xfframe.hxx"
+#include "xfilter/xfimage.hxx"
+#include "xfilter/xfimagestyle.hxx"
+#include "xfilter/xfstylemanager.hxx"
+#include "xfilter/xfparagraph.hxx"
+#include "xfilter/xfannotation.hxx"
+
+//For chart
+#include "string.h"
+//#include "lwpchartstreamtools.hxx"
+
+#ifndef _OSL_THREAD_H_
+#include <osl/thread.h>
+#endif
+
+#define EF_NONE 0x0000
+#define EF_FTP 0x0001
+#define EF_ODMA 0x0002
+#define EF_NOS 0x0003
+
+LwpGraphicObject::LwpGraphicObject(LwpObjectHeader &objHdr, LwpSvStream* pStrm)
+:LwpGraphicOleObject(objHdr, pStrm),m_bCompressed(0),m_bIsLinked(0),m_nCachedBaseLine(0)
+{
+}
+LwpGraphicObject::~LwpGraphicObject()
+{
+	m_vXFDrawObjects.clear();
+}
+void LwpGraphicObject::Read()
+{
+	LwpGraphicOleObject::Read();
+	sal_uInt16 disksize = m_pObjStrm->QuickReaduInt16();
+	sal_uInt16 strsize = m_pObjStrm->QuickReaduInt16();
+	if (strsize<AFID_MAX_FILE_FORMAT_SIZE)
+	{
+		m_pObjStrm->QuickRead(m_sDataFormat,strsize);
+		m_sDataFormat[strsize] = '\0';
+	}
+/*
+	if (m_sDataFormat!=(unsigned char*)(".lch"))
+	{
+		return;
+	}
+*/
+	sal_uInt32 nServerContextSize = m_pObjStrm->QuickReaduInt32();
+	unsigned char *pServerContext = NULL;
+	if (nServerContextSize > 0)
+	{
+		pServerContext = new unsigned char[nServerContextSize];
+		m_pObjStrm->QuickRead(pServerContext, static_cast<sal_uInt16>(nServerContextSize));
+		// add by , 04/05/2005
+		if (nServerContextSize > 44)
+		{
+			m_aIPData.nBrightness = pServerContext[14];
+			m_aIPData.nContrast = pServerContext[19];
+			m_aIPData.nEdgeEnchancement = pServerContext[24];
+			m_aIPData.nSmoothing = pServerContext[29];
+			m_aIPData.bInvertImage = (sal_Bool)(pServerContext[34] == 0x01);
+			m_aIPData.bAutoContrast = (sal_Bool)(pServerContext[44] == 0x00);
+		}
+		// end add
+	}
+	disksize = m_pObjStrm->QuickReaduInt16();
+	strsize = m_pObjStrm->QuickReaduInt16();
+	if (strsize<AFID_MAX_FILE_FORMAT_SIZE)
+	{
+		m_pObjStrm->QuickRead(m_sServerContextFormat,strsize);
+		m_sServerContextFormat[strsize] = '\0';
+	}
+	if (nServerContextSize == 0)
+	{
+		if (strcmp((char *)m_sServerContextFormat, ".cht") == 0 &&
+			strcmp((char *)m_sDataFormat, ".sdw") == 0)
+		{
+			strcpy((char *)m_sServerContextFormat, ".lch");
+			strcpy((char *)m_sDataFormat, ".lch");
+		}
+	}
+	m_nCachedBaseLine = m_pObjStrm->QuickReadInt32();
+	m_bIsLinked = m_pObjStrm->QuickReadInt16();
+	//OUString pLinkedFilePath;
+	unsigned char * pFilterContext = NULL;
+	sal_uInt32 nFilterContextSize = 0;
+
+	if (m_bIsLinked)
+	{
+		m_LinkedFilePath = m_pObjStrm->QuickReadStringPtr();
+
+		nFilterContextSize = m_pObjStrm->QuickReaduInt32();
+		if (nFilterContextSize > 0)
+		{
+			pFilterContext = new unsigned char[nFilterContextSize];
+			m_pObjStrm->QuickRead(pFilterContext, static_cast<sal_uInt16>(nFilterContextSize));
+		}
+		if (LwpFileHeader::m_nFileRevision >= 0x000b)
+		{
+
+			// read external file object stuff
+			sal_uInt16 type = m_pObjStrm->QuickReaduInt16();
+//			if (EF_ODMA == type)
+//				;
+			if ((EF_ODMA != type) && (EF_NONE != type)) // don't know about this
+			{
+				sal_uInt32 size = m_pObjStrm->QuickReaduInt32();
+				m_pObjStrm->SeekRel(static_cast<sal_uInt16>(size));
+			}
+			// else no external file object
+		}
+	}
+
+	if (LwpFileHeader::m_nFileRevision >= 0x000b)
+	{
+		m_bCompressed = m_pObjStrm->QuickReadInt16();
+		m_Cache.LinkedFileSize = m_pObjStrm->QuickReaduInt32();
+		m_Cache.LinkedFileTime = m_pObjStrm->QuickReaduInt32();
+		m_Cache.Width = m_pObjStrm->QuickReadInt32();
+		m_Cache.Height = m_pObjStrm->QuickReadInt32();
+	}
+	
+	if(LwpFileHeader::m_nFileRevision >= 0x000c)
+	{
+		m_WatermarkName = m_pObjStrm->QuickReadStringPtr();	
+	}
+
+	if (pServerContext != NULL)
+		delete[] pServerContext;
+
+	if (pFilterContext != NULL)
+		delete[] pFilterContext;	
+
+}
+
+void LwpGraphicObject::XFConvert (XFContentContainer* pCont)
+{
+	if ((m_sServerContextFormat[1]=='s'&&m_sServerContextFormat[2]=='d'&&m_sServerContextFormat[3]=='w'))
+	{
+/*		LwpSvStream* pStream = m_pStrm;
+		//test code
+		OpenStormBento::LtcBenContainer* pBentoContainer;
+		ULONG ulRet = OpenStormBento::BenOpenContainer(pStream, &pBentoContainer);
+		std::vector<SvStream*> vStream;
+		std::vector<SvStream*>::iterator iter;
+		pBentoContainer->CreateGraphicStreams(&vStream);
+		for (iter=vStream.begin();iter!=vStream.end();iter++)
+		{
+			LwpSdwFileLoader fileLoader(*iter,pOutputStream);
+			fileLoader.LoadObjectList();
+			delete *iter;
+		}
+		vStream.clear();*/
+
+		//XFParagraph* pPara = new XFParagraph();
+		std::vector <XFFrame*>::iterator iter;
+		for (iter = m_vXFDrawObjects.begin(); iter != m_vXFDrawObjects.end(); iter++)
+		{
+			//pPara->Add(*iter);
+			pCont->Add(*iter);
+		}
+
+		//pCont->Add(pPara);
+		
+	}
+	else if (this->IsGrafFormatValid())
+	{
+		XFImage* pImage = static_cast<XFImage*>(m_vXFDrawObjects.front());
+
+		if (m_bIsLinked)
+		{
+			OUString fileURL = LwpTools::convertToFileUrl(OUStringToOString(m_LinkedFilePath, osl_getThreadTextEncoding()));
+			pImage->SetFileURL(fileURL);
+		}
+		else
+		{
+			sal_uInt8* pGrafData = NULL;
+			sal_uInt32 nDataLen = this->GetRawGrafData(pGrafData);
+
+			if (pGrafData)
+			{
+				pImage->SetImageData(pGrafData, nDataLen);
+
+				// delete used image data
+				delete [] pGrafData;
+				pGrafData = NULL;
+			}
+		}
+
+		pCont->Add(pImage);
+	}
+	else if((m_sServerContextFormat[1]=='t'&&m_sServerContextFormat[2]=='e'&&m_sServerContextFormat[3]=='x'))
+	{
+		XFConvertEquation(pCont);		
+	}
+	if (m_sServerContextFormat[1]=='l'&&m_sServerContextFormat[2]=='c'&&m_sServerContextFormat[3]=='h')
+	{
+		LwpSvStream* pDocStream = m_pStrm;
+		//LwpChartStreamTools::ParseChart(pDocStream, GetObjectID(),
+		//								GetRectIn100thMM(), GetRectInCM(), pOutputStream);
+		//LwpChartStreamTools::ParseChart(pDocStream, GetObjectID(),
+		//								GetRectIn100thMM(), GetRectInCM(), pCont, m_strStyleName);
+	}
+}
+
+/**
+* @short   Get the rectangle of a chart in 100thMM
+* @descr   
+* @return the rectangle of the chart
+*/
+Rectangle LwpGraphicObject::GetRectIn100thMM()
+{
+#define To100thMM(num) (long)(2540* (double(num)/(72 * 65536L)))
+	INT32 nLeft,nTop,nRight,nBottom;
+	GetRect(nLeft,nTop,nRight,nBottom);
+	return Rectangle( To100thMM(nLeft),To100thMM(nTop),To100thMM(nRight),To100thMM(nBottom) ); 
+}
+
+/**
+* @short   Get the rectangle of a chart in CM
+* @descr   
+* @return	The rectangle of the chart
+*/
+XFRect LwpGraphicObject::GetRectInCM()
+{
+#define ToCM(num) (2.54*(double(num)/(72 * 65536L)))
+	INT32 nLeft,nTop,nRight,nBottom;
+	GetRect(nLeft,nTop,nRight,nBottom);
+	return XFRect( ToCM(nLeft),ToCM(nTop),ToCM(nRight-nLeft),ToCM(nBottom-nTop) ); 
+}
+
+/**
+* @short   Get the rectangle of a chart
+* @descr   
+* @param   nLeft 
+* @param   nTop 
+* @param   nRight 
+* @param   nBottom 
+*/
+#include "lwpframelayout.hxx"
+void LwpGraphicObject::GetRect(INT32& nLeft, INT32& nTop, INT32& nRight, INT32& nBottom)
+{
+	nLeft = nTop = nRight = nBottom = 0;
+
+	LwpObjectID* pObjID = GetLayoutsWithMe()->GetOnlyLayout();
+	if (pObjID)
+	{
+		LwpFrameLayout* pLayout = (LwpFrameLayout*)pObjID->obj();
+		if (pLayout)
+		{
+			LwpLayoutGeometry* pGeometry =(LwpLayoutGeometry*) pLayout->GetGeometry();
+	
+			if (pGeometry)
+			{
+				LwpPoint aOrigin = pGeometry->GetOrigin();
+// 2005.6
+//frame width/height are not width/height of a chart
+//				sal_Int32 nWidth = pGeometry->GetWidth();
+//				sal_Int32 nHeight = pGeometry->GetHeight();
+				double fWidth =0;
+				double fHeight = 0;
+				GetGrafScaledSize(fWidth, fHeight);
+				
+				sal_Int32 nWidth = fWidth * UNITS_PER_INCH /CM_PER_INCH;
+				sal_Int32 nHeight = fHeight * UNITS_PER_INCH /CM_PER_INCH;			
+//end
+				nLeft = pLayout->GetMarginsValue(MARGIN_LEFT) * UNITS_PER_INCH /CM_PER_INCH;
+				nTop = pLayout->GetMarginsValue(MARGIN_TOP)* UNITS_PER_INCH /CM_PER_INCH;
+				nRight = nLeft+nWidth;
+				nBottom = nTop+nHeight;
+			}
+		}
+	}
+}
+
+/**
+ * @descr   judge if the graphic format is what we can support: bmp, jpg, wmf, gif, tgf(tif). other format will be filtered to
+ *	these formats by Word Pro.
+ * @return  sal_True if yes sal_False if not.
+ */
+sal_Bool LwpGraphicObject::IsGrafFormatValid()
+{
+	if ((m_sServerContextFormat[1]=='b'&& m_sServerContextFormat[2]=='m' && m_sServerContextFormat[3]=='p')
+	|| (m_sServerContextFormat[1]=='j' && m_sServerContextFormat[2]=='p' && m_sServerContextFormat[3]=='g')
+	|| (m_sServerContextFormat[1]=='w' && m_sServerContextFormat[2]=='m' && m_sServerContextFormat[3]=='f')
+	|| (m_sServerContextFormat[1]=='g' && m_sServerContextFormat[2]=='i' && m_sServerContextFormat[3]=='f')
+	|| (m_sServerContextFormat[1]=='t' && m_sServerContextFormat[2]=='g' && m_sServerContextFormat[3]=='f')
+	|| (m_sServerContextFormat[1]=='p' && m_sServerContextFormat[2]=='n' && m_sServerContextFormat[3]=='g')
+	|| (m_sServerContextFormat[1]=='e' && m_sServerContextFormat[2]=='p' && m_sServerContextFormat[3]=='s'))
+	{
+		return sal_True;
+	}
+	else
+	{
+		return sal_False;
+	}
+}
+
+/**
+ * @descr   create drawing object and image object.
+ */
+void LwpGraphicObject::RegisterStyle()
+{
+	if (m_sServerContextFormat[1]=='s'&&m_sServerContextFormat[2]=='d'&&m_sServerContextFormat[3]=='w')
+	{
+		this->CreateDrawObjects();
+	}
+	// test codes for importing pictures
+	else if(this->IsGrafFormatValid())
+	{
+		this->CreateGrafObject();
+	}
+/*	if (m_sServerContextFormat[1]=='s'&&m_sServerContextFormat[2]=='d'&&m_sServerContextFormat[3]=='w')
+	{
+		LwpSvStream* pStream = m_pStrm;
+		//test code
+		OpenStormBento::LtcBenContainer* pBentoContainer;
+		ULONG ulRet = OpenStormBento::BenOpenContainer(pStream, &pBentoContainer);
+		std::vector<SvStream*> vStream;
+		std::vector<SvStream*>::iterator iter;
+		pBentoContainer->CreateGraphicStreams(&vStream);
+		for (iter=vStream.begin();iter!=vStream.end();iter++)
+		{
+			LwpSdwFileLoader fileLoader(*iter);
+			fileLoader.RegisterStyle();
+			delete *iter;
+		}
+		vStream.clear();
+
+	}*/
+	if (m_sServerContextFormat[1]=='l'&&m_sServerContextFormat[2]=='c'&&m_sServerContextFormat[3]=='h')
+	{
+		LwpVirtualLayout* pMyLayout = GetLayout(NULL);
+		if(pMyLayout->IsFrame())
+		{
+			XFFrameStyle* pXFFrameStyle = new XFFrameStyle();
+			pXFFrameStyle->SetXPosType(enumXFFrameXPosFromLeft, enumXFFrameXRelFrame);
+			pXFFrameStyle->SetYPosType(enumXFFrameYPosFromTop, enumXFFrameYRelPara);
+			XFStyleManager* pXFStyleManager = LwpGlobalMgr::GetInstance()->GetXFStyleManager(); 	
+			m_strStyleName = pXFStyleManager->AddStyle(pXFFrameStyle)->GetStyleName();
+		}
+	}
+	
+}
+
+// add by , 03/25/2005
+/**
+ * @descr   create drawing object.
+ */
+void LwpGraphicObject::CreateDrawObjects()
+{
+	// if small file, use the compressed stream for BENTO
+	LwpSvStream* pStream = m_pStrm->GetCompressedStream() ?  m_pStrm->GetCompressedStream(): m_pStrm;
+
+	OpenStormBento::LtcBenContainer* pBentoContainer;
+	ULONG ulRet = OpenStormBento::BenOpenContainer(pStream, &pBentoContainer);
+	SvStream* pDrawObjStream = NULL;
+
+	// get graphic object's bento objet name
+	LwpObjectID* pMyID = this->GetObjectID();
+	std::string aGrfObjName;
+	this->GetBentoNamebyID(pMyID,  aGrfObjName);
+	
+	// get bento stream by the name
+	pBentoContainer->CreateGraphicStream(pDrawObjStream, aGrfObjName.c_str());
+	if (pDrawObjStream)
+	{
+		LwpSdwFileLoader fileLoader(pDrawObjStream, this);
+		fileLoader.CreateDrawObjects(&m_vXFDrawObjects);
+
+		delete pDrawObjStream;
+		pDrawObjStream = NULL;
+	}
+}
+
+/**
+ * @descr   create drawing object.
+ */
+void LwpGraphicObject::GetBentoNamebyID(LwpObjectID* pMyID, std::string& rName)
+{
+	sal_uInt16 nHigh = pMyID->GetHigh();
+	sal_uInt32 nLow = pMyID->GetLow();
+	char pTempStr[32];
+	rName = std::string("Gr");
+	sprintf(pTempStr, "%X,%lX", nHigh, nLow);
+	rName.append(pTempStr);
+}
+
+/**
+ * @descr   get the image data read from bento stream according to the VO_GRAPHIC ID.
+ * @param   pGrafData   the array to store the image data. the pointer need to be deleted outside.
+ * @return  the length of the image data.
+ */
+sal_uInt32 LwpGraphicObject::GetRawGrafData(sal_uInt8*& pGrafData)
+{
+	// create graphic object
+	// if small file, use the compressed stream for BENTO
+	LwpSvStream* pStream = m_pStrm->GetCompressedStream() ?  m_pStrm->GetCompressedStream(): m_pStrm;
+
+	OpenStormBento::LtcBenContainer* pBentoContainer;
+	ULONG ulRet = OpenStormBento::BenOpenContainer(pStream, &pBentoContainer);
+	SvStream* pGrafStream = NULL;
+
+	// get graphic object's bento objet name
+	LwpObjectID* pMyID = this->GetObjectID();
+	std::string aGrfObjName;
+	this->GetBentoNamebyID(pMyID,  aGrfObjName);
+	
+	// get bento stream by the name
+	pBentoContainer->CreateGraphicStream(pGrafStream, aGrfObjName.c_str());
+	SvMemoryStream* pMemGrafStream = static_cast<SvMemoryStream*>(pGrafStream);
+
+	if (pMemGrafStream)
+	{
+		// read image data
+		sal_uInt32 nDataLen = pMemGrafStream->GetSize();
+		pGrafData = new sal_uInt8 [nDataLen];
+		pMemGrafStream->Read(pGrafData, nDataLen);
+
+		delete pMemGrafStream;
+		pMemGrafStream = NULL;
+
+		return nDataLen;
+	}
+
+	return 0;
+}
+
+/**
+ * @descr   get the image data (only -D dara) read from bento stream according to the VO_GRAPHIC ID. 
+ * @param   pGrafData   the array to store the image data. the pointer need to be deleted outside.
+ * @return  the length of the image data.
+ */
+sal_uInt32 LwpGraphicObject::GetGrafData(sal_uInt8*& pGrafData)
+{
+	// create graphic object
+	// if small file, use the compressed stream for BENTO
+	LwpSvStream* pStream = m_pStrm->GetCompressedStream() ?  m_pStrm->GetCompressedStream(): m_pStrm;
+
+	OpenStormBento::LtcBenContainer* pBentoContainer;
+	ULONG ulRet = OpenStormBento::BenOpenContainer(pStream, &pBentoContainer);	
+	
+	SvStream* pGrafStream = NULL;
+
+	// get graphic object's bento objet name
+	LwpObjectID* pMyID = this->GetObjectID();
+	std::string aGrfObjName;
+	this->GetBentoNamebyID(pMyID,  aGrfObjName);
+
+	char sDName[64]="";
+	sprintf(sDName, "%s-D", aGrfObjName.c_str());
+	
+	// get bento stream by the name	
+	pGrafStream = pBentoContainer->FindValueStreamWithPropertyName(sDName);
+		
+	SvMemoryStream* pMemGrafStream = static_cast<SvMemoryStream*>(pGrafStream);
+
+	if (pMemGrafStream)
+	{
+		// read image data		
+		UINT32 nPos = pGrafStream->Tell();
+		pGrafStream->Seek(STREAM_SEEK_TO_END);
+		sal_uInt32 nDataLen = pGrafStream->Tell();
+		pGrafStream->Seek(nPos);
+		
+		pGrafData = new sal_uInt8 [nDataLen];
+		pMemGrafStream->Read(pGrafData, nDataLen);
+
+		delete pMemGrafStream;
+		pMemGrafStream = NULL;
+
+		return nDataLen;
+	}
+
+	return 0;
+}
+
+
+/**
+ * @descr   create xf-image object and save it in the container: m_vXFDrawObjects.
+ */
+void LwpGraphicObject::CreateGrafObject()
+{
+
+	XFImage* pImage = new XFImage();
+
+	// set image processing styles
+	XFImageStyle* pImageStyle = new XFImageStyle();
+	if (m_sServerContextFormat[1]!='w' || m_sServerContextFormat[2]!='m' || m_sServerContextFormat[3]!='f')
+	{
+		if (m_aIPData.nBrightness != 50)
+		{
+			sal_Int32 nSODCBrightness = (sal_Int32)m_aIPData.nBrightness*2 - 100;
+			pImageStyle->SetBrightness(nSODCBrightness);
+		}
+		if (m_aIPData.nContrast != 50)
+		{
+			//sal_Int32 nSODCContrast = (sal_Int32)m_aIPData.nContrast*2 - 100;
+			//lwp [0, 100] map to sodc [80, -80]
+			sal_Int32 nSODCContrast = (sal_Int32)(80 - (double)m_aIPData.nContrast*1.6);
+			pImageStyle->SetContrast(nSODCContrast);
+		}
+	}
+	
+	// set scale and crop styles
+	LwpAssociatedLayouts* pLayoutWithMe = GetLayoutsWithMe();
+	LwpFrameLayout* pMyFrameLayout = 
+		static_cast<LwpFrameLayout*>(pLayoutWithMe->GetOnlyLayout()->obj(VO_FRAMELAYOUT));
+	if (pMyFrameLayout)
+	{
+		LwpLayoutScale* pMyScale = pMyFrameLayout->GetLayoutScale();
+		LwpLayoutGeometry* pFrameGeo = pMyFrameLayout->GetGeometry();
+
+		// original image size
+		double fOrgGrafWidth = (double)m_Cache.Width/TWIPS_PER_CM;
+		double fOrgGrafHeight = (double)m_Cache.Height/TWIPS_PER_CM;
+		
+		// get margin values
+		double fLeftMargin = pMyFrameLayout->GetMarginsValue(MARGIN_LEFT);
+		double fRightMargin = pMyFrameLayout->GetMarginsValue(MARGIN_RIGHT);
+		double fTopMargin = pMyFrameLayout->GetMarginsValue(MARGIN_TOP);
+		double fBottomMargin = pMyFrameLayout->GetMarginsValue(MARGIN_BOTTOM);
+		
+		if (pMyScale && pFrameGeo)
+		{
+			// frame size
+			double fFrameWidth = LwpTools::ConvertFromUnitsToMetric(pFrameGeo->GetWidth());
+			double fFrameHeight = LwpTools::ConvertFromUnitsToMetric(pFrameGeo->GetHeight());
+
+			// calculate the displayed size of the frame
+			double fDisFrameWidth = fFrameWidth - (fLeftMargin+fRightMargin);
+			double fDisFrameHeight = fFrameHeight - (fTopMargin+fBottomMargin);
+			
+			// scaled image size
+			double fSclGrafWidth = fOrgGrafWidth;//LwpTools::ConvertFromUnitsToMetric(pMyScale->GetScaleWidth());
+			double fSclGrafHeight = fOrgGrafHeight;//LwpTools::ConvertFromUnitsToMetric(pMyScale->GetScaleHeight());
+
+			// get scale mode
+			sal_uInt16 nScalemode = pMyScale->GetScaleMode();
+			if (nScalemode & LwpLayoutScale::CUSTOM)
+			{
+				fSclGrafWidth = LwpTools::ConvertFromUnitsToMetric(pMyScale->GetScaleWidth());
+				fSclGrafHeight = LwpTools::ConvertFromUnitsToMetric(pMyScale->GetScaleHeight());
+			}
+			else if (nScalemode & LwpLayoutScale::PERCENTAGE)
+			{
+				double fScalePercentage = (double)pMyScale->GetScalePercentage() / 1000;
+				fSclGrafWidth = fScalePercentage * fOrgGrafWidth;
+				fSclGrafHeight = fScalePercentage * fOrgGrafHeight;
+			}
+			else if (nScalemode & LwpLayoutScale::FIT_IN_FRAME)
+			{
+				if (pMyFrameLayout->IsFitGraphic())
+				{
+					fSclGrafWidth = fOrgGrafWidth;
+					fSclGrafHeight = fOrgGrafHeight;
+				}
+				else if (nScalemode & LwpLayoutScale::MAINTAIN_ASPECT_RATIO)
+				{
+					if (fOrgGrafWidth/fOrgGrafHeight >= fDisFrameWidth/fDisFrameHeight)
+					{
+						fSclGrafWidth = fDisFrameWidth;
+						fSclGrafHeight = (fDisFrameWidth/fOrgGrafWidth) * fOrgGrafHeight;
+					}
+					else
+					{
+						fSclGrafHeight = fDisFrameHeight;
+						fSclGrafWidth = (fDisFrameHeight/fOrgGrafHeight) * fOrgGrafWidth;
+					}
+				}
+				else
+				{
+					fSclGrafWidth = fDisFrameWidth;
+					fSclGrafHeight = fDisFrameHeight;
+				}
+			}
+
+			// scaled ratio
+			double fXRatio = fSclGrafWidth / fOrgGrafWidth;
+			double fYRatio = fSclGrafHeight / fOrgGrafHeight;
+			
+			// set image to scaled size.
+			pImage->SetWidth(fSclGrafWidth);
+			pImage->SetHeight(fSclGrafHeight);
+				
+			// placement:centered or tiled. tiled style is not supported so it's processed together with centered.
+			if (pMyFrameLayout->GetScaleCenter() || pMyFrameLayout->GetScaleTile())
+			{
+				// set center alignment
+				pImageStyle->SetXPosType(enumXFFrameXPosCenter, enumXFFrameXRelFrame);
+				pImageStyle->SetYPosType(enumXFFrameYPosMiddle, enumXFFrameYRelFrame);
+
+				// need horizontal crop?
+				double fClipWidth = 0;
+				double fClipHeight = 0;
+				sal_Bool sal_bCropped = sal_False;
+				if (fSclGrafWidth > fDisFrameWidth)
+				{
+					fClipWidth = (fSclGrafWidth-fDisFrameWidth ) / 2 / fXRatio;
+					sal_bCropped = sal_True;
+				}
+
+				// need vertical crop?
+				if (fSclGrafHeight > fDisFrameHeight)
+				{
+					fClipHeight = (fSclGrafHeight-fDisFrameHeight ) / 2 / fYRatio;
+					sal_bCropped = sal_True;
+				}
+				
+				if (sal_bCropped)
+				{
+					pImageStyle->SetClip(fClipWidth, fClipWidth, fClipHeight, fClipHeight);
+					pImage->SetWidth(fDisFrameWidth);
+					pImage->SetHeight(fDisFrameHeight);
+				}
+			}
+			// placement:automatic 
+			else 
+			{
+				// set left-top alignment
+//					pImageStyle->SetXPosType(enumXFFrameXPosLeft, enumXFFrameXRelFrame);
+//					pImageStyle->SetYPosType(enumXFFrameYPosTop, enumXFFrameYRelFrame);
+				pImageStyle->SetYPosType(enumXFFrameYPosFromTop, enumXFFrameYRelFrame);
+				pImageStyle->SetXPosType(enumXFFrameXPosFromLeft, enumXFFrameXRelFrame);
+
+				// get image position offset
+				LwpPoint* pOffset = pMyScale->GetOffset();
+				double fOffsetX = LwpTools::ConvertFromUnitsToMetric(pOffset->GetX());
+				double fOffsetY = LwpTools::ConvertFromUnitsToMetric(pOffset->GetY());
+
+				struct LwpRect
+				{
+					double fLeft;
+					double fRight;
+					double fTop;
+					double fBottom;
+
+					LwpRect()
+					{
+						fLeft = 0.00;
+						fRight = 0.00;
+						fTop = 0.00;
+						fBottom = 0.00;
+					}
+					LwpRect(double fL, double fR, double fT, double fB)
+					{
+						fLeft = fL;
+						fRight = fR;
+						fTop = fT;
+						fBottom = fB;
+					}
+				};
+				LwpRect aFrameRect(-fOffsetX, (fDisFrameWidth-fOffsetX), (-fOffsetY), ((fDisFrameHeight-fOffsetY)));
+				LwpRect aImageRect(0, fSclGrafWidth, 0, fSclGrafHeight);
+				LwpRect aCropRect;
+
+				if (aFrameRect.fRight <= aImageRect.fLeft || aFrameRect.fLeft >= aImageRect.fRight
+					||aFrameRect.fBottom <= aImageRect.fTop|| aFrameRect.fTop >= aImageRect.fBottom)
+				{
+					// display blank
+				}
+				else// need cropped
+				{
+					// horizontal crop
+					if (aFrameRect.fLeft > aImageRect.fLeft)
+					{
+						aCropRect.fLeft = (aFrameRect.fLeft - aImageRect.fLeft) / fXRatio;					
+					}
+
+					if (aFrameRect.fRight < aImageRect.fRight)
+					{
+						aCropRect.fRight = (aImageRect.fRight - aFrameRect.fRight) / fXRatio;
+					}
+
+					// vertical crop
+					if (aFrameRect.fTop > aImageRect.fTop)
+					{
+						aCropRect.fTop = (aFrameRect.fTop - aImageRect.fTop) / fYRatio;
+					}
+					if (aFrameRect.fBottom < aImageRect.fBottom)
+					{
+						aCropRect.fBottom = (aImageRect.fBottom - aFrameRect.fBottom) / fYRatio;
+					}
+
+					pImageStyle->SetClip(aCropRect.fLeft, aCropRect.fRight, aCropRect.fTop, aCropRect.fBottom);
+					double fPicWidth = fSclGrafWidth - (aCropRect.fLeft+aCropRect.fRight)*fXRatio;
+					double fPicHeight = fSclGrafHeight- (aCropRect.fTop+aCropRect.fBottom)*fYRatio;
+					double fX = fOffsetX > 0 ? fOffsetX : 0.00;
+					double fY = fOffsetY > 0 ? fOffsetY : 0.00;
+					pImage->SetPosition((fX+fLeftMargin), (fY+fTopMargin), fPicWidth, fPicHeight);
+				}
+			}
+		}
+	}
+
+	// set style for the image
+	XFStyleManager* pXFStyleManager = LwpGlobalMgr::GetInstance()->GetXFStyleManager(); 	
+	pImage->SetStyleName(pXFStyleManager->AddStyle(pImageStyle)->GetStyleName());
+	
+	// set archor to frame
+	pImage->SetAnchorType(enumXFAnchorFrame);
+//		pImage->SetAnchorType(enumXFAnchorPara);//enumXFAnchorFrame);
+
+	// set object name
+	LwpAtomHolder* pHolder = this->GetName();
+	if ( pHolder && pHolder->str().getLength() )
+	{
+		pImage->SetName(pHolder->str());
+	}
+
+	// insert image object into array
+	m_vXFDrawObjects.push_back(pImage);
+
+}
+// end add
+
+/**
+ * @descr   Reserve the equation text in a note in the context.
+ */
+void LwpGraphicObject::XFConvertEquation(XFContentContainer * pCont)
+{
+	sal_uInt8* pGrafData = NULL;
+	sal_uInt32 nDataLen = this->GetGrafData(pGrafData);
+	if(pGrafData)
+	{
+		//convert equation
+		XFParagraph* pXFPara = new XFParagraph;		
+		pXFPara->Add(A2OUSTR("Formula:")); 
+		//add notes
+		XFAnnotation* pXFNote = new XFAnnotation;
+		//add equation to comment notes
+		XFParagraph* pXFNotePara = new XFParagraph;
+		//equation header text: Times New Roman,
+		//                                18,12,0,0,0,0,0.
+		//                                 .TCIformat{2}
+		//total head length = 45
+		sal_uInt32 nBegin = 45;
+		sal_uInt32 nEnd = nDataLen -1;		
+		sal_uInt32 nIndex = 0;
+
+		if(pGrafData[nEnd] == '$' && pGrafData[nEnd-1]!= '\\')
+		{
+			//equation body is contained by '$';
+			nBegin++;
+			nEnd--;
+		}
+		
+		if(nEnd >= nBegin)
+		{
+			sal_uInt8* pEquData = new sal_uInt8[nEnd - nBegin + 1];
+			for(nIndex = 0; nIndex < nEnd - nBegin +1 ; nIndex++)
+			{
+				pEquData[nIndex] = pGrafData[nBegin + nIndex];
+			}
+			pXFNotePara->Add(rtl::OUString((sal_Char*)pEquData, (nEnd - nBegin + 1), gsl_getSystemTextEncoding()));			
+			delete pEquData;
+		}
+		pXFNote->Add(pXFNotePara);
+		
+		pXFPara->Add(pXFNote);
+		pCont->Add(pXFPara);
+
+		delete [] pGrafData;
+		pGrafData = NULL;
+	}
+	
+}
+
+void LwpGraphicObject::GetGrafOrgSize(double & rWidth, double & rHeight)
+{
+	// original image size
+	rWidth = (double)m_Cache.Width/TWIPS_PER_CM;
+	rHeight = (double)m_Cache.Height/TWIPS_PER_CM;
+}
+
+
diff -urNp lotuswordpro.bak/source/filter/lwpgrfobj.hxx lotuswordpro/source/filter/lwpgrfobj.hxx
--- lotuswordpro.bak/source/filter/lwpgrfobj.hxx	1970-01-01 08:00:00.000000000 +0800
+++ lotuswordpro/source/filter/lwpgrfobj.hxx	2008-10-22 11:42:29.000000000 +0800
@@ -0,0 +1,141 @@
+/*************************************************************************
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: IBM Corporation
+ *
+ *  Copyright: 2008 by IBM Corporation
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+/*************************************************************************
+ * @file 
+ *  For LWP filter architecture prototype
+ ************************************************************************/
+
+#ifndef LWPGRFOBJECT_HXX_
+#define LWPGRFOBJECT_HXX_
+
+#include "lwpoleobject.hxx"
+#include "lwpheader.hxx"
+#include "xfilter/xfrect.hxx"
+#include <tools/gen.hxx>
+
+struct ImageProcessingData
+{
+	sal_uInt8 nBrightness;
+	sal_uInt8 nContrast;
+	sal_uInt8 nEdgeEnchancement;
+	sal_uInt8 nSmoothing;
+	sal_Bool bAutoContrast;
+	sal_Bool bInvertImage;
+
+	ImageProcessingData()
+	{
+		nBrightness = 50;
+		nContrast = 50;
+		nEdgeEnchancement = 0;
+		nSmoothing = 0;
+		bAutoContrast = sal_False;
+		bInvertImage= sal_False;
+	}
+};
+
+class XFFrame;
+class LwpGraphicObject : public LwpGraphicOleObject
+{
+public:
+	LwpGraphicObject(LwpObjectHeader &objHdr, LwpSvStream* pStrm);
+	~LwpGraphicObject();
+private:
+	unsigned char m_sDataFormat[AFID_MAX_FILE_FORMAT_SIZE];
+	unsigned char m_sServerContextFormat[AFID_MAX_CONTEXT_FORMAT_SIZE];
+	sal_Int32 m_nCachedBaseLine;
+	sal_Int16 m_bIsLinked;
+	AFID_CACHE m_Cache;
+	sal_Int16 m_bCompressed;
+	OUString m_WatermarkName;
+	OUString m_LinkedFilePath;
+
+	ImageProcessingData m_aIPData;
+	
+	void GetRect(INT32& nLeft, INT32& nTop, INT32& nRight, INT32& nBottom);
+	XFRect GetRectInCM();
+	Rectangle GetRectIn100thMM();
+	void XFConvertEquation(XFContentContainer* pCont);
+
+	void ParseChart(IXFStream* pOutputStream);
+	sal_Bool IsGrafFormatValid();
+	// add by , 03/25/2005
+	std::vector <XFFrame*> m_vXFDrawObjects;
+	// end add
+	
+public:
+	//inline sal_uInt8* GetBuffer(){return m_DataBuffer;}
+	void Read();
+	//Added by  for XFConvert refactor, 03/31/2005
+	virtual void XFConvert (XFContentContainer* pCont);
+	//End of Add
+	void RegisterStyle();
+	
+	// add by , 03/25/2005
+	void CreateDrawObjects();
+	void CreateGrafObject();
+	void GetBentoNamebyID(LwpObjectID* pMyID, std::string& rName);
+	sal_uInt32 GetRawGrafData(sal_uInt8*& pGrafData);
+	sal_uInt32 GetGrafData(sal_uInt8*& pGrafData);
+	void GetGrafOrgSize(long& rWidth, long& rHeight) { rWidth = m_Cache.Width; rHeight = m_Cache.Height; }
+	void GetGrafOrgSize(double& rWidth, double& rHeight);
+	// end add
+	
+	OUString GetWatermarkName(){ return m_WatermarkName;}
+	sal_Int16 IsLinked(){ return m_bIsLinked;}
+	OUString GetLinkedFilePath(){ return m_LinkedFilePath;}
+};
+
+#endif
+
diff -urNp lotuswordpro.bak/source/filter/lwpheader.hxx lotuswordpro/source/filter/lwpheader.hxx
--- lotuswordpro.bak/source/filter/lwpheader.hxx	1970-01-01 08:00:00.000000000 +0800
+++ lotuswordpro/source/filter/lwpheader.hxx	2008-10-22 11:42:29.000000000 +0800
@@ -0,0 +1,84 @@
+/*************************************************************************
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: IBM Corporation
+ *
+ *  Copyright: 2008 by IBM Corporation
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+/*************************************************************************
+ * @file 
+ *  For LWP filter architecture prototype
+ ************************************************************************/
+/*************************************************************************
+ * Change History
+ Jan 2005			Created
+ ************************************************************************/
+
+#ifndef _LWPHEADERS_HXX
+#define _LWPHEADERS_HXX
+
+#include <math.h>
+#include <vector>
+#include <memory>
+#include <hash_map>
+#include <map>
+#include <assert.h>
+#include <string>
+
+#include <sal/types.h>
+#include <tools/solar.h>
+#include <sal/config.h>
+
+#include <rtl/ustring.hxx>
+#include <tools/string.hxx>
+#include <memory.h>
+
+
+#endif
diff -urNp lotuswordpro.bak/source/filter/lwpholder.cxx lotuswordpro/source/filter/lwpholder.cxx
--- lotuswordpro.bak/source/filter/lwpholder.cxx	1970-01-01 08:00:00.000000000 +0800
+++ lotuswordpro/source/filter/lwpholder.cxx	2008-10-22 11:42:29.000000000 +0800
@@ -0,0 +1,119 @@
+/*************************************************************************
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: IBM Corporation
+ *
+ *  Copyright: 2008 by IBM Corporation
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+/*************************************************************************
+ * @file 
+ *  For LWP filter architecture prototype
+ ************************************************************************/
+/*************************************************************************
+ * Change History
+ Jan 2005			Created
+ ************************************************************************/
+
+#include "lwpholder.hxx"
+#include "lwpfilehdr.hxx"
+
+LwpDLVListHeadHolder::LwpDLVListHeadHolder(LwpObjectHeader& objHdr, LwpSvStream* pStrm)
+	: LwpObject(objHdr, pStrm)
+{}
+/**
+ * @descr		read LwpDLVListHeadHolder from object stream
+*/
+void LwpDLVListHeadHolder::Read()
+{
+	m_DLVHead.ReadIndexed(m_pObjStrm);
+	m_pObjStrm->SkipExtra();
+}
+
+LwpDLVListHeadTailHolder::LwpDLVListHeadTailHolder(LwpObjectHeader& objHdr, LwpSvStream* pStrm)
+	: LwpObject(objHdr, pStrm)
+{}
+/**
+ * @descr		read LwpDLVListHeadTailHolder from object stream
+*/
+void LwpDLVListHeadTailHolder::Read()
+{
+	m_HeadTail.Read(m_pObjStrm);
+	//m_pObjStrm->SkipExtra();
+}
+
+LwpObjectHolder::LwpObjectHolder(LwpObjectHeader &objHdr, LwpSvStream *pStrm)
+	:LwpDLVList(objHdr, pStrm)
+{}
+/**
+ * @descr		read LwpObjectHolder from object stream
+*/
+void LwpObjectHolder::Read()
+{
+	LwpDLVList::Read();
+
+	m_Object.ReadIndexed(m_pObjStrm);
+	if( LwpFileHeader::m_nFileRevision < 0x0006 )
+		m_pObjStrm->SkipExtra();	
+}
+
+LwpListList::LwpListList(LwpObjectHeader &objHdr, LwpSvStream *pStrm)
+	:LwpObjectHolder(objHdr, pStrm)
+{}
+/**
+ * @descr		read LwpListList from object stream
+*/
+void LwpListList::Read()
+{
+	LwpObjectHolder::Read();
+
+	m_HeadTail.Read(m_pObjStrm);
+	m_pObjStrm->SkipExtra();
+}
+
diff -urNp lotuswordpro.bak/source/filter/lwpholder.hxx lotuswordpro/source/filter/lwpholder.hxx
--- lotuswordpro.bak/source/filter/lwpholder.hxx	1970-01-01 08:00:00.000000000 +0800
+++ lotuswordpro/source/filter/lwpholder.hxx	2008-10-22 11:42:29.000000000 +0800
@@ -0,0 +1,129 @@
+/*************************************************************************
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: IBM Corporation
+ *
+ *  Copyright: 2008 by IBM Corporation
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+/*************************************************************************
+ * @file 
+ *  kinds of holder classes header file
+ ************************************************************************/
+/*************************************************************************
+ * Change History
+ Jan 2005			Created
+ ************************************************************************/
+
+#ifndef _LWPDLVLISTHEADHOLDER_HXX_
+#define _LWPDLVLISTHEADHOLDER_HXX_
+
+#include "lwpobj.hxx"
+#include "lwpdlvlist.hxx"
+/**
+ * @brief	VO_HEADHOLDER, LwpDLVListHeadHolder, 
+ * 		contains an id to the head of LwpDLVList
+*/
+class LwpDLVListHeadHolder : public LwpObject
+{
+public:
+	LwpDLVListHeadHolder(LwpObjectHeader& objHdr, LwpSvStream* pStrm);
+	~LwpDLVListHeadHolder(){};
+	void Read();
+	LwpObjectID* GetHeadID() { return &m_DLVHead;}
+private:
+	LwpObjectID m_DLVHead;
+};
+/**
+ * @brief	VO_HEADTAILHOLDER, LwpDLVListHeadTailHolder, 
+ * 		contains a LwpDLVListHeadTail (Head and tail id)
+*/
+class LwpDLVListHeadTailHolder : public LwpObject
+{
+public:
+	LwpDLVListHeadTailHolder(LwpObjectHeader& objHdr, LwpSvStream* pStrm);
+	~LwpDLVListHeadTailHolder(){};
+	void Read();
+	LwpObjectID* GetHead(){ return m_HeadTail.GetHead();}
+	LwpObjectID* GetTail(){ return m_HeadTail.GetTail();}
+protected:
+	LwpDLVListHeadTail m_HeadTail;
+};
+/**
+ * @brief	LwpObjectHolder, which is LwpDLVList, contains an id to an object
+ *		VO_OBJECTHOLDER
+*/
+class LwpObjectHolder : public LwpDLVList
+{
+public:
+	LwpObjectHolder(LwpObjectHeader& objHdr, LwpSvStream* pStrm);
+	~LwpObjectHolder(){};
+	void Read();
+	LwpObjectID* GetObject(){return &m_Object;}
+protected:
+	LwpObjectID m_Object;
+};
+
+/**
+ * @brief		VO_LISTLIST object in .lwp file  
+ * 
+ */
+class LwpListList : public LwpObjectHolder
+{
+public:
+	LwpListList(LwpObjectHeader& objHdr, LwpSvStream* pStrm);
+	~LwpListList(){};
+	void Read();
+	LwpObjectID* GetHead(){ return m_HeadTail.GetHead();}
+	LwpObjectID* GetTail(){ return m_HeadTail.GetTail();}
+protected:
+	LwpDLVListHeadTail m_HeadTail;
+};
+
+#endif
diff -urNp lotuswordpro.bak/source/filter/lwphyperlinkmgr.cxx lotuswordpro/source/filter/lwphyperlinkmgr.cxx
--- lotuswordpro.bak/source/filter/lwphyperlinkmgr.cxx	1970-01-01 08:00:00.000000000 +0800
+++ lotuswordpro/source/filter/lwphyperlinkmgr.cxx	2008-10-22 11:42:29.000000000 +0800
@@ -0,0 +1,82 @@
+/*************************************************************************
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: IBM Corporation
+ *
+ *  Copyright: 2008 by IBM Corporation
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+/*************************************************************************
+ * @file 
+ *  For LWP filter architecture prototype
+ ************************************************************************/
+/*************************************************************************
+ * Change History
+ Mar 2005			Created
+ ************************************************************************/
+#include "lwphyperlinkmgr.hxx"
+
+LwpHyperlinkMgr::LwpHyperlinkMgr()
+{
+	m_bIsHyperlink = sal_False;
+}
+
+LwpHyperlinkMgr::~LwpHyperlinkMgr()
+{		
+}
+
+OUString LwpHyperlinkMgr::GetHyperlink()
+{
+	return m_Hyperlink;
+}
+
+void LwpHyperlinkMgr::SetHyperlink(OUString hyperlink)
+{
+	m_Hyperlink = hyperlink;
+}
\ No newline at end of file
diff -urNp lotuswordpro.bak/source/filter/lwphyperlinkmgr.hxx lotuswordpro/source/filter/lwphyperlinkmgr.hxx
--- lotuswordpro.bak/source/filter/lwphyperlinkmgr.hxx	1970-01-01 08:00:00.000000000 +0800
+++ lotuswordpro/source/filter/lwphyperlinkmgr.hxx	2008-10-22 11:42:29.000000000 +0800
@@ -0,0 +1,82 @@
+/*************************************************************************
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: IBM Corporation
+ *
+ *  Copyright: 2008 by IBM Corporation
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+/*************************************************************************
+ * @file 
+ *  For LWP filter architecture prototype
+ ************************************************************************/
+/*************************************************************************
+ * Change History
+ Mar 2005			Created
+ ************************************************************************/
+#ifndef _LWPHYPERLINKMGR_HXX_
+#define _LWPHYPERLINKMGR_HXX_
+
+#include "lwpfilehdr.hxx"
+
+class LwpHyperlinkMgr
+{
+public:
+	LwpHyperlinkMgr();
+	~LwpHyperlinkMgr();
+	void SetHyperlinkFlag(sal_Bool bFlag){m_bIsHyperlink = bFlag;}
+	sal_Bool GetHyperlinkFlag(){return m_bIsHyperlink;}
+	void SetHyperlink(OUString hyperlink);
+	OUString GetHyperlink();
+private:
+	OUString m_Hyperlink;
+	sal_Bool m_bIsHyperlink;
+};
+
+#endif
diff -urNp lotuswordpro.bak/source/filter/lwpidxmgr.cxx lotuswordpro/source/filter/lwpidxmgr.cxx
--- lotuswordpro.bak/source/filter/lwpidxmgr.cxx	1970-01-01 08:00:00.000000000 +0800
+++ lotuswordpro/source/filter/lwpidxmgr.cxx	2008-10-22 11:42:29.000000000 +0800
@@ -0,0 +1,354 @@
+/*************************************************************************
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: IBM Corporation
+ *
+ *  Copyright: 2008 by IBM Corporation
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+/**********************************************************************************************************************
+ * @file 
+ *   index manager implementation
+ *  Three record types are related with index information, and two ways are used.
+*  1. VO_ROOTOBJINDEX works with one or more VO_LEAFOBJINDEX records to 
+*  provide the map of all object ids and their offsets. 
+*  VO_ROOTOBJINDEX includes k (object id, offset) and timetable which is used to map index to actual low id
+ *  2. VO_ROOTLEAFOBJINDEX is used when the file is so small that the number of objects is less than 256(?)
+ *  VO_ROOTLEAFOBJINDEX contains directly the (object id, offset) map and time table.
+/**********************************************************************************************************************/
+/**********************************************************************************************************************
+ * Change History
+ Jan 2005			Created
+/**********************************************************************************************************************/
+
+#include "lwpidxmgr.hxx"
+
+const sal_uInt8 LwpIndexManager::MAXOBJECTIDS = 255;
+
+LwpIndexManager::LwpIndexManager()
+	:m_nKeyCount(0), m_nLeafCount(0)
+{
+	
+	m_TempVec.resize( LwpIndexManager::MAXOBJECTIDS );
+	
+}
+
+LwpIndexManager::~LwpIndexManager()
+{
+	//Clear m_ObjectKeys
+	std::vector<LwpKey*>::iterator it;
+
+	for( it = m_ObjectKeys.begin(); it != m_ObjectKeys.end(); it++ )
+	{
+		LwpKey* pKey = *it;
+		if( pKey )
+		{
+			delete pKey;
+			pKey = NULL;
+		}			
+	}
+	m_ObjectKeys.clear();
+}
+
+/**
+ * @descr	Read all index records, VO_ROOTLEAFOBJINDEX, VO_ROOTOBJINDEX, VO_LEAFOBJINDEX
+ */
+void LwpIndexManager::Read(LwpSvStream* pStrm)
+{
+	//Read index obj
+	LwpObjectHeader ObjHdr;
+	ObjHdr.Read(*pStrm);
+	LwpObjectStream* pObjStrm = new LwpObjectStream(pStrm, ObjHdr.IsCompressed(), 
+			static_cast<sal_uInt16>(ObjHdr.GetSize()) );
+
+	if( ObjHdr.GetTag() == VO_ROOTLEAFOBJINDEX )
+	{
+		ReadLeafData(pObjStrm);
+		ReadTimeTable(pObjStrm);
+		delete pObjStrm;
+	}
+	else
+	{
+		ReadRootData(pObjStrm);
+		delete pObjStrm;
+
+		for (sal_uInt16 k = 0; k < m_nLeafCount; k++)
+		{
+			//Read leaf
+			pStrm->Seek(m_ChildIndex[k]+LwpSvStream::LWP_STREAM_BASE);
+
+			
+			//Old Code
+			//ReadLeafIndex(pStrm);
+			//New Code
+			ReadObjIndex( pStrm );
+			
+			
+			//Read object in root, these objects are between the leaf objects
+			if(k!=m_nLeafCount-1)  
+			{
+				m_ObjectKeys.push_back(m_RootObjs[k]);
+				m_nKeyCount ++;
+			}
+		}
+		m_RootObjs.clear();
+	}
+}
+
+/**
+ * @descr	Read data in VO_ROOTOBJINDEX
+ */
+void LwpIndexManager::ReadRootData(LwpObjectStream* pObjStrm)
+{
+
+	sal_uInt16 KeyCount = 0;
+	pObjStrm->QuickRead(&KeyCount, sizeof(KeyCount));
+	m_nLeafCount = KeyCount + 1;
+
+	if(KeyCount)
+	{
+		//read object keys
+		LwpKey* akey = new LwpKey();
+		akey->id.Read(pObjStrm);
+		m_RootObjs.push_back(akey);
+
+		
+		//sal_uInt8 k = 0;
+		sal_uInt16 k = 0;
+		
+		for (k = 1; k < KeyCount; k++)
+		{
+			akey = new LwpKey();
+			akey->id.ReadCompressed(pObjStrm, m_RootObjs[k-1]->id);
+			m_RootObjs.push_back(akey);
+		}
+
+		for (k = 0; k < KeyCount; k++)
+		{
+			pObjStrm->QuickRead(&(m_RootObjs[k]->offset), sizeof(sal_uInt32));
+		}
+
+		//read leaf index offset
+		for (k = 0; k < m_nLeafCount; k++)
+		{
+			pObjStrm->QuickRead(&(m_ChildIndex[k]), sizeof(sal_uInt32));
+		}
+	}
+
+	ReadTimeTable(pObjStrm);
+
+}
+
+
+//Add new method to handle ObjIndex data
+/**
+ * @descr	Read data in VO_OBJINDEX
+ */
+void LwpIndexManager::ReadObjIndexData(LwpObjectStream* pObjStrm)
+{
+	sal_uInt16 KeyCount = 0;
+	sal_uInt16 LeafCount = 0;
+	pObjStrm->QuickRead(&KeyCount, sizeof(KeyCount));
+	LeafCount = KeyCount + 1;
+
+	std::vector<LwpKey*> vObjIndexs;
+
+	if(KeyCount)
+	{
+		LwpKey* akey = new LwpKey();
+		akey->id.Read(pObjStrm);
+		vObjIndexs.push_back(akey);
+
+		sal_uInt16 k = 0;
+
+		for (k = 1; k < KeyCount; k++)
+		{
+			akey = new LwpKey();
+			akey->id.ReadCompressed(pObjStrm, vObjIndexs[k-1]->id);
+			vObjIndexs.push_back(akey);
+		}
+						
+		for (k = 0; k < KeyCount; k++)
+			pObjStrm->QuickRead(&(vObjIndexs[k]->offset), sizeof(sal_uInt32));
+
+		for (k = 0; k < LeafCount; k++)
+			pObjStrm->QuickRead(&(m_TempVec[k]), sizeof(sal_uInt32));
+	}
+
+	for( sal_uInt16 j=0; j<LeafCount; j++ ) 
+	{
+		pObjStrm->GetStream()->Seek( m_TempVec[j]+LwpSvStream::LWP_STREAM_BASE);
+		ReadLeafIndex(pObjStrm->GetStream());
+
+		if(j!=LeafCount-1)
+		{
+			m_ObjectKeys.push_back(vObjIndexs[j]);
+
+			m_nKeyCount ++;
+		}
+	}
+
+	vObjIndexs.clear();
+	m_TempVec.clear();
+}
+
+
+/**
+ * @descr	Read VO_OBJINDEX
+ */
+void LwpIndexManager::ReadObjIndex( LwpSvStream *pStrm )
+{
+
+	LwpObjectHeader ObjHdr;
+	ObjHdr.Read(*pStrm);
+	LwpObjectStream* pObjStrm = new LwpObjectStream(pStrm, ObjHdr.IsCompressed(), 
+			static_cast<sal_uInt16>(ObjHdr.GetSize()) );
+
+	if( (sal_uInt32)VO_OBJINDEX == ObjHdr.GetTag() )
+	{
+		ReadObjIndexData( pObjStrm );
+	}
+	else if( (sal_uInt32)VO_LEAFOBJINDEX == ObjHdr.GetTag() )
+	{
+		ReadLeafData(pObjStrm);
+	}
+
+	delete pObjStrm;
+}
+
+
+/**
+ * @descr	Read VO_LEAFOBJINDEX
+ */
+void LwpIndexManager::ReadLeafIndex( LwpSvStream *pStrm )
+{
+	LwpObjectHeader ObjHdr;
+	ObjHdr.Read(*pStrm);
+	LwpObjectStream* pObjStrm = new LwpObjectStream(pStrm, ObjHdr.IsCompressed(), 
+			static_cast<sal_uInt16>(ObjHdr.GetSize()) );
+
+	ReadLeafData(pObjStrm);
+
+	delete pObjStrm;
+}
+/**
+ * @descr	Read data in VO_LEAFOBJINDEX
+ */
+void LwpIndexManager::ReadLeafData( LwpObjectStream *pObjStrm )
+{
+	sal_uInt16 KeyCount;
+	pObjStrm->QuickRead(&KeyCount, sizeof(KeyCount));
+
+	if(KeyCount)
+	{
+		LwpKey* akey = new LwpKey();
+		//read object keys: id & offset
+		akey->id.Read(pObjStrm);
+		m_ObjectKeys.push_back(akey);
+
+		for (sal_uInt8 k = 1; k < KeyCount; k++)
+		{
+			akey = new LwpKey();
+			akey->id.ReadCompressed(pObjStrm, m_ObjectKeys[m_nKeyCount+k-1]->id);
+			m_ObjectKeys.push_back(akey);
+		}
+						
+		for (sal_uInt8 j = 0; j < KeyCount; j++)
+		{
+			pObjStrm->QuickRead(&(m_ObjectKeys[m_nKeyCount+j]->offset), sizeof(sal_uInt32));
+		}
+	}
+	m_nKeyCount += KeyCount;
+}
+/**
+ * @descr	Read time table in VO_ROOTLEAFOBJINDEX and VO_ROOTOBJINDEX
+ */
+void LwpIndexManager::ReadTimeTable(LwpObjectStream *pObjStrm)
+{
+	sal_uInt16 nTimeCount;
+	pObjStrm->QuickRead(&nTimeCount, sizeof(nTimeCount));
+
+	sal_uInt32 atime;
+	for(sal_uInt16 i=0; i<nTimeCount; i++)
+	{
+		pObjStrm->QuickRead( &atime, sizeof(atime) );
+		m_TimeTable.push_back(atime);
+	}
+}
+/**
+ * @descr		get object offset per the object id
+ */
+sal_uInt32 LwpIndexManager::GetObjOffset( LwpObjectID objid )
+{
+	
+	//sal_uInt16 L, U, M;
+	sal_uInt32 L, U, M;
+	
+
+	L = 0;
+	U = m_nKeyCount;
+	while (L != U)
+	{
+		M = (L + U) >> 1;
+
+		if (objid.GetLow() > m_ObjectKeys[M]->id.GetLow())
+			L = M + 1;
+		else if (objid.GetLow() < m_ObjectKeys[M]->id.GetLow())
+			U = M;
+		else if (objid.GetHigh() > m_ObjectKeys[M]->id.GetHigh())
+			L = M + 1;
+		else if (objid.GetHigh() < m_ObjectKeys[M]->id.GetHigh())
+			U = M;
+		else
+		{
+			return(m_ObjectKeys[M]->offset);
+		}
+	}
+	return BAD_OFFSET;
+}
diff -urNp lotuswordpro.bak/source/filter/lwpidxmgr.hxx lotuswordpro/source/filter/lwpidxmgr.hxx
--- lotuswordpro.bak/source/filter/lwpidxmgr.hxx	1970-01-01 08:00:00.000000000 +0800
+++ lotuswordpro/source/filter/lwpidxmgr.hxx	2008-10-22 11:42:29.000000000 +0800
@@ -0,0 +1,116 @@
+/*************************************************************************
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: IBM Corporation
+ *
+ *  Copyright: 2008 by IBM Corporation
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+/*************************************************************************
+ * @file 
+ *  index manager, to maintain the map between object id and offset
+ ************************************************************************/
+/*************************************************************************
+ * Change History
+ Jan 2005			Created
+ ************************************************************************/
+
+#ifndef _LWPINDEXMANAGER_HXX
+#define _LWPINDEXMANAGER_HXX
+
+#include <rtl/ustring.hxx>
+#include "lwpobjhdr.hxx"
+#include "lwpobjstrm.hxx"
+
+/**
+ * @brief	key structure used to map id to offset
+*/
+struct LwpKey
+{
+	LwpObjectID id;
+	sal_uInt32 offset;
+};
+/**
+ * @brief	LwpIndexManager, to read all index records and maintain the index information
+*/
+class LwpIndexManager
+{
+public:
+	LwpIndexManager();
+	~LwpIndexManager();
+protected:
+	static const sal_uInt8 MAXOBJECTIDS;
+	std::vector<LwpKey*> m_ObjectKeys;	//the <id, offset> ordered vector
+	std::vector<LwpKey*> m_RootObjs;		//For those object ids in RootObjIndex
+	std::vector<sal_uInt32> m_TimeTable;	//Time table for object low id compression
+	
+	//sal_uInt16 m_nKeyCount;
+	sal_uInt32 m_nKeyCount;		//the count of all object
+	std::vector<sal_uInt32> m_TempVec;	// a temp vector , store the offset of leafindex
+	
+	sal_uInt32 m_ChildIndex[256];	//Offset of leaf index
+	sal_uInt16 m_nLeafCount;
+protected:
+	void ReadRootData(LwpObjectStream *pObjStrm );	//Read root index data
+
+	
+	//Add new method to handle ObjIndex
+	void ReadObjIndexData(LwpObjectStream* pObjStrm);
+	void ReadObjIndex( LwpSvStream *pStrm );	//Read Obj index 
+	
+
+	void ReadLeafIndex( LwpSvStream *pStrm );	//Read leaf index obj
+	void ReadLeafData( LwpObjectStream *pStrm );	//Read leaf index obj data
+	void ReadTimeTable( LwpObjectStream *pStrm );	
+public:
+	void Read( LwpSvStream *pStrm );
+	sal_uInt32 GetObjOffset( LwpObjectID objid );
+	sal_uInt32 GetObjTime( sal_uInt16 index ) { return m_TimeTable[index-1]; }
+};
+#endif
diff -urNp lotuswordpro.bak/source/filter/lwplayout.cxx lotuswordpro/source/filter/lwplayout.cxx
--- lotuswordpro.bak/source/filter/lwplayout.cxx	1970-01-01 08:00:00.000000000 +0800
+++ lotuswordpro/source/filter/lwplayout.cxx	2008-10-22 11:42:29.000000000 +0800
@@ -0,0 +1,2215 @@
+/*************************************************************************
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: IBM Corporation
+ *
+ *  Copyright: 2008 by IBM Corporation
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+/*************************************************************************
+ * @file 
+ *  For LWP filter architecture prototype
+ ************************************************************************/
+/*************************************************************************
+ * Change History
+ Jan 2005			Created
+ Feb 2005			Process gemotry, margins
+ ************************************************************************/
+
+#include "lwplayout.hxx"
+#include "lwpusewhen.hxx"
+#include "lwptools.hxx"
+#include "xfilter/xfcolumns.hxx"
+#include "lwpstory.hxx"
+#include "lwpparastyle.hxx"
+#include "lwpholder.hxx"
+#include "lwpdoc.hxx"
+#include "lwppagehint.hxx"
+#include "lwpdivinfo.hxx"
+#include "lwpgrfobj.hxx"
+#ifndef _OSL_THREAD_H_
+#include <osl/thread.h>
+#endif
+
+LwpVirtualLayout::LwpVirtualLayout(LwpObjectHeader &objHdr, LwpSvStream* pStrm)
+	: LwpDLNFPVList(objHdr, pStrm)
+{}
+
+void LwpVirtualLayout::Read()
+{
+	LwpDLNFPVList::Read();
+	
+	LwpObjectStream* pStrm = m_pObjStrm;
+	pStrm->QuickRead(&m_nAttributes, sizeof(m_nAttributes)); 
+	pStrm->QuickRead(&m_nAttributes2, sizeof(m_nAttributes2)); 	
+	pStrm->QuickRead(&m_nAttributes3, sizeof(m_nAttributes3)); 
+	pStrm->QuickRead(&m_nOverrideFlag, sizeof(m_nOverrideFlag)); 
+	pStrm->QuickRead(&m_nDirection, sizeof(m_nDirection)); 
+
+	//Note that two bytes is read into m_nEditorID instead of one byte.
+	pStrm->QuickRead(&m_nEditorID, sizeof(m_nEditorID)); 
+
+	m_NextEnumerated.ReadIndexed(pStrm);
+	m_PreviousEnumerated.ReadIndexed(pStrm);	
+
+	pStrm->SkipExtra();
+}
+
+sal_Bool LwpVirtualLayout::MarginsSameAsParent()
+{
+	return m_nAttributes2 & STYLE2_MARGINSSAMEASPARENT ? sal_True : sal_False;
+}
+
+/**
+* @descr: 	Get column width
+*
+*/
+double LwpVirtualLayout::GetColWidth(sal_uInt16 nIndex)
+{
+	//return GetContentWidth(); //not support now
+	//return LwpTools::ConvertToMetric(5); //test
+	return 0; //test
+}
+
+/**
+* @descr: 	Get the gap between columns
+*
+*/
+double LwpVirtualLayout::GetColGap(sal_uInt16 nIndex)
+{
+	//return DEFAULTGAPSIZE;
+	//return LwpTools::ConvertToMetric(0.17);//DEFAULTGAPSIZE=0.17
+	return LwpTools::ConvertToMetric(0.17);
+}
+
+/**
+* @descr: 	Whether it is honoring protection
+*
+*/
+sal_Bool LwpVirtualLayout::HonorProtection()
+{
+	if(!(m_nAttributes2 & STYLE2_HONORPROTECTION))
+		return sal_False;
+
+	LwpVirtualLayout* pParent = static_cast<LwpVirtualLayout*> (GetParent()->obj());
+	if(pParent && !pParent->IsHeader())
+	{
+		return pParent->HonorProtection();
+	}
+
+	if(m_pFoundry)//is null now
+	{
+		LwpDocument* pDoc = m_pFoundry->GetDocument();
+		/*if(pDoc)
+		{
+			return pDoc->HonorProtection();
+		}*/
+		if(pDoc && pDoc->GetRootDocument())
+			return pDoc->GetRootDocument()->HonorProtection();
+	}
+
+	return sal_True;
+}
+
+/**
+* @descr: 	Whether it is protected
+*
+*/
+sal_Bool LwpVirtualLayout::IsProtected()
+{
+	sal_Bool bProtected = (m_nAttributes & STYLE_PROTECTED)!=0;
+
+	LwpVirtualLayout* pParent = static_cast<LwpVirtualLayout*> (GetParent()->obj());
+	if(pParent && !pParent->IsHeader())
+	{
+		if(pParent->HonorProtection()&&(pParent->HasProtection()||bProtected))
+		{
+			return sal_True;
+		}
+	}
+	else if(m_pFoundry)//is null now
+	{
+		LwpDocument* pDoc = m_pFoundry->GetDocument();
+		if(pDoc)
+		{
+			if (pDoc->HonorProtection() && bProtected)
+			{
+				return sal_True;
+			}
+		}
+	}	
+
+	return sal_False;
+}
+
+/**
+* @descr: 	Whether it has protection
+*
+*/
+sal_Bool LwpVirtualLayout::HasProtection()
+{
+	if(m_nAttributes & STYLE_PROTECTED)
+		return sal_True;
+
+	LwpVirtualLayout* pParent = static_cast<LwpVirtualLayout*> (GetParent()->obj());
+	if(pParent && !pParent->IsHeader())
+	{
+		return pParent->HasProtection();
+	}
+
+	return sal_False;
+}
+
+/**
+* @descr: 	Whether it is a mirror layout
+*
+*/
+sal_Bool LwpVirtualLayout::IsComplex()
+{
+	return m_nAttributes & STYLE_COMPLEX ? sal_True : sal_False;
+}
+
+/**
+* @descr: 	Get usewhen pointer
+*
+*/
+LwpUseWhen* LwpVirtualLayout::GetUseWhen()
+{
+	/* 
+		If we have a parent, and I'm not a page layout,
+		use my parents information.
+	*/
+	if(GetLayoutType()!=LWP_PAGE_LAYOUT)
+	{
+		//get parent
+		LwpVirtualLayout* pParent = static_cast<LwpVirtualLayout*> (GetParent()->obj());
+		if(pParent && !pParent->IsHeader()&& (pParent->GetLayoutType()!=LWP_PAGE_LAYOUT))
+			return pParent->GetUseWhen();
+
+	}
+
+	return VirtualGetUseWhen();
+}
+/**
+ * @descr:  Whether this layout is page layout or not
+ * @param:   
+ * @return:  
+*/
+sal_Bool LwpVirtualLayout::IsPage()
+{
+	return (GetLayoutType() == LWP_PAGE_LAYOUT);
+}
+/**
+ * @descr:  Whether this layout is heaer layout or not
+ * @param:   
+ * @return:  
+*/
+sal_Bool LwpVirtualLayout::IsHeader()
+{
+	return (GetLayoutType() == LWP_HEADER_LAYOUT);
+}
+/**
+ * @descr:  Whether this layout is footer layout or not
+ * @param:   
+ * @return:  
+*/
+sal_Bool LwpVirtualLayout::IsFooter()
+{
+	return (GetLayoutType() == LWP_FOOTER_LAYOUT);
+}
+/**
+ * @descr:  Whether this layout is frame layout or not
+ * @param:   
+ * @return:  
+*/
+sal_Bool LwpVirtualLayout::IsFrame()
+{
+	return (GetLayoutType() == LWP_FRAME_LAYOUT);
+}
+
+/**
+ * @descr:  Whether this layout is cell layout or not
+ * @param:   
+ * @return:  
+*/
+sal_Bool LwpVirtualLayout::IsCell()
+{
+	return (GetLayoutType() == LWP_CELL_LAYOUT
+		|| GetLayoutType() == LWP_CONNECTED_CELL_LAYOUT
+		|| GetLayoutType() == LWP_HIDDEN_CELL_LAYOUT);
+}
+/**
+ * @descr:  Whether this layout is supertable layout or not
+ * @param:   
+ * @return:  
+*/
+sal_Bool LwpVirtualLayout::IsSuperTable()
+{
+	return (GetLayoutType() == LWP_SUPERTABLE_LAYOUT);
+}
+/**
+ * @descr:  Whether this layout is group layout or not
+ * @param:   
+ * @return:  
+*/
+sal_Bool LwpVirtualLayout::IsGroupHead()
+{
+	return (GetLayoutType() == LWP_GROUP_LAYOUT);
+}
+/**
+ * @descr:  get the relative type
+ * @param:   
+ * @return:  
+*/
+sal_uInt8 LwpVirtualLayout::GetRelativeType()
+{
+	return LwpLayoutRelativityGuts::LAY_PARENT_RELATIVE;
+}
+/**
+ * @descr:  whether it is relative anchored layout
+ * @param:   
+ * @return:  
+*/
+sal_Bool LwpVirtualLayout::IsRelativeAnchored()
+{
+	sal_uInt8 nType;
+
+	nType = GetRelativeType();
+	return (nType == LwpLayoutRelativityGuts::LAY_PARA_RELATIVE) || (nType == LwpLayoutRelativityGuts::LAY_INLINE)
+	|| (nType == LwpLayoutRelativityGuts::LAY_INLINE_NEWLINE) || (nType == LwpLayoutRelativityGuts::LAY_INLINE_VERTICAL);
+}
+/**
+ * @descr:  whether it is MinimumHeight layout
+ * @param:   
+ * @return:  
+*/
+sal_Bool LwpVirtualLayout::IsMinimumHeight()
+{
+	return ((m_nAttributes3& STYLE3_MINHEIGHTVALID) != 0);
+}
+
+/**
+* @descr: 	Get parent layout
+*
+*/
+LwpVirtualLayout* LwpVirtualLayout::GetParentLayout()
+{
+	return static_cast<LwpVirtualLayout*> (GetParent()->obj());	
+}
+
+/**
+* @descr:   Register child layout style
+* 		
+*/
+void LwpVirtualLayout::RegisterChildStyle()
+{
+	//Register all children styles
+	LwpVirtualLayout* pLayout = static_cast<LwpVirtualLayout*>(GetChildHead()->obj());
+	while(pLayout)
+	{
+		pLayout->SetFoundry(m_pFoundry);
+		pLayout->RegisterStyle();
+		pLayout = static_cast<LwpVirtualLayout*>(pLayout->GetNext()->obj());
+	}
+}
+
+sal_Bool LwpVirtualLayout::NoContentReference()
+{
+	return (m_nAttributes2 & STYLE2_NOCONTENTREFERENCE) != 0;
+}
+
+sal_Bool LwpVirtualLayout::IsStyleLayout()
+{
+	if (m_nAttributes3 & STYLE3_STYLELAYOUT)
+		return sal_True;
+
+	LwpVirtualLayout* pParent =static_cast<LwpVirtualLayout*>(GetParent()->obj());
+	if (pParent)
+		return pParent->IsStyleLayout();
+	return sal_False;
+}
+
+/**
+* @descr: 	Find child layout by layout type
+*
+*/
+LwpVirtualLayout* LwpVirtualLayout::FindChildByType(LWP_LAYOUT_TYPE eType)
+{
+	LwpObjectID *pID = GetChildHead();
+
+	while(pID && !pID->IsNull())
+	{
+		LwpVirtualLayout * pLayout = static_cast<LwpVirtualLayout *>(pID->obj());
+		if(!pLayout)
+		{
+			break;
+		}
+		
+		if (pLayout && pLayout->GetLayoutType() == eType)
+		{
+			return pLayout;
+		}
+		pID = pLayout->GetNext();
+	}
+
+	return NULL;
+}
+
+/**
+* @descr: 	Whether the size of layout is fit the graphic
+*
+*/
+sal_Bool LwpVirtualLayout::IsFitGraphic()
+{
+	return IsAutoGrowRight() && !IsAutoGrowLeft() && IsAutoGrowDown();
+}
+
+/**
+* @descr: 	Whether the width of layout is auto grow
+*
+*/
+sal_Bool LwpVirtualLayout::IsAutoGrowWidth()
+{
+	return IsAutoGrowLeft() || IsAutoGrowRight();
+}
+
+/**
+* @descr: 	Determine whether the layout width is to margin
+*
+*/
+sal_Bool LwpVirtualLayout::IsInlineToMargin()
+{
+	return (m_nAttributes3 & STYLE3_INLINETOMARGIN) != 0;
+}
+
+void LwpAssociatedLayouts::Read(LwpObjectStream* pStrm)
+{
+	m_OnlyLayout.ReadIndexed(pStrm);
+	m_Layouts.Read(pStrm);
+	pStrm->SkipExtra();
+}
+
+/**
+* @descr: 	Looking for the layout which follows the pStartLayout
+* @param:  	pStartLayout - the layout which is used for looking for its following layout
+*/
+LwpVirtualLayout* LwpAssociatedLayouts::GetLayout(LwpVirtualLayout *pStartLayout)
+{
+	LwpVirtualLayout* pLayout = NULL;
+
+	if (!pStartLayout && !m_OnlyLayout.IsNull())
+		/* Looking for the first layout and there's only one layout in  the list.*/
+		return static_cast<LwpVirtualLayout*>(m_OnlyLayout.obj());
+	
+	LwpObjectHolder* pObjHolder =static_cast<LwpObjectHolder*>(m_Layouts.GetHead()->obj());
+	if(pObjHolder)
+	{
+		pLayout = static_cast<LwpVirtualLayout*>(pObjHolder->GetObject()->obj());
+		if(!pStartLayout )
+			return pLayout;
+
+		while(pObjHolder && pStartLayout != pLayout)
+		{
+			pObjHolder = static_cast<LwpObjectHolder*>(pObjHolder->GetNext()->obj());
+			if(pObjHolder)
+			{
+				pLayout = static_cast<LwpVirtualLayout*>(pObjHolder->GetObject()->obj());
+			}
+		}
+
+		if(pObjHolder)
+		{
+			pObjHolder = static_cast<LwpObjectHolder*>(pObjHolder->GetNext()->obj());
+			if(pObjHolder)
+			{
+				pLayout = static_cast<LwpVirtualLayout*>(pObjHolder->GetObject()->obj());
+				return pLayout;
+			}
+		}
+
+		//return pLayout;
+	}
+
+	return NULL;
+}
+
+LwpHeadLayout::LwpHeadLayout(LwpObjectHeader &objHdr, LwpSvStream* pStrm)
+	: LwpVirtualLayout(objHdr, pStrm)
+{}
+
+void LwpHeadLayout::Read()
+{
+	LwpVirtualLayout::Read();
+	//For PermissiveLayout
+	m_pObjStrm->SkipExtra();
+	//For me
+	m_pObjStrm->SkipExtra();
+}
+
+void LwpHeadLayout::RegisterStyle()
+{
+	//Register all children styles
+	LwpVirtualLayout* pLayout = static_cast<LwpVirtualLayout*>(GetChildHead()->obj());
+	while(pLayout)
+	{
+		pLayout->SetFoundry(m_pFoundry);
+		//if the layout is relative to para, the layout will be registered in para
+		if(!pLayout->IsRelativeAnchored())
+		{			
+			pLayout->RegisterStyle();
+		}		
+		pLayout = static_cast<LwpVirtualLayout*>(pLayout->GetNext()->obj());
+	}
+}
+
+/**
+ * @descr   find endnote supertable layout from the child layout list. Suppose that there is only one endnote supertablelayout in one division
+ * @return pointer to endnote supertable layout
+ */
+LwpVirtualLayout* LwpHeadLayout::FindEnSuperTableLayout()
+{
+	LwpVirtualLayout* pLayout = static_cast<LwpVirtualLayout*>(GetChildHead()->obj());
+	while(pLayout)
+	{		
+		if(pLayout->GetLayoutType() == LWP_ENDNOTE_SUPERTABLE_LAYOUT)
+		{			
+			return pLayout;
+		}		
+		pLayout = static_cast<LwpVirtualLayout*>(pLayout->GetNext()->obj());
+	}
+	return NULL;
+}
+
+LwpLayoutStyle::LwpLayoutStyle() :
+m_nStyleDefinition(0), m_nKey(0),
+m_pDescription(new LwpAtomHolder)
+{
+}
+
+LwpLayoutStyle::~LwpLayoutStyle()
+{
+	if (m_pDescription)
+	{
+		delete m_pDescription;
+	}
+}
+
+void LwpLayoutStyle::Read(LwpObjectStream* pStrm)
+{
+	pStrm->QuickRead(&m_nStyleDefinition, sizeof(m_nStyleDefinition));
+	m_pDescription->Read(pStrm);
+	if (pStrm->CheckExtra())
+	{
+		pStrm->QuickRead(&m_nKey, 2);
+		pStrm->SkipExtra();
+	}
+}
+
+LwpLayoutMisc::LwpLayoutMisc() :
+m_nGridDistance(0), m_nGridType(0),
+m_pContentStyle(new LwpAtomHolder)
+{
+}
+
+LwpLayoutMisc::~LwpLayoutMisc()
+{
+	if (m_pContentStyle)
+	{
+		delete m_pContentStyle;
+	}
+}
+
+void LwpLayoutMisc::Read(LwpObjectStream* pStrm)
+{
+	pStrm->QuickRead(&m_nGridType, 2);
+	pStrm->QuickRead(&m_nGridDistance, 4);
+	m_pContentStyle->Read(pStrm);
+	pStrm->SkipExtra();
+}
+
+LwpMiddleLayout::LwpMiddleLayout( LwpObjectHeader &objHdr, LwpSvStream* pStrm )
+	: LwpVirtualLayout(objHdr, pStrm), 
+	  m_pStyleStuff(new LwpLayoutStyle), m_pMiscStuff(new LwpLayoutMisc)
+{}
+
+LwpMiddleLayout::~LwpMiddleLayout()
+{
+	if (m_pStyleStuff)
+	{
+		delete m_pStyleStuff;
+	}
+	if (m_pMiscStuff)
+	{
+		delete m_pMiscStuff;
+	}
+}
+void LwpMiddleLayout::Read()
+{
+	LwpObjectStream* pStrm = m_pObjStrm;
+	
+	LwpVirtualLayout::Read();
+	
+	//skip CLiteLayout data;
+	LwpAtomHolder ContentClass;
+	ContentClass.Read(pStrm);
+	pStrm->SkipExtra();
+
+	// before layout hierarchy rework
+	if(LwpFileHeader::m_nFileRevision < 0x000B)
+		return;
+
+	m_Content.ReadIndexed(pStrm);
+
+	// 01/20/2005
+	m_BasedOnStyle.ReadIndexed(pStrm);
+	m_TabPiece.ReadIndexed(pStrm);
+
+	sal_uInt8 nWhatsItGot = 0;
+	pStrm->QuickRead(&nWhatsItGot, 1);
+
+	if (nWhatsItGot & DISK_GOT_STYLE_STUFF)
+	{
+		m_pStyleStuff->Read(pStrm);	
+	}
+	if (nWhatsItGot & DISK_GOT_MISC_STUFF)
+	{
+		m_pMiscStuff->Read(pStrm);
+	}
+
+	m_LayGeometry.ReadIndexed(pStrm);
+	m_LayScale.ReadIndexed(pStrm);
+	m_LayMargins.ReadIndexed(pStrm);
+	m_LayBorderStuff.ReadIndexed(pStrm);
+	m_LayBackgroundStuff.ReadIndexed(pStrm);
+
+	if (pStrm->CheckExtra())
+	{
+		m_LayExtBorderStuff.ReadIndexed(pStrm);
+		pStrm->SkipExtra();
+	}
+	//end
+}
+
+#include "lwplaypiece.hxx"
+
+/**
+* @descr: 	Get the geometry of current layout
+* 
+*/
+LwpLayoutGeometry* LwpMiddleLayout::GetGeometry()
+{
+	if( !m_LayGeometry.IsNull() )
+	{
+		return ( static_cast<LwpLayoutGeometry*> (m_LayGeometry.obj()) );
+	}
+	else if( !m_BasedOnStyle.IsNull() )
+	{
+		LwpMiddleLayout* pLay = static_cast<LwpMiddleLayout*> ( m_BasedOnStyle.obj() );
+		return pLay->GetGeometry();
+	}
+	return NULL;
+}
+
+/**
+* @descr: 	Get layout height, measured by "cm"
+* 
+*/
+double LwpMiddleLayout::GetGeometryHeight()
+{
+	LwpLayoutGeometry* pGeo = GetGeometry();
+	if(pGeo) 
+	{
+		return ( LwpTools::ConvertFromUnitsToMetric( pGeo->GetHeight() ) );
+	}
+	else
+		return -1;
+}
+
+/**
+* @descr: 	Get layout width, measured by "cm"
+* 
+*/
+double LwpMiddleLayout::GetGeometryWidth()
+{
+	LwpLayoutGeometry* pGeo = GetGeometry();
+	if(pGeo) 
+	{
+		return ( LwpTools::ConvertFromUnitsToMetric( pGeo->GetWidth() ) );
+	}
+	else 
+		return -1;
+}
+
+/**
+* @descr: 	Whether the margins is same as parent layout
+* 
+*/
+BOOL LwpMiddleLayout::MarginsSameAsParent()
+{
+	if(m_nOverrideFlag & OVER_MARGINS)
+	{
+		return LwpVirtualLayout::MarginsSameAsParent();
+	}
+	if(!m_BasedOnStyle.IsNull())
+	{
+		LwpVirtualLayout* play = static_cast<LwpVirtualLayout*> (m_BasedOnStyle.obj());
+		play->MarginsSameAsParent();
+	}
+	return LwpVirtualLayout::MarginsSameAsParent();
+	
+}
+
+/**
+* @descr: 	Get margin
+* @param:  	nWhichSide - 0: left, 1: right, 2:top, 3: bottom
+*/
+double LwpMiddleLayout::GetMarginsValue(const sal_uInt8 &nWhichSide)
+{
+	double fValue = 0;
+	if((nWhichSide==MARGIN_LEFT)||(nWhichSide==MARGIN_RIGHT))
+	{
+		if ( MarginsSameAsParent() )
+		{
+			LwpVirtualLayout* pParent = static_cast<LwpVirtualLayout*> (GetParent()->obj());
+			if(pParent && !pParent->IsHeader())
+			{
+				fValue = pParent->GetMarginsValue(nWhichSide);
+				return fValue;
+			}
+		}
+	}
+
+	if(m_nOverrideFlag & OVER_MARGINS)
+	{
+		LwpLayoutMargins* pMar1 = static_cast<LwpLayoutMargins*> (m_LayMargins.obj());
+		if(pMar1)
+		{
+			fValue = pMar1->GetMargins()->GetMarginsValue(nWhichSide);			
+			return fValue;
+		}
+	}
+	LwpVirtualLayout* pStyle = static_cast<LwpVirtualLayout*> (m_BasedOnStyle.obj());
+	if(pStyle)
+	{
+		fValue = pStyle->GetMarginsValue(nWhichSide);
+		return fValue;
+	}
+	return LwpVirtualLayout::GetMarginsValue(nWhichSide);
+}
+/**
+ * @descr:	Get extmargin value
+ * @param:	nWhichSide - 0: left, 1: right, 2:top, 3: bottom
+ * @param:   
+ * @return:  
+*/
+double LwpMiddleLayout::GetExtMarginsValue(const sal_uInt8 &nWhichSide)
+{
+	double fValue = 0;	
+	if(m_nOverrideFlag & OVER_MARGINS)
+	{
+		LwpLayoutMargins* pMar1 = static_cast<LwpLayoutMargins*> (m_LayMargins.obj());
+		if(pMar1)
+		{
+			fValue = pMar1->GetExtMargins()->GetMarginsValue(nWhichSide);			
+			return fValue;
+		}
+	}
+	LwpVirtualLayout* pStyle = static_cast<LwpVirtualLayout*> (m_BasedOnStyle.obj());
+	if(pStyle)
+	{
+		fValue = pStyle->GetExtMarginsValue(nWhichSide);
+		return fValue;
+	}
+	return LwpVirtualLayout::GetExtMarginsValue(nWhichSide);
+}
+/**
+ * @descr:  Get the LwpBorderStuff object according to m_LayBorderStuff id.
+ * @param:   
+ * @param:   
+ * @return:  
+*/
+LwpBorderStuff* LwpMiddleLayout::GetBorderStuff()
+{
+	if(m_nOverrideFlag & OVER_BORDERS)
+	{
+		LwpLayoutBorder* pLayoutBorder = static_cast<LwpLayoutBorder*>(m_LayBorderStuff.obj());
+		return pLayoutBorder->GetBorderStuff();
+	}
+	else if( !m_BasedOnStyle.IsNull() )
+	{
+		LwpMiddleLayout* pLay = static_cast<LwpMiddleLayout*> ( m_BasedOnStyle.obj() );
+		return pLay->GetBorderStuff();
+	}
+	return NULL;
+}
+
+/**
+ * @descr:  Get LwpBackgroundStuff object according to m_LayBackgroundStuff id; 
+ * @param:   
+ * @param:   
+ * @return:  
+*/
+LwpBackgroundStuff* LwpMiddleLayout::GetBackgroundStuff()
+{
+	if(m_nOverrideFlag & OVER_BACKGROUND)
+	{
+		LwpLayoutBackground* pLayoutBackground = static_cast<LwpLayoutBackground*>(m_LayBackgroundStuff.obj());
+		return pLayoutBackground->GetBackgoudStuff();
+	}
+	else if( !m_BasedOnStyle.IsNull() )
+	{
+		LwpMiddleLayout* pLay = static_cast<LwpMiddleLayout*> ( m_BasedOnStyle.obj() );
+		return pLay->GetBackgroundStuff();
+	}
+	return NULL;
+}
+/**
+ * @descr:  create xfborder.  
+ * @param:   
+ * @param:   
+ * @return:  
+*/
+XFBorders* LwpMiddleLayout::GetXFBorders()
+{
+	LwpBorderStuff* pBorderStuff = GetBorderStuff();
+	if(pBorderStuff&&pBorderStuff->GetSide() != 0)
+	{
+		//copy from lwpparastyle.
+		XFBorders	*pXFBorders = new XFBorders();
+		// apply 4 borders respectively
+		LwpBorderStuff::BorderType pType[] = { LwpBorderStuff::LEFT, LwpBorderStuff::RIGHT,
+			LwpBorderStuff::TOP, LwpBorderStuff::BOTTOM };
+
+		for (sal_uInt8 nC = 0; nC < 4; nC++)
+		{
+			if (pBorderStuff->HasSide(pType[nC]))
+			{
+				LwpParaStyle::ApplySubBorder(pBorderStuff, pType[nC], pXFBorders);
+			}
+		}
+		return pXFBorders;
+	}
+	return NULL;
+}
+
+/**
+ * @descr:  Get text direction settings.  
+ * @param:   
+ * @param:   
+ * @return:  
+*/
+enumXFTextDir LwpMiddleLayout::GetTextDirection()
+{
+	enumXFTextDir eTextDir = enumXFTextDirNone;
+	sal_uInt8 nDirection = GetContentOrientation();
+	switch(nDirection)
+	{
+		case TEXT_ORIENT_LRTB:
+		{
+			eTextDir = enumXFTextDirLR_TB;
+			break;
+		}
+		case TEXT_ORIENT_TBRL:
+		{
+			eTextDir = enumXFTextDirTB_RL;
+			break;
+		}
+		case TEXT_ORIENT_RLBT: // not supported now
+		{
+			eTextDir = enumXFTextDirNone;
+			break;
+		}
+		case TEXT_ORIENT_BTLR: // not supported now
+		{
+			eTextDir = enumXFTextDirNone;
+			break;
+		}
+		default:
+			break;
+	}
+	return eTextDir;
+}
+/**
+ * @descr: Get back ground color.  
+ * @param:   
+ * @param:   
+ * @return:  
+*/
+LwpColor* LwpMiddleLayout::GetBackColor()
+{
+	LwpBackgroundStuff* pBackgroundStuff = GetBackgroundStuff();
+	if(pBackgroundStuff && !pBackgroundStuff->IsTransparent())
+	{
+		LwpColor* pColor = pBackgroundStuff->GetFillColor();
+		if(pColor->IsValidColor())
+		{
+			return pColor;
+		}
+	}
+	return NULL;
+}
+
+/**
+ * @descr:  Add back color settings into xfpagemaster.  
+ * @param:   
+ * @param:   
+ * @return:  
+*/
+LwpTabOverride* LwpMiddleLayout::GetTabOverride()
+{
+	if(m_nAttributes & OVER_TABS)
+	{
+		if(!m_TabPiece.IsNull())
+			return (LwpTabOverride*)static_cast<LwpTabPiece*>(m_TabPiece.obj())->GetOverride();
+		return NULL;
+	}
+	else if( !m_BasedOnStyle.IsNull() )
+	{
+		LwpMiddleLayout* pLay = static_cast<LwpMiddleLayout*> ( m_BasedOnStyle.obj() );
+		return pLay->GetTabOverride();
+	}
+	return NULL;
+}
+
+/**
+ * @descr:   Layscale for graphic & watermark
+ * @param:   
+ * @param:   
+ * @return:  
+*/
+sal_uInt16 LwpMiddleLayout::GetScaleMode(void)
+{
+	if ((m_nOverrideFlag & OVER_SCALING) && m_LayScale.obj())
+		return GetLayoutScale()->GetScaleMode();
+	else if (m_BasedOnStyle.obj())
+		return static_cast<LwpMiddleLayout*>(m_BasedOnStyle.obj())->GetScaleMode();
+	else
+		return (LwpLayoutScale::FIT_IN_FRAME | LwpLayoutScale::MAINTAIN_ASPECT_RATIO);	
+}
+
+void LwpMiddleLayout::SetScaleMode(sal_uInt16 nVal)
+{
+	m_nOverrideFlag |= OVER_SCALING;
+//	nVal |= LwpLayoutScale::MAINTAIN_ASPECT_RATIO;
+	GetLayoutScale()->SetScaleMode(nVal);
+}
+
+sal_uInt16 LwpMiddleLayout::GetScaleTile(void)
+{
+	if ((m_nOverrideFlag & OVER_SCALING) && m_LayScale.obj())
+		return (GetLayoutScale()->GetPlacement() & LwpLayoutScale::TILED) 
+			? 1 : 0;
+	else if (m_BasedOnStyle.obj())
+		return static_cast<LwpMiddleLayout*>(m_BasedOnStyle.obj())->GetScaleTile();
+	else
+		return 0;	
+}
+
+void LwpMiddleLayout::SetScaleTile(sal_uInt16 nVal)
+{
+	m_nOverrideFlag |= OVER_SCALING;	
+	if (nVal)
+		GetLayoutScale()->SetPlacement(GetLayoutScale()->GetPlacement() | LwpLayoutScale::TILED);
+	else
+		GetLayoutScale()->SetPlacement(GetLayoutScale()->GetPlacement() & ~LwpLayoutScale::TILED);	
+}
+
+sal_uInt16 LwpMiddleLayout::GetScaleCenter(void)
+{
+	if ((m_nOverrideFlag & OVER_SCALING) && m_LayScale.obj())
+		return (GetLayoutScale()->GetPlacement() & LwpLayoutScale::CENTERED) 
+			? 1 : 0;
+	else if (m_BasedOnStyle.obj())
+		return static_cast<LwpMiddleLayout*>(m_BasedOnStyle.obj())->GetScaleCenter();
+	else
+		return 0;
+}
+
+void LwpMiddleLayout::SetScaleCenter(sal_uInt16 nVal)
+{
+	m_nOverrideFlag |= OVER_SCALING;	
+	if (nVal)
+		GetLayoutScale()->SetPlacement(GetLayoutScale()->GetPlacement() | LwpLayoutScale::CENTERED);
+	else
+		GetLayoutScale()->SetPlacement(GetLayoutScale()->GetPlacement() & ~LwpLayoutScale::CENTERED);	
+}
+
+sal_uInt32 LwpMiddleLayout::GetScalePercentage(void)
+{
+	if ((m_nOverrideFlag & OVER_SCALING) && m_LayScale.obj())
+		return GetLayoutScale()->GetScalePercentage()/10;//m_nScalePercentage 1000 = 100%
+	else if (m_BasedOnStyle.obj())
+		return static_cast<LwpMiddleLayout*>(m_BasedOnStyle.obj())->GetScalePercentage();
+	else
+		return 100;	
+}
+
+void LwpMiddleLayout::SetScalePercentage(sal_uInt32 nVal)
+{
+	m_nOverrideFlag |= OVER_SCALING;
+	GetLayoutScale()->SetScalePercentage(nVal*10);	
+}
+
+double LwpMiddleLayout::GetScaleWidth(void)
+{
+	if ((m_nOverrideFlag & OVER_SCALING) && m_LayScale.obj())
+		return LwpTools::ConvertFromUnits(GetLayoutScale()->GetScaleWidth());
+	else if (m_BasedOnStyle.obj())
+		return static_cast<LwpMiddleLayout*>(m_BasedOnStyle.obj())->GetScaleWidth();
+	else
+		return 0;		
+}
+
+void LwpMiddleLayout::SetScaleWidth(double fVal)
+{
+	m_nOverrideFlag |= OVER_SCALING;
+	GetLayoutScale()->SetScaleWidth(LwpTools::ConvertToUnits(fVal));
+}
+
+double LwpMiddleLayout::GetScaleHeight(void)
+{
+	if ((m_nOverrideFlag & OVER_SCALING) && m_LayScale.obj())
+		return LwpTools::ConvertFromUnits(GetLayoutScale()->GetScaleHeight());
+	else if (m_BasedOnStyle.obj())
+		return static_cast<LwpMiddleLayout*>(m_BasedOnStyle.obj())->GetScaleHeight();
+	else
+		return 0;	
+}
+sal_Bool LwpMiddleLayout::CanSizeRight(void)
+{
+	sal_uInt8 RelType = GetRelativeType();
+
+	if (RelType == LwpLayoutRelativityGuts::LAY_INLINE || RelType == LwpLayoutRelativityGuts::LAY_PARA_RELATIVE
+	|| RelType == LwpLayoutRelativityGuts::LAY_INLINE_VERTICAL)
+	{
+		return sal_False;
+	}
+	return sal_True;
+}
+sal_Int32 LwpMiddleLayout::GetMinimumWidth()
+{
+	if (((m_nAttributes3 & STYLE3_WIDTHVALID) != 0) && GetGeometry())
+	{
+		return GetGeometry()->GetWidth();
+	}
+	else if (m_nOverrideFlag & OVER_SIZE)
+	{
+		return DetermineWidth();
+	}
+	return 0;
+}
+sal_Int32 LwpMiddleLayout::DetermineWidth()
+{
+	if (IsSizeRightToContent())
+	{
+		assert(sal_False);
+	}
+	else if (IsSizeRightToContainer())
+	{
+		assert(sal_False);
+	}
+	else
+	{
+		m_nAttributes3 |= STYLE3_WIDTHVALID;
+		return GetGeometry()->GetWidth();
+	}
+	return 0;
+}
+sal_Bool LwpMiddleLayout::IsSizeRightToContainer(void)
+{
+	if (!CanSizeRight())
+		return sal_False;
+
+	if (m_nOverrideFlag & OVER_SIZE)
+	{
+		return (m_nDirection & ((LAY_USEDIRECTION|LAY_AUTOSIZE|LAY_TOCONTAINER)
+						<< SHIFT_RIGHT))
+		== ((LAY_USEDIRECTION | LAY_TOCONTAINER | LAY_AUTOSIZE) << SHIFT_RIGHT);
+	}
+	else if (m_BasedOnStyle.obj())
+	{
+		LwpMiddleLayout * pLayout = static_cast<LwpMiddleLayout *>(m_BasedOnStyle.obj());
+		return pLayout->IsSizeRightToContainer();
+	}
+	else
+		return sal_False;
+}
+sal_Bool LwpMiddleLayout::IsSizeRightToContent(void)
+{
+	if (!CanSizeRight())
+		return sal_False;
+
+	if (m_nOverrideFlag & OVER_SIZE)
+	{	
+		return (m_nDirection & ((LAY_USEDIRECTION|LAY_AUTOSIZE|LAY_TOCONTAINER)
+							<< SHIFT_RIGHT)) 
+				== ((LAY_USEDIRECTION | LAY_AUTOSIZE) << SHIFT_RIGHT);
+	}
+	else if (m_BasedOnStyle.obj())
+	{
+		LwpMiddleLayout * pLayout = static_cast<LwpMiddleLayout *>(m_BasedOnStyle.obj());
+		return pLayout->IsSizeRightToContent();
+	}
+	else
+		return sal_False;
+}
+
+/**
+* @descr: 	Get layout height
+* 
+*/
+double LwpMiddleLayout::GetHeight()
+{
+	return GetGeometryHeight();
+}
+
+/**
+* @descr: 	Get layout height
+* 
+*/
+double LwpMiddleLayout::GetWidth()
+{
+	return GetGeometryWidth();
+}
+/**
+* @descr: 	Get layout orgin point
+* 
+*/
+LwpPoint LwpMiddleLayout::GetOrigin()
+{
+	LwpLayoutGeometry* pGeo = GetGeometry();
+	if(pGeo)
+	{
+		sal_uInt8 nType = GetRelativeType();
+		if(nType == LwpLayoutRelativityGuts::LAY_INLINE
+			|| nType == LwpLayoutRelativityGuts::LAY_INLINE_NEWLINE )
+		{
+			return pGeo->GetAbsoluteOrigin();
+		}
+		else
+			return pGeo->GetOrigin();
+		
+	}
+
+	return LwpPoint();
+}
+
+void LwpMiddleLayout::SetScaleHeight(double fVal)
+{
+	m_nOverrideFlag |= OVER_SCALING;
+	GetLayoutScale()->SetScaleHeight(LwpTools::ConvertToUnits(fVal));
+}
+
+/**
+* @descr: 	Whether the fill is pattern fill or not
+* @return:	True if yes, false if not.
+*/
+sal_Bool LwpMiddleLayout::IsPatternFill()
+{
+	LwpBackgroundStuff* pBackgroundStuff = GetBackgroundStuff();
+	if (pBackgroundStuff)
+	{
+		return pBackgroundStuff->IsPatternFill();
+	}
+
+	return sal_False;
+}
+
+/**
+* @descr: 	Get the fill pattern style. Data are saved in a XFBGImage object
+* @return:	the fill pattern style.
+*/
+XFBGImage* LwpMiddleLayout::GetFillPattern()
+{
+	LwpBackgroundStuff* pBackgroundStuff = GetBackgroundStuff();
+	if (pBackgroundStuff)
+	{
+		return pBackgroundStuff->GetFillPattern();
+	}
+
+	return NULL;
+
+}
+
+/**
+* @descr: 	Whether the height and width of layout is auto grow
+* 
+*/
+sal_Bool LwpMiddleLayout::IsAutoGrow()
+{	
+	if(m_nOverrideFlag & OVER_SIZE)
+	{		
+		return m_nDirection & 
+			((LAY_AUTOGROW << SHIFT_UP) | (LAY_AUTOGROW << SHIFT_DOWN) |
+			(LAY_AUTOGROW << SHIFT_RIGHT) | (LAY_AUTOGROW << SHIFT_LEFT))
+			? sal_True : sal_False;
+	}
+	else if( !m_BasedOnStyle.IsNull() )
+	{
+		LwpMiddleLayout* pLay = static_cast<LwpMiddleLayout*> ( m_BasedOnStyle.obj() );
+		return pLay->IsAutoGrow();
+	}
+	return LwpVirtualLayout::IsAutoGrow();
+}
+
+/**
+* @descr: 	Whether the height of layout is auto grow down
+* 
+*/
+sal_Bool LwpMiddleLayout::IsAutoGrowDown()
+{	
+	if(m_nOverrideFlag & OVER_SIZE)
+	{		
+		return m_nDirection & (LAY_AUTOGROW << SHIFT_DOWN) ? sal_True : sal_False;
+	}
+	else if( !m_BasedOnStyle.IsNull() )
+	{
+		LwpMiddleLayout* pLay = static_cast<LwpMiddleLayout*> ( m_BasedOnStyle.obj() );
+		return pLay->IsAutoGrowDown();
+	}
+	return LwpVirtualLayout::IsAutoGrowDown();
+}
+
+/**
+* @descr: 	Whether the height of layout is auto grow up
+* 
+*/
+sal_Bool LwpMiddleLayout::IsAutoGrowUp()
+{
+	if(m_nOverrideFlag & OVER_SIZE)
+	{		
+		return m_nDirection & (LAY_AUTOGROW << SHIFT_UP) ? sal_True : sal_False;
+	}
+	else if( !m_BasedOnStyle.IsNull() )
+	{
+		LwpMiddleLayout* pLay = static_cast<LwpMiddleLayout*> ( m_BasedOnStyle.obj() );
+		return pLay->IsAutoGrowUp();
+	}
+	return LwpVirtualLayout::IsAutoGrowUp();
+}
+
+/**
+* @descr: 	Whether the height of layout is auto grow down
+* 
+*/
+sal_Bool LwpMiddleLayout::IsAutoGrowLeft()
+{	
+	if(m_nOverrideFlag & OVER_SIZE)
+	{		
+		return m_nDirection & (LAY_AUTOGROW << SHIFT_LEFT) ? sal_True : sal_False;
+	}
+	else if( !m_BasedOnStyle.IsNull() )
+	{
+		LwpMiddleLayout* pLay = static_cast<LwpMiddleLayout*> ( m_BasedOnStyle.obj() );
+		return pLay->IsAutoGrowLeft();
+	}
+	return LwpVirtualLayout::IsAutoGrowLeft();
+}
+
+/**
+* @descr: 	Whether the height of layout is auto grow down
+* 
+*/
+sal_Bool LwpMiddleLayout::IsAutoGrowRight()
+{	
+	if(m_nOverrideFlag & OVER_SIZE)
+	{		
+		return m_nDirection & (LAY_AUTOGROW << SHIFT_RIGHT) ? sal_True : sal_False;
+	}
+	else if( !m_BasedOnStyle.IsNull() )
+	{
+		LwpMiddleLayout* pLay = static_cast<LwpMiddleLayout*> ( m_BasedOnStyle.obj() );
+		return pLay->IsAutoGrowRight();
+	}
+	return LwpVirtualLayout::IsAutoGrowRight();
+}
+
+
+/**
+* @descr: 	Get contents orientation
+* 
+*/
+sal_uInt8 LwpMiddleLayout::GetContentOrientation()
+{	
+	//content orientation in Graphic objects and OLE objects not supported now
+	if((m_nOverrideFlag & OVER_ROTATION)&& !m_LayGeometry.IsNull())
+	{
+		LwpLayoutGeometry* pLayGeometry = static_cast<LwpLayoutGeometry*> (m_LayGeometry.obj());
+		return pLayGeometry->GetContentOrientation();
+	}
+	else if( !m_BasedOnStyle.IsNull() )
+	{
+		LwpMiddleLayout* pLay = static_cast<LwpMiddleLayout*> ( m_BasedOnStyle.obj() );
+		return pLay->GetContentOrientation();
+	}
+	return LwpVirtualLayout::GetContentOrientation();	
+}
+
+/**
+* @descr: 	Whether it is honoring protection
+*
+*/
+sal_Bool LwpMiddleLayout::HonorProtection()
+{
+	if(m_nOverrideFlag & OVER_MISC)
+	{
+		if(!(m_nAttributes2 & STYLE2_HONORPROTECTION))
+			return sal_False;
+
+		LwpVirtualLayout* pParent = static_cast<LwpVirtualLayout*> (GetParent()->obj());
+		if(pParent && !pParent->IsHeader())
+		{
+			return pParent->HonorProtection();
+		}
+
+		if(m_pFoundry)//is null now
+		{
+			LwpDocument* pDoc = m_pFoundry->GetDocument();
+			if(pDoc)
+			{
+				return pDoc->HonorProtection();
+			}
+		}
+	}
+	else if( !m_BasedOnStyle.IsNull() )
+	{
+		LwpMiddleLayout* pLay = static_cast<LwpMiddleLayout*> ( m_BasedOnStyle.obj() );
+		return pLay->HonorProtection();
+	}
+
+	return LwpVirtualLayout::HonorProtection();
+}
+
+/**
+* @descr: 	Whether it is pretected
+*
+*/
+sal_Bool LwpMiddleLayout::IsProtected()
+{
+	sal_Bool bProtected = sal_False;
+	if(m_nOverrideFlag & OVER_MISC)
+	{
+		bProtected = (m_nAttributes & STYLE_PROTECTED)!=0;
+	}
+	else if( !m_BasedOnStyle.IsNull() )
+	{
+		LwpMiddleLayout* pLay = static_cast<LwpMiddleLayout*> ( m_BasedOnStyle.obj() );
+		bProtected = pLay->IsProtected();
+	}
+	else
+		bProtected = LwpVirtualLayout::IsProtected();		
+
+	LwpVirtualLayout* pParent = static_cast<LwpVirtualLayout*> (GetParent()->obj());
+	if(pParent && !pParent->IsHeader())
+	{
+		/* If a parent's protected then none of its children can be accessed. */
+		if(pParent->IsProtected())
+			return sal_True;
+		
+		if(pParent->HonorProtection())
+			return bProtected;
+
+		/* If our parent isn't honoring protection then we aren't protected. */
+		return sal_False;
+
+	}
+	if(m_pFoundry)//is null now
+	{
+		LwpDocument* pDoc = m_pFoundry->GetDocument();
+		if(pDoc)
+		{
+			if (pDoc->HonorProtection())
+				return bProtected;
+
+			/* If the document isn't honoring protection then we aren't protected.*/
+			return sal_False;
+		}
+	}
+
+	return bProtected;
+}
+
+/**
+* @descr: 	Get watermark layout
+*
+*/
+LwpVirtualLayout* LwpMiddleLayout::GetWaterMarkLayout()
+{
+	LwpVirtualLayout* pLay = static_cast<LwpVirtualLayout*>(GetChildHead()->obj());
+	while(pLay)
+	{
+		if( pLay->IsForWaterMark())
+		{
+			return pLay;
+		}
+		pLay = static_cast<LwpVirtualLayout*> (pLay->GetNext()->obj());
+	}
+	return NULL;	
+}
+
+/**
+* @descr: 	Create and reture xfbgimage object for watermark
+*
+*/
+XFBGImage* LwpMiddleLayout::GetXFBGImage()
+{
+	LwpMiddleLayout* pLay = static_cast<LwpMiddleLayout*>(GetWaterMarkLayout());
+	if(pLay)
+	{		
+		//test BGImage
+		LwpGraphicObject* pGrfObj = static_cast<LwpGraphicObject*>(pLay->GetContent()->obj());
+		if(pGrfObj)
+		{
+			XFBGImage* pXFBGImage = new XFBGImage();
+			
+			if(pGrfObj->IsLinked())
+			{
+				//set file link
+				OUString linkedfilepath = pGrfObj->GetLinkedFilePath();				
+				OUString fileURL = LwpTools::convertToFileUrl(OUStringToOString(linkedfilepath, osl_getThreadTextEncoding()));
+				pXFBGImage->SetFileLink(fileURL);	
+			}
+			else
+			{
+				sal_uInt8* pGrafData = NULL;
+				sal_uInt32 nDataLen = pGrfObj->GetRawGrafData(pGrafData);
+				pXFBGImage->SetImageData(pGrafData, nDataLen);
+				if(pGrafData)
+				{
+					delete pGrafData;
+					pGrafData = NULL;
+				}
+			}
+			
+
+			//automatic, top left
+			pXFBGImage->SetPosition(enumXFAlignStart,enumXFAlignTop);	
+			if(pLay->GetScaleCenter())
+			{
+				//center
+				pXFBGImage->SetPosition(enumXFAlignCenter,enumXFAlignCenter);
+			}
+			else if(pLay->GetScaleTile())
+			{
+				//tile
+				pXFBGImage->SetRepeate();
+			}
+			//fit type, area type
+			if((pLay->GetScaleMode()& LwpLayoutScale::FIT_IN_FRAME)!=0)
+			{
+				if((pLay->GetScaleMode()& LwpLayoutScale::MAINTAIN_ASPECT_RATIO)==0)
+				{
+					pXFBGImage->SetStretch();
+				}				
+			}
+			return pXFBGImage;			
+		}		
+	}
+	return NULL;
+}
+
+/**
+* @descr: 	Whether the page uses the printer setting
+*
+*/
+sal_Bool LwpMiddleLayout::GetUsePrinterSettings()
+{
+	if(m_nOverrideFlag & OVER_SIZE)
+	{		
+		return (m_nAttributes3 & STYLE3_USEPRINTERSETTINGS) != 0;
+	}
+	else if( !m_BasedOnStyle.IsNull() )
+	{
+		LwpMiddleLayout* pLay = static_cast<LwpMiddleLayout*> ( m_BasedOnStyle.obj() );
+		return pLay->GetUsePrinterSettings();
+	}
+	return sal_False;
+}
+
+
+//Check whether there are contents in the layout
+sal_Bool LwpMiddleLayout::HasContent()
+{
+	LwpObject* content = m_Content.obj();
+	if(content)
+		return sal_True;
+	return sal_False;
+}
+//End by 
+	
+LwpLayout::LwpLayout( LwpObjectHeader &objHdr, LwpSvStream* pStrm ) :
+	LwpMiddleLayout(objHdr, pStrm), m_pUseWhen(new LwpUseWhen)
+{}
+
+LwpLayout::~LwpLayout()
+{
+	if (m_pUseWhen)
+	{
+		delete m_pUseWhen;
+	}
+}
+
+void LwpLayout::Read()
+{
+	LwpObjectStream* pStrm = m_pObjStrm;
+
+	LwpMiddleLayout::Read();
+	if (LwpFileHeader::m_nFileRevision < 0x000B)
+	{
+		// read PreRevBLayout...
+	}
+	else
+	{
+		sal_uInt16 nSimple;
+		pStrm->QuickRead(&nSimple, 2);
+
+		if (!nSimple)
+		{
+			m_pUseWhen->Read(pStrm);
+
+			sal_uInt8 nFlag;
+			pStrm->QuickRead(&nFlag, 1);
+			if (nFlag)
+			{
+				m_Positon.ReadIndexed(pStrm);
+			}
+		}
+
+		m_LayColumns.ReadIndexed(pStrm);
+		m_LayGutterStuff.ReadIndexed(pStrm);
+		m_LayJoinStuff.ReadIndexed(pStrm);
+		m_LayShadow.ReadIndexed(pStrm);
+
+		if (pStrm->CheckExtra())
+		{
+			m_LayExtJoinStuff.ReadIndexed(pStrm);
+			pStrm->SkipExtra();
+		}
+	}
+}
+
+/**
+* @descr: 	Get columns number
+*
+*/
+sal_uInt16 LwpLayout::GetNumCols()
+{
+	if(m_nOverrideFlag & OVER_COLUMNS)
+	{
+		LwpLayoutColumns* pLayColumns = static_cast<LwpLayoutColumns*>(m_LayColumns.obj());
+		if(pLayColumns)
+		{
+			return pLayColumns->GetNumCols();
+		}
+	}
+	
+	LwpVirtualLayout* pStyle = static_cast<LwpVirtualLayout*> (m_BasedOnStyle.obj());
+	if(pStyle)
+	{
+		return pStyle->GetNumCols();		
+	}
+
+	return LwpVirtualLayout::GetNumCols();
+
+}
+
+/**
+* @descr: 	Get column width
+* @param:	the order of column
+*/
+double LwpLayout::GetColWidth(sal_uInt16 nIndex)
+{
+	if((m_nOverrideFlag & OVER_COLUMNS)||(m_nAttributes2 & STYLE2_LOCALCOLUMNINFO))
+	{
+		LwpLayoutColumns* pLayColumns = static_cast<LwpLayoutColumns*>(m_LayColumns.obj());
+		if(pLayColumns)
+		{
+			return pLayColumns->GetColWidth(nIndex);
+		}
+	}
+	
+	LwpVirtualLayout* pStyle = static_cast<LwpVirtualLayout*> (m_BasedOnStyle.obj());
+	if(pStyle)
+	{
+		return pStyle->GetColWidth(nIndex);		
+	}
+
+	return LwpVirtualLayout::GetColWidth(nIndex);
+	
+}
+
+/**
+* @descr: 	Get gap between columns
+* @param:	the order of column
+*/
+double LwpLayout::GetColGap(sal_uInt16 nIndex)
+{
+	if((m_nOverrideFlag & OVER_COLUMNS)||(m_nAttributes2 & STYLE2_LOCALCOLUMNINFO))
+	{
+		LwpLayoutColumns* pLayColumns = static_cast<LwpLayoutColumns*>(m_LayColumns.obj());
+		if(pLayColumns)
+		{
+			return pLayColumns->GetColGap(nIndex);
+		}
+	}
+	
+	LwpVirtualLayout* pStyle = static_cast<LwpVirtualLayout*> (m_BasedOnStyle.obj());
+	if(pStyle)
+	{
+		return pStyle->GetColGap(nIndex);		
+	}
+
+	return LwpVirtualLayout::GetColGap(nIndex);
+}
+
+/**
+* @descr: 	Create and return XFColumns object
+* 
+*/
+XFColumns* LwpLayout::GetXFColumns()
+{
+	//if there is only one column, do not need insert columns
+	sal_uInt16 nCols = GetNumCols();
+	if(nCols==1)
+	{
+		return NULL;
+	}
+
+	XFColumns* pColumns = new XFColumns();
+	//set XFColumnSep
+	XFColumnSep* pColumnSep = GetColumnSep();
+	if(pColumnSep)
+	{
+		pColumns->SetSeperator(*pColumnSep);
+	}
+	
+	//set column count and column gap
+	pColumns->SetCount(nCols);
+	double fGap = GetColGap(0);
+	pColumns->SetGap(fGap);
+	
+	//set xfcolumn
+	for(sal_uInt16 nIndex = 0; nIndex<nCols; nIndex++)
+	{
+		XFColumn* pColumn = new XFColumn();
+		sal_Int32 nWidth = static_cast<sal_Int32>(GetColWidth(nIndex));
+		nWidth=8305/nCols;	//relative width
+		pColumn->SetRelWidth(nWidth);		
+
+		//the left and right margins is 0;
+		double nGap = GetColGap(nIndex)/2;
+		//nGap=0;
+		pColumn->SetMargins(nGap,nGap);		
+		if(nIndex==0)
+		{
+			pColumn->SetMargins(0,nGap);			
+		}
+		if(nIndex==(nCols-1))
+		{
+			pColumn->SetMargins(nGap,0);			
+		}
+		pColumns->AddColumn(*pColumn);			
+	}
+	
+	return pColumns;
+}
+
+/**
+* @descr: 	Create and return XFColumnSep object
+* 
+*/
+XFColumnSep* LwpLayout::GetColumnSep()
+{
+	
+	//Get LwpLayoutGutters
+	LwpLayoutGutters* pLayoutGutters = static_cast<LwpLayoutGutters*>(m_LayGutterStuff.obj());
+	if(!pLayoutGutters)
+	{
+		return NULL;
+	}
+
+	LwpBorderStuff* pBorderStuff = pLayoutGutters->GetBorderStuff();
+
+	if(pBorderStuff)
+	{
+		LwpBorderStuff::BorderType eType = LwpBorderStuff::LEFT;
+		LwpColor	aColor = pBorderStuff->GetSideColor(eType);
+		double	fWidth = pBorderStuff->GetSideWidth(eType);
+		//sal_uInt16	nType = pBorderStuff->GetSideType(eType);
+		
+		XFColumnSep* pColumnSep = new XFColumnSep();
+		XFColor aXFColor(aColor.To24Color());
+		pColumnSep->SetColor(aXFColor);
+		pColumnSep->SetWidth(fWidth);
+		pColumnSep->SetRelHeight(100);
+		pColumnSep->SetVerticalAlign(enumXFAlignTop);
+
+		return pColumnSep;
+	}
+	return NULL;
+
+}
+
+/**
+* @descr: 	Get use when type
+* 
+*/
+LwpLayout::UseWhenType LwpLayout::GetUseWhenType()
+{
+	UseWhenType eType = StartWithinPage;
+	LwpUseWhen* pUseWhen = GetUseWhen();
+	if(pUseWhen)
+	{
+		if(pUseWhen->IsStartOnThisHF())
+		{
+			eType =  StartWithinColume;
+		}
+		else if(pUseWhen->IsStartOnThisPage())
+		{
+			eType =  StartWithinPage;
+		}
+		else if(pUseWhen->IsStartOnNextPage())
+		{
+			eType = StartOnNextPage; 
+		}
+		else if(pUseWhen->IsStartOnNextOddPage())
+		{
+			eType =  StartOnOddPage;
+		}
+		else if(pUseWhen->IsStartOnNextEvenPage())
+		{
+			eType =   StartOnEvenPage;
+		}
+
+	}
+	else
+	{
+		eType =   StartOnNextPage;
+	}
+	return eType;
+}
+
+/**
+* @descr: 	Get use page
+* 
+*/
+sal_uInt16 LwpLayout::GetUsePage()
+{
+	if(m_nOverrideFlag & OVER_PLACEMENT)
+	{
+		LwpUseWhen* pUseWhen = GetUseWhen();
+		if(pUseWhen)
+			return pUseWhen->GetUsePage();
+		else
+			return NULL;
+	}
+	else if( !m_BasedOnStyle.IsNull() )
+	{
+		LwpLayout* pLay = static_cast<LwpLayout*> ( m_BasedOnStyle.obj() );
+		return pLay->GetUsePage();
+	}
+	return 0;
+}
+
+/**
+* @descr: 	Get usewhen pointer
+* 
+*/
+LwpUseWhen* LwpLayout::VirtualGetUseWhen()
+{
+	if(m_nOverrideFlag & OVER_PLACEMENT)
+	{		
+		return m_pUseWhen;
+	}
+	else if( !m_BasedOnStyle.IsNull() )
+	{
+		LwpLayout* pLay = static_cast<LwpLayout*> ( m_BasedOnStyle.obj() );
+		return pLay->VirtualGetUseWhen();
+	}
+	return LwpVirtualLayout::VirtualGetUseWhen();
+}
+
+/**
+* @descr: 	Whether it is use on all pages
+* 
+*/
+sal_Bool LwpLayout::IsUseOnAllPages()
+{
+	if(m_nOverrideFlag & OVER_PLACEMENT)
+	{
+		LwpUseWhen* pUseWhen = GetUseWhen();
+		if(pUseWhen)
+			return pUseWhen->IsUseOnAllPages();
+		else
+			return NULL;
+	}
+	else if( !m_BasedOnStyle.IsNull() )
+	{
+		LwpLayout* pLay = static_cast<LwpLayout*> ( m_BasedOnStyle.obj() );
+		return pLay->IsUseOnAllPages();
+	}
+	return LwpVirtualLayout::IsUseOnAllPages();
+}
+
+/**
+* @descr: 	Whether it is use on all even pages
+* 
+*/
+sal_Bool LwpLayout::IsUseOnAllEvenPages()
+{
+	if(m_nOverrideFlag & OVER_PLACEMENT)
+	{		
+		LwpUseWhen* pUseWhen = GetUseWhen();
+		if(pUseWhen)
+			return pUseWhen->IsUseOnAllEvenPages();
+		else
+			return NULL;
+	}
+	else if( !m_BasedOnStyle.IsNull() )
+	{
+		LwpLayout* pLay = static_cast<LwpLayout*> ( m_BasedOnStyle.obj() );
+		return pLay->IsUseOnAllEvenPages();
+	}
+	return LwpVirtualLayout::IsUseOnAllEvenPages();
+}
+
+/**
+* @descr: 	Whether it is use on all odd pages
+* 
+*/
+sal_Bool LwpLayout::IsUseOnAllOddPages()
+{
+	if(m_nOverrideFlag & OVER_PLACEMENT)
+	{		
+		LwpUseWhen* pUseWhen = GetUseWhen();
+		if(pUseWhen)
+			return pUseWhen->IsUseOnAllOddPages();
+		else
+			return NULL;
+	}
+	else if( !m_BasedOnStyle.IsNull() )
+	{
+		LwpLayout* pLay = static_cast<LwpLayout*> ( m_BasedOnStyle.obj() );
+		return pLay->IsUseOnAllOddPages();
+	}
+	return LwpVirtualLayout::IsUseOnAllOddPages();
+}
+
+/**
+* @descr: 	Whether it is use on current page
+* 
+*/
+sal_Bool LwpLayout::IsUseOnPage()
+{
+	if(m_nOverrideFlag & OVER_PLACEMENT)
+	{		
+		LwpUseWhen* pUseWhen = GetUseWhen();
+		if(pUseWhen)
+			return pUseWhen->IsUseOnPage();
+		else
+			return NULL;
+	}
+	else if( !m_BasedOnStyle.IsNull() )
+	{
+		LwpLayout* pLay = static_cast<LwpLayout*> ( m_BasedOnStyle.obj() );
+		return pLay->IsUseOnPage();
+	}
+	return LwpVirtualLayout::IsUseOnPage();
+}
+
+/**
+ * @descr:  Get the LwpShadow object according to m_LayShadow id. 
+ * @param:   
+ * @param:   
+ * @return:  
+*/
+LwpShadow* LwpLayout::GetShadow()
+{
+	if(m_nOverrideFlag & OVER_SHADOW)
+	{
+		LwpLayoutShadow* pLayoutShadow = static_cast<LwpLayoutShadow*>(m_LayShadow.obj());
+		return pLayoutShadow->GetShadow();
+	}
+	else if( !m_BasedOnStyle.IsNull() )
+	{
+		LwpLayout* pLay = static_cast<LwpLayout*> ( m_BasedOnStyle.obj() );
+		return pLay->GetShadow();
+	}
+	return NULL;
+}
+
+/**
+ * @descr:  create xfshadow 
+ * @param:   
+ * @param:   
+ * @return:  
+*/
+XFShadow* LwpLayout::GetXFShadow()
+{
+	LwpShadow* pShadow = GetShadow();
+	if( pShadow )
+	{		
+		LwpColor color = pShadow->GetColor();
+		double	offsetX = pShadow->GetOffsetX();
+		double	offsetY = pShadow->GetOffsetY();
+
+		if( offsetX && offsetY && color.IsValidColor() )
+		{
+			XFShadow* pXFShadow = new XFShadow();
+			enumXFShadowPos eXFShadowPos = enumXFShadowLeftTop;
+			double fOffset = 0;
+
+			sal_Bool left = sal_False;
+			sal_Bool top = sal_False;
+			if( offsetX < 0 )
+				left = sal_True;
+			if( offsetY < 0 )
+				top = sal_True;
+			if( left )
+			{
+				fOffset = -offsetX;
+				if( top )					
+					eXFShadowPos = enumXFShadowLeftTop;
+				else					
+					eXFShadowPos = enumXFShadowLeftBottom;
+			}
+			else
+			{
+				fOffset = offsetX;
+				if( top )					
+					eXFShadowPos = enumXFShadowRightTop;
+				else					
+					eXFShadowPos = enumXFShadowRightBottom;
+			}
+
+			pXFShadow->SetPosition(eXFShadowPos);
+			pXFShadow->SetOffset(fOffset);
+			pXFShadow->SetColor(XFColor(color.To24Color()));
+
+			return pXFShadow;
+		}
+	}
+	return NULL;
+}
+
+/**
+ * @descr get the layout that containers the current frame layout 
+ * 		
+ */
+LwpVirtualLayout* LwpLayout::GetContainerLayout()
+{
+	if(IsRelativeAnchored())
+	{
+		//get position
+		LwpPara* pPara = static_cast<LwpPara*>(GetPosition()->obj());
+		if(pPara)
+		{
+			LwpStory* pStory = pPara->GetStory();
+			return pStory->GetTabLayout();
+		}		
+	}
+	return GetParentLayout();
+}
+
+LwpPlacableLayout::LwpPlacableLayout( LwpObjectHeader &objHdr, LwpSvStream* pStrm ) 
+	: LwpLayout(objHdr, pStrm),m_pFont(NULL)
+{}
+
+LwpPlacableLayout::~LwpPlacableLayout()
+{}
+
+void LwpPlacableLayout::Read()
+{
+	LwpObjectStream* pStrm = m_pObjStrm;
+	LwpLayout::Read();
+	if(LwpFileHeader::m_nFileRevision < 0x000B)
+	{
+		assert(false);
+	}
+	else
+	{
+		sal_uInt16 simple;
+		pStrm->QuickRead(&simple, sizeof(simple));
+		if(!simple)
+		{
+			pStrm->QuickRead(&m_nWrapType, sizeof(m_nWrapType));
+			pStrm->QuickRead(&m_nBuoyancy, sizeof(m_nBuoyancy));
+			pStrm->QuickRead(&m_nBaseLineOffset, sizeof(m_nBaseLineOffset));		
+			m_Script.Read( pStrm);
+		}
+		else
+		{
+			m_nWrapType = LAY_WRAP_AROUND;
+			m_nBuoyancy = LAY_BUOYNEUTRAL;
+			m_nBaseLineOffset	 = 0;	
+		}
+		m_LayRelativity.ReadIndexed( pStrm);
+		if(pStrm->CheckExtra())
+		{
+			sal_uInt16 count;
+			pStrm->QuickRead(&count, sizeof(count));
+			if(count)
+			{
+				// temporily added by  to avoid assertion
+				while (count)
+				{
+					LwpPoint aPoint;
+					aPoint.Read(pStrm);
+					count--;
+				}
+				// end added by 
+			}
+			pStrm->SkipExtra();
+		}
+	}
+}
+/**
+ * @descr:  get wrap type
+ * @param:   
+ * @param:   
+ * @return:  
+*/
+sal_uInt8 LwpPlacableLayout::GetWrapType()
+{
+	if(m_nOverrideFlag & OVER_PLACEMENT)
+	{
+		return m_nWrapType;
+	}
+	else if( !m_BasedOnStyle.IsNull() )
+	{
+		LwpPlacableLayout* pLay = static_cast<LwpPlacableLayout*> ( m_BasedOnStyle.obj() );
+		return pLay->GetWrapType();
+	}
+	return LAY_WRAP_AROUND;
+}
+/**
+ * @descr:  get LayoutRelativity
+ * @param:   
+ * @param:   
+ * @return:  
+*/
+LwpLayoutRelativity* LwpPlacableLayout::GetRelativityPiece()
+{
+	if(!m_LayRelativity.IsNull())
+	{
+		if(m_nOverrideFlag & OVER_PLACEMENT)
+		{
+			return static_cast<LwpLayoutRelativity*>(m_LayRelativity.obj());
+		}
+	}
+	else if( !m_BasedOnStyle.IsNull() )
+	{
+		LwpPlacableLayout* pLay = static_cast<LwpPlacableLayout*> ( m_BasedOnStyle.obj() );
+		return pLay->GetRelativityPiece();
+	}
+	return NULL;
+}
+/**
+* @descr: 	Get relative type
+*
+*/
+sal_uInt8 LwpPlacableLayout::GetRelativeType()
+{
+	LwpLayoutRelativity* pLayRel = GetRelativityPiece();
+	if(pLayRel)
+	{
+		return pLayRel->GetRelGuts()->GetRelativeType();
+	}
+	return LwpVirtualLayout::GetRelativeType();
+}
+/**
+* @descr: 	Get relative from where type
+*
+*/
+sal_uInt8 LwpPlacableLayout::GetRelativeFromWhere()
+{
+	LwpLayoutRelativity* pLayRel = GetRelativityPiece();
+	if(pLayRel)
+	{
+		return pLayRel->GetRelGuts()->GetRelativeFromWhere();
+	}
+	return 0;
+}
+/**
+* @descr: 	Get relative distance
+*
+*/
+LwpPoint LwpPlacableLayout::GetRelativeDistance()
+{
+	LwpPoint aPoint;
+	LwpLayoutRelativity* pLayRel = GetRelativityPiece();
+	if(pLayRel)
+	{
+		aPoint = pLayRel->GetRelGuts()->GetRelativeDistance();		
+	}
+	return aPoint;
+}
+/**
+* @descr: 	Get tether type
+*
+*/
+sal_uInt8 LwpPlacableLayout::GetTetherType()
+{
+	LwpLayoutRelativity* pLayRel = GetRelativityPiece();
+	if(pLayRel)
+	{
+		return pLayRel->GetRelGuts()->GetTetherType();
+	}
+	return 0;
+}
+/**
+* @descr: 	Get tether where type
+*
+*/
+sal_uInt8 LwpPlacableLayout::GetTetherWhere()
+{
+	LwpLayoutRelativity* pLayRel = GetRelativityPiece();
+	if(pLayRel)
+	{
+		return pLayRel->GetRelGuts()->GetTetherWhere();
+	}
+	return 0;
+}
+/**
+* @descr: 	Get offset from the baseline
+*
+*/
+sal_Int32 LwpPlacableLayout::GetBaseLineOffset()
+{
+	/* The baseline is only valid if this is flow-with-text */
+	if(GetRelativeType()!=LwpLayoutRelativityGuts::LAY_INLINE)
+	{
+		return 0;
+	}
+
+	// First, ask our content if it has a baseline, ignore now
+	/*
+	if (Content && Content->GetBaseLineOffset(&Baseline))
+		return Baseline;
+	*/
+
+	if(m_nOverrideFlag & OVER_PLACEMENT)
+	{
+		return m_nBaseLineOffset;
+	}
+	else if( !m_BasedOnStyle.IsNull() )
+	{
+		LwpPlacableLayout* pLay = static_cast<LwpPlacableLayout*> ( m_BasedOnStyle.obj() );
+		return pLay->GetBaseLineOffset();
+	}
+	return 0;
+
+
+}
+/**
+* @descr: 	whether the parent layout is page layout
+*
+*/
+sal_Bool LwpPlacableLayout::IsAnchorPage()
+{
+	if(IsRelativeAnchored())
+		return sal_False;
+
+	LwpVirtualLayout* pLayout = GetParentLayout();
+	if(pLayout && (pLayout->IsPage() || pLayout->IsHeader() || pLayout->IsFooter()))
+	//if(pLayout && pLayout->IsPage())
+	{
+		return sal_True;
+	}
+	return sal_False;
+}
+/**
+* @descr: 	whether the parent layout is frame layout
+*
+*/
+sal_Bool LwpPlacableLayout::IsAnchorFrame()
+{
+	if(IsRelativeAnchored())
+		return sal_False;
+
+	LwpVirtualLayout* pLayout = GetParentLayout();
+	if(pLayout && (pLayout->IsFrame()||pLayout->IsGroupHead()))
+	{
+		return sal_True;
+	}
+	return sal_False;
+}
+/**
+* @descr: 	whether the parent layout is cell layout
+*
+*/
+sal_Bool LwpPlacableLayout::IsAnchorCell()
+{
+	if(IsRelativeAnchored())
+		return sal_False;
+
+	LwpVirtualLayout* pLayout = GetParentLayout();
+	if(pLayout && pLayout->IsCell())
+	{
+		return sal_True;
+	}
+	return sal_False;
+}
+
+/**
+* @descr: 	Get font style for setting position of frame
+*
+*/
+XFFont* LwpPlacableLayout::GetFont()
+{
+	return m_pFont;
+}
+/**
+* @descr: 	Set font style for setting position of frame
+*
+*/
+void LwpPlacableLayout::SetFont(XFFont * pFont)
+{
+	m_pFont = pFont;
+}
diff -urNp lotuswordpro.bak/source/filter/lwplayoutdef.hxx lotuswordpro/source/filter/lwplayoutdef.hxx
--- lotuswordpro.bak/source/filter/lwplayoutdef.hxx	1970-01-01 08:00:00.000000000 +0800
+++ lotuswordpro/source/filter/lwplayoutdef.hxx	2008-10-22 11:42:29.000000000 +0800
@@ -0,0 +1,170 @@
+/*************************************************************************
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: IBM Corporation
+ *
+ *  Copyright: 2008 by IBM Corporation
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+#ifndef _LWPLAYOUTDEF_HXX
+#define _LWPLAYOUTDEF_HXX 
+
+#define	STYLE_AUTOLINK		0x01UL	/* content span's to next container */
+#define	STYLE_SELECTABLE	0x02UL	/* selectable container */
+#define	STYLE_SHARED		0x04UL	/* is this a global layout style */
+#define STYLE_PAINTMARGINSINCOLOR	0x8UL	/* does this layout paint margins */
+#define STYLE_PROTECTED		0x10UL	/* is this layout protected */
+#define STYLE_LOCAL			0x20UL	/* is local layout */
+#define STYLE_NOERRORCHECK	0x40UL	/* is error checking enabled */
+#define STYLE_HEADING		0x80UL	/* heading */
+#define STYLE_MUTE			0x100UL	/* gray modify menu */
+#define STYLE_SCRIPTING		0x200UL	/* scripting enabled */
+#define STYLE_CONTENTREPLACEABLE		0x400UL	/* contents can be replaced */
+#define STYLE_PRINTABLE		0x800UL	/* contents can be printed */
+#define STYLE_COLUMNBALANCE			0x1000UL
+#define STYLE_LANDSCAPE				0x2000UL
+#define STYLE_COLLAPSIBLE			0x4000UL
+#define STYLE_COLLAPSED				0x8000UL
+#define STYLE_NOTCOPYABLE			0x10000UL
+#define STYLE_PARENTSELECTABLE		0x20000UL
+#define STYLE_CONNECTED				0x40000UL
+#define STYLE_OVERRIDE				0x80000UL	/* is layout an override */
+#define STYLE_SELECTED				0x100000UL	
+#define STYLE_CENTEREDHORIZONTALLY	0x200000UL	
+#define STYLE_CREATIONREVISION		0x400000UL	
+#define STYLE_DELETIONREVISION		0x800000UL		
+#define STYLE_PAGEBREAK				0x1000000UL
+#define STYLE_MODIFIED				0x2000000UL
+#define STYLE_INDIRECT				0x4000000UL	/* double click required */
+#define STYLE_COMPLEX				0x8000000UL
+#define STYLE_CENTEREDVERTICALLY	0x10000000UL
+#define STYLE_BOTTOMALIGNED			0x20000000UL
+#define STYLE_NOTGROUPABLE			0x40000000UL
+#define STYLE_ABSOLUTE				0x80000000UL
+// Don't assign these flags from one layout to another
+#define STYLE_DONTASSIGN			(STYLE_SHARED)
+
+#define STYLE2_VSCROLLABLE			0x1UL
+#define STYLE2_HSCROLLABLE			0x2UL
+#define STYLE2_SCROLLABLE			0x3UL
+#define STYLE2_MIRROR				0x4UL
+#define	STYLE2_PRIVATE				0x8UL
+#define	STYLE2_PUBLIC				0x00UL
+#define	STYLE2_PRIVATE2				0x10UL
+#define	STYLE2_PROTECTED			0x20UL
+#define	STYLE2_ACCESSRIGHTS			0x30UL
+#define	STYLE2_HONORPROTECTION		0x40UL
+#define	STYLE2_CHILDSPANNABLE		0x80UL
+#define STYLE2_DEACTIVATED			0x200UL
+#define STYLE2_NOCONTENTREFERENCE	0x400UL
+#define STYLE2_ADOPTED				0x800UL
+#define STYLE2_NOTUSERDELETEABLE	0x1000UL
+#define	STYLE2_EXPANDRIGHT			0x2000UL
+#define	STYLE2_EXPANDLEFT			0x4000UL
+#define	STYLE2_EXPANDUP				0x8000UL
+#define	STYLE2_EXPANDDOWN			0x10000UL
+#define STYLE2_NOTDIRTYABLE			0x20000UL
+#define STYLE2_NONHIERARCHICAL		0x40000UL			// Now not used
+#define STYLE2_NOTSIZABLE			0x80000UL
+#define STYLE2_MARGINSSAMEASPARENT	0x100000UL
+#define STYLE2_DISPLAYANCHORPOINTS	0x200000UL
+#define STYLE2_DISPLAYTETHERPOINTS	0x400000UL
+#define STYLE2_SNAPTO				0x800000UL
+#define STYLE2_NOINTERSECTSIBLINGS	0x1000000UL
+#define STYLE2_LOCALCOLUMNINFO		0x2000000UL
+#define STYLE2_INOVERRIDE			0x4000000UL
+#define STYLE2_FROMSTYLE			0x8000000UL
+#define STYLE2_CONTENTFROMSTYLE		0x10000000UL
+#define STYLE2_TEMPORARY			0x20000000UL
+#define STYLE2_JUSTIFIABLE			0x40000000UL
+// Don't assign these flags from one layout to another
+#define STYLE2_DONTASSIGN			(STYLE2_DEACTIVATED |			\
+										STYLE2_NOCONTENTREFERENCE)
+
+#define STYLE3_ORIGINVALID 			0x0001UL
+#define STYLE3_WIDTHVALID 			0x0002UL
+#define STYLE3_MINHEIGHTVALID 		0x0004UL
+#define STYLE3_STYLELAYOUT			0x0008UL
+#define STYLE3_LINELOCATION1		0x0010UL
+#define STYLE3_LINELOCATION2		0x0020UL
+#define STYLE3_OPENED				0x0040UL
+#define STYLE3_ORIENTSWITHPARENT	0x0080UL
+#define STYLE3_FROZEN				0x0100UL
+#define STYLE3_VALUE_VALID			0x0200UL	// moved from CLayout
+#define STYLE3_USEPRINTERSETTINGS	0x0400UL	// moved from CLayout
+#define STYLE3_ISAMIPROTABLE		0x0800UL	// wrap tables around frames
+												// like Ami Pro
+#define STYLE3_INLINETOMARGIN		0x1000UL	// for Croom
+
+#define OVER_PLACEMENT				0x01UL
+#define OVER_SIZE					0x02UL
+#define OVER_MARGINS				0x04UL
+#define OVER_BORDERS				0x08UL
+#define OVER_BACKGROUND				0x10UL
+#define OVER_SHADOW					0x20UL
+#define OVER_JOIN					0x40UL
+#define OVER_COLUMNS				0x80UL
+#define OVER_ROTATION				0x100UL
+#define OVER_SCALING				0x200UL
+#define OVER_NUMERICS				0x400UL
+#define OVER_TABS					0x800UL
+#define OVER_SCRIPT					0x1000UL
+#define OVER_LEADERS				0x2000UL
+#define OVER_ORIENTATION			0x4000UL
+#define OVER_MISC					0x8000UL
+#define OVER_INTERNAL				0x10000UL // User can't access these props.
+
+// the first 4 orientations are left-handed
+// and are simply rotated forms of each other
+#define TEXT_ORIENT_LRTB			0		// left to right, top to bottom
+#define TEXT_ORIENT_TBRL			1		// top to bottom, right to left
+#define TEXT_ORIENT_RLBT			2		// right to left, bottom to top
+#define TEXT_ORIENT_BTLR			3		// bottom to top, left to right
+
+#endif
diff -urNp lotuswordpro.bak/source/filter/lwplayout.hxx lotuswordpro/source/filter/lwplayout.hxx
--- lotuswordpro.bak/source/filter/lwplayout.hxx	1970-01-01 08:00:00.000000000 +0800
+++ lotuswordpro/source/filter/lwplayout.hxx	2008-10-22 11:42:29.000000000 +0800
@@ -0,0 +1,458 @@
+/*************************************************************************
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: IBM Corporation
+ *
+ *  Copyright: 2008 by IBM Corporation
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+/*************************************************************************
+ * @file 
+ *  For LWP filter architecture prototype
+ ************************************************************************/
+/*************************************************************************
+ * Change History
+ Jan 2005			Created
+ ************************************************************************/
+
+#ifndef _LWPLAYOUT_HXX
+#define _LWPLAYOUT_HXX
+
+#include "lwpheader.hxx"
+#include "lwpobj.hxx"
+#include "lwpobjhdr.hxx"
+#include "lwpobjstrm.hxx"
+#include "lwpobjid.hxx"
+#include "lwpdlvlist.hxx"
+#include "lwpfilehdr.hxx"
+
+#include "lwplayoutdef.hxx"
+#include "xfilter/xfdefs.hxx"
+#include "xfilter/xfpagemaster.hxx"
+#include "xfilter/xfcolumns.hxx"
+#include "xfilter/xfborders.hxx"
+#include "xfilter/xfframestyle.hxx"
+#include "xfilter/xfframe.hxx"
+#include "xfilter/xfbgimage.hxx"
+#include "lwpusewhen.hxx"
+
+#define ANCHOR_HEIGHT 		0x120000
+#define FIRST_LAYOUTPAGENO	0x0001
+#define LAST_LAYOUTPAGENO		0xffff
+
+#define LAY_BUOYFLOAT 		0x01
+#define LAY_BUOYNEUTRAL		0x02
+#define	LAY_BUOYSINK 		0x03
+#define	LAY_BUOYLAYER 		0x80
+
+class LwpPara;
+class LwpVirtualLayout : public LwpDLNFPVList
+{
+public:
+	LwpVirtualLayout(LwpObjectHeader &objHdr, LwpSvStream* pStrm);
+	virtual ~LwpVirtualLayout(){};
+	virtual sal_Bool MarginsSameAsParent();
+	inline virtual sal_uInt16 GetNumCols(){return 1;}
+	virtual double GetColWidth(sal_uInt16 nIndex);
+	virtual double GetColGap(sal_uInt16 nIndex);
+	virtual double GetMarginsValue(const sal_uInt8& nWhichSide){return 0;}
+	virtual double GetExtMarginsValue(const sal_uInt8& nWhichSide){return 0;}
+	virtual sal_Bool IsAutoGrow(){ return sal_False;}
+	virtual sal_Bool IsAutoGrowUp(){ return sal_False;}
+	virtual sal_Bool IsAutoGrowDown(){ return sal_False;}
+	virtual sal_Bool IsAutoGrowLeft(){ return sal_False;};
+	virtual sal_Bool IsAutoGrowRight(){ return sal_False;};
+	virtual sal_Bool IsFitGraphic();
+	virtual sal_Bool IsAutoGrowWidth();
+	virtual sal_Bool IsInlineToMargin();
+	virtual sal_uInt8 GetContentOrientation(){ return TEXT_ORIENT_LRTB;}
+	virtual sal_Bool HonorProtection();
+	virtual sal_Bool IsProtected();
+	virtual sal_Bool HasProtection();
+	virtual OUString GetStyleName(){ return m_StyleName;}
+	virtual sal_Bool IsComplex();
+	virtual sal_Bool IsAnchorPage(){ return sal_False;}
+	virtual sal_Bool IsAnchorFrame(){ return sal_False;}
+	virtual sal_Bool IsAnchorCell(){ return sal_False;}
+	virtual sal_Bool IsPage();
+	virtual sal_Bool IsHeader();
+	virtual sal_Bool IsFooter();
+	virtual sal_Bool IsFrame();
+	virtual sal_Bool IsCell();
+	virtual sal_Bool IsSuperTable();
+	virtual sal_Bool IsGroupHead();
+	virtual sal_uInt8 GetRelativeType();
+	virtual sal_Bool IsRelativeAnchored();
+	virtual LwpUseWhen* GetUseWhen();
+	virtual LwpUseWhen* VirtualGetUseWhen(){ return NULL;}
+	virtual sal_Bool IsUseOnAllPages(){ return sal_False;}
+	virtual sal_Bool IsUseOnAllEvenPages(){ return sal_False;}
+	virtual sal_Bool IsUseOnAllOddPages(){ return sal_False;}
+	virtual sal_Bool IsUseOnPage(){ return sal_False;}
+	virtual sal_Int32 GetPageNumber(sal_uInt16 nLayoutNumber = 0){ return -1;}
+	virtual sal_Bool IsMinimumHeight();
+	virtual sal_Bool IsForWaterMark(){ return sal_False;}
+	virtual LwpPara* GetLastParaOfPreviousStory() { return NULL; }
+	virtual LwpVirtualLayout* GetParentLayout();
+	virtual LwpVirtualLayout* GetContainerLayout(){ return NULL;}
+	virtual void RegisterChildStyle();
+	virtual sal_Bool NoContentReference();
+	virtual sal_Bool IsStyleLayout();
+	virtual enumXFAlignType GetVerticalAlignmentType() 
+	{
+		if (m_nAttributes & STYLE_CENTEREDVERTICALLY)
+		{
+			return enumXFAlignMiddle;
+		}
+		else if (m_nAttributes & STYLE_BOTTOMALIGNED)
+		{
+			return enumXFAlignBottom;
+		}
+		return enumXFAlignTop;
+	};
+	virtual void SetStyleName(const OUString & str){ m_StyleName = str;};
+	virtual double GetWidth(){return -1;};	
+	
+	//Check whether there are contents in the layout
+	virtual sal_Bool HasContent(){return sal_False;}
+	//End by 
+protected:
+	void Read();	
+protected:
+	sal_uInt32 m_nAttributes;
+	sal_uInt32 m_nAttributes2;
+	sal_uInt32 m_nAttributes3;
+	sal_uInt32 m_nOverrideFlag;
+	sal_uInt16 m_nDirection;
+	sal_uInt16 m_nEditorID;
+	LwpObjectID m_NextEnumerated;
+	LwpObjectID m_PreviousEnumerated;
+	OUString m_StyleName;
+	enum LWP_LAYOUT_TYPE
+	{
+		LWP_VIRTUAL_LAYOUT,
+		LWP_HEAD_LAYOUT,
+		LWP_PAGE_LAYOUT,
+		LWP_HEADER_LAYOUT,
+		LWP_FOOTER_LAYOUT,
+		LWP_FRAME_LAYOUT,
+		LWP_SUPERTABLE_LAYOUT,
+		LWP_TABLE_LAYOUT,
+		LWP_ROW_LAYOUT,
+		LWP_COLUMN_LAYOUT,
+		LWP_CELL_LAYOUT,
+		LWP_CONNECTED_CELL_LAYOUT,
+		LWP_HIDDEN_CELL_LAYOUT,
+		LWP_TABLE_HEADING_LAYOUT,
+		LWP_ROW_HEADING_LAYOUT,
+		LWP_DROPCAP_LAYOUT,
+		LWP_GROUP_LAYOUT,
+		LWP_TOC_SUPERTABLE_LAYOUT,
+		LWP_FOOTNOTE_LAYOUT,
+		LWP_FOOTNOTE_ROW_LAYOUT,
+		LWP_FOOTNOTE_CELL_LAYOUT,
+		LWP_ENDNOTE_LAYOUT,
+		LWP_ENDNOTE_SUPERTABLE_LAYOUT,
+		LWP_FOOTNOTE_SUPERTABLE_LAYOUT,
+		LWP_NOTE_LAYOUT,
+		LWP_NOTEHEADER_LAYOUT,
+		LWP_NOTETEXT_LAYOUT,
+		LWP_VIEWPORT_LAYOUT
+	};
+	enum LayoutDirection
+	{
+		LAY_USEDIRECTION	= 0x01,
+		LAY_AUTOGROW		= 0x02,
+		LAY_AUTOSIZE		= 0x04,
+		LAY_TOCONTAINER		= 0x08,
+		LAY_DIRALLBITS		= 0x0f
+	};
+	enum	{SHIFT_UP = 0, SHIFT_DOWN = 4, SHIFT_LEFT = 8, SHIFT_RIGHT =12};
+public:
+	virtual LWP_LAYOUT_TYPE GetLayoutType () { return LWP_VIRTUAL_LAYOUT;}
+	virtual LwpVirtualLayout* FindChildByType(LWP_LAYOUT_TYPE eType);
+};
+
+class LwpAssociatedLayouts
+{
+public:
+	LwpAssociatedLayouts(){};
+	//LwpAssociatedLayouts(LwpObjectStream* pStrm){Read(pStrm);};
+public:
+	void Read(LwpObjectStream* pStrm);
+	LwpObjectID* GetOnlyLayout(){return &m_OnlyLayout;}
+	LwpDLVListHeadTail* GetLayouts(){return &m_Layouts;}
+	LwpVirtualLayout* GetLayout(LwpVirtualLayout* pStartLayout);
+protected:
+	LwpObjectID m_OnlyLayout; //LwpVirtualLayout
+	LwpDLVListHeadTail m_Layouts;	
+};
+
+class LwpHeadLayout : public LwpVirtualLayout
+{
+public:
+	LwpHeadLayout(LwpObjectHeader &objHdr, LwpSvStream* pStrm);
+	virtual ~LwpHeadLayout(){};
+	void RegisterStyle();
+	LwpVirtualLayout* FindEnSuperTableLayout();
+protected:
+	void Read();
+	virtual LWP_LAYOUT_TYPE GetLayoutType () { return LWP_HEAD_LAYOUT;}
+};
+
+//add by , 01/20/2005
+class LwpLayoutStyle
+{
+public:
+	LwpLayoutStyle();
+	virtual ~LwpLayoutStyle();
+	void Read(LwpObjectStream* pStrm);
+private:
+	sal_uInt32		m_nStyleDefinition;
+	LwpAtomHolder*	m_pDescription;
+	sal_uInt16		m_nKey;
+};
+
+class LwpLayoutMisc
+{
+public:
+	LwpLayoutMisc();
+	virtual ~LwpLayoutMisc();
+	void Read(LwpObjectStream* pStrm);
+private:
+	sal_Int32	m_nGridDistance;
+	sal_uInt16 m_nGridType;
+	LwpAtomHolder* m_pContentStyle;
+};
+//end add
+
+#include "lwplaypiece.hxx"
+
+class LwpMiddleLayout : public LwpVirtualLayout
+{
+public:
+	LwpMiddleLayout( LwpObjectHeader &objHdr, LwpSvStream* pStrm );
+	virtual ~LwpMiddleLayout();
+	virtual BOOL MarginsSameAsParent();
+	virtual double GetMarginsValue(const sal_uInt8& nWhichSide);
+	virtual double GetExtMarginsValue(const sal_uInt8& nWhichSide);	
+	LwpLayoutGeometry* GetGeometry();
+	double GetGeometryHeight();
+	double GetGeometryWidth();
+	LwpBorderStuff* GetBorderStuff();	
+	LwpBackgroundStuff* GetBackgroundStuff();	
+	enumXFTextDir GetTextDirection();	
+	XFBorders* GetXFBorders();
+	LwpColor* GetBackColor();
+	virtual sal_Bool IsAutoGrow();
+	virtual sal_Bool IsAutoGrowUp();
+	virtual sal_Bool IsAutoGrowDown();
+	virtual sal_Bool IsAutoGrowLeft();
+	virtual sal_Bool IsAutoGrowRight();
+	virtual sal_uInt8 GetContentOrientation();
+	virtual sal_Bool HonorProtection();
+	virtual sal_Bool IsProtected();
+	virtual LwpVirtualLayout* GetWaterMarkLayout();
+	XFBGImage* GetXFBGImage();
+	virtual sal_Bool GetUsePrinterSettings();
+	
+	LwpLayoutScale* GetLayoutScale(){return static_cast<LwpLayoutScale*>(m_LayScale.obj());}
+        sal_uInt16 GetScaleMode(void);
+	void SetScaleMode(sal_uInt16 nVal);
+	sal_uInt16 GetScaleTile(void);
+	void SetScaleTile(sal_uInt16 nVal);
+	sal_uInt16 GetScaleCenter(void);
+	void SetScaleCenter(sal_uInt16 nVal);
+	sal_uInt32 GetScalePercentage(void);
+	void SetScalePercentage(sal_uInt32 nVal);
+	double GetScaleWidth(void);
+	void SetScaleWidth(double fVal);
+	double GetScaleHeight(void);
+	void SetScaleHeight(double fVal);
+
+	sal_Bool CanSizeRight(void);
+	virtual double GetWidth();	
+	virtual sal_Int32 GetMinimumWidth();
+	sal_Bool IsSizeRightToContent(void);
+	sal_Bool IsSizeRightToContainer(void);
+	sal_Int32 DetermineWidth();
+	virtual double GetHeight();
+	virtual LwpPoint GetOrigin(); 
+
+	// added by , 06/01/2004
+	sal_Bool IsPatternFill();
+	XFBGImage* GetFillPattern();
+	// end add
+
+	
+	//Check whether there are contents in the layout
+	virtual sal_Bool HasContent();
+	//End by 
+	
+protected:
+	void Read();
+protected:
+	enum
+	{
+		DISK_GOT_STYLE_STUFF		= 0x01,
+		DISK_GOT_MISC_STUFF			= 0x02
+	};
+
+	LwpObjectID m_Content;
+	LwpObjectID m_BasedOnStyle;
+
+	// 01/20/2005
+	LwpObjectID		m_TabPiece;
+	LwpLayoutStyle*	m_pStyleStuff;
+	LwpLayoutMisc*	m_pMiscStuff;
+	LwpObjectID		m_LayGeometry;
+	LwpObjectID		m_LayScale;
+	LwpObjectID		m_LayMargins;
+	LwpObjectID		m_LayBorderStuff;
+	LwpObjectID		m_LayBackgroundStuff;
+	LwpObjectID		m_LayExtBorderStuff;
+	//end
+public:
+	LwpObjectID* GetContent(){return &m_Content;}
+	LwpTabOverride* GetTabOverride();
+};
+
+class LwpLayout : public LwpMiddleLayout
+{
+public:
+	LwpLayout( LwpObjectHeader &objHdr, LwpSvStream* pStrm );
+ 	virtual ~LwpLayout();	
+	XFColumns* GetXFColumns();
+	XFColumnSep* GetColumnSep();
+	LwpShadow* GetShadow();	
+	XFShadow* GetXFShadow();
+protected:
+	void Read();
+protected:
+	// 01/20/2005
+	LwpUseWhen*	m_pUseWhen;
+	LwpObjectID	m_Positon;
+	LwpObjectID	m_LayColumns;
+	LwpObjectID	m_LayGutterStuff;
+	LwpObjectID	m_LayJoinStuff;
+	LwpObjectID	m_LayShadow;
+	LwpObjectID	m_LayExtJoinStuff;
+	//end
+
+public:	
+	LwpUseWhen* VirtualGetUseWhen();
+	virtual sal_uInt16 GetNumCols();
+	virtual double GetColWidth(sal_uInt16 nIndex);
+	virtual double GetColGap(sal_uInt16 nIndex);
+	virtual sal_uInt16 GetUsePage();
+public:
+	enum UseWhenType
+	{
+		StartWithinColume,
+		StartWithinPage,
+		StartOnNextPage,
+		StartOnOddPage,
+		StartOnEvenPage
+	};
+public:
+	virtual UseWhenType GetUseWhenType();
+	virtual sal_Bool IsUseOnAllPages();
+	virtual sal_Bool IsUseOnAllEvenPages();	
+	virtual sal_Bool IsUseOnAllOddPages();
+	virtual sal_Bool IsUseOnPage();
+	LwpObjectID* GetPosition(){ return &m_Positon;}
+	virtual LwpVirtualLayout* GetContainerLayout();
+};
+
+class XFFont;
+class LwpPlacableLayout : public LwpLayout
+{
+public:
+	LwpPlacableLayout( LwpObjectHeader &objHdr, LwpSvStream* pStrm );
+ 	virtual ~LwpPlacableLayout();
+	virtual sal_uInt8 GetWrapType();
+	virtual LwpLayoutRelativity* GetRelativityPiece();
+	virtual sal_uInt8 GetRelativeType();
+	sal_uInt8 GetRelativeFromWhere();
+	LwpPoint GetRelativeDistance();
+	sal_uInt8 GetTetherType();
+	sal_uInt8 GetTetherWhere();
+	virtual sal_Int32 GetBaseLineOffset();
+	virtual sal_Bool IsAnchorPage();
+	virtual sal_Bool IsAnchorFrame();
+	virtual sal_Bool IsAnchorCell();	
+	virtual void XFConvertFrame(XFContentContainer* pCont, sal_Int32 nStart = 0, sal_Int32 nEnd = 0, sal_Bool bAll = sal_False){}
+	XFFont* GetFont();
+	void SetFont(XFFont* pFont);
+	enum WrapType
+	{
+		LAY_WRAP_AROUND = 1,
+		LAY_NO_WRAP_BESIDE,
+		LAY_NO_WRAP_AROUND,
+		LAY_WRAP_LEFT,
+		LAY_WRAP_RIGHT,
+		//OLD_LAY_WRAP_RIGHT,
+		LAY_WRAP_BOTH,
+		LAY_WRAP_IRREG_BOTH,
+		LAY_WRAP_IRREG_LEFT,
+		LAY_WRAP_IRREG_RIGHT,
+		LAY_WRAP_IRREG_BIGGEST
+	};	
+protected:
+	void Read();	
+protected:
+	sal_uInt8 m_nWrapType;
+	sal_uInt8 m_nBuoyancy;
+	sal_Int32 m_nBaseLineOffset;
+	LwpAtomHolder m_Script;
+	LwpObjectID m_LayRelativity;
+	sal_uInt16 m_nPageNumber;//for frame anchored to page	
+	XFFont* m_pFont;//for frame position
+};
+#endif
diff -urNp lotuswordpro.bak/source/filter/lwplaypiece.cxx lotuswordpro/source/filter/lwplaypiece.cxx
--- lotuswordpro.bak/source/filter/lwplaypiece.cxx	1970-01-01 08:00:00.000000000 +0800
+++ lotuswordpro/source/filter/lwplaypiece.cxx	2008-10-22 11:42:29.000000000 +0800
@@ -0,0 +1,465 @@
+/*************************************************************************
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: IBM Corporation
+ *
+ *  Copyright: 2008 by IBM Corporation
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+/*************************************************************************
+ * @file 
+ *  For LWP filter architecture prototype
+ ************************************************************************/
+/*************************************************************************
+ * Change History
+ Jan 28 2005			Created
+ ************************************************************************/
+
+#include "lwplaypiece.hxx"
+
+#include "lwpfilehdr.hxx"
+LwpRotor::LwpRotor()
+{}
+
+LwpRotor::~LwpRotor()
+{}
+
+void LwpRotor:: Read(LwpObjectStream *pStrm)
+{
+	m_nRotation = pStrm->QuickReadInt16();
+}
+
+LwpLayoutGeometry::LwpLayoutGeometry(LwpObjectHeader& objHdr, LwpSvStream* pStrm)
+	: LwpVirtualPiece(objHdr, pStrm)
+{}
+
+LwpLayoutGeometry::~LwpLayoutGeometry()
+{}
+
+void LwpLayoutGeometry::Read()
+{
+	LwpVirtualPiece::Read();
+	
+	if(LwpFileHeader::m_nFileRevision >= 0x000B)
+	{
+		m_nWidth = m_pObjStrm->QuickReadInt32();
+		m_nHeight = m_pObjStrm->QuickReadInt32();
+		m_Origin.Read(m_pObjStrm);
+		m_AbsoluteOrigin.Read(m_pObjStrm);
+		m_ContainerRotor.Read(m_pObjStrm);
+		m_ContentOrientation = m_pObjStrm->QuickReaduInt8();
+		m_pObjStrm->SkipExtra();
+	}
+}
+void LwpLayoutGeometry::Parse(IXFStream* pOutputStream)
+{}
+
+LwpLayoutScale::LwpLayoutScale(LwpObjectHeader& objHdr, LwpSvStream* pStrm)
+	: LwpVirtualPiece(objHdr, pStrm)
+{}
+
+LwpLayoutScale::~LwpLayoutScale()
+{}
+
+void LwpLayoutScale::Read()
+{
+	LwpVirtualPiece::Read();
+
+	if(LwpFileHeader::m_nFileRevision >= 0x000B)
+	{
+		m_nScaleMode = m_pObjStrm->QuickReaduInt16();
+		m_nScalePercentage = m_pObjStrm->QuickReaduInt32();
+		m_nScaleWidth = m_pObjStrm->QuickReadInt32();
+		m_nScaleHeight = m_pObjStrm->QuickReadInt32();
+		m_nContentRotation = m_pObjStrm->QuickReaduInt16();
+		m_Offset.Read(m_pObjStrm);
+
+		m_nPlacement = m_pObjStrm->QuickReaduInt16();
+		m_pObjStrm->SkipExtra();
+	}
+}
+
+void LwpLayoutScale::Parse(IXFStream* pOutputStream)
+{}
+
+LwpLayoutMargins::LwpLayoutMargins(LwpObjectHeader& objHdr, LwpSvStream* pStrm)
+	: LwpVirtualPiece(objHdr, pStrm)
+{}
+
+LwpLayoutMargins::~LwpLayoutMargins()
+{}
+
+void LwpLayoutMargins::Read()
+{
+	LwpVirtualPiece::Read();
+	
+	if( LwpFileHeader::m_nFileRevision >= 0x000B )
+	{
+		m_Margins.Read(m_pObjStrm);
+		m_ExtMargins.Read(m_pObjStrm);
+		m_ExtraMargins.Read(m_pObjStrm);
+		m_pObjStrm->SkipExtra();
+	}
+}
+
+void LwpLayoutMargins::Parse(IXFStream* pOutputStream)
+{}
+
+LwpLayoutBorder::LwpLayoutBorder(LwpObjectHeader& objHdr, LwpSvStream* pStrm)
+	: LwpVirtualPiece(objHdr, pStrm)
+{}
+
+LwpLayoutBorder::~LwpLayoutBorder()
+{}
+
+void LwpLayoutBorder::Read()
+{
+	LwpVirtualPiece::Read();
+	
+	if( LwpFileHeader::m_nFileRevision >= 0x000B )
+	{
+		m_BorderStuff.Read(m_pObjStrm);
+		m_pObjStrm->SkipExtra();
+	}
+}
+
+void LwpLayoutBorder::Parse(IXFStream* pOutputStream)
+{}
+
+LwpLayoutBackground::LwpLayoutBackground(LwpObjectHeader& objHdr, LwpSvStream* pStrm)
+	: LwpVirtualPiece(objHdr, pStrm)
+{}
+
+LwpLayoutBackground::~LwpLayoutBackground()
+{}
+
+void LwpLayoutBackground::Read()
+{
+	LwpVirtualPiece::Read();
+	
+	if( LwpFileHeader::m_nFileRevision >= 0x000B )
+	{
+		m_BackgroundStuff.Read(m_pObjStrm);
+		m_pObjStrm->SkipExtra();
+	}
+}
+
+void LwpLayoutBackground::Parse(IXFStream* pOutputStream)
+{}
+
+LwpExternalBorder::LwpExternalBorder()
+{}
+
+LwpExternalBorder::~LwpExternalBorder()
+{}
+
+void LwpExternalBorder:: Read(LwpObjectStream *pStrm)
+{
+	if( LwpFileHeader::m_nFileRevision >= 0x000F )
+	{
+		//enum {BORDER,JOIN};
+		m_LeftName.Read(pStrm);
+		m_TopName.Read(pStrm);
+		m_RightName.Read(pStrm);
+		m_BottomName.Read(pStrm);
+		// TODO: Do not know what it is for
+		/*cLeftName = CStyleMgr::GetUniqueMetaFileName(cLeftName,BORDER);
+		cRightName = CStyleMgr::GetUniqueMetaFileName(cRightName,BORDER);
+		cTopName = CStyleMgr::GetUniqueMetaFileName(cTopName,BORDER);
+		cBottomName = CStyleMgr::GetUniqueMetaFileName(cBottomName,BORDER);*/
+		pStrm->SkipExtra();
+	}
+}
+
+LwpLayoutExternalBorder::LwpLayoutExternalBorder(LwpObjectHeader& objHdr, LwpSvStream* pStrm)
+	: LwpVirtualPiece(objHdr, pStrm)
+{}
+
+LwpLayoutExternalBorder::~LwpLayoutExternalBorder()
+{}
+
+void LwpLayoutExternalBorder::Read()
+{
+	LwpVirtualPiece::Read();
+	
+	if( LwpFileHeader::m_nFileRevision >= 0x000B )
+	{
+		m_ExtranalBorder.Read(m_pObjStrm);
+		m_pObjStrm->SkipExtra();
+	}
+}
+
+void LwpLayoutExternalBorder::Parse(IXFStream* pOutputStream)
+{}
+
+LwpColumnInfo::LwpColumnInfo()
+{}
+
+LwpColumnInfo::~LwpColumnInfo()
+{}
+
+void LwpColumnInfo:: Read(LwpObjectStream *pStrm)
+{
+	m_nWidth = pStrm->QuickReadInt32();
+	m_nGap = pStrm->QuickReadInt32();
+}
+
+LwpLayoutColumns::LwpLayoutColumns(LwpObjectHeader& objHdr, LwpSvStream* pStrm)
+	: LwpVirtualPiece(objHdr, pStrm),m_pColumns(NULL)
+{}
+
+LwpLayoutColumns::~LwpLayoutColumns()
+{
+	if(m_pColumns)
+	{
+		delete[] m_pColumns;
+		m_pColumns = NULL;
+	}
+		
+}
+
+void LwpLayoutColumns::Read()
+{
+	LwpVirtualPiece::Read();
+	
+	if( LwpFileHeader::m_nFileRevision >= 0x000B )
+	{
+		m_nNumCols = m_pObjStrm->QuickReaduInt16();
+		m_pColumns = new LwpColumnInfo[m_nNumCols];
+		for(int i=0; i<m_nNumCols; i++)
+		{
+			m_pColumns[i].Read(m_pObjStrm);
+		}
+		m_pObjStrm->SkipExtra();
+	}
+}
+
+double LwpLayoutColumns::GetColWidth(sal_uInt16 nIndex)
+{
+	if(nIndex >= m_nNumCols)
+	{
+		return 0;
+	}
+	return m_pColumns[nIndex].GetWidth();
+}
+
+double LwpLayoutColumns::GetColGap(sal_uInt16 nIndex)
+{
+	if(nIndex >= m_nNumCols)
+	{
+		return 0;
+	}
+	return m_pColumns[nIndex].GetGap();
+}
+
+void LwpLayoutColumns::Parse(IXFStream* pOutputStream)
+{}
+
+LwpLayoutGutters::LwpLayoutGutters(LwpObjectHeader& objHdr, LwpSvStream* pStrm)
+	: LwpVirtualPiece(objHdr, pStrm)
+{}
+
+LwpLayoutGutters::~LwpLayoutGutters()
+{}
+
+void LwpLayoutGutters::Read()
+{
+	LwpVirtualPiece::Read();
+	
+	if( LwpFileHeader::m_nFileRevision >= 0x000B )
+	{
+		m_BorderBuffer.Read(m_pObjStrm);
+		m_pObjStrm->SkipExtra();
+	}
+}
+
+
+void LwpLayoutGutters::Parse(IXFStream* pOutputStream)
+{}
+
+LwpJoinStuff::LwpJoinStuff()
+{}
+
+LwpJoinStuff::~LwpJoinStuff()
+{}
+
+#include "lwpstyledef.hxx"
+void LwpJoinStuff:: Read(LwpObjectStream *pStrm)
+{
+	m_nWidth = pStrm->QuickReadInt32();
+	m_nHeight = pStrm->QuickReadInt32();
+	m_nPercentage = pStrm->QuickReaduInt16();
+	m_nID = pStrm->QuickReaduInt16();
+	m_nCorners = pStrm->QuickReaduInt16();
+	m_nScaling = pStrm->QuickReaduInt16();
+	m_Color.Read(pStrm);
+	pStrm->SkipExtra();
+
+	// Bug fix: if reading in from something older than Release 9
+	// then check for the external ID and change it to solid.
+	if (LwpFileHeader::m_nFileRevision < 0x0010)
+	{
+		if (m_nID & EXTERNAL_ID)
+			m_nID = MITRE;
+	}
+}
+
+LwpLayoutJoins::LwpLayoutJoins(LwpObjectHeader& objHdr, LwpSvStream* pStrm)
+	: LwpVirtualPiece(objHdr, pStrm)
+{}
+
+LwpLayoutJoins::~LwpLayoutJoins()
+{}
+
+void LwpLayoutJoins::Read()
+{
+	LwpVirtualPiece::Read();
+	
+	if( LwpFileHeader::m_nFileRevision >= 0x000B )
+	{
+		m_JoinStuff.Read(m_pObjStrm);
+		m_pObjStrm->SkipExtra();
+	}
+}
+
+void LwpLayoutJoins::Parse(IXFStream* pOutputStream)
+{}
+
+LwpLayoutShadow::LwpLayoutShadow(LwpObjectHeader& objHdr, LwpSvStream* pStrm)
+	: LwpVirtualPiece(objHdr, pStrm)
+{}
+
+LwpLayoutShadow::~LwpLayoutShadow()
+{}
+
+void LwpLayoutShadow::Read()
+{
+	LwpVirtualPiece::Read();
+	
+	if( LwpFileHeader::m_nFileRevision >= 0x000B )
+	{
+		m_Shadow.Read(m_pObjStrm);
+		m_pObjStrm->SkipExtra();
+	}
+}
+
+void LwpLayoutShadow::Parse(IXFStream* pOutputStream)
+{}
+/**************************************************************************
+ * @descr: Constructor  
+ * @param:   
+ * @param:   
+ * @return:  
+**************************************************************************/
+LwpLayoutRelativityGuts::LwpLayoutRelativityGuts()
+{
+	m_nRelType = LAY_PARENT_RELATIVE;
+	m_nRelFromWhere = LAY_UPPERLEFT;
+	m_RelDistance.SetX(0);
+	m_RelDistance.SetY(0);
+	m_nTether = LAY_UPPERLEFT;
+	m_nTetherWhere = LAY_BORDER;
+  	m_nFlags = 0;
+}
+/**************************************************************************
+ * @descr: Read LayoutRelativityGuts' infomation.  
+ * @param:   
+ * @param:   
+ * @return:  
+**************************************************************************/
+void LwpLayoutRelativityGuts::Read(LwpObjectStream *pStrm)
+{
+	m_nRelType = pStrm->QuickReaduInt8();
+	m_nRelFromWhere = pStrm->QuickReaduInt8();
+	m_RelDistance.Read(pStrm);
+	m_nTether = pStrm->QuickReaduInt8();
+	m_nTetherWhere = pStrm->QuickReaduInt8();
+	if(LwpFileHeader::m_nFileRevision >= 0x000B)
+	{
+		m_nFlags = pStrm->QuickReaduInt8();
+	}
+	else
+	{
+		m_nFlags = 0;
+	}
+}
+/**************************************************************************
+ * @descr: Constructor
+ * @param:   
+ * @param:   
+ * @return:  
+**************************************************************************/
+LwpLayoutRelativity::LwpLayoutRelativity(LwpObjectHeader &objHdr, LwpSvStream *pStrm)
+	: LwpVirtualPiece(objHdr, pStrm)
+{
+}
+/**************************************************************************
+ * @descr: destructor
+ * @param:   
+ * @param:   
+ * @return:  
+**************************************************************************/
+LwpLayoutRelativity::~LwpLayoutRelativity()
+{
+}
+
+void LwpLayoutRelativity::Read()
+{
+	LwpVirtualPiece::Read();
+	if(LwpFileHeader::m_nFileRevision >= 0x000B)
+	{
+		m_RelGuts.Read(m_pObjStrm);
+		m_pObjStrm->SkipExtra();
+	}	
+}
+
+void LwpLayoutRelativity::Parse(IXFStream *pOutputStream)
+{
+}
+
diff -urNp lotuswordpro.bak/source/filter/lwplaypiece.hxx lotuswordpro/source/filter/lwplaypiece.hxx
--- lotuswordpro.bak/source/filter/lwplaypiece.hxx	1970-01-01 08:00:00.000000000 +0800
+++ lotuswordpro/source/filter/lwplaypiece.hxx	2008-10-22 11:42:29.000000000 +0800
@@ -0,0 +1,392 @@
+/*************************************************************************
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: IBM Corporation
+ *
+ *  Copyright: 2008 by IBM Corporation
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+/*************************************************************************
+ * @file 
+ *  For LWP filter architecture prototype
+ ************************************************************************/
+/*************************************************************************
+ * Change History
+ Jan 28 2005			Created
+ ************************************************************************/
+#ifndef _LWPLAYOUTPIECE_HXX
+#define _LWPLAYOUTPIECE_HXX
+
+#include "lwppiece.hxx"
+#include "lwpbasetype.hxx"
+
+class LwpRotor
+{
+public:
+	LwpRotor();
+	~LwpRotor();
+	void Read(LwpObjectStream *pStrm);
+private:
+	sal_Int16 m_nRotation;	//angle
+	sal_uInt16 m_nSin;
+	sal_uInt16 m_nCos;
+};
+
+class LwpLayoutGeometry : public LwpVirtualPiece
+{
+public:
+	LwpLayoutGeometry(LwpObjectHeader& objHdr, LwpSvStream* pStrm);
+	virtual ~LwpLayoutGeometry();
+	virtual void Parse(IXFStream* pOutputStream);
+	sal_Int32 GetWidth() { return m_nWidth; }
+	sal_Int32 GetHeight() { return m_nHeight; }
+	LwpPoint GetOrigin() { return m_Origin; }
+	LwpPoint GetAbsoluteOrigin() { return m_AbsoluteOrigin; }
+	sal_uInt8 GetContentOrientation(){ return m_ContentOrientation;}
+
+protected:
+	virtual void Read();
+protected:
+	sal_Int32 m_nWidth;
+	sal_Int32 m_nHeight;
+	LwpPoint m_Origin;
+	LwpPoint m_AbsoluteOrigin;
+	LwpRotor m_ContainerRotor;
+	sal_uInt8 m_ContentOrientation;	
+};
+
+class LwpLayoutScale : public LwpVirtualPiece
+{
+public:
+	enum    {ORIGINAL_SIZE = 1, FIT_IN_FRAME = 2, PERCENTAGE = 4, 
+             CUSTOM = 8, MAINTAIN_ASPECT_RATIO = 16};
+
+	enum    {CENTERED = 1, TILED = 2};
+	LwpLayoutScale(LwpObjectHeader& objHdr, LwpSvStream* pStrm);
+	virtual ~LwpLayoutScale();
+	virtual void Parse(IXFStream* pOutputStream);
+	sal_uInt16 GetScaleMode(){return m_nScaleMode;}
+	void SetScaleMode(sal_uInt16 nVal){m_nScaleMode = nVal;}
+	sal_uInt32 GetScalePercentage(){return m_nScalePercentage;}
+	void SetScalePercentage(sal_uInt32 nVal){m_nScalePercentage = nVal;}
+	sal_Int32 GetScaleWidth(){return m_nScaleWidth;}
+	void SetScaleWidth(sal_Int32 nVal){m_nScaleWidth = nVal;}
+	sal_Int32 GetScaleHeight(){return m_nScaleHeight;}
+	void SetScaleHeight(sal_Int32 nVal){m_nScaleHeight = nVal;}
+	sal_uInt16 GetContentRotation(){return m_nContentRotation;}
+	void SetContentRotation(sal_uInt16 nVal){m_nContentRotation = nVal;}
+	sal_uInt16 GetPlacement(){return m_nPlacement;}
+	void SetPlacement(sal_uInt16 nVal){m_nPlacement = nVal;}
+	// add by , 04/05/2005
+	inline LwpPoint* GetOffset() {return &m_Offset;};
+	// end add
+protected:
+	virtual void Read();
+protected:
+	sal_uInt16 m_nScaleMode;
+	sal_uInt32 m_nScalePercentage;
+	sal_Int32 m_nScaleWidth;
+	sal_Int32 m_nScaleHeight;
+	sal_uInt16 m_nContentRotation;
+	LwpPoint m_Offset;
+	sal_uInt16 m_nPlacement;
+};
+
+#include "lwpmargins.hxx"
+
+class LwpLayoutMargins : public LwpVirtualPiece
+{
+public:
+	LwpLayoutMargins(LwpObjectHeader& objHdr, LwpSvStream* pStrm);
+	virtual ~LwpLayoutMargins();
+	virtual void Parse(IXFStream* pOutputStream);
+	LwpMargins* GetMargins() { return &m_Margins; }
+	LwpMargins* GetExtMargins(){ return &m_ExtMargins;}
+protected:
+	virtual void Read();
+protected:
+	LwpMargins m_Margins;
+	LwpMargins m_ExtMargins;
+	LwpMargins m_ExtraMargins;
+};
+
+#include "lwpborderstuff.hxx"
+class LwpLayoutBorder : public LwpVirtualPiece
+{
+public:
+	LwpLayoutBorder(LwpObjectHeader& objHdr, LwpSvStream* pStrm);
+	virtual ~LwpLayoutBorder();
+	virtual void Parse(IXFStream* pOutputStream);
+	LwpBorderStuff* GetBorderStuff(){ return &m_BorderStuff;}
+protected:
+	virtual void Read();
+protected:
+	LwpBorderStuff m_BorderStuff;
+};
+
+class LwpLayoutBackground : public LwpVirtualPiece
+{
+public:
+	LwpLayoutBackground(LwpObjectHeader& objHdr, LwpSvStream* pStrm);
+	virtual ~LwpLayoutBackground();
+	virtual void Parse(IXFStream* pOutputStream);
+	LwpBackgroundStuff* GetBackgoudStuff(){return &m_BackgroundStuff;}
+protected:
+	virtual void Read();
+protected:
+	LwpBackgroundStuff m_BackgroundStuff;
+};
+
+class LwpExternalBorder 
+{
+public:
+	LwpExternalBorder();
+	~LwpExternalBorder();
+	void Read(LwpObjectStream *pStrm);
+private:
+	LwpAtomHolder m_LeftName;
+	LwpAtomHolder m_TopName;
+	LwpAtomHolder m_RightName;
+	LwpAtomHolder m_BottomName;
+};
+
+//It seems that this class is used for designer border. Only read now.
+class LwpLayoutExternalBorder : public LwpVirtualPiece
+{
+public:
+	LwpLayoutExternalBorder(LwpObjectHeader& objHdr, LwpSvStream* pStrm);
+	virtual ~LwpLayoutExternalBorder();
+	virtual void Parse(IXFStream* pOutputStream);
+protected:
+	virtual void Read();
+protected:
+	LwpExternalBorder	m_ExtranalBorder;
+};
+
+class LwpColumnInfo
+{
+public:
+	LwpColumnInfo();
+	~LwpColumnInfo();
+	void Read(LwpObjectStream *pStrm);
+	inline double GetWidth(){return LwpTools::ConvertFromUnitsToMetric(m_nWidth);}
+	inline void SetWidth(sal_Int32 w){m_nWidth = w;}
+	inline double GetGap(){return LwpTools::ConvertFromUnitsToMetric(m_nGap);}
+	inline void SetGap(sal_Int32 g){m_nGap = g;}	
+private:
+	sal_Int32 m_nWidth;
+	sal_Int32 m_nGap;
+};
+
+class LwpLayoutColumns : public LwpVirtualPiece
+{
+public:
+	LwpLayoutColumns(LwpObjectHeader& objHdr, LwpSvStream* pStrm);
+	virtual ~LwpLayoutColumns();
+	virtual void Parse(IXFStream* pOutputStream);
+	inline sal_uInt16 GetNumCols(){return m_nNumCols;};
+	double GetColWidth(sal_uInt16 nIndex);
+	double GetColGap(sal_uInt16 nIndex);
+protected:
+	virtual void Read();
+protected:
+	sal_uInt16 m_nNumCols;
+	LwpColumnInfo* m_pColumns;
+};
+
+class LwpLayoutGutters : public LwpVirtualPiece
+{
+public:
+	LwpLayoutGutters(LwpObjectHeader& objHdr, LwpSvStream* pStrm);
+	virtual ~LwpLayoutGutters();
+	virtual void Parse(IXFStream* pOutputStream);
+	inline virtual LwpBorderStuff* GetBorderStuff(){return &m_BorderBuffer;}
+protected:
+	virtual void Read();
+protected:
+	LwpBorderStuff m_BorderBuffer;
+};
+
+class LwpJoinStuff
+{
+public:
+	LwpJoinStuff();
+	~LwpJoinStuff();
+	void Read(LwpObjectStream *pStrm);
+private:
+	sal_uInt16 m_nPercentage;
+	sal_uInt16 m_nCorners;
+	sal_Int32 m_nWidth;
+	sal_Int32 m_nHeight;
+	
+	enum JoinType
+	{
+		MITRE = 1,
+		NEGATE = 2,
+		ROUNDED = 3,
+		RECTANGLE =	4,
+		SPECIAL = 5,
+		DIAGONAL = 6,
+		NEGATE_NO_CROSS = 7, 
+		DOG_EAR_PAGE = 8, 
+		DESKTOP = 9,
+		BOX_HIGHLIGHT = 10,
+//#ifdef BORDER_BMP
+		STAR = 11,
+		ROPE = 12,
+		DECO1 = 13,
+		DECO2 = 14,
+		RAIN = 15,
+		PIN = 16,
+		ROSE = 17,
+		SUNF = 18,
+		DECO3 = 19,
+//#endif //BORDER_BMP
+		WARNING = 20,
+		BUBBLE = 21,
+		GIRDER = 22,
+		SMILE = 23,
+		ARROW = 24,
+		MAXJOIN = 24
+	};
+
+	sal_uInt16 m_nID;//JoinType
+	sal_uInt16 m_nScaling;
+	LwpColor m_Color;
+};
+
+class LwpLayoutJoins : public LwpVirtualPiece
+{
+public:
+	LwpLayoutJoins(LwpObjectHeader& objHdr, LwpSvStream* pStrm);
+	virtual ~LwpLayoutJoins();
+	virtual void Parse(IXFStream* pOutputStream);
+protected:
+	virtual void Read();
+protected:
+	LwpJoinStuff m_JoinStuff;
+};
+
+#include "lwpshadow.hxx"
+
+class LwpLayoutShadow : public LwpVirtualPiece
+{
+public:
+	LwpLayoutShadow(LwpObjectHeader& objHdr, LwpSvStream* pStrm);
+	virtual ~LwpLayoutShadow();
+	virtual void Parse(IXFStream* pOutputStream);
+	LwpShadow* GetShadow(){return &m_Shadow;}
+protected:
+	virtual void Read();
+protected:
+	LwpShadow m_Shadow;
+};
+
+/*class LwpLayoutRelativityGuts*/
+class LwpLayoutRelativityGuts
+{
+public:
+	LwpLayoutRelativityGuts();
+	void Read(LwpObjectStream *pStrm);
+	sal_uInt8 GetRelativeType(){ return m_nRelType;}
+	sal_uInt8 GetRelativeFromWhere(){ return m_nRelFromWhere;}
+	LwpPoint GetRelativeDistance(){ return m_RelDistance;}
+	sal_uInt8 GetTetherType(){ return m_nTether;}
+	sal_uInt8 GetTetherWhere(){ return m_nTetherWhere;}
+public:
+	enum RelativeType
+	{
+		LAY_PARENT_RELATIVE = 1,
+		LAY_PARA_RELATIVE,
+		LAY_INLINE,
+		LAY_INLINE_NEWLINE,
+		LAY_CONTENT_RELATIVE,
+		LAY_INLINE_VERTICAL
+	};
+	enum WhereType
+	{
+		LAY_UPPERLEFT = 1,
+		LAY_MIDDLETOP,	
+		LAY_UPPERRIGHT,	
+		LAY_MIDDLELEFT,	
+		LAY_MIDDLERIGHT, 
+		LAY_LOWERLEFT,
+		LAY_MIDDLEBOTTOM,
+		LAY_LOWERRIGHT,
+		LAY_MIDDLE
+	};
+	enum TetherWhereType
+	{
+		LAY_INTERNAL = 1,
+		LAY_EXTERNAL,
+		LAY_BORDER
+	};
+private:
+	sal_uInt8	m_nRelType;
+	sal_uInt8	m_nRelFromWhere;
+	LwpPoint	m_RelDistance;
+	sal_uInt8	m_nTether;
+	sal_uInt8	m_nTetherWhere;	
+	sal_uInt8	m_nFlags;
+};
+
+class LwpLayoutRelativity: public LwpVirtualPiece
+{
+public:
+	LwpLayoutRelativity(LwpObjectHeader& objHdr, LwpSvStream* pStrm);
+	virtual ~LwpLayoutRelativity();
+	virtual void Parse(IXFStream* pOutputStream);
+	LwpLayoutRelativityGuts* GetRelGuts(){return &m_RelGuts;}
+protected:
+	virtual void Read();
+protected:
+	LwpLayoutRelativityGuts m_RelGuts;
+};
+
+#endif
diff -urNp lotuswordpro.bak/source/filter/lwplnopts.cxx lotuswordpro/source/filter/lwplnopts.cxx
--- lotuswordpro.bak/source/filter/lwplnopts.cxx	1970-01-01 08:00:00.000000000 +0800
+++ lotuswordpro/source/filter/lwplnopts.cxx	2008-10-22 11:42:29.000000000 +0800
@@ -0,0 +1,98 @@
+/*************************************************************************
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: IBM Corporation
+ *
+ *  Copyright: 2008 by IBM Corporation
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+#include "lwpglobalmgr.hxx"
+#include "lwplnopts.hxx"
+
+LwpLineNumberOptions::LwpLineNumberOptions(LwpObjectStream* pStrm)
+{
+	Read(pStrm);
+}
+/**
+ * @descr	 	Read LwpLineNumberOptions from object stream
+ */
+void LwpLineNumberOptions::Read(LwpObjectStream *pStrm)
+{
+	pStrm->QuickRead(&m_nType, sizeof(m_nType));
+	pStrm->QuickRead(&m_nFlags, sizeof(m_nFlags));
+	pStrm->QuickRead(&m_nSeparator, sizeof(m_nSeparator));
+	pStrm->QuickRead(&m_nSpacing, sizeof(m_nSpacing));
+	pStrm->QuickRead(&m_nDistance, sizeof(m_nDistance));
+	pStrm->SkipExtra();
+}
+/**
+ * @descr	 	set XFLineNumberConfig
+ */
+void LwpLineNumberOptions::RegisterStyle()
+{
+	if (m_nType == NUMBER_NONE)
+		return;
+	XFLineNumberConfig* pLineNumber = new XFLineNumberConfig;
+	pLineNumber->SetNumberPosition(enumXFLineNumberLeft);
+	pLineNumber->SetNumberOffset(LwpTools::ConvertFromUnitsToMetric(m_nDistance));
+	pLineNumber->SetNumberIncrement(m_nSeparator);
+	if (m_nFlags & LN_RESETEACHPAGE)	
+		pLineNumber->SetRestartOnPage(sal_True);
+	else
+		pLineNumber->SetRestartOnPage(sal_False);		
+	if (m_nFlags & LN_COUNTBLANKLINES)
+		pLineNumber->SetCountEmptyLines(sal_True);
+	else
+		pLineNumber->SetCountEmptyLines(sal_False);
+
+	XFStyleManager* pXFStyleManager = LwpGlobalMgr::GetInstance()->GetXFStyleManager(); 	
+	pXFStyleManager->SetLineNumberConfig(pLineNumber);
+}
+
+
diff -urNp lotuswordpro.bak/source/filter/lwplnopts.hxx lotuswordpro/source/filter/lwplnopts.hxx
--- lotuswordpro.bak/source/filter/lwplnopts.hxx	1970-01-01 08:00:00.000000000 +0800
+++ lotuswordpro/source/filter/lwplnopts.hxx	2008-10-22 11:42:29.000000000 +0800
@@ -0,0 +1,98 @@
+/*************************************************************************
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: IBM Corporation
+ *
+ *  Copyright: 2008 by IBM Corporation
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+/*************************************************************************
+ * @file 
+ *  For LWP filter architecture prototype
+ ************************************************************************/
+/*************************************************************************
+ * Change History
+ Jan 2005			Created
+ ************************************************************************/
+
+#ifndef _LWPLINENUMBEROPTIONS_HXX
+#define _LWPLINENUMBEROPTIONS_HXX
+
+#include "lwpobjstrm.hxx"
+#include "lwptools.hxx"
+#include "xfilter/xflinenumberconfig.hxx"
+#include "xfilter/xfstylemanager.hxx"
+/**
+ * @brief	line number options
+*/
+class LwpLineNumberOptions
+{
+public:
+	LwpLineNumberOptions(LwpObjectStream* pStrm);
+	~LwpLineNumberOptions(){};
+protected:
+	sal_uInt16 m_nType;
+	sal_uInt16 m_nFlags;
+	sal_uInt16 m_nSeparator;
+	sal_uInt32 m_nSpacing;
+	sal_uInt32 m_nDistance;
+public:
+	enum
+	{
+		NUMBER_NONE, NUMBER_LINES, NUMBER_TEXTLINESONLY
+	}; 
+	enum
+	{
+		LN_RESETEACHPAGE	= 0x01,
+		LN_COUNTBLANKLINES	= 0x02
+	};		
+	void Read(LwpObjectStream *pStrm);
+	void RegisterStyle();
+};
+#endif
diff -urNp lotuswordpro.bak/source/filter/lwpmargins.hxx lotuswordpro/source/filter/lwpmargins.hxx
--- lotuswordpro.bak/source/filter/lwpmargins.hxx	1970-01-01 08:00:00.000000000 +0800
+++ lotuswordpro/source/filter/lwpmargins.hxx	2008-10-22 11:42:29.000000000 +0800
@@ -0,0 +1,117 @@
+/*************************************************************************
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: IBM Corporation
+ *
+ *  Copyright: 2008 by IBM Corporation
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+//
+#ifndef		_LWPMARGINS_HXX
+#define		_LWPMARGINS_HXX
+
+#include	"lwpobjstrm.hxx"
+#include	"lwptools.hxx"
+
+const sal_uInt8 MARGIN_LEFT = 0;
+const sal_uInt8 MARGIN_RIGHT = 1;
+const sal_uInt8 MARGIN_TOP = 2;
+const sal_uInt8 MARGIN_BOTTOM = 3;
+
+class LwpMargins
+{
+public:
+	LwpMargins():m_nLeft(0),m_nTop(0),m_nRight(0),m_nBottom(0){}
+public:
+	void	Read(LwpObjectStream *pStrm)
+	{
+		pStrm->QuickRead(&m_nLeft, 4);
+		pStrm->QuickRead(&m_nTop, 4);
+		pStrm->QuickRead(&m_nRight, 4);
+		pStrm->QuickRead(&m_nBottom, 4);
+		pStrm->SkipExtra();
+	}
+	//add by , 01/26/2004
+	inline void operator = (const LwpMargins& rOther);
+	inline double GetMarginsValue(const sal_uInt8& nWhichSide);
+	//end add
+private:
+	sal_Int32		m_nLeft;
+	sal_Int32		m_nTop;
+	sal_Int32		m_nRight;
+	sal_Int32		m_nBottom;
+};
+
+inline void LwpMargins::operator = (const LwpMargins& rOther)
+{
+	m_nLeft = rOther.m_nLeft;
+	m_nTop = rOther.m_nTop;
+	m_nRight = rOther.m_nRight;
+	m_nBottom = rOther.m_nBottom;
+}
+
+inline double LwpMargins::GetMarginsValue(const sal_uInt8& nWhichSide)
+{
+	switch (nWhichSide)
+	{
+	case MARGIN_LEFT://left
+		return LwpTools::ConvertFromUnitsToMetric(m_nLeft);
+		break;
+	case MARGIN_RIGHT://right
+		return LwpTools::ConvertFromUnitsToMetric(m_nRight);
+		break;
+	case MARGIN_TOP://top
+		return LwpTools::ConvertFromUnitsToMetric(m_nTop);
+		break;
+	case MARGIN_BOTTOM://bottom
+		return LwpTools::ConvertFromUnitsToMetric(m_nBottom);
+		break;
+	}
+}
+#endif
\ No newline at end of file
diff -urNp lotuswordpro.bak/source/filter/lwpmarker.cxx lotuswordpro/source/filter/lwpmarker.cxx
--- lotuswordpro.bak/source/filter/lwpmarker.cxx	1970-01-01 08:00:00.000000000 +0800
+++ lotuswordpro/source/filter/lwpmarker.cxx	2008-10-22 11:42:29.000000000 +0800
@@ -0,0 +1,573 @@
+/*************************************************************************
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: IBM Corporation
+ *
+ *  Copyright: 2008 by IBM Corporation
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+/*************************************************************************
+ * @file 
+ *  For LWP filter architecture prototype
+ ************************************************************************/
+/*************************************************************************
+ * Change History
+ Mar 2005			Created
+ ************************************************************************/
+#include "lwpfoundry.hxx"
+#include "lwpfilehdr.hxx"
+#include "lwpstory.hxx"
+#include "lwpmarker.hxx"
+#include "lwpproplist.hxx"
+#include "lwpglobalmgr.hxx"
+#include "xfilter/xfplaceholder.hxx"
+#include "xfilter/xfinputlist.hxx"
+
+LwpMarker::LwpMarker(LwpObjectHeader &objHdr, LwpSvStream *pStrm):LwpDLNFPVList(objHdr,pStrm)
+{
+}
+
+void LwpMarker::Read()
+{
+	LwpDLNFPVList::Read();
+	m_objContent.ReadIndexed(m_pObjStrm);
+	m_objLayout.ReadIndexed(m_pObjStrm);
+	m_objMarkerList.ReadIndexed(m_pObjStrm);
+	m_nNeedUpdate = m_pObjStrm->QuickReaduInt16();
+	m_nFlag = m_pObjStrm->QuickReaduInt16();
+	m_nPageNumber = m_pObjStrm->QuickReaduInt16();
+
+	m_pObjStrm->SkipExtra();
+}
+
+OUString LwpMarker::GetNamedProperty(OUString name)
+{
+	LwpPropList* pProp = GetPropList();
+	if (pProp)
+		return pProp->GetNamedProperty(name);
+	else
+		return OUString(A2OUSTR(""));
+}
+	
+LwpStoryMarker::LwpStoryMarker(LwpObjectHeader &objHdr, LwpSvStream *pStrm):LwpMarker(objHdr,pStrm)
+{
+}
+
+void LwpStoryMarker::Read()
+{
+	LwpMarker::Read();
+	m_nFlag = m_pObjStrm->QuickReaduInt16();
+	m_Range.Read(m_pObjStrm);
+	m_pObjStrm->SkipExtra();
+}
+
+void LwpFribRange::Read(LwpObjectStream* pObjStrm)
+{
+	m_StartPara.ReadIndexed(pObjStrm);
+	m_EndPara.ReadIndexed(pObjStrm);
+}
+
+LwpCHBlkMarker::LwpCHBlkMarker(LwpObjectHeader &objHdr, LwpSvStream *pStrm):LwpStoryMarker(objHdr,pStrm)
+{
+}
+
+void LwpCHBlkMarker::Read()
+{
+	LwpStoryMarker::Read();
+	m_objPromptStory.ReadIndexed(m_pObjStrm);
+	m_Help.Read(m_pObjStrm);
+	m_nAction = m_pObjStrm->QuickReaduInt16();
+	m_nTab = m_pObjStrm->QuickReaduInt32();
+	m_nFlag = m_pObjStrm->QuickReaduInt16();
+	if(m_pObjStrm->CheckExtra())
+	{
+		m_Mirror.Read(m_pObjStrm);
+		m_pObjStrm->SkipExtra();
+	}	
+}
+
+OUString LwpCHBlkMarker::GetPromptText()
+{
+	LwpStory* pStory = NULL;
+	if (m_objPromptStory.obj())
+		pStory = static_cast<LwpStory*>(m_objPromptStory.obj());
+	if (pStory)
+		return pStory->GetContentText();
+	return A2OUSTR("");
+}
+
+void LwpCHBlkMarker::ConvertCHBlock(XFContentContainer* pXFPara, sal_uInt8 nType)
+{
+	sal_uInt16 nAction = GetAction();
+	
+	switch(nAction)
+	{
+	case CLICKHERE_CHBEHAVIORTEXT:
+	case CLICKHERE_CHBEHAVIORTABLE:
+	case CLICKHERE_CHBEHAVIORPICTURE:
+	case CLICKHERE_CHBEHAVIOROLEOBJECT:
+		ProcessPlaceHolder(pXFPara,nAction,nType);
+		break;
+	case CLICKHERE_CHBEHAVIORCHART:
+	case CLICKHERE_CHBEHAVIORDRAWING:
+	case CLICKHERE_CHBEHAVIORGLOSSARY:
+	case CLICKHERE_CHBEHAVIOREQUATION:
+	case CLICKHERE_CHBEHAVIORSYMBOL:
+	case CLICKHERE_CHBEHAVIORPAGENUM:
+	case CLICKHERE_CHBEHAVIORDOCFIELD:
+	case CLICKHERE_CHBEHAVIORDATETIME:	
+		ProcessOtherCHB(pXFPara,nType);
+		break;	
+//		ProcessPageNumber(pXFPara,nType);
+//		break;	
+	case CLICKHERE_CHBEHAVIORSTRINGLIST:
+		ProcessKeylist(pXFPara,nType);
+		break;
+	default:
+		break;
+	}
+}
+
+void LwpCHBlkMarker::ProcessPlaceHolder(XFContentContainer* pXFPara,sal_uInt16 nAction,
+				sal_uInt8 nType)
+{
+	sal_Bool bFillFlag = IsHasFilled();
+	sal_Bool bHelpFlag = IsBubbleHelp(); 
+	
+	if ( bFillFlag )
+		return;
+	if (nType == MARKER_START)
+	{
+		XFHolderStart* pHolder= new XFHolderStart;
+		switch(nAction)
+		{
+		case CLICKHERE_CHBEHAVIORTEXT:
+			pHolder->SetType(A2OUSTR("text"));
+			break;			
+		case CLICKHERE_CHBEHAVIORTABLE:
+			pHolder->SetType(A2OUSTR("table"));
+			break;
+		case CLICKHERE_CHBEHAVIORPICTURE:
+			pHolder->SetType(A2OUSTR("image"));
+			break;
+		case CLICKHERE_CHBEHAVIOROLEOBJECT:
+			pHolder->SetType(A2OUSTR("object"));
+			break;
+		default:
+			break;	
+		}
+
+		if (bHelpFlag)
+			pHolder->SetDesc(m_Help.str());
+		pHolder->SetPrompt(GetPromptText());
+		pXFPara->Add(pHolder);
+	}
+	else if (nType == MARKER_END)
+	{
+		XFHolderEnd* pHolder = new XFHolderEnd;
+		pXFPara->Add(pHolder);
+	}
+}
+
+void LwpCHBlkMarker::ProcessOtherCHB(XFContentContainer* pXFPara,sal_uInt8 nType)
+{
+	sal_Bool bFillFlag = IsHasFilled();
+	sal_Bool bHelpFlag = IsBubbleHelp(); 
+	
+	if ( bFillFlag )
+		return;
+	if (nType == MARKER_START)
+	{
+		XFHolderStart* pHolder= new XFHolderStart;
+		pHolder->SetType(A2OUSTR("text"));
+		if (bHelpFlag)
+			pHolder->SetDesc(m_Help.str());
+		pHolder->SetPrompt(GetPromptText());
+		pXFPara->Add(pHolder);
+	}
+	else if (nType == MARKER_END)
+	{
+		XFHolderEnd* pHolder = new XFHolderEnd;
+		pXFPara->Add(pHolder);
+	} 
+	
+}
+
+void LwpCHBlkMarker::ProcessPageNumber(XFContentContainer* pXFPara,sal_uInt8 nType)
+{
+	sal_Bool bFillFlag = IsHasFilled();
+	sal_Bool bHelpFlag = IsBubbleHelp(); 
+	
+	if ( bFillFlag )
+		return;
+	if (nType == MARKER_START)
+	{
+		XFHolderStart* pHolder= new XFHolderStart;
+		pHolder->SetType(A2OUSTR("text"));
+		if (bHelpFlag)
+			pHolder->SetDesc(m_Help.str());
+		pHolder->SetPrompt(GetPromptText());
+		pXFPara->Add(pHolder);
+	}
+	else if (nType == MARKER_END)
+	{
+		XFHolderEnd* pHolder = new XFHolderEnd;
+		pXFPara->Add(pHolder);
+	} 
+	
+}
+
+//note: there will be a blank to mark the list
+//all input content of key list processed as normal text
+void LwpCHBlkMarker::ProcessKeylist(XFContentContainer* pXFPara,sal_uInt8 nType)
+{
+	sal_Bool bFillFlag = IsHasFilled(); 
+	
+	if ( bFillFlag )
+	{
+		if (nType == MARKER_START)
+		{
+			EnumAllKeywords();//traverse the proplist to find all keywords
+			XFInputList* pList = new XFInputList;
+			pList->SetName(LwpDLNFPVList::m_Name.str());
+			pList->SetLabels(m_Keylist);
+			pXFPara->Add(pList);
+		}
+		else if (nType == MARKER_END)//skip
+		{		
+		}
+	}
+	else
+	{
+		if (nType == MARKER_START)
+		{
+			EnumAllKeywords();
+			XFInputList* pList = new XFInputList;
+			pList->SetName(LwpDLNFPVList::m_Name.str());
+			pList->SetLabels(m_Keylist);
+			pXFPara->Add(pList);
+			
+			XFHolderStart* pHolder= new XFHolderStart;
+			pHolder->SetType(A2OUSTR("text"));
+			pHolder->SetPrompt(GetPromptText());
+			pXFPara->Add(pHolder);
+		}
+		else if (nType == MARKER_END)
+		{
+			XFHolderEnd* pHolder = new XFHolderEnd;
+			pXFPara->Add(pHolder);
+		} 			
+	}
+}
+
+sal_Bool LwpCHBlkMarker::IsHasFilled()
+{
+	if (CHB_PROMPT & m_nFlag)
+		return sal_False;
+	return sal_True;
+}
+
+sal_Bool LwpCHBlkMarker::IsBubbleHelp()
+{
+	return (CHB_HELP & m_nFlag);
+}
+
+void LwpCHBlkMarker::EnumAllKeywords()
+{
+	OUString name1(A2OUSTR(""));
+	OUString value1(A2OUSTR(""));
+	OUString name2(A2OUSTR("start"));
+	LwpPropList* pProp = GetPropList();
+	if (!pProp)
+		return;
+	while(name2.getLength()>0)
+	{
+		name2 = pProp->EnumNamedProperty(name1,value1);
+		if ( name1.match(A2OUSTR("LIST"),0) )
+		{
+			m_Keylist.push_back(value1);			
+		}
+		name1 = name2;
+	}
+}
+
+
+LwpBookMark::LwpBookMark(LwpObjectHeader &objHdr, LwpSvStream *pStrm)
+	: LwpDLNFVList(objHdr,pStrm)
+{
+}
+
+void LwpBookMark::Read()
+{
+	LwpDLNFVList::Read();
+	m_objMarker.ReadIndexed(m_pObjStrm);
+	if (LwpFileHeader::m_nFileRevision < 0x0008)
+	{
+		if (m_pObjStrm->QuickReadBool())
+			m_nFlag |= BKMK_NOTESFX;
+	}
+	else
+		m_nFlag = m_pObjStrm->QuickReaduInt16();
+	m_pObjStrm->SkipExtra();
+}
+
+sal_Bool LwpBookMark::IsRightMarker(LwpObjectID objMarker)
+{
+	if (objMarker == m_objMarker)
+		return sal_True;
+	return sal_False;
+}
+
+OUString LwpBookMark::GetName()
+{
+	if (LwpDLNFVList::GetName())
+		return LwpDLNFVList::GetName()->str();
+	else
+		return OUString(A2OUSTR(""));
+}
+
+sal_Bool LwpBookMark::IsRightName(OUString sName)
+{
+	return sName.equals(GetName());
+}
+
+LwpFieldMark::LwpFieldMark(LwpObjectHeader &objHdr, LwpSvStream *pStrm):LwpStoryMarker(objHdr,pStrm),
+	m_bHasStyle(sal_False),m_bHasStart(sal_False),m_bRevisionFlag(sal_False),m_pFrib(NULL)
+{
+}
+
+void LwpFieldMark::Read()
+{
+	LwpStoryMarker::Read();
+	m_Formula.Read(m_pObjStrm);
+	m_objFormulaStory.ReadIndexed(m_pObjStrm);
+	if (LwpFileHeader::m_nFileRevision < 0x000B)
+		return;	
+	m_objResultContent.ReadIndexed(m_pObjStrm);
+	m_nFlag = m_pObjStrm->QuickReaduInt16();
+	m_nFieldType = m_pObjStrm->QuickReaduInt16();
+	m_pObjStrm->SkipExtra();		
+}
+
+void LwpFieldMark::ParseIndex(OUString& sKey1,OUString& sKey2)
+{
+	OUString sFormula = m_Formula.str();
+	sal_Int32 index[4];
+	sal_Unicode ch(0x0022);//"
+	index[0] = sFormula.indexOf(ch,0);
+	index[1] = sFormula.indexOf(ch,index[0]+1);
+	
+	index[2] = sFormula.indexOf(ch,index[1]+1);
+	index[3] = sFormula.indexOf(ch,index[2]+1);
+	if (index[0]>=0 && index[1]>=0)
+		sKey1 = sFormula.copy(index[0]+1,index[1]-index[0]-1);
+	else
+		sKey1 = A2OUSTR("");
+	if (index[2]>=0 && index[3]>=0)
+		sKey2 = sFormula.copy(index[2]+1,index[3]-index[2]-1);
+	else
+		sKey2 = A2OUSTR("");
+}
+
+void LwpFieldMark::ParseTOC(OUString& sLevel,OUString& sText)
+{
+	OUString sFormula = m_Formula.str();
+	sal_Int32 index[4];
+	sal_Unicode ch1(0x0020);//space	
+	sal_Unicode ch2(0x0022);//"
+	
+	index[0] = sFormula.indexOf(ch1,0);
+	index[1] = sFormula.indexOf(ch1,index[0]+1);
+	
+	index[2] = sFormula.indexOf(ch2,index[1]+1);
+	index[3] = sFormula.indexOf(ch2,index[2]+1);
+	if (index[0]>=0 && index[1]>=0)
+		sLevel = sFormula.copy(index[0]+1,index[1]-index[0]-1);
+	else
+		sLevel = A2OUSTR("");
+	if (index[2]>=0 && index[3]>=0)
+		sText = sFormula.copy(index[2]+1,index[3]-index[2]-1);
+	else
+		sText = A2OUSTR("");
+}
+
+sal_Bool LwpFieldMark::IsFormulaInsert()
+{
+	if (m_nFlag & FF_FORMULAINSERTED)
+		return sal_True;
+	return sal_False;
+}
+
+sal_Bool LwpFieldMark::IsDateTimeField(sal_uInt8& type,OUString& formula)
+{
+	OUString sFormula = m_Formula.str();
+	sal_Int32 index;
+	sal_Unicode ch1(0x0020);//space	
+	OUString tag;
+	
+	index = sFormula.indexOf(ch1,0);
+	if (index < 0)
+	{
+		if (sFormula == A2OUSTR("TotalEditingTime"))
+		{
+			type = DATETIME_TOTALTIME;
+			return sal_True;
+		}
+		return sal_False;
+	}
+	
+	tag = sFormula.copy(0,index);
+	if (tag == A2OUSTR("Now()"))
+	{
+		type = DATETIME_NOW;
+		formula = sFormula.copy(index+1,sFormula.getLength()-index-1);
+		return sal_True;
+	}
+	else if (tag == A2OUSTR("CreateDate"))
+	{
+		type = DATETIME_CREATE;
+		formula = sFormula.copy(index+1,sFormula.getLength()-index-1);
+		return sal_True;
+	}
+	else if (tag == A2OUSTR("EditDate"))
+	{
+		type = DATETIME_LASTEDIT;
+		formula = sFormula.copy(index+1,sFormula.getLength()-index-1);
+		return sal_True;
+	}
+	else if (tag == A2OUSTR("YesterdaysDate") || tag == A2OUSTR("TomorrowsDate") 
+			|| tag == A2OUSTR("TodaysDate"))
+	{
+		type = DATETIME_SKIP;
+		return sal_True;
+	}	
+	else
+		return sal_False;
+}
+
+sal_Bool LwpFieldMark::IsCrossRefField(sal_uInt8& nType, OUString& sMarkName)
+{
+	OUString sFormula = m_Formula.str();
+	sal_Int32 index;
+	sal_Unicode ch1(0x0020);//space	
+	OUString tag;
+	
+	index = sFormula.indexOf(ch1,0);
+	if (index < 0)
+	{
+		LwpGlobalMgr* pGlobal = LwpGlobalMgr::GetInstance(); 
+		LwpBookmarkMgr* pMarkMgr = pGlobal->GetLwpBookmarkMgr();
+		if (pMarkMgr->FindBookmark(sFormula))
+		{
+			sMarkName = sFormula;
+			nType = CROSSREF_TEXT;
+			return sal_True;
+		}
+		else
+			return sal_False;
+	}
+	
+	tag = sFormula.copy(0,index);
+	if (tag == A2OUSTR("PageRef"))
+	{
+		sMarkName = sFormula.copy(index+1,sFormula.getLength()-index-1);
+		nType = CROSSREF_PAGE;
+		return sal_True;
+	}
+	else if (tag == A2OUSTR("ParaRef"))
+	{
+		sMarkName = sFormula.copy(index+1,sFormula.getLength()-index-1);
+		nType = CROSSREF_PARANUMBER;
+		return sal_True;
+	}
+	else
+		return sal_False;
+}
+
+sal_Bool LwpFieldMark::IsDocPowerField(sal_uInt8& nType,OUString& sFormula)
+{
+	sFormula = m_Formula.str();
+
+	if (sFormula == A2OUSTR("Description"))
+	{
+		nType = DOC_DESCRIPTION;
+		return sal_True;
+	}
+	else if (sFormula == A2OUSTR("NumPages"))
+	{
+		nType = DOC_NUMPAGES;
+		return sal_True;
+	}
+	else if (sFormula == A2OUSTR("NumChars"))
+	{
+		nType = DOC_NUMCHARS;
+		return sal_True;
+	}
+	else if (sFormula == A2OUSTR("NumWords"))
+	{
+		nType = DOC_NUMWORDS;
+		return sal_True;
+	}
+	else
+	{	
+		return sal_False;	
+	}	
+}
+
+LwpRubyMarker::LwpRubyMarker(LwpObjectHeader &objHdr, LwpSvStream *pStrm):LwpStoryMarker(objHdr,pStrm)
+{	
+}
+
+void LwpRubyMarker::Read()
+{
+	LwpStoryMarker::Read();
+	m_objLayout.ReadIndexed(m_pObjStrm);
+	m_pObjStrm->SkipExtra();		
+}
+
diff -urNp lotuswordpro.bak/source/filter/lwpmarker.hxx lotuswordpro/source/filter/lwpmarker.hxx
--- lotuswordpro.bak/source/filter/lwpmarker.hxx	1970-01-01 08:00:00.000000000 +0800
+++ lotuswordpro/source/filter/lwpmarker.hxx	2008-10-22 11:42:29.000000000 +0800
@@ -0,0 +1,281 @@
+/*************************************************************************
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: IBM Corporation
+ *
+ *  Copyright: 2008 by IBM Corporation
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+/*************************************************************************
+ * @file 
+ *  For LWP filter architecture prototype
+ ************************************************************************/
+/*************************************************************************
+ * Change History
+ Mar 2005			Created
+ ************************************************************************/
+ 
+
+#ifndef _LWPMARKER_HXX_
+#define _LWPMARKER_HXX_
+
+#include "lwpobj.hxx"
+#include "lwpobjid.hxx"
+#include "lwpdlvlist.hxx"
+#include "lwpfrib.hxx"
+#include "xfilter/xftextspan.hxx"
+
+class LwpMarker : public LwpDLNFPVList
+{
+public:
+	LwpMarker(LwpObjectHeader &objHdr, LwpSvStream *pStrm);
+	~LwpMarker(){};
+	void Read();
+	OUString GetNamedProperty(OUString name);
+protected:	
+	enum{
+		MARKER_START=1,
+		MARKER_END=2
+	};
+private:	
+	sal_uInt16 m_nFlag;
+	sal_uInt16 m_nPageNumber;
+	sal_uInt16 m_nNeedUpdate;
+	LwpObjectID m_objLayout;
+	LwpObjectID m_objMarkerList;
+	LwpObjectID m_objContent;
+	
+};
+
+class LwpFribRange
+{
+public:
+	LwpFribRange(){};
+	~LwpFribRange(){};
+	void Read(LwpObjectStream* pObjStrm);
+private:
+	LwpObjectID m_StartPara;
+	LwpObjectID m_EndPara;
+};
+
+class LwpStoryMarker : public LwpMarker
+{
+public:
+	LwpStoryMarker(LwpObjectHeader &objHdr, LwpSvStream *pStrm);
+	~LwpStoryMarker(){};
+	void Read();
+private:
+	LwpFribRange m_Range;
+	sal_uInt16 m_nFlag;
+};
+
+class LwpCHBlkMarker : public LwpStoryMarker
+{
+public:
+	LwpCHBlkMarker(LwpObjectHeader &objHdr, LwpSvStream *pStrm);
+	~LwpCHBlkMarker(){};
+	void Read();
+	sal_uInt16 GetAction(){return m_nAction;}
+	void ConvertCHBlock(XFContentContainer* pXFPara,sal_uInt8 nType);
+	enum{
+		CLICKHERE_CHBEHAVIORTEXT=1,
+		CLICKHERE_CHBEHAVIORTABLE=2,
+		CLICKHERE_CHBEHAVIORPICTURE=3,
+		CLICKHERE_CHBEHAVIOROLEOBJECT=4,
+		CLICKHERE_CHBEHAVIORCHART=5,
+		CLICKHERE_CHBEHAVIORDRAWING=6,
+		CLICKHERE_CHBEHAVIORFILE=7,
+		CLICKHERE_CHBEHAVIORGLOSSARY=8,
+		CLICKHERE_CHBEHAVIOREQUATION=9,
+		CLICKHERE_CHBEHAVIORINTERNETLINK=10,
+		CLICKHERE_CHBEHAVIORSTRINGLIST=11,
+		CLICKHERE_CHBEHAVIORDATETIME=12,
+		CLICKHERE_CHBEHAVIORSYMBOL=13,
+		CLICKHERE_CHBEHAVIORDOCFIELD=14,
+		CLICKHERE_CHBEHAVIORPAGENUM=15
+	};
+private:
+	void ProcessPlaceHolder(XFContentContainer* pXFPara,sal_uInt16 nAction,sal_uInt8 nType);
+	void ProcessOtherCHB(XFContentContainer* pXFPara,sal_uInt8 nType);
+	void ProcessPageNumber(XFContentContainer* pXFPara,sal_uInt8 nType);
+	void ProcessKeylist(XFContentContainer* pXFPara,sal_uInt8 nType);
+	sal_Bool IsHasFilled();
+	sal_Bool IsBubbleHelp();
+	OUString GetPromptText();
+	void EnumAllKeywords();
+private:	
+	enum{
+		CHB_PROMPT = 0x01,
+		CHB_EDIT = 0x02,
+		CHB_HELP = 0x04,
+		CHB_TAB = 0x08,
+		CHB_HIDDEN = 0x10,
+		CHB_ALLOWVALUESNOTINLIST = 0x20,
+		CHB_ALLOWMULTIVALUES = 0x40,
+		CHB_RETURN = 0x80,
+		CHB_NOEARS = 0x100,
+		CHB_MAGNETIC = 0x200,
+		CHB_PERSISTENT = (CHB_PROMPT+CHB_HELP+CHB_TAB+CHB_HIDDEN
+			+CHB_ALLOWVALUESNOTINLIST+CHB_ALLOWMULTIVALUES
+			+CHB_RETURN+CHB_NOEARS+CHB_MAGNETIC)
+	};
+	LwpObjectID m_objPromptStory;
+	sal_uInt32 m_nTab;
+	sal_uInt16 m_nFlag;
+	sal_uInt16 m_nAction;	
+	LwpAtomHolder m_Help;
+	LwpAtomHolder m_Mirror;	
+	std::vector<OUString> m_Keylist;
+};
+
+class LwpBookMark : public LwpDLNFVList
+{
+public:
+	LwpBookMark(LwpObjectHeader &objHdr, LwpSvStream *pStrm);
+	~LwpBookMark(){};
+protected:
+	void Read();
+public:
+	sal_Bool IsRightMarker(LwpObjectID objMarker);
+	OUString GetName();
+	sal_Bool IsRightName(OUString sName);
+private:
+	enum {	BKMK_NOTESFX = 0x0001,
+		BKMK_OLDNOTESFX = 0x0002
+		};
+	LwpObjectID m_objMarker;
+	sal_Bool m_bHint;
+	sal_uInt16 m_nFlag;
+};
+
+class LwpFieldMark : public LwpStoryMarker
+{
+public:
+	LwpFieldMark(LwpObjectHeader &objHdr, LwpSvStream *pStrm);
+	~LwpFieldMark(){};
+	void Read();
+	void ParseIndex(OUString& sKey1,OUString& sKey2);
+	void ParseTOC(OUString& sLevel,OUString& sText);
+//	sal_uInt8 ParseCrossRef(OUString& sMarkName);
+	sal_uInt16 GetFieldType(){return m_nFieldType;}
+	sal_Bool IsFormulaInsert();
+	sal_Bool IsDateTimeField(sal_uInt8& type,OUString& formula);
+	sal_Bool IsCrossRefField(sal_uInt8& nType, OUString& sMarkName);
+	sal_Bool IsDocPowerField(sal_uInt8& nType,OUString& sFormula);
+	OUString GetFormula(){return m_Formula.str();}
+	void SetStyleFlag(sal_Bool bFalg){m_bHasStyle = bFalg;}
+	sal_Bool GetStyleFlag(){return m_bHasStyle;}
+	sal_Bool GetStart(){return m_bHasStart;}
+	void SetStart(sal_Bool bFlag){m_bHasStart = bFlag;}
+	LwpFrib* GetStartFrib(){return m_pFrib;}
+	void SetStartFrib(LwpFrib* pFrib){m_pFrib = pFrib;}
+	sal_Bool GetRevisionFlag(){return m_bRevisionFlag;}
+	void SetRevisionFlag(sal_Bool bFlag){m_bRevisionFlag = bFlag;}
+	
+	enum{
+		FLD_FIELD = 0x0003,
+		FLD_INDEX = 0x0008,
+		FLD_TOC = 0x000B
+	};
+	enum{
+		FF_FORMULAINSERTED = 0X0008,
+	};
+	enum{
+		CROSSREF_INVALID = 0,
+		CROSSREF_TEXT = 1,
+		CROSSREF_PAGE = 2,
+		CROSSREF_PARANUMBER = 3
+	};
+	enum{
+		DATETIME_SKIP = 0,
+		DATETIME_NOW = 1,
+		DATETIME_CREATE = 2,
+		DATETIME_LASTEDIT = 3,
+		DATETIME_TOTALTIME = 4
+	};
+	enum{
+		DOC_DESCRIPTION = 1,
+		DOC_NUMPAGES = 2,
+		DOC_NUMWORDS = 3,
+		DOC_NUMCHARS = 4,
+	};
+private:
+	LwpObjectID m_objFormulaStory;
+	LwpObjectID m_objResultContent;
+	sal_uInt8* m_nExtra;
+	sal_uInt16 m_nFlag;
+	sal_uInt16 m_nFieldType;	
+	LwpAtomHolder m_Formula;	
+		
+	sal_Bool m_bHasStyle;
+	sal_Bool m_bHasStart;
+	
+	LwpFrib* m_pFrib;
+	sal_Bool m_bRevisionFlag;					
+};
+
+class LwpRubyMarker : public LwpStoryMarker
+{
+public:
+	LwpRubyMarker(LwpObjectHeader &objHdr, LwpSvStream *pStrm);
+	~LwpRubyMarker(){};
+	void Read();
+	OUString GetRubyText(){return m_strRubyText;}
+	void SetRubyText(OUString sText){m_strRubyText = sText;}
+	OUString GetTextStyleName(){return m_TextStye;}
+	void SetTextStyleName(OUString sName){m_TextStye = sName;}
+	OUString GetRubyStyleName(){return m_RubyStyle;}
+	void SetRubyStyleName(OUString sName){m_RubyStyle = sName;}	
+private:
+	LwpObjectID m_objLayout;	
+	OUString m_strRubyText;
+	OUString m_RubyStyle;
+	OUString m_TextStye;
+};
+#endif
diff -urNp lotuswordpro.bak/source/filter/lwpnotes.cxx lotuswordpro/source/filter/lwpnotes.cxx
--- lotuswordpro.bak/source/filter/lwpnotes.cxx	1970-01-01 08:00:00.000000000 +0800
+++ lotuswordpro/source/filter/lwpnotes.cxx	2008-10-22 11:42:29.000000000 +0800
@@ -0,0 +1,329 @@
+/*************************************************************************
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: IBM Corporation
+ *
+ *  Copyright: 2008 by IBM Corporation
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+/**
+ * @file 
+ *  For LWP filter architecture prototype - notes
+ */
+/*************************************************************************
+ * Change History
+ May 2005		Created
+ ************************************************************************/
+#include "lwpnotes.hxx"
+#include "lwppara.hxx"
+#include "xfilter/xfannotation.hxx"
+#include "xfilter/xftextspan.hxx"
+#include "localtime.hxx"
+#include "lwptools.hxx"
+
+ LwpFribNote::LwpFribNote(LwpPara* pPara ):LwpFrib(pPara)
+{
+}
+
+/**
+ * @descr  read  frib information
+ */
+void LwpFribNote::Read(LwpObjectStream *pObjStrm, sal_uInt16 len)
+{
+	m_Layout.ReadIndexed(pObjStrm);
+}
+
+/**
+ * @descr  Register style
+ */
+void LwpFribNote::RegisterStyle()
+{	
+	LwpObject* pLayout = m_Layout.obj();
+	if(pLayout)
+	{
+		//register font style
+		LwpFrib::RegisterStyle(m_pPara->GetFoundry());
+		//register foonote style
+		pLayout->SetFoundry(m_pPara->GetFoundry());
+		pLayout->RegisterStyle();
+	}
+}
+
+/**
+ * @descr  convert note
+ */
+void LwpFribNote::XFConvert(XFContentContainer* pCont)
+{
+	LwpNoteLayout* pLayout =static_cast<LwpNoteLayout*>(m_Layout.obj());	
+	if(pLayout)
+	{		
+		XFAnnotation* pXFNote = new XFAnnotation;
+		pXFNote->SetAuthor(pLayout->GetAuthor());		
+		LtTm aTm;
+		long nTime = pLayout->GetTime();
+		if(LtgLocalTime(nTime, aTm))
+		{
+			pXFNote->SetDate(LwpTools::DateTimeToOUString(aTm));
+		}
+		
+		pLayout->XFConvert(pXFNote);
+		if(m_pModifiers)
+		{
+			XFTextSpan *pSpan = new XFTextSpan();
+			pSpan->SetStyleName(GetStyleName());			
+			pSpan->Add(pXFNote);
+			pCont->Add(pSpan); 
+		}
+		else
+		{
+			pCont->Add(pXFNote);
+		}
+	}	
+	
+}
+
+
+LwpNoteLayout::LwpNoteLayout(LwpObjectHeader &objHdr, LwpSvStream* pStrm)
+	: LwpFrameLayout(objHdr, pStrm)
+{
+	
+}
+
+LwpNoteLayout::~LwpNoteLayout()
+{
+	
+}
+
+/**
+ * @descr read note layout object
+ * 		
+ */
+void LwpNoteLayout::Read()
+{
+	LwpFrameLayout::Read();
+
+	m_pObjStrm->QuickRead(&m_nTime, sizeof(m_nTime));
+	m_UserName.Read(m_pObjStrm);
+
+	LwpAtomHolder aUserInitials;
+	aUserInitials.Read(m_pObjStrm);
+
+	LwpColor aColor;
+	aColor.Read(m_pObjStrm);
+
+	// vacant note sequence
+	m_pObjStrm->QuickReadInt32();
+	
+	m_pObjStrm->SkipExtra();
+}
+
+/**
+ * @descr  Register style
+ */
+void LwpNoteLayout::RegisterStyle()
+{
+	LwpVirtualLayout* pTextLayout = GetTextLayout();
+	if(pTextLayout)
+	{
+		pTextLayout->SetFoundry(GetFoundry());
+		pTextLayout->RegisterStyle();
+	}
+}
+
+/**
+ * @descr  convert note
+ */
+void LwpNoteLayout::XFConvert(XFContentContainer * pCont)
+{
+	LwpVirtualLayout* pTextLayout = GetTextLayout();
+	if(pTextLayout)
+	{		
+		pTextLayout->XFConvert(pCont);			
+	}
+}
+
+/**
+ * @descr  Get layout that contains note text.
+ */
+LwpVirtualLayout* LwpNoteLayout::GetTextLayout()
+{
+	LwpVirtualLayout* pLayout = FindChildByType(LWP_VIEWPORT_LAYOUT);
+	if(pLayout)
+	{
+		return pLayout->FindChildByType(LWP_NOTETEXT_LAYOUT);
+	}
+
+	return NULL;
+}
+/**
+ * @descr  Get author.
+ */
+OUString LwpNoteLayout::GetAuthor()
+{
+	if(m_UserName.HasValue())
+	{
+		if(m_UserName.str() != A2OUSTR(" "))
+		{
+			return m_UserName.str();
+		}		
+	}
+	//if username is null or writerspace, get username from noteheaderlayout
+	LwpNoteHeaderLayout* pTextLayout = static_cast<LwpNoteHeaderLayout*>(FindChildByType(LWP_NOTEHEADER_LAYOUT));
+	if(pTextLayout)
+	{
+		LwpStory* pStory = static_cast<LwpStory*>(pTextLayout->GetContent()->obj());
+		if(pStory)
+		{
+			LwpPara* pFirst = static_cast<LwpPara*>(pStory->GetFirstPara()->obj());
+			if(pFirst)
+				return pFirst->GetContentText(sal_True);
+		}
+	}	
+	
+	return m_UserName.str();
+}
+
+LwpNoteHeaderLayout::LwpNoteHeaderLayout(LwpObjectHeader &objHdr, LwpSvStream* pStrm)
+	: LwpFrameLayout(objHdr, pStrm)
+{	
+}
+
+LwpNoteHeaderLayout::~LwpNoteHeaderLayout()
+{	
+}
+
+/**
+ * @descr read note layout object
+ * 		
+ */
+void LwpNoteHeaderLayout::Read()
+{
+	LwpFrameLayout::Read();	
+	m_pObjStrm->SkipExtra();
+}
+
+void LwpNoteHeaderLayout::RegisterStyle()
+{
+}
+
+void LwpNoteHeaderLayout::XFConvert(XFContentContainer * pCont)
+{
+}
+
+LwpNoteTextLayout::LwpNoteTextLayout(LwpObjectHeader &objHdr, LwpSvStream* pStrm)
+	: LwpFrameLayout(objHdr, pStrm)
+{	
+}
+
+LwpNoteTextLayout::~LwpNoteTextLayout()
+{	
+}
+
+/**
+ * @descr read note layout object
+ * 		
+ */
+void LwpNoteTextLayout::Read()
+{
+	LwpFrameLayout::Read();	
+	m_pObjStrm->SkipExtra();
+}
+
+/**
+ * @descr  Register style, SODC doesn't support text style in note
+ */
+void LwpNoteTextLayout::RegisterStyle()
+{
+	LwpObject* pContent = m_Content.obj();
+	if(pContent)
+	{
+		pContent->SetFoundry(GetFoundry());
+		pContent->RegisterStyle();
+	}
+}
+
+void LwpNoteTextLayout::XFConvert(XFContentContainer * pCont)
+{
+	LwpObject* pContent = m_Content.obj();
+	if(pContent)
+	{
+		pContent->XFConvert(pCont);
+	}
+}
+
+
+LwpViewportLayout::LwpViewportLayout(LwpObjectHeader &objHdr, LwpSvStream* pStrm)
+	: LwpPlacableLayout(objHdr, pStrm)
+{	
+}
+
+LwpViewportLayout::~LwpViewportLayout()
+{	
+}
+
+/**
+ * @descr read note layout object
+ * 		
+ */
+void LwpViewportLayout::Read()
+{
+	LwpPlacableLayout::Read();	
+	m_pObjStrm->SkipExtra();
+}
+
+void LwpViewportLayout::RegisterStyle()
+{
+}
+
+void LwpViewportLayout::XFConvert(XFContentContainer * pCont)
+{
+}
+
+
+
diff -urNp lotuswordpro.bak/source/filter/lwpnotes.hxx lotuswordpro/source/filter/lwpnotes.hxx
--- lotuswordpro.bak/source/filter/lwpnotes.hxx	1970-01-01 08:00:00.000000000 +0800
+++ lotuswordpro/source/filter/lwpnotes.hxx	2008-10-22 11:42:29.000000000 +0800
@@ -0,0 +1,161 @@
+/*************************************************************************
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: IBM Corporation
+ *
+ *  Copyright: 2008 by IBM Corporation
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+/**
+ * @file 
+ *  For LWP filter architecture prototype - notes
+ */
+/*************************************************************************
+ * Change History
+ May 2005		Created
+ ************************************************************************/
+#ifndef _LWPNOTES_HXX_
+#define _LWPNOTES_HXX_
+
+#include "lwpfrib.hxx"
+#include "lwpframelayout.hxx"
+
+/**
+ * @brief		TAG_NOTE_FRIB object 
+ * 
+ */
+class LwpFribNote: public LwpFrib
+{
+public:
+	LwpFribNote(LwpPara* pPara );
+	~LwpFribNote(){};
+	void Read(LwpObjectStream* pObjStrm, sal_uInt16 len);
+	void RegisterStyle();
+	void XFConvert(XFContentContainer* pCont);
+private:	
+	LwpObjectID m_Layout;
+};
+
+/**
+ * @brief		VO_NOTELAYOUT object 
+ * 
+ */
+class LwpNoteLayout: public LwpFrameLayout
+{
+public:
+	LwpNoteLayout(LwpObjectHeader &objHdr, LwpSvStream* pStrm);
+	virtual ~LwpNoteLayout();
+	virtual LWP_LAYOUT_TYPE GetLayoutType () { return LWP_NOTE_LAYOUT;}	
+	virtual void RegisterStyle();	
+	virtual void XFConvert(XFContentContainer* pCont);
+	sal_uInt32 GetTime(){ return m_nTime;};
+	OUString GetAuthor();
+
+protected:
+	void Read();
+	LwpVirtualLayout* GetTextLayout();
+
+private:
+	sal_uInt32 m_nTime;
+	LwpAtomHolder m_UserName;	
+};
+
+
+/**
+ * @brief		VO_NOTEHEADERLAYOUT object 
+ * 
+ */
+class LwpNoteHeaderLayout: public LwpFrameLayout
+{
+public:
+	LwpNoteHeaderLayout(LwpObjectHeader &objHdr, LwpSvStream* pStrm);
+	virtual ~LwpNoteHeaderLayout();
+	virtual LWP_LAYOUT_TYPE GetLayoutType () { return LWP_NOTEHEADER_LAYOUT;}	
+	virtual void RegisterStyle();	
+	virtual void XFConvert(XFContentContainer* pCont);	
+
+protected:
+	void Read();	
+};
+
+/**
+ * @brief		VO_NOTETEXTLAYOUT object 
+ * 
+ */
+class LwpNoteTextLayout: public LwpFrameLayout
+{
+public:
+	LwpNoteTextLayout(LwpObjectHeader &objHdr, LwpSvStream* pStrm);
+	virtual ~LwpNoteTextLayout();
+	virtual LWP_LAYOUT_TYPE GetLayoutType () { return LWP_NOTETEXT_LAYOUT;}	
+	virtual void RegisterStyle();	
+	virtual void XFConvert(XFContentContainer* pCont);	
+
+protected:
+	void Read();	
+};
+
+/**
+ * @brief		VO_VPLAYOUT object 
+ * 
+ */
+class LwpViewportLayout: public LwpPlacableLayout
+{
+public:
+	LwpViewportLayout(LwpObjectHeader &objHdr, LwpSvStream* pStrm);
+	virtual ~LwpViewportLayout();
+	virtual LWP_LAYOUT_TYPE GetLayoutType () { return LWP_VIEWPORT_LAYOUT;}	
+	virtual void RegisterStyle();	
+	virtual void XFConvert(XFContentContainer* pCont);	
+
+protected:
+	void Read();	
+};
+
+#endif
\ No newline at end of file
diff -urNp lotuswordpro.bak/source/filter/lwpnumberingoverride.cxx lotuswordpro/source/filter/lwpnumberingoverride.cxx
--- lotuswordpro.bak/source/filter/lwpnumberingoverride.cxx	1970-01-01 08:00:00.000000000 +0800
+++ lotuswordpro/source/filter/lwpnumberingoverride.cxx	2008-10-22 11:42:29.000000000 +0800
@@ -0,0 +1,180 @@
+/*************************************************************************
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: IBM Corporation
+ *
+ *  Copyright: 2008 by IBM Corporation
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+/*************************************************************************
+* @file 
+* Numbering override of Wordpro.
+************************************************************************/
+/*************************************************************************
+* Change History
+* 2005-01-12 Create and implement.
+************************************************************************/
+
+#include	"lwpnumberingoverride.hxx"
+#include	"lwpobjstrm.hxx"
+
+LwpNumberingOverride::LwpNumberingOverride()
+{
+	m_nLevel = 0;
+	m_nPosition = 0;
+}
+
+void	LwpNumberingOverride::Read(LwpObjectStream *pStrm)
+{
+	if (pStrm->QuickReadBool())
+	{
+		ReadCommon(pStrm);
+		
+		pStrm->QuickRead(&m_nLevel, sizeof(m_nLevel));
+		pStrm->QuickRead(&m_nPosition, sizeof(m_nPosition));
+	}
+	
+	pStrm->SkipExtra();
+}
+//add by , 02/03/2005
+void LwpNumberingOverride::Override(LwpNumberingOverride* pOther)
+{
+	if (m_nApply & NO_LEVEL)
+	{
+		if (IsLevelOverridden())
+		{
+			pOther->OverrideLevel(m_nLevel);
+		}
+		else
+		{
+			pOther->RevertLevel();
+		}
+	}
+
+	if (m_nApply & NO_POSITION)
+	{
+		if (IsPositionOverridden())
+		{
+			pOther->OverridePosition(m_nPosition);
+		}
+		else
+		{
+			pOther->RevertPosition();
+		}
+	}
+
+	if (m_nApply & HEADING)
+	{
+		if (IsHeadingOverridden())
+		{
+			pOther->OverrideHeading(IsHeading());
+		}
+		else
+		{
+			pOther->RevertHeading();
+		}
+	}
+
+	if (m_nApply & SMARTLEVEL)
+	{
+		if (IsSmartLevelOverridden())
+		{
+			pOther->OverrideSmartLevel(IsSmartLevel());
+		}
+		else
+		{
+			pOther->RevertSmartLevel();
+		}
+	}
+}
+
+void LwpNumberingOverride::operator=(const LwpOverride& rOther)
+{
+	LwpOverride::operator=(rOther);
+
+	const LwpNumberingOverride* pOther = 
+		static_cast<LwpNumberingOverride*>((LwpOverride*)&rOther);
+
+	m_nLevel = pOther->m_nLevel;
+	m_nPosition = pOther->m_nPosition;
+}
+
+void LwpNumberingOverride::OverrideLevel(sal_uInt16 nNewLv)
+{
+	m_nLevel = nNewLv;
+	LwpOverride::Override(NO_LEVEL, STATE_ON);
+}
+void LwpNumberingOverride::OverridePosition(sal_uInt16 nNewPos)
+{
+	m_nPosition = nNewPos;
+	LwpOverride::Override(NO_POSITION, STATE_ON);
+}
+void LwpNumberingOverride::OverrideHeading(sal_Bool bVal)
+{
+	if (bVal)
+	{
+		LwpOverride::Override(HEADING, STATE_ON);
+	}
+	else
+	{
+		LwpOverride::Override(HEADING, STATE_OFF);
+	}
+}
+void LwpNumberingOverride::OverrideSmartLevel(sal_Bool bVal)
+{
+	if (bVal)
+	{
+		LwpOverride::Override(SMARTLEVEL, STATE_ON);
+	}
+	else
+	{
+		LwpOverride::Override(SMARTLEVEL, STATE_OFF);
+	}
+}
+//end add
diff -urNp lotuswordpro.bak/source/filter/lwpnumberingoverride.hxx lotuswordpro/source/filter/lwpnumberingoverride.hxx
--- lotuswordpro.bak/source/filter/lwpnumberingoverride.hxx	1970-01-01 08:00:00.000000000 +0800
+++ lotuswordpro/source/filter/lwpnumberingoverride.hxx	2008-10-22 11:42:29.000000000 +0800
@@ -0,0 +1,170 @@
+/*************************************************************************
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: IBM Corporation
+ *
+ *  Copyright: 2008 by IBM Corporation
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+/*************************************************************************
+* @file 
+* Numbering override of Wordpro.
+************************************************************************/
+/*************************************************************************
+* Change History
+* 2005-01-12 Create and implement.
+************************************************************************/
+
+#ifndef		_LWPNUMBERINGOVERRIDE_HXX
+#define		_LWPNUMBERINGOVERRIDE_HXX
+
+#include	"lwpoverride.hxx"
+
+class LwpObjectStream;
+class LwpNumberingOverride : public LwpOverride
+{	
+public:
+	LwpNumberingOverride();
+	virtual ~LwpNumberingOverride(){}
+	
+	enum
+	{
+		NO_LEVEL		= 0x0001,
+		NO_POSITION		= 0x0002,
+		HEADING			= 0x0004,
+		SMARTLEVEL		= 0x0008
+	};
+public:
+	virtual void Read(LwpObjectStream *pStrm);
+
+	//add by , 02/03/2005
+	void Override(LwpNumberingOverride* pOther);
+	void operator=(const LwpOverride& rOther);
+
+	inline sal_uInt16 GetLevel() const;
+	inline sal_uInt16 GetPosition() const;
+	
+	inline sal_Bool IsLevelOverridden();
+	inline sal_Bool IsPositionOverridden();
+	inline sal_Bool IsHeadingOverridden();
+	inline sal_Bool IsSmartLevelOverridden();
+	inline sal_Bool IsHeading();
+	inline sal_Bool IsSmartLevel();
+
+	void OverrideLevel(sal_uInt16 nNewLv);
+	void OverridePosition(sal_uInt16 nNewPos);
+	void OverrideHeading(sal_Bool bVal);
+	void OverrideSmartLevel(sal_Bool bVal);
+
+	inline void RevertLevel();
+	inline void RevertPosition();
+	inline void RevertHeading();
+	inline void RevertSmartLevel();
+	//end add
+private:	
+	sal_uInt16	m_nLevel;
+	sal_uInt16	m_nPosition;
+};
+
+inline sal_uInt16 LwpNumberingOverride::GetLevel() const
+{
+	return m_nLevel;
+}
+
+inline sal_uInt16 LwpNumberingOverride::GetPosition() const
+{
+	return m_nPosition;
+}
+	
+//add by , 02/03/2005
+inline sal_Bool LwpNumberingOverride::IsLevelOverridden()
+{
+	return (sal_Bool)((m_nOverride & NO_LEVEL) != 0);
+}
+inline sal_Bool LwpNumberingOverride::IsPositionOverridden()
+{
+	return (sal_Bool)((m_nOverride & NO_POSITION) != 0);
+}
+inline sal_Bool LwpNumberingOverride::IsHeadingOverridden()
+{
+	return (sal_Bool)((m_nOverride & HEADING) != 0);
+}
+inline sal_Bool LwpNumberingOverride::IsSmartLevelOverridden()
+{
+	return (sal_Bool)((m_nOverride & SMARTLEVEL) != 0);
+}
+inline sal_Bool LwpNumberingOverride::IsHeading()
+{
+	return (m_nValues & HEADING) != 0;
+}
+inline sal_Bool LwpNumberingOverride::IsSmartLevel()
+{
+	return (m_nValues & SMARTLEVEL) != 0;
+}
+
+inline void LwpNumberingOverride::RevertLevel()
+{
+	LwpOverride::Override(NO_LEVEL, STATE_STYLE);
+}
+inline void LwpNumberingOverride::RevertPosition()
+{
+	LwpOverride::Override(NO_POSITION, STATE_STYLE);
+}
+inline void LwpNumberingOverride::RevertHeading()
+{
+	LwpOverride::Override(HEADING, STATE_STYLE);
+}
+inline void LwpNumberingOverride::RevertSmartLevel()
+{
+	LwpOverride::Override(SMARTLEVEL, STATE_STYLE);
+}
+
+//end add
+
+#endif
\ No newline at end of file
diff -urNp lotuswordpro.bak/source/filter/lwpnumericfmt.cxx lotuswordpro/source/filter/lwpnumericfmt.cxx
--- lotuswordpro.bak/source/filter/lwpnumericfmt.cxx	1970-01-01 08:00:00.000000000 +0800
+++ lotuswordpro/source/filter/lwpnumericfmt.cxx	2008-10-22 11:42:29.000000000 +0800
@@ -0,0 +1,566 @@
+/*************************************************************************
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: IBM Corporation
+ *
+ *  Copyright: 2008 by IBM Corporation
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+/**
+ * @file 
+ *  For LWP filter architecture prototype - table cell numerics format
+ */
+/*************************************************************************
+ * Change History
+ Mar 2005		 	Created
+ ************************************************************************/
+
+#include "lwpnumericfmt.hxx"
+
+///////////////////////////////////////////////////////////////////
+LwpCurrencyPool  LwpNumericFormat::m_aCurrencyInfo;
+
+/**
+*	
+*	@date	03/26/2005
+*	@param	
+*	@param	
+*	@return
+*/
+String LwpCurrencyPool::GetCurrencySymbol(sal_uInt16 nFormat)
+{
+	return m_aCurrencyInfo[nFormat].sSymbol;
+}
+
+/**
+*	
+*	@date	03/26/2005
+*	@param	
+*	@param	
+*	@return	sal_Bool.
+*/
+sal_Bool LwpCurrencyPool::IsSymbolPost(sal_uInt16 nFormat)
+{
+	return m_aCurrencyInfo[nFormat].bPost;;
+}
+
+/**
+*	
+*	@date	03/26/2005
+*	@param	
+*	@param	
+*	@return	sal_Bool.
+*/
+sal_Bool LwpCurrencyPool::IsShowSpace(sal_uInt16 nFormat)
+{
+	return m_aCurrencyInfo[nFormat].bShowSpace;
+}
+//////////////////////////////////////////////////////////////////////
+/**
+*	
+*	@date	03/26/2005
+*	@param	
+*	@param	
+*	@return
+*/
+XFStyle* LwpLayoutNumerics::Convert()
+{
+	return cNumerics.Convert();
+}
+
+/**
+*	
+*	@date	03/26/2005
+*	@param	
+*	@param	
+*	@return	sal_Bool.
+*/
+void LwpLayoutNumerics::Read()
+{
+	LwpVirtualPiece::Read();
+
+	if(LwpFileHeader::m_nFileRevision >= 0x000b)
+	{
+		cNumerics.Read();
+		m_pObjStrm->SkipExtra();
+	}
+}
+///////////////////////////////////////////////////////////////////
+
+/**
+*	
+*	@date	03/26/2005
+*	@param	
+*	@param	
+*	@return	sal_Bool.
+*/
+void LwpNumericFormatSubset::QuickRead(LwpObjectStream* pStrm)
+{
+	cColor.Read(pStrm);
+	cPrefix.Read(pStrm);
+	cSuffix.Read(pStrm);
+	cSubFlags = pStrm->QuickReaduInt16();
+
+	pStrm->SkipExtra();
+}
+/**
+*	
+*	@date	03/26/2005
+*	@param	
+*	@param	
+*	@return.
+*/
+LwpColor LwpNumericFormatSubset::GetColor()
+{
+	if (cSubFlags&0x04)
+	{
+		return cColor;
+	}
+	else
+	{
+		return LwpColor();
+	}
+}
+LwpNumericFormatSubset::LwpNumericFormatSubset():cSubFlags(0)
+{
+}
+LwpNumericFormatSubset::~LwpNumericFormatSubset()
+{
+}
+
+///////////////////////////////////////////////////////////////////////////////////
+LwpNumericFormat::LwpNumericFormat(LwpObjectStream * pStrm):cDecimalPlaces(0),cFormat(FMT_DEFAULT)
+{
+	assert(pStrm); 
+	m_pObjStrm = pStrm;
+}
+/**
+*	Read number format from wordpro file
+*	@date	03/26/2005
+*	@param	
+*	@param	
+*	@return
+*/
+void LwpNumericFormat::Read()
+{
+	LwpObjectStream* pStrm = m_pObjStrm;
+
+	if(LwpFileHeader::m_nFileRevision >= 0x000b)
+	{
+		cFlags			= pStrm->QuickReaduInt16();
+		cDecimalPlaces 	= pStrm->QuickReaduInt16();
+		cFormat 			= pStrm->QuickReaduInt16();
+
+		cAnyNumber.QuickRead(pStrm);
+		cZero.QuickRead(pStrm);
+		cNegative.QuickRead(pStrm);
+
+		pStrm->SkipExtra();
+	}
+}
+/**
+*	
+*	@date	03/26/2005
+*	@param	
+*	@param	
+*	@return	sal_Bool.
+*/
+sal_Bool
+LwpNumericFormat::IsCurrencyFormat(USHORT Format)
+{
+	switch (Format)
+	{
+	case FMT_ARGENTINEANPESO:
+	case FMT_AUSTRALIANDOLLAR:
+	case FMT_AUSTRIANSCHILLING:
+	case FMT_BELGIANFRANC:
+	case FMT_BRAZILIANCRUZEIRO:
+	case FMT_BRITISHPOUND:
+	case FMT_CANADIANDOLLAR:
+	case FMT_CHINESEYUAN:
+	case FMT_CZECHKORUNA:
+	case FMT_DANISHKRONE:
+	case FMT_ECU:
+	case FMT_FINNISHMARKKA:
+	case FMT_FRENCHFRANC:
+	case FMT_GREEKDRACHMA:
+	case FMT_HONGKONGDOLLAR:
+	case FMT_HUNGARIANFORINT:
+	case FMT_INDIANRUPEE:
+	case FMT_INDONESIANRUPIAH:
+	case FMT_IRISHPUNT:
+	case FMT_LUXEMBOURGFRANC:
+	case FMT_MALAYSIANRINGGIT:
+	case FMT_MEXICANPESO:
+	case FMT_NETHERLANDSGUILDER:
+	case FMT_NEWZEALANDDOLLAR:
+	case FMT_NORWEGIANKRONE:
+	case FMT_POLISHZLOTY:
+	case FMT_PORTUGUESEESCUDO:
+	case FMT_ROMANIANLEI:
+	case FMT_RUSSIANRUBLE:
+	case FMT_SINGAPOREDOLLAR:
+	case FMT_SLOVAKIANKORUNA:
+	case FMT_SLOVENIANTHOLAR:
+	case FMT_SOUTHAFRICANRAND:
+	case FMT_SOUTHKOREANWON:
+	case FMT_SWEDISHKRONA:
+	case FMT_SWISSFRANC:
+	case FMT_TAIWANDOLLAR:
+	case FMT_THAIBAHT:
+	case FMT_USDOLLAR:
+	case FMT_OTHERCURRENCY:
+	case FMT_GERMANMARK:
+	case FMT_ITALIANLIRA:
+	case FMT_JAPANESEYEN:
+	case FMT_SPANISHPESETA:
+	case FMT_EURO:
+		return sal_True;
+
+	default:
+		return sal_False;
+	}
+}
+/**
+*	
+*	@date	03/26/2005
+*	@param	
+*	@param	
+*	@return.
+*/
+USHORT
+LwpNumericFormat::GetDecimalPlaces(void)
+{
+	if (IsDecimalPlacesOverridden())
+		return cDecimalPlaces;
+	return GetDefaultDecimalPlaces(cFormat);
+}
+/**
+*	Make the currency string.
+*	@date	03/26/2005
+*	@param	
+*	@param	
+*	@return
+*/
+void LwpNumericFormat::GetCurrencyStr(LwpNumericFormatSubset aNumber, String& aPrefix, String& aSuffix, sal_Bool bNegtive)
+{
+	aPrefix = aNumber.GetPrefix();
+	aSuffix = aNumber.GetSuffix(); 
+
+	//Make the default prefix and suffix
+	String aSymbol = m_aCurrencyInfo.GetCurrencySymbol(cFormat);
+	sal_Bool bPost = m_aCurrencyInfo.IsSymbolPost(cFormat);
+	sal_Bool bShowSpace = m_aCurrencyInfo.IsShowSpace(cFormat);
+	if ( aNumber.IsDefaultPrefix())
+	{
+		if (bNegtive)
+		{
+			aPrefix = String::CreateFromAscii("(");
+		}
+		if (!bPost)
+		{
+			aPrefix += aSymbol;
+			if (bShowSpace)
+			{
+				aPrefix +=String::CreateFromAscii(" ");
+			}
+		}
+	}
+	if ( aNumber.IsDefaultSuffix())
+	{
+		if (bPost)
+		{
+			aSuffix = aSymbol;
+			if (bShowSpace)
+			{
+				aSuffix.Insert(String::CreateFromAscii(" "),0);
+			}
+
+		}
+
+		if (bNegtive)
+		{
+			aSuffix += String::CreateFromAscii(")");
+		}
+	}
+}
+/**
+*	
+*	@date	03/26/2005
+*	@param	
+*	@param	
+*	@return	
+*/
+void LwpNumericFormat::SetNumberType(XFNumberStyle* pStyle)
+{
+	switch(cFormat)
+	{
+	case FMT_PERCENT:
+		{
+			pStyle->SetNumberType(enumXFNumberPercent);
+		}
+		break;
+	
+	case FMT_COMMA:
+		{
+			pStyle->SetNumberType(enumXFNumberNumber);
+			pStyle->SetGroup();
+		}
+		break;
+	case FMT_SCIENTIFIC:
+		{
+			pStyle->SetNumberType(enumXFNumberScientific);
+		}
+		break;
+	case FMT_FIXED:
+	case FMT_GENERAL:
+		{
+			pStyle->SetNumberType(enumXFNumberNumber);
+		}
+		break;
+	default://including text type, which is not a style of number format in SODC
+		{
+			pStyle->SetNumberType(enumXFText);
+		}
+		break;
+	}	
+}
+/**
+*	Make the xml content of number format
+*	@date	03/26/2005
+*	@param	
+*	@param	
+*	@return	XFStyle*
+*/
+XFStyle* LwpNumericFormat::Convert()
+{
+	XFNumberStyle* pStyle = new XFNumberStyle;
+	String aPrefix, aSuffix,aNegPrefix,aNegSuffix;
+	LwpColor aColor, aNegativeColor;
+	
+	if (IsCurrencyFormat(cFormat))
+	{
+		pStyle->SetNumberType(enuMXFNumberCurrency);
+		pStyle->SetGroup();
+		GetCurrencyStr(cAnyNumber, aPrefix, aSuffix);
+		GetCurrencyStr(cNegative, aNegPrefix, aNegSuffix,sal_True);
+	}
+	else
+	{
+		SetNumberType(pStyle);
+		{//Anynumber
+			aPrefix 	= cAnyNumber.GetPrefix();				
+			//Set suffix
+			aSuffix 	= cAnyNumber.GetSuffix();
+			//Set color
+			aColor 	= cAnyNumber.GetColor();
+		}
+		
+		if (!IsNegativeOverridden())
+		{
+			aNegPrefix 		= aPrefix;
+			aNegSuffix 		= aSuffix;
+			aNegativeColor 	= aColor;
+		}
+		else
+		{//negative
+			aNegPrefix 		= cNegative.GetPrefix();
+			aNegSuffix 		= cNegative.GetSuffix();
+			aNegativeColor 	= cNegative.GetColor();
+		}
+		if (FMT_COMMA==cFormat)
+		{
+			if (cNegative.IsDefaultPrefix() && aNegPrefix.Len() == 0)
+			{
+				aNegPrefix = String::CreateFromAscii("(");
+			}
+			if (cNegative.IsDefaultSuffix() && aNegSuffix.Len() == 0)
+			{
+				aNegSuffix = String::CreateFromAscii(")");
+			}
+		}
+		
+	}
+
+	pStyle->SetDecimalDigits(GetDecimalPlaces());
+	
+	aPrefix = reencode(aPrefix);
+	aSuffix = reencode(aSuffix);
+	aNegPrefix = reencode(aNegPrefix);
+	aNegSuffix = reencode(aNegSuffix);
+	
+	{//Anynumber
+		//Set prefix
+		pStyle->SetPrefix(aPrefix);
+		//Set suffix
+		pStyle->SetSurfix(aSuffix);
+		pStyle->SetColor( XFColor( (sal_uInt8)aColor.GetRed(),
+								   (sal_uInt8)aColor.GetGreen(),
+								   (sal_uInt8)aColor.GetBlue()) );
+	}
+	{//Negtive
+		pStyle->SetNegativeStyle( aNegPrefix, aNegSuffix, XFColor((sal_uInt8)aNegativeColor.GetRed(),
+																	(sal_uInt8)aNegativeColor.GetGreen(),
+																	(sal_uInt8)aNegativeColor.GetBlue()) );
+	}
+	
+	return pStyle;
+}
+/**
+*	
+*	@descrption for SODC_2754
+*	@date	04/04/2006
+*	@param	
+*	@param	
+*	@return	fix wrong encoding of POUND symbol
+*/
+OUString	LwpNumericFormat::reencode(OUString sCode)
+{
+	const sal_Unicode * pString = sCode.getStr();
+	sal_uInt16 nLen = sCode.getLength();
+	sal_Bool bFound = sal_False;
+	sal_uInt16 i;
+	sal_Unicode *pBuff = new sal_Unicode[sCode.getLength()];
+
+	for (i=0; i< sCode.getLength() - 1; i++)
+	{
+		if ( (pString[i] == 0x00a1) && (pString[i+1] == 0x00ea))
+		{
+			bFound = sal_True;
+			break;
+		}
+		pBuff[i] = pString[i];
+	}
+	if (bFound)
+	{
+		pBuff[i] = 0xffe1; 
+		for (sal_uInt32 j=i+1; j < sCode.getLength() - 1; j++)
+		{
+			pBuff[j] = pString[j+1];
+		}
+		OUString sRet(pBuff, nLen - 1);
+		delete [] pBuff;
+		return sRet;
+	}
+
+	delete [] pBuff;
+	return sCode;
+}
+
+/**
+*	
+*	@date	03/26/2005
+*	@param	
+*	@param	
+*	@return	
+*/
+USHORT
+LwpNumericFormat::GetDefaultDecimalPlaces(USHORT Format)
+{
+	switch (Format)
+	{
+	case FMT_ARGENTINEANPESO:
+	case FMT_AUSTRALIANDOLLAR:
+	case FMT_AUSTRIANSCHILLING:
+	case FMT_BELGIANFRANC:
+	case FMT_BRAZILIANCRUZEIRO:
+	case FMT_BRITISHPOUND:
+	case FMT_CANADIANDOLLAR:
+	case FMT_CHINESEYUAN:
+	case FMT_CZECHKORUNA:
+	case FMT_DANISHKRONE:
+	case FMT_ECU:
+	case FMT_FINNISHMARKKA:
+	case FMT_FRENCHFRANC:
+	case FMT_GERMANMARK:
+	case FMT_HONGKONGDOLLAR:
+	case FMT_HUNGARIANFORINT:
+	case FMT_INDIANRUPEE:
+	case FMT_INDONESIANRUPIAH:
+	case FMT_IRISHPUNT:
+	case FMT_LUXEMBOURGFRANC:
+	case FMT_MALAYSIANRINGGIT:
+	case FMT_MEXICANPESO:
+	case FMT_NETHERLANDSGUILDER:
+	case FMT_NEWZEALANDDOLLAR:
+	case FMT_NORWEGIANKRONE:
+	case FMT_POLISHZLOTY:
+	case FMT_PORTUGUESEESCUDO:
+	case FMT_ROMANIANLEI:
+	case FMT_RUSSIANRUBLE:
+	case FMT_SINGAPOREDOLLAR:
+	case FMT_SLOVAKIANKORUNA:
+	case FMT_SLOVENIANTHOLAR:
+	case FMT_SOUTHAFRICANRAND:
+	case FMT_SOUTHKOREANWON:
+	case FMT_SWEDISHKRONA:
+	case FMT_SWISSFRANC:
+	case FMT_TAIWANDOLLAR:
+	case FMT_THAIBAHT:
+	case FMT_USDOLLAR:
+	case FMT_OTHERCURRENCY:
+	case FMT_EURO:
+		return 2;
+
+	case FMT_GREEKDRACHMA:
+	case FMT_ITALIANLIRA:
+	case FMT_JAPANESEYEN:
+	case FMT_SPANISHPESETA:
+		return 0;
+
+	case FMT_DEFAULT:
+	case FMT_GENERAL:
+	case FMT_FIXED:
+	case FMT_COMMA:
+	case FMT_PERCENT:
+	case FMT_SCIENTIFIC:
+	default:
+		return 2;
+	}
+}
diff -urNp lotuswordpro.bak/source/filter/lwpnumericfmt.hxx lotuswordpro/source/filter/lwpnumericfmt.hxx
--- lotuswordpro.bak/source/filter/lwpnumericfmt.hxx	1970-01-01 08:00:00.000000000 +0800
+++ lotuswordpro/source/filter/lwpnumericfmt.hxx	2008-10-22 11:42:29.000000000 +0800
@@ -0,0 +1,313 @@
+/*************************************************************************
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: IBM Corporation
+ *
+ *  Copyright: 2008 by IBM Corporation
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+/**
+ * @file 
+ *  For LWP filter architecture prototype - table object
+ */
+/*************************************************************************
+ * Change History
+ Mar 2005			Created
+ ************************************************************************/
+#ifndef _LWPNUMBERICFMT_HXX
+#define _LWPNUMBERICFMT_HXX
+
+#include "lwpatomholder.hxx"
+#include "lwptblcell.hxx"
+#include "lwpcolor.hxx"
+
+//For converting to xml
+#include "xfilter/xfnumberstyle.hxx"
+
+class LwpObjectStream;
+
+class LwpNumericFormatSubset
+{
+public:
+	LwpNumericFormatSubset();
+	~LwpNumericFormatSubset();	
+	void QuickRead(LwpObjectStream* pStrm);
+	String GetPrefix(){ return cPrefix.str();}
+	String GetSuffix(){ return cSuffix.str();}
+	sal_Bool IsBlack(){ return (cColor.GetBlue()==0 && cColor.GetGreen()==0 && cColor.GetRed()==0);}
+	sal_Bool IsDefaultPrefix(){ return !(cSubFlags&SF_OVER_PREFIX); }
+	sal_Bool IsDefaultSuffix(){ return !(cSubFlags&SF_OVER_SUFFIX);	}
+	LwpColor GetColor();
+protected:
+	LwpColor cColor;
+	LwpAtomHolder cPrefix;
+	LwpAtomHolder cSuffix;
+	sal_uInt16 cSubFlags;
+	enum // for cSubFlags
+	{
+		SF_OVER_PREFIX		= 0x0001,
+		SF_OVER_SUFFIX		= 0x0002,
+		SF_OVER_COLOR		= 0x0004
+	};
+};
+
+struct LwpCurrencyInfo
+{
+	String sSymbol;
+	sal_Bool bPost;
+	sal_Bool bShowSpace;
+	LwpCurrencyInfo(String sSym)
+	{
+		sSymbol = sSym;
+		bPost = sal_False;
+		bShowSpace = sal_False;
+	}
+	LwpCurrencyInfo()
+	{
+		bPost = sal_False;
+		bShowSpace = sal_False;
+	}
+	LwpCurrencyInfo(String sSym,sal_Bool bPost, sal_Bool bShowSpace)
+	{
+		this->sSymbol = sSym;
+		this->bPost = bPost;
+		this->bShowSpace = bShowSpace;
+	}
+};
+
+enum
+{
+	/* These are types of formats.  They are mutually exclusive.
+	*/
+	FMT_NONE				= 0,
+	FMT_ARGENTINEANPESO		= 1,
+	FMT_AUSTRALIANDOLLAR	= 2,
+	FMT_AUSTRIANSCHILLING	= 3,
+	FMT_BELGIANFRANC		= 4,
+	FMT_BRAZILIANCRUZEIRO	= 5,
+	FMT_BRITISHPOUND		= 6,
+	FMT_CANADIANDOLLAR		= 7,
+	FMT_CHINESEYUAN			= 8,
+	FMT_CZECHKORUNA			= 9,
+	FMT_DANISHKRONE			= 10,
+	FMT_ECU					= 11,
+	FMT_FINNISHMARKKA		= 12,
+	FMT_FRENCHFRANC			= 13,
+	FMT_GERMANMARK			= 14,
+	FMT_GREEKDRACHMA		= 15,
+	FMT_HONGKONGDOLLAR		= 16,
+	FMT_HUNGARIANFORINT		= 17,
+	FMT_INDIANRUPEE			= 18,
+	FMT_INDONESIANRUPIAH	= 19,
+	FMT_IRISHPUNT			= 20,
+	FMT_ITALIANLIRA			= 21,
+	FMT_JAPANESEYEN			= 22,
+	FMT_LUXEMBOURGFRANC		= 23,
+	FMT_MALAYSIANRINGGIT	= 24,
+	FMT_MEXICANPESO			= 25,
+	FMT_NETHERLANDSGUILDER	= 26,
+	FMT_NEWZEALANDDOLLAR	= 27,
+	FMT_NORWEGIANKRONE		= 28,
+	FMT_POLISHZLOTY			= 29,
+	FMT_PORTUGUESEESCUDO	= 30,
+	FMT_ROMANIANLEI			= 31,
+	FMT_RUSSIANRUBLE		= 32,
+	FMT_SINGAPOREDOLLAR		= 33,
+	FMT_SLOVAKIANKORUNA		= 34,
+	FMT_SLOVENIANTHOLAR		= 35,
+	FMT_SOUTHAFRICANRAND	= 36,
+	FMT_SOUTHKOREANWON		= 37,
+	FMT_SPANISHPESETA		= 38,
+	FMT_SWEDISHKRONA		= 39,
+	FMT_SWISSFRANC			= 40,
+	FMT_TAIWANDOLLAR		= 41,
+	FMT_THAIBAHT			= 42,
+	FMT_USDOLLAR			= 43,
+	FMT_OTHERCURRENCY		= 44,
+	FMT_DEFAULT				= 45,
+	FMT_GENERAL				= 46, 
+	FMT_FIXED				= 47,
+	FMT_COMMA				= 48, 
+	FMT_PERCENT				= 49,
+	FMT_SCIENTIFIC			= 50,
+	FMT_LABEL				= 51,
+	FMT_EURO				= 52
+};
+
+class LwpCurrencyPool
+{
+public:
+	LwpCurrencyPool(){InitCurrencySymbol();}
+	String GetCurrencySymbol(sal_uInt16 nFormat);
+	sal_Bool IsShowSpace(sal_uInt16 nFormat);
+	sal_Bool IsSymbolPost(sal_uInt16 nFormat);
+private:
+	std::map<sal_uInt16,LwpCurrencyInfo> m_aCurrencyInfo;
+	void InitCurrencySymbol()
+	{
+		USHORT nC=FMT_ARGENTINEANPESO;
+		m_aCurrencyInfo[nC++]=LwpCurrencyInfo(String::CreateFromAscii("A"));					//FMT_ARGENTINEANPESO		= 1,
+		m_aCurrencyInfo[nC++]=LwpCurrencyInfo(String::CreateFromAscii("A$"));					//FMT_AUSTRALIANDOLLAR	= 2,
+		m_aCurrencyInfo[nC++]=LwpCurrencyInfo(String::CreateFromAscii("oS"),sal_True, sal_True);//FMT_AUSTRIANSCHILLING	= 3,
+		m_aCurrencyInfo[nC++]=LwpCurrencyInfo(String::CreateFromAscii("BF"),sal_True, sal_True);//FMT_BELGIANFRANC		= 4,
+		m_aCurrencyInfo[nC++]=LwpCurrencyInfo(String::CreateFromAscii("R$"),sal_False, sal_True);//FMT_BRAZILIANCRUZEIRO	= 5,
+		m_aCurrencyInfo[nC++]=LwpCurrencyInfo(String("",RTL_TEXTENCODING_UTF8));					//FMT_BRITISHPOUND		= 6,
+		m_aCurrencyInfo[nC++]=LwpCurrencyInfo(String::CreateFromAscii("C$"));					//FMT_CANADIANDOLLAR		= 7,
+		m_aCurrencyInfo[nC++]=LwpCurrencyInfo(String("PRC",RTL_TEXTENCODING_UTF8),sal_False,sal_True);	//FMT_CHINESEYUAN			= 8,
+		m_aCurrencyInfo[nC++]=LwpCurrencyInfo(String::CreateFromAscii("Kc"),sal_True, sal_True);//FMT_CZECHKORUNA			= 9,
+		m_aCurrencyInfo[nC++]=LwpCurrencyInfo(String::CreateFromAscii("Dkr"),sal_False, sal_True);//FMT_DANISHKRONE			= 10,
+		m_aCurrencyInfo[nC++]=LwpCurrencyInfo(String::CreateFromAscii("ECU"),sal_True, sal_True);//FMT_ECU					= 11,
+		m_aCurrencyInfo[nC++]=LwpCurrencyInfo(String::CreateFromAscii("mk"),sal_True, sal_True);//FMT_FINNISHMARKKA		= 12,
+		m_aCurrencyInfo[nC++]=LwpCurrencyInfo(String::CreateFromAscii("F"),sal_True, sal_True);//FMT_FRENCHFRANC			= 13,
+		m_aCurrencyInfo[nC++]=LwpCurrencyInfo(String::CreateFromAscii("DM"),sal_True, sal_True);//FMT_GERMANMARK			= 14,
+		m_aCurrencyInfo[nC++]=LwpCurrencyInfo(String::CreateFromAscii("Dr"),sal_True, sal_True);//FMT_GREEKDRACHMA		= 15,
+		m_aCurrencyInfo[nC++]=LwpCurrencyInfo(String::CreateFromAscii("HK$"));					//FMT_HONGKONGDOLLAR		= 16,
+		m_aCurrencyInfo[nC++]=LwpCurrencyInfo(String::CreateFromAscii("Ft"),sal_True, sal_True);//FMT_HUNGARIANFORINT		= 17,
+		m_aCurrencyInfo[nC++]=LwpCurrencyInfo(String::CreateFromAscii("Rs"),sal_False, sal_True);//FMT_INDIANRUPEE			= 18,
+		m_aCurrencyInfo[nC++]=LwpCurrencyInfo(String::CreateFromAscii("Rp"),sal_False, sal_True);//FMT_INDONESIANRUPIAH	= 19,
+		m_aCurrencyInfo[nC++]=LwpCurrencyInfo(String("IR",RTL_TEXTENCODING_UTF8));					//FMT_IRISHPUNT			= 20,
+		m_aCurrencyInfo[nC++]=LwpCurrencyInfo(String::CreateFromAscii("L."),sal_False, sal_True);//FMT_ITALIANLIRA			= 21,
+		m_aCurrencyInfo[nC++]=LwpCurrencyInfo(String("",RTL_TEXTENCODING_UTF8));				//FMT_JAPANESEYEN			= 22,
+		m_aCurrencyInfo[nC++]=LwpCurrencyInfo(String::CreateFromAscii("LF"),sal_True, sal_True);//FMT_LUXEMBOURGFRANC		= 23,
+		m_aCurrencyInfo[nC++]=LwpCurrencyInfo(String::CreateFromAscii("Rm"),sal_False, sal_True);//FMT_MALAYSIANRINGGIT	= 24,
+		m_aCurrencyInfo[nC++]=LwpCurrencyInfo(String::CreateFromAscii("Mex$"));					//FMT_MEXICANPESO			= 25,
+		m_aCurrencyInfo[nC++]=LwpCurrencyInfo(String::CreateFromAscii("F"),sal_False, sal_True);//FMT_NETHERLANDSGUILDER	= 26,
+		m_aCurrencyInfo[nC++]=LwpCurrencyInfo(String::CreateFromAscii("NZ$"));					//FMT_NEWZEALANDDOLLAR	= 27,
+		m_aCurrencyInfo[nC++]=LwpCurrencyInfo(String::CreateFromAscii("Nkr"),sal_False, sal_True);//FMT_NORWEGIANKRONE		= 28,
+		m_aCurrencyInfo[nC++]=LwpCurrencyInfo(String::CreateFromAscii("Zl"),sal_True, sal_True);//FMT_POLISHZLOTY			= 29,
+		m_aCurrencyInfo[nC++]=LwpCurrencyInfo(String::CreateFromAscii("Esc."),sal_True, sal_True);//FMT_PORTUGUESEESCUDO	= 30,
+		m_aCurrencyInfo[nC++]=LwpCurrencyInfo(String::CreateFromAscii("Leu"),sal_True, sal_True);//FMT_ROMANIANLEI			= 31,
+		m_aCurrencyInfo[nC++]=LwpCurrencyInfo(String::CreateFromAscii("R"),sal_True, sal_True);//FMT_RUSSIANRUBLE		= 32,
+		m_aCurrencyInfo[nC++]=LwpCurrencyInfo(String::CreateFromAscii("S$"));					//FMT_SINGAPOREDOLLAR		= 33,
+		m_aCurrencyInfo[nC++]=LwpCurrencyInfo(String::CreateFromAscii("Sk"),sal_True, sal_True);//FMT_SLOVAKIANKORUNA		= 34,
+		m_aCurrencyInfo[nC++]=LwpCurrencyInfo(String::CreateFromAscii("SIT"),sal_False, sal_True);//FMT_SLOVENIANTHOLAR		= 35,
+		m_aCurrencyInfo[nC++]=LwpCurrencyInfo(String::CreateFromAscii("R"));					//FMT_SOUTHAFRICANRAND	= 36,
+		m_aCurrencyInfo[nC++]=LwpCurrencyInfo(String::CreateFromAscii("W"));					//FMT_SOUTHKOREANWON		= 37,
+		m_aCurrencyInfo[nC++]=LwpCurrencyInfo(String::CreateFromAscii("Pts"),sal_True, sal_True);//FMT_SPANISHPESETA		= 38,
+		m_aCurrencyInfo[nC++]=LwpCurrencyInfo(String::CreateFromAscii("Skr"),sal_True, sal_True);//FMT_SWEDISHKRONA		= 39,
+		m_aCurrencyInfo[nC++]=LwpCurrencyInfo(String::CreateFromAscii("SFr"),sal_False, sal_True);//FMT_SWISSFRANC			= 40,
+		m_aCurrencyInfo[nC++]=LwpCurrencyInfo(String::CreateFromAscii("NT$"));					//FMT_TAIWANDOLLAR		= 41,
+		m_aCurrencyInfo[nC++]=LwpCurrencyInfo(String::CreateFromAscii("Bt"),sal_True, sal_True);//FMT_THAIBAHT			= 42,
+		m_aCurrencyInfo[nC++]=LwpCurrencyInfo(String::CreateFromAscii("$"));					//FMT_USDOLLAR			= 43,
+		m_aCurrencyInfo[nC++]=LwpCurrencyInfo(String::CreateFromAscii("OTH"),sal_False, sal_True);//FMT_OTHERCURRENCY		= 44,
+
+		m_aCurrencyInfo[FMT_EURO]=LwpCurrencyInfo(String("",RTL_TEXTENCODING_UTF8));				//FMT_EURO				= 52
+	}
+};
+
+class LwpNumericFormat
+{
+public:
+	LwpNumericFormat(LwpObjectStream * pStrm);
+	~LwpNumericFormat(){};
+	void Read();
+	static sal_Bool IsCurrencyFormat(USHORT Format);
+	USHORT GetDecimalPlaces(void);
+	sal_Bool IsDecimalPlacesOverridden(void);
+	sal_Bool IsNegativeOverridden(void);
+	sal_Bool IsZeroOverridden(void);
+	XFStyle* Convert();
+private:
+	LwpObjectStream * m_pObjStrm;
+
+	sal_uInt16 cFlags;
+	enum // for cFlags
+	{
+		NF_OVER_ZERO			= 0x0001,
+		NF_OVER_NEGATIVE		= 0x0002,
+		NF_OVER_DECIMAL_PLACES	= 0x0004
+	};
+
+	sal_uInt16 cFormat;
+
+	LwpNumericFormatSubset cAnyNumber;
+	LwpNumericFormatSubset cZero;
+	LwpNumericFormatSubset cNegative;
+
+	sal_uInt16 cDecimalPlaces;
+
+	static USHORT GetDefaultDecimalPlaces(USHORT Format);
+	static LwpCurrencyPool m_aCurrencyInfo;
+	
+	void GetCurrencyStr(LwpNumericFormatSubset aNumber, String& aPrefix, String& aSuffix, sal_Bool bNegtive=sal_False);
+	void SetNumberType(XFNumberStyle* pStyle);
+	OUString	reencode(OUString sCode);
+};
+
+inline sal_Bool
+LwpNumericFormat::IsDecimalPlacesOverridden(void)
+{
+	return (cFlags & NF_OVER_DECIMAL_PLACES) != 0;
+}
+inline sal_Bool
+LwpNumericFormat::IsNegativeOverridden(void)
+{
+	return (cFlags & NF_OVER_NEGATIVE) != 0;
+}
+inline sal_Bool
+LwpNumericFormat::IsZeroOverridden(void)
+{
+	return (cFlags & NF_OVER_ZERO) != 0;
+}
+
+#include "lwppiece.hxx"
+class LwpLayoutNumerics : public LwpVirtualPiece
+{
+public:
+	LwpLayoutNumerics(LwpObjectHeader& objHdr, LwpSvStream* pStrm)
+	:LwpVirtualPiece(objHdr, pStrm),cNumerics(m_pObjStrm){};
+	~LwpLayoutNumerics(){};
+	XFStyle* Convert();
+	virtual void Read();
+protected:
+	LwpNumericFormat cNumerics;
+};
+
+#endif
+
diff -urNp lotuswordpro.bak/source/filter/lwpobj.cxx lotuswordpro/source/filter/lwpobj.cxx
--- lotuswordpro.bak/source/filter/lwpobj.cxx	1970-01-01 08:00:00.000000000 +0800
+++ lotuswordpro/source/filter/lwpobj.cxx	2008-10-22 11:42:29.000000000 +0800
@@ -0,0 +1,121 @@
+/*************************************************************************
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: IBM Corporation
+ *
+ *  Copyright: 2008 by IBM Corporation
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+/*************************************************************************
+ * Change History
+ Jan 2005			Created
+ ************************************************************************/
+
+#include "lwpobj.hxx"
+
+/**
+ * @descr  private contor to ensure only object constructed from stream
+ */
+LwpObject::LwpObject()
+	: m_pObjStrm(NULL),  m_pFoundry(NULL), m_pStrm(NULL)
+{}
+/**
+ * @descr  construct lwpobject from stream
+ */
+LwpObject::LwpObject(LwpObjectHeader objHdr, LwpSvStream* pStrm)
+	: m_ObjHdr(objHdr), m_pStrm(pStrm), m_pObjStrm(NULL), m_pFoundry(NULL)
+{
+	m_pObjStrm = new LwpObjectStream(pStrm, m_ObjHdr.IsCompressed(), 
+			static_cast<sal_uInt16>(m_ObjHdr.GetSize()) );
+}
+/**
+ * @descr	dtor()
+*/
+LwpObject::~LwpObject()
+{
+	if(m_pObjStrm) 
+		delete m_pObjStrm;	
+
+}
+/**
+ * @descr  QuickRead template
+ */
+void LwpObject::QuickRead()
+{
+	Read();
+	m_pObjStrm->ReadComplete();
+	if(m_pObjStrm)
+	{
+		delete m_pObjStrm;	
+		m_pObjStrm = NULL;
+	}
+}
+/**
+ * @descr  default read function
+ */
+void LwpObject::Read()
+{}
+/**
+ * @descr  default parse function
+ */
+void LwpObject::Parse(IXFStream* pOutputStream)
+{}
+/**
+ * @descr  default register style function
+ */
+void LwpObject::RegisterStyle()
+{}
+
+/**
+ * @descr  default XFConvert function
+ * pCont is the XFContentContainer for the object conversion
+ */
+void LwpObject::XFConvert(XFContentContainer* pCont)
+{}
+
diff -urNp lotuswordpro.bak/source/filter/lwpobjfactory.cxx lotuswordpro/source/filter/lwpobjfactory.cxx
--- lotuswordpro.bak/source/filter/lwpobjfactory.cxx	1970-01-01 08:00:00.000000000 +0800
+++ lotuswordpro/source/filter/lwpobjfactory.cxx	2008-10-22 11:42:29.000000000 +0800
@@ -0,0 +1,781 @@
+/*************************************************************************
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: IBM Corporation
+ *
+ *  Copyright: 2008 by IBM Corporation
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+/*************************************************************************
+ * @file 
+ *  For LWP filter architecture prototype
+ ************************************************************************/
+/*************************************************************************
+ * Change History
+ Jan 2005			Created
+ ************************************************************************/
+
+#include "lwpobjfactory.hxx"
+
+#ifndef _LWPDEFS_HXX
+#include "lwpdefs.hxx"
+#endif
+
+#include "lwpdoc.hxx"
+#include "lwpdefobj.hxx"
+#include "lwptemp.hxx"
+#include "lwpstory.hxx"
+#include "lwplayout.hxx"
+#include "lwppara.hxx"
+#include "lwpparastyle.hxx"
+#include "lwpcharacterstyle.hxx"
+#include "lwppiece.hxx"
+#include "lwptabrack.hxx"
+#include "lwpsilverbullet.hxx"
+#include "lwpdivinfo.hxx"
+#include "lwpholder.hxx"
+#include "lwpdivopts.hxx"
+#include "lwplaypiece.hxx"
+#include "lwpsection.hxx"
+#include "lwppagehint.hxx"
+#include "lwpoleobject.hxx"
+#include "lwpgrfobj.hxx"
+#include "lwptable.hxx"
+#include "lwptblcell.hxx"
+#include "lwpmarker.hxx"
+#include "lwpproplist.hxx"
+#include <new>
+#include "lwpframelayout.hxx"
+#include "lwptablelayout.hxx"
+#include "lwppagelayout.hxx"
+#include "lwptblformula.hxx"
+#include "lwpvpointer.hxx"
+#include "lwpfootnote.hxx"
+#include "lwpnumericfmt.hxx"
+#include "lwpfnlayout.hxx"
+#include "lwptoc.hxx"
+#include "lwpdocdata.hxx"
+#include "lwpnotes.hxx"
+#include "lwpverdocument.hxx"
+
+//LwpObjectFactory* LwpObjectFactory::m_pMgr = NULL;
+
+LwpObjectFactory::LwpObjectFactory(LwpSvStream* pSvStream)
+	: m_pSvStream(pSvStream), m_nNumObjs(0)
+{
+	m_ObjList.clear();
+}
+
+LwpObjectFactory::~LwpObjectFactory()
+{
+//	m_pMgr = NULL;
+	if(!m_ObjList.empty())
+		ClearObjectMap();
+}
+
+/**
+ * @descr		create the single object factory
+*/
+/*
+LwpObjectFactory* LwpObjectFactory::Instance(LwpSvStream* pStream)
+{
+	if(m_pMgr == NULL)
+	{
+		if(pStream)
+		{
+			m_pMgr = new LwpObjectFactory(pStream);
+		}
+	}
+	return(m_pMgr);
+}*/
+/**
+ * @descr		clear object map and delete all objects
+*/
+void LwpObjectFactory::ClearObjectMap()
+{
+	LwpObjMap::iterator it = m_ObjList.begin();
+	while( it!=m_ObjList.end() )
+	{
+		delete (*it).second;
+		(*it).second = NULL;
+		it++;
+	}
+	m_ObjList.clear();
+}
+/**
+ * @descr		read the index manager
+*/
+void LwpObjectFactory::ReadIndex(LwpSvStream* pStrm)
+{
+	m_IndexMgr.Read(pStrm);
+}
+
+/**
+ * @descr		create all kinds of objects except lwp7
+*/
+LwpObject* LwpObjectFactory::CreateObject(sal_uInt32 type, LwpObjectHeader &objHdr)
+{
+	LwpObject* newObj = NULL;
+	m_nNumObjs++;
+	assert(type<300);
+	switch(type)
+	{
+		case VO_DOCUMENT: 
+		{
+			newObj = new LwpDocument(objHdr, m_pSvStream);
+			break;
+		}
+		case VO_DOCSOCK:
+		{
+			newObj = new LwpDocSock(objHdr, m_pSvStream);
+			break;
+		}
+		case VO_DIVISIONINFO:
+		{
+			newObj = new LwpDivInfo(objHdr, m_pSvStream);
+			break;
+		}
+		case VO_DIVOPTS:
+		{
+			newObj = new LwpDivisionOptions(objHdr, m_pSvStream);
+			break;
+		}			
+		case VO_HEADCONTENT:
+		{
+			newObj = new LwpHeadContent(objHdr, m_pSvStream);
+			break;
+		}
+		case VO_HEADLAYOUT:
+		{
+			newObj = new LwpHeadLayout(objHdr, m_pSvStream);
+			break;
+		}
+		case VO_PAGELAYOUT:
+		{
+			newObj = new LwpPageLayout(objHdr, m_pSvStream);
+			break;			
+		}
+		case VO_STORY:
+		{
+			newObj = new LwpStory(objHdr, m_pSvStream);
+			break;
+		}
+		case VO_PARA:
+		{
+			newObj = new LwpPara(objHdr, m_pSvStream);
+			break;
+		}
+		case VO_HEADERLAYOUT:
+		{
+			newObj = new LwpHeaderLayout(objHdr, m_pSvStream);
+			break;
+		}
+		case VO_FOOTERLAYOUT:
+		{
+			newObj = new LwpFooterLayout(objHdr, m_pSvStream);
+			break;
+		}
+		case VO_FRAMELAYOUT:
+		{
+			newObj = new LwpFrameLayout(objHdr, m_pSvStream);
+			break;
+		}
+		case VO_LAYOUTGEOMETRY:
+		{
+			newObj = new LwpLayoutGeometry(objHdr, m_pSvStream);
+			break;
+		}
+		case VO_LAYOUTSCALE:
+		{
+			newObj = new LwpLayoutScale(objHdr, m_pSvStream);
+			break;
+		}
+		case VO_LAYOUTMARGINS:
+		{
+			newObj = new LwpLayoutMargins(objHdr, m_pSvStream);
+			break;
+		}		
+		case VO_LAYOUTBORDERSTUFF:
+		{
+			newObj = new LwpLayoutBorder(objHdr, m_pSvStream);
+			break;
+		}
+		case VO_LAYOUTBACKGROUNDSTUFF:
+		{
+			newObj = new LwpLayoutBackground(objHdr, m_pSvStream);
+			break;
+		}		
+		case VO_LAYOUTEXTERNALBORDERSTUFF:
+		{
+			newObj = new LwpLayoutExternalBorder(objHdr, m_pSvStream);
+			break;
+		}
+		case VO_LAYOUTCOLUMNS:
+		{
+			newObj = new LwpLayoutColumns(objHdr, m_pSvStream);
+			break;
+		}
+		case VO_LAYOUTGUTTERSTUFF:
+		{
+			newObj = new LwpLayoutGutters(objHdr, m_pSvStream);
+			break;
+		}
+		case VO_LAYOUTJOINSTUFF:
+		{
+			newObj = new LwpLayoutJoins(objHdr, m_pSvStream);
+			break;
+		}
+		case VO_LAYOUTSHADOW:
+		{
+			newObj = new LwpLayoutShadow(objHdr, m_pSvStream);
+			break;
+		}
+		// 01/12/2005
+		case VO_PARASTYLE:
+		{
+			newObj = new LwpParaStyle(objHdr, m_pSvStream);
+			break;
+		}
+		case VO_CHARACTERSTYLE:
+		{
+			newObj = new LwpCharacterStyle(objHdr, m_pSvStream);
+			break;
+		}
+		case VO_SILVERBULLET:
+		{
+			newObj = new LwpSilverBullet(objHdr, m_pSvStream);
+			break;
+		}
+		case VO_ALIGNMENTPIECE:
+		{
+			newObj = new LwpAlignmentPiece(objHdr, m_pSvStream);
+			break;
+		}
+		case VO_INDENTPIECE:
+		{
+			newObj = new LwpIndentPiece(objHdr, m_pSvStream);
+			break;
+		}
+		case VO_SPACINGPIECE:
+		{
+			newObj = new LwpSpacingPiece(objHdr, m_pSvStream);
+			break;
+		}
+		case VO_CHARBORDERPIECE:
+		{
+			newObj = new LwpCharacterBorderPiece(objHdr, m_pSvStream);
+			break;
+		}
+		case VO_AMIKAKEPIECE:
+		{
+			newObj = new LwpAmikakePiece(objHdr, m_pSvStream);
+			break;
+		}
+		// end
+
+		case VO_HEADHOLDER:
+		{
+			newObj = new LwpDLVListHeadHolder(objHdr, m_pSvStream);
+			break;
+		}			
+		
+		// start
+		case VO_PARABORDERPIECE:
+		{
+			newObj = new LwpParaBorderPiece(objHdr, m_pSvStream);
+			break;
+		}
+		case VO_BREAKSPIECE:
+		{
+			newObj = new LwpBreaksPiece(objHdr, m_pSvStream);
+			break;
+		}
+		case VO_NUMBERINGPIECE:
+		{
+			newObj = new LwpNumberingPiece(objHdr, m_pSvStream);
+			break;
+		}
+		case VO_TABRACK:
+		{
+			newObj = new LwpTabRack(objHdr, m_pSvStream);
+			break;
+		}
+		case VO_TABPIECE:
+		{
+			newObj = new LwpTabPiece(objHdr, m_pSvStream);
+			break;
+		}
+		case VO_PARABACKGROUNDPIECE:	//perhaps wrong.
+		{
+			newObj = new LwpBackgroundPiece(objHdr, m_pSvStream);
+			break;
+		}
+		// end.
+		case VO_SECTION:
+		{
+			newObj = new LwpSection(objHdr, m_pSvStream);
+			break;
+		}
+		case VO_INDEXSECTION:
+		{
+			newObj = new LwpIndexSection(objHdr, m_pSvStream);
+			break;
+		}
+		case VO_HEADTAILHOLDER:
+		{
+			newObj = new LwpDLVListHeadTailHolder(objHdr, m_pSvStream);
+			break;
+		}
+		case VO_PAGEHINT:
+		{
+			newObj = new LwpPageHint(objHdr, m_pSvStream);
+			break;
+		}
+		case VO_OLEOBJECT:
+		{
+			newObj = new LwpOleObject(objHdr, m_pSvStream);
+			break;
+		}
+		//
+		case VO_GRAPHIC:
+		{
+			newObj = new LwpGraphicObject(objHdr, m_pSvStream);
+			break;
+		}
+ 		case VO_DOCDATA:
+		{
+			newObj = new LwpDocData(objHdr, m_pSvStream);
+			break;
+		}
+		//
+		case VO_DROPCAPLAYOUT:
+		{
+			newObj = new LwpDropcapLayout(objHdr, m_pSvStream);
+			break;
+		}
+		case VO_LAYOUTRELATIVITY:
+		{
+			newObj = new LwpLayoutRelativity(objHdr, m_pSvStream);
+			break;
+		}
+		//  for table
+		case VO_TABLE:
+		{
+			newObj = new LwpTable(objHdr, m_pSvStream);
+			break;
+		}
+		case VO_TABLELAYOUT:
+		{
+			newObj = new LwpTableLayout(objHdr, m_pSvStream);
+			break;
+		}
+		case VO_SUPERTABLE:
+		{
+			newObj = new LwpSuperTable(objHdr, m_pSvStream);
+			break;
+		}
+		case VO_SUPERTABLELAYOUT:
+		{
+			newObj = new LwpSuperTableLayout(objHdr, m_pSvStream);
+			break;
+		}
+		case VO_CELLLAYOUT:
+		{
+			newObj = new LwpCellLayout(objHdr, m_pSvStream);
+			break;
+		}
+		case VO_ROWLAYOUT:
+		{
+			newObj = new LwpRowLayout(objHdr, m_pSvStream);
+			break;
+		}
+		case VO_LAYOUTNUMERICS:
+		{
+			newObj = new LwpLayoutNumerics(objHdr, m_pSvStream);
+			break;
+		}
+		case VO_NUMERICVALUE:
+		{
+			newObj = new LwpNumericValue(objHdr, m_pSvStream);
+			break;
+		}
+		case VO_FORMULAINFO:
+		{
+			newObj = new LwpFormulaInfo(objHdr, m_pSvStream);
+			break;
+		}
+		case VO_COLUMNLAYOUT:
+		{
+			newObj = new LwpColumnLayout(objHdr, m_pSvStream);
+			break;
+		}
+		case VO_ROWLIST:
+		{
+			newObj = new LwpRowList(objHdr, m_pSvStream);
+			break;
+		}
+		case VO_CELLLIST:
+		{
+			newObj = new LwpCellList(objHdr, m_pSvStream);
+			break;
+		}
+		case VO_TABLERANGE:
+		{
+			newObj = new LwpTableRange(objHdr, m_pSvStream);
+			break;
+		}
+		case VO_CELLRANGE:
+		{
+			newObj = new LwpCellRange(objHdr, m_pSvStream);
+			break;
+		}
+		case VO_FOLDER:
+		{
+			newObj = new LwpFolder(objHdr, m_pSvStream);
+			break;
+		}
+		case VO_DEPENDENT:
+		{
+			newObj = new LwpDependent(objHdr, m_pSvStream);
+			break;
+		}
+		case VO_CONNECTEDCELLLAYOUT:
+		{
+			newObj = new LwpConnectedCellLayout(objHdr, m_pSvStream);
+			break;
+		}
+		case VO_HIDDENCELLLAYOUT:
+		{
+			newObj = new LwpHiddenCellLayout(objHdr, m_pSvStream);
+			break;
+		}
+		case VO_TABLEHEADINGLAYOUT:
+		{
+			newObj = new LwpTableHeadingLayout(objHdr, m_pSvStream);
+			break;
+		}
+		case VO_ROWHEADINGLAYOUT:
+		{
+			newObj = new LwpRowHeadingLayout(objHdr, m_pSvStream);
+			break;
+		}
+		case VO_TABLEHEADING:
+		{
+			newObj = new LwpTableHeading(objHdr, m_pSvStream);
+			break;
+		}
+		/* some member variables can't be read until now
+		case VO_TABLEHINT:
+		{
+			newObj = new LwpTableHint(objHdr, m_pSvStream);
+			break;
+		}
+		*/
+		// end table
+		//add by 
+		case VO_CHBLKMARKER:
+		{
+			newObj = new LwpCHBlkMarker(objHdr, m_pSvStream);
+			break;
+		}
+		case VO_PROPLIST:
+		{
+			newObj = new LwpPropListElement(objHdr, m_pSvStream);
+			break;	
+		}
+		case VO_BOOKMARK:
+		{
+			newObj = new LwpBookMark(objHdr, m_pSvStream);
+			break;
+		}
+		case VO_FIELDMARKER:
+		{
+			newObj = new LwpFieldMark(objHdr, m_pSvStream);
+			break;
+		}
+		case VO_OBJECTHOLDER:
+		{
+			newObj = new LwpObjectHolder(objHdr, m_pSvStream);
+			break;
+		}
+		case VO_POBJECTHOLDER:
+		{
+			newObj = new LwpObjectHolder(objHdr, m_pSvStream);
+			break;
+		}
+		case VO_VERGTR: //fall through
+		case VO_VERQTR:
+		{
+			newObj = new LwpVersionedPointer(objHdr, m_pSvStream);
+			break;
+		}
+		case VO_FOOTNOTE:
+		{
+			newObj = new LwpFootnote(objHdr, m_pSvStream);
+			break;
+		}
+		case VO_FOOTNOTETABLE:
+		{
+			newObj = new LwpFootnoteTable(objHdr, m_pSvStream);
+			break;
+		}
+		case VO_FOOTNOTEOPTS:
+		{
+			newObj = new LwpFootnoteOptions(objHdr, m_pSvStream);
+			break;
+		}
+		case VO_FOOTNOTELAYOUT:
+		{
+			newObj = new LwpFootnoteLayout(objHdr, m_pSvStream);
+			break;
+		}
+		case VO_FNROWLAYOUT:
+		{
+			newObj = new LwpFnRowLayout(objHdr, m_pSvStream);
+			break;
+		}
+		case VO_FNCELLLAYOUT:
+		{
+			newObj = new LwpFnCellLayout(objHdr, m_pSvStream);
+			break;
+		}
+		case VO_ENDNOTELAYOUT:
+		{
+			newObj = new LwpEndnoteLayout(objHdr, m_pSvStream);
+			break;
+		}
+		case VO_ENSUPERTABLELAYOUT:
+		{
+			newObj = new LwpEnSuperTableLayout(objHdr, m_pSvStream);
+			break;
+		}
+		case VO_FNSUPERTABLELAYOUT:
+		{
+			newObj = new LwpFnSuperTableLayout(objHdr, m_pSvStream);
+			break;
+		}
+		case VO_CONTONLAYOUT:
+		{
+			newObj = new LwpContOnLayout(objHdr, m_pSvStream);
+			break;
+		}
+		case VO_CONTFROMLAYOUT:
+		{
+			newObj = new LwpContFromLayout(objHdr, m_pSvStream);
+			break;
+		}
+		case VO_GROUPLAYOUT:
+		{
+			newObj = new LwpGroupLayout(objHdr, m_pSvStream);
+			break;
+		}
+		case VO_GROUPFRAME:
+		{
+			newObj = new LwpGroupFrame(objHdr, m_pSvStream);
+			break;
+		}
+		case VO_TOCSUPERTABLELAYOUT:
+		{
+			newObj = new LwpTocSuperLayout(objHdr, m_pSvStream);
+			break;
+		}
+		case VO_LISTLIST:
+		{
+			newObj = new LwpListList(objHdr, m_pSvStream);
+			break;
+		}
+		case VO_TOCLEVELDATA:
+		{
+			newObj = new LwpTocLevelData(objHdr, m_pSvStream);
+			break;
+		}
+		case VO_NOTELAYOUT:
+		{
+			newObj = new LwpNoteLayout(objHdr, m_pSvStream);
+			break;
+		}
+		case VO_NOTEHEADERLAYOUT:
+		{
+			newObj = new LwpNoteHeaderLayout(objHdr, m_pSvStream);
+			break;
+		}
+		case VO_NOTETEXTLAYOUT:
+		{
+			newObj = new LwpNoteTextLayout(objHdr, m_pSvStream);
+			break;
+		}
+		case VO_VPLAYOUT:
+		{
+			newObj = new LwpViewportLayout(objHdr, m_pSvStream);
+			break;
+		}
+		case VO_PCOLBLOCK:
+		{
+			newObj = new LwpParallelColumnsBlock(objHdr, m_pSvStream);
+			break;
+		}
+		case VO_SUPERPARALLELCOLUMNLAYOUT:
+		{
+			newObj = new LwpSuperParallelColumnLayout(objHdr, m_pSvStream);
+			break;
+		}
+		case VO_PCOLLAYOUT:
+		{
+			newObj = new LwpParallelColumnsLayout(objHdr, m_pSvStream);
+			break;
+		}
+		case VO_PARALLELCOLUMNS:
+		{
+			newObj = new LwpParallelColumns(objHdr, m_pSvStream);
+			break;
+		}
+		case VO_RUBYMARKER:
+		{
+			newObj = new LwpRubyMarker(objHdr, m_pSvStream);
+			break;
+		}
+		case VO_RUBYLAYOUT:
+		{
+			newObj = new LwpRubyLayout(objHdr, m_pSvStream);
+			break;
+		}
+		case VO_GLOSSARY:
+		{
+			newObj = new LwpGlossary(objHdr, m_pSvStream);
+			break;
+		}
+		case VO_SUPERGLOSSARYLAYOUT:
+		{
+			newObj = new LwpSuperGlossaryLayout(objHdr, m_pSvStream);
+			break;
+		}
+		case VO_VERDOCUMENT:
+		{
+			newObj = new LwpVerDocument(objHdr, m_pSvStream);
+			break;
+		}
+		default:	
+		{
+			//Unknown object type
+			assert(false);
+			newObj = NULL;
+			//newObj = new LwpDefaultObject(objHdr, m_pSvStream);
+			break;
+		}
+	}
+	if(newObj)
+	{
+		newObj->QuickRead();
+		m_ObjList.insert(LwpObjMap::value_type(*objHdr.GetID(), newObj));
+	}
+	
+	return(newObj);
+}
+/**
+ * @descr		query object by object id
+ *			object is created if not in the factory
+*/
+LwpObject* LwpObjectFactory::QueryObject(const LwpObjectID &objID)
+{
+	LwpObject* obj = FindObject( objID );
+	if(!obj)
+	{
+		//Read the object from file
+		sal_uInt32 nStreamOffset = m_IndexMgr.GetObjOffset(objID);
+		if(nStreamOffset == BAD_OFFSET) //does not find the offset in index manager
+		{
+			return NULL;
+		}
+		m_pSvStream->Seek( nStreamOffset + LwpSvStream::LWP_STREAM_BASE );
+		LwpObjectHeader objHdr;
+		objHdr.Read(*m_pSvStream);
+		obj = CreateObject(objHdr.GetTag(), objHdr);
+	}
+	return obj;
+}
+#if 0
+#ifdef WIN32
+void LwpObjectFactory::SetOleObjInfo(SvStorageRef& objStor)
+{
+	m_objStor = objStor; 			
+	m_objStor->FillInfoList(&m_infoList);	//Fill all objects into a list from then storage.
+}
+
+void LwpObjectFactory::GetOleObjInfo(SvStorageRef & objStor, SvStorageInfoList ** ppInfoList)  
+{
+	objStor = m_objStor; 
+	*ppInfoList = &m_infoList; 
+}
+#endif
+#endif
+
+/**
+ * @descr		find object in the factory per the object id
+*/
+LwpObject* LwpObjectFactory::FindObject(const LwpObjectID &objID)
+{
+	LwpObjMap::const_iterator it =  m_ObjList.find(objID);
+	if (it != m_ObjList.end()) {
+		return((*it).second);
+	}
+	else
+	{
+		return NULL;
+	}
+}
+/**
+ * @descr		release object in the factory per the object id
+*/
+void LwpObjectFactory::ReleaseObject(const LwpObjectID &objID)
+{
+	LwpObject* obj = FindObject( objID );
+	m_ObjList.erase(objID);
+	if( obj )
+		delete obj;
+}
diff -urNp lotuswordpro.bak/source/filter/lwpobjfactory.hxx lotuswordpro/source/filter/lwpobjfactory.hxx
--- lotuswordpro.bak/source/filter/lwpobjfactory.hxx	1970-01-01 08:00:00.000000000 +0800
+++ lotuswordpro/source/filter/lwpobjfactory.hxx	2008-10-22 11:42:29.000000000 +0800
@@ -0,0 +1,140 @@
+/*************************************************************************
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: IBM Corporation
+ *
+ *  Copyright: 2008 by IBM Corporation
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+/*************************************************************************
+ * @file 
+ *  For LWP filter architecture prototype
+ ************************************************************************/
+/*************************************************************************
+ * Change History
+ Jan 2005			Created
+ ************************************************************************/
+
+#ifndef LWPOBJFACTORY_HXX_
+#define LWPOBJFACTORY_HXX_
+
+#include "lwpheader.hxx"
+#include "lwpobjid.hxx"
+#include "lwpobj.hxx"
+#include "lwpobjhdr.hxx"
+#include "lwpidxmgr.hxx"
+#if 0
+#ifdef WIN32
+#include <so3/svstor.hxx>
+#include <so3/outplace.hxx>
+#include <so3/ipobj.hxx>
+#include <so3/factory.hxx>
+#include <svx/svdoole2.hxx>
+#include <svx/svdpage.hxx>
+#include <sfx2/objsh.hxx>
+#include <sot/storinfo.hxx>
+#endif //WIN32
+#endif
+/**
+ * @brief	object factory used for lwp object creation and maintenance
+*/
+class LwpObjectFactory
+{
+public:
+	LwpObjectFactory(LwpSvStream* pSvStream);
+public:
+//	static LwpObjectFactory* Instance(LwpSvStream* pSvStream=NULL);
+	~LwpObjectFactory();
+
+//For object Factory and object manager
+private:
+//	static LwpObjectFactory *m_pMgr;
+	sal_uInt32 m_nNumObjs;
+	LwpSvStream* m_pSvStream;
+	struct hashFunc
+	{
+			size_t operator()( const LwpObjectID& rName ) const
+			{
+				return rName.HashCode();
+			}
+	};
+	struct eqFunc
+	{
+			bool operator()( const LwpObjectID& rKey1, const LwpObjectID& rKey2 ) const
+			{
+				return(rKey1==rKey2);
+			}
+	};		
+	typedef std::hash_map<LwpObjectID, LwpObject *, hashFunc, eqFunc> LwpObjMap;
+	LwpObjMap m_ObjList;
+	LwpIndexManager m_IndexMgr;
+	void ClearObjectMap();
+
+protected:
+	LwpObject* FindObject(const LwpObjectID &objID);
+public:
+	LwpObject* CreateObject(sal_uInt32 type, LwpObjectHeader &objHdr);
+	LwpObject* QueryObject(const LwpObjectID &objID);
+	void ReleaseObject(const LwpObjectID &objID);
+	void ReadIndex(LwpSvStream* pStrm);
+	LwpIndexManager* GetIndexManager(){return &m_IndexMgr;}
+#if 0
+// for OLE objects in current wordpro file
+#ifdef WIN32
+private:
+	SvStorageRef m_objStor;
+	SvStorageInfoList m_infoList;
+public:
+	void SetOleObjInfo(SvStorageRef & objStor);
+	void GetOleObjInfo(SvStorageRef & objStor, SvStorageInfoList ** ppInfoList);
+#endif
+#endif
+};
+
+#endif
diff -urNp lotuswordpro.bak/source/filter/lwpobjhdr.cxx lotuswordpro/source/filter/lwpobjhdr.cxx
--- lotuswordpro.bak/source/filter/lwpobjhdr.cxx	1970-01-01 08:00:00.000000000 +0800
+++ lotuswordpro/source/filter/lwpobjhdr.cxx	2008-10-22 11:42:29.000000000 +0800
@@ -0,0 +1,198 @@
+/*************************************************************************
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: IBM Corporation
+ *
+ *  Copyright: 2008 by IBM Corporation
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+/*************************************************************************
+ * @file 
+ *  For LWP filter architecture prototype
+ ************************************************************************/
+/*************************************************************************
+ * Change History
+ Jan 2005			Created
+ ************************************************************************/
+
+#include "lwpobjhdr.hxx"
+#include "lwpdefs.hxx"
+#include "lwpfilehdr.hxx"
+
+LwpObjectHeader::LwpObjectHeader()
+	: m_nTag(0), m_ID(), m_nSize(0), m_bCompressed(sal_False)
+	// m_nHeaderSize(0), m_nVersionID(0), m_nRefCount(0), m_nFlagBits(0), 
+	//m_nNextVersionOffset(0), m_nNextVersionID(0), 
+{};
+/**
+ * @descr  read header from stream
+  */
+void LwpObjectHeader::Read(LwpSvStream &rStrm)
+{
+
+	sal_uInt8 nFlagBits = 0;
+	sal_uInt32 nVersionID = 0;
+	sal_uInt32 nRefCount = 0;
+	sal_uInt32 nNextVersionOffset = 0;
+	sal_uInt32 nNextVersionID = 0;
+	sal_uInt32 nHeaderSize = 0;
+
+	if ( LwpFileHeader::m_nFileRevision < 0x000B)
+	{
+		rStrm.Read(&m_nTag, sizeof(m_nTag));
+		m_ID.Read(&rStrm);
+		rStrm.Read(&nVersionID, sizeof(nVersionID));
+		rStrm.Read(&nRefCount, sizeof(nRefCount));
+		rStrm.Read(&nNextVersionOffset, sizeof(nNextVersionOffset));		
+
+		nHeaderSize = sizeof(m_nTag) + m_ID.DiskSize()
+			+ sizeof(nVersionID)
+			+ sizeof(nRefCount)
+			+ sizeof(nNextVersionOffset)
+			+ sizeof(m_nSize);
+
+		if ((m_nTag == TAG_AMI) || ( LwpFileHeader::m_nFileRevision < 0x0006))
+		{
+			rStrm.Read(&nNextVersionID, sizeof(nNextVersionID));				
+			nHeaderSize += sizeof(nNextVersionID);
+		}
+		rStrm.Read(&m_nSize, sizeof(m_nSize));		
+	}
+	else
+	{
+		sal_uInt16 VOType = 0;
+		rStrm.Read(&VOType, sizeof(VOType));		
+		rStrm.Read(&nFlagBits, sizeof(nFlagBits));				
+
+		m_nTag = static_cast<sal_uInt32>(VOType);
+		m_ID.ReadIndexed(&rStrm);
+		nHeaderSize = sizeof(VOType) + sizeof(nFlagBits) + m_ID.DiskSizeIndexed();
+
+		sal_uInt8 tmpByte;
+		sal_uInt16 tmpShort;
+		switch (nFlagBits & VERSION_BITS)
+		{
+			case ONE_BYTE_VERSION:
+				rStrm.Read(&tmpByte, sizeof(tmpByte));
+				nVersionID = static_cast<sal_uInt32>( tmpByte );
+				nHeaderSize++;
+				break;
+
+			case TWO_BYTE_VERSION:
+				rStrm.Read(&tmpShort, sizeof(tmpShort));
+				nVersionID = static_cast<sal_uInt32>( tmpShort );
+				nHeaderSize += 2;
+				break;
+
+			case FOUR_BYTE_VERSION:
+				rStrm.Read(&nVersionID, sizeof(nVersionID));				
+				nHeaderSize += 4;
+				break;
+			case DEFAULT_VERSION:	//fall through
+			default:
+				nVersionID = 2;
+				break;		// nothing				
+		}
+
+		switch (nFlagBits & REFCOUNT_BITS)
+		{
+			case ONE_BYTE_REFCOUNT:
+				rStrm.Read(&tmpByte, sizeof(tmpByte));
+				nRefCount = static_cast<sal_uInt32>( tmpByte );
+				nHeaderSize++;
+				break;
+
+			case TWO_BYTE_REFCOUNT:
+				rStrm.Read(&tmpShort, sizeof(tmpShort));
+				nRefCount = static_cast<sal_uInt32>( tmpShort );
+				nHeaderSize += 2;
+				break;
+
+			case FOUR_BYTE_REFCOUNT:	//through
+			default:
+				rStrm.Read(&nRefCount, sizeof(nRefCount));				
+				nHeaderSize += 4;
+				break;
+		}
+
+		if (nFlagBits & HAS_PREVOFFSET)
+		{
+			rStrm.Read(&nNextVersionOffset, sizeof(nNextVersionOffset));		
+			nHeaderSize += 4;
+		}
+		else
+			nNextVersionOffset = BAD_OFFSET;
+
+		switch (nFlagBits & SIZE_BITS)
+		{
+			case ONE_BYTE_SIZE:
+				rStrm.Read(&tmpByte, sizeof(tmpByte));
+				m_nSize = static_cast<sal_uInt32>( tmpByte );
+				nHeaderSize++;
+				break;
+
+			case TWO_BYTE_SIZE:
+				rStrm.Read(&tmpShort, sizeof(tmpShort));
+				m_nSize = static_cast<sal_uInt32>(tmpShort);	
+				nHeaderSize += 2;
+				break;
+
+			case FOUR_BYTE_SIZE:	//go through
+			default:
+				rStrm.Read(&m_nSize, sizeof(m_nSize));				
+				nHeaderSize += 4;
+				break;
+		}
+
+		if (nFlagBits & DATA_COMPRESSED)
+		{
+			m_bCompressed = sal_True;
+		}
+	}
+}
diff -urNp lotuswordpro.bak/source/filter/lwpobjhdr.hxx lotuswordpro/source/filter/lwpobjhdr.hxx
--- lotuswordpro.bak/source/filter/lwpobjhdr.hxx	1970-01-01 08:00:00.000000000 +0800
+++ lotuswordpro/source/filter/lwpobjhdr.hxx	2008-10-22 11:42:29.000000000 +0800
@@ -0,0 +1,137 @@
+/*************************************************************************
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: IBM Corporation
+ *
+ *  Copyright: 2008 by IBM Corporation
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+/*************************************************************************
+ * @file 
+ *  For LWP filter architecture prototype
+ ************************************************************************/
+/*************************************************************************
+ * Change History
+ Jan 2005			Created
+ ************************************************************************/
+
+
+#ifndef _LWPOBJECTHEADER_HXX
+#define _LWPOBJECTHEADER_HXX
+
+#include "lwpobjid.hxx"
+#include "lwpobjtags.hxx"
+/**
+ * @brief	Base class of all Lwp VO objects
+*/
+class LwpObjectHeader
+{
+public:
+	LwpObjectHeader();
+private:
+	sal_uInt32 m_nTag;
+	LwpObjectID m_ID;
+	sal_uInt32 m_nSize;		//Data size
+	sal_Bool m_bCompressed;
+
+	//localize the following memebers to save memory
+	//sal_uInt8 m_nFlagBits;
+	//sal_uInt32 m_nVersionID;
+	//sal_uInt32 m_nRefCount;
+	//sal_uInt32 m_nNextVersionOffset;
+	//sal_uInt32 m_nNextVersionID;
+	//sal_uInt32 m_nHeaderSize;
+
+	enum
+	{
+		VERSION_BITS			= 0x03,
+		DEFAULT_VERSION			= 0x00,
+		ONE_BYTE_VERSION		= 0x01,
+		TWO_BYTE_VERSION		= 0x02,
+		FOUR_BYTE_VERSION		= 0x03,
+
+		REFCOUNT_BITS			= 0x0C,
+		ONE_BYTE_REFCOUNT		= 0x04,
+		TWO_BYTE_REFCOUNT		= 0x08,
+		FOUR_BYTE_REFCOUNT		= 0x0C,
+
+		SIZE_BITS				= 0x30,
+		ONE_BYTE_SIZE			= 0x10,
+		TWO_BYTE_SIZE			= 0x20,
+		FOUR_BYTE_SIZE			= 0x30,
+
+		HAS_PREVOFFSET			= 0x40,
+		DATA_COMPRESSED		= 0x80
+	};
+
+public:
+	void Read(LwpSvStream &pStrm);
+	inline sal_uInt32 GetTag();
+	inline sal_uInt32 GetSize();
+	inline LwpObjectID* GetID();
+	inline sal_Bool IsCompressed();
+};
+
+inline sal_uInt32 LwpObjectHeader::GetTag()
+{
+	return m_nTag;
+}
+inline sal_uInt32 LwpObjectHeader::GetSize()
+{
+	return m_nSize;
+}
+inline LwpObjectID* LwpObjectHeader::GetID()
+{
+	return &m_ID;
+}
+inline sal_Bool LwpObjectHeader::IsCompressed()
+{
+	return m_bCompressed;
+}
+#endif
diff -urNp lotuswordpro.bak/source/filter/lwpobj.hxx lotuswordpro/source/filter/lwpobj.hxx
--- lotuswordpro.bak/source/filter/lwpobj.hxx	1970-01-01 08:00:00.000000000 +0800
+++ lotuswordpro/source/filter/lwpobj.hxx	2008-10-22 11:42:29.000000000 +0800
@@ -0,0 +1,105 @@
+/*************************************************************************
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: IBM Corporation
+ *
+ *  Copyright: 2008 by IBM Corporation
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+/*************************************************************************
+ * Change History
+ Jan 2005			Created
+ ************************************************************************/
+ /**
+ * @file 
+ *  Base class of all Lwp VO objects
+ */
+
+#ifndef _LWPOBJ_HXX_
+#define _LWPOBJ_HXX_
+
+#include "lwpheader.hxx"
+
+#include "lwpobjhdr.hxx"
+#include "lwpobjstrm.hxx"
+#include "lwpunoheader.hxx"
+#include "xfilter/ixfstream.hxx"
+#include "xfilter/xfcontentcontainer.hxx"
+
+class LwpFoundry;
+/**
+ * @brief	Base class of all Lwp VO objects
+*/
+class LwpObject
+{
+private:
+	LwpObject();//Don't permit to create an object without header
+public:
+	LwpObject(LwpObjectHeader objHdr, LwpSvStream* pStrm);	
+	virtual ~LwpObject();
+protected:
+	LwpObjectHeader m_ObjHdr;
+	LwpObjectStream* m_pObjStrm;
+	LwpFoundry* m_pFoundry;
+	LwpSvStream* m_pStrm;
+protected:
+	virtual void Read();
+public:
+	void QuickRead();
+	virtual void RegisterStyle();
+	virtual void Parse(IXFStream* pOutputStream);
+	virtual void XFConvert(XFContentContainer* pCont);
+
+	LwpFoundry* GetFoundry(){return m_pFoundry;}
+	void SetFoundry(LwpFoundry* pFoundry){m_pFoundry = pFoundry;}
+	LwpObjectID* GetObjectID(){ return m_ObjHdr.GetID();}
+	sal_uInt32 GetTag() { return m_ObjHdr.GetTag();}
+	LwpSvStream* GetStream() { return m_pStrm; }
+};
+#endif
diff -urNp lotuswordpro.bak/source/filter/lwpobjid.cxx lotuswordpro/source/filter/lwpobjid.cxx
--- lotuswordpro.bak/source/filter/lwpobjid.cxx	1970-01-01 08:00:00.000000000 +0800
+++ lotuswordpro/source/filter/lwpobjid.cxx	2008-10-22 11:42:29.000000000 +0800
@@ -0,0 +1,256 @@
+/*************************************************************************
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: IBM Corporation
+ *
+ *  Copyright: 2008 by IBM Corporation
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+/*************************************************************************
+ * @file 
+ *  For LWP filter architecture prototype
+ ************************************************************************/
+/*************************************************************************
+ * Change History
+ Jan 2005			Created
+ ************************************************************************/
+
+
+#ifndef _LWPOBJECTID_HXX
+#include "lwpobjid.hxx"
+#endif
+
+#include "lwpfilehdr.hxx"
+#include "lwpobjfactory.hxx"
+#include "lwpglobalmgr.hxx"
+
+LwpObjectID::LwpObjectID(sal_uInt32 low, sal_uInt16 high)
+	:m_nLow(low), m_nHigh(high), m_bIsCompressed(sal_False), m_nIndex(0)
+{
+}
+/**
+ * @descr		Read object id with format: low(4bytes)+high(2bytes) from stream
+ *			for LWP7 record
+*/
+sal_uInt32 LwpObjectID::Read(LwpSvStream *pStrm)
+{
+	pStrm->Read(&m_nLow, sizeof(m_nLow));
+	pStrm->Read(&m_nHigh, sizeof(m_nHigh));
+	return DiskSize();
+}
+/**
+ * @descr		Read object id with format: low(4bytes)+high(2bytes) from object stream
+*/
+sal_uInt32 LwpObjectID::Read(LwpObjectStream *pObj)
+{
+	pObj->QuickRead(&m_nLow, sizeof(m_nLow));
+	pObj->QuickRead(&m_nHigh, sizeof(m_nHigh));
+	return DiskSize();
+}
+/**
+ * @descr		Read object id with indexed format from stream
+ *			if index>0, lowid is get from time table per the index
+*			else	index+lowid+highid
+*/
+sal_uInt32 LwpObjectID::ReadIndexed(LwpSvStream *pStrm)
+{
+//note the m_nLow store the index instead of time from the timetable as in LWP
+	m_bIsCompressed = sal_False;
+	if( LwpFileHeader::m_nFileRevision < 0x000B)	
+	{
+		return Read(pStrm);
+	}
+
+	pStrm->Read(&m_nIndex, sizeof(m_nIndex));
+
+	if (m_nIndex)
+	{
+		m_bIsCompressed = sal_True;
+		//m_nLow = index;		//note the m_nLow stores the index instead of the actual time id
+		LwpGlobalMgr* pGlobal = LwpGlobalMgr::GetInstance();
+		LwpObjectFactory* pFactory = pGlobal->GetLwpObjFactory();
+		LwpIndexManager* pIdxMgr = pFactory->GetIndexManager();
+		m_nLow =  pIdxMgr->GetObjTime( (sal_uInt16)m_nIndex);
+	}
+	else
+	{
+		pStrm->Read(&m_nLow, sizeof(m_nLow));
+	}
+	pStrm->Read(&m_nHigh, sizeof(m_nHigh));
+	return DiskSizeIndexed();
+}
+
+/**
+ * @descr		Read object id with indexed format from object stream
+ *			if index>0, lowid is get from time table per the index
+*			else	index+lowid+highid
+*/
+sal_uInt32 LwpObjectID::ReadIndexed(LwpObjectStream *pStrm)
+{
+	m_bIsCompressed = sal_False;
+	if(LwpFileHeader::m_nFileRevision < 0x000B)	
+	{
+		return Read(pStrm);
+	}
+
+	pStrm->QuickRead(&m_nIndex, sizeof(m_nIndex));
+	if (m_nIndex)
+	{
+		m_bIsCompressed = sal_True;
+		//m_nLow = index;		//note the m_nLow stores the index instead of the actual time id
+		LwpGlobalMgr* pGlobal = LwpGlobalMgr::GetInstance();
+		LwpObjectFactory* pFactory = pGlobal->GetLwpObjFactory();
+		LwpIndexManager* pIdxMgr = pFactory->GetIndexManager();
+		m_nLow =  pIdxMgr->GetObjTime( (sal_uInt16)m_nIndex);
+	}
+	else
+	{
+		 pStrm->QuickRead(&m_nLow, sizeof(m_nLow));
+	}
+	pStrm->QuickRead(&m_nHigh, sizeof(m_nHigh));
+	return DiskSizeIndexed();
+}
+/**
+ * @descr		Read object id with compressed format from stream
+ *			if diff == 255: 255+lowid+highid
+ *			else	lowid equals to the lowid of previous low id
+ * 				and high id = the high id of previous id + diff +1
+*/
+sal_uInt32 LwpObjectID::ReadCompressed( LwpSvStream* pStrm, LwpObjectID &prev )
+{
+	sal_uInt32 len=0;
+	sal_uInt8 diff;
+
+	len = pStrm->Read( &diff, sizeof(diff));
+	if (diff == 255)
+	{
+		len += Read(pStrm);
+	}
+	else
+	{
+		m_nLow = prev.GetLow();
+		m_nHigh = prev.GetHigh() + diff +1;
+	}
+	return len;
+}
+/**
+ * @descr		Read object id with compressed format from object stream
+ *			if diff == 255: 255+lowid+highid
+ *			else	lowid equals to the lowid of previous low id
+ * 				and high id = the high id of previous id + diff +1
+*/
+sal_uInt32 LwpObjectID::ReadCompressed( LwpObjectStream* pObj, LwpObjectID &prev )
+{
+
+	sal_uInt32 len=0;
+	sal_uInt8 diff;
+
+	len += pObj->QuickRead( &diff, sizeof(diff));
+	
+	if (diff == 255)
+	{
+		len += Read(pObj);
+	}
+	else
+	{
+		m_nLow = prev.GetLow();
+		m_nHigh = prev.GetHigh() + diff +1;
+	}
+	return len;
+}
+/**
+ * @descr		return the size of indexed object id
+*/
+sal_uInt32 LwpObjectID::DiskSizeIndexed() const
+{
+	return sizeof(sal_uInt8)
+		+ (((0 < m_nIndex) && (m_nIndex <= 255)) ? 0 : sizeof(m_nLow))
+		+ sizeof(m_nHigh);
+}
+/**
+ * @descr		return the size of object id with format: low(4bytes)+high(2bytes)
+*/
+sal_uInt32 LwpObjectID::DiskSize() const
+{
+	return sizeof(m_nLow) + sizeof(m_nHigh);
+}
+/**
+ * @descr		get object from object factory per the object id
+*/
+LwpObject* LwpObjectID::obj(VO_TYPE tag) const
+{
+	LwpGlobalMgr* pGlobal = LwpGlobalMgr::GetInstance();
+	LwpObjectFactory* pObjMgr = pGlobal->GetLwpObjFactory();
+	if(IsNull())
+	{
+		return NULL;
+	}
+	LwpObject* pObj = pObjMgr->QueryObject(*this);
+	if( tag!=VO_INVALID &&  (pObj) )
+	{
+		if(tag!=pObj->GetTag()) 
+		{
+			pObj=NULL;
+		}
+	}
+	return(pObj); 
+}
+/**
+ * @descr		returns a buffer that contains the highid + lowid
+ */
+sal_Char* LwpObjectID::GetBuffer(sal_Char *buf)
+{
+	buf[0] = m_nHigh && 0xFF00;
+	buf[1] = m_nHigh && 0x00FF;
+	buf[2] = m_nLow && 0xFF000000;
+	buf[3] = m_nLow && 0x00FF0000;
+	buf[4] = m_nLow && 0x0000FF00;
+	buf[5] = m_nLow && 0x000000FF;
+	return buf;
+}
diff -urNp lotuswordpro.bak/source/filter/lwpobjid.hxx lotuswordpro/source/filter/lwpobjid.hxx
--- lotuswordpro.bak/source/filter/lwpobjid.hxx	1970-01-01 08:00:00.000000000 +0800
+++ lotuswordpro/source/filter/lwpobjid.hxx	2008-10-22 11:42:29.000000000 +0800
@@ -0,0 +1,159 @@
+/*************************************************************************
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: IBM Corporation
+ *
+ *  Copyright: 2008 by IBM Corporation
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+/*************************************************************************
+ * @file 
+ *  For LWP filter architecture prototype
+ ************************************************************************/
+/*************************************************************************
+ * Change History
+ Jan 2005			Created
+ ************************************************************************/
+
+#ifndef _LWPOBJECTID_HXX
+#define _LWPOBJECTID_HXX
+
+#include "lwpheader.hxx"
+#include "lwpobjstrm.hxx"
+#include "lwpdefs.hxx"
+
+class LwpObject;
+
+/**
+ * @brief	object id class
+*/
+class LwpObjectID
+{
+public:	
+	LwpObjectID(sal_uInt32 low=0, sal_uInt16 high=0);
+private:
+	sal_uInt32 m_nLow;
+	sal_uInt16 m_nHigh;
+	sal_uInt8 m_nIndex;
+	sal_Bool m_bIsCompressed;	
+public:
+	sal_uInt32  Read( LwpSvStream *pStrm );
+	sal_uInt32 Read( LwpObjectStream *pStrm );
+	sal_uInt32 ReadIndexed( LwpSvStream* pStrm );
+	sal_uInt32 ReadIndexed( LwpObjectStream *pStrm );
+	sal_uInt32 ReadCompressed( LwpSvStream* pStrm, LwpObjectID &prev );
+	sal_uInt32 ReadCompressed( LwpObjectStream* pObj, LwpObjectID& prev );
+	
+	sal_uInt32 DiskSize() const;
+	sal_uInt32 DiskSizeIndexed() const;
+	BOOL IsNull() const;
+	sal_Bool IsCompressed();
+
+	sal_uInt32 GetLow() const ;
+	sal_uInt16 GetHigh() const ;
+	void SetLow(sal_uInt32 nl);
+	void SetHigh(sal_uInt16 nh);
+
+	BOOL operator == (const LwpObjectID &Other) const;
+	BOOL operator != (const LwpObjectID &Other) const;
+	sal_Char* GetBuffer(sal_Char* buf);
+	LwpObject* obj(VO_TYPE tag=VO_INVALID) const;
+	size_t HashCode() const;
+};
+
+inline BOOL LwpObjectID::IsNull() const
+{
+	return (m_nLow == 0) && (m_nHigh == 0);
+}
+
+inline BOOL LwpObjectID::operator == (const LwpObjectID &Other) const
+{
+	return (m_nHigh == Other.m_nHigh) && (m_nLow == Other.m_nLow);
+}
+
+inline BOOL LwpObjectID::operator != (const LwpObjectID &Other) const
+{
+	return (m_nHigh != Other.m_nHigh) || (m_nLow != Other.m_nLow);
+}
+
+inline sal_Bool LwpObjectID::IsCompressed()
+{ 
+	return m_bIsCompressed; 
+}
+inline sal_uInt32 LwpObjectID::GetLow() const 
+{
+	return m_nLow;
+}
+inline sal_uInt16 LwpObjectID::GetHigh() const 
+{
+	return m_nHigh;
+}
+inline void LwpObjectID::SetLow(sal_uInt32 nl) 
+{
+	m_nLow=nl;
+}
+inline void LwpObjectID::SetHigh(sal_uInt16 nh)
+{	
+	m_nHigh = nh;
+}
+inline size_t LwpObjectID::HashCode() const
+{
+	rtl::OUString str;
+	if(m_nIndex)
+	{
+		str = rtl::OUString(m_nIndex) + rtl::OUString(m_nHigh);
+	}
+	else
+	{
+		str = rtl::OUString(m_nLow) + rtl::OUString(m_nHigh);
+	}
+	return str.hashCode();
+}	
+
+#endif
diff -urNp lotuswordpro.bak/source/filter/lwpobjstrm.cxx lotuswordpro/source/filter/lwpobjstrm.cxx
--- lotuswordpro.bak/source/filter/lwpobjstrm.cxx	1970-01-01 08:00:00.000000000 +0800
+++ lotuswordpro/source/filter/lwpobjstrm.cxx	2008-10-22 11:42:29.000000000 +0800
@@ -0,0 +1,371 @@
+/*************************************************************************
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: IBM Corporation
+ *
+ *  Copyright: 2008 by IBM Corporation
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+/*************************************************************************
+ * Change History
+ Jan 2005			Created
+ ************************************************************************/
+
+#include "lwpobjstrm.hxx"
+#include "lwptools.hxx"
+
+/**
+ * @descr  ctor() from LwpSvStream
+ */
+LwpObjectStream::LwpObjectStream(LwpSvStream *pStrm, BOOL isCompressed, sal_uInt16 size)
+	:m_pContentBuf(NULL), m_nBufSize(size), m_nReadPos(0),
+	m_pStrm(pStrm), m_bCompressed(isCompressed)
+{
+	assert(size<IO_BUFFERSIZE);
+	ReadStream();
+}
+/**
+ * @descr  read object data from stream
+ */
+void LwpObjectStream::ReadStream()
+{
+	if(m_nBufSize == 0)
+	{
+		m_pContentBuf = NULL;
+	}
+	else 
+	{
+		Read2Buffer();
+	}
+}
+/**
+ * @descr  read object data from stream to buffer
+ */
+void LwpObjectStream::Read2Buffer()
+{
+	if( m_pContentBuf ) 
+	{
+		ReleaseBuffer();
+	}
+
+	m_nReadPos = 0;
+	
+	if( m_bCompressed )
+	{
+		sal_uInt8* pCompressBuffer = new sal_uInt8[m_nBufSize];
+		m_pStrm->Read(pCompressBuffer, m_nBufSize);
+
+		sal_uInt8 pTempDst[IO_BUFFERSIZE];
+		m_nBufSize = DecompressBuffer(pTempDst, pCompressBuffer, m_nBufSize);
+		assert( m_nBufSize < IO_BUFFERSIZE);
+		delete [] pCompressBuffer;
+		pCompressBuffer = NULL;
+
+		m_pContentBuf = AllocBuffer(m_nBufSize);
+		memcpy(m_pContentBuf, pTempDst, m_nBufSize);
+		//delete [] pTempDst;
+		
+	}
+	else
+	{
+		m_pContentBuf = AllocBuffer(m_nBufSize);
+		m_pStrm->Read(m_pContentBuf, m_nBufSize);
+	}	
+}
+/**
+ * @descr  alloc size of buffer
+ */
+sal_uInt8* LwpObjectStream::AllocBuffer(sal_uInt16 size)
+{
+	if(size<=100)
+	{
+		return(m_SmallBuffer);
+	}
+	else
+	{
+		return (new sal_uInt8[size]);
+	}
+}
+/**
+ * @descr  signal complete to release object buffer
+ */
+void LwpObjectStream::ReadComplete()
+{
+	ReleaseBuffer();
+}
+
+LwpObjectStream::~LwpObjectStream()
+{
+	ReleaseBuffer();
+}
+/**
+ * @descr  release object buffer
+ */
+void LwpObjectStream::ReleaseBuffer()
+{
+	
+	if(m_nBufSize>100)
+	{
+		if(m_pContentBuf)
+		{
+			delete [] m_pContentBuf;
+			m_pContentBuf = NULL;
+		}
+	}
+}
+/**
+ * @descr  read len bytes from object stream to buffer
+ */
+sal_uInt16 LwpObjectStream::QuickRead(void* buf, sal_uInt16 len)
+{
+	if( len > m_nBufSize - m_nReadPos )
+	{
+		assert(false);
+		len = m_nBufSize - m_nReadPos;
+	}
+	if( m_pContentBuf && len) 
+	{
+		memcpy(buf, m_pContentBuf+m_nReadPos, len);
+		m_nReadPos += len;
+	}
+	return len;
+}
+/**
+ * @descr  SeekRel pos in object stream/buffer
+ */
+void LwpObjectStream::SeekRel(sal_uInt16 pos)
+{
+	if( pos > m_nBufSize - m_nReadPos) 
+		pos = m_nBufSize - m_nReadPos;
+	m_nReadPos +=pos;
+}
+/**
+ * @descr  Seek to pos in object buffer/buffer
+ */
+BOOL LwpObjectStream::Seek( sal_uInt16 pos) 
+{ 
+	if(pos>=0 && pos<m_nBufSize)
+	{
+		m_nReadPos = pos; 
+		return TRUE;
+	}
+	return FALSE;
+}
+
+/**
+ * @descr  Quick read sal_Bool
+ */
+sal_Bool LwpObjectStream::QuickReadBool()
+{
+	sal_uInt16 nValue;
+	QuickRead(&nValue, 2);
+	return (sal_Bool)(nValue != 0);
+}
+/**
+ * @descr  Quick read sal_uInt32
+ */
+sal_uInt32 LwpObjectStream::QuickReaduInt32()
+{
+	sal_uInt32 nValue;
+	QuickRead(&nValue, sizeof(nValue));
+	return nValue;
+}
+/**
+ * @descr  Quick read sal_uInt32
+ */
+sal_uInt16 LwpObjectStream::QuickReaduInt16()
+{
+	sal_uInt16 nValue;
+	QuickRead(&nValue, sizeof(nValue));
+	return nValue;
+}
+/**
+ * @descr  Quick read sal_Int32
+ */
+sal_Int32 LwpObjectStream::QuickReadInt32()
+{
+	sal_Int32 nValue;
+	QuickRead(&nValue, sizeof(nValue));
+	return nValue;
+}
+/**
+ * @descr  Quick read sal_Int16
+ */
+sal_Int16 LwpObjectStream::QuickReadInt16()
+{
+	sal_Int16 nValue;
+	QuickRead(&nValue, sizeof(nValue));
+	return nValue;
+}
+/**
+ * @descr  Quick read sal_Int8
+ */
+sal_Int8 LwpObjectStream::QuickReadInt8()
+{
+	sal_Int8 nValue;
+	QuickRead(&nValue, sizeof(nValue));
+	return nValue;
+}
+/**
+ * @descr  Quick read sal_uInt8
+ */
+sal_uInt8 LwpObjectStream::QuickReaduInt8()
+{
+	sal_uInt8 nValue;
+	QuickRead(&nValue, sizeof(nValue));
+	return nValue;
+}
+/**
+ * @descr  skip extra bytes
+ */
+void LwpObjectStream::SkipExtra()
+{
+	sal_uInt16 extra;
+
+	QuickRead(&extra, sizeof(extra));
+	while (extra != 0)
+	{
+		assert(false);
+		QuickRead(&extra, sizeof(extra));
+	}
+}
+/**
+ * @descr  check if extra bytes
+ */
+sal_uInt16 LwpObjectStream::CheckExtra()
+{
+	sal_uInt16 extra;
+	QuickRead(&extra, sizeof(extra));
+	return extra;
+}
+/**
+ * @descr  decompress data buffer from pSrc to pDst
+ * 		  Refer to the CAmiPro40File::DecompressObject(~) in LWP
+ */
+sal_uInt16 LwpObjectStream::DecompressBuffer(sal_uInt8* pDst, sal_uInt8* pSrc, sal_uInt16 Size)
+{
+	sal_uInt16 Cnt;
+	sal_uInt32 DstSize = 0;
+
+	while (Size)
+	{
+		switch (*pSrc & 0xC0)
+		{
+			case 0x00:
+				// 1 - 64 bytes of 0
+				// Code 00zzzzzz
+				// where zzzzzz is the count - 1 of compressed 0 bytes
+
+				Cnt = (*pSrc++ & 0x3F) + 1;
+				memset(pDst, 0, Cnt);
+				pDst += Cnt;
+				DstSize += Cnt;
+				Size--;
+				break;
+
+			case 0x40:
+				// 1 - 8 zeros followed by 1 - 8 non-zero
+				// Code 01zzznnn binary
+				// where zzz is the count - 1 of compressed zero bytes
+				// and nnn is the count - 1 of following non-zero bytes
+
+				Cnt = ((*pSrc & 0x38) >> 3) + 1;
+				memset(pDst, 0, Cnt);
+				pDst += Cnt;
+				DstSize += Cnt;
+				Cnt = (*pSrc++ & 0x07) + 1;
+				memcpy(pDst, pSrc, Cnt);
+				pDst += Cnt;
+				DstSize += Cnt;
+				pSrc += Cnt;
+				Size -= Cnt + 1;
+				break;
+
+			case 0x80:
+				// 1 0 followed by 1 - 64 bytes of non-zero
+				// Code 0x80 (or 0x40 if 8 or less non-zero)
+				// Code 10nnnnnn binary
+				// where nnnnnn is the count - 1 of following non-zero bytes
+
+				*pDst++ = 0;
+				DstSize++;
+				// fall thru into next case!
+
+			case 0xC0:
+				// 1 - 64 bytes of non-zero
+				// Code = 11nnnnnn binary
+				// nnnnnn is the count less 1 of following non-zero bytes
+
+				Cnt = (*pSrc++ & 0x3F) + 1;
+				memcpy(pDst, pSrc, Cnt);
+				pDst += Cnt;
+				DstSize += Cnt;
+				pSrc += Cnt;
+				Size -= Cnt + 1;
+				break;
+		}
+		assert(DstSize < IO_BUFFERSIZE);
+	}
+	return(static_cast<sal_uInt16>(DstSize));
+}
+/**
+ * @descr  quick read string with 1252
+ */
+OUString LwpObjectStream::QuickReadStringPtr(void)
+{
+	sal_uInt16 len, diskSize;
+
+	diskSize = QuickReaduInt16();
+	len = QuickReaduInt16();
+
+	OUString str;
+	rtl_TextEncoding rEncode =  RTL_TEXTENCODING_MS_1252;
+	LwpTools::QuickReadUnicode(this, str, diskSize-sizeof(diskSize), rEncode);	
+	return str;
+}
diff -urNp lotuswordpro.bak/source/filter/lwpobjstrm.hxx lotuswordpro/source/filter/lwpobjstrm.hxx
--- lotuswordpro.bak/source/filter/lwpobjstrm.hxx	1970-01-01 08:00:00.000000000 +0800
+++ lotuswordpro/source/filter/lwpobjstrm.hxx	2008-10-22 11:42:29.000000000 +0800
@@ -0,0 +1,127 @@
+/*************************************************************************
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: IBM Corporation
+ *
+ *  Copyright: 2008 by IBM Corporation
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+/*************************************************************************
+ * @file 
+ *  object stream header file
+ *  stream for one LwpObject body data
+ ************************************************************************/
+/*************************************************************************
+ * Change History
+ Jan 2005			Created
+ ************************************************************************/
+
+#ifndef _LWPOBJECTSTREAM_HXX
+#define _LWPOBJECTSTREAM_HXX
+
+#include "lwpheader.hxx"
+#include "lwpsvstream.hxx"
+/**
+ * @brief	stream class for LwpObject body data
+ *  		provide stream like interface to read object data
+*/
+class LwpObjectStream
+{
+public:
+	LwpObjectStream(LwpSvStream *pStrm, BOOL isCompressed, sal_uInt16 size);
+	~LwpObjectStream();
+private:
+	sal_uInt8* m_pContentBuf;			//The content buffer of the object
+	sal_uInt8 m_SmallBuffer[100];		//To avoid frequent new
+	enum
+	{
+		IO_BUFFERSIZE = 0xFF00		//Refer to LWP, not sure if it is enough
+	};
+	sal_uInt16 m_nBufSize;				//The total size of m_pContentBuf
+	sal_uInt16 m_nReadPos;			//The position of the quick read
+	LwpSvStream* m_pStrm;
+	BOOL m_bCompressed;
+public:
+	sal_uInt16 QuickRead(void* buf, sal_uInt16 len);
+	sal_uInt16 GetPos() { return m_nReadPos; }
+	void SeekRel(sal_uInt16 pos);
+	BOOL Seek( sal_uInt16 pos);
+	void SkipExtra();
+	sal_uInt16 CheckExtra();
+
+	//01/14/2005
+	sal_Bool QuickReadBool();
+	sal_uInt32 QuickReaduInt32();
+	sal_uInt16 QuickReaduInt16();
+	sal_uInt8 QuickReaduInt8();	
+	sal_Int32 QuickReadInt32();
+	sal_Int16 QuickReadInt16();
+	sal_Int8 QuickReadInt8();	
+	//end
+
+	OUString QuickReadStringPtr(void);
+	//void QuickReadString(unsigned char *pString, sal_uInt16 len);
+	void QuickReadStringWithMax(unsigned char * pString, sal_uInt16 MaxLen);
+
+public:
+	void ReadComplete();
+	LwpSvStream *GetStream();
+private:
+	void ReadStream();
+	void Read2Buffer();
+	sal_uInt8* AllocBuffer(sal_uInt16 size);
+	sal_uInt16 DecompressBuffer(sal_uInt8* pDst, sal_uInt8* pSrc, sal_uInt16 Size);
+	void ReleaseBuffer();
+};
+
+inline LwpSvStream *LwpObjectStream::GetStream()
+{ 
+	return m_pStrm; 
+}
+#endif
diff -urNp lotuswordpro.bak/source/filter/lwpobjtags.hxx lotuswordpro/source/filter/lwpobjtags.hxx
--- lotuswordpro.bak/source/filter/lwpobjtags.hxx	1970-01-01 08:00:00.000000000 +0800
+++ lotuswordpro/source/filter/lwpobjtags.hxx	2008-10-22 11:42:29.000000000 +0800
@@ -0,0 +1,241 @@
+/*************************************************************************
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: IBM Corporation
+ *
+ *  Copyright: 2008 by IBM Corporation
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+#ifndef _LWPOBJTAGS_HXX_
+#define _LWPOBJTAGS_HXX_
+
+// file header object
+#define TAG_AMI				0x3750574CUL		// "LWP7"
+
+// layout sub-objects
+#define TAG_ENDSUBOBJ		0x646E4553UL		// "SEnd"
+#define TAG_LAY_GEOMETRY	0x6F65474CUL		// "LGeo"
+#define TAG_LAY_OFFSET		0x66664F4CUL		// "LOff"
+#define TAG_LAY_SCALE		0x6C63534CUL		// "LScl"
+#define TAG_LAY_MARGINS		0x72614D4CUL		// "LMar"
+#define TAG_LAY_RELATIVITY	0x6C65524CUL		// "LRel"
+#define TAG_LAY_COLUMNS		0x6C6F434CUL		// "LCol"
+#define TAG_LAY_BORDER		0x726F424CUL		// "LBor"
+#define TAG_LAY_GUTTER		0x7475474CUL		// "LGut"
+#define TAG_LAY_JOIN		0x696F4A4CUL		// "LJoi"
+#define TAG_LAY_BACKGROUND	0x6B63424CUL		// "LBck"
+#define TAG_LAY_SHADOW		0x7764534CUL		// "LSdw"
+#define TAG_LAY_LEADERDOTS	0x72644C4CUL		// "LLdr"
+#define TAG_LAY_NUMERICS	0x6D754E4CUL		// "LNum"
+#define TAG_LAY_HIERARCHY	0x6569484CUL		// "LHie"
+
+// Paragraph properties
+#define TAG_PARA_SHOW		0x65644850UL		// "PHde"
+#define TAG_PARA_HIDE		0x77685350UL		// "PShw"
+#define TAG_PARA_ALIGN		0x6e6c4150UL		// "PAln"
+#define TAG_PARA_INDENT		0x74644950UL		// "PIdt"
+#define TAG_PARA_SPACING	0x63705350UL		// "PSpc"
+#define TAG_PARA_BORDER		0x64724250UL		// "PBrd"
+#define TAG_PARA_BACKGROUND	0x6b614250UL		// "PBak"
+#define TAG_PARA_BREAKS		0x6b724250UL		// "PBrk"
+#define TAG_PARA_BULLET		0x746c4250UL		// "PBlt"
+#define TAG_PARA_NUMBERING	0x6d754e50UL		// "PNum"
+#define TAG_PARA_TAB		0x62615450UL		// "PTab"
+#define TAG_PARA_KINSOKU	0x6e694b50UL		// "PKin"
+#define TAG_PARA_PROPLIST	0x70725050UL		// "PPrp"
+
+#define TAG_SLVLIST			0x734C4C53UL		// "SLLs"
+#define TAG_DLFVLIST		0x4C464C44UL		// "DLFL"
+#define TAG_DLVLISTHEAD		0x64484C44UL		// "DLHd"
+#define TAG_DLNFVLIST		0x464E4C44UL		// "DLNF"
+#define TAG_DLVLIST			0x734C4C44UL		// "DLLs"
+
+#define TAG_DOCUMENT		0x20636F44UL		// "Doc "
+#define TAG_VERDOCUMENT		0x636F4456UL		// "VDoc"
+#define TAG_DOCDATA			0x44636F44UL		// "DocD"
+#define TAG_OBJINDEX		0x78644E4FUL		// "ONdx"
+#define TAG_DIVISIONINFO	0x49766944UL		// "DivI"
+#define TAG_CONTENT			0x746E6F43UL		// "Cont"
+#define TAG_HEADCONTENT		0x746E4348UL		// "HCnt"
+#define TAG_STORY			0x79727453UL		// "Stry"
+#define TAG_TABLE			0x6C626154UL		// "Tabl"
+#define TAG_SUPERTABLE		0x62547553UL		// "SuTb"
+#define TAG_GLOSSARY		0x736F6C47UL		// "Glos"
+#define TAG_PARALLELCOLUMNS	0x6C6F4350UL		// "PCol"
+#define TAG_PARALLELCOLUMNSLAYOUT	0x794C4350UL	// "PCLy"
+#define TAG_PARALLELCOLUMNSBLOCK	0x6C424350UL	// "PCBl"
+#define TAG_PARALLELCOLUMNSCONNECTEDBLOCK	0x42434350UL	// "PCCB"
+#define TAG_FOOTNOTETABLE	0x62546E46UL		// "FnTb"
+#define TAG_PARAGRAPH		0x61726150UL		// "Para"
+#define TAG_BOOKMARK		0x6B4D6B42UL		// "BkMk"
+#define TAG_DDELINK			0x4C656444UL		// "DdeL"
+#define TAG_VIRTUALLAYOUT	0x79614C56UL		// "VLay"
+#define TAG_LITELAYOUT		0x79614C4CUL		// "LLay"
+#define TAG_LAYOUT			0x2079614CUL		// "Lay "
+#define TAG_PERMISSIVELAYOUT	0x79614C50UL	// "PLay"
+#define TAG_HEADLAYOUT		0x79614C48UL		// "HLay"
+#define TAG_FRAMELAYOUT		0x6D617246UL		// "Fram"
+#define TAG_DROPCAPLAYOUT	0x70614344UL		// "DCap"
+#define TAG_NOTELAYOUT		0x794C744EUL		// "NtLy"
+#define TAG_NOTETEXTLAYOUT	0x6C54744EUL		// "NtTl"
+#define TAG_NOTEHEADERLAYOUT 0x6C48744EUL		// "NtHl"
+#define TAG_PAGELAYOUT		0x65676150UL		// "Page"
+#define TAG_HEADERLAYOUT	0x4C726448UL		// "HdrL"
+#define TAG_FOOTERLAYOUT	0x4C727446UL		// "FtrL"
+#define TAG_ROWLAYOUT		0x4C776F52UL		// "RowL"
+#define TAG_COLUMNLAYOUT	0x4C6C6F43UL		// "ColL"
+#define TAG_FNROWLAYOUT		0x4C526E46UL		// "FnRL"
+#define TAG_CELLLAYOUT		0x4C6C6543UL		// "CelL"
+#define TAG_VIEWPORTLAYOUT	0x794C7056UL		// "VpLy"
+#define TAG_CONNECTEDCELLLAYOUT	0x4C436E43UL	// "CnCL"
+#define TAG_HIDDENCELLLAYOUT	0x4C436E48UL	// "HnCL"
+#define TAG_TABLEHEADINGLAYOUT	0x4C486254UL	// "TbHL"
+#define TAG_ROWHEADINGLAYOUT	0x4C486F52UL	// "RoHL"
+#define TAG_FNCELLLAYOUT	0x4C436E46UL		// "FnCL"
+#define TAG_FOOTNOTELAYOUT	0x794C6E46UL		// "FnLy"
+#define TAG_TABLELAYOUT		0x794C6254UL		// "TbLy"
+#define TAG_SUPERTABLELAYOUT	0x4C625453UL	// "STbL"
+#define TAG_FNSUPERTABLELAYOUT	0x4C545346UL	// "FSTL"
+#define TAG_ENSUPERTABLELAYOUT	0x4C545345UL	// "ESTL"
+#define TAG_SUPERPARALLELCOLUMNLAYOUT	0x4C435053UL	// "SPCL"
+#define TAG_SUPERGLOSSARYLAYOUT	0x534C4753UL	// "SGLS"
+#define TAG_CONTONLAYOUT	0x4C6E4F43UL		// "COnL"
+#define TAG_CONTFROMLAYOUT	0x4C724643UL		// "CFrL"
+#define TAG_CHARSTYLE		0x79745343UL		// "CSty"
+#define TAG_PARASTYLE		0x79745350UL		// "PSty"
+#define TAG_TABRACK			0x20626154UL		// "Tab "
+#define TAG_GROUPLAYOUT		0x4c707247UL		// "GrpL"
+#define TAG_GROUPFRAME		0x46707247UL		// "GrpF"
+#define TAG_SILVERBULLET	0x6c754253UL		// "SBul"
+#define TAG_TABLEHEADING 	0x486c6254UL		// "TblH"
+#define TAG_LINEHINT		0x746e484cUL		// "LHnt"
+#define TAG_TABLEHINT		0x746e4854UL		// "THnt"
+#define TAG_PAGEHINT		0x746e4850UL		// "PHnt"
+#define TAG_NUMBERHINT		0x746e484EUL		// "NHnt"
+#define TAG_FOOTNOTESEEN	0x65655346UL		// "FSee"
+#define TAG_OBJECTHOLDER	0x646c6F48UL		// "Hold"
+#define TAG_LISTLIST		0x744c744cUL		// "LtLt"
+#define TAG_FOOTNOTELISTLIST 0x744c7446UL		// "FtLt"
+#define TAG_ENDNOTELAYOUT	0x794C6E45UL		// "EnLy"
+#define TAG_FOOTNOTE		0x746F4E46UL		// "FNot"
+#define TAG_CELLNUMBERHINT	0x74486e43UL		// "CnHt"
+#define TAG_MARKER			0x6b72614DUL		// "Mark"
+#define TAG_STORYMARKER		0x6b724d53UL		// "SMrk"
+#define TAG_TABLEMARKER		0x6b724d54UL		// "TMrk"
+#define TAG_FIELDMARKER		0x4c724d54UL		// "FMrk"
+#define TAG_NUMERICVALUE	0x6c61564eUL		// "NVal"
+#define TAG_TEXTVALUE		0x6c615654UL		// "TVal"
+#define TAG_REFERENCEVALUE	0x6c615652UL		// "RVal"
+#define TAG_CELLLIST		0x64734c43UL		// "CLst"
+#define TAG_DEPENDENT		0x74647044UL		// "Dpdt"
+#define TAG_FORMULAINFO		0x616c7246UL		// "Frla"
+#define TAG_TABLERANGE		0x676e5254UL		// "TRng"
+#define TAG_CELLRANGE		0x676e5243UL		// "CRng"
+#define TAG_FOLDER			0x726c6446UL		// "Fldr"
+#define TAG_ROWLIST			0x74734c52UL		// "RLst"
+#define TAG_SECTION			0x74636553UL		// "Sect"
+#define TAG_INDEXSECTION	0x63657349UL		// "Isec"
+#define TAG_GRAPHIC			0x68707247UL		// "Grph"
+#define TAG_DIRTBAG			0x74726944UL		// "Dirt"
+#define TAG_NAMEDOUTLINESEQ	0x71534f4eUL		// "NOSq"
+#define TAG_OUTLINESEQITEM	0x7449534fUL		// "OSIt"
+#define TAG_TOCSUPERTABLELAYOUT	0x6C747354UL	// "Tstl"
+#define TAG_DOCSOCKET		0x786F5344UL		// "DSox"
+#define TAG_USER_VERSION	0x72655655UL		// "UVer"
+#define TAG_NOTE			0x65746F4EUL		// "Note"
+#define TAG_MARKERLIST		0x74734c4dUL		// "MLst"
+#define TAG_BOOKMARKMARKERLIST	0x744c4d42UL	// "BMLt"
+#define TAG_DDEMARKMARKERLIST	0x744c4d44UL	// "DMLt"
+#define TAG_FIELDMARKERLIST	0x744c6c46UL		// "FlLt"
+#define TAG_CHBLKMARKER		0x6b4d4843UL		// "CHMk"
+#define TAG_CHBMARKERLIST	0x424d4c43UL		// "CMLt"
+#define TAG_PPTRHOLDER		0x72745070UL		// "pPtr"
+#define TAG_QPTRHOLDER		0x72745071UL		// "qPtr"
+#define TAG_GPTRHOLDER		0x72745067UL		// "gPtr"
+#define TAG_PROPLIST		0x706f7250UL		// "Prop"
+#define TAG_HEADHOLDER		0x646C4848UL		// "HHld"
+#define TAG_HEADTAILHOLDER	0x72485448UL		// "HTHr"
+#define TAG_OLEOBJECT		0x4F656C4FUL		// "OleO"
+#define TAG_ENUMOBJHD		0x64484F45UL		// "EOHd"
+#define TAG_TOCLEVELDATA	0x4C6f6354UL		// "TocL"
+#define TAG_VERPTR			0x72745056UL		// "VPtr"
+#define TAG_VERQTR			0x72745156UL		// "VQtr"
+#define TAG_VERDOCINFO		0x6E494456UL		// "VDIn"
+#define TAG_TOMBSTONE		0x20504952UL		// "RIP "
+#define TAG_NOTIFY			0x7966744EUL		// "Ntfy"
+#define TAG_LONGHOLDER		0x676E6F4CUL		// "Long"
+
+#ifdef SMARTEXT
+#define TAG_STXINFO			0x6e495f53UL		// "S_In"
+#define TAG_STXMANAGER		0x674d5f53UL		// "S_Mg"
+#define TAG_STXLINK			0x6b4c5f53UL		// "S_Lk"
+#define TAG_STXLINKMARKERLIST	0x4c4d5f53UL		// "S_ML"
+#endif // SMARTEXT
+
+#define TAG_DIVOPTS			0x74704f44UL		// "DOpt"
+#define TAG_FOOTNOTEOPTS	0x704f4e46UL		// "FNOp"
+
+#ifdef RUBY
+#define TAG_RUBYLAYOUT		0x794C6252UL		// "RbLy"
+#define TAG_RUBYMARKER		0x6b724d52UL		// "RMrk"
+#define TAG_RUBYMARKERLIST	0x744c6252UL		// "RbLt"
+#endif
+
+#define TAG_ALIGNMENTPIECE			0x63506c41UL	// "AlPc"
+#define TAG_INDENTPIECE				0x63506e49UL	// "InPc"
+#define TAG_PARABORDERPIECE			0x63504250UL	// "PBPc"
+#define TAG_PARABACKGROUNDPIECE		0x63505250UL	// "PRPc"
+#define TAG_SPACINGPIECE			0x63507053UL	// "SpPc"
+#define TAG_BREAKSPIECE				0x63507242UL	// "BrPc"
+#define TAG_NUMBERINGPIECE			0x6350724eUL	// "NrPc"
+#define TAG_CHARBORDERPIECE			0x63504243UL	// "CBPc"
+#define TAG_AMIKAKEPIECE			0x63504b41UL	// "AKPc"
+#define TAG_TABPIECE				0x63506254UL	// "TbPc"
+
+#endif
diff -urNp lotuswordpro.bak/source/filter/lwpoleobject.cxx lotuswordpro/source/filter/lwpoleobject.cxx
--- lotuswordpro.bak/source/filter/lwpoleobject.cxx	1970-01-01 08:00:00.000000000 +0800
+++ lotuswordpro/source/filter/lwpoleobject.cxx	2008-10-22 11:47:28.000000000 +0800
@@ -0,0 +1,752 @@
+/*************************************************************************
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: IBM Corporation
+ *
+ *  Copyright: 2008 by IBM Corporation
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+/**
+ * @file 
+ *  For LWP filter architecture prototype - OLE object
+ */
+/*************************************************************************
+ * Change History
+ Feb 2005		 	Created
+ ************************************************************************/
+#include <stdio.h>
+#include <tools/stream.hxx>
+#include "lwpglobalmgr.hxx"
+#include "lwpoleobject.hxx"
+#include "lwpobjfactory.hxx"
+#include "lwpidxmgr.hxx"
+#include "lwp9reader.hxx"
+#include "xfilter/xfoleobj.hxx"
+#include "xfilter/xfparagraph.hxx"
+#include "lwpframelayout.hxx"
+#include "xfilter/xfstylemanager.hxx"
+#include "bento.hxx"
+
+/**
+ * @descr:   construction function
+ * @param:  objHdr - object header, read before entering this function
+ * @param: pStrm - file stream
+ * @return:  None
+ * @date:    2/22/2005
+ */
+LwpGraphicOleObject::LwpGraphicOleObject(LwpObjectHeader &objHdr, LwpSvStream* pStrm)
+	: LwpContent(objHdr, pStrm)
+{}
+/**
+ * @descr:   Read GraphicOleObject part
+ * @param:  None
+ * @return:  None
+ * @date:    2/22/2005
+ */
+void LwpGraphicOleObject::Read()
+{
+	LwpContent::Read();
+
+	if (LwpFileHeader::m_nFileRevision >= 0x000b)
+	{
+		// I'm not sure about the read method
+		m_pNextObj.ReadIndexed(m_pObjStrm);
+		m_pPrevObj.ReadIndexed(m_pObjStrm);
+	}
+	m_pObjStrm->SkipExtra();	
+	
+}
+
+void LwpGraphicOleObject::GetGrafOrgSize(double & rWidth, double & rHeight)
+{
+	rWidth = 0;
+	rHeight = 0;
+}
+
+void LwpGraphicOleObject::GetGrafScaledSize(double & fWidth, double & fHeight)
+{
+	GetGrafOrgSize(fWidth, fHeight);
+	// scaled image size
+	double fSclGrafWidth = fWidth;//LwpTools::ConvertFromUnitsToMetric(pMyScale->GetScaleWidth());
+	double fSclGrafHeight = fHeight;//LwpTools::ConvertFromUnitsToMetric(pMyScale->GetScaleHeight());
+
+	
+	LwpVirtualLayout* pLayout = GetLayout(NULL);
+	if (pLayout && pLayout->IsFrame())
+	{
+		LwpFrameLayout* pMyFrameLayout = static_cast<LwpFrameLayout*>(pLayout);
+		LwpLayoutScale* pMyScale = pMyFrameLayout->GetLayoutScale();
+		LwpLayoutGeometry* pFrameGeo = pMyFrameLayout->GetGeometry();
+
+		// original image size
+		//double fOrgGrafWidth = (double)m_Cache.Width/TWIPS_PER_CM;
+		//double fOrgGrafHeight = (double)m_Cache.Height/TWIPS_PER_CM;
+		
+		// get margin values
+		double fLeftMargin = pMyFrameLayout->GetMarginsValue(MARGIN_LEFT);
+		double fRightMargin = pMyFrameLayout->GetMarginsValue(MARGIN_RIGHT);
+		double fTopMargin = pMyFrameLayout->GetMarginsValue(MARGIN_TOP);
+		double fBottomMargin = pMyFrameLayout->GetMarginsValue(MARGIN_BOTTOM);
+		
+		if (pMyScale && pFrameGeo)
+		{
+			// frame size
+			double fFrameWidth = LwpTools::ConvertFromUnitsToMetric(pFrameGeo->GetWidth());
+			double fFrameHeight = LwpTools::ConvertFromUnitsToMetric(pFrameGeo->GetHeight());
+
+			// calculate the displayed size of the frame
+			double fDisFrameWidth = fFrameWidth - (fLeftMargin+fRightMargin);
+			double fDisFrameHeight = fFrameHeight - (fTopMargin+fBottomMargin);
+						
+			// get scale mode
+			sal_uInt16 nScalemode = pMyScale->GetScaleMode();
+			if (nScalemode & LwpLayoutScale::CUSTOM)
+			{
+				fSclGrafWidth = LwpTools::ConvertFromUnitsToMetric(pMyScale->GetScaleWidth());
+				fSclGrafHeight = LwpTools::ConvertFromUnitsToMetric(pMyScale->GetScaleHeight());
+			}
+			else if (nScalemode & LwpLayoutScale::PERCENTAGE)
+			{
+				double fScalePercentage = (double)pMyScale->GetScalePercentage() / 1000;
+				fSclGrafWidth = fScalePercentage * fWidth;
+				fSclGrafHeight = fScalePercentage * fHeight;
+			}
+			else if (nScalemode & LwpLayoutScale::FIT_IN_FRAME)
+			{
+				if (pMyFrameLayout->IsFitGraphic())
+				{
+					fSclGrafWidth = fWidth;
+					fSclGrafHeight = fHeight;
+				}
+				else if (nScalemode & LwpLayoutScale::MAINTAIN_ASPECT_RATIO)
+				{
+					if (fWidth/fHeight >= fDisFrameWidth/fDisFrameHeight)
+					{
+						fSclGrafWidth = fDisFrameWidth;
+						fSclGrafHeight = (fDisFrameWidth/fWidth) * fHeight;
+					}
+					else
+					{
+						fSclGrafHeight = fDisFrameHeight;
+						fSclGrafWidth = (fDisFrameHeight/fHeight) * fWidth;
+					}
+				}
+				else
+				{
+					fSclGrafWidth = fDisFrameWidth;
+					fSclGrafHeight = fDisFrameHeight;
+				}
+			}
+		}
+	}
+	fWidth = fSclGrafWidth ;
+	fHeight =  fSclGrafHeight ;
+
+}
+
+/**
+ * @descr:   construction function
+ * @param:  objHdr - object header, read before entering this function
+ * @param: pStrm - file stream
+ * @return:  None
+ * @date:    2/22/2005
+ */
+LwpOleObject::LwpOleObject(LwpObjectHeader &objHdr, LwpSvStream* pStrm)
+	: LwpGraphicOleObject(objHdr, pStrm),m_SizeRect(0,0,5,5)
+{	
+}
+/**
+ * @descr:   Read VO_OLEOBJECT record
+ * @param:  None
+ * @return:  None
+ * @date:    2/22/2005
+ */
+void LwpOleObject::Read()
+{
+	LwpGraphicOleObject::Read();
+
+	cPersistentFlags = m_pObjStrm->QuickReaduInt16();
+
+	sal_uInt16 nNonVersionedPersistentFlags = 0;
+	sal_uInt32 nFormat = 0;
+	sal_uInt16 nNumberOfPages = 0;
+	// qCMarker read
+	LwpObjectID ID;
+
+	if (LwpFileHeader::m_nFileRevision >= 0x0004)
+	{
+		nNonVersionedPersistentFlags = m_pObjStrm->QuickReaduInt16();
+
+		OUString sFormat = m_pObjStrm->QuickReadStringPtr();
+
+		if (LwpFileHeader::m_nFileRevision < 0x000B)
+		{
+			// null pointers have a VO_INVALID type
+			//if (VO_INVALID == m_pObjStrm->QuickReaduInt16())
+			//	return;
+
+			ID.Read(m_pObjStrm);
+			//return m_pObjStrm->Locate(ID);
+		}
+		else
+		{
+			ID.ReadIndexed(m_pObjStrm);
+			//if (ID.IsNull())
+			//	return;
+
+			//return m_pObjStrm->Locate(ID);
+		}	
+	}
+
+	if (m_pObjStrm->CheckExtra())
+	{
+		nNumberOfPages = m_pObjStrm->QuickReaduInt16();
+		m_pObjStrm->SkipExtra();
+	}
+
+}
+/**
+ * @descr:   Construct ole-storage name by ObjectID
+ * @param:  pObjName - input&output string of object name, spaces allocated outside and at least length should be MAX_STREAMORSTORAGENAME
+ * @return:  None
+ * @date:    2/22/2005
+ */
+void LwpOleObject::GetChildStorageName(char *pObjName)
+{
+	/*LwpObjectFactory * pObjMgr = LwpObjectFactory::Instance();
+	LwpIndexManager * pIdxMgr = pObjMgr->GetIndexManager();
+	sal_uInt32 nLowID = pIdxMgr->GetObjTime(static_cast<sal_uInt16>(GetObjectID()->GetLow()));*/
+
+	char sName[MAX_STREAMORSTORAGENAME];
+	//LwpObjectID ID(nLowID, GetObjectID()->GetHigh());
+	sprintf( sName, "%s%lX,%lX", "Ole",
+	  GetObjectID()->GetHigh(), GetObjectID()->GetLow());
+
+	strcpy( pObjName, sName);
+	return;
+}
+/**
+ * @descr:   Parse VO_OLEOBJECT and dump to XML stream only on WIN32 platform
+ * @param:  pOutputStream - stream to dump OLE object
+ * @param:  pFrameLayout -  framlayout object used to dump OLE object
+ * @return:  None
+ * @date:    2/22/2005
+ */
+void LwpOleObject::Parse(IXFStream* pOutputStream)
+{
+#if 0
+#ifdef WIN32
+
+	//
+	// Construct OLE object storage name
+	//
+	char sObjectName[MAX_STREAMORSTORAGENAME];
+	GetChildStorageName(sObjectName);
+	String aObjName= String::CreateFromAscii(sObjectName);
+
+	//
+	// Get OLE objects information
+	//
+	LwpGlobalMgr* pGlobal = LwpGlobalMgr::GetInstance();
+	LwpObjectFactory* pObjMgr = pGlobal->GetLwpObjFactory();
+	SvStorageRef objStor;
+	SvStorageInfoList * pInfoList;
+	pObjMgr->GetOleObjInfo(objStor, &pInfoList);
+
+	if(pInfoList == NULL)
+	{
+		assert(sal_False);
+		return;
+	}
+
+	//
+	// Get ole object buffer
+	// 
+	BYTE * pBuf = NULL;
+	sal_uInt32 nSize = 0;
+	for (sal_uInt32 j=0; j<pInfoList->Count(); j++)
+	{
+
+		SvStorageInfo& rInfo = pInfoList->GetObject(j);
+		String aName = rInfo.GetName();
+
+		if(aName == aObjName)
+		{
+			SvStorageRef childStor;		
+			childStor = objStor->OpenStorage(rInfo.GetName());
+			SvStorage * aEleStor;    
+			aEleStor = objStor->OpenOLEStorage( rInfo.GetName() );
+			SvInPlaceObjectRef xInplaceObj( ((SvFactory*)SvInPlaceObject::ClassFactory())->CreateAndLoad( childStor ) );
+			SvOutPlaceObjectRef xOutplaceObj(xInplaceObj);
+			aEleStor->SetVersion( SOFFICE_FILEFORMAT_60 );
+			SvStream *pStream=xOutplaceObj->GetOLEObjectStream(aEleStor);
+
+			//Get Ole original size
+			m_SizeRect = xOutplaceObj->GetVisSize(xOutplaceObj->GetViewAspect());
+
+			nSize = pStream->Seek( STREAM_SEEK_TO_END );
+			pBuf = new BYTE[nSize];
+			if (pBuf == NULL)
+			{
+				assert(sal_False);
+				return;
+			}
+			pStream->Seek(0);
+			pStream->Read(pBuf, nSize);
+
+			delete pStream;
+			break;
+		}
+	}
+
+	//
+	// dump the buffer by XFilter
+	//
+	if(pBuf != NULL)
+	{
+		// set ole buffer
+		XFOleObject *pOleObj = new XFOleObject();
+		pOleObj->SetOleData(pBuf, nSize);
+
+		// set frame attributes
+		pOleObj->SetAnchorType(enumXFAnchorPara);
+		double fWidth = 0;
+		double fHeight = 0;
+		GetGrafScaledSize( fWidth,  fHeight);
+		if(fWidth < 0.001 || fHeight < 0.001)
+		{
+			fWidth = 5.0;
+			fHeight = 5.0;
+		}
+		pOleObj->SetWidth(fWidth);
+		pOleObj->SetHeight(fHeight);
+		/*
+		pOleObj->SetName(A2OUSTR("TestOle"));
+		pOleObj->SetX(5);
+		pOleObj->SetY(5);
+		pOleObj->SetWidth(5);
+		pOleObj->SetHeight(5);
+		*/
+
+		// To XML
+		XFParagraph *pPara = new XFParagraph();
+		pPara->Add(pOleObj);
+		pPara->ToXml(pOutputStream);
+
+		delete pPara;		// pOleObj will be deleted inside
+
+#if 0
+		// dump to file
+		String aTempDir( SvtPathOptions().GetTempPath() );
+		sal_Int32 nLength = aTempDir.Len();
+		if ( aTempDir.GetChar(nLength-1 ) !=UChar32( '/' ) )
+			aTempDir += String::CreateFromAscii("/");
+
+		aTempDir += aObjName;
+		SvFileStream aStream(aTempDir, STREAM_WRITE);
+		aStream.Write(pBuf, nSize);
+		aStream.Close();
+#endif
+		delete []pBuf;
+		
+		// dump attributes to 
+	}
+	
+	return;
+#endif	
+#endif	
+}
+
+void LwpOleObject::XFConvert(XFContentContainer * pCont)
+{
+#if 0
+	//Add by  10/24/2005
+	//Get ole object stream with the object name; 
+
+	// modified by 
+	// if small file, use the compressed stream for BENTO
+	LwpSvStream* pStream = m_pStrm->GetCompressedStream() ?  m_pStrm->GetCompressedStream(): m_pStrm;
+	// end modified by 
+
+	OpenStormBento::LtcBenContainer* pBentoContainer;
+	ULONG ulRet = OpenStormBento::BenOpenContainer(pStream, &pBentoContainer);
+
+	char sObjectName[MAX_STREAMORSTORAGENAME];
+	GetChildStorageName(sObjectName);
+	std::string aObjName(sObjectName);
+	SotStorageStreamRef xOleObjStm = pBentoContainer->ConvertAswStorageToOLE2Stream(aObjName.c_str());
+
+	//Get stream size and data
+	if(!xOleObjStm.Is() || xOleObjStm->GetError())
+		return;
+	
+
+	BYTE * pBuf = NULL;
+	sal_uInt32 nSize = 0;
+
+	SvStorageRef xOleObjStor = new SvStorage( *xOleObjStm );
+	//SvStorageRef xOleObjStor = pBentoContainer->CreateOLEStorageWithObjectName(aObjName.c_str());
+	if( !xOleObjStor.Is())
+		return ;	
+	
+	SvInPlaceObjectRef xInplaceObj( ((SvFactory*)SvInPlaceObject::ClassFactory())->CreateAndLoad( xOleObjStor ) );
+
+	
+	//when the OLE object is converted into native object.
+//	SvOutPlaceObjectRef xOutplaceObj(xInplaceObj);
+//	xOutplaceObj->SetVersion( SOFFICE_FILEFORMAT_60 );
+//	SvStream *pOleStream=xOutplaceObj->GetOLEObjectStream(xOleObjStor);
+	//Get Ole original size
+	m_SizeRect = GetOLEObjectSize(xOleObjStor);	
+	//End by 
+
+	nSize = xOleObjStm->Seek( STREAM_SEEK_TO_END );
+	pBuf = new BYTE[nSize];
+	if (pBuf == NULL)
+	{
+		assert(sal_False);
+		return;
+	}
+	xOleObjStm->Seek(0);
+	xOleObjStm->Read(pBuf, nSize);
+
+	//delete pOleStream;
+	
+	
+	//End by 	
+
+	//
+	// dump the buffer by XFilter
+	//
+	if(pBuf != NULL)
+	{
+		// set ole buffer
+		XFOleObject *pOleObj = new XFOleObject();
+		pOleObj->SetOleData(pBuf, nSize);
+
+		// set frame attributes
+		pOleObj->SetAnchorType(enumXFAnchorFrame);
+		pOleObj->SetStyleName( m_strStyleName);		
+		LwpFrameLayout* pMyFrameLayout = static_cast<LwpFrameLayout*>(GetLayout(NULL));
+		if(pMyFrameLayout)
+		{
+			pOleObj->SetX(pMyFrameLayout->GetMarginsValue(MARGIN_LEFT));
+			pOleObj->SetY(pMyFrameLayout->GetMarginsValue(MARGIN_TOP));
+		}
+		
+		double fWidth = 0;
+		double fHeight = 0;
+		GetGrafScaledSize( fWidth,  fHeight);
+		if(fWidth < 0.001 || fHeight < 0.001)
+		{
+			fWidth = 5.0;
+			fHeight = 5.0;
+		}
+		
+		
+		pOleObj->SetWidth(fWidth);
+		pOleObj->SetHeight(fHeight);		
+
+
+		//delete pPara;		// pOleObj will be deleted inside
+		pCont->Add(pOleObj);
+
+#if 0
+		// dump to file
+		String aTempDir( SvtPathOptions().GetTempPath() );
+		sal_Int32 nLength = aTempDir.Len();
+		if ( aTempDir.GetChar(nLength-1 ) !=UChar32( '/' ) )
+			aTempDir += String::CreateFromAscii("/");
+
+		aTempDir += aObjName;
+		SvFileStream aStream(aTempDir, STREAM_WRITE);
+		aStream.Write(pBuf, nSize);
+		aStream.Close();
+#endif
+		delete []pBuf;
+		
+		// dump attributes to 
+	}
+#endif	
+	return;
+}
+
+void LwpOleObject::GetGrafOrgSize(double & rWidth, double & rHeight)
+{
+	rWidth = (double)m_SizeRect.GetWidth()/1000;//cm unit
+	rHeight = (double)m_SizeRect.GetHeight()/1000;//cm unit
+}
+
+void LwpOleObject::RegisterStyle()
+{
+#if 0
+#ifdef WIN32
+	LwpVirtualLayout* pMyLayout = GetLayout(NULL);
+	if(pMyLayout->IsFrame())
+	{
+		XFFrameStyle* pXFFrameStyle = new XFFrameStyle();
+		pXFFrameStyle->SetXPosType(enumXFFrameXPosFromLeft, enumXFFrameXRelFrame);
+		pXFFrameStyle->SetYPosType(enumXFFrameYPosFromTop, enumXFFrameYRelPara);
+		XFStyleManager* pXFStyleManager = LwpGlobalMgr::GetInstance()->GetXFStyleManager(); 
+		m_strStyleName = pXFStyleManager->AddStyle(pXFFrameStyle)->GetStyleName();
+	}
+#endif
+#endif
+}
+
+
+#include <sot/exchange.hxx>
+#include <sot/storinfo.hxx>
+#include <svtools/wmf.hxx>
+/**
+* @descr:   For SODC_2667, To get the OLE object size by reading OLE object picture information.
+*/
+Rectangle LwpOleObject::GetOLEObjectSize( SotStorage * pStor ) const
+{
+	Rectangle aSize(0,0,0,0);
+	String aStreamName;
+	if( pStor->IsContained( String::CreateFromAscii( RTL_CONSTASCII_STRINGPARAM( "\002OlePres000" ) ) ) )
+		aStreamName = String::CreateFromAscii( RTL_CONSTASCII_STRINGPARAM( "\002OlePres000" ) );
+	else if( pStor->IsContained( String::CreateFromAscii( RTL_CONSTASCII_STRINGPARAM( "\1Ole10Native" ) ) ) )
+		aStreamName = String::CreateFromAscii( RTL_CONSTASCII_STRINGPARAM( "\1Ole10Native" ) );
+
+	if( aStreamName.Len() == 0 )
+		return aSize;
+
+
+	for( USHORT i = 1; i < 10; i++ )
+	{
+		SotStorageStreamRef xStm = pStor->OpenSotStream( aStreamName,
+			STREAM_READ | STREAM_NOCREATE );
+		if( xStm->GetError() )
+			break;
+
+		xStm->SetBufferSize( 8192 );
+		LwpOlePres * pEle = new LwpOlePres( 0 );
+		if( pEle->Read( *xStm ) && !xStm->GetError() )
+		{
+			if( pEle->GetFormat() == FORMAT_GDIMETAFILE || pEle->GetFormat() == FORMAT_BITMAP )
+			{
+				aSize = Rectangle( Point(), pEle->GetSize());
+				delete pEle;
+				break;
+			}				
+		}
+		delete pEle;
+		pEle = NULL;
+		aStreamName = String::CreateFromAscii( RTL_CONSTASCII_STRINGPARAM( "\002OlePres00" ) );
+		aStreamName += String( i );
+	};
+
+	return aSize;
+}
+/**
+* @descr:   Read OLE object picture information
+*/
+BOOL LwpOlePres::Read( SvStream & rStm )
+{
+#if 0
+	ULONG nBeginPos = rStm.Tell();
+	INT32 n;
+	rStm >> n;
+	if( n != -1 )
+	{
+		pBmp = new Bitmap;
+		rStm >> *pBmp;
+		if( rStm.GetError() == SVSTREAM_OK )
+		{
+			nFormat = FORMAT_BITMAP;
+			aSize = pBmp->GetPrefSize();
+			MapMode aMMSrc;
+			if( !aSize.Width() || !aSize.Height() )
+			{
+				// letzte Chance
+				aSize = pBmp->GetSizePixel();
+				aMMSrc = MAP_PIXEL;
+			}
+			else
+				aMMSrc = pBmp->GetPrefMapMode();
+			MapMode aMMDst( MAP_100TH_MM );
+			aSize = OutputDevice::LogicToLogic( aSize, aMMSrc, aMMDst );
+			return TRUE;
+		}
+		else
+		{
+			delete pBmp;
+			pBmp = NULL;
+
+			pMtf = new GDIMetaFile();
+			rStm.ResetError();
+			rStm >> *pMtf;
+			if( rStm.GetError() == SVSTREAM_OK )
+			{
+				nFormat = FORMAT_GDIMETAFILE;
+				aSize = pMtf->GetPrefSize();
+				MapMode aMMSrc = pMtf->GetPrefMapMode();
+				MapMode aMMDst( MAP_100TH_MM );
+				aSize = OutputDevice::LogicToLogic( aSize, aMMSrc, aMMDst );
+				return TRUE;
+			}
+			else
+			{
+				delete pMtf;
+				pMtf = NULL;
+			}
+		}
+
+	}
+
+	rStm.ResetError();
+	rStm.Seek( nBeginPos );
+	nFormat = ReadClipboardFormat( rStm );
+	// JobSetup, bzw. TargetDevice ueberlesen
+	// Information aufnehmen, um sie beim Schreiben nicht zu verlieren
+	nJobLen = 0;
+	rStm >> nJobLen;
+	if( nJobLen >= 4 )
+	{
+		nJobLen -= 4;
+		if( nJobLen )
+		{
+			pJob = new BYTE[ nJobLen ];
+			rStm.Read( pJob, nJobLen );
+		}
+	}
+	else
+	{
+		rStm.SetError( SVSTREAM_GENERALERROR );
+		return FALSE;
+	}
+	UINT32 nAsp;
+	rStm >> nAsp;
+	USHORT nSvAsp = USHORT( nAsp );
+	SetAspect( nSvAsp );
+	rStm.SeekRel( 4 ); //L-Index ueberlesen
+	rStm >> nAdvFlags;
+	rStm.SeekRel( 4 ); //Compression
+	UINT32 nWidth  = 0;
+	UINT32 nHeight = 0;
+	UINT32 nSize   = 0;
+	rStm >> nWidth >> nHeight >> nSize;
+	aSize.Width() = nWidth;
+	aSize.Height() = nHeight;
+
+	if( nFormat == FORMAT_GDIMETAFILE )
+	{
+		pMtf = new GDIMetaFile();
+		ReadWindowMetafile( rStm, *pMtf );
+	}
+	else if( nFormat == FORMAT_BITMAP )
+	{
+		pBmp = new Bitmap();
+		rStm >> *pBmp;
+	}
+	else
+	{
+		void * p = new BYTE[ nSize ];
+		rStm.Read( p, nSize );
+		delete p;
+		return FALSE;
+	}
+#endif     
+	return TRUE;
+}
+
+/**
+* @descr:   Write OLE object picture information.
+*/
+void LwpOlePres::Write( SvStream & rStm )
+{
+	WriteClipboardFormat( rStm, FORMAT_GDIMETAFILE );
+	rStm << (INT32)(nJobLen +4);       // immer leeres TargetDevice
+	if( nJobLen )
+		rStm.Write( pJob, nJobLen );
+	rStm << (UINT32)nAspect;
+	rStm << (INT32)-1;      //L-Index immer -1
+	rStm << (INT32)nAdvFlags;
+	rStm << (INT32)0;       //Compression
+	rStm << (INT32)aSize.Width();
+	rStm << (INT32)aSize.Height();
+	ULONG nPos = rStm.Tell();
+	rStm << (INT32)0;
+
+	if( GetFormat() == FORMAT_GDIMETAFILE && pMtf )
+	{
+		// Immer auf 1/100 mm, bis Mtf-Loesung gefunden
+		// Annahme (keine Skalierung, keine Org-Verschiebung)
+		DBG_ASSERT( pMtf->GetPrefMapMode().GetScaleX() == Fraction( 1, 1 ),
+			"X-Skalierung im Mtf" )
+			DBG_ASSERT( pMtf->GetPrefMapMode().GetScaleY() == Fraction( 1, 1 ),
+			"Y-Skalierung im Mtf" )
+			DBG_ASSERT( pMtf->GetPrefMapMode().GetOrigin() == Point(),
+			"Origin-Verschiebung im Mtf" )
+			MapUnit nMU = pMtf->GetPrefMapMode().GetMapUnit();
+		if( MAP_100TH_MM != nMU )
+		{
+			Size aPrefS( pMtf->GetPrefSize() );
+			Size aS( aPrefS );
+			aS = OutputDevice::LogicToLogic( aS, nMU, MAP_100TH_MM );
+
+			pMtf->Scale( Fraction( aS.Width(), aPrefS.Width() ),
+				Fraction( aS.Height(), aPrefS.Height() ) );
+			pMtf->SetPrefMapMode( MAP_100TH_MM );
+			pMtf->SetPrefSize( aS );
+		}
+		WriteWindowMetafileBits( rStm, *pMtf );
+	}
+	else
+	{
+		DBG_ERROR( "unknown format" )
+	}
+	ULONG nEndPos = rStm.Tell();
+	rStm.Seek( nPos );
+	rStm << (UINT32)(nEndPos - nPos - 4);
+	rStm.Seek( nEndPos );
+}
+//End by 
diff -urNp lotuswordpro.bak/source/filter/lwpoleobject.hxx lotuswordpro/source/filter/lwpoleobject.hxx
--- lotuswordpro.bak/source/filter/lwpoleobject.hxx	1970-01-01 08:00:00.000000000 +0800
+++ lotuswordpro/source/filter/lwpoleobject.hxx	2008-10-22 11:42:29.000000000 +0800
@@ -0,0 +1,195 @@
+/*************************************************************************
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: IBM Corporation
+ *
+ *  Copyright: 2008 by IBM Corporation
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+/**
+ * @file 
+ *  For LWP filter architecture prototype - OLE object
+ */
+/*************************************************************************
+ * Change History
+ Feb 2005		 	Created
+ ************************************************************************/
+#ifndef _LWPOLEOBJECT_HXX_
+#define _LWPOLEOBJECT_HXX_
+
+#include "lwpobj.hxx"
+#include "lwpobjhdr.hxx"
+#include "lwpobjid.hxx"
+#include "lwpstory.hxx"
+#include "tools/gen.hxx"
+/*
+#include <so3/svstor.hxx>
+#include <so3/outplace.hxx>
+#include <so3/ipobj.hxx>
+#include <so3/factory.hxx>
+*/
+#include <svx/svdoole2.hxx>
+#include <svx/svdpage.hxx>
+#include <sfx2/objsh.hxx>
+#include <sot/storinfo.hxx>
+
+
+typedef struct tagAFID_CACHE
+{
+	unsigned long LinkedFileSize;				/* 0 if not linked */
+	unsigned long LinkedFileTime;				/* 0 if not linked */
+	long Width;								/* -1 if not present */
+	long Height;								/* -1 if not present */
+} AFID_CACHE,  * PAFID_CACHE;
+
+/* Maximum string sizes - includes space for null terminator */
+#define AFID_MAX_FILE_FORMAT_SIZE                	80
+#define AFID_MAX_CONTEXT_FORMAT_SIZE             	80
+
+// OLE defined maximum
+#define MAX_STREAMORSTORAGENAME		32
+/**
+ * @descr
+ * super class of LwpOleObject and LwpGraphicObject
+ */
+class LwpGraphicOleObject : public LwpContent
+{
+public:
+	LwpGraphicOleObject(LwpObjectHeader& objHdr, LwpSvStream* pStrm);
+	virtual void Read();
+	virtual void GetGrafScaledSize(double& fWidth, double& fHeight);
+	virtual void GetGrafOrgSize(double& rWidth, double& rHeight);
+protected:
+	LwpObjectID m_pPrevObj;
+	LwpObjectID m_pNextObj;
+
+	rtl::OUString m_strStyleName;
+};
+
+class LwpFrameLayout;
+/**
+ * @descr
+ * class to read and parse VO_OLEOBJECT object
+ */
+class LwpOleObject : public LwpGraphicOleObject
+{
+public:
+	LwpOleObject(LwpObjectHeader& objHdr, LwpSvStream* pStrm);
+	~LwpOleObject(){};
+	virtual void Read();
+	virtual void Parse(IXFStream* pOutputStream);
+	virtual void XFConvert(XFContentContainer * pCont);	
+	virtual void RegisterStyle();
+	void GetGrafOrgSize(double& rWidth, double& rHeight) ;
+private:
+	void GetChildStorageName(char *pObjName);
+	Rectangle GetOLEObjectSize( SotStorage * pStor ) const;
+
+	sal_uInt16 cPersistentFlags;
+
+	Rectangle m_SizeRect;
+};
+
+/**
+*  Added by  for SODC_2667,03/20/2006
+*  Read the OLE Object stream and get the info of the OLE picture
+*/
+#include <tools/stream.hxx>
+#include <vcl/gdimtf.hxx>
+#include <vcl/bitmap.hxx>
+#include <vcl/outdev.hxx>
+class LwpOlePres
+{
+	ULONG	nFormat;
+	USHORT	nAspect;
+	Bitmap *		pBmp;
+	GDIMetaFile *	pMtf;
+
+	UINT32  nAdvFlags;
+	INT32 	nJobLen;
+	void *	pJob;
+	Size	aSize;		// Groesse in 100TH_MM
+public:
+	LwpOlePres( ULONG nF )
+		: nFormat( nF )
+		, nAdvFlags( 0x2 ) // in Dokument gefunden
+		, nJobLen( 0 )
+		, pJob( NULL )
+		, pBmp( NULL )
+		, pMtf( NULL )
+	{}
+	~LwpOlePres()
+	{
+		delete pJob;
+		delete pBmp;
+		delete pMtf;
+	}
+	void	SetMtf( const GDIMetaFile & rMtf )
+	{
+		if( pMtf )
+			delete pMtf;
+		pMtf = new GDIMetaFile( rMtf );
+	}
+	Bitmap *GetBitmap() const { return pBmp; }
+	GDIMetaFile *GetMetaFile() const { return pMtf; }
+	ULONG	GetFormat() const { return nFormat; }
+	void	SetAspect( USHORT nAsp ) { nAspect = nAsp; }
+	ULONG	GetAdviseFlags() const { return nAdvFlags; }
+	void	SetAdviseFlags( ULONG nAdv ) { nAdvFlags = nAdv; }
+	void	SetSize( const Size & rSize ) { aSize = rSize; }
+	Size GetSize() const { return aSize; } //Add by , 10/26/2005
+	/// return FALSE => unknown format
+	BOOL 	Read( SvStream & rStm );
+	void 	Write( SvStream & rStm );
+};
+//End by 
+
+
+#endif
+
diff -urNp lotuswordpro.bak/source/filter/lwpoverride.cxx lotuswordpro/source/filter/lwpoverride.cxx
--- lotuswordpro.bak/source/filter/lwpoverride.cxx	1970-01-01 08:00:00.000000000 +0800
+++ lotuswordpro/source/filter/lwpoverride.cxx	2008-10-22 11:42:29.000000000 +0800
@@ -0,0 +1,555 @@
+/*************************************************************************
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: IBM Corporation
+ *
+ *  Copyright: 2008 by IBM Corporation
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+/*************************************************************************
+ * @file 
+ *  For LWP filter architecture prototype
+ ************************************************************************/
+/*************************************************************************
+ * Change History
+ Jan 2005			Created
+ ************************************************************************/
+ 
+#include "lwpoverride.hxx"
+#include "lwpfilehdr.hxx"
+#include "lwpatomholder.hxx"
+#include "lwpborderstuff.hxx"
+#include "lwpmargins.hxx"
+#include "lwpbackgroundstuff.hxx"
+
+/*class LwpOverride*/
+void LwpOverride::ReadCommon(LwpObjectStream* pStrm)
+{
+	pStrm->QuickRead(&m_nValues, 2);
+	pStrm->QuickRead(&m_nOverride, 2);
+	pStrm->QuickRead(&m_nApply, 2);
+	pStrm->SkipExtra();
+}
+
+void LwpOverride::Clear()
+{
+	m_nValues = 0;
+	m_nOverride = 0;
+	m_nApply = 0;
+}
+
+void LwpOverride::operator=(const LwpOverride& rOther)
+{
+	m_nValues = rOther.m_nValues;
+	m_nOverride = rOther.m_nOverride;
+	m_nApply = rOther.m_nApply;
+}
+
+void LwpOverride::Override(sal_uInt16 nBits, STATE eState)
+{
+	if (eState == STATE_STYLE)
+	{
+		m_nValues &= ~nBits;
+		m_nOverride &= ~nBits;
+	}
+	else
+	{
+		m_nOverride |= nBits;
+		if (eState == STATE_ON)
+		{
+			m_nValues |= nBits;
+		}
+		else	/* State == STATE_OFF */
+		{
+			m_nValues &= ~nBits;
+		}
+	}
+	m_nApply |= nBits;
+}
+
+/*class LwpTextLanguageOverride*/
+void LwpTextLanguageOverride::Read(LwpObjectStream* pStrm)
+{
+	if (pStrm->QuickReadBool())
+	{
+		ReadCommon(pStrm);
+		pStrm->QuickRead(&m_nLanguage, 2);
+	}
+
+	pStrm->SkipExtra();
+
+}
+
+/*class LwpTextAttributeOverride*/
+void LwpTextAttributeOverride::Read(LwpObjectStream* pStrm)
+{
+	if (pStrm->QuickReadBool())
+	{
+		ReadCommon(pStrm);
+		pStrm->QuickRead(&m_nHideLevels, 2);
+
+		if (LwpFileHeader::m_nFileRevision > 0x000A)
+		{
+			pStrm->QuickRead(&m_nBaseLineOffset, 4);
+		}
+	}
+
+	pStrm->SkipExtra();
+}
+
+sal_Bool LwpTextAttributeOverride::IsHighLight()
+{
+	return (m_nValues & TAO_HIGHLIGHT);
+}
+
+/*class LwpKinsokuOptsOverride*/
+void LwpKinsokuOptsOverride::Read(LwpObjectStream* pStrm)
+{
+	if (pStrm->QuickReadBool())
+	{
+		ReadCommon(pStrm);
+		pStrm->QuickRead(&m_nLevels, 2);
+	}
+
+	pStrm->SkipExtra();
+}
+
+/*class LwpBulletOverride*/
+void LwpBulletOverride::Read(LwpObjectStream * pStrm)
+{
+	if (pStrm->QuickReadBool())
+	{
+		m_bIsNull= sal_False;
+		ReadCommon(pStrm);
+		m_SilverBullet.ReadIndexed(pStrm);
+	}
+	else
+		m_bIsNull = sal_True;
+
+	pStrm->SkipExtra();
+}
+void LwpBulletOverride::OverrideSkip(sal_Bool bOver)
+{
+	if (bOver)
+	{
+		LwpOverride::Override(BO_SKIP, STATE_ON);
+	}
+	else
+	{
+		LwpOverride::Override(BO_SKIP, STATE_OFF);
+	}
+}
+
+void LwpBulletOverride::OverrideRightAligned(sal_Bool bOver)
+{
+	if(bOver)
+	{
+		LwpOverride::Override(BO_RIGHTALIGN,STATE_ON);
+	}
+	else
+	{
+		LwpOverride::Override(BO_RIGHTALIGN,STATE_OFF);
+	}
+}
+
+void LwpBulletOverride::operator=(const LwpOverride& rOther)
+{
+	LwpOverride::operator=(rOther);
+	const LwpBulletOverride* pBullet = static_cast<LwpBulletOverride*>((LwpOverride*)&rOther);
+
+	m_SilverBullet = pBullet->m_SilverBullet;
+
+}
+
+void LwpBulletOverride::OverrideSilverBullet(LwpObjectID aID)
+{
+	if (!aID.IsNull())
+	{
+		m_SilverBullet = aID;
+	}
+
+	LwpOverride::Override(BO_SILVERBULLET,STATE_ON);
+}
+	
+void LwpBulletOverride::Override(LwpBulletOverride* pOther)
+{
+	if (m_nApply & BO_SILVERBULLET)
+	{
+		if (IsSilverBulletOverridden())
+		{
+			pOther->OverrideSilverBullet(m_SilverBullet);
+		}
+		else
+		{
+			pOther->RevertSilverBullet();
+		}
+	}
+	
+	if (m_nApply & BO_SKIP)
+	{
+		if (IsSkipOverridden())
+		{
+			pOther->OverrideSkip(IsSkip());
+		}
+		else
+		{
+			pOther->RevertSkip();
+		}
+	}
+
+	if (m_nApply & BO_RIGHTALIGN)
+	{
+		if (IsRightAlignedOverridden())
+		{
+			pOther->OverrideRightAligned(IsRightAligned());
+		}
+		else
+		{
+			pOther->RevertRightAligned();
+		}
+	}
+
+}
+
+/*class LwpAlignmentOverride*/
+void LwpAlignmentOverride::Read(LwpObjectStream * pStrm)
+{
+	if (pStrm->QuickReadBool())
+	{
+		ReadCommon(pStrm);
+		pStrm->QuickRead(&m_nAlignType, 1);
+		pStrm->QuickRead(&m_nPosition, 4);
+		pStrm->QuickRead(&m_nAlignChar, 2);
+	}
+
+	pStrm->SkipExtra();
+}
+
+/*class LwpSpacingCommonOverride*/
+void LwpSpacingCommonOverride::Read(LwpObjectStream* pStrm)
+{
+	if (pStrm->QuickReadBool())
+	{
+		ReadCommon(pStrm);
+		pStrm->QuickRead(&m_nSpacingType, 2);
+		pStrm->QuickRead(&m_nAmount, 4);
+		pStrm->QuickRead(&m_nMultiple, 4);
+	}
+
+	pStrm->SkipExtra();
+}
+
+/*class LwpSpacingOverride*/
+LwpSpacingOverride::LwpSpacingOverride() :
+m_pSpacing(new LwpSpacingCommonOverride),
+m_pAboveLineSpacing(new LwpSpacingCommonOverride),
+m_pParaSpacingAbove(new LwpSpacingCommonOverride),
+m_pParaSpacingBelow(new LwpSpacingCommonOverride)
+{
+}
+
+LwpSpacingOverride& LwpSpacingOverride::operator=(LwpSpacingOverride& other)
+{
+    LwpOverride::operator=(other);
+    *m_pSpacing = *other.m_pSpacing;
+    *m_pAboveLineSpacing = *other.m_pAboveLineSpacing;
+    *m_pParaSpacingAbove = *other.m_pParaSpacingAbove;
+    *m_pParaSpacingAbove = *other.m_pParaSpacingAbove;
+    return *this;
+}
+
+LwpSpacingOverride::~LwpSpacingOverride()
+{
+	if (m_pSpacing)
+	{
+		delete m_pSpacing;
+	}
+	if (m_pAboveLineSpacing)
+	{
+		delete m_pAboveLineSpacing;
+	}
+	if (m_pParaSpacingAbove)
+	{
+		delete m_pParaSpacingAbove;
+	}
+	if (m_pParaSpacingBelow)
+	{
+		delete m_pParaSpacingBelow;
+	}
+}
+
+void LwpSpacingOverride::Read(LwpObjectStream* pStrm)
+{
+	if (pStrm->QuickReadBool())
+	{
+		ReadCommon(pStrm);
+		m_pSpacing->Read(pStrm);
+		if (LwpFileHeader::m_nFileRevision >= 0x000d)
+		{
+			m_pAboveLineSpacing->Read(pStrm);
+		}
+		m_pParaSpacingAbove->Read(pStrm);
+		m_pParaSpacingBelow->Read(pStrm);
+	}
+
+	pStrm->SkipExtra();
+}
+
+/*class LwpIndentOverride*/
+void LwpIndentOverride::Read(LwpObjectStream* pStrm)
+{
+	if (pStrm->QuickReadBool())
+	{
+		ReadCommon(pStrm);
+
+		pStrm->QuickRead(&m_nAll, 4);
+		pStrm->QuickRead(&m_nFirst, 4);
+		pStrm->QuickRead(&m_nRest, 4);
+		pStrm->QuickRead(&m_nRight, 4);
+	}
+
+	pStrm->SkipExtra();
+}
+
+
+/*class LwpAmikakeOverride*/
+LwpAmikakeOverride::LwpAmikakeOverride() :
+m_pBackgroundStuff(new LwpBackgroundStuff), m_nType(AMIKAKE_NONE)
+{
+}
+
+LwpAmikakeOverride::~LwpAmikakeOverride()
+{
+	if (m_pBackgroundStuff)
+	{
+		delete m_pBackgroundStuff;
+	}
+}
+
+void LwpAmikakeOverride::Read(LwpObjectStream* pStrm)
+{
+	if (pStrm->QuickReadBool())
+	{
+		ReadCommon(pStrm);
+		m_pBackgroundStuff->Read(pStrm);
+	}
+	else
+	{
+		Clear();
+	}
+	
+	if (pStrm->CheckExtra())
+	{
+		pStrm->QuickRead(&m_nType, 2);
+		pStrm->SkipExtra();
+	}
+	else
+	{
+		m_nType = AMIKAKE_NONE;
+	}
+}
+
+void LwpAlignmentOverride::Override(LwpAlignmentOverride* other)//add by  1-24
+{
+	if (m_nOverride & AO_TYPE)
+	{
+	    other->OverrideAlignment(m_nAlignType);
+	}
+/*	if (m_nOverride & AO_POSITION)
+	{
+		Other->OverridePosition(GetPosition());
+	}
+	if (m_nOverride & AO_CHAR)
+	{
+		Other->OverrideAlignChar(GetAlignChar());
+	}  
+*/  
+}
+
+void LwpAlignmentOverride::OverrideAlignment(AlignType val)//add by  1-24
+{
+    m_nAlignType = val;
+	m_nOverride |= AO_TYPE;
+}
+
+LwpIndentOverride& LwpIndentOverride::operator=(LwpIndentOverride& other)
+{
+	LwpOverride::operator=(other);
+    m_nAll   = other.m_nAll;
+	m_nFirst = other.m_nFirst;
+	m_nRest  = other.m_nRest;
+	m_nRight = other.m_nRight;
+	return *this;
+}
+
+void LwpIndentOverride::Override(LwpIndentOverride* other)
+{
+    if(m_nOverride & IO_ALL)
+        other->OverrideIndentAll(m_nAll);
+    if(m_nOverride & IO_FIRST)
+        other->OverrideIndentFirst(m_nFirst);
+    if(m_nOverride & IO_RIGHT)
+        other->OverrideIndentRight(m_nRight);
+    if(m_nOverride & IO_REST)
+        other->OverrideIndentRest(m_nRest); 
+	if(m_nOverride & IO_USE_RELATIVE)
+		other->OverrideUseRelative(IsUseRelative());
+	if (m_nOverride & IO_REL_FLAGS)
+		other->OverrideRelative(GetRelative());
+}
+
+sal_uInt16 LwpIndentOverride::GetRelative()
+{
+	if ((m_nOverride & IO_REL_FLAGS) == IO_REL_FIRST)
+		return RELATIVE_FIRST;
+	else if ((m_nOverride & IO_REL_FLAGS) == IO_REL_ALL)
+		return RELATIVE_ALL;
+	return RELATIVE_REST;	
+}
+
+sal_Bool LwpIndentOverride::IsUseRelative()
+{
+	return (m_nValues & IO_USE_RELATIVE) != 0;
+}
+
+void LwpIndentOverride::OverrideIndentAll(sal_Int32 val)	
+{
+    m_nAll = val;
+	m_nOverride |= IO_ALL;    
+}
+
+void LwpIndentOverride::OverrideIndentFirst(sal_Int32 val)	
+{
+    m_nFirst = val;
+	m_nOverride |= IO_FIRST;    
+}
+
+void LwpIndentOverride::OverrideIndentRight(sal_Int32 val)	
+{
+    m_nRight = val;
+	m_nOverride |= IO_RIGHT;    
+}
+
+void LwpIndentOverride::OverrideIndentRest(sal_Int32 val)
+{
+    m_nRest = val;
+//    m_nAll = val;
+//    m_nFirst = 0-val;        
+	m_nOverride |= IO_REST;   
+}
+	
+void LwpIndentOverride::OverrideUseRelative(sal_Bool use)
+{
+	if (use)
+	{
+		m_nOverride |= IO_USE_RELATIVE; 
+		m_nValues |= IO_USE_RELATIVE; 
+	}
+	else
+	{
+		m_nOverride &= ~IO_USE_RELATIVE; 
+		m_nValues &= ~IO_USE_RELATIVE; 
+	}
+}
+
+void LwpIndentOverride::OverrideRelative(sal_uInt16 relative)
+{
+	sal_uInt16 Flag;
+
+	if (relative == RELATIVE_FIRST)
+		Flag = IO_REL_FIRST;
+	else if (relative == RELATIVE_ALL)
+		Flag = IO_REL_ALL;
+	else
+		Flag = IO_REL_REST;
+
+	m_nOverride &= ~IO_REL_FLAGS;
+	m_nOverride |= Flag;	
+}
+
+void LwpSpacingOverride::Override(LwpSpacingOverride* other)
+{
+//    if (IsAlwaysOverridden())
+//		other->SetAlways(IsAlways());//To be done
+	if (other)
+	{
+		m_pSpacing->Override(other->GetSpacing());
+		m_pAboveLineSpacing->Override(other->GetAboveLineSpacing());
+		m_pParaSpacingAbove->Override(other->GetAboveSpacing());
+		m_pParaSpacingBelow->Override(other->GetBelowSpacing());
+	}
+}
+
+void LwpSpacingCommonOverride::Override(LwpSpacingCommonOverride* other)
+{
+    if (m_nOverride & SPO_TYPE)
+        other->OverrideType(m_nSpacingType);
+    if (m_nOverride & SPO_AMOUNT)
+        other->OverrideAmount(m_nAmount);
+    if (m_nOverride & SPO_MULTIPLE)
+        other->OverrideMultiple(m_nMultiple); 
+}
+
+void LwpSpacingCommonOverride::OverrideType(SpacingType val)
+{
+    m_nSpacingType = val;
+    m_nOverride |= SPO_TYPE;
+}
+
+void LwpSpacingCommonOverride::OverrideAmount(sal_Int32 val)
+{
+    m_nAmount = val;
+    m_nOverride |= SPO_AMOUNT;
+}
+
+void LwpSpacingCommonOverride::OverrideMultiple(sal_Int32 val)
+{
+    m_nMultiple = val;
+    m_nOverride |= SPO_MULTIPLE;
+}
diff -urNp lotuswordpro.bak/source/filter/lwpoverride.hxx lotuswordpro/source/filter/lwpoverride.hxx
--- lotuswordpro.bak/source/filter/lwpoverride.hxx	1970-01-01 08:00:00.000000000 +0800
+++ lotuswordpro/source/filter/lwpoverride.hxx	2008-10-22 11:42:29.000000000 +0800
@@ -0,0 +1,438 @@
+/*************************************************************************
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: IBM Corporation
+ *
+ *  Copyright: 2008 by IBM Corporation
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+/*************************************************************************
+ * @file 
+ *  For LWP filter architecture prototype
+ ************************************************************************/
+/*************************************************************************
+ * Change History
+ Jan 2005			Created
+ ************************************************************************/
+ 
+#ifndef _LWPOVERRIDE_HXX
+#define _LWPOVERRIDE_HXX
+
+#include "lwpobjid.hxx"
+#include "lwptools.hxx"
+
+class LwpObjectStream;
+
+enum STATE
+{
+	STATE_OFF	= 0,
+	STATE_ON	= 1,
+	STATE_STYLE	= 2
+};
+
+class LwpOverride
+{
+public:
+	LwpOverride() : m_nValues(0), m_nOverride(0), m_nApply(0) {};
+
+	virtual ~LwpOverride(){}
+
+	virtual void Read(LwpObjectStream* pStrm) = 0;
+
+	virtual void operator=(const LwpOverride& rOther);
+
+	void ReadCommon(LwpObjectStream* pStrm);
+
+	void Clear();
+
+	void Override(sal_uInt16 nBits, STATE eState);
+	
+protected:
+	sal_uInt16	m_nValues;
+	sal_uInt16	m_nOverride;
+	sal_uInt16	m_nApply;
+};
+
+/////////////////////////////////////////////////////////////////
+class LwpTextLanguageOverride : public LwpOverride
+{
+public:
+	LwpTextLanguageOverride() : m_nLanguage(0) {};
+
+	void Read(LwpObjectStream* pStrm);
+	
+private:
+	sal_uInt16	m_nLanguage;
+};
+
+/////////////////////////////////////////////////////////////////
+class LwpTextAttributeOverride : public LwpOverride
+{
+public:
+	LwpTextAttributeOverride() : m_nHideLevels(0), m_nBaseLineOffset(0) {};
+
+	void Read(LwpObjectStream* pStrm);
+
+	inline sal_uInt16 GetHideLevels() const;
+	
+	sal_Bool IsHighLight();
+	
+private:
+	enum{
+	TAO_HIGHLIGHT = 0x08,
+	};
+	sal_uInt16	m_nHideLevels;
+	sal_uInt32	m_nBaseLineOffset;
+};
+
+inline sal_uInt16 LwpTextAttributeOverride::GetHideLevels() const
+{
+	return m_nHideLevels;
+}
+/////////////////////////////////////////////////////////////////
+class LwpKinsokuOptsOverride : public LwpOverride
+{
+public:
+	LwpKinsokuOptsOverride() : m_nLevels(0) {};
+
+	void Read(LwpObjectStream* pStrm);
+	
+private:
+	sal_uInt16	m_nLevels;
+};
+
+/////////////////////////////////////////////////////////////////
+class LwpBulletOverride : public LwpOverride
+{
+public:
+	LwpBulletOverride() {m_bIsNull = sal_True;}
+
+	void Read(LwpObjectStream* pStrm);
+
+	inline LwpObjectID GetSilverBullet() const;
+
+	void operator=(const LwpOverride& rOther);
+	
+	void Override(LwpBulletOverride* pOther);
+
+	inline sal_Bool IsSilverBulletOverridden();
+	inline sal_Bool IsSkipOverridden();
+	inline sal_Bool IsRightAlignedOverridden();
+	inline sal_Bool IsSkip();
+	inline sal_Bool IsRightAligned();
+	inline sal_Bool IsEditable();
+
+	
+	void OverrideSilverBullet(LwpObjectID aID);
+	void OverrideSkip(sal_Bool bOver);
+	void OverrideRightAligned(sal_Bool bOver);
+
+	inline void RevertSilverBullet();
+	inline void RevertSkip();
+	inline void RevertRightAligned();
+
+	sal_Bool IsInValid(){return m_bIsNull;}
+private:
+	enum
+	{
+		BO_SILVERBULLET	= 0x01,
+		// 0x02 is free
+		BO_RIGHTALIGN	= 0x04,
+		BO_EDITABLE		= 0x08,
+		BO_SKIP			= 0x10
+	};
+	
+	LwpObjectID	m_SilverBullet;
+	sal_Bool m_bIsNull;
+};
+inline LwpObjectID LwpBulletOverride::GetSilverBullet() const
+{
+	return m_SilverBullet;
+}
+
+inline sal_Bool LwpBulletOverride::IsSilverBulletOverridden()
+{
+	return (sal_Bool)((m_nOverride & BO_SILVERBULLET) != 0);
+}
+
+inline sal_Bool LwpBulletOverride::IsSkipOverridden()
+{
+	return (sal_Bool)((m_nOverride & BO_SKIP) != 0);
+}
+
+inline sal_Bool LwpBulletOverride::IsRightAlignedOverridden()
+{
+	return (sal_Bool)((m_nOverride & BO_RIGHTALIGN) != 0);
+}
+
+inline sal_Bool LwpBulletOverride::IsSkip()
+{
+	return (sal_Bool)((m_nValues & BO_SKIP) != 0);
+}
+
+inline sal_Bool LwpBulletOverride::IsEditable()
+{
+	return (sal_Bool)((m_nValues & BO_EDITABLE) != 0);	
+}
+
+inline sal_Bool LwpBulletOverride::IsRightAligned()
+{
+	return (sal_Bool)((m_nValues & BO_RIGHTALIGN) != 0);
+}
+
+inline void LwpBulletOverride::RevertSilverBullet()
+{
+	LwpOverride::Override(BO_SILVERBULLET, STATE_STYLE);
+}
+
+inline void LwpBulletOverride::RevertSkip()
+{
+	LwpOverride::Override(BO_SKIP, STATE_STYLE);
+}
+
+inline void LwpBulletOverride::RevertRightAligned()
+{
+	LwpOverride::Override(BO_RIGHTALIGN, STATE_STYLE);
+}
+
+/////////////////////////////////////////////////////////////////
+class LwpAlignmentOverride : public LwpOverride
+{
+public:
+	LwpAlignmentOverride() : m_nAlignType(ALIGN_LEFT), m_nPosition(0), m_nAlignChar(0){};
+	
+	void Read(LwpObjectStream* pStrm);	
+
+	enum AlignType
+	{
+		ALIGN_LEFT			= 0,
+		ALIGN_RIGHT			= 1,
+		ALIGN_CENTER		= 2,
+		ALIGN_JUSTIFY		= 3,
+		ALIGN_JUSTIFYALL	= 4,
+		ALIGN_NUMERICLEFT	= 5,
+		ALIGN_NUMERICRIGHT	= 6,
+		ALIGN_SQUEEZE		= 7
+	};
+	
+	AlignType GetAlignType(){ return m_nAlignType; }
+	void Override(LwpAlignmentOverride* other);//add by  1-24
+	void OverrideAlignment(AlignType val);//add by  1-24
+private:
+	enum
+	{
+		AO_TYPE		= 0x01,
+		AO_POSITION	= 0x02,
+		AO_CHAR		= 0x04
+	};
+
+	AlignType	m_nAlignType;
+	sal_uInt32	m_nPosition;
+	sal_uInt16	m_nAlignChar;
+};
+
+/////////////////////////////////////////////////////////////////
+class LwpSpacingCommonOverride : public LwpOverride
+{
+public:
+	LwpSpacingCommonOverride() : m_nSpacingType(SPACING_NONE), m_nAmount(0), m_nMultiple(65536){};
+	
+	void Read(LwpObjectStream* pStrm);
+
+	enum SpacingType
+	{
+		SPACING_DYNAMIC	= 0,
+		SPACING_LEADING	= 1,
+		SPACING_CUSTOM	= 2,
+		SPACING_NONE	= 3
+	};
+	
+	SpacingType GetType() const {return m_nSpacingType;};
+	sal_Int32 GetAmount() const {return m_nAmount;};
+	sal_Int32 GetMultiple() const {return m_nMultiple;};
+	
+	void Override(LwpSpacingCommonOverride* other);
+	void OverrideType(SpacingType val);
+	void OverrideAmount(sal_Int32 val);
+	void OverrideMultiple(sal_Int32 val);
+	
+protected:
+	enum
+	{
+		SPO_TYPE	= 0x01,
+		SPO_AMOUNT	= 0x02,
+		SPO_MULTIPLE= 0x04
+	};
+	SpacingType	m_nSpacingType;//sal_uInt16
+	sal_Int32	m_nAmount;
+	sal_Int32	m_nMultiple;
+	
+};
+
+/////////////////////////////////////////////////////////////////
+class LwpSpacingOverride : public LwpOverride
+{
+public:
+	LwpSpacingOverride();
+	LwpSpacingOverride& operator=(LwpSpacingOverride& other);
+	virtual ~LwpSpacingOverride();
+
+	void Read(LwpObjectStream* pStrm);
+	
+	void Override(LwpSpacingOverride* other);
+	
+	LwpSpacingCommonOverride* GetSpacing(){return m_pSpacing;};
+	LwpSpacingCommonOverride* GetAboveLineSpacing(){return m_pAboveLineSpacing;};
+	LwpSpacingCommonOverride* GetAboveSpacing(){return m_pParaSpacingAbove;};
+	LwpSpacingCommonOverride* GetBelowSpacing(){return m_pParaSpacingBelow;};
+private:
+	LwpSpacingCommonOverride*	m_pSpacing;
+	LwpSpacingCommonOverride*	m_pAboveLineSpacing;
+	LwpSpacingCommonOverride*	m_pParaSpacingAbove;
+	LwpSpacingCommonOverride*	m_pParaSpacingBelow;
+};
+
+/////////////////////////////////////////////////////////////////
+class LwpIndentOverride : public LwpOverride
+{
+public:
+	LwpIndentOverride() : m_nAll(0), m_nFirst(0), m_nRest(0), m_nRight(0) {};
+	LwpIndentOverride& operator=(LwpIndentOverride& other);
+	void Read(LwpObjectStream* pStrm);
+
+	enum
+	{
+		RELATIVE_FIRST, RELATIVE_REST, RELATIVE_ALL
+	};
+
+	inline double GetFirst() const;
+	inline double GetLeft() const;
+	inline double GetRight() const;
+	
+	sal_uInt16 GetRelative();
+	sal_Bool IsUseRelative();
+	void Override(LwpIndentOverride* other);
+	void OverrideIndentAll(sal_Int32 val);
+	void OverrideIndentFirst(sal_Int32 val);
+	void OverrideIndentRight(sal_Int32 val);	
+    void OverrideIndentRest(sal_Int32 val);	
+    void OverrideUseRelative(sal_Bool use);    
+    void OverrideRelative(sal_uInt16 relative);
+    sal_Int32 GetMAll() const {return m_nAll;}
+    sal_Int32 GetMFirst() const {return m_nFirst;}
+    sal_Int32 GetMRest() const {return m_nRest;}
+    sal_Int32 GetMRight() const {return m_nRight;}
+    void SetMAll(sal_Int32 val){m_nAll=val;}
+    void SetMFirst(sal_Int32 val){m_nFirst=val;}
+    void SetMRest(sal_Int32 val){m_nRest=val;}
+    void SetMRight(sal_Int32 val){m_nRight=val;}
+private:
+	enum
+	{
+		IO_ALL			= 0x0001,
+		IO_FIRST		= 0x0002,
+		IO_REST			= 0x0004,
+		IO_RIGHT		= 0x0008,
+		IO_HANGING		= 0x0010,
+		IO_EQUAL		= 0x0020,
+		IO_BODY			= 0x0040,
+		IO_REL_ALL		= 0x0080,
+		IO_REL_FIRST	= 0x0100,
+		IO_REL_REST		= 0x0200,
+		IO_REL_FLAGS	= (IO_REL_ALL | IO_REL_FIRST | IO_REL_REST),
+#ifdef JAPANESE_ENABLED // 96/4/8 ueda for indentation by char width
+		IO_USE_RELATIVE	= 0x0400,
+		IO_CHARUNIT		= 0x0800
+#else
+		IO_USE_RELATIVE	= 0x0400
+#endif
+	};
+
+	sal_Int32	m_nAll;
+	sal_Int32	m_nFirst;
+	sal_Int32	m_nRest;
+	sal_Int32	m_nRight;
+};
+inline double LwpIndentOverride::GetFirst() const
+{
+        return LwpTools::ConvertToMetric(LwpTools::ConvertFromUnits(m_nFirst-m_nRest));
+}
+inline double LwpIndentOverride::GetLeft() const
+{ 
+        return LwpTools::ConvertToMetric(LwpTools::ConvertFromUnits(m_nAll+m_nRest));
+}
+inline double LwpIndentOverride::GetRight() const
+{ 
+	return LwpTools::ConvertToMetric(LwpTools::ConvertFromUnits(m_nRight));
+}
+
+/////////////////////////////////////////////////////////////////
+class LwpBackgroundStuff;
+class LwpAmikakeOverride : public LwpOverride
+{
+public:
+	LwpAmikakeOverride();
+
+	virtual ~LwpAmikakeOverride();
+	
+	void Read(LwpObjectStream* pStrm);
+	enum
+	{
+		AMIKAKE_NONE		= 0,
+		AMIKAKE_BACKGROUND	= 1,
+		AMIKAKE_CHARACTER	= 2
+	};
+	
+private:
+	LwpBackgroundStuff*	m_pBackgroundStuff;
+	sal_uInt16		m_nType;
+	
+};
+
+#endif
diff -urNp lotuswordpro.bak/source/filter/lwppagehint.cxx lotuswordpro/source/filter/lwppagehint.cxx
--- lotuswordpro.bak/source/filter/lwppagehint.cxx	1970-01-01 08:00:00.000000000 +0800
+++ lotuswordpro/source/filter/lwppagehint.cxx	2008-10-22 11:42:29.000000000 +0800
@@ -0,0 +1,119 @@
+/*************************************************************************
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: IBM Corporation
+ *
+ *  Copyright: 2008 by IBM Corporation
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+/*************************************************************************
+ * @file 
+ *  For LWP filter architecture prototype
+ ************************************************************************/
+/*************************************************************************
+ * Change History
+ Feb 2005			Created
+ ************************************************************************/
+
+#include "lwppagehint.hxx"
+
+
+void LwpSLVListHead::Read(LwpObjectStream* pObjStrm)
+{
+	m_ListHead.ReadIndexed(pObjStrm);
+	pObjStrm->SkipExtra();
+}
+
+void LwpContentHintHead::Read(LwpObjectStream* pObjStrm)
+{
+	m_ListHead.Read(pObjStrm);
+	pObjStrm->SkipExtra();
+}
+
+void LwpFootnoteSeenHead::Read(LwpObjectStream* pObjStrm)
+{
+	m_ListHead.Read(pObjStrm);
+	pObjStrm->SkipExtra();
+}
+
+LwpPageHint::LwpPageHint(LwpObjectHeader &objHdr, LwpSvStream *pStrm)
+	:LwpDLVList(objHdr,pStrm)
+{
+}
+
+void LwpPageHint::Read()
+{
+	LwpDLVList::Read();
+	
+	m_PageLayout.ReadIndexed(m_pObjStrm);
+	//m_ContentHints.ReadIndexed(m_pObjStrm);
+	m_ContentHints.Read(m_pObjStrm);
+	m_pObjStrm->QuickRead(&m_nLastFootnoteSeen,sizeof(m_nLastFootnoteSeen));
+	m_pObjStrm->QuickRead(&m_nLastFootnoteProcessed,sizeof(m_nLastFootnoteProcessed));
+	m_pObjStrm->QuickRead(&m_nFlags,sizeof(m_nFlags));
+	m_pObjStrm->QuickRead(&m_nPageNumber,sizeof(m_nPageNumber));
+	m_pObjStrm->QuickRead(&m_nNumberStyle,sizeof(m_nNumberStyle));
+	m_BeforeText.Read(m_pObjStrm);
+	m_AfterText.Read(m_pObjStrm);
+	m_pObjStrm->QuickRead(&m_nNumberFlags,sizeof(m_nNumberFlags));
+	m_pObjStrm->QuickRead(&m_nRenderedPageNumber,sizeof(m_nRenderedPageNumber));
+	m_CurrentSection.ReadIndexed(m_pObjStrm);
+	m_pObjStrm->QuickRead(&m_nCurrentSectionPage,sizeof(m_nCurrentSectionPage));
+	//m_FootnoteSeen.ReadIndexed(m_pObjStrm);
+	m_FootnoteSeen.Read(m_pObjStrm);
+	m_pObjStrm->QuickRead(&m_nLayoutPageNumber,sizeof(m_nLayoutPageNumber));
+
+	m_pObjStrm->SkipExtra();
+}
+
+void LwpPageHint::Parse(IXFStream *pOutputStream)
+{
+}
+
+
diff -urNp lotuswordpro.bak/source/filter/lwppagehint.hxx lotuswordpro/source/filter/lwppagehint.hxx
--- lotuswordpro.bak/source/filter/lwppagehint.hxx	1970-01-01 08:00:00.000000000 +0800
+++ lotuswordpro/source/filter/lwppagehint.hxx	2008-10-22 11:42:29.000000000 +0800
@@ -0,0 +1,129 @@
+/*************************************************************************
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: IBM Corporation
+ *
+ *  Copyright: 2008 by IBM Corporation
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+/*************************************************************************
+ * @file 
+ *  For LWP filter architecture prototype
+ ************************************************************************/
+/*************************************************************************
+ * Change History
+ Feb 2005			Created
+ ************************************************************************/
+#ifndef _LWPPAGEHINT_HXX
+#define _LWPPAGEHINT_HXX
+
+#include "lwpobj.hxx"
+#include "lwpobjid.hxx"
+#include "lwpatomholder.hxx"
+#include "lwpdlvlist.hxx"
+
+class LwpSLVListHead
+{
+public:
+	LwpSLVListHead(){};
+	void Read(LwpObjectStream* pObjStrm);
+private:
+	LwpObjectID m_ListHead;
+};
+
+class LwpContentHintHead
+{
+public:
+	LwpContentHintHead(){};
+	void Read(LwpObjectStream* pObjStrm);
+private:
+	LwpSLVListHead m_ListHead;
+};
+
+class LwpFootnoteSeenHead
+{
+public:
+	LwpFootnoteSeenHead(){};
+	void Read(LwpObjectStream* pObjStrm);
+private:
+	LwpSLVListHead m_ListHead;
+};
+
+class LwpPageHint : public LwpDLVList
+{
+public:
+	LwpPageHint(LwpObjectHeader &objHdr, LwpSvStream* pStrm);
+	~LwpPageHint(){};
+	void Read();
+	void Parse(IXFStream* pOutputStream);
+	sal_uInt16 GetPageNumber(){return m_nPageNumber;}
+	LwpObjectID* GetCurrentSectionID(){return &m_CurrentSection;}
+	sal_uInt16 GetCurrentSectionPage(){return m_nCurrentSectionPage;}
+	LwpObjectID* GetPageLayoutID(){ return &m_PageLayout;}
+	sal_uInt16 GetLayoutPageNumber(){ return m_nLayoutPageNumber;}
+private:
+
+	LwpObjectID m_PageLayout;
+	LwpContentHintHead m_ContentHints;
+	sal_uInt16 m_nLastFootnoteSeen;
+	sal_uInt16 m_nLastFootnoteProcessed;
+	sal_uInt16 m_nFlags;
+	sal_uInt16 m_nPageNumber;
+	sal_uInt16 m_nNumberStyle;
+	LwpAtomHolder m_BeforeText;
+	LwpAtomHolder m_AfterText;
+	sal_uInt8 m_nNumberFlags;
+	sal_uInt16 m_nRenderedPageNumber;
+	LwpObjectID m_CurrentSection;
+	sal_uInt16 m_nCurrentSectionPage;
+	LwpFootnoteSeenHead m_FootnoteSeen;
+	sal_uInt16 m_nLayoutPageNumber;
+};
+
+#endif //
\ No newline at end of file
diff -urNp lotuswordpro.bak/source/filter/lwppagelayout.cxx lotuswordpro/source/filter/lwppagelayout.cxx
--- lotuswordpro.bak/source/filter/lwppagelayout.cxx	1970-01-01 08:00:00.000000000 +0800
+++ lotuswordpro/source/filter/lwppagelayout.cxx	2008-10-22 11:42:29.000000000 +0800
@@ -0,0 +1,1061 @@
+/*************************************************************************
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: IBM Corporation
+ *
+ *  Copyright: 2008 by IBM Corporation
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+/*************************************************************************
+ * Change History
+Mar 2005			Created
+ ************************************************************************/
+#include "lwppagelayout.hxx"
+#include "lwplaypiece.hxx"
+#include "lwpfootnote.hxx"
+#include "lwpdoc.hxx"
+#include "lwpholder.hxx"
+#include "lwppagehint.hxx"
+#include "lwpdivinfo.hxx"
+#include "lwpstory.hxx"
+#include "xfilter/xfstylemanager.hxx"
+#include "xfilter/xfmasterpage.hxx"
+#include "xfilter/xfcontentcontainer.hxx"
+#include "xfilter/xfheader.hxx"
+#include "xfilter/xfheaderstyle.hxx"
+#include "xfilter/xffooterstyle.hxx"
+#include "xfilter/xffooter.hxx"
+#include <sfx2/printer.hxx>
+#include "lwpchangemgr.hxx"
+#include "lwpglobalmgr.hxx"
+
+LwpPageLayout::LwpPageLayout(LwpObjectHeader &objHdr, LwpSvStream* pStrm)
+	: LwpLayout(objHdr, pStrm), m_pPrinterBinName(new LwpAtomHolder),
+	m_pPaperName(new LwpAtomHolder),m_pXFPageMaster(NULL)
+{
+}
+
+LwpPageLayout::~LwpPageLayout()
+{
+	if (m_pPrinterBinName)
+	{
+		delete m_pPrinterBinName;
+	}
+	if (m_pPaperName)
+	{
+		delete m_pPaperName;
+	}
+}
+void LwpPageLayout::Read()
+{
+	LwpLayout::Read();
+
+	if (LwpFileHeader::m_nFileRevision < 0x000B)
+	{
+		// read PreRevBLayout...
+	}
+
+	m_pObjStrm->QuickRead(&m_nPrinterBin, sizeof(m_nPrinterBin));
+	m_pPrinterBinName->Read(m_pObjStrm);
+
+	if (LwpFileHeader::m_nFileRevision >= 0x000B)
+	{
+		m_pObjStrm->QuickRead(&m_nBdroffset, sizeof(m_nBdroffset));
+	}
+
+	if (m_pObjStrm->CheckExtra())
+	{
+		m_pPaperName->Read(m_pObjStrm);
+		m_pObjStrm->SkipExtra();
+	}
+	
+}
+
+void LwpPageLayout::Parse(IXFStream* pOutputStream)
+{
+	//Only parse this layout
+	LwpObject* pStory = m_Content.obj();
+	if(pStory)
+	{
+		pStory->SetFoundry(m_pFoundry);
+		pStory->Parse(pOutputStream);	//Do not parse the next story
+	}
+}
+
+/**
+* @descr:   set page margins 
+* 		
+*/
+void LwpPageLayout::ParseMargins(XFPageMaster* pm1)
+{
+	double fLeft	= GetMarginsValue(MARGIN_LEFT);
+	double fRight	= GetMarginsValue(MARGIN_RIGHT);
+	double fTop	= GetMarginsValue(MARGIN_TOP);
+	double fBottom	= GetMarginsValue(MARGIN_BOTTOM);
+	
+	pm1->SetMargins( fLeft, fRight, fTop, fBottom );
+	
+}
+
+/**
+* @descr:   set page height and width
+* 		
+*/
+void LwpPageLayout::ParseGeometry(XFPageMaster* pm1)
+{
+	/*
+	LwpLayoutGeometry* pLayoutGeo = GetGeometry();
+	if(pLayoutGeo)
+	{
+		pm1->SetPageHeight( GetGeometryHeight() );
+		pm1->SetPageWidth( GetGeometryWidth() );
+	}
+	*/
+	double fWidth =0;
+	double fHeight = 0;
+	GetWidthAndHeight(fWidth, fHeight);
+	pm1->SetPageWidth( fWidth );
+	pm1->SetPageHeight( fHeight );	
+}
+
+/**
+* @descr:   set page watermark
+* 		
+*/
+void LwpPageLayout::ParseWaterMark(XFPageMaster *pm1)
+{
+	XFBGImage* pXFBGImage = GetXFBGImage();
+	if(pXFBGImage)
+	{
+		pm1->SetBackImage(pXFBGImage);
+	}
+}
+
+/**
+* @descr:   set page columns
+* 		
+*/
+void LwpPageLayout::ParseColumns(XFPageMaster * pm1)
+{
+	XFColumns* pColumns = GetXFColumns();
+	if(pColumns)
+	{
+		pm1->SetColumns(pColumns);
+	}	
+}
+
+/**
+* @descr:   set page borders
+* 		
+*/
+void LwpPageLayout::ParseBorders(XFPageMaster *pm1)
+{
+	XFBorders* pBordres = GetXFBorders();
+	if(pBordres)
+	{
+		pm1->SetBorders(pBordres);
+	}
+}
+
+
+/**
+* @descr:   set page shadow
+* 		
+*/
+void LwpPageLayout::ParseShadow(XFPageMaster *pm1)
+{
+	XFShadow* pXFShadow = GetXFShadow();
+	if(pXFShadow)
+	{
+		pm1->SetShadow(pXFShadow);
+	}
+}
+
+/**
+* @descr:   set page back pattern
+* 		
+*/
+void LwpPageLayout::ParsePatternFill(XFPageMaster* pm1)
+{
+	XFBGImage* pXFBGImage = this->GetFillPattern();
+	if (pXFBGImage)
+	{
+		pm1->SetBackImage(pXFBGImage);
+	}
+}
+/**
+* @descr:   set page background
+* 		
+*/
+void LwpPageLayout::ParseBackGround(XFPageMaster* pm1)
+{
+	if (this->IsPatternFill())
+	{
+		ParsePatternFill(pm1);
+	}
+	else
+	{
+		ParseBackColor(pm1);
+	}
+}
+
+/**
+* @descr:   set page back color
+* 		
+*/
+void LwpPageLayout::ParseBackColor(XFPageMaster* pm1)
+{
+	LwpColor* pColor = GetBackColor();
+	if(pColor)
+	{
+		pm1->SetBackColor(XFColor(pColor->To24Color()));
+	}	
+}
+
+/**
+* @descr:   set page footnote separator information
+* 		
+*/
+void LwpPageLayout::ParseFootNoteSeparator(XFPageMaster * pm1)
+{	
+	//Get the footnoteoptions for the root document
+	LwpDocument* pDocument = m_pFoundry->GetDocument();
+	if(pDocument)
+	{
+		LwpFootnoteOptions* pFootnoteOpts = static_cast<LwpFootnoteOptions*>(pDocument->GetValidFootnoteOpts()->obj());
+		if(pFootnoteOpts)
+		{
+			LwpFootnoteSeparatorOptions* pFootnoteSep = pFootnoteOpts->GetFootnoteSeparator();
+			//set length
+			sal_uInt32 nLengthPercent = 100;
+			double fWidth = 0;
+			if(pFootnoteSep->HasSeparator())
+			{
+				fWidth = pFootnoteSep->GetTopBorderWidth();
+			}
+			if(pFootnoteSep->HasCustomLength())
+			{				
+				nLengthPercent =  static_cast<sal_uInt32>(100*LwpTools::ConvertFromUnitsToMetric(pFootnoteSep->GetLength())/GetMarginWidth());
+				if(nLengthPercent > 100)
+					nLengthPercent = 100;
+			}
+			double fAbove = LwpTools::ConvertFromUnitsToMetric(pFootnoteSep->GetAbove());
+			double fBelow = LwpTools::ConvertFromUnitsToMetric(pFootnoteSep->GetBelow());
+			LwpColor aColor = pFootnoteSep->GetTopBorderColor();
+			enumXFAlignType eAlignType = enumXFAlignStart;
+			if(pFootnoteSep->GetIndent() > 0)
+			{
+				//SODC don't support indent
+				sal_uInt32 nIndentPercent =  static_cast<sal_uInt32>(100*LwpTools::ConvertFromUnitsToMetric(pFootnoteSep->GetIndent())/GetMarginWidth());
+				if(nIndentPercent + nLengthPercent >= 100)
+					eAlignType = enumXFAlignEnd;
+			}
+			if(aColor.IsValidColor())
+			{
+				XFColor aXFColor(aColor.To24Color());
+				pm1->SetFootNoteSeparator(eAlignType,fWidth, nLengthPercent, fAbove, fBelow, aXFColor);
+			}			
+		}
+	}	
+}
+
+/**
+* @descr:   Register master page and page master style
+* 		
+*/
+void LwpPageLayout::RegisterStyle()
+{
+	XFPageMaster* pm1 = new XFPageMaster();
+	m_pXFPageMaster = pm1;
+
+	ParseGeometry( pm1 );
+	//Does not process LayoutScale, for watermark is not supported in SODC.
+	ParseWaterMark( pm1);
+	ParseMargins( pm1);
+	ParseColumns(pm1);	
+	ParseBorders(pm1);
+	ParseShadow(pm1);
+//	ParseBackColor(pm1);
+	ParseBackGround(pm1);
+	ParseFootNoteSeparator(pm1);
+	pm1->SetTextDir(GetTextDirection());
+
+	LwpUseWhen* pUseWhen = GetUseWhen();
+	if(IsComplex() ||( pUseWhen && pUseWhen->IsUseOnAllOddPages()))
+	{
+		pm1->SetPageUsage(enumXFPageUsageMirror);
+	}
+
+	//Add the page master to stylemanager
+	XFStyleManager* pXFStyleManager = LwpGlobalMgr::GetInstance()->GetXFStyleManager(); 
+	OUString pmname = pXFStyleManager->AddStyle(pm1)->GetStyleName();
+	
+	//Add master page
+	XFMasterPage* mp1 = new XFMasterPage();
+	mp1->SetStyleName(GetName()->str());
+	mp1->SetPageMaster(pmname);
+	m_StyleName = pXFStyleManager->AddStyle(mp1)->GetStyleName();
+
+	//Set footer style
+	LwpFooterLayout* pLayoutFooter = GetFooterLayout();
+	if(pLayoutFooter)
+	{
+		pLayoutFooter->SetFoundry(m_pFoundry);
+		pLayoutFooter->RegisterStyle(pm1);
+		pLayoutFooter->RegisterStyle(mp1);
+	}
+		
+	//Set header style
+	LwpHeaderLayout* pLayoutHeader = GetHeaderLayout();
+	if(pLayoutHeader)
+	{
+		pLayoutHeader->SetFoundry(m_pFoundry);
+		pLayoutHeader->RegisterStyle(pm1);
+		pLayoutHeader->RegisterStyle(mp1);
+	}
+	//register child layout style for mirror page and frame
+	RegisterChildStyle();
+}
+
+/**
+* @descr:   Register master page for endnote which name is "endnote"
+* @return:  Return the master page name.		
+*/
+OUString LwpPageLayout::RegisterEndnoteStyle()
+{
+	XFPageMaster* pm1 = new XFPageMaster();
+	m_pXFPageMaster = pm1;
+
+	ParseGeometry( pm1 );	
+	ParseWaterMark( pm1);
+	ParseMargins( pm1);
+	ParseColumns(pm1);	
+	ParseBorders(pm1);
+	ParseShadow(pm1);
+//	ParseBackColor(pm1);
+	ParseBackGround(pm1);
+	//ParseFootNoteSeparator(pm1);
+	pm1->SetTextDir(GetTextDirection());
+
+	LwpUseWhen* pUseWhen = GetUseWhen();
+	if(IsComplex() ||( pUseWhen && pUseWhen->IsUseOnAllOddPages()))
+	{
+		pm1->SetPageUsage(enumXFPageUsageMirror);
+	}
+
+	//Add the page master to stylemanager
+	XFStyleManager* pXFStyleManager = LwpGlobalMgr::GetInstance()->GetXFStyleManager(); 
+	OUString pmname = pXFStyleManager->AddStyle(pm1)->GetStyleName();
+	
+	//Add master page
+	XFMasterPage* mp1 = new XFMasterPage();
+	mp1->SetStyleName(A2OUSTR("Endnote"));
+	mp1->SetPageMaster(pmname);
+
+	//Set footer style
+	LwpFooterLayout* pLayoutFooter = GetFooterLayout();
+	if(pLayoutFooter)
+	{
+		pLayoutFooter->SetFoundry(m_pFoundry);
+		pLayoutFooter->RegisterStyle(pm1);
+		pLayoutFooter->RegisterStyle(mp1);
+	}
+		
+	//Set header style
+	LwpHeaderLayout* pLayoutHeader = GetHeaderLayout();
+	if(pLayoutHeader)
+	{
+		pLayoutHeader->SetFoundry(m_pFoundry);
+		pLayoutHeader->RegisterStyle(pm1);
+		pLayoutHeader->RegisterStyle(mp1);
+	}
+
+	return pXFStyleManager->AddStyle(mp1)->GetStyleName();
+}
+/**
+* @descr:   Whether current page layout has columns
+* 		
+*/
+sal_Bool LwpPageLayout::HasColumns()
+{
+	return GetNumCols() > 1 ? sal_True : sal_False;
+}
+
+/**
+* @descr:   Whether has filler page text in current page layout
+* 		
+*/
+sal_Bool LwpPageLayout::HasFillerPageText(LwpFoundry* pFoundry)
+{
+	if(!pFoundry) return sal_False;
+
+	sal_Bool bFillerPage = sal_False;
+	LwpLayout::UseWhenType eWhenType = GetUseWhenType();
+	if(eWhenType==LwpLayout::StartOnOddPage||eWhenType==LwpLayout::StartOnEvenPage)
+	{
+		//get pagenumber
+		sal_uInt16 nPageNumber = 0;
+
+		//get the page number that current page layout inserted
+		nPageNumber = GetPageNumber(FIRST_LAYOUTPAGENO)-1;
+
+		if(nPageNumber>0)
+		{
+			if((eWhenType==LwpLayout::StartOnOddPage)&&(LwpTools::IsOddNumber(nPageNumber)))
+			{
+				bFillerPage = sal_True;
+			}
+			else if((eWhenType==LwpLayout::StartOnEvenPage)&&(LwpTools::IsEvenNumber(nPageNumber)))
+			{
+				bFillerPage = sal_True;
+			}
+			else
+			{
+				bFillerPage = sal_False;
+			}
+		}
+	}
+
+	return bFillerPage;
+}
+
+/**
+* @descr:   Parse filler page text
+* 		
+*/
+void LwpPageLayout::ConvertFillerPageText(XFContentContainer* pCont)
+{
+	if(HasFillerPageText(m_pFoundry))
+	{
+		//get filerpage story from division info
+		LwpDocument* pDoc = m_pFoundry->GetDocument();
+		LwpDivInfo* pDivInfo = static_cast<LwpDivInfo*>(pDoc->GetDivInfoID()->obj());
+		LwpStory* pStory = static_cast<LwpStory*>(pDivInfo->GetFillerPageTextID()->obj());
+		
+		//parse fillerpage story
+		if(pStory)
+		{
+			pStory->XFConvert(pCont);
+		}
+	}		
+}
+/**
+* @descr:   Clear columns style in page layout
+* 		
+*/
+void LwpPageLayout::ResetXFColumns()
+{
+	if(m_pXFPageMaster)
+	{
+		m_pXFPageMaster->SetColumns(NULL);
+	}	
+}
+
+LwpHeaderLayout* LwpPageLayout::GetHeaderLayout()
+{
+	LwpVirtualLayout* pLay = static_cast<LwpVirtualLayout*>(GetChildHead()->obj());
+	while(pLay)
+	{
+		if( pLay->GetLayoutType() == LWP_HEADER_LAYOUT )
+			return ( static_cast<LwpHeaderLayout*> (pLay) );
+		pLay = static_cast<LwpVirtualLayout*> (pLay->GetNext()->obj());
+	}
+	return NULL;
+}
+
+LwpFooterLayout* LwpPageLayout::GetFooterLayout()
+{
+	LwpVirtualLayout* pLay = static_cast<LwpVirtualLayout*>(GetChildHead()->obj());
+	while(pLay)
+	{
+		if( pLay->GetLayoutType() == LWP_FOOTER_LAYOUT )
+			return ( static_cast<LwpFooterLayout*> (pLay) );
+		pLay = static_cast<LwpVirtualLayout*> (pLay->GetNext()->obj());
+	}
+	return NULL;
+}
+
+/**
+* @descr:   Get the odd layout if current page layout is mirror page
+* 		
+*/
+LwpPageLayout* LwpPageLayout::GetOddChildLayout()
+{
+	if(IsComplex())
+	{
+		LwpVirtualLayout* pLay = static_cast<LwpVirtualLayout*>(GetChildHead()->obj());
+		while(pLay)
+		{			
+			if( pLay->GetLayoutType() == LWP_PAGE_LAYOUT )
+			{
+				LwpPageLayout* pPageLayout = static_cast<LwpPageLayout*> (pLay);
+				LwpUseWhen* pUseWhen = pPageLayout->GetUseWhen();
+				if(pUseWhen && pUseWhen->IsUseOnAllOddPages())
+				{
+					return pPageLayout;
+				}
+			}				
+			pLay = static_cast<LwpVirtualLayout*> (pLay->GetNext()->obj());
+		}
+	}	
+	return NULL;
+}
+
+/**
+* @descr:   Get margin width of page
+* 		
+*/
+double LwpPageLayout::GetMarginWidth()
+{	
+	double fPagewidth = GetGeometryWidth();
+	double fLeftMargin = GetMarginsValue(MARGIN_LEFT);
+	double fRightMargin = GetMarginsValue(MARGIN_RIGHT);
+
+	return fPagewidth - (fLeftMargin + fRightMargin);
+}
+
+/**
+ * @descr:  Get the pagenumber 
+ * @param:  if  nLayoutNumber =FIRST_LAYOUTPAGENO,  return the first page number  that current page layout covers
+ 						    =LAST_LAYOUTPAGENO, return the last page number that current page layout covers
+ 						    else, return the specified page number that current page layout covers
+ * @param:   
+ * @return:  if reture value >=0, success to find the page number, or fail.
+*/
+sal_Int32 LwpPageLayout::GetPageNumber(sal_uInt16 nLayoutNumber)
+{
+	sal_Int16 nPageNumber = -1;
+	LwpFoundry* pFoundry = this->GetFoundry();
+	LwpDocument* pDoc = pFoundry->GetDocument();	
+	LwpDLVListHeadTailHolder* pHeadTail = static_cast<LwpDLVListHeadTailHolder*>(pDoc->GetPageHintsID()->obj());
+	if(!pHeadTail) return nPageNumber;
+	
+	//get first pagehint
+	LwpPageHint* pPageHint =static_cast<LwpPageHint*>(pHeadTail->GetHead()->obj());		
+	while(pPageHint)
+	{					
+		if(*(this->GetObjectID()) == *(pPageHint->GetPageLayoutID()))
+		{
+			sal_uInt16 nNumber = pPageHint->GetPageNumber();
+			if(nLayoutNumber==FIRST_LAYOUTPAGENO && pPageHint->GetLayoutPageNumber()==1)
+			{
+				//get the first page number
+				nPageNumber = nNumber;	
+				break;
+			}
+			else if( nLayoutNumber ==LAST_LAYOUTPAGENO && nNumber >nPageNumber )
+			{
+				//get the last page number
+				nPageNumber = nNumber;
+				if(pPageHint->GetNext()->IsNull())
+				{
+					//if is last page number of entire document, reture directly
+					return nPageNumber + pDoc->GetNumberOfPagesBefore();
+				}				
+			}
+			else if(nLayoutNumber > 0 && pPageHint->GetLayoutPageNumber() == nLayoutNumber)
+			{
+				//get specified page number
+				nPageNumber = nNumber;				
+				break;
+			}
+			
+		}
+		pPageHint = static_cast<LwpPageHint*>(pPageHint->GetNext()->obj());		
+	}
+	if(nPageNumber>=0)
+	{
+		return nPageNumber + 1 + pDoc->GetNumberOfPagesBefore();
+	}
+	return -1;
+}
+
+/**
+* @descr:   Get page width and height
+* 		
+*/
+void LwpPageLayout::GetWidthAndHeight(double& fWidth, double& fHeight)
+{
+	//use customized size
+	LwpLayoutGeometry* pLayoutGeo = GetGeometry();
+	if(pLayoutGeo)
+	{
+		fWidth = GetGeometryWidth();
+		fHeight = GetGeometryHeight();
+	}
+	
+	if(GetUsePrinterSettings())
+	{		
+		//replaced by printer paper size
+		Printer aPrinter;
+		sal_Bool bScreen = aPrinter.IsDisplayPrinter();
+		if (!bScreen)//Printer available
+		{
+			Size aPaperSize = aPrinter.GetPaperSize();
+			aPaperSize = aPrinter.PixelToLogic( aPaperSize, MapMode( MAP_10TH_MM ) );
+			fWidth = static_cast<double>(aPaperSize.Width())/100;	//cm unit
+			fHeight = static_cast<double>(aPaperSize.Height())/100;
+		}		
+	}
+	
+	//Follow the former design of Lotus WordPro filter, some default will be given:
+	//Page Width: 8.5 Inch -> 21.59 cm
+	//Page Height: 11 Inch -> 27.94 cm
+	if (fWidth < 4.39)
+		fWidth = 21.59;
+	if (fHeight < 4.49)
+		fHeight = 27.94;
+	//End of modification, by ZF
+}
+
+/**
+* @descr:   Get page width
+* 		
+*/
+double LwpPageLayout::GetWidth()
+{
+	double fWidth =0, fHeight = 0;
+	GetWidthAndHeight(fWidth, fHeight);
+	return fWidth;
+}
+
+/**
+* @descr:   Get page height
+* 		
+*/
+double LwpPageLayout::GetHeight()
+{
+	double fWidth =0, fHeight = 0;
+	GetWidthAndHeight(fWidth, fHeight);
+	return fHeight;
+}
+/**
+* @descr:  Compare the position of layout. If the poistion of this layout is earlier than other layout,return ture, or return false
+* 		
+*/
+sal_Bool LwpPageLayout::operator<(LwpPageLayout& Other)
+{
+	LwpPara* pThisPara = GetPagePosition();
+	LwpPara* pOtherPara = Other.GetPagePosition();
+	if(pThisPara && pOtherPara)
+	{
+		if(pThisPara == pOtherPara)
+		{
+			//If the two layouts in the same para, compare which layout is earlied according to frib order
+			return pThisPara->ComparePagePosition(this, &Other);
+		}
+		else
+		{
+			return *pThisPara < *pOtherPara;
+		}
+	}		
+
+	if(!pThisPara)
+		return sal_True;
+
+	return sal_False;
+}
+
+/**
+* @descr:  Get the position of pagelayout
+* 		
+*/
+LwpPara* LwpPageLayout::GetPagePosition()
+{
+	LwpPara* pPara = static_cast<LwpPara*>(GetPosition()->obj());
+	if(pPara)
+		return pPara;
+	//Get the position from its related section
+	LwpSection* pSection = NULL;
+	LwpFoundry* pFoundry = GetFoundry();
+	if(pFoundry)
+	{
+		while(pSection = pFoundry->EnumSections(pSection))
+		{
+			if(pSection->GetPageLayout() == this)
+				return static_cast<LwpPara*>(pSection->GetPosition()->obj());
+		}
+	}
+
+	return NULL;
+}
+LwpHeaderLayout::LwpHeaderLayout( LwpObjectHeader &objHdr, LwpSvStream* pStrm )
+	: LwpPlacableLayout(objHdr, pStrm)
+{
+}
+
+LwpHeaderLayout::~LwpHeaderLayout()
+{
+}
+
+void LwpHeaderLayout::Read()
+{
+	LwpPlacableLayout::Read();
+	
+	if(LwpFileHeader::m_nFileRevision >= 0x000E)
+	{
+		m_pObjStrm->QuickRead(&m_nBorderOffset, sizeof(m_nBorderOffset));
+	}
+	else
+		m_nBorderOffset = 0;
+	m_pObjStrm->SkipExtra();	
+}
+
+
+void LwpHeaderLayout::RegisterStyle(XFPageMaster* pm1)
+{
+	XFHeaderStyle* pHeaderStyle = new XFHeaderStyle();
+
+	//Modify page top margin
+	//page top maring: from top of header to the top edge
+	double top = GetMarginsValue(MARGIN_TOP);
+	pm1->SetMargins(-1, -1, top, -1);
+
+	ParseMargins(pHeaderStyle);
+	ParseBorder(pHeaderStyle);
+	ParseShadow(pHeaderStyle);
+//	ParseBackColor(pHeaderStyle);
+	ParseBackGround(pHeaderStyle);
+	
+	ParseWaterMark(pHeaderStyle);
+	//End by 
+
+	pm1->SetHeaderStyle(pHeaderStyle);
+}
+
+void LwpHeaderLayout::ParseMargins(XFHeaderStyle* ph1)
+{
+	//Set height: from top of header to top of body, including the spacing between header and body
+	double height = GetGeometryHeight()- GetMarginsValue(MARGIN_TOP);
+	if( IsAutoGrowDown() )
+	{
+		ph1->SetMinHeight(height);
+	}
+	else
+	{
+		ph1->SetHeight(height);
+	}
+
+	//Set left,right,bottom margins
+	LwpMiddleLayout* parent = static_cast<LwpMiddleLayout*> (GetParent()->obj());
+	//left margin in SODC: the space from the left edge of body to the left edge of header
+	double left = GetMarginsValue(MARGIN_LEFT) - parent->GetMarginsValue(MARGIN_LEFT);
+	if(left<=0)	//The left margin in SODC can not be minus value
+	{
+		left = -1;
+	}
+	//left margin in SODC: the space from the right edge of header to the right edge of body
+	double right = GetMarginsValue(MARGIN_RIGHT) - parent->GetMarginsValue(MARGIN_RIGHT);
+	if(right<=0)//The right margin in SODC can not be minus value
+	{
+		right = -1;
+	}
+	ph1->SetMargins( left, right, GetMarginsValue(MARGIN_BOTTOM));
+
+	//Word Pro has no dynamic spacing, should be set to false
+	ph1->SetDynamicSpace(sal_False);
+}
+
+void LwpHeaderLayout::ParseBorder(XFHeaderStyle* pHeaderStyle)
+{
+	XFBorders* pBordres = GetXFBorders();
+	if(pBordres)
+	{
+		pHeaderStyle->SetBorders(pBordres);
+	}
+}
+
+void LwpHeaderLayout::ParseShadow(XFHeaderStyle* pHeaderStyle)
+{
+	XFShadow* pXFShadow = GetXFShadow();
+	if(pXFShadow)
+	{
+		pHeaderStyle->SetShadow(pXFShadow);
+	}
+}
+
+/**
+* @descr:   set header back pattern
+* 		
+*/
+void LwpHeaderLayout::ParsePatternFill(XFHeaderStyle* pHeaderStyle)
+{
+	XFBGImage* pXFBGImage = this->GetFillPattern();
+	if (pXFBGImage)
+	{
+		pHeaderStyle->SetBackImage(pXFBGImage);
+	}
+}
+/**
+* @descr:   set header background
+* 		
+*/
+void LwpHeaderLayout::ParseBackGround(XFHeaderStyle* pHeaderStyle)
+{
+	if (this->IsPatternFill())
+	{
+		ParsePatternFill(pHeaderStyle);
+	}
+	else
+	{
+		ParseBackColor(pHeaderStyle);
+	}
+}
+
+void LwpHeaderLayout::ParseBackColor(XFHeaderStyle* pHeaderStyle)
+{
+	LwpColor* pColor = GetBackColor();
+	if(pColor)
+	{
+		pHeaderStyle->SetBackColor(XFColor(pColor->To24Color()));
+	}		
+}
+
+
+void LwpHeaderLayout::ParseWaterMark(XFHeaderStyle * pHeaderStyle)
+{
+	XFBGImage* pXFBGImage = GetXFBGImage();
+	if(pXFBGImage)
+	{
+		pHeaderStyle->SetBackImage(pXFBGImage);
+	}
+}
+//End by 
+
+void LwpHeaderLayout::RegisterStyle(XFMasterPage* mp1)
+{
+	XFHeader* pHeader = new XFHeader();
+	LwpObject* pStory = m_Content.obj();
+	if(pStory)
+	{	
+		LwpGlobalMgr* pGlobal = LwpGlobalMgr::GetInstance(); 
+		LwpChangeMgr* pChangeMgr = pGlobal->GetLwpChangeMgr();
+		pChangeMgr->SetHeadFootFribMap(sal_True);
+		
+		//Call the RegisterStyle first to register the styles in header paras, and then XFConvert()
+		pStory->SetFoundry(m_pFoundry);
+		pStory->RegisterStyle();
+		//, 06/27/2005
+		//register child layout style for framelayout,
+		RegisterChildStyle();
+		//End
+		pChangeMgr->SetHeadFootChange(pHeader);
+		pStory->XFConvert(pHeader);
+		
+		pChangeMgr->SetHeadFootFribMap(sal_False);			
+	}
+	mp1->SetHeader(pHeader);
+}
+
+LwpFooterLayout::LwpFooterLayout( LwpObjectHeader &objHdr, LwpSvStream* pStrm )
+	: LwpPlacableLayout( objHdr, pStrm )
+{
+}
+
+LwpFooterLayout::~LwpFooterLayout()
+{
+}
+
+void LwpFooterLayout::Read()
+{
+	LwpPlacableLayout::Read();
+	
+	if(LwpFileHeader::m_nFileRevision >= 0x000E)
+	{
+		m_pObjStrm->QuickRead(&m_nBorderOffset, sizeof(m_nBorderOffset));
+	}
+	else
+		m_nBorderOffset = 0;
+	m_pObjStrm->SkipExtra();	
+}
+
+void LwpFooterLayout::RegisterStyle(XFPageMaster* pm1)
+{
+	XFFooterStyle* pFooterStyle = new XFFooterStyle();
+
+	//Modify page bottom margin
+	//page bottom maring: from bottom of footer to the bottom edge
+	double bottom = GetMarginsValue(MARGIN_BOTTOM);
+	pm1->SetMargins(-1, -1, -1, bottom);
+
+	ParseMargins(pFooterStyle);
+	ParseBorder(pFooterStyle);
+	ParseShadow(pFooterStyle);
+	ParseBackGround(pFooterStyle);
+//	ParseBackColor(pFooterStyle);
+	
+	ParseWaterMark(pFooterStyle); 
+	//End by 
+
+	pm1->SetFooterStyle(pFooterStyle);
+}
+
+void LwpFooterLayout::ParseMargins(XFFooterStyle* pFooterStyle)
+{
+
+	//Set height: from top of header to top of body, including the spacing between header and body	
+	double height = GetGeometryHeight() - GetMarginsValue(MARGIN_BOTTOM);
+	if( IsAutoGrowUp() )
+	{
+		pFooterStyle->SetMinHeight(height);
+	}
+	else
+	{
+		pFooterStyle->SetHeight(height);
+	}
+
+	//Set left,right,top margins
+	LwpMiddleLayout* parent = static_cast<LwpMiddleLayout*> (GetParent()->obj());
+	double left = GetMarginsValue(MARGIN_LEFT) - parent->GetMarginsValue(MARGIN_LEFT);
+	if(left<=0)	//The left margin in SODC can not be minus value
+	{
+		left = -1;
+	}
+	double right = GetMarginsValue(MARGIN_RIGHT) - parent->GetMarginsValue(MARGIN_RIGHT);
+	if(right<=0)//The left margin in SODC can not be minus value
+	{
+		right = -1;
+	}
+	pFooterStyle->SetMargins( left, right, GetMarginsValue(MARGIN_TOP));
+	
+	//Word Pro has no dynamic spacing, should be set to false
+	pFooterStyle->SetDynamicSpace(sal_False);
+}
+
+void LwpFooterLayout::ParseBorder(XFFooterStyle* pFooterStyle)
+{
+	XFBorders* pBordres = GetXFBorders();
+	if(pBordres)
+	{
+		pFooterStyle->SetBorders(pBordres);
+	}
+}
+
+void LwpFooterLayout::ParseShadow(XFFooterStyle* pFooterStyle)
+{
+	XFShadow* pXFShadow = GetXFShadow();
+	if(pXFShadow)
+	{
+		pFooterStyle->SetShadow(pXFShadow);
+	}
+}
+/**
+* @descr:   set footer back pattern
+* 		
+*/
+void LwpFooterLayout::ParsePatternFill(XFFooterStyle* pFooterStyle)
+{
+	XFBGImage* pXFBGImage = this->GetFillPattern();
+	if (pXFBGImage)
+	{
+		pFooterStyle->SetBackImage(pXFBGImage);
+	}
+}
+/**
+* @descr:   set footer background
+* 		
+*/
+void LwpFooterLayout::ParseBackGround(XFFooterStyle* pFooterStyle)
+{
+	if (this->IsPatternFill())
+	{
+		ParsePatternFill(pFooterStyle);
+	}
+	else
+	{
+		ParseBackColor(pFooterStyle);
+	}
+}
+
+void LwpFooterLayout::ParseBackColor(XFFooterStyle* pFooterStyle)
+{
+	LwpColor* pColor = GetBackColor();
+	if(pColor)
+	{
+		pFooterStyle->SetBackColor(XFColor(pColor->To24Color()));
+	}		
+}
+
+void LwpFooterLayout::RegisterStyle(XFMasterPage* mp1)
+{
+	XFFooter* pFooter = new XFFooter();
+	LwpObject* pStory = m_Content.obj(VO_STORY);
+	//Call the RegisterStyle first to register the styles in footer paras, and then XFConvert()
+	if(pStory)
+	{
+		LwpGlobalMgr* pGlobal = LwpGlobalMgr::GetInstance(); 
+		LwpChangeMgr* pChangeMgr = pGlobal->GetLwpChangeMgr();
+		pChangeMgr->SetHeadFootFribMap(sal_True);
+		
+		pStory->SetFoundry(m_pFoundry);
+		pStory->RegisterStyle();
+		//, 06/27/2005
+		//register child layout style for framelayout,
+		RegisterChildStyle();
+		//End
+		
+		pChangeMgr->SetHeadFootChange(pFooter);//add by ,7/6
+		
+		pStory->XFConvert(pFooter);
+		
+		pChangeMgr->SetHeadFootFribMap(sal_False);		
+	}
+	mp1->SetFooter(pFooter);
+}
+
+
+void LwpFooterLayout::ParseWaterMark(XFFooterStyle * pFooterStyle)
+{
+	XFBGImage* pXFBGImage = GetXFBGImage();
+	if(pXFBGImage)
+	{
+		pFooterStyle->SetBackImage(pXFBGImage);
+	}
+}
+//End by 
diff -urNp lotuswordpro.bak/source/filter/lwppagelayout.hxx lotuswordpro/source/filter/lwppagelayout.hxx
--- lotuswordpro.bak/source/filter/lwppagelayout.hxx	1970-01-01 08:00:00.000000000 +0800
+++ lotuswordpro/source/filter/lwppagelayout.hxx	2008-10-22 11:42:29.000000000 +0800
@@ -0,0 +1,169 @@
+/*************************************************************************
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: IBM Corporation
+ *
+ *  Copyright: 2008 by IBM Corporation
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+/*************************************************************************
+ * Change History
+Mar 2005			Created
+ ************************************************************************/
+
+#ifndef _LWPPAGELAYOUT_HXX
+#define _LWPPAGELAYOUT_HXX
+
+#include "lwplayout.hxx"
+
+class LwpHeaderLayout;
+class LwpFooterLayout;
+
+class LwpPageLayout: public LwpLayout
+{
+public:
+	LwpPageLayout(LwpObjectHeader &objHdr, LwpSvStream* pStrm);
+	virtual ~LwpPageLayout();
+	virtual void RegisterStyle();
+	OUString RegisterEndnoteStyle();
+	virtual void Parse(IXFStream* pOutputStream);
+	virtual LWP_LAYOUT_TYPE GetLayoutType () { return LWP_PAGE_LAYOUT;}	
+protected:
+	void Read();
+	LwpHeaderLayout* GetHeaderLayout();
+	LwpFooterLayout* GetFooterLayout();
+	//void RegisterChildStyle();
+	void ParseGeometry(XFPageMaster* pm1);
+	void ParseMargins(XFPageMaster* pm1);
+	void ParseBorders(XFPageMaster* pm1);
+	// add by , 06/03/2005
+	void ParsePatternFill(XFPageMaster* pm1);
+	void ParseBackGround(XFPageMaster* pm1);
+	// end add
+	void ParseBackColor(XFPageMaster* pm1);
+	void ParseWaterMark(XFPageMaster* pm1);
+	void ParseColumns(XFPageMaster* pm1);
+	void ParseShadow(XFPageMaster* pm1);
+	void ParseFootNoteSeparator(XFPageMaster* pm1);
+	double GetMarginWidth();
+	void GetWidthAndHeight(double& fWidth, double& fHeight);
+	double GetWidth();
+	double GetHeight();
+protected:
+	LwpAtomHolder*	m_pPrinterBinName;
+	sal_uInt16		m_nPrinterBin;
+	sal_Int32		m_nBdroffset;
+	LwpAtomHolder*	m_pPaperName;	
+	XFPageMaster* m_pXFPageMaster;
+public:	
+	sal_Bool HasColumns();		
+	sal_Bool HasFillerPageText(LwpFoundry* pFoundry);	
+	void ConvertFillerPageText(XFContentContainer* pCont);
+	void ResetXFColumns();
+	LwpPageLayout* GetOddChildLayout();
+	virtual sal_Int32 GetPageNumber(sal_uInt16 nLayoutNumber = 0);
+	sal_Bool operator <(LwpPageLayout& Other);
+	LwpPara* GetPagePosition();
+};
+
+#include "xfilter/xfmasterpage.hxx"
+
+class LwpHeaderLayout: public LwpPlacableLayout
+{
+public:
+	LwpHeaderLayout(LwpObjectHeader &objHdr, LwpSvStream* pStrm);
+	~LwpHeaderLayout();
+	virtual LWP_LAYOUT_TYPE GetLayoutType () { return LWP_HEADER_LAYOUT;}
+	void RegisterStyle( XFPageMaster* pm1 );
+	void RegisterStyle( XFMasterPage* mp1 );
+protected:
+	void Read();	
+	void ParseMargins( XFHeaderStyle* ph1 );
+	void ParseBorder( XFHeaderStyle* ph1 );
+	void ParseShadow( XFHeaderStyle* ph1 );
+	// add by , 06/03/2005
+	void ParsePatternFill(XFHeaderStyle* ph1);
+	void ParseBackGround(XFHeaderStyle* ph1);	
+	// end add	
+	void ParseBackColor(XFHeaderStyle* ph1);
+	
+	void ParseWaterMark(XFHeaderStyle* ph1);
+	//End by 
+private:
+	sal_Int32 m_nBorderOffset;
+};
+
+class LwpFooterLayout: public LwpPlacableLayout
+{
+public:
+	LwpFooterLayout(LwpObjectHeader &objHdr, LwpSvStream* pStrm);
+	~LwpFooterLayout();
+	virtual LWP_LAYOUT_TYPE GetLayoutType () { return LWP_FOOTER_LAYOUT;}
+	void RegisterStyle(XFPageMaster* pm1);
+	void RegisterStyle(XFMasterPage* mp1);
+protected:
+	void Read();	
+	void ParseMargins( XFFooterStyle* pFooterStyle );
+	void ParseBorder( XFFooterStyle* pFooterStyle );
+	void ParseShadow( XFFooterStyle* pFooterStyle );
+	// add by , 06/03/2005
+	void ParsePatternFill(XFFooterStyle* pFooterStyle);
+	void ParseBackGround(XFFooterStyle* pFooterStyle);
+	// end add
+
+	void ParseBackColor(XFFooterStyle* pFooterStyle);
+	
+	void ParseWaterMark(XFFooterStyle* pFooterStyle);
+	//End by 
+
+private:
+	sal_Int32 m_nBorderOffset;
+};
+
+#endif
diff -urNp lotuswordpro.bak/source/filter/lwppara1.cxx lotuswordpro/source/filter/lwppara1.cxx
--- lotuswordpro.bak/source/filter/lwppara1.cxx	1970-01-01 08:00:00.000000000 +0800
+++ lotuswordpro/source/filter/lwppara1.cxx	2008-10-22 11:42:29.000000000 +0800
@@ -0,0 +1,730 @@
+/*************************************************************************
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: IBM Corporation
+ *
+ *  Copyright: 2008 by IBM Corporation
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+/*************************************************************************
+ * @file 
+ *  For LWP filter architecture prototype
+ ************************************************************************/
+/*************************************************************************
+ * Change History
+ Jan 2005			Created
+ ************************************************************************/
+
+#include "lwppara.hxx"
+#include "lwpglobalmgr.hxx"
+#include "lwpfilehdr.hxx"
+#include "lwpparaproperty.hxx"
+#include "lwptools.hxx"
+#include "lwpparastyle.hxx"
+#include "xfilter/xffont.hxx"
+#include "xfilter/xftextstyle.hxx"
+#include "xfilter/xfstylemanager.hxx"
+#include "xfilter/xfparagraph.hxx"
+#include "xfilter/xftextcontent.hxx"
+#include "xfilter/xftextspan.hxx"
+#include "xfilter/xfmargins.hxx"
+#include "xfilter/xftabstop.hxx"
+#include "xfilter/xflinebreak.hxx"
+#include "xfilter/xfsection.hxx"
+#include "xfilter/xfsectionstyle.hxx"
+#include "xfilter/xfcolor.hxx"
+#include "xfilter/xfhyperlink.hxx"
+#include "lwpcharsetmgr.hxx"
+#include "lwpsection.hxx"
+#include "lwplayout.hxx"
+#include "lwpusewhen.hxx"
+
+#include "lwpbulletstylemgr.hxx"
+#include "lwpstory.hxx"
+#include "lwpsilverbullet.hxx"
+#include "xfilter/xflist.hxx"
+#include "xfilter/xfframe.hxx"
+
+#include "lwpdivinfo.hxx"
+#include "lwpdoc.hxx"
+#include "lwpholder.hxx"
+#include "lwppagehint.hxx"
+
+#include "lwpdropcapmgr.hxx"
+#include "lwptable.hxx"
+#include "lwpcelllayout.hxx"
+/**
+ * @short   get text of paragraph
+ */
+OUString LwpPara::GetContentText(sal_Bool bAllText)
+{
+//	rFont = m_FontID;
+	if (bAllText)
+	{
+		m_Fribs.SetPara(this);
+		m_Fribs.GatherAllText();
+		return m_AllText;
+	}
+	else
+		return m_Content;
+}
+
+/**
+ * @short   set text of paragraph
+ */
+void LwpPara::SetAllText(OUString sText)
+{
+	m_AllText+=sText;
+}
+
+/**
+ * @short   set first frib content
+ */
+void LwpPara::SetFirstFrib(rtl::OUString Content,sal_uInt32 FontID)
+{
+	m_FontID= FontID;
+	m_Content=Content;
+}
+/**
+ * @short   get paragraph xfstyle
+ */
+XFParaStyle* LwpPara::GetXFParaStyle()
+{
+	XFStyleManager* pXFStyleManager = LwpGlobalMgr::GetInstance()->GetXFStyleManager(); 
+	return pXFStyleManager->FindParaStyle(m_StyleName);
+}
+/**
+ * @short   get drop cap info
+ */
+#include "lwpframelayout.hxx"
+void LwpPara::GatherDropcapInfo()
+{
+	SetDropcapLines(m_pDropcapLayout->GetLines());
+	SetDropcapChars(m_pDropcapLayout->GetChars());		
+}
+/**
+ * @short   get parent paragraph
+ */
+LwpPara* LwpPara::GetParent()
+{
+	LwpPara* pPara;
+	sal_uInt16 otherlevel;
+	sal_uInt16 level = GetLevel();
+
+	if (level != 1)
+	{
+		pPara = static_cast<LwpPara*>(GetPrevious()->obj());
+		while (pPara)
+		{
+			otherlevel = pPara->GetLevel();
+			if ((otherlevel < level) || (otherlevel && (level == 0)))
+				return pPara;
+			pPara = static_cast<LwpPara*>(pPara->GetPrevious()->obj());
+		}
+	}	
+	return NULL;
+}
+
+/**
+ * @short:   Offer prefix, paranumber and suffix according to position.
+ * @param:   nPosition index of wanted paranumbering in the style-list.
+ * @param:   pParaNumbering a pointer to the structure which contains prefix, paranumber and
+ *		 suffix.
+ */
+void LwpPara::GetParaNumber(sal_uInt16 nPosition, ParaNumbering* pParaNumbering)
+{
+	if (nPosition > 9)
+	{
+		return;
+	}
+	sal_uInt16 nCurrentPos = 0;
+	
+	LwpFrib* pPreFrib = NULL;
+	LwpFrib* pFrib = m_Fribs.GetFribs();
+	if (!pFrib)
+	{
+		return;
+	}
+
+	while (pFrib)
+	{
+		sal_uInt8 nFribType = pFrib->GetType();
+		if (nFribType == FRIB_TAG_PARANUMBER)
+		{
+			nCurrentPos++;
+			ModifierInfo* pModInfo = pFrib->GetModifiers();
+			if (pModInfo)
+			{
+				sal_uInt16 nHideLevels = pModInfo->aTxtAttrOverride.GetHideLevels();
+				if (nCurrentPos == nPosition)
+				{
+					//get prefix text frib
+					if (pPreFrib)
+					{
+						if ((pPreFrib->GetType() == FRIB_TAG_TEXT) && 
+							(pPreFrib->GetModifiers()->aTxtAttrOverride.GetHideLevels() == nHideLevels))
+						{
+							pParaNumbering->pPrefix = static_cast<LwpFribText*>(pPreFrib);
+						}
+					}
+
+					//get para numbering
+					pParaNumbering->pParaNumber = static_cast<LwpFribParaNumber*>(pFrib);
+					pParaNumbering->nNumLevel = nHideLevels;
+
+					//get suffix text frib
+					if (pFrib = pFrib->GetNext())
+					{
+//						if((pFrib->GetType() == FRIB_TAG_TEXT) && 
+//							(pFrib->GetModifiers()->aTxtAttrOverride.GetHideLevels() == nHideLevels))
+						if( pFrib->GetType() == FRIB_TAG_TEXT )
+						{
+							if ((pFrib->GetNext()->GetType() == FRIB_TAG_TEXT ) ||
+								(pFrib->GetModifiers()->aTxtAttrOverride.GetHideLevels() == nHideLevels))
+							{
+								pParaNumbering->pSuffix = static_cast<LwpFribText*>(pFrib);
+							}
+						}
+					}
+
+					break;
+				}
+			}
+			else
+			{
+				if (nCurrentPos == nPosition)
+				{
+					//get prefix text frib
+					if (pPreFrib)
+					{
+						if (pPreFrib->GetType() == FRIB_TAG_TEXT)
+						{
+							pParaNumbering->pPrefix = static_cast<LwpFribText*>(pPreFrib);
+						}
+					}
+
+					//get para numbering
+					pParaNumbering->pParaNumber = static_cast<LwpFribParaNumber*>(pFrib);
+
+					//get suffix text frib
+					if (pFrib = pFrib->GetNext())
+					{
+						if (pFrib->GetType() == FRIB_TAG_TEXT)
+						{
+							pParaNumbering->pSuffix = static_cast<LwpFribText*>(pFrib);
+						}
+					}
+
+				}
+			}
+		}
+		pPreFrib = pFrib;
+		if (pFrib)
+		{
+ 			pFrib = pFrib->GetNext();
+		}
+	}
+}
+/**
+ * @short   override alignment
+ */
+//override style, add by  1-24
+void LwpPara::OverrideAlignment(LwpAlignmentOverride* base,LwpAlignmentOverride* over,XFParaStyle* pOverStyle)
+{
+    if (base)//the latter two parameter never be null
+    {
+        over->Override(base);
+        LwpParaStyle::ApplyAlignment(pOverStyle,base);      
+    }
+    else
+        LwpParaStyle::ApplyAlignment(pOverStyle,over);          
+}
+/**
+ * @short   override indent attribute
+ */
+void LwpPara::OverrideIndent(LwpIndentOverride* base,LwpIndentOverride* over,XFParaStyle* pOverStyle)
+{
+	if (base)//the latter two parameter never be null
+	{
+        	over->Override(base);
+        	LwpParaStyle::ApplyIndent(this,pOverStyle,base);   
+	}
+	else
+	{
+        	LwpParaStyle::ApplyIndent(this,pOverStyle,over);       
+    	}   
+}
+/**
+ * @short   override spacing
+ */
+void LwpPara::OverrideSpacing(LwpSpacingOverride* base,LwpSpacingOverride* over,XFParaStyle* pOverStyle)
+{
+    if (base)//the latter two parameter never be null
+    {
+        over->Override(base);   
+        LwpParaStyle::ApplySpacing(this,pOverStyle,base);   
+    }
+    else
+        LwpParaStyle::ApplySpacing(this,pOverStyle,over);    
+}
+
+//add by , 01/25/2005
+/**
+ * @short:   Get parastyle object according to the objID.
+ * @return:  pointer to the parastyle.
+ */
+LwpParaStyle* LwpPara::GetParaStyle()
+{
+	return static_cast<LwpParaStyle*>(m_ParaStyle.obj(VO_PARASTYLE));
+}
+
+/**
+ * @short:   Override paraborder style.
+ * @param:   pProps pointer to the LwpParaProperty and we can get local breaks through it.
+ * @param:   pOverStyle pointer to XFParaStyle which contains the parastyle for XFilter.
+ */
+void LwpPara::OverrideParaBorder(LwpParaProperty* pProps, XFParaStyle* pOverStyle)
+{
+	// get paraborder in parastyle
+	LwpParaStyle* pParaStyle = this->GetParaStyle();
+	if (!pParaStyle)
+	{
+		return;
+	}
+	
+	LwpOverride* pBorder = pParaStyle->GetParaBorder();
+	LwpParaBorderOverride aFinalBorder;
+	if (pBorder)
+	{
+		aFinalBorder = *pBorder;
+	}
+
+	// get local border
+	pBorder = static_cast<LwpParaBorderProperty*>(pProps)->GetLocalParaBorder();
+	if (pBorder)
+	{
+		LwpParaBorderOverride aLocalBorder;
+		aLocalBorder =  *pBorder;
+		aLocalBorder.Override(&aFinalBorder);
+	}
+
+	pParaStyle->ApplyParaBorder(pOverStyle, &aFinalBorder);
+}
+/**
+ * @short:   Override parabreaks style.
+ * @param:   pProps pointer to the LwpParaProperty and we can get local breaks through it.
+ * @param:   pOverStyle pointer to XFParaStyle which contains the parastyle for XFilter.
+ */
+void LwpPara::OverrideParaBreaks(LwpParaProperty* pProps, XFParaStyle* pOverStyle)
+{
+	// get breaks in parastyle
+	LwpParaStyle* pParaStyle = this->GetParaStyle();
+	if (!pParaStyle)
+	{
+		return;
+	}
+
+	LwpOverride* pBreaks = pParaStyle->GetBreaks();
+	LwpBreaksOverride* pFinalBreaks = new LwpBreaksOverride();
+	if (pBreaks)
+	{
+		*pFinalBreaks = *pBreaks;
+	}
+
+	// get local breaks
+	pBreaks = static_cast<LwpParaBreaksProperty*>(pProps)->GetLocalParaBreaks();
+	if (pBreaks)
+	{
+		LwpBreaksOverride aLocalBreaks;
+		aLocalBreaks = *pBreaks;
+		aLocalBreaks.Override(pFinalBreaks);
+	}
+
+	// save the breaks
+	m_pBreaks = pFinalBreaks;
+	
+//add by  1/31
+	XFStyleManager* pXFStyleManager = LwpGlobalMgr::GetInstance()->GetXFStyleManager(); 
+	if (m_pBreaks->IsKeepWithNext())
+	{
+		pOverStyle->SetBreaks(enumXFBreakKeepWithNext);
+	}
+	if (m_pBreaks->IsPageBreakBefore())
+	{
+		XFParaStyle* pStyle = new XFParaStyle();		
+		pStyle->SetBreaks(enumXFBreakAftPage);
+		m_BefPageBreakName = pXFStyleManager->AddStyle(pStyle)->GetStyleName();			
+	}
+	if (m_pBreaks->IsPageBreakAfter())
+	{
+		XFParaStyle* pStyle = new XFParaStyle();
+		pStyle->SetBreaks(enumXFBreakAftPage);
+		m_AftPageBreakName = pXFStyleManager->AddStyle(pStyle)->GetStyleName();		
+	}
+	if (m_pBreaks->IsColumnBreakBefore())
+	{
+		XFParaStyle* pStyle = new XFParaStyle();
+		pStyle->SetBreaks(enumXFBreakAftColumn);//tmp after, should change when layout read,note by  1/31
+		m_BefColumnBreakName = pXFStyleManager->AddStyle(pStyle)->GetStyleName();		
+	}
+	if (m_pBreaks->IsColumnBreakAfter())
+	{
+		XFParaStyle* pStyle = new XFParaStyle();
+		pStyle->SetBreaks(enumXFBreakAftColumn);
+		m_AftColumnBreakName = pXFStyleManager->AddStyle(pStyle)->GetStyleName();		
+	}
+//add end	
+	
+//	pParaStyle->ApplyBreaks(pOverStyle, &aFinalBreaks);
+}
+
+/**
+ * @short:   Override bullet styles.
+ * @param:   pProps pointer to the LwpParaProperty and we can get local bullet through it.
+ */
+void LwpPara::OverrideParaBullet(LwpParaProperty* pProps)
+{
+	// get bulletoverride in parastyle
+	LwpParaStyle* pParaStyle = this->GetParaStyle();
+	if (!pParaStyle)
+	{
+		return;
+	}
+	
+	if (pProps)
+	{
+		m_pBullOver = new LwpBulletOverride();
+		// get local bulletoverride
+		LwpBulletOverride* pLocalBullet  = static_cast<LwpParaBulletProperty*>(pProps)->GetLocalParaBullet();
+		if (!pLocalBullet)
+		{
+			return;
+		}
+		
+		LwpObjectID aSilverBulletID = pLocalBullet->GetSilverBullet();
+		if (aSilverBulletID.IsNull())
+		{
+			return;
+		}
+		else
+		{
+			m_bHasBullet = sal_True;
+
+			LwpOverride* pBullet= pParaStyle->GetBulletOverride();
+			LwpBulletOverride aFinalBullet;
+			if (pBullet)
+			{
+				aFinalBullet = *pBullet;
+			}
+
+			LwpBulletOverride aLocalBullet;
+			aLocalBullet = *pLocalBullet;
+			aLocalBullet.Override(&aFinalBullet);
+
+			*m_pBullOver = aFinalBullet;
+			aSilverBulletID = aFinalBullet.GetSilverBullet();
+			if (!aSilverBulletID.IsNull())
+			{
+				m_pSilverBullet = static_cast<LwpSilverBullet*>(aSilverBulletID.obj(VO_SILVERBULLET));
+				m_pSilverBullet->SetFoundry(m_pFoundry);
+			}
+
+			m_aSilverBulletID = aSilverBulletID;
+		}
+	}
+	else
+	{
+//		m_pBullOver = pParaStyle->GetBulletOverride();
+		LwpBulletOverride* pBullOver = pParaStyle->GetBulletOverride();
+		if (pBullOver)
+		{
+			m_aSilverBulletID = pBullOver->GetSilverBullet();
+			if (!m_aSilverBulletID.IsNull())
+			{
+				m_bHasBullet = sal_True;
+
+				m_pSilverBullet = static_cast<LwpSilverBullet*>(m_aSilverBulletID.obj(VO_SILVERBULLET));
+				m_pSilverBullet->SetFoundry(m_pFoundry);
+			}
+			
+			m_pBullOver = new LwpBulletOverride();
+			*m_pBullOver = *pBullOver;
+		}
+	}
+}
+/**
+ * @short:   Override paranumbering properties.
+ * @param:   pProps pointer to the LwpParaProperty and we can get local paranumbering through it.
+ */
+void LwpPara::OverrideParaNumbering(LwpParaProperty* pProps)
+{
+	// get numbering override in parastyle
+	LwpParaStyle* pParaStyle = this->GetParaStyle();
+	if (!pParaStyle)
+	{
+		return;
+	}
+
+	LwpNumberingOverride* pParaNumbering = pParaStyle->GetNumberingOverride();
+	LwpNumberingOverride aOver;
+	//Override with the local numbering, if any
+	if (pProps)
+	{
+		LwpNumberingOverride* pPropNumbering = static_cast<LwpParaNumberingProperty*>(pProps)->GetLocalNumbering();
+		if (pPropNumbering)
+		{
+			aOver = *pPropNumbering;
+		}
+	}
+	else
+	{
+		if (pParaNumbering)
+		{
+			aOver = *pParaNumbering;
+		}
+	}
+
+	if (m_nFlags & VALID_LEVEL)
+	{
+		aOver.OverrideLevel(m_nLevel);
+	}
+
+	m_aParaNumbering = aOver;
+
+}
+
+/**************************************************************************
+ * @short:   
+ * @descr:  
+ * @param:   
+ * @param:   
+ * @return:  
+**************************************************************************/
+void LwpPara::OverrideTab(LwpTabOverride *base, LwpTabOverride *over, XFParaStyle *pOverStyle)
+{
+	if (base)
+    {
+        over->Override(base);
+        LwpParaStyle::ApplyTab(pOverStyle,base);      
+    }
+    else
+        LwpParaStyle::ApplyTab(pOverStyle,over);  
+}
+
+void LwpPara::FindLayouts()
+{
+	m_Fribs.SetPara(this);
+	m_Fribs.FindLayouts();
+	LwpPara* pNextPara = static_cast<LwpPara*>(GetNext()->obj());
+	if(pNextPara)
+	{
+		pNextPara->FindLayouts();
+	}
+}
+
+/**************************************************************************
+ * @descr:  Get property according to the property type
+ * @param:   
+ * @param:   
+ * @return:  
+**************************************************************************/
+LwpParaProperty* LwpPara::GetProperty(sal_uInt32 nPropType)
+{
+	LwpParaProperty* pProps = m_pProps;
+	while(pProps)
+	{
+		if(pProps->GetType() == nPropType)
+		{
+			return pProps;
+		}
+		pProps = pProps->GetNext();
+		
+	}	
+	return NULL;
+}
+
+/**************************************************************************
+ * @descr:  Get local tab rack
+ * @param:   
+ * @param:   
+ * @return:  
+**************************************************************************/
+LwpTabOverride* LwpPara::GetLocalTabOverride()
+{
+	LwpParaProperty* pProp = GetProperty(PP_LOCAL_TABRACK);
+	if(pProp)
+	{
+		return static_cast<LwpParaTabRackProperty*>(pProp)->GetTab();
+	}
+	return NULL;
+}
+
+/**
+* @descr:   Determined which para is earlier in position
+* 		
+*/
+sal_Bool LwpPara::operator< (LwpPara& Other)
+{
+	return m_nOrdinal < Other.GetOrdinal();
+}
+
+/**
+* @descr:  If the two layouts in the same para, compare which layout is earlied according to frib order
+* 		
+*/
+sal_Bool LwpPara::ComparePagePosition(LwpVirtualLayout * pPreLayout, LwpVirtualLayout * pNextLayout)
+{
+	m_Fribs.SetPara(this);
+	return m_Fribs.ComparePagePosition(pPreLayout, pNextLayout);
+}
+/*
+sal_Bool LwpPara::IsNeedTabForTOC()
+{
+	LwpStory* pStory = GetStory();	
+	if(pStory)
+	{
+		if(GetNext()->IsNull())
+		{
+			LwpVirtualLayout* pLayout = pStory->GetLayout(NULL);
+			if(pLayout && pLayout->IsCell())
+			{
+				LwpCellLayout * pCell = static_cast<LwpCellLayout *>(pStory->GetLayout(NULL));
+				if (pCell->GetLeaderChar() == 0)
+				{
+					return sal_False;
+				}
+				return sal_True;
+			}
+		}		
+	}
+	return sal_False;
+}
+
+void LwpPara::AddTabStyleForTOC( )
+{
+	if(IsNeedTabForTOC())
+	{
+		XFParaStyle* pParaStyle = new XFParaStyle;
+		*pParaStyle = *GetXFParaStyle();  
+		pParaStyle->ClearTabStyles();
+		//Add Tab Style;
+		enumXFTab eType = enumXFTabRight;
+
+		LwpCellLayout * pCell = static_cast<LwpCellLayout *>(GetStory()->GetLayout(NULL));
+		double dLen = pCell->GetActualWidth(); /// todo: get from table
+		sal_Unicode cLeader = static_cast<sal_Unicode>(pCell->GetLeaderChar());
+		pParaStyle->AddTabStyle(eType, dLen, cLeader );
+		m_StyleName = XFStyleManager::AddStyle(pParaStyle)->GetStyleName();
+
+		// Get font info of default text style and set into tab style
+		XFParaStyle* pBaseStyle = static_cast<XFParaStyle*>(m_pFoundry->GetStyleManager()->GetStyle(*m_pFoundry->GetDefaultTextStyle())); 
+		XFTextStyle*pTextStyle = new XFTextStyle;
+		pTextStyle->SetFont(pBaseStyle->GetFont()); // who delete this font?????
+		m_TabStyleName = XFStyleManager::AddStyle(pTextStyle)->GetStyleName();
+	}
+}
+
+void LwpPara::AddTabStopForTOC()
+{
+	if(IsNeedTabForTOC())
+	{
+		 XFParagraph* pXFPara = GetFribs()->GetXFPara();		 
+		 pXFPara->SetStyleName(m_StyleName);		 
+		 
+		 XFParaStyle* pParaStyle = static_cast<XFParaStyle*>(XFStyleManager::FindStyle(m_StyleName));
+		 if(pParaStyle)
+	 	{
+			XFTextSpan *pSpan = new XFTextSpan;
+	 		XFTabStop *pTab = new XFTabStop;
+			pSpan->Add(pTab);
+			pSpan->SetStyleName(m_TabStyleName);
+			enumXFAlignType eType = pParaStyle->GetAlighType();
+
+			if(eType == enumXFAlignStart || eType == enumXFAlignJustify || eType == enumXFAlignNone)
+			{
+				pXFPara->Add(pSpan);
+			}
+			else if(eType == enumXFAlignEnd)
+			{
+				pXFPara->InsertAtBegin(pSpan);
+			}
+			else
+			{
+				delete pSpan; // pTabl will be delete inside XFTextSpan
+			}	
+				
+	 	}
+		
+	}
+}
+*/
+/**
+ * @short   check paragraph alignment
+ */
+sal_Bool LwpPara::IsNumberRight()
+{
+	LwpObject* pObj = m_ParaStyle.obj();
+	if (pObj)
+	{
+		LwpParaStyle* pStyle = static_cast<LwpParaStyle*>(pObj);
+		return pStyle->IsNumberRight();	
+	}
+	else
+		return sal_False;
+}
+/**
+ * @short   check paragraph in cell or not
+ */
+sal_Bool LwpPara::IsInCell()
+{
+	LwpVirtualLayout* pLayout = GetStory()->GetLayout(NULL);
+	if(pLayout && pLayout->IsCell())
+		return sal_True;
+	return sal_False;
+}
diff -urNp lotuswordpro.bak/source/filter/lwpparaborderoverride.cxx lotuswordpro/source/filter/lwpparaborderoverride.cxx
--- lotuswordpro.bak/source/filter/lwpparaborderoverride.cxx	1970-01-01 08:00:00.000000000 +0800
+++ lotuswordpro/source/filter/lwpparaborderoverride.cxx	2008-10-22 11:42:29.000000000 +0800
@@ -0,0 +1,394 @@
+/*************************************************************************
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: IBM Corporation
+ *
+ *  Copyright: 2008 by IBM Corporation
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+/*************************************************************************
+* @file 
+* Border override of Wordpro.
+************************************************************************/
+/*************************************************************************
+* Change History
+* 2005-01-11 create and implement.
+************************************************************************/
+#include	"lwpparaborderoverride.hxx"
+#include	"lwpborderstuff.hxx"
+#include	"lwpshadow.hxx"
+#include	"lwpmargins.hxx"
+
+LwpParaBorderOverride::LwpParaBorderOverride()
+{
+	m_pBorderStuff = new LwpBorderStuff();
+	m_pBetweenStuff = new LwpBorderStuff();
+	m_pShadow = new LwpShadow();
+	m_pMargins = new LwpMargins();
+	
+	m_eAboveType = PB_NONE;
+	m_eBelowType = PB_NONE;
+	m_eRightType = PB_NONE;
+	m_eBetweenType = PB_NONE;
+	
+	m_nAboveWidth = 0;
+	m_nBelowWidth = 0;
+	m_nBetweenWidth = 0;
+	m_nRightWidth = 0;
+	
+	m_nBetweenMargin = 0;
+}
+
+LwpParaBorderOverride::~LwpParaBorderOverride()
+{
+	if( m_pBorderStuff )
+		delete m_pBorderStuff;
+	if( m_pBetweenStuff )
+		delete m_pBetweenStuff;
+	if( m_pShadow )
+		delete m_pShadow;
+	if( m_pMargins )
+		delete m_pMargins;
+}
+
+void LwpParaBorderOverride::Read(LwpObjectStream *pStrm)
+{
+	if (pStrm->QuickReadBool())
+	{
+		ReadCommon(pStrm);		
+		//start here:
+		m_pBorderStuff->Read(pStrm);
+		m_pShadow->Read(pStrm);
+		m_pMargins->Read(pStrm);
+		
+		pStrm->QuickRead(&m_eAboveType,2);
+		pStrm->QuickRead(&m_eBelowType,2);
+		pStrm->QuickRead(&m_eRightType,2);
+		
+		if( pStrm->CheckExtra() )
+		{
+			m_pBetweenStuff->Read(pStrm);
+			
+			pStrm->QuickRead(&m_eBetweenType,2);
+			pStrm->QuickRead(&m_nBetweenWidth,4 );
+			pStrm->QuickRead(&m_nBetweenMargin,4 );
+			
+			if( pStrm->CheckExtra() )
+			{
+				pStrm->QuickRead( &m_eRightType, 2);
+				pStrm->QuickRead( &m_nRightWidth, 4);
+			}
+		}
+	}
+	
+	pStrm->SkipExtra();
+}
+
+// 01/26/2005
+void LwpParaBorderOverride::operator=(const LwpOverride& rOther)
+{
+	LwpOverride::operator=(rOther);
+	const LwpParaBorderOverride* pParaBorder = static_cast<LwpParaBorderOverride*>((LwpOverride*)&rOther);
+	
+	if (pParaBorder->m_pBorderStuff)
+	{
+		*m_pBorderStuff = *(pParaBorder->m_pBorderStuff);
+	}
+	if (pParaBorder->m_pBetweenStuff)
+	{
+		*m_pBetweenStuff = *(pParaBorder->m_pBetweenStuff);
+	}
+	if (pParaBorder->m_pShadow)
+	{
+		*m_pShadow = *(pParaBorder->m_pShadow);
+	}
+	if (pParaBorder->m_pMargins)
+	{
+		*m_pMargins = *(pParaBorder->m_pMargins);
+	}
+	
+	m_eAboveType = pParaBorder->m_eAboveType;
+	m_eBelowType = pParaBorder->m_eBelowType;
+	m_eRightType = pParaBorder->m_eRightType;
+	m_eBetweenType = pParaBorder->m_eBelowType;
+	
+	m_nAboveWidth = pParaBorder->m_nAboveWidth;
+	m_nBelowWidth = pParaBorder->m_nBelowWidth;
+	m_nBetweenWidth = pParaBorder->m_nBetweenWidth;
+	m_nRightWidth = pParaBorder->m_nRightWidth;
+	
+	m_nBetweenMargin = pParaBorder->m_nBetweenMargin;
+}
+
+void LwpParaBorderOverride::Override(LwpParaBorderOverride* pOther)
+{
+	if (m_nApply & PBO_STUFF)
+	{
+		if (IsBorderStuffOverridden())
+		{
+			pOther->OverrideBorderStuff(m_pBorderStuff);
+		}
+		else
+		{
+			pOther->RevertBorderStuff();
+		}
+	}
+
+	if (m_nApply & PBO_BETWEENSTUFF)
+	{
+		if (IsBetweenStuffOverridden())
+		{
+			pOther->OverrideBetweenStuff(m_pBetweenStuff);
+		}
+		else
+		{
+			pOther->RevertBetweenStuff();
+		}
+	}
+
+	if (m_nApply & PBO_SHADOW)
+	{
+		if (IsShadowOverridden())
+		{
+			pOther->OverrideShadow(m_pShadow);
+		}
+		else
+		{
+			pOther->RevertShadow();
+		}
+	}
+
+	if (m_nApply & PBO_MARGINS)
+	{
+		if (IsMarginsOverridden())
+		{
+			pOther->OverrideMargins(m_pMargins);
+		}
+		else
+		{
+			pOther->RevertMargins();
+		}
+	}
+
+	if (m_nApply & PBO_ABOVETYPE)
+	{
+		if (IsAboveTypeOverridden())
+		{
+			pOther->OverrideAboveType(m_eAboveType);
+		}
+		else
+		{
+			pOther->RevertAboveType();
+		}
+	}
+
+	if (m_nApply & PBO_BELOWTYPE)
+	{
+		if (IsBelowTypeOverridden())
+		{
+			pOther->OverrideBelowType(m_eBelowType);
+		}
+		else
+		{
+			pOther->RevertBelowType();
+		}
+	}
+
+	if (m_nApply & PBO_RIGHTTYPE)
+	{
+		if (IsRightTypeOverridden())
+		{
+			pOther->OverrideRightType(m_eRightType);
+		}
+		else
+		{
+			pOther->RevertRightType();
+		}
+	}
+
+	if (m_nApply & PBO_BETWEENTYPE)
+	{
+		if (IsBetweenTypeOverridden())
+		{
+			pOther->OverrideBetweenType(m_eBetweenType);
+		}
+		else
+		{
+			pOther->RevertBetweenType();
+		}
+	}
+
+	if (m_nApply & PBO_ABOVE)
+	{
+		if (IsAboveWidthOverridden())
+		{
+			pOther->OverrideAboveWidth(m_nAboveWidth);
+		}
+		else
+		{
+			pOther->RevertAboveWidth();
+		}
+	}
+
+	if (m_nApply & PBO_BELOW)
+	{
+		if (IsBelowWidthOverridden())
+		{
+			pOther->OverrideBelowWidth(m_nBelowWidth);
+		}
+		else
+		{
+			pOther->RevertBelowWidth();
+		}
+	}
+
+	if (m_nApply & PBO_BETWEEN)
+	{
+		if (IsBetweenWidthOverridden())
+		{
+			pOther->OverrideBetweenWidth(m_nBetweenWidth);
+		}
+		else
+		{
+			pOther->RevertBetweenWidth();
+		}
+	}
+
+	if (m_nApply & PBO_BETWEENMARGIN)
+	{
+		if (IsBetweenMarginOverridden())
+		{
+			pOther->OverrideBetweenMargin(m_nBetweenMargin);
+		}
+		else
+		{
+			pOther->RevertBetweenMargin();
+		}
+	}
+
+	if (m_nApply & PBO_RIGHT)
+	{
+		if (IsRightWidthOverridden())
+		{
+			pOther->OverrideRightWidth(m_nRightWidth);
+		}
+		else
+		{
+			pOther->RevertRightWidth();
+		}
+	}
+}
+
+void LwpParaBorderOverride::OverrideBorderStuff(LwpBorderStuff* pBorderStuff)
+{
+	*m_pBorderStuff = *pBorderStuff;
+	LwpOverride::Override(PBO_STUFF, STATE_ON);
+}
+void LwpParaBorderOverride::OverrideBetweenStuff(LwpBorderStuff* pBorderStuff)
+{
+	*m_pBetweenStuff = *pBorderStuff;
+	LwpOverride::Override(PBO_BETWEENSTUFF, STATE_ON);
+}
+void LwpParaBorderOverride::OverrideShadow(LwpShadow* pShadow)
+{
+	*m_pShadow = *pShadow;
+	LwpOverride::Override(PBO_SHADOW, STATE_ON);
+}
+void LwpParaBorderOverride::OverrideMargins(LwpMargins* pMargins)
+{
+	*m_pMargins = *pMargins;
+	LwpOverride::Override(PBO_MARGINS, STATE_ON);
+}
+void LwpParaBorderOverride::OverrideAboveType(BorderWidthType eNewType)
+{
+	m_eAboveType = eNewType;
+	LwpOverride::Override(PBO_ABOVETYPE, STATE_ON);
+}
+void LwpParaBorderOverride::OverrideBelowType(BorderWidthType eNewType)
+{
+	m_eBelowType = eNewType;
+	LwpOverride::Override(PBO_BELOWTYPE, STATE_ON);
+}
+void LwpParaBorderOverride::OverrideRightType(BorderWidthType eNewType)
+{
+	m_eRightType = eNewType;
+	LwpOverride::Override(PBO_RIGHTTYPE, STATE_ON);
+}
+void LwpParaBorderOverride::OverrideBetweenType(BorderWidthType eNewType)
+{
+	m_eBetweenType = eNewType;
+	LwpOverride::Override(PBO_BETWEENTYPE, STATE_ON);
+}
+void LwpParaBorderOverride::OverrideAboveWidth(sal_uInt32 nNewWidth)
+{
+	m_nAboveWidth = nNewWidth;
+	LwpOverride::Override(PBO_ABOVE, STATE_ON);
+}
+void LwpParaBorderOverride::OverrideBelowWidth(sal_uInt32 nNewWidth)
+{
+	m_nBelowWidth = nNewWidth;
+	LwpOverride::Override(PBO_BELOW, STATE_ON);
+}
+void LwpParaBorderOverride::OverrideBetweenWidth(sal_uInt32 nNewWidth)
+{
+	m_nBetweenWidth = nNewWidth;
+	LwpOverride::Override(PBO_BETWEEN, STATE_ON);
+}
+void LwpParaBorderOverride::OverrideRightWidth(sal_uInt32 nNewWidth)
+{
+	m_nRightWidth = nNewWidth;
+	LwpOverride::Override(PBO_RIGHT, STATE_ON);
+}
+void LwpParaBorderOverride::OverrideBetweenMargin(sal_uInt32 nNewMargin)
+{
+	m_nBetweenMargin = nNewMargin;
+	LwpOverride::Override(PBO_BETWEENMARGIN, STATE_ON);
+}
+
+//end
diff -urNp lotuswordpro.bak/source/filter/lwpparaborderoverride.hxx lotuswordpro/source/filter/lwpparaborderoverride.hxx
--- lotuswordpro.bak/source/filter/lwpparaborderoverride.hxx	1970-01-01 08:00:00.000000000 +0800
+++ lotuswordpro/source/filter/lwpparaborderoverride.hxx	2008-10-22 11:42:29.000000000 +0800
@@ -0,0 +1,285 @@
+/*************************************************************************
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: IBM Corporation
+ *
+ *  Copyright: 2008 by IBM Corporation
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+/*************************************************************************
+* @file 
+* Border override of Wordpro.
+************************************************************************/
+/*************************************************************************
+* Change History
+* 2005-01-11 Create and implement.
+************************************************************************/
+#ifndef		_LWPPARABORDEROVERRIDE_HXX
+#define		_LWPPARABORDEROVERRIDE_HXX
+
+#include	"lwpoverride.hxx"
+
+class LwpBorderStuff;
+class LwpShadow;
+class LwpMargins;
+
+class LwpParaBorderOverride : public LwpOverride
+{
+public:
+	LwpParaBorderOverride();
+	virtual ~LwpParaBorderOverride();
+	
+	enum BorderWidthType
+	{
+		PB_NONE			= 0,		/* No border */
+		PB_TEXTWIDTH	= 1,		/* Border is width of text */
+		PB_MARGINWIDTH	= 2,		/* Border extends to margins */
+		PB_CUSTOMWIDTH	= 3			/* Border width is specified explicitly */
+	};
+public:
+	virtual void Read(LwpObjectStream *pStrm);
+
+	LwpShadow*	GetShadow(){ return m_pShadow; }
+	LwpBorderStuff* GetBorderStuff(){ return m_pBorderStuff; }
+	LwpMargins* GetMargins() { return m_pMargins; };
+	
+	//add by , 01/25/2005
+	virtual void operator=(const LwpOverride& rOther);
+	
+	void Override(LwpParaBorderOverride* pOther);
+
+	inline sal_Bool IsBorderStuffOverridden();
+	inline sal_Bool IsBetweenStuffOverridden();
+	inline sal_Bool IsShadowOverridden();
+	inline sal_Bool IsMarginsOverridden();
+	inline sal_Bool IsAboveTypeOverridden();
+	inline sal_Bool IsBelowTypeOverridden();
+	inline sal_Bool IsRightTypeOverridden();
+	inline sal_Bool IsBetweenTypeOverridden();
+	inline sal_Bool IsAboveWidthOverridden();
+	inline sal_Bool IsBelowWidthOverridden();
+	inline sal_Bool IsBetweenWidthOverridden();
+	inline sal_Bool IsRightWidthOverridden();
+	inline sal_Bool IsBetweenMarginOverridden();
+
+	void OverrideBorderStuff(LwpBorderStuff* pBorderStuff);
+	void OverrideBetweenStuff(LwpBorderStuff* pBorderStuff);
+	void OverrideShadow(LwpShadow* pShadow);
+	void OverrideMargins(LwpMargins* pMargins);
+	void OverrideAboveType(BorderWidthType eNewType);
+	void OverrideBelowType(BorderWidthType eNewType);
+	void OverrideRightType(BorderWidthType eNewType);
+	void OverrideBetweenType(BorderWidthType eNewType);
+	void OverrideAboveWidth(sal_uInt32 nNewWidth);
+	void OverrideBelowWidth(sal_uInt32 nNewWidth);
+	void OverrideBetweenWidth(sal_uInt32 nNewWidth);
+	void OverrideRightWidth(sal_uInt32 nNewWidth);
+	void OverrideBetweenMargin(sal_uInt32 nNewMargin);
+
+	inline void RevertBorderStuff();
+	inline void RevertBetweenStuff();
+	inline void RevertShadow();
+	inline void RevertMargins();
+	inline void RevertAboveType();
+	inline void RevertBelowType();
+	inline void RevertRightType();
+	inline void RevertBetweenType();
+	inline void RevertAboveWidth();
+	inline void RevertBelowWidth();
+	inline void RevertBetweenWidth();
+	inline void RevertRightWidth();
+	inline void RevertBetweenMargin();
+	
+	//end add
+	friend class LwpParaBorderPiece;
+protected:
+	enum
+	{
+		PBO_STUFF			= 0x0001,
+		PBO_SHADOW			= 0x0002,
+		PBO_MARGINS 		= 0x0004,
+		PBO_ABOVETYPE		= 0x0008,
+		PBO_BELOWTYPE		= 0x0010,
+		PBO_RIGHTTYPE		= 0x0020,
+		PBO_ABOVE			= 0x0040,
+		PBO_BELOW			= 0x0080,
+		PBO_BETWEENSTUFF	= 0x0100,
+		PBO_BETWEENTYPE 	= 0x0200,
+		PBO_BETWEEN			= 0x0400,
+		PBO_BETWEENMARGIN	= 0x0800,
+		PBO_RIGHT			= 0x1000
+	};
+		
+private:
+	LwpBorderStuff		*m_pBorderStuff;
+	LwpBorderStuff		*m_pBetweenStuff;
+	LwpShadow			*m_pShadow;
+	LwpMargins			*m_pMargins;
+	
+	BorderWidthType		m_eAboveType;
+	BorderWidthType		m_eBelowType;
+	BorderWidthType		m_eRightType;
+	BorderWidthType		m_eBetweenType;
+	
+	sal_uInt32			m_nAboveWidth;
+	sal_uInt32			m_nBelowWidth;
+	sal_uInt32			m_nBetweenWidth;
+	sal_uInt32			m_nRightWidth;
+	
+	sal_uInt32			m_nBetweenMargin;
+};
+
+inline sal_Bool LwpParaBorderOverride::IsBorderStuffOverridden()
+{
+	return (sal_Bool)((m_nOverride & PBO_STUFF) != 0);
+}
+inline sal_Bool LwpParaBorderOverride::IsBetweenStuffOverridden()
+{
+	return (sal_Bool)((m_nOverride & PBO_BETWEENSTUFF) != 0);
+}
+inline sal_Bool LwpParaBorderOverride::IsShadowOverridden()
+{
+	return (sal_Bool)((m_nOverride & PBO_SHADOW) != 0);
+}
+inline sal_Bool LwpParaBorderOverride::IsMarginsOverridden()
+{
+	return (sal_Bool)((m_nOverride & PBO_MARGINS) != 0);
+}
+inline sal_Bool LwpParaBorderOverride::IsAboveTypeOverridden()
+{
+	return (sal_Bool)((m_nOverride & PBO_ABOVETYPE) != 0);
+}
+inline sal_Bool LwpParaBorderOverride::IsBelowTypeOverridden()
+{
+	return (sal_Bool)((m_nOverride & PBO_BELOWTYPE) != 0);
+}
+inline sal_Bool LwpParaBorderOverride::IsRightTypeOverridden()
+{
+	return (sal_Bool)((m_nOverride & PBO_RIGHTTYPE) != 0);
+}
+inline sal_Bool LwpParaBorderOverride::IsBetweenTypeOverridden()
+{
+	return (sal_Bool)((m_nOverride & PBO_BETWEENTYPE) != 0);
+}
+inline sal_Bool LwpParaBorderOverride::IsAboveWidthOverridden()
+{
+	return (sal_Bool)((m_nOverride & PBO_ABOVE) != 0);
+}
+inline sal_Bool LwpParaBorderOverride::IsBelowWidthOverridden()
+{
+	return (sal_Bool)((m_nOverride & PBO_BELOW) != 0);
+}
+inline sal_Bool LwpParaBorderOverride::IsBetweenWidthOverridden()
+{
+	return (sal_Bool)((m_nOverride & PBO_BETWEEN) != 0);
+}
+inline sal_Bool LwpParaBorderOverride::IsRightWidthOverridden()
+{
+	return (sal_Bool)((m_nOverride & PBO_RIGHT) != 0);
+}
+inline sal_Bool LwpParaBorderOverride::IsBetweenMarginOverridden()
+{
+	return (sal_Bool)((m_nOverride & PBO_BETWEENMARGIN) != 0);
+}
+
+inline void LwpParaBorderOverride::RevertBorderStuff()
+{
+	LwpOverride::Override(PBO_STUFF, STATE_STYLE);
+}
+inline void LwpParaBorderOverride::RevertBetweenStuff()
+{
+	LwpOverride::Override(PBO_BETWEENSTUFF, STATE_STYLE);
+}
+inline void LwpParaBorderOverride::RevertShadow()
+{
+	LwpOverride::Override(PBO_SHADOW, STATE_STYLE);
+}
+inline void LwpParaBorderOverride::RevertMargins()
+{
+	LwpOverride::Override(PBO_MARGINS, STATE_STYLE);
+}
+inline void LwpParaBorderOverride::RevertAboveType()
+{
+	LwpOverride::Override(PBO_ABOVETYPE, STATE_STYLE);
+}
+inline void LwpParaBorderOverride::RevertBelowType()
+{
+	LwpOverride::Override(PBO_BELOWTYPE, STATE_STYLE);
+}
+inline void LwpParaBorderOverride::RevertRightType()
+{
+	LwpOverride::Override(PBO_RIGHTTYPE, STATE_STYLE);
+}
+inline void LwpParaBorderOverride::RevertBetweenType()
+{
+	LwpOverride::Override(PBO_BETWEENTYPE, STATE_STYLE);
+}
+inline void LwpParaBorderOverride::RevertAboveWidth()
+{
+	LwpOverride::Override(PBO_ABOVE, STATE_STYLE);
+}
+inline void LwpParaBorderOverride::RevertBelowWidth()
+{
+	LwpOverride::Override(PBO_BELOW, STATE_STYLE);
+}
+inline void LwpParaBorderOverride::RevertBetweenWidth()
+{
+	LwpOverride::Override(PBO_BETWEEN, STATE_STYLE);
+}
+inline void LwpParaBorderOverride::RevertRightWidth()
+{
+	LwpOverride::Override(PBO_RIGHT, STATE_STYLE);
+}
+inline void LwpParaBorderOverride::RevertBetweenMargin()
+{
+	LwpOverride::Override(PBO_BETWEENMARGIN, STATE_STYLE);
+}
+	
+#endif
+
diff -urNp lotuswordpro.bak/source/filter/lwppara.cxx lotuswordpro/source/filter/lwppara.cxx
--- lotuswordpro.bak/source/filter/lwppara.cxx	1970-01-01 08:00:00.000000000 +0800
+++ lotuswordpro/source/filter/lwppara.cxx	2008-10-22 11:42:29.000000000 +0800
@@ -0,0 +1,1047 @@
+/*************************************************************************
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: IBM Corporation
+ *
+ *  Copyright: 2008 by IBM Corporation
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+/*************************************************************************
+ * @file 
+ *  For LWP filter architecture prototype
+ ************************************************************************/
+/*************************************************************************
+ * Change History
+ Jan 2005			Created
+ ************************************************************************/
+
+#include "lwppara.hxx"
+#include "lwpglobalmgr.hxx"
+#include "lwpfilehdr.hxx"
+#include "lwpparaproperty.hxx"
+#include "lwptools.hxx"
+#include "lwpparastyle.hxx"
+#include "xfilter/xffont.hxx"
+#include "xfilter/xftextstyle.hxx"
+#include "xfilter/xfstylemanager.hxx"
+#include "xfilter/xfparagraph.hxx"
+#include "xfilter/xftextcontent.hxx"
+#include "xfilter/xftextspan.hxx"
+#include "xfilter/xfmargins.hxx"
+#include "xfilter/xftabstop.hxx"
+#include "xfilter/xflinebreak.hxx"
+#include "xfilter/xfsection.hxx"
+#include "xfilter/xfsectionstyle.hxx"
+#include "xfilter/xfcolor.hxx"
+#include "xfilter/xfhyperlink.hxx"
+#include "xfilter/xfliststyle.hxx"
+#include "lwpcharsetmgr.hxx"
+#include "lwpsection.hxx"
+#include "lwplayout.hxx"
+#include "lwpusewhen.hxx"
+#include "lwpbulletstylemgr.hxx"
+#include "lwpstory.hxx"
+#include "lwpsilverbullet.hxx"
+#include "xfilter/xflist.hxx"
+#include "xfilter/xfframe.hxx"
+
+#include "lwpdivinfo.hxx"
+#include "lwpdoc.hxx"
+#include "lwpholder.hxx"
+#include "lwppagehint.hxx"
+
+#include "lwpdropcapmgr.hxx"
+#include "lwptable.hxx"
+LwpPara::LwpPara(LwpObjectHeader& objHdr, LwpSvStream* pStrm)
+	: LwpDLVList(objHdr, pStrm), m_pBreaks(NULL), m_pIndentOverride(NULL), m_bHasBullet(sal_False), m_bBullContinue(sal_False),
+	/*m_pParaNumbering(NULL),*/ m_pSilverBullet(NULL), m_pBullOver(NULL),m_bHasDropcap(sal_False),m_nLines(0),m_nChars(0),
+	m_BelowSpacing(0),m_pDropcapLayout(NULL), m_pXFContainer(NULL)
+{
+	m_pProps = NULL;
+	m_SectionStyleName = A2OUSTR("");
+	m_AllText = A2OUSTR("");
+}
+
+LwpPara::~LwpPara()
+{
+
+	if (m_pBreaks)
+	{
+		delete m_pBreaks;
+		m_pBreaks = NULL;
+	}
+/*	if (m_pParaNumbering)
+	{
+		delete m_pParaNumbering;
+		m_pParaNumbering = NULL;
+	}*/
+
+	if (m_pBullOver)
+	{
+		delete m_pBullOver;
+		m_pBullOver = NULL;
+	}
+	if(m_pIndentOverride)
+	{
+		delete m_pIndentOverride;
+	}
+	
+	LwpParaProperty* pNextProp;
+	while(m_pProps)
+	{
+		pNextProp = m_pProps->GetNext();
+		delete m_pProps;
+		m_pProps = pNextProp;
+	}
+}
+
+void LwpPara::Read()
+{
+	LwpDLVList::Read();
+	
+	sal_Bool Simple;
+	sal_Bool Notify = sal_False;
+//	m_Fribs.SetPara(this);
+//	LwpParaPropListProperty *PropList = NULL;
+	if(LwpFileHeader::m_nFileRevision<0x0006)
+		Simple = sal_False;
+	else if(LwpFileHeader::m_nFileRevision<0x000B)
+		m_pObjStrm->QuickRead(&Simple, sizeof(Simple));
+	else
+	{
+		sal_uInt8 Flag;
+		m_pObjStrm->QuickRead(&Flag, sizeof(Flag));
+
+		const int DISK_SIMPLE = 1;
+		const int DISK_NOTIFY = 2;
+
+		Simple = (Flag & DISK_SIMPLE) ? sal_True : sal_False;
+		Notify = (Flag & DISK_NOTIFY) ? sal_True : sal_False;
+	}
+
+	if(!Simple)
+	{
+		m_pObjStrm->QuickRead(&m_nOrdinal, sizeof(m_nOrdinal));
+		if(LwpFileHeader::m_nFileRevision<0x000B)
+		{
+			// TODO: to process
+			assert(false);
+			/*pCForked3NotifyList Notify = new CForked3NotifyList(this); 
+			Notify->GetExtraList()->QuickRead(pFile);
+			Notify->QuickRead(pFile);
+			if(Notify->GetExtraList()->IsEmpty() && 
+				Notify->IsEmpty())
+				delete Notify;
+			else
+				cNotifyList = Notify;*/
+		}
+		else
+		{
+			if (Notify)
+			{
+				LwpForked3NotifyList* pNotifyList = new LwpForked3NotifyList();
+				pNotifyList->GetExtraList()->Read(m_pObjStrm);
+				pNotifyList->Read(m_pObjStrm);
+				delete pNotifyList;
+			}
+		}
+	}
+	else
+		m_nOrdinal = 0x0001;
+
+	m_pObjStrm->QuickRead(&m_nFlags, sizeof(m_nFlags));
+	m_ParaStyle.ReadIndexed(m_pObjStrm);
+	
+	if(!Simple)
+	{
+		m_Hint.Read(m_pObjStrm);
+		if (IsBadHintsInFile())
+		{
+			// This hint is no good, so throw it away -- SDC 9/28/95
+			m_Hint.Reset();
+		}
+	}
+	
+	m_Story.ReadIndexed(m_pObjStrm);
+	if(!Simple)
+	{
+		if(LwpFileHeader::m_nFileRevision<0x000B)
+		{
+			// TODO: to process
+			assert(false);
+			/*PropList = new CParaPropListProperty(this);
+			PropList->GetList()->QuickRead(pFile);
+			if(PropList->GetList()->IsEmpty())
+			{
+				delete PropList;
+				PropList = LNULL;
+			}*/
+		}
+		m_pObjStrm->QuickRead(&m_nLevel, sizeof(m_nLevel));
+
+		// test
+		if (m_nLevel > 9)
+		{
+			m_nLevel = 9;
+		}
+		// test ends
+	}
+	else
+		m_nLevel = 0x0001;
+
+	m_Fribs.SetPara(this);//add by  2/1, for silver bullet
+	m_Fribs.ReadPara(m_pObjStrm);
+
+	m_pProps = LwpParaProperty::ReadPropertyList(m_pObjStrm,this);		
+}
+
+void LwpPara::Parse(IXFStream* pOutputStream)
+{
+	m_pXFContainer = new XFContentContainer;
+	XFConvert(m_pXFContainer);
+	m_pXFContainer->ToXml(pOutputStream);
+	m_pXFContainer->Reset();
+	delete m_pXFContainer;
+	m_pXFContainer = NULL;
+}
+
+void LwpPara::XFConvert(XFContentContainer* pCont)
+{
+	m_pXFContainer = pCont;
+
+	if (static_cast<LwpStory*>(m_Story.obj())->GetDropcapFlag() == sal_True)
+	{
+		ParseDropcapContent();
+		/*LwpObject* pNextPara = GetNext()->obj();
+		if(pNextPara)
+			pNextPara->XFConvert(pCont);*/
+		return;
+	}
+
+	//Add the break before para
+	if (m_pBreaks && m_nOrdinal!=0)
+		AddBreakBefore(pCont);
+
+	//Create an XFPara for this VO_PARA
+	XFParagraph *pPara = new XFParagraph;
+	pPara->SetStyleName(m_StyleName);
+	
+	if(m_SectionStyleName.getLength()>0)
+	{
+		XFSection* pSection = CreateXFSection();
+		LwpStory* pStory = static_cast<LwpStory*> ( m_Story.obj() );
+		pStory->AddXFContent(pSection);		
+		//pSection->Add(pPara);
+		m_pXFContainer = pSection;
+	}
+	
+	if (m_bHasBullet &&  m_pSilverBullet)
+	{
+		XFContentContainer* pListItem = AddBulletList(m_pXFContainer);
+		if (pListItem)
+		{
+			pListItem->Add(pPara);
+		}
+	}
+	else
+	{
+		LwpBulletStyleMgr* pBulletStyleMgr = this->GetBulletStyleMgr();
+		if (pBulletStyleMgr)
+		{
+			pBulletStyleMgr->SetCurrentSilverBullet(LwpObjectID());
+			pBulletStyleMgr->SetContinueFlag(sal_False);
+		}
+		m_pXFContainer->Add(pPara);
+	}
+    
+	m_Fribs.SetXFPara(pPara);
+	m_Fribs.XFConvert();
+		
+	if (m_pBreaks)
+		AddBreakAfter(m_pXFContainer);
+
+	// maybe useful for futer version
+	// deleted by 
+	// AddTabStopForTOC();
+	
+	//Caller is responsible for calling the next para object
+	/*LwpObject* pNextPara = GetNext()->obj();
+	if(pNextPara)
+		pNextPara->XFConvert( m_pXFContainer );*/
+}
+
+sal_Bool LwpPara::RegisterMasterPage(XFParaStyle* pBaseStyle)
+{
+	sal_Bool bSuccess = sal_False;
+	//get story
+	LwpStory* pStory = static_cast<LwpStory*>(m_Story.obj());	
+	//if pagelayout is modified, register the pagelayout
+	if(pStory->IsPMModified())
+	{
+		sal_Bool bNewSection = sal_False;
+		bNewSection = pStory->IsNeedSection();
+		LwpPageLayout* pLayout = pStory->GetCurrentLayout();
+		if(bNewSection)
+		{			
+			RegisterNewSectionStyle(pLayout);
+		}
+		
+		bSuccess = sal_True;
+		//register master page style
+		XFParaStyle* pOverStyle = new XFParaStyle();
+		*pOverStyle = *pBaseStyle;
+		pOverStyle->SetStyleName( A2OUSTR(""));
+		pOverStyle->SetMasterPage(pLayout->GetStyleName());
+		if (m_ParentStyleName.getLength()) 
+        			pOverStyle->SetParentStyleName(m_ParentStyleName); //Add by  2005/12/12 
+		XFStyleManager* pXFStyleManager = LwpGlobalMgr::GetInstance()->GetXFStyleManager(); 
+		m_StyleName = pXFStyleManager->AddStyle(pOverStyle)->GetStyleName();	
+	}
+	return bSuccess;
+}
+/**
+ * @short   register paragraph style
+ */
+void LwpPara::RegisterStyle()
+{ //1 reg autostyle
+//	m_Fribs.SetPara(this);
+//	m_Fribs.RegisterStyle(); 
+    
+  //2 reg para style  
+	if (!m_pFoundry)
+		return;
+    XFParaStyle* pBaseStyle = static_cast<XFParaStyle*>(m_pFoundry->GetStyleManager()->GetStyle(m_ParaStyle)); 
+    if (pBaseStyle == NULL) return;
+    m_StyleName = pBaseStyle->GetStyleName();//such intf to be added
+    m_ParentStyleName = m_StyleName;//Add by ,2005/12/12
+    XFStyleManager* pXFStyleManager = LwpGlobalMgr::GetInstance()->GetXFStyleManager(); 
+    
+	if (GetParaStyle()->GetIndent())
+	{
+		m_pIndentOverride = new LwpIndentOverride;
+		*m_pIndentOverride = *(GetParaStyle()->GetIndent()); //add by  2-6,for indent hierachy		
+	}
+//	else
+//		m_pIndentOverride = NULL;
+
+	XFParaStyle* pOverStyle = NULL;
+	sal_Bool noSpacing = sal_True;
+    sal_Bool noIndent = sal_True;
+	LwpParaProperty* pBulletProps = NULL, *pNumberingProps = NULL;
+
+    if (m_pProps != NULL)
+    {
+        pOverStyle = new XFParaStyle;
+        *pOverStyle = *pBaseStyle;
+        pOverStyle->SetStyleName(A2OUSTR(""));
+        LwpParaProperty* pProps = m_pProps;
+        sal_uInt32 PropType;
+        LwpParaStyle* pParaStyle = static_cast<LwpParaStyle*>(m_ParaStyle.obj());
+        while(pProps)
+        {
+            PropType = pProps->GetType();
+            switch(PropType)
+            {
+            case PP_LOCAL_ALIGN:
+            {
+                LwpAlignmentOverride aAlign;
+                if (!pParaStyle->GetAlignment())
+                    OverrideAlignment(NULL,static_cast<LwpParaAlignProperty*>(pProps)->GetAlignment(),pOverStyle);                
+                else
+                {
+                    aAlign = *(pParaStyle->GetAlignment());
+                    OverrideAlignment(&aAlign,static_cast<LwpParaAlignProperty*>(pProps)->GetAlignment(),pOverStyle);           
+                }
+            }
+                break;
+            case PP_LOCAL_INDENT:
+            {
+            	noIndent = sal_False;
+                if (!pParaStyle->GetIndent())
+                    OverrideIndent(NULL,static_cast<LwpParaIndentProperty*>(pProps)->GetIndent(),pOverStyle);                    
+                
+                else
+                {
+                    OverrideIndent(m_pIndentOverride,static_cast<LwpParaIndentProperty*>(pProps)->GetIndent(),pOverStyle);
+                }
+            }
+                break;
+            case PP_LOCAL_SPACING:
+            {
+                LwpSpacingOverride aSpacing;
+				noSpacing = sal_False;
+                if (!pParaStyle->GetSpacing())
+                    OverrideSpacing(NULL,static_cast<LwpParaSpacingProperty*>(pProps)->GetSpacing(),pOverStyle);                
+                else
+                {
+                    aSpacing = *(pParaStyle->GetSpacing());
+                    OverrideSpacing(&aSpacing,static_cast<LwpParaSpacingProperty*>(pProps)->GetSpacing(),pOverStyle);
+                }
+            }
+                break;
+		// 01/25/2005
+		case PP_LOCAL_BORDER:
+		{
+			OverrideParaBorder(pProps, pOverStyle);
+			break;
+		}
+		case PP_LOCAL_BREAKS:
+		{
+			OverrideParaBreaks(pProps, pOverStyle);
+			break;
+		}
+		case PP_LOCAL_BULLET:
+		{
+			pBulletProps = pProps;
+//			OverrideParaBullet(pProps);
+			break;
+		}
+		case PP_LOCAL_NUMBERING:
+		{
+			pNumberingProps = pProps;
+//			OverrideParaNumbering(pProps);
+			break;
+		}
+		//end
+		case PP_LOCAL_TABRACK:
+		{
+			//, 01/28/05
+			/*LwpTabOverride* pTabOverride=pParaStyle->GetTabOverride();
+			if(!pTabOverride)
+			{
+				OverrideTab(NULL,static_cast<LwpParaTabRackProperty*>(pProps)->GetTab(),pOverStyle);
+			}
+			else
+			{
+				OverrideTab(pTabOverride,static_cast<LwpParaTabRackProperty*>(pProps)->GetTab(),pOverStyle);				
+			}*/
+			break;
+		}
+		case PP_LOCAL_BACKGROUND:
+		{
+/*			LwpBackgroundOverride aBackground;
+			if (!pParaStyle->GetBackground())
+				OverrideBackground(NULL,static_cast<LwpParaBackGroundProperty*>(pProps)->GetBackground(),pOverStyle);                
+			else
+			{
+				aBackground = *(pParaStyle->GetaBackground());
+				OverrideBackground(&aBackground,static_cast<LwpParaBackGroundProperty*>(pProps)->GetBackground(),pOverStyle);
+			}
+*/
+			// modified by , 06/03/2005
+			LwpBackgroundOverride* pBGOver = static_cast<LwpParaBackGroundProperty*>(pProps)->GetBackground();
+			if (pBGOver)
+			{
+				LwpBackgroundStuff* pBGStuff = pBGOver->GetBGStuff();
+				if (pBGStuff && !pBGStuff->IsTransparent() )
+				{
+					if (pBGStuff->IsPatternFill())
+					{
+						XFBGImage* pXFBGImage = pBGStuff->GetFillPattern();
+						pOverStyle->SetBackImage(pXFBGImage);
+					}
+					else
+					{
+						LwpColor* pColor = pBGStuff->GetFillColor();
+						if (pColor && pColor->IsValidColor())
+						{
+							XFColor aXFColor( pColor->To24Color());
+							pOverStyle->SetBackColor( aXFColor );
+						}
+					}
+				}
+			}
+			// end modified
+                	break;			
+		}
+            	default:
+                	break;
+            	}
+		    pProps = pProps->GetNext();
+		}  
+		
+		if (noIndent && m_pIndentOverride)
+    		{
+    			if (m_pIndentOverride->IsUseRelative() && GetParent())
+    			{ 		
+				OverrideIndent(NULL,m_pIndentOverride,pOverStyle);
+    			}
+    		}  
+    		if (m_ParentStyleName.getLength()) 
+    			pOverStyle->SetParentStyleName(m_ParentStyleName); //Add by  2005/12/12   
+        	m_StyleName = pXFStyleManager->AddStyle(pOverStyle)->GetStyleName();
+
+    }
+	else //use named style
+	{
+		if (m_pIndentOverride)
+    		{
+    			if (m_pIndentOverride->IsUseRelative() && GetParent())
+    			{ 		
+        			pOverStyle = new XFParaStyle;
+        			*pOverStyle = *pBaseStyle;		
+        			OverrideIndent(NULL,m_pIndentOverride,pOverStyle); 
+        			if (m_ParentStyleName.getLength()) 
+        				pOverStyle->SetParentStyleName(m_ParentStyleName); //Add by  2005/12/12    		
+    				m_StyleName = pXFStyleManager->AddStyle(pOverStyle)->GetStyleName();
+    			}
+    		}
+	}  
+
+	if (IsInCell())
+	{
+		XFParaStyle* pOldStyle = pXFStyleManager->FindParaStyle(m_StyleName);
+		if (pOldStyle->GetNumberRight())
+		{
+			pOverStyle = new XFParaStyle;
+			*pOverStyle = *pOldStyle;
+  			pOverStyle->SetAlignType(enumXFAlignStart);
+			if (m_ParentStyleName.getLength()) 
+				pOverStyle->SetParentStyleName(m_ParentStyleName); //Add by  2005/12/12 
+			m_StyleName = pXFStyleManager->AddStyle(pOverStyle)->GetStyleName();
+		}
+	}
+	
+	// override bullet and numbering
+	OverrideParaBullet(pBulletProps);
+	OverrideParaNumbering(pNumberingProps);
+
+	//add by 
+	//register bullet style
+	LwpBulletStyleMgr* pBulletStyleMgr = this->GetBulletStyleMgr();
+	if (pBulletStyleMgr)
+	{
+		// if has bullet or numbering
+		if (m_bHasBullet)
+		{
+			//if it's normal bullet
+			if (m_pSilverBullet)
+			{
+				if (m_pSilverBullet->HasName())
+				{
+					m_aBulletStyleName = m_pSilverBullet->GetBulletStyleName();
+				}
+				else if (!m_pBullOver->IsEditable())
+				{
+					m_aBulletStyleName = pBulletStyleMgr->RegisterBulletStyle(this, m_pBullOver, m_pIndentOverride);
+				}
+
+				// test codes
+				if (m_pSilverBullet->IsBulletOrdered())
+				{
+					rtl::OUString aPreBullStyleName;
+					LwpNumberingOverride* pNumbering = this->GetParaNumbering();
+					sal_uInt16 nPosition = pNumbering->GetPosition();
+					sal_Bool bLesser = m_pSilverBullet->IsLesserLevel(nPosition);
+					sal_Bool bResetSection = m_pSilverBullet->IsNewSection(nPosition);
+					sal_Bool bHeading;
+					LwpPara* pPara = this;
+					LwpPara* pPrePara = NULL;
+					LwpSilverBullet* pParaSilverBullet = NULL;
+					sal_uInt16 nNum = 0, nOffset = 0, nLevel = 0, nFoundLevel = 0xffff, nFoundBound = 0;
+
+					nFoundBound = nLevel = pNumbering->GetLevel();
+					if (nPosition == pNumbering->GetPosition())
+					{
+						nFoundBound++;
+					}
+					bHeading = pNumbering->IsHeading();
+
+					while(sal_True)
+					{
+						/*// When we hit the hint paragraph, we can stop and check the hint.
+						if (qNumberHint && (qPara == qNumberHint->GetPara()) &&
+							qNumberHint->Lookup(qSilverBullet, Level, Position, &Offset))
+						{
+							Num += Offset;
+							break;
+						}*/
+
+						pParaSilverBullet = pPara->GetSilverBullet();
+						pNumbering = pPara->GetParaNumbering();
+
+						if (*(pPara->GetObjectID()) != *(this->GetObjectID()))
+						{
+							if (!pParaSilverBullet)
+							{
+								break;
+							}
+
+							/* If lesser, stop when we hit an outline style whose level is
+								* higher than our current level.
+								*/
+							// restart based on Outline level?
+							if (pNumbering && bLesser && (bHeading ? pNumbering->IsHeading() : sal_True))
+							{
+								if (nFoundLevel != 0xffff)
+								{
+									if (pNumbering->GetLevel() < nFoundLevel)
+									{
+										break;
+									}
+									if ((pNumbering->GetLevel() == nFoundLevel)
+										&& (*(pParaSilverBullet->GetObjectID()) != *(m_pSilverBullet->GetObjectID())
+											|| pNumbering->GetPosition() != nPosition))
+									{
+										break;
+									}
+								}
+								else
+								{
+									if (pNumbering && pNumbering->GetLevel() < nFoundBound && pParaSilverBullet
+										&&  (*(pParaSilverBullet->GetObjectID()) != *(m_pSilverBullet->GetObjectID())
+											|| pNumbering->GetPosition() != nPosition))
+									{
+										nFoundBound = pNumbering->GetLevel();
+									}
+								}
+							}
+				
+							/*if (qSpecificStyle
+							&& qSpecificStyle == qPara->GetParaStyle(LTRUE))
+								break;
+
+							// See if we crossed a section boundary
+							if (ResetSection)
+							{
+								CurrPos.SetPara(qPara);
+								if (CurrPos <= SectionPos)
+									break;
+							}*/
+						}
+						
+						// Don't bump the number if this bullet is skipped
+						if (m_pBullOver->IsSkip())
+							;
+						else if ( pParaSilverBullet
+							&& *(pParaSilverBullet->GetObjectID()) == *(m_pSilverBullet->GetObjectID())
+							&& pNumbering && nPosition == pNumbering->GetPosition())
+						{
+							if (bLesser)
+							{
+								if (nFoundLevel != 0xffff)
+								{
+									if (nFoundLevel == pNumbering->GetLevel())
+									{
+										aPreBullStyleName = pPara->GetBulletStyleName();
+										nNum++;
+									}
+								}
+								else if (pNumbering->GetLevel() <= nLevel)
+								{
+									if (pNumbering->GetLevel() >= nFoundBound)
+									{
+										break;
+									}
+									nFoundLevel = pNumbering->GetLevel();
+									aPreBullStyleName = pPara->GetBulletStyleName();
+									nNum++;
+								}
+							}
+							else
+							{
+								aPreBullStyleName = pPara->GetBulletStyleName();
+								nNum++;
+							}
+						}
+						
+						if (pPara && pPara->GetPrevious())
+							pPrePara = static_cast<LwpPara*>(pPara->GetPrevious()->obj(VO_PARA));
+						else
+							pPrePara=NULL;
+
+						if (!pPrePara)
+						{
+							LwpStory* pStory = pPara->GetStory();
+							pPrePara = pStory->GetLastParaOfPreviousStory();
+
+							if (!pPrePara)
+							{
+								break;
+							}
+						}
+						pPara = pPrePara;
+					}
+					nNum = nNum ? nNum : 1;
+
+					if (nNum > 1)
+					{
+						m_aBulletStyleName = aPreBullStyleName;
+						m_bBullContinue = sal_True;
+					}
+					else
+					{
+						m_bBullContinue = sal_False;
+						if (this->IsInCell())
+						{
+							XFListStyle* pOldStyle = static_cast<XFListStyle*>(pXFStyleManager->FindStyle(m_aBulletStyleName));
+							if (pOldStyle)
+							{
+								XFListStyle* pNewStyle = new XFListStyle(*pOldStyle);
+								m_aBulletStyleName = pXFStyleManager->AddStyle(pNewStyle)->GetStyleName();
+							}
+						}
+					}
+
+					LwpStory* pMyStory = this->GetStory();
+					if (pMyStory)
+					{
+						if (pMyStory->IsBullStyleUsedBefore(m_aBulletStyleName, m_aParaNumbering.GetPosition()))
+						{
+							//m_bBullContinue = sal_True;
+						}
+						else
+						{
+							pMyStory->AddBullStyleName2List(m_aBulletStyleName, m_aParaNumbering.GetPosition());
+						}
+					}
+
+				}
+				// end of test codes
+			}
+		}
+	}
+	//end add
+
+	if (noSpacing && GetPrevious())
+	{
+		LwpPara* pPrePara = static_cast<LwpPara*>(GetPrevious()->obj());
+		if (pPrePara && pPrePara->GetBelowSpacing()!=0)
+		{		
+			pOverStyle = new XFParaStyle;
+			*pOverStyle = *GetXFParaStyle();		
+			XFMargins* pMargin = &pOverStyle->GetMargins();
+			pMargin->SetTop(pMargin->GetTop()+pPrePara->GetBelowSpacing()); 
+			if (m_ParentStyleName.getLength()) 
+        			pOverStyle->SetParentStyleName(m_ParentStyleName); //Add by  2005/12/12 		
+			m_StyleName = pXFStyleManager->AddStyle(pOverStyle)->GetStyleName();
+		}		
+	}
+	
+	//register tab style	
+	if(m_Fribs.HasFrib(FRIB_TAG_TAB))
+	{
+		XFParaStyle* pParaStyle = new XFParaStyle;
+		*pParaStyle = *GetXFParaStyle();
+		//pOverStyle->SetStyleName(A2OUSTR(""));
+		this->RegisterTabStyle(pParaStyle);
+		if (m_ParentStyleName.getLength()) 
+        			pParaStyle->SetParentStyleName(m_ParentStyleName); //Add by  2005/12/12 
+		m_StyleName = pXFStyleManager->AddStyle(pParaStyle)->GetStyleName();
+	}
+	
+	//register master page;	
+	RegisterMasterPage(GetXFParaStyle());
+
+	// reg auto style,lay here for pagebreak need overrided para style 
+	m_Fribs.SetPara(this);
+	m_Fribs.RegisterStyle(); 
+	
+	if (m_bHasDropcap == sal_True)
+	{
+		GatherDropcapInfo(); 
+		XFParaStyle* pStyle = new XFParaStyle;
+		*pStyle = *GetXFParaStyle();
+		pStyle->SetDropCap(m_nChars-1,m_nLines);
+		if (m_ParentStyleName.getLength()) 
+        			pStyle->SetParentStyleName(m_ParentStyleName); //Add by  2005/12/12 
+		m_StyleName = pXFStyleManager->AddStyle(pStyle)->GetStyleName();		
+	} 
+	// maybe useful for futer version
+	// deleted because Leader of Table is not supported in this version
+	//AddTabStyleForTOC();
+}
+
+void LwpPara::RegisterNewSectionStyle(LwpPageLayout *pLayout)
+{
+	if( !pLayout )
+		return;
+	
+	XFSectionStyle* pSectStyle= new XFSectionStyle();
+	XFColumns* pColumns = pLayout->GetXFColumns();
+	if(pColumns)
+	{
+		pSectStyle->SetColumns(pColumns);
+	}
+	XFStyleManager* pXFStyleManager = LwpGlobalMgr::GetInstance()->GetXFStyleManager(); 
+	m_SectionStyleName = pXFStyleManager->AddStyle(pSectStyle)->GetStyleName();
+}
+
+XFSection* LwpPara::CreateXFSection()
+{
+	XFSection* pXFSection = new XFSection();	
+	pXFSection->SetStyleName(m_SectionStyleName);
+	m_SectionStyleName = A2OUSTR("");
+	return pXFSection;
+}
+
+/**************************************************************************
+ * @descr:  register tab style
+ * @param:   
+ * @param:   
+ * @return:  
+**************************************************************************/
+void LwpPara::RegisterTabStyle(XFParaStyle* pXFParaStyle)
+{
+	LwpTabOverride aFinaOverride;
+	LwpTabOverride* pBase = NULL;
+	//get the tabrack from the current layout
+	LwpStory* pStory = static_cast<LwpStory*>(m_Story.obj());
+	LwpMiddleLayout* pLayout = pStory->GetTabLayout();
+	if(pLayout)
+	{
+		pBase = pLayout->GetTabOverride();
+		if(pBase)
+		{
+			pBase->Override(&aFinaOverride);
+		}
+	}
+	
+	//get the tabrack from the base parastyle
+	LwpParaStyle* pParaStyle =  GetParaStyle();
+	pBase = pParaStyle->GetTabOverride();
+	if(pBase)
+	{
+		pBase->Override(&aFinaOverride);
+	}
+	//get the tabrack from the local property
+	pBase = GetLocalTabOverride();
+	if(pBase)
+	{
+		pBase->Override(&aFinaOverride);
+	}
+
+	LwpParaStyle::ApplyTab(pXFParaStyle, &aFinaOverride);
+}
+/**
+ * @short   parse dropcap text
+ */
+void LwpPara::ParseDropcapContent()
+{
+	if (!GetFoundry())
+		return;
+	XFParagraph* pDropcap = GetFoundry()->GetDropcapMgr()->GetXFPara();
+	if (pDropcap)
+	{
+		m_Fribs.SetXFPara(pDropcap);
+		m_Fribs.XFConvert();	
+	}
+}
+/**
+ * @short   add paragraph break attribute
+ */
+void LwpPara::AddBreakBefore(XFContentContainer* pCont)
+{
+	if (!m_pBreaks)
+		return;
+	if (m_pBreaks->IsPageBreakBefore())
+	{
+		XFParagraph *pPara = new XFParagraph();			
+		pPara->SetStyleName(m_BefPageBreakName);
+		pCont->Add(pPara);
+	}
+	else if (m_pBreaks->IsColumnBreakBefore())
+	{
+		XFParagraph *pPara = new XFParagraph();				
+		pPara->SetStyleName(m_BefColumnBreakName);
+		pCont->Add(pPara);
+	}	
+}
+
+void LwpPara::AddBreakAfter(XFContentContainer* pCont)
+{
+	if (!m_pBreaks)
+		return;
+	if (m_pBreaks->IsPageBreakAfter())
+	{
+		XFParagraph *pPara = new XFParagraph();			
+		pPara->SetStyleName(m_AftPageBreakName);
+		pCont->Add(pPara);
+	}
+	else if (m_pBreaks->IsColumnBreakAfter())
+	{
+		XFParagraph *pPara = new XFParagraph();			
+		pPara->SetStyleName(m_AftColumnBreakName);
+		pCont->Add(pPara);
+	}			
+}
+
+LwpVirtualLayout* LwpPara::GetLayoutWithMyStory()
+{
+	LwpStory* pMyStory = NULL;
+	if (!m_Story.IsNull())
+	{
+		pMyStory = static_cast<LwpStory*>(m_Story.obj(VO_STORY));
+		if (!pMyStory)
+		{
+			return NULL;
+		}
+
+		return pMyStory->GetLayout(NULL);
+	}
+
+	return NULL;
+}
+
+LwpBulletStyleMgr* LwpPara::GetBulletStyleMgr()
+{
+	if (m_pFoundry)
+	{
+		return m_pFoundry->GetBulletStyleMgr();
+	}
+
+	return NULL;
+}
+
+XFContentContainer* LwpPara::AddBulletList(XFContentContainer* pCont)
+{
+	LwpBulletStyleMgr* pBulletStyleMgr = this->GetBulletStyleMgr();
+	if (!pBulletStyleMgr)
+	{
+		assert(false);
+		return NULL;
+	}
+
+	sal_uInt16 nLevel = m_nLevel;
+	sal_Bool bOrdered = sal_False;
+	LwpStory* pMyStory = this->GetStory();	
+
+	pBulletStyleMgr->SetContinueFlag(m_bBullContinue);
+#if 0
+	if (m_pSilverBullet->IsBulletOrdered())
+	{
+		LwpObjectID aSilverBulletID = pBulletStyleMgr->GetCurrentSilverBullet();
+		if (aSilverBulletID.IsNull())
+		{
+			pBulletStyleMgr->SetContinueFlag(sal_False);
+		}
+		else if (pMyStory && pMyStory->IsBullStyleUsedBefore(m_aBulletStyleName, this->m_aParaNumbering.GetPosition()))
+		{
+			pBulletStyleMgr->SetContinueFlag(sal_True);
+		}
+/*		else if (aSilverBulletID == *(m_pSilverBullet->GetObjectID()))
+		{
+			LwpNumberingOverride* pNumOver = pBulletStyleMgr->GetCurrentNumOver();
+			if (!pNumOver)
+			{
+				pBulletStyleMgr->SetContinueFlag(sal_False);
+			}
+			else if (m_aParaNumbering.GetPosition() == pNumOver->GetPosition())
+			{
+				pBulletStyleMgr->SetContinueFlag(sal_True);
+			}
+		}
+		else
+		{
+			pBulletStyleMgr->SetContinueFlag(sal_False);
+		}
+*/
+		pBulletStyleMgr->SetCurrentNumOver(m_aParaNumbering);
+		pBulletStyleMgr->SetCurrentSilverBullet(*(m_pSilverBullet->GetObjectID()));
+	}
+#endif
+
+	if (m_pSilverBullet->IsBulletOrdered())
+	{
+		bOrdered = sal_True;
+	}
+	if (m_pSilverBullet->HasName())
+	{
+//		nLevel = m_pParaNumbering->GetPosition();
+		nLevel = m_aParaNumbering.GetPosition();
+		m_nLevel = nLevel;//add by ,for get para level
+//		m_aBulletStyleName = m_pSilverBullet->GetBulletStyleName();
+	}
+	
+	return ( pBulletStyleMgr->AddBulletList(pCont, bOrdered, m_aBulletStyleName, 
+			nLevel, m_pBullOver->IsSkip()) );
+}
+
+LwpNumberingOverride* LwpPara::GetParaNumbering()
+{
+	return &m_aParaNumbering;
+#if 0
+	LwpNumberingOverride* pNumbering = NULL;
+	LwpParaStyle* pStyle = this->GetParaStyle();
+	if (pStyle)
+	{
+		pNumbering = pStyle->GetNumberingOverride();
+	}
+
+	if (pNumbering)
+	{
+/*		if (m_pParaNumbering)
+		{
+			m_pParaNumbering->Override(pNumbering);
+		}*/
+		m_aParaNumbering.Override(pNumbering);
+		return pNumbering;
+	}
+	else
+	{
+//		return m_pParaNumbering;
+		return &m_aParaNumbering;
+	}
+#endif
+}
+
+void LwpForked3NotifyList::Read(LwpObjectStream* pObjStrm)
+{
+	m_PersistentList.Read(pObjStrm);
+}
+
+void LwpNotifyListPersistent::Read(LwpObjectStream* pObjStrm)
+{
+	m_Head.ReadIndexed(pObjStrm);
+	pObjStrm->SkipExtra();
+}
+
+void LwpPara::Release()
+{}
+
diff -urNp lotuswordpro.bak/source/filter/lwppara.hxx lotuswordpro/source/filter/lwppara.hxx
--- lotuswordpro.bak/source/filter/lwppara.hxx	1970-01-01 08:00:00.000000000 +0800
+++ lotuswordpro/source/filter/lwppara.hxx	2008-10-22 11:42:29.000000000 +0800
@@ -0,0 +1,423 @@
+/*************************************************************************
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: IBM Corporation
+ *
+ *  Copyright: 2008 by IBM Corporation
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+/*************************************************************************
+ * @file 
+ *  LwpPara: Word Pro object for paragraph
+ ************************************************************************/
+/*************************************************************************
+ * Change History
+ Jan 2005			Created
+ ************************************************************************/
+
+
+#ifndef _LWPPARAGRAPH_HXX_
+#define _LWPPARAGRAPH_HXX_
+#include "lwpfribheader.hxx"
+#include "lwpobj.hxx"
+#include "lwpobjstrm.hxx"
+
+#include <vector>
+#include "lwpheader.hxx"
+#include "lwpdlvlist.hxx"
+#include "lwpbasetype.hxx"
+#include "lwpoverride.hxx"
+#include "lwpfoundry.hxx"
+#include "lwplayout.hxx"
+#include "lwpfrib.hxx"
+#include "lwpfribptr.hxx"
+#include "lwpfribtext.hxx"
+#include "xfilter/xfparagraph.hxx"
+#include "xfilter/xfdefs.hxx"
+#include "xfilter/xfparastyle.hxx"
+#include "xfilter/xfsection.hxx"
+
+class LwpParaProperty;
+class LwpPara;
+class LwpBreaksOverride;
+class LwpBulletStyleMgr;
+class LwpNotifyListPersistent
+{
+public:
+	LwpNotifyListPersistent(){};
+	void Read(LwpObjectStream* pObjStrm);
+protected:
+	LwpObjectID m_Head;
+};
+
+class LwpForked3NotifyList
+{
+public:
+	LwpForked3NotifyList(){};
+protected:
+	LwpNotifyListPersistent m_ExtraList;
+	LwpNotifyListPersistent m_PersistentList;
+public:
+	LwpNotifyListPersistent* GetExtraList(){return &m_ExtraList;}
+	void Read(LwpObjectStream* pObjStrm);
+};
+
+class LwpParaStyle;
+class LwpTabOverride;
+class LwpNumberingOverride;
+class LwpSilverBullet;
+class LwpPageLayout;
+
+struct ParaNumbering
+{
+	LwpFribText* pPrefix;
+	LwpFribParaNumber* pParaNumber;
+	LwpFribText* pSuffix;
+
+	sal_uInt16 nPrefixLevel;//hidelevels of prefix text frib
+	sal_uInt16 nNumLevel;//hidelevels of paranumber frib
+	sal_uInt16 nSuffixLevel;//hidelevels of suffix text frib
+	
+	ParaNumbering()
+	{
+		clear();
+	}
+
+	void clear()
+	{
+		pPrefix = NULL;
+		pParaNumber = NULL;
+		pSuffix = NULL;
+		nPrefixLevel = 0;
+		nNumLevel = 0;
+		nSuffixLevel = 0;
+	}
+};
+
+class LwpDropcapLayout;
+class LwpCellLayout;
+class LwpPara : public LwpDLVList
+{
+public:
+	LwpPara(LwpObjectHeader& objHdr, LwpSvStream* pStrm);
+	~LwpPara();
+public:
+	void Read();
+	void RegisterStyle();
+	void Parse(IXFStream* pOutputStream);
+	void XFConvert(XFContentContainer* pCont);
+	void Release();
+
+	LwpPara* GetParent();
+	LwpObjectID* GetStoryID();
+	LwpStory* GetStory();
+	LwpBreaksOverride* GetBreaks();
+	
+	LwpParaStyle* GetParaStyle();
+	XFParaStyle* GetXFParaStyle();
+	LwpIndentOverride* GetIndent();
+	LwpTabOverride* GetLocalTabOverride();
+	LwpNumberingOverride* GetParaNumbering();
+	
+	inline LwpSilverBullet* GetSilverBullet();
+	inline LwpObjectID GetSilverBulletID();
+	rtl::OUString GetBulletChar() const;
+	sal_uInt32 GetBulletFontID() const;
+	sal_uInt16 GetLevel() const;
+	sal_Bool GetBulletFlag() const;
+	
+	void GetParaNumber(sal_uInt16 nPosition, ParaNumbering* pParaNumbering);
+	LwpFribPtr* GetFribs();
+	double GetBelowSpacing();
+	LwpParaProperty* GetProperty(sal_uInt32 nPropType);
+	void GatherDropcapInfo();
+	rtl::OUString GetBulletStyleName() const;
+	void SetBelowSpacing(double value);
+	void SetBulletStyleName(const rtl::OUString& rNewName);
+	void SetBulletFlag(sal_Bool bFlag);
+	void SetIndent(LwpIndentOverride* pIndentOverride);
+	void SetFirstFrib(rtl::OUString Content,sal_uInt32 FontID);
+	OUString GetContentText(sal_Bool bAllText = sal_False);
+
+	void SetParaDropcap(sal_Bool bFlag);
+	void SetDropcapLines(sal_uInt16 number);
+	void SetDropcapChars(sal_uInt32 chars);
+	void SetDropcapLayout(LwpDropcapLayout* pLayout);
+	sal_Bool IsHasDropcap();
+	
+	XFContentContainer* GetXFContainer();
+	void AddXFContent(XFContent* pCont);
+	void SetXFContainer(XFContentContainer* pCont);
+	void FindLayouts();// for register pagelayout, add by , 02/20/2005
+	void RegisterTabStyle(XFParaStyle* pXFParaStyle);
+
+	// add by  04/13/2005
+	LwpVirtualLayout* GetLayoutWithMyStory();
+	LwpBulletStyleMgr* GetBulletStyleMgr();
+	sal_uInt32 GetOrdinal(){ return m_nOrdinal;};
+	sal_Bool operator <(LwpPara& Other);	
+	sal_Bool ComparePagePosition(LwpVirtualLayout* pPreLayout, LwpVirtualLayout* pNextLayout);
+//	rtl::OUString RegisterBulletStyle();
+	// end add
+	
+	sal_Bool IsNumberRight();
+	sal_Bool IsInCell();
+	
+	void SetAllText(OUString sText);
+	OUString GetStyleName(){return m_StyleName;}
+	
+protected:
+	sal_uInt32	m_nOrdinal;	// Ordinal number of this paragraph 
+	LwpObjectID	m_ParaStyle;	// handle of paragraph style
+	LwpPoint		m_Hint;		// Paragraph hint - width & height
+	LwpObjectID	m_Story;		// Story the paragraph is part of 
+	
+	sal_uInt16	m_nFlags;
+	sal_uInt16	m_nLevel;
+	LwpFribPtr	m_Fribs;
+	LwpParaProperty*  m_pProps;
+	//LwpForked3NotifyList* m_NotifyList;	//not saved
+	
+	rtl::OUString m_StyleName;
+	rtl::OUString m_ParentStyleName;//Add by ,to support toc,2005/12/13	
+	LwpBreaksOverride* m_pBreaks;
+	rtl::OUString m_AftPageBreakName;
+	rtl::OUString m_BefPageBreakName;	
+	rtl::OUString m_AftColumnBreakName;
+	
+	rtl::OUString m_BefColumnBreakName;
+	LwpIndentOverride* m_pIndentOverride;	
+	rtl::OUString m_Content;//for silver bullet,get text of first frib, add by  2/1
+	sal_uInt32 m_FontID;//for silver bullet, add by  2/1
+	rtl::OUString m_AllText;//get all text in this paragraph
+
+	//add by 
+	sal_Bool m_bHasBullet;
+	LwpObjectID m_aSilverBulletID;
+	LwpSilverBullet* m_pSilverBullet;
+	LwpBulletOverride* m_pBullOver;
+//	LwpNumberingOverride* m_pParaNumbering;
+	LwpNumberingOverride m_aParaNumbering;
+	rtl::OUString m_aBulletStyleName;
+	sal_Bool m_bBullContinue;
+	//end add
+
+	OUString m_SectionStyleName;
+	sal_Bool m_bHasDropcap;
+	sal_uInt16 m_nLines;
+	sal_uInt32 m_nChars;
+	LwpDropcapLayout* m_pDropcapLayout;
+	double m_BelowSpacing;
+	
+	XFContentContainer* m_pXFContainer;	//Current container for VO_PARA
+
+	rtl::OUString m_TabStyleName;
+	enum
+	{
+		/* bit definitions for the paragraph object flags */
+		DEMAND_LOAD		= 0x0001,	// need to demand load this para
+		DATA_DIRTY		= 0x0002,	// paragraph data is dirty
+		SPELLSTARTOVER	= 0x0004,	// need to recheck paragraph
+		SPELLDIRTY		= 0x0008,	// has misspelled word in para
+		SPELLCHECKING	= 0x0010,	// started checking paragraph
+		READING			= 0x0020,	// We're loading this para from disk
+		DISKCHANGED		= 0x0040,	// Read size different from write size
+		USEFLOWBREAKS	= 0x0080,	// Use line breaks provided by filter
+		VALID_LEVEL		= 0x0100,	// cLevel is valid
+		NOUSECOUNT		= 0x0200,	// Don't change the style's use count
+		CHANGED			= 0x0400,	// This para has been edited
+		SPREADBULLET	= 0x0800,	// Para's bullet is in edit-on-page mode
+		NEWBULLET		= 0x1000,	// Bullets should have new font behavior
+
+		// Don't write these flags out to disk
+		NOWRITEFLAGS	= (READING | DISKCHANGED | CHANGED),
+
+		MAX_INDENT_LEVELS	= 10
+	};
+private:
+	void OverrideAlignment(LwpAlignmentOverride* base,LwpAlignmentOverride* over,XFParaStyle* pOverStyle);//add by  1-24  
+	void OverrideIndent(LwpIndentOverride* base,LwpIndentOverride* over,XFParaStyle* pOverStyle);
+	void OverrideSpacing(LwpSpacingOverride* base,LwpSpacingOverride* over,XFParaStyle* pOverStyle);
+	void OverrideParaBorder(LwpParaProperty* pProps, XFParaStyle* pOverStyle);
+	void OverrideParaBreaks(LwpParaProperty* pProps, XFParaStyle* pOverStyle);
+
+	void OverrideParaBullet(LwpParaProperty* pProps);
+	void OverrideParaNumbering(LwpParaProperty* pProps);
+	void OverrideTab(LwpTabOverride* base,LwpTabOverride* over,XFParaStyle* pOverStyle);
+	BOOL IsBadHintsInFile();
+
+	//void OutPutSectionTail(IXFStream* pOutputStream);
+	//void OutPutBulletTail(LwpBulletStyleMgr* pBulletStyleMgr,IXFStream* pOutputStream);	
+	
+	sal_Bool RegisterMasterPage(XFParaStyle* pBaseStyle);
+	void RegisterNewSectionStyle(LwpPageLayout* pLayout);
+
+	void ParseDropcapContent();
+	XFContentContainer* AddBulletList(XFContentContainer* pCont);
+	void AddBreakAfter(XFContentContainer* pCont);
+	void AddBreakBefore(XFContentContainer* pCont);
+	XFSection* CreateXFSection();
+
+	/*
+	sal_Bool IsNeedTabForTOC();
+	void AddTabStyleForTOC();
+	void AddTabStopForTOC();
+	maybe useful for futer version */
+};
+
+inline LwpSilverBullet* LwpPara::GetSilverBullet()
+{ 
+	return m_pSilverBullet; 
+}
+inline LwpObjectID LwpPara::GetSilverBulletID()
+{
+	return m_aSilverBulletID;
+}
+inline rtl::OUString LwpPara::GetBulletChar() const 
+{ 
+	return m_Content; 
+}
+inline sal_uInt32 LwpPara::GetBulletFontID() const 
+{ 
+	return m_FontID; 
+}
+inline sal_uInt16 LwpPara::GetLevel() const 
+{ 
+	return m_nLevel; 
+}
+inline void LwpPara::SetBulletStyleName(const rtl::OUString& rNewName)
+{ 
+	m_aBulletStyleName = rNewName; 
+}
+inline void LwpPara::SetBulletFlag(sal_Bool bFlag) 
+{ 
+	m_bHasBullet = bFlag; 
+}
+inline sal_Bool LwpPara::GetBulletFlag() const 
+{ 
+	return m_bHasBullet; 
+}
+inline LwpFribPtr* LwpPara::GetFribs() 
+{ 
+	return &m_Fribs; 
+}
+inline LwpBreaksOverride* LwpPara::GetBreaks()
+{ 
+	return m_pBreaks; 
+}
+inline XFContentContainer* LwpPara::GetXFContainer()
+{ 
+	return m_pXFContainer; 
+}
+inline rtl::OUString LwpPara::GetBulletStyleName() const
+{
+	return m_aBulletStyleName;
+}
+inline void LwpPara::AddXFContent(XFContent* pCont)
+{ 
+	m_pXFContainer->Add(pCont); 
+}
+inline void LwpPara::SetXFContainer(XFContentContainer* pCont)
+{ 
+	m_pXFContainer = pCont; 
+}
+inline LwpIndentOverride* LwpPara::GetIndent()
+{
+	return m_pIndentOverride;
+}
+inline void LwpPara::SetIndent(LwpIndentOverride* pIndentOverride)
+{
+	if (m_pIndentOverride)
+		delete m_pIndentOverride;
+	m_pIndentOverride = pIndentOverride;
+}
+inline LwpObjectID* LwpPara::GetStoryID()
+{
+	return &m_Story;
+}
+inline LwpStory* LwpPara::GetStory()
+{
+	if (m_Story.obj())
+		return static_cast<LwpStory*>(m_Story.obj());
+	return NULL;
+}
+
+inline sal_Bool LwpPara::IsHasDropcap()
+{
+	return m_bHasDropcap;
+}
+inline void LwpPara::SetParaDropcap(sal_Bool bFlag)
+{
+	m_bHasDropcap = bFlag;
+}
+inline void LwpPara::SetDropcapLines(sal_uInt16 number)
+{
+	m_nLines = number;
+}
+inline void LwpPara::SetDropcapChars(sal_uInt32 chars)
+{
+	m_nChars = chars;
+}
+inline void LwpPara::SetDropcapLayout(LwpDropcapLayout* pLayout)
+{
+	m_pDropcapLayout = pLayout;
+}
+inline BOOL LwpPara::IsBadHintsInFile()
+{
+	return (BOOL) ((m_nFlags & DOC_BADFILEPARAHINTS) != 0);
+}
+inline double LwpPara::GetBelowSpacing()
+{
+	return m_BelowSpacing;
+}
+inline void LwpPara::SetBelowSpacing(double value)
+{
+	m_BelowSpacing = value;
+}
+#endif
diff -urNp lotuswordpro.bak/source/filter/lwpparaproperty.cxx lotuswordpro/source/filter/lwpparaproperty.cxx
--- lotuswordpro.bak/source/filter/lwpparaproperty.cxx	1970-01-01 08:00:00.000000000 +0800
+++ lotuswordpro/source/filter/lwpparaproperty.cxx	2008-10-22 11:42:29.000000000 +0800
@@ -0,0 +1,298 @@
+/*************************************************************************
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: IBM Corporation
+ *
+ *  Copyright: 2008 by IBM Corporation
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+/*************************************************************************
+ * @file 
+ *  For LWP filter architecture prototype
+ ************************************************************************/
+/*************************************************************************
+ * Change History
+ Jan 2005			Created
+ ************************************************************************/
+#include "lwpparaproperty.hxx"
+#include "lwpobjtags.hxx"
+#include "lwppara.hxx"
+
+LwpParaProperty* LwpParaProperty::ReadPropertyList(LwpObjectStream* pFile,LwpObject* Whole)
+{
+	sal_uInt32 tag;
+	LwpParaProperty* Prop= NULL;
+	LwpParaProperty* NewProp= NULL;
+	sal_uInt16 Len;
+
+	for(;;)
+	{
+		pFile->QuickRead(&tag,sizeof(sal_uInt32));
+		// Keep reading properties until we hit the end tag
+		if (tag == TAG_ENDSUBOBJ)
+			break;
+
+		// Get the length of this property
+		pFile->QuickRead(&Len,sizeof(sal_uInt16));
+
+		// Create whatever kind of tag we just found
+		switch (tag)
+		{
+			case TAG_PARA_ALIGN:
+				NewProp = new LwpParaAlignProperty(pFile);
+				break;
+
+			case TAG_PARA_INDENT:
+				NewProp = new LwpParaIndentProperty(pFile);
+				break;
+
+			case TAG_PARA_SPACING:
+				NewProp = new LwpParaSpacingProperty(pFile);
+				break;
+
+			case TAG_PARA_BORDER:
+				NewProp = new LwpParaBorderProperty(pFile);
+				break;
+
+			case TAG_PARA_BACKGROUND:
+				NewProp = new LwpParaBackGroundProperty(pFile);
+				break;
+
+			case TAG_PARA_BREAKS:
+				NewProp = new LwpParaBreaksProperty(pFile);
+				break;
+
+			case TAG_PARA_BULLET:
+				NewProp = new LwpParaBulletProperty(pFile);
+				static_cast<LwpPara*>(Whole)->SetBulletFlag(sal_True);
+				break;
+
+			case TAG_PARA_NUMBERING:
+				NewProp = new LwpParaNumberingProperty(pFile);
+				break;
+
+			case TAG_PARA_TAB:
+				NewProp = new LwpParaTabRackProperty(pFile);
+				break;
+/*
+#ifdef KINSOKU
+			case TAG_PARA_KINSOKU:
+				NewProp = new CParaKinsokuProperty(pFile);
+				break;
+#endif
+
+			case TAG_PARA_PROPLIST:
+				NewProp = new CParaPropListProperty(pFile,Whole);
+				break;
+
+			case TAG_PARA_SHOW:
+			case TAG_PARA_HIDE:
+				// Ignore these properties
+*/			default:
+				pFile->SeekRel(Len);
+				NewProp = NULL;
+				break;
+		}
+		// Stick it at the beginning of the list
+		if (NewProp)
+		{
+			NewProp->insert(Prop, NULL);
+			Prop = NewProp;
+		}
+	}
+	return Prop;
+}
+
+LwpParaAlignProperty::LwpParaAlignProperty(LwpObjectStream* pFile)
+{
+//    pFile->SeekRel(3);
+     LwpObjectID align;
+     align.ReadIndexed(pFile);
+     m_pAlignment =static_cast<LwpAlignmentOverride*>
+     		(static_cast<LwpAlignmentPiece*>(align.obj(VO_ALIGNMENTPIECE))->GetOverride());
+/*    if(pFile->GetFileRevision() < 0x000b)
+	{
+		CAlignmentPieceGuts guts;
+		CAlignmentPiece::QuickReadGuts(pFile, &guts);
+		cAlignment = GetPieceManager()->GetAlignmentPiece(&guts);
+	}
+	else
+	{
+		LwpFoundry* OldFoundry = pFile->GetFoundry();
+		pFile->SetFoundry(GetPieceManager()->GetFoundry());
+		cAlignment.QuickRead(pFile);
+		pFile->SetFoundry(OldFoundry);
+	} */
+}
+
+LwpParaAlignProperty::~LwpParaAlignProperty(void)
+{  
+}
+    
+sal_uInt32	LwpParaAlignProperty::GetType(void)
+{
+    return PP_LOCAL_ALIGN;
+}
+
+LwpParaIndentProperty::LwpParaIndentProperty(LwpObjectStream* pFile)
+{
+//    LwpObjectID indent;
+    m_aIndentID.ReadIndexed(pFile);
+    m_pIndent = static_cast<LwpIndentOverride*>
+    		(static_cast<LwpIndentPiece*>(m_aIndentID.obj(VO_INDENTPIECE))->GetOverride());
+}
+
+LwpParaIndentProperty::~LwpParaIndentProperty(void)
+{
+}
+
+sal_uInt32 LwpParaIndentProperty::GetType(void)
+{
+    return PP_LOCAL_INDENT;
+}
+
+LwpParaSpacingProperty::LwpParaSpacingProperty(LwpObjectStream* pFile)
+{
+    LwpObjectID spacing;
+    spacing.ReadIndexed(pFile);
+    m_pSpacing = static_cast<LwpSpacingOverride*>
+    		(static_cast<LwpSpacingPiece*>(spacing.obj(VO_SPACINGPIECE))->GetOverride());
+}
+
+LwpParaSpacingProperty::~LwpParaSpacingProperty(void)
+{
+}
+
+sal_uInt32 LwpParaSpacingProperty::GetType(void)
+{
+    return PP_LOCAL_SPACING;
+}
+
+// 01/25/2004////////////////////////////////////////////////////////
+LwpParaBorderProperty::LwpParaBorderProperty(LwpObjectStream* pStrm) :
+m_pParaBorderOverride(NULL)
+{
+	LwpObjectID aParaBorder;
+	aParaBorder.ReadIndexed(pStrm);
+
+	if (!aParaBorder.IsNull())
+	{
+		m_pParaBorderOverride = static_cast<LwpParaBorderOverride*>
+			(static_cast<LwpParaBorderPiece*>(aParaBorder.obj())->GetOverride());
+	}
+}
+
+LwpParaBreaksProperty::LwpParaBreaksProperty(LwpObjectStream* pStrm) :
+m_pBreaks(NULL)
+{
+	LwpObjectID aBreaks;
+	aBreaks.ReadIndexed(pStrm);
+
+	if (!aBreaks.IsNull())
+	{
+		m_pBreaks = static_cast<LwpBreaksOverride*>
+			(static_cast<LwpBreaksPiece*>(aBreaks.obj())->GetOverride());
+	}
+}
+
+LwpParaBulletProperty::LwpParaBulletProperty(LwpObjectStream* pStrm) :
+m_pBullet(new LwpBulletOverride)
+{
+	m_pBullet->Read(pStrm);
+}
+
+LwpParaBulletProperty::~LwpParaBulletProperty()
+{
+	if (m_pBullet)
+	{
+		delete m_pBullet;
+	}
+}
+
+LwpParaNumberingProperty::LwpParaNumberingProperty(LwpObjectStream * pStrm)
+{
+	LwpObjectID aNumberingPiece;
+	aNumberingPiece.ReadIndexed(pStrm);
+	if (aNumberingPiece.IsNull())
+	{
+		return;
+	}
+
+	m_pNumberingOverride = static_cast<LwpNumberingOverride*>
+		(static_cast<LwpNumberingPiece*>(aNumberingPiece.obj(VO_NUMBERINGPIECE))->GetOverride());
+		
+}
+//end//////////////////////////////////////////////////////////////////////
+
+LwpParaTabRackProperty::LwpParaTabRackProperty(LwpObjectStream* pFile)
+{
+    LwpObjectID aTabRack;
+    aTabRack.ReadIndexed(pFile);
+    m_pTabOverride =static_cast<LwpTabOverride*>(static_cast<LwpTabPiece*>(aTabRack.obj())->GetOverride());
+}
+
+LwpParaTabRackProperty::~LwpParaTabRackProperty()
+{
+}
+
+LwpParaBackGroundProperty::LwpParaBackGroundProperty(LwpObjectStream* pFile)
+{
+	LwpObjectID background;
+	background.ReadIndexed(pFile);
+	m_pBackground = static_cast<LwpBackgroundOverride*>(
+		static_cast<LwpBackgroundPiece*>(background.obj())->GetOverride());	
+}
+
+LwpParaBackGroundProperty::~LwpParaBackGroundProperty()
+{
+}
+
+
+
+
diff -urNp lotuswordpro.bak/source/filter/lwpparaproperty.hxx lotuswordpro/source/filter/lwpparaproperty.hxx
--- lotuswordpro.bak/source/filter/lwpparaproperty.hxx	1970-01-01 08:00:00.000000000 +0800
+++ lotuswordpro/source/filter/lwpparaproperty.hxx	2008-10-22 11:42:29.000000000 +0800
@@ -0,0 +1,319 @@
+/*************************************************************************
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: IBM Corporation
+ *
+ *  Copyright: 2008 by IBM Corporation
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+/*************************************************************************
+ * @file 
+ *  For LWP filter architecture prototype
+ ************************************************************************/
+/*************************************************************************
+ * Change History
+ Jan 2005			Created
+ ************************************************************************/
+#ifndef _LWPPARAPROPERTY_HXX_
+#define _LWPPARAPROPERTY_HXX_
+
+#include "lwpobj.hxx"
+#include "lwpobjstrm.hxx"
+#include "lwpdllist.hxx"
+
+#include "lwpoverride.hxx"
+#include "lwppiece.hxx"
+
+/* paragraph property ID's */
+#define	PP_OUTLINE_SHOW			0x53484f4cUL	/* "SHOW" */
+#define	PP_OUTLINE_HIDE			0x48494445UL	/* "HIDE" */
+#define PP_LOCAL_ALIGN			0x414c494eUL	/* "ALIN" */
+#define PP_LOCAL_INDENT			0x494e444eUL	/* "INDN" */
+#define PP_LOCAL_SPACING		0x5350434eUL	/* "SPCN" */
+#define PP_LOCAL_TABRACK		0x54414253UL	/* "TABS" */
+#define PP_LOCAL_BREAKS			0x42524b53UL	/* "BRKS" */
+#define PP_LOCAL_BULLET			0x42554c4cUL	/* "BULL" */
+#define PP_LOCAL_BORDER			0x424f5244UL	/* "BORD" */
+#define PP_LOCAL_BACKGROUND		0x4241434bUL	/* "BACK" */
+#define PP_LOCAL_NUMBERING		0x4e4d4252UL	/* "NMBR" */
+#define PP_LOCAL_KINSOKU		0x4b494e53UL	/* "KINS" */
+#define PP_PROPLIST				0x50524f50UL	/* "PROP" */
+
+class LwpParaProperty : public LwpDLList
+{
+public:
+    LwpParaProperty(){};
+    virtual ~LwpParaProperty(void){};
+    virtual sal_uInt32	GetType(void) = 0;
+    inline  LwpParaProperty* GetNext(void);
+    inline  LwpParaProperty* GetPrevious(void);
+
+    static LwpParaProperty* ReadPropertyList(LwpObjectStream* pFile,LwpObject* Whole);
+
+};
+
+inline LwpParaProperty* LwpParaProperty::GetNext(void)
+{
+	return static_cast<LwpParaProperty*>(LwpDLList::GetNext());
+}
+
+inline LwpParaProperty* LwpParaProperty::GetPrevious(void)
+{
+	return static_cast<LwpParaProperty*>(LwpDLList::GetPrevious());
+}
+
+//align/indent/spacing
+//TO DO:border/backgroud etc
+
+
+class LwpParaAlignProperty : public LwpParaProperty
+{
+public:
+//		LwpParaAlignProperty(LwpParaAlignProperty* pOther);
+		LwpParaAlignProperty(LwpObjectStream* pFile);
+		virtual ~LwpParaAlignProperty(void);
+		LwpAlignmentOverride* GetAlignment(void);
+		sal_uInt32	GetType(void);
+
+private:
+//		LwpAlignmentPiece m_Alignment; 
+        LwpAlignmentOverride* m_pAlignment;
+};
+
+inline LwpAlignmentOverride* LwpParaAlignProperty::GetAlignment(void)
+{
+//	return static_cast<LwpAlignmentOverride*>(m_Alignment.m_pOverride);  
+	return m_pAlignment; //add by  1-24   
+}
+
+class LwpParaIndentProperty : public LwpParaProperty
+{
+public:
+		LwpParaIndentProperty(LwpObjectStream* pFile);
+		virtual ~LwpParaIndentProperty(void);
+		LwpIndentOverride* GetIndent(void);
+		sal_uInt32 GetType(void);
+		//add by , 03/22/2005
+		inline LwpObjectID GetIndentID();
+		//end add
+
+private:
+		//add by , 03/22/2005
+		LwpObjectID m_aIndentID;
+		//end add
+		LwpIndentOverride* m_pIndent;
+};
+inline LwpObjectID LwpParaIndentProperty::GetIndentID()
+{
+	return m_aIndentID;
+}
+inline LwpIndentOverride* LwpParaIndentProperty::GetIndent(void)
+{ 
+	return m_pIndent;  
+}
+
+class LwpParaSpacingProperty : public LwpParaProperty
+{
+public:
+		LwpParaSpacingProperty(LwpObjectStream* pFile);
+		virtual ~LwpParaSpacingProperty(void);
+		LwpSpacingOverride* GetSpacing(void);
+		sal_uInt32 GetType(void);
+private:
+		LwpSpacingOverride* m_pSpacing;
+
+};
+
+inline LwpSpacingOverride* LwpParaSpacingProperty::GetSpacing(void)
+{
+	return m_pSpacing;
+}
+
+//add by , 01/25/2005////////////////////////////////////////////
+class LwpParaBorderOverride;
+class LwpParaBorderProperty : public LwpParaProperty
+{
+public:
+	LwpParaBorderProperty(LwpObjectStream* pStrm);
+
+	inline sal_uInt32 GetType();
+
+	inline LwpParaBorderOverride* GetLocalParaBorder();
+	
+private:
+	LwpParaBorderOverride* m_pParaBorderOverride;
+};
+
+inline LwpParaBorderOverride* LwpParaBorderProperty::GetLocalParaBorder()
+{
+	return m_pParaBorderOverride;
+}
+
+inline sal_uInt32 LwpParaBorderProperty::GetType()
+{
+	return PP_LOCAL_BORDER;
+}
+
+class LwpParaBreaksProperty : public LwpParaProperty
+{
+public:
+	LwpParaBreaksProperty(LwpObjectStream* pStrm);
+
+	inline sal_uInt32 GetType();
+
+	inline LwpBreaksOverride* GetLocalParaBreaks();
+
+private:
+	LwpBreaksOverride* m_pBreaks;
+
+};
+
+inline sal_uInt32 LwpParaBreaksProperty::GetType()
+{
+	return PP_LOCAL_BREAKS;
+}
+inline LwpBreaksOverride* LwpParaBreaksProperty::GetLocalParaBreaks()
+{
+	return m_pBreaks;
+}
+
+
+class LwpParaBulletProperty : public LwpParaProperty
+{
+public:
+	LwpParaBulletProperty(LwpObjectStream* pStrm);
+
+	virtual ~LwpParaBulletProperty();
+	
+	inline sal_uInt32 GetType();
+
+	inline LwpBulletOverride* GetLocalParaBullet();
+
+private:
+	LwpBulletOverride* m_pBullet;
+};
+
+inline sal_uInt32 LwpParaBulletProperty::GetType()
+{
+	return PP_LOCAL_BULLET;
+}
+inline LwpBulletOverride* LwpParaBulletProperty::GetLocalParaBullet()
+{
+	return m_pBullet;
+}
+
+
+class LwpParaNumberingProperty : public LwpParaProperty
+{
+public:
+	LwpParaNumberingProperty(LwpObjectStream* pStrm);
+
+	inline sal_uInt32 GetType();
+
+	inline LwpNumberingOverride* GetLocalNumbering() const;
+private:
+	LwpNumberingOverride* m_pNumberingOverride;
+};
+inline sal_uInt32 LwpParaNumberingProperty::GetType()
+{
+	return PP_LOCAL_NUMBERING;
+}
+inline LwpNumberingOverride* LwpParaNumberingProperty::GetLocalNumbering() const
+{
+	return m_pNumberingOverride;
+}
+//end add/////////////////////////////////////////////////////////////
+
+
+class LwpParaTabRackProperty : public LwpParaProperty
+{
+public:
+	LwpParaTabRackProperty(LwpObjectStream* pStrm);
+	~LwpParaTabRackProperty(void);
+	inline sal_uInt32 GetType();
+
+	inline LwpTabOverride* GetTab(); //should add by , note by  1/28
+	
+private:
+	LwpTabOverride* m_pTabOverride;
+};
+
+inline LwpTabOverride* LwpParaTabRackProperty::GetTab()
+{
+	return m_pTabOverride;
+}
+
+inline sal_uInt32 LwpParaTabRackProperty::GetType(void)
+{
+    return PP_LOCAL_TABRACK;
+}
+
+
+class LwpParaBackGroundProperty : public LwpParaProperty
+{
+public:
+	LwpParaBackGroundProperty(LwpObjectStream* pFile);
+	virtual ~LwpParaBackGroundProperty(void);
+	LwpBackgroundOverride* GetBackground(void);
+	sal_uInt32 GetType(void);
+private:
+	LwpBackgroundOverride* m_pBackground;
+};
+
+inline LwpBackgroundOverride* LwpParaBackGroundProperty::GetBackground(void)
+{
+	return m_pBackground;
+}
+
+inline sal_uInt32 LwpParaBackGroundProperty::GetType()
+{
+	return PP_LOCAL_BACKGROUND;
+}
+
+#endif
diff -urNp lotuswordpro.bak/source/filter/lwpparastyle.cxx lotuswordpro/source/filter/lwpparastyle.cxx
--- lotuswordpro.bak/source/filter/lwpparastyle.cxx	1970-01-01 08:00:00.000000000 +0800
+++ lotuswordpro/source/filter/lwpparastyle.cxx	2008-10-22 11:42:29.000000000 +0800
@@ -0,0 +1,795 @@
+/*************************************************************************
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: IBM Corporation
+ *
+ *  Copyright: 2008 by IBM Corporation
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+/*************************************************************************
+ * @file 
+ *  For LWP filter architecture prototype
+ ************************************************************************/
+/*************************************************************************
+ * Change History
+ Jan 2005			Created
+ ************************************************************************/
+
+
+#include "lwpparastyle.hxx"
+#include "lwpfilehdr.hxx"
+#include "lwpoverride.hxx"
+#include "lwpparaborderoverride.hxx"
+#include "lwpbreaksoverride.hxx"
+#include "lwpnumberingoverride.hxx"
+#include "lwptaboverride.hxx"
+#include "lwpbackgroundoverride.hxx"
+#include "xfilter/xfdefs.hxx"
+#include "xfilter/xfparastyle.hxx"
+#include "xfilter/xfborders.hxx"
+#include "lwpfont.hxx"
+#include "lwpfoundry.hxx"
+#include "lwppiece.hxx"
+#include "lwpshadow.hxx"
+#include "lwpborderstuff.hxx"
+#include "lwpmargins.hxx"
+#include "lwptabrack.hxx"
+
+#include "lwpsilverbullet.hxx"
+
+
+LwpParaStyle::LwpParaStyle(LwpObjectHeader& objHdr, LwpSvStream* pStrm) :
+LwpTextStyle(objHdr, pStrm), m_pKinsokuOptsOverride(new LwpKinsokuOptsOverride),
+m_pBulletOverride(new LwpBulletOverride)
+{
+}
+
+LwpParaStyle::~LwpParaStyle()
+{
+	if (m_pKinsokuOptsOverride)
+	{
+		delete m_pKinsokuOptsOverride;
+	}
+	
+	if (m_pBulletOverride)
+	{
+		delete m_pBulletOverride;
+	}
+}
+
+void LwpParaStyle::Read()
+{
+	LwpTextStyle::Read();
+
+	if (LwpFileHeader::m_nFileRevision < 0x000B)
+	{
+		// read many overrides
+		LwpAlignmentOverride	aAlignOverride;
+		aAlignOverride.Read(m_pObjStrm);
+
+		LwpSpacingOverride	aSpacingOverride;
+		aSpacingOverride.Read(m_pObjStrm);
+
+		LwpIndentOverride		aIndentOverride;
+		aIndentOverride.Read(m_pObjStrm);
+
+		LwpParaBorderOverride	aPBOverride;
+		aPBOverride.Read(m_pObjStrm);
+
+		LwpBreaksOverride	aBreaksOverride;
+		aBreaksOverride.Read(m_pObjStrm);
+
+		LwpNumberingOverride	aNumberingOverride;
+		aNumberingOverride.Read(m_pObjStrm);
+
+		LwpTabOverride		aTabOverride;
+		aTabOverride.Read(m_pObjStrm);
+		
+	}
+	else
+	{
+		m_AlignmentStyle.ReadIndexed(m_pObjStrm);
+		m_SpacingStyle.ReadIndexed(m_pObjStrm);
+		m_IndentStyle.ReadIndexed(m_pObjStrm);
+		m_BorderStyle.ReadIndexed(m_pObjStrm);
+		m_BreaksStyle.ReadIndexed(m_pObjStrm);
+		m_NumberingStyle.ReadIndexed(m_pObjStrm);
+		m_TabStyle.ReadIndexed(m_pObjStrm);
+	
+		m_pKinsokuOptsOverride->Read(m_pObjStrm);
+		m_pBulletOverride->Read(m_pObjStrm);
+
+		if (m_pObjStrm->CheckExtra())
+		{
+			m_BackgroundStyle.ReadIndexed(m_pObjStrm);
+			m_pObjStrm->SkipExtra(); 
+		}
+
+		
+	}
+}
+
+void	LwpParaStyle::Apply(XFParaStyle *pParaStyle)
+{
+	assert(pParaStyle);
+	LwpVirtualPiece	*pPiece = NULL;
+	//alignment:
+	pPiece = (LwpVirtualPiece*)m_AlignmentStyle.obj();
+	if( pPiece )
+	{
+		LwpAlignmentOverride	*pAlign = (LwpAlignmentOverride*)pPiece->GetOverride();
+		if( pAlign )
+                ApplyAlignment(pParaStyle,pAlign);
+	}
+
+	//don't known top and bottom indent now.
+	pPiece = (LwpVirtualPiece*)m_IndentStyle.obj();
+	if( pPiece )
+	{
+		LwpIndentOverride	*pIndent = (LwpIndentOverride*)pPiece->GetOverride();
+		if( pIndent )
+		{
+			if (!m_pBulletOverride->IsInValid())//Add by ,for remove bullet indent in named bullet style
+			{
+				LwpIndentOverride* pNewIndent = new LwpIndentOverride;
+                *pNewIndent = *pIndent;
+				pNewIndent->SetMFirst(0);
+				pNewIndent->SetMRest(0);
+				ApplyIndent(NULL,pParaStyle,pNewIndent);
+				delete pNewIndent;
+			}
+			else
+				ApplyIndent(NULL,pParaStyle,pIndent);
+		}
+	}
+	//shadow & borders.
+	pPiece = (LwpVirtualPiece*)m_BorderStyle.obj();
+	if( pPiece )
+	{
+		LwpParaBorderOverride *pBorder = (LwpParaBorderOverride*)pPiece->GetOverride();
+		if( pBorder )
+		{
+			this->ApplyParaBorder(pParaStyle, pBorder);
+		}
+	}
+
+    pPiece = (LwpVirtualPiece*)m_SpacingStyle.obj();
+    if (pPiece)
+    {
+        LwpSpacingOverride	*pSpacing = (LwpSpacingOverride*)pPiece->GetOverride();
+        if( pSpacing)
+            ApplySpacing(NULL,pParaStyle,pSpacing);        
+    }
+    
+	//paragraph background.
+	pPiece = (LwpVirtualPiece*)m_BackgroundStyle.obj();
+	if( pPiece )
+	{
+		LwpBackgroundOverride *pBack = (LwpBackgroundOverride*)pPiece->GetOverride();
+		if( pBack )
+		{
+			LwpColor color = pBack->GetBackColor();
+			XFColor aXFColor( color.To24Color() );
+			pParaStyle->SetBackColor( aXFColor );
+		}
+	}
+
+	// 01/28/2005
+	//add tab style
+	pPiece = (LwpVirtualPiece*)m_TabStyle.obj();
+	if( pPiece	)
+	{
+		LwpTabOverride *pTab=(LwpTabOverride*)pPiece->GetOverride();
+		if(pTab)
+		{
+			ApplyTab(pParaStyle,pTab);
+		}		
+	}
+	//add by  2005/02/16
+	pPiece = (LwpVirtualPiece*)m_BreaksStyle.obj();
+	if( pPiece	)
+	{
+		LwpBreaksOverride *pBreak=(LwpBreaksOverride*)pPiece->GetOverride();
+		if(pBreak)
+		{
+			ApplyBreaks(pParaStyle,pBreak);
+		}		
+	}
+	//add end
+}
+
+void LwpParaStyle::ApplySubBorder(LwpBorderStuff* pBorderStuff, LwpBorderStuff::BorderType eType, XFBorders* pXFBorders)
+{
+	enumXFBorder eXFBorderSide = enumXFBorderNone;
+	switch (eType)
+	{
+	case LwpBorderStuff::LEFT:
+		eXFBorderSide = enumXFBorderLeft;
+		break;
+	case LwpBorderStuff::RIGHT:
+		eXFBorderSide = enumXFBorderRight;
+		break;
+	case LwpBorderStuff::TOP:
+		eXFBorderSide = enumXFBorderTop;
+		break;
+	case LwpBorderStuff::BOTTOM:
+		eXFBorderSide = enumXFBorderBottom;
+		break;
+	}
+	
+	LwpColor	aColor = pBorderStuff->GetSideColor(eType);
+	float		fWidth = pBorderStuff->GetSideWidth(eType);
+	sal_uInt16	nType = pBorderStuff->GetSideType(eType);
+
+	switch (nType)
+	{
+	default://fall through!
+	case 0x14: //single fall through!
+	case 0x17: //treble
+		pXFBorders->SetWidth(eXFBorderSide, fWidth);
+		break;
+	case 0x15: //double , fall through!
+	case 0x16: //thick double
+		pXFBorders->SetDoubleLine(eXFBorderSide, sal_True, sal_False);
+		pXFBorders->SetWidthOutter(eXFBorderSide, static_cast<float>(fWidth*0.333));
+		pXFBorders->SetWidthSpace(eXFBorderSide, static_cast<float>(fWidth*0.334));
+		pXFBorders->SetWidthInner(eXFBorderSide, static_cast<float>(fWidth*0.333));
+//		pXFBorders->SetWidth(eXFBorderSide, fWidth);
+		break;
+	case 0x18: //thick-thin
+		pXFBorders->SetDoubleLine(eXFBorderSide, sal_True, sal_False);
+		pXFBorders->SetWidthOutter(eXFBorderSide, static_cast<float>(fWidth*0.5));
+		pXFBorders->SetWidthInner(eXFBorderSide, static_cast<float>(fWidth*0.25));
+		pXFBorders->SetWidthSpace(eXFBorderSide, static_cast<float>(fWidth*0.25));
+		break;
+	case 0x19: //thin-thick
+		pXFBorders->SetDoubleLine(eXFBorderSide, sal_True, sal_False);
+		pXFBorders->SetWidthInner(eXFBorderSide, static_cast<float>(fWidth*0.7));
+		pXFBorders->SetWidthOutter(eXFBorderSide, static_cast<float>(fWidth*0.15));
+		pXFBorders->SetWidthSpace(eXFBorderSide, static_cast<float>(fWidth*0.15));
+		break;
+	}
+
+	if (aColor.IsValidColor())
+	{
+		XFColor aXFColor(aColor.To24Color());
+		pXFBorders->SetColor(eXFBorderSide, aXFColor );
+	}
+}
+
+void LwpParaStyle::ApplyParaBorder(XFParaStyle* pParaStyle, LwpParaBorderOverride* pBorder)
+{
+	//convert LwpShadow:
+	LwpShadow *pShadow = pBorder->GetShadow();
+	if( pShadow )
+	{
+		LwpColor color = pShadow->GetColor();
+		float	offsetX = pShadow->GetOffsetX();
+		float	offsetY = pShadow->GetOffsetY();
+
+		if( offsetX && offsetY && color.IsValidColor() )
+		{
+			XFColor aXFColor(color.To24Color());
+			sal_Bool left = sal_False;
+			sal_Bool top = sal_False;
+			if( offsetX < 0 )
+				left = sal_True;
+			if( offsetY < 0 )
+				top = sal_True;
+			if( left )
+			{
+				if( top )
+					pParaStyle->SetShadow(enumXFShadowLeftTop,-offsetX,aXFColor);
+				else
+					pParaStyle->SetShadow(enumXFShadowLeftBottom,-offsetX,aXFColor);
+			}
+			else
+			{
+				if( top )
+					pParaStyle->SetShadow(enumXFShadowRightTop,offsetX,aXFColor);
+				else
+					pParaStyle->SetShadow(enumXFShadowRightBottom,offsetX,aXFColor);
+			}
+		}
+	}
+	
+	//convert to XFBorders obejct:
+	LwpBorderStuff	*pBorderStuff = pBorder->GetBorderStuff();
+	if( pBorderStuff && pBorderStuff->GetSide() != 0 )
+	{			
+		XFBorders	*pXFBorders = new XFBorders();
+		pParaStyle->SetBorders(pXFBorders);
+
+		LwpMargins* pMargins = pBorder->GetMargins();
+		
+		// apply 4 borders respectively
+		LwpBorderStuff::BorderType pType[] = { LwpBorderStuff::LEFT, LwpBorderStuff::RIGHT,
+			LwpBorderStuff::TOP, LwpBorderStuff::BOTTOM };
+		float pMarginValue[4];
+		
+		for (sal_uInt8 nC = 0; nC < 4; nC++)
+		{
+			if (pBorderStuff->HasSide(pType[nC]))
+			{
+				this->ApplySubBorder(pBorderStuff, pType[nC], pXFBorders);
+
+				//get border spacing to text content
+				if (pMargins)
+				{
+					pMarginValue[nC] = static_cast<float>(pMargins->GetMarginsValue(nC));
+				}
+			}
+
+		}
+
+		//apply border spacing to text content
+		pParaStyle->SetPadding(pMarginValue[0], pMarginValue[1], pMarginValue[2], pMarginValue[3]);
+		
+	}
+}
+
+void LwpParaStyle::ApplyBreaks(XFParaStyle* pParaStyle, LwpBreaksOverride* pBreaks)
+{
+	if (pBreaks->IsKeepWithNext())
+	{
+		pParaStyle->SetBreaks(enumXFBreakKeepWithNext);
+	}
+	if (pBreaks->IsPageBreakBefore())
+	{
+		pParaStyle->SetBreaks(enumXFBreakBefPage);
+	}
+	if (pBreaks->IsPageBreakAfter())
+	{
+		pParaStyle->SetBreaks(enumXFBreakAftPage);
+	}
+	if (pBreaks->IsColumnBreakBefore())
+	{
+		pParaStyle->SetBreaks(enumXFBreakBefColumn);
+	}
+	if (pBreaks->IsColumnBreakAfter())
+	{
+		pParaStyle->SetBreaks(enumXFBreakAftColumn);
+	}
+}
+
+void LwpParaStyle::ApplyAlignment(XFParaStyle* pParaStyle, LwpAlignmentOverride* pAlign)
+{
+    enumXFAlignType alignType = enumXFAlignStart;
+    LwpAlignmentOverride::AlignType type;
+        
+	type = pAlign->GetAlignType();
+	pParaStyle->SetNumberRight(sal_False);//to identify its align attribute
+	switch(type)
+	{
+	case LwpAlignmentOverride::ALIGN_LEFT:
+		alignType = enumXFAlignStart;
+		break;
+	case LwpAlignmentOverride::ALIGN_RIGHT:
+		alignType = enumXFAlignEnd;
+		break;
+	case LwpAlignmentOverride::ALIGN_CENTER:
+		alignType = enumXFAlignCenter;
+		break;
+	case LwpAlignmentOverride::ALIGN_NUMERICLEFT://if non-number in table,ALIGN_NUMERICLEFT/RIGHT are useless
+		alignType = enumXFAlignStart;            //note by  1/28
+		break;
+	case LwpAlignmentOverride::ALIGN_JUSTIFY:
+	case LwpAlignmentOverride::ALIGN_JUSTIFYALL:
+		alignType = enumXFAlignJustify;	    
+		break;
+	case LwpAlignmentOverride::ALIGN_NUMERICRIGHT:
+		pParaStyle->SetNumberRight(sal_True);//to identify its align attribute
+		alignType = enumXFAlignEnd;	
+		break;
+	}
+	pParaStyle->SetAlignType(alignType);    
+}
+
+void LwpParaStyle::ApplyIndent(LwpPara* pPara, XFParaStyle* pParaStyle, LwpIndentOverride* pIndent)
+{
+	LwpPara* pParentPara;
+	if (pPara)
+		pParentPara = pPara->GetParent();
+	else
+		pParentPara = NULL;
+		
+	LwpIndentOverride* pTotalIndent = new LwpIndentOverride;		
+	if (pIndent->IsUseRelative() && pParentPara)
+	{
+		LwpIndentOverride* pParentIndent = pParentPara->GetIndent();
+		if (!pParentIndent)
+			return;
+		*pTotalIndent = *pIndent;
+	
+		//add by ,for bullet only
+		if (pPara)
+		{
+			if (pPara->GetBulletFlag())
+			{	
+				pTotalIndent->SetMAll(pParentIndent->GetMAll() + pTotalIndent->GetMAll());
+				pTotalIndent->SetMRight(pParentIndent->GetMRight()+ pTotalIndent->GetMRight());				
+				pParaStyle->SetMargins(LwpTools::ConvertToMetric(LwpTools::ConvertFromUnits(
+					pTotalIndent->GetMAll())), pTotalIndent->GetRight());
+				pPara->SetIndent(pTotalIndent);					
+				return;
+			}
+		}
+		//end add
+		sal_uInt16 relative = pParentIndent->GetRelative();
+		
+		sal_Int32 Amount = pParentIndent->GetMAll();
+		
+		if (relative == LwpIndentOverride::RELATIVE_FIRST)
+			Amount += pParentIndent->GetMFirst();
+		else if (relative == LwpIndentOverride::RELATIVE_REST)
+			Amount += pParentIndent->GetMRest();
+		pTotalIndent->SetMAll(Amount + pTotalIndent->GetMAll());
+		pTotalIndent->SetMRight(pParentIndent->GetMRight()+ pTotalIndent->GetMRight());
+		
+		pParaStyle->SetIndent(pTotalIndent->GetFirst());
+		pParaStyle->SetMargins(pTotalIndent->GetLeft(), pTotalIndent->GetRight());	
+		pPara->SetIndent(pTotalIndent);	
+
+	}
+	else
+	{
+		*pTotalIndent = *pIndent;	
+		//add by 
+		if (pPara)
+		{
+			if (pPara->GetBulletFlag())
+			{
+//				pParaStyle->SetIndent(LwpTools::ConvertFromUnits(pIndent->GetMAll()));
+				pParaStyle->SetMargins(LwpTools::ConvertToMetric(
+					LwpTools::ConvertFromUnits(pIndent->GetMAll())), pIndent->GetRight());
+				pPara->SetIndent(pTotalIndent);
+				return;			
+			}
+		}
+		//end add
+
+		pParaStyle->SetIndent(pIndent->GetFirst());
+		pParaStyle->SetMargins(pIndent->GetLeft(), pIndent->GetRight());
+		if (pPara)
+		{
+			pPara->SetIndent(pTotalIndent);
+		}
+	}    
+}
+
+void LwpParaStyle::ApplySpacing(LwpPara* pPara, XFParaStyle* pParaStyle, LwpSpacingOverride* pSpacing)
+{
+    LwpSpacingCommonOverride* spacing = pSpacing->GetSpacing();
+    LwpSpacingCommonOverride* aboveline = pSpacing->GetAboveLineSpacing();
+    LwpSpacingCommonOverride* abovepara = pSpacing->GetAboveSpacing();
+    LwpSpacingCommonOverride* belowpara = pSpacing->GetBelowSpacing();         
+    
+    LwpSpacingCommonOverride::SpacingType type = spacing->GetType();
+    sal_Int32 amount = spacing->GetAmount();
+    sal_Int32 multiple = spacing->GetMultiple();
+    enumLHType xftype;
+    double height;
+  
+    switch(type)
+    {
+    case LwpSpacingCommonOverride::SPACING_DYNAMIC:
+    {
+	xftype = enumLHPercent;
+	height = double(multiple)/65536L*100;
+	pParaStyle->SetLineHeight(xftype,height);  
+    }
+        break;
+    case LwpSpacingCommonOverride::SPACING_LEADING:
+    {
+	xftype = enumLHSpace;
+	height = LwpTools::ConvertToMetric(LwpTools::ConvertFromUnits(amount));
+	pParaStyle->SetLineHeight(xftype,height);  
+    }
+        break;
+    case LwpSpacingCommonOverride::SPACING_CUSTOM:
+    {
+	xftype = enumLHHeight;
+	height =  LwpTools::ConvertToMetric(LwpTools::ConvertFromUnits(sal_Int32(float(multiple)/65536L*amount)));
+    	pParaStyle->SetLineHeight(xftype,height);  
+	}
+        break;
+    case LwpSpacingCommonOverride::SPACING_NONE:
+        break; 
+    }
+      
+//TO DO: Above Line need to be processed!!!!!!! what it means??????  1-26    
+    
+    type = abovepara->GetType();
+    amount = abovepara->GetAmount();
+    multiple = abovepara->GetMultiple();
+    double above_val =-1;
+    switch(type)
+    {
+    case LwpSpacingCommonOverride::SPACING_DYNAMIC:
+//        above_val = LINE_HEIGHT*float(multiple)/65536L*100; //TO DO:  1-26 
+        break;
+    case LwpSpacingCommonOverride::SPACING_LEADING:
+        break;
+    case LwpSpacingCommonOverride::SPACING_CUSTOM:
+        above_val =  LwpTools::ConvertToMetric(LwpTools::ConvertFromUnits(sal_Int32(float(multiple)/65536L*amount)));
+        break;
+    case LwpSpacingCommonOverride::SPACING_NONE:
+        break; 
+    }
+        
+    type = belowpara->GetType();
+    amount = belowpara->GetAmount();
+    multiple = belowpara->GetMultiple();    
+    double below_val=-1; 
+    switch(type)
+    {
+    case LwpSpacingCommonOverride::SPACING_DYNAMIC:
+//        below_val = LINE_HEIGHT*float(multiple)/65536L*100;//TO DO:  1-26 
+        break;
+    case LwpSpacingCommonOverride::SPACING_LEADING:
+        break;
+    case LwpSpacingCommonOverride::SPACING_CUSTOM:
+        below_val =  LwpTools::ConvertToMetric(LwpTools::ConvertFromUnits(sal_Int32(float(multiple)/65536L*amount)));
+        break;
+    case LwpSpacingCommonOverride::SPACING_NONE:
+        break; 
+    }
+  
+    if (pPara)
+    {
+    	if (below_val != -1)
+    		pPara->SetBelowSpacing(below_val);
+    	LwpPara* pPrePara = static_cast<LwpPara*>(pPara->GetPrevious()->obj());
+    	if (pPrePara && above_val != -1)
+    	{
+    		above_val += pPrePara->GetBelowSpacing();
+    		
+    	}
+    	
+    }
+    pParaStyle->SetMargins(-1,-1,above_val,below_val);    
+}
+/**************************************************************************
+ * @short:   
+ * @descr:  
+ * @param:   
+ * @param:   
+ * @return:  
+**************************************************************************/
+void LwpParaStyle::ApplyTab(XFParaStyle *pParaStyle, LwpTabOverride *pTab)
+{
+	LwpObjectID* pTabRackID = pTab->GetTabRackID();
+	if(pTabRackID->IsNull())
+	{
+		//assert(false);
+		return;
+	}
+
+	LwpTabRack* pTabRack = static_cast<LwpTabRack*>(pTabRackID->obj());
+	if(!pTabRack)
+	{
+		//assert(false);
+		return;
+	}
+	
+	pParaStyle->ClearTabStyles();
+	//Get margin left value
+	double dMarginLeft = pParaStyle->GetMargins().GetLeft();
+	
+	sal_uInt16 nNumTabs = pTabRack->GetNumTabs();
+	for(sal_uInt16 nIndex=0; nIndex<nNumTabs; nIndex++)
+	{
+		//get tab type
+		LwpTab* pTab = pTabRack->Lookup(nIndex);
+		if(!pTab)
+			return;
+
+		enumXFTab eType;
+		LwpTab::TabType type = pTab->GetTabType();
+		switch(type)
+		{
+		case LwpTab::TT_LEFT:
+			eType = enumXFTabLeft;
+			break;
+		case LwpTab::TT_CENTER:
+			eType = enumXFTabCenter;
+			break;
+		case LwpTab::TT_RIGHT:
+			eType = enumXFTabRight;
+			break;
+		case LwpTab::TT_NUMERIC:
+			eType = enumXFTabChar;
+			break;
+		}
+		
+		//get position
+		sal_uInt32 nPos = pTab->GetPosition();
+		//different feature between SODC and lwp, the tab length must minus the margin left of para.
+		double fLen = LwpTools::ConvertFromUnitsToMetric(nPos) - dMarginLeft;
+		
+		//get leader type
+		sal_Unicode cLeader;
+		LwpTab::LeaderType leader= pTab->GetLeaderType();
+		switch(leader)
+		{
+		case LwpTab::TL_NONE:
+			cLeader = 0x20;		//space
+			break;
+		case LwpTab::TL_HYPHEN:	//'-'
+			cLeader = 0xAD;		
+			break;
+		case LwpTab::TL_DOT:	//'.'
+			cLeader = 0x2E;
+			break;
+		case LwpTab::TL_LINE:	//'_'
+			cLeader = 0x5F;
+			break;
+		}
+
+		sal_Unicode cAlignChar = static_cast<sal_Unicode>(pTab->GetAlignChar());		
+
+		pParaStyle->AddTabStyle(eType,fLen,cLeader,cAlignChar);	
+	}
+	
+}
+
+
+void LwpParaStyle::RegisterStyle()
+{
+	XFParaStyle* pStyle = new XFParaStyle();
+
+	//Set name
+	OUString styleName = GetName()->str();
+	pStyle->SetStyleName(styleName);
+	
+	//Create font
+	LwpFontManager* pFontMgr = m_pFoundry->GetFontManger();
+	XFFont* pFont = pFontMgr->CreateFont(m_nFinalFontID);
+	pStyle->SetFont(pFont);
+	
+	//Set other paragraph properties...
+
+	Apply(pStyle);
+	//Add style
+	LwpStyleManager* pStyleMgr = m_pFoundry->GetStyleManager();
+	pStyleMgr->AddStyle(*GetObjectID(), pStyle);
+
+/*	// add list style for bullet
+	if (!m_pBulletOverride)
+	{
+		return;
+	}
+	LwpSilverBullet* pSilverBullet = static_cast<LwpSilverBullet*>(m_pBulletOverride->GetSilverBullet().obj());
+	if (!pSilverBullet)
+	{
+		return;
+	}
+
+	pSilverBullet->SetFoundry(m_pFoundry);
+	pSilverBullet->RegisterStyle();*/
+}
+
+LwpAlignmentOverride* LwpParaStyle::GetAlignment()
+{
+    if (m_AlignmentStyle.obj()!= NULL)
+        return static_cast<LwpAlignmentOverride*>(static_cast<LwpAlignmentPiece*>(m_AlignmentStyle.obj())->GetOverride());
+    else
+        return NULL;
+}
+
+LwpIndentOverride* LwpParaStyle::GetIndent()
+{
+    if (m_IndentStyle.obj() != NULL)
+        return static_cast<LwpIndentOverride*>(static_cast<LwpIndentPiece*>(m_IndentStyle.obj())->GetOverride());
+    else
+        return NULL;
+}
+
+LwpSpacingOverride* LwpParaStyle::GetSpacing()
+{
+    if (m_SpacingStyle.obj() != NULL)
+        return static_cast<LwpSpacingOverride*>(static_cast<LwpSpacingPiece*>(m_SpacingStyle.obj())->GetOverride());
+    else
+        return NULL;
+}
+
+LwpParaBorderOverride* LwpParaStyle::GetParaBorder() const
+{
+	if(m_BorderStyle.IsNull()) return NULL;
+	return static_cast<LwpParaBorderOverride*>
+		(static_cast<LwpParaBorderPiece*>(m_BorderStyle.obj(VO_PARABORDERPIECE))->GetOverride());
+}
+
+LwpBreaksOverride* LwpParaStyle::GetBreaks() const
+{
+	if(m_BreaksStyle.IsNull()) return NULL;
+	return static_cast<LwpBreaksOverride*>
+		(static_cast<LwpBreaksPiece*>(m_BreaksStyle.obj(VO_BREAKSPIECE))->GetOverride());
+}
+
+LwpBulletOverride* LwpParaStyle::GetBulletOverride() const
+{
+	return m_pBulletOverride;
+}
+
+LwpNumberingOverride* LwpParaStyle::GetNumberingOverride() const
+{
+	if(m_NumberingStyle.IsNull()) return NULL;
+	return static_cast<LwpNumberingOverride*>
+		(static_cast<LwpNumberingPiece*>(m_NumberingStyle.obj(VO_NUMBERINGPIECE))->GetOverride());
+}
+
+
+/**************************************************************************
+ * @short:   
+ * @descr:  
+ * @param:   
+ * @param:   
+ * @return:  
+**************************************************************************/
+LwpTabOverride* LwpParaStyle::GetTabOverride() const
+{
+	if(m_TabStyle.obj() != NULL)
+		return (LwpTabOverride*)static_cast<LwpTabPiece*>(m_TabStyle.obj())->GetOverride();
+	else
+		return NULL;
+}
+
+sal_Bool LwpParaStyle::IsNumberRight()
+{
+	LwpAlignmentOverride* pAlign = GetAlignment();
+	if (pAlign)
+	{
+		LwpAlignmentOverride::AlignType type; 
+		type = pAlign->GetAlignType();
+		if (type == LwpAlignmentOverride::ALIGN_NUMERICRIGHT)
+			return sal_True;	
+	}
+	return sal_False;
+}
\ No newline at end of file
diff -urNp lotuswordpro.bak/source/filter/lwpparastyle.hxx lotuswordpro/source/filter/lwpparastyle.hxx
--- lotuswordpro.bak/source/filter/lwpparastyle.hxx	1970-01-01 08:00:00.000000000 +0800
+++ lotuswordpro/source/filter/lwpparastyle.hxx	2008-10-22 11:42:29.000000000 +0800
@@ -0,0 +1,130 @@
+/*************************************************************************
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: IBM Corporation
+ *
+ *  Copyright: 2008 by IBM Corporation
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+/*************************************************************************
+ * @file 
+ *  For LWP filter architecture prototype
+ ************************************************************************/
+/*************************************************************************
+ * Change History
+ Jan 2005			Created
+ ************************************************************************/
+
+#ifndef _LWPPARASTYLE_HXX
+#define _LWPPARASTYLE_HXX
+
+#include "lwpcharacterstyle.hxx"
+#include "lwppiece.hxx"
+#include "lwpborderstuff.hxx"
+#include "lwppara.hxx"
+
+class LwpKinsokuOptsOverride;
+class LwpBulletOverride;
+class XFParaStyle;
+class XFBorders;
+
+class LwpParaStyle : public LwpTextStyle
+{
+public:
+	LwpParaStyle(LwpObjectHeader& objHdr, LwpSvStream* pStrm);
+	
+	virtual ~LwpParaStyle();
+	
+	void Read();
+	
+	virtual void	Apply(XFParaStyle *pStrm);
+	// 01/26/2005
+	void ApplyParaBorder(XFParaStyle* pParaStyle, LwpParaBorderOverride* pBorder);
+	void ApplyBreaks(XFParaStyle* pParaStyle, LwpBreaksOverride* pBreaks);
+	//end
+	static void ApplyAlignment(XFParaStyle* pParaStyle, LwpAlignmentOverride* pAlign);
+	static void ApplyIndent(LwpPara* pPara, XFParaStyle* pParaStyle, LwpIndentOverride* pIndent);
+	static void ApplySpacing(LwpPara* pPara, XFParaStyle* pParaStyle, LwpSpacingOverride* pSpacing);
+
+	// 2005/01/28
+	static void ApplyTab(XFParaStyle* pParaStyle, LwpTabOverride* pTab);
+
+	void RegisterStyle();
+	
+	LwpAlignmentOverride* GetAlignment();//add by  1-24
+	LwpIndentOverride* GetIndent();
+ 	LwpSpacingOverride* GetSpacing();
+	LwpParaBorderOverride* GetParaBorder() const;
+	LwpBreaksOverride* GetBreaks() const;
+	LwpTabOverride* GetTabOverride() const;
+	LwpBulletOverride* GetBulletOverride() const;
+	LwpNumberingOverride* GetNumberingOverride() const;
+	
+	sal_Bool IsNumberRight();
+public:
+	//add by , 01/27/2004
+	static void ApplySubBorder(LwpBorderStuff* pBorderStuff, LwpBorderStuff::BorderType eType, XFBorders* pXFBorders);
+	//end
+	
+private:
+	//style IDs
+	LwpObjectID	m_AlignmentStyle;
+	LwpObjectID	m_SpacingStyle;
+	LwpObjectID	m_IndentStyle;
+	LwpObjectID	m_BorderStyle;
+	LwpObjectID	m_BreaksStyle;
+	LwpObjectID	m_NumberingStyle;
+	LwpObjectID	m_TabStyle;
+	LwpObjectID	m_BackgroundStyle;
+
+	LwpKinsokuOptsOverride*	m_pKinsokuOptsOverride;
+	LwpBulletOverride*		m_pBulletOverride;
+};
+
+#endif
diff -urNp lotuswordpro.bak/source/filter/lwppiece.hxx lotuswordpro/source/filter/lwppiece.hxx
--- lotuswordpro.bak/source/filter/lwppiece.hxx	1970-01-01 08:00:00.000000000 +0800
+++ lotuswordpro/source/filter/lwppiece.hxx	2008-10-22 11:42:29.000000000 +0800
@@ -0,0 +1,202 @@
+/*************************************************************************
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: IBM Corporation
+ *
+ *  Copyright: 2008 by IBM Corporation
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+/*************************************************************************
+ * @file 
+ *  For LWP filter architecture prototype
+ ************************************************************************/
+/*************************************************************************
+ * Change History
+ Jan 2005		Created
+ ************************************************************************/
+ 
+#ifndef		_LWPPIECE_HXX
+#define		_LWPPIECE_HXX
+
+#include	"lwpobj.hxx"
+#include	"lwpoverride.hxx"
+#include	"lwpobjstrm.hxx"
+#include	"lwpdlvlist.hxx"
+#include	"lwpbreaksoverride.hxx"
+#include	"lwpparaborderoverride.hxx"
+#include	"lwpnumberingoverride.hxx"
+#include	"lwpcharborderoverride.hxx"
+#include	"lwpbackgroundoverride.hxx"
+#include	"lwptaboverride.hxx"
+
+class LwpOverride;
+class LwpDLVList;
+
+class LwpVirtualPiece : public LwpDLVList
+{
+public:
+	LwpVirtualPiece(LwpObjectHeader& objHdr, LwpSvStream* pStrm):LwpDLVList(objHdr, pStrm)
+	{
+		m_pOverride = NULL;
+	}
+
+	virtual ~LwpVirtualPiece()
+	{
+		if( m_pOverride )
+			delete m_pOverride;
+	}
+
+	virtual void Read()
+	{
+		LwpDLVList::Read();
+		if( m_pOverride )
+			m_pOverride->Read(m_pObjStrm);
+	}
+
+	LwpOverride* GetOverride()
+	{
+		return m_pOverride;
+	}
+protected:
+	LwpOverride		*m_pOverride;
+};
+
+
+class LwpParaBorderPiece : public LwpVirtualPiece
+{
+public:
+	LwpParaBorderPiece(LwpObjectHeader& objHdr, LwpSvStream* pStrm):LwpVirtualPiece(objHdr, pStrm)
+	{
+		m_pOverride = new LwpParaBorderOverride();
+	}
+};
+
+class LwpBreaksPiece : public LwpVirtualPiece
+{
+public:
+	LwpBreaksPiece(LwpObjectHeader& objHdr, LwpSvStream* pStrm):LwpVirtualPiece(objHdr, pStrm)
+	{
+		m_pOverride = new LwpBreaksOverride();
+	}
+};
+
+class LwpNumberingPiece : public LwpVirtualPiece
+{
+public:
+	LwpNumberingPiece(LwpObjectHeader& objHdr, LwpSvStream* pStrm):LwpVirtualPiece(objHdr, pStrm)
+	{
+		m_pOverride = new LwpNumberingOverride();
+	}
+};
+
+class LwpTabPiece : public LwpVirtualPiece
+{
+public:
+	LwpTabPiece(LwpObjectHeader& objHdr, LwpSvStream* pStrm):LwpVirtualPiece(objHdr, pStrm)
+	{
+		m_pOverride = new LwpTabOverride();
+	}
+};
+
+
+class LwpBackgroundPiece : public LwpVirtualPiece
+{
+public:
+	LwpBackgroundPiece(LwpObjectHeader& objHdr, LwpSvStream* pStrm):LwpVirtualPiece(objHdr, pStrm)
+	{
+		m_pOverride = new LwpBackgroundOverride();
+	}
+};
+
+class LwpAlignmentPiece : public LwpVirtualPiece
+{
+public:
+	LwpAlignmentPiece(LwpObjectHeader& objHdr, LwpSvStream* pStrm):LwpVirtualPiece(objHdr, pStrm)
+	{
+		m_pOverride = new LwpAlignmentOverride();
+	}
+};
+
+class LwpIndentPiece : public LwpVirtualPiece
+{
+public:
+	LwpIndentPiece(LwpObjectHeader& objHdr, LwpSvStream* pStrm):LwpVirtualPiece(objHdr, pStrm)
+	{
+		m_pOverride = new LwpIndentOverride();
+	}
+};
+
+class LwpSpacingPiece : public LwpVirtualPiece
+{
+public:
+	LwpSpacingPiece(LwpObjectHeader& objHdr, LwpSvStream* pStrm):LwpVirtualPiece(objHdr, pStrm)
+	{
+		m_pOverride = new LwpSpacingOverride();
+	}
+};
+
+class LwpAmikakePiece : public LwpVirtualPiece
+{
+public:
+	LwpAmikakePiece(LwpObjectHeader& objHdr, LwpSvStream* pStrm):LwpVirtualPiece(objHdr, pStrm)
+	{
+		m_pOverride = new LwpAmikakeOverride();
+	}
+};
+
+class LwpCharacterBorderPiece : public LwpVirtualPiece
+{
+public:
+	LwpCharacterBorderPiece(LwpObjectHeader& objHdr, LwpSvStream* pStrm):LwpVirtualPiece(objHdr, pStrm)
+	{
+		m_pOverride = new LwpCharacterBorderOverride();
+	}
+};
+
+#endif
\ No newline at end of file
diff -urNp lotuswordpro.bak/source/filter/lwpproplist.cxx lotuswordpro/source/filter/lwpproplist.cxx
--- lotuswordpro.bak/source/filter/lwpproplist.cxx	1970-01-01 08:00:00.000000000 +0800
+++ lotuswordpro/source/filter/lwpproplist.cxx	2008-10-22 11:42:29.000000000 +0800
@@ -0,0 +1,151 @@
+/*************************************************************************
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: IBM Corporation
+ *
+ *  Copyright: 2008 by IBM Corporation
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+/*************************************************************************
+ * @file 
+ *  For LWP filter architecture prototype
+ ************************************************************************/
+/*************************************************************************
+ * Change History
+ Mar 2005			Created
+ ************************************************************************/
+
+#include "lwpproplist.hxx"
+
+LwpPropListElement::LwpPropListElement(LwpObjectHeader &objHdr, LwpSvStream *pStrm)
+:LwpDLVList(objHdr,pStrm)
+{
+}
+
+LwpPropListElement* LwpPropListElement::GetNext()
+{
+	return static_cast<LwpPropListElement*>(LwpDLVList::GetNext()->obj());
+}
+
+void LwpPropListElement::Read()
+{
+	LwpDLVList::Read();
+	m_Name.Read(m_pObjStrm);
+	m_Value.Read(m_pObjStrm);
+	m_pObjStrm->SkipExtra();
+}
+
+sal_Bool LwpPropListElement::IsNamed(OUString name)
+{
+	return name.equals(m_Name.str());
+}
+
+OUString LwpPropList::GetNamedProperty(OUString name)
+{
+	LwpPropListElement* pProp = FindPropByName(name);
+	if (pProp)
+	{
+		return pProp->GetValue().str();
+	}
+	return OUString(A2OUSTR(""));
+}
+	
+LwpPropListElement* LwpPropList::FindPropByName(OUString name)
+{
+	LwpPropListElement* pElement = GetFirst();
+
+	while(pElement)
+	{
+		if (pElement->IsNamed(name))
+			return pElement;
+		pElement = pElement->GetNext();
+	}
+	return NULL;
+}
+
+void LwpPropList::Read(LwpObjectStream* pObjStrm)
+{
+	LwpDLVListHead::Read(pObjStrm);
+}
+
+LwpPropListElement* LwpPropList::GetFirst()
+{
+	return static_cast<LwpPropListElement*>(LwpDLVListHead::GetFirst()->obj());
+}
+
+OUString LwpPropList::EnumNamedProperty(OUString& name,OUString& value)
+{
+	LwpPropListElement* pElement;
+	if (name.getLength()==0)
+	{
+		pElement = GetFirst();
+		if (pElement)
+		{
+			value = pElement->GetValue().str();
+			name  = pElement->GetName().str();
+			pElement = pElement->GetNext();
+			return  pElement->GetName().str();		
+		}
+		else
+			return A2OUSTR("");
+		
+	}
+	else
+	{
+		pElement = FindPropByName(name);
+		if (pElement)
+		{
+			value = pElement->GetValue().str();
+			pElement = pElement->GetNext();
+			if(pElement)
+				return  pElement->GetName().str();
+		}
+		return A2OUSTR("");
+	}
+}
diff -urNp lotuswordpro.bak/source/filter/lwpproplist.hxx lotuswordpro/source/filter/lwpproplist.hxx
--- lotuswordpro.bak/source/filter/lwpproplist.hxx	1970-01-01 08:00:00.000000000 +0800
+++ lotuswordpro/source/filter/lwpproplist.hxx	2008-10-22 11:42:29.000000000 +0800
@@ -0,0 +1,99 @@
+/*************************************************************************
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: IBM Corporation
+ *
+ *  Copyright: 2008 by IBM Corporation
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+/*************************************************************************
+ * @file 
+ *  For LWP filter architecture prototype
+ ************************************************************************/
+/*************************************************************************
+ * Change History
+ Mar 2005			Created
+ ************************************************************************/
+
+#ifndef _LWPPROPLIST_HXX_
+#define _LWPPROPLIST_HXX_
+
+#include "lwpobj.hxx"
+#include "lwpdlvlist.hxx"
+#include "lwpatomholder.hxx"
+
+class LwpPropListElement : public LwpDLVList
+{
+public:
+	LwpPropListElement(LwpObjectHeader &objHdr, LwpSvStream *pStrm);
+	~LwpPropListElement(){};
+	void Read();
+	sal_Bool IsNamed(OUString name);
+	LwpPropListElement* GetNext();
+	LwpAtomHolder GetValue(){return m_Value;}
+	LwpAtomHolder GetName(){return m_Name;}
+private:
+	LwpAtomHolder m_Name;
+	LwpAtomHolder m_Value;
+};
+
+class LwpPropList : public LwpDLVListHead
+{
+public:
+	LwpPropList(){};
+	~LwpPropList(){};
+	void Read(LwpObjectStream* pObjStrm);
+	LwpPropListElement* GetFirst();
+	OUString GetNamedProperty(OUString name);
+	OUString EnumNamedProperty(OUString& name,OUString& value);
+private:
+	LwpPropListElement* FindPropByName(OUString name);
+};
+
+#endif
diff -urNp lotuswordpro.bak/source/filter/lwpprtinfo.cxx lotuswordpro/source/filter/lwpprtinfo.cxx
--- lotuswordpro.bak/source/filter/lwpprtinfo.cxx	1970-01-01 08:00:00.000000000 +0800
+++ lotuswordpro/source/filter/lwpprtinfo.cxx	2008-10-22 11:42:29.000000000 +0800
@@ -0,0 +1,105 @@
+/*************************************************************************
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: IBM Corporation
+ *
+ *  Copyright: 2008 by IBM Corporation
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+#include "lwpprtinfo.hxx"
+
+LwpPrinterInfo::LwpPrinterInfo(LwpObjectStream* pStrm)
+{
+	Read(pStrm);
+}
+/**
+ * @descr  read printer info in VO_DOCUMENT
+  */
+void LwpPrinterInfo::Read(LwpObjectStream* pStrm)
+{
+	//Just skip now
+	Skip(pStrm);
+}
+/**
+ * @descr  skip printer info in VO_DOCUMENT
+  */
+void LwpPrinterInfo::Skip(LwpObjectStream *pStrm)
+{
+	sal_uInt16 platform;
+	pStrm->QuickRead(&platform, sizeof(platform));
+
+	//Skip the size and the buffer
+	sal_uInt32 size;
+	pStrm->QuickRead(&size, sizeof(size));
+	pStrm->SeekRel(static_cast<sal_uInt16>(size));
+	
+	//Skip others printer infor
+	pStrm->SeekRel(6*sizeof(sal_uInt16)+sizeof(sal_uInt32)+sizeof(sal_uInt16));
+
+	//Skip the next five LwpAtomHolder
+	{
+		LwpAtomHolder toSkip;
+		toSkip.Skip(pStrm);
+		toSkip.Skip(pStrm);
+		toSkip.Skip(pStrm);
+		toSkip.Skip(pStrm);
+		toSkip.Skip(pStrm);
+	}
+
+	sal_uInt16 count;
+	pStrm->QuickRead(&count, sizeof(count));
+	//Skip each selected division
+	LwpAtomHolder toSkip;
+	while(count--)
+	{
+		toSkip.Skip(pStrm);
+		pStrm->SkipExtra();
+	}
+	pStrm->SkipExtra();
+}
diff -urNp lotuswordpro.bak/source/filter/lwpprtinfo.hxx lotuswordpro/source/filter/lwpprtinfo.hxx
--- lotuswordpro.bak/source/filter/lwpprtinfo.hxx	1970-01-01 08:00:00.000000000 +0800
+++ lotuswordpro/source/filter/lwpprtinfo.hxx	2008-10-22 11:42:29.000000000 +0800
@@ -0,0 +1,93 @@
+/*************************************************************************
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: IBM Corporation
+ *
+ *  Copyright: 2008 by IBM Corporation
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+/*************************************************************************
+ * @file 
+ *  For LWP filter architecture prototype
+ ************************************************************************/
+/*************************************************************************
+ * Change History
+ Jan 2005			Created
+ ************************************************************************/
+
+#ifndef _LWPPRINTERINFO_HXX
+#define _LWPPRINTERINFO_HXX
+
+#include "lwpatomholder.hxx"
+#include "lwpobjstrm.hxx"
+/**
+ * @brief	printer info used in VO_DOCUMENT
+ *		not parsed yet
+*/
+class LwpPrinterInfo
+{
+public:
+	LwpPrinterInfo(LwpObjectStream* pStrm);
+	~LwpPrinterInfo(){};
+private:
+	LwpAtomHolder m_OutputFile;	
+	LwpAtomHolder cSelectedDivisions;
+	
+	LwpAtomHolder m_Output;
+	LwpAtomHolder m_Name;
+	LwpAtomHolder m_Driver;
+	LwpAtomHolder m_Queue;
+	LwpAtomHolder m_SelectedPages;	
+	
+public:
+	void Read(LwpObjectStream* pStrm);
+	void Skip(LwpObjectStream *pStrm);
+};
+#endif
+
diff -urNp lotuswordpro.bak/source/filter/lwppttntbl.hxx lotuswordpro/source/filter/lwppttntbl.hxx
--- lotuswordpro.bak/source/filter/lwppttntbl.hxx	1970-01-01 08:00:00.000000000 +0800
+++ lotuswordpro/source/filter/lwppttntbl.hxx	2008-10-22 11:42:29.000000000 +0800
@@ -0,0 +1,145 @@
+/*************************************************************************
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: IBM Corporation
+ *
+ *  Copyright: 2008 by IBM Corporation
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+/*************************************************************************
+* Change History
+* 2005-06-01  created
+************************************************************************/
+/**
+ * @file 
+ * For LWP filter architecture prototype
+ *  WordPro Pattern Table
+ */
+
+#ifndef _LTPATTERNTABLE_HXX
+#define _LTPATTERNTABLE_HXX
+
+static sal_uInt8 s_pLwpPatternTab[][8] = {                //Id	Name
+	{ 0xDF, 0xAF, 0x77, 0x77, 0x77, 0x77, 0xFA, 0xFD },//0	Transparent
+	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },//1	SolidForeground
+	{ 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF },//2	SolidBackground
+	{ 0x7F, 0xFF, 0xF7, 0xFF, 0x7F, 0xFF, 0xF7, 0xFF },//3	BACK_10PCTDOTS(31 GrayScale4thLightest)
+	{ 0x77, 0xFF, 0xDD, 0xFF, 0x77, 0xFF, 0xDD, 0xFF },//4	BACK_30PCTDOTS(30 GrayScale5thLightest)
+	{ 0x6F, 0xFF, 0xB5, 0xFF, 0xB5, 0xFF, 0xDA, 0xFF },//5	BACK_50PCTDOTS
+	{ 0x77, 0xDD, 0x77, 0xDD, 0x77, 0xDD, 0x77, 0xDD },//6
+	{ 0x88, 0x22, 0x88, 0x22, 0x88, 0x22, 0x88, 0x22 },//7
+	{ 0x22, 0x88, 0x22, 0x88, 0x22, 0x88, 0x22, 0x88 },//8
+	{ 0x22, 0x00, 0x88, 0x00, 0x22, 0x00, 0x88, 0x00 },//9
+	{ 0x80, 0x00, 0x08, 0x00, 0x80, 0x00, 0x08, 0x00 },//10
+	{ 0x80, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00 },//11
+	{ 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },//12
+	{ 0xB1, 0x30, 0x03, 0x1B, 0xD8, 0xC0, 0x0C, 0x8D },//13
+	{ 0x80, 0x10, 0x02, 0x20, 0x01, 0x08, 0x40, 0x04 },//14
+	{ 0x33, 0x99, 0xCC, 0x66, 0x33, 0x99, 0xCC, 0x66 },//15
+	{ 0x77, 0xBB, 0xDD, 0xEE, 0x77, 0xBB, 0xDD, 0xEE },//16
+	{ 0x6F, 0xB7, 0xDB, 0xED, 0xF6, 0x7B, 0xBD, 0xDE },//17
+	{ 0x5F, 0xAF, 0xD7, 0xEB, 0xF5, 0xFA, 0x7D, 0xBE },//18
+	{ 0xEA, 0x75, 0xBA, 0x5D, 0xAE, 0x57, 0xAB, 0xD5 },//19
+	{ 0x7F, 0xBF, 0xDF, 0xEF, 0xF7, 0xFB, 0xFD, 0xFE },//20
+	{ 0xCC, 0x99, 0x33, 0x66, 0xCC, 0x99, 0x33, 0x66 },//21
+	{ 0xEE, 0xDD, 0xBB, 0x77, 0xEE, 0xDD, 0xBB, 0x77 },//22
+	{ 0xDE, 0xBD, 0x7B, 0xF6, 0xED, 0xDB, 0xB7, 0x6F },//23
+	{ 0xFA, 0xF5, 0xEB, 0xD7, 0xAF, 0x5F, 0xBE, 0x7D },//24
+	{ 0x57, 0xAE, 0x5D, 0xBA, 0x75, 0xEA, 0xD5, 0xAB },//25
+	{ 0xFE, 0xFD, 0xFB, 0xF7, 0xEF, 0xDF, 0xBF, 0x7F },//26
+	{ 0x44, 0xAA, 0x11, 0xAA, 0x44, 0xAA, 0x11, 0xAA },//27
+	{ 0xBB, 0x55, 0xEE, 0x55, 0xBB, 0x55, 0xEE, 0x55 },//28
+	{ 0x7E, 0xBD, 0xDB, 0xE7, 0xE7, 0xDB, 0xBD, 0x7E },//29
+	{ 0xF9, 0xF6, 0x6F, 0x9F, 0x9F, 0x6F, 0xF6, 0xF9 },//30
+	{ 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF },//31
+	{ 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x00 },//32
+	{ 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0x00, 0xFF },//33
+	{ 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF },//34
+	{ 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55 },//35
+	{ 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99 },//36
+	{ 0xDB, 0xDB, 0xDB, 0xDB, 0xDB, 0xDB, 0xDB, 0xDB },//37
+	{ 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE },//38
+	{ 0xFF, 0x55, 0xFF, 0x55, 0xFF, 0x55, 0xFF, 0x55 },//39
+	{ 0xBB, 0xBB, 0x00, 0xBB, 0xBB, 0xBB, 0x00, 0xBB },//40
+	{ 0x00, 0xFD, 0xFD, 0xFD, 0xFD, 0xFD, 0xFD, 0xFD },//41
+	{ 0x22, 0x00, 0x20, 0x00, 0xAA, 0x00, 0x20, 0x00 },//42
+	{ 0x40, 0xA0, 0x00, 0x00, 0x04, 0x0A, 0x00, 0x00 },//43
+	{ 0x01, 0x80, 0x00, 0x08, 0x10, 0x20, 0x00, 0x02 },//44
+	{ 0xED, 0xED, 0x0C, 0xC0, 0xDE, 0xDE, 0xC0, 0x0C },//45
+	{ 0xC1, 0xE2, 0x77, 0x2E, 0x1C, 0x3A, 0x77, 0xA3 },//46
+	{ 0x00, 0xF7, 0xF7, 0xF7, 0x00, 0x7F, 0x7F, 0x7F },//47
+	{ 0x7C, 0xBB, 0xC7, 0xEF, 0xDF, 0xBF, 0x7F, 0xFE },//48
+	{ 0xFF, 0x33, 0xFF, 0xCC, 0xFF, 0x33, 0xFF, 0xCC },//49
+	{ 0xCC, 0xCC, 0x33, 0x33, 0x33, 0x33, 0xCC, 0xCC },//50
+	{ 0xF0, 0xF0, 0x0F, 0x0F, 0xF0, 0xF0, 0x0F, 0x0F },//51
+	{ 0xC3, 0xC3, 0xC3, 0xC3, 0x3C, 0x3C, 0x3C, 0x3C },//52
+	{ 0x33, 0x33, 0xCC, 0xCC, 0x33, 0x33, 0xCC, 0xCC },//53
+	{ 0x08, 0x08, 0x14, 0x22, 0xC9, 0x22, 0x14, 0x08 },//54
+	{ 0x0A, 0x04, 0x04, 0x55, 0xA0, 0x40, 0x40, 0x55 },//55
+	{ 0x01, 0x01, 0x03, 0x84, 0x48, 0x30, 0x0C, 0x02 },//56
+	{ 0x28, 0xC7, 0x01, 0x01, 0x82, 0x7C, 0x10, 0x10 },//57
+	{ 0x40, 0x80, 0x01, 0x02, 0x04, 0x8A, 0x55, 0xFF },//58
+	{ 0xC7, 0xC7, 0xBB, 0x4C, 0x7C, 0x7C, 0xBB, 0xC4 },//59
+	{ 0x8A, 0x05, 0x02, 0x00, 0x02, 0x05, 0x8A, 0x55 },//60
+	{ 0x28, 0x44, 0x82, 0x11, 0x00, 0x55, 0x00, 0x11 },//61
+	{ 0x81, 0x41, 0x60, 0x70, 0x78, 0x70, 0x60, 0x41 },//62
+	{ 0xEE, 0x57, 0xAB, 0x55, 0xEE, 0x5D, 0xBA, 0x75 },//63
+
+//
+	{ 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF },//2	SolidBackground
+	{ 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF },//2	SolidBackground
+	{ 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF },//2	SolidBackground
+	{ 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF },//2	SolidBackground
+	{ 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF },//2	SolidBackground
+	{ 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF },//2	SolidBackground
+	{ 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF },//2	SolidBackground
+	{ 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF },//2	SolidBackground
+};
+
+#endif
diff -urNp lotuswordpro.bak/source/filter/lwpresource.hxx lotuswordpro/source/filter/lwpresource.hxx
--- lotuswordpro.bak/source/filter/lwpresource.hxx	1970-01-01 08:00:00.000000000 +0800
+++ lotuswordpro/source/filter/lwpresource.hxx	2008-10-22 11:42:29.000000000 +0800
@@ -0,0 +1,68 @@
+/*************************************************************************
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: IBM Corporation
+ *
+ *  Copyright: 2008 by IBM Corporation
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+#ifndef		_RESOURCE_HXX
+#define		_RESOURCE_HXX
+
+#define		IMPLEMENTATION_NAME			"com.ibm.ILWPImportFilter"
+
+const char	STR_WORDPRO[]				= "Wordpro";
+const char	STR_IMPLEMENTATION_NAME[]	= IMPLEMENTATION_NAME;
+const char	STR_SERVICE_NAME[]			= "com.sun.star.document.ImportFilter";
+const char	STR_WRITER_IMPORTER_NAME[]	= "com.sun.star.comp.Writer.XMLImporter";
+
+#endif
+
+
+
diff -urNp lotuswordpro.bak/source/filter/lwprowlayout.cxx lotuswordpro/source/filter/lwprowlayout.cxx
--- lotuswordpro.bak/source/filter/lwprowlayout.cxx	1970-01-01 08:00:00.000000000 +0800
+++ lotuswordpro/source/filter/lwprowlayout.cxx	2008-10-22 11:42:29.000000000 +0800
@@ -0,0 +1,492 @@
+/*************************************************************************
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: IBM Corporation
+ *
+ *  Copyright: 2008 by IBM Corporation
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+/**
+ * @file 
+ *  For LWP filter architecture prototype - row layouts
+ */
+/*************************************************************************
+ * Change History
+ April 2005		 	Created
+ ************************************************************************/
+#include "lwprowlayout.hxx"
+#include "lwptable.hxx"
+#include "lwpglobalmgr.hxx"
+#include "xfilter/xfstylemanager.hxx"
+#include "xfilter/xfrow.hxx"
+#include "xfilter/xfrowstyle.hxx"
+#include "xfilter/xftablestyle.hxx"
+#include "xfilter/xftable.hxx"
+#include "xfilter/xfcell.hxx"
+#include "xfilter/xfcellstyle.hxx"
+
+LwpRowLayout::LwpRowLayout(LwpObjectHeader &objHdr, LwpSvStream* pStrm)
+	: LwpVirtualLayout(objHdr, pStrm)
+{
+	m_ConnCellList.clear();
+}
+
+LwpRowLayout::~LwpRowLayout()
+{}
+
+/**
+ * @short   register row style
+ * @param   
+ * @param   
+ * @param   
+ * @return   
+ */
+void LwpRowLayout::SetRowMap(void)
+{
+	LwpObjectID *pCellID= GetChildHead();
+	LwpCellLayout * pCellLayout = static_cast<LwpCellLayout *>(pCellID->obj());
+
+	while(pCellLayout)
+	{
+		pCellLayout->SetCellMap();
+
+		pCellID = pCellLayout->GetNext();
+		pCellLayout = static_cast<LwpCellLayout *>(pCellID->obj()); 
+	}
+}
+/**
+ * @short   register row style
+ * @param   
+ * @param   
+ * @param   
+ * @return   
+ */
+void LwpRowLayout::RegisterStyle()
+{
+	// register row style
+	XFRowStyle *pRowStyle = new XFRowStyle();
+
+	if (m_nDirection & 0x0030)
+	{
+		pRowStyle->SetMinRowHeight((float)LwpTools::ConvertFromUnitsToMetric(cheight));
+	}
+	else
+	{
+		pRowStyle->SetRowHeight((float)LwpTools::ConvertFromUnitsToMetric(cheight));
+	}
+	XFStyleManager* pXFStyleManager = LwpGlobalMgr::GetInstance()->GetXFStyleManager(); 
+	m_StyleName = pXFStyleManager->AddStyle(pRowStyle)->GetStyleName();
+
+	LwpTableLayout* pTableLayout = GetParentTableLayout();
+	LwpTable * pTable = NULL;
+	if (pTableLayout)
+	{
+		pTable = pTableLayout->GetTable();
+	}
+	// register cells' style
+	LwpObjectID *pCellID= GetChildHead();
+	LwpCellLayout * pCellLayout = static_cast<LwpCellLayout *>(pCellID->obj());
+
+	while(pCellLayout)
+	{
+		pCellLayout->SetFoundry(m_pFoundry);
+		pCellLayout->RegisterStyle();
+		pCellID = pCellLayout->GetNext();
+		pCellLayout = static_cast<LwpCellLayout *>(pCellID->obj()); 
+	}
+	
+}
+/**
+ * @short   register row style
+ * @param   
+ * @param   
+ * @param   
+ * @return   
+ */
+void LwpRowLayout::Read()
+{
+	#define MAXUNIT	(0x7fffffffL)				// Highest positive UNIT value
+	LwpObjectStream* pStrm = m_pObjStrm;
+	
+	LwpVirtualLayout::Read();
+	
+	//skip CLiteLayout data;
+	LwpAtomHolder ContentClass;
+	ContentClass.Read(pStrm);
+	pStrm->SkipExtra();
+
+	// Row layout content
+	crowid = pStrm->QuickReaduInt16();
+	cheight = pStrm->QuickReadInt32();
+	cLeaderDotCount = (sal_uInt8)pStrm->QuickReaduInt16();	// was written as lushort.
+	cLeaderDotY = MAXUNIT;	// Sentinel meaning "not calculated yet"
+	cRowFlags = (sal_uInt8)pStrm->QuickReaduInt16();	// was written as lushort.
+
+	pStrm->SkipExtra();
+}
+
+/**
+ * @short   Parse rows with connect cell
+ * @param  pXFTable - pointer to created XFTable
+ */
+void LwpRowLayout::ConvertRow(XFTable* pXFTable,sal_uInt8 nStartCol,sal_uInt8 nEndCol)
+{	
+	XFRow* pXFRow = new XFRow;
+	
+	LwpTableLayout* pTableLayout = GetParentTableLayout();
+	LwpTable* pTable = pTableLayout->GetTable();
+	
+	//calculate the connected cell position
+	sal_Int32 nMarkConnCell;	
+	nMarkConnCell = FindMarkConnCell(nStartCol,nEndCol);
+	
+	//if there is no connected cell
+	if (nMarkConnCell == -1)
+	{
+		ConvertCommonRow(pXFTable,nStartCol,nEndCol);
+		return;
+	} 
+	
+	//register connect row style	
+	sal_uInt16 nRowMark = crowid + GetCurMaxSpannedRows(nStartCol,nEndCol);
+	RegisterCurRowStyle(pXFRow,nRowMark);
+	
+	sal_Bool bIsRight = sal_False;
+	sal_Bool bIsTop = sal_False;
+			
+	//if there is connected cell
+	for (sal_uInt8 i=nStartCol; i<nEndCol; )
+	{
+		XFCell* pXFCell;
+		sal_uInt8 nColMark;
+
+		if (nMarkConnCell == -1)
+			nColMark = nEndCol;
+		else
+			nColMark = m_ConnCellList[nMarkConnCell]->GetColID();
+
+		if (nColMark > i)//create subtable
+		{
+			pXFCell = new XFCell;
+			pXFCell->SetColumnSpaned(nColMark-i);
+			XFTable* pSubTable = new XFTable;
+			pTableLayout->ConvertTable(pSubTable,crowid,nRowMark,i,nColMark);
+			pXFCell->Add(pSubTable);
+			i = nColMark;	
+		}
+		else
+		{
+			sal_uInt8 nColID = m_ConnCellList[nMarkConnCell]->GetColID()
+					+m_ConnCellList[nMarkConnCell]->GetNumcols()-1;
+			pXFCell = m_ConnCellList[nMarkConnCell]->ConvertCell(
+				*pTable->GetObjectID(),
+				crowid+m_ConnCellList[nMarkConnCell]->GetNumrows()-1,
+				m_ConnCellList[nMarkConnCell]->GetColID());
+				
+			//set all cell in this merge cell to cellsmap	
+			for (sal_uInt16 nRowLoop = crowid;nRowLoop<nRowMark ;nRowLoop++)
+				for (sal_uInt8 nColLoop = i;nColLoop<nColID+1;nColLoop++)
+					pTableLayout->SetCellsMap(nRowLoop,nColLoop,pXFCell);
+				
+			i += m_ConnCellList[nMarkConnCell]->GetNumcols();
+			nMarkConnCell = FindNextMarkConnCell(static_cast<sal_uInt16>(nMarkConnCell),nEndCol);		
+		}	
+
+		if (pXFCell)		
+			pXFRow->AddCell(pXFCell);				
+	}
+	pXFTable->AddRow(pXFRow);
+}
+
+/**
+ * @short   register row style in SODC table
+ * @param   pXFRow - pointer of row
+ * @param   nRowMark - spanned row number
+ */
+void LwpRowLayout::RegisterCurRowStyle(XFRow* pXFRow,sal_uInt16 nRowMark)
+{
+	XFRowStyle* pRowStyle;
+	XFRowStyle* pNewStyle = new XFRowStyle;	
+	double fHeight;
+	XFStyleManager* pXFStyleManager = LwpGlobalMgr::GetInstance()->GetXFStyleManager(); 
+	pRowStyle = static_cast<XFRowStyle*>(pXFStyleManager->FindStyle(m_StyleName));
+	if (!pRowStyle)
+		return;
+	fHeight = pRowStyle->GetRowHeight();
+	
+	*pNewStyle = *pRowStyle;
+	std::map<sal_uInt16,LwpRowLayout*>::iterator iter;
+	LwpTableLayout* pTableLayout = GetParentTableLayout();
+	if (!pTableLayout)
+		return;
+	std::map<sal_uInt16,LwpRowLayout*> RowsMap = pTableLayout->GetRowsMap();
+	
+	for (sal_uInt16 i=crowid+1; i<nRowMark;i++)
+	{
+		iter = RowsMap.find(i);
+		if (iter == RowsMap.end())
+		{
+			pRowStyle = static_cast<XFRowStyle*>(
+				pXFStyleManager->FindStyle(pTableLayout->GetDefaultRowStyleName()));
+			fHeight += pRowStyle->GetRowHeight();		
+		}
+		else
+		{
+			pRowStyle = static_cast<XFRowStyle*>(
+				pXFStyleManager->FindStyle(iter->second->GetStyleName()));
+			fHeight+=pRowStyle->GetRowHeight();
+		}	
+	}	
+	
+	if (m_nDirection & 0x0030)
+	{
+		pNewStyle->SetMinRowHeight((float)fHeight);
+	}
+	else
+	{
+		pNewStyle->SetRowHeight((float)fHeight);
+	}
+	
+	pXFRow->SetStyleName(pXFStyleManager->AddStyle(pNewStyle)->GetStyleName());
+}
+
+/**
+ * @short   find max merge cell in a given column range
+ * @param   nStartCol - start column ID
+ * @param   nEndCol - end column ID
+ */
+sal_Int32 LwpRowLayout::FindMarkConnCell(sal_uInt8 nStartCol,sal_uInt8 nEndCol)
+{
+	if (m_ConnCellList.size() == 0)
+		return -1;
+		
+	sal_uInt16 nSpannRows = 1;
+	sal_Int32 nMarkConnCell = -1;
+	
+	for (sal_uInt16 i=0;i<m_ConnCellList.size();i++)
+	{
+		if (m_ConnCellList[i]->GetColID()>=nEndCol)
+			break;
+		if (m_ConnCellList[i]->GetColID()>=nStartCol)
+		{
+			if (m_ConnCellList[i]->GetNumrows()>nSpannRows)
+			{
+				nSpannRows = m_ConnCellList[i]->GetNumrows();
+				nMarkConnCell = i;
+			}
+		}
+	}
+	return nMarkConnCell;
+}
+
+/**
+ * @short   find next merge cell with the same spanned row number with current merge cell
+ * @param   nStartCol - start column ID
+ * @param   nEndCol - end column ID
+ */
+sal_Int32 LwpRowLayout::FindNextMarkConnCell(sal_uInt16 nMarkConnCell,sal_uInt8 nEndCol)
+{
+	sal_uInt16 nMaxRows = m_ConnCellList[nMarkConnCell]->GetNumrows();
+	
+	for (sal_uInt16 i=nMarkConnCell+1;i<m_ConnCellList.size();i++)
+	{
+		if (m_ConnCellList[i]->GetColID()>=nEndCol)
+			break;
+		if (m_ConnCellList[i]->GetNumrows() == nMaxRows)
+		{
+			return i;
+		}
+	}
+	return -1;
+}
+/**
+ * @short   get max spanned row numbers in a given column range
+ * @param   nStartCol - start column ID
+ * @param   nEndCol - end column ID
+ */
+sal_uInt16 LwpRowLayout::GetCurMaxSpannedRows(sal_uInt8 nStartCol,sal_uInt8 nEndCol)
+{
+	sal_Int32 nMarkConnCell = FindMarkConnCell(nStartCol,nEndCol);
+	if (nMarkConnCell == -1)
+		return 1;
+	else
+		return m_ConnCellList[nMarkConnCell]->GetNumrows();
+}
+/**
+ * @short   convert row with rowlayout,but no merge cells
+ * @param   pXFTable - pointer of table 
+ * @param   nStartCol - start column ID
+ * @param   nEndCol - end column ID
+ */
+void LwpRowLayout::ConvertCommonRow(XFTable* pXFTable,sal_uInt8 nStartCol,sal_uInt8 nEndCol)
+{
+	XFRow* pRow = new XFRow;
+	pRow->SetStyleName(m_StyleName);
+	
+	XFCell * pCell;
+	LwpTableLayout* pTableLayout = GetParentTableLayout();
+	LwpTable* pTable = pTableLayout->GetTable();
+	sal_Bool bIsRight = sal_False;
+	sal_Bool bIsTop = sal_False;
+	sal_uInt8 nCellStartCol,nCellEndCol;
+	
+	for (sal_uInt8 i = nStartCol; i < nEndCol ; i++)		
+	{
+		// add row to table
+		LwpObjectID *pCellID= GetChildHead();
+		LwpCellLayout * pCellLayout = static_cast<LwpCellLayout *>(pCellID->obj());
+		nCellStartCol = i;//mark the begin position of cell
+		nCellEndCol = i;//mark the end position of cell
+		while(pCellLayout)
+		{
+			if (pCellLayout->GetColID() == i)
+			{
+				if (pCellLayout->GetLayoutType() == LWP_CONNECTED_CELL_LAYOUT)
+				{
+					LwpConnectedCellLayout* pConnCell = static_cast<LwpConnectedCellLayout*>(pCellLayout);
+					nCellEndCol = i+pConnCell->GetNumcols()-1;
+					i = nCellEndCol;
+				}
+				pCell = pCellLayout->ConvertCell(*pTable->GetObjectID(),crowid,i);
+				break;
+			}
+			pCellID = pCellLayout->GetNext();
+			pCellLayout = static_cast<LwpCellLayout *>(pCellID->obj()); 
+		}
+		if (!pCellLayout)
+		{
+			// if table has default cell layout, use it to ConvertCell
+			// otherwise use blank cell
+			LwpCellLayout * pDefaultCell = pTableLayout->GetDefaultCellLayout();
+			if (pDefaultCell)
+			{
+				pCell = pDefaultCell->ConvertCell(
+					*pTable->GetObjectID(),crowid, i);
+			}
+			else
+			{
+				pCell = new XFCell;
+			}
+		}
+		pRow->AddCell(pCell);
+		
+		for (sal_uInt8 j=nCellStartCol;j<=nCellEndCol;j++)
+			pTableLayout->SetCellsMap(crowid,j,pCell);//set to cellsmap
+	}
+	
+	pXFTable->AddRow(pRow);
+}
+/**
+ * @short   collect merge cell info when register row styles
+ */
+void LwpRowLayout::CollectMergeInfo()
+{
+	LwpObjectID *pCellID= GetChildHead();
+	LwpCellLayout * pCellLayout = static_cast<LwpCellLayout *>(pCellID->obj());
+
+	while(pCellLayout)
+	{
+		if (pCellLayout->GetLayoutType() == LWP_CONNECTED_CELL_LAYOUT)
+		{
+			LwpConnectedCellLayout* pConnCell = static_cast<LwpConnectedCellLayout*>(pCellLayout);
+			m_ConnCellList.push_back(pConnCell);
+		}	
+		pCellID = pCellLayout->GetNext();
+		pCellLayout = static_cast<LwpCellLayout *>(pCellID->obj()); 
+	}
+}
+/**
+ * @short   split merge cells in this row
+ * @param   nEffectRows - max spanned number of prevoius row 
+ */
+void LwpRowLayout::SetCellSplit(sal_uInt16 nEffectRows)
+{
+	LwpConnectedCellLayout* pConnCell;
+	for (sal_uInt32 i=0; i<m_ConnCellList.size(); i++)
+	{	
+		pConnCell = m_ConnCellList[i];
+		sal_uInt16 nRowSpan = pConnCell->GetRowID()+pConnCell->GetNumrows();
+		if ( nRowSpan > nEffectRows )
+		{
+			pConnCell->SetNumrows(nEffectRows - pConnCell->GetRowID());
+		}
+	}
+}
+/**
+ * @short   check if the row has merge cell
+ */
+sal_Bool LwpRowLayout::GetMergeCellFlag()
+{
+	if (m_ConnCellList.size() == 0)
+		return sal_False;
+	else
+		return sal_True;
+}
+
+
+LwpRowHeadingLayout::LwpRowHeadingLayout(LwpObjectHeader &objHdr, LwpSvStream* pStrm)
+	: LwpRowLayout(objHdr, pStrm)
+{}
+
+LwpRowHeadingLayout::~LwpRowHeadingLayout()
+{}
+void LwpRowHeadingLayout::Read()
+{
+	LwpRowLayout::Read();
+
+	cRowLayout.ReadIndexed(m_pObjStrm);
+	m_pObjStrm->SkipExtra();
+}
+
+LwpRowLayout * LwpRowHeadingLayout::GetRowLayout()
+{
+	LwpRowLayout * pRow = static_cast<LwpRowLayout *>(cRowLayout.obj());
+	return pRow;
+}
+
diff -urNp lotuswordpro.bak/source/filter/lwprowlayout.hxx lotuswordpro/source/filter/lwprowlayout.hxx
--- lotuswordpro.bak/source/filter/lwprowlayout.hxx	1970-01-01 08:00:00.000000000 +0800
+++ lotuswordpro/source/filter/lwprowlayout.hxx	2008-10-22 11:42:29.000000000 +0800
@@ -0,0 +1,134 @@
+/*************************************************************************
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: IBM Corporation
+ *
+ *  Copyright: 2008 by IBM Corporation
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+/**
+ * @file 
+ *  For LWP filter architecture prototype - row layouts
+ */
+/*************************************************************************
+ * Change History
+ April 2005		 	Created
+ ************************************************************************/
+#ifndef _LWPROWLAYOUT_HXX
+#define _LWPROWLAYOUT_HXX
+
+#include "lwplayout.hxx"
+#include "lwptablelayout.hxx"
+#include "lwpcelllayout.hxx"
+
+class XFCell;
+class XFRow;
+class XFTable;
+class LwpTableLayout;
+class XFRowStyle;
+/**
+ * @brief
+ * VO_ROWLAYOUT obj
+ */
+class LwpRowLayout : public LwpVirtualLayout
+{
+public:
+	LwpRowLayout(LwpObjectHeader &objHdr, LwpSvStream* pStrm);
+	virtual ~LwpRowLayout();
+	virtual LWP_LAYOUT_TYPE GetLayoutType () { return LWP_ROW_LAYOUT;};
+	sal_uInt16 GetRowID() { return crowid;};
+	virtual void RegisterStyle();
+	inline LwpTableLayout * GetParentTableLayout(){return static_cast<LwpTableLayout *>(GetParent()->obj());};
+	void SetRowMap(void);
+protected:
+	void Read();	
+	sal_uInt16 crowid;
+	sal_Int32 cheight;				// Minimum height if height is automatic.
+	sal_uInt8 cLeaderDotCount;	// dfb - # of cells with leader dots
+	sal_Int32 cLeaderDotY;
+	sal_uInt8 cRowFlags;
+	enum // for cRowFlags
+	{
+		RF_HAS_BORDER		= 0x01,
+		RF_VALID_HAS_BORDER	= 0x02,
+		RF_LEADER_COUNT_VALID = 0x4
+	};
+private:
+	std::vector<LwpConnectedCellLayout*> m_ConnCellList;
+	sal_Int32 FindMarkConnCell(sal_uInt8 nStartCol,sal_uInt8 nEndCol);
+	sal_Int32 FindNextMarkConnCell(sal_uInt16 nMarkConnCell,sal_uInt8 nEndCol);	
+
+public:
+	void ConvertRow(XFTable* pXFTable,sal_uInt8 nStartCol,sal_uInt8 nEndCol);
+	void ConvertCommonRow(XFTable* pXFTable,sal_uInt8 nStartCol,sal_uInt8 nEndCol);
+	void CollectMergeInfo();
+	void SetCellSplit(sal_uInt16 nEffectRows);
+	sal_Bool GetMergeCellFlag();
+	sal_uInt16 GetCurMaxSpannedRows(sal_uInt8 nStartCol,sal_uInt8 nEndCol);
+	void RegisterCurRowStyle(XFRow* pXFRow,sal_uInt16 nRowMark);
+};
+
+
+/**
+ * @brief
+ * VO_ROWHEADINGLAYOUT obj
+ */
+class LwpRowHeadingLayout : public LwpRowLayout
+{
+public:
+	LwpRowHeadingLayout(LwpObjectHeader &objHdr, LwpSvStream* pStrm);
+	virtual ~LwpRowHeadingLayout();
+	virtual LWP_LAYOUT_TYPE GetLayoutType () { return LWP_ROW_HEADING_LAYOUT;}
+	LwpRowLayout * GetRowLayout();
+protected:
+	void Read();	
+	LwpObjectID cRowLayout;
+};
+
+#endif
diff -urNp lotuswordpro.bak/source/filter/lwpsdwdrawheader.hxx lotuswordpro/source/filter/lwpsdwdrawheader.hxx
--- lotuswordpro.bak/source/filter/lwpsdwdrawheader.hxx	1970-01-01 08:00:00.000000000 +0800
+++ lotuswordpro/source/filter/lwpsdwdrawheader.hxx	2008-10-22 11:42:29.000000000 +0800
@@ -0,0 +1,297 @@
+/*************************************************************************
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: IBM Corporation
+ *
+ *  Copyright: 2008 by IBM Corporation
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+/*****************************************************************************
+ * Change History
+ * Mar 2005			Created
+ ****************************************************************************/
+/**
+ * @file 
+ * For LWP filter architecture prototype
+ * The file declares structures and enums used by Lwp-Drawing-Module
+ */
+ 
+#ifndef _LWPSDWRAWHEADER_HXX
+#define _LWPSDWRAWHEADER_HXX
+
+#include "lwpheader.hxx"
+#include "lwptools.hxx"
+
+const sal_uInt8 DRAW_FACESIZE = 32;
+const double THRESHOLD = 0.0001;
+
+enum DrawObjectType
+{
+	OT_UNDEFINED,
+	OT_SELECT	   = 0,
+	OT_HAND 	   = 1,
+	OT_LINE 	   = 2,
+	OT_PERPLINE	   = 3,
+	OT_POLYLINE	   = 4,
+	OT_POLYGON	   = 5,
+	OT_RECT 	   = 6,
+	OT_SQUARE	   = 7,
+	OT_RNDRECT	   = 8,
+	OT_RNDSQUARE   = 9,
+	OT_OVAL 	   = 10,
+	OT_CIRCLE	   = 11,
+	OT_ARC		   = 12,
+	OT_TEXT 	   = 13,
+	OT_GROUP	   = 14,
+	OT_CHART	   = 15,
+	OT_METAFILE	   = 16,
+	OT_METAFILEIMG = 17,
+	OT_BITMAP	   = 18,
+	OT_TEXTART     = 19,
+	OT_BIGBITMAP   = 20
+};
+
+enum DrawFillType
+{
+	FT_TRANSPARENT	  = 0,
+	FT_VLTGRAY		  = 1,
+	FT_LTGRAY		  = 2,
+	FT_GRAY 		  = 3,
+	FT_DKGRAY		  = 4,
+	FT_SOLID		  = 5,
+	FT_HORZHATCH	  = 6,
+	FT_VERTHATCH	  = 7,
+	FT_FDIAGHATCH	  = 8,
+	FT_BDIAGHATCH	  = 9,
+	FT_CROSSHATCH	  = 10,
+	FT_DIAGCROSSHATCH = 11,
+	FT_PATTERN		  = 12
+};
+
+enum DrawLineStyle
+{
+	LS_SOLID	   = 0,
+	LS_DASH 	   = 1,
+	LS_DOT		   = 2,
+	LS_DASHDOT	   = 3,
+	LS_DASHDOTDOT  = 4,
+	LS_NULL 	   = 5,
+	LS_INSIDEFRAME = 6
+};
+
+// Text Attributes as stored in Draw files V1.2 and earlier
+enum DrawTextAttribute
+{
+	TA_BOLD			  = 0x0001,	/* bolded font */
+	TA_ITALIC		  = 0x0002,	/* italic font */
+	TA_UNDERLINE	  =	0x0004,	/* underlined font */
+	TA_WORDUNDERLINE  =	0x0008,	/* broken underline */
+	TA_ALLCAPS		  = 0x0010,	/* capitalized font */
+	TA_SMALLCAPS	  =	0x0020,	/* all small capital letters */
+	TA_DOUBLEUNDER	  =	0x0040,	/* double underline */
+	TA_STRIKETHRU	  =	0x0080,	/* strikethru */
+	TA_SUPERSCRIPT	  =	0x0100,	/* superscript */
+	TA_SUBSCRIPT	  =	0x0200	/* subscript */
+};
+
+enum DrawArrowHead
+{
+	AH_ARROW_NONE = 0,
+	AH_ARROW_FULLARROW = 1,
+	AH_ARROW_HALFARROW = 2,
+	AH_ARROW_LINEARROW = 3,
+	AH_ARROW_INVFULLARROW = 4,
+	AH_ARROW_INVHALFARROW = 5,
+	AH_ARROW_INVLINEARROW = 6,
+	AH_ARROW_TEE = 7,
+	AH_ARROW_SQUARE = 8,
+	AH_ARROW_CIRCLE = 9
+};
+
+struct SdwPoint
+{
+	sal_Int16 x;
+	sal_Int16 y;
+};
+
+struct SdwColor
+{
+	sal_uInt8 nR;
+	sal_uInt8 nG;
+	sal_uInt8 nB;
+	sal_uInt8 unused;
+};
+
+struct SdwClosedObjStyleRec
+{
+	sal_uInt8 nLineWidth;
+	sal_uInt8 nLineStyle;
+	SdwColor aPenColor;
+	SdwColor aForeColor;
+	SdwColor aBackColor;
+	sal_uInt16 nFillType;
+	sal_uInt8 pFillPattern[8];
+};
+
+struct SdwDrawObjHeader
+{
+//	sal_uInt8 nType
+//	sal_uInt8 nFlags;
+	sal_uInt16 nRecLen;
+	sal_Int16 nLeft;
+	sal_Int16 nTop;
+	sal_Int16 nRight;
+	sal_Int16 nBottom;
+//	sal_uInt16 nextObj;
+//	sal_uInt16 prevObj;
+};
+
+struct SdwLineRecord
+{
+	sal_Int16 nStartX;
+	sal_Int16 nStartY;
+	sal_Int16 nEndX;
+	sal_Int16 nEndY;
+	sal_uInt8 nLineWidth;
+	sal_uInt8 nLineEnd;
+	sal_uInt8 nLineStyle;
+	SdwColor aPenColor;
+};
+
+struct SdwPolyLineRecord
+{
+	sal_uInt8 nLineWidth;
+	sal_uInt8 nLineEnd;
+	sal_uInt8 nLineStyle;
+	SdwColor aPenColor;
+	sal_uInt16 nNumPoints;
+};
+
+struct SdwArcRecord
+{
+	sal_uInt8 nLineWidth;
+	sal_uInt8 nLineEnd;
+	sal_uInt8 nLineStyle;
+	SdwColor aPenColor;
+};
+
+struct SdwTextBoxRecord
+{
+	sal_Int16 nTextWidth;
+	sal_Int16 nTextHeight;
+	sal_Int16 nTextSize;
+	SdwColor aTextColor;
+	sal_uInt8 tmpTextFaceName[DRAW_FACESIZE];
+	sal_uInt16 nTextAttrs;
+	sal_uInt16 nTextCharacterSet;
+	sal_Int16 nTextRotation;
+	sal_Int16 nTextExtraSpacing;
+	sal_uInt8* pTextString;
+};
+
+struct SdwFMPATH
+{
+	sal_uInt16 n;
+	SdwPoint* pPts;
+};
+
+struct SdwTextArt : public SdwTextBoxRecord
+{
+	sal_uInt8 nIndex;
+	sal_Int16 nRotation;
+	sal_uInt16 nTextLen;
+	SdwFMPATH aPath[2];
+};
+
+struct SdwBmpRecord
+{
+	sal_uInt16 nTranslation;
+	sal_uInt16 nRotation;
+	sal_uInt32 nFileSize;
+};
+
+struct BmpInfoHeader
+{
+	sal_uInt32 nHeaderLen;
+	sal_uInt16 nWidth;
+	sal_uInt16 nHeight;
+	sal_uInt16 nPlanes;
+	sal_uInt16 nBitCount;
+};
+
+struct BmpInfoHeader2
+{
+	sal_uInt32 nHeaderLen;
+	sal_uInt32 nWidth;
+	sal_uInt32 nHeight;
+	sal_uInt16 nPlanes;
+	sal_uInt16 nBitCount;
+};
+
+struct DrawingOffsetAndScale
+{
+	double fOffsetX;
+	double fOffsetY;
+	double fScaleX;
+	double fScaleY;
+	double fLeftMargin;
+	double fTopMargin;
+	
+	DrawingOffsetAndScale()
+	{
+		fOffsetX = 0.00;
+		fOffsetY = 0.00;
+		fScaleX = 1.00;
+		fScaleY = 1.00;
+		fLeftMargin = 0.00;
+		fTopMargin = 0.00;
+	}
+};
+
+#endif
diff -urNp lotuswordpro.bak/source/filter/lwpsdwfileloader.cxx lotuswordpro/source/filter/lwpsdwfileloader.cxx
--- lotuswordpro.bak/source/filter/lwpsdwfileloader.cxx	1970-01-01 08:00:00.000000000 +0800
+++ lotuswordpro/source/filter/lwpsdwfileloader.cxx	2008-10-22 11:42:29.000000000 +0800
@@ -0,0 +1,148 @@
+/*************************************************************************
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: IBM Corporation
+ *
+ *  Copyright: 2008 by IBM Corporation
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+/*****************************************************************************
+ * Change History
+ * Mar 2005			revised for new processing procedure.
+ * Jan 2005			created
+ ****************************************************************************/
+#include "lwpsdwfileloader.hxx"
+#include "lwpsdwgrouploaderv0102.hxx"
+
+#include "xfilter/xfframe.hxx"
+
+LwpSdwFileLoader::LwpSdwFileLoader(SvStream* pStream, LwpGraphicObject* pGraphicObj,
+	IXFStream* pOutputStream)
+:m_pStream(pStream), m_pGraphicObj(pGraphicObj), m_pOutputStream(pOutputStream)
+{
+	pStream->Seek(0);
+}
+
+LwpSdwFileLoader::~LwpSdwFileLoader(void)
+{
+}
+/*
+void LwpSdwFileLoader::LoadObjectList(void)
+{
+	unsigned char BinSignature[2];
+	m_pStream->Read(BinSignature,2);
+
+	if (BinSignature[0] == 'S' && BinSignature[1] == 'M')
+	{
+		unsigned short nVersion;
+		m_pStream->Read(&nVersion,2);
+		
+		m_pStream->Seek(0);
+		if (nVersion<0x0102)
+		{
+			assert(false);
+		}
+		if (nVersion>=0x0102)
+		{
+			LwpSdwGroupLoaderV0102 sdwGroupLoader(m_pStream, m_pGraphicObj, m_pOutputStream);
+			sdwGroupLoader.LoadDrawGroupObject();
+		}
+	}
+}
+void LwpSdwFileLoader::RegisterStyle()
+{
+	unsigned char BinSignature[2];
+	m_pStream->Read(BinSignature,2);
+
+	if (BinSignature[0] == 'S' && BinSignature[1] == 'M')
+	{
+		unsigned short nVersion;
+		m_pStream->Read(&nVersion,2);
+
+		m_pStream->Seek(0);
+		if (nVersion<0x0102)
+		{
+			assert(false);
+		}
+		if (nVersion>=0x0102)
+		{
+			LwpSdwGroupLoaderV0102 sdwGroupLoader(m_pStream, m_pGraphicObj, m_pOutputStream);
+			sdwGroupLoader.RegisterGroupStyle();
+		}
+	}
+}
+*/
+// add by  ,03/25/2005
+/**
+ * @descr   entry of lwp-drawing objects. 
+ * @param   pDrawObjVector   a container which will contains the created drawing object of XF-Model.
+ */
+void LwpSdwFileLoader::CreateDrawObjects(vector <XFFrame*>* pDrawObjVector)
+{
+	unsigned char BinSignature[2];
+	m_pStream->Read(BinSignature,2);
+
+	if (BinSignature[0] == 'S' && BinSignature[1] == 'M')
+	{
+		unsigned short nVersion;
+		m_pStream->Read(&nVersion,2);
+
+		m_pStream->Seek(0);
+		if (nVersion<0x0102)
+		{
+			assert(false);
+		}
+		if (nVersion>=0x0102)
+		{
+			LwpSdwGroupLoaderV0102 sdwGroupLoader(m_pStream, m_pGraphicObj, m_pOutputStream);
+			sdwGroupLoader.BeginDrawObjects(pDrawObjVector);
+		}
+	}
+}
+// end add
\ No newline at end of file
diff -urNp lotuswordpro.bak/source/filter/lwpsdwfileloader.hxx lotuswordpro/source/filter/lwpsdwfileloader.hxx
--- lotuswordpro.bak/source/filter/lwpsdwfileloader.hxx	1970-01-01 08:00:00.000000000 +0800
+++ lotuswordpro/source/filter/lwpsdwfileloader.hxx	2008-10-22 11:42:29.000000000 +0800
@@ -0,0 +1,87 @@
+/*************************************************************************
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: IBM Corporation
+ *
+ *  Copyright: 2008 by IBM Corporation
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+/*****************************************************************************
+ * Change History
+ * Mar 2005			revised for new processing procedure.
+ * Jan 2005			created
+ ****************************************************************************/
+#include <assert.h>
+#include <tools/stream.hxx>
+#include "lwpheader.hxx"
+#include "xfilter/ixfstream.hxx"
+#include <vector>
+using namespace std;
+
+class XFFrame;
+class LwpGraphicObject;
+class LwpSdwFileLoader
+{
+private:
+	SvStream* m_pStream;
+	IXFStream* m_pOutputStream;
+	LwpGraphicObject* m_pGraphicObj;
+public:
+	LwpSdwFileLoader(SvStream* pStream, LwpGraphicObject* pGraphicObj,
+		IXFStream* pOutputStream=NULL);
+	~LwpSdwFileLoader(void);
+public:
+//	void LoadObjectList(void);
+//	void RegisterStyle(void);
+
+	// add by  ,03/25/2005
+	void CreateDrawObjects(vector <XFFrame*>* pDrawObjVector);
+	// end add
+};
+
diff -urNp lotuswordpro.bak/source/filter/lwpsdwgrouploaderv0102.cxx lotuswordpro/source/filter/lwpsdwgrouploaderv0102.cxx
--- lotuswordpro.bak/source/filter/lwpsdwgrouploaderv0102.cxx	1970-01-01 08:00:00.000000000 +0800
+++ lotuswordpro/source/filter/lwpsdwgrouploaderv0102.cxx	2008-10-22 11:42:29.000000000 +0800
@@ -0,0 +1,410 @@
+/*************************************************************************
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: IBM Corporation
+ *
+ *  Copyright: 2008 by IBM Corporation
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+/*****************************************************************************
+ * Change History
+ * Mar 2005			revised for new processing procedure.
+ * Jan 2005			created
+ ****************************************************************************/
+#include "lwpsdwgrouploaderv0102.hxx"
+#include "lwpdrawobj.hxx"
+#include "lwptools.hxx"
+#include "lwpcharsetmgr.hxx"
+#include "lwpgrfobj.hxx"
+#include "lwpframelayout.hxx"
+
+#include "xfilter/xfcolor.hxx"
+#include "xfilter/xfdrawline.hxx"
+#include "xfilter/xfdrawpath.hxx"
+#include "xfilter/xfdrawpolyline.hxx"
+#include "xfilter/xfdrawrect.hxx"
+#include "xfilter/xfdrawellipse.hxx"
+#include "xfilter/xfdrawpolygon.hxx"
+#include "xfilter/xfdrawgroup.hxx"
+#include "xfilter/xfdrawcircle.hxx"
+#include "xfilter/xfdrawstyle.hxx"
+#include "xfilter/xfdrawlinestyle.hxx"
+#include "xfilter/xfparagraph.hxx"
+#include "xfilter/xfstylemanager.hxx"
+#include "xfilter/xfdrawgroup.hxx"
+
+LwpSdwGroupLoaderV0102::LwpSdwGroupLoaderV0102(SvStream* pStream, LwpGraphicObject* pGraphicObj, 
+	IXFStream* pOutputStream)
+:m_pStream(pStream), m_pGraphicObj(pGraphicObj), m_pOutputStream(pOutputStream)
+{
+}
+LwpSdwGroupLoaderV0102::~LwpSdwGroupLoaderV0102(void)
+{
+}
+
+// add by , 03/25/2005
+/**
+ * @descr   entry of lwp-drawing objects. the functin begins to parse the sdw-drawing bento stream and create
+ *		the corresponding drawing objects.
+ * @param   pDrawObjVector   a container which will contains the created drawing object of XF-Model.
+ */
+void LwpSdwGroupLoaderV0102::BeginDrawObjects(std::vector <XFFrame*>* pDrawObjVector)
+{
+	// save the container
+	m_pDrawObjVector = pDrawObjVector;
+
+	//flag
+	unsigned char BinSignature[2];
+	m_pStream->Read(BinSignature,2);
+	if (BinSignature[0] != 'S' || BinSignature[1] != 'M')
+	{
+		assert(false);
+		return;
+	}
+	//version
+	unsigned short nVersion;
+	m_pStream->Read(&nVersion,2);
+	if (nVersion<0x0102)
+	{
+		assert(false);
+		return;
+	}
+	// topObj, botObj
+	m_pStream->SeekRel(4); 
+	//record count
+	unsigned short nRecCount;
+	m_pStream->Read(&nRecCount,2); 
+	// selCount
+	m_pStream->SeekRel(2); 
+	//boundrect
+	unsigned short left,top,right,bottom;
+	m_pStream->Read(&left,2); 
+	m_pStream->Read(&top,2); 
+	m_pStream->Read(&right,2); 
+	m_pStream->Read(&bottom,2); 
+	// fileSize
+	m_pStream->SeekRel(2); 
+
+	//for calculating transformation params.
+	LwpFrameLayout* pMyFrameLayout = static_cast<LwpFrameLayout*>(m_pGraphicObj->GetLayout(NULL));
+	if (pMyFrameLayout)
+	{
+		LwpLayoutScale* pMyScale = pMyFrameLayout->GetLayoutScale();
+		LwpLayoutGeometry* pFrameGeo = pMyFrameLayout->GetGeometry();
+		if (pMyScale && pFrameGeo)
+		{
+			// original drawing size
+			long nWidth = 0, nHeight = 0;
+			m_pGraphicObj->GetGrafOrgSize(nWidth, nHeight);
+			double fGrafOrgWidth = (double)nWidth/TWIPS_PER_CM;
+			double fGrafOrgHeight = (double)nHeight/TWIPS_PER_CM;
+
+			// get margin values
+			double fLeftMargin = pMyFrameLayout->GetMarginsValue(MARGIN_LEFT);
+//			double fRightMargin = pMyFrameLayout->GetMarginsValue(MARGIN_RIGHT);
+			double fTopMargin = pMyFrameLayout->GetMarginsValue(MARGIN_TOP);
+//			double fBottomMargin = pMyFrameLayout->GetMarginsValue(MARGIN_BOTTOM);
+
+			// frame size
+			double fFrameWidth = LwpTools::ConvertFromUnitsToMetric(pFrameGeo->GetWidth());
+			double fFrameHeight = LwpTools::ConvertFromUnitsToMetric(pFrameGeo->GetHeight());
+
+			// get frame offset
+			LwpPoint* pOffset = pMyScale->GetOffset();
+			double fOffsetX = LwpTools::ConvertFromUnitsToMetric(pOffset->GetX());
+			double fOffsetY = LwpTools::ConvertFromUnitsToMetric(pOffset->GetY());
+
+			// get scale mode
+			sal_uInt16 nScalemode = pMyScale->GetScaleMode();
+
+			if (nScalemode & LwpLayoutScale::CUSTOM)
+			{
+				m_aTransformData.fScaleX =
+					LwpTools::ConvertFromUnitsToMetric(pMyScale->GetScaleWidth()) / fGrafOrgWidth;
+				m_aTransformData.fScaleY =
+					LwpTools::ConvertFromUnitsToMetric(pMyScale->GetScaleHeight()) / fGrafOrgHeight;
+			}
+			else if (nScalemode & LwpLayoutScale::PERCENTAGE)
+			{
+				double fScalePercentage = (double)pMyScale->GetScalePercentage() / 1000;
+				m_aTransformData.fScaleX = fScalePercentage;
+				m_aTransformData.fScaleY = fScalePercentage;
+			}
+			else if (nScalemode & LwpLayoutScale::FIT_IN_FRAME)
+			{
+				double fWidth0 = (double)right / TWIPS_PER_CM;
+				double fHeight0 = (double)bottom / TWIPS_PER_CM;
+
+				double fWidth1 = LwpTools::ConvertFromUnitsToMetric(pMyScale->GetScaleWidth());
+				double fHeight1 = LwpTools::ConvertFromUnitsToMetric(pMyScale->GetScaleHeight());
+
+				double fScaleX = fWidth1 / fWidth0;
+				double fScaleY = fHeight1 / fHeight0;
+				
+				if (nScalemode & LwpLayoutScale::MAINTAIN_ASPECT_RATIO)
+				{
+					m_aTransformData.fScaleX = std::min(fScaleX, fScaleY);
+					m_aTransformData.fScaleY = m_aTransformData.fScaleX;
+				}
+				else
+				{
+					m_aTransformData.fScaleX = fWidth1 / fWidth0;
+					m_aTransformData.fScaleY = fHeight1 / fHeight0;
+				}
+			}
+			
+			// placement: centered
+			if (pMyFrameLayout->GetScaleCenter())
+			{
+				Rectangle aBoundRect(left*m_aTransformData.fScaleX + fLeftMargin,
+					top*m_aTransformData.fScaleY + fTopMargin,
+					right * m_aTransformData.fScaleX,
+					bottom * m_aTransformData.fScaleY);
+				Point aCenter = aBoundRect.Center();
+
+				double fNewCenterX = (double(left)/TWIPS_PER_CM + fFrameWidth/*-fOffsetX*/) / 2;
+				double fNewCenterY = (double(top)/TWIPS_PER_CM + fFrameHeight/*-fOffsetY*/) / 2;
+
+				m_aTransformData.fOffsetX = fNewCenterX - (double)aCenter.X()/TWIPS_PER_CM;
+				m_aTransformData.fOffsetY = fNewCenterY -(double)aCenter.Y()/TWIPS_PER_CM;
+			}
+			else
+			{
+				m_aTransformData.fOffsetX = fOffsetX;
+				m_aTransformData.fOffsetY = fOffsetY;
+			}
+
+			m_aTransformData.fOffsetX += fLeftMargin;
+			m_aTransformData.fOffsetY += fTopMargin;
+			m_aTransformData.fLeftMargin = fLeftMargin;
+			m_aTransformData.fTopMargin = fTopMargin;
+		}
+	}
+	
+	//load draw object
+	for (unsigned short i = 0; i < nRecCount; i++)
+	{
+		XFFrame* pXFDrawObj = this->CreateDrawObject();
+
+		if (pXFDrawObj)
+		{
+			pDrawObjVector->push_back(pXFDrawObj);
+		}
+	}
+}
+
+/**
+ * @descr   when we encounter a group object the function will be called to create a XF-drawgroup object
+ *		the corresponding drawing objects.
+ * @param   pDrawObjVector   a container which will contains the created drawing object of XF-Model.
+ */
+XFDrawGroup* LwpSdwGroupLoaderV0102::CreateDrawGroupObject(void)
+{
+	//flag
+	unsigned char BinSignature[2];
+	m_pStream->Read(BinSignature,2);
+	if (BinSignature[0] != 'S' || BinSignature[1] != 'M')
+	{
+		assert(false);
+		return NULL;
+	}
+	//version
+	unsigned short nVersion;
+	m_pStream->Read(&nVersion,2);
+	if (nVersion<0x0102)
+	{
+		assert(false);
+		return NULL;
+	}
+	// topObj, botObj
+	m_pStream->SeekRel(4); 
+	//record count
+	unsigned short nRecCount;
+	m_pStream->Read(&nRecCount,2); 
+	// selCount
+	m_pStream->SeekRel(2); 
+	//boundrect
+	unsigned short left,top,right,bottom;
+	m_pStream->Read(&left,2); 
+	m_pStream->Read(&top,2); 
+	m_pStream->Read(&right,2); 
+	m_pStream->Read(&bottom,2); 
+	// fileSize
+	m_pStream->SeekRel(2); 
+
+	XFDrawGroup* pXFDrawGroup = new XFDrawGroup();
+	
+	//load draw object
+	for (unsigned short i = 0; i < nRecCount; i++)
+	{
+		XFFrame* pXFDrawObj = this->CreateDrawObject();
+
+		if (pXFDrawObj)
+		{
+			if (pXFDrawObj->GetFrameType() == enumXFFrameImage)
+			{
+				m_pDrawObjVector->push_back(pXFDrawObj);
+			}
+			else
+			{
+				pXFDrawGroup->Add(pXFDrawObj);
+			}
+		}
+	}
+
+	return pXFDrawGroup;
+}
+
+/**
+ * @descr   Create the XF-drawing objects according to the object type read from bento stream.
+ * @return   the created XF-drawing objects.
+ */
+XFFrame* LwpSdwGroupLoaderV0102::CreateDrawObject(void)
+{
+	//record type
+	unsigned char recType;
+	m_pStream->Read(&recType,1); 
+
+	LwpDrawObj* pDrawObj = NULL;
+	XFFrame* pRetObjct = NULL;
+	
+	switch(recType)
+	{
+	case OT_PERPLINE://fall-through
+	case OT_LINE:
+	{
+		pDrawObj = new LwpDrawLine(m_pStream, &m_aTransformData);
+		break;
+	}
+	case OT_POLYLINE:
+	{
+		pDrawObj = new LwpDrawPolyLine(m_pStream, &m_aTransformData);
+		break;
+	}
+	case OT_POLYGON:
+	{
+		pDrawObj = new LwpDrawPolygon(m_pStream, &m_aTransformData);
+		pDrawObj->SetObjectType(OT_POLYGON);
+		break;
+	}
+	case OT_SQUARE://fall-through
+	case OT_RECT:
+	{
+		pDrawObj = new LwpDrawRectangle(m_pStream, &m_aTransformData);
+		break;
+	}
+	case OT_RNDSQUARE://fall-through
+	case OT_RNDRECT:
+	{
+		pDrawObj = new LwpDrawRectangle(m_pStream, &m_aTransformData);
+		pDrawObj->SetObjectType(OT_RNDRECT);
+		break;
+	}
+	case OT_CIRCLE://fall-through
+	case OT_OVAL:
+	{
+		pDrawObj = new LwpDrawEllipse(m_pStream, &m_aTransformData);
+		break;
+	}
+	case OT_ARC:
+	{
+		pDrawObj = new LwpDrawArc(m_pStream, &m_aTransformData);
+		break;
+	}
+	case OT_TEXT:
+	{
+		pDrawObj = new LwpDrawTextBox(m_pStream);
+		break;
+	}
+	case OT_TEXTART:
+	{
+		pDrawObj = new LwpDrawTextArt(m_pStream, &m_aTransformData);
+		pDrawObj->SetObjectType(OT_TEXTART);
+		break;
+	}
+	case OT_GROUP:
+	{
+		m_pStream->SeekRel(2);
+		// read out the object header
+		pDrawObj = new LwpDrawGroup(m_pStream);
+		
+		pRetObjct = this->CreateDrawGroupObject();
+
+		// set anchor type
+		pRetObjct->SetAnchorType(enumXFAnchorFrame);
+		break;
+	}
+	case OT_CHART://fall-through
+	case OT_METAFILE://fall-through
+	case OT_METAFILEIMG:
+	{
+		LwpDrawMetafile aMeta(m_pStream);
+		break;
+	}
+	case OT_BITMAP:
+		pDrawObj = new LwpDrawBitmap(m_pStream);
+		pDrawObj->SetObjectType(OT_BITMAP);
+		break;
+	}
+
+	// we don't need create the corresponding XF-object of a group object.
+	if (pDrawObj && recType != OT_GROUP)
+	{
+		pRetObjct = pDrawObj->CreateXFDrawObject();		
+	}
+
+	if (pDrawObj)
+	{
+		delete pDrawObj;
+		pDrawObj = NULL;
+	}
+	
+	return pRetObjct;
+}
+// end add
diff -urNp lotuswordpro.bak/source/filter/lwpsdwgrouploaderv0102.hxx lotuswordpro/source/filter/lwpsdwgrouploaderv0102.hxx
--- lotuswordpro.bak/source/filter/lwpsdwgrouploaderv0102.hxx	1970-01-01 08:00:00.000000000 +0800
+++ lotuswordpro/source/filter/lwpsdwgrouploaderv0102.hxx	2008-10-22 11:42:29.000000000 +0800
@@ -0,0 +1,95 @@
+/*************************************************************************
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: IBM Corporation
+ *
+ *  Copyright: 2008 by IBM Corporation
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+/*****************************************************************************
+ * Change History
+ * Mar 2005			revised for new processing procedure.
+ * Jan 2005			created
+ ****************************************************************************/
+#include <tools/stream.hxx>
+#include "lwpheader.hxx"
+#include "assert.h"
+#include "xfilter/ixfstream.hxx"
+#include "lwpsdwdrawheader.hxx"
+
+class XFFrame;
+class XFDrawGroup;
+class LwpGraphicObject;
+class LwpSdwGroupLoaderV0102
+{
+private:
+	SvStream* m_pStream;
+	IXFStream* m_pOutputStream;
+	LwpGraphicObject* m_pGraphicObj;
+	std::vector <XFFrame*>* m_pDrawObjVector;
+
+	DrawingOffsetAndScale m_aTransformData;
+	
+public:
+	LwpSdwGroupLoaderV0102(SvStream* pStream, LwpGraphicObject* pGraphicObj, 
+		IXFStream* pOutputStream);
+	~LwpSdwGroupLoaderV0102(void);
+public:
+//	void LoadDrawGroupObject(void);
+//	void LoadDrawObject(void);
+//	void RegisterGroupStyle(void);
+//	void RegisterStyle(void);
+
+	// add by  ,03/25/2005
+	void BeginDrawObjects(std::vector <XFFrame*>* pDrawObjVector);
+	XFDrawGroup* CreateDrawGroupObject(void);
+	XFFrame* CreateDrawObject(void);
+	// end add
+};
+
diff -urNp lotuswordpro.bak/source/filter/lwpsdwrect.cxx lotuswordpro/source/filter/lwpsdwrect.cxx
--- lotuswordpro.bak/source/filter/lwpsdwrect.cxx	1970-01-01 08:00:00.000000000 +0800
+++ lotuswordpro/source/filter/lwpsdwrect.cxx	2008-10-22 11:42:29.000000000 +0800
@@ -0,0 +1,231 @@
+/*************************************************************************
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: IBM Corporation
+ *
+ *  Copyright: 2008 by IBM Corporation
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+/*****************************************************************************
+ * Change History
+ *  Mar 2005			Revised for lwpfilter
+ ****************************************************************************/
+/**
+ * @file 
+ * For LWP filter architecture prototype
+ * Implementation file of SdwRectangle.
+ */
+#include "lwpsdwrect.hxx"
+
+/**************************************************************************
+ * @date:	11/19/2004
+ * @short:	Default constructor
+**************************************************************************/
+SdwRectangle::SdwRectangle() : m_bRotated(sal_False)
+{
+	for (UINT16 i = 0; i < 4; i++)
+	{
+		m_nRectCorner[0] = Point(0, 0);
+	}
+}
+/**************************************************************************
+ * @date:	11/19/2004
+ * @short:	Constructor
+ * @param:	aPt0~aPt3 four corner points of a rectangle.
+**************************************************************************/
+SdwRectangle::SdwRectangle(const Point& rPt0, const Point& rPt1,
+		const Point& rPt2, const Point& rPt3) : m_bRotated(sal_True)
+{
+	m_nRectCorner[0] = rPt0;
+	m_nRectCorner[1] = rPt1;
+	m_nRectCorner[2] = rPt2;
+	m_nRectCorner[3] = rPt3;
+
+	if (rPt0.Y() == rPt1.Y() && rPt0.Y() < rPt3.Y())
+	{
+		m_bRotated = sal_False;
+	}
+}
+
+/**************************************************************************
+ * @date:	12/15/2004
+ * @short:	Copy constructor
+**************************************************************************/
+SdwRectangle::SdwRectangle(const SdwRectangle& rOther)
+{
+	m_nRectCorner[0] = rOther.m_nRectCorner[0];
+	m_nRectCorner[1] = rOther.m_nRectCorner[1];
+	m_nRectCorner[2] = rOther.m_nRectCorner[2];
+	m_nRectCorner[3] = rOther.m_nRectCorner[3];
+
+	m_bRotated  = rOther.IsRectRotated();
+}
+/**************************************************************************
+ * @date:	11/19/2004
+ * @short:	Destructor
+**************************************************************************/
+SdwRectangle::~SdwRectangle()
+{
+}
+/**************************************************************************
+ * @date:	11/19/2004
+ * @short:	Get the flag whether if the rectangle has been rotated.
+ * @return:	m_bRotated rotation flag.
+**************************************************************************/
+sal_Bool SdwRectangle::IsRectRotated() const
+{
+	return m_bRotated;
+}
+/**************************************************************************
+ * @date:	11/19/2004
+ * @short:	Calculate and return center point of the rectangle.
+ * @return:	center point
+**************************************************************************/
+Point SdwRectangle::GetRectCenter() const
+{
+	long nX = (long)((double)(m_nRectCorner[0].X() + m_nRectCorner[2].X())/2 + 0.5);
+	long nY = (long)((double)(m_nRectCorner[0].Y() + m_nRectCorner[2].Y())/2 + 0.5);
+	
+	return Point(nX, nY);
+}
+/**************************************************************************
+ * @date:	11/19/2004
+ * @short:	Calculate width of the rectangle.
+ * @return:	rectangle width.
+**************************************************************************/
+long SdwRectangle::GetWidth() const
+{
+	long nX0 = m_nRectCorner[0].X();
+	long nY0 = m_nRectCorner[0].Y();
+	long nX1 = m_nRectCorner[1].X();
+	long nY1 = m_nRectCorner[1].Y();
+	
+	return (long)CalcDistBetween2Points(nX0, nY0, nX1, nY1);
+}
+/**************************************************************************
+ * @date:	11/19/2004
+ * @short:	Calculate height of the rectangle.
+ * @return:	rectangle height.
+**************************************************************************/
+long SdwRectangle::GetHeight() const
+{
+	long nX1 = m_nRectCorner[1].X();
+	long nY1 = m_nRectCorner[1].Y();
+	long nX2 = m_nRectCorner[2].X();
+	long nY2 = m_nRectCorner[2].Y();
+	
+	return (long)CalcDistBetween2Points(nX1, nY1, nX2, nY2);
+}
+/**************************************************************************
+ * @date:	11/19/2004
+ * @short:	Calculate coordinate of the original rectangle.
+ * @return:	a prz rectangle
+**************************************************************************/
+Rectangle SdwRectangle::GetOriginalRect() const
+{
+	if (m_bRotated)
+	{
+		long nHeight = GetHeight();
+		long nWidth = GetWidth();
+		Point aCenter = GetRectCenter();
+
+		Point aLT(aCenter.X()-(long)((double)nWidth/2+0.5),
+			aCenter.Y()-(long)((double)nHeight/2+0.5));
+		Point aRT(aLT.X()+nWidth, aLT.Y());
+		Point aLB(aLT.X(), aLT.Y()-nHeight);
+		Point aRB(aLT.X()+nWidth, aLT.Y()+nHeight);
+
+		return Rectangle(aLT, aRB);
+	}
+	else
+	{
+		return Rectangle(m_nRectCorner[3], m_nRectCorner[1]);
+	}
+}
+/**************************************************************************
+ * @date:	11/19/2004
+ * @short:	Calculate rotation angle of the rectangle.
+ * @return:	rotation angle.
+**************************************************************************/
+double SdwRectangle::GetRotationAngle() const
+{
+	if (!m_bRotated)
+	{
+		return 0.00;
+	}
+	
+	double fX1 = (double)(m_nRectCorner[1].X());
+	double fY1 = (double)(m_nRectCorner[1].Y());
+	double fX2 = (double)(m_nRectCorner[2].X());
+	double fY2 = (double)(m_nRectCorner[2].Y());
+	double fMidX = (fX1 + fX2) / 2;
+	double fMidY = (fY1 + fY2) / 2;
+
+	Point aCenter = GetRectCenter();
+	double fCenterX = (double)aCenter.X();
+	double fCenterY = (double)aCenter.Y();
+
+	double fAngle = atan2((fMidY - fCenterY), (fMidX - fCenterX));
+
+	return -fAngle;
+}
+
+double SdwRectangle::CalcDistBetween2Points(long nX1, long nY1, long nX2, long nY2)
+{
+	return sqrt((double)((nX1-nX2)*(nX1-nX2) + (nY1-nY2)*(nY1-nY2)));
+}
+
+Rectangle SdwRectangle::GetOriginalRect(const Point& rCenter, long nHalfWidth, long nHalfHeight)
+{
+	Point aLT(rCenter.X()-nHalfWidth, rCenter.Y()-nHalfHeight);
+	Point aRB(rCenter.X()+nHalfWidth, rCenter.Y()+nHalfHeight);
+
+	return Rectangle(aLT, aRB);
+}
+
diff -urNp lotuswordpro.bak/source/filter/lwpsdwrect.hxx lotuswordpro/source/filter/lwpsdwrect.hxx
--- lotuswordpro.bak/source/filter/lwpsdwrect.hxx	1970-01-01 08:00:00.000000000 +0800
+++ lotuswordpro/source/filter/lwpsdwrect.hxx	2008-10-22 11:42:29.000000000 +0800
@@ -0,0 +1,128 @@
+/*************************************************************************
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: IBM Corporation
+ *
+ *  Copyright: 2008 by IBM Corporation
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+/*****************************************************************************
+ * Change History
+ *  Mar 2005			Revised for lwpfilter
+ ****************************************************************************/
+/**
+ * @file 
+ * For LWP filter architecture prototype
+ * Implementation file of SdwRectangle.
+ */
+#ifndef _SDWRECTANGLE_HXX
+#define _SDWRECTANGLE_HXX
+
+#include "lwpheader.hxx"
+#include <tools/gen.hxx>
+
+/**
+ * @brief
+ *   SdwRectangle: Not like rectangle in SODC, rectagles in Word Pro are
+ * defined by 4 points. So they can be any posture in the two-dimensional
+ * coordinate system. The class is used to describ such rectangles.
+ *	 The foure corner points must be save in menber variable:m_nRectCorner
+ * one after another. We assume the input order(the same order in .lwp files)
+ * is as below:
+ *
+ * y ^     m_nRectCorner[3]             m_nRectCorner[2]
+ *   |                 |--------------------|
+ *   |                 |                    |
+ *   |                 |                    |
+ *   |                 |--------------------|
+ *   |     m_nRectCorner[0]             m_nRectCorner[1]
+ *   |
+ *   |------------------------------------------------------->
+ * (0,0)                                                     x
+ *
+ */
+class SdwRectangle
+{
+private:
+	sal_Bool m_bRotated;
+
+public:
+	Point m_nRectCorner[4];
+
+public:
+	
+	SdwRectangle();
+
+	SdwRectangle(const Point& rPt0, const Point& rPt1,
+		const Point& rPt2, const Point& rPt3);
+
+	SdwRectangle(const SdwRectangle& rOther);
+
+	~SdwRectangle();
+
+public:
+	sal_Bool IsRectRotated() const;
+
+	Point GetRectCenter() const ;
+
+	long GetWidth() const;
+
+	long GetHeight() const;
+
+	Rectangle GetOriginalRect() const;
+
+	double GetRotationAngle() const;
+
+	static double CalcDistBetween2Points(long nX1, long nY1, long nX2, long nY2);
+
+	static Rectangle GetOriginalRect(const Point& rCenter, long nHalfWidth, long nHalfHeight);
+
+};
+
+#endif
diff -urNp lotuswordpro.bak/source/filter/lwpsection.cxx lotuswordpro/source/filter/lwpsection.cxx
--- lotuswordpro.bak/source/filter/lwpsection.cxx	1970-01-01 08:00:00.000000000 +0800
+++ lotuswordpro/source/filter/lwpsection.cxx	2008-10-22 11:42:29.000000000 +0800
@@ -0,0 +1,156 @@
+/*************************************************************************
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: IBM Corporation
+ *
+ *  Copyright: 2008 by IBM Corporation
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+/*************************************************************************
+ * @file 
+ *  For LWP filter architecture prototype
+ ************************************************************************/
+/*************************************************************************
+ * Change History
+ Jan 2005			Created
+ ************************************************************************/
+
+#include "lwpcolor.hxx"
+#include "lwpatomholder.hxx"
+#include "lwplayout.hxx"
+#include "lwpdlvlist.hxx"
+#include "lwpobj.hxx"
+#include "lwpsection.hxx"
+#include "xfilter/xfsection.hxx"
+
+LwpOrderedObject::LwpOrderedObject(LwpObjectHeader &objHdr, LwpSvStream* pStrm)
+	: LwpDLNFVList(objHdr, pStrm)
+{}
+
+/**
+ * @descr: read object information
+ * 		
+ */
+void LwpOrderedObject::Read()	
+{
+	LwpDLNFVList::Read();
+	
+	m_ListList.ReadIndexed(m_pObjStrm);
+	m_Para.ReadIndexed(m_pObjStrm);
+	m_pObjStrm->SkipExtra();
+}
+
+LwpSection::LwpSection(LwpObjectHeader &objHdr, LwpSvStream *pStrm)
+	: LwpOrderedObject(objHdr, pStrm)
+{}
+
+LwpSection::~LwpSection()
+{
+	
+}
+
+/**
+ * @descr: read object information
+ * 		
+ */
+void LwpSection::Read()
+{
+	LwpOrderedObject::Read();
+	m_pObjStrm->QuickRead(&m_Flags, sizeof(m_Flags));
+	m_PageLayout.ReadIndexed(m_pObjStrm);
+	m_Color.Read(m_pObjStrm);
+	m_AtomHolder.Read(m_pObjStrm);
+	m_pObjStrm->SkipExtra();
+}
+
+/**
+ * @descr: do nothing
+ * 		
+ */
+void LwpSection::Parse(IXFStream *pOutputStream)
+{
+	
+}
+
+LwpIndexSection::LwpIndexSection(LwpObjectHeader &objHdr, LwpSvStream *pStrm)
+	: LwpSection(objHdr, pStrm)
+{}
+
+LwpIndexSection::~LwpIndexSection()
+{	
+}
+
+/**
+ * @descr: read object information
+ * 		
+ */
+void LwpIndexSection::Read()
+{
+	LwpSection::Read();
+	m_TextMarker.Read(m_pObjStrm);
+	m_ParentName.Read(m_pObjStrm);
+	m_DivisionName.Read(m_pObjStrm);
+	m_SectionName.Read(m_pObjStrm);		
+	m_pObjStrm->QuickRead(&m_nForm, sizeof(m_nForm));
+	m_pObjStrm->QuickRead(&m_nFlags, sizeof(m_nFlags));
+	m_pObjStrm->SkipExtra();
+}
+
+sal_Bool LwpIndexSection::IsFormatRunin()
+{
+	return (m_nFlags & RUN_IN);
+		
+}
+
+sal_Bool LwpIndexSection::IsFormatSeparator()
+{
+	return (m_nFlags & SEPARATORS);
+		
+}
+
diff -urNp lotuswordpro.bak/source/filter/lwpsection.hxx lotuswordpro/source/filter/lwpsection.hxx
--- lotuswordpro.bak/source/filter/lwpsection.hxx	1970-01-01 08:00:00.000000000 +0800
+++ lotuswordpro/source/filter/lwpsection.hxx	2008-10-22 11:42:29.000000000 +0800
@@ -0,0 +1,172 @@
+/*************************************************************************
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: IBM Corporation
+ *
+ *  Copyright: 2008 by IBM Corporation
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+/*************************************************************************
+ * @file 
+ *  For LWP filter architecture prototype
+ ************************************************************************/
+/*************************************************************************
+ * Change History
+ Jan 2005			Created
+ ************************************************************************/
+
+#ifndef _LWPSECTION_HXX
+#define _LWPSECTION_HXX
+#include "lwppagelayout.hxx"
+
+/**
+ * @brief		COrderedObject class in .lwp file
+ * 
+ */
+class LwpDLNFVList;
+class LwpOrderedObject : public LwpDLNFVList
+{
+public:
+	LwpOrderedObject(LwpObjectHeader &objHdr, LwpSvStream* pStrm);
+	virtual ~LwpOrderedObject(){};
+	void Read();	
+	LwpObjectID* GetPosition(){ return &m_Para;};
+	LwpObjectID* GetListList(){ return &m_ListList;};
+protected:
+	LwpObjectID m_ListList;//lwplistlist object, 
+	LwpObjectID m_Para;	
+};
+
+/**
+ * @brief		VO_SECTION object in .lwp file  
+ * 
+ */
+class LwpColor;
+class LwpAtomHolder;
+class LwpSection : public LwpOrderedObject
+{
+public:
+	LwpSection(LwpObjectHeader &objHdr, LwpSvStream* pStrm);	
+	~LwpSection();
+	inline sal_uInt16 GetFlags();
+	inline LwpPageLayout* GetPageLayout();
+	inline LwpColor* GetColor();
+	inline LwpAtomHolder* GetAtomHolder();
+	void Parse(IXFStream* pOutputStream);
+	OUString GetSectionName(){return m_AtomHolder.str();}
+
+protected:
+	void Read();
+private:
+	sal_uInt16 m_Flags;
+	LwpObjectID m_PageLayout;
+	LwpColor m_Color;
+	LwpAtomHolder m_AtomHolder;
+	
+};
+
+/**
+ * @descr Get flage value
+ * 		
+ */
+inline sal_uInt16 LwpSection::GetFlags()
+{
+	return m_Flags;
+}
+
+/**
+ * @descr Get page layout pointer
+ * 		
+ */
+inline LwpPageLayout* LwpSection::GetPageLayout()
+{
+	return static_cast<LwpPageLayout*>(m_PageLayout.obj());
+}
+
+/**
+ * @descr get section tab color
+ * 		
+ */
+inline LwpColor* LwpSection::GetColor()
+{
+	return &m_Color;
+}
+
+/**
+ * @descr get section atom holder pointer
+ * 		
+ */
+inline LwpAtomHolder* LwpSection::GetAtomHolder()
+{
+	return &m_AtomHolder;
+}
+
+
+class LwpIndexSection : public LwpSection
+{
+public:
+	LwpIndexSection(LwpObjectHeader &objHdr, LwpSvStream* pStrm);	
+	~LwpIndexSection();
+	sal_Bool IsFormatRunin();
+	sal_Bool IsFormatSeparator();
+protected:
+	void Read();
+private:
+	enum{
+		SEPARATORS = 0x01,
+		RUN_IN = 0X02,
+		};
+	LwpAtomHolder m_TextMarker;
+	LwpAtomHolder m_ParentName;
+	LwpAtomHolder m_DivisionName;
+	LwpAtomHolder m_SectionName;	
+	sal_uInt16 m_nForm;
+	sal_uInt16 m_nFlags;
+};
+#endif
diff -urNp lotuswordpro.bak/source/filter/lwpshadow.hxx lotuswordpro/source/filter/lwpshadow.hxx
--- lotuswordpro.bak/source/filter/lwpshadow.hxx	1970-01-01 08:00:00.000000000 +0800
+++ lotuswordpro/source/filter/lwpshadow.hxx	2008-10-22 11:42:29.000000000 +0800
@@ -0,0 +1,121 @@
+/*************************************************************************
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: IBM Corporation
+ *
+ *  Copyright: 2008 by IBM Corporation
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+/*************************************************************************
+ * @file 
+ *  For LWP filter architecture prototype
+ ************************************************************************/
+/*************************************************************************
+ * Change History
+ * 2005-01-13	Created
+ ************************************************************************/
+#ifndef		_LWPSHADOW_HXX
+#define		_LWPSHADOW_HXX
+
+#include	"lwpcolor.hxx"
+#include	"lwptools.hxx"
+
+class LwpShadow
+{
+public:
+	LwpShadow():m_nDirX(0),m_nDirY(0){}
+public:
+	void Read(LwpObjectStream *pStrm)
+	{
+		m_aColor.Read(pStrm);
+		pStrm->QuickRead(&m_nDirX, sizeof(m_nDirX));
+		pStrm->QuickRead(&m_nDirY, sizeof(m_nDirY));
+		pStrm->SkipExtra();
+	}
+
+	double	GetOffsetX();
+
+	double	GetOffsetY();
+
+	LwpColor GetColor();
+
+	//add by , 01/26/2005
+	inline void operator = (const LwpShadow& rOther);
+	//end add
+	
+private:
+	LwpColor		m_aColor;
+	sal_Int32		m_nDirX;
+	sal_Int32		m_nDirY;
+};
+
+inline double	LwpShadow::GetOffsetX()
+{
+	//	return 0.102;
+	return LwpTools::ConvertFromUnitsToMetric(m_nDirX);
+}
+
+inline double	LwpShadow::GetOffsetY()
+{
+	return LwpTools::ConvertFromUnitsToMetric(m_nDirY);
+}
+
+inline LwpColor LwpShadow::GetColor()
+{
+	return m_aColor;
+}
+
+inline void LwpShadow::operator = (const LwpShadow& rOther)
+{
+	m_aColor = rOther.m_aColor;
+	m_nDirX = rOther.m_nDirX;
+	m_nDirY = rOther.m_nDirY;
+}
+#endif
+
diff -urNp lotuswordpro.bak/source/filter/lwpsilverbullet.cxx lotuswordpro/source/filter/lwpsilverbullet.cxx
--- lotuswordpro.bak/source/filter/lwpsilverbullet.cxx	1970-01-01 08:00:00.000000000 +0800
+++ lotuswordpro/source/filter/lwpsilverbullet.cxx	2008-10-22 11:42:29.000000000 +0800
@@ -0,0 +1,486 @@
+/*************************************************************************
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: IBM Corporation
+ *
+ *  Copyright: 2008 by IBM Corporation
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+/*************************************************************************
+ * @file 
+ *  For LWP filter architecture prototype
+ ************************************************************************/
+/*************************************************************************
+ * Change History
+ Jan 2005			Created
+ ************************************************************************/
+#include "lwpglobalmgr.hxx" 
+#include "lwpsilverbullet.hxx"
+#include "lwpdoc.hxx"
+#include "lwpdivinfo.hxx"
+#include "lwpfoundry.hxx"
+#include "lwpstory.hxx"
+#include "lwppara.hxx"
+#include "xfilter/xfliststyle.hxx"
+#include "xfilter/xfstylemanager.hxx"
+
+LwpSilverBullet::LwpSilverBullet(LwpObjectHeader& objHdr, LwpSvStream* pStrm)
+	: LwpDLNFVList(objHdr, pStrm), m_pAtomHolder(new LwpAtomHolder), m_pBulletPara(NULL)
+{
+}
+
+LwpSilverBullet::~LwpSilverBullet()
+{
+	if (m_pAtomHolder)
+	{
+		delete m_pAtomHolder;
+	}
+}
+
+void LwpSilverBullet::Read()
+{
+	LwpDLNFVList::Read();
+
+	m_pObjStrm->QuickRead(&m_nFlags, 2);
+	m_aStory.ReadIndexed(m_pObjStrm);
+
+	sal_uInt16 nNumPos;
+	m_pObjStrm->QuickRead(&nNumPos, 2);
+
+	for (sal_uInt8 nC = 0; nC < nNumPos; nC++)
+	{
+		m_pObjStrm->QuickRead(&m_pResetPositionFlags[nC], 1);
+	}
+
+	m_pObjStrm->QuickRead(&m_nUseCount, 4);
+
+	m_pAtomHolder->Read(m_pObjStrm);
+}
+
+/**
+ * @short:   Register bullet or numbering style-list and store the returned
+ *			name from XFStyleManager.
+ * @descr:
+ */
+void LwpSilverBullet::RegisterStyle()
+{
+	XFListStyle* pListStyle = new XFListStyle();
+	XFStyleManager* pXFStyleManager = LwpGlobalMgr::GetInstance()->GetXFStyleManager(); 
+
+	this->GetBulletPara();
+		
+	if (this->IsBulletOrdered() && this->HasName())
+	{
+		ParaNumbering aParaNumbering;
+		XFNumFmt aFmt;
+
+		//todo: find the flag in the file
+		sal_Bool bCumulative = sal_False;		
+
+		//get the numbeing format of level-1
+		m_pBulletPara->GetParaNumber(1, &aParaNumbering);
+		if (aParaNumbering.pPrefix)
+		{
+			aFmt.SetPrefix(aParaNumbering.pPrefix->GetText());
+		}
+
+		
+		for (sal_uInt8 nPos = 1; nPos < 10; nPos++)
+		{
+			//get numbering format according to the position.
+			m_pBulletPara->GetParaNumber(nPos, &aParaNumbering);
+			LwpFribParaNumber* pParaNumber = aParaNumbering.pParaNumber;
+			if (pParaNumber)
+			{
+				if (pParaNumber->GetStyleID() != NUMCHAR_other)
+				{
+					m_pHideLevels[nPos] = aParaNumbering.nNumLevel;
+					sal_uInt16 nDisplayLevel = this->GetDisplayLevel(nPos);
+					bCumulative = (sal_Bool)(nDisplayLevel > 1);
+					rtl::OUString aPrefix = this->GetAdditionalName(nPos);
+					
+					XFNumFmt aFmt;
+					if (!bCumulative && aParaNumbering.pPrefix)
+					{
+						aFmt.SetPrefix(aPrefix + aParaNumbering.pPrefix->GetText());
+					}
+
+					aFmt.SetFormat(this->GetNumCharByStyleID(pParaNumber));
+					
+					if (aParaNumbering.pSuffix)
+					{
+						aFmt.SetSuffix(aParaNumbering.pSuffix->GetText());
+					}
+
+					//set numbering format into the style-list.
+					pListStyle->SetListNumber(nPos, aFmt, pParaNumber->GetStart()+1);
+
+					if (bCumulative && nPos > 1)
+					{
+						pListStyle->SetDisplayLevel(nPos, nDisplayLevel);
+					}
+
+				}
+				else
+				{
+					rtl::OUString aPrefix, aSuffix;
+					if (aParaNumbering.pPrefix)
+					{
+						aPrefix = aParaNumbering.pPrefix->GetText();
+					}
+					if (aParaNumbering.pSuffix)
+					{
+						aSuffix = aParaNumbering.pSuffix->GetText();
+					}
+
+					pListStyle->SetListBullet(nPos, this->GetNumCharByStyleID(pParaNumber).toChar(), 
+						rtl::OUString::createFromAscii("Times New Roman"), aPrefix, aSuffix);
+				}
+
+				pListStyle->SetListPosition(nPos, 0.0, 0.635, 0.0);
+				aParaNumbering.clear();
+			}
+		}
+	}
+	else
+	{
+		//register bullet style-list
+/*		for (sal_uInt8 nC = 1; nC < 11; nC++)
+		{
+			pListStyle->SetListBullet(nC, this->GetBulletChar(), this->GetBulletFontName(),
+				this->GetPrefix(), this->GetSuffix());
+			pListStyle->SetListPosition(nC, 0.0, 0.635, 0.0);
+		}*/
+
+	}
+	
+	//add style-list to style manager.
+	m_strStyleName = pXFStyleManager->AddStyle(pListStyle)->GetStyleName();
+}
+
+/**
+ * @short:   Get the font name of the bullet.
+ * @descr:
+ * @return:  Font name of the bullet.
+ */
+rtl::OUString LwpSilverBullet::GetBulletFontName()
+{
+	//foundry has been set?
+	if (!m_pFoundry)
+	{
+		return rtl::OUString::createFromAscii("");
+	}
+
+	LwpFontManager* pFontMgr = m_pFoundry->GetFontManger();
+	if (!pFontMgr)
+	{
+		return rtl::OUString::createFromAscii("");
+	}
+
+	sal_uInt32 nBulletFontID = m_pBulletPara->GetBulletFontID();
+	sal_uInt16 nFinalFont = static_cast<sal_uInt16>((nBulletFontID >> 16) & 0xFFFF);
+	
+	//final fontid is valid?
+	if (nFinalFont > 255 || nFinalFont == 0)
+	{
+		return rtl::OUString::createFromAscii("");
+	}
+
+	//get font name from font manager.
+	rtl::OUString aFontName = pFontMgr->GetNameByID(nBulletFontID);
+
+	return aFontName;
+}
+/**
+ * @short:   Get bullet character of the bullet vo_para.
+ * @descr:
+ * @return:  An UChar32 bulle character.
+ */
+UChar32 LwpSilverBullet::GetBulletChar()
+{
+	rtl::OUString aBulletChar = m_pBulletPara->GetBulletChar();
+
+	return aBulletChar.toChar();
+}
+
+rtl::OUString LwpSilverBullet::GetPrefix()
+{
+	return rtl::OUString::createFromAscii("");
+}
+
+rtl::OUString LwpSilverBullet::GetSuffix()
+{
+	return rtl::OUString::createFromAscii("");
+}
+/**
+ * @short:   Get the LwpPara object through story id.
+ */
+LwpPara* LwpSilverBullet::GetBulletPara()
+{
+	if (!m_pBulletPara)
+	{
+		LwpStory* pStory = static_cast<LwpStory*>(m_aStory.obj(VO_STORY));
+		if (!pStory)
+		{	
+			return NULL;
+		}
+
+		m_pBulletPara = static_cast<LwpPara*>(pStory->GetFirstPara()->obj(VO_PARA));
+	}
+
+	return m_pBulletPara;
+}
+
+/**
+ * @short:   Get numbering character of the bullet vo_para.
+ * @descr:
+ * @param:   pParaNumber a pionter to the structure LwpFribParaNumber which
+ *			includes numbering prefix, format and suffix.
+ * @return:  An OUString object which store the numbering character.
+ */
+rtl::OUString LwpSilverBullet::GetNumCharByStyleID(LwpFribParaNumber* pParaNumber)
+{
+	if (!pParaNumber)
+	{
+		assert(false);
+		return rtl::OUString::createFromAscii("");
+	}
+	
+	rtl::OUString strNumChar = rtl::OUString::createFromAscii("1");
+	sal_uInt16 nStyleID = pParaNumber->GetStyleID();
+	UChar32 uC = 0x0000;
+	
+	switch (nStyleID)
+	{
+	case NUMCHAR_1:
+	case NUMCHAR_01:
+	case NUMCHAR_Chinese4:
+		strNumChar =  rtl::OUString::createFromAscii("1");
+		break;
+	case NUMCHAR_A :
+		strNumChar =  rtl::OUString::createFromAscii("A");
+		break;
+	case NUMCHAR_a:
+		strNumChar = rtl::OUString::createFromAscii("a");
+		break;
+	case NUMCHAR_I:
+		strNumChar = rtl::OUString::createFromAscii("I");
+		break;
+	case NUMCHAR_i:
+		strNumChar = rtl::OUString::createFromAscii("i");
+		break;
+	case NUMCHAR_other:
+		uC = static_cast<UChar32>(pParaNumber->GetNumberChar());
+		strNumChar = rtl::OUString(uC);
+		break;
+	case NUMCHAR_Chinese1:
+		{
+		sal_Unicode sBuf[13] = {0x58f9,0x002c,0x0020,0x8d30,0x002c,0x0020,0x53c1,0x002c,0x0020,0x002e,0x002e,0x002e,0x0};
+		strNumChar = rtl::OUString(sBuf);	
+		}
+		break;
+	case NUMCHAR_Chinese2:
+		{
+		sal_Unicode sBuf[13] = {0x4e00,0x002c,0x0020,0x4e8c,0x002c,0x0020,0x4e09,0x002c,0x0020,0x002e,0x002e,0x002e,0x0};
+		strNumChar = rtl::OUString(sBuf);	
+		}
+		break;
+	case NUMCHAR_Chinese3:
+		{
+		sal_Unicode sBuf[13] = {0x7532,0x002c,0x0020,0x4e59,0x002c,0x0020,0x4e19,0x002c,0x0020,0x002e,0x002e,0x002e,0x0};
+		strNumChar = rtl::OUString(sBuf);	
+		}		
+		break;
+	case NUMCHAR_none:
+		strNumChar = rtl::OUString::createFromAscii("");
+		break;
+	default:
+		break;
+	}//mod end
+	return strNumChar;
+}
+
+/**
+ * @short:   To judge the silverbullet list is ordered or not.
+ * @descr:
+ * @return:  sal_True if list is ordered, sal_False if list is unordered.
+ */
+sal_Bool LwpSilverBullet::IsBulletOrdered()
+{
+	return (sal_Bool)(m_pBulletPara->GetFribs()->HasFrib(FRIB_TAG_PARANUMBER) != NULL);
+}
+
+/**
+ * @short:   Calculate the displaylevel according to the position and hidelevels.
+ * @descr:
+ * @param:   nPos position of the numbering.
+ * @return:  displaylevel of the position passed in.
+ */
+sal_uInt16 LwpSilverBullet::GetDisplayLevel(sal_uInt8 nPos)
+{
+	if (nPos > 1)
+	{
+		sal_uInt16 nHideBit = (1 << nPos);
+		for (sal_uInt8 nC = nPos-1; nC > 0; nC--)
+		{
+			sal_uInt16 nAttrMask = ~m_pHideLevels[nC];
+			if (!(nAttrMask & nHideBit))
+			{
+				return static_cast<sal_uInt16>(nPos - nC);
+			}
+		}
+	}
+	
+	return static_cast<sal_uInt16>(nPos);
+}
+
+/**
+ * @descr:   Get the additional information, "Division name" or "Section Name" from document 
+ *		variable frib according to numbering position. Whether we should add a
+ *		Division/Section name or not is determined by the hidelevels of the frib.
+ * @param:   nPos position of the numbering.
+ * @return:  Division or Section name.
+ */
+rtl::OUString LwpSilverBullet::GetAdditionalName(sal_uInt8 nPos)
+{
+	rtl::OUString aRet = rtl::OUString::createFromAscii("");
+	sal_uInt16 nHideBit = (1 << nPos);
+	sal_Bool bDivisionName = sal_False;
+	sal_Bool bSectionName = sal_False;
+	
+	LwpFrib* pParaFrib = m_pBulletPara->GetFribs()->GetFribs();
+	if (!pParaFrib)
+	{
+		return rtl::OUString::createFromAscii("");
+	}
+
+	while (pParaFrib)
+	{
+		if (pParaFrib->GetType() == FRIB_TAG_DOCVAR)
+		{
+			ModifierInfo* pMoInfo = pParaFrib->GetModifiers();
+			if (!pMoInfo)
+			{
+				return rtl::OUString::createFromAscii("");
+			}
+			sal_uInt16 nHideLevels = pMoInfo->aTxtAttrOverride.GetHideLevels();
+			sal_uInt16 nType = static_cast<LwpFribDocVar*>(pParaFrib)->GetType();
+
+			if (~nHideLevels & nHideBit)
+			{
+				if (nType == 0x000D)
+				{
+					bDivisionName = sal_True;
+				}
+				else if (nType == 0x000E)
+				{
+					bSectionName= sal_True;
+				}
+			}
+		}
+		pParaFrib = pParaFrib->GetNext();
+	}
+
+	if (bDivisionName)
+	{
+		aRet += this->GetDivisionName();
+	}
+	if (bSectionName)
+	{
+		aRet += this->GetSectionName();
+	}
+
+	return aRet;
+}
+
+rtl::OUString LwpSilverBullet::GetDivisionName()
+{
+	if (!m_pFoundry)
+	{
+		return rtl::OUString::createFromAscii("");
+	}
+
+	rtl::OUString aRet = rtl::OUString::createFromAscii("");
+	
+	LwpDocument* pDoc = m_pFoundry->GetDocument();
+	if (pDoc)
+	{
+		LwpObjectID* pID = pDoc->GetDivInfoID();
+		if (!pID->IsNull())
+		{
+			aRet = static_cast<LwpDivInfo*>(pID->obj(VO_DIVISIONINFO))->GetDivName();
+		}
+	}
+
+	return aRet;
+}
+
+rtl::OUString LwpSilverBullet::GetSectionName()
+{
+	LwpStory* pStory = static_cast<LwpStory*>(m_aStory.obj(VO_STORY));
+	if (!pStory)
+	{	
+		return rtl::OUString::createFromAscii("");
+	}
+
+	return pStory->GetSectionName();
+}
+
+sal_Bool LwpSilverBullet::HasName()
+{
+	LwpAtomHolder* pName = this->GetName();
+	if (pName)
+	{
+		return (sal_Bool)(pName->str().getLength() != 0);
+	}
+	else
+	{
+		return sal_False;
+	}
+}
\ No newline at end of file
diff -urNp lotuswordpro.bak/source/filter/lwpsilverbullet.hxx lotuswordpro/source/filter/lwpsilverbullet.hxx
--- lotuswordpro.bak/source/filter/lwpsilverbullet.hxx	1970-01-01 08:00:00.000000000 +0800
+++ lotuswordpro/source/filter/lwpsilverbullet.hxx	2008-10-22 11:42:29.000000000 +0800
@@ -0,0 +1,189 @@
+/*************************************************************************
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: IBM Corporation
+ *
+ *  Copyright: 2008 by IBM Corporation
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+/*************************************************************************
+ * @file 
+ *  For LWP filter architecture prototype
+ ************************************************************************/
+/*************************************************************************
+ * Change History
+ Jan 2005			Created
+ ************************************************************************/
+ 
+#ifndef _LWPSILVERBULLET_HXX
+#define _LWPSILVERBULLET_HXX
+
+#include "lwpheader.hxx"
+#include "lwpobj.hxx"
+#include "lwpdlvlist.hxx"
+#include "lwpobjid.hxx"
+#include "lwpatomholder.hxx"
+//Added by yanjun for SS merge: 2007-12-21
+#include	"unicode/utypes.h"
+//End
+const sal_uInt16 MAXNUMBERPOSITIONS = 10; //max number of positions
+const sal_uInt16 NUMCHAR_none = 0x00;	//none of numberchar
+const sal_uInt16 NUMCHAR_1 = 0x01;		//index for numberchar "1"
+const sal_uInt16 NUMCHAR_A = 0x02;		//index for numberchar "A"
+const sal_uInt16 NUMCHAR_a = 0x03;		//index for numberchar "a"
+const sal_uInt16 NUMCHAR_I = 0x04;		//index for numberchar "I"
+const sal_uInt16 NUMCHAR_i = 0x05;		//index for numberchar "i"
+const sal_uInt16 NUMCHAR_other= 0x06;	//index for numberchar "other"
+const sal_uInt16 NUMCHAR_01 = 0x0B;		//index for numberchar "01"
+
+const sal_uInt16 NUMCHAR_Chinese1 = 0x09;		//index for numberchar ""
+const sal_uInt16 NUMCHAR_Chinese2 = 0x08;		//index for numberchar ""
+const sal_uInt16 NUMCHAR_Chinese3= 0x0A;	//index for numberchar ""
+const sal_uInt16 NUMCHAR_Chinese4 = 0x13;		//index for numberchar "01" in chinese version
+//add end
+
+class LwpStory;
+class LwpAtomHolder;
+class LwpPara;
+class LwpFribParaNumber;
+
+class LwpSilverBullet : public LwpDLNFVList
+{
+public:
+	LwpSilverBullet(LwpObjectHeader& objHdr, LwpSvStream* pStrm);
+
+	virtual ~LwpSilverBullet();
+
+	virtual void RegisterStyle();
+
+	void Read();
+	
+	sal_Bool IsBulletOrdered();
+
+	rtl::OUString GetBulletFontName();
+
+	inline rtl::OUString GetBulletStyleName() const;
+
+	UChar32 GetBulletChar();
+
+	rtl::OUString GetPrefix();
+
+	rtl::OUString GetSuffix();
+
+	inline rtl::OUString GetNumberingName();
+
+	inline LwpPara* GetNumberingPara();
+
+	sal_Bool HasName();
+
+	static rtl::OUString GetNumCharByStyleID(LwpFribParaNumber* pParaNumber);
+
+	inline sal_Bool IsPosCumulative(sal_uInt16 nHideLevels);
+	inline sal_Bool IsLesserLevel(sal_uInt16 nPos);
+	inline sal_Bool IsNewSection(sal_uInt16 nPos);
+	
+	LwpPara* GetBulletPara();
+
+	sal_uInt16 GetDisplayLevel(sal_uInt8 nPos);
+
+	rtl::OUString GetAdditionalName(sal_uInt8 nPos);
+
+	rtl::OUString GetDivisionName();
+
+	rtl::OUString GetSectionName();
+	
+private:
+	sal_uInt16		m_nFlags;
+	LwpObjectID		m_aStory;
+	sal_uInt8		m_pResetPositionFlags[MAXNUMBERPOSITIONS];
+	sal_uInt32		m_nUseCount;
+	LwpAtomHolder*	m_pAtomHolder;
+
+	LwpPara* m_pBulletPara;
+	rtl::OUString m_strStyleName;
+	sal_uInt16 m_pHideLevels[10];
+
+private:
+	enum	// For m_pResetPositionFlags
+	{
+		LESSERLEVEL		= 0x01,
+		LESSERSPECIFIC	= 0x02,
+		NEWDIVISION		= 0x04,
+		NEWSECTION		= 0x08,
+		CUMULATIVE		= 0x10
+	};
+};
+inline rtl::OUString LwpSilverBullet::GetBulletStyleName() const
+{
+	return m_strStyleName;
+}
+
+inline rtl::OUString LwpSilverBullet::GetNumberingName()
+{
+	return GetName()->str();
+}
+inline LwpPara* LwpSilverBullet::GetNumberingPara()
+{
+	return m_pBulletPara;
+}
+inline sal_Bool LwpSilverBullet::IsPosCumulative(sal_uInt16 nHideLevels)
+{
+	sal_uInt16 AttrMask = ~nHideLevels;
+	return (sal_Bool)((AttrMask & (AttrMask - 1)) != 0);
+}
+inline sal_Bool LwpSilverBullet::IsLesserLevel(sal_uInt16 nPos)
+{
+	return (sal_Bool)((m_pResetPositionFlags[nPos] & LESSERLEVEL) != 0);
+}
+inline sal_Bool LwpSilverBullet::IsNewSection(sal_uInt16 nPos)
+{
+	return (sal_Bool)((m_pResetPositionFlags[nPos] & NEWSECTION) != 0);
+}
+
+#endif
diff -urNp lotuswordpro.bak/source/filter/lwpslvlist.hxx lotuswordpro/source/filter/lwpslvlist.hxx
--- lotuswordpro.bak/source/filter/lwpslvlist.hxx	1970-01-01 08:00:00.000000000 +0800
+++ lotuswordpro/source/filter/lwpslvlist.hxx	2008-10-22 11:42:29.000000000 +0800
@@ -0,0 +1,89 @@
+/*************************************************************************
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: IBM Corporation
+ *
+ *  Copyright: 2008 by IBM Corporation
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+/*************************************************************************
+ * @file 
+ * single list.
+ ************************************************************************/
+/*************************************************************************
+ * Change History
+ * 2005-01-12 create and implement.
+ ************************************************************************/
+
+#ifndef		_LWPSLVLIST_HXX
+#define		_LWPSLVLIST_HXX
+
+#include	"lwpobjstrm.hxx"
+#include	"lwpfilehdr.hxx"
+#include	"lwpobjid.hxx"
+
+class LwpSLVList
+{
+public:
+	LwpSLVList(){}
+	LwpSLVList(LwpObjectStream* pStrm){Read(pStrm);};
+public:
+	void Read(LwpObjectStream* pStrm)
+	{
+		m_NextID.ReadIndexed(pStrm);
+		if( LwpFileHeader::m_nFileRevision < 0x0006 )
+			pStrm->SkipExtra();
+	}
+	LwpObjectID* GetNext(){return &m_NextID;}
+public:
+private:
+	LwpObjectID		m_NextID;
+};
+
+#endif
\ No newline at end of file
diff -urNp lotuswordpro.bak/source/filter/lwpsortopt.cxx lotuswordpro/source/filter/lwpsortopt.cxx
--- lotuswordpro.bak/source/filter/lwpsortopt.cxx	1970-01-01 08:00:00.000000000 +0800
+++ lotuswordpro/source/filter/lwpsortopt.cxx	2008-10-22 11:42:29.000000000 +0800
@@ -0,0 +1,106 @@
+/*************************************************************************
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: IBM Corporation
+ *
+ *  Copyright: 2008 by IBM Corporation
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+/*************************************************************************
+ * @file 
+ *  For LWP filter architecture prototype
+ ************************************************************************/
+/*************************************************************************
+ * Change History
+ Jan 2005			Created
+ ************************************************************************/
+
+#include "lwpsortopt.hxx"
+
+void LwpSortKey::Read(LwpObjectStream *pStrm) 
+{
+	pStrm->QuickRead(&m_nField, sizeof(m_nField));
+	pStrm->QuickRead(&m_nFlag, sizeof(m_nFlag));
+	pStrm->QuickRead(&m_nWord, sizeof(m_nWord));
+	pStrm->SkipExtra();
+}
+LwpSortOption::LwpSortOption(LwpObjectStream* pStrm)
+{
+	Read(pStrm);
+}
+/**
+ * @descr		Read sort option in VO_DOCUMNET from object stream
+ **/
+void LwpSortOption::Read(LwpObjectStream *pStrm) 
+{
+	pStrm->QuickRead(&m_nCount, sizeof(m_nCount));
+	pStrm->QuickRead(&m_nFlags, sizeof(m_nFlags));
+	pStrm->QuickRead(&m_nText, sizeof(m_nText));
+	for(sal_uInt8 i=0; i<3; i++)
+	{
+		m_Keys[i].Read(pStrm);
+	}
+	pStrm->SkipExtra();
+}
+/**
+ * @descr		skip the sort option
+ **/
+void LwpSortOption::Skip(LwpObjectStream *pStrm)
+{
+	pStrm->SeekRel(DiskSize());
+}
+/**
+ * @descr		return the disk size
+ **/
+sal_uInt16 LwpSortOption::DiskSize()
+{
+	sal_uInt16 keysize = 4 * sizeof(sal_uInt16);
+	return (3* keysize + (2 * sizeof(sal_uInt16)) + sizeof(sal_uInt8) + sizeof(sal_uInt16));
+}
+
diff -urNp lotuswordpro.bak/source/filter/lwpsortopt.hxx lotuswordpro/source/filter/lwpsortopt.hxx
--- lotuswordpro.bak/source/filter/lwpsortopt.hxx	1970-01-01 08:00:00.000000000 +0800
+++ lotuswordpro/source/filter/lwpsortopt.hxx	2008-10-22 11:42:29.000000000 +0800
@@ -0,0 +1,102 @@
+/*************************************************************************
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: IBM Corporation
+ *
+ *  Copyright: 2008 by IBM Corporation
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+/*************************************************************************
+ * @file 
+ *  For LWP filter architecture prototype
+ ************************************************************************/
+/*************************************************************************
+ * Change History
+ Jan 2005			Created
+ ************************************************************************/
+
+#ifndef _LWPSORTOPTION_HXX
+#define _LWPSORTOPTION_HXX
+
+#include "lwpheader.hxx"
+#include "lwpobjstrm.hxx"
+
+/**
+ * @brief		sort key class for LwpSortOption
+*/
+class LwpSortKey
+{
+private:
+	sal_uInt16 m_nField;
+	sal_uInt16 m_nFlag;
+	sal_uInt16 m_nWord;
+public:
+	void Read(LwpObjectStream *pStrm);
+};
+/**
+ * @brief		sort options in VO_DOCUMENT
+ *			only for read, not parsed now
+*/
+class LwpSortOption
+{
+public:
+	LwpSortOption(){};
+	LwpSortOption(LwpObjectStream* pStrm);
+	~LwpSortOption(){};
+public:
+	void Read(LwpObjectStream *pStrm);
+	void Skip(LwpObjectStream *pStrm);
+	sal_uInt16 DiskSize();
+private:
+	LwpSortKey m_Keys[3];
+	sal_uInt16 m_nCount;
+	sal_uInt16 m_nFlags;
+	sal_uInt8 m_nText;
+};
+#endif
diff -urNp lotuswordpro.bak/source/filter/lwpstory.cxx lotuswordpro/source/filter/lwpstory.cxx
--- lotuswordpro.bak/source/filter/lwpstory.cxx	1970-01-01 08:00:00.000000000 +0800
+++ lotuswordpro/source/filter/lwpstory.cxx	2008-10-22 11:42:29.000000000 +0800
@@ -0,0 +1,550 @@
+/*************************************************************************
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: IBM Corporation
+ *
+ *  Copyright: 2008 by IBM Corporation
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+/*************************************************************************
+ * @file 
+ *  LwpStory: 
+ 		1. Word Pro object for paragraph list; 
+ 		2. the content of layout object
+ ************************************************************************/
+/*************************************************************************
+ * Change History
+ Jan 2005			Created
+ ************************************************************************/
+#include "lwpglobalmgr.hxx" 
+#include "lwpstory.hxx"
+#include "xfilter/xfstylemanager.hxx"
+
+LwpStory::LwpStory(LwpObjectHeader &objHdr, LwpSvStream* pStrm)
+	: LwpContent(objHdr, pStrm),m_bPMModified(sal_False),m_pCurrentLayout(NULL),
+	m_pTabLayout(NULL),m_bDropcap(sal_False), m_pHyperlinkMgr(new LwpHyperlinkMgr)
+{}
+
+LwpStory::~LwpStory()
+{
+	if (m_pHyperlinkMgr)
+		delete m_pHyperlinkMgr;
+}
+void LwpStory::Read()
+{
+	LwpContent::Read();
+	m_ParaList.Read(m_pObjStrm);
+	m_FirstParaStyle.ReadIndexed(m_pObjStrm);
+	m_pObjStrm->SkipExtra();
+}
+
+#include "lwppara.hxx"
+#include "lwpobjfactory.hxx"
+/**************************************************************************
+ * @descr:   Convert all the contents in current story
+ * @param:   
+ * @param:   
+ * @return:  
+**************************************************************************/
+void LwpStory::XFConvert(XFContentContainer* pCont)
+{
+	//process frame which anchor frame
+	XFConvertFrameInFrame(pCont);
+	//process para list
+	XFContentContainer* pParaCont = pCont;
+	LwpPara* pPara = static_cast<LwpPara*> ( GetFirstPara()->obj() );
+	while(pPara)
+	{
+		pPara->SetFoundry(m_pFoundry);
+		pPara->XFConvert(pParaCont); 
+
+		//Get the xfcontainer for the next para
+		pParaCont = pPara->GetXFContainer();
+		pPara = static_cast<LwpPara*> ( pPara->GetNext()->obj() );
+	}
+
+	//process frame which anchor is to cell after converter all the para
+	XFConvertFrameInCell(pCont);
+	XFConvertFrameInHeaderFooter(pCont);
+
+	//Release Lwp Objects
+	LwpPara* pCur = static_cast<LwpPara*> (GetFirstPara()->obj());
+	LwpPara* pNext;
+	while(pCur)
+	{
+		pCur->Release(); 
+		pNext = static_cast<LwpPara*> ( pCur->GetNext()->obj() );
+		LwpGlobalMgr* pGlobal = LwpGlobalMgr::GetInstance();
+		LwpObjectFactory* pObjMgr = pGlobal->GetLwpObjFactory();
+		pObjMgr->ReleaseObject(*pCur->GetObjectID());
+		pCur = pNext;
+	}	
+}
+
+void LwpStory::RegisterStyle()
+{
+	LwpPara* pPara = static_cast<LwpPara*>( GetFirstPara()->obj() );
+	while(pPara)
+	{
+		pPara->SetFoundry(m_pFoundry);
+		pPara->RegisterStyle();
+		pPara = static_cast<LwpPara*>(pPara->GetNext()->obj());
+	}
+}
+
+void LwpStory::Parse(IXFStream* pOutputStream)
+{
+	m_pXFContainer = new XFContentContainer;
+	XFConvert(m_pXFContainer);
+	m_pXFContainer->ToXml(pOutputStream);
+	delete m_pXFContainer;
+	m_pXFContainer = NULL;
+
+	//It seems that, currently, we do not need to process the child story
+	/*LwpObject* pChildStory = GetFirstStory()->obj();
+	if(pChildStory)
+	{
+		pChildStory->SetFoundry(m_pFoundry);
+		pChildStory->Parse(pOutputStream);
+	}*/
+
+	//Don't process the next story
+/*	LwpObject* pNextStory = GetNextStory()->obj();
+	if(pNextStory)
+	{
+		pNextStory->SetFoundry(m_pFoundry);
+		pNextStory->Parse(pOutputStream); 
+	}*/
+
+}
+
+#include "lwppagelayout.hxx"
+/**************************************************************************
+ * @descr:   Set current page layout. If pPageLayout is a mirro page layout,
+ 		    use odd child page layout as current page layout.
+ * @param:   
+ * @param:   
+ * @return:  
+**************************************************************************/
+void LwpStory::SetCurrentLayout(LwpPageLayout *pPageLayout)
+{
+	LwpPageLayout* pLayout = pPageLayout->GetOddChildLayout();
+	if(pLayout)
+	{
+		m_pCurrentLayout = pLayout;
+		m_pTabLayout = pLayout;		
+	}
+	else
+	{
+		m_pCurrentLayout = pPageLayout;
+		m_pTabLayout = pPageLayout;
+	}
+	m_bPMModified = sal_True;
+}
+
+void LwpStory::AddPageLayout(LwpPageLayout * pObject)
+{	
+	m_LayoutList.push_back(pObject);
+}
+/**************************************************************************
+ * @descr:   Get the next page layout relative to m_pCurrentLayout
+ * @param:   
+ * @param:   
+ * @return:  
+**************************************************************************/
+LwpPageLayout* LwpStory::GetNextPageLayout()
+{
+	std::vector<LwpPageLayout*>::iterator it;
+	for( it = m_LayoutList.begin(); it != m_LayoutList.end(); it++ )
+	{
+		if(m_pCurrentLayout == *it)
+		{
+			if((it+1) !=m_LayoutList.end())
+			{
+				return *(it+1);
+			}
+		}
+	}
+	return NULL;
+}
+/**************************************************************************
+ * @descr:   Sort the pagelayout according to their position
+ * @param:   
+ * @param:   
+ * @return:  
+**************************************************************************/
+void LwpStory::SortPageLayout()
+{
+	//Get all the pagelayout and store in list
+	std::vector<LwpPageLayout*>  aLayoutList;
+	LwpVirtualLayout* pLayout = GetLayout(NULL);
+	while(pLayout)
+	{
+		if(pLayout->IsPage())
+		{
+			LwpLayout::UseWhenType eSectionType = static_cast<LwpPageLayout*>(pLayout)->GetUseWhenType();
+			//for mirror page, the child  is pagelayout
+			LwpVirtualLayout* pParent = pLayout->GetParentLayout();
+			if(eSectionType != LwpLayout::StartWithinColume && !pParent->IsPage())
+			{
+				aLayoutList.push_back(static_cast<LwpPageLayout*>(pLayout));
+			}
+		}			
+		pLayout = GetLayout(pLayout);
+	}
+	// sort the pagelayout according to their position
+	LwpPageLayout* pTemp = NULL;
+	std::vector<LwpPageLayout*>::iterator aIt;
+	std::vector<LwpPageLayout*>::iterator bIt;
+	for( aIt = aLayoutList.begin(); aIt != aLayoutList.end() -1; aIt++)
+	{
+		for( bIt = aIt +1; bIt != aLayoutList.end(); bIt ++)
+		{
+			if(**aIt < **bIt)
+			{
+				continue;
+			}
+			else
+			{
+				pTemp = *aIt;
+				*aIt = *bIt;
+				*bIt = pTemp;
+			}
+		}
+	}
+
+	//put all the sorted  layouts into list
+	m_LayoutList.clear();
+	
+	for( aIt = aLayoutList.begin(); aIt != aLayoutList.end(); aIt++)
+	{
+		m_LayoutList.push_back(*aIt);
+	}
+}
+
+/**************************************************************************
+ * @descr:  whether need create a new section and reset column in current page layout
+ * @param:   
+ * @param:   
+ * @return:  sal_True if need create a new section
+**************************************************************************/
+sal_Bool LwpStory::IsNeedSection()
+{
+	sal_Bool bColumns = sal_False;
+	sal_Bool bNewSection = sal_False;	
+	if(m_pCurrentLayout)
+	{
+		if(m_pCurrentLayout->HasColumns())
+		{
+			//get the following pagelayout and its type
+			bColumns = sal_True;
+			LwpPageLayout* pNextLayout = GetNextPageLayout();
+			if(pNextLayout)
+			{
+				//get layout type
+				LwpLayout::UseWhenType eWhenType = pNextLayout->GetUseWhenType();
+				switch(eWhenType)
+				{
+				case LwpLayout::StartWithinColume://not support now
+				case LwpLayout::StartWithinPage:
+				{	
+					bColumns =sal_False;
+					bNewSection = sal_True;											
+					break;
+				}
+				case LwpLayout::StartOnNextPage:					
+				case LwpLayout::StartOnOddPage://not support now
+				case LwpLayout::StartOnEvenPage://not support now
+				{
+					bColumns =sal_True;
+					bNewSection = sal_False;
+					break;
+				}
+				default:
+					break;
+				}
+			}
+
+			//if bColumns is ture, the page layout doesn't need columns, set the xfcolumns to NULL in page master
+			if(!bColumns)
+			{
+				m_pCurrentLayout->ResetXFColumns();
+			}
+		}		
+		SetPMModified(sal_False);
+	}	
+	return bNewSection;
+}
+/**************************************************************************
+ * @descr:  process frame which anchor type is to page, frame or cell
+ * @param:   
+ * @param:   
+ * @return:  
+**************************************************************************/
+void LwpStory::XFConvertFrame(XFContentContainer* pCont)
+{
+	LwpVirtualLayout* pLayout = GetLayout(NULL);
+	while(pLayout)
+	{
+		LwpVirtualLayout* pFrameLayout = static_cast<LwpVirtualLayout*>(pLayout->GetChildHead()->obj());
+		while(pFrameLayout)
+		{
+			if((pFrameLayout->IsAnchorPage()&&(pFrameLayout->IsFrame()||pFrameLayout->IsSuperTable()||pFrameLayout->IsGroupHead()))
+			    ||(pFrameLayout->IsAnchorFrame()))			   
+			{
+				pFrameLayout->XFConvert(pCont);
+			}
+			pFrameLayout = static_cast<LwpVirtualLayout*>(pFrameLayout->GetNext()->obj());
+		}		
+		pLayout = GetLayout(pLayout);
+	}
+}
+/**************************************************************************
+ * @descr:  process frame which anchor type is to cell
+ * @param:   
+ * @param:   
+ * @return:  
+**************************************************************************/
+void LwpStory::XFConvertFrameInCell(XFContentContainer* pCont)
+{
+	LwpVirtualLayout* pLayout = GetLayout(NULL);
+	while(pLayout)
+	{
+		LwpVirtualLayout* pFrameLayout = static_cast<LwpVirtualLayout*>(pLayout->GetChildHead()->obj());
+		while(pFrameLayout)
+		{
+			
+			//if(pFrameLayout->IsAnchorCell())
+			if(pFrameLayout->IsAnchorCell() && pFrameLayout->HasContent())
+			{
+				//get the first xfpara
+				XFContentContainer* pXFFirtPara = static_cast<XFContentContainer*>(pCont->FindFirstContent(enumXFContentPara));
+				if(pXFFirtPara)
+					pFrameLayout->XFConvert(pXFFirtPara);						
+			}
+			pFrameLayout = static_cast<LwpVirtualLayout*>(pFrameLayout->GetNext()->obj());
+		}
+		pLayout = GetLayout(pLayout);
+	}
+}
+
+/**************************************************************************
+ * @descr:  process frame which anchor type is to page
+ * @param:   
+ * @param:   
+ * @return:  
+**************************************************************************/
+void LwpStory::XFConvertFrameInPage(XFContentContainer* pCont)
+{
+	LwpVirtualLayout* pLayout = GetLayout(NULL);
+	while(pLayout)
+	{
+		LwpVirtualLayout* pFrameLayout = static_cast<LwpVirtualLayout*>(pLayout->GetChildHead()->obj());
+		while(pFrameLayout)
+		{
+			if((pFrameLayout->IsAnchorPage()
+				&&(pFrameLayout->IsFrame()
+				      ||pFrameLayout->IsSuperTable()
+				      ||pFrameLayout->IsGroupHead())))
+			{
+				pFrameLayout->XFConvert(pCont);
+			}
+			pFrameLayout = static_cast<LwpVirtualLayout*>(pFrameLayout->GetNext()->obj());
+		}		
+		pLayout = GetLayout(pLayout);
+	}
+}
+/**************************************************************************
+ * @descr:  process frame which anchor type is to frame
+ * @param:   
+ * @param:   
+ * @return:  
+**************************************************************************/
+void LwpStory::XFConvertFrameInFrame(XFContentContainer* pCont)
+{
+	LwpVirtualLayout* pLayout = GetLayout(NULL);
+	while(pLayout)
+	{
+		LwpVirtualLayout* pFrameLayout = static_cast<LwpVirtualLayout*>(pLayout->GetChildHead()->obj());
+		while(pFrameLayout)
+		{
+			if(pFrameLayout->IsAnchorFrame())				
+			{
+				pFrameLayout->XFConvert(pCont);
+			}
+			pFrameLayout = static_cast<LwpVirtualLayout*>(pFrameLayout->GetNext()->obj());
+		}		
+		pLayout = GetLayout(pLayout);
+	}
+}
+/**************************************************************************
+ * @descr:  process frame which anchor type is to page and the frame is contained by header or footer
+ * @param:   
+ * @param:   
+ * @return:  
+**************************************************************************/
+void LwpStory::XFConvertFrameInHeaderFooter(XFContentContainer* pCont)
+{
+	LwpVirtualLayout* pLayout = GetLayout(NULL);
+	while(pLayout)
+	{
+		LwpVirtualLayout* pFrameLayout = static_cast<LwpVirtualLayout*>(pLayout->GetChildHead()->obj());
+		while(pFrameLayout)
+		{
+			if(pFrameLayout->IsAnchorPage() && (pLayout->IsHeader() || pLayout->IsFooter()))				
+			{
+				//The frame must be included by <text:p>
+				XFContentContainer* pXFFirtPara = static_cast<XFContentContainer*>(pCont->FindFirstContent(enumXFContentPara));
+				if(pXFFirtPara)
+					pFrameLayout->XFConvert(pXFFirtPara);
+			}
+			pFrameLayout = static_cast<LwpVirtualLayout*>(pFrameLayout->GetNext()->obj());
+		}		
+		pLayout = GetLayout(pLayout);
+	}
+}
+
+void LwpStory::AddXFContent(XFContent* pContent)
+{
+	if(m_pXFContainer)
+		m_pXFContainer->Add(pContent); 
+}
+
+XFContentContainer* LwpStory::GetXFContent()
+{
+	if(m_pXFContainer)
+		return m_pXFContainer;
+	else
+		return NULL;
+}
+
+LwpPara* LwpStory::GetLastParaOfPreviousStory()
+{
+	LwpVirtualLayout* pVLayout = this->GetLayout(NULL);
+	if (pVLayout)
+	{
+		return pVLayout->GetLastParaOfPreviousStory();
+	}
+
+	return NULL;
+}
+/**************************************************************************
+ * @descr:  get text from story
+ * @param:   
+ * @param:   
+ * @return:  
+**************************************************************************/
+OUString LwpStory::GetContentText(sal_Bool bAllText)
+{
+	if (bAllText)//convert all text fribs
+	{
+		OUString sText = A2OUSTR("");
+		//process para list
+		LwpPara* pPara = static_cast<LwpPara*>(GetFirstPara()->obj());
+		while (pPara)
+		{
+			pPara->SetFoundry(m_pFoundry);
+			sText += pPara->GetContentText(sal_True);
+			pPara = static_cast<LwpPara*>(pPara->GetNext()->obj());
+		}
+		return sText;
+	}
+	else //only the first text frib
+	{
+		LwpObject* pObj = GetFirstPara()->obj();
+		if(pObj)
+		{
+			LwpPara* pPara = static_cast<LwpPara*>(pObj);
+			if (pPara->GetNext()->obj() != NULL)
+				return A2OUSTR("");
+			pPara->SetFoundry(m_pFoundry);
+			return pPara->GetContentText();
+		}
+		return 	A2OUSTR("");		
+	}
+
+}
+OUString LwpStory::RegisterFirstFribStyle()
+{
+	LwpPara* pPara = static_cast<LwpPara*>(GetFirstPara()->obj());
+	pPara->SetFoundry(m_pFoundry);
+	LwpFribPtr* pFribs = pPara->GetFribs();
+	if (pFribs)
+	{
+		LwpFrib* pFirstFrib = pFribs->GetFribs();
+		pFirstFrib->RegisterStyle(m_pFoundry);
+		XFStyleManager* pXFStyleManager = LwpGlobalMgr::GetInstance()->GetXFStyleManager(); 
+		XFTextStyle* pBaseStyle = pXFStyleManager->FindTextStyle(pFirstFrib->GetStyleName());
+		if (pBaseStyle == NULL)
+			return A2OUSTR("");
+		XFTextStyle* pStyle = new XFTextStyle;
+		*pStyle = *pBaseStyle;
+		OUString sName = A2OUSTR("Ruby") + pFirstFrib->GetStyleName();
+		pStyle->SetStyleName(sName);
+		pXFStyleManager->AddStyle(pStyle);		
+		return sName;
+	}
+	return A2OUSTR("");
+}
+
+sal_Bool LwpStory::IsBullStyleUsedBefore(const rtl::OUString& rStyleName, const sal_uInt8& nPos)
+{
+	std::vector <NamePosPair>::reverse_iterator rIter;
+	for (rIter = m_vBulletStyleNameList.rbegin(); rIter != m_vBulletStyleNameList.rend(); rIter++)
+	{
+		rtl::OUString aName = (*rIter).first;
+		sal_uInt8 nPosition = (*rIter).second;
+		if ((*rIter).first == rStyleName && (*rIter).second == nPos)
+		{
+			return sal_True;
+		}
+	}
+	return sal_False;
+}
+
diff -urNp lotuswordpro.bak/source/filter/lwpstory.hxx lotuswordpro/source/filter/lwpstory.hxx
--- lotuswordpro.bak/source/filter/lwpstory.hxx	1970-01-01 08:00:00.000000000 +0800
+++ lotuswordpro/source/filter/lwpstory.hxx	2008-10-22 11:42:29.000000000 +0800
@@ -0,0 +1,202 @@
+/*************************************************************************
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: IBM Corporation
+ *
+ *  Copyright: 2008 by IBM Corporation
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+/*************************************************************************
+ * @file 
+ *  LwpStory: 
+ 		1. Word Pro object for paragraph list; 
+ 		2. the content of layout object
+ ************************************************************************/
+/*************************************************************************
+ * Change History
+ Jan 2005			Created
+ ************************************************************************/
+
+#ifndef _LWPSTORY_HXX
+#define _LWPSTORY_HXX
+#include "lwpcontent.hxx"
+
+class LwpPageLayout;
+class LwpStory: public LwpContent
+{
+public:
+	LwpStory(LwpObjectHeader &objHdr, LwpSvStream* pStrm);
+	virtual ~LwpStory();
+private:
+	//File format members:
+	LwpDLVListHeadTail m_ParaList;
+	LwpObjectID m_FirstParaStyle;
+
+	// for bullet , 05/23/2005
+	typedef std::pair<rtl::OUString, sal_uInt8> NamePosPair;
+	std::vector <NamePosPair> m_vBulletStyleNameList;
+	
+	// , 02/16/2005
+	sal_Bool m_bPMModified;
+	LwpPageLayout* m_pCurrentLayout;	//for register page layout style
+	std::vector<LwpPageLayout*> m_LayoutList;	
+	LwpLayout* m_pTabLayout;	//for register tab style
+	
+	sal_Bool m_bDropcap;
+	LwpHyperlinkMgr* m_pHyperlinkMgr;
+	OUString m_CurrSectionName;
+
+	XFContentContainer* m_pXFContainer;
+
+protected:
+	void Read();	
+	void XFConvertFrame(XFContentContainer* pCont);
+	void XFConvertFrameInCell(XFContentContainer* pCont);	
+	void XFConvertFrameInFrame(XFContentContainer* pCont);
+	void XFConvertFrameInHeaderFooter(XFContentContainer* pCont);
+
+public:
+	void RegisterStyle();
+	void Parse(IXFStream* pOutputStream);	
+	virtual void XFConvert(XFContentContainer* pCont);
+	void XFConvertFrameInPage(XFContentContainer* pCont);
+	inline LwpDLVListHeadTail* GetParaList();
+	inline LwpObjectID* GetFirstPara();
+	inline LwpObjectID* GetLastPara();
+	 XFContentContainer* GetXFContent();
+	void AddXFContent(XFContent* pContent);
+
+	inline sal_Bool GetDropcapFlag();
+	inline LwpPageLayout* GetCurrentLayout();
+	inline LwpMiddleLayout* GetTabLayout();//for register tab style
+	inline OUString GetSectionName();
+	inline LwpHyperlinkMgr* GetHyperlinkMgr();
+
+	inline sal_Bool IsPMModified();	
+	inline void SetPMModified(sal_Bool bPMModified);
+	inline void SetDropcapFlag(sal_Bool bFlag);
+	inline void SetTabLayout(LwpLayout* pLayout);
+	inline void SetSectionName(OUString StyleName);
+	
+	void SetCurrentLayout(LwpPageLayout* pPageLayout);
+	void AddPageLayout(LwpPageLayout* pObject);
+	LwpPageLayout* GetNextPageLayout();
+	sal_Bool IsNeedSection();
+	void SortPageLayout();
+
+	LwpPara* GetLastParaOfPreviousStory();
+	
+	OUString GetContentText(sal_Bool bAllText = sal_False);//add by ,for CHB,05/5/25
+	inline void AddBullStyleName2List(const rtl::OUString& rStyleName, const sal_uInt8& nPos);
+	sal_Bool IsBullStyleUsedBefore(const rtl::OUString& rStyleName, const sal_uInt8& nPos);
+	
+	OUString RegisterFirstFribStyle();
+};
+
+LwpDLVListHeadTail* LwpStory::GetParaList()
+{
+	return &m_ParaList;
+}
+LwpObjectID* LwpStory::GetFirstPara()
+{
+	return m_ParaList.GetHead();
+}
+LwpObjectID* LwpStory::GetLastPara()
+{
+	return m_ParaList.GetTail();
+}
+sal_Bool LwpStory::GetDropcapFlag()
+{
+	return m_bDropcap;
+}
+LwpMiddleLayout* LwpStory::GetTabLayout()
+{
+	if(m_pTabLayout)
+		return m_pTabLayout;
+	return static_cast<LwpMiddleLayout*>(GetLayout(NULL));
+}
+void LwpStory::SetPMModified(sal_Bool bPMModified)
+{
+	m_bPMModified = bPMModified;
+}
+void LwpStory::SetDropcapFlag(sal_Bool bFlag)
+{
+	m_bDropcap = bFlag;
+}
+void LwpStory::SetTabLayout(LwpLayout* pLayout)
+{ 
+	m_pTabLayout = pLayout;
+}
+void LwpStory::SetSectionName(OUString StyleName)
+{ 
+	m_CurrSectionName = StyleName;
+}
+OUString LwpStory::GetSectionName()
+{
+	return m_CurrSectionName;
+}
+sal_Bool LwpStory::IsPMModified()
+{
+	return m_bPMModified;
+}
+LwpPageLayout* LwpStory::GetCurrentLayout()
+{
+	return m_pCurrentLayout;
+}
+LwpHyperlinkMgr* LwpStory::GetHyperlinkMgr()
+{
+	return m_pHyperlinkMgr;
+}
+inline void LwpStory::AddBullStyleName2List(const rtl::OUString& rStyleName, const sal_uInt8& nPos)
+{
+	m_vBulletStyleNameList.push_back(std::make_pair(rStyleName, nPos));
+}
+
+#endif
+
diff -urNp lotuswordpro.bak/source/filter/lwpstyledef.hxx lotuswordpro/source/filter/lwpstyledef.hxx
--- lotuswordpro.bak/source/filter/lwpstyledef.hxx	1970-01-01 08:00:00.000000000 +0800
+++ lotuswordpro/source/filter/lwpstyledef.hxx	2008-10-22 11:42:29.000000000 +0800
@@ -0,0 +1,257 @@
+/*************************************************************************
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: IBM Corporation
+ *
+ *  Copyright: 2008 by IBM Corporation
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+
+#ifndef	_LWPSTYLEDEF_H_
+#define	_LWPSTYLEDEF_H_
+
+#define	INVALID_ATTR_ID 0
+#define	EXTERNAL_ID			0x8000
+#define	EXTERNAL_MASK		0x7FFF
+#define MAX_DESIGNERBORDERS 18
+
+#define BORDER_SOLID		1
+#define	BORDER_SDASH		2
+#define	BORDER_LDASH		3
+#define	BORDER_WAVY			4
+#define	BORDER_THKWAVY		5
+#define	BORDER_LSDASH		6
+#define	BORDER_LSSDASH		7
+#define	BORDER_DOT			8
+#define	BORDER_CIRCLE		9
+#define	BORDER_DBLWAVY		10
+#define	BORDER_DBLTHKWAVY	11
+#define	BORDER_STAR			12
+#define	BORDER_ROPE			13
+#define	BORDER_DECO1		14
+#define	BORDER_DECO2		15
+#define	BORDER_RAIN			16
+#define	BORDER_PIN			17
+#define	BORDER_ROSE			18
+#define	BORDER_SUNF			19
+#define	BORDER_DECO3		20
+#define	BORDER_WARNING		21
+// SPACE					22
+#define BORDER_GIRDER		23
+
+// User defined bitmap borders (200 - 400)
+//========================================
+
+// scalable lines
+#define BGRP_SOLID				20
+#define BGRP_DOUBLE_ONE			21
+#define BGRP_DOUBLE_TWO			22
+#define BGRP_121				23
+#define BGRP_31					24
+#define BGRP_13					25
+#define BGRP_WAVY				26
+#define BGRP_DBLWAVY			27
+#define BGRP_THICK_WAVY			28
+#define BGRP_THICK_DBLWAVY		29
+#define BGRP_SDASH				30
+#define BGRP_LDASH				31
+#define BGRP_LDASH_SDASH		32
+#define BGRP_LDASH_SDASH_SDASH	33
+#define BGRP_BUTTONUP			34
+#define BGRP_BUTTONDOWN			35
+#define BGRP_13SPACE			36
+#define BGRP_31SPACE			37
+#define BGRP_DIAGONAL			38
+#define BGRP_TARO				39
+#define BGRP_DOT				40
+#define BGRP_CIRCLE				41
+#define	BGRP_STAR				42
+#define	BGRP_ROPE				43
+#define	BGRP_DECO1				44
+#define	BGRP_DECO2				45
+#define	BGRP_RAIN				46
+#define	BGRP_PIN				47
+#define	BGRP_ROSE				48
+#define	BGRP_SUNF				49
+#define	BGRP_DECO3				50
+#define	BGRP_WARNING			51
+//SPACE 					52
+#define BGRP_GIRDER				53
+
+#define UNIT_4_96  ((UNIT)196608L)	//INCHES(4/96)
+#define UNIT_13_96 ((UNIT)638976L)	//INCHES(13/96)
+#define UNIT_14_96 ((UNIT)688128L)	//INCHES(14/96)
+#define UNIT_15_96 ((UNIT)737280L)	//INCHES(15/96)
+#define UNIT_17_96 ((UNIT)835584L)	//INCHES(17/96)
+#define UNIT_18_96 ((UNIT)884736L)	//INCHES(18/96)
+#define UNIT_19_96 ((UNIT)933888L)	//INCHES(19/96)
+#define UNIT_20_96 ((UNIT)983040L)	//INCHES(20/96)
+#define UNIT_21_96 ((UNIT)1032192L)	//INCHES(21/96)
+#define UNIT_22_96 ((UNIT)1081344L)	//INCHES(22/96)
+#define UNIT_25_96 ((UNIT)1228800L)	//INCHES(25/96)
+#define UNIT_28_96 ((UNIT)1376256L)	//INCHES(28/96)
+#define UNIT_34_96 ((UNIT)1671108L)	//INCHES(34/96)
+#define UNIT_42_96 ((UNIT)2064384L)	//INCHES(42/96)
+#define UNIT_44_96 ((UNIT)2162688L)	//INCHES(44/96)
+#define UNIT_48_96 ((UNIT)2359296L)	//INCHES(48/96)
+#define UNIT_56_96 ((UNIT)2752512L)	//INCHES(56/96)
+#define UNIT_64_96 ((UNIT)3145728L)	//INCHES(64/96)
+
+#define ROPE_AMPLITUDE 		UNIT_18_96
+#define ROPE_PERIOD			UNIT_20_96
+#define DECO1_AMPLITUDE 	UNIT_17_96
+#define DECO1_PERIOD		UNIT_4_96
+#define DECO2_AMPLITUDE 	UNIT_18_96
+#define DECO2_PERIOD		UNIT_64_96
+#define RAIN_AMPLITUDE 		UNIT_22_96
+#define RAIN_PERIOD			UNIT_28_96
+#define PIN_AMPLITUDE 		UNIT_15_96
+#define PIN_PERIOD			UNIT_4_96
+#define ROSE_AMPLITUDE 		UNIT_34_96
+#define ROSE_PERIOD			UNIT_64_96
+#define SUNF_AMPLITUDE 		UNIT_25_96
+#define SUNF_PERIOD			UNIT_48_96
+#define DECO3_AMPLITUDE 	UNIT_14_96
+#define DECO3_PERIOD		UNIT_20_96
+
+#define ROPE_JOIN_W			UNIT_18_96
+#define ROPE_JOIN_H 		UNIT_18_96
+#define DECO1_JOIN_W 		UNIT_56_96
+#define DECO1_JOIN_H 		UNIT_44_96
+#define DECO2_JOIN_W 		UNIT_64_96
+#define DECO2_JOIN_H 		UNIT_64_96
+#define RAIN_JOIN_W 		UNIT_48_96
+#define RAIN_JOIN_H 		UNIT_48_96
+#define PIN_JOIN_W 			UNIT_42_96
+#define PIN_JOIN_H 			UNIT_42_96
+#define ROSE_JOIN_W 		UNIT_48_96
+#define ROSE_JOIN_H 		UNIT_48_96
+#define SUNF_JOIN_W 		UNIT_48_96
+#define SUNF_JOIN_H 		UNIT_48_96
+#define DECO3_JOIN_W 		UNIT_56_96
+#define DECO3_JOIN_H 		UNIT_56_96
+
+// User defined bitmap border groups 200 - 400
+//============================================
+
+/* background patterns */
+#define BACK_TRANSPARENT	0
+#define BACK_FILL			1
+#define BACK_PATTERN		2
+#define BACK_10PCTDOTS		3
+#define BACK_30PCTDOTS		4
+#define BACK_50PCTDOTS		5
+#define BACK_75PCTDOTS		6
+#define BACK_90PCTDOTS		7
+#define BACK_90PCTINVDOTS	8
+#define BACK_75PCTINVDOTS	9
+#define BACK_50PCTINVDOTS	10
+#define BACK_30PCTINVDOTS	11
+#define BACK_10PCTINVDOTS	12
+#define BACK_MARBLES		13
+#define BACK_STARRYNIGHT	14
+#define BACK_DIAGTHICK		15
+#define BACK_DIAGTHIN		16
+#define BACK_DIAGDOUBLE		17
+#define BACK_DIAGDOUBLENARROW 18
+#define BACK_DIAGTRIPLE		19
+#define BACK_DIAGSINGLEWIDE	20
+#define BACK_DIAGTHICKINV	21
+#define BACK_DIAGTHININV	22
+#define BACK_DIAGDOUBLEINV	23
+#define BACK_DIAGDOUBLENARROWINV 24
+#define BACK_DIAGTRIPLEINV		25
+#define BACK_DIAGSINGLEWIDEINV	26
+#define BACK_CHAINLINKSMALLINV	27
+#define BACK_CHAINLINKSMALL		28
+#define BACK_CHAINLINKMEDIUM	29
+#define BACK_CHAINLINKLARGE		30
+#define BACK_HORZSTRIPE1		31
+#define BACK_HORZSTRIPE2		32
+#define BACK_HORZSTRIPE3		33
+#define BACK_HORZSTRIPE4		34
+#define BACK_VERTSTRIPE1		35
+#define BACK_VERTSTRIPE2		36
+#define BACK_VERTSTRIPE3		37
+#define BACK_VERTSTRIPE4		38
+#define BACK_GRIDSMALL			39
+#define BACK_GRIDMEDIUM			40
+#define BACK_GRIDLARGE			41
+#define BACK_BOXDOT				42
+#define BACK_GOLFGREEN			43
+#define BACK_DITZ				44
+#define BACK_HORZWEAVE			45
+#define BACK_APPLEPIE			46
+#define BACK_BRICK				47
+#define BACK_DIAGBRICK			48
+#define BACK_CHECKER1			49
+#define BACK_CHECKER2			50
+#define BACK_CHECKER3			51
+#define BACK_CHECKER4			52
+#define BACK_CHECKER5			53
+#define BACK_SNOWFLAKE			54
+#define BACK_MARGARITA			55
+#define BACK_SIDEHARP			56
+#define BACK_SCALES				57
+#define BACK_TAYLOR				58
+#define BACK_BUBBLES			59
+#define BACK_ARGYLE				60
+#define BACK_INDIAN1			61
+#define BACK_INDIAN3			62
+#define BACK_PEACHPIE			63
+#define BACK_GRADIENT1			64
+#define BACK_GRADIENT2			65
+#define BACK_GRADIENT3			66
+#define BACK_GRADIENT4			67
+#define BACK_GRADIENT5			68
+#define BACK_GRADIENT6			69
+#define BACK_GRADIENT7			70
+#define BACK_GRADIENT8			71
+
+#endif //STYLEDEF_H_
diff -urNp lotuswordpro.bak/source/filter/lwpsvstream.cxx lotuswordpro/source/filter/lwpsvstream.cxx
--- lotuswordpro.bak/source/filter/lwpsvstream.cxx	1970-01-01 08:00:00.000000000 +0800
+++ lotuswordpro/source/filter/lwpsvstream.cxx	2008-10-22 11:42:29.000000000 +0800
@@ -0,0 +1,99 @@
+/*************************************************************************
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: IBM Corporation
+ *
+ *  Copyright: 2008 by IBM Corporation
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+#include "lwpsvstream.hxx"
+#include <memory>
+
+const sal_uInt32 LwpSvStream::LWP_STREAM_BASE = 0x0010;
+
+LwpSvStream::LwpSvStream(SvStream* pStream, LwpSvStream * pCompressed)
+	: m_pStream(pStream), m_pCompressedStream(pCompressed)
+{
+}
+
+/**
+ * @descr		read nBytesToRead bytes to buf
+*/
+sal_Int32 LwpSvStream::Read(void* buf, sal_Int32 nBytesToRead)
+{
+	return m_pStream->Read(buf,nBytesToRead);
+}
+/**
+ * @descr		SeekRel in stream
+*/
+sal_Int64 LwpSvStream::SeekRel(sal_Int64 pos)
+{
+	return m_pStream->SeekRel(pos);
+}
+/**
+ * @descr		Get the current position in stream
+*/
+sal_Int64 LwpSvStream::Tell()
+{
+        return m_pStream->Tell();
+}
+/**
+ * @descr		Seek to pos
+*/
+sal_Int64 LwpSvStream::Seek(sal_Int64 pos)
+{
+        return m_pStream->Seek(pos);
+}
+/**
+ * @descr		Return the stream data length
+*/
+//sal_Int64 LwpSvStream::GetLength()
+//{
+//	return m_pStream->get
+//}
diff -urNp lotuswordpro.bak/source/filter/lwpsvstream.hxx lotuswordpro/source/filter/lwpsvstream.hxx
--- lotuswordpro.bak/source/filter/lwpsvstream.hxx	1970-01-01 08:00:00.000000000 +0800
+++ lotuswordpro/source/filter/lwpsvstream.hxx	2008-10-22 11:42:29.000000000 +0800
@@ -0,0 +1,99 @@
+/*************************************************************************
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: IBM Corporation
+ *
+ *  Copyright: 2008 by IBM Corporation
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+#ifndef _SVSTREAM_HXX
+#define _SVSTREAM_HXX
+
+#include "lwpheader.hxx"
+#include "lwpunoheader.hxx"
+#include <tools/stream.hxx>
+
+/**
+ * @brief	encapsulate XInputStream to provide SvStream like interfaces
+*/
+class LwpSvStream
+{
+public:
+	LwpSvStream(SvStream* pStream, LwpSvStream * pCompressed = NULL);
+	sal_Int32 Read( void* bytes, sal_Int32 nBytesToRead );
+	sal_Int64 SeekRel( sal_Int64 pos );
+	sal_Int64 Tell();
+	sal_Int64 Seek( sal_Int64 pos );
+//	sal_Int64 GetLength();
+	static const sal_uInt32 LWP_STREAM_BASE;
+
+	// added by  for small file feature
+	LwpSvStream * GetCompressedStream()
+	{ 
+		return m_pCompressedStream;
+	};
+	SvStream * GetStream()
+	{
+		return m_pStream;
+	}
+	// end of added by 
+
+private:
+	// when the file opened is small file, m_pStream is the decompressed stream
+	// when not, m_pStream contains the normal stream
+	SvStream* m_pStream;
+
+	// added by  for small file feature
+	// when the file opened is small file, this stream is
+	// for saving the compressed stream which is to be used for Chart/OLE as BENTO container
+	LwpSvStream * m_pCompressedStream;
+	// end of added by 
+	
+};
+#endif
diff -urNp lotuswordpro.bak/source/filter/lwptable.cxx lotuswordpro/source/filter/lwptable.cxx
--- lotuswordpro.bak/source/filter/lwptable.cxx	1970-01-01 08:00:00.000000000 +0800
+++ lotuswordpro/source/filter/lwptable.cxx	2008-10-22 11:42:29.000000000 +0800
@@ -0,0 +1,276 @@
+/*************************************************************************
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: IBM Corporation
+ *
+ *  Copyright: 2008 by IBM Corporation
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+/**
+ * @file 
+ *  For LWP filter architecture prototype - table object
+ */
+/*************************************************************************
+ * Change History
+ Mar 2005		 	Created
+ ************************************************************************/
+
+ #include "lwptable.hxx"
+
+ LwpSuperTable::LwpSuperTable(LwpObjectHeader &objHdr, LwpSvStream* pStrm):LwpContent(objHdr, pStrm)
+{}
+
+LwpSuperTable::~LwpSuperTable()
+{}
+
+void LwpSuperTable::Read()
+{
+	LwpContent::Read();
+	m_pObjStrm->SkipExtra();
+
+}
+ void  LwpSuperTable::Parse(IXFStream* pOutputStream)
+{
+}
+
+//Added by  for XFConvert refactor, 03/31/2005
+void LwpSuperTable::XFConvert(XFContentContainer* pCont)
+{}
+//End of Add
+/*****************************************************************************/
+ LwpTable::LwpTable(LwpObjectHeader &objHdr, LwpSvStream* pStrm):LwpContent(objHdr, pStrm)
+{}
+
+LwpTable::~LwpTable()
+{}
+
+void LwpTable::Read()
+{
+	LwpContent::Read();
+	//m_RowCache.Read(m_pObjStrm);
+	//m_ColumnCache.Read(m_pObjStrm);
+
+	//m_CPNotifyList.Read(m_pObjStrm);
+	//m_CPTempVersionedNotifyList.Read(m_pObjStrm);
+	
+	m_nRow = m_pObjStrm->QuickReaduInt16();
+	m_nColumn = m_pObjStrm->QuickReaduInt16(); 
+
+	m_nHeight = m_pObjStrm->QuickReadInt32();
+	m_nWidth = m_pObjStrm->QuickReadInt32();
+	
+	m_nDefaultAutoGrowRowHeight = m_pObjStrm->QuickReadInt32();
+	
+	m_nAttributes = m_pObjStrm->QuickReaduInt16();
+	
+	m_Layout.ReadIndexed(m_pObjStrm);
+
+	m_DefaultCellStyle.ReadIndexed(m_pObjStrm);
+	if (LwpFileHeader::m_nFileRevision >= 0x0007)
+		m_CPNotifyList.Read(m_pObjStrm);
+
+	m_pObjStrm->SkipExtra();
+}
+
+sal_Bool LwpTable::IsNumberDown()
+{
+	if (m_nAttributes & NUMBER_DOWN)
+		return sal_True;
+	return sal_False;
+}
+
+ void  LwpTable::Parse(IXFStream* pOutputStream)
+{
+}
+
+ LwpSuperTableLayout* LwpTable::GetSuperTableLayout()
+{
+	LwpTableLayout* pLayout = static_cast<LwpTableLayout*>(m_Layout.obj());
+	if(pLayout)
+		return static_cast<LwpSuperTableLayout*>(pLayout->GetParent()->obj());
+
+	return NULL;
+}
+
+ /*****************************************************************************/
+ LwpTableHeading::LwpTableHeading(LwpObjectHeader &objHdr, LwpSvStream* pStrm):LwpTable(objHdr, pStrm)
+{}
+
+LwpTableHeading::~LwpTableHeading()
+{}
+
+void LwpTableHeading::Read()
+{
+	m_pObjStrm->SkipExtra();
+}
+ void  LwpTableHeading::Parse(IXFStream* pOutputStream)
+{
+}
+
+ /*****************************************************************************/
+ LwpTableHint::LwpTableHint(LwpObjectHeader &objHdr, LwpSvStream* pStrm):LwpObject(objHdr, pStrm)
+{}
+
+LwpTableHint::~LwpTableHint()
+{}
+
+void LwpTableHint::Read()
+{
+	cListNext.ReadIndexed(m_pObjStrm);
+	if (LwpFileHeader::m_nFileRevision < 0x0006)
+		m_pObjStrm->SkipExtra();
+
+	// not implemented yet
+	//lbool Problem;
+	// ?Problem = cStart.QuickReadNonEmbedded(m_pObjStrm);
+	
+	cLayout.ReadIndexed(m_pObjStrm);
+	cContent.ReadIndexed(m_pObjStrm);
+	cFlags = m_pObjStrm->QuickReaduInt8();
+	cParent.ReadIndexed(m_pObjStrm);
+	//cNumberHint.QuickRead (m_pObjStrm);
+	cLineNumber = m_pObjStrm->QuickReaduInt32();
+	cPageHint.ReadIndexed (m_pObjStrm);
+
+	m_pObjStrm->SkipExtra ();
+
+	//CContentHint(pFile, pLoader);
+
+	cRow = m_pObjStrm->QuickReaduInt16();
+	cCellHint.Read (m_pObjStrm);
+	cRowContinued = (sal_Bool)m_pObjStrm->QuickReaduInt16();
+	
+	cTable.ReadIndexed(m_pObjStrm);
+	//if (!cTable.PointerTest())
+	//	cTable = NullObjPtr;
+
+	//cCellNumberHint.QuickRead (m_pObjStrm);
+	LwpObjectID cList;
+	cList.ReadIndexed(m_pObjStrm);
+
+	m_pObjStrm->SkipExtra();
+}
+ void  LwpTableHint::Parse(IXFStream* pOutputStream)
+{
+}
+
+ /*****************************************************************************/
+LwpParallelColumns::LwpParallelColumns(LwpObjectHeader &objHdr, LwpSvStream* pStrm):LwpTable(objHdr, pStrm)
+{
+}
+
+LwpParallelColumns::~LwpParallelColumns()
+{
+}
+
+void LwpParallelColumns::Read()
+{
+	LwpTable::Read();
+	cDefaultLeftColumnStyle.ReadIndexed(m_pObjStrm);
+	cDefaultRightColumnStyle.ReadIndexed(m_pObjStrm);
+
+	m_pObjStrm->SkipExtra();
+}
+ /*****************************************************************************/
+LwpGlossary::LwpGlossary(LwpObjectHeader &objHdr, LwpSvStream* pStrm):LwpParallelColumns(objHdr, pStrm)
+{
+}
+
+LwpGlossary::~LwpGlossary()
+{
+}
+sal_uInt16 LwpGlossary::GetNumIndexRows(void)
+{
+	if (GetRow() > 0 && GetRow() <= MAX_NUM_ROWS)
+		return GetRow() - 1;	// Minus one row for repeated heading.
+	return 0;
+}
+
+void LwpGlossary::Read()
+{
+	LwpParallelColumns::Read();
+
+	sal_uInt16 FiledEntries = m_pObjStrm->QuickReaduInt16();
+	sal_uInt16 NumIndexRows = GetNumIndexRows();
+
+	sal_uInt16 * cpIndex = NULL;
+	if (FiledEntries < NumIndexRows)
+	{
+		/* We'll have to do sequential (slow) searches. */
+		m_pObjStrm->SeekRel( FiledEntries * sizeof(sal_uInt16));
+	}
+	else
+	{
+		if (NumIndexRows)
+		{
+			sal_uInt16 EntriesRead, EntryCount;
+			sal_uInt16 *pRowID;
+
+			cpIndex = new sal_uInt16[NumIndexRows];
+
+			if (cpIndex)
+			{
+				pRowID = cpIndex;
+
+				EntriesRead = (FiledEntries > NumIndexRows)? NumIndexRows:FiledEntries;
+
+				for (EntryCount = 1; EntryCount <= EntriesRead; EntryCount++)
+					*pRowID++ = m_pObjStrm->QuickReaduInt16();
+
+				if (FiledEntries > EntriesRead)
+					m_pObjStrm->SeekRel((FiledEntries - EntriesRead)* sizeof(sal_uInt16));
+			}
+		}
+		else
+			m_pObjStrm->SeekRel(FiledEntries * sizeof(sal_uInt16));
+	}
+
+	m_pObjStrm->SkipExtra();
+}
+
diff -urNp lotuswordpro.bak/source/filter/lwptable.hxx lotuswordpro/source/filter/lwptable.hxx
--- lotuswordpro.bak/source/filter/lwptable.hxx	1970-01-01 08:00:00.000000000 +0800
+++ lotuswordpro/source/filter/lwptable.hxx	2008-10-22 11:42:29.000000000 +0800
@@ -0,0 +1,236 @@
+/*************************************************************************
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: IBM Corporation
+ *
+ *  Copyright: 2008 by IBM Corporation
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+/**
+ * @file 
+ *  For LWP filter architecture prototype - table object
+ */
+/*************************************************************************
+ * Change History
+ Mar 2005		 	Created
+ ************************************************************************/
+#ifndef _LWPTABLE_HXX_
+#define _LWPTABLE_HXX_
+
+#include "lwpobj.hxx"
+#include "lwpobjhdr.hxx"
+#include "lwpobjid.hxx"
+#include "lwpstory.hxx"
+#include "lwppara.hxx"
+#include "lwppagehint.hxx"
+#include "lwptools.hxx"
+#include "lwptablelayout.hxx"
+
+class LwpTableLayout;
+/**
+ * @brief
+ * VO_SUPERTABLE object
+ */
+class LwpSuperTable: public LwpContent
+{
+public:
+	LwpSuperTable(LwpObjectHeader &objHdr, LwpSvStream* pStrm);
+	virtual ~LwpSuperTable();
+	
+	virtual void Parse(IXFStream* pOutputStream);
+	//Added by  for XFConvert refactor, 03/31/2005
+	virtual void XFConvert(XFContentContainer* pCont);
+	//End of Add
+protected:
+	void Read();	
+};
+/**
+ * @brief
+ * for VO_TABLE object reading
+ */
+class LwpForkedNotifyList
+{
+public:
+	LwpForkedNotifyList(){};
+	~LwpForkedNotifyList() {};
+	void Read(LwpObjectStream* pObjStrm)
+	{
+		m_PersistentList.Read(pObjStrm);
+	};
+	
+protected:
+	LwpNotifyListPersistent m_PersistentList;
+};
+/**
+ * @brief
+ * VO_TABLE object
+ */
+class LwpTable: public LwpContent
+{
+public:
+	LwpTable(LwpObjectHeader &objHdr, LwpSvStream* pStrm);
+	virtual ~LwpTable();
+	
+	virtual void Parse(IXFStream* pOutputStream);
+	double GetWidth() {return LwpTools::ConvertFromUnitsToMetric(m_nWidth);};
+	double GetHeight() {return LwpTools::ConvertFromUnitsToMetric(m_nHeight);};
+	LwpObjectID * GetDefaultCellStyle() {return &m_DefaultCellStyle;};
+	sal_uInt16 GetRow() {return m_nRow;};
+	sal_uInt16 GetColumn() {return m_nColumn;};
+	LwpTableLayout * GetTableLayout(){return static_cast<LwpTableLayout *>(GetLayout(NULL));};
+	sal_Bool IsNumberDown();
+	virtual sal_Bool IsTable(){ return sal_True;};
+	LwpSuperTableLayout* GetSuperTableLayout();
+protected:
+	LwpDLVListHeadTail m_RowCache;
+	LwpDLVListHeadTail m_ColumnCache;
+	LwpNotifyListPersistent m_CPTempVersionedNotifyList;
+	LwpForkedNotifyList m_CPNotifyList;
+
+	sal_uInt16 		m_nRow, m_nColumn;
+	sal_Int32			m_nHeight;
+	sal_Int32			m_nWidth;
+	sal_Int32			m_nDefaultAutoGrowRowHeight;
+	sal_uInt16 		m_nAttributes;
+	enum lTableAttributes
+	{
+		NUMBER_DOWN					= 0x01,
+		SIZING_VIA_MOUSE_ENABLED	= 0x02,
+		NUMBER_RESET				= 0x04
+	};
+	
+	LwpObjectID		m_Layout;
+	LwpObjectID		m_DefaultCellStyle; // gCVirtualLayout
+	void Read();	
+};
+
+/**
+ * @brief
+ * 
+ */
+class LwpTableHint : public LwpObject
+{
+public:
+	LwpTableHint(LwpObjectHeader &objHdr, LwpSvStream* pStrm);
+	virtual ~LwpTableHint();
+	
+	virtual void Parse(IXFStream* pOutputStream);
+protected:
+	void Read();	
+	sal_uInt16	cRow;
+	LwpContentHintHead cCellHint;
+	sal_Bool cRowContinued;
+	LwpObjectID cTable;
+	//CCellNumberHintHead cCellNumberHint;
+
+	LwpObjectID cListNext;
+
+	LwpFribPtr cStart;
+	LwpObjectID cLayout;		// if the layout is complex then we
+									// store the parent not the left or
+									// right
+	LwpObjectID cContent;
+	sal_uInt8 cFlags;
+	LwpObjectID cParent;
+	//CNumberHintHead cNumberHint;
+	sal_uInt32 cLineNumber;
+	LwpObjectID cPageHint;				// the page hint we belong to
+
+	// cFlags
+	enum
+	{
+		HF_INVALID		= 0x01,		// hint should not be used to start flowing
+		HF_LASTPAGE		= 0x02,		// content ends with this hint
+		HF_REGISTERED	= 0x04,		// the hint has been registered with a
+									// paragraph
+		HF_DIDBULLET	= 0x08,		// We flowed bullet text right before
+									// the end of this stream
+		HF_PROBLEMPARA	= 0x10		// This hint's paragraph changed from disk
+	};
+
+
+};
+/**
+ * @brief
+ * VO_TABLEHEADING object
+ */
+class LwpTableHeading : public LwpTable
+{
+public:
+	LwpTableHeading(LwpObjectHeader &objHdr, LwpSvStream* pStrm);
+	virtual ~LwpTableHeading();
+	
+	virtual void Parse(IXFStream* pOutputStream);
+protected:
+	void Read();	
+
+};
+class LwpParallelColumns : public LwpTable
+{
+public:
+	LwpParallelColumns(LwpObjectHeader &objHdr, LwpSvStream* pStrm);
+	~LwpParallelColumns();
+protected:
+	void Read();
+	LwpObjectID 	cDefaultLeftColumnStyle;
+	LwpObjectID	cDefaultRightColumnStyle;
+};
+#define MAX_NUM_ROWS 8192
+class LwpGlossary : public LwpParallelColumns
+{
+public:
+	LwpGlossary(LwpObjectHeader &objHdr, LwpSvStream* pStrm);
+	~LwpGlossary();
+protected:
+	void Read();
+	sal_uInt16 GetNumIndexRows(void);
+};
+
+
+#endif
diff -urNp lotuswordpro.bak/source/filter/lwptablelayout.cxx lotuswordpro/source/filter/lwptablelayout.cxx
--- lotuswordpro.bak/source/filter/lwptablelayout.cxx	1970-01-01 08:00:00.000000000 +0800
+++ lotuswordpro/source/filter/lwptablelayout.cxx	2008-10-22 11:42:29.000000000 +0800
@@ -0,0 +1,1543 @@
+/*************************************************************************
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: IBM Corporation
+ *
+ *  Copyright: 2008 by IBM Corporation
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+/**
+ * @file 
+ *  For LWP filter architecture prototype - table layouts
+ */
+/*************************************************************************
+ * Change History
+ Mar 2005		 	Created
+ ************************************************************************/
+#include "lwpglobalmgr.hxx"
+#include "lwptablelayout.hxx"
+#include "lwpfoundry.hxx"
+#include "lwpobjfactory.hxx"
+#include "lwpholder.hxx"
+#include "lwptable.hxx"
+#include "lwptblcell.hxx"
+#include "lwpnumericfmt.hxx"
+#include "lwpdlvlist.hxx"
+#include "lwppara.hxx"
+
+#include "xfilter/xfstylemanager.hxx"
+#include "xfilter/xftablestyle.hxx"
+#include "xfilter/xftable.hxx"
+#include "xfilter/xfrow.hxx"
+#include "xfilter/xfrowstyle.hxx"
+#include "xfilter/xfcell.hxx"
+#include "xfilter/xfcellstyle.hxx"
+#include "xfilter/xfcolstyle.hxx"
+#include "xfilter/xfframestyle.hxx"
+#include "xfilter/xfframe.hxx"
+#include	"xfilter/xffloatframe.hxx"
+#include "lwpframelayout.hxx"
+#include "xfilter/xfparastyle.hxx"
+
+LwpSuperTableLayout::LwpSuperTableLayout(LwpObjectHeader &objHdr, LwpSvStream* pStrm)
+	: LwpPlacableLayout(objHdr, pStrm)
+{
+	m_pFrame = new LwpFrame(this);
+}
+
+LwpSuperTableLayout::~LwpSuperTableLayout()
+{
+	if(m_pFrame)
+	{
+		delete m_pFrame;
+	}
+}
+/**
+ * @short    Read super table layout record
+ */
+void LwpSuperTableLayout::Read()
+{
+	LwpPlacableLayout::Read();
+	m_pObjStrm->SkipExtra();
+
+}
+/**
+ * @short   Get child table layout
+ * @return pointer to table layout
+ */
+LwpTableLayout* LwpSuperTableLayout::GetTableLayout()
+{
+	LwpObjectID *pID = GetChildTail();
+
+	while(pID && !pID->IsNull())
+	{
+		LwpVirtualLayout * pLayout = static_cast<LwpVirtualLayout *>(pID->obj());
+		if (!pLayout)
+		{
+			break;
+		}
+		if (pLayout->GetLayoutType() == LWP_TABLE_LAYOUT)
+		{
+			return static_cast<LwpTableLayout *>(pLayout);
+		}
+		pID = pLayout->GetPrevious();
+	}
+
+	return NULL;
+}
+/**
+ * @short   Get effective heading table layout, the one just before table layout is the only one which is effective
+ * @return LwpTableHeadingLayout* - pointer to table heading layout
+ */
+LwpTableHeadingLayout* LwpSuperTableLayout::GetTableHeadingLayout()
+{
+	LwpObjectID *pID = GetChildTail();
+
+	while(pID && !pID->IsNull())
+	{
+		LwpVirtualLayout * pLayout = static_cast<LwpVirtualLayout *>(pID->obj());
+		if (!pLayout)
+		{
+			break;
+		}
+			
+		if (pLayout->GetLayoutType() == LWP_TABLE_HEADING_LAYOUT)
+		{
+			return static_cast<LwpTableHeadingLayout *>(pLayout);
+		}
+		pID = pLayout->GetPrevious();
+	}
+
+	return NULL;
+}
+/**
+ * @short   Register super table layout style
+ */
+void LwpSuperTableLayout::RegisterStyle()
+{
+	// if this layout is style of real table entry
+	LwpTableLayout* pTableLayout = GetTableLayout();
+	if (pTableLayout != NULL)
+	{
+		pTableLayout->SetFoundry(m_pFoundry);
+		pTableLayout->RegisterStyle();		
+	}
+}
+/**
+ * @short   Judge whether table size is according to content, borrowed from Word Pro code
+ * @param 
+ * @return sal_Bool
+ */
+sal_Bool LwpSuperTableLayout::IsSizeRightToContent()
+{
+	/* Only "with paragraph above" tables can size right to content. */
+	if (GetRelativeType() == LwpLayoutRelativityGuts::LAY_INLINE_NEWLINE)
+		return LwpPlacableLayout::IsSizeRightToContent();
+
+	return sal_False;
+}
+/**
+ * @short   Judge whether table is justifiable, borrowed from Word Pro code
+ * @param 
+ * @return sal_Bool
+ */
+sal_Bool LwpSuperTableLayout::IsJustifiable()
+{
+	return (GetRelativeType() != LwpLayoutRelativityGuts::LAY_INLINE_NEWLINE || IsSizeRightToContent());
+}
+/**
+ * @short   Get width of frame outside table
+ * @param pTableStyle - pointer of XFTableStyle
+ * @return double - table width
+ */
+double LwpSuperTableLayout::GetWidth()
+{
+	double dWidth = GetTableWidth();
+	double dLeft	= GetMarginsValue(MARGIN_LEFT);
+	double dRight	= GetMarginsValue(MARGIN_RIGHT);
+
+	return (dWidth + dLeft + dRight);
+}
+/**
+ * @short   Get width of table
+ * @param pTableStyle - pointer of XFTableStyle
+ * @return double - table width
+ */
+double LwpSuperTableLayout::GetTableWidth()
+{
+	sal_Int32 nWidth = 0;
+	if(!IsJustifiable() || ((nWidth = LwpMiddleLayout::GetMinimumWidth()) <= 0))
+	{
+		LwpTableLayout* pTableLayout = GetTableLayout();
+		if(!pTableLayout)
+		{
+			assert(sal_False);
+			return 0;
+		}
+		LwpTable *pTable = pTableLayout->GetTable();
+		if(!pTable)
+		{
+			assert(sal_False);
+			return 0;
+		}
+		double dDefaultWidth = pTable->GetWidth();
+		sal_uInt16 nCol = pTable->GetColumn();
+		
+		double dWidth = 0;
+
+		for(sal_uInt16 i =0; i< nCol; i++)
+		{
+			LwpObjectID *pColumnID = pTableLayout->GetColumnLayoutHead();
+			LwpColumnLayout * pColumnLayout = static_cast<LwpColumnLayout *>(pColumnID->obj());
+			double dColumnWidth = dDefaultWidth;
+			while (pColumnLayout)
+			{
+				if(pColumnLayout->GetColumnID() == i)
+				{
+					dColumnWidth = pColumnLayout->GetWidth();
+					break;
+				}
+				pColumnID = pColumnLayout->GetNext();
+				pColumnLayout = static_cast<LwpColumnLayout *>(pColumnID->obj());
+			}
+			dWidth += dColumnWidth;
+		}
+
+		return dWidth;
+	}
+
+	double dLeft	= GetMarginsValue(MARGIN_LEFT);
+	double dRight	= GetMarginsValue(MARGIN_RIGHT);
+	return LwpTools::ConvertFromUnitsToMetric(nWidth)-dLeft-dRight;
+	
+}
+/**
+ * @short   Apply shadow to table
+ * @param pTableStyle - pointer of XFTableStyle
+ * @return 
+ */
+void LwpSuperTableLayout::ApplyShadow(XFTableStyle *pTableStyle)
+{
+	// use shadow property of supertable
+	XFShadow* pXFShadow = GetXFShadow();
+	if(pXFShadow)
+	{
+		pTableStyle->SetShadow(pXFShadow->GetPosition(), pXFShadow->GetOffset(), pXFShadow->GetColor());
+	}
+}
+/**
+ * @short   Apply pattern fill to table style
+ * @param pTableStyle - pointer of XFTableStyle
+ * @return 
+ */
+void LwpSuperTableLayout::ApplyPatternFill(XFTableStyle* pTableStyle)
+{
+	XFBGImage* pXFBGImage = this->GetFillPattern();
+	if (pXFBGImage)
+	{
+		pTableStyle->SetBackImage(pXFBGImage);
+	}
+}
+
+/**
+ * @short   Apply background to table style
+ * @param pTableStyle - pointer of XFTableStyle
+ * @return 
+ */
+void LwpSuperTableLayout::ApplyBackGround(XFTableStyle* pTableStyle)
+{
+	if (this->IsPatternFill())
+	{
+		ApplyPatternFill(pTableStyle);
+	}
+	else
+	{
+		ApplyBackColor(pTableStyle);
+	}
+}
+/**
+ * @short   Apply back color to table
+ * @param pTableStyle - pointer of XFTableStyle
+ * @return 
+ */
+void LwpSuperTableLayout::ApplyBackColor(XFTableStyle *pTableStyle)
+{
+	LwpColor* pColor = GetBackColor();
+	if(pColor && pColor->IsValidColor())
+	{
+		XFColor aColor(pColor->To24Color());
+		pTableStyle->SetBackColor(aColor);
+	}	
+}
+/**
+ * @short   Apply watermark to  table
+ * @param pTableStyle - pointer of XFTableStyle
+ * @return 
+ */
+void LwpSuperTableLayout::ApplyWatermark(XFTableStyle *pTableStyle)
+{
+	XFBGImage* pBGImage = GetXFBGImage();
+	if(pBGImage)
+	{
+		pTableStyle->SetBackImage(pBGImage);
+	}
+}
+/**
+ * @short   Apply alignment  to table
+ * @param pTableStyle - pointer of XFTableStyle
+ * @return 
+ */
+void LwpSuperTableLayout::ApplyAlignment(XFTableStyle * pTableStyle)
+{
+	LwpPoint aPoint;
+	if (GetGeometry())
+		aPoint = GetGeometry()->GetOrigin();
+	//LwpPoint aPoint = GetOrigin();
+	double dXOffset = LwpTools::ConvertFromUnitsToMetric(aPoint.GetX());
+
+	// add left padding to alignment distance
+	double dLeft = GetMarginsValue(MARGIN_LEFT);
+
+	pTableStyle->SetAlign(enumXFAlignStart, dXOffset+ dLeft);
+}
+/**
+ * @short   Add table to container
+ * @param pCont - pointer of container
+ * @return pCont 
+ */
+void  LwpSuperTableLayout::XFConvert(XFContentContainer* pCont)
+{
+	if ( LwpLayoutRelativityGuts::LAY_INLINE_NEWLINE == GetRelativeType()
+			&& !GetContainerLayout()->IsCell())
+	{
+		LwpTableLayout * pTableLayout = GetTableLayout();
+		if (pTableLayout)
+		{
+			pTableLayout->XFConvert(pCont);
+		}
+	}
+	else if(IsRelativeAnchored())
+	{
+		//anchor to paragraph except "with paragraph above"
+		XFConvertFrame(pCont);
+	}
+	else if(m_pFrame)
+	{
+		//anchor to page, frame, cell
+		m_pFrame->XFConvert(pCont);
+	}
+}
+/**
+ * @short   convert frame which anchor to page
+ * @param 
+ * @return  
+ */
+void  LwpSuperTableLayout::XFConvertFrame(XFContentContainer* pCont, sal_Int32 nStart , sal_Int32 nEnd , sal_Bool bAll)
+{
+	if(m_pFrame)
+	{
+		XFFrame* pXFFrame = NULL;
+		if(nEnd < nStart)
+		{
+			pXFFrame = new XFFrame();
+		}
+		else
+		{
+			pXFFrame = new XFFloatFrame(nStart, nEnd, bAll);
+		}
+	
+		m_pFrame->Parse(pXFFrame, static_cast<sal_uInt16>(nStart));
+		//parse table, and add table to frame
+		LwpTableLayout * pTableLayout = GetTableLayout();
+		if (pTableLayout)
+		{
+			pTableLayout->XFConvert(pXFFrame);
+		}
+		//add frame to the container
+		pCont ->Add(pXFFrame);
+	}
+	
+}
+/**
+ * @short   parse frame
+ * @param 
+ * @return  
+ */
+void  LwpSuperTableLayout::ParseFrame(XFFrame * pXFFrame)
+{
+	if(m_pFrame)
+	{
+		m_pFrame->Parse(pXFFrame);
+	}
+}
+/**
+ * @short  register frame style
+ * @param 
+ * @return  
+ */
+void  LwpSuperTableLayout::RegisterFrameStyle()
+{
+	XFFrameStyle* pFrameStyle = new XFFrameStyle();
+	m_pFrame->RegisterStyle(pFrameStyle);	
+}
+
+LwpTableLayout::LwpTableLayout(LwpObjectHeader &objHdr, LwpSvStream* pStrm)
+	: LwpLayout(objHdr, pStrm),m_pXFTable(NULL), m_nRows(0), m_nCols(0)
+{
+	m_CellsMap.clear();
+	m_pColumns = NULL;
+}
+
+LwpTableLayout::~LwpTableLayout()
+{
+	m_CellsMap.clear();
+
+	if (m_pColumns)
+	{
+		delete [] m_pColumns;
+		m_pColumns = NULL;
+	}
+}
+/**
+ * @short   Get neighbour cell by specifying ROW+COL
+ * @param   nRow
+ * @param   nCol
+ * @return   LwpCellLayout *
+ */
+LwpCellLayout * LwpTableLayout::GetCellByRowCol(sal_uInt16 nRow, sal_uInt16 nCol)
+{
+	if (nRow >= m_nRows || nCol >= m_nCols)
+		return NULL;
+
+	return m_WordProCellsMap[nRow*m_nCols + nCol];
+}
+/**
+ * @short   traverse all table cells
+ * @param  
+ * @param  
+ * @param  
+ */
+void LwpTableLayout::TraverseTable()
+{
+	sal_uInt32 iLoop, jLoop;
+	sal_uInt32 nCount = m_nRows*m_nCols;
+
+	// new cell map nRow*nCOl and initialize
+	for(iLoop = 0;iLoop<nCount; iLoop++)
+	{
+		m_WordProCellsMap.push_back(GetDefaultCellLayout());
+	}
+	
+	// set value
+	LwpObjectID *pRowID = GetChildHead();
+	LwpRowLayout * pRowLayout = static_cast<LwpRowLayout *>(pRowID->obj());
+	while (pRowLayout)
+	{
+		pRowLayout->SetRowMap();
+
+		// for 's analysis job
+		m_RowsMap[pRowLayout->GetRowID()] = pRowLayout;
+		pRowLayout->CollectMergeInfo();
+		// end for 's analysis
+		
+		pRowID = pRowLayout->GetNext();
+		pRowLayout = static_cast<LwpRowLayout *>(pRowID->obj());
+	}
+}
+
+/**
+ * @short   search the cell map
+ * @param   nRow - row id (0 based)
+ * @param   nRow - row id (0 based)
+ * @return   LwpObjectID * - pointer to cell story object ID
+ */
+LwpObjectID * LwpTableLayout::SearchCellStoryMap(sal_uInt16 nRow, sal_uInt16 nCol)
+{
+	if (nRow >= m_nRows || nCol >= m_nCols )
+	{
+		return NULL;
+	}
+
+	LwpCellLayout * pCell = GetCellByRowCol(nRow, nCol);
+	if (pCell)
+	{
+		// maybe connected cell layout
+		// maybe default cell layout
+		if (nRow != pCell->GetRowID() || nCol != pCell->GetColID())
+		{
+			return NULL;
+		}
+		return pCell->GetContent();
+	}
+
+	return NULL;
+}
+
+/**
+ * @short   Get parent super table layout of table layout
+ * @return  LwpSuperTableLayout * - pointer of parent super table layout   
+ */
+LwpSuperTableLayout * LwpTableLayout::GetSuperTableLayout()
+{
+	return static_cast<LwpSuperTableLayout *>(GetParent()->obj());
+}
+/**
+ * @short    Get table pointer
+ * @return   LwpTable * - content table pointer
+ */
+LwpTable *  LwpTableLayout::GetTable()
+{
+	LwpTable *pTable = static_cast<LwpTable *>(m_Content.obj());
+	return pTable;
+}
+/**
+ * @short   Get column style name by column ID
+ * @param   sal_uInt16 -- col id(0 based)
+ * @return OUString - name of column style
+ */
+OUString LwpTableLayout::GetColumnWidth(sal_uInt16 nCol)
+{
+	if (nCol >= m_nCols)
+	{
+		assert(sal_False);
+		return m_DefaultColumnStyleName;
+	}
+
+	LwpColumnLayout * pCol = m_pColumns[nCol];
+	if (pCol)
+	{
+		return pCol->GetStyleName();
+	}
+
+	return m_DefaultColumnStyleName;
+}
+/**
+ * @short   analyze all columns to get whole table width and width of all columns
+ * @short   and register all column styles
+ * @param   none
+ */
+void LwpTableLayout::RegisterColumns()
+{
+	LwpTable * pTable = GetTable();
+	LwpSuperTableLayout * pSuper = GetSuperTableLayout();
+
+	sal_uInt16 nCols = m_nCols;
+
+	m_pColumns = new LwpColumnLayout *[nCols];
+	sal_Bool * pWidthCalculated = new sal_Bool[nCols];
+	for(sal_uInt16 i=0;i<nCols; i++)
+	{
+		pWidthCalculated[i] = sal_False;
+		m_pColumns[i] = NULL;
+	}
+	
+	double dDefaultColumn = pTable->GetWidth();
+	sal_uInt16 nJustifiableColumn = nCols;
+	
+	double dTableWidth = pSuper->GetTableWidth();
+
+	// Get total width of justifiable columns
+	// NOTICE: all default columns are regarded as justifiable columns
+	LwpObjectID *pColumnID = GetColumnLayoutHead();
+	LwpColumnLayout * pColumnLayout = static_cast<LwpColumnLayout *>(pColumnID->obj());
+	while (pColumnLayout)
+	{
+		m_pColumns[pColumnLayout->GetColumnID()] = pColumnLayout;
+		if (!pColumnLayout->IsJustifiable())
+		{
+			pWidthCalculated[pColumnLayout->GetColumnID()] = sal_True;
+			dTableWidth -= pColumnLayout->GetWidth();
+			nJustifiableColumn --;
+		}
+
+		pColumnID = pColumnLayout->GetNext();
+		pColumnLayout = static_cast<LwpColumnLayout *>(pColumnID->obj());
+	}
+	
+	// if all columns are not justifiable, the rightmost column will be changed to justifiable
+	if(nJustifiableColumn == 0)
+	{
+		nJustifiableColumn ++;
+		if (m_pColumns[nCols - 1])
+		{
+			pWidthCalculated[nCols-1] = sal_False;
+			dTableWidth += m_pColumns[nCols-1]->GetWidth();
+		}
+		else
+		{
+			// this can't happen
+			dTableWidth = dDefaultColumn;
+			assert(sal_False);
+		}
+	}
+	
+	// justifiable columns will share the remain width averagely
+	dDefaultColumn = dTableWidth/nJustifiableColumn; 
+
+	// register defualt column style
+	XFColStyle *pColStyle = new XFColStyle();
+	pColStyle->SetWidth(static_cast<float>(dDefaultColumn));
+	
+	XFStyleManager* pXFStyleManager = LwpGlobalMgr::GetInstance()->GetXFStyleManager();
+	m_DefaultColumnStyleName =  pXFStyleManager->AddStyle(pColStyle)->GetStyleName();
+
+	// register existed column style
+    sal_uInt16 i=0;
+	for( i=0;i<nCols; i++)
+	{
+		if(m_pColumns[i])
+		{
+			m_pColumns[i]->SetFoundry(m_pFoundry);
+			if(!pWidthCalculated[i])
+			{
+				// justifiable ----register style with calculated value
+				m_pColumns[i]->SetStyleName(m_DefaultColumnStyleName);
+			}
+			else
+			{
+				// not justifiable ---- register style with original value
+				m_pColumns[i]->RegisterStyle(m_pColumns[i]->GetWidth());
+			}
+		}
+	}
+	delete [] pWidthCalculated;
+}
+/**
+ * @short    register all row styles
+ * @param   none
+ */
+void LwpTableLayout::RegisterRows()
+{
+	LwpTable * pTable = GetTable();
+	if (pTable == NULL)
+	{
+		assert(sal_False);
+		return;
+	}
+
+	// register default row style
+	XFRowStyle * pRowStyle = new  XFRowStyle();
+	if (m_nDirection & 0x0030)
+	{
+		pRowStyle->SetMinRowHeight((float)pTable->GetHeight());
+	}
+	else
+	{
+		pRowStyle->SetRowHeight((float)pTable->GetHeight());
+	}
+	XFStyleManager* pXFStyleManager = LwpGlobalMgr::GetInstance()->GetXFStyleManager(); 
+	m_DefaultRowStyleName =  pXFStyleManager->AddStyle(pRowStyle)->GetStyleName();
+
+	// register style of rows
+	LwpObjectID * pRowID = GetChildHead();
+	LwpRowLayout * pRowLayout = static_cast<LwpRowLayout *>(pRowID->obj());
+	while (pRowLayout)
+	{
+		pRowLayout->SetFoundry(m_pFoundry);
+		pRowLayout->RegisterStyle();
+		
+		pRowID = pRowLayout->GetNext();
+		pRowLayout = static_cast<LwpRowLayout *>(pRowID->obj());
+	}
+}
+/**
+ * @short   register table style, if needed, including frame style
+ * @param   none
+ */
+void LwpTableLayout::RegisterStyle()
+{
+	// get super table layout
+	LwpSuperTableLayout * pSuper = GetSuperTableLayout();
+	if(!pSuper)
+	{
+		assert(sal_False);
+		return;
+	}
+	
+	// get table
+	LwpTable * pTable = GetTable();
+	if (pTable == NULL)
+	{
+		assert(sal_False);
+		return;
+	}
+
+	// get row/column number of this table
+	m_nRows = pTable->GetRow();
+	m_nCols = pTable->GetColumn();
+	
+	// get default cell layout of current table
+	LwpObjectID * pID= pTable->GetDefaultCellStyle();
+	if (pID)
+	{
+		m_pDefaultCellLayout = static_cast<LwpCellLayout *>(pID->obj());
+	}
+
+	// register columns styles
+	RegisterColumns();
+	
+	// register style of whole table
+	XFTableStyle * pTableStyle = new XFTableStyle();
+	
+	sal_uInt8 nType = pSuper->GetRelativeType();
+	// If the table is not "with paragraph above" placement, create an frame style 
+	// by supertable layout
+	if ( LwpLayoutRelativityGuts::LAY_INLINE_NEWLINE == nType 
+		&& !pSuper->GetContainerLayout()->IsCell())	
+	{
+		//with para above
+//		pSuper->ApplyBackColor(pTableStyle);
+		pSuper->ApplyBackGround(pTableStyle);
+		pSuper->ApplyWatermark(pTableStyle);
+		pSuper->ApplyShadow(pTableStyle);
+		pSuper->ApplyAlignment(pTableStyle);
+		pTableStyle->SetWidth(pSuper->GetTableWidth());
+	}
+	else
+	{
+		pSuper->RegisterFrameStyle();
+		pTableStyle->SetAlign(enumXFAlignCenter);
+		pTableStyle->SetWidth(pSuper->GetTableWidth());
+	}
+	XFStyleManager* pXFStyleManager = LwpGlobalMgr::GetInstance()->GetXFStyleManager(); 
+	m_StyleName = pXFStyleManager->AddStyle(pTableStyle)->GetStyleName();
+
+	//convert to OO table now and register row stle
+	// traverse
+	TraverseTable();
+	
+	SplitConflictCells();
+
+	// Register rows layouts, it must be after SplitConflictCells
+	RegisterRows();
+	
+	// Parse table
+	Parse();
+	
+	
+	//Comment:The old code doesn't check if the LwpFoundry pointer is NULL,
+	//		  So the NULL pointer cause sodc frozee. Add code to check the 
+	//		  the pointer.
+	//New Code
+	if( GetFoundry() && GetTable() )
+	
+	PutCellVals( GetFoundry(),*GetTable()->GetObjectID() );
+}
+/**
+ * @short   read table layout
+ * @param   none
+ */
+void LwpTableLayout::Parse()
+{
+	// get super table layout
+	LwpSuperTableLayout * pSuper = GetSuperTableLayout();
+	if(!pSuper)
+	{
+		assert(sal_False);
+		return;
+	}
+
+	// set name of object	
+	m_pXFTable = new XFTable;
+	m_pXFTable->SetTableName(pSuper->GetName()->str());	
+	// set table style
+	m_pXFTable->SetStyleName(m_StyleName);
+	
+	sal_uInt16 nRow = m_nRows;
+	sal_uInt8 nCol = (sal_uInt8)m_nCols;		
+	
+	//process header rows
+	LwpTableHeadingLayout* pTableHeading;
+	pTableHeading = pSuper->GetTableHeadingLayout();
+	sal_uInt16 nStartHeadRow;
+	sal_uInt16 nEndHeadRow;
+	sal_uInt16 nContentRow;
+	if (pTableHeading)
+	{
+		pTableHeading->GetStartEndRow(nStartHeadRow,nEndHeadRow);
+		if (nStartHeadRow != 0)
+			ConvertTable(m_pXFTable,0,nRow,0,nCol);	
+		else
+		{
+			nContentRow = ConvertHeadingRow(m_pXFTable,nStartHeadRow,nEndHeadRow+1);
+			ConvertTable(m_pXFTable,nContentRow,nRow,0,nCol);	
+		}	
+	}
+	else	
+		ConvertTable(m_pXFTable,0,nRow,0,nCol);	
+}
+
+/**
+ * @short   read table layout
+ * @param   none
+ */
+void LwpTableLayout::Read()
+{
+	LwpLayout::Read();
+
+	// before layout hierarchy rework!
+	if(LwpFileHeader::m_nFileRevision < 0x000b)
+	{
+		assert(sal_False);
+	}
+	m_ColumnLayout.ReadIndexed(m_pObjStrm);
+	
+	m_pObjStrm->SkipExtra();
+}
+
+/**
+ * @short    Convert table
+ * @param 
+ * @return   pCont - container which will contain table
+ */
+void LwpTableLayout::XFConvert(XFContentContainer* pCont)
+{
+	
+	pCont->Add(m_pXFTable);
+}
+/**
+ * @short   convert heading row
+ * @param  pXFTable - pointer of table
+ * @param  nStartRow - start heading row ID
+ * @param  nEndRow - end heading row ID
+ */
+sal_uInt16 LwpTableLayout::ConvertHeadingRow(
+		XFTable* pXFTable,sal_uInt16 nStartHeadRow,sal_uInt16 nEndHeadRow)
+{
+	sal_uInt16 nContentRow;
+	sal_uInt8 nCol = static_cast<sal_uInt8>(GetTable()->GetColumn());
+	sal_uInt8 nFirstColSpann = 1;
+	XFTable* pTmpTable = new XFTable;
+	XFRow* pXFRow;
+		
+	ConvertTable(pTmpTable,nStartHeadRow,nEndHeadRow,0,nCol);
+	
+	sal_uInt16 nRowNum = static_cast<sal_uInt16>(pTmpTable->GetRowCount());
+	sal_uInt8* CellMark = new sal_uInt8[nRowNum];
+	sal_Bool bFindFlag = sal_False;
+	
+	if (nRowNum == 1)
+	{
+		pXFRow = pTmpTable->GetRow(1);
+		pXFTable->AddHeaderRow(pXFRow);
+		pTmpTable->RemoveRow(1);
+		nContentRow = nEndHeadRow;		
+	}
+	else
+	{	
+		bFindFlag = FindSplitColMark(pTmpTable,CellMark,nFirstColSpann);
+		
+		if (bFindFlag)//split to 2 cells
+		{
+			SplitRowToCells(pTmpTable,pXFTable,nFirstColSpann,CellMark);
+			nContentRow = nEndHeadRow;
+		}		
+		else//can not split,the first row will be the heading row,the rest will be content row
+		{
+			pXFRow = pTmpTable->GetRow(1);
+			pXFTable->AddHeaderRow(pXFRow);
+			pTmpTable->RemoveRow(1);
+			nContentRow = m_RowsMap[0]->GetCurMaxSpannedRows(0,nCol);
+		}	
+	}
+	delete pTmpTable;
+	delete [] CellMark;
+	return nContentRow;
+}
+
+void LwpTableLayout::SplitRowToCells(XFTable* pTmpTable,XFTable* pXFTable,
+		sal_uInt8 nFirstColSpann,sal_uInt8* pCellMark)
+{
+	sal_uInt16 i;
+	sal_uInt8 j;
+	sal_uInt16 nRowNum = static_cast<sal_uInt16>(pTmpTable->GetRowCount());
+	sal_uInt8 nCol = static_cast<sal_uInt8>(GetTable()->GetColumn());	
+	
+	XFRow* pXFRow = new XFRow;
+	
+	//register style for heading row
+	double fHeight = 0;
+	OUString styleName;
+	XFRowStyle* pRowStyle = new XFRowStyle;
+	styleName = pTmpTable->GetRow(1)->GetStyleName();	
+
+	// get settings of the row and assign them to new row style
+	XFStyleManager* pXFStyleManager = LwpGlobalMgr::GetInstance()->GetXFStyleManager(); 
+	XFRowStyle *pTempRowStyle = static_cast<XFRowStyle*>(pXFStyleManager->FindStyle(styleName));
+	if (pTempRowStyle)
+		*pRowStyle = *pTempRowStyle;
+	
+	for (i=1;i<=nRowNum;i++)
+	{
+		styleName = pTmpTable->GetRow(i)->GetStyleName();						
+		fHeight+=static_cast<XFRowStyle*>(pXFStyleManager->FindStyle(styleName))->GetRowHeight();
+	}
+	if (m_nDirection & 0x0030)
+	{
+		pRowStyle->SetMinRowHeight((float)fHeight);
+	}
+	else
+	{
+		pRowStyle->SetRowHeight((float)fHeight);
+	}
+	pXFRow->SetStyleName(pXFStyleManager->AddStyle(pRowStyle)->GetStyleName());				
+	
+	//construct headong row
+	XFCell* pXFCell1 = new XFCell;
+	XFCell* pXFCell2 = new XFCell;
+	XFTable* pSubTable1 = new XFTable;
+	XFTable* pSubTable2 = new XFTable;
+	XFRow* pNewRow;
+	XFRow* pOldRow;
+	XFCell* pNewCell;
+	
+	for (i=1;i<=nRowNum;i++)
+	{
+		pOldRow = pTmpTable->GetRow(i);
+		pNewRow = new XFRow;	
+		pNewRow->SetStyleName(pOldRow->GetStyleName());				
+		for (j=1;j<=pCellMark[i];j++)
+		{
+			pNewCell = pOldRow->GetCell(j);
+			pNewRow->AddCell(pNewCell);
+		}
+		pSubTable1->AddRow(pNewRow);
+	}
+	ConvertColumn(pSubTable1,0,nFirstColSpann);//add column info
+	
+	pXFCell1->Add(pSubTable1);
+	pXFCell1->SetColumnSpaned(nFirstColSpann);
+	pXFRow->AddCell(pXFCell1);
+	
+	for (i=1;i<=nRowNum;i++)
+	{
+		pOldRow = pTmpTable->GetRow(i);
+		pNewRow = new XFRow;
+		pNewRow->SetStyleName(pOldRow->GetStyleName());				
+		for(j=pCellMark[i]+1;j<=pOldRow->GetCellCount();j++)
+		{
+			pNewCell = pOldRow->GetCell(j);
+			pNewRow->AddCell(pNewCell);
+		}
+		pSubTable2->AddRow(pNewRow);
+
+	}
+	ConvertColumn(pSubTable2,nFirstColSpann,nCol);//add column info
+	pXFCell2->Add(pSubTable2);
+	pXFCell2->SetColumnSpaned(nCol-nFirstColSpann);
+	pXFRow->AddCell(pXFCell2);
+				
+	pXFTable->AddHeaderRow(pXFRow);
+	
+	//remove tmp table
+	for (i=1;i<=nRowNum;i++)
+	{
+		pOldRow = pTmpTable->GetRow(i);
+		for(j=1;j<=pOldRow->GetCellCount();j++)
+			pOldRow->RemoveCell(j);	
+		pTmpTable->RemoveRow(i);				
+	}		
+}
+
+/**
+ * @short   find if the heading rows can be split to 2 cells
+ * @param  pXFTable - pointer of tmp XFtable
+ * @param  CellMark - pointer of cell mark array
+ */
+sal_Bool  LwpTableLayout::FindSplitColMark(XFTable* pXFTable,sal_uInt8* pCellMark,
+			sal_uInt8& nMaxColSpan)
+{
+	sal_uInt16 nRowNum = static_cast<sal_uInt16>(pXFTable->GetRowCount());
+	sal_uInt8 nColNum = static_cast<sal_uInt8>(pXFTable->GetColumnCount());
+	sal_uInt8 nCellMark=0;
+	sal_uInt8 nCount;
+	sal_uInt8 nColSpan;
+	sal_Bool bFindFlag = sal_False;	
+	XFRow* pTmpRow;
+	
+	for(sal_uInt8 i=1;i<=nColNum;i++)
+	{
+		sal_uInt16 nRowLoop;
+		sal_uInt8 nCellLoop;
+		
+		//find current max column span
+		nMaxColSpan = 1;
+		for (nRowLoop=1;nRowLoop<=nRowNum;nRowLoop++)
+		{
+			nColSpan = 0;
+			for(nCellLoop=1; nCellLoop<i+1; nCellLoop++)
+			{
+				pTmpRow = pXFTable->GetRow(nRowLoop);
+				XFCell* pCell = pTmpRow->GetCell(nCellLoop);
+				if (pCell)
+					nColSpan += static_cast<sal_uInt8>(pCell->GetColSpaned());
+				else
+					return sal_False;
+			}
+			if (nColSpan > nMaxColSpan)
+				nMaxColSpan = nColSpan;
+			pCellMark[nRowLoop] = 0;//reset all cell mark to zero
+		}
+		
+		//find if other row has the same colum
+		for (nRowLoop=1;nRowLoop<=nRowNum;nRowLoop++)
+		{
+			pTmpRow = pXFTable->GetRow(nRowLoop);
+			nCount = 0;
+			nCellMark = 0;
+			for (nCellLoop=1; nCellLoop<=pTmpRow->GetCellCount(); nCellLoop++)
+			{
+				if (nCount>nMaxColSpan)
+					break;
+				nCount+= static_cast<sal_uInt8>(pTmpRow->GetCell(nCellLoop)->GetColSpaned());
+				if (nCount == nMaxColSpan)
+				{
+					nCellMark = nCellLoop;
+					break;
+				}
+			}
+			if (nCellMark == 0)
+				break;
+			else
+				pCellMark[nRowLoop] = nCellMark;
+		}
+		for(nRowLoop=1;nRowLoop<=nRowNum;nRowLoop++)//check if all ==0,break
+		{	
+			if (pCellMark[nRowLoop] == 0)
+				break;
+		}
+		if (nRowLoop == nRowNum+1)
+		{
+			bFindFlag = sal_True;
+			return bFindFlag;
+		}
+			
+	}
+	return bFindFlag;
+}
+
+/**
+ * @short   convert word pro table to SODC table
+ * @param  pXFTable - pointer of table
+ * @param  nStartRow - start row ID
+ * @param  nEndRow - end row ID
+ * @param  nStartCol - start column ID
+ * @param  nEndCol - end column ID 
+ */
+void LwpTableLayout::ConvertTable(XFTable* pXFTable,sal_uInt16 nStartRow,
+				sal_uInt16 nEndRow,sal_uInt8 nStartCol,sal_uInt8 nEndCol)
+{
+	//out put column info TO BE CHANGED,note by ,2005/4/4
+	ConvertColumn(pXFTable,nStartCol,nEndCol);
+	//note end
+	
+	std::map<sal_uInt16,LwpRowLayout*>::iterator iter;
+
+	for (sal_uInt16 i=nStartRow; i<nEndRow;)
+	{
+		iter = m_RowsMap.find(i);
+		if (iter == m_RowsMap.end())
+		{			
+			ConvertDefaultRow(pXFTable,nStartCol,nEndCol,i);
+			i++;
+		}
+		else
+		{	
+			LwpRowLayout* pRow = iter->second;
+			if (pRow->GetCurMaxSpannedRows(nStartCol,nEndCol) == 1)
+			{
+				pRow->ConvertCommonRow(pXFTable,nStartCol,nEndCol);
+				i++;			
+			}
+			else
+			{		
+				pRow->ConvertRow(pXFTable,nStartCol,nEndCol);		
+				i += pRow->GetCurMaxSpannedRows(nStartCol,nEndCol);
+			}
+		}
+	}
+}
+
+/**
+ * @short   apply numeric value and formula to cell
+ * @param  pFoundry - pointer of foundry
+ * @param  aTableID - table ID
+ */
+void LwpTableLayout::PutCellVals(LwpFoundry* pFoundry, LwpObjectID aTableID)
+{
+	
+	//Comment:The old code doesn't check if the LwpFoundry pointer is NULL,
+	//		  So the NULL pointer cause sodc frozee. Add code to check the 
+	//		  the pointer.
+	//New Code
+	if( !pFoundry ) return;
+	
+
+	try{
+
+		LwpDLVListHeadHolder* pHolder = (LwpDLVListHeadHolder*)pFoundry->GetNumberManager()->GetTableRangeID().obj();
+
+		LwpTableRange* pTableRange = (LwpTableRange*)pHolder->GetHeadID()->obj();
+
+		//Look up the table
+		while (NULL!=pTableRange)
+		{
+			LwpObjectID aID = pTableRange->GetTableID();
+			if (aID == aTableID)
+			{
+				break;
+			}
+			pTableRange = pTableRange->GetNext();
+		}
+
+		if (pTableRange)
+		{		
+			LwpCellRange* pRange = (LwpCellRange*)pTableRange->GetCellRangeID().obj();
+			LwpFolder* pFolder = (LwpFolder*)pRange->GetFolderID().obj();
+			LwpObjectID aRowListID = pFolder->GetChildHeadID();
+			LwpRowList* pRowList = (LwpRowList*)aRowListID.obj();
+
+			//loop the rowlist
+			while( NULL!=pRowList)
+			{
+				sal_uInt16 nRowID =  pRowList->GetRowID();
+				{
+					LwpCellList* pCellList = (LwpCellList*)pRowList->GetChildHeadID().obj();
+					//loop the celllist
+					while( NULL!=pCellList) 
+					{
+						{//put cell
+							sal_uInt16 nColID = pCellList->GetColumnID();
+							
+							XFCell* pCell = GetCellsMap(nRowID,static_cast<sal_uInt8>(nColID));
+							if (pCell)
+							{
+								pCellList->Convert(pCell, this);
+
+								//process paragraph
+								PostProcessParagraph(pCell, nRowID, nColID);
+							}
+							else
+							{
+								//Hidden cell would not be in cellsmap
+								assert(false);
+							}
+						}
+						pCellList = (LwpCellList*)pCellList->GetNextID().obj();
+					}
+				}
+				pRowList =(LwpRowList*)pRowList->GetNextID().obj();
+			}
+		}
+
+	}catch (...) {
+		assert(false);
+	}
+}
+
+/**
+ * @short   1. set number right alignment to right if number 2. remove tab added before if number
+ * @param  pCell - cell which to be process
+ * @param  nRowID - row number in Word Pro file
+ * @param  nColID - column number in Word Pro file
+ */
+void LwpTableLayout::PostProcessParagraph(XFCell *pCell, sal_uInt16 nRowID, sal_uInt16 nColID)
+{
+	// if number right, set alignment to right
+	LwpCellLayout * pCellLayout = GetCellByRowCol(nRowID, nColID);
+	if(pCellLayout)
+	{
+		XFParagraph * pXFPara = NULL;
+		//mod by ,fix bug 2759,2006/3/22
+		pXFPara = static_cast<XFParagraph*>(pCell->FindFirstContent(enumXFContentPara));
+		if (!pXFPara)
+			return;
+		//mod end
+		XFColor aColor;
+		XFColor aNullColor = XFColor();
+		
+		if ( pXFPara)
+		{
+			OUString sNumfmt = pCellLayout->GetNumfmtName();
+			sal_Bool bColorMod = sal_False;
+			XFNumberStyle* pNumStyle = NULL;
+			XFStyleManager* pXFStyleManager = LwpGlobalMgr::GetInstance()->GetXFStyleManager(); 
+			if (sNumfmt.getLength())
+			{
+				pNumStyle = (XFNumberStyle*)pXFStyleManager->FindStyle( sNumfmt);
+				aColor = pNumStyle->GetColor();
+				if ( pNumStyle &&  aColor != aNullColor )
+					bColorMod = sal_True;//end
+			}
+
+			XFParaStyle * pStyle = pXFStyleManager->FindParaStyle(pXFPara->GetStyleName());
+			if (pStyle->GetNumberRight()  || bColorMod)
+			{
+				XFParaStyle* pOverStyle = new XFParaStyle;
+				*pOverStyle = *pStyle;
+						
+				if (pStyle->GetNumberRight())
+					pOverStyle->SetAlignType(enumXFAlignEnd);
+							
+				if (bColorMod)
+				{
+					XFFont* pFont = pOverStyle->GetFont();
+					aColor = pFont->GetColor();
+					if ( aColor == aNullColor )
+					{						
+						XFFont* pNewFont = new XFFont;
+						aColor = pNumStyle->GetColor();
+						pNewFont->SetColor(aColor);								
+						pOverStyle->SetFont(pNewFont);
+					}
+				}
+							
+				pOverStyle->SetStyleName(A2OUSTR(""));					
+				OUString StyleName = pXFStyleManager->AddStyle(pOverStyle)->GetStyleName();
+						
+				pXFPara->SetStyleName(StyleName);
+			}
+		}
+	}
+}
+
+/**
+ * @short   Parse all cols of table
+ * @param  pXFTable - pointer to created XFTable
+ */
+void LwpTableLayout::ConvertColumn(XFTable *pXFTable,sal_uInt8 nStartCol,sal_uInt8 nEndCol)
+{
+	LwpTable * pTable = GetTable();
+	if (!pTable)
+	{
+		assert(sal_False);
+		return;
+	}
+
+	for (sal_uInt16 iLoop = 0; iLoop < nEndCol-nStartCol ; iLoop ++)		
+	{
+		// add row to table
+		LwpObjectID *pColID = GetColumnLayoutHead();
+		LwpColumnLayout * pColumnLayout = static_cast<LwpColumnLayout *>(pColID->obj());
+		while (pColumnLayout)
+		{
+			if (pColumnLayout->GetColumnID() == (iLoop+nStartCol))
+			{
+				pXFTable->SetColumnStyle(iLoop+1,  pColumnLayout->GetStyleName());
+				break;
+			}
+			pColID = pColumnLayout->GetNext();
+			pColumnLayout = static_cast<LwpColumnLayout *>(pColID->obj());
+		}
+		if (!pColumnLayout)
+		{
+			pXFTable->SetColumnStyle(iLoop+1, m_DefaultColumnStyleName);
+		}
+	}
+}
+/**
+ * @short   split conflict merged cells 
+ */
+void LwpTableLayout::SplitConflictCells()
+{
+	LwpTable * pTable = GetTable();
+	if (!pTable)
+		return;
+	sal_uInt16 nCol = pTable->GetColumn();
+	sal_uInt16 nRow = pTable->GetRow();
+
+	sal_uInt16 nEffectRows;
+	std::map<sal_uInt16,LwpRowLayout*>::iterator iter1;
+	std::map<sal_uInt16,LwpRowLayout*>::iterator iter2;
+	LwpRowLayout* pRowLayout;
+	LwpRowLayout* pEffectRow;
+	
+	for (sal_uInt16 i=0; i<nRow; )
+	{
+		iter1 = m_RowsMap.find(i);
+		if (iter1 == m_RowsMap.end())//default rows
+		{
+	        	i++;
+			continue;
+		}
+		pRowLayout= iter1->second;
+		if (pRowLayout->GetMergeCellFlag() == sal_False)
+		{
+			i++;
+			continue;
+		}
+		else
+		{
+			nEffectRows = i + pRowLayout->GetCurMaxSpannedRows(0,(sal_uInt8)nCol);
+			
+			for (sal_uInt16 j = i+1; j<nEffectRows; j++)
+			{
+				iter2 = m_RowsMap.find(j);
+	        		if (iter2 == m_RowsMap.end())
+	        			continue;
+	        		pEffectRow = iter2->second;
+				if (pEffectRow->GetMergeCellFlag() == sal_False)
+					continue;
+				else
+					pEffectRow->SetCellSplit(nEffectRows);
+			}			
+			i = nEffectRows;
+		}
+	}//end for 
+
+}
+/**
+ * @short   add default row which are missing in the file
+ * @param   pXFTable - pointer to new created table
+ * @param   nStartCol - starting column	
+ * @param   nEndCol  - end column
+ * @return   pXFTable
+ */
+void LwpTableLayout::ConvertDefaultRow(XFTable* pXFTable,sal_uInt8 nStartCol,
+		 sal_uInt8 nEndCol,sal_uInt16 nRowID)
+{
+	// current row doesn't exist in the file
+	XFRow * pRow = new XFRow();
+	pRow->SetStyleName(m_DefaultRowStyleName);
+	sal_Bool bIsTop = sal_False;
+	sal_Bool bIsRight = sal_False;
+
+	for (sal_uInt16 j =0;j < nEndCol-nStartCol; j++)
+	{
+		// if table has default cell layout, use it to ConvertCell
+		// otherwise use blank cell
+		XFCell * pCell = NULL;
+		if (m_pDefaultCellLayout)
+		{
+			pCell = m_pDefaultCellLayout->ConvertCell(
+				*GetTable()->GetObjectID(),nRowID,j+nStartCol);
+		}
+		else
+		{
+			pCell = new XFCell();
+		}
+		pRow->AddCell(pCell);
+	}
+	
+	pXFTable->AddRow(pRow);
+}
+/**
+ * @short   set cell map info
+ * @param   pXFCell - pointer to xfcell
+ * @param   nRow - row id	
+ * @param   nCol - column id
+ */
+void LwpTableLayout::SetCellsMap(sal_uInt16 nRow,sal_uInt8 nCol,XFCell* pXFCell)
+{
+	std::pair<std::pair<sal_uInt16,sal_uInt8>,XFCell*> cell;
+	std::pair<sal_uInt16,sal_uInt8> pos;
+	pos.first = nRow;
+	pos.second = nCol;
+	cell.first = pos;
+	cell.second = pXFCell;
+	m_CellsMap.insert(cell);
+}
+
+/**
+ * @short   get cell map info
+ * @param   nRow - row id	
+ * @param   nCol  - column id
+ * @return  pXFCell
+ */
+XFCell* LwpTableLayout::GetCellsMap(sal_uInt16 nRow,sal_uInt8 nCol)
+{
+	std::pair<sal_uInt16,sal_uInt8> pos;
+	pos.first = nRow;
+	pos.second = nCol;
+	std::map<std::pair<sal_uInt16,sal_uInt8>,XFCell*>::iterator iter;
+	iter = 	m_CellsMap.find(pos);
+	if (iter == m_CellsMap.end())
+		return NULL;
+	return iter->second;
+}
+/**
+ * @descr   Get row layout by row id
+ * @param   nRow - row id
+ */
+ LwpRowLayout* LwpTableLayout::GetRowLayout(sal_uInt16 nRow)
+{
+	LwpObjectID *pRowID = GetChildHead();
+	LwpRowLayout * pRowLayout = static_cast<LwpRowLayout *>(pRowID->obj());
+	while (pRowLayout)
+	{
+		if(pRowLayout->GetRowID() == nRow)
+			return pRowLayout;
+		
+		pRowID = pRowLayout->GetNext();
+		pRowLayout = static_cast<LwpRowLayout *>(pRowID->obj());
+	}
+	return NULL;
+}
+
+
+//add end by 
+LwpColumnLayout::LwpColumnLayout(LwpObjectHeader &objHdr, LwpSvStream* pStrm)
+	: LwpVirtualLayout(objHdr, pStrm)
+{}
+
+LwpColumnLayout::~LwpColumnLayout()
+{}
+void LwpColumnLayout::Read()
+{
+	LwpObjectStream* pStrm = m_pObjStrm;
+	
+	LwpVirtualLayout::Read();
+
+	sal_uInt16 colid;
+
+	colid = pStrm->QuickReaduInt16();	// forced to lushort
+	ccolid = (sal_uInt8)colid;	// Phillip
+	cwidth = pStrm->QuickReadInt32();
+	
+	pStrm->SkipExtra();
+}
+
+void LwpColumnLayout::RegisterStyle(double dCalculatedWidth)
+{
+	XFColStyle * pColStyle = new XFColStyle();
+	pColStyle->SetWidth(static_cast<float>(dCalculatedWidth));
+	XFStyleManager* pXFStyleManager = LwpGlobalMgr::GetInstance()->GetXFStyleManager(); 
+	m_StyleName = pXFStyleManager->AddStyle(pColStyle)->GetStyleName();
+}
+
+LwpTableHeadingLayout::LwpTableHeadingLayout(LwpObjectHeader &objHdr, LwpSvStream* pStrm)
+	: LwpTableLayout(objHdr, pStrm)
+{}
+
+LwpTableHeadingLayout::~LwpTableHeadingLayout()
+{}
+/**
+ * @short   read table heading layout
+ * @param 
+ * @return 
+ */
+void LwpTableHeadingLayout::Read()
+{
+	LwpTableLayout::Read();
+	
+	cStartRow = m_pObjStrm->QuickReaduInt16();
+	cEndRow = m_pObjStrm->QuickReaduInt16();
+	
+	m_pObjStrm->SkipExtra();
+
+}
+/**
+ * @short   get start and end row number of table heading 
+ * @param 
+ * @return *pStartRow - starting row number
+ * @return *pEndRow -   end row number
+ */
+void LwpTableHeadingLayout::GetStartEndRow(sal_uInt16& nStartRow, sal_uInt16& nEndRow)
+{
+	nStartRow = cStartRow;
+	nEndRow = cEndRow;
+}
+/**
+ * @short   get first row heading layout of table heading
+ * @param 
+ * @return LwpRowHeadingLayout * - pointer to first row heading layout of table heading
+ */
+LwpRowHeadingLayout * LwpTableHeadingLayout::GetFirstRowHeadingLayout()
+{
+	LwpObjectID *pID = GetChildHead();
+	if(pID && !pID->IsNull())
+	{
+		LwpRowHeadingLayout * pHeadingRow = static_cast<LwpRowHeadingLayout *>(pID->obj());
+		return pHeadingRow;
+	}
+	return NULL;
+}
+
+LwpSuperParallelColumnLayout::LwpSuperParallelColumnLayout(LwpObjectHeader &objHdr, LwpSvStream* pStrm):LwpSuperTableLayout(objHdr, pStrm)
+{
+}
+LwpSuperParallelColumnLayout::~LwpSuperParallelColumnLayout()
+{}
+
+void LwpSuperParallelColumnLayout::Read()
+{
+	LwpSuperTableLayout::Read();
+	m_pObjStrm->SkipExtra();
+
+}
+
+LwpSuperGlossaryLayout::LwpSuperGlossaryLayout(LwpObjectHeader &objHdr, LwpSvStream* pStrm):LwpSuperTableLayout(objHdr, pStrm)
+{
+}
+
+LwpSuperGlossaryLayout::~LwpSuperGlossaryLayout()
+{
+}
+
+void LwpSuperGlossaryLayout::Read()
+{
+	LwpSuperTableLayout::Read();
+	m_pObjStrm->SkipExtra();
+}
+
+
+LwpParallelColumnsLayout::LwpParallelColumnsLayout(LwpObjectHeader &objHdr, LwpSvStream* pStrm):LwpTableLayout(objHdr, pStrm)
+{
+}
+
+LwpParallelColumnsLayout::~LwpParallelColumnsLayout()
+{
+}
+
+void LwpParallelColumnsLayout::Read()
+{
+	LwpTableLayout::Read();
+	m_pObjStrm->SkipExtra();
+}
+
diff -urNp lotuswordpro.bak/source/filter/lwptablelayout.hxx lotuswordpro/source/filter/lwptablelayout.hxx
--- lotuswordpro.bak/source/filter/lwptablelayout.hxx	1970-01-01 08:00:00.000000000 +0800
+++ lotuswordpro/source/filter/lwptablelayout.hxx	2008-10-22 11:42:29.000000000 +0800
@@ -0,0 +1,270 @@
+/*************************************************************************
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: IBM Corporation
+ *
+ *  Copyright: 2008 by IBM Corporation
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+/**
+ * @file 
+ *  For LWP filter architecture prototype - table layouts
+ */
+/*************************************************************************
+ * Change History
+ Mar 2005		 	Created
+ ************************************************************************/
+#ifndef _LWPTABLELAYOUT_HXX
+#define _LWPTABLELAYOUT_HXX
+#include <vector>
+#include <map>
+#include "lwplayout.hxx"
+
+class XFTableStyle;
+class XFTable;
+class XFCell;
+class LwpTable;
+class LwpFrame;
+class LwpSuperTableLayout;
+class LwpRowLayout;
+class LwpCellLayout;
+class LwpTableHeadingLayout;
+class LwpRowHeadingLayout;
+class LwpConnectedCellLayout;
+class LwpColumnLayout;
+
+/**
+ * @brief
+ * VO_TABLELAYOUT object and functions for registering styles and coverting tables
+ */
+class LwpTableLayout: public LwpLayout
+{
+public:
+	LwpTableLayout(LwpObjectHeader &objHdr, LwpSvStream* pStrm);
+	virtual ~LwpTableLayout();
+	virtual LWP_LAYOUT_TYPE GetLayoutType () { return LWP_TABLE_LAYOUT;}
+	LwpObjectID * GetColumnLayoutHead(){return &m_ColumnLayout;};
+	void RegisterStyle();
+	LwpTable *  GetTable();	
+	LwpCellLayout * GetDefaultCellLayout(){return m_pDefaultCellLayout;};
+	LwpSuperTableLayout * GetSuperTableLayout();
+	LwpObjectID * SearchCellStoryMap(sal_uInt16 nRow, sal_uInt16 nCol);
+	LwpCellLayout * GetCellByRowCol(sal_uInt16 nRow, sal_uInt16 nCol);
+	OUString GetColumnWidth(sal_uInt16 nCol);
+	void SetWordProCellMap(sal_uInt16 nRow, sal_uInt16 nCol, LwpCellLayout * pCell)
+	{
+		if (nRow >= m_nRows || nCol >= m_nCols)
+			return;
+		m_WordProCellsMap[nRow * m_nCols + nCol] = pCell;
+	};
+protected:
+	void Read();	
+	void TraverseTable();
+	void RegisterColumns();
+	void RegisterRows();
+	void Parse();
+	void PostProcessParagraph(XFCell *pCell, sal_uInt16 nRowID, sal_uInt16 nColID);
+
+	sal_uInt16 m_nRows;
+	sal_uInt16 m_nCols;
+	
+private:
+	//CColumnLayoutHead cColumnLayout;
+	LwpObjectID m_ColumnLayout;
+	OUString m_FrameStyleName;
+	LwpCellLayout * m_pDefaultCellLayout;
+	OUString m_DefaultColumnStyleName;
+	OUString m_DefaultRowStyleName;
+
+	// wordpro cell  map
+	std::vector<LwpCellLayout *> m_WordProCellsMap;
+	// column vector
+	LwpColumnLayout ** m_pColumns;
+	
+//add  by ,2005/4/1
+public:
+	void XFConvert(XFContentContainer* pCont);
+	void ConvertTable(XFTable* pXFTable,sal_uInt16 nStartRow,
+				sal_uInt16 nEndRow,sal_uInt8 nStartCol,sal_uInt8 nEndCol);
+	OUString GetDefaultRowStyleName(){return m_DefaultRowStyleName;}
+	void SetCellsMap(sal_uInt16 nRow,sal_uInt8 nCol,XFCell* pXFCell);
+	XFCell* GetCellsMap(sal_uInt16 nRow,sal_uInt8 nCol);
+	std::map<sal_uInt16,LwpRowLayout*> GetRowsMap(){return m_RowsMap;}
+	LwpRowLayout* GetRowLayout(sal_uInt16 nRow);
+private:
+	void ConvertDefaultRow(XFTable* pXFTable,sal_uInt8 nStartCol, 
+				sal_uInt8 nEndCol,sal_uInt16 nRowID);
+	void ConvertColumn(XFTable *pXFTable,sal_uInt8 nStartCol,sal_uInt8 nEndCol);
+	sal_uInt16 ConvertHeadingRow(XFTable* pXFTable,sal_uInt16 nStartHeadRow,sal_uInt16 nEndHeadRow);
+	sal_Bool  FindSplitColMark(XFTable* pXFTable,sal_uInt8* pCellMark,sal_uInt8& nMaxColSpan);
+	void SplitRowToCells(XFTable* pTmpTable,XFTable* pXFTable,
+				sal_uInt8 nFirstColSpann,sal_uInt8* pCellMark);
+			
+	std::map<sal_uInt16,LwpRowLayout*> m_RowsMap;
+	void SplitConflictCells();
+	XFTable* m_pXFTable;
+	std::map<std::pair<sal_uInt16,sal_uInt8>,XFCell*> m_CellsMap;
+
+	void PutCellVals(LwpFoundry* pFoundry, LwpObjectID aTableID);
+};
+/**
+ * @brief
+ * VO_SUPERTABLELAYOUT object
+ */
+class LwpSuperTableLayout: public LwpPlacableLayout
+{
+public:
+	LwpSuperTableLayout(LwpObjectHeader &objHdr, LwpSvStream* pStrm);
+	virtual ~LwpSuperTableLayout();
+	virtual LWP_LAYOUT_TYPE GetLayoutType () { return LWP_SUPERTABLE_LAYOUT;}
+	void RegisterStyle();
+	// for table style
+	// add by , 06/03/2005
+	void ApplyPatternFill(XFTableStyle* pTableStyle);
+ 	void ApplyBackGround(XFTableStyle* pTableStyle);
+	// end add
+
+	void ApplyBackColor(XFTableStyle *pTableStyle);
+	void ApplyShadow(XFTableStyle *pTableStyle);
+	double GetWidth();
+	double GetTableWidth();
+	void ApplyWatermark(XFTableStyle *pTableStyle);
+	void ApplyAlignment(XFTableStyle * pTableStyle);
+	void XFConvert(XFContentContainer* pCont);
+	// for frame style
+	virtual void XFConvertFrame(XFContentContainer* pCont, sal_Int32 nStart = 0, sal_Int32 nEnd = 0, sal_Bool bAll = sal_False);
+	void ParseFrame(XFFrame* pXFFrame);
+	void RegisterFrameStyle();
+	LwpTableHeadingLayout* GetTableHeadingLayout();
+protected:
+	void Read();	
+	LwpTableLayout* GetTableLayout();
+	sal_Bool IsSizeRightToContent();
+	sal_Bool IsJustifiable();
+	LwpFrame* m_pFrame;
+
+private:
+};
+/**
+ * @brief
+ * VO_COLUMNLAYOUT object
+ */
+class LwpColumnLayout : public LwpVirtualLayout
+{
+public:
+	LwpColumnLayout(LwpObjectHeader &objHdr, LwpSvStream* pStrm);
+	virtual ~LwpColumnLayout();
+	virtual LWP_LAYOUT_TYPE GetLayoutType () { return LWP_COLUMN_LAYOUT;}
+	sal_uInt32 GetColumnID(){return ccolid;};
+	double GetWidth(){return LwpTools::ConvertFromUnitsToMetric(cwidth);};
+	void RegisterStyle(double dCalculatedWidth);
+	sal_Bool IsJustifiable(){return (( m_nAttributes2 & STYLE2_JUSTIFIABLE) != 0);};
+protected:
+	void Read();	
+	sal_uInt8 ccolid;
+	sal_Int32 cwidth;
+
+};
+/**
+ * @brief
+ * VO_TABLEHEADINGLAYOUT object
+ */
+class LwpTableHeadingLayout : public LwpTableLayout
+{
+public:
+	LwpTableHeadingLayout(LwpObjectHeader &objHdr, LwpSvStream* pStrm);
+	virtual ~LwpTableHeadingLayout();
+	virtual LWP_LAYOUT_TYPE GetLayoutType () { return LWP_TABLE_HEADING_LAYOUT;}
+	void GetStartEndRow(sal_uInt16& nStartRow, sal_uInt16& nEndRow);
+	LwpRowHeadingLayout * GetFirstRowHeadingLayout();
+protected:
+	void Read();	
+	sal_uInt16 cStartRow;
+	sal_uInt16 cEndRow;
+};
+/**
+ * @brief
+ * VO_SUPERPARALLELCOLUMNLAYOUT object
+ */
+class LwpSuperParallelColumnLayout : public LwpSuperTableLayout
+{
+public:
+	LwpSuperParallelColumnLayout(LwpObjectHeader &objHdr, LwpSvStream* pStrm);
+	virtual ~LwpSuperParallelColumnLayout();
+protected:
+	void Read();
+};
+
+/**
+ * @brief
+ * VO_PCOLLAYOUT object
+ */
+class LwpParallelColumnsLayout : public LwpTableLayout
+{
+public:
+	LwpParallelColumnsLayout(LwpObjectHeader &objHdr, LwpSvStream* pStrm);
+	virtual ~LwpParallelColumnsLayout();
+protected:
+	void Read();	
+};
+
+class LwpSuperGlossaryLayout : public LwpSuperTableLayout
+{
+public:
+	LwpSuperGlossaryLayout(LwpObjectHeader &objHdr, LwpSvStream* pStrm);
+	virtual ~LwpSuperGlossaryLayout();
+protected:
+	void Read();	
+};
+
+#include "lwpcelllayout.hxx"
+#include "lwprowlayout.hxx"
+
+#endif
+
diff -urNp lotuswordpro.bak/source/filter/lwptaboverride.hxx lotuswordpro/source/filter/lwptaboverride.hxx
--- lotuswordpro.bak/source/filter/lwptaboverride.hxx	1970-01-01 08:00:00.000000000 +0800
+++ lotuswordpro/source/filter/lwptaboverride.hxx	2008-10-22 11:42:29.000000000 +0800
@@ -0,0 +1,129 @@
+/*************************************************************************
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: IBM Corporation
+ *
+ *  Copyright: 2008 by IBM Corporation
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+/*************************************************************************
+ * @file 
+ * Tab override for VO_PARASTYLE.
+ ************************************************************************/
+/*************************************************************************
+ * Change History
+ * 2005-01-12  create and implement.
+ ************************************************************************/
+
+#ifndef		_LWPTABOVERRIDE_HXX
+#define		_LWPTABOVERRIDE_HXX
+
+#include	"lwpoverride.hxx"
+#include	"lwpobjid.hxx"
+
+class	LwpTabOverride : public LwpOverride
+{
+public:
+	LwpTabOverride()
+	{
+	}
+
+	virtual ~LwpTabOverride()
+	{
+	}
+
+	virtual void Read(LwpObjectStream *pStrm)
+	{
+		if (pStrm->QuickReadBool())
+		{
+			ReadCommon(pStrm);
+			m_aTabRackID.ReadIndexed(pStrm);
+		}
+		
+		pStrm->SkipExtra();
+	}
+
+	inline LwpObjectID* GetTabRackID();
+	inline sal_Bool IsTabRackOverridden();
+	inline void Override(LwpTabOverride* pOther);
+	inline void OverrideTabRack(LwpObjectID* pTabRackID);
+private:
+	LwpObjectID	m_aTabRackID;
+	enum
+	{
+		TO_TABRACK	= 0x01
+	};
+};
+
+inline LwpObjectID* LwpTabOverride::GetTabRackID()
+{
+	return &m_aTabRackID;
+}
+
+inline void LwpTabOverride::Override(LwpTabOverride* pOther)
+{
+	if (m_nApply & TO_TABRACK)
+	{
+		if (IsTabRackOverridden())
+			//m_aTabRackID = *(pOther->GetTabRackID());	
+			pOther->OverrideTabRack(GetTabRackID());
+	}
+}
+
+inline sal_Bool LwpTabOverride::IsTabRackOverridden()
+{
+	return (m_nOverride & TO_TABRACK) != 0;
+}
+
+inline void LwpTabOverride::OverrideTabRack(LwpObjectID* pTabRackID)
+{
+	m_aTabRackID = *pTabRackID;
+}
+#endif
+
diff -urNp lotuswordpro.bak/source/filter/lwptabrack.cxx lotuswordpro/source/filter/lwptabrack.cxx
--- lotuswordpro.bak/source/filter/lwptabrack.cxx	1970-01-01 08:00:00.000000000 +0800
+++ lotuswordpro/source/filter/lwptabrack.cxx	2008-10-22 11:42:29.000000000 +0800
@@ -0,0 +1,134 @@
+/*************************************************************************
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: IBM Corporation
+ *
+ *  Copyright: 2008 by IBM Corporation
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+/*************************************************************************
+ * @file 
+ * Tabrack for LwpTabPiece object.
+ ************************************************************************/
+/*************************************************************************
+ * Change History
+ * 2005-01-12 create this file.
+ ************************************************************************/
+#include	"lwptabrack.hxx"
+#include	"lwpobjstrm.hxx"
+#include	"lwpslvlist.hxx"
+
+LwpTab::LwpTab()
+{
+	m_nX = 0;
+	m_nAlignChar = 0;		//be careful,not quite sure it's 8-bit,perhaps 16-bit.
+	m_nType = 0;
+	m_nLeader = 0;
+	m_nRelativeType = 0;
+}
+
+void	LwpTab::Read(LwpObjectStream *pStrm)
+{
+	pStrm->QuickRead(&m_nX, sizeof(m_nX));	
+	pStrm->QuickRead(&m_nType, sizeof(m_nType));
+	pStrm->QuickRead(&m_nLeader, sizeof(m_nLeader));
+	pStrm->QuickRead(&m_nRelativeType, sizeof(m_nRelativeType));
+	pStrm->QuickRead(&m_nAlignChar, sizeof(m_nAlignChar));
+}
+
+
+LwpTabRack::LwpTabRack(LwpObjectHeader objHdr, LwpSvStream* pStrm):LwpObject(objHdr,pStrm)
+{
+	m_nNumTabs = 0;
+}
+
+void LwpTabRack::Read()
+{
+//	LwpObjectID		m_NextID;
+	m_NextID.ReadIndexed(m_pObjStrm);
+
+	m_pObjStrm->QuickRead(&m_nNumTabs, sizeof(m_nNumTabs));
+	for( int i=0; i<m_nNumTabs; i++ )
+	{
+		m_aTabs[i].Read(m_pObjStrm);
+		m_pObjStrm->SkipExtra();
+	}
+	m_pObjStrm->SkipExtra();
+}
+
+LwpTab* LwpTabRack::Lookup(sal_uInt16 nIndex)
+{
+	/* Is the tab in this tabrack? */
+	if(nIndex<m_nNumTabs)
+	{
+		return &m_aTabs[nIndex];
+	}
+	//return NULL;	
+	/* It's not in this tabrack, so get it out of our next. */
+	if (!GetNext())
+		return NULL;		/* ouch */
+
+	return GetNext()->Lookup(nIndex - m_nNumTabs);	
+}
+
+LwpTabRack* LwpTabRack::GetNext()
+{
+	LwpTabRack* pTabRack = static_cast<LwpTabRack*>(m_NextID.obj());
+	return pTabRack;
+}
+
+sal_uInt16 LwpTabRack::GetNumTabs()
+{
+	sal_uInt16 nNum=0;	
+	if(GetNext())
+	{
+		nNum = GetNext()->GetNumTabs();
+	}	
+	return m_nNumTabs+nNum;
+}
diff -urNp lotuswordpro.bak/source/filter/lwptabrack.hxx lotuswordpro/source/filter/lwptabrack.hxx
--- lotuswordpro.bak/source/filter/lwptabrack.hxx	1970-01-01 08:00:00.000000000 +0800
+++ lotuswordpro/source/filter/lwptabrack.hxx	2008-10-22 11:42:29.000000000 +0800
@@ -0,0 +1,162 @@
+/*************************************************************************
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: IBM Corporation
+ *
+ *  Copyright: 2008 by IBM Corporation
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+/*************************************************************************
+ * @file 
+ * Tabrack for LwpTabPiece object.
+ ************************************************************************/
+/*************************************************************************
+ * Change History
+ * 2005-01-12 create this file.
+ ************************************************************************/
+
+#ifndef		_LWPTABRACK_HXX
+#define		_LWPTABRACK_HXX
+
+#include	"lwpobj.hxx"
+
+class	LwpObjectStream;
+class	LwpTab;
+class	LwpTabRack;
+
+class LwpTab
+{
+public:
+	LwpTab(void);
+
+	enum TabType
+	{
+		TT_LEFT = 1,
+		TT_CENTER,
+		TT_RIGHT,
+		TT_NUMERIC
+	};
+	
+	enum LeaderType
+	{
+		TL_NONE	= 0,
+		TL_HYPHEN,
+		TL_DOT,
+		TL_LINE
+	};
+	
+	enum RelativeType
+	{
+		TR_LEFT = 1,
+		TR_RIGHT,
+		TR_CENTER
+	};
+public:
+	void	Read(LwpObjectStream *pStrm);
+	// 2005/01/28
+	inline sal_uInt32 GetPosition();
+	inline TabType GetTabType();
+	inline LeaderType GetLeaderType();
+	inline RelativeType GetRelativeType();
+	inline sal_uInt16 GetAlignChar();
+	
+protected:
+	sal_uInt32		m_nX;	
+	sal_uInt8		m_nType;
+	sal_uInt8		m_nLeader;
+	sal_uInt8		m_nRelativeType;
+	sal_uInt16		m_nAlignChar;		//be careful
+};
+
+// 2005/01/28
+inline sal_uInt32 LwpTab::GetPosition()
+{
+	return m_nX;
+}
+
+inline LwpTab::TabType LwpTab::GetTabType()
+{
+	return (LwpTab::TabType)m_nType;
+}
+
+inline LwpTab::LeaderType LwpTab::GetLeaderType()
+{
+	return (LwpTab::LeaderType)m_nLeader;
+}
+inline LwpTab::RelativeType LwpTab::GetRelativeType()
+{
+	return (LwpTab::RelativeType)m_nRelativeType;
+}
+
+inline sal_uInt16 LwpTab::GetAlignChar()
+{
+	return m_nAlignChar;
+}
+
+class	LwpTabRack : public LwpObject
+{
+public:
+	LwpTabRack(LwpObjectHeader objHdr, LwpSvStream* pStrm);	
+	virtual ~LwpTabRack(){}
+public:
+	void Read();
+	// 2005/01/28
+	sal_uInt16 GetNumTabs();
+	LwpTab* Lookup(sal_uInt16 nIndex);
+	LwpTabRack* GetNext();
+private:	
+	enum{
+		MaxTabs = 15
+	};
+	sal_uInt16		m_nNumTabs;
+	LwpTab			m_aTabs[MaxTabs];
+	LwpObjectID		m_NextID;
+};
+
+#endif
diff -urNp lotuswordpro.bak/source/filter/lwptblcell.cxx lotuswordpro/source/filter/lwptblcell.cxx
--- lotuswordpro.bak/source/filter/lwptblcell.cxx	1970-01-01 08:00:00.000000000 +0800
+++ lotuswordpro/source/filter/lwptblcell.cxx	2008-10-22 11:42:29.000000000 +0800
@@ -0,0 +1,253 @@
+/*************************************************************************
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: IBM Corporation
+ *
+ *  Copyright: 2008 by IBM Corporation
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+/**
+ * @file 
+ *  For LWP filter architecture prototype - table cell numerics format
+ */
+/*************************************************************************
+ * Change History
+ Mar 2005		 	Created
+ ************************************************************************/
+
+#include	"lwpoverride.hxx"
+#include	"lwpobjid.hxx"
+#include 	"lwptblcell.hxx"
+#include "lwppara.hxx"
+
+//////////////////////////////////////////////////////////////////
+ LwpCellList::LwpCellList(LwpObjectHeader &objHdr, LwpSvStream* pStrm):LwpDLVList(objHdr, pStrm)
+{}
+
+LwpCellList::~LwpCellList()
+{}
+
+void LwpCellList::Read()
+{
+	// CDLFVList read construction
+	LwpDLVList::Read();
+
+	LwpDLVListHeadTail cChild;
+	cChild.Read(m_pObjStrm);
+
+	cParent.ReadIndexed(m_pObjStrm);
+	
+	if (LwpFileHeader::m_nFileRevision < 0x0006)
+		m_pObjStrm->SkipExtra();
+	
+	cValue.ReadIndexed(m_pObjStrm);
+	
+	LwpObjectID cDependent;
+	cDependent.ReadIndexed(m_pObjStrm);
+	
+	cColumn = (sal_uInt8) m_pObjStrm->QuickReaduInt16();		// written as a sal_uInt16
+//	sal_uInt8 cCellFlags = (sal_uInt8) m_pObjStrm->QuickReaduInt16();	// written as a sal_uInt16
+	m_pObjStrm->SeekRel(2);//CellFlags
+	m_pObjStrm->SkipExtra();
+
+}
+ void  LwpCellList::Parse(IXFStream* pOutputStream)
+{
+}
+void LwpCellList::Convert(XFCell * pCell, LwpTableLayout* pCellsMap)
+{
+	LwpObjectID aValueID = GetValueID();
+	LwpNumericValue* pValue = (LwpNumericValue*)aValueID.obj();
+	if (pValue)
+	{
+		pCell->SetValue( pValue->GetValue() );
+	}
+}
+
+//////////////////////////////////////////////////////////////////
+ LwpNumericValue::LwpNumericValue(LwpObjectHeader &objHdr, LwpSvStream* pStrm):LwpObject(objHdr, pStrm)
+{}
+
+LwpNumericValue::~LwpNumericValue()
+{}
+
+void LwpNumericValue::Read()
+{
+	m_pObjStrm->QuickRead(&cNumber, sizeof(cNumber));
+	m_pObjStrm->SkipExtra();
+
+}
+ void  LwpNumericValue::Parse(IXFStream* pOutputStream)
+{
+}
+//////////////////////////////////////////////////////////////////
+ LwpRowList::LwpRowList(LwpObjectHeader &objHdr, LwpSvStream* pStrm):LwpDLVList(objHdr, pStrm)
+{}
+
+LwpRowList::~LwpRowList()
+{}
+
+void LwpRowList::Read()
+{
+	// CDLFVList read construction
+	LwpDLVList::Read();
+
+	cChild.Read(m_pObjStrm);
+	cParent.ReadIndexed(m_pObjStrm);
+	
+	if (LwpFileHeader::m_nFileRevision < 0x0006)
+		m_pObjStrm->SkipExtra();
+
+	cRowID = m_pObjStrm->QuickReaduInt16();
+
+	m_pObjStrm->SkipExtra();
+}
+ void  LwpRowList::Parse(IXFStream* pOutputStream)
+{
+}
+
+//////////////////////////////////////////////////////////////////
+ LwpTableRange::LwpTableRange(LwpObjectHeader &objHdr, LwpSvStream* pStrm)
+ 	:LwpDLVList(objHdr, pStrm)
+{}
+
+LwpTableRange::~LwpTableRange()
+{}
+
+void LwpTableRange::Read()
+{
+	LwpDLVList::Read();
+	
+	cqTable.ReadIndexed(m_pObjStrm);
+	cpCellRange.ReadIndexed(m_pObjStrm);
+	m_pObjStrm->SkipExtra();
+}
+ void  LwpTableRange::Parse(IXFStream* pOutputStream)
+{
+}
+//////////////////////////////////////////////////////////////////
+ LwpCellRange::LwpCellRange(LwpObjectHeader &objHdr, LwpSvStream* pStrm):LwpObject(objHdr, pStrm)
+{}
+
+LwpCellRange::~LwpCellRange()
+{}
+
+void LwpCellRange::Read()
+{
+	cpFolder.ReadIndexed(m_pObjStrm);
+	m_pObjStrm->SkipExtra();
+}
+ void  LwpCellRange::Parse(IXFStream* pOutputStream)
+{
+}
+//////////////////////////////////////////////////////////////////
+
+ LwpFolder::LwpFolder(LwpObjectHeader &objHdr, LwpSvStream* pStrm):LwpDLVList(objHdr, pStrm)
+{}
+
+LwpFolder::~LwpFolder()
+{}
+
+void LwpFolder::Read()
+{
+	// CDLFVList read construction
+	LwpDLVList::Read();
+
+	cChild.Read(m_pObjStrm);
+	cParent.ReadIndexed(m_pObjStrm);
+	
+	if (LwpFileHeader::m_nFileRevision < 0x0006)
+		m_pObjStrm->SkipExtra();
+
+	cqTable.ReadIndexed(m_pObjStrm);
+	m_pObjStrm->SkipExtra();
+}
+ void  LwpFolder::Parse(IXFStream* pOutputStream)
+{
+}
+//////////////////////////////////////////////////////////////////
+
+ LwpDependent::LwpDependent(LwpObjectHeader &objHdr, LwpSvStream* pStrm):LwpDLVList(objHdr, pStrm)
+{}
+
+LwpDependent::~LwpDependent()
+{}
+
+void LwpDependent::Read()
+{
+	LwpDLVList::Read();
+
+	cFormulaInfo.ReadIndexed(m_pObjStrm);
+	cReferenceOffset = m_pObjStrm->QuickReaduInt16();
+	cFlags = (sal_uInt8)m_pObjStrm->QuickReaduInt16();	// Written as lushort.
+
+	m_pObjStrm->SkipExtra();
+}
+ void  LwpDependent::Parse(IXFStream* pOutputStream)
+{
+}
+//////////////////////////////////////////////////////////////////
+
+void LwpRowSpecifier::QuickRead(LwpObjectStream *pStrm)
+{
+	cRow = pStrm->QuickReaduInt16();
+	cQualifier.QuickRead(pStrm);
+}
+void LwpColumnSpecifier::QuickRead(LwpObjectStream *pStrm)
+{
+	cColumn = (sal_uInt8)pStrm->QuickReaduInt16();
+	cQualifier.QuickRead(pStrm);
+}
+
+void LwpRowColumnQualifier::QuickRead(LwpObjectStream *pStrm)
+{
+	// written as lushort for future flags
+	cFlags = (sal_uInt8)pStrm->QuickReaduInt16();
+}
+
diff -urNp lotuswordpro.bak/source/filter/lwptblcell.hxx lotuswordpro/source/filter/lwptblcell.hxx
--- lotuswordpro.bak/source/filter/lwptblcell.hxx	1970-01-01 08:00:00.000000000 +0800
+++ lotuswordpro/source/filter/lwptblcell.hxx	2008-10-22 11:42:29.000000000 +0800
@@ -0,0 +1,495 @@
+/*************************************************************************
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: IBM Corporation
+ *
+ *  Copyright: 2008 by IBM Corporation
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+/**
+ * @file 
+ *  For LWP filter architecture prototype - table object
+ */
+/*************************************************************************
+ * Change History
+ Mar 2005		 	Created
+ ************************************************************************/
+#ifndef _LWPLAYOUTNUMERICSOVERRIDE_HXX_
+#define _LWPLAYOUTNUMERICSOVERRIDE_HXX_
+
+#include "lwpobj.hxx"
+#include "lwpatomholder.hxx"
+#include "lwpstory.hxx"
+
+#include "xfilter/xfcell.hxx"
+
+// temporily added for compile
+class LwpObject;
+
+class LwpContent;
+class LwpTableLayout;
+/**
+ * @brief
+ * VO_CELLLIST object
+ */
+class LwpCellList : public LwpDLVList
+{
+public:
+	LwpCellList(LwpObjectHeader &objHdr, LwpSvStream* pStrm);
+	virtual ~LwpCellList();
+	
+	virtual void Parse(IXFStream* pOutputStream);
+	LwpObjectID GetNextID(){return *GetNext();}
+	sal_uInt8 GetColumnID(){return cColumn;}
+	virtual sal_Bool IsFormula(){return sal_False;}
+	LwpObjectID GetValueID(){return cValue;}
+
+	virtual void Convert(XFCell * pCell, LwpTableLayout* pCellsMap=NULL);
+protected:
+	sal_uInt8 cColumn;
+	LwpObjectID cParent;
+
+	void Read();	
+	LwpObjectID cValue;
+};
+/**
+ * @brief
+ * VO_ROWLIST object
+ */
+class LwpRowList : public LwpDLVList
+{
+public:
+	LwpRowList(LwpObjectHeader &objHdr, LwpSvStream* pStrm);
+	~LwpRowList();
+	
+	void Parse(IXFStream* pOutputStream);
+	LwpObjectID GetChildHeadID(){return *cChild.GetHead();}
+	LwpObjectID GetNextID(){return *GetNext();}
+	sal_uInt16 GetRowID(){return cRowID;}
+protected:
+	LwpDLVListHeadTail cChild;
+	LwpObjectID cParent;
+	sal_uInt16 cRowID;
+	void Read();	
+};
+/**
+ * @brief
+ * VO_NUMERICVALUE object
+ */
+class LwpNumericValue : public LwpObject
+{
+public:
+	LwpNumericValue(LwpObjectHeader &objHdr, LwpSvStream* pStrm);
+	~LwpNumericValue();
+	
+	double GetValue(){return cNumber;} 
+	void Parse(IXFStream* pOutputStream);
+protected:
+	double cNumber;
+	//LwpContent m_TheContent;
+	void Read();	
+};
+
+////////////////////////////////////////////////////////////////////////
+/**
+ * @brief
+ * VO_TABLERANGE object
+ */
+class LwpTableRange: public LwpDLVList
+{
+public:
+	LwpTableRange(LwpObjectHeader &objHdr, LwpSvStream* pStrm);
+	~LwpTableRange();
+	
+	void Parse(IXFStream* pOutputStream);
+	LwpObjectID GetCellRangeID(){return cpCellRange;}
+	LwpObjectID GetTableID(){ return cqTable;}
+	LwpTableRange* GetNext() { return (LwpTableRange*)(LwpDLVList::GetNext()->obj());}
+protected:
+	LwpObjectID cqTable;
+	LwpObjectID cpCellRange;
+	void Read();	
+};
+/**
+ * @brief
+ * VO_CELLRANGE object
+ */
+class LwpCellRange: public LwpObject
+{
+public:
+	LwpCellRange(LwpObjectHeader &objHdr, LwpSvStream* pStrm);
+	~LwpCellRange();
+	
+	void Parse(IXFStream* pOutputStream);
+	LwpObjectID GetFolderID(){return cpFolder;}
+protected:
+	LwpObjectID cpFolder;
+	void Read();	
+};
+/**
+ * @brief
+ * VO_FOLDER object
+ */
+class LwpFolder: public LwpDLVList
+{
+public:
+	LwpFolder(LwpObjectHeader &objHdr, LwpSvStream* pStrm);
+	~LwpFolder();
+	
+	void Parse(IXFStream* pOutputStream);
+	LwpObjectID GetChildHeadID(){ return *cChild.GetHead();}
+protected:
+	LwpDLVListHeadTail cChild;
+	LwpObjectID cParent;
+	LwpObjectID cqTable;
+	void Read();	
+};
+/**
+ * @brief
+ * VO_DEPENDENT object
+ */
+class LwpDependent: public LwpDLVList
+{
+public:
+	LwpDependent(LwpObjectHeader &objHdr, LwpSvStream* pStrm);
+	~LwpDependent();
+	
+	void Parse(IXFStream* pOutputStream);
+protected:
+	void Read();	
+	LwpObjectID cFormulaInfo;
+	sal_uInt16 cReferenceOffset;	// Used to fix dependent formula when we're
+								//  dropped, sorted.
+	// Flags:
+	enum
+	{
+		START_CELL	= 0x01,
+		END_CELL	= 0x02,
+		REGISTERED	= 0x04
+	};
+	sal_uInt8 cFlags;				 // Used to fix dependent formula when we're
+								//  dropped, sorted.
+};
+
+
+///////////////////////////////////////////////////////////////
+/**
+ * @brief
+ * row or column id 
+ */
+class LwpRowColumnQualifier
+{
+public:
+	LwpRowColumnQualifier(void);
+	~LwpRowColumnQualifier(){}
+
+	inline void SetAbsolute(void);
+	inline void ClearAbsolute(void);
+	sal_Bool IsAbsolute(void);
+
+	inline void SetAfter(void);
+	inline void ClearAfter(void);
+	sal_Bool IsAfter(void);
+
+	void SetBad(sal_Bool Bad);
+	sal_Bool IsBad(void);
+
+	void QuickRead(LwpObjectStream *pStrm);
+
+private:
+	enum	// cFlags bit definitions
+	{
+		REF_ABSOLUTE	= 0x01,
+		REF_AFTER		= 0x02,
+		REF_BAD			= 0x04
+	};
+	sal_uInt8 cFlags;
+};
+
+inline void
+LwpRowColumnQualifier::SetAbsolute(void)
+{
+	cFlags |= REF_ABSOLUTE;
+}
+
+inline void
+LwpRowColumnQualifier::ClearAbsolute(void)
+{
+	cFlags &= ~REF_ABSOLUTE;
+}
+
+inline void
+LwpRowColumnQualifier::SetAfter(void)
+{
+	cFlags |= REF_AFTER;
+}
+
+inline void
+LwpRowColumnQualifier::ClearAfter(void)
+{
+	cFlags &= ~REF_AFTER;
+}
+
+inline
+LwpRowColumnQualifier::LwpRowColumnQualifier()
+{
+	cFlags = 0;
+}
+
+inline sal_Bool
+LwpRowColumnQualifier::IsAfter()
+{
+	return cFlags & REF_AFTER ? sal_True : sal_False;
+}
+
+inline sal_Bool
+LwpRowColumnQualifier::IsBad()
+{
+	return cFlags & REF_BAD ? sal_True : sal_False;
+}
+
+inline sal_Bool
+LwpRowColumnQualifier::IsAbsolute()
+{
+	return cFlags & REF_ABSOLUTE ? sal_True : sal_False;
+}
+/**
+ * @brief
+ * row id
+ */
+class LwpRowSpecifier
+{
+public:
+	LwpRowSpecifier(void){}
+	~LwpRowSpecifier(){}
+
+	void QuickRead(LwpObjectStream *pStrm);
+	String ToString(USHORT nFormulaRow);
+
+	USHORT RowID(USHORT FormulaRow);
+	USHORT &Row(void);
+
+	void SetAbsolute(void);
+	void ClearAbsolute(void);
+	sal_Bool IsAbsolute(void);
+
+	void SetAfter(void);
+	void ClearAfter(void);
+	sal_Bool IsAfter(void);
+
+	void SetBad(sal_Bool Bad);
+	sal_Bool IsBad(void);
+	void SetRowDelta(USHORT ReferenceRowID, USHORT FormulaRowID);
+
+private:	
+	sal_uInt16 cRow;
+	LwpRowColumnQualifier cQualifier;
+};
+
+inline USHORT
+LwpRowSpecifier::RowID(USHORT FormulaRow)
+{
+	if (cQualifier.IsBad())
+	{
+		return 0xffff;
+	}
+	if (cQualifier.IsAbsolute())
+		return cRow;
+
+	if (cQualifier.IsAfter())
+		return FormulaRow + cRow;
+	return FormulaRow - cRow;
+}
+
+inline USHORT &
+LwpRowSpecifier::Row()
+{
+	return cRow;
+}
+
+inline void
+LwpRowSpecifier::SetAbsolute(void)
+{
+	cQualifier.SetAbsolute();
+}
+
+inline void
+LwpRowSpecifier::ClearAbsolute(void)
+{
+	cQualifier.ClearAbsolute();
+}
+
+inline sal_Bool
+LwpRowSpecifier::IsAbsolute()
+{
+	return cQualifier.IsAbsolute();
+}
+
+inline void
+LwpRowSpecifier::SetAfter(void)
+{
+	cQualifier.SetAfter();
+}
+
+inline void
+LwpRowSpecifier::ClearAfter(void)
+{
+	cQualifier.ClearAfter();
+}
+
+inline sal_Bool
+LwpRowSpecifier::IsAfter()
+{
+	return cQualifier.IsAfter();
+}
+
+inline void
+LwpRowSpecifier::SetBad(sal_Bool Bad)
+{
+	cQualifier.SetBad(Bad);
+}
+
+inline sal_Bool
+LwpRowSpecifier::IsBad()
+{
+	return cQualifier.IsBad();
+}
+/**
+ * @brief
+ * column id
+ */
+class LwpColumnSpecifier
+{
+public:
+	LwpColumnSpecifier(void){};
+	~LwpColumnSpecifier(){};
+
+	void QuickRead(LwpObjectStream *pStrm);
+	sal_uInt8 Column(){return cColumn;}
+	String ToString(sal_uInt8 nFormulaCol);
+
+	sal_uInt8 ColumnID(sal_uInt8 FormulaColumn);
+	void SetAbsolute(void);
+	void ClearAbsolute(void);
+	sal_Bool IsAbsolute(void);
+	void SetAfter(void);
+	void ClearAfter(void);
+	sal_Bool IsAfter(void);
+	void SetBad(sal_Bool Bad);
+	sal_Bool IsBad(void);
+	void SetColumnDelta(sal_uInt8 ReferenceColumnID, sal_uInt8 FormulaColumnID);
+
+private:	
+	sal_uInt8 cColumn;
+	LwpRowColumnQualifier cQualifier;
+};
+
+inline sal_uInt8
+LwpColumnSpecifier::ColumnID(sal_uInt8 FormulaColumn)
+{
+	if (cQualifier.IsBad())
+	{
+		return 0xff;
+	}
+	if (cQualifier.IsAbsolute())
+		return cColumn;
+	if (cQualifier.IsAfter())
+		return FormulaColumn + cColumn;
+	return FormulaColumn - cColumn;
+}
+
+inline void
+LwpColumnSpecifier::SetAbsolute(void)
+{
+	cQualifier.SetAbsolute();
+}
+
+inline void
+LwpColumnSpecifier::ClearAbsolute(void)
+{
+	cQualifier.ClearAbsolute();
+}
+
+inline sal_Bool
+LwpColumnSpecifier::IsAbsolute()
+{
+	return cQualifier.IsAbsolute();
+}
+
+inline void
+LwpColumnSpecifier::SetAfter(void)
+{
+	cQualifier.SetAfter();
+}
+
+inline void
+LwpColumnSpecifier::ClearAfter(void)
+{
+	cQualifier.ClearAfter();
+}
+
+inline sal_Bool
+LwpColumnSpecifier::IsAfter()
+{
+	return cQualifier.IsAfter();
+}
+
+inline void
+LwpColumnSpecifier::SetBad(sal_Bool Bad)
+{
+	cQualifier.SetBad(Bad);
+}
+
+inline sal_Bool
+LwpColumnSpecifier::IsBad()
+{
+	return cQualifier.IsBad();
+}
+#endif
+
diff -urNp lotuswordpro.bak/source/filter/lwptblformula.cxx lotuswordpro/source/filter/lwptblformula.cxx
--- lotuswordpro.bak/source/filter/lwptblformula.cxx	1970-01-01 08:00:00.000000000 +0800
+++ lotuswordpro/source/filter/lwptblformula.cxx	2008-10-22 11:42:29.000000000 +0800
@@ -0,0 +1,804 @@
+/*************************************************************************
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: IBM Corporation
+ *
+ *  Copyright: 2008 by IBM Corporation
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+/**
+ * @file 
+ *  For LWP filter architecture prototype - table cell numerics format
+ */
+/*************************************************************************
+ * Change History
+ Mar 2005		 	Created
+ ************************************************************************/
+
+#include	"lwpoverride.hxx"
+#include 	"lwptblcell.hxx"
+#include	"lwppara.hxx"
+#include 	"lwptblformula.hxx"
+
+#include "lwptablelayout.hxx"
+
+//////////////////////////////////////////////////////////////////
+ LwpFormulaInfo::LwpFormulaInfo(LwpObjectHeader &objHdr, LwpSvStream* pStrm)
+:LwpCellList(objHdr, pStrm),m_nFormulaRow(0),m_bSupported(sal_True)
+{}
+
+LwpFormulaInfo::~LwpFormulaInfo()
+{
+	try{
+		while(m_aStack.size()>0)
+		{
+			LwpFormulaArg* pArg=m_aStack.back();
+			m_aStack.pop_back();
+			delete pArg; pArg=NULL;
+		}
+	}catch (...) 
+	{
+		assert(false);
+	}
+}
+
+/**
+*	
+*	@date	03/26/2005
+*	@param	
+*	@param	
+*	@return	sal_Bool.
+*/
+sal_Bool LwpFormulaInfo::ReadConst()
+{
+	double Constant;
+	m_pObjStrm->QuickRead(&Constant, sizeof(Constant));
+
+	m_aStack.push_back( new LwpFormulaConst(Constant) );
+
+	return sal_True;
+}
+/**
+*	Need more effort for unicode.
+*	@date	03/26/2005
+*	@param	
+*	@param	
+*	@return	sal_Bool.
+*/
+sal_Bool LwpFormulaInfo::ReadText()
+{
+	USHORT nDiskSize,nStrLen;
+	nDiskSize = m_pObjStrm->QuickReadInt16(); 
+	nStrLen = m_pObjStrm->QuickReadInt16();
+
+	auto_ptr<char> pBuf(new char[nStrLen+1]);
+	m_pObjStrm->QuickRead( pBuf.get(), nStrLen );	
+	*(pBuf.get()+nStrLen)='\0';
+	String aText;
+	aText += String::CreateFromAscii("\"");
+	aText.Append(String(pBuf.get(),nStrLen,gsl_getSystemTextEncoding()));
+	aText += String::CreateFromAscii("\"");
+	
+	m_aStack.push_back(new LwpFormulaText(aText));
+	return sal_True;
+}
+/**
+*	
+*	@date	03/26/2005
+*	@param	
+*	@param	
+*	@return	sal_Bool.
+*/
+sal_Bool LwpFormulaInfo::ReadCellID()
+{
+	LwpRowSpecifier RowSpecifier;
+	LwpColumnSpecifier ColumnSpecifier;
+	sal_Bool readSucceeded = true;
+
+	RowSpecifier.QuickRead(m_pObjStrm);
+	ColumnSpecifier.QuickRead(m_pObjStrm);
+	
+	m_aStack.push_back( new LwpFormulaCellAddr(ColumnSpecifier.ColumnID(cColumn),
+												RowSpecifier.RowID(m_nFormulaRow)) );
+	return readSucceeded;
+}
+/**
+*	
+*	@date	03/26/2005
+*	@param	
+*	@param	
+*	@return	sal_Bool.
+*/
+sal_Bool LwpFormulaInfo::ReadCellRange()
+{
+	sal_Bool readSucceeded = sal_True;
+	if (!ReadCellID( )) // start
+		readSucceeded = false;
+	LwpFormulaCellAddr* pStartCellAddr = (LwpFormulaCellAddr*)m_aStack.back();
+	m_aStack.pop_back();
+
+	if (!ReadCellID()) // end
+		readSucceeded = false;
+	LwpFormulaCellAddr* pEndCellAddr = (LwpFormulaCellAddr*)m_aStack.back();
+	m_aStack.pop_back();
+
+	m_aStack.push_back( new LwpFormulaCellRangeAddr(pStartCellAddr->GetCol(),
+													pStartCellAddr->GetRow(),
+													pEndCellAddr->GetCol(),
+													pEndCellAddr->GetRow()) );
+	delete pStartCellAddr;
+	delete pEndCellAddr;
+
+	return readSucceeded;
+}
+
+/**
+*	Read expression from wordpro file
+*	@date	03/26/2005
+*	@param	
+*	@param	
+*	@return	sal_Bool.
+*/
+sal_Bool LwpFormulaInfo::ReadExpression()
+{
+	sal_uInt16 TokenType, DiskLength;
+	sal_Bool readSucceeded = sal_True;
+
+	/* Read the compiled expression length */
+//	Len = m_pObjStrm->QuickReaduInt16();
+	m_pObjStrm->SeekRel(2);	
+
+	while ((TokenType = m_pObjStrm->QuickReaduInt16()) != TK_END)
+	{
+		// Get the disk length of this token
+		DiskLength = m_pObjStrm->QuickReaduInt16();
+
+		switch (TokenType)
+		{
+			case TK_CONSTANT:
+			{
+				ReadConst();
+				break;
+			}
+
+			case TK_CELLID:
+				if (!ReadCellID())
+					readSucceeded = FALSE;
+				break;
+
+			case TK_CELLRANGE:
+				readSucceeded = ReadCellRange();		
+				break;
+
+			case TK_SUM:
+			case TK_IF:
+			case TK_COUNT:
+			case TK_MINIMUM:
+			case TK_MAXIMUM:
+			case TK_AVERAGE:		
+				{
+					LwpFormulaFunc* pFunc = new LwpFormulaFunc(TokenType);
+					if (!ReadArguments(*pFunc))
+						readSucceeded = FALSE;
+					m_aStack.push_back(pFunc);
+				}
+				break;
+
+			case TK_ADD://7
+			case TK_SUBTRACT:
+			case TK_MULTIPLY:
+			case TK_DIVIDE:
+			case TK_LESS:
+			case TK_LESS_OR_EQUAL:
+			case TK_GREATER:
+			case TK_GREATER_OR_EQUAL:
+			case TK_EQUAL:
+			case TK_NOT_EQUAL:		
+			case TK_AND:
+			case TK_OR:
+			case TK_NOT:
+				m_pObjStrm->SeekRel(DiskLength); // extensible for future
+
+				{//binary operator
+					LwpFormulaOp* pOp = new LwpFormulaOp(TokenType);
+					pOp->AddArg(m_aStack.back()); m_aStack.pop_back();
+					pOp->AddArg(m_aStack.back()); m_aStack.pop_back();
+					m_aStack.push_back(pOp);
+				}
+				break;
+			case TK_UNARY_MINUS:
+				{
+					LwpFormulaUnaryOp* pOp = new LwpFormulaUnaryOp(TokenType);
+					pOp->AddArg(m_aStack.back()); m_aStack.pop_back();
+					m_aStack.push_back(pOp);
+				}
+				break;
+			default:
+				// We don't know what to do with this token, so eat it.
+				m_pObjStrm->SeekRel(DiskLength);
+				readSucceeded = FALSE;
+				break;
+		}
+		MarkUnsupported(TokenType);
+	}
+	return readSucceeded;
+}
+
+/**
+*	
+*	@date	03/26/2005
+*	@param	
+*	@param	
+*	@return	
+*/
+void LwpFormulaInfo::MarkUnsupported(sal_uInt16 TokenType)
+{
+	switch(TokenType)
+	{
+	case TK_IF:
+	case TK_COUNT:
+	case TK_NOT:
+		{
+			m_bSupported = sal_False;//Not supported formulas
+		}
+		break;
+	default:
+		break;
+	}
+}
+/**
+*	Read arguments of functions from wordpro file
+*	@date	03/26/2005
+*	@param	LwpFormulaFunc& aFunc, functions object
+*	@return	sal_Bool.
+*/
+sal_Bool LwpFormulaInfo::ReadArguments(LwpFormulaFunc& aFunc)
+{
+	sal_uInt16 NumberOfArguments = m_pObjStrm->QuickReaduInt16();
+	sal_uInt16 ArgumentDiskLength, Count;
+	sal_uInt8 ArgumentType;
+	sal_Bool bArgument = sal_False;
+	sal_Bool readSucceeded = sal_True;
+
+	for (Count = 0; Count < NumberOfArguments; Count++)
+	{
+		ArgumentType = (sal_uInt8) m_pObjStrm->QuickReaduInt16(); // written as lushort
+		ArgumentDiskLength = m_pObjStrm->QuickReaduInt16();
+		bArgument = sal_True;
+
+		switch(ArgumentType)
+		{
+			case TK_CELLID:
+				ReadCellID();
+				break;
+
+			case TK_CELLRANGE:
+				ReadCellRange();
+				break;
+
+			case TK_CONSTANT:
+				ReadConst();
+				break;
+
+			case TK_TEXT:
+				ReadText();
+				break;
+
+			case TK_EXPRESSION:
+				ReadExpression();	
+				break;
+
+			default:
+				bArgument = sal_False;
+				m_pObjStrm->SeekRel(ArgumentDiskLength);
+				readSucceeded = sal_False;
+				break;
+		}
+
+		if (bArgument)
+		{
+			aFunc.AddArg( m_aStack.back() );
+			m_aStack.pop_back();
+		}
+	}
+	return readSucceeded;
+}
+
+/**
+*	
+*	@date	03/26/2005
+*	@param	
+*	@param	
+*	@return
+*/
+void LwpFormulaInfo::Read()
+{
+	LwpCellList::Read();
+	{
+		LwpRowList* pRowList =(LwpRowList*)cParent.obj();
+		if (pRowList)
+		{
+			m_nFormulaRow = pRowList->GetRowID();
+		}
+		else
+		{
+			assert(false);
+		}
+	}
+//	sal_uInt8 cFlags = (sal_uInt8) m_pObjStrm->QuickReaduInt16(); // written as a sal_uInt16
+	m_pObjStrm->SeekRel(2);//flags, size in file: sal_uInt16
+
+	LwpNotifyListPersistent cNotifyList;
+	cNotifyList.Read(m_pObjStrm);
+
+	ReadExpression();
+
+	m_pObjStrm->SkipExtra();
+}
+
+/**
+*	Make the formula string.
+*	@date	03/26/2005
+*	@param	
+*	@param	
+*	@return	sal_Bool.
+*/
+String  LwpFormulaInfo::Convert(LwpTableLayout* pCellsMap)
+{
+	String aFormula;
+	if (m_bSupported)
+	{
+		if(1==m_aStack.size())
+		{
+			LwpFormulaArg* pFormula = m_aStack.back();
+			aFormula = pFormula->ToString(pCellsMap);
+		}
+		else
+		{
+			assert(false);
+		}
+	}
+	return aFormula;
+}
+
+/**
+*	Fill the XFCell content
+*	@date	03/26/2005
+*	@param	
+*	@param	
+*	@return	sal_Bool.
+*/
+void LwpFormulaInfo::Convert(XFCell * pCell,LwpTableLayout* pCellsMap)
+{
+	String aFormula;
+	aFormula = Convert(pCellsMap);
+	if (aFormula.Len()) 
+	{
+		pCell->SetFormula(aFormula);
+	}
+	LwpCellList::Convert(pCell);
+}
+
+//////////////////////////////////////////////////////////////////
+
+/**
+*	
+*	@date	03/26/2005
+*	@param	
+*	@param	
+*	@return	sal_Bool.
+*/
+LwpFormulaConst::LwpFormulaConst(double dVal)
+{
+	m_dVal = dVal;
+}
+
+/**
+*	
+*	@date	03/26/2005
+*	@param	
+*	@param	
+*	@return	sal_Bool.
+*/
+String LwpFormulaConst::ToString(LwpTableLayout* pCellsMap)
+{
+	return String::CreateFromDouble(m_dVal);
+}
+
+/**
+*	
+*	@date	03/26/2005
+*	@param	
+*	@param	
+*	@return
+*/
+LwpFormulaText::LwpFormulaText( String aText)
+{
+	m_aText = aText;
+}
+
+/**
+*	
+*	@date	03/26/2005
+*	@param	
+*	@param	
+*	@return
+*/
+LwpFormulaCellAddr::LwpFormulaCellAddr(sal_Int16 aCol, sal_Int16 aRow)
+{
+	m_aCol = aCol;
+	m_aRow = aRow;
+}
+
+/**
+*	
+*	@date	03/26/2005
+*	@param	
+*	@param	
+*	@return String
+*/
+String LwpFormulaCellAddr::ToString(LwpTableLayout* pCellsMap)
+{
+//	String aCellAddr;
+//	aCellAddr.AppendAscii("<");//&lt;
+//	aCellAddr+=m_aCol;
+//	aCellAddr+=m_aRow;
+//	aCellAddr.AppendAscii(">");//&gt;
+	
+	String aCellAddr;
+	aCellAddr.AppendAscii("<");//&lt;
+
+	aCellAddr += LwpFormulaTools::GetCellAddr(m_aRow,m_aCol,pCellsMap);
+	
+	aCellAddr.AppendAscii(">");//&gt;
+	return aCellAddr;
+}
+
+/**
+*	
+*	@date	03/26/2005
+*	@param	
+*	@param	
+*	@return
+*/
+LwpFormulaCellRangeAddr::LwpFormulaCellRangeAddr(sal_Int16 aStartCol, 
+												 sal_Int16 aStartRow,
+												 sal_Int16 aEndCol,
+												 sal_Int16 aEndRow)
+{
+	m_aStartCol = aStartCol;
+	m_aStartRow = aStartRow;
+	m_aEndCol = aEndCol;
+	m_aEndRow = aEndRow;
+}
+
+/**
+*	Convert the cell range into a string 
+*	@date	03/26/2005
+*	@param	
+*	@param	
+*	@return	String.
+*/
+String LwpFormulaCellRangeAddr::ToString(LwpTableLayout* pCellsMap)
+{
+//	String aCellAddr;
+//	aCellAddr.AppendAscii("<");//&lt;
+//	aCellAddr+=m_aStartCol;
+//	aCellAddr+=m_aStartRow;
+//	aCellAddr.AppendAscii(":");
+//	aCellAddr+=m_aEndCol;
+//	aCellAddr+=m_aEndRow;
+//	aCellAddr.AppendAscii(">");//&gt;
+
+	String aCellAddr;
+	aCellAddr.AppendAscii("<");//&lt;
+
+	aCellAddr += LwpFormulaTools::GetCellAddr(m_aStartRow,m_aStartCol,pCellsMap);
+	aCellAddr.AppendAscii(":");
+	aCellAddr += LwpFormulaTools::GetCellAddr(m_aEndRow,m_aEndCol,pCellsMap);
+
+	aCellAddr.AppendAscii(">");//&gt;
+
+	return aCellAddr;
+}
+
+/**
+*	
+*	@date	03/26/2005
+*	@param	
+*	@param	
+*	@return
+*/
+LwpFormulaFunc::LwpFormulaFunc(sal_uInt16 nTokenType)
+{
+	m_nTokenType = nTokenType;
+}
+
+/**
+*	
+*	@date	03/26/2005
+*	@param	
+*	@param	
+*	@return
+*/
+LwpFormulaFunc::~LwpFormulaFunc()
+{
+	try
+	{
+		while(m_aArgs.size()>0)
+		{
+			LwpFormulaArg* pArg = m_aArgs.back();
+			m_aArgs.pop_back();
+			delete pArg;pArg=NULL;
+		}
+	}catch (...) {
+		assert(false);
+	}
+
+}
+/**
+*	
+*	@date	03/26/2005
+*	@param	
+*	@param	
+*	@return
+*/
+void LwpFormulaFunc::AddArg(LwpFormulaArg* pArg)
+{
+	m_aArgs.push_back(pArg);
+}
+/**
+*	Convert the functions to a string, which is a argument of other formula
+*	@date	03/26/2005
+*	@param	
+*	@param	
+*	@return	 String.
+*/
+String LwpFormulaFunc::ToArgString(LwpTableLayout* pCellsMap)
+{
+	String aFormula;
+	aFormula.AppendAscii("(");
+	aFormula+=ToString(pCellsMap);
+	aFormula.AppendAscii(")");
+	return aFormula;
+}
+/**
+*	Convert the function to a formula string.
+*	@date	03/26/2005
+*	@param	
+*	@param	
+*	@return	sal_Bool.
+*/
+String LwpFormulaFunc::ToString(LwpTableLayout* pCellsMap)
+{
+	String aFormula;
+
+	String aFuncName = LwpFormulaTools::GetName(m_nTokenType);
+	aFormula += aFuncName;
+	aFormula.AppendAscii(" ");//Append a blank space
+	
+	//Append args
+	vector<LwpFormulaArg*>::iterator aItr;
+	for (aItr=m_aArgs.begin();aItr!=m_aArgs.end();aItr++)
+	{
+		aFormula.Append( (*aItr)->ToArgString(pCellsMap) );
+		aFormula.AppendAscii("|");//separator
+	}
+
+	//erase the last "|"
+	if (m_aArgs.size()>0) 
+	{
+		aFormula.Erase(aFormula.Len()-1,1);
+	}
+	else
+	{
+		assert(false);
+	}
+
+	return aFormula;
+}
+
+/**
+*	Convert the formula in operators to a string : e.g. 1+2+3
+*	@date	03/26/2005
+*	@param	
+*	@param	
+*	@return	sal_Bool.
+*/
+String LwpFormulaOp::ToString(LwpTableLayout* pCellsMap)
+{
+	String aFormula;
+	if (2==m_aArgs.size())
+	{
+		vector<LwpFormulaArg*>::iterator aItr = m_aArgs.end();
+		aItr--;
+		aFormula.Append( (*aItr)->ToArgString(pCellsMap) );
+
+		aFormula.AppendAscii(" ");
+
+		String aFuncName = LwpFormulaTools::GetName(m_nTokenType);
+		aFormula.Append(aFuncName);
+
+		aFormula.AppendAscii(" ");
+
+		aItr--;
+		aFormula.Append( (*aItr)->ToArgString(pCellsMap) );
+	}
+	else
+	{
+		assert(false);
+	}
+	return aFormula;
+}
+
+/**
+*	convert the formula in unary operators into string : e.g. -2
+*	@date	03/26/2005
+*	@param	
+*	@param	
+*	@return	sal_Bool.
+*/
+String LwpFormulaUnaryOp::ToString(LwpTableLayout* pCellsMap)
+{
+	String aFormula;
+	if (1==m_aArgs.size())
+	{
+		String aFuncName = LwpFormulaTools::GetName(m_nTokenType);
+		aFormula.Append(aFuncName);
+
+		vector<LwpFormulaArg*>::iterator aItr = m_aArgs.begin();
+		aFormula.Append( (*aItr)->ToArgString(pCellsMap) );
+	}
+	else
+	{
+		assert(false);
+	}
+	return aFormula;
+}
+/**
+*	Get token name
+*	@date	03/26/2005
+*	@param	
+*	@param	
+*	@return	String.
+*/
+String LwpFormulaTools::GetName(sal_uInt16 nTokenType)
+{
+	String aName;
+	switch(nTokenType)
+	{
+	case TK_SUM:
+		aName = String::CreateFromAscii("SUM");
+		break;
+	case TK_IF:
+		aName = String::CreateFromAscii("IF");//Not supported by SODC
+		break;
+	case TK_COUNT:
+		aName = String::CreateFromAscii("COUNT");//Not supported by SODC
+		break;
+	case TK_MINIMUM:
+		aName = String::CreateFromAscii("MIN");
+		break;
+	case TK_MAXIMUM:
+		aName = String::CreateFromAscii("MAX");
+		break;
+	case TK_AVERAGE:
+		aName = String::CreateFromAscii("MEAN");
+		break;
+	case TK_ADD:
+		aName = String::CreateFromAscii("+");
+		break;
+	case TK_SUBTRACT:
+		aName = String::CreateFromAscii("-");
+		break;
+	case TK_MULTIPLY:
+		aName = String::CreateFromAscii("*");
+		break;
+	case TK_DIVIDE:
+		aName = String::CreateFromAscii("/");
+		break;
+	case TK_UNARY_MINUS:
+		aName = String::CreateFromAscii("-");
+		break;
+	case TK_LESS:
+		aName = String::CreateFromAscii("L");
+		break;
+	case TK_LESS_OR_EQUAL:
+		aName = String::CreateFromAscii("LEQ");
+		break;
+	case TK_GREATER:
+		aName = String::CreateFromAscii("G");
+		break;
+	case TK_GREATER_OR_EQUAL:
+		aName = String::CreateFromAscii("GEQ");
+		break;
+	case TK_EQUAL:
+		aName = String::CreateFromAscii("EQ");
+		break;
+	case TK_NOT_EQUAL:
+		aName = String::CreateFromAscii("NEQ");
+		break;
+	case TK_NOT:
+		aName = String::CreateFromAscii("NOT");
+		break;
+	case TK_AND:
+		aName = String::CreateFromAscii("AND");
+		break;
+	case TK_OR:
+		aName = String::CreateFromAscii("OR");
+		break;
+	default:
+		assert(false);
+		break;
+	}
+	return aName;
+}
+
+/**
+*	Get cell address in String
+*	@date	03/26/2005
+*	@param	
+*	@param	
+*	@return	String.
+*/
+String LwpFormulaTools::GetCellAddr(sal_Int16 nRow, sal_Int16 nCol, LwpTableLayout* pCellsMap)
+{
+	String aCellAddr;
+	XFCell* pCell = pCellsMap->GetCellsMap(nRow,(sal_uInt8)nCol);
+	if (pCell)
+	{
+		aCellAddr = pCell->GetCellName();
+	}
+	else
+	{
+		assert( -1==nRow || -1==(sal_Int8)nCol);
+	}
+	return aCellAddr;
+}
+
diff -urNp lotuswordpro.bak/source/filter/lwptblformula.hxx lotuswordpro/source/filter/lwptblformula.hxx
--- lotuswordpro.bak/source/filter/lwptblformula.hxx	1970-01-01 08:00:00.000000000 +0800
+++ lotuswordpro/source/filter/lwptblformula.hxx	2008-10-22 11:42:29.000000000 +0800
@@ -0,0 +1,224 @@
+/*************************************************************************
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: IBM Corporation
+ *
+ *  Copyright: 2008 by IBM Corporation
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+/**
+ * @file 
+ *  For LWP filter architecture prototype - table object
+ */
+/*************************************************************************
+ * Change History
+ Mar 2005			Created
+ ************************************************************************/
+#ifndef _LWPTBLFORMULA_HXX_
+#define _LWPTBLFORMULA_HXX_
+
+using namespace std;
+
+/* These token types are written to the file.  Don't change their
+values unless you filter them.
+*/
+enum lTokenType
+{
+	TK_BAD					= 0,
+	TK_OPERAND				= 1,
+	TK_END					= 2,
+	TK_RIGHTPAREN			= 3,
+	TK_FUNCTION				= 4,
+	TK_LEFTPAREN			= 5,
+	TK_UNARY_MINUS			= 6,
+	TK_ADD					= 7,
+	TK_SUBTRACT				= 8,
+	TK_MULTIPLY				= 9,
+	TK_DIVIDE				= 10,
+	TK_EQUAL				= 11,
+	TK_LESS					= 12,
+	TK_GREATER				= 13,
+	TK_NOT_EQUAL			= 14,
+	TK_GREATER_OR_EQUAL		= 15,
+	TK_LESS_OR_EQUAL		= 16,
+	TK_NOT					= 17,
+	TK_AND					= 18,
+	TK_OR					= 19,
+	TK_CELLID				= 20,
+	TK_CONSTANT				= 21,
+	TK_TEXT					= 22,
+	TK_SUM					= 23,
+	TK_IF					= 24,
+	TK_AVERAGE				= 25,
+	TK_MAXIMUM				= 26,
+	TK_MINIMUM				= 27,
+	TK_COUNT				= 28,
+	TK_CELLRANGE			= 29,
+	TK_EXPRESSION			= 30,
+	TK_OPEN_FUNCTION		= 31,
+	TK_LIST_SEPARATOR		= 32
+};
+class LwpTableLayout;
+class LwpFormulaArg
+{
+public:
+	virtual String ToString(LwpTableLayout* pCellsMap)=0;
+	virtual String ToArgString(LwpTableLayout* pCellsMap){ return ToString(pCellsMap);}
+};
+
+class LwpFormulaTools
+{
+public:
+	static String GetName(sal_uInt16 nTokenType);
+	static String GetCellAddr(sal_Int16 nRow, sal_Int16 nCol, LwpTableLayout* pCellsMap);
+};
+
+class LwpFormulaConst:public LwpFormulaArg
+{
+public:
+	LwpFormulaConst( double dVal);
+	virtual String ToString(LwpTableLayout* pCellsMap);
+private:
+	double m_dVal;
+};
+
+class LwpFormulaText:public LwpFormulaArg
+{
+public:
+	LwpFormulaText( String aText);
+	virtual String ToString(LwpTableLayout* pCellsMap){return m_aText;}
+private:
+	String m_aText;
+};
+
+class LwpFormulaCellAddr:public LwpFormulaArg
+{
+public:
+	LwpFormulaCellAddr(sal_Int16 aCol, sal_Int16 aRow);
+
+	sal_Int16 GetCol(){return m_aCol;}
+	sal_Int16 GetRow(){return m_aRow;}
+
+	virtual String ToString(LwpTableLayout* pCellsMap);
+private:
+	sal_Int16 m_aCol;
+	sal_Int16 m_aRow;
+};
+
+class LwpFormulaCellRangeAddr:public LwpFormulaArg
+{
+public:
+	LwpFormulaCellRangeAddr(sal_Int16 aStartCol, sal_Int16 aStartRow, sal_Int16 aEndCol, sal_Int16 aEndRow);
+
+	virtual String ToString(LwpTableLayout* pCellsMap);
+private:
+	sal_Int16 m_aStartCol;
+	sal_Int16 m_aStartRow;
+	sal_Int16 m_aEndCol;
+	sal_Int16 m_aEndRow;
+};
+
+class LwpFormulaFunc :public LwpFormulaArg
+{
+public:
+	LwpFormulaFunc(sal_uInt16 nTokenType);
+	virtual ~LwpFormulaFunc();
+
+	void AddArg(LwpFormulaArg* pArg);
+
+	virtual String ToString(LwpTableLayout* pCellsMap);
+	String ToArgString(LwpTableLayout* pCellsMap);
+
+protected:
+	vector<LwpFormulaArg*> m_aArgs;
+	sal_uInt16 m_nTokenType;
+};
+
+class LwpFormulaOp : public LwpFormulaFunc
+{
+public:
+	LwpFormulaOp(sal_uInt16 nTokenType):LwpFormulaFunc(nTokenType){;}
+	String ToString(LwpTableLayout* pCellsMap);
+};
+
+class LwpFormulaUnaryOp : public LwpFormulaFunc
+{
+public:
+	LwpFormulaUnaryOp(sal_uInt16 nTokenType):LwpFormulaFunc(nTokenType){;}
+	String ToString(LwpTableLayout* pCellsMap);
+};
+
+
+class LwpFormulaInfo : public LwpCellList
+{
+public:
+	LwpFormulaInfo(LwpObjectHeader &objHdr, LwpSvStream* pStrm);
+	~LwpFormulaInfo();
+	sal_Bool IsFormula(){return sal_True;}
+	void SetRow(USHORT nRow){ m_nFormulaRow = nRow;}
+	String Convert(LwpTableLayout* pCellsMap);
+	void Convert(XFCell * pCell, LwpTableLayout* pCellsMap);
+protected:
+	void Read();	
+	sal_Bool ReadCellID();
+	sal_Bool ReadText();
+	sal_Bool ReadCellRange();
+	sal_Bool ReadExpression();
+	sal_Bool ReadArguments(LwpFormulaFunc& aFunc);
+	sal_Bool m_bSupported;
+private:
+	vector<LwpFormulaArg*> m_aStack;
+	sal_Bool ReadConst();
+	void MarkUnsupported(sal_uInt16 TokenType);
+	
+	USHORT m_nFormulaRow;
+};
+
+#endif
+
diff -urNp lotuswordpro.bak/source/filter/lwptemp.hxx lotuswordpro/source/filter/lwptemp.hxx
--- lotuswordpro.bak/source/filter/lwptemp.hxx	1970-01-01 08:00:00.000000000 +0800
+++ lotuswordpro/source/filter/lwptemp.hxx	2008-10-22 11:42:29.000000000 +0800
@@ -0,0 +1,80 @@
+/*************************************************************************
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: IBM Corporation
+ *
+ *  Copyright: 2008 by IBM Corporation
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+#ifndef _LWPTEMPOBJ_HXX_
+#define _LWPTEMPOBJ_HXX_
+
+
+class LwpTempObject
+{
+//	friend class LwpObjectFactory;
+public:
+	LwpTempObject(){};
+	~LwpTempObject(){};
+
+/*protected:
+	LwpObjectHeader m_ObjHdr;
+	LwpObjectStream* m_pObjStrm;
+	LwpObjectStream m_TempObjStrm;
+	SvStream* m_pTempStrm;
+
+protected:
+	void QuickRead();
+	virtual void Read();
+public:
+	LwpObjectID* GetObjectID(){ return m_ObjHdr.GetID();}*/
+};
+
+#endif
+
diff -urNp lotuswordpro.bak/source/filter/lwptoc.cxx lotuswordpro/source/filter/lwptoc.cxx
--- lotuswordpro.bak/source/filter/lwptoc.cxx	1970-01-01 08:00:00.000000000 +0800
+++ lotuswordpro/source/filter/lwptoc.cxx	2008-10-22 11:42:29.000000000 +0800
@@ -0,0 +1,456 @@
+/*************************************************************************
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: IBM Corporation
+ *
+ *  Copyright: 2008 by IBM Corporation
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+/**
+ * @file 
+ *  For LWP filter architecture prototype - TOC related object
+ */
+/*************************************************************************
+ * Change History
+ April 2005		 	Created
+ April 2005			Modified
+ April 2005 				Modified - add LwpTocLevelData class
+ ************************************************************************/
+#include "lwptoc.hxx"
+#include "lwpfoundry.hxx"
+#include "lwpdoc.hxx"
+#include "lwpframelayout.hxx"
+#include "lwpglobalmgr.hxx"
+
+#include "xfilter/xffont.hxx"
+#include "xfilter/xftextstyle.hxx"
+#include "xfilter/xfstylemanager.hxx"
+#include "xfilter/xfparagraph.hxx"
+#include "xfilter/xfparastyle.hxx"
+#include "xfilter/xfindex.hxx"
+#include	"xfilter/xffloatframe.hxx"
+#include "xfilter/xfframestyle.hxx"
+#include "xfilter/xfframe.hxx"
+#include "xfilter/xftable.hxx"
+
+LwpTocSuperLayout::LwpTocSuperLayout(LwpObjectHeader &objHdr, LwpSvStream* pStrm)
+	: LwpSuperTableLayout(objHdr, pStrm)
+{}
+
+LwpTocSuperLayout::~LwpTocSuperLayout()
+{}
+/**
+ * @short   Read TOCSUPERTABLELAYOUT object
+ * @return  none
+ */
+void LwpTocSuperLayout::Read()
+{
+	LwpSuperTableLayout::Read();
+	m_TextMarker.Read(m_pObjStrm);
+	m_ParentName.Read(m_pObjStrm);
+	m_DivisionName.Read(m_pObjStrm);
+	m_SectionName.Read(m_pObjStrm);
+	m_nFrom = m_pObjStrm->QuickReaduInt16();
+
+	m_SearchItems.Read(m_pObjStrm);
+
+	sal_uInt16 i;
+	sal_uInt16 count = m_pObjStrm->QuickReaduInt16();
+	for (i = 0; (i < MAX_LEVELS) && (count > 0); i++, count--)
+		m_DestName[i].Read(m_pObjStrm);
+
+	count = m_pObjStrm->QuickReaduInt16();
+	for (i = 0; (i < MAX_LEVELS) && (count > 0); i++, count--)
+		m_DestPGName[i].Read(m_pObjStrm);
+
+	count = m_pObjStrm->QuickReaduInt16();
+	for (i = 0; i < count; i++)
+		m_nFlags[i] = m_pObjStrm->QuickReaduInt32();
+
+	m_pObjStrm->SkipExtra();
+}
+/**
+ * @short   Register style of TOC
+ * @return  none
+ */
+void LwpTocSuperLayout::RegisterStyle()
+{
+	LwpSuperTableLayout::RegisterStyle();
+
+	// Get font info of default text style and set into tab style
+	XFParaStyle* pBaseStyle = static_cast<XFParaStyle*>(m_pFoundry->GetStyleManager()->GetStyle(*m_pFoundry->GetDefaultTextStyle())); 
+	XFTextStyle*pTextStyle = new XFTextStyle;
+	pTextStyle->SetFont(pBaseStyle->GetFont()); // who delete this font?????
+	XFStyleManager* pXFStyleManager = LwpGlobalMgr::GetInstance()->GetXFStyleManager(); 
+	m_TabStyleName = pXFStyleManager->AddStyle(pTextStyle)->GetStyleName();
+	
+}
+/**
+ * @short   Convert TOC
+ * @param  pCont - container
+ * @return none
+ */
+void  LwpTocSuperLayout::XFConvert(XFContentContainer* pCont)
+{
+	XFIndex* pToc = new XFIndex();
+
+	pToc->SetProtected(sal_False);
+	pToc->SetIndexType(enumXFIndexTOC);
+
+	// add TOC template
+	for (sal_uInt16 i = 1; i<= MAX_LEVELS; i++)
+	{
+		LwpTocLevelData * pLevel = GetSearchLevelPtr(i);
+		XFIndexTemplate * pTemplate = new XFIndexTemplate();
+
+		if(!pLevel)
+		{
+			// add an blank template so that SODC won't add default style to this level
+			pToc->AddTemplate(Int32ToOUString(i),  String::CreateFromAscii(""), pTemplate);
+			continue;
+		}
+
+		sal_Bool bInserted = sal_False;
+		do
+		{
+			// One level has 1 template
+			if (!bInserted)
+			{
+				pTemplate->SetLevel(Int32ToOUString(i));
+				if(pLevel->GetUseLeadingText())
+				{
+					pTemplate->AddEntry(enumXFIndexTemplateChapter, pLevel->GetSearchStyle());
+				}
+				if(pLevel->GetUseText())
+				{
+					pTemplate->AddEntry(enumXFIndexTemplateText, pLevel->GetSearchStyle());
+				}
+				if(GetUsePageNumber(i)) 
+				{
+					sal_uInt16 nLeaderType = GetSeparatorType(i);
+					if (GetRightAlignPageNumber(i))
+					{
+						char cSep = ' ';
+						switch(nLeaderType)
+						{
+						default: // go through
+						case NONE: // no leaders
+							cSep = ' ';
+							break;
+						case LEADERDOTS:
+							cSep = '.';
+							break;
+						case LEADERDASHES:
+							cSep = '-';
+							break;
+						case LEADERUNDERLINE:
+							cSep = '_';
+							break;
+						}
+
+						pTemplate->AddTabEntry(enumXFTabRight, 0, cSep, 'd', m_TabStyleName);
+					}
+					else
+					{
+						char sSep[8];
+						switch(nLeaderType)
+						{
+						default: // go through
+						case NONE: // no leaders
+							strcpy(sSep, "  ");
+							break;
+						case SEPARATORCOMMA:
+							strcpy(sSep, ", ");
+							break;
+						case SEPARATORDOTS:
+							strcpy(sSep, "...");
+							break;
+						}
+						pTemplate->AddTextEntry(A2OUSTR(sSep), m_TabStyleName);
+					}
+					//"TOC Page Number Text Style" style always exists in Word Pro file
+					pTemplate->AddEntry(enumXFIndexTemplatePage, A2OUSTR("TOC Page Number Text Style"));
+				}
+
+				pToc->AddTemplate(Int16ToOUString(i),  m_pFoundry->FindActuralStyleName(pLevel->GetSearchStyle()), pTemplate);
+				bInserted = sal_True;
+			}
+
+			// 1 style in WordPro may be mapped to several styles in SODC
+			LwpDocument * pDocument = m_pFoundry->GetDocument()->GetRootDocument();
+			AddSourceStyle(pToc, pLevel,  pDocument->GetFoundry());
+
+			// one level may have several corresponding Styles
+			pLevel = GetNextSearchLevelPtr(i, pLevel);  // find next LwpTocLevelData which is same index
+		}while (pLevel != NULL);
+	}
+
+	m_pCont = pCont;
+	// add TOC content
+	LwpSuperTableLayout::XFConvert(pToc);
+
+	// if current TOC is located in a cell, we must add a frame between upper level container and TOC
+	if ( !GetContainerLayout()->IsCell() )
+	{
+		pCont->Add(pToc);
+	}
+}
+
+/**
+ * @short   convert frame which anchor to page
+ * @param pCont - 
+ * @return  
+ */
+void  LwpTocSuperLayout::XFConvertFrame(XFContentContainer* pCont, sal_Int32 nStart , sal_Int32 nEnd , sal_Bool bAll)
+{
+	if(m_pFrame)
+	{
+		XFFrame* pXFFrame = NULL;
+		if(nEnd < nStart)
+		{
+			pXFFrame = new XFFrame();
+		}
+		else
+		{
+			pXFFrame = new XFFloatFrame(nStart, nEnd, bAll);
+		}
+	
+		m_pFrame->Parse(pXFFrame, static_cast<sal_uInt16>(nStart));
+
+		//parse table, and add table to frame or TOC
+		LwpTableLayout * pTableLayout = GetTableLayout();
+		if (pTableLayout)
+		{
+			XFContentContainer * pTableContainer = pXFFrame;
+			// if *this is a TOCSuperTableLayout and it's located in a cell
+			// add the frame to upper level and add TOCSuperTableLayout into the frame
+			if ( GetContainerLayout()->IsCell() )
+			{
+				pTableContainer = pCont; // TOC contain table directly
+				pXFFrame->Add(pCont);
+				m_pCont->Add(pXFFrame);
+			}
+			else
+			{
+				//add frame to the container
+				pCont ->Add(pXFFrame);
+			}
+			pTableLayout->XFConvert(pTableContainer);
+		}
+	}
+	
+}
+
+/**
+ * @short   Add source style into TOC
+ * @param  pToc - TOC pointer
+ * @param  pLevel - TOC level data
+ * @param  pFoundry - foundry pointer
+ * @return sal_Bool
+ */
+void LwpTocSuperLayout::AddSourceStyle(XFIndex* pToc, LwpTocLevelData * pLevel, LwpFoundry * pFoundry)
+{
+	if (!pLevel)
+	{
+		return;
+	}
+	
+	OUString sLwpStyleName = pLevel->GetSearchStyle();
+
+	if (pFoundry)
+	{
+		LwpDocument * pDoc = pFoundry->GetDocument();
+		if (pDoc && pDoc->IsChildDoc())
+		{
+			OUString sSodcStyleName = pFoundry->FindActuralStyleName(sLwpStyleName);
+			pToc->AddTocSource(pLevel->GetLevel(), sSodcStyleName);
+		}
+		else
+		{
+			pDoc = pDoc->GetFirstDivision();
+			while (pDoc)
+			{
+				AddSourceStyle(pToc, pLevel, pDoc->GetFoundry() );
+				pDoc = pDoc->GetNextDivision();
+			}
+		}
+	}
+}
+
+/**
+ * @short   Get whether page number is right alignment
+ * @param  index - TOC level
+ * @return sal_Bool
+ */
+sal_Bool LwpTocSuperLayout::GetRightAlignPageNumber(sal_uInt16 index)
+{
+	if (index < MAX_LEVELS)
+		return (m_nFlags[index] & TS_RIGHTALIGN) ? sal_True : sal_False;
+	return sal_False;
+}
+/**
+ * @short   Get whether page number is used in TOC entries
+ * @param  index - TOC level
+ * @return sal_Bool
+ */
+sal_Bool LwpTocSuperLayout::GetUsePageNumber(sal_uInt16 index)
+{
+	if (index < MAX_LEVELS)
+		return (m_nFlags[index] & TS_PAGENUMBER) ? sal_True : sal_False;
+	return sal_False;
+}
+/**
+ * @short   Get what is used for separater
+ * @param  index - TOC level
+ * @return sal_uInt16 - separator type
+ */
+sal_uInt16 LwpTocSuperLayout::GetSeparatorType(sal_uInt16 index)
+{
+	sal_uInt16 Flag = (sal_uInt16)m_nFlags[index];
+
+	if (Flag & TS_LEADERDOTS)
+		return LEADERDOTS;
+	else if (Flag & TS_LEADERDASHES)
+		return LEADERDASHES;
+	else if (Flag & TS_LEADERUNDERLINE)
+		return LEADERUNDERLINE;
+	else if (Flag & TS_SEPARATORCOMMA)
+		return SEPARATORCOMMA;
+	else if (Flag & TS_SEPARATORDOTS)
+		return SEPARATORDOTS;
+	else 
+		return NONE;
+}
+
+/**
+ * @short   Get TOCLEVELDATA obj
+ * @param  index - TOC level
+ * @return LwpTocLevelData * - pointer to TOCLEVELDATA obj
+ */
+LwpTocLevelData * LwpTocSuperLayout::GetSearchLevelPtr(sal_uInt16 index)
+{
+	LwpObjectID * pID = m_SearchItems.GetHead(); // not necessary to check pID NULL or not
+	LwpTocLevelData * pObj = static_cast<LwpTocLevelData *>(pID->obj());
+
+	while(pObj)
+	{
+		if(pObj->GetLevel()== index)
+		{
+			return pObj;
+		}
+	
+		pID = pObj->GetNext(); // not necessary to check pID NULL or not
+		pObj = static_cast<LwpTocLevelData *>(pID->obj());
+	}
+
+	return NULL;
+}
+/**
+ * @short   Get next TOCLEVELDATA obj from current position
+ * @param  index - TOC level
+ * @param  pCurData - current LwpTocLevelData
+ * @return LwpTocLevelData * - pointer to TOCLEVELDATA obj
+ */
+LwpTocLevelData * LwpTocSuperLayout::GetNextSearchLevelPtr(sal_uInt16 index, LwpTocLevelData * pCurData)
+{
+	LwpObjectID * pID = pCurData->GetNext();
+	LwpTocLevelData * pObj = static_cast<LwpTocLevelData *>(pID->obj());
+
+	while(pObj)
+	{
+		if(pObj->GetLevel()== index)
+		{
+			return pObj;
+		}
+	
+		pID = pObj->GetNext(); // not necessary to check pID NULL or not
+		pObj = static_cast<LwpTocLevelData *>(pID->obj());
+	}
+
+	return NULL;
+}
+
+LwpTocLevelData::LwpTocLevelData(LwpObjectHeader &objHdr, LwpSvStream* pStrm):LwpDLVList(objHdr, pStrm)
+{
+	m_nFlags = 0;
+	m_nLevel = 0;
+}
+LwpTocLevelData::~LwpTocLevelData()
+{
+}
+/**
+ * @short   Register style
+ * @param 
+ * @return 
+ */
+void LwpTocLevelData::RegisterStyle()
+{
+}
+/**
+ * @short   Convert
+ * @param  pCont - container
+ * @return none
+ */
+void LwpTocLevelData::XFConvert(XFContentContainer* pCont)
+{
+}
+/**
+ * @short   Read TOCLEVELDATA obj
+ * @param  
+ * @return 
+ */
+void LwpTocLevelData::Read()
+{
+	LwpDLVList::Read();
+	m_nFlags = m_pObjStrm->QuickReaduInt16();
+	m_nLevel = m_pObjStrm->QuickReaduInt16();
+	m_SearchName.Read(m_pObjStrm);
+	
+	m_pObjStrm->SkipExtra();
+}
diff -urNp lotuswordpro.bak/source/filter/lwptoc.hxx lotuswordpro/source/filter/lwptoc.hxx
--- lotuswordpro.bak/source/filter/lwptoc.hxx	1970-01-01 08:00:00.000000000 +0800
+++ lotuswordpro/source/filter/lwptoc.hxx	2008-10-22 11:42:29.000000000 +0800
@@ -0,0 +1,170 @@
+/*************************************************************************
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: IBM Corporation
+ *
+ *  Copyright: 2008 by IBM Corporation
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+/*************************************************************************
+ * Change History
+April 2005			Created
+ April 2005 				Modified - add LwpTocLevelData class
+ ************************************************************************/
+
+#ifndef _LWPTOCSUPERTABLELAYOUT_HXX
+#define _LWPTOCSUPERTABLELAYOUT_HXX
+#include "lwptablelayout.hxx"
+class XFIndex;
+class LwpDocument;
+class LwpFoundry;
+class LwpTocLevelData;
+class XFIndex;
+class XFIndexTemplate;
+/**
+ * @brief
+ * VO_TOCSUPERTABLELAYOUT object
+ */
+class LwpTocSuperLayout : public LwpSuperTableLayout
+{
+public:
+	LwpTocSuperLayout(LwpObjectHeader &objHdr, LwpSvStream* pStrm);
+	virtual ~LwpTocSuperLayout();
+	void RegisterStyle();
+	virtual void XFConvert(XFContentContainer* pCont);
+	virtual LWP_LAYOUT_TYPE GetLayoutType () { return LWP_TOC_SUPERTABLE_LAYOUT;}
+	virtual void XFConvertFrame(XFContentContainer* pCont, sal_Int32 nStart = 0, sal_Int32 nEnd = 0, sal_Bool bAll = sal_False);
+protected:
+	void Read();	
+	sal_Bool GetRightAlignPageNumber(sal_uInt16 index);
+	sal_Bool GetUsePageNumber(sal_uInt16 index);
+	sal_uInt16 GetSeparatorType(sal_uInt16 index);
+	LwpTocLevelData * GetSearchLevelPtr(sal_uInt16 index);
+	LwpTocLevelData * GetNextSearchLevelPtr(sal_uInt16 index, LwpTocLevelData * pCurData);
+	void AddSourceStyle(XFIndex* pToc, LwpTocLevelData * pLevel,  LwpFoundry * pFoundry);
+private:
+	enum {MAX_LEVELS = 9};
+	enum
+	{
+		TS_NOLEADERS = 0x01,
+		TS_LEADERDOTS = 0x02,
+		TS_LEADERDASHES = 0x04,
+		TS_LEADERUNDERLINE = 0x08,
+		TS_SEPARATORCOMMA = 0x10,
+		TS_SEPARATORDOTS = 0x20,
+		TS_PAGENUMBER = 0x40,
+		TS_RIGHTALIGN = 0x80
+	};
+
+	enum
+	{
+		NONE = 0,
+		LEADERDOTS = 1,
+		LEADERDASHES = 2,
+		LEADERUNDERLINE = 3,
+		SEPARATORCOMMA = 4,
+		SEPARATORDOTS = 5
+	};
+
+	//m_nFrom
+	enum
+	{
+		SELECTEDTEXT = 1,
+		ENTIREDOCUMENT = 2,
+		CURRENTLEVELDIVISION = 3,
+		CURRENTDIVISION = 4,
+		CURRENTSECTION = 5
+	};
+
+	LwpAtomHolder m_TextMarker;			/* for selected text */
+	LwpAtomHolder m_ParentName;		/* for currentleveldivision */
+	LwpAtomHolder m_DivisionName;		/* for currentdivision&currentsection */
+	LwpAtomHolder m_SectionName;		/* for currentsection */
+	sal_uInt16 m_nFrom;
+	LwpDLVListHeadTail m_SearchItems;
+	LwpAtomHolder m_DestName[MAX_LEVELS];
+	LwpAtomHolder m_DestPGName[MAX_LEVELS];
+	sal_uInt32 m_nFlags[MAX_LEVELS];
+	
+	std::vector<std::pair<OUString,OUString> > m_TOCList;
+
+	rtl::OUString m_TabStyleName;
+
+	XFContentContainer* m_pCont;
+};
+/**
+ * @brief
+ * VO_TOCLEVELDATA object
+ */
+class LwpTocLevelData : public LwpDLVList
+{
+public:
+	enum
+	{
+		USETEXT = 0x01,
+		USENUMBER = 0x02
+	};
+	LwpTocLevelData(LwpObjectHeader &objHdr, LwpSvStream* pStrm);
+	~LwpTocLevelData();
+	void RegisterStyle();
+	virtual void XFConvert(XFContentContainer* pCont);
+	inline sal_uInt16 GetLevel(void){return m_nLevel;};
+	inline sal_Bool GetUseText(void){	return (m_nFlags & USETEXT) ? sal_True : sal_False;};
+	inline OUString GetSearchStyle(void){return m_SearchName.str();};
+	inline sal_Bool GetUseLeadingText(void){	return (m_nFlags & USENUMBER) ? sal_True : sal_False;}
+private:
+	sal_uInt16 m_nFlags;
+	sal_uInt16 m_nLevel;
+	LwpAtomHolder m_SearchName;
+
+protected:
+	void Read();	
+};
+
+#endif
diff -urNp lotuswordpro.bak/source/filter/lwptools.cxx lotuswordpro/source/filter/lwptools.cxx
--- lotuswordpro.bak/source/filter/lwptools.cxx	1970-01-01 08:00:00.000000000 +0800
+++ lotuswordpro/source/filter/lwptools.cxx	2008-10-22 11:42:29.000000000 +0800
@@ -0,0 +1,921 @@
+/*************************************************************************
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: IBM Corporation
+ *
+ *  Copyright: 2008 by IBM Corporation
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+/*************************************************************************
+ * @file 
+ *  For LWP filter architecture prototype
+ ************************************************************************/
+/*************************************************************************
+ * Change History
+ Jan 2005			Created
+ ************************************************************************/
+
+#include "lwptools.hxx"
+#include <rtl/ustrbuf.hxx>
+#include <osl/process.h>
+#include <osl/thread.h>
+#include <osl/file.hxx>
+#include <vcl/svapp.hxx>
+#include <vcl/settings.hxx>
+#include <unicode/datefmt.h>
+#include <unicode/udat.h>
+
+#ifdef SAL_UNX
+#define SEPARATOR '/'
+#else
+#define SEPARATOR '\\'
+#endif
+
+using namespace icu;
+using namespace ::rtl;
+using namespace ::osl;
+
+/**
+ * @descr		read lwp unicode string from stream to OUString per aEncoding
+*/
+sal_uInt16 LwpTools::QuickReadUnicode(LwpObjectStream* pObjStrm, 
+		OUString& str, sal_uInt16 strlen, rtl_TextEncoding aEncoding)	
+		//strlen: length of bytes
+{
+
+	sal_uInt16 readLen = 0;
+	OUStringBuffer strBuf(128);
+	sal_uInt16 len = 0;
+	
+	if( !IsUnicodePacked(pObjStrm, strlen) )
+	{
+		sal_Char buf[1024];
+		
+		while(strlen)
+		{
+			strlen>1023?len=1023 :len=strlen;
+			len = pObjStrm->QuickRead(buf, len);
+			buf[len] = '\0';
+			strBuf.append( OUString(buf, len, aEncoding) );
+			strlen -= len;
+			readLen += len;
+			if(!len) break;
+		}
+		str = strBuf.makeStringAndClear();
+		return readLen;
+	}
+	else
+	{
+		sal_Char buf[1024];
+		sal_Unicode unibuf[1024];
+		sal_uInt8 readbyte;
+		sal_uInt16 readword;
+
+		BOOL flag = sal_False;	//switch if unicode part reached
+		sal_uInt16 sublen = 0;
+		
+		while(readLen<strlen)
+		{
+			if(!flag)	//Not unicode string
+			{
+				len = pObjStrm->QuickRead(&readbyte, sizeof(readbyte));
+				if(!len) break;
+				readLen+=len;
+				
+				if(readbyte == 0x00)
+				{
+					flag = sal_True;
+					if(sublen>0)	//add it to the strBuf
+					{
+						strBuf.append( OUString(buf, sublen, aEncoding) ); //try the aEncoding
+						sublen = 0;
+					}
+				}
+				else
+				{
+					buf[sublen++] = readbyte;						
+				}
+				if(sublen>=1023 || readLen==strlen) //add it to the strBuf
+				{
+					strBuf.append( OUString(buf, sublen, aEncoding) ); //try the aEncoding
+					sublen = 0;
+				}
+			}
+			else		//unicode string
+			{
+				len = pObjStrm->QuickRead(&readword, sizeof(readword));
+				if(!len) break;
+				readLen+=len;
+				
+				if(readword == 0x0000)
+				{
+					flag = sal_False;
+					if(sublen)
+					{
+						unibuf[sublen] = sal_Unicode('\0');
+						strBuf.append( OUString(unibuf) );
+						sublen = 0;
+					}
+				}
+				else
+				{
+					unibuf[sublen++] = readword;
+				}
+				if(sublen>=1023 || readLen==strlen)
+				{
+					unibuf[sublen] = sal_Unicode('\0');
+					strBuf.append( OUString(unibuf) );
+					sublen = 0;
+				}
+			}
+		}
+//		if(sublen)
+//		{
+//			unibuf[sublen] = sal_Unicode('\0');
+//			strBuf.append( OUString(unibuf) );
+//			sublen = 0;
+//		}	
+		str = strBuf.makeStringAndClear();
+		return readLen;
+	}
+}
+
+/**
+ * @descr		Judge if the data (len) in object stream is lwp unicode packed
+*/
+BOOL LwpTools::IsUnicodePacked(LwpObjectStream* pObjStrm, sal_uInt16 len)
+{
+	sal_uInt8 byte;
+	sal_uInt16 oldpos = pObjStrm->GetPos();
+	
+	for (sal_uInt16 i = 0; i < len; i++)
+	{
+		pObjStrm->QuickRead(&byte, sizeof(byte));
+		if (byte == 0x00)
+		{
+			pObjStrm->Seek(oldpos);
+			return sal_True;
+		}
+	}
+	pObjStrm->Seek(oldpos);
+	return sal_False;
+}
+
+sal_Bool LwpTools::isFileUrl(const OString &fileName)
+{
+	if (fileName.indexOf("file://") == 0 )
+        return sal_True;
+    return sal_False;
+}
+
+OUString LwpTools::convertToFileUrl(const OString &fileName)
+{
+	if ( isFileUrl(fileName) )
+    {
+        return OStringToOUString(fileName, osl_getThreadTextEncoding());
+    }
+
+    OUString uUrlFileName;
+    OUString uFileName(fileName.getStr(), fileName.getLength(), osl_getThreadTextEncoding());
+    if ( fileName.indexOf('.') == 0 || fileName.indexOf(SEPARATOR) < 0 )
+    {
+        OUString uWorkingDir;
+        OSL_VERIFY( osl_getProcessWorkingDir(&uWorkingDir.pData) == osl_Process_E_None );
+        OSL_VERIFY( FileBase::getAbsoluteFileURL(uWorkingDir, uFileName, uUrlFileName) == FileBase::E_None );
+    } else
+    {
+        OSL_VERIFY( FileBase::getFileURLFromSystemPath(uFileName, uUrlFileName) == FileBase::E_None );
+    }
+
+    return uUrlFileName;
+}
+
+OUString LwpTools::DateTimeToOUString(LtTm & dt)
+{
+	rtl::OUStringBuffer	buf;
+	buf.append(dt.tm_year);
+	buf.append( A2OUSTR("-") );
+	buf.append(dt.tm_mon);
+	buf.append( A2OUSTR("-") );
+	buf.append(dt.tm_mday);
+	buf.append( A2OUSTR("T") );
+	buf.append(dt.tm_hour);
+	buf.append( A2OUSTR(":") );
+	buf.append(dt.tm_min);
+	buf.append( A2OUSTR(":") );
+	buf.append(dt.tm_sec);
+	
+	return buf.makeStringAndClear();
+}
+
+/**
+ * @descr	get the system date format
+*/
+XFDateStyle* LwpTools::GetSystemDateStyle(sal_Bool bLongFormat)
+{
+	icu::DateFormat::EStyle style;
+	if (bLongFormat)
+		style = icu::DateFormat::FULL;//system full date format
+	else
+		style = icu::DateFormat::SHORT;//system short date format
+/*	::com::sun::star::lang::Locale aLocale=Application::GetSettings().GetLocale();
+	rtl::OUString strLang = aLocale.Language;
+	rtl::OUString strCountry = aLocale.Country;
+	strLang = strLang + A2OUSTR("_");
+	rtl::OUString strLocale = strLang + strCountry;	
+	
+	int32_t nLength = 0;
+	int32_t nLengthNeed;
+	UErrorCode status = U_ZERO_ERROR;
+	UChar* pattern = NULL;
+	
+	UDateFormat* fmt= udat_open(UDAT_FULL, UDAT_FULL, 
+		(char*)(OUStringToOString(strLocale,RTL_TEXTENCODING_MS_1252).getStr()), NULL, 0, NULL, 0, &status);
+	
+	nLengthNeed = udat_toPattern(fmt,true,NULL,nLength,&status);
+	if (status == U_BUFFER_OVERFLOW_ERROR)
+	{
+		status = U_ZERO_ERROR;
+		nLength = nLengthNeed +1;
+		pattern = (UChar*)malloc(sizeof(UChar)*nLength);
+		udat_toPattern(fmt,true,pattern,nLength,&status);
+	}
+*/	
+	//1 get locale for system
+	::com::sun::star::lang::Locale aLocale=Application::GetSettings().GetLocale();
+	rtl::OUString strLang = aLocale.Language;
+	rtl::OUString strCountry = aLocale.Country;
+	icu::Locale bLocale((char*)(OUStringToOString(strLang,RTL_TEXTENCODING_MS_1252).getStr()),
+		(char*)(OUStringToOString(strCountry,RTL_TEXTENCODING_MS_1252).getStr()));	
+	//2 get icu format pattern by locale
+	icu::DateFormat* fmt = icu::DateFormat::createDateInstance(style,bLocale);
+	
+	int32_t nLength = 0;
+	int32_t nLengthNeed;
+	UErrorCode status = U_ZERO_ERROR;
+	UChar* pattern = NULL;
+	
+	nLengthNeed = udat_toPattern((void *const *)fmt,sal_False,NULL,nLength,&status);
+	if (status == U_BUFFER_OVERFLOW_ERROR)
+	{
+		status = U_ZERO_ERROR;
+		nLength = nLengthNeed +1;
+		pattern = (UChar*)malloc(sizeof(UChar)*nLength);
+		udat_toPattern((void *const *)fmt,sal_False,pattern,nLength,&status);
+	}
+	if (pattern == NULL)
+		return NULL;
+	// 3 parse pattern string,per icu date/time format syntax, there are 20 letters reserved
+	// as patter letter,each represent a element in date/time and its repeat numbers represent 
+	// different format: for exampel: M produces '1',MM produces '01', MMM produces 'Jan', MMMM produces 'Januaray'
+	// letter other than these letters is regard as text in the format, for example ','in 'Jan,2005'
+	// we parse pattern string letter by letter and get the time format.
+	UChar cSymbol;
+	UChar cTmp;	
+	XFDateStyle* pDateStyle = new XFDateStyle;
+	
+	for (int32_t i=0;i<nLengthNeed;)
+	{
+		cSymbol = pattern[i];
+		int32_t j;
+		switch(cSymbol)
+		{
+			case 'G':
+			{
+				for (j=1;;j++)
+				{
+					cTmp = pattern[i+j];
+					if (cTmp != cSymbol)
+					{
+						i=i+j;
+						break;
+					}
+				}
+				pDateStyle->AddEra();
+				break;
+			}
+			case 'y':
+			{
+				for (j=1;;j++)
+				{
+					cTmp = pattern[i+j];
+					if (cTmp != cSymbol)
+					{
+						i=i+j;
+						break;
+					}
+				}
+				if (j <= 2)
+					pDateStyle->AddYear(sal_False);	
+				else
+					pDateStyle->AddYear();
+				break;
+			}
+			case 'M':
+			{
+				for (j=1;;j++)
+				{
+					cTmp = pattern[i+j];
+					if (cTmp != cSymbol)
+					{
+						i=i+j;
+						break;
+					}
+				}
+				if (j==1)
+					pDateStyle->AddMonth(sal_False,sal_False);	
+				else if (j==2)
+					pDateStyle->AddMonth(sal_True,sal_False);
+				else if (j==3)
+					pDateStyle->AddMonth(sal_False,sal_True);
+				else
+					pDateStyle->AddMonth(sal_True,sal_True);	
+				break;
+			}
+			case 'd':
+			{
+				for (j=1;;j++)
+				{
+					cTmp = pattern[i+j];
+					if (cTmp != cSymbol)
+					{
+						i=i+j;
+						break;
+					}
+				}
+				if (j==1)
+					pDateStyle->AddMonthDay(sal_False);	
+				else 
+					pDateStyle->AddMonthDay();	
+				break;
+			}
+			case 'h':
+			{
+				for (j=1;;j++)
+				{
+					cTmp = pattern[i+j];
+					if (cTmp != cSymbol)
+					{
+						i=i+j;
+						break;
+					}
+				}
+				if (j==1)
+					pDateStyle->AddHour(sal_False);	
+				else 
+					pDateStyle->AddHour();	
+				break;
+			}
+			case 'H':
+			{
+				for (j=1;;j++)
+				{
+					cTmp = pattern[i+j];
+					if (cTmp != cSymbol)
+					{
+						i=i+j;
+						break;
+					}
+				}
+				if (j==1)
+					pDateStyle->AddHour(sal_False);	
+				else 
+					pDateStyle->AddHour();	
+				break;				
+			}
+			case 'm':
+			{
+				for (j=1;;j++)
+				{
+					cTmp = pattern[i+j];
+					if (cTmp != cSymbol)
+					{
+						i=i+j;
+						break;
+					}
+				}
+				if (j==1)
+					pDateStyle->AddMinute(sal_False);	
+				else 
+					pDateStyle->AddMinute();	
+				break;				
+			}
+			case 's':
+			{
+				for (j=1;;j++)
+				{
+					cTmp = pattern[i+j];
+					if (cTmp != cSymbol)
+					{
+						i=i+j;
+						break;
+					}
+				}
+				if (j==1)
+					pDateStyle->AddSecond(sal_False,0);	
+				else 
+					pDateStyle->AddSecond(sal_True,0);	
+				break;				
+			}
+			case 'S':
+			{
+				for (j=1;;j++)
+				{
+					cTmp = pattern[i+j];
+					if (cTmp != cSymbol)
+					{
+						i=i+j;
+						break;
+					}
+				}
+				/*if (j==1)
+					pDateStyle->AddSecond(sal_False);	
+				else 
+					pDateStyle->AddSecond();*/	
+				break;				
+			}
+			case 'E':
+			{
+				for (j=1;;j++)
+				{
+					cTmp = pattern[i+j];
+					if (cTmp != cSymbol)
+					{
+						i=i+j;
+						break;
+					}
+				}
+				if (j<=2)
+					pDateStyle->AddWeekDay(sal_False);	
+				else
+					pDateStyle->AddWeekDay();	
+				break;
+			}
+			case 'D':
+			{
+				for (j=1;;j++)
+				{
+					cTmp = pattern[i+j];
+					if (cTmp != cSymbol)
+					{
+						i=i+j;
+						break;
+					}
+				}
+				/*if (j==1)
+					pDateStyle->AddWeekDay(sal_False);	
+				else
+					pDateStyle->AddWeekDay();*/	
+				break;
+			}
+			case 'F':
+			{
+				for (j=1;;j++)
+				{
+					cTmp = pattern[i+j];
+					if (cTmp != cSymbol)
+					{
+						i=i+j;
+						break;
+					}
+				}
+				/*if (j==1)
+					pDateStyle->AddWeekDay(sal_False);	
+				else
+					pDateStyle->AddWeekDay();*/	
+				break;
+			}
+			case 'w':
+			{
+				for (j=1;;j++)
+				{
+					cTmp = pattern[i+j];
+					if (cTmp != cSymbol)
+					{
+						i=i+j;
+						break;
+					}
+				}
+				/*if (j==1)
+					pDateStyle->AddWeekDay(sal_False);	
+				else
+					pDateStyle->AddWeekDay();*/	
+				break;
+			}
+			case 'W':
+			{
+				for (j=1;;j++)
+				{
+					cTmp = pattern[i+j];
+					if (cTmp != cSymbol)
+					{
+						i=i+j;
+						break;
+					}
+				}
+				/*if (j==1)
+					pDateStyle->AddWeekDay(sal_False);	
+				else
+					pDateStyle->AddWeekDay();*/	
+				break;
+			}
+			case 'a':
+			{
+				for (j=1;;j++)
+				{
+					cTmp = pattern[i+j];
+					if (cTmp != cSymbol)
+					{
+						i=i+j;
+						break;
+					}
+				}
+				pDateStyle->AddAmPm(sal_True);	
+				break;
+			}
+			case 'k':
+			{
+				for (j=1;;j++)
+				{
+					cTmp = pattern[i+j];
+					if (cTmp != cSymbol)
+					{
+						i=i+j;
+						break;
+					}
+				}	
+				break;
+			}
+			case 'K':
+			{
+				for (j=1;;j++)
+				{
+					cTmp = pattern[i+j];
+					if (cTmp != cSymbol)
+					{
+						i=i+j;
+						break;
+					}
+				}
+				if (j==1)
+					pDateStyle->AddHour(sal_False);
+				else
+					pDateStyle->AddHour();						
+				break;
+			}
+			case 'Z':
+			{
+				for (j=1;;j++)
+				{
+					cTmp = pattern[i+j];
+					if (cTmp != cSymbol)
+					{
+						i=i+j;
+						break;
+					}
+				}	
+				break;
+			}
+			case '\''://'
+			{
+				for (j=1;;j++)
+				{
+					cTmp = pattern[i+j];
+					if (cTmp != cSymbol)
+					{
+						i=i+j;
+						break;
+					}
+				}	
+				break;	
+			}
+			case '"':
+			{
+				pDateStyle->AddText(OUString(A2OUSTR("'")));
+				break;
+			}
+			default:
+			{
+				if ((cSymbol>='A' && cSymbol<='Z') || (cSymbol>='a' && cSymbol<='z') )
+					return NULL;
+				else//TEXT
+				{
+					//UChar buffer[1024];
+					sal_Unicode buffer[1024];
+					buffer[0] = cSymbol;
+					for (j=1;;j++)
+					{
+						cTmp = pattern[i+j];
+						if ((cTmp>='A' && cTmp<='Z') || (cTmp>='a' && cTmp<='z') || 
+							cTmp=='\'' || cTmp=='"' )
+						{
+							i=i+j;
+							buffer[j]= '\0';
+							break;
+						}
+						else
+							buffer[j] = cTmp;
+					}
+										
+					pDateStyle->AddText(OUString(buffer));//keep for all parsed
+				}				
+				break;
+			}
+		}
+	}
+//	udat_close(fmt);
+	return pDateStyle;
+}
+/**
+ * @descr	get the system time format
+*/
+XFTimeStyle* LwpTools::GetSystemTimeStyle()
+{
+/*	::com::sun::star::lang::Locale aLocale=Application::GetSettings().GetLocale();
+	rtl::OUString strLang = aLocale.Language;
+	rtl::OUString strCountry = aLocale.Country;
+	strLang = strLang + A2OUSTR("_");
+	rtl::OUString strLocale = strLang + strCountry;	
+	
+	int32_t nLength = 0;
+	int32_t nLengthNeed;
+	UErrorCode status = U_ZERO_ERROR;
+	UChar* pattern = NULL;
+	
+	UDateFormat* fmt= udat_open(UDAT_FULL, UDAT_FULL, 
+		(char*)(OUStringToOString(strLocale,RTL_TEXTENCODING_MS_1252).getStr()), NULL, 0, NULL, 0, &status);
+	
+	nLengthNeed = udat_toPattern(fmt,true,NULL,nLength,&status);
+	if (status == U_BUFFER_OVERFLOW_ERROR)
+	{
+		status = U_ZERO_ERROR;
+		nLength = nLengthNeed +1;
+		pattern = (UChar*)malloc(sizeof(UChar)*nLength);
+		udat_toPattern(fmt,true,pattern,nLength,&status);
+	}
+*/
+	//1 get locale for system
+	::com::sun::star::lang::Locale aLocale=Application::GetSettings().GetLocale();
+	rtl::OUString strLang = aLocale.Language;
+	rtl::OUString strCountry = aLocale.Country;
+	icu::Locale bLocale((char*)(OUStringToOString(strLang,RTL_TEXTENCODING_MS_1252).getStr()),
+		(char*)(OUStringToOString(strCountry,RTL_TEXTENCODING_MS_1252).getStr()));	
+	
+	icu::DateFormat* fmt = icu::DateFormat::createTimeInstance(icu::DateFormat::DEFAULT,bLocale);
+	//2 get icu format pattern by locale
+	int32_t nLength = 0;
+	int32_t nLengthNeed;
+	UErrorCode status = U_ZERO_ERROR;
+	UChar* pattern = NULL;
+	nLengthNeed = udat_toPattern((void *const *)fmt,false,NULL,nLength,&status);
+	if (status == U_BUFFER_OVERFLOW_ERROR)
+	{
+		status = U_ZERO_ERROR;
+		nLength = nLengthNeed +1;
+		pattern = (UChar*)malloc(sizeof(UChar)*nLength);
+		udat_toPattern((void *const *)fmt,false,pattern,nLength,&status);
+	}
+
+	if (pattern == NULL)
+		return NULL;
+	// 3 parse pattern string,per icu date/time format syntax, there are 20 letters reserved
+	// as patter letter,each represent a element in date/time and its repeat numbers represent 
+	// different format: for exampel: M produces '1',MM produces '01', MMM produces 'Jan', MMMM produces 'Januaray'
+	// letter other than these letters is regard as text in the format, for example ','in 'Jan,2005'
+	// we parse pattern string letter by letter and get the time format.
+	// for time format ,for there is not date info,we can only parse the letter representing time.	
+	UChar cSymbol;
+	UChar cTmp;	
+	XFTimeStyle* pTimeStyle = new XFTimeStyle;
+	
+	for (int32_t i=0;i<nLengthNeed;)
+	{
+		cSymbol = pattern[i];
+		int32_t j;
+		switch(cSymbol)
+		{
+			case 'h':
+			{
+				for (j=1;;j++)
+				{
+					cTmp = pattern[i+j];
+					if (cTmp != cSymbol)
+					{
+						i=i+j;
+						break;
+					}
+				}
+				if (j==1)
+					pTimeStyle->AddHour(sal_False);	
+				else 
+					pTimeStyle->AddHour();	
+				break;
+			}
+			case 'H':
+			{
+				for (j=1;;j++)
+				{
+					cTmp = pattern[i+j];
+					if (cTmp != cSymbol)
+					{
+						i=i+j;
+						break;
+					}
+				}
+				if (j==1)
+					pTimeStyle->AddHour(sal_False);	
+				else 
+					pTimeStyle->AddHour();	
+				break;				
+			}
+			case 'm':
+			{
+				for (j=1;;j++)
+				{
+					cTmp = pattern[i+j];
+					if (cTmp != cSymbol)
+					{
+						i=i+j;
+						break;
+					}
+				}
+				if (j==1)
+					pTimeStyle->AddMinute(sal_False);	
+				else 
+					pTimeStyle->AddMinute();	
+				break;				
+			}
+			case 's':
+			{
+				for (j=1;;j++)
+				{
+					cTmp = pattern[i+j];
+					if (cTmp != cSymbol)
+					{
+						i=i+j;
+						break;
+					}
+				}
+				if (j==1)
+					pTimeStyle->AddSecond(sal_False,0);	
+				else 
+					pTimeStyle->AddSecond(sal_True,0);	
+				break;				
+			}
+			case 'S':
+			{
+				for (j=1;;j++)
+				{
+					cTmp = pattern[i+j];
+					if (cTmp != cSymbol)
+					{
+						i=i+j;
+						break;
+					}
+				}
+				/*if (j==1)
+					pDateStyle->AddSecond(sal_False);	
+				else 
+					pDateStyle->AddSecond();*/	
+				break;				
+			}
+			case 'a':
+			{
+				for (j=1;;j++)
+				{
+					cTmp = pattern[i+j];
+					if (cTmp != cSymbol)
+					{
+						i=i+j;
+						break;
+					}
+				}
+				pTimeStyle->SetAmPm(sal_True);	
+				break;
+			}
+			case 'k':
+			{
+				for (j=1;;j++)
+				{
+					cTmp = pattern[i+j];
+					if (cTmp != cSymbol)
+					{
+						i=i+j;
+						break;
+					}
+				}	
+				break;
+			}
+			case 'K':
+			{
+				for (j=1;;j++)
+				{
+					cTmp = pattern[i+j];
+					if (cTmp != cSymbol)
+					{
+						i=i+j;
+						break;
+					}
+				}
+				if (j==1)
+					pTimeStyle->AddHour(sal_False);
+				else
+					pTimeStyle->AddHour();						
+				break;
+			}
+			case '\''://'
+			{
+				for (j=1;;j++)
+				{
+					cTmp = pattern[i+j];
+					if (cTmp != cSymbol)
+					{
+						i=i+j;
+						break;
+					}
+				}	
+				break;	
+			}
+			case '"':
+			{
+				pTimeStyle->AddText(OUString(A2OUSTR("'")));
+				break;
+			}
+			default:
+			{
+				if ((cSymbol>='A' && cSymbol<='Z') || (cSymbol>='a' && cSymbol<='z') )
+					return NULL;
+				else//TEXT
+				{
+					sal_Unicode buffer[1024];
+					buffer[0] = cSymbol;
+					//strBuffer.append(cSymbol);
+					for (j=1;;j++)
+					{
+						cTmp = pattern[i+j];
+						if ((cTmp>='A' && cTmp<='Z') || (cTmp>='a' && cTmp<='z') || 
+							cTmp=='\'' || cTmp=='"' )
+						{
+							i=i+j;
+							buffer[j]= '\0';
+							break;
+						}
+						else
+							buffer[j] = cTmp;
+					}					
+					pTimeStyle->AddText(OUString(buffer));//keep for all parsed
+				}				
+				break;
+			}
+		}
+	}	
+//	udat_close(fmt);
+	return pTimeStyle;
+}
+
diff -urNp lotuswordpro.bak/source/filter/lwptools.hxx lotuswordpro/source/filter/lwptools.hxx
--- lotuswordpro.bak/source/filter/lwptools.hxx	1970-01-01 08:00:00.000000000 +0800
+++ lotuswordpro/source/filter/lwptools.hxx	2008-10-22 11:42:29.000000000 +0800
@@ -0,0 +1,149 @@
+/*************************************************************************
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: IBM Corporation
+ *
+ *  Copyright: 2008 by IBM Corporation
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+/*************************************************************************
+ * @file 
+ *  to provide basic utilities for word pro filter
+ ************************************************************************/
+/*************************************************************************
+ * Change History
+ Jan 2005			Created
+ ************************************************************************/
+
+#ifndef _LWPTOOLS_HXX
+#define _LWPTOOLS_HXX
+
+#include "lwpheader.hxx"
+#include "lwpobjstrm.hxx"
+#include "localtime.hxx"
+#include "xfilter/xfdatestyle.hxx"
+#include "xfilter/xftimestyle.hxx"
+#include <rtl/textenc.h>
+
+// 01/19/2005
+const sal_uInt32 UNITS_PER_INCH = 65536L * 72L;
+const double CM_PER_INCH = 2.54;
+const double INCHT_PER_CM = (1.0 / CM_PER_INCH);
+//end
+
+const double POINTS_PER_INCH = 72.27;
+const double TWIPS_PER_POINT = 20.0;
+const double TWIPS_PER_INCH = (TWIPS_PER_POINT * POINTS_PER_INCH);
+const double TWIPS_PER_CM = (TWIPS_PER_INCH/CM_PER_INCH);
+/**
+ * @brief	tool class (unicode, conversion) for lwp filter.
+*/
+class LwpTools
+{
+
+public:
+	static sal_uInt16 QuickReadUnicode( LwpObjectStream* pObjStrm, 
+		OUString& str, sal_uInt16 strlen,  rtl_TextEncoding aEncoding );
+	static BOOL IsUnicodePacked(LwpObjectStream* pObjStrm, sal_uInt16 len);
+
+	// 01/19/2005
+	inline static double ConvertFromUnits(const sal_Int32& nUnits);
+	inline static double ConvertToMetric(const double& fInch);
+	inline static double ConvertFromMetric(const double& fCM);
+	inline static double ConvertFromUnitsToMetric(const sal_Int32& nUnits);
+	//end
+	
+	//add by , 03/11/2005
+	inline static sal_Int32 ConvertToUnits(const double& fInch);
+	//add end
+
+	//, 02/23/2005
+	inline static sal_Bool IsOddNumber(sal_uInt16& nNumber);
+	inline static sal_Bool IsEvenNumber(sal_uInt16& nNumber);
+
+	static sal_Bool isFileUrl(const OString& fileName);
+	static OUString convertToFileUrl(const OString& fileName);
+	static rtl::OUString	DateTimeToOUString(LtTm& dt);
+	
+	//add by ,2005/6/1
+	static XFDateStyle* GetSystemDateStyle(sal_Bool bLongFormat);
+	static XFTimeStyle* GetSystemTimeStyle();	
+};
+
+inline double LwpTools::ConvertFromUnits(const sal_Int32& nUnits)
+{
+	return (double)nUnits/UNITS_PER_INCH;
+}
+inline double LwpTools::ConvertToMetric(const double& fInch)
+{
+	return fInch*CM_PER_INCH; 
+}
+inline double LwpTools::ConvertFromMetric(const double& fCM)
+{
+	return fCM/CM_PER_INCH;
+}
+inline double LwpTools::ConvertFromUnitsToMetric(const sal_Int32& nUnits)
+{
+	double fInch = ConvertFromUnits(nUnits);
+	return ConvertToMetric(fInch);
+}
+inline sal_Int32 LwpTools::ConvertToUnits(const double& fInch)
+{
+	return (sal_Int32)fInch*UNITS_PER_INCH;
+}
+inline sal_Bool LwpTools::IsOddNumber(sal_uInt16& nNumber)
+{
+	return nNumber%2? sal_True : sal_False;
+}
+inline sal_Bool LwpTools::IsEvenNumber(sal_uInt16& nNumber)
+{
+	return nNumber%2? sal_False : sal_True;
+}
+
+#endif
diff -urNp lotuswordpro.bak/source/filter/lwpuidoc.cxx lotuswordpro/source/filter/lwpuidoc.cxx
--- lotuswordpro.bak/source/filter/lwpuidoc.cxx	1970-01-01 08:00:00.000000000 +0800
+++ lotuswordpro/source/filter/lwpuidoc.cxx	2008-10-22 11:42:29.000000000 +0800
@@ -0,0 +1,140 @@
+/*************************************************************************
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: IBM Corporation
+ *
+ *  Copyright: 2008 by IBM Corporation
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+/*************************************************************************
+ * @file 
+ *  For LWP filter architecture prototype
+ ************************************************************************/
+/*************************************************************************
+ * Change History
+ Jan 2005			Created
+ ************************************************************************/
+
+#include "lwpuidoc.hxx"
+
+LwpUIDocument::LwpUIDocument()
+	: m_nFlags(DOC_LOCKED)
+{}
+
+
+LwpUIDocument::LwpUIDocument(LwpObjectStream *pStrm)
+	: m_nFlags(DOC_LOCKED)
+{
+	Read(pStrm);
+}
+
+LwpUIDocument::~LwpUIDocument()
+{};
+	
+void LwpUIDocument::Read(LwpObjectStream *pStrm)
+{
+	m_NamedProps.Read(pStrm);
+	m_ARMacroOpts.Read(pStrm);
+	m_MergedOpts.Read(pStrm);
+	m_SheetFullPath.ReadPathAtom(pStrm);
+
+	sal_uInt16 saved_flags;
+	pStrm->QuickRead(&saved_flags, sizeof(saved_flags));
+	m_nFlags  |= saved_flags;
+	
+	if(pStrm->CheckExtra())
+	{
+		m_InitialSaveAsType.Read(pStrm);
+		pStrm->SkipExtra();
+	}
+}
+/**
+ * @descr		Read macro options from object stream
+ **/
+void LwpNamedProperties::Read(LwpObjectStream *pStrm)
+{
+	sal_uInt16 numEntries;
+	pStrm->QuickRead(&numEntries, sizeof(numEntries));
+	
+	for (sal_uInt16 k = 0 ; k < numEntries; k++)
+	{
+		assert(false);
+		// TODO: Read each NamedProperties
+	}	
+	pStrm->SkipExtra();
+}
+/**
+ * @descr		Read macro options from object stream
+ **/
+void LwpAutoRunMacroOptions::Read(LwpObjectStream *pStrm)
+{
+	m_OpenName.ReadPathAtom(pStrm);
+	m_CloseName.ReadPathAtom(pStrm);
+	m_NewName.ReadPathAtom(pStrm);
+	pStrm->QuickRead(&m_OptionFlag, sizeof(m_OptionFlag));
+	pStrm->SkipExtra();
+}
+/**
+ * @descr		Read merge options from object stream
+ **/
+void LwpMergeOptions::Read(LwpObjectStream *pStrm)
+{
+	m_RecordFile.ReadPathAtom(pStrm);
+	m_DescriptionFile.ReadPathAtom(pStrm);
+	m_Filter.Read(pStrm);
+	pStrm->QuickRead(&m_nType, sizeof(m_nType));
+
+	//Does not process m_nType here. Assume m_nType is 0.
+	// TODO: Read the CMergeDataFile
+	assert(m_nType==0);
+
+	pStrm->QuickRead(&m_nLastActionFlag, sizeof(m_nLastActionFlag));
+	pStrm->SkipExtra();		
+}
+
diff -urNp lotuswordpro.bak/source/filter/lwpuidoc.hxx lotuswordpro/source/filter/lwpuidoc.hxx
--- lotuswordpro.bak/source/filter/lwpuidoc.hxx	1970-01-01 08:00:00.000000000 +0800
+++ lotuswordpro/source/filter/lwpuidoc.hxx	2008-10-22 11:42:29.000000000 +0800
@@ -0,0 +1,154 @@
+/*************************************************************************
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: IBM Corporation
+ *
+ *  Copyright: 2008 by IBM Corporation
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+/*************************************************************************
+ * @file 
+ *  all classes for LwpUIDocument
+ ************************************************************************/
+/*************************************************************************
+ * Change History
+ Jan 2005			Created
+ ************************************************************************/
+#ifndef _LWPUIDOCUMENT_HXX
+#define _LWPUIDOCUMENT_HXX
+
+#include "lwpheader.hxx"
+#include "lwpdefs.hxx"
+
+class LwpNamedProperties;
+class LwpAutoRunMacroOptions;
+class LwpMergeOptions;
+
+#include "lwpobjstrm.hxx"
+#include "lwpatomholder.hxx"
+/**
+ * @brief		Properties in UIDocument structure
+ *			not parsed yet
+*/
+class LwpNamedProperties
+{
+public:
+	LwpNamedProperties(){};
+	~LwpNamedProperties(){};
+public:
+	void Read(LwpObjectStream *pStrm);
+};
+/**
+ * @brief		macro options contained in UIDocument structure
+ *			not parsed yet
+*/
+class LwpAutoRunMacroOptions
+{
+public:
+	LwpAutoRunMacroOptions(){};
+	~LwpAutoRunMacroOptions(){};
+private:
+	LwpAtomHolder m_OpenName;
+	LwpAtomHolder m_CloseName;
+	LwpAtomHolder m_NewName;
+	sal_uInt16 m_OptionFlag;
+public:
+	void Read(LwpObjectStream *pStrm);
+};
+/**
+ * @brief		Merget options contained in UIDocument structure
+ *			not parsed yet
+*/
+class LwpMergeOptions
+{
+public:
+	LwpMergeOptions(){};
+	~LwpMergeOptions(){};
+private:
+	LwpAtomHolder m_RecordFile;
+	LwpAtomHolder m_DescriptionFile;
+	LwpAtomHolder m_Filter;
+	sal_uInt16 m_nType;
+	sal_uInt16 m_nLastActionFlag;	// flag remembers last merge action
+public:
+	void Read(LwpObjectStream *pStrm);	
+};
+/**
+ * @brief		UIDocument structure contained in VO_DOCUMENT
+ *			not parsed yet
+*/
+class LwpUIDocument
+{
+public:
+	LwpUIDocument();
+	LwpUIDocument(LwpObjectStream *pStrm);
+	~LwpUIDocument();
+private:
+	LwpNamedProperties m_NamedProps;
+	LwpAutoRunMacroOptions m_ARMacroOpts;
+	LwpMergeOptions m_MergedOpts;
+	LwpAtomHolder m_SheetFullPath;	// full path for style sheet	
+	sal_uInt16 m_nFlags;
+	LwpAtomHolder m_InitialSaveAsType;
+	enum
+	{
+		DOC_READONLY	= 0x01,
+		DOC_BLOCKSETS	= 0x02,
+		DOC_LOCKED = 0x04,
+		DOC_ENVELOPE = 0x08,
+		DOC_EXTERNALFILE = 0x10,
+		DOC_SANITYCHECK = 0x20,
+		DOC_ANNOTATEONLY = 0x40,
+		DOC_CANCELED = 0x80
+	};
+public:
+	void Read(LwpObjectStream *pStrm);
+};
+
+#endif
diff -urNp lotuswordpro.bak/source/filter/lwpunoheader.hxx lotuswordpro/source/filter/lwpunoheader.hxx
--- lotuswordpro.bak/source/filter/lwpunoheader.hxx	1970-01-01 08:00:00.000000000 +0800
+++ lotuswordpro/source/filter/lwpunoheader.hxx	2008-10-22 11:42:29.000000000 +0800
@@ -0,0 +1,85 @@
+/*************************************************************************
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: IBM Corporation
+ *
+ *  Copyright: 2008 by IBM Corporation
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+/*************************************************************************
+ * @file 
+ *  For LWP filter
+ ************************************************************************/
+/*************************************************************************
+ * Change History
+ Jan 2005			Created
+ ************************************************************************/
+
+#include	<cppuhelper/implbase1.hxx>
+#include	<cppuhelper/implbase3.hxx>
+#include	<cppuhelper/factory.hxx>
+#include	<com/sun/star/document/XFilter.hpp>
+#include	<com/sun/star/document/XImporter.hpp>
+#include	<com/sun/star/xml/sax/XDocumentHandler.hpp>
+#include	<com/sun/star/lang/XServiceInfo.hpp>
+#include <com/sun/star/io/XInputStream.hpp>
+#include <com/sun/star/io/XSeekable.hpp>
+
+#include "xfilter/xfglobal.hxx"
+
+using namespace ::rtl;
+using namespace ::cppu;
+using namespace ::com::sun::star::lang;
+using namespace ::com::sun::star::io;
+using namespace ::com::sun::star::registry;
+using namespace ::com::sun::star::document;
+using namespace ::com::sun::star::beans;
+using namespace ::com::sun::star::xml::sax;
+using namespace ::com::sun::star::uno;
+
diff -urNp lotuswordpro.bak/source/filter/lwpusewhen.hxx lotuswordpro/source/filter/lwpusewhen.hxx
--- lotuswordpro.bak/source/filter/lwpusewhen.hxx	1970-01-01 08:00:00.000000000 +0800
+++ lotuswordpro/source/filter/lwpusewhen.hxx	2008-10-22 11:42:29.000000000 +0800
@@ -0,0 +1,176 @@
+/*************************************************************************
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: IBM Corporation
+ *
+ *  Copyright: 2008 by IBM Corporation
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+/*************************************************************************
+ * @file 
+ *  For LWP filter architecture prototype
+ ************************************************************************/
+/*************************************************************************
+ * Change History
+ Jan 2005			Created
+ ************************************************************************/
+ 
+#ifndef _LWPUSEWHEN_HXX
+#define _LWPUSEWHEN_HXX
+
+#include "lwpheader.hxx"
+
+#define STYLE_USEONALLPAGES		0x0001U	/* repeat on all pages */
+#define STYLE_USEONALLEVENPAGES	0x0002U	/* repeat on all even pages */
+#define STYLE_USEONALLODDPAGES	0x0004U	/* repeat on all odd pages */
+#define STYLE_USEONTHISPAGE		0x0008U	/* use this guy on this page */
+#define STYLE_USEEXCEPTTHISPAGE	0x0010U	/* use guy except on this page */
+#define STYLE_USESTARTINGONPAGE	0x0020U	/* use starting on page n */
+#define STYLE_USEONMASK			(STYLE_USEONALLPAGES | \
+									STYLE_USEONALLEVENPAGES | \
+									STYLE_USEONALLODDPAGES | \
+									STYLE_USEONTHISPAGE | \
+									STYLE_USEEXCEPTTHISPAGE | \
+									STYLE_USESTARTINGONPAGE)
+
+#define STYLE_STARTONNEXTPAGE	0x0000U	// This is the default
+#define STYLE_STARTONTHISPAGE	0x0040U
+#define STYLE_STARTONNEXTODD	0x0080U
+#define STYLE_STARTONNEXTEVEN	0x0100U
+#define STYLE_STARTONTHISHF		0x0200U
+#define STYLE_STARTONMASK		(STYLE_STARTONTHISPAGE | \
+									STYLE_STARTONNEXTODD | \
+									STYLE_STARTONNEXTEVEN | \
+									STYLE_STARTONTHISHF)
+class LwpUseWhen
+{
+public:
+	LwpUseWhen() : m_nFlags(0), m_nUsePage(0) {}
+
+	inline void Read(LwpObjectStream* pStrm);
+
+	inline sal_Bool IsUseOnAllPages();
+
+	inline sal_Bool IsUseOnAllEvenPages();
+
+	inline sal_Bool IsUseOnAllOddPages();
+
+	inline sal_Bool IsUseOnPage();
+
+	inline sal_Bool IsStartOnThisPage();
+
+	inline sal_Bool IsStartOnNextPage();
+
+	inline sal_Bool IsStartOnNextEvenPage();
+
+	inline sal_Bool IsStartOnNextOddPage();
+
+	inline sal_Bool IsStartOnThisHF();
+
+	inline sal_uInt16 GetUsePage();
+private:
+	sal_uInt16	m_nFlags;
+	sal_uInt16	m_nUsePage;
+};
+
+inline void LwpUseWhen::Read(LwpObjectStream* pStrm)
+{
+	pStrm->QuickRead(&m_nFlags, 2);
+	pStrm->QuickRead(&m_nUsePage, 2);
+	pStrm->SkipExtra();
+}
+inline sal_Bool LwpUseWhen::IsUseOnAllPages()
+{
+	return (sal_Bool)((m_nFlags & STYLE_USEONALLPAGES) != 0);
+}
+inline sal_Bool LwpUseWhen::IsUseOnAllEvenPages()
+{
+	return (sal_Bool)((m_nFlags & STYLE_USEONALLEVENPAGES) != 0);
+}
+inline sal_Bool LwpUseWhen::IsUseOnAllOddPages()
+{
+	return (sal_Bool)((m_nFlags & STYLE_USEONALLODDPAGES) != 0);
+}
+
+inline sal_Bool LwpUseWhen::IsUseOnPage()
+{
+	return (sal_Bool)((m_nFlags & STYLE_USEONTHISPAGE) != 0);
+}
+
+inline sal_Bool LwpUseWhen::IsStartOnThisPage()
+{
+	return (sal_Bool)((m_nFlags & STYLE_STARTONTHISPAGE) != 0);
+}
+
+inline sal_Bool LwpUseWhen::IsStartOnNextPage()
+{
+	return (sal_Bool)((m_nFlags & STYLE_STARTONMASK) == 0);
+}
+
+inline sal_Bool LwpUseWhen::IsStartOnNextOddPage()
+{
+	return (sal_Bool)((m_nFlags & STYLE_STARTONNEXTODD) != 0);
+}
+
+inline sal_Bool LwpUseWhen::IsStartOnNextEvenPage()
+{
+	return (sal_Bool)((m_nFlags & STYLE_STARTONNEXTEVEN) != 0);
+}
+
+inline sal_Bool LwpUseWhen::IsStartOnThisHF()
+{
+	return (sal_Bool)((m_nFlags & STYLE_STARTONTHISHF) != 0);
+}
+
+inline sal_uInt16 LwpUseWhen::GetUsePage()
+{
+	return m_nUsePage;
+}
+
+#endif
diff -urNp lotuswordpro.bak/source/filter/lwpusrdicts.cxx lotuswordpro/source/filter/lwpusrdicts.cxx
--- lotuswordpro.bak/source/filter/lwpusrdicts.cxx	1970-01-01 08:00:00.000000000 +0800
+++ lotuswordpro/source/filter/lwpusrdicts.cxx	2008-10-22 11:42:29.000000000 +0800
@@ -0,0 +1,86 @@
+/*************************************************************************
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: IBM Corporation
+ *
+ *  Copyright: 2008 by IBM Corporation
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+/*************************************************************************
+ * @file 
+ *  For LWP filter architecture prototype
+ ************************************************************************/
+/*************************************************************************
+ * Change History
+ Jan 2005			Created
+ ************************************************************************/
+
+#include "lwpusrdicts.hxx"
+#include "lwpatomholder.hxx"
+LwpUserDictFiles::LwpUserDictFiles(LwpObjectStream *pStrm)
+{
+	Read(pStrm);
+}
+/**
+ * @descr		Read UserDictFiles in VO_DOCUMENT
+ *			words are skipped, not parsed yet
+ **/
+void LwpUserDictFiles::Read(LwpObjectStream *pStrm)
+{
+	sal_uInt16 cnt;
+	pStrm->QuickRead(&cnt, sizeof(cnt));
+	LwpAtomHolder word; 
+	while(cnt--)
+	{
+		word.Read(pStrm);
+		pStrm->SkipExtra();
+	}
+	pStrm->SkipExtra();
+}
+
diff -urNp lotuswordpro.bak/source/filter/lwpusrdicts.hxx lotuswordpro/source/filter/lwpusrdicts.hxx
--- lotuswordpro.bak/source/filter/lwpusrdicts.hxx	1970-01-01 08:00:00.000000000 +0800
+++ lotuswordpro/source/filter/lwpusrdicts.hxx	2008-10-22 11:42:29.000000000 +0800
@@ -0,0 +1,80 @@
+/*************************************************************************
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: IBM Corporation
+ *
+ *  Copyright: 2008 by IBM Corporation
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+/*************************************************************************
+ * @file 
+ *  For LWP filter architecture prototype
+ ************************************************************************/
+/*************************************************************************
+ * Change History
+ Jan 2005			Created
+ ************************************************************************/
+
+#ifndef _LWPUSERDICTFILES_HXX
+#define _LWPUSERDICTFILES_HXX
+
+#include "lwpheader.hxx"
+#include "lwpobjstrm.hxx"
+/**
+ * @brief	User defined words used in VO_DOCUMENT
+*/
+class LwpUserDictFiles
+{
+public:
+	LwpUserDictFiles(){};
+	LwpUserDictFiles(LwpObjectStream *pStrm);
+	~LwpUserDictFiles(){};
+	void Read(LwpObjectStream *pStrm);
+};
+#endif
diff -urNp lotuswordpro.bak/source/filter/lwpverdocument.cxx lotuswordpro/source/filter/lwpverdocument.cxx
--- lotuswordpro.bak/source/filter/lwpverdocument.cxx	1970-01-01 08:00:00.000000000 +0800
+++ lotuswordpro/source/filter/lwpverdocument.cxx	2008-10-22 11:42:29.000000000 +0800
@@ -0,0 +1,109 @@
+/*************************************************************************
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: IBM Corporation
+ *
+ *  Copyright: 2008 by IBM Corporation
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+/*************************************************************************
+ * @file 
+ *  Versioned Pointer object, used for VO_VEGTR and VO_QTR
+ * Does not find the difference between CVersionedQointer and 
+ * CVersionedGointer, so use one class
+ ************************************************************************/
+/*************************************************************************
+ * Change History
+Jun 2005		Created
+ ************************************************************************/
+#include "lwpglobalmgr.hxx"
+#include "lwpverdocument.hxx"
+#include "lwplnopts.hxx"
+#include "lwpproplist.hxx"
+#include "xfilter/xfparastyle.hxx"
+#include "lwptools.hxx"
+
+LwpVerDocument::LwpVerDocument(LwpObjectHeader& objHdr, LwpSvStream* pStrm)
+	: LwpObject(objHdr, pStrm)
+{}
+
+void LwpVerDocument::Read()
+{
+	m_nTabSpacing = m_pObjStrm->QuickReaduInt32();
+
+	if (m_pObjStrm->CheckExtra())
+	{
+		LwpLineNumberOptions aLineNumberOptions(m_pObjStrm);		
+
+		if (m_pObjStrm->CheckExtra())
+		{
+			LwpPropList aPropList;
+			aPropList.Read(m_pObjStrm);
+			m_pObjStrm->SkipExtra();
+		}
+	}
+}
+
+void LwpVerDocument::RegisterStyle()
+{
+	XFDefaultParaStyle* pDefault = new XFDefaultParaStyle;
+	double len =(double) m_nTabSpacing/UNITS_PER_INCH*CM_PER_INCH;
+	if(len < 0.001)
+	{
+		len = 1.27; //0.5 inch
+	}
+	pDefault->SetTabDistance(len);
+	XFStyleManager* pXFStyleManager = LwpGlobalMgr::GetInstance()->GetXFStyleManager(); 
+	pXFStyleManager->AddStyle(pDefault);
+}
+
+sal_uInt32 LwpVerDocument::GetTabSpacing()
+{
+	return m_nTabSpacing;
+}
diff -urNp lotuswordpro.bak/source/filter/lwpverdocument.hxx lotuswordpro/source/filter/lwpverdocument.hxx
--- lotuswordpro.bak/source/filter/lwpverdocument.hxx	1970-01-01 08:00:00.000000000 +0800
+++ lotuswordpro/source/filter/lwpverdocument.hxx	2008-10-22 11:42:29.000000000 +0800
@@ -0,0 +1,86 @@
+/*************************************************************************
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: IBM Corporation
+ *
+ *  Copyright: 2008 by IBM Corporation
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+/*************************************************************************
+ * @file 
+ *  Versioned Pointer object, used for VO_VEGTR and VO_QTR
+ * Does not find the difference between CVersionedQointer and 
+ * CVersionedGointer, so use one class
+ ************************************************************************/
+/*************************************************************************
+ * Change History
+Jun 2005		Created
+ ************************************************************************/
+
+#ifndef _LWPVERDOCUMENT_HXX_
+#define _LWPVERDOCUMENT_HXX_
+
+#include "lwpobj.hxx"
+
+/*VO_VERDOCUMENT*/
+
+class LwpVerDocument : public LwpObject
+{
+public:
+	LwpVerDocument(LwpObjectHeader& objHdr, LwpSvStream* pStrm);
+	~LwpVerDocument(){};
+	void Read();	
+	virtual void RegisterStyle();
+	sal_uInt32 GetTabSpacing();
+private:
+	sal_uInt32 m_nTabSpacing;
+};
+#endif
+
+
diff -urNp lotuswordpro.bak/source/filter/lwpvpointer.cxx lotuswordpro/source/filter/lwpvpointer.cxx
--- lotuswordpro.bak/source/filter/lwpvpointer.cxx	1970-01-01 08:00:00.000000000 +0800
+++ lotuswordpro/source/filter/lwpvpointer.cxx	2008-10-22 11:42:29.000000000 +0800
@@ -0,0 +1,80 @@
+/*************************************************************************
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: IBM Corporation
+ *
+ *  Copyright: 2008 by IBM Corporation
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+#include "lwpvpointer.hxx"
+#include "lwpfilehdr.hxx"
+
+LwpVersionedPointer::LwpVersionedPointer(LwpObjectHeader& objHdr, LwpSvStream* pStrm)
+	: LwpObject(objHdr, pStrm)
+{}
+
+void LwpVersionedPointer::Read()
+{
+	m_PointerID.ReadIndexed(m_pObjStrm);
+	if( LwpFileHeader::m_nFileRevision < 0x0006 )
+		m_pObjStrm->SkipExtra();	
+}
+void LwpVersionedPointer::Parse(IXFStream* pOutputStream)
+{}
+
+void LwpVersionedPointer::RegisterStyle()
+{
+	LwpObject* pObj = m_PointerID.obj();
+	if( pObj )
+	{
+		pObj->SetFoundry(m_pFoundry);
+		pObj->RegisterStyle();
+	}
+}
+
diff -urNp lotuswordpro.bak/source/filter/lwpvpointer.hxx lotuswordpro/source/filter/lwpvpointer.hxx
--- lotuswordpro.bak/source/filter/lwpvpointer.hxx	1970-01-01 08:00:00.000000000 +0800
+++ lotuswordpro/source/filter/lwpvpointer.hxx	2008-10-22 11:42:29.000000000 +0800
@@ -0,0 +1,82 @@
+/*************************************************************************
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: IBM Corporation
+ *
+ *  Copyright: 2008 by IBM Corporation
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+/*************************************************************************
+ * @file 
+ *  Versioned Pointer object, used for VO_VEGTR and VO_QTR
+ * Does not find the difference between CVersionedQointer and 
+ * CVersionedGointer, so use one class
+ ************************************************************************/
+/*************************************************************************
+ * Change History
+March 2005			Created
+ ************************************************************************/
+
+#ifndef _LWPVERSIONEDPOINTER_HXX_
+#define _LWPVERSIONEDPOINTER_HXX_
+
+#include "lwpobj.hxx"
+class LwpVersionedPointer : public LwpObject
+{
+public:
+	LwpVersionedPointer(LwpObjectHeader& objHdr, LwpSvStream* pStrm);
+	~LwpVersionedPointer(){};
+	void Read();
+	void RegisterStyle();
+	void Parse(IXFStream* pOutputStream);
+	LwpObjectID* GetPointer(){return &m_PointerID;};
+protected:
+	LwpObjectID m_PointerID;
+};
+#endif
diff -urNp lotuswordpro.bak/source/filter/schxmlwrapper.cxx lotuswordpro/source/filter/schxmlwrapper.cxx
--- lotuswordpro.bak/source/filter/schxmlwrapper.cxx	1970-01-01 08:00:00.000000000 +0800
+++ lotuswordpro/source/filter/schxmlwrapper.cxx	2008-10-22 11:42:29.000000000 +0800
@@ -0,0 +1,489 @@
+/*************************************************************************
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: IBM Corporation
+ *
+ *  Copyright: 2008 by IBM Corporation
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+
+#ifndef _COM_SUN_STAR_BEANS_PROPERTYATTRIBUTE_HXX_
+#include <com/sun/star/beans/PropertyAttribute.hpp>
+#endif
+#ifndef _COM_SUN_STAR_TASK_XSTATUSINDICATORSUPPLIER_HPP_ 
+#include <com/sun/star/task/XStatusIndicatorSupplier.hpp>
+#endif
+#ifndef _COM_SUN_STAR_DOCUMENT_XIMPORTER_HPP_ 
+#include <com/sun/star/document/XImporter.hpp>
+#endif
+#ifndef _COM_SUN_STAR_DOCUMENT_XFILTER_HPP_ 
+#include <com/sun/star/document/XFilter.hpp>
+#endif
+#ifndef _COM_SUN_STAR_DOCUMENT_XExporter_HPP_ 
+#include <com/sun/star/document/XExporter.hpp>
+#endif
+
+#ifndef _SFXDOCFILE_HXX
+#include <sfx2/docfile.hxx>
+#endif
+#ifndef _SFXECODE_HXX
+#include <svtools/sfxecode.hxx>
+#endif
+
+#include "schxmlwrapper.hxx"
+
+#ifndef _UTL_STREAM_WRAPPER_HXX_
+#include <unotools/streamwrap.hxx>
+#endif
+#ifndef _XMLGRHLP_HXX
+#include <svx/xmlgrhlp.hxx>
+#endif
+#ifndef _TOOLS_DEBUG_HXX
+#include <tools/debug.hxx>
+#endif
+#ifndef _COMPHELPER_PROCESSFACTORY_HXX_
+#include <comphelper/processfactory.hxx>
+#endif
+
+#ifndef _COMPHELPER_GENERICPROPERTYSET_HXX_
+#include <comphelper/genericpropertyset.hxx>
+#endif
+#ifndef _COMPHELPER_PROPERTSETINFO_HXX_
+#include <comphelper/propertysetinfo.hxx>
+#endif
+
+#ifndef INCLUDED_SVTOOLS_SAVEOPT_HXX 
+#include <svtools/saveopt.hxx>
+#endif
+
+#ifndef _COM_SUN_STAR_XML_SAX_XERRORHANDLER_HPP_
+#include <com/sun/star/xml/sax/XErrorHandler.hpp>
+#endif
+#ifndef _COM_SUN_STAR_XML_SAX_XENTITYRESOLVER_HPP_
+#include <com/sun/star/xml/sax/XEntityResolver.hpp>
+#endif
+#ifndef _COM_SUN_STAR_XML_SAX_INPUTSOURCE_HPP_
+#include <com/sun/star/xml/sax/InputSource.hpp>
+#endif
+#ifndef _COM_SUN_STAR_XML_SAX_XDTDHANDLER_HPP_
+#include <com/sun/star/xml/sax/XDTDHandler.hpp>
+#endif
+#ifndef _COM_SUN_STAR_XML_SAX_XPARSER_HPP_
+#include <com/sun/star/xml/sax/XParser.hpp>
+#endif
+#ifndef _COM_SUN_STAR_IO_XACTIVEDATASOURCE_HPP_
+#include <com/sun/star/io/XActiveDataSource.hpp>
+#endif
+#ifndef _COM_SUN_STAR_IO_XACTIVEDATACONTROL_HPP_
+#include <com/sun/star/io/XActiveDataControl.hpp>
+#endif
+#ifndef _COM_SUN_STAR_LANG_XMULTISERVICEFACTORY_HPP_
+#include <com/sun/star/lang/XMultiServiceFactory.hpp>
+#endif
+#ifndef _COM_SUN_STAR_XML_SAX_SAXPARSEEXCEPTION_HPP_
+#include <com/sun/star/xml/sax/SAXParseException.hpp>
+#endif
+#ifndef _COM_SUN_STAR_PACKAGES_ZIP_ZIPIOEXCEPTION_HPP_
+#include <com/sun/star/packages/zip/ZipIOException.hpp>
+#endif
+
+#define XML_STRING(i, x) sal_Char __READONLY_DATA i[sizeof(x)] = x
+#define MAP_LEN(x) x, sizeof(x) - 1
+
+XML_STRING( sXML_metaStreamName, 		"meta.xml");
+XML_STRING( sXML_styleStreamName,		"styles.xml" );
+XML_STRING( sXML_contentStreamName,		"content.xml" );
+XML_STRING( sXML_oldContentStreamName,	"Content.xml" );
+
+XML_STRING( sXML_export_chart_meta_service, 		"com.sun.star.comp.Chart.XMLMetaExporter" );
+XML_STRING( sXML_export_chart_styles_service, 		"com.sun.star.comp.Chart.XMLStylesExporter" );
+XML_STRING( sXML_export_chart_content_service,		"com.sun.star.comp.Chart.XMLContentExporter" );
+XML_STRING( sXML_export_chart_old_content_service,	"com.sun.star.office.sax.exporter.Chart" );
+
+XML_STRING( sXML_export_chart_allinone_service, 		"com.sun.star.comp.Chart.XMLExporter" );
+
+
+
+XML_STRING( sXML_import_chart_meta_service, 		"com.sun.star.comp.Chart.XMLMetaImporter" );
+XML_STRING( sXML_import_chart_styles_service,		"com.sun.star.comp.Chart.XMLStylesImporter" );
+XML_STRING( sXML_import_chart_content_service,		"com.sun.star.comp.Chart.XMLContentImporter" );
+XML_STRING( sXML_import_chart_old_content_service,	"com.sun.star.office.sax.importer.Chart" );
+
+using namespace ::com::sun::star;
+using namespace ::rtl;
+using namespace comphelper;
+
+SchXMLWrapper::SchXMLWrapper( uno::Reference< frame::XModel >& xModel,
+							  SvStorage& rStorage,
+							  sal_Bool bShowProgress ) :
+		mxModel( xModel ),
+		mrStorage( rStorage ),
+		mbShowProgress( bShowProgress )
+{}
+
+
+sal_Int32 SchXMLWrapper::ImportStream( 
+	const ::rtl::OUString& rsStreamName,
+	const ::rtl::OUString& rsServiceName,
+	uno::Reference< xml::sax::XParser >& xParser,
+	uno::Reference< lang::XMultiServiceFactory >& xServiceFactory,
+	uno::Reference< document::XGraphicObjectResolver >& xGraphObjResolver )
+{
+	xml::sax::InputSource aParserInput;
+	SvStorageStreamRef rInpStream;
+	uno::Reference< io::XActiveDataSource > xSource;
+    sal_Bool bEncrypted = sal_False;
+
+    try
+	{
+		String sStreamName( rsStreamName );
+		if( ! mrStorage.IsStream( String( rsStreamName )))
+			return sal_False;
+
+		rInpStream = mrStorage.OpenStream( sStreamName, STREAM_READ | STREAM_NOCREATE );
+		if( ! rInpStream.Is())
+			return sal_False;
+
+        uno::Any aAny;
+        bEncrypted = rInpStream->GetProperty( ::rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "Encrypted" )), aAny )
+            && aAny.getValueType() == ::getBooleanCppuType()
+            && *(sal_Bool *)aAny.getValue();
+
+		aParserInput.aInputStream = rInpStream->GetXInputStream(); 
+
+		if( aParserInput.aInputStream.is() )
+		{
+			sal_Int32 nArgs = 0;
+			if( mxStatusIndicator.is())
+				nArgs++;
+			if( xGraphObjResolver.is())
+				nArgs++;
+
+			uno::Sequence< uno::Any > aArgs( nArgs );
+
+			nArgs = 0;
+			if( mxStatusIndicator.is())
+				aArgs[ nArgs++ ] <<= mxStatusIndicator;
+
+			if( xGraphObjResolver.is())
+				aArgs[ nArgs++ ] <<= xGraphObjResolver;
+			
+			uno::Reference< xml::sax::XDocumentHandler > xDocHandler(
+				xServiceFactory->createInstanceWithArguments( rsServiceName, aArgs ),
+				uno::UNO_QUERY );
+
+			if( xDocHandler.is() )
+			{
+				uno::Reference< document::XImporter > xImporter( xDocHandler, uno::UNO_QUERY );
+				uno::Reference< lang::XComponent > xComponent( mxModel, uno::UNO_QUERY ); 
+
+				if( xImporter.is() )
+				{
+					xImporter->setTargetDocument( xComponent );
+					xParser->setDocumentHandler( xDocHandler );
+
+					xParser->parseStream( aParserInput );
+				}
+			}
+		}
+	}
+	catch( xml::sax::SAXParseException&)
+    {
+        if( bEncrypted )
+            return ERRCODE_SFX_WRONGPASSWORD;
+        return ERRCODE_SFX_GENERAL;
+    }
+	catch( xml::sax::SAXException&)
+    {
+        if( bEncrypted )
+            return ERRCODE_SFX_WRONGPASSWORD;
+        return ERRCODE_SFX_GENERAL;
+    }
+  	catch( io::IOException&)
+    {
+        return ERRCODE_SFX_GENERAL;
+	}
+  	catch( packages::zip::ZipIOException& )
+    {
+        return ERRCODE_IO_BROKENPACKAGE;
+	}
+	catch( uno::Exception&)
+	{
+        return ERRCODE_SFX_GENERAL;
+	}
+
+	return 0;
+}
+
+sal_Int32 SchXMLWrapper::Import()
+{
+	sal_Int32 nWarning = 0;
+
+	if( !mxModel.is() )
+	{
+		DBG_ERROR("Got NO Model in XMLImport");
+		return sal_False;
+	}
+
+	uno::Reference<lang::XServiceInfo> xServiceInfo( mxModel, uno::UNO_QUERY );
+	
+	if( !xServiceInfo.is() || !xServiceInfo->supportsService( OUString( RTL_CONSTASCII_USTRINGPARAM( "com.sun.star.chart.ChartDocument" ) ) ) )
+	{
+		DBG_ERROR( "Model is no ChartDocument in XMLImport" );
+		return sal_False;
+	}
+
+	uno::Reference< lang::XMultiServiceFactory> xServiceFactory( ::comphelper::getProcessServiceFactory() );
+	
+	if( !xServiceFactory.is() )
+	{
+		DBG_ERROR( "XMLReader::Read: got no service manager" );
+		return sal_False;
+	}
+
+	// get the sax parser component
+	uno::Reference< xml::sax::XParser > xXMLParser(
+		xServiceFactory->createInstance( ::rtl::OUString::createFromAscii( "com.sun.star.xml.sax.Parser" )),
+		uno::UNO_QUERY );
+	
+	if( ! xXMLParser.is() )
+	{
+		DBG_ERROR( "com.sun.star.xml.sax.Parser service missing" );
+		return sal_False;
+	}
+
+	// create graphics resolver component
+	SvXMLGraphicHelper* pGraphicHelper = SvXMLGraphicHelper::Create( mrStorage, GRAPHICHELPER_MODE_READ );
+	uno::Reference< document::XGraphicObjectResolver > xGraphObjResolver = pGraphicHelper;
+
+	// import meta information
+	ImportStream(
+		::rtl::OUString::createFromAscii( sXML_metaStreamName ),
+		::rtl::OUString::createFromAscii( sXML_import_chart_meta_service ),
+		xXMLParser, xServiceFactory, xGraphObjResolver );
+
+	// import styles
+    ImportStream(
+		::rtl::OUString::createFromAscii( sXML_styleStreamName ),
+		::rtl::OUString::createFromAscii( sXML_import_chart_styles_service ),
+		xXMLParser, xServiceFactory, xGraphObjResolver );
+
+	// import content
+    nWarning = ImportStream(
+        ::rtl::OUString::createFromAscii( sXML_contentStreamName ),
+        ::rtl::OUString::createFromAscii( sXML_import_chart_content_service ),
+        xXMLParser, xServiceFactory, xGraphObjResolver );
+
+	// import of "content.xml" didn't work - try old "Content.xml" stream
+	if( nWarning != 0 )
+	{
+		nWarning = ImportStream(
+			::rtl::OUString::createFromAscii( sXML_oldContentStreamName ),
+			::rtl::OUString::createFromAscii( sXML_import_chart_old_content_service ),
+			xXMLParser, xServiceFactory, xGraphObjResolver );
+	}
+
+	// graphics resolver has to be destroyed this way!
+	SvXMLGraphicHelper::Destroy( pGraphicHelper );
+
+	return nWarning;
+}
+
+// -----------------------------------------------------------------------------
+
+sal_Bool SchXMLWrapper::ExportStream(
+	const ::rtl::OUString& rsStreamName,
+	const ::rtl::OUString& rsServiceName,
+	uno::Reference< io::XActiveDataSource >& xDataSource,
+	uno::Reference< lang::XMultiServiceFactory>& xServiceFactory,
+	uno::Sequence< uno::Any >& aArgs )
+{
+	sal_Bool bRet = sal_False;
+
+	try
+	{
+		// create output stream
+		SvStorageStreamRef rOutputStream( mrStorage.OpenStream(
+			String( rsStreamName ), STREAM_WRITE | STREAM_SHARE_DENYWRITE | STREAM_TRUNC ));
+
+		rtl::OUString sMIMEType( RTL_CONSTASCII_USTRINGPARAM( "text/xml" ) );
+		uno::Any aAny;
+		aAny <<= sMIMEType;
+		rOutputStream->SetProperty( ::rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "MediaType" )), aAny );
+
+        // "Encrypted" means "Encryptable". Has to be set for all but the meta stream (which doesn't exist in charts)
+        aAny <<= (sal_Bool)(sal_True);
+        rOutputStream->SetProperty( ::rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "Encrypted" )), aAny );
+
+		rOutputStream->SetBufferSize( 0x4000 );	   // 16*1024
+
+		if( xDataSource.is())
+			xDataSource->setOutputStream( new ::utl::OOutputStreamWrapper( *rOutputStream ));
+
+		uno::Reference< document::XFilter > xFilter(
+			xServiceFactory->createInstanceWithArguments( rsServiceName, aArgs ),
+			uno::UNO_QUERY );
+
+		if( xFilter.is())
+		{
+			uno::Reference< document::XExporter > xExporter( xFilter, uno::UNO_QUERY );
+			if( xExporter.is())
+			{
+				uno::Reference< lang::XComponent > xModelComponent( mxModel, uno::UNO_QUERY );
+				xExporter->setSourceDocument( xModelComponent );
+			}
+
+			// empty Descriptior (formerly FileName was given)
+			uno::Sequence< beans::PropertyValue > aEmptyDescriptor( 0 );
+			bRet = xFilter->filter( aEmptyDescriptor );
+
+			if( bRet && rOutputStream.Is())
+				rOutputStream->Commit();
+		}
+	}
+	catch( uno::Exception )
+	{
+	}
+
+	return bRet;
+}
+
+sal_Bool SchXMLWrapper::Export()
+{
+	sal_Bool bRet = sal_False;
+
+	try
+	{
+		if( !mxModel.is() )
+		{
+			DBG_ERROR("Got NO Model in XMLExport");
+			return sal_False;
+		}
+
+		uno::Reference< lang::XServiceInfo > xServiceInfo( mxModel, uno::UNO_QUERY );
+
+		if( ! xServiceInfo.is() || !xServiceInfo->supportsService(
+			OUString( RTL_CONSTASCII_USTRINGPARAM( "com.sun.star.chart.ChartDocument" ) ) ) )
+		{
+			DBG_ERROR( "Model is no ChartDocument in XMLExport" );
+			return sal_False;
+		}
+
+		uno::Reference< lang::XMultiServiceFactory> xServiceFactory( ::comphelper::getProcessServiceFactory() );
+	
+		if( !xServiceFactory.is() )
+		{
+			DBG_ERROR( "got no service manager" );
+			return sal_False;
+		}
+
+		uno::Reference< uno::XInterface > xWriter( xServiceFactory->createInstance(
+			OUString( RTL_CONSTASCII_USTRINGPARAM( "com.sun.star.xml.sax.Writer" ) ) ) );
+	
+		if( !xWriter.is() )
+		{
+			DBG_ERROR( "com.sun.star.xml.sax.Writer service missing" );
+			return sal_False;
+		}
+		uno::Reference<xml::sax::XDocumentHandler > xHandler( xWriter, uno::UNO_QUERY );
+		uno::Sequence< beans::PropertyValue > aEmptyDescriptor( 0 );
+
+
+		/** property map for export info set */
+		PropertyMapEntry aExportInfoMap[] =
+		{
+			{ MAP_LEN( "UsePrettyPrinting"),0, &::getBooleanCppuType(),				::com::sun::star::beans::PropertyAttribute::MAYBEVOID, 0},
+			{ NULL, 0, 0, NULL, 0, 0 }
+		};
+
+		uno::Reference< beans::XPropertySet > xInfoSet( GenericPropertySet_CreateInstance( new PropertySetInfo( aExportInfoMap ) ) );
+
+		SvtSaveOptions aSaveOpt;
+		OUString sUsePrettyPrinting(RTL_CONSTASCII_USTRINGPARAM("UsePrettyPrinting"));
+		sal_Bool bUsePrettyPrinting( aSaveOpt.IsPrettyPrinting() );
+		xInfoSet->setPropertyValue( sUsePrettyPrinting, uno::makeAny( bUsePrettyPrinting ) );
+
+
+		SvXMLGraphicHelper* pGraphicHelper = SvXMLGraphicHelper::Create( mrStorage, GRAPHICHELPER_MODE_WRITE, sal_False );
+		uno::Reference< document::XGraphicObjectResolver > xGraphObjResolver( pGraphicHelper );
+		uno::Reference< io::XActiveDataSource > xDataSource( xWriter, uno::UNO_QUERY );
+
+		sal_Int32 nArgs = 2;
+		if( mxStatusIndicator.is())
+			nArgs++;
+		if( xGraphObjResolver.is())
+			nArgs++;
+
+		uno::Sequence< uno::Any > aArgs( nArgs );
+
+		nArgs = 0;
+		aArgs[ nArgs++ ] <<= xHandler;
+		aArgs[ nArgs++ ] <<= xInfoSet;
+
+		if( mxStatusIndicator.is())
+			aArgs[ nArgs++ ] <<= mxStatusIndicator;
+		if( xGraphObjResolver.is())
+			aArgs[ nArgs++ ] <<= xGraphObjResolver;
+
+		//export to one stream
+		bRet = ExportStream(
+			::rtl::OUString::createFromAscii( sXML_contentStreamName ),
+			::rtl::OUString::createFromAscii( sXML_export_chart_allinone_service ),
+			xDataSource, xServiceFactory, aArgs );
+
+		// graphics resolver has to be destroyed this way!
+		SvXMLGraphicHelper::Destroy( pGraphicHelper );
+	}
+	catch( uno::Exception)
+	{
+	}
+
+	return bRet;
+}
+
diff -urNp lotuswordpro.bak/source/filter/schxmlwrapper.hxx lotuswordpro/source/filter/schxmlwrapper.hxx
--- lotuswordpro.bak/source/filter/schxmlwrapper.hxx	1970-01-01 08:00:00.000000000 +0800
+++ lotuswordpro/source/filter/schxmlwrapper.hxx	2008-10-22 11:42:29.000000000 +0800
@@ -0,0 +1,118 @@
+/*************************************************************************
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: IBM Corporation
+ *
+ *  Copyright: 2008 by IBM Corporation
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+
+#ifndef _SCH_XMLWRP_HXX_
+#define _SCH_XMLWRP_HXX_
+
+#ifndef _SVSTOR_HXX
+#include <so3/svstor.hxx>
+#endif
+
+namespace com { namespace sun { namespace star {
+	namespace xml {
+		namespace sax {
+			class XParser;
+		}
+	}
+	namespace document {
+		class XGraphicObjectResolver;
+	}
+	namespace frame {
+		class XModel;
+	}
+	namespace task {
+		class XStatusIndicator;
+	}
+	namespace lang {
+		class XMultiServiceFactory;
+	}
+    namespace io {
+        class XActiveDataSource;
+    }
+}}}
+
+class SchXMLWrapper
+{
+	::com::sun::star::uno::Reference< ::com::sun::star::frame::XModel > mxModel;
+	::com::sun::star::uno::Reference< ::com::sun::star::task::XStatusIndicator > mxStatusIndicator;
+	SvStorage& mrStorage;
+
+	sal_Bool mbIsDraw : 1;
+	sal_Bool mbShowProgress : 1;
+
+	sal_Int32 ImportStream(
+		const ::rtl::OUString& rsStreamName,
+		const ::rtl::OUString& rsServiceName,
+		::com::sun::star::uno::Reference< ::com::sun::star::xml::sax::XParser >& xParser,
+		::com::sun::star::uno::Reference< ::com::sun::star::lang::XMultiServiceFactory>& xServiceFactory,
+		::com::sun::star::uno::Reference< ::com::sun::star::document::XGraphicObjectResolver >& xGraphObjResolver );
+
+	sal_Bool ExportStream(
+		const ::rtl::OUString& rsStreamName,
+		const ::rtl::OUString& rsServiceName,
+		::com::sun::star::uno::Reference< ::com::sun::star::io::XActiveDataSource >& xDataSource,
+		::com::sun::star::uno::Reference< ::com::sun::star::lang::XMultiServiceFactory>& xServiceFactory,
+		::com::sun::star::uno::Sequence< ::com::sun::star::uno::Any >& aArgs );
+
+public:
+	SchXMLWrapper( ::com::sun::star::uno::Reference< com::sun::star::frame::XModel >& xModel,
+				   SvStorage& rStorage,
+				   sal_Bool bShowProgress = TRUE );
+
+	sal_Int32 Import();
+	sal_Bool Export();
+};
+
+#endif	// _SCH_XMLWRP_HXX_
diff -urNp lotuswordpro.bak/source/filter/tocread.cxx lotuswordpro/source/filter/tocread.cxx
--- lotuswordpro.bak/source/filter/tocread.cxx	1970-01-01 08:00:00.000000000 +0800
+++ lotuswordpro/source/filter/tocread.cxx	2008-10-22 11:42:29.000000000 +0800
@@ -0,0 +1,516 @@
+/*************************************************************************
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: IBM Corporation
+ *
+ *  Copyright: 2008 by IBM Corporation
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+#include "first.hxx"
+#include "assert.h"
+namespace OpenStormBento
+{
+
+BenError
+CBenTOCReader::ReadLabelAndTOC()
+{
+	BenError Err;
+
+	unsigned long TOCOffset;
+	if ((Err = ReadLabel(&TOCOffset, &cTOCSize)) != BenErr_OK)
+		return Err;
+
+	if ((Err = cpContainer->SeekToPosition(TOCOffset)) != BenErr_OK)
+		return Err;
+
+	cpTOC = new BenByte[cTOCSize];
+	if ((Err = cpContainer->ReadKnownSize(cpTOC, cTOCSize)) != BenErr_OK) 
+		return Err;
+
+	if ((Err = ReadTOC()) != BenErr_OK)
+		return Err;
+
+	return BenErr_OK;
+}
+
+BenError
+CBenTOCReader::ReadLabel(unsigned long * pTOCOffset, unsigned long * pTOCSize)
+{
+	// If seek fails, then probably because stream is smaller than
+	// BEN_LABEL_SIZE and thus can't be Bento container
+	BenError Err;
+	if ((Err = cpContainer->SeekFromEnd(-BEN_LABEL_SIZE)) != BenErr_OK)
+		return BenErr_NotBentoContainer;
+
+	BenByte Label[BEN_LABEL_SIZE];
+	if ((Err = cpContainer->ReadKnownSize(Label, BEN_LABEL_SIZE)) != BenErr_OK)
+		return Err;
+
+	if (memcmp(Label, gsBenMagicBytes, BEN_MAGIC_BYTES_SIZE) != 0)
+		if ((Err = SearchForLabel(Label)) != BenErr_OK)
+			return Err;
+
+	BenByte * pCurrLabel = Label + BEN_MAGIC_BYTES_SIZE;
+
+	BenWord Flags = UtGetIntelWord(pCurrLabel); pCurrLabel += 2; // Flags
+	// Newer files are 0x0101--indicates if big or little endian.  Older
+	// files are 0x0 for flags
+	assert(Flags == 0x0101 || Flags == 0x0);
+
+	cBlockSize = UtGetIntelWord(pCurrLabel) * 1024; pCurrLabel += 2;
+
+	// Check major version
+	if (UtGetIntelWord(pCurrLabel) != BEN_CURR_MAJOR_VERSION)
+		return BenErr_UnknownBentoFormatVersion;
+	pCurrLabel += 2;
+
+	UtGetIntelWord(pCurrLabel); pCurrLabel += 2;	// Minor version
+
+	*pTOCOffset = UtGetIntelDWord(pCurrLabel); pCurrLabel += 4;
+	*pTOCSize = UtGetIntelDWord(pCurrLabel);
+
+	assert(pCurrLabel + 4 == Label + BEN_LABEL_SIZE);
+
+	return BenErr_OK;
+}
+
+#define LABEL_READ_BUFFER_SIZE 500
+#define MAX_SEARCH_AMOUNT 1024 * 1024
+
+BenError
+CBenTOCReader::SearchForLabel(BenByte * pLabel)
+{
+	BenError Err;
+
+	unsigned long Length;
+	if ((Err = cpContainer->GetSize(&Length)) != BenErr_OK)
+		return Err;
+
+	// Always ready to check for MagicBytes from
+	// CurrOffset - BEN_MAGIC_BYTES_SIZE to CurrOffset - 1 
+	unsigned long CurrOffset = Length - BEN_LABEL_SIZE + BEN_MAGIC_BYTES_SIZE -
+	  1;
+
+	char Buffer[LABEL_READ_BUFFER_SIZE];
+
+	unsigned long BufferStartOffset = Length;	// Init to big value
+
+	while (CurrOffset >= BEN_MAGIC_BYTES_SIZE)
+	{
+		// Don't search backwards more than 1 meg
+		if (Length - CurrOffset > MAX_SEARCH_AMOUNT)
+			break;
+
+		unsigned long UsedBufferSize;
+
+		// If before beginning of buffer
+		if (CurrOffset - BEN_MAGIC_BYTES_SIZE < BufferStartOffset)
+		{
+			if (CurrOffset < LABEL_READ_BUFFER_SIZE)
+				UsedBufferSize = CurrOffset;
+			else UsedBufferSize = LABEL_READ_BUFFER_SIZE;
+
+			if ((Err = cpContainer->SeekToPosition(CurrOffset - UsedBufferSize))
+			  != BenErr_OK)
+			  	return Err;
+
+			if ((Err = cpContainer->ReadKnownSize(Buffer, UsedBufferSize)) !=
+			  BenErr_OK)
+				return Err;
+
+			BufferStartOffset = CurrOffset - UsedBufferSize;
+		}
+
+		if (memcmp(Buffer + (CurrOffset - BEN_MAGIC_BYTES_SIZE -
+		  BufferStartOffset), gsBenMagicBytes, BEN_MAGIC_BYTES_SIZE) == 0)
+		{
+			if ((Err = cpContainer->SeekToPosition(CurrOffset -
+			  BEN_MAGIC_BYTES_SIZE)) != BenErr_OK)
+				return Err;
+
+			return cpContainer->ReadKnownSize(pLabel, BEN_LABEL_SIZE);
+		}
+
+		--CurrOffset;
+	}
+
+	return BenErr_NotBentoContainer;	// Didn't find magic bytes
+}
+
+BenError
+CBenTOCReader::ReadTOC()
+{
+	BenError Err;
+	BenByte LookAhead = GetCode();
+	BenGeneration Generation = 0;
+
+	// Read in all objects
+	while (LookAhead == BEN_NEW_OBJECT)
+	{
+		BenObjectID ObjectID;
+		if ((Err = GetDWord(&ObjectID)) != BenErr_OK)
+			return Err;
+		pCBenObject pObject = NULL;
+
+		// Read in all properties for object
+		do
+		{
+			BenObjectID PropertyID;
+
+			if ((Err = GetDWord(&PropertyID)) != BenErr_OK)
+				return Err;
+			pCBenProperty pProperty = NULL;
+
+			// Read in all values for property
+			do
+			{
+				BenObjectID ReferencedListID = 0;
+
+				BenObjectID TypeID;
+				if ((Err = GetDWord(&TypeID)) != BenErr_OK)
+					return Err;
+				LookAhead = GetCode();
+
+				if (LookAhead == BEN_EXPLICIT_GEN)
+				{
+					if ((Err = GetDWord(&Generation)) != BenErr_OK)
+						return Err;
+					LookAhead = GetCode();
+				}
+
+				if (LookAhead == BEN_REFERENCE_LIST_ID)
+				{
+					// Eat it, unless BENUTIL_SUPPORT turned on
+					if ((Err = GetDWord(&ReferencedListID)) != BenErr_OK)
+						return Err;
+					LookAhead = GetCode();
+				}
+
+				if (PropertyID == BEN_PROPID_GLOBAL_PROPERTY_NAME ||
+			  	  PropertyID == BEN_PROPID_GLOBAL_TYPE_NAME)
+				{
+					// Read property or type name
+
+					if (pObject != NULL || TypeID != BEN_TYPEID_7_BIT_ASCII ||
+					  LookAhead != BEN_OFFSET4_LEN4)
+						return BenErr_NamedObjectError;
+
+					BenContainerPos Pos;
+					unsigned long Length;
+
+					if ((Err = GetDWord(&Pos)) != BenErr_OK)
+						return Err;
+					if ((Err = GetDWord(&Length)) != BenErr_OK)
+						return Err;
+					LookAhead = GetCode();
+
+					if ((Err = cpContainer->SeekToPosition(Pos)) != BenErr_OK)
+						return Err;
+
+					#define STACK_BUFFER_SIZE 256
+					char sStackBuffer[STACK_BUFFER_SIZE];
+					char * sAllocBuffer;
+					char * sBuffer;
+					if (Length > STACK_BUFFER_SIZE)
+					{
+						sBuffer = new char[Length];
+						sAllocBuffer = sBuffer;
+					}
+					else
+					{
+						sBuffer = sStackBuffer;
+						sAllocBuffer = NULL;
+					}
+
+					if ((Err = cpContainer->ReadKnownSize(sBuffer, Length)) !=
+					  BenErr_OK)
+					{
+						delete[] sAllocBuffer;
+						return Err;
+					}
+
+					pCBenNamedObjectListElmt pPrevNamedObjectListElmt;
+					if (FindNamedObject(cpContainer->GetNamedObjects(),
+					  sBuffer, &pPrevNamedObjectListElmt) != NULL)
+					{
+						delete[] sAllocBuffer;
+						return BenErr_DuplicateName;
+					}
+
+					pCBenObject pPrevObject = (pCBenObject) cpContainer->
+					  GetObjects()->GetLast();
+
+					if (PropertyID == BEN_PROPID_GLOBAL_PROPERTY_NAME)
+						pObject = new CBenPropertyName(cpContainer, ObjectID,
+						  pPrevObject, sBuffer, pPrevNamedObjectListElmt);
+					else pObject = new CBenTypeName(cpContainer, ObjectID,
+					  pPrevObject, sBuffer, pPrevNamedObjectListElmt);
+
+					delete[] sAllocBuffer;
+				}
+				// If BENUTIL_SUPPORT turned on, read in references object
+				// like regular object
+#ifndef BENUTIL_SUPPORT
+				else if (PropertyID == BEN_PROPID_OBJ_REFERENCES)
+				{
+					// Don't need to read in references object--we assume
+					// that all references use object ID as key
+					if ((Err = ReadSegments(NULL, &LookAhead)) != BenErr_OK)
+						return Err;
+				}
+#endif
+				else if (ObjectID == BEN_OBJID_TOC)
+				{
+					if (PropertyID == BEN_PROPID_TOC_SEED)
+					{
+						if (TypeID != BEN_TYPEID_TOC_TYPE ||
+					  	  LookAhead !=  BEN_IMMEDIATE4)
+							return BenErr_TOCSeedError;
+
+						BenDWord Data;
+						if ((Err = GetDWord(&Data)) != BenErr_OK)
+							return Err;
+						LookAhead = GetCode();
+
+						cpContainer->SetNextAvailObjectID(Data);
+					}
+					else
+					{
+						// Ignore the other BEN_OBJID_TOC properties
+						if ((Err = ReadSegments(NULL, &LookAhead)) != BenErr_OK)
+							return Err;
+					}
+				}
+				else
+				{
+					if (pProperty != NULL)
+						return BenErr_PropertyWithMoreThanOneValue;
+
+					if (pObject == NULL)
+						pObject = new CBenObject(cpContainer, ObjectID,
+						  (pCBenObject) cpContainer->GetObjects()->GetLast());
+
+					pProperty = new CBenProperty(pObject, PropertyID, TypeID,
+					  (pCBenProperty) pObject->GetProperties()->GetLast());
+
+#ifdef BENUTIL_SUPPORT
+					pProperty->UseValue()->
+					  SetReferencedListObjectID(ReferencedListID);
+#endif
+
+					if ((Err = ReadSegments(pProperty->UseValue(),
+					  &LookAhead)) != BenErr_OK)
+						return Err;
+				}
+			} while (LookAhead == BEN_NEW_TYPE);
+		} while (LookAhead == BEN_NEW_PROPERTY);
+	}
+
+	if (LookAhead == BEN_READ_PAST_END_OF_TOC)
+		return BenErr_OK;
+	else return BenErr_InvalidTOC;
+}
+
+BenError
+CBenTOCReader::ReadSegments(pCBenValue pValue, BenByte * pLookAhead)
+{
+	BenError Err;
+
+	while (*pLookAhead >= BEN_SEGMENT_CODE_START &&
+	  *pLookAhead <= BEN_SEGMENT_CODE_END)
+	{
+		if ((Err = ReadSegment(pValue, pLookAhead)) !=
+		  BenErr_OK)
+			return Err;
+	}
+
+	return BenErr_OK;
+}
+
+BenError
+CBenTOCReader::ReadSegment(pCBenValue pValue, BenByte * pLookAhead)
+{
+	BenError Err;
+
+	UtBool Immediate = UT_FALSE;
+	UtBool EightByteOffset = UT_FALSE;
+	unsigned long Offset, Length;
+
+	switch (*pLookAhead)
+	{
+		case BEN_CONT_OFFSET4_LEN4:
+		case BEN_OFFSET4_LEN4:
+			if ((Err = GetDWord(&Offset))  != BenErr_OK)
+				return Err;
+			if ((Err = GetDWord(&Length))  != BenErr_OK)
+				return Err;
+			break;
+
+		case BEN_IMMEDIATE0:
+			Length = 0; Immediate = UT_TRUE;
+			break;
+
+		case BEN_IMMEDIATE1:
+			Length = 1; Immediate = UT_TRUE;
+			break;
+
+		case BEN_IMMEDIATE2:
+			Length = 2; Immediate = UT_TRUE;
+			break;
+							
+		case BEN_IMMEDIATE3:
+			Length = 3; Immediate = UT_TRUE;
+			break;
+
+		case BEN_CONT_IMMEDIATE4:
+		case BEN_IMMEDIATE4:
+			Length = 4; Immediate = UT_TRUE;
+			break;
+
+		case BEN_CONT_OFFSET8_LEN4:
+		case BEN_OFFSET8_LEN4:
+			EightByteOffset = UT_TRUE;
+			break;
+
+		default:
+			return BenErr_OK;
+	}
+
+	BenByte ImmData[4];
+	if (Immediate && Length != 0)
+		if ((Err = GetData(ImmData, 4)) != BenErr_OK)
+			return Err;
+
+	*pLookAhead = GetCode();
+
+	if (EightByteOffset)
+		return BenErr_64BitOffsetNotSupported;
+
+	if (pValue != NULL)
+	{
+		if (! Immediate)
+			new CBenValueSegment(pValue, Offset, Length);
+		else if (Length != 0)
+		{
+			assert(Length <= 4);
+			new CBenValueSegment(pValue, ImmData, (unsigned short) Length);
+		}
+	}
+
+	return BenErr_OK;
+}
+
+UtBool
+CBenTOCReader::CanGetData(unsigned long Amt)
+{
+	return cCurr + Amt <= cTOCSize;
+}
+
+BenError
+CBenTOCReader::GetByte(BenByte * pByte)
+{
+	if (! CanGetData(1))
+		return BenErr_ReadPastEndOfTOC;
+
+	*pByte = UtGetIntelByte(cpTOC + cCurr);
+	++cCurr;
+	return BenErr_OK;
+}
+
+BenError
+CBenTOCReader::GetWord(BenWord * pWord)
+{
+	if (! CanGetData(2))
+		return BenErr_ReadPastEndOfTOC;
+
+	*pWord = UtGetIntelWord(cpTOC + cCurr);
+	cCurr += 2;
+	return BenErr_OK;
+}
+
+BenError
+CBenTOCReader::GetDWord(BenDWord * pDWord)
+{
+	if (! CanGetData(4))
+		return BenErr_ReadPastEndOfTOC;
+
+	*pDWord = UtGetIntelDWord(cpTOC + cCurr);
+	cCurr += 4;
+	return BenErr_OK;
+}
+
+BenByte
+CBenTOCReader::GetCode()
+{
+	BenByte Code;
+	do
+	{
+		if (GetByte(&Code) != BenErr_OK)
+			return BEN_READ_PAST_END_OF_TOC;
+
+		if (Code == BEN_END_OF_BUFFER)
+			// Advance to next block
+			cCurr = cBlockSize * ((cCurr + (cBlockSize - 1)) /
+			  cBlockSize);
+	}
+	while (Code == BEN_NOOP || Code == BEN_END_OF_BUFFER);
+	return Code;
+}
+
+BenError
+CBenTOCReader::GetData(BenDataPtr pBuffer, unsigned long Amt)
+{
+	if (! CanGetData(Amt))
+		return BenErr_ReadPastEndOfTOC;
+
+	UtHugeMemcpy(pBuffer, cpTOC + cCurr, Amt);
+	cCurr += Amt;
+	return BenErr_OK;
+}
+}//end OpenStormBento namespace
diff -urNp lotuswordpro.bak/source/filter/tocread.hxx lotuswordpro/source/filter/tocread.hxx
--- lotuswordpro.bak/source/filter/tocread.hxx	1970-01-01 08:00:00.000000000 +0800
+++ lotuswordpro/source/filter/tocread.hxx	2008-10-22 11:42:29.000000000 +0800
@@ -0,0 +1,89 @@
+/*************************************************************************
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: IBM Corporation
+ *
+ *  Copyright: 2008 by IBM Corporation
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+#ifndef TOCREAD_H
+#define TOCREAD_H
+namespace OpenStormBento
+{
+
+class CBenTOCReader
+{
+public: // Methods
+	CBenTOCReader(pLtcBenContainer pContainer)
+	  { cpContainer = pContainer; cpTOC = NULL; cCurr = 0; }
+	~CBenTOCReader() { delete cpTOC; }
+	BenError ReadLabelAndTOC();
+
+private: // Methods
+	BenError ReadLabel(unsigned long * pTOCOffset, unsigned long * pTOCSize);
+	BenError SearchForLabel(BenByte * pLabel);
+	BenError ReadTOC();
+	BenError ReadSegments(pCBenValue pValue, BenByte * pLookAhead);
+	BenError ReadSegment(pCBenValue pValue, BenByte * pLookAhead);
+	UtBool CanGetData(unsigned long Amt);
+	BenError GetByte(BenByte * pByte);
+	BenError GetWord(BenWord * pWord);
+	BenError GetDWord(BenDWord * pDWord);
+	BenByte GetCode();
+	BenError GetData(BenDataPtr pBuffer, unsigned long Amt);
+	
+private: // Data
+	pLtcBenContainer cpContainer;
+	BenByteDataPtr cpTOC;
+	unsigned long cBlockSize;
+	unsigned long cCurr;
+	unsigned long cTOCSize;
+};
+}//end namespace OpenStormBento
+#endif
diff -urNp lotuswordpro.bak/source/filter/utbenvs.cxx lotuswordpro/source/filter/utbenvs.cxx
--- lotuswordpro.bak/source/filter/utbenvs.cxx	1970-01-01 08:00:00.000000000 +0800
+++ lotuswordpro/source/filter/utbenvs.cxx	2008-10-22 11:42:29.000000000 +0800
@@ -0,0 +1,288 @@
+/*************************************************************************
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: IBM Corporation
+ *
+ *  Copyright: 2008 by IBM Corporation
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+#include "first.hxx"
+#include <assert.h>
+namespace OpenStormBento
+{
+/*
+ * useless in SODC
+void	LtcUtBenValueStream::GetAmountLeft(ULONG * pAmtLeft)
+{
+	if (cCurrentPosition >= m_ulValueLength)
+	{
+		*pAmtLeft = 0;
+	}
+	else
+	{
+		*pAmtLeft = m_ulValueLength - cCurrentPosition;
+	}
+}
+*/
+/**
+*	Value stream read function
+*	@date	07/05/2004
+*	@param	data pointer of bytes read
+*	@param	number of bytes to be read
+*	@return	number of bytes read
+*/
+ULONG	LtcUtBenValueStream::GetData( void* pData, ULONG nSize )
+{
+	//unsigned long AmtLeft;
+	ULONG AmtRead;
+	//GetAmountLeft(&AmtLeft);
+
+	//unsigned long AmtShouldRead = UtMin(nSize, AmtLeft);
+	BenError Err = cpValue->ReadValueData(pData, cCurrentPosition, nSize,
+	  &AmtRead);
+	cCurrentPosition += AmtRead;
+
+	return AmtRead;
+}
+ /**
+*	Value stream write function, not suppoted now
+*	@date	07/05/2004
+*	@param	pointer of saved buffer
+*	@param	size of buffer to be written
+*	@return	number of bytes written into value stream
+*/
+ULONG	LtcUtBenValueStream::PutData( const void* pData, ULONG nSize )
+{
+	/* Because we only support IMPORT filter, PutData implementation is ignored
+	    It won't bring negative influence to read-only stream object */
+	assert(false);
+	return nSize;
+}
+/**
+*	Seek function of value stream
+*	@date	07/05/2004
+*	@param	position in value stream
+*	@return	current position in value stream
+*/
+ ULONG	LtcUtBenValueStream::SeekPos( ULONG nPos )
+{
+	if (nPos <= m_ulValueLength)
+		cCurrentPosition = nPos;
+	else
+		cCurrentPosition = m_ulValueLength;
+	return cCurrentPosition;
+}
+/**
+*	Set buffer size function
+*	@date	07/05/2004
+*	@param 	size of buffer
+*	@return	
+*/
+ void	LtcUtBenValueStream::SetSize( ULONG nSize )
+{
+	pLtcBenContainer pContainer = cpValue->GetContainer();
+	//pContainer->GetStream()->SetStreamSize(nSize);
+
+	return;
+}
+/**
+*	Flush data funciton, not supported now
+*	@date	07/05/2004
+*	@param 	
+*	@return	
+*/
+void	LtcUtBenValueStream::FlushData()
+{
+	/* Because we only support IMPORT filter, FlushData implementation is ignored
+	    It won't bring negative influence to read-only stream object 
+	pLtcBenContainer pContainer = cpValue->GetContainer();
+	pContainer->GetStream()->Flush();*/
+	assert(false);
+	return;
+}
+/**
+*	Construction
+*	@date	07/05/2004
+*	@param	pointer to CBenValue object
+*	@return	
+*/
+LtcUtBenValueStream::LtcUtBenValueStream(pCBenValue pValue)
+{
+	// Calculate the length of the whole value stream
+	cCurrentPosition = 0;
+	m_ulValueLength = pValue->GetValueSize();
+	cpValue = pValue;
+}
+
+LtcUtBenValueStream::~LtcUtBenValueStream()
+{
+}
+#if 0		// Deleted by  2004-06-16
+UtError
+CUtBenValueStream::Open(UtBool /* OpenNew */, UtStrmOpenFlags /* Flags */)
+{
+	cCurrentPosition = 0;
+	return UtErr_OK;
+}
+
+UtError
+CUtBenValueStream::Close()
+{
+	return UtErr_OK;
+}
+
+UtError
+CUtBenValueStream::Seek(long Offset, UtSeekMode Mode)
+{
+	unsigned long NewPos;
+
+	if (Mode == UtSeek_FromStart)
+		NewPos = (unsigned long) Offset;
+	else if (Mode == UtSeek_FromCurr)
+	{
+		if (Offset < 0 && cCurrentPosition < (unsigned long) -Offset)
+			return UtErr_SeekError;
+		NewPos = cCurrentPosition + Offset;
+	}
+	else if (Mode == UtSeek_FromEnd)
+	{
+		unsigned long ValueSize = cpValue->GetValueSize();
+		if (Offset < 0 && ValueSize < (unsigned long) -Offset)
+			return UtErr_SeekError;
+		NewPos = ValueSize + Offset;
+	}
+	else 
+	{
+		UT_ASSERT(! "Illegal seek");
+		return UtErr_SeekError;
+	}
+
+	cCurrentPosition = NewPos;
+	return UtErr_OK;
+}
+
+UtError
+CUtBenValueStream::GetPosition(unsigned long * pPosition)
+{
+	*pPosition = cCurrentPosition;
+	return UtErr_OK;
+}
+
+UtError
+CUtBenValueStream::GetSize(unsigned long * pSize)
+{
+	*pSize = cpValue->GetValueSize();
+	return UtErr_OK;
+}
+
+UtError
+CUtBenValueStream::Read(UtStrmDataPtr pBuffer, unsigned long MaxSize,
+  unsigned long * pAmtRead)
+{
+	unsigned long AmtLeft;
+	GetAmountLeft(&AmtLeft);
+
+	unsigned long AmtShouldRead = UtMin(MaxSize, AmtLeft);
+
+	BenError Err = cpValue->ReadValueData(pBuffer, cCurrentPosition, MaxSize,
+	  pAmtRead);
+	cCurrentPosition += *pAmtRead;
+
+	return BenToUtError(Err);
+}
+
+UtError
+CUtBenValueStream::Write(UtConstStrmDataPtr pBuffer, unsigned long Size,
+  unsigned long * pAmtWritten)
+{
+	BenError Err;
+
+	*pAmtWritten = 0;
+
+	// IStream::Write semantics are that when write zero bytes, doesn't fill
+	// in gap
+	if (Size == 0)
+		return UtErr_OK;
+
+	// See if anybody exercies code below
+	//UT_ASSERT(cCurrentPosition <= (long) cpValue->GetValueSize());
+
+	// Fill out "gap" in data, if there is one, with nulls
+	while (cCurrentPosition > cpValue->GetValueSize())
+		if ((Err = cpValue->WriteValueData("", cpValue->GetValueSize(), 1,
+		  NULL)) != BenErr_OK)
+			return BenToUtError(Err);
+
+	unsigned long AmtWritten;
+	Err = cpValue->WriteValueData(pBuffer, cCurrentPosition, Size,
+	  &AmtWritten);
+
+	//UT_ASSERT(Size == AmtWritten);
+
+	cCurrentPosition += AmtWritten;
+
+	*pAmtWritten = AmtWritten;
+
+	return BenToUtError(Err);
+}
+
+UtError
+CUtBenValueStream::TruncateSize(unsigned long Size)
+{
+	return BenToUtError(cpValue->TruncateValueSize(Size));
+}
+
+UtError
+CUtBenValueStream::Flush()
+{
+	return UtErr_OK;
+
+}
+#endif
+} // end namespace OpenStormBento
diff -urNp lotuswordpro.bak/source/filter/ut.hxx lotuswordpro/source/filter/ut.hxx
--- lotuswordpro.bak/source/filter/ut.hxx	1970-01-01 08:00:00.000000000 +0800
+++ lotuswordpro/source/filter/ut.hxx	2008-10-22 11:42:29.000000000 +0800
@@ -0,0 +1,101 @@
+/*************************************************************************
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: IBM Corporation
+ *
+ *  Copyright: 2008 by IBM Corporation
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+#ifndef UT_HXX
+#define UT_HXX
+# include <sal/types.h>
+
+namespace OpenStormBento
+{
+
+#define UtMin(x,y) ((x) < (y) ? (x) : (y))
+#define UtMax(x,y) ((x) > (y) ? (x) : (y))
+
+#define UtHugeMemcpy memcpy
+
+#define UtErr_OK 0
+#define UtErr_Fail 1
+
+#define UT_TRUE	sal_True
+#define UT_FALSE sal_False
+
+#define UtByte sal_uInt8
+#define UtDWord sal_uInt32
+#define UtWord sal_uInt16
+#define UtBool sal_Int32
+
+#define UtDefClassP(Name) class Name; typedef Name * p##Name; \
+  typedef const Name * pConst##Name
+
+inline UtWord UtGetIntelWord(UtByte * pData)
+{ return * (UtWord *) pData; }
+
+inline UtDWord UtGetIntelDWord(UtByte * pData)
+{ return * (UtDWord *) pData; }
+
+inline void UtPutIntelWord(UtByte * pData, UtWord Val)
+{ * (UtWord *) pData = Val; }
+
+inline void UtPutIntelDWord(UtByte * pData, UtDWord Val)
+{ * (UtDWord *) pData = Val; }
+
+inline UtByte UtGetIntelByte(UtByte * pData)
+{ return * pData; }
+
+inline void UtPutIntelByte(UtByte * pData, UtByte Val)
+
+{ * pData = Val; }
+
+}
+#endif
diff -urNp lotuswordpro.bak/source/filter/utlist.cxx lotuswordpro/source/filter/utlist.cxx
--- lotuswordpro.bak/source/filter/utlist.cxx	1970-01-01 08:00:00.000000000 +0800
+++ lotuswordpro/source/filter/utlist.cxx	2008-10-22 11:42:29.000000000 +0800
@@ -0,0 +1,250 @@
+/*************************************************************************
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: IBM Corporation
+ *
+ *  Copyright: 2008 by IBM Corporation
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+#include "first.hxx"
+
+namespace OpenStormBento
+{
+
+CUtListElmt::CUtListElmt(pCUtList pList)
+{
+	if (pList == NULL)
+		cpNext = NULL;
+	else InsertAfter(pList->GetLast());
+}
+
+CUtListElmt::~CUtListElmt()
+{
+	if (OnList())
+	{
+		cpPrev->cpNext = cpNext;
+		cpNext->cpPrev = cpPrev;
+	}
+}
+
+
+
+
+CUtList::~CUtList()
+{
+	pCUtListElmt pTerminating = GetTerminating();
+	for (pCUtListElmt pCurr = GetFirst(); pCurr != pTerminating; )
+	{
+		pCUtListElmt pNext = pCurr->GetNext();
+		pCurr->MakeNotOnList();
+		pCurr = pNext;
+	}
+	pTerminating->SetPrev(pTerminating);
+	pTerminating->SetNext(pTerminating);
+}
+
+int
+CUtList::GetCount()
+{
+	int Count = 0;
+
+	pCUtListElmt pTerminating = GetTerminating();
+	for (pCUtListElmt pCurr = GetFirst(); pCurr != pTerminating; 
+				pCurr = pCurr->GetNext())
+	{
+		Count++;
+	}
+	return Count;
+}
+
+pCUtListElmt 
+CUtList::GetIndex(int Index)
+{
+	int Count = 0;
+
+	pCUtListElmt pTerminating = GetTerminating();
+	for (pCUtListElmt pCurr = GetFirst(); pCurr != pTerminating; 
+				pCurr = pCurr->GetNext())
+	{
+		if (Count == Index)
+			return pCurr;
+		Count++;
+	}
+	return NULL;
+}
+
+int 
+CUtList::GetIndex(pCUtListElmt pNode)
+{
+	int Count = 0;
+
+	pCUtListElmt pTerminating = GetTerminating();
+	for (pCUtListElmt pCurr = GetFirst(); pCurr != pTerminating; 
+				pCurr = pCurr->GetNext())
+	{
+		if (pNode == pCurr)
+			break;
+		Count++;
+	}
+	return Count;
+}
+
+// If pCurr is last item in list, returns first item in list (terminating
+// item is skipped when circle around)
+pCUtListElmt
+CUtList::CircularGetNext(pConstCUtListElmt pCurr)
+{
+	pCUtListElmt pNext = pCurr->GetNext();
+	if (pNext == GetTerminating())
+		pNext = GetFirst();
+	return pNext;
+}
+
+pCUtListElmt
+CUtList::CircularGetPrev(pConstCUtListElmt pCurr)
+{
+	pCUtListElmt pPrev = pCurr->GetPrev();
+	if (pPrev == GetTerminating())
+		pPrev = GetLast();
+	return pPrev;
+}
+
+// If pCurr is NULL, returns first item in list.  Otherwise, returns item
+// in list after pCurr or NULL if no more items in list.  Terminating item
+// is never returned
+pCUtListElmt
+CUtList::GetNextOrNULL(pCUtListElmt pCurr)
+{
+	pCUtListElmt pNext;
+
+	if (pCurr == NULL)
+		pNext = GetFirst();
+	else pNext = pCurr->GetNext();
+	if (pNext == GetTerminating())
+		pNext = NULL;
+	return pNext;
+}
+
+// If pCurr is NULL, returns last item in list.  Otherwise, returns item
+// in list before pCurr or NULL if no more items in list.  Terminating item
+// is never returned
+pCUtListElmt
+CUtList::GetPrevOrNULL(pCUtListElmt pCurr)
+{
+	pCUtListElmt pPrev;
+
+	if (pCurr == NULL)
+		pPrev = GetLast();
+	else pPrev = pCurr->GetPrev();
+	if (pPrev == GetTerminating())
+		pPrev = NULL;
+	return pPrev;
+}
+#if 0                 // Deleted by  2004-06-16
+
+// Does an insertion sort on list.  If list is already sorted, takes O(n)
+// time.  Assumes elements are of type CUtComparableListElmt
+void
+CUtList::Sort(LCID LangID)
+{
+	pCUtListElmt pSortedTo = GetFirst();
+
+	// Before each iteration, list is sorted up to, but not including,
+	// pSortedTo.  On each iteration, we look backwards through sorted portion
+	// of list searching for spot that pSortedTo should go and move it to that
+	// location
+	while (pSortedTo != GetTerminating())
+	{
+		pCUtListElmt pNextSortedTo = pSortedTo->GetNext();
+
+		UtBool FoundSpot = UT_FALSE;
+		for (pCUtListElmt pCurr = pSortedTo->GetPrev();
+		  pCurr != GetTerminating();
+		  pCurr = pCurr->GetPrev())
+		{
+			if (((pCUtComparableListElmt) pSortedTo)->
+			  Compare((pCUtComparableListElmt) pCurr, LangID) >= 0)
+			{
+				pSortedTo->Remove();
+				pSortedTo->InsertAfter(pCurr);
+				FoundSpot = UT_TRUE;
+				break;
+			}
+		}
+
+		if (! FoundSpot)
+		{
+			pSortedTo->Remove();
+			pSortedTo->InsertAfter(GetTerminating());	// Add at beginning
+		}
+
+		pSortedTo = pNextSortedTo;
+	}
+}
+#endif
+void
+CUtList::Destroy()
+{
+	pCUtListElmt pTerminating = GetTerminating();
+	for (pCUtListElmt pCurr = GetFirst(); pCurr != pTerminating; )
+	{
+		pCUtListElmt pNext = pCurr->GetNext();
+		delete pCurr;
+		pCurr = pNext;
+	}
+}
+
+
+
+
+CUtOwningList::~CUtOwningList()
+{
+	Destroy();
+}
+}//end namespace OpenStormBento
diff -urNp lotuswordpro.bak/source/filter/utlist.hxx lotuswordpro/source/filter/utlist.hxx
--- lotuswordpro.bak/source/filter/utlist.hxx	1970-01-01 08:00:00.000000000 +0800
+++ lotuswordpro/source/filter/utlist.hxx	2008-10-22 11:42:29.000000000 +0800
@@ -0,0 +1,157 @@
+/*************************************************************************
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: IBM Corporation
+ *
+ *  Copyright: 2008 by IBM Corporation
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+#ifndef UTLIST_H
+#define UTLIST_H
+
+#include "ut.hxx"
+
+namespace OpenStormBento
+{
+
+
+UtDefClassP(CUtListElmt);
+UtDefClassP(CUtList);
+UtDefClassP(CUtComparableListElmt);
+
+class CUtListElmt
+{
+public: // Methods
+	CUtListElmt() { cpNext = NULL; }
+	CUtListElmt(pCUtListElmt pPrev) { InsertAfter(pPrev); }
+	CUtListElmt(pCUtList pList);
+	virtual ~CUtListElmt();
+	void Remove()
+	{
+		cpPrev->cpNext = cpNext;
+		cpNext->cpPrev = cpPrev;
+		cpNext = NULL;
+	}
+	UtBool OnList() { return cpNext != NULL; }
+	void MakeNotOnList() { cpNext = NULL; }	// Same as Remove but doesn't
+											// patch up list
+	pCUtListElmt GetNext() const { return cpNext; }
+	void SetNext(pCUtListElmt pNext) { cpNext = pNext; }
+	pCUtListElmt GetPrev() const { return cpPrev; }
+	void SetPrev(pCUtListElmt pPrev) { cpPrev = pPrev; }
+	void InsertAfter(pCUtListElmt pPrev)
+	{
+		cpNext = pPrev->cpNext;
+		cpPrev = pPrev;
+		cpNext->cpPrev = this;
+		pPrev->cpNext = this;
+	}
+
+private: // Data
+	pCUtListElmt cpNext;
+	pCUtListElmt cpPrev;
+};
+
+
+
+
+class CUtComparableListElmt : public CUtListElmt
+{
+public: // Methods
+	CUtComparableListElmt() { ; }
+	CUtComparableListElmt(pCUtComparableListElmt pPrev) :
+	  CUtListElmt(pPrev) { ; }
+	CUtComparableListElmt(pCUtList pList) : CUtListElmt(pList) { ; }
+
+public: // Pure virtual methods
+#if 0            // Deleted by  2004-06-16
+	virtual int Compare(pCUtComparableListElmt pOther, LCID LangID = 0) = 0;
+#endif
+};
+
+
+
+
+class CUtList
+{
+public: // Methods
+	CUtList() { cDummyElmt.SetNext(&cDummyElmt);
+	  cDummyElmt.SetPrev(&cDummyElmt); }
+	virtual ~CUtList();
+	pCUtListElmt GetFirst() { return cDummyElmt.GetNext(); }
+	pCUtListElmt GetLast() { return cDummyElmt.GetPrev(); }
+	pCUtListElmt GetTerminating() { return &cDummyElmt; }
+	pCUtListElmt CircularGetNext(pConstCUtListElmt pCurr);
+	pCUtListElmt CircularGetPrev(pConstCUtListElmt pCurr);
+	pCUtListElmt GetNextOrNULL(pCUtListElmt pCurr);
+	pCUtListElmt GetPrevOrNULL(pCUtListElmt pCurr);
+	UtBool IsEmpty() { return GetFirst() == GetTerminating(); };
+	UtBool ContainsAtLeastTwoItems() { return GetFirst() != GetLast(); };
+#if 0             // Deleted by  2004-06-16
+void Sort(LCID LangID = 0); // Assumes elements are of type CUtComparableListElmt
+#endif
+	int GetCount(void);
+	void Destroy(void);
+	pCUtListElmt GetIndex(int Index);
+	int GetIndex(pCUtListElmt pNode);
+
+private: // Data
+	CUtListElmt cDummyElmt;
+};
+
+
+
+
+class CUtOwningList : public CUtList
+{
+public: // Methods
+	~CUtOwningList();
+};
+}//end namespace OpenStormBento
+#endif
