Index: sc/inc/filter.hxx
===================================================================
RCS file: /cvs/sc/sc/inc/filter.hxx,v
retrieving revision 1.3
retrieving revision 1.3.410.1
diff -w -u -r1.3 -r1.3.410.1
--- sc/inc/filter.hxx	20 Jul 2001 18:34:25 -0000	1.3
+++ sc/inc/filter.hxx	23 Mar 2004 17:37:49 -0000	1.3.410.1
@@ -121,8 +121,6 @@
 // ***********************************************************************
 
 FltError ScImportLotus123( SfxMedium&, ScDocument*, CharSet eSrc = RTL_TEXTENCODING_DONTKNOW );
-
-FltError ScImportExcel( SvStream&, ScDocument* );
 
 FltError ScImportExcel( SfxMedium&, ScDocument* );
 
Index: sc/inc/scextopt.hxx
===================================================================
RCS file: /cvs/sc/sc/inc/scextopt.hxx,v
retrieving revision 1.9
retrieving revision 1.9.72.1
diff -w -u -r1.9 -r1.9.72.1
--- sc/inc/scextopt.hxx	4 Jun 2004 10:14:45 -0000	1.9
+++ sc/inc/scextopt.hxx	16 Jul 2004 17:41:18 -0000	1.9.72.1
@@ -158,6 +158,7 @@
 
     BOOL                    bChanged;       // for import: copy data only first time to doc
 	bool					bWinProtection;  // Excel Workbook Windows protection flag
+	bool					bWinEncryption;  // Excel Workbook Windows encryption flag
 
     void                    Reset();
 
@@ -202,6 +203,8 @@
 	void					AddCodename( const String& );	// -> tables
 	inline void				SetWinProtection(bool bImportWinProtection) {bWinProtection = bImportWinProtection; }
 	inline bool				IsWinProtected()         { return bWinProtection; }
+	inline void				SetWinEncryption(bool bImportWinEncryption) {bWinEncryption = bImportWinEncryption; }
+	inline bool				IsWinEncrypted()         { return bWinEncryption; }
 };
 
 

Index: sc/source/filter/excel/XclImpCharts.cxx
===================================================================
RCS file: /cvs/sc/sc/source/filter/excel/XclImpCharts.cxx,v
retrieving revision 1.15
retrieving revision 1.13.6.3
diff -w -u -r1.15 -r1.13.6.3
--- sc/source/filter/excel/XclImpCharts.cxx	4 Jun 2004 10:41:11 -0000	1.15
+++ sc/source/filter/excel/XclImpCharts.cxx	14 Jul 2004 10:13:54 -0000	1.13.6.3
@@ -177,7 +177,7 @@
     XclImpObjectManager aObjManager( GetRoot() );
     XclImpEscherPropSet aPropSet( aObjManager.GetDffManager() );
     // read from stream
-    rStrm.InitializeRecord( true, rStrm.GetRecId() );
+    rStrm.ResetRecord( true, rStrm.GetRecId() );
     rStrm >> aPropSet;
     // get the data
     aPropSet.FillToItemSet( maItemSet );
@@ -1324,8 +1324,7 @@
         rStrm.Ignore( 2 );
         UINT8 nLen;
         rStrm >> nLen;
-        rpString = new String;
-        rStrm.AppendUniString( *rpString, nLen );
+        rpString = new String( rStrm.ReadUniString( nLen ) );
 	}
 }
 
Index: sc/source/filter/excel/biffdump.cxx
===================================================================
RCS file: /cvs/sc/sc/source/filter/excel/biffdump.cxx,v
retrieving revision 1.64
retrieving revision 1.62.6.6
diff -w -u -r1.64 -r1.62.6.6
--- sc/source/filter/excel/biffdump.cxx	4 Jun 2004 13:58:51 -0000	1.64
+++ sc/source/filter/excel/biffdump.cxx	14 Jul 2004 10:14:18 -0000	1.62.6.6
@@ -97,8 +97,8 @@
 #ifndef SC_FPROGRESSBAR_HXX
 #include "fprogressbar.hxx"
 #endif
-#ifndef SC_XLTOOLS_HXX
-#include "xltools.hxx"
+#ifndef SC_XICONTENT_HXX
+#include "xicontent.hxx"
 #endif
 
 #ifndef _FLTTOOLS_HXX
@@ -133,9 +133,6 @@
 static UINT16			nSXLISize[2] = {0, 0};		// array size for SXLI records [rows/cols]
 static UINT16			nSXLIIndex = 0;				// current index for SXLI records
 
-extern const sal_Char*	pUserNamesStreamName;
-extern const sal_Char*	pRevLogStreamName;
-
 Biff8RecDumper			__aDummyBiff8RecDumperInstance();
 
 
@@ -917,6 +914,32 @@
 }
 
 
+void Biff8RecDumper::PreDumpDecrypted( ULONG nL )
+{
+    if( !nL ) return;
+
+    ByteString t;
+    const sal_Char* pPre = (pLevelPre > pLevelPreString) ? pLevelPre - 1 : pLevelPre;
+
+    LINESTART();
+    ADDTEXT( "*** encrypted ***" );
+    PRINT();
+    pIn->DisableDecryption();
+    pIn->Seek( EXC_REC_SEEK_TO_BEGIN );
+    ContDump( nL );
+
+    if( pIn->HasValidDecrypter() )
+    {
+        LINESTART();
+        ADDTEXT( "*** decrypted ***" );
+        PRINT();
+        pIn->EnableDecryption();
+        pIn->Seek( EXC_REC_SEEK_TO_BEGIN );
+        ContDump( nL );
+    }
+}
+
+
 void Biff8RecDumper::RecDump( BOOL bSubStream )
 {
 	const sal_Char*		p;
@@ -926,6 +949,15 @@
     const UINT16        nR = pIn->GetRecId();
 	const ByteString*	pName = GetName( nR );
 
+    // detect BIFF version
+    switch( nR )
+    {
+        case 0x0009:    SetBiff( xlBiff2 );                     break;
+        case 0x0209:    SetBiff( xlBiff3 );                     break;
+        case 0x0409:    SetBiff( xlBiff4 );                     break;
+        case 0x0809:    SetBiff( bBIFF8 ? xlBiff8 : xlBiff5 );  break;
+    }
+
 	// set CONTINUE handling mode
 	switch( nR )
 	{
@@ -934,10 +966,10 @@
 		case 0x005D:		// OBJ
 		case 0x00EC:		// MSODRAWING
 		case 0x01B6:		// TXO
-            pIn->InitializeRecord( false );
+            pIn->ResetRecord( false );
 		break;
 		default:
-			pIn->InitializeRecord( bReadContRecs );
+            pIn->ResetRecord( bReadContRecs );
 	}
     const ULONG         nL = pIn->GetRecSize();
 
@@ -1003,7 +1035,7 @@
 		if( !bSkipOffset )
 		{
 			aT += " :";
-            __AddHex( aT, UINT32(pIn->Tell() - 2 * sizeof(UINT16)) );
+            __AddHex( aT, UINT32(pIn->GetSvStreamPos() - 2 * sizeof(UINT16)) );
 			aT += ':';
 		}
 
@@ -1013,11 +1045,25 @@
 	if( HasModeNameOnly( nR ) )
 		;
     else if( HasModeHex( nR ) || !bBIFF8 )
+    {
+        if( bEncrypted )
+            PreDumpDecrypted( nL );
+        else
 		ContDump( nL );
+    }
 	else if( nMaxBodyLines && nL )
 	{
 		XclImpStream& rIn = *pIn;
 
+        if( bEncrypted )
+        {
+            PreDumpDecrypted( nL );
+            LINESTART();
+            ADDTEXT( "*** contents ***" );
+            PRINT();
+            pIn->Seek( EXC_REC_SEEK_TO_BEGIN );
+        }
+
 		LINESTART();
 
 		switch( nR )
@@ -1353,9 +1399,20 @@
                         {
                             case 0x0001:
                             {
-                                ADDTEXT( "BIFF8 standard)   key=..." );
+                                ADDTEXT( "BIFF8 standard)" );
                                 PRINT();
-                                ContDump( rIn.GetRecLeft() );
+                                LINESTART();
+                                ADDTEXT( "document-id=..." );
+                                PRINT();
+                                ContDump( 16 );
+                                LINESTART();
+                                ADDTEXT( "salt-data=..." );
+                                PRINT();
+                                ContDump( 16 );
+                                LINESTART();
+                                ADDTEXT( "salt-hash=..." );
+                                PRINT();
+                                ContDump( 16 );
                             }
                             break;
                             case 0x0002:
@@ -1374,12 +1431,12 @@
                                 ADDTEXT( "   hash-key-len=" );  ADDDEC( 4 );
                                 PRINT();
                                 LINESTART();
-                                ADDTEXT( "unknown=" );          ADDHEX( 4 );
+                                ADDTEXT( "crypt-prov-type=" );  ADDHEX( 4 );
                                 ADDTEXT( "   unknown=" );       ADDHEX( 4 );
                                 ADDTEXT( "   unknown=" );       ADDHEX( 4 );
                                 PRINT();
                                 LINESTART();
-                                ADDTEXT( "crypto-provider='" );
+                                ADDTEXT( "crypt-provider-name='" );
                                 sal_uInt16 nChar;
                                 do
                                 {
@@ -1393,12 +1450,16 @@
                                 LINESTART();
                                 sal_uInt32 nLen;
                                 rIn >> nLen;
-                                ADDTEXT( "*** key1 ***   len=" );   __AddHex( t, nLen );
+                                ADDTEXT( "*** document-id ***   len=" );   __AddHex( t, nLen );
                                 PRINT();
-                                ContDump( 2 * nLen );
+                                ContDump( nLen );
+                                LINESTART();
+                                ADDTEXT( "*** salt-data ***   len=" );   __AddHex( t, nLen );
+                                PRINT();
+                                ContDump( nLen );
                                 LINESTART();
                                 rIn >> nLen;
-                                ADDTEXT( "*** key2 ***   len=" );   __AddHex( t, nLen );
+                                ADDTEXT( "*** salt-hash ***   len=" );   __AddHex( t, nLen );
                                 PRINT();
                                 ContDump( nLen );
                             }
@@ -1420,7 +1481,6 @@
                         ContDump( rIn.GetRecLeft() );
                     }
                 }
-                bBIFF8 = FALSE;     // continue in hex mode
             }
             break;
 			case 0x0031:		// FONT
@@ -1478,6 +1538,7 @@
                     String aData;
                     sal_uInt32 __nFlags;
                     LINESTART();
+                    rIn.SetNulSubstChar( '\0' );
                     aData = rIn.ReadRawUniString( 32, true );
                     ADDTEXT( "device-name='" );         ADDTEXT( GETSTR( aData ) );
                     ADDTEXT( "'" );
@@ -2604,6 +2665,7 @@
 			break;
 			case 0x0138:		// CHTRINFO - change tracking info
 			{
+                rIn.DisableDecryption();
 				ADDTEXT( "14 bytes of unknown data..." );
 				PRINT();
 				ContDump( 14 );
@@ -2919,6 +2981,7 @@
 			break;
 			case 0x0194:
 			{
+                rIn.DisableDecryption();
 				ADDTEXT( "unknown: " );			ADDHEX( 4 );
 				ADDTEXT( "   date/time: " );	ADDDEC( 2 );
 				ADDTEXT( "-" );					ADDDEC( 1 );
@@ -2940,8 +3003,13 @@
 				ContDump( rIn.GetRecLeft() );
 			}
 			break;
+            case 0x0195:
+                rIn.DisableDecryption();
+                ContDump( nL );
+            break;
 			case 0x0196:
 			{
+                rIn.DisableDecryption();
 				ADDTEXT( "unknown: " );				ADDHEX( 2 );
 				ADDTEXT( " " );						ADDHEX( 2 );
 				ADDTEXT( " " );						ADDHEX( 2 );
@@ -3910,6 +3978,7 @@
 			break;
 			case 0x0809:		// BOF
 			{
+                rIn.DisableDecryption();
 				LINESTART();
 				ADDTEXT( "version number:      " );
 				ADDHEX( 2 );
@@ -4846,24 +4915,36 @@
 				ContDump( nL );
 				break;
 			case 0x1066:		// ChartGelframe
-                rIn.InitializeRecord( true, 0x1066 );
+                rIn.ResetRecord( true, 0x1066 );
                 EscherDump( nL );
 				break;
 			case 0x1067:		// ChartBoppcustom
 				ContDump( nL );
 				break;
 			default:
+                if( !bEncrypted )
 				ContDump( nL );
 		}
 
 	}
 
+    if( nR == EXC_ID_FILEPASS )
+    {
+        bEncrypted = true;
+        pIn->Seek( EXC_REC_SEEK_TO_BEGIN );
+        bool bValid = (XclImpDecryptHelper::ReadFilepass( *pIn ) == ERRCODE_NONE);
+        LINESTART();
+        ADDTEXT( "decrypter=" );    lcl_AddOnOff( t, bValid );
+        PRINT();
+        bBIFF8 = bBIFF8 && bValid;  // dump BIFF8 hex only on invalid decrypter
+    }
+
 	if( bDec )
 		pLevelPre -= nLevelInc;
 }
 
 
-void Biff8RecDumper::DumpSubStream( SvStorage* pStorage, const sal_Char* pStreamName )
+void Biff8RecDumper::DumpSubStream( SvStorage* pStorage, const String& rStrmName )
 {
 	ByteString sOutput;
 
@@ -4875,14 +4956,12 @@
 		return;
 	}
 
-	String sName;
-	sName.AppendAscii( pStreamName );
-	if( !pStorage->IsContained( sName ) || !pStorage->IsStream( sName ) )
+    if( !pStorage->IsContained( rStrmName ) || !pStorage->IsStream( rStrmName ) )
 		return;
 
-	SvStream* pStream = pStorage->OpenStream( sName, STREAM_STD_READ );
+    SvStorageStreamRef xSvStrm = OpenStream( pStorage, rStrmName );
 
-	if( !pStream )
+    if( !xSvStrm.Is() )
 	{
 		sOutput = "-- no stream available --";
 		Print( sOutput );
@@ -4890,26 +4969,26 @@
 		return;
 	}
 
-	pStream->Seek( STREAM_SEEK_TO_END );
-	if( pStream->Tell() == ~((ULONG)0) )
+    xSvStrm->Seek( STREAM_SEEK_TO_END );
+    if( xSvStrm->Tell() == STREAM_SEEK_TO_END )
 	{
 		sOutput = "-- no stream available --";
 		Print( sOutput );
 		DBG_ERROR( "Biff8RecDumper::DumpSubStream - no stream available" );
-		delete pStream;
 		return;
 	}
 
 	sOutput = "-- substream dump --";
 	Print( sOutput );
 	sOutput = "Stream name: ";
-	sOutput += pStreamName;
+    sOutput += ByteString( rStrmName, RTL_TEXTENCODING_ASCII_US );
 	Print( sOutput );
 
 	XclImpStream* pOldStream = pIn;
-    pIn = new XclImpStream( *pStream, *pExcRoot->pIR );
+    pIn = new XclImpStream( *xSvStrm, GetRoot() );
 	XclImpStream& rIn = *pIn;
-	rIn.SetWarningMode( bWarnings );
+    if( pOldStream )
+        rIn.CopyDecrypterFrom( *pOldStream );
 
 	// -- dump from here --
 	UINT16	nId;
@@ -4927,16 +5006,14 @@
 	sOutput = "-- end of stream --\n";
 	Print( sOutput );
 	delete pIn;
-	delete pStream;
 	pIn = pOldStream;
 }
 
 
 void Biff8RecDumper::DumpPivotCache( const UINT16 nStrId )
 {
-	ByteString sByteStrName;
-	__AddPureHex( sByteStrName, nStrId );
-	DumpSubStream( pPivotCache, sByteStrName.GetBuffer() );
+    SvStorageRef xStrg = OpenStorage( EXC_STORAGE_PTCACHE );
+    DumpSubStream( xStrg, ScfTools::GetHexStr( nStrId ) );
 }
 
 
@@ -7815,7 +7892,7 @@
 				if( *pOutName == "*" )
 				{
 					ByteString			aDefault( "DefaultDumpName.txt" );
-					SfxObjectShell*		pShell = pExcRoot->pDoc->GetDocumentShell();
+                    SfxObjectShell*     pShell = GetDocShell();
 					if( pShell )
 					{
 						SfxMedium*		pMedium = pShell->GetMedium();
@@ -8309,14 +8386,14 @@
 }
 
 
-Biff8RecDumper::Biff8RecDumper( RootData& rRootData, BOOL _bBIFF8 ) :
-    ExcRoot( &rRootData ),
-    bBIFF8( _bBIFF8 )
+Biff8RecDumper::Biff8RecDumper( const XclImpRoot& rRoot, BOOL _bBIFF8 ) :
+    XclImpRoot( rRoot ),
+    bBIFF8( _bBIFF8 ),
+    bEncrypted( false )
 {
 	nXFCount = 0;
 	nFontIndex = 0;
 	nInstances++;
-	pPivotCache = NULL;
 
 	if( !pCharType )
 	{
@@ -8493,7 +8570,7 @@
                 r.StoreGlobalPosition();
                 while( r.StartNextRecord() )
                 {
-                    r.InitializeRecord( false );
+                    r.ResetRecord( false );
                     sal_uInt16 nRecSize = (sal_uInt16) Min( r.GetRecSize(), nBufLen );
                     aBook << r.GetRecId() << nRecSize;
                     r.Read( pBuffer, nRecSize );
@@ -8503,23 +8580,20 @@
             }
         }
 
-		pPivotCache = pExcRoot->pPivotCacheStorage;
-
 		if( pTitle )
 			*pDumpStream << pTitle->GetBuffer();
 
 		pIn = &r;
         r.StoreGlobalPosition();
-		r.SetWarningMode( bWarnings );
 
         ::std::auto_ptr< ScfProgressBar > pProgress( new ScfProgressBar(
-            pExcRoot->pIR->GetDocShell(), String( RTL_CONSTASCII_USTRINGPARAM( "Dumper" ) ) ) );
-        sal_Int32 nStreamSeg = pProgress->AddSegment( r.GetStreamSize() );
+            GetDocShell(), String( RTL_CONSTASCII_USTRINGPARAM( "Dumper" ) ) ) );
+        sal_Int32 nStreamSeg = pProgress->AddSegment( r.GetSvStreamSize() );
         pProgress->ActivateSegment( nStreamSeg );
 
 		while( r.StartNextRecord() )
 		{
-            pProgress->Progress( r.Tell() );
+            pProgress->Progress( r.GetSvStreamPos() );
 
             if( HasModeDump( r.GetRecId() ) )
                 RecDump();
@@ -8531,17 +8605,22 @@
         pProgress.reset();
 
         r.SeekGlobalPosition();
-		r.SetWarningMode( TRUE );
-
-		pPivotCache = NULL;
 
 		// dump substreams
-        if( pExcRoot->pRootStorage )
+        if( GetRootStorage() )
         {
-            DumpSubStream( pExcRoot->pRootStorage, pUserNamesStreamName );
-            DumpSubStream( pExcRoot->pRootStorage, pRevLogStreamName );
+            pIn = NULL;
+            bool bOldEncr = bEncrypted;
+            bEncrypted = false;
+            DumpSubStream( GetRootStorage(), EXC_STREAM_USERNAMES );
+
+            pIn = &r;
+            bEncrypted = bOldEncr;
+            DumpSubStream( GetRootStorage(), EXC_STREAM_REVLOG );
+
+            pIn = NULL;
 
-            SvStorageStream*    pContrIn = pExcRoot->pRootStorage->OpenStream( _STRINGCONST( "Ctls" ), STREAM_STD_READ );
+            SvStorageStream*    pContrIn = GetRootStorage()->OpenStream( _STRINGCONST( "Ctls" ), STREAM_STD_READ );
             if( pContrIn )
                 ControlsDump( *pContrIn );
         }
Index: sc/source/filter/excel/colrowst.cxx
===================================================================
RCS file: /cvs/sc/sc/source/filter/excel/colrowst.cxx,v
retrieving revision 1.22
retrieving revision 1.22.72.1
diff -w -u -r1.22 -r1.22.72.1
--- sc/source/filter/excel/colrowst.cxx	4 Jun 2004 10:41:40 -0000	1.22
+++ sc/source/filter/excel/colrowst.cxx	16 Jul 2004 17:39:37 -0000	1.22.72.1
@@ -487,6 +487,7 @@
     bChanged = TRUE;
 
     SetWinProtection(false);
+    SetWinEncryption(false);
 }
 
 
@@ -576,6 +577,7 @@
 
     bChanged = rCpy.bChanged;
     bWinProtection = rCpy.bWinProtection;
+    bWinEncryption = rCpy.bWinEncryption;
 
 	return *this;
 }
Index: sc/source/filter/excel/excchart.cxx
===================================================================
RCS file: /cvs/sc/sc/source/filter/excel/excchart.cxx,v
retrieving revision 1.20
retrieving revision 1.20.108.1
diff -w -u -r1.20 -r1.20.108.1
--- sc/source/filter/excel/excchart.cxx	5 Nov 2003 13:31:17 -0000	1.20
+++ sc/source/filter/excel/excchart.cxx	23 Mar 2004 15:41:49 -0000	1.20.108.1
@@ -304,7 +304,7 @@
 void ImportExcel8::ChartEof( void )
 {
     // #90118# be able to read following CONTINUE record as MSODRAWING
-    aIn.InitializeRecord( false );
+    aIn.ResetRecord( false );
     bObjSection = TRUE;
 }
 
Index: sc/source/filter/excel/excel.cxx
===================================================================
RCS file: /cvs/sc/sc/source/filter/excel/excel.cxx,v
retrieving revision 1.13
retrieving revision 1.12.140.3
diff -w -u -r1.13 -r1.12.140.3
--- sc/source/filter/excel/excel.cxx	28 Jun 2004 17:56:06 -0000	1.13
+++ sc/source/filter/excel/excel.cxx	14 Jul 2004 10:15:12 -0000	1.12.140.3
@@ -111,30 +111,6 @@
 void DeInitFuncData();
 
 
-
-static const sal_Char*			pWrkbkNameExcel5 = "Book";
-static const sal_Char*			pWrkbkNameExcel97 = "Workbook";
-const sal_Char*					pPivotCacheStorageName = "_SX_DB_CUR";
-const sal_Char*					pVBAStorageName = "_VBA_PROJECT_CUR";
-const sal_Char*					pVBASubStorageName = "VBA";
-const sal_Char*					pUserNamesStreamName = "User Names";
-const sal_Char*					pRevLogStreamName = "Revision Log";
-
-String lcl_GetDocUrl( const SfxMedium& rMedium )
-{
-    String aDocUrl;
-    if( const SfxStringItem* pItem = (const SfxStringItem*) rMedium.GetItemSet()->GetItem( SID_FILE_NAME ) )
-        aDocUrl = pItem->GetValue();
-    return aDocUrl;
-}
-
-FltError ScImportExcel( SvStream& rStream, ScDocument* pDocument )
-{
-    ImportExcel             aFilter( rStream, pDocument, String() );
-	return aFilter.Read();
-}
-
-
 FltError ScImportExcel( SfxMedium& r, ScDocument* p )
 {
 	return ScImportExcel( r, p, EIF_AUTO );
@@ -151,10 +127,10 @@
     {
         // *** look for contained streams ***
 
-        const String aStreamName5( String::CreateFromAscii( pWrkbkNameExcel5 ) );
+        const String aStreamName5( EXC_STREAM_BOOK );
         sal_Bool bHasBook = pStorage->IsContained( aStreamName5 ) && pStorage->IsStream( aStreamName5 );
 
-        const String aStreamName8( String::CreateFromAscii( pWrkbkNameExcel97 ) );
+        const String aStreamName8( EXC_STREAM_WORKBOOK );
         sal_Bool bHasWorkbook = pStorage->IsContained( aStreamName8 ) && pStorage->IsStream( aStreamName8 );
 
         // *** handle user-defined filter selection ***
@@ -204,7 +180,7 @@
 
         if( (eRet == eERR_OK) && pStreamName )
         {
-            SvStorageStreamRef xStream = pStorage->OpenStream( *pStreamName, STREAM_READ | STREAM_SHARE_DENYALL );
+            SvStorageStreamRef xStream = ScfTools::OpenStorageStreamRead( pStorage, *pStreamName );
             DBG_ASSERT( xStream.Is(), "ScImportExcel - missing stream" );
             xStream->SetBufferSize( 32768 );
 
@@ -222,13 +198,6 @@
             else if( bHasBook && (nVersion == 0x0600) )
                 eBiffDetect = xlBiffDet8;
 
-            //!!! move into filter !!!
-            const String aPvCchStrgNm( String::CreateFromAscii( pPivotCacheStorageName ) );
-            SvStorage* pPivotCacheStorage = NULL;
-            if( eBiffDetect == xlBiffDet8 )
-                pPivotCacheStorage = pStorage->OpenStorage( aPvCchStrgNm, STREAM_STD_READ );
-            //!!! move into filter !!!
-
             // *** and Go! ***
 
             if( eRet == eERR_OK )
@@ -236,9 +205,9 @@
                 ImportExcel* pFilter = NULL;
 
                 if( eBiffDetect == xlBiffDet5 )
-                    pFilter = new ImportExcel( *xStream, pDocument, lcl_GetDocUrl( rMedium ) );
+                    pFilter = new ImportExcel( rMedium, *xStream, pDocument );
                 else if( eBiffDetect == xlBiffDet8 )
-                    pFilter = new ImportExcel8( pStorage, *xStream, pDocument, lcl_GetDocUrl( rMedium ), pPivotCacheStorage );
+                    pFilter = new ImportExcel8( rMedium, *xStream, pDocument );
 
                 if( pFilter )
                     eRet = pFilter->Read();
@@ -263,7 +232,7 @@
             pStream->Seek( 0UL );
             pStream->SetBufferSize( 32768 );
 
-            ImportExcel aFilter( *pStream, pDocument, lcl_GetDocUrl( rMedium ) );
+            ImportExcel aFilter( rMedium, *pStream, pDocument );
             eRet = aFilter.Read();
 
             pStream->SetBufferSize( 0 );
@@ -293,19 +262,19 @@
 FltError ScExportExcel5( SfxMedium &rOutMedium, ScDocument *pDocument,
 	const BOOL bBiff8, CharSet eNach )
 {
-	const sal_Char*				pWrkBook;
+    String                      aWrkBook;
 	const sal_Char*				pClipboard;
 	const sal_Char*				pClassName;
 
 	if( bBiff8 )
 	{
-		pWrkBook = pWrkbkNameExcel97;
+        aWrkBook = EXC_STREAM_WORKBOOK;
 		pClipboard = "Biff8";
 		pClassName = "Microsoft Excel 97-Tabelle";
 	}
 	else
 	{
-		pWrkBook = pWrkbkNameExcel5;
+        aWrkBook = EXC_STREAM_BOOK;
 		pClipboard = "Biff5";
 		pClassName = "Microsoft Excel 5.0-Tabelle";
 	}
@@ -317,8 +286,7 @@
 		SvStorage* pStorage = rOutMedium.GetStorage();
 		if( pStorage )
 		{// OLE2-Datei
-			SvStorageStreamRef	xStStream =
-				pStorage->OpenStream( _STRING( pWrkBook ), STREAM_READWRITE | STREAM_TRUNC );
+            SvStorageStreamRef xStStream = ScfTools::OpenStorageStreamWrite( pStorage, aWrkBook );
 
 			xStStream->SetBufferSize( 32768 );
 
@@ -329,12 +297,12 @@
 
 			if ( bBiff8 )
 			{
-                ExportBiff8     aFilter( *pStorage, *xStStream, xlBiff8, pDocument, lcl_GetDocUrl( rOutMedium ), eNach, bRelUrl );
+                ExportBiff8 aFilter( rOutMedium, *xStStream, xlBiff8, pDocument, eNach, bRelUrl );
 				eRet = aFilter.Write();
 			}
 			else
 			{
-                ExportBiff5     aFilter( *pStorage, *xStStream, xlBiff5, pDocument, lcl_GetDocUrl( rOutMedium ), eNach, bRelUrl );
+                ExportBiff5 aFilter( rOutMedium, *xStStream, xlBiff5, pDocument, eNach, bRelUrl );
 				eRet = aFilter.Write();
 			}
 
Index: sc/source/filter/excel/excform.cxx
===================================================================
RCS file: /cvs/sc/sc/source/filter/excel/excform.cxx,v
retrieving revision 1.27
retrieving revision 1.24.10.2
diff -w -u -r1.27 -r1.24.10.2
--- sc/source/filter/excel/excform.cxx	28 Jun 2004 16:52:55 -0000	1.27
+++ sc/source/filter/excel/excform.cxx	14 Jul 2004 10:15:20 -0000	1.24.10.2
@@ -432,8 +432,7 @@
 				break;
 			case 0x17: // String Constant						[314 266]
 				aIn >> nLen;
-				aString.Erase();
-                aIn.AppendRawByteString( aString, nLen );
+                aString = aIn.ReadRawByteString( nLen );
 
 				aStack << aPool.Store( aString );
 				break;
Index: sc/source/filter/excel/excform8.cxx
===================================================================
RCS file: /cvs/sc/sc/source/filter/excel/excform8.cxx,v
retrieving revision 1.28
retrieving revision 1.26.6.2
diff -w -u -r1.28 -r1.26.6.2
--- sc/source/filter/excel/excform8.cxx	28 Jun 2004 17:56:19 -0000	1.28
+++ sc/source/filter/excel/excform8.cxx	14 Jul 2004 10:15:28 -0000	1.26.6.2
@@ -300,8 +300,7 @@
 				break;
 			case 0x17: // String Constant						[314 266]
 				aIn >> nLen;		// und?
-				aString.Erase();
-                aIn.AppendUniString( aString, nLen ); // reads Grbit even if nLen==0
+                aString = aIn.ReadUniString( nLen );            // reads Grbit even if nLen==0
 
 				aStack << aPool.Store( aString );
 				break;
Index: sc/source/filter/excel/excimp8.cxx
===================================================================
RCS file: /cvs/sc/sc/source/filter/excel/excimp8.cxx,v
retrieving revision 1.93
retrieving revision 1.90.6.5
diff -w -u -r1.93 -r1.90.6.5
--- sc/source/filter/excel/excimp8.cxx	28 Jun 2004 17:56:33 -0000	1.93
+++ sc/source/filter/excel/excimp8.cxx	14 Jul 2004 10:15:37 -0000	1.90.6.5
@@ -162,27 +162,19 @@
 
 using namespace com::sun::star;
 
-extern const sal_Char* pVBAStorageName;
-extern const sal_Char* pVBASubStorageName;
-
-
 
 #define	INVALID_POS		0xFFFFFFFF
 
 
 
 
-ImportExcel8::ImportExcel8( SvStorage* pStorage, SvStream& rStream, ScDocument* pDoc, const String& rDocUrl, SvStorage* pPivotCache ) :
-    ImportExcel( rStream, pDoc, rDocUrl )
+ImportExcel8::ImportExcel8( SfxMedium& rMedium, SvStream& rStream, ScDocument* pDoc ) :
+    ImportExcel( rMedium, rStream, pDoc )
 {
 	delete pFormConv;
 
     pFormConv = pExcRoot->pFmlaConverter = new ExcelToSc8( pExcRoot, aIn );
 
-	pExcRoot->pPivotCacheStorage = pPivotCache;
-
-	pExcRoot->pRootStorage = pStorage;
-
 	bHasBasic = FALSE;
 }
 
@@ -538,14 +530,13 @@
 		{
 			if( pFiltOpt->IsLoadExcelBasicCode() || pFiltOpt->IsLoadExcelBasicStorage() )
 			{
-				DBG_ASSERT( pExcRoot->pRootStorage, "-ImportExcel8::PostDocLoad(): no storage, no cookies!" );
+                DBG_ASSERT( GetRootStorage(), "-ImportExcel8::PostDocLoad(): no storage, no cookies!" );
 
-                SvxImportMSVBasic   aBasicImport( *pShell, *pExcRoot->pRootStorage,
+                SvxImportMSVBasic   aBasicImport( *pShell, *GetRootStorage(),
 													pFiltOpt->IsLoadExcelBasicCode(),
 													pFiltOpt->IsLoadExcelBasicStorage() );
 
-				aBasicImport.Import( String::CreateFromAscii( pVBAStorageName ),
-									 String::CreateFromAscii( pVBASubStorageName ) );
+                aBasicImport.Import( EXC_STORAGE_VBA_PROJECT, EXC_STORAGE_VBA );
 			}
 		}
 	}
@@ -557,7 +548,7 @@
         SfxDocumentInfo     aNewDocInfo;
         SfxDocumentInfo&    rOldDocInfo = pShell->GetDocInfo();
 
-        aNewDocInfo.LoadPropertySet( pExcRoot->pRootStorage );
+        aNewDocInfo.LoadPropertySet( GetRootStorage() );
 
         rOldDocInfo = aNewDocInfo;
         pShell->Broadcast( SfxDocumentInfoHint( &rOldDocInfo ) );
Index: sc/source/filter/excel/excobj.cxx
===================================================================
RCS file: /cvs/sc/sc/source/filter/excel/excobj.cxx,v
retrieving revision 1.32
retrieving revision 1.31.6.2
diff -w -u -r1.32 -r1.31.6.2
--- sc/source/filter/excel/excobj.cxx	4 Jun 2004 10:43:09 -0000	1.32
+++ sc/source/filter/excel/excobj.cxx	14 Jul 2004 10:15:45 -0000	1.31.6.2
@@ -424,7 +424,7 @@
 	UINT16	nId;
 	aIn >> nId;
 	if( pChart )
-        aIn.AppendByteString( pChart->aLastLabel, FALSE );
+        pChart->aLastLabel = aIn.ReadByteString( false );
 }
 
 
Index: sc/source/filter/excel/exctools.cxx
===================================================================
RCS file: /cvs/sc/sc/source/filter/excel/exctools.cxx,v
retrieving revision 1.48
retrieving revision 1.44.4.3
diff -w -u -r1.48 -r1.44.4.3
--- sc/source/filter/excel/exctools.cxx	28 Jun 2004 17:57:05 -0000	1.48
+++ sc/source/filter/excel/exctools.cxx	14 Jul 2004 10:16:03 -0000	1.44.4.3
@@ -120,12 +120,10 @@
 	bBreakSharedFormula = TRUE;
     bChartTab = FALSE;
 
-	pRootStorage = pPivotCacheStorage = /*pCtrlStorage = */NULL;
     pAutoFilterBuffer = NULL;
     pPrintRanges = new _ScRangeListTabs;
     pPrintTitles = new _ScRangeListTabs;
 
-	pRootStorage = NULL;
 	pTabId = NULL;
 	pUserBViewList = NULL;
 	pCellMerging = NULL;
Index: sc/source/filter/excel/expop2.cxx
===================================================================
RCS file: /cvs/sc/sc/source/filter/excel/expop2.cxx,v
retrieving revision 1.18
retrieving revision 1.17.6.3
diff -w -u -r1.18 -r1.17.6.3
--- sc/source/filter/excel/expop2.cxx	4 Jun 2004 10:43:59 -0000	1.18
+++ sc/source/filter/excel/expop2.cxx	14 Jul 2004 10:16:15 -0000	1.17.6.3
@@ -93,17 +93,11 @@
 #include "xelink.hxx"
 #endif
 
-extern const sal_Char*	pVBAStorageName;
-extern const sal_Char*	pVBASubStorageName;
 
-
-
-
-ExportBiff5::ExportBiff5( SvStorage& rRootStorage, SvStream& aStream, XclBiff eBiff, ScDocument* pDoc, const String& rBasePath, CharSet eDest, bool bRelUrl ):
-    XclExpRootData( eBiff, *pDoc, rBasePath, eDest, bRelUrl ),
+ExportBiff5::ExportBiff5( SfxMedium& rMedium, SvStream& aStream, XclBiff eBiff, ScDocument* pDoc, CharSet eDest, bool bRelUrl ):
+    XclExpRootData( eBiff, rMedium, *pDoc, eDest, bRelUrl ),
     ExportTyp( aStream, pDoc, eDest ),
     XclExpRoot( static_cast< XclExpRootData& >( *this ) )
-	// Excel immer Windoofs, Quelle (SC) immer System
 {
 	DBG_ASSERT( pDoc, "-ExportBiff5::ExportBiff5(): No Null-Document!" );
 
@@ -117,7 +111,6 @@
 	pExcRoot->eDateiTyp = Biff5;
 	pExcRoot->nColMax = static_cast<SCCOL>(XCL_COLMAX);
 	pExcRoot->nRowMax = static_cast<SCROW>(EXC5_ANZROW);
-	pExcRoot->pRootStorage = &rRootStorage;
 
 	pExcRoot->pCharset = &eZielChar;
 
@@ -144,7 +137,6 @@
 {
 	FltError				eRet = eERR_OK;
 	SvtFilterOptions*		pFiltOpt = NULL;
-	SvStorage*				pRootStorage = pExcRoot->pRootStorage;
 
     if( pExcRoot->eHauptDateiTyp >= Biff8 )
 	{
@@ -159,27 +151,27 @@
 	{
 		SfxObjectShell&		rDocShell = *pExcRoot->pDoc->GetDocumentShell();
 
-		DBG_ASSERT( pExcRoot->pRootStorage, "-ImportExcel8::ImportExcel8(): no storage, no cookies!" );
+        DBG_ASSERT( GetRootStorage(), "ExportBiff5::Write - no storage" );
 
 		SvxImportMSVBasic	aBasicImport(	rDocShell,
-											*pRootStorage,
+                                            *GetRootStorage(),
 											pFiltOpt->IsLoadExcelBasicCode(),
 											pFiltOpt->IsLoadExcelBasicStorage() );
 
-		ULONG		nErr = aBasicImport.SaveOrDelMSVBAStorage( TRUE, _STRING( pVBAStorageName ) );
+        ULONG       nErr = aBasicImport.SaveOrDelMSVBAStorage( TRUE, EXC_STORAGE_VBA_PROJECT );
 
 		if( nErr != ERRCODE_NONE )
 			rDocShell.SetError( nErr );
 	}
 
 	// VBA-storage written?
-	pExcRoot->bWriteVBAStorage = pRootStorage->IsContained( _STRING( pVBAStorageName ) );
+    pExcRoot->bWriteVBAStorage = GetRootStorage()->IsContained( EXC_STORAGE_VBA_PROJECT );
 
 	pExcDoc->ReadDoc();			// ScDoc -> ExcDoc
 	pExcDoc->Write( aOut );		// wechstreamen
 
 	SfxDocumentInfo&	rInfo = rDocShell.GetDocInfo();
-	rInfo.SavePropertySet( pExcRoot->pRootStorage );
+    rInfo.SavePropertySet( GetRootStorage() );
 
     if( pExcRoot->bCellCut || IsTruncated() )
 		return SCWARN_EXPORT_MAXROW;
@@ -189,8 +181,8 @@
 
 
 
-ExportBiff8::ExportBiff8( SvStorage& rRootStorage, SvStream& aStream, XclBiff eBiff, ScDocument* pDoc, const String& rBasePath, CharSet eZ, bool bRelUrl ) :
-    ExportBiff5( rRootStorage, aStream, eBiff, pDoc, rBasePath, eZ, bRelUrl )
+ExportBiff8::ExportBiff8( SfxMedium& rMedium, SvStream& aStream, XclBiff eBiff, ScDocument* pDoc, CharSet eZ, bool bRelUrl ) :
+    ExportBiff5( rMedium, aStream, eBiff, pDoc, eZ, bRelUrl )
 {
 	pExcRoot->eHauptDateiTyp = Biff8;
 	pExcRoot->eDateiTyp = Biff8;
Index: sc/source/filter/excel/impop.cxx
===================================================================
RCS file: /cvs/sc/sc/source/filter/excel/impop.cxx,v
retrieving revision 1.61
retrieving revision 1.60.4.6
diff -w -u -r1.61 -r1.60.4.6
--- sc/source/filter/excel/impop.cxx	4 Jun 2004 10:44:32 -0000	1.61
+++ sc/source/filter/excel/impop.cxx	14 Jul 2004 10:16:45 -0000	1.60.4.6
@@ -195,8 +195,8 @@
 
 
 
-ImportExcel::ImportExcel( SvStream& rSvStrm, ScDocument* pDoc, const String& rDocUrl ):
-    XclImpRootData( xlBiffUnknown, *pDoc, rDocUrl, RTL_TEXTENCODING_MS_1252 ),
+ImportExcel::ImportExcel( SfxMedium& rMedium, SvStream& rSvStrm, ScDocument* pDoc ):
+    XclImpRootData( xlBiffUnknown, rMedium, *pDoc, RTL_TEXTENCODING_MS_1252 ),
     ImportTyp( pDoc, RTL_TEXTENCODING_MS_1252 ),
     XclImpRoot( static_cast< XclImpRootData& >( *this ) ),
     maStrm( rSvStrm, *this ),
@@ -507,15 +507,10 @@
 void ImportExcel::Bof2( void )
 {
     sal_uInt16 nSubType;
-#if SC_XCL_USEDECR
-    maStrm.UseDecryption( false );
-#endif
+    maStrm.DisableDecryption();
     maStrm.Ignore( 2 );
     maStrm >> nSubType;
     SetBiff( xlBiff2 );
-#if SC_XCL_USEDECR
-    maStrm.UseDecryption( true );
-#endif
 
 	pExcRoot->eHauptDateiTyp = Biff2;
     if( nSubType == 0x0010 )        // Worksheet?
@@ -553,9 +548,9 @@
 
 void ImportExcel::Externsheet( void )
 {
-    String aEncodedUrl, aUrl, aTabName;
+    String aUrl, aTabName;
     bool bSameWorkBook;
-    aIn.AppendByteString( aEncodedUrl, false );
+    String aEncodedUrl( aIn.ReadByteString( false ) );
     XclImpUrlHelper::DecodeUrl( aUrl, aTabName, bSameWorkBook, *pExcRoot->pIR, aEncodedUrl );
     ScfTools::ConvertToScSheetName( aTabName );
     pExcRoot->pExtSheetBuff->Add( aUrl, aTabName, bSameWorkBook );
@@ -764,41 +759,6 @@
 }
 
 
-BOOL ImportExcel::Filepass( void )
-{
-#if SC_XCL_USEDECR
-    if( pExcRoot->eHauptDateiTyp <= Biff5 )
-    {
-        aIn.UseDecryption( false );
-        sal_uInt16 nKey, nHash;
-        aIn >> nKey >> nHash;
-
-        bool bValid = (maPassword.Len() > 0);
-        if( !bValid )
-        {
-            if( (nKey == 0xB359) && (nHash == 0x9A0A) )
-            {
-                // Workbook protection -> password is encoded in PASSWORD record
-                maPassword.AssignAscii( "VelvetSweatshop" );
-                bValid = true;
-            }
-        }
-
-        if( bValid )
-        {
-            XclImpBiff5Decrypter* pDecrypter = new XclImpBiff5Decrypter( maPassword, nKey, nHash );
-            bValid = pDecrypter->IsValid();     // validates password
-            aIn.EnableDecryption( pDecrypter );
-        }
-        return !bValid;
-    }
-    else
-#endif
-        // POST: return = TRUE, wenn Password <> 0
-        return aIn.ReaduInt32() != 0;
-}
-
-
 void ImportExcel::Pane( void )
 {
     pColRowBuff->ReadSplit( aIn );
@@ -1296,15 +1256,10 @@
 void ImportExcel::Bof3( void )
 {
     sal_uInt16 nSubType;
-#if SC_XCL_USEDECR
-    maStrm.UseDecryption( false );
-#endif
+    maStrm.DisableDecryption();
     maStrm.Ignore( 2 );
     maStrm >> nSubType;
     SetBiff( xlBiff3 );
-#if SC_XCL_USEDECR
-    maStrm.UseDecryption( true );
-#endif
 
     DBG_ASSERT( nSubType != 0x0100, "*ImportExcel::Bof3(): Biff3 als Workbook?!" );
 	pExcRoot->eHauptDateiTyp = Biff3;
@@ -1505,15 +1460,10 @@
 void ImportExcel::Bof4( void )
 {
     sal_uInt16 nSubType;
-#if SC_XCL_USEDECR
-    maStrm.UseDecryption( false );
-#endif
+    maStrm.DisableDecryption();
     maStrm.Ignore( 2 );
     maStrm >> nSubType;
     SetBiff( xlBiff4 );
-#if SC_XCL_USEDECR
-    maStrm.UseDecryption( true );
-#endif
 
 	pExcRoot->eHauptDateiTyp = Biff4;
     if( nSubType == 0x0010 )        // Sheet?
@@ -1539,15 +1489,10 @@
 	BiffTyp		eHaupt = Biff5;
 	BiffTyp		eDatei;
 
-#if SC_XCL_USEDECR
-    maStrm.UseDecryption( false );
-#endif
+    maStrm.DisableDecryption();
     maStrm >> nVers >> nSubType;
     if( nSubType == 0x0005 )    // nVers may be wrong in Worksheet BOFs
         SetBiff( (nVers == 0x0600) ? xlBiff8 : xlBiff5 );
-#if SC_XCL_USEDECR
-    maStrm.UseDecryption( true );
-#endif
 
 	switch( nSubType )
 	{
Index: sc/source/filter/excel/makefile.mk
===================================================================
RCS file: /cvs/sc/sc/source/filter/excel/makefile.mk,v
retrieving revision 1.25
retrieving revision 1.24.60.2
diff -w -u -r1.25 -r1.24.60.2
--- sc/source/filter/excel/makefile.mk	4 Jun 2004 14:00:14 -0000	1.25
+++ sc/source/filter/excel/makefile.mk	14 Jul 2004 10:16:53 -0000	1.24.60.2
@@ -81,6 +81,7 @@
 # --- Files --------------------------------------------------------
 
 SLOFILES =	\
+		$(SLO)$/xlstream.obj				\
 		$(SLO)$/xltools.obj					\
 		$(SLO)$/xlroot.obj					\
 		$(SLO)$/xlstyle.obj					\
Index: sc/source/filter/excel/read.cxx
===================================================================
RCS file: /cvs/sc/sc/source/filter/excel/read.cxx,v
retrieving revision 1.43
retrieving revision 1.42.6.5
diff -w -u -r1.43 -r1.42.6.5
--- sc/source/filter/excel/read.cxx	4 Jun 2004 14:00:29 -0000	1.43
+++ sc/source/filter/excel/read.cxx	14 Jul 2004 10:13:35 -0000	1.42.6.5
@@ -118,7 +118,7 @@
 {
 #if EXC_INCL_DUMPER
 	{
-        Biff8RecDumper aDumper( *pExcRoot, FALSE );
+        Biff8RecDumper aDumper( GetRoot(), FALSE );
 		if( aDumper.Dump( aIn ) )
 			return eERR_OK;
 	}
@@ -161,7 +161,7 @@
 	DBG_ASSERT( &aIn != NULL, "-ImportExcel::Read(): Kein Stream - wie dass?!" );
 
     ::std::auto_ptr< ScfSimpleProgressBar > pProgress( new ScfSimpleProgressBar(
-        aIn.GetStreamSize(), GetDocShell(), STR_LOAD_DOC ) );
+        aIn.GetSvStreamSize(), GetDocShell(), STR_LOAD_DOC ) );
 
 	while( eAkt != Z_Ende )
 	{
@@ -175,7 +175,7 @@
 		}
 
 		if( eAkt != Z_Biff5Pre && eAkt != Z_Biff5WPre )
-            pProgress->Progress( aIn.Tell() );
+            pProgress->Progress( aIn.GetSvStreamPos() );
 
 		switch( eAkt )
 		{
@@ -269,11 +269,9 @@
                     case 0x2A:  GetPageSettings().ReadPrintheaders( maStrm );   break;
                     case 0x2B:  GetPageSettings().ReadPrintgridlines( maStrm ); break;
 					case 0x2F:							// FILEPASS		[ 2345]
-						if( Filepass() )
-						{
-							eLastErr = eERR_FILEPASSWD;
+                        eLastErr = XclImpDecryptHelper::ReadFilepass( maStrm );
+                        if( eLastErr != ERRCODE_NONE )
 							eAkt = Z_Ende;
-						}
 						break;
                     case 0x31:  GetFontBuffer().ReadFont( maStrm );             break;
 					case 0x41:	Pane(); break;			// PANE			[ 2345]
@@ -310,11 +308,9 @@
                     case 0x2A:  GetPageSettings().ReadPrintheaders( maStrm );   break;
                     case 0x2B:  GetPageSettings().ReadPrintgridlines( maStrm ); break;
 					case 0x2F:							// FILEPASS		[ 2345]
-						if( Filepass() )
-						{
-							eLastErr = eERR_FILEPASSWD;
+                        eLastErr = XclImpDecryptHelper::ReadFilepass( maStrm );
+                        if( eLastErr != ERRCODE_NONE )
 							eAkt = Z_Ende;
-						}
 						break;
 					case 0x41:	Pane(); break;			// PANE			[ 2345]
 					case 0x42:	Codepage(); break;		// CODEPAGE		[ 2345]
@@ -368,11 +364,10 @@
                     case 0x2A:  GetPageSettings().ReadPrintheaders( maStrm );   break;
                     case 0x2B:  GetPageSettings().ReadPrintgridlines( maStrm ); break;
 					case 0x2F:							// FILEPASS		[ 2345]
-						if( Filepass() )
-						{
-							eLastErr = eERR_FILEPASSWD;
+                        eLastErr = XclImpDecryptHelper::ReadFilepass( maStrm );
+                        if( eLastErr != ERRCODE_NONE )
 							eAkt = Z_Ende;
-						}
+                        break;
 					case 0x41:	Pane(); break;			// PANE			[ 2345]
 					case 0x42:	Codepage(); break;		// CODEPAGE		[ 2345]
 					case 0x55:	DefColWidth(); break;
@@ -413,11 +408,9 @@
 						break;
 					case 0x12:	DocProtect(); break;	// PROTECT		[    5]
 					case 0x2F:							// FILEPASS		[ 2345]
-						if( Filepass() )
-						{
-							eLastErr = eERR_FILEPASSWD;
+                        eLastErr = XclImpDecryptHelper::ReadFilepass( maStrm );
+                        if( eLastErr != ERRCODE_NONE )
 							eAkt = Z_Ende;
-						}
 						break;
 					case 0x17:	Externsheet(); break;	// EXTERNSHEET	[ 2345]
 					case 0x42:	Codepage(); break;		// CODEPAGE		[ 2345]
@@ -469,11 +462,9 @@
 						break;
 					case 0x1D:	Selection(); break;		// SELECTION	[ 2345]
 					case 0x2F:							// FILEPASS		[ 2345]
-						if( Filepass() )
-						{
-							eLastErr = eERR_FILEPASSWD;
+                        eLastErr = XclImpDecryptHelper::ReadFilepass( maStrm );
+                        if( eLastErr != ERRCODE_NONE )
 							eAkt = Z_Ende;
-						}
 						break;
 					case 0x41:	Pane(); break;			// PANE			[ 2345]
 					case 0x42:	Codepage(); break;		// CODEPAGE		[ 2345]
@@ -586,11 +577,9 @@
 						break;
 					case 0x12:	DocProtect(); break;	// PROTECT		[    5]
 					case 0x2F:							// FILEPASS		[ 2345]
-						if( Filepass() )
-						{
-							eLastErr = eERR_FILEPASSWD;
+                        eLastErr = XclImpDecryptHelper::ReadFilepass( maStrm );
+                        if( eLastErr != ERRCODE_NONE )
 							eAkt = Z_Ende;
-						}
 						break;
 					case 0x42:	Codepage(); break;		// CODEPAGE		[ 2345]
 					case 0x85:	Boundsheet(); break;	// BOUNDSHEET	[    5]
@@ -612,13 +601,6 @@
                     case 0x1E:  GetNumFmtBuffer().ReadFormat( maStrm );         break;
 					case 0x22:	Rec1904(); break;		// 1904			[ 2345]
 					case 0x25:	Defrowheight2(); break;	// DEFAULTROWHEI[ 2   ]
-                    case 0x2F:                          // FILEPASS     [ 2345]
-                        if( Filepass() )
-                        {
-                            eLastErr = eERR_FILEPASSWD;
-                            eAkt = Z_Ende;
-                        }
-                        break;
                     case 0x31:  GetFontBuffer().ReadFont( maStrm );             break;
 					case 0x42:	Codepage(); break;		// CODEPAGE		[ 2345]
 					case 0x55:	DefColWidth(); break;
@@ -681,11 +663,9 @@
                     case 0x2A:  GetPageSettings().ReadPrintheaders( maStrm );   break;
                     case 0x2B:  GetPageSettings().ReadPrintgridlines( maStrm ); break;
                     case 0x2F:                          // FILEPASS     [ 2345]
-                        if( Filepass() )
-                        {
-                            eLastErr = eERR_FILEPASSWD;
+                        eLastErr = XclImpDecryptHelper::ReadFilepass( maStrm );
+                        if( eLastErr != ERRCODE_NONE )
                             eAkt = Z_Ende;
-                        }
                         break;
 					case 0x5D:
 						if( bWithDrawLayer )
@@ -1014,7 +994,7 @@
 {
 #if EXC_INCL_DUMPER
     {
-        Biff8RecDumper aDumper( *pExcRoot, TRUE );
+        Biff8RecDumper aDumper( GetRoot(), TRUE );
         if( aDumper.Dump( aIn ) )
             return eERR_OK;
     }
@@ -1046,7 +1026,7 @@
 		"-ImportExcel8::Read(): Kein Stream - wie dass?!" );
 
     ::std::auto_ptr< ScfSimpleProgressBar > pProgress( new ScfSimpleProgressBar(
-        aIn.GetStreamSize(), GetDocShell(), STR_LOAD_DOC ) );
+        aIn.GetSvStreamSize(), GetDocShell(), STR_LOAD_DOC ) );
 
     bObjSection = FALSE;
 
@@ -1061,11 +1041,11 @@
 		}
 
 		if( eAkt != Z_Biff8Pre && eAkt != Z_Biff8WPre )
-            pProgress->Progress( aIn.Tell() );
+            pProgress->Progress( aIn.GetSvStreamPos() );
 
         if( nOpcode != EXC_ID_CONT )
         {
-            aIn.InitializeRecord( TRUE );       // enable internal CONTINUE handling
+            aIn.ResetRecord( true );            // enable internal CONTINUE handling
             bObjSection =
                 (nOpcode == 0x005D) ||          // OBJ
                 (nOpcode == 0x00EB) ||          // MSODRAWINGGROUP
@@ -1110,12 +1090,9 @@
 					case 0x12:	DocProtect(); break;	// PROTECT		[    5678]
 					case 0x19:  WinProtection(); break;
 					case 0x2F:							// FILEPASS		[ 2345   ]
-						if( Filepass() )
-						{
-							GetTracer().TraceLog(ePassword);
-            				eLastErr = eERR_FILEPASSWD;
+                        eLastErr = XclImpDecryptHelper::ReadFilepass( maStrm );
+                        if( eLastErr != ERRCODE_NONE )
 							eAkt = Z_Ende;
-						}
 						break;
 					case 0x42:	Codepage(); break;		// CODEPAGE		[ 2345   ]
 					case 0x85:	Boundsheet(); break;	// BOUNDSHEET	[    5   ]
@@ -1336,15 +1313,6 @@
                             IncCurrScTab();
 						}
 						break;
-						case 0x002F:							// FILEPASS		[ 2345   ]
-						{
-							if( Filepass() )
-							{
-								eLastErr = eERR_FILEPASSWD;
-								eAkt = Z_Ende;
-							}
-						}
-						break;
 						default:	bFound = FALSE;
 					}
 				}
@@ -1481,7 +1449,7 @@
         PostDocLoad();
 
         // import change tracking data
-        XclImpChangeTrack aImpChTr( pExcRoot );
+        XclImpChangeTrack aImpChTr( pExcRoot, maStrm );
         aImpChTr.Apply();
 
         if( bTabTruncated || IsTruncated() )
@@ -1512,7 +1480,7 @@
 			if( bLoop )
                 bLoop = (aIn.GetRecId() != 0x000A);
 		}
-        rProgress.Progress( aIn.Tell() );
+        rProgress.Progress( aIn.GetSvStreamPos() );
 
 		return eERR_OK;
 	}
@@ -1523,7 +1491,7 @@
 		bLoop = aIn.StartNextRecord();
         nOpcode = aIn.GetRecId();
 
-        rProgress.Progress( aIn.Tell() );
+        rProgress.Progress( aIn.GetSvStreamPos() );
 
         // page settings - only for charts in entire sheet
         if( bOwnTab ) switch( nOpcode )
Index: sc/source/filter/excel/xepivot.cxx
===================================================================
RCS file: /cvs/sc/sc/source/filter/excel/xepivot.cxx,v
retrieving revision 1.2
retrieving revision 1.2.72.3
diff -w -u -r1.2 -r1.2.72.3
--- sc/source/filter/excel/xepivot.cxx	4 Jun 2004 14:01:19 -0000	1.2
+++ sc/source/filter/excel/xepivot.cxx	15 Jul 2004 08:56:59 -0000	1.2.72.3
@@ -117,9 +117,6 @@
 #include "xelink.hxx"
 #endif
 
-#include "root.hxx"
-extern const sal_Char*  pPivotCacheStorageName;
-
 using ::com::sun::star::sheet::DataPilotFieldOrientation;
 using ::com::sun::star::sheet::DataPilotFieldOrientation_HIDDEN;
 using ::com::sun::star::sheet::DataPilotFieldOrientation_ROW;
@@ -442,7 +439,7 @@
         GetDoc().GetDataStart( nScTab, nFirstDocCol, nFirstDocRow );
         GetDoc().GetPrintArea( nScTab, nLastDocCol, nLastDocRow, false );
         SCCOL nFirstSrcCol = maSrcRange.aStart.Col(), nLastSrcCol = maSrcRange.aEnd.Col();
-        SCCOL nFirstSrcRow = maSrcRange.aStart.Row(), nLastSrcRow = maSrcRange.aEnd.Row();
+        SCROW nFirstSrcRow = maSrcRange.aStart.Row(), nLastSrcRow = maSrcRange.aEnd.Row();
 
         // adjust row indexes, keep one row of empty area to add an empty cache item
         if( nFirstSrcRow < nFirstDocRow )
@@ -524,12 +521,8 @@
 
 void XclExpPivotCache::WriteCacheStream()
 {
-    if( !mpRD->pPivotCacheStorage )
-        mpRD->pPivotCacheStorage =
-            GetRootStorage()->OpenStorage(
-                String::CreateFromAscii(pPivotCacheStorageName), STREAM_STD_WRITE );
-    SvStorageStreamRef xSvStrm = mpRD->pPivotCacheStorage->OpenStream(
-        ScfTools::GetHexStr( mnStrmId ), STREAM_READWRITE | STREAM_TRUNC );
+    SvStorageRef xSvStrg = OpenStorage( EXC_STORAGE_PTCACHE );
+    SvStorageStreamRef xSvStrm = OpenStream( xSvStrg, ScfTools::GetHexStr( mnStrmId ) );
     if( xSvStrm.Is() )
     {
         XclExpStream aStrm( *xSvStrm, GetRoot() );
Index: sc/source/filter/excel/xeroot.cxx
===================================================================
RCS file: /cvs/sc/sc/source/filter/excel/xeroot.cxx,v
retrieving revision 1.10
retrieving revision 1.9.6.3
diff -w -u -r1.10 -r1.9.6.3
--- sc/source/filter/excel/xeroot.cxx	4 Jun 2004 14:01:37 -0000	1.10
+++ sc/source/filter/excel/xeroot.cxx	14 Jul 2004 10:18:23 -0000	1.9.6.3
@@ -65,6 +65,10 @@
 #include "xeroot.hxx"
 #endif
 
+#ifndef _SVSTOR_HXX
+#include <so3/svstor.hxx>
+#endif
+
 #ifndef SC_ADDINCOL_HXX
 #include "addincol.hxx"
 #endif
@@ -85,11 +89,10 @@
 #include "xepivot.hxx"
 #endif
 
-
 // Global data ================================================================
 
-XclExpRootData::XclExpRootData( XclBiff eBiff, ScDocument& rDocument, const String& rDocUrl, CharSet eCharSet, bool bRelUrl ) :
-    XclRootData( eBiff, rDocument, rDocUrl, eCharSet ),
+XclExpRootData::XclExpRootData( XclBiff eBiff, SfxMedium& rMedium, ScDocument& rDocument, CharSet eCharSet, bool bRelUrl ) :
+    XclRootData( eBiff, rMedium, rDocument, eCharSet, true ),
     mbRelUrl( bRelUrl )
 {
 }
@@ -98,14 +101,12 @@
 {
 }
 
-
 // ----------------------------------------------------------------------------
 
 XclExpRoot::XclExpRoot( XclExpRootData& rExpRootData ) :
     XclRoot( rExpRootData ),
     mrExpData( rExpRootData )
 {
-    mrExpData.mpTracer.reset( new XclTracer( GetDocUrl(), CREATE_OUSTRING( "Office.Tracing/Export/Excel" ) ) );
     mrExpData.mpPalette.reset( new XclExpPalette( GetRoot() ) );
     mrExpData.mpFontBuffer.reset( new XclExpFontBuffer( GetRoot() ) );
     mrExpData.mpNumFmtBuffer.reset( new XclExpNumFmtBuffer( GetRoot() ) );
@@ -182,7 +183,6 @@
 {
     XclRoot::CheckCellRangeList( rRanges, GetXclMaxPos() );
 }
-
 
 // ============================================================================
 
Index: sc/source/filter/excel/xicontent.cxx
===================================================================
RCS file: /cvs/sc/sc/source/filter/excel/xicontent.cxx,v
retrieving revision 1.10
retrieving revision 1.8.6.3
diff -w -u -r1.10 -r1.8.6.3
--- sc/source/filter/excel/xicontent.cxx	4 Jun 2004 14:01:53 -0000	1.10
+++ sc/source/filter/excel/xicontent.cxx	14 Jul 2004 10:18:32 -0000	1.8.6.3
@@ -213,7 +211,7 @@
 void lclAppendString32( String& rString, XclImpStream& rStrm, sal_uInt32 nChars, bool b16Bit )
 {
     sal_uInt16 nReadChars = static_cast< sal_uInt16 >( ::std::min( nChars, 0xFFFFUL ) );
-    rStrm.AppendRawUniString( rString, nReadChars, b16Bit );
+    rString.Append( rStrm.ReadRawUniString( nReadChars, b16Bit ) );
     // ignore remaining chars
     sal_uInt32 nIgnore = nChars - nReadChars;
     if( b16Bit )
@@ -713,15 +706,13 @@
     rStrm >> nFlags;
 
     // message strings
-    String aPromptTitle, aErrorTitle, aPromptMessage, aErrorMessage;
-
     /*  Empty strings are single NUL characters in Excel (string length is 1).
         -> Do not let the stream replace them with '?' characters. */
     rStrm.SetNulSubstChar( '\0' );
-    rStrm.AppendUniString( aPromptTitle );
-    rStrm.AppendUniString( aErrorTitle );
-    rStrm.AppendUniString( aPromptMessage );
-    rStrm.AppendUniString( aErrorMessage );
+    String aPromptTitle(   rStrm.ReadUniString() );
+    String aErrorTitle(    rStrm.ReadUniString() );
+    String aPromptMessage( rStrm.ReadUniString() );
+    String aErrorMessage(  rStrm.ReadUniString() );
     rStrm.SetNulSubstChar();    // back to default
 
     // formula(s)
@@ -873,8 +863,7 @@
 
 void XclImpWebQuery::ReadWqstring( XclImpStream& rStrm )
 {
-    maURL.Erase();
-    rStrm.AppendUniString( maURL );
+    maURL = rStrm.ReadUniString();
 }
 
 void XclImpWebQuery::ReadWqsettings( XclImpStream& rStrm )
@@ -893,9 +882,8 @@
 {
     if( meMode == xlWQSpecTables )
 	{
-        String aTables;
         rStrm.Ignore( 4 );
-        rStrm.AppendUniString( aTables );
+        String aTables( rStrm.ReadUniString() );
 
         const sal_Unicode cSep = ';';
         aTables.SearchAndReplaceAll( ',', cSep );
@@ -938,8 +925,7 @@
     if( GetBiff() == xlBiff8 )
     {
         rStrm.Ignore( 10 );
-        String aXclName;
-        rStrm.AppendUniString( aXclName );
+        String aXclName( rStrm.ReadUniString() );
 
         // #101529# find the defined name used in Calc
         if( const XclImpName* pName = GetNameBuffer().FindName( aXclName, GetCurrScTab() ) )
@@ -992,6 +978,108 @@
         pQuery->Apply( rDoc, aFilterName );
 }
 
+// Decryption =================================================================
+
+namespace {
+
+XclImpDecrypterRef lclReadFilepass5( XclImpStream& rStrm )
+{
+    XclImpDecrypterRef xDecr;
+    DBG_ASSERT( rStrm.GetRecLeft() == 4, "lclReadFilepass5 - wrong record size" );
+    if( rStrm.GetRecLeft() == 4 )
+    {
+        sal_uInt16 nKey, nHash;
+        rStrm >> nKey >> nHash;
+        xDecr.reset( new XclImpBiff5Decrypter( rStrm.GetRoot(), nKey, nHash ) );
+    }
+    return xDecr;
+}
+
+XclImpDecrypterRef lclReadFilepass8_Standard( XclImpStream& rStrm )
+{
+    XclImpDecrypterRef xDecr;
+    DBG_ASSERT( rStrm.GetRecLeft() == 48, "lclReadFilepass8 - wrong record size" );
+    if( rStrm.GetRecLeft() == 48 )
+    {
+        sal_uInt8 pnDocId[ 16 ];
+        sal_uInt8 pnSaltData[ 16 ];
+        sal_uInt8 pnSaltHash[ 16 ];
+        rStrm.Read( pnDocId, 16 );
+        rStrm.Read( pnSaltData, 16 );
+        rStrm.Read( pnSaltHash, 16 );
+        xDecr.reset( new XclImpBiff8Decrypter(
+            rStrm.GetRoot(), pnDocId, pnSaltData, pnSaltHash ) );
+    }
+    return xDecr;
+}
+
+XclImpDecrypterRef lclReadFilepass8_Strong( XclImpStream& rStrm )
+{
+    // not supported
+    return XclImpDecrypterRef();
+}
+
+XclImpDecrypterRef lclReadFilepass8( XclImpStream& rStrm )
+{
+    XclImpDecrypterRef xDecr;
+
+    sal_uInt16 nMode;
+    rStrm >> nMode;
+    switch( nMode )
+    {
+        case EXC_FILEPASS_BIFF5:
+            xDecr = lclReadFilepass5( rStrm );
+        break;
+
+        case EXC_FILEPASS_BIFF8:
+        {
+            rStrm.Ignore( 2 );
+            sal_uInt16 nSubMode;
+            rStrm >> nSubMode;
+            switch( nSubMode )
+            {
+                case EXC_FILEPASS_BIFF8_STD:
+                    xDecr = lclReadFilepass8_Standard( rStrm );
+                break;
+                case EXC_FILEPASS_BIFF8_STRONG:
+                    xDecr = lclReadFilepass8_Strong( rStrm );
+                break;
+                default:
+                    DBG_ERRORFILE( "lclReadFilepass8 - unknown BIFF8 encryption sub mode" );
+            }
+        }
+        break;
+
+        default:
+            DBG_ERRORFILE( "lclReadFilepass8 - unknown encryption mode" );
+    }
+
+    return xDecr;
+}
+
+} // namespace
+
+// ----------------------------------------------------------------------------
+
+ErrCode XclImpDecryptHelper::ReadFilepass( XclImpStream& rStrm )
+{
+    XclImpDecrypterRef xDecr;
+    rStrm.DisableDecryption();
+
+    switch( rStrm.GetRoot().GetBiff() )
+    {
+        case xlBiff2:
+        case xlBiff3:
+        case xlBiff4:
+        case xlBiff5:
+        case xlBiff7:   xDecr = lclReadFilepass5( rStrm );  break;
+        case xlBiff8:   xDecr = lclReadFilepass8( rStrm );  break;
+        default:        DBG_ERROR_BIFF();
+    };
+    rStrm.SetDecrypter( xDecr );
+
+    return xDecr.get() ? xDecr->GetError() : EXC_ENCR_ERROR_UNSUPP_CRYPT;
+}
 
 // ============================================================================
 
Index: sc/source/filter/excel/xiescher.cxx
===================================================================
RCS file: /cvs/sc/sc/source/filter/excel/xiescher.cxx,v
retrieving revision 1.17
retrieving revision 1.13.6.4
diff -w -u -r1.17 -r1.13.6.4
--- sc/source/filter/excel/xiescher.cxx	28 Jun 2004 17:57:51 -0000	1.17
+++ sc/source/filter/excel/xiescher.cxx	14 Jul 2004 10:18:40 -0000	1.13.6.4
@@ -229,7 +229,7 @@
     if( !nSrcSize )
         return NULL;
 
-    rSrcStrm.Seek( RECORD_SEEK_TO_BEGIN );
+    rSrcStrm.Seek( EXC_REC_SEEK_TO_BEGIN );
     sal_Char* pBuf = new sal_Char[ nSrcSize ];
     rSrcStrm.Read( pBuf, nSrcSize );
     aStrm.Write( pBuf, nSrcSize );
@@ -872,7 +872,7 @@
                 rStrm >> n16;     // string length
                 if( n16 )
                 {   // the 4th way Xcl stores a unicode string: not even a Grbit byte present if length 0
-                    rStrm.AppendUniString( aUserName, n16 );
+                    aUserName = rStrm.ReadUniString( n16 );
                     // 0:= ID follows, 1:= pad byte + ID
 #ifndef PRODUCT
                     sal_Int32 nLeft = sal_Int32(nFmlaLen) - (rStrm.GetRecPos() - nPos0);
@@ -1568,7 +1568,7 @@
 
 void XclImpObjectManager::ReadMsodrawing( XclImpStream& rStrm )
 {
-    rStrm.InitializeRecord( false );    // disable internal CONTINUE handling
+    rStrm.ResetRecord( false );     // disable internal CONTINUE handling
 
     if( !maStreamConsumer.HasData() )
         return;
@@ -1613,7 +1613,7 @@
 
 void XclImpObjectManager::ReadObj( XclImpStream& rStrm )
 {
-    rStrm.InitializeRecord( false );      // disable internal CONTINUE handling
+    rStrm.ResetRecord( false );     // disable internal CONTINUE handling
 
     sal_uInt16 nSubRecId, nSubRecSize;
     bool bLoop = true;
@@ -1644,7 +1644,7 @@
 
 void XclImpObjectManager::ReadTxo( XclImpStream& rStrm )
 {
-    rStrm.InitializeRecord( false );      // disable internal CONTINUE handling
+    rStrm.ResetRecord( false );     // disable internal CONTINUE handling
 
     sal_uInt16 nAlign, nTextLen, nFormCnt;
     ::std::auto_ptr< XclImpString > pString;
@@ -1667,9 +1667,8 @@
         DBG_ASSERT( bValid, "XclImpObjectManager::ReadTxo - missing CONTINUE record" );
         if( bValid )
         {
-            rStrm.InitializeRecord( false );
-            String aText;
-            rStrm.AppendUniString( aText, nTextLen );
+            rStrm.ResetRecord( false );
+            String aText( rStrm.ReadUniString( nTextLen ) );
             pString.reset( new XclImpString( aText ) );
         }
     }
@@ -1682,7 +1681,7 @@
         DBG_ASSERT( bValid, "XclImpObjectManager::ReadTxo - missing CONTINUE record" );
         if( bValid )
         {
-            rStrm.InitializeRecord( false );
+            rStrm.ResetRecord( false );
 
             sal_uInt16 nChar, nFont;
             sal_uInt16 nCount = nFormCnt - 1;
Index: sc/source/filter/excel/xihelper.cxx
===================================================================
RCS file: /cvs/sc/sc/source/filter/excel/xihelper.cxx,v
retrieving revision 1.11
retrieving revision 1.10.10.2
diff -w -u -r1.11 -r1.10.10.2
--- sc/source/filter/excel/xihelper.cxx	4 Jun 2004 10:46:58 -0000	1.11
+++ sc/source/filter/excel/xihelper.cxx	14 Jul 2004 10:18:50 -0000	1.10.10.2
@@ -144,7 +144,7 @@
     rStrm.ReadUniStringExtHeader( b16Bit, bRich, bFarEast, nRunCount, nExtInf, nFlagField );
 
     // --- character array ---
-    rStrm.AppendRawUniString( maString, nChars, b16Bit );
+    maString = rStrm.ReadRawUniString( nChars, b16Bit );
 
     // --- formatting ---
     ReadFormats( rStrm, nRunCount );
@@ -744,8 +744,7 @@
             rStrm >> mfValue;
         break;
         case EXC_CACHEDVAL_STRING:
-            mpStr.reset( new String );
-            rStrm.AppendUniString( *mpStr );
+            mpStr.reset( new String( rStrm.ReadUniString() ) );
         break;
         case EXC_CACHEDVAL_BOOL:
         case EXC_CACHEDVAL_ERROR:
Index: sc/source/filter/excel/xilink.cxx
===================================================================
RCS file: /cvs/sc/sc/source/filter/excel/xilink.cxx,v
retrieving revision 1.12
retrieving revision 1.8.10.2
diff -w -u -r1.12 -r1.8.10.2
--- sc/source/filter/excel/xilink.cxx	28 Jun 2004 17:58:04 -0000	1.12
+++ sc/source/filter/excel/xilink.cxx	14 Jul 2004 10:18:59 -0000	1.8.10.2
@@ -552,7 +552,7 @@
     sal_uInt8 nLen;
 
     rStrm >> nFlags >> mnStorageId >> nLen ;
-    rStrm.AppendUniString( maName, nLen );
+    maName = rStrm.ReadUniString( nLen );
 
     if( ::get_flag( nFlags, EXC_EXTN_BUILTIN ) || !::get_flag( nFlags, EXC_EXTN_OLE_OR_DDE ) )
     {
Index: sc/source/filter/excel/xipage.cxx
===================================================================
RCS file: /cvs/sc/sc/source/filter/excel/xipage.cxx,v
retrieving revision 1.5
retrieving revision 1.3.4.2
diff -w -u -r1.5 -r1.3.4.2
--- sc/source/filter/excel/xipage.cxx	4 Jun 2004 10:47:26 -0000	1.5
+++ sc/source/filter/excel/xipage.cxx	14 Jul 2004 10:19:07 -0000	1.3.4.2
@@ -187,12 +187,7 @@
 {
     String aString;
     if( rStrm.GetRecLeft() )
-    {
-        if( GetBiff() < xlBiff8 )
-            rStrm.AppendByteString( aString, false );
-        else
-            rStrm.AppendUniString( aString );
-    }
+        aString = (GetBiff() < xlBiff8) ? rStrm.ReadByteString( false ) : rStrm.ReadUniString();
 
     switch( rStrm.GetRecId() )
     {
Index: sc/source/filter/excel/xipivot.cxx
===================================================================
RCS file: /cvs/sc/sc/source/filter/excel/xipivot.cxx,v
retrieving revision 1.2
retrieving revision 1.2.72.2
diff -w -u -r1.2 -r1.2.72.2
--- sc/source/filter/excel/xipivot.cxx	4 Jun 2004 14:02:26 -0000	1.2
+++ sc/source/filter/excel/xipivot.cxx	15 Jul 2004 09:05:19 -0000	1.2.72.2
@@ -204,20 +204,19 @@
 
 // ============================================================================
 
-XclImpPivotCache::XclImpPivotCache( const XclImpRoot& rRoot, sal_uInt16 nStrmId ) :
-    XclImpRoot( rRoot ),
+XclImpPivotCache::XclImpPivotCache( const XclImpStream& rBookStrm, sal_uInt16 nStrmId ) :
+    XclImpRoot( rBookStrm.GetRoot() ),
     mnSrcType( EXC_SXVS_UNKNOWN )
 {
-    if( SvStorage* pSt = mpRD->pPivotCacheStorage )
-    {
-        SvStorageStreamRef pStIn = pSt->OpenStream( ScfTools::GetHexStr( nStrmId ), STREAM_STD_READ );
-        if( pStIn.Is() )
+    SvStorageRef xSvStrg = OpenStorage( EXC_STORAGE_PTCACHE );
+    SvStorageStreamRef xSvStrm = OpenStream( xSvStrg, ScfTools::GetHexStr( nStrmId ) );
+    if( xSvStrm.Is() )
         {
-            XclImpStream aStrm( *pStIn, GetRoot() );
+        XclImpStream aStrm( *xSvStrm, GetRoot() );
+        aStrm.CopyDecrypterFrom( rBookStrm );
             ReadPivotCacheStream( aStrm );
         }
     }
-}
 
 XclImpPivotCache::~XclImpPivotCache()
 {
@@ -845,7 +844,7 @@
 {
     sal_uInt16 nStrmId;
     rStrm >> nStrmId;
-    maPCacheList.Append( new XclImpPivotCache( GetRoot(), nStrmId ) );
+    maPCacheList.Append( new XclImpPivotCache( rStrm, nStrmId ) );
 }
 
 void XclImpPivotTableManager::ReadDconref( XclImpStream& rStrm )
Index: sc/source/filter/excel/xiroot.cxx
===================================================================
RCS file: /cvs/sc/sc/source/filter/excel/xiroot.cxx,v
retrieving revision 1.9
retrieving revision 1.8.6.3
diff -w -u -r1.9 -r1.8.6.3
--- sc/source/filter/excel/xiroot.cxx	4 Jun 2004 14:02:42 -0000	1.9
+++ sc/source/filter/excel/xiroot.cxx	14 Jul 2004 10:19:30 -0000	1.8.6.3
@@ -94,11 +94,10 @@
 #include "root.hxx"
 #include "excimp8.hxx"
 
-
 // Global data ================================================================
 
-XclImpRootData::XclImpRootData( XclBiff eBiff, ScDocument& rDocument, const String& rDocUrl, CharSet eCharSet ) :
-    XclRootData( eBiff, rDocument, rDocUrl, eCharSet )
+XclImpRootData::XclImpRootData( XclBiff eBiff, SfxMedium& rMedium, ScDocument& rDocument, CharSet eCharSet ) :
+    XclRootData( eBiff, rMedium, rDocument, eCharSet, false )
 {
 }
 
@@ -106,14 +105,12 @@
 {
 }
 
-
 // ----------------------------------------------------------------------------
 
 XclImpRoot::XclImpRoot( XclImpRootData& rImpRootData ) :
     XclRoot( rImpRootData ),
     mrImpData( rImpRootData )
 {
-    mrImpData.mpTracer.reset( new XclTracer( GetDocUrl(), CREATE_OUSTRING( "Office.Tracing/Import/Excel" ) ) );
     mrImpData.mpPalette.reset( new XclImpPalette( GetRoot() ) );
     mrImpData.mpFontBuffer.reset( new XclImpFontBuffer( GetRoot() ) );
     mrImpData.mpNumFmtBuffer.reset( new XclImpNumFmtBuffer( GetRoot() ) );
Index: sc/source/filter/excel/xistream.cxx
===================================================================
RCS file: /cvs/sc/sc/source/filter/excel/xistream.cxx,v
retrieving revision 1.5
retrieving revision 1.5.6.8
diff -w -u -r1.5 -r1.5.6.8
--- sc/source/filter/excel/xistream.cxx	2 Mar 2004 09:39:12 -0000	1.5
+++ sc/source/filter/excel/xistream.cxx	14 Apr 2004 10:08:16 -0000	1.5.6.8
@@ -59,217 +59,299 @@
  *
  ************************************************************************/
 
-#ifdef PCH
-#include "filt_pch.hxx"
-#endif
-
-#pragma hdrstop
-
-
 // ============================================================================
 
 #ifndef SC_XISTREAM_HXX
 #include "xistream.hxx"
 #endif
 
-#ifndef _STREAM_HXX
-#include <tools/stream.hxx>
-#endif
-
 #ifndef SC_XIROOT_HXX
 #include "xiroot.hxx"
 #endif
 
-
+// ============================================================================
+// Decryption
 // ============================================================================
 
-#if SC_XCL_USEDECR
-XclImpDecrypter::~XclImpDecrypter()
+XclImpDecrypter::XclImpDecrypter() :
+    mnError( EXC_ENCR_ERROR_UNSUPP_CRYPT ),
+    mnOldPos( STREAM_SEEK_TO_END ),
+    mnRecSize( 0 )
 {
 }
 
-sal_uInt16 XclImpDecrypter::GetHash( const ByteString& rPass )
+XclImpDecrypter::XclImpDecrypter( const XclImpDecrypter& rSrc ) :
+    mnError( rSrc.mnError ),
+    mnOldPos( STREAM_SEEK_TO_END ),
+    mnRecSize( 0 )
 {
-    sal_uInt16 nLen = static_cast< sal_uInt16 >( ::std::min< xub_StrLen >( rPass.Len(), 0xFFFF ) );
-    sal_uInt16 nHash = nLen;
-    if( nLen )
-        nHash ^= 0xCE4B;
+}
 
-    for( sal_uInt16 nIndex = 0; nIndex < nLen; ++nIndex )
+XclImpDecrypter::~XclImpDecrypter()
     {
-        sal_uInt16 nChar = static_cast< sal_uInt8 >( rPass.GetChar( nIndex ) );
-        sal_uInt8 nRot = static_cast< sal_uInt8 >( (nIndex + 1) % 15 );
-        ::rotate_left( nChar, nRot, 15 );
-        nHash ^= nChar;
     }
-    return nHash;
+
+XclImpDecrypterRef XclImpDecrypter::Clone() const
+{
+    XclImpDecrypterRef xNewDecr;
+    if( IsValid() )
+        xNewDecr.reset( OnClone() );
+    return xNewDecr;
 }
 
-sal_uInt16 XclImpDecrypter::GetKey( const ByteString& rPass )
+void XclImpDecrypter::Update( SvStream& rStrm, sal_uInt16 nRecSize )
 {
-    xub_StrLen nLen = rPass.Len();
-    if( !nLen ) return 0;
+    if( IsValid() )
+    {
+        ULONG nNewPos = rStrm.Tell();
+        if( (mnOldPos != nNewPos) || (mnRecSize != nRecSize) )
+        {
+            OnUpdate( mnOldPos, nNewPos, nRecSize );
+            mnOldPos = nNewPos;
+            mnRecSize = nRecSize;
+        }
+    }
+}
 
-    sal_uInt16 nKey = 0;
-    sal_uInt16 nKeyBase = 0x8000;
-    sal_uInt16 nKeyEnd = 0xFFFF;
-    for( xub_StrLen nIndex = 0; nIndex < nLen; ++nIndex )
+sal_uInt16 XclImpDecrypter::Read( SvStream& rStrm, void* pData, sal_uInt16 nBytes )
     {
-        sal_Char nChar = rPass.GetChar( nLen - nIndex - 1 ) & 0x7F;
-        for( sal_uInt8 nBit = 0; nBit < 8; ++nBit )
+    sal_uInt16 nRet = 0;
+    if( pData && nBytes )
         {
-            ::rotate_left( nKeyBase, 1 );
-            if( nKeyBase & 1 ) nKeyBase ^= 0x1020;
-            if( nChar & 1 ) nKey ^= nKeyBase;
-            nChar >>= 1;
-            ::rotate_left( nKeyEnd, 1 );
-            if( nKeyEnd & 1 ) nKeyEnd ^= 0x1020;
+        if( IsValid() )
+        {
+            Update( rStrm, mnRecSize );
+            nRet = OnRead( rStrm, reinterpret_cast< sal_uInt8* >( pData ), nBytes );
+            mnOldPos = rStrm.Tell();
         }
+        else
+            nRet = static_cast< sal_uInt16 >( rStrm.Read( pData, nBytes ) );
     }
-    return nKey ^ nKeyEnd;
+    return nRet;
 }
 
+void XclImpDecrypter::SetHasValidPassword( bool bValid )
+{
+    mnError = bValid ? ERRCODE_NONE : EXC_ENCR_ERROR_WRONG_PASS;
+}
 
 // ----------------------------------------------------------------------------
 
-XclImpBiff5Decrypter::XclImpBiff5Decrypter( const String& rPass, sal_uInt16 nKey, sal_uInt16 nHash ) :
-    mbIsValid( false )
+XclImpBiff5Decrypter::XclImpBiff5Decrypter( const XclImpRoot& rRoot, sal_uInt16 nKey, sal_uInt16 nHash )
 {
-    ByteString aPass( rPass, RTL_TEXTENCODING_MS_1252 );    //! correct?
-    xub_StrLen nLen = aPass.Len();
-    if( (0 < nLen) && (nLen < 16) && (GetKey( aPass ) == nKey) && (GetHash( aPass ) == nHash) )
+    Init( XclCryptoHelper::GetBiff5WbProtPassword(), nKey, nHash );
+    if( !IsValid() )
     {
-        static const sal_uInt8 pFillChars[] =
+        //! TODO: correct byte string encoding in all cases?
+        ByteString aPass( rRoot.QueryPassword(), RTL_TEXTENCODING_MS_1252 );
+        Init( aPass, nKey, nHash );
+    }
+}
+
+XclImpBiff5Decrypter::XclImpBiff5Decrypter( const XclImpBiff5Decrypter& rSrc ) :
+    XclImpDecrypter( rSrc )
+{
+    if( rSrc.IsValid() )
+    {
+        memcpy( mpnPassw, rSrc.mpnPassw, sizeof( mpnPassw ) );
+        maCodec.InitKey( mpnPassw );
+    }
+}
+
+XclImpBiff5Decrypter* XclImpBiff5Decrypter::OnClone() const
         {
-            0xBB, 0xFF, 0xFF, 0xBA,
-            0xFF, 0xFF, 0xB9, 0x80,
-            0x00, 0xBE, 0x0F, 0x00,
-            0xBF, 0x0F, 0x00
-        };
-        const sal_uInt8* pFillChar = pFillChars;
+    return new XclImpBiff5Decrypter( *this );
+}
 
-        xub_StrLen nIndex;
-        for( nIndex = 0; nIndex < nLen; ++nIndex )
-            mpKey[ nIndex ] = aPass.GetChar( nIndex );
-        for( ; nIndex < 16; ++nIndex, ++pFillChar )
-            mpKey[ nIndex ] = *pFillChar;
+void XclImpBiff5Decrypter::OnUpdate( ULONG nOldStrmPos, ULONG nNewStrmPos, sal_uInt16 nRecSize )
+{
+    maCodec.InitCipher();
+    maCodec.Skip( (nNewStrmPos + nRecSize) & 0x0F );
+}
 
-        SVBT16 nOrigKey;
-        ShortToSVBT16( nKey, nOrigKey );
-        sal_uInt8* pKeyChar = mpKey;
-        for( nIndex = 0; nIndex < 16; ++nIndex, ++pKeyChar )
+sal_uInt16 XclImpBiff5Decrypter::OnRead( SvStream& rStrm, sal_uInt8* pnData, sal_uInt16 nBytes )
         {
-            *pKeyChar ^= nOrigKey[ nIndex & 0x01 ];
-            ::rotate_left( *pKeyChar, 2 );
+    sal_uInt16 nRet = static_cast< sal_uInt16 >( rStrm.Read( pnData, nBytes ) );
+    maCodec.Decode( pnData, nRet );
+    return nRet;
         }
 
-        mbIsValid = true;
+void XclImpBiff5Decrypter::Init( const ByteString& rPass, sal_uInt16 nKey, sal_uInt16 nHash )
+{
+    xub_StrLen nLen = rPass.Len();
+    bool bValid = (0 < nLen) && (nLen < 16);
+
+    if( bValid )
+    {
+        // transform ByteString to sal_uInt8 array
+        memset( mpnPassw, 0, sizeof( mpnPassw ) );
+        for( xub_StrLen nChar = 0; nChar < nLen; ++nChar )
+            mpnPassw[ nChar ] = static_cast< sal_uInt8 >( rPass.GetChar( nChar ) );
+        // init codec
+        maCodec.InitKey( mpnPassw );
+        bValid = maCodec.VerifyKey( nKey, nHash );
     }
+
+    SetHasValidPassword( bValid );
 }
 
-bool XclImpBiff5Decrypter::IsValid() const
+// ----------------------------------------------------------------------------
+
+XclImpBiff8Decrypter::XclImpBiff8Decrypter(
+        const XclImpRoot& rRoot, sal_uInt8 pnDocId[ 16 ],
+        sal_uInt8 pnSaltData[ 16 ], sal_uInt8 pnSaltHash[ 16 ] )
 {
-    return mbIsValid;
+    Init( XclCryptoHelper::GetBiff8WbProtPassword(), pnDocId, pnSaltData, pnSaltHash );
+    if( !IsValid() )
+        Init( rRoot.QueryPassword(), pnDocId, pnSaltData, pnSaltHash );
 }
 
-void XclImpBiff5Decrypter::SetOffset( sal_uInt16 nRecSize )
+XclImpBiff8Decrypter::XclImpBiff8Decrypter( const XclImpBiff8Decrypter& rSrc ) :
+    XclImpDecrypter( rSrc )
+{
+    if( rSrc.IsValid() )
 {
-    mnOffset = nRecSize & 0x0F;
+        memcpy( mpnPassw, rSrc.mpnPassw, sizeof( mpnPassw ) );
+        memcpy( mpnDocId, rSrc.mpnDocId, sizeof( mpnDocId ) );
+        maCodec.InitKey( mpnPassw, mpnDocId );
+    }
 }
 
-sal_uInt32 XclImpBiff5Decrypter::ReadDecrypt( SvStream& rStrm, void* pData, sal_uInt32 nBytes )
+XclImpBiff8Decrypter* XclImpBiff8Decrypter::OnClone() const
 {
-    DBG_ASSERT( mbIsValid, "XclImpBiff5Decrypter::ReadDecrypt - invalid decrypter" );
+    return new XclImpBiff8Decrypter( *this );
+}
 
-    sal_uInt32 nRet = 0;
-    if( pData && nBytes )
+void XclImpBiff8Decrypter::OnUpdate( ULONG nOldStrmPos, ULONG nNewStrmPos, sal_uInt16 nRecSize )
+{
+    if( nNewStrmPos != nOldStrmPos )
     {
-        sal_uInt8* pCurrKey = mpKey + ((rStrm.Tell() + mnOffset) & 0x0F);
-        sal_uInt8* pKeyLast = mpKey + 0x0F;
+        sal_uInt32 nOldBlock = GetBlock( nOldStrmPos );
+        sal_uInt16 nOldOffset = GetOffset( nOldStrmPos );
 
-        nRet = rStrm.Read( pData, nBytes );
+        sal_uInt32 nNewBlock = GetBlock( nNewStrmPos );
+        sal_uInt16 nNewOffset = GetOffset( nNewStrmPos );
 
-        sal_uInt32 nBytesLeft = nBytes;
-        sal_uInt8* pBuffer = reinterpret_cast< sal_uInt8* >( pData );
-        const sal_uInt8* pBufferEnd = pBuffer + nBytes;
-        for( ; pBuffer < pBufferEnd; ++pBuffer )
-        {
-            ::rotate_left( *pBuffer, 3 );
-            *pBuffer ^= *pCurrKey;
-            if( pCurrKey < pKeyLast ) ++pCurrKey; else pCurrKey = mpKey;
+        /*  Rekey cipher, if block changed or if previous offset in same block. */
+        if( (nNewBlock != nOldBlock) || (nNewOffset < nOldOffset) )
+        {
+            maCodec.InitCipher( nNewBlock );
+            nOldOffset = 0;     // reset nOldOffset for next if() statement
         }
+
+        /*  Seek to correct offset. */
+        if( nNewOffset > nOldOffset )
+            maCodec.Skip( nNewOffset - nOldOffset );
     }
-    return nRet;
 }
 
+sal_uInt16 XclImpBiff8Decrypter::OnRead( SvStream& rStrm, sal_uInt8* pnData, sal_uInt16 nBytes )
+{
+    sal_uInt16 nRet = 0;
 
-// ----------------------------------------------------------------------------
-
-XclImpBiff8Decrypter::XclImpBiff8Decrypter( const String& rPass )
+    sal_uInt8* pnCurrData = pnData;
+    sal_uInt16 nBytesLeft = nBytes;
+    while( nBytesLeft )
 {
-    DBG_ERRORFILE( "XclImpBiff8Decrypter::XclImpBiff8Decrypter - not implemented" );
+        sal_uInt16 nBlockLeft = EXC_ENCR_BLOCKSIZE - GetOffset( rStrm.Tell() );
+        sal_uInt16 nDecBytes = ::std::min< sal_uInt16 >( nBytesLeft, nBlockLeft );
+
+        // read the block from stream
+        nRet += static_cast< sal_uInt16 >( rStrm.Read( pnCurrData, nDecBytes ) );
+        // decode the block inplace
+        maCodec.Decode( pnCurrData, nDecBytes, pnCurrData, nDecBytes );
+        if( GetOffset( rStrm.Tell() ) == 0 )
+            maCodec.InitCipher( GetBlock( rStrm.Tell() ) );
+
+        pnCurrData += nDecBytes;
+        nBytesLeft -= nDecBytes;
 }
 
-bool XclImpBiff8Decrypter::IsValid() const
-{
-    return false;
+    return nRet;
 }
 
-void XclImpBiff8Decrypter::SetOffset( sal_uInt16 nRecSize )
+void XclImpBiff8Decrypter::Init(
+        const String& rPass, sal_uInt8 pnDocId[ 16 ],
+        sal_uInt8 pnSaltData[ 16 ], sal_uInt8 pnSaltHash[ 16 ] )
 {
+    xub_StrLen nLen = rPass.Len();
+    bool bValid = (0 < nLen) && (nLen < 16);
+
+    if( bValid )
+    {
+        // transform String to sal_uInt16 array
+        memset( mpnPassw, 0, sizeof( mpnPassw ) );
+        for( xub_StrLen nChar = 0; nChar < nLen; ++nChar )
+            mpnPassw[ nChar ] = static_cast< sal_uInt16 >( rPass.GetChar( nChar ) );
+        // copy document ID
+        memcpy( mpnDocId, pnDocId, sizeof( mpnDocId ) );
+        // init codec
+        maCodec.InitKey( mpnPassw, mpnDocId );
+        bValid = maCodec.VerifyKey( pnSaltData, pnSaltHash );
+    }
+
+    SetHasValidPassword( bValid );
 }
 
-sal_uInt32 XclImpBiff8Decrypter::ReadDecrypt( SvStream& rStrm, void* pData, sal_uInt32 nBytes )
+sal_uInt32 XclImpBiff8Decrypter::GetBlock( ULONG nStrmPos ) const
 {
-    return rStrm.Read( pData, nBytes );
+    return static_cast< sal_uInt32 >( nStrmPos / EXC_ENCR_BLOCKSIZE );
 }
-#endif
 
+sal_uInt16 XclImpBiff8Decrypter::GetOffset( ULONG nStrmPos ) const
+{
+    return static_cast< sal_uInt16 >( nStrmPos % EXC_ENCR_BLOCKSIZE );
+}
 
 // ============================================================================
+// Stream
+// ============================================================================
 
-XclImpStreamPos::XclImpStreamPos(
-        sal_uInt32 nStrmPos, sal_uInt32 nNextPos,
-        sal_uInt32 nCurrSize, sal_uInt32 nRecLeft, sal_uInt16 nRecSize ) :
-    mnPos( nStrmPos ),
-    mnNextPos( nNextPos ),
-    mnCurrSize( nCurrSize ),
-    mnRecLeft( nRecLeft ),
-    mnRecSize( nRecSize )
+XclImpStreamPos::XclImpStreamPos() :
+    mnPos( STREAM_SEEK_TO_BEGIN ),
+    mnNextPos( STREAM_SEEK_TO_BEGIN ),
+    mnCurrSize( 0 ),
+    mnRawRecId( EXC_ID_UNKNOWN ),
+    mnRawRecSize( 0 ),
+    mnRawRecLeft( 0 ),
+    mbValid( false )
 {
 }
 
 void XclImpStreamPos::Set(
-        sal_uInt32 nStrmPos, sal_uInt32 nNextPos,
-        sal_uInt32 nCurrSize, sal_uInt32 nRecLeft, sal_uInt16 nRecSize )
+        const SvStream& rStrm, ULONG nNextPos, sal_uInt32 nCurrSize,
+        sal_uInt16 nRawRecId, sal_uInt16 nRawRecSize, sal_uInt16 nRawRecLeft,
+        bool bValid )
 {
-    mnPos = nStrmPos;
+    mnPos = rStrm.Tell();
     mnNextPos = nNextPos;
     mnCurrSize = nCurrSize;
-    mnRecLeft = nRecLeft;
-    mnRecSize = nRecSize;
+    mnRawRecId = nRawRecId;
+    mnRawRecSize = nRawRecSize;
+    mnRawRecLeft = nRawRecLeft;
+    mbValid = bValid;
 }
 
 void XclImpStreamPos::Get(
-        sal_uInt32& rnStrmPos, sal_uInt32& rnNextPos,
-        sal_uInt32& rnCurrSize, sal_uInt32& rnRecLeft, sal_uInt16& rnRecSize ) const
+        SvStream& rStrm, ULONG& rnNextPos, sal_uInt32& rnCurrSize,
+        sal_uInt16& rnRawRecId, sal_uInt16& rnRawRecSize, sal_uInt16& rnRawRecLeft,
+        bool& rbValid ) const
 {
-    rnStrmPos = mnPos;
+    rStrm.Seek( mnPos );
     rnNextPos = mnNextPos;
     rnCurrSize = mnCurrSize;
-    rnRecLeft = mnRecLeft;
-    rnRecSize = mnRecSize;
+    rnRawRecId = mnRawRecId;
+    rnRawRecSize = mnRawRecSize;
+    rnRawRecLeft = mnRawRecLeft;
+    rbValid = mbValid;
 }
 
-
 // ============================================================================
 
-XclImpStream::XclImpStream( SvStream& rInStrm, const XclImpRoot& rRoot, bool bContHandling ) :
+XclImpStream::XclImpStream( SvStream& rInStrm, const XclImpRoot& rRoot, bool bContLookup ) :
     mrStrm( rInStrm ),
     mrRoot( rRoot ),
-    maFirstRec( STREAM_SEEK_TO_BEGIN, STREAM_SEEK_TO_BEGIN, 0, 0, 0 ),
-    maGlobPos( STREAM_SEEK_TO_BEGIN, STREAM_SEEK_TO_BEGIN, 0, 0, 0 ),
-    mnGlobRecId( 0 ),
+    mnGlobRecId( EXC_ID_UNKNOWN ),
     mbGlobValidRec( false ),
     mbHasGlobPos( false ),
     mnNextRecPos( STREAM_SEEK_TO_BEGIN ),
@@ -278,16 +360,14 @@
     mbHasComplRec( false ),
     mnRecId( EXC_ID_UNKNOWN ),
     mnAltContId( EXC_ID_UNKNOWN ),
-    mnRecSize( 0 ),
-    mnRecLeft( 0 ),
+    mnRawRecId( EXC_ID_UNKNOWN ),
+    mnRawRecSize( 0 ),
+    mnRawRecLeft( 0 ),
     mcNulSubst( '?' ),
-    mbCont( bContHandling ),
-#if SC_XCL_USEDECR
+    mbCont( bContLookup ),
     mbUseDecr( false ),
-#endif
     mbValidRec( false ),
-    mbValid( false ),
-    mbWarnings( true )
+    mbValid( false )
 {
     mnStreamSize = mrStrm.Seek( STREAM_SEEK_TO_END );
     mrStrm.Seek( STREAM_SEEK_TO_BEGIN );
@@ -298,157 +378,98 @@
 {
 }
 
-bool XclImpStream::GetNextRecord( sal_uInt16& rnRecId, sal_uInt16& rnRecSize )
-{
-    mrStrm.Seek( mnNextRecPos );
-    bool bRet = (mnNextRecPos < mnStreamSize);
-    if( bRet )
-    {
-        mrStrm >> rnRecId >> rnRecSize;  // read direct
-#if SC_XCL_USEDECR
-        SetDecrypterOffset( rnRecSize );
-#endif
-    }
-    else
-        rnRecId = rnRecSize = 0;
-    return bRet;
-}
-
-void XclImpStream::SetupRecord()
-{
-    mnRecLeft = mnRecSize;
-    mnCurrRecSize = mnComplRecSize = mnRecSize;
-    mbHasComplRec = !mbCont;
-    maFirstRec.Set( Tell(), mnNextRecPos, mnComplRecSize, mnRecLeft, mnRecSize );
-}
-
-bool XclImpStream::IsContinueId( sal_uInt16 nRecId )
-{
-    return (nRecId == EXC_ID_CONT) || (nRecId == mnAltContId);
-}
-
 bool XclImpStream::StartNextRecord()
 {
-    maPosStack.Clear();
+    maPosStack.clear();
 
-    /*  counter to ignore zero records (id==len==0) (i.e. the application
+    /*  #i4266# Counter to ignore zero records (id==len==0) (i.e. the application
         "Crystal Report" writes zero records between other records) */
     sal_uInt32 nZeroRecCount = 5;
     bool bIsZeroRec = false;
 
 	do
 	{
-        mbValidRec = GetNextRecord( mnRecId, mnRecSize );
-        bIsZeroRec = !mnRecId && !mnRecSize;
+        mbValidRec = ReadNextRawRecHeader();
+        bIsZeroRec = !mnRawRecId && !mnRawRecSize;
         if( bIsZeroRec ) --nZeroRecCount;
-        mnNextRecPos = Tell() + mnRecSize;
+        mnNextRecPos = mrStrm.Tell() + mnRawRecSize;
 	}
-    while( mbValidRec && ((mbCont && IsContinueId( mnRecId )) || (bIsZeroRec && nZeroRecCount)) );
+    while( mbValidRec && ((mbCont && IsContinueId( mnRawRecId )) || (bIsZeroRec && nZeroRecCount)) );
 
-    if( bIsZeroRec )
-        mbValidRec = false;
+    mbValidRec = mbValidRec && !bIsZeroRec;
     mbValid = mbValidRec;
-    mnAltContId = EXC_ID_UNKNOWN;
 	SetupRecord();
+
     return mbValidRec;
 }
 
-void XclImpStream::InitializeRecord( bool bContHandling, sal_uInt16 nAltContId )
+void XclImpStream::ResetRecord( bool bContLookup, sal_uInt16 nAltContId )
 {
     if( mbValidRec )
     {
-        maPosStack.Clear();
+        maPosStack.clear();
         RestorePosition( maFirstRec );
-        mnCurrRecSize = mnComplRecSize = mnRecSize;
-        mbHasComplRec = !bContHandling;
-        mbCont = bContHandling;
+        mnCurrRecSize = mnComplRecSize = mnRawRecSize;
+        mbHasComplRec = !bContLookup;
+        mbCont = bContLookup;
         mnAltContId = nAltContId;
+        EnableDecryption();
     }
 }
 
-#if SC_XCL_USEDECR
-void XclImpStream::EnableDecryption( XclImpDecrypter* pDecrypter )
+void XclImpStream::SetDecrypter( XclImpDecrypterRef xDecrypter )
 {
-    mpDecrypter.reset( pDecrypter );
-    SetDecrypterOffset( mnRecSize );
-    UseDecryption( true );
+    mxDecrypter = xDecrypter;
+    EnableDecryption();
+    SetupDecrypter();
 }
 
-void XclImpStream::UseDecryption( bool bUse )
+void XclImpStream::CopyDecrypterFrom( const XclImpStream& rStrm )
 {
-    mbUseDecr = (mpDecrypter.get() && mpDecrypter->IsValid()) ? bUse : false;
+    XclImpDecrypterRef xNewDecr;
+    if( rStrm.mxDecrypter.get() )
+        xNewDecr = rStrm.mxDecrypter->Clone();
+    SetDecrypter( xNewDecr );
 }
-#endif
 
-bool XclImpStream::GetContinue()
+bool XclImpStream::HasValidDecrypter() const
 {
-    bool bRet = mbCont || IsContinueId( mnRecId );
-    if( bRet )
-    {
-        sal_uInt16 nNewNum;
-        bRet = GetNextRecord( nNewNum, mnRecSize ) && IsContinueId( nNewNum );
-    }
-    if( bRet )
-    {
-        mnRecLeft = mnRecSize;
-        mnNextRecPos = Tell() + mnRecSize;
-        mnCurrRecSize += mnRecSize;
-    }
-    return bRet;
+    return mxDecrypter.get() && mxDecrypter->IsValid();
 }
 
-bool XclImpStream::CheckDataLeft( sal_uInt32 nBytes )
+void XclImpStream::EnableDecryption( bool bEnable )
 {
-    bool bNewValid = mbValid && ((mnRecLeft >= nBytes) ? true : (mnRecLeft ? false : GetContinue()));
-    DBG_ASSERT( !mbWarnings || bNewValid || !mbValid, "XclImpStream - record overread" ); // one assertion per record
-    return (mbValid = bNewValid);   // really assignment
+    mbUseDecr = bEnable && HasValidDecrypter();
 }
 
-void XclImpStream::StartContinue()
-{
-    bool bNewValid = (mbValid && !mnRecLeft) ? GetContinue() : false;
-    DBG_ASSERT( !mbWarnings || bNewValid || !mbValid, "XclImpStream - record overread" ); // one assertion per record
-    mbValid = bNewValid;
-}
-
-
 // ----------------------------------------------------------------------------
 
 void XclImpStream::PushPosition()
 {
-    if( mbValid )
-        maPosStack.Push( new XclImpStreamPos(
-            Tell(), mnNextRecPos, mnCurrRecSize, mnRecLeft, mnRecSize ) );
-}
-
-void XclImpStream::RestorePosition( const XclImpStreamPos& rPos )
-{
-    sal_uInt32 nPos;
-    rPos.Get( nPos, mnNextRecPos, mnCurrRecSize, mnRecLeft, mnRecSize );
-    mrStrm.Seek( nPos );
-    mbValid = true;
+    maPosStack.push_back( XclImpStreamPos() );
+    StorePosition( maPosStack.back() );
 }
 
 void XclImpStream::PopPosition()
 {
-    XclImpStreamPos* pPos = maPosStack.Pop();
-    DBG_ASSERT( pPos, "XclImpStream::PopPosition - stack empty" );
-    if( pPos )
+    DBG_ASSERT( !maPosStack.empty(), "XclImpStream::PopPosition - stack empty" );
+    if( !maPosStack.empty() )
     {
-        RestorePosition( *pPos );
-        delete pPos;
+        RestorePosition( maPosStack.back() );
+        maPosStack.pop_back();
     }
 }
 
 void XclImpStream::RejectPosition()
 {
-    DBG_ASSERT( !maPosStack.Empty(), "XclImpStream::RejectPosition - stack empty" );
-    delete maPosStack.Pop();
+    DBG_ASSERT( !maPosStack.empty(), "XclImpStream::RejectPosition - stack empty" );
+    if( !maPosStack.empty() )
+        maPosStack.pop_back();
 }
 
 void XclImpStream::StoreGlobalPosition()
 {
-    maGlobPos.Set( Tell(), mnNextRecPos, mnCurrRecSize, mnRecLeft, mnRecSize );
+    StorePosition( maGlobPos );
     mnGlobRecId = mnRecId;
     mbGlobValidRec = mbValidRec;
     mbHasGlobPos = true;
@@ -463,19 +484,21 @@
         mnRecId = mnGlobRecId;
         mnComplRecSize = mnCurrRecSize;
         mbHasComplRec = !mbCont;
-        mbValidRec = mbValid = mbGlobValidRec;
-#if SC_XCL_USEDECR
-        SetDecrypterOffset( mnRecSize );
-#endif
+        mbValidRec = mbGlobValidRec;
     }
 }
 
+sal_uInt32 XclImpStream::GetRecPos() const
+{
+    return mbValid ? (mnCurrRecSize - mnRawRecLeft) : EXC_REC_SEEK_TO_END;
+}
+
 sal_uInt32 XclImpStream::GetRecSize()
 {
-    if( IsValid() && !mbHasComplRec )
+    if( !mbHasComplRec )
     {
         PushPosition();
-        while( GetContinue() );     // GetContinue() adds up mnCurrRecSize
+        while( JumpToNextContinue() );  // JumpToNextContinue() adds up mnCurrRecSize
         mnComplRecSize = mnCurrRecSize;
         mbHasComplRec = true;
         PopPosition();
@@ -483,137 +506,142 @@
     return mnComplRecSize;
 }
 
+sal_uInt32 XclImpStream::GetRecLeft()
+{
+    return mbValid ? (GetRecSize() - GetRecPos()) : 0;
+}
 
 // ----------------------------------------------------------------------------
 
-void XclImpStream::ReadAtom( sal_Int8& rnValue )
+XclImpStream& XclImpStream::operator>>( sal_Int8& rnValue )
+{
+    if( EnsureRawReadSize( 1 ) )
 {
-#if SC_XCL_USEDECR
     if( mbUseDecr )
-        mpDecrypter->ReadDecrypt( mrStrm, &rnValue, 1 );
+            mxDecrypter->Read( mrStrm, &rnValue, 1 );
     else
-#endif
         mrStrm >> rnValue;
-    --mnRecLeft;
+        --mnRawRecLeft;
+    }
+    return *this;
 }
 
-void XclImpStream::ReadAtom( sal_uInt8& rnValue )
+XclImpStream& XclImpStream::operator>>( sal_uInt8& rnValue )
+{
+    if( EnsureRawReadSize( 1 ) )
 {
-#if SC_XCL_USEDECR
     if( mbUseDecr )
-        mpDecrypter->ReadDecrypt( mrStrm, &rnValue, 1 );
+            mxDecrypter->Read( mrStrm, &rnValue, 1 );
     else
-#endif
         mrStrm >> rnValue;
-    --mnRecLeft;
+        --mnRawRecLeft;
+    }
+    return *this;
 }
 
-void XclImpStream::ReadAtom( sal_Int16& rnValue )
+XclImpStream& XclImpStream::operator>>( sal_Int16& rnValue )
+{
+    if( EnsureRawReadSize( 2 ) )
 {
-#if SC_XCL_USEDECR
     if( mbUseDecr )
     {
-        SVBT16 pBuffer;
-        mpDecrypter->ReadDecrypt( mrStrm, pBuffer, 2 );
-        rnValue = static_cast< sal_Int16 >( SVBT16ToShort( pBuffer ) );
+            SVBT16 pnBuffer;
+            mxDecrypter->Read( mrStrm, pnBuffer, 2 );
+            rnValue = static_cast< sal_Int16 >( SVBT16ToShort( pnBuffer ) );
     }
     else
-#endif
         mrStrm >> rnValue;
-    mnRecLeft -= 2;
+        mnRawRecLeft -= 2;
+    }
+    return *this;
 }
 
-void XclImpStream::ReadAtom( sal_uInt16& rnValue )
+XclImpStream& XclImpStream::operator>>( sal_uInt16& rnValue )
+{
+    if( EnsureRawReadSize( 2 ) )
 {
-#if SC_XCL_USEDECR
     if( mbUseDecr )
     {
-        SVBT16 pBuffer;
-        mpDecrypter->ReadDecrypt( mrStrm, pBuffer, 2 );
-        rnValue = SVBT16ToShort( pBuffer );
+            SVBT16 pnBuffer;
+            mxDecrypter->Read( mrStrm, pnBuffer, 2 );
+            rnValue = SVBT16ToShort( pnBuffer );
     }
     else
-#endif
         mrStrm >> rnValue;
-    mnRecLeft -= 2;
+        mnRawRecLeft -= 2;
+    }
+    return *this;
 }
 
-void XclImpStream::ReadAtom( sal_Int32& rnValue )
+XclImpStream& XclImpStream::operator>>( sal_Int32& rnValue )
+{
+    if( EnsureRawReadSize( 4 ) )
 {
-#if SC_XCL_USEDECR
     if( mbUseDecr )
     {
-        SVBT32 pBuffer;
-        mpDecrypter->ReadDecrypt( mrStrm, pBuffer, 4 );
-        rnValue = static_cast< sal_Int32 >( SVBT32ToLong( pBuffer ) );
+            SVBT32 pnBuffer;
+            mxDecrypter->Read( mrStrm, pnBuffer, 4 );
+            rnValue = static_cast< sal_Int32 >( SVBT32ToLong( pnBuffer ) );
     }
     else
-#endif
         mrStrm >> rnValue;
-    mnRecLeft -= 4;
+        mnRawRecLeft -= 4;
+    }
+    return *this;
 }
 
-void XclImpStream::ReadAtom( sal_uInt32& rnValue )
+XclImpStream& XclImpStream::operator>>( sal_uInt32& rnValue )
+{
+    if( EnsureRawReadSize( 4 ) )
 {
-#if SC_XCL_USEDECR
     if( mbUseDecr )
     {
-        SVBT32 pBuffer;
-        mpDecrypter->ReadDecrypt( mrStrm, pBuffer, 4 );
-        rnValue = SVBT32ToLong( pBuffer );
+            SVBT32 pnBuffer;
+            mxDecrypter->Read( mrStrm, pnBuffer, 4 );
+            rnValue = SVBT32ToLong( pnBuffer );
     }
     else
-#endif
         mrStrm >> rnValue;
-    mnRecLeft -= 4;
+        mnRawRecLeft -= 4;
+    }
+    return *this;
 }
 
-void XclImpStream::ReadAtom( float& rfValue )
+XclImpStream& XclImpStream::operator>>( float& rfValue )
+{
+    if( EnsureRawReadSize( 4 ) )
 {
-#if SC_XCL_USEDECR
     if( mbUseDecr )
     {
-        SVBT32 pBuffer;
-        mpDecrypter->ReadDecrypt( mrStrm, pBuffer, 4 );
-        sal_uInt32 nValue = SVBT32ToLong( pBuffer );
+            SVBT32 pnBuffer;
+            mxDecrypter->Read( mrStrm, pnBuffer, 4 );
+            sal_uInt32 nValue = SVBT32ToLong( pnBuffer );
         memcpy( &rfValue, &nValue, 4 );
     }
     else
-#endif
         mrStrm >> rfValue;
-    mnRecLeft -= 4;
+        mnRawRecLeft -= 4;
+    }
+    return *this;
 }
 
-void XclImpStream::ReadAtom( double& rfValue )
+XclImpStream& XclImpStream::operator>>( double& rfValue )
+{
+    if( EnsureRawReadSize( 8 ) )
 {
-#if SC_XCL_USEDECR
     if( mbUseDecr )
     {
-        SVBT64 pBuffer;
-        mpDecrypter->ReadDecrypt( mrStrm, pBuffer, 8 );
-        rfValue = SVBT64ToDouble( pBuffer );
+            SVBT64 pnBuffer;
+            mxDecrypter->Read( mrStrm, pnBuffer, 8 );
+            rfValue = SVBT64ToDouble( pnBuffer );
     }
     else
-#endif
         mrStrm >> rfValue;
-    mnRecLeft -= 8;
+        mnRawRecLeft -= 8;
 }
-
-sal_uInt32 XclImpStream::ReadData( void* pData, sal_uInt32 nBytes )
-{
-#if SC_XCL_USEDECR
-    sal_uInt32 nRet = mbUseDecr ?
-        mpDecrypter->ReadDecrypt( mrStrm, pData, nBytes ) : mrStrm.Read( pData, nBytes );
-#else
-    sal_uInt32 nRet = mrStrm.Read( pData, nBytes );
-#endif
-    mnRecLeft -= nRet;
-    return nRet;
+    return *this;
 }
 
-
-// ----------------------------------------------------------------------------
-
 sal_Int8 XclImpStream::ReadInt8()
 {
     sal_Int8 nValue;
@@ -673,22 +701,23 @@
 sal_uInt32 XclImpStream::Read( void* pData, sal_uInt32 nBytes )
 {
     sal_uInt32 nRet = 0;
-    if( IsValid() && pData && nBytes )
+    if( mbValid && pData && nBytes )
     {
-        sal_uInt8* pBuffer = reinterpret_cast< sal_uInt8* >( pData );
+        sal_uInt8* pnBuffer = reinterpret_cast< sal_uInt8* >( pData );
         sal_uInt32 nBytesLeft = nBytes;
 
-        while( IsValid() && nBytesLeft )
+        while( mbValid && nBytesLeft )
         {
-            sal_uInt32 nReadSize = ::std::min( nBytesLeft, mnRecLeft );
-            sal_uInt32 nReadRet = ReadData( pBuffer, nReadSize );
+            sal_uInt16 nReadSize = GetMaxRawReadSize( nBytesLeft );
+            sal_uInt16 nReadRet = ReadRawData( pnBuffer, nReadSize );
             nRet += nReadRet;
             mbValid = (nReadSize == nReadRet);
-            DBG_ASSERT( !mbWarnings || IsValid(), "XclImpStream::Read - stream read error" );
-            pBuffer += nReadRet;
+            DBG_ASSERT( mbValid, "XclImpStream::Read - stream read error" );
+            pnBuffer += nReadRet;
             nBytesLeft -= nReadRet;
-            if( IsValid() && nBytesLeft )
-                StartContinue();
+            if( mbValid && nBytesLeft )
+                JumpToNextContinue();
+            DBG_ASSERT( mbValid, "XclImpStream::Read - record overread" );
         }
     }
     return nRet;
@@ -697,21 +726,21 @@
 sal_uInt32 XclImpStream::CopyToStream( SvStream& rOutStrm, sal_uInt32 nBytes )
 {
     sal_uInt32 nRet = 0;
-    if( IsValid() && nBytes )
+    if( mbValid && nBytes )
     {
         const sal_uInt32 nMaxBuffer = 0x1000;
-        sal_uInt8* pBuffer = new sal_uInt8[ ::std::min( nBytes, nMaxBuffer ) ];
+        sal_uInt8* pnBuffer = new sal_uInt8[ ::std::min( nBytes, nMaxBuffer ) ];
         sal_uInt32 nBytesLeft = nBytes;
 
-        while( IsValid() && nBytesLeft )
+        while( mbValid && nBytesLeft )
         {
             sal_uInt32 nReadSize = ::std::min( nBytesLeft, nMaxBuffer );
-            nRet += Read( pBuffer, nReadSize );
-            rOutStrm.Write( pBuffer, nReadSize );
+            nRet += Read( pnBuffer, nReadSize );
+            rOutStrm.Write( pnBuffer, static_cast< ULONG >( nReadSize ) );
             nBytesLeft -= nReadSize;
         }
 
-        delete[] pBuffer;
+        delete[] pnBuffer;
     }
     return nRet;
 }
@@ -734,69 +763,47 @@
     if( mbValidRec )
     {
         sal_uInt32 nCurrPos = GetRecPos();
-        if( nPos > nCurrPos )       // forward
-            Ignore( nPos - nCurrPos );
-        else if( nPos < nCurrPos )  // backward
+        if( !mbValid || (nPos < nCurrPos) ) // from invalid state or backward
         {
             RestorePosition( maFirstRec );
             Ignore( nPos );
         }
+        else if( nPos > nCurrPos )          // forward
+        {
+            Ignore( nPos - nCurrPos );
+        }
     }
 }
 
 void XclImpStream::Ignore( sal_uInt32 nBytes )
 {
+    // implementation similar to Read(), but without really reading anything
     sal_uInt32 nBytesLeft = nBytes;
-    while( IsValid() && nBytesLeft )
+    while( mbValid && nBytesLeft )
     {
-        sal_uInt32 nReadSize = ::std::min( nBytesLeft, mnRecLeft );
-        mrStrm.SeekRel( static_cast< sal_Int32 >( nReadSize ) );
-        mnRecLeft -= nReadSize;
+        sal_uInt16 nReadSize = GetMaxRawReadSize( nBytesLeft );
+        mrStrm.SeekRel( nReadSize );
+        mnRawRecLeft -= nReadSize;
         nBytesLeft -= nReadSize;
         if( nBytesLeft )
-            StartContinue();
+            JumpToNextContinue();
+        DBG_ASSERT( mbValid, "XclImpStream::Ignore - record overread" );
     }
 }
 
-
 // ----------------------------------------------------------------------------
 
-void XclImpStream::StartStringContinue( bool& rb16Bit )
-{
-    DBG_ASSERT( !mbWarnings || !mnRecLeft, "XclImpStream::StartStringContinue - unexpected garbage" );
-
-    if( mbCont && GetRecLeft() )
-        StartContinue();
-    else if( mnRecId == EXC_ID_CONT )   // start next CONTINUE for TXO import
-    {
-        sal_uInt16 nNewNum, nNewSize;
-        mbValidRec = GetNextRecord( nNewNum, nNewSize ) && (nNewNum || nNewSize);
-        mbValid = mbValidRec && (nNewNum == EXC_ID_CONT);
-        if( mbValid )
-        {
-            mnRecSize = nNewSize;
-            mnNextRecPos = Tell() + nNewSize;
-            SetupRecord();
-        }
-    }
-    else
-        mbValid = false;
-
-    if( mbValid )
-        rb16Bit = HasFlag( ReaduInt8(), EXC_STRF_16BIT );
-}
-
 sal_uInt32 XclImpStream::ReadUniStringExtHeader(
         bool& rb16Bit, bool& rbRich, bool& rbFareast,
-        sal_uInt16& rnCrun, sal_uInt32& rnExtInf, sal_uInt8 nFlags )
+        sal_uInt16& rnFormatRuns, sal_uInt32& rnExtInf, sal_uInt8 nFlags )
 {
-    DBG_ASSERT( !HasFlag( nFlags, EXC_STRF_UNKNOWN ), "XclImpStream::ReadUniStringExt - unknown flags" );
-    rb16Bit = HasFlag( nFlags, EXC_STRF_16BIT );
-    rbRich = HasFlag( nFlags, EXC_STRF_RICH );
-    rbFareast = HasFlag( nFlags, EXC_STRF_FAREAST );
-    rnCrun = rbRich ? ReaduInt16() : 0;
+    DBG_ASSERT( !::get_flag( nFlags, EXC_STRF_UNKNOWN ), "XclImpStream::ReadUniStringExt - unknown flags" );
+    rb16Bit = ::get_flag( nFlags, EXC_STRF_16BIT );
+    rbRich = ::get_flag( nFlags, EXC_STRF_RICH );
+    rbFareast = ::get_flag( nFlags, EXC_STRF_FAREAST );
+    rnFormatRuns = rbRich ? ReaduInt16() : 0;
     rnExtInf = rbFareast ? ReaduInt32() : 0;
-    return rnExtInf + 4UL * rnCrun;
+    return rnExtInf + 4 * rnFormatRuns;
 }
 
 sal_uInt32 XclImpStream::ReadUniStringExtHeader( bool& rb16Bit, sal_uInt8 nFlags )
@@ -807,10 +814,13 @@
     return ReadUniStringExtHeader( rb16Bit, bRich, bFareast, nCrun, nExtInf, nFlags );
 }
 
-void XclImpStream::AppendRawUniString( String& rString, sal_uInt16 nChars, bool b16Bit )
+// ----------------------------------------------------------------------------
+
+String XclImpStream::ReadRawUniString( sal_uInt16 nChars, bool b16Bit )
 {
-    sal_uInt32 nCharsLeft = nChars;
-    sal_uInt32 nReadSize;
+    String aRet;
+    sal_uInt16 nCharsLeft = nChars;
+    sal_uInt16 nReadSize;
 
     sal_Unicode* pcBuffer = new sal_Unicode[ nCharsLeft + 1 ];
 
@@ -818,12 +828,12 @@
     {
         if( b16Bit )
         {
-            nReadSize = ::std::min( nCharsLeft, mnRecLeft / 2 );
-            DBG_ASSERT( !mbWarnings || (nReadSize <= nCharsLeft) || !(mnRecLeft & 0x1),
+            nReadSize = ::std::min< sal_uInt16 >( nCharsLeft, mnRawRecLeft / 2 );
+            DBG_ASSERT( (nReadSize <= nCharsLeft) || !(mnRawRecLeft & 0x1),
                 "XclImpStream::ReadRawUniString - missing a byte" );
         }
         else
-            nReadSize = ::std::min( nCharsLeft, mnRecLeft );
+            nReadSize = GetMaxRawReadSize( nCharsLeft );
 
         sal_Unicode* pcUniChar = pcBuffer;
         sal_Unicode* pcEndChar = pcBuffer + nReadSize;
@@ -848,117 +858,226 @@
         }
 
         *pcEndChar = '\0';
-        rString.Append( pcBuffer );
+        aRet.Append( pcBuffer );
 
         nCharsLeft -= nReadSize;
         if( nCharsLeft )
-            StartStringContinue( b16Bit );
+            JumpToNextStringContinue( b16Bit );
     }
 
     delete[] pcBuffer;
+    return aRet;
+}
+
+String XclImpStream::ReadUniString( sal_uInt16 nChars, sal_uInt8 nFlags )
+{
+    bool b16Bit;
+    sal_uInt32 nExtSize = ReadUniStringExtHeader( b16Bit, nFlags );
+    String aRet( ReadRawUniString( nChars, b16Bit ) );
+    SkipUniStringExtData( nExtSize );
+    return aRet;
+}
+
+String XclImpStream::ReadUniString( sal_uInt16 nChars )
+{
+    return ReadUniString( nChars, ReaduInt8() );
+}
+
+String XclImpStream::ReadUniString()
+{
+    return ReadUniString( ReaduInt16() );
 }
 
 void XclImpStream::IgnoreRawUniString( sal_uInt16 nChars, bool b16Bit )
 {
-    sal_uInt32 nCharsLeft = nChars;
-    sal_uInt32 nReadSize;
+    sal_uInt16 nCharsLeft = nChars;
+    sal_uInt16 nReadSize;
 
     while( IsValid() && nCharsLeft )
     {
         if( b16Bit )
         {
-            nReadSize = ::std::min( nCharsLeft, mnRecLeft / 2 );
-            DBG_ASSERT( !mbWarnings || (nReadSize <= nCharsLeft) || !(mnRecLeft & 0x1),
+            nReadSize = ::std::min< sal_uInt16 >( nCharsLeft, mnRawRecLeft / 2 );
+            DBG_ASSERT( (nReadSize <= nCharsLeft) || !(mnRawRecLeft & 0x1),
                 "XclImpStream::IgnoreRawUniString - missing a byte" );
             Ignore( nReadSize * 2 );
         }
         else
         {
-            nReadSize = ::std::min( nCharsLeft, mnRecLeft );
+            nReadSize = GetMaxRawReadSize( nCharsLeft );
             Ignore( nReadSize );
         }
 
         nCharsLeft -= nReadSize;
         if( nCharsLeft )
-            StartStringContinue( b16Bit );
+            JumpToNextStringContinue( b16Bit );
     }
 }
 
-void XclImpStream::AppendUniString( String& rString, sal_uInt16 nChars, sal_uInt8 nFlags )
+void XclImpStream::IgnoreUniString( sal_uInt16 nChars, sal_uInt8 nFlags )
 {
     bool b16Bit;
     sal_uInt32 nExtSize = ReadUniStringExtHeader( b16Bit, nFlags );
-    AppendRawUniString( rString, nChars, b16Bit );
+    IgnoreRawUniString( nChars, b16Bit );
     SkipUniStringExtData( nExtSize );
 }
 
-String XclImpStream::ReadRawUniString( sal_uInt16 nChars, bool b16Bit )
+void XclImpStream::IgnoreUniString( sal_uInt16 nChars )
 {
-    String aRet;
-    AppendRawUniString( aRet, nChars, b16Bit );
-    return aRet;
+    IgnoreUniString( nChars, ReaduInt8() );
 }
 
-String XclImpStream::ReadUniString( sal_uInt16 nChars, sal_uInt8 nFlags )
+void XclImpStream::IgnoreUniString()
 {
-    String aRet;
-    AppendUniString( aRet, nChars, nFlags );
-    return aRet;
+    IgnoreUniString( ReaduInt16() );
 }
 
-String XclImpStream::ReadUniString( sal_uInt16 nChars )
+// ----------------------------------------------------------------------------
+
+String XclImpStream::ReadRawByteString( sal_uInt16 nChars )
 {
-    String aRet;
-    AppendUniString( aRet, nChars );
+    sal_Char* pcBuffer = new sal_Char[ nChars + 1 ];
+    sal_uInt16 nCharsRead = ReadRawData( pcBuffer, nChars );
+    pcBuffer[ nCharsRead ] = '\0';
+    String aRet( pcBuffer, mrRoot.GetCharSet() );
+    delete[] pcBuffer;
     return aRet;
 }
 
-String XclImpStream::ReadUniString()
+String XclImpStream::ReadByteString( bool b16BitLen )
 {
-    String aRet;
-    AppendUniString( aRet );
-    return aRet;
+    return ReadRawByteString( ReadByteStrLen( b16BitLen ) );
 }
 
-void XclImpStream::IgnoreUniString( sal_uInt16 nChars, sal_uInt8 nFlags )
+void XclImpStream::IgnoreRawByteString( sal_uInt16 nChars )
 {
-    bool b16Bit;
-    sal_uInt32 nExtSize = ReadUniStringExtHeader( b16Bit, nFlags );
-    IgnoreRawUniString( nChars, b16Bit );
-    SkipUniStringExtData( nExtSize );
+    Ignore( nChars );
 }
 
-void XclImpStream::AppendRawByteString( String& rString, sal_uInt16 nChars )
+void XclImpStream::IgnoreByteString( bool b16BitLen )
 {
-    sal_Char* pcBuffer = new sal_Char[ nChars + 1 ];
-    sal_uInt32 nCharsRead = ReadData( pcBuffer, nChars );
-    pcBuffer[ nCharsRead ] = '\0';
-    rString.Append( String( pcBuffer, mrRoot.GetCharSet() ) );
-    delete[] pcBuffer;
+    IgnoreRawByteString( ReadByteStrLen( b16BitLen ) );
 }
 
-String XclImpStream::ReadRawByteString( sal_uInt16 nChars )
+// private --------------------------------------------------------------------
+
+void XclImpStream::StorePosition( XclImpStreamPos& rPos )
 {
-    String aRet;
-    AppendRawByteString( aRet, nChars );
-    return aRet;
+    rPos.Set( mrStrm, mnNextRecPos, mnCurrRecSize, mnRawRecId, mnRawRecSize, mnRawRecLeft, mbValid );
 }
 
-String XclImpStream::ReadByteString( bool b16BitLen )
+void XclImpStream::RestorePosition( const XclImpStreamPos& rPos )
 {
-    String aRet;
-    AppendByteString( aRet, b16BitLen );
-    return aRet;
+    rPos.Get( mrStrm, mnNextRecPos, mnCurrRecSize, mnRawRecId, mnRawRecSize, mnRawRecLeft, mbValid );
+    SetupDecrypter();
 }
 
+bool XclImpStream::ReadNextRawRecHeader()
+{
+    mrStrm.Seek( mnNextRecPos );
+    bool bRet = (mnNextRecPos < mnStreamSize);
+    if( bRet )
+        mrStrm >> mnRawRecId >> mnRawRecSize;
+    return bRet;
+}
 
-// ----------------------------------------------------------------------------
+void XclImpStream::SetupDecrypter()
+{
+    if( mxDecrypter.get() )
+        mxDecrypter->Update( mrStrm, mnRawRecSize );
+}
 
-sal_uInt32 XclImpStream::Tell() const
+void XclImpStream::SetupRawRecord()
 {
-    return mrStrm.Tell();
+    // pre: mnRawRecSize contains current raw record size
+    // pre: mrStrm points to start of raw record data
+    mnNextRecPos = mrStrm.Tell() + mnRawRecSize;
+    mnRawRecLeft = mnRawRecSize;
+    mnCurrRecSize += mnRawRecSize;
+    SetupDecrypter();   // decrypter works on raw record level
 }
 
+void XclImpStream::SetupRecord()
+{
+    mnRecId = mnRawRecId;
+    mnAltContId = EXC_ID_UNKNOWN;
+    mnCurrRecSize = 0;
+    mnComplRecSize = mnRawRecSize;
+    mbHasComplRec = !mbCont;
+    SetupRawRecord();
+    SetNulSubstChar();
+    EnableDecryption();
+    StorePosition( maFirstRec );
+}
+
+bool XclImpStream::IsContinueId( sal_uInt16 nRecId ) const
+{
+    return (nRecId == EXC_ID_CONT) || (nRecId == mnAltContId);
+}
+
+bool XclImpStream::JumpToNextContinue()
+{
+    mbValid = mbValid && (mbCont || IsContinueId( mnRecId ));
+    if( mbValid )
+        mbValid = ReadNextRawRecHeader() && IsContinueId( mnRawRecId );
+    if( mbValid )   // do not setup a following non-CONTINUE record
+        SetupRawRecord();
+    return mbValid;
+}
+
+bool XclImpStream::JumpToNextStringContinue( bool& rb16Bit )
+{
+    DBG_ASSERT( !mnRawRecLeft, "XclImpStream::JumpToNextStringContinue - unexpected garbage" );
+
+    if( mbCont && GetRecLeft() )
+    {
+        JumpToNextContinue();
+    }
+    else if( mnRecId == EXC_ID_CONT )
+    {
+        // CONTINUE handling is off, but we have started reading in a CONTINUE record
+        // -> start next CONTINUE for TXO import
+        mbValidRec = ReadNextRawRecHeader() && (mnRawRecId || mnRawRecSize);
+        mbValid = mbValidRec && (mnRawRecId == EXC_ID_CONT);
+        // we really start a new record here - no chance to return to string origin
+        if( mbValid )
+            SetupRecord();
+    }
+    else
+        mbValid = false;
+
+    if( mbValid )
+        rb16Bit = ::get_flag( ReaduInt8(), EXC_STRF_16BIT );
+    return mbValid;
+}
+
+bool XclImpStream::EnsureRawReadSize( sal_uInt16 nBytes )
+{
+    if( mbValid && nBytes )
+    {
+        while( mbValid && !mnRawRecLeft ) JumpToNextContinue();
+        mbValid = mbValid && (nBytes <= mnRawRecLeft);
+        DBG_ASSERT( mbValid, "XclImpStream::EnsureRawReadSize - record overread" );
+    }
+    return mbValid;
+}
+
+sal_uInt16 XclImpStream::GetMaxRawReadSize( sal_uInt32 nBytes ) const
+{
+    return static_cast< sal_uInt16 >( ::std::min< sal_uInt32 >( nBytes, mnRawRecLeft ) );
+}
+
+sal_uInt16 XclImpStream::ReadRawData( void* pData, sal_uInt16 nBytes )
+{
+    DBG_ASSERT( (nBytes <= mnRawRecLeft), "XclImpStream::ReadRawData - record overread" );
+    sal_uInt16 nRet = 0;
+    if( mbUseDecr )
+        nRet = mxDecrypter->Read( mrStrm, pData, nBytes );
+    else
+        nRet = static_cast< sal_uInt16 >( mrStrm.Read( pData, nBytes ) );
+    mnRawRecLeft -= nRet;
+    return nRet;
+}
 
 // ============================================================================
 
Index: sc/source/filter/excel/xistyle.cxx
===================================================================
RCS file: /cvs/sc/sc/source/filter/excel/xistyle.cxx,v
retrieving revision 1.14
retrieving revision 1.13.6.2
diff -w -u -r1.14 -r1.13.6.2
--- sc/source/filter/excel/xistyle.cxx	4 Jun 2004 10:47:43 -0000	1.14
+++ sc/source/filter/excel/xistyle.cxx	14 Jul 2004 10:19:39 -0000	1.13.6.2
@@ -425,14 +425,12 @@
 
 void XclImpFont::ReadFontName2( XclImpStream& rStrm )
 {
-    maData.maName.Erase();
-    rStrm.AppendByteString( maData.maName, false );
+    maData.maName = rStrm.ReadByteString( false );
 }
 
 void XclImpFont::ReadFontName8( XclImpStream& rStrm )
 {
-    maData.maName.Erase();
-    rStrm.AppendUniString( maData.maName, rStrm.ReaduInt8() );
+    maData.maName = rStrm.ReadUniString( rStrm.ReaduInt8() );
 }
 
 void XclImpFont::GuessScriptType()
@@ -677,7 +675,7 @@
     {
         case xlBiff2:
         case xlBiff3:
-            rStrm.AppendByteString( aFormat, false );
+            aFormat = rStrm.ReadByteString( false );
             bAppend = true;
         break;
 
@@ -687,12 +685,12 @@
         case xlBiff5:
         case xlBiff7:
             rStrm >> nIndex;
-            rStrm.AppendByteString( aFormat, false );
+            aFormat = rStrm.ReadByteString( false );
         break;
 
         case xlBiff8:
             rStrm >> nIndex;
-            rStrm.AppendUniString( aFormat );
+            aFormat = rStrm.ReadUniString();
         break;
 
         default:
@@ -1486,9 +1484,9 @@
         {
             String aStyleName;
             if( GetBiff() < xlBiff8 )
-                rStrm.AppendByteString( aStyleName, false );    // 8 bit length
+                aStyleName = rStrm.ReadByteString( false );    // 8 bit length
             else
-                rStrm.AppendUniString( aStyleName );
+                aStyleName = rStrm.ReadUniString();
             if( aStyleName.Len() )  // #i1624# #i1768# ignore unnamed styles
                 pXF->SetStyleName( aStyleName );
         }
Index: sc/source/filter/excel/xlocx.cxx
===================================================================
RCS file: /cvs/sc/sc/source/filter/excel/xlocx.cxx,v
retrieving revision 1.9
retrieving revision 1.6.6.2
diff -w -u -r1.9 -r1.6.6.2
--- sc/source/filter/excel/xlocx.cxx	28 Jun 2004 17:58:28 -0000	1.9
+++ sc/source/filter/excel/xlocx.cxx	14 Jul 2004 10:20:07 -0000	1.6.6.2
@@ -218,7 +218,7 @@
     XclOcxConverter( rRoot ),
     XclImpRoot( rRoot )
 {
-    mxStrm = ScfTools::OpenStorageStreamRead( GetRootStorage(), EXC_STREAMNAME_CTLS );
+    mxStrm = OpenStream( EXC_STREAMNAME_CTLS );
 }
 
 bool XclImpOcxConverter::CreateSdrUnoObj( XclImpEscherOle& rOcxCtrl )
@@ -457,7 +457,7 @@
         {
             // output stream
             if( !mxStrm.Is() )
-                mxStrm = ScfTools::OpenStorageStreamWrite( GetRootStorage(), EXC_STREAMNAME_CTLS );
+                mxStrm = OpenStream( EXC_STREAMNAME_CTLS );
             if( mxStrm.Is() )
             {
                 String aClassName;
Index: sc/source/filter/excel/xlroot.cxx
===================================================================
RCS file: /cvs/sc/sc/source/filter/excel/xlroot.cxx,v
retrieving revision 1.12
retrieving revision 1.11.6.5
diff -w -u -r1.12 -r1.11.6.5
--- sc/source/filter/excel/xlroot.cxx	4 Jun 2004 10:48:23 -0000	1.12
+++ sc/source/filter/excel/xlroot.cxx	16 Jul 2004 17:39:37 -0000	1.11.6.5
@@ -68,12 +68,18 @@
 #ifndef _SV_SVAPP_HXX
 #include <vcl/svapp.hxx>
 #endif
+#ifndef _SFXSTRITEM_HXX
+#include <svtools/stritem.hxx>
+#endif
 #ifndef _SFX_OBJSH_HXX
 #include <sfx2/objsh.hxx>
 #endif
 #ifndef _SFX_PRINTER_HXX
 #include <sfx2/printer.hxx>
 #endif
+#ifndef _SFXDOCFILE_HXX
+#include <sfx2/docfile.hxx>
+#endif
 #ifndef _SV_FONT_HXX
 #include <vcl/font.hxx>
 #endif
@@ -81,10 +87,6 @@
 #include <svx/editstat.hxx>
 #endif
 
-#ifndef _COM_SUN_STAR_UNO_REFERENCE_HXX_
-#include <com/sun/star/uno/Reference.hxx>
-#endif
-
 #ifndef SC_ITEMS_HXX
 #include "scitems.hxx"
 #endif
@@ -114,6 +116,9 @@
 #include "patattr.hxx"
 #endif
 
+#ifndef SC_FAPIHELPER_HXX
+#include "fapihelper.hxx"
+#endif
 #ifndef SC_XLSTYLE_HXX
 #include "xlstyle.hxx"
 #endif
@@ -123,20 +128,17 @@
 
 #include "root.hxx"
 
-
 namespace com { namespace sun { namespace star { namespace frame { class XModel; } } } }
 
 using ::com::sun::star::uno::Reference;
 using ::com::sun::star::frame::XModel;
 
-
 // Global data ================================================================
 
-XclRootData::XclRootData( XclBiff eBiff, ScDocument& rDocument, const String& rDocUrl, CharSet eCharSet ) :
+XclRootData::XclRootData( XclBiff eBiff, SfxMedium& rMedium, ScDocument& rDocument, CharSet eCharSet, bool bExport ) :
     meBiff( eBiff ),
+    mrMedium( rMedium ),
     mrDoc( rDocument ),
-    maDocUrl( rDocUrl ),
-    maBasePath( rDocUrl, 0, rDocUrl.SearchBackward( '/' ) + 1 ),
     meCharSet( eCharSet ),
     meSysLang( Application::GetSettings().GetLanguage() ),
     meDocLang( Application::GetSettings().GetLanguage() ),
@@ -148,17 +150,29 @@
             static_cast<SCTAB>(EXC_MAXTAB2) ),
     mnCharWidth( 110 ),
     mnScTab( 0 ),
+    mbExport( bExport ),
     mbTruncated( false ),
-    mpRDP( new RootData )//!
+    mbHasPassw( false ),
+    mxRD( new RootData )//!
 {
 #ifdef DBG_UTIL
     mnObjCnt = 0;
 #endif
 
+    // document URL and path
+    if( const SfxItemSet* pItemSet = mrMedium.GetItemSet() )
+        if( const SfxStringItem* pItem = static_cast< const SfxStringItem* >( pItemSet->GetItem( SID_FILE_NAME ) ) )
+            maDocUrl = pItem->GetValue();
+    maBasePath = maDocUrl.Copy( 0, maDocUrl.SearchBackward( '/' ) + 1 );
+
+    // extended document options
     if( mrDoc.GetExtDocOptions() )
         mpExtDocOpt.reset( new ScExtDocOptions( *mrDoc.GetExtDocOptions() ) );
     else
         mpExtDocOpt.reset( new ScExtDocOptions );
+
+    mpTracer.reset( new XclTracer( maDocUrl, CREATE_OUSTRING(
+        mbExport ? "Office.Tracing/Export/Excel" : "Office.Tracing/Import/Excel" ) ) );
 }
 
 XclRootData::~XclRootData()
@@ -168,12 +182,11 @@
 #endif
 }
 
-
 // ----------------------------------------------------------------------------
 
 XclRoot::XclRoot( XclRootData& rRootData ) :
     mrData( rRootData ),
-    mpRD( rRootData.mpRDP.get() )//!
+    mpRD( rRootData.mxRD.get() )//!
 {
 #ifdef DBG_UTIL
     ++mrData.mnObjCnt;
@@ -264,6 +277,48 @@
     mrData.maMaxPos.SetTab( ::std::min( mrData.maScMaxPos.Tab(), mrData.maXclMaxPos.Tab() ) );
 }
 
+const String& XclRoot::QueryPassword() const
+{
+    if( !mrData.mbHasPassw )
+    {
+        mrData.maPassw = ScfApiHelper::QueryPasswordForMedium( GetMedium() );
+        // set to true, even if dialog has been cancelled (never ask twice)
+        mrData.mbHasPassw = true;
+
+        GetExtDocOptions().SetWinEncryption( true );
+    }
+    return mrData.maPassw;
+}
+
+SvStorage* XclRoot::GetRootStorage() const
+{
+    return GetMedium().GetStorage();
+}
+
+SvStorageRef XclRoot::OpenStorage( SvStorage* pStrg, const String& rStrgName ) const
+{
+    return mrData.mbExport ?
+        ScfTools::OpenStorageWrite( pStrg, rStrgName ) :
+        ScfTools::OpenStorageRead( pStrg, rStrgName );
+}
+
+SvStorageRef XclRoot::OpenStorage( const String& rStrgName ) const
+{
+    return OpenStorage( GetRootStorage(), rStrgName );
+}
+
+SvStorageStreamRef XclRoot::OpenStream( SvStorage* pStrg, const String& rStrmName ) const
+{
+    return mrData.mbExport ?
+        ScfTools::OpenStorageStreamWrite( pStrg, rStrmName ) :
+        ScfTools::OpenStorageStreamRead( pStrg, rStrmName );
+}
+
+SvStorageStreamRef XclRoot::OpenStream( const String& rStrmName ) const
+{
+    return OpenStream( GetRootStorage(), rStrmName );
+}
+
 SfxObjectShell* XclRoot::GetDocShell() const
 {
     return GetDoc().GetDocumentShell();
@@ -295,11 +350,6 @@
     return *GetDoc().GetRangeName();
 }
 
-SvStorage* XclRoot::GetRootStorage() const
-{
-    return mpRD->pRootStorage;
-}
-
 ScEditEngineDefaulter& XclRoot::GetEditEngine() const
 {
     if( !mrData.mpEditEngine.get() )
@@ -408,7 +458,6 @@
             delete rRanges.Remove( nIndex );
     }
 }
-
 
 // ============================================================================
 
cvs server: tag CWS_SRC680_ENCRYPTION_ANCHOR is not in file sc/source/filter/excel/xlstream.cxx
cvs server: Diffing sc/source/filter/ftools
Index: sc/source/filter/ftools/fapihelper.cxx
===================================================================
RCS file: /cvs/sc/sc/source/filter/ftools/fapihelper.cxx,v
retrieving revision 1.2
retrieving revision 1.2.280.2
diff -w -u -r1.2 -r1.2.280.2
--- sc/source/filter/ftools/fapihelper.cxx	26 Mar 2003 18:04:50 -0000	1.2
+++ sc/source/filter/ftools/fapihelper.cxx	16 Jul 2004 17:43:07 -0000	1.2.280.2
@@ -59,24 +59,48 @@
  *
  ************************************************************************/
 
-#ifdef PCH
-#include "filt_pch.hxx"
-#endif
-#pragma hdrstop
-
 // ============================================================================
 
 #ifndef SC_FAPIHELPER_HXX
 #include "fapihelper.hxx"
 #endif
 
+#ifndef _COM_SUN_STAR_TASK_XINTERACTIONHANDLER_HPP_
+#include <com/sun/star/task/XInteractionHandler.hpp>
+#endif
+#ifndef _COM_SUN_STAR_TASK_XINTERACTIONREQUEST_HPP_
+#include <com/sun/star/task/XInteractionRequest.hpp>
+#endif
+
+#ifndef _URLOBJ_HXX
+#include <tools/urlobj.hxx>
+#endif
+// no include guard in this header!!!
+//#ifndef ...
+#include <svtools/docpasswdrequest.hxx>
+//#endif
+#ifndef _SFXDOCFILE_HXX
+#include <sfx2/docfile.hxx>
+#endif
+#ifndef _SFXSTRITEM_HXX //SfxStringItem
+#include <svtools/stritem.hxx>
+#endif
+#ifndef _SFXITEMSET_HXX
+#include <svtools/itemset.hxx>
+#endif
+#ifndef _SFXSIDS_HRC
+#include <sfx2/sfxsids.hrc>
+#endif
+
+
 using ::rtl::OUString;
 using ::com::sun::star::uno::Any;
 using ::com::sun::star::uno::Reference;
 using ::com::sun::star::uno::Exception;
 using ::com::sun::star::beans::XPropertySet;
 using ::com::sun::star::beans::XPropertySetInfo;
-
+using ::com::sun::star::task::XInteractionHandler;
+using ::com::sun::star::task::XInteractionRequest;
 
 // Set properties =============================================================
 
@@ -116,6 +139,42 @@
     return bSuccess;
 }
 
+// Static helper functions ====================================================
+
+String ScfApiHelper::QueryPasswordForMedium( SfxMedium& rMedium )
+{
+    String aPassw;
+    const SfxItemSet* pSet = rMedium.GetItemSet();
+    const SfxPoolItem *pPasswordItem;
+               
+    if(pSet && SFX_ITEM_SET == pSet->GetItemState(SID_PASSWORD, TRUE, &pPasswordItem))
+        aPassw = ((const SfxStringItem *)pPasswordItem)->GetValue();
+    else
+    {
+        try
+        {
+            Reference< XInteractionHandler > xHandler( rMedium.GetInteractionHandler() );
+            if( xHandler.is() )
+            {
+                RequestDocumentPassword* pRequest = new RequestDocumentPassword(
+                    ::com::sun::star::task::PasswordRequestMode_PASSWORD_ENTER,
+                    INetURLObject( rMedium.GetOrigURL() ).GetName( INetURLObject::DECODE_WITH_CHARSET ) );
+                Reference< XInteractionRequest > xRequest( pRequest );
+
+               xHandler->handle( xRequest );
+
+    	       if( pRequest->isPassword() )
+                   aPassw = pRequest->getPassword();
+            }
+        }
+        catch( Exception& )
+        {
+        }
+    }
+
+    return aPassw;
+}
+
 
 // MultiPropertySets ==========================================================
 
Index: sc/source/filter/ftools/ftools.cxx
===================================================================
RCS file: /cvs/sc/sc/source/filter/ftools/ftools.cxx,v
retrieving revision 1.7
retrieving revision 1.7.6.1
diff -w -u -r1.7 -r1.7.6.1
--- sc/source/filter/ftools/ftools.cxx	2 Mar 2004 09:40:57 -0000	1.7
+++ sc/source/filter/ftools/ftools.cxx	25 Mar 2004 13:04:50 -0000	1.7.6.1
@@ -59,12 +59,6 @@
  *
  ************************************************************************/
 
-#ifdef PCH
-#include "filt_pch.hxx"
-#endif
-
-#pragma hdrstop
-
 // ============================================================================
 
 #ifndef SC_FTOOLS_HXX
@@ -239,26 +230,41 @@
             rName.SetChar( nPos, '_' );
 }
 
-
 // *** streams and storages *** -----------------------------------------------
 
-const SvStorageStreamRef ScfTools::OpenStorageStreamRead( SvStorage* pStorage, const String& rStrmName )
+SvStorageRef ScfTools::OpenStorageRead( SvStorage* pStrg, const String& rStrgName )
+{
+    SvStorageRef xSubStrg;
+    if( pStrg && pStrg->IsContained( rStrgName ) )
+        xSubStrg = pStrg->OpenStorage( rStrgName, STREAM_STD_READ );
+    return xSubStrg;
+}
+
+SvStorageRef ScfTools::OpenStorageWrite( SvStorage* pStrg, const String& rStrgName )
+{
+    SvStorageRef xSubStrg;
+    if( pStrg )
+        xSubStrg = pStrg->OpenStorage( rStrgName, STREAM_STD_WRITE );
+    return xSubStrg;
+}
+
+SvStorageStreamRef ScfTools::OpenStorageStreamRead( SvStorage* pStrg, const String& rStrmName )
 {
     SvStorageStreamRef xStrm;
-    if( pStorage && pStorage->IsContained( rStrmName ) && pStorage->IsStream( rStrmName ) )
-        xStrm = pStorage->OpenStream( rStrmName, STREAM_READ | STREAM_SHARE_DENYALL );
+    if( pStrg && pStrg->IsContained( rStrmName ) && pStrg->IsStream( rStrmName ) )
+        xStrm = pStrg->OpenStream( rStrmName, STREAM_STD_READ );
     return xStrm;
 }
 
-const SvStorageStreamRef ScfTools::OpenStorageStreamWrite( SvStorage* pStorage, const String& rStrmName )
+SvStorageStreamRef ScfTools::OpenStorageStreamWrite( SvStorage* pStrg, const String& rStrmName )
 {
+    DBG_ASSERT( !pStrg || !pStrg->IsContained( rStrmName ), "ScfTools::OpenStorageStreamWrite - stream exists already" );
     SvStorageStreamRef xStrm;
-    if( pStorage )
-        xStrm = pStorage->OpenStream( rStrmName/*, STREAM_READWRITE | STREAM_TRUNC*/ );
+    if( pStrg )
+        xStrm = pStrg->OpenStream( rStrmName, STREAM_STD_WRITE | STREAM_TRUNC );
     return xStrm;
 }
 
-
 // *** item handling *** ------------------------------------------------------
 
 bool ScfTools::CheckItem( const SfxItemSet& rItemSet, sal_uInt16 nWhichId, bool bDeep )
Index: sc/source/filter/inc/XclImpChangeTrack.hxx
===================================================================
RCS file: /cvs/sc/sc/source/filter/inc/XclImpChangeTrack.hxx,v
retrieving revision 1.14
retrieving revision 1.13.282.4
diff -w -u -r1.14 -r1.13.282.4
--- sc/source/filter/inc/XclImpChangeTrack.hxx	4 Jun 2004 10:50:45 -0000	1.14
+++ sc/source/filter/inc/XclImpChangeTrack.hxx	14 Jul 2004 10:22:59 -0000	1.13.282.4
@@ -118,7 +118,7 @@
 	String						sOldUsername;
 
 	ScChangeTrack*				pChangeTrack;
-	SvStream*					pInStrm;		// input stream
+    SvStorageStreamRef          xInStrm;        // input stream
 	XclImpStream*				pStrm;			// stream import class
 	sal_uInt16					nTabIdCount;
 	sal_Bool					bGlobExit;		// global exit loop
@@ -169,7 +169,7 @@
 	void						ReadRecords();
 
 public:
-								XclImpChangeTrack( RootData* pRootData );
+                                XclImpChangeTrack( RootData* pRootData, const XclImpStream& rBookStrm );
 								~XclImpChangeTrack();
 
 								// reads extended 3D ref info following the formulas, returns sc tab nums
@@ -214,7 +214,7 @@
 
 inline void XclImpChangeTrack::ReadString( String& rString )
 {
-    pStrm->AppendUniString( rString );
+    rString = pStrm->ReadUniString();
 }
 
 inline void XclImpChangeTrack::IgnoreString()
Index: sc/source/filter/inc/biffdump.hxx
===================================================================
RCS file: /cvs/sc/sc/source/filter/inc/biffdump.hxx,v
retrieving revision 1.11
retrieving revision 1.11.242.2
diff -w -u -r1.11 -r1.11.242.2
--- sc/source/filter/inc/biffdump.hxx	21 May 2003 08:01:01 -0000	1.11
+++ sc/source/filter/inc/biffdump.hxx	25 Mar 2004 13:15:17 -0000	1.11.242.2
@@ -86,8 +86,8 @@
 #ifndef _EXCFORM_HXX
 #include "excform.hxx"
 #endif
-#ifndef _ROOT_HXX
-#include "root.hxx"
+#ifndef SC_XIROOT_HXX
+#include "xiroot.hxx"
 #endif
 
 
@@ -171,7 +171,7 @@
 
 
 
-class Biff8RecDumper : public ExcRoot
+class Biff8RecDumper : public XclImpRoot
 {
 private:
 protected:
@@ -185,7 +185,6 @@
 
 	SvFileStream*				pDumpStream;
 	XclImpStream*				pIn;
-	SvStorage*					pPivotCache;
 
 	UINT32						nMaxBodyLines;
 	BOOL						bEndLoading;
@@ -197,6 +196,7 @@
 	BOOL						bBlankLine;
     BOOL                        bExportBookStream;
     BOOL                        bBIFF8;
+    bool                        bEncrypted;
 
 	UINT32						nFieldCnt;
 	UINT32						nItemCnt;
@@ -225,7 +225,7 @@
 
 	void						Print( const ByteString& rStr );
 	void						Print( const sal_Char* pStr );
-	void						DumpSubStream( SvStorage* pStorage, const sal_Char* pStreamName );
+    void                        DumpSubStream( SvStorage* pStorage, const String& rStrmName );
 	void						DumpPivotCache( const UINT16 nStrId );
 	UINT16						DumpXF( XclImpStream& rIn, const sal_Char* pPre );
 	void						DumpValidPassword( XclImpStream& rIn, const sal_Char* pPre );
@@ -236,6 +236,7 @@
 	void						ContDumpStream( SvStream& rStrm, const ULONG nL );
 	void						FormulaDump( const UINT16 nL, const FORMULA_TYPE eFT );
 	void						ControlsDump( SvStream& rIn );
+    void                        PreDumpDecrypted( ULONG nL );
 	static const sal_Char*		GetBlanks( const UINT16 nNumOfBlanks );
 	static BOOL					IsLineEnd( const sal_Char c, sal_Char& rNext, SvStream& rIn, INT32& rLeft );
 	void						Init( void );
@@ -286,7 +287,7 @@
 	inline const DUMP_ERR*		FirstErr( void );
 	inline const DUMP_ERR*		NextErr( void );
 public:
-                                Biff8RecDumper( RootData& rRootData, BOOL bBIFF8 );
+                                Biff8RecDumper( const XclImpRoot& rRoot, BOOL bBIFF8 );
 								~Biff8RecDumper();
 	BOOL						Dump( XclImpStream& rIn );
 								// = TRUE -> nicht weiter laden
Index: sc/source/filter/inc/excdefs.hxx
===================================================================
RCS file: /cvs/sc/sc/source/filter/inc/excdefs.hxx,v
retrieving revision 1.43
retrieving revision 1.41.6.2
diff -w -u -r1.43 -r1.41.6.2
--- sc/source/filter/inc/excdefs.hxx	4 Jun 2004 14:03:50 -0000	1.43
+++ sc/source/filter/inc/excdefs.hxx	14 Jul 2004 10:23:50 -0000	1.41.6.2
@@ -171,6 +171,9 @@
 #define EXC_OUTLINE_COUNT			(EXC_OUTLINE_MAX + 1)
 
 // defines for change tracking ================================================
+
+#define EXC_STREAM_USERNAMES        CREATE_STRING( "User Names" )
+#define EXC_STREAM_REVLOG           CREATE_STRING( "Revision Log" )
 
 // opcodes
 #define EXC_CHTR_OP_COLFLAG			0x0001
Index: sc/source/filter/inc/excimp8.hxx
===================================================================
RCS file: /cvs/sc/sc/source/filter/inc/excimp8.hxx,v
retrieving revision 1.53
retrieving revision 1.51.108.3
diff -w -u -r1.53 -r1.51.108.3
--- sc/source/filter/inc/excimp8.hxx	4 Jun 2004 14:04:06 -0000	1.53
+++ sc/source/filter/inc/excimp8.hxx	14 Jul 2004 10:24:17 -0000	1.51.108.3
@@ -153,11 +153,9 @@
 
     public:
 								ImportExcel8(
-									SvStorage*	pStorage,
+                                    SfxMedium&  rMedium,
 									SvStream&	aStream,
-									ScDocument*	pDoc,
-                                    const String& rDocUrl,
-									SvStorage*	pPivotCache );
+                                    ScDocument* pDoc );
 
 		virtual					~ImportExcel8( void );
 
Index: sc/source/filter/inc/exp_op.hxx
===================================================================
RCS file: /cvs/sc/sc/source/filter/inc/exp_op.hxx,v
retrieving revision 1.7
retrieving revision 1.6.272.2
diff -w -u -r1.7 -r1.6.272.2
--- sc/source/filter/inc/exp_op.hxx	4 Jun 2004 10:53:48 -0000	1.7
+++ sc/source/filter/inc/exp_op.hxx	14 Jul 2004 10:24:46 -0000	1.6.272.2
@@ -152,7 +152,7 @@
     RootData*           pExcRoot;
 
 public:
-                        ExportBiff5( SvStorage&, SvStream&, XclBiff, ScDocument*, const String& rBasePath, CharSet eDest, bool bRelUrl );
+                        ExportBiff5( SfxMedium& rMedium, SvStream&, XclBiff, ScDocument*, CharSet eDest, bool bRelUrl );
 	virtual				~ExportBiff5();
 	FltError			Write();
 };
@@ -163,7 +163,7 @@
 class ExportBiff8 : public ExportBiff5
 {
 public:
-                        ExportBiff8( SvStorage&, SvStream&, XclBiff, ScDocument*, const String& rBasePath, CharSet eDest, bool bRelUrl );
+                        ExportBiff8( SfxMedium& rMedium, SvStream&, XclBiff, ScDocument*, CharSet eDest, bool bRelUrl );
 	virtual				~ExportBiff8();
 };
 
Index: sc/source/filter/inc/fapihelper.hxx
===================================================================
RCS file: /cvs/sc/sc/source/filter/inc/fapihelper.hxx,v
retrieving revision 1.4
retrieving revision 1.4.140.1
diff -w -u -r1.4 -r1.4.140.1
--- sc/source/filter/inc/fapihelper.hxx	7 Aug 2003 15:30:15 -0000	1.4
+++ sc/source/filter/inc/fapihelper.hxx	23 Mar 2004 17:40:54 -0000	1.4.140.1
@@ -80,13 +80,15 @@
 #include <com/sun/star/beans/XMultiPropertySet.hpp>
 #endif
 
-#ifndef _TOOLS_DEBUG_HXX
-#include <tools/debug.hxx>
-#endif
 #ifndef _COMPHELPER_TYPES_HXX_
 #include <comphelper/types.hxx>
 #endif
 
+#ifndef SC_FTOOLS_HXX
+#include "ftools.hxx"
+#endif
+
+class SfxMedium;
 
 // ============================================================================
 
@@ -129,7 +131,6 @@
     ::setPropValue( xProp, rName, ::rtl::OUString( rText ) );
 }
 
-
 // Get properties =============================================================
 
 /** Puts the value of a property into an Any. The XPropertySet must be valid.
@@ -177,6 +178,16 @@
     return ::getPropBool( bRet, rxProp, rName ) && bRet;
 }
 
+// Static helper functions ====================================================
+
+/** Static API helper functions. */
+class ScfApiHelper : ScfNoInstance
+{
+public:
+    /** Opens a password dialog and returns the entered password.
+        @return  The entered password or an empty string on 'Cancel' or any error. */
+    static String       QueryPasswordForMedium( SfxMedium& rMedium );
+};
 
 // MultiPropertySets ==========================================================
 
@@ -223,6 +234,7 @@
                                     const XPropertySetRef& xPropSet );
 };
 
+// ----------------------------------------------------------------------------
 
 inline const ::rtl::OUString& ScfMultiPSHelper::getName( sal_Int32 nIndex ) const
 {
@@ -235,7 +247,6 @@
     DBG_ASSERT( (0 <= nIndex) && (nIndex < maValueSeq.getLength()), "ScfMultiPSHelper::getValue - invalid index" );
     return maValueSeq[ nIndex ];
 }
-
 
 // ============================================================================
 
Index: sc/source/filter/inc/ftools.hxx
===================================================================
RCS file: /cvs/sc/sc/source/filter/inc/ftools.hxx,v
retrieving revision 1.10
retrieving revision 1.7.108.3
diff -w -u -r1.10 -r1.7.108.3
--- sc/source/filter/inc/ftools.hxx	4 Jun 2004 14:07:10 -0000	1.10
+++ sc/source/filter/inc/ftools.hxx	14 Jul 2004 10:25:17 -0000	1.7.108.3
@@ -127,7 +124,7 @@
 /** Returns the value, if it is not greater than nMax, otherwise nMax. */
 template< typename ReturnType, typename Type >
 inline ReturnType ulimit( Type nValue, ReturnType nMax )
-{ return static_cast< ReturnType >( ::std::min< Type >( nValue, nMax ) ); }
+{ return static_cast< ReturnType >( ::std::min( nValue, static_cast< Type >( nMax ) ) ); }
 
 /** Returns the value, if it fits into ReturnType, otherwise the maximum value of ReturnType. */
 template< typename ReturnType, typename Type >
@@ -187,46 +183,6 @@
     (rnBitField &= ~(nMask << nStartBit)) |= (nNewValue << nStartBit);
 }
 
-
-// Modify values on bit-level -------------------------------------------------
-
-/** Rotates rnValue left by nBits bits. */
-template< typename Type >
-inline void rotate_left( Type& rnValue, sal_uInt8 nBits )
-{
-    DBG_ASSERT( nBits < sizeof( Type ) * 8, "rotate_left - overflow" );
-    rnValue = static_cast< Type >( (rnValue << nBits) | (rnValue >> (sizeof( Type ) * 8 - nBits)) );
-}
-
-/** Rotates the lower nWidth bits of rnValue left by nBits bits. */
-template< typename Type >
-inline void rotate_left( Type& rnValue, sal_uInt8 nBits, sal_uInt8 nWidth )
-{
-    DBG_ASSERT( (nBits < nWidth) && (nWidth < sizeof( Type ) * 8), "rotate_left - overflow" );
-    Type nMask = static_cast< Type >( (1UL << nWidth) - 1 );
-    rnValue = static_cast< Type >(
-        ((rnValue << nBits) | ((rnValue & nMask) >> (nWidth - nBits))) & nMask );
-}
-
-/** Rotates rnValue right by nBits bits. */
-template< typename Type >
-inline void rotate_right( Type& rnValue, sal_uInt8 nBits )
-{
-    DBG_ASSERT( nBits < sizeof( Type ) * 8, "rotate_right - overflow" );
-    return static_cast< Type >( (rnValue >> nBits) | (rnValue << (sizeof( Type ) * 8 - nBits)) );
-}
-
-/** Rotates the lower nWidth bits of rnValue right by nBits bits. */
-template< typename Type >
-inline void rotate_right( Type& rnValue, sal_uInt8 nBits, sal_uInt8 nWidth )
-{
-    DBG_ASSERT( (nBits < nWidth) && (nWidth < sizeof( Type ) * 8), "rotate_right - overflow" );
-    Type nMask = static_cast< Type >( (1UL << nWidth) - 1 );
-    return static_cast< Type >(
-        (((rnValue & nMask) >> nBits) | (rnValue << (nWidth - nBits))) & nMask );
-}
-
-
 // ============================================================================
 
 /** Deriving from this class prevents copy construction. */
@@ -239,29 +195,28 @@
     inline                      ScfNoCopy() {}
 };
 
-
 // ----------------------------------------------------------------------------
 
 /** Deriving from this class prevents construction in general. */
 class ScfNoInstance : private ScfNoCopy {};
 
-
 // ============================================================================
 
 class SfxPoolItem;
 class SfxItemSet;
 class ScStyleSheet;
 class ScStyleSheetPool;
+class SvStream;
 class SvStorage;
+class SvStorageRef;
 class SvStorageStreamRef;
-class SvStream;
 
 /** Contains static methods used anywhere in the filters. */
 class ScfTools : ScfNoInstance
 {
 public:
 
-// *** common methods ***
+// *** common methods *** -----------------------------------------------------
 
     /** Reads a 10-byte-long-double and converts it to double. */
     static double               ReadLongDouble( SvStream& rStrm );
@@ -270,12 +225,14 @@
     /** Returns a string representing the hexadecimal value of nValue. */
     static String               GetHexStr( sal_uInt16 nValue );
 
-    /** Mixes RGB components with given transparence (0x0000 == full nFore ... 0x8000 = full nBack). */
+    /** Mixes RGB components with given transparence.
+        @param nTrans  Foreground transparence (0x0000 == full nFore ... 0x8000 = full nBack). */
     static sal_uInt8            GetMixedColorComp( sal_uInt8 nFore, sal_uInt8 nBack, sal_uInt16 nTrans );
-    /** Mixes colors with given transparence (0x0000 == full rFore ... 0x8000 = full rBack). */
+    /** Mixes colors with given transparence.
+        @param nTrans  Foreground transparence (0x0000 == full rFore ... 0x8000 = full rBack). */
     static Color                GetMixedColor( const Color& rFore, const Color& rBack, sal_uInt16 nTrans );
 
-// *** conversion of names ***
+// *** conversion of names *** ------------------------------------------------
 
     /** Converts a string to a valid Calc sheet name.
         @descr  Sheet names in Calc may contain letters, digits, underscores, and spaces
@@ -287,14 +244,19 @@
         (*) = not allowed at first position. */
     static void                 ConvertToScDefinedName( String& rName );
 
-// *** streams and storages ***
+// *** streams and storages *** -----------------------------------------------
 
-    /** Tries to open the stream with the specified name in the passed storage (read-only). */
-    static const SvStorageStreamRef OpenStorageStreamRead( SvStorage* pStorage, const String& rStrmName );
-    /** Tries to create or open a stream with the specified name in the passed storage (read/write). */
-    static const SvStorageStreamRef OpenStorageStreamWrite( SvStorage* pStorage, const String& rStrmName );
+    /** Tries to open an existing stream with the specified name in the passed storage (read-only). */
+    static SvStorageRef         OpenStorageRead( SvStorage* pStrg, const String& rStrgName );
+    /** Creates and opens a stream with the specified name in the passed storage (read/write). */
+    static SvStorageRef         OpenStorageWrite( SvStorage* pStrg, const String& rStrgName );
+
+    /** Tries to open an existing stream with the specified name in the passed storage (read-only). */
+    static SvStorageStreamRef   OpenStorageStreamRead( SvStorage* pStrg, const String& rStrmName );
+    /** Creates and opens a stream with the specified name in the passed storage (read/write). */
+    static SvStorageStreamRef   OpenStorageStreamWrite( SvStorage* pStrg, const String& rStrmName );
 
-// *** item handling ***
+// *** item handling *** ------------------------------------------------------
 
     /** Returns true, if the passed item set contains the item.
         @param bDeep  true = Searches in parent item sets too. */
Index: sc/source/filter/inc/imp_op.hxx
===================================================================
RCS file: /cvs/sc/sc/source/filter/inc/imp_op.hxx,v
retrieving revision 1.25
retrieving revision 1.24.108.5
diff -w -u -r1.25 -r1.24.108.5
--- sc/source/filter/inc/imp_op.hxx	4 Jun 2004 10:55:05 -0000	1.25
+++ sc/source/filter/inc/imp_op.hxx	14 Jul 2004 10:25:50 -0000	1.24.108.5
@@ -186,7 +186,6 @@
 
     XclImpStream            maStrm;             // input stream
     XclImpStream&           aIn;                // input stream
-    String                  maPassword;
 
     NameBuffer*             pExtNameBuff;       // ... externe Namen (Ind.-Basis=1)
 	ExcelToSc*				pFormConv;			// Formel-Konverter
@@ -231,7 +230,6 @@
 	void					Externname25( void );			// 0x23
 	void					Colwidth( void );				// 0x24
 	void					Defrowheight2( void );			// 0x25
-	BOOL					Filepass( void );				// 0x2F
 //		void				Window1( void );				// 0x3D
 	void					Pane( void );					// 0x41
 	void					Codepage( void );				// 0x42
@@ -351,12 +349,9 @@
 											// Achtung: rUnconvertedText wird moeglicherweise veraendert
 
 public:
-                            ImportExcel( SvStream&, ScDocument*, const String& rDocUrl );
+                            ImportExcel( SfxMedium&, SvStream&, ScDocument* );
 
 	virtual					~ImportExcel( void );
-
-    /** Sets a password for stream decryption. */
-    inline void             SetPassword( const String& rPassword ) { maPassword = rPassword; }
 
 	virtual FltError		Read( void );
 };
Index: sc/source/filter/inc/root.hxx
===================================================================
RCS file: /cvs/sc/sc/source/filter/inc/root.hxx,v
retrieving revision 1.34
retrieving revision 1.31.6.3
diff -w -u -r1.34 -r1.31.6.3
--- sc/source/filter/inc/root.hxx	28 Jun 2004 17:59:07 -0000	1.34
+++ sc/source/filter/inc/root.hxx	14 Jul 2004 10:26:51 -0000	1.31.6.3
@@ -85,7 +85,6 @@
 #include "excdefs.hxx"
 #endif
 
-class SvStorage;
 class SvNumberFormatter;
 class ScRangeName;
 class ScProgress;
@@ -119,7 +118,6 @@
 
 struct RootData		// -> Inkarnation jeweils im ImportExcel-Objekt!
 {
-	SvStorage*			pRootStorage;			// THE storage
 	double				fRowScale;				//  Spaltenbreiten / Zeilenhoehen
 	ScDocument*			pDoc;
 	ScRangeName*		pScRangeName;
@@ -139,7 +137,6 @@
 	BOOL				bChartTab;				// Tabelle mit einem einzigen Chart
 
 	// Biff8
-	SvStorage*				pPivotCacheStorage;
     XclImpAutoFilterBuffer* pAutoFilterBuffer;      // ranges for autofilter and advanced filter
     _ScRangeListTabs*       pPrintRanges;
     _ScRangeListTabs*       pPrintTitles;
Index: sc/source/filter/inc/xeroot.hxx
===================================================================
RCS file: /cvs/sc/sc/source/filter/inc/xeroot.hxx,v
retrieving revision 1.9
retrieving revision 1.8.6.2
diff -w -u -r1.9 -r1.8.6.2
--- sc/source/filter/inc/xeroot.hxx	4 Jun 2004 14:05:21 -0000	1.9
+++ sc/source/filter/inc/xeroot.hxx	14 Jul 2004 10:29:13 -0000	1.8.6.2
@@ -107,8 +107,8 @@
 
     explicit                    XclExpRootData(
                                     XclBiff eBiff,
+                                    SfxMedium& rMedium,
                                     ScDocument& rDocument,
-                                    const String& rDocUrl,
                                     CharSet eCharSet,
                                     bool bRelUrl );
     virtual                     ~XclExpRootData();
Index: sc/source/filter/inc/xestream.hxx
===================================================================
RCS file: /cvs/sc/sc/source/filter/inc/xestream.hxx,v
retrieving revision 1.4
retrieving revision 1.4.108.1
diff -w -u -r1.4 -r1.4.108.1
--- sc/source/filter/inc/xestream.hxx	5 Nov 2003 13:40:58 -0000	1.4
+++ sc/source/filter/inc/xestream.hxx	17 Mar 2004 12:56:14 -0000	1.4.108.1
@@ -64,14 +64,9 @@
 #ifndef SC_XESTREAM_HXX
 #define SC_XESTREAM_HXX
 
-#ifndef _STREAM_HXX
-#include <tools/stream.hxx>
+#ifndef SC_XLSTREAM_HXX
+#include "xlstream.hxx"
 #endif
-
-#ifndef SC_FTOOLS_HXX
-#include "ftools.hxx"
-#endif
-
 
 /* ============================================================================
 Output stream class for Excel export
Index: sc/source/filter/inc/xicontent.hxx
===================================================================
RCS file: /cvs/sc/sc/source/filter/inc/xicontent.hxx,v
retrieving revision 1.6
retrieving revision 1.5.108.2
diff -w -u -r1.6 -r1.5.108.2
--- sc/source/filter/inc/xicontent.hxx	4 Jun 2004 14:05:42 -0000	1.6
+++ sc/source/filter/inc/xicontent.hxx	14 Jul 2004 10:29:22 -0000	1.5.108.2
@@ -80,7 +80,6 @@
 
 class XclImpStream;
 
-
 /* ============================================================================
 Classes to import the big Excel document contents (related to several cells or
 globals for the document).
@@ -90,6 +89,7 @@
 - Conditional formatting
 - Data validation
 - Web queries
+- Stream decryption
 ============================================================================ */
 
 // Shared string table ========================================================
@@ -113,7 +113,9 @@
     ScBaseCell*                 CreateCell( sal_uInt32 nSstIndex, sal_uInt32 nXFIndex = 0 ) const;
 
 private:
-    ScfDelList< XclImpString >  maStringList;       /// List with formatted and unformatted strings.
+    typedef ScfDelList< XclImpString > XclImpStringList;
+
+    XclImpStringList    maStringList;       /// List with formatted and unformatted strings.
     XclImpString                maErrorString;      /// Placeholder for strings not found in the list.
 };
 
@@ -211,14 +208,13 @@
     static void                 ReadDV( XclImpStream& rStrm );
 };
 
-
 // Web queries ================================================================
 
 /** Stores the data of one web query. */
 class XclImpWebQuery : ScfNoCopy
 {
 public:
-                                XclImpWebQuery( const ScRange& rDestRange );
+    explicit            XclImpWebQuery( const ScRange& rDestRange );
 
     /** Reads a PARAMQRY record and sets data to the web query. */
     void                        ReadParamqry( XclImpStream& rStrm );
@@ -249,14 +245,12 @@
     sal_uInt16                  mnRefresh;      /// Refresh time in minutes.
 };
 
-
 // ----------------------------------------------------------------------------
 
 class XclImpWebQueryBuffer : protected XclImpRoot
 {
 public:
-    inline                      XclImpWebQueryBuffer( const XclImpRoot& rRoot ) :
-                                    XclImpRoot( rRoot ) {}
+    inline explicit     XclImpWebQueryBuffer( const XclImpRoot& rRoot ) : XclImpRoot( rRoot ) {}
 
     /** Reads the QSI record and creates a new web query in the buffer. */
     void                        ReadQsi( XclImpStream& rStrm );
@@ -276,6 +270,16 @@
     ScfDelList< XclImpWebQuery > maWQList;      /// List of the web query objects.
 };
 
+// Decryption =================================================================
+
+/** Provides static functions to import stream decryption settings. */
+class XclImpDecryptHelper : ScfNoInstance
+{
+public:
+    /** Reads the FILEPASS record, queries a password and sets decryption algorihm.
+        @return  Error code that may cause an error message after import. */
+    static ErrCode      ReadFilepass( XclImpStream& rStrm );
+};
 
 // ============================================================================
 
Index: sc/source/filter/inc/xipivot.hxx
===================================================================
RCS file: /cvs/sc/sc/source/filter/inc/xipivot.hxx,v
retrieving revision 1.2
retrieving revision 1.2.72.1
diff -w -u -r1.2 -r1.2.72.1
--- sc/source/filter/inc/xipivot.hxx	4 Jun 2004 14:06:12 -0000	1.2
+++ sc/source/filter/inc/xipivot.hxx	14 Jul 2004 14:18:12 -0000	1.2.72.1
@@ -122,7 +122,7 @@
 class XclImpPivotCache : protected XclImpRoot
 {
 public:
-    explicit            XclImpPivotCache( const XclImpRoot& rRoot, sal_uInt16 nStrmId );
+    explicit            XclImpPivotCache( const XclImpStream& rBookStrm, sal_uInt16 nStrmId );
                         ~XclImpPivotCache();
 
     // data access ------------------------------------------------------------
Index: sc/source/filter/inc/xiroot.hxx
===================================================================
RCS file: /cvs/sc/sc/source/filter/inc/xiroot.hxx,v
retrieving revision 1.9
retrieving revision 1.8.6.2
diff -w -u -r1.9 -r1.8.6.2
--- sc/source/filter/inc/xiroot.hxx	4 Jun 2004 14:06:31 -0000	1.9
+++ sc/source/filter/inc/xiroot.hxx	14 Jul 2004 10:30:15 -0000	1.8.6.2
@@ -127,8 +127,8 @@
 
     explicit                    XclImpRootData(
                                     XclBiff eBiff,
+                                    SfxMedium& rMedium,
                                     ScDocument& rDocument,
-                                    const String& rDocUrl,
                                     CharSet eCharSet );
     virtual                     ~XclImpRootData();
 };
Index: sc/source/filter/inc/xistream.hxx
===================================================================
RCS file: /cvs/sc/sc/source/filter/inc/xistream.hxx,v
retrieving revision 1.4
retrieving revision 1.4.6.7
diff -w -u -r1.4 -r1.4.6.7
--- sc/source/filter/inc/xistream.hxx	2 Mar 2004 09:44:55 -0000	1.4
+++ sc/source/filter/inc/xistream.hxx	4 Jun 2004 11:32:10 -0000	1.4.6.7
@@ -64,227 +64,240 @@
 #ifndef SC_XISTREAM_HXX
 #define SC_XISTREAM_HXX
 
-#ifndef SC_FTOOLS_HXX
-#include "ftools.hxx"
+#ifndef SVX_MSCODEC_HXX
+#include <svx/mscodec.hxx>
 #endif
-#ifndef SC_XLCONST_HXX
-#include "xlconst.hxx"
+#ifndef SC_XLSTREAM_HXX
+#include "xlstream.hxx"
 #endif
 
+class XclImpRoot;
 
 /* ============================================================================
 Input stream class for Excel import
 - CONTINUE record handling
 - ByteString and UniString support
+- Decryption
 ============================================================================ */
 
-// Decryption =================================================================
+// ============================================================================
+// Decryption
+// ============================================================================
 
-#define SC_XCL_USEDECR 0
+class XclImpDecrypter;
+typedef ::boost::shared_ptr< XclImpDecrypter > XclImpDecrypterRef;
 
-#if SC_XCL_USEDECR
 /** Base class for BIFF stream decryption. */
 class XclImpDecrypter : ScfNoCopy
 {
 public:
+    explicit            XclImpDecrypter();
     virtual                     ~XclImpDecrypter();
 
-    /** Returns true, if the decrypter has been constructed successfully (especially
-        with a valid password). */
-    virtual bool                IsValid() const = 0;
-    /** Initializes the key array offset which is dependent from record size. */
-    virtual void                SetOffset( sal_uInt16 nRecSize ) = 0;
+    /** Returns the current error code of the decrypter. */
+    inline ErrCode      GetError() const { return mnError; }
+    /** Returns true, if the decrypter has been constructed successfully.
+        This means especially that construction happened with a valid password. */
+    inline bool         IsValid() const { return mnError == ERRCODE_NONE; }
+
+    /** Creates a (ref-counted) copy of this decrypter object. */
+    XclImpDecrypterRef  Clone() const;
+
+    /** Updates the decrypter on start of a new record or after seeking stream. */
+    void                Update( SvStream& rStrm, sal_uInt16 nRecSize );
     /** Reads and decrypts nBytes bytes and stores data into the existing(!) buffer pData.
         @return  Count of bytes really read. */
-    virtual sal_uInt32          ReadDecrypt( SvStream& rStrm, void* pData, sal_uInt32 nBytes ) = 0;
+    sal_uInt16          Read( SvStream& rStrm, void* pData, sal_uInt16 nBytes );
 
-    /** Calculates the 16-bit hash value for the given password. */
-    static sal_uInt16           GetHash( const ByteString& rPass );
-    /** Calculates the BIFF2-BIFF7 decryption key for the given password. */
-    static sal_uInt16           GetKey( const ByteString& rPass );
-};
+protected:
+    /** Protected copy c'tor for OnClone(). */
+    explicit            XclImpDecrypter( const XclImpDecrypter& rSrc );
+
+    /** Sets the decrypter to a state showing whether the password was correct. */
+    void                SetHasValidPassword( bool bValid );
 
+private:
+    /** Implementation of cloning this object. */
+    virtual XclImpDecrypter* OnClone() const = 0;
+    /** Implementation of updating the decrypter. */
+    virtual void        OnUpdate( ULONG nOldStrmPos, ULONG nNewStrmPos, sal_uInt16 nRecSize ) = 0;
+    /** Implementation of the decryption. */
+    virtual sal_uInt16  OnRead( SvStream& rStrm, sal_uInt8* pnData, sal_uInt16 nBytes ) = 0;
+
+private:
+    ErrCode             mnError;        /// Decrypter error code.
+    ULONG               mnOldPos;       /// Last known stream position.
+    sal_uInt16          mnRecSize;      /// Current record size.
+};
 
 // ----------------------------------------------------------------------------
 
-/** Decrypts BIFF5 stream contents using the given password and key. */
+/** Decrypts BIFF5 stream contents. */
 class XclImpBiff5Decrypter : public XclImpDecrypter
 {
-private:
-    sal_uInt8                   mpKey[ 16 ];    /// Decryption key.
-    sal_uInt32                  mnOffset;       /// Key/stream offset.
-    bool                        mbIsValid;      /// true = Password is valid.
-
 public:
     /** Constructs the decrypter.
-        @param nKey  Password key from FILEPASS record.
-        @param nHash  Password hash value from FILEPASS record. */
-    explicit                    XclImpBiff5Decrypter( const String& rPass, sal_uInt16 nKey, sal_uInt16 nHash );
-
-    /** Returns true, if the decrypter has been constructed successfully (especially
-        with a valid password). */
-    virtual bool                IsValid() const;
-    /** Initializes the key array offset dependent from record size. */
-    virtual void                SetOffset( sal_uInt16 nRecSize );
-    /** Reads and decrypts nBytes bytes and stores data into the existing(!) buffer pData.
-        @return  Count of bytes really read. */
-    virtual sal_uInt32          ReadDecrypt( SvStream& rStrm, void* pData, sal_uInt32 nBytes );
-};
+        @descr  Checks if the passed key and hash specify workbook protection.
+        Asks for a password otherwise.
+        @param nKey  Password key from FILEPASS record to verify password.
+        @param nHash  Password hash value from FILEPASS record to verify password. */
+    explicit            XclImpBiff5Decrypter( const XclImpRoot& rRoot, sal_uInt16 nKey, sal_uInt16 nHash );
+
+private:
+    /** Private copy c'tor for OnClone(). */
+    explicit            XclImpBiff5Decrypter( const XclImpBiff5Decrypter& rSrc );
 
+    /** Implementation of cloning this object. */
+    virtual XclImpBiff5Decrypter* OnClone() const;
+    /** Implementation of updating the decrypter. */
+    virtual void        OnUpdate( ULONG nOldStrmPos, ULONG nNewStrmPos, sal_uInt16 nRecSize );
+    /** Implementation of the decryption. */
+    virtual sal_uInt16  OnRead( SvStream& rStrm, sal_uInt8* pnData, sal_uInt16 nBytes );
+
+    /** Initializes the members.
+        @postcond  Internal status is set and can be querried with IsValid(). */
+    void                Init( const ByteString& rPass, sal_uInt16 nKey, sal_uInt16 nHash );
+
+private:
+    ::svx::MSCodec_XorXLS95 maCodec;       /// Crypto algorithm implementation.
+    sal_uInt8           mpnPassw[ 16 ]; /// Cached password data for copy construction.
+};
 
 // ----------------------------------------------------------------------------
 
-/** Decrypts BIFF8 stream contents using the given password and key. */
+/** Decrypts BIFF8 stream contents using the given document identifier. */
 class XclImpBiff8Decrypter : public XclImpDecrypter
 {
 public:
-    explicit                    XclImpBiff8Decrypter( const String& rPass );
+    /** Constructs the decrypter.
+        @descr  Checks if the passed salt data specifies workbook protection.
+        Asks for a password otherwise.
+        @param pnDocId  Unique document identifier from FILEPASS record.
+        @param pnSaltData  Salt data from FILEPASS record.
+        @param pnSaltHash  Salt hash value from FILEPASS record. */
+    explicit            XclImpBiff8Decrypter( const XclImpRoot& rRoot, sal_uInt8 pnDocId[ 16 ],
+                            sal_uInt8 pnSaltData[ 16 ], sal_uInt8 pnSaltHash[ 16 ] );
 
-    /** Returns true, if the decrypter has been constructed successfully (especially
-        with a valid password). */
-    virtual bool                IsValid() const;
-    /** Initializes the key array offset dependent from record size. */
-    virtual void                SetOffset( sal_uInt16 nRecSize );
-    /** Reads and decrypts nBytes bytes and stores data into the existing(!) buffer pData.
-        @return  Count of bytes really read. */
-    virtual sal_uInt32          ReadDecrypt( SvStream& rStrm, void* pData, sal_uInt32 nBytes );
-};
-#endif
+private:
+    /** Private copy c'tor for OnClone(). */
+    explicit            XclImpBiff8Decrypter( const XclImpBiff8Decrypter& rSrc );
+
+    /** Implementation of cloning this object. */
+    virtual XclImpBiff8Decrypter* OnClone() const;
+    /** Implementation of updating the decrypter. */
+    virtual void        OnUpdate( ULONG nOldStrmPos, ULONG nNewStrmPos, sal_uInt16 nRecSize );
+    /** Implementation of the decryption. */
+    virtual sal_uInt16  OnRead( SvStream& rStrm, sal_uInt8* pnData, sal_uInt16 nBytes );
+
+    /** Initializes the internal codec.
+        @postcond  Internal status is set and can be querried with IsValid(). */
+    void                Init( const String& rPass, sal_uInt8 pnDocId[ 16 ],
+                            sal_uInt8 pnSaltData[ 16 ], sal_uInt8 pnSaltHash[ 16 ] );
+
+    /** Returns the block number corresponding to the passed stream position. */
+    sal_uInt32          GetBlock( ULONG nStrmPos ) const;
+    /** Returns the block offset corresponding to the passed stream position. */
+    sal_uInt16          GetOffset( ULONG nStrmPos ) const;
 
+private:
+    ::svx::MSCodec_Std97 maCodec;       /// Crypto algorithm implementation.
+    sal_uInt16          mpnPassw[ 16 ]; /// Cached password data for copy construction.
+    sal_uInt8           mpnDocId[ 16 ]; /// Cached document ID for copy construction.
+};
 
 // ============================================================================
+// Stream
+// ============================================================================
 
 /** This class represents an Excel stream position.
     @descr  It contains the relevant data for a stream position inside of a record
     (including CONTINUE records). */
 class XclImpStreamPos
 {
-private:
-    sal_uInt32                  mnPos;          /// Absolute position of the stream.
-    sal_uInt32                  mnNextPos;      /// Absolute position of next record.
-    sal_uInt32                  mnCurrSize;     /// Current calculated size of the record.
-    sal_uInt32                  mnRecLeft;      /// Size left in current record.
-    sal_uInt16                  mnRecSize;      /// Size of record (without CONTINUE).
-
 public:
-    /** Constructs the stream position data with the passed values. */
-    explicit                    XclImpStreamPos(
-                                    sal_uInt32 nStrmPos, sal_uInt32 nNextPos,
-                                    sal_uInt32 nCurrSize, sal_uInt32 nRecLeft,
-                                    sal_uInt16 nRecSize );
+    /** Constructs an invalid stream position data object. */
+    explicit            XclImpStreamPos();
 
     /** Sets the stream position data to the passed values. */
-    void                        Set(
-                                    sal_uInt32 nStrmPos, sal_uInt32 nNextPos,
-                                    sal_uInt32 nCurrSize, sal_uInt32 nRecLeft,
-                                    sal_uInt16 nRecSize );
+    void                Set( const SvStream& rStrm, ULONG nNextPos, sal_uInt32 nCurrSize,
+                            sal_uInt16 nRawRecId, sal_uInt16 nRawRecSize, sal_uInt16 nRawRecLeft,
+                            bool bValid );
 
     /** Writes the contained stream position data to the given variables. */
-    void                        Get(
-                                    sal_uInt32& rnStrmPos, sal_uInt32& rnNextPos,
-                                    sal_uInt32& rnCurrSize, sal_uInt32& rnRecLeft,
-                                    sal_uInt16& rnRecSize ) const;
-};
+    void                Get( SvStream& rStrm, ULONG& rnNextPos, sal_uInt32& rnCurrSize,
+                            sal_uInt16& rnRawRecId, sal_uInt16& rnRawRecSize, sal_uInt16& rnRawRecLeft,
+                            bool& rbValid ) const;
 
+private:
+    ULONG               mnPos;          /// Absolute position of the stream.
+    ULONG               mnNextPos;      /// Absolute position of next record.
+    sal_uInt32          mnCurrSize;     /// Current calculated size of the record.
+    sal_uInt16          mnRawRecId;     /// Current raw record ID (including CONTINUEs).
+    sal_uInt16          mnRawRecSize;   /// Current raw record size (without following CONTINUEs).
+    sal_uInt16          mnRawRecLeft;   /// Bytes left in current raw record (without following CONTINUEs).
+    bool                mbValid;        /// Read state: false = record overread.
+};
 
-// ----------------------------------------------------------------------------
-
-class XclImpRoot;
+// ============================================================================
 
 /** This class is used to import record oriented streams.
     @descr  An instance is constructed with an SvStream. The SvStream stream is
     reset to its start while constructing this stream.
 
-    To start reading a record call StartNextRecord(). Now it is possible to read
-    all contents of the record using operator>>() or any of the Read***() methods.
-    If some data exceeds the record size limit, the stream looks for a following
-    CONTINUE record and jumps automatically to it. It is NOT allowed that an atomic
-    data type is split into two records (i.e. 4 bytes of a double in one record and
-    the other 4 bytes in a following CONTINUE).
-
-    Trying to read over the record limits results in a stream error. The IsValid()
-    method indicates that with returning false. From now on it is undefined what data
-    the read methods will return. The error state will be reset, if the record is
-    reset (with the method InitializeRecord()) or if the next record is started.
-
-    To switch off the automatic lookup of CONTINUE records, use InitializeRecord()
-    with false parameter. This is useful i.e. on import of Escher objects, where
-    sometimes solely CONTINUE records will occur. The automatic lookup keeps switched
-    off until the method InitializeRecord() is called with parameter true.
-
-    The import stream supports decrypting the stream data. The contents of a record
-    (not the record header) will be encrypted by Excel if the file has been stored with
-    password protection. The methods EnableDecryption() and UseDecryption() control
-    the usage of the decryption algorithms. EnableDecryption() sets a decryption
-    algorithm. UseDecryption() may be used to stop the usage of the decryption
-    temporarily (sometimes record contents are never encrypted, i.e. all BOF records
-    or the stream position in BOUNDSHEET). If decryption has been enabled
-    with EnableDecryption(), the usage will be switched on automatically.
-
-    It is possible to store several stream positions inside of a record (including
-    its CONTINUE records). The positions are stored in a stack, which can be controlled
-    with the methods PushPosition(), PopPosition() and RejectPosition(). The stack
-    will be cleared whenever a new record is started (using the method
-    StartNextRecord()).
-
-    Additionally a single global stream position can be stored which keeps valid
-    during the whole import process (methods StoreGlobalPosition(), SeekGlobalPosition()
-    and DeleteGlobalPosition()). So it is possible to jump back to a previous record
-    (that is a real jump without return).
+    To start reading a record call StartNextRecord(). Now it is possible to
+    read all contents of the record using operator>>() or any of the Read***()
+    functions. If some data exceeds the record size limit, the stream looks for
+    a following CONTINUE record and jumps automatically to it. It is NOT
+    allowed that an atomic data type is split into two records (i.e. 4 bytes of
+    a double in one record and the other 4 bytes in a following CONTINUE).
+
+    Trying to read over the record limits results in a stream error. The
+    IsValid() function indicates that with returning false. From now on it is
+    undefined what data the read functions will return. The error state will be
+    reset, if the record is reset (with the method ResetRecord()) or if the
+    next record is started.
+
+    To switch off the automatic lookup of CONTINUE records, use ResetRecord()
+    with false parameter. This is useful i.e. on import of Escher objects,
+    where sometimes solely CONTINUE records will occur. The automatic lookup
+    keeps switched off until the method ResetRecord() is called with parameter
+    true. All other settings done on the stream (i.e. alternative CONTINUE
+    record identifier, enabled decryption, NUL substitution character) will be
+    reset to default values, if a new record is started.
+
+    The import stream supports decrypting the stream data. The contents of a
+    record (not the record header) will be encrypted by Excel if the file has
+    been stored with password protection. The functions SetDecrypter(),
+    EnableDecryption(), and DisableDecryption() control the usage of the
+    decryption algorithms. SetDecrypter() sets a new decryption algorithm and
+    initially enables it. DisableDecryption() may be used to stop the usage of
+    the decryption temporarily (sometimes record contents are never encrypted,
+    i.e. all BOF records or the stream position in BOUNDSHEET). Decryption will
+    be reenabled automatically, if a new record is started with the function
+    StartNextRecord().
+
+    It is possible to store several stream positions inside a record (including
+    its CONTINUE records). The positions are stored on a stack, which can be
+    controlled with the functions PushPosition(), PopPosition() and
+    RejectPosition(). The stack will be cleared whenever a new record is
+    started with the function StartNextRecord().
+
+    Additionally a single global stream position can be stored which keeps
+    valid during the whole import process (methods StoreGlobalPosition(),
+    SeekGlobalPosition() and DeleteGlobalPosition()). This is the only way to
+    jump back to a previous record (that is a real jump without return).
 */
 class XclImpStream
 {
-private:
-#if SC_XCL_USEDECR
-    typedef ::std::auto_ptr< XclImpDecrypter >  XclImpDecrypterPtr;
-#endif
-    typedef ScfDelStack< XclImpStreamPos >      XclImpStreamPosStack;
-
-private:
-    SvStream&                   mrStrm;         /// Reference to the system input stream.
-    const XclImpRoot&           mrRoot;         /// Filter root data.
-
-#if SC_XCL_USEDECR
-    XclImpDecrypterPtr          mpDecrypter;    /// Provides methods to decrypt data.
-#endif
-
-    XclImpStreamPos             maFirstRec;     /// Start position of current record.
-    XclImpStreamPosStack        maPosStack;     /// Stack for record positions.
-
-    XclImpStreamPos             maGlobPos;      /// User defined position elsewhere in stream.
-    sal_uInt16                  mnGlobRecId;    /// Record ID for user defined position.
-    bool                        mbGlobValidRec; /// Was user position a valid record?
-    bool                        mbHasGlobPos;   /// Is user position defined?
-
-    sal_uInt32                  mnStreamSize;   /// Size of system stream.
-    sal_uInt32                  mnNextRecPos;   /// Start of next record header.
-    sal_uInt32                  mnCurrRecSize;  /// Helper for record position.
-    sal_uInt32                  mnComplRecSize; /// Size of complete record data (with CONTINUEs).
-    bool                        mbHasComplRec;  /// true = mnComplRecSize is valid.
-
-    sal_uInt16                  mnRecId;        /// Current record ID (not the CONTINUE ID).
-    sal_uInt16                  mnAltContId;    /// Alternative record ID for content continuation.
-    sal_uInt16                  mnRecSize;      /// Size of current record content (without CONTINUE).
-    sal_uInt32                  mnRecLeft;      /// Count of bytes left in current record.
-
-    sal_Unicode                 mcNulSubst;     /// Replacement for NUL characters.
-
-    bool                        mbCont;         /// Automatic CONTINUE lookup on/off.
-#if SC_XCL_USEDECR
-    bool                        mbUseDecr;      /// Usage of decryption.
-#endif
-    bool                        mbValidRec;     /// Read state: false = no record available.
-    bool                        mbValid;        /// Read state: false = record overread.
-    bool                        mbWarnings;     /// Enable/disable assertions.
-
 public:
-    /** Constructs the Excel record import stream.
+    /** Constructs the Excel record import stream using a TOOLS stream object.
         @param rInStrm  The system input stream. Will be set to its start position.
-        @param bContHandling  Automatic CONTINUE lookup on/off. */
+        Must exist as long as this object exists.
+        @param bContLookup  Automatic CONTINUE lookup on/off. */
     explicit                    XclImpStream(
                                     SvStream& rInStrm,
                                     const XclImpRoot& rRoot,
-                                    bool bContHandling = true );
+                            bool bContLookup = true );
 
                                 ~XclImpStream();
 
@@ -297,27 +310,35 @@
         @return  false = no record found (end of stream). */
     bool                        StartNextRecord();
     /** Sets stream pointer to begin of record content.
-        @param bContHandling  Automatic CONTINUE lookup on/off.
-        This setting is persistent until next call of this function.
-        @param nAltContId  Sets an alternative record ID for content continuation.
-        This value is reset automatically when a new record is started with
-        StartNextRecord(). */
-    void                        InitializeRecord( bool bContHandling, sal_uInt16 nAltContId = EXC_ID_UNKNOWN );
-
-    /** Controls the appearance of overread warnings.
-        @param bWarnMode  false = no overread assertions. */
-    inline void                 SetWarningMode( bool bWarnMode ) { mbWarnings = bWarnMode; }
-
-#if SC_XCL_USEDECR
-    /** Enables decryption of record contents for the rest of the stream.
-        @descr  Stream takes ownership of the decrypter object. */
-    void                        EnableDecryption( XclImpDecrypter* pDecrypter );
-    /** Switches usage of current decryption algorithm on/off. */
-    void                        UseDecryption( bool bUse );
-#endif
+        @param bContLookup  Automatic CONTINUE lookup on/off. In difference
+        to other stream settings, this setting is persistent until next call of
+        this function (because it is wanted to receive the next CONTINUE
+        records separately).
+        @param nAltContId  Sets an alternative record ID for content
+        continuation. This value is reset automatically when a new record is
+        started with StartNextRecord(). */
+    void                ResetRecord( bool bContLookup,
+                            sal_uInt16 nAltContId = EXC_ID_UNKNOWN );
+
+    /** Enables decryption of record contents for the rest of the stream. */
+    void                SetDecrypter( XclImpDecrypterRef xDecrypter );
+    /** Sets decrypter from another stream. */
+    void                CopyDecrypterFrom( const XclImpStream& rStrm );
+    /** Returns true, if a valid decrypter is set at the stream. */
+    bool                HasValidDecrypter() const;
+    /** Switches usage of current decryption algorithm on/off.
+        @descr  Encryption is re-enabled automatically, if a new record is
+        started using the function StartNextRecord(). */
+    void                EnableDecryption( bool bEnable = true );
+    /** Switches usage of current decryption algorithm off.
+        @descr  This is a record-local setting. The function StartNextRecord()
+        always enables decryption. */
+    inline void         DisableDecryption() { EnableDecryption( false ); }
 
     /** Pushes current position on user position stack.
-        @descr  This stack is emptied at every start of a new record. */
+        @descr  This stack is emptied when starting a new record with
+        StartNextRecord(). The decryption state (enabled/disabled) is not
+        pushed onto the stack. */
     void                        PushPosition();
     /** Seeks to last position from user position stack.
         @descr  This position will be removed from the stack. */
@@ -332,27 +353,25 @@
     /** Invalidates global user position. */
     inline void                 DeleteGlobalPosition() { mbHasGlobPos = false; }
 
-    /** Returns read state: false = record overread. */
+    /** Returns record reading state: false = record overread. */
     inline bool                 IsValid() const { return mbValid; }
     /** Returns the current record ID. */
     inline sal_uInt16           GetRecId() const { return mnRecId; }
     /** Returns the position inside of the whole record content. */
-    inline sal_uInt32           GetRecPos() const
-                                    { return IsValid() ? mnCurrRecSize - mnRecLeft : 0; }
+    sal_uInt32          GetRecPos() const;
     /** Returns the data size of the whole record without record headers. */
     sal_uInt32                  GetRecSize();
     /** Returns remaining data size of the whole record without record headers. */
-    inline sal_uInt32           GetRecLeft()
-                                    { return IsValid() ? GetRecSize() - GetRecPos() : 0; }
+    sal_uInt32          GetRecLeft();
 
-    inline XclImpStream&        operator>>( sal_Int8& rnValue );
-    inline XclImpStream&        operator>>( sal_uInt8& rnValue );
-    inline XclImpStream&        operator>>( sal_Int16& rnValue );
-    inline XclImpStream&        operator>>( sal_uInt16& rnValue );
-    inline XclImpStream&        operator>>( sal_Int32& rnValue );
-    inline XclImpStream&        operator>>( sal_uInt32& rnValue );
-    inline XclImpStream&        operator>>( float& rfValue );
-    inline XclImpStream&        operator>>( double& rfValue );
+    XclImpStream&       operator>>( sal_Int8& rnValue );
+    XclImpStream&       operator>>( sal_uInt8& rnValue );
+    XclImpStream&       operator>>( sal_Int16& rnValue );
+    XclImpStream&       operator>>( sal_uInt16& rnValue );
+    XclImpStream&       operator>>( sal_Int32& rnValue );
+    XclImpStream&       operator>>( sal_uInt32& rnValue );
+    XclImpStream&       operator>>( float& rfValue );
+    XclImpStream&       operator>>( double& rfValue );
 
     sal_Int8                    ReadInt8();
     sal_uInt8                   ReaduInt8();
@@ -379,55 +398,46 @@
     /** Seeks forward inside the current record. */
     void                        Ignore( sal_uInt32 nBytes );
 
+    // *** special string functions *** ---------------------------------------
 
-    // *** UNICODE STRINGS ***
-    // structure of an Excel unicode string:
-    // (1) 2 byte character count
-    // (2) 1 byte flags (16-bit-characters, rich string, far east string)
-    // (3) [2 byte rich string format run count]
-    // (4) [4 byte far east data size]
-    // (5) character array
-    // (6) [4 * (rich string format run count) byte]
-    // (7) [(far east data size) byte]
-    // header = (1), (2)
-    // ext. header = (3), (4)
-    // ext. data = (6), (7)
-
-    // *** special string functions ***
+    // *** read/ignore unicode strings *** ------------------------------------
+    /*  - look for CONTINUE records even if CONTINUE handling disabled
+          (only if inside of a CONTINUE record - for TXO import)
+        - no overread assertions (for Applix wrong string length export bug)
+
+        structure of an Excel unicode string:
+        (1) 2 byte character count
+        (2) 1 byte flags (16-bit-characters, rich string, far east string)
+        (3) [2 byte rich string format run count]
+        (4) [4 byte far east data size]
+        (5) character array
+        (6) [4 * (rich string format run count) byte]
+        (7) [(far east data size) byte]
+        header = (1), (2)
+        ext. header = (3), (4)
+        ext. data = (6), (7)
+     */
 
     /** Reads ext. header, detects 8/16 bit mode, sets all ext. info.
-        @return  Size of ext. data. */
+        @return  Total size of ext. data. */
     sal_uInt32                  ReadUniStringExtHeader(
                                     bool& rb16Bit, bool& rbRich, bool& rbFareast,
-                                    sal_uInt16& rnCrun, sal_uInt32& rnExtInf, sal_uInt8 nFlags );
+                            sal_uInt16& rnFormatRuns, sal_uInt32& rnExtInf, sal_uInt8 nFlags );
     /** Seeks to begin of character array, detects 8/16 bit mode.
-        @return  Size of ext. data. */
+        @return  Total size of ext. data. */
     sal_uInt32                  ReadUniStringExtHeader( bool& rb16Bit, sal_uInt8 nFlags );
     /** Skips ext. data after character array. */
-    inline void                 SkipUniStringExtData( sal_uInt32 nExtSize )
-                                    { Ignore( nExtSize ); }
+    inline void         SkipUniStringExtData( sal_uInt32 nExtSize ) { Ignore( nExtSize ); }
 
     /** Sets a replacement character for NUL characters.
-        @descr  NUL characters must be replaced, because Tools strings cannot handle them.
-        @param cNulSubst  The character to use for NUL replacement. It is possible to specify
-        NUL here. in this case strings are terminated when the first NUL occurs during string import. */
+        @descr  NUL characters must be replaced, because Tools strings cannot
+        handle them. The substitution character is reset to '?' automatically,
+        if a new record is started using the function StartNextRecord().
+        @param cNulSubst  The character to use for NUL replacement. It is
+        possible to specify NUL here. in this case strings are terminated when
+        the first NUL occurs during string import. */
     inline void                 SetNulSubstChar( sal_Unicode cNulSubst = '?' ) { mcNulSubst = cNulSubst; }
 
-    // *** read/ignore unicode strings ***
-    // - look for CONTINUE records even if CONTINUE handling disabled
-    //   (only if inside of a CONTINUE record - for TXO import)
-    // - no overread assertions (for Applix wrong string length export bug)
-
-    /** Reads nChars characters and appends string to rString. */
-    void                        AppendRawUniString( String& rString, sal_uInt16 nChars, bool b16Bit );
-    /** Reads ext. header, nChar characters, ext. data and appends string to rString. */
-    void                        AppendUniString( String& rString, sal_uInt16 nChars, sal_uInt8 nFlags );
-    /** Reads 8 bit flags, ext. header, nChar characters, ext. data and appends string to rString. */
-    inline void                 AppendUniString( String& rString, sal_uInt16 nChars );
-    /** Reads 16 bit character count, 8 bit flags, ext. header, character array,
-        ext. data and appends string to rString. */
-    inline void                 AppendUniString( String& rString );
-
     /** Reads nChars characters and returns the string. */
     String                      ReadRawUniString( sal_uInt16 nChars, bool b16Bit );
     /** Reads ext. header, nChar characters, ext. data and returns the string. */
@@ -443,16 +453,11 @@
     /** Ignores ext. header, nChar characters, ext. data. */
     void                        IgnoreUniString( sal_uInt16 nChars, sal_uInt8 nFlags );
     /** Ignores 8 bit flags, ext. header, nChar characters, ext. data. */
-    inline void                 IgnoreUniString( sal_uInt16 nChars );
+    void                IgnoreUniString( sal_uInt16 nChars );
     /** Ignores 16 bit character count, 8 bit flags, ext. header, character array, ext. data. */
-    inline void                 IgnoreUniString();
+    void                IgnoreUniString();
 
-    // *** read/ignore 8-bit-strings, store in String ***
-
-    /** Reads nChar byte characters and appends string to rString. */
-    void                        AppendRawByteString( String& rString, sal_uInt16 nChars );
-    /** Reads 8/16 bit string length, character array and appends string to rString. */
-    inline void                 AppendByteString( String& rString, bool b16BitLen );
+    // *** read/ignore 8-bit-strings, store in String *** ---------------------
 
     /** Reads nChar byte characters and returns the string. */
     String                      ReadRawByteString( sal_uInt16 nChars );
@@ -460,176 +465,106 @@
     String                      ReadByteString( bool b16BitLen );
 
     /** Ignores nChar byte characters. */
-    inline void                 IgnoreRawByteString( sal_uInt16 nChars );
+    void                IgnoreRawByteString( sal_uInt16 nChars );
     /** Ignores 8/16 bit string length, character array. */
-    inline void                 IgnoreByteString( bool b16BitLen );
+    void                IgnoreByteString( bool b16BitLen );
 
-    // *** SvStream functions ***
+    // *** SvStream functions *** ---------------------------------------------
 
     /** Returns the absolute stream position. */
-    sal_uInt32                  Tell() const;
+    inline ULONG        GetSvStreamPos() const { return mrStrm.Tell(); }
     /** Returns the stream size. */
-    inline sal_uInt32           GetStreamSize() const { return mnStreamSize; }
+    inline ULONG        GetSvStreamSize() const { return mnStreamSize; }
 
 private:
-#if SC_XCL_USEDECR
-    /** Initializes the key/stream offset of the decrypter. */
-    inline void                 SetDecrypterOffset( sal_uInt16 nRecSize );
-#endif
-
-    /** Reads and decrypts a sal_Int8 value. */
-    void                        ReadAtom( sal_Int8& rnValue );
-    /** Reads and decrypts a sal_uInt8 value. */
-    void                        ReadAtom( sal_uInt8& rnValue );
-    /** Reads and decrypts a sal_Int16 value. */
-    void                        ReadAtom( sal_Int16& rnValue );
-    /** Reads and decrypts a sal_uInt16 value. */
-    void                        ReadAtom( sal_uInt16& rnValue );
-    /** Reads and decrypts a sal_Int32 value. */
-    void                        ReadAtom( sal_Int32& rnValue );
-    /** Reads and decrypts a sal_uInt32 value. */
-    void                        ReadAtom( sal_uInt32& rnValue );
-    /** Reads and decrypts a float value. */
-    void                        ReadAtom( float& rfValue );
-    /** Reads and decrypts a double value. */
-    void                        ReadAtom( double& rfValue );
-    /** Reads and decrypts nBytes bytes to the existing(!) buffer pData.
-        @return  Count of bytes really read. */
-    sal_uInt32                  ReadData( void* pData, sal_uInt32 nBytes );
+    /** Stores current stream position into rPos. */
+    void                StorePosition( XclImpStreamPos& rPos );
+    /** Restores stream position contained in rPos. */
+    void                RestorePosition( const XclImpStreamPos& rPos );
 
-    /** Internal start of a new record, doesn't change mnNextRecPos and mbValid.
-        @return  false = no record found (end of stream). */
-    bool                        GetNextRecord( sal_uInt16& rnRecId, sal_uInt16& rnRecSize );
-    /** Internal setup of a new record, expecting mnRecId and mnNextRecPos. */
+    /** Seeks to next raw record header and reads record ID and size.
+        @descr  This is a "raw" function, means that stream members are
+        inconsistent after return. Does only change mnRawRecId, mnRawRecSize,
+        and the base stream position, but no other members.
+        @return  false = No record header found (end of stream). */
+    bool                ReadNextRawRecHeader();
+
+    /** Initializes the decrypter to read a new record. */
+    void                SetupDecrypter();
+    /** Initializes all members after base stream has been seeked to new raw record. */
+    void                SetupRawRecord();
+    /** Initializes all members after base stream has been seeked to new record. */
     void                        SetupRecord();
-    /** Returns true, if the passed ID is a real or an alternative continuation record ID. */
-    bool                        IsContinueId( sal_uInt16 nRecId );
-    /** Looks for and goes to a following CONTINUE record.
-        @descr  Does not change mbValid, updates mnCurrRecSize. */
-    bool                        GetContinue();
 
-    /** Checks mnRecLeft and jumps into next CONTINUE record if necessary and mbCont is true. */
-    bool                        CheckDataLeft( sal_uInt32 nBytes );
+    /** Returns true, if the passed ID is real or alternative continuation record ID. */
+    bool                IsContinueId( sal_uInt16 nRecId ) const;
 
     /** Goes to start of the next CONTINUE record.
-        @descr  Sets mbValid, mnNextRecPos and mnRecLeft. */
-    void                        StartContinue();
+        @descr  Stream must be located at the end of a raw record, and handling
+        of CONTINUE records must be enabled.
+        @return  Copy of mbValid. */
+    bool                JumpToNextContinue();
     /** Goes to start of the next CONTINUE record while reading strings.
-        @descr  Sets mbValid, mnNextRecPos and mnRecLeft, reads additional Unicode
-        flag byte and sets/resets rb16Bit. */
-    void                        StartStringContinue( bool& rb16Bit );
+        @descr  Stream must be located at the end of a raw record. If reading
+        has been started in a CONTINUE record, jumps to an existing following
+        CONTINUE record, even if handling of CONTINUE records is disabled (This
+        is a special handling for TXO string data). Reads additional Unicode
+        flag byte at start of the new raw record and sets or resets rb16Bit.
+        @return  Copy of mbValid. */
+    bool                JumpToNextStringContinue( bool& rb16Bit );
+
+    /** Ensures that reading nBytes bytes is possible with next stream access.
+        @descr  Stream must be located at the end of a raw record, and handling
+        of CONTINUE records must be enabled.
+        @return  Copy of mbValid. */
+    bool                EnsureRawReadSize( sal_uInt16 nBytes );
+    /** Returns the maximum size of raw data possible to read in one block. */
+    sal_uInt16          GetMaxRawReadSize( sal_uInt32 nBytes ) const;
+
+    /** Reads and decrypts nBytes bytes to the existing(!) buffer pData.
+        @return  Count of bytes really read. */
+    sal_uInt16          ReadRawData( void* pData, sal_uInt16 nBytes );
 
     /** Reads 8 bit/16 bit string length. */
     inline sal_uInt16           ReadByteStrLen( bool b16BitLen )
                                     { return b16BitLen ? ReaduInt16() : ReaduInt8(); }
 
-    /** Restores stream position contained in rPos. */
-    void                        RestorePosition( const XclImpStreamPos& rPos );
-};
-
-
-// ----------------------------------------------------------------------------
-
-inline XclImpStream& XclImpStream::operator>>( sal_Int8& rnValue )
-{
-    if( CheckDataLeft( 1 ) ) ReadAtom( rnValue );
-    return *this;
-}
-
-inline XclImpStream& XclImpStream::operator>>( sal_uInt8& rnValue )
-{
-    if( CheckDataLeft( 1 ) ) ReadAtom( rnValue );
-    return *this;
-}
-
-inline XclImpStream& XclImpStream::operator>>( sal_Int16& rnValue )
-{
-    if( CheckDataLeft( 2 ) ) ReadAtom( rnValue );
-    return *this;
-}
-
-inline XclImpStream& XclImpStream::operator>>( sal_uInt16& rnValue )
-{
-    if( CheckDataLeft( 2 ) ) ReadAtom( rnValue );
-    return *this;
-}
-
-inline XclImpStream& XclImpStream::operator>>( sal_Int32& rnValue )
-{
-    if( CheckDataLeft( 4 ) ) ReadAtom( rnValue );
-    return *this;
-}
-
-inline XclImpStream& XclImpStream::operator>>( sal_uInt32& rnValue )
-{
-    if( CheckDataLeft( 4 ) ) ReadAtom( rnValue );
-    return *this;
-}
-
-inline XclImpStream& XclImpStream::operator>>( float& rfValue )
-{
-    if( CheckDataLeft( 4 ) ) ReadAtom( rfValue );
-    return *this;
-}
-
-inline XclImpStream& XclImpStream::operator>>( double& rfValue )
-{
-    if( CheckDataLeft( 8 ) ) ReadAtom( rfValue );
-    return *this;
-}
-
-
-// ----------------------------------------------------------------------------
-
-inline void XclImpStream::AppendUniString( String& rString, sal_uInt16 nChars )
-{
-    AppendUniString( rString, nChars, ReaduInt8() );
-}
-
-inline void XclImpStream::AppendUniString( String& rString )
-{
-    AppendUniString( rString, ReaduInt16() );
-}
-
-inline void XclImpStream::IgnoreUniString( sal_uInt16 nChars )
-{
-    IgnoreUniString( nChars, ReaduInt8() );
-}
+private:
+    typedef ::std::vector< XclImpStreamPos > XclImpStreamPosStack;
 
-inline void XclImpStream::IgnoreUniString()
-{
-    IgnoreUniString( ReaduInt16() );
-}
+    SvStream&           mrStrm;         /// Reference to the system input stream.
+    const XclImpRoot&   mrRoot;         /// Filter root data.
 
+    XclImpDecrypterRef  mxDecrypter;    /// Provides methods to decrypt data.
 
-// ----------------------------------------------------------------------------
-
-inline void XclImpStream::AppendByteString( String& rString, bool b16BitLen )
-{
-    AppendRawByteString( rString, ReadByteStrLen( b16BitLen ) );
-}
+    XclImpStreamPos     maFirstRec;     /// Start position of current record.
+    XclImpStreamPosStack maPosStack;    /// Stack for record positions.
 
-inline void XclImpStream::IgnoreRawByteString( sal_uInt16 nChars )
-{
-    Ignore( nChars );
-}
+    XclImpStreamPos     maGlobPos;      /// User defined position elsewhere in stream.
+    sal_uInt16          mnGlobRecId;    /// Record ID for user defined position.
+    bool                mbGlobValidRec; /// Was user position a valid record?
+    bool                mbHasGlobPos;   /// Is user position defined?
 
-inline void XclImpStream::IgnoreByteString( bool b16BitLen )
-{
-    IgnoreRawByteString( ReadByteStrLen( b16BitLen ) );
-}
+    ULONG               mnStreamSize;   /// Size of system stream.
+    ULONG               mnNextRecPos;   /// Start of next record header.
+    sal_uInt32          mnCurrRecSize;  /// Helper for record position.
+    sal_uInt32          mnComplRecSize; /// Size of complete record data (with CONTINUEs).
+    bool                mbHasComplRec;  /// true = mnComplRecSize is valid.
 
+    sal_uInt16          mnRecId;        /// Current record ID (not the CONTINUE ID).
+    sal_uInt16          mnAltContId;    /// Alternative record ID for content continuation.
 
-// ----------------------------------------------------------------------------
+    sal_uInt16          mnRawRecId;     /// Current raw record ID (including CONTINUEs).
+    sal_uInt16          mnRawRecSize;   /// Current raw record size (without following CONTINUEs).
+    sal_uInt16          mnRawRecLeft;   /// Bytes left in current raw record (without following CONTINUEs).
 
-#if SC_XCL_USEDECR
-inline void XclImpStream::SetDecrypterOffset( sal_uInt16 nRecSize )
-{
-    if( mpDecrypter.get() )
-        mpDecrypter->SetOffset( nRecSize );
-}
-#endif
+    sal_Unicode         mcNulSubst;     /// Replacement for NUL characters.
 
+    bool                mbCont;         /// Automatic CONTINUE lookup on/off.
+    bool                mbUseDecr;      /// Usage of decryption.
+    bool                mbValidRec;     /// false = No more records to read.
+    bool                mbValid;        /// false = Record overread.
+};
 
 // ============================================================================
 
Index: sc/source/filter/inc/xlconst.hxx
===================================================================
RCS file: /cvs/sc/sc/source/filter/inc/xlconst.hxx,v
retrieving revision 1.15
retrieving revision 1.13.10.4
diff -w -u -r1.15 -r1.13.10.4
--- sc/source/filter/inc/xlconst.hxx	4 Jun 2004 14:06:49 -0000	1.15
+++ sc/source/filter/inc/xlconst.hxx	14 Jul 2004 10:30:45 -0000	1.13.10.4
@@ -102,14 +102,13 @@
 const SCTAB  SCNOTAB                        = SCTAB_MAX;  /// An invalid Calc sheet index, for common use.
 const sal_uInt16 EXC_NOTAB                  = 0xFFFF;     /// An invalid Excel sheet index, for common use.
 
+// Storage/stream names -------------------------------------------------------
 
-// In/out stream --------------------------------------------------------------
+#define EXC_STORAGE_VBA_PROJECT             CREATE_STRING( "_VBA_PROJECT_CUR" )
+#define EXC_STORAGE_VBA                     CREATE_STRING( "VBA" )
 
-const sal_uInt32 RECORD_SEEK_TO_BEGIN       = 0;
-const sal_uInt32 RECORD_SEEK_TO_END         = ~RECORD_SEEK_TO_BEGIN;
-
-const sal_uInt16 EXC_MAXRECSIZE_BIFF5       = 2080;
-const sal_uInt16 EXC_MAXRECSIZE_BIFF8       = 8224;
+#define EXC_STREAM_BOOK                     CREATE_STRING( "Book" )
+#define EXC_STREAM_WORKBOOK                 CREATE_STRING( "Workbook" )
 
 // String import/export -------------------------------------------------------
 
@@ -189,16 +183,11 @@
 const sal_uInt16 EXC_ID_NOTE                = 0x001C;
 const sal_uInt16 EXC_NOTE_VISIBLE           = 0x0002;
 
-
 // (0x0012, 0x0019) PROTECT and WINDOWPROTECT --------------------
 
 const sal_uInt16 EXC_ID_PROTECT             = 0x0012;
 const sal_uInt16 EXC_ID_WINDOWPROTECT       = 0x0019;
 
-// (0x003C) CONTINUE ----------------------------------------------------------
-
-const sal_uInt16 EXC_ID_CONT                = 0x003C;
-
 // (0x003D) WINDOW1 -----------------------------------------------------------
 
 const sal_uInt16 EXC_ID_WINDOW1             = 0x003D;
@@ -240,14 +226,9 @@
 
 const sal_uInt16 EXC_WSBOOL_DEFAULTFLAGS    = 0x04C1;
 
-
 // (0x008C) COUNTRY -----------------------------------------------------------
 
 const sal_uInt16 EXC_ID_COUNTRY             = 0x008C;
-
-// (0xFFFF) unknown record - special ID ---------------------------------------
-
-const sal_uInt16 EXC_ID_UNKNOWN             = 0xFFFF;
 
 // ============================================================================
 
Index: sc/source/filter/inc/xlcontent.hxx
===================================================================
RCS file: /cvs/sc/sc/source/filter/inc/xlcontent.hxx,v
retrieving revision 1.4
retrieving revision 1.3.108.2
diff -w -u -r1.4 -r1.3.108.2
--- sc/source/filter/inc/xlcontent.hxx	4 Jun 2004 14:07:04 -0000	1.4
+++ sc/source/filter/inc/xlcontent.hxx	14 Jul 2004 10:30:53 -0000	1.3.108.2
@@ -70,6 +70,15 @@
 
 
 // Constants ==================================================================
+
+// (0x002F) FILEPASS ----------------------------------------------------------
+
+const sal_uInt16 EXC_ID_FILEPASS            = 0x002F;
+
+const sal_uInt16 EXC_FILEPASS_BIFF5         = 0x0000;
+const sal_uInt16 EXC_FILEPASS_BIFF8         = 0x0001;
+const sal_uInt16 EXC_FILEPASS_BIFF8_STD     = 0x0001;
+const sal_uInt16 EXC_FILEPASS_BIFF8_STRONG  = 0x0002;
 
 // (0x00FC, 0x00FF) SST, EXTSST -----------------------------------------------
 
Index: sc/source/filter/inc/xlocx.hxx
===================================================================
RCS file: /cvs/sc/sc/source/filter/inc/xlocx.hxx,v
retrieving revision 1.7
retrieving revision 1.6.6.2
diff -w -u -r1.7 -r1.6.6.2
--- sc/source/filter/inc/xlocx.hxx	4 Jun 2004 11:01:20 -0000	1.7
+++ sc/source/filter/inc/xlocx.hxx	14 Jul 2004 10:31:25 -0000	1.6.6.2
@@ -143,7 +143,7 @@
                                     const XclImpCtrlLinkHelper& rControl ) const;
 
 private:
-    SvStorageStreamRef          mxStrm;         /// The 'Ctls' strem.
+    SvStorageStreamRef          mxStrm;         /// The 'Ctls' stream.
 };
 
 
@@ -180,7 +180,9 @@
                                     const XControlModelRef& rxModel ) const;
 
 private:
+#if EXC_EXP_OCX_CTRL
     SvStorageStreamRef          mxStrm;         /// The 'Ctls' stream.
+#endif
 };
 
 // ============================================================================
Index: sc/source/filter/inc/xlpivot.hxx
===================================================================
RCS file: /cvs/sc/sc/source/filter/inc/xlpivot.hxx,v
retrieving revision 1.2
retrieving revision 1.2.72.1
diff -w -u -r1.2 -r1.2.72.1
--- sc/source/filter/inc/xlpivot.hxx	4 Jun 2004 14:07:18 -0000	1.2
+++ sc/source/filter/inc/xlpivot.hxx	14 Jul 2004 14:18:13 -0000	1.2.72.1
@@ -95,6 +95,8 @@
 // Constants and Enumerations =================================================
 
 // misc -----------------------------------------------------------------------
+
+#define EXC_STORAGE_PTCACHE         CREATE_STRING( "_SX_DB_CUR" )
 
 const sal_uInt16 EXC_PC_MAXFIELDCOUNT       = 0xFFFE;
 const sal_uInt16 EXC_PC_MAXITEMCOUNT        = 32500;
Index: sc/source/filter/inc/xlroot.hxx
===================================================================
RCS file: /cvs/sc/sc/source/filter/inc/xlroot.hxx,v
retrieving revision 1.12
retrieving revision 1.11.6.4
diff -w -u -r1.12 -r1.11.6.4
--- sc/source/filter/inc/xlroot.hxx	4 Jun 2004 11:01:34 -0000	1.12
+++ sc/source/filter/inc/xlroot.hxx	14 Jul 2004 10:31:43 -0000	1.11.6.4
@@ -76,9 +76,10 @@
 #include "xltools.hxx"
 #endif
 
-
 // Global data ================================================================
 
+class SfxMedium;
+class SvStorage;
 class ScEditEngineDefaulter;
 class ScHeaderEditEngine;
 class EditEngine;
@@ -90,16 +91,18 @@
 /** Stores global buffers and data needed elsewhere in the Excel filters. */
 struct XclRootData
 {
-    typedef ::std::auto_ptr< ScEditEngineDefaulter >    ScEditEngineDefaulterPtr;
-    typedef ::std::auto_ptr< ScHeaderEditEngine >       ScHeaderEditEnginePtr;
+    typedef ::std::auto_ptr< ScEditEngineDefaulter >    ScEEDefaulterPtr;
+    typedef ::std::auto_ptr< ScHeaderEditEngine >       ScHeaderEEPtr;
     typedef ::std::auto_ptr< EditEngine >               EditEnginePtr;
     typedef ::std::auto_ptr< ScExtDocOptions >          ScExtDocOptionsPtr;
     typedef ::std::auto_ptr< XclTracer >                XclTracerPtr;
 
     XclBiff                     meBiff;         /// Current BIFF version.
+    SfxMedium&          mrMedium;       /// The medium to import from.
     ScDocument&                 mrDoc;          /// The source or destination document.
     String                      maDocUrl;       /// Document URL of imported/exported file.
     String                      maBasePath;     /// Base path of imported/exported file (path of maDocUrl).
+    String              maPassw;        /// Entered password for stream encryption/decryption.
     CharSet                     meCharSet;      /// Character set to import/export byte strings.
     LanguageType                meSysLang;      /// System language.
     LanguageType                meDocLang;      /// Document language (import: from file, export: from system).
@@ -107,19 +110,21 @@
     ScAddress                   maScMaxPos;     /// Highest Calc cell position.
     ScAddress                   maXclMaxPos;    /// Highest Excel cell position.
     ScAddress                   maMaxPos;       /// Highest position valid in Calc and Excel.
-    long                        mnCharWidth;    /// Width of '0' in default font (twips).
-    SCTAB                       mnScTab;        /// Current Calc sheet index.
-    bool                        mbTruncated;    /// Flag for the table truncated warning box.
 
-    ScEditEngineDefaulterPtr    mpEditEngine;   /// Edit engine for rich strings etc.
-    ScHeaderEditEnginePtr       mpHFEditEngine; /// Edit engine for header/footer.
+    ScEEDefaulterPtr    mpEditEngine;   /// Edit engine for rich strings etc.
+    ScHeaderEEPtr       mpHFEditEngine; /// Edit engine for header/footer.
     EditEnginePtr               mpDrawEditEng;  /// Edit engine for text boxes.
 
     ScExtDocOptionsPtr          mpExtDocOpt;        /// Extended document options.
-
     XclTracerPtr                mpTracer;       /// Filter tracer.
 
-    ::std::auto_ptr< RootData > mpRDP;//!
+    long                mnCharWidth;    /// Width of '0' in default font (twips).
+    SCTAB               mnScTab;        /// Current Calc sheet index.
+    const bool          mbExport;       /// false = Import, true = Export.
+    bool                mbTruncated;    /// Flag for the table truncated warning box.
+    bool                mbHasPassw;     /// true = Password already querried.
+
+    ::std::auto_ptr< RootData > mxRD;//!
 
 #ifdef DBG_UTIL
     sal_Int32                   mnObjCnt;       /// Object counter for mem leak tests.
@@ -127,13 +132,13 @@
 
     explicit                    XclRootData(
                                     XclBiff eBiff,
+                            SfxMedium& rMedium,
                                     ScDocument& rDocument,
-                                    const String& rDocUrl,
-                                    CharSet eCharSet );
+                            CharSet eCharSet,
+                            bool bExport );
     virtual                     ~XclRootData();
 };
 
-
 // ----------------------------------------------------------------------------
 
 class SfxObjectShell;
@@ -149,9 +154,6 @@
 /** Access to global data for a filter object (imported or exported document) from other classes. */
 class XclRoot
 {
-private:
-    mutable XclRootData&        mrData;     /// Reference to the global data struct.
-
 public:
                                 XclRoot( const XclRoot& rRoot );
     virtual                     ~XclRoot();
@@ -170,19 +172,35 @@
     inline LanguageType         GetDocLanguage() const { return mrData.meDocLang; }
     /** Returns the UI language. */
     inline LanguageType         GetUILanguage() const { return mrData.meUILang; }
+    /** Returns the character set to import/export byte strings. */
+    inline CharSet      GetCharSet() const { return mrData.meCharSet; }
+    /** Returns the width of the '0' character (default font) for the current printer (twips). */
+    inline long         GetCharWidth() const { return mrData.mnCharWidth; }
     /** Returns the current Calc sheet index. */
     inline SCTAB                GetCurrScTab() const { return mrData.mnScTab; }
     /** Returns whether the "some cells have been cut" warning box should show. */
     inline bool                 IsTruncated() const { return mrData.mbTruncated; }
 
+    /** Returns the medium to import from. */
+    inline SfxMedium&   GetMedium() const { return mrData.mrMedium; }
     /** Returns the document URL of the imported/exported file. */
     inline const String&        GetDocUrl() const { return mrData.maDocUrl; }
     /** Returns the base path of the imported/exported file. */
     inline const String&        GetBasePath() const { return mrData.maBasePath; }
-    /** Returns the character set to import/export byte strings. */
-    inline CharSet              GetCharSet() const { return mrData.meCharSet; }
-    /** Returns the width of the '0' character (default font) for the current printer (twips). */
-    inline long                 GetCharWidth() const { return mrData.mnCharWidth; }
+    /** Queries a password from the user and returns it (empty string -> input cancelled). */
+    const String&       QueryPassword() const;
+
+    /** Returns the OLE2 root storage of the imported/exported file.
+        @return  Pointer to root storage or 0, if the file is a simple stream. */
+    SvStorage*          GetRootStorage() const;
+    /** Tries to open a storage as child of the specified storage for writing. */
+    SvStorageRef        OpenStorage( SvStorage* pStrg, const String& rStrgName ) const;
+    /** Tries to open a storage as child of the root storage for writing. */
+    SvStorageRef        OpenStorage( const String& rStrgName ) const;
+    /** Tries to open a new stream in the specified storage for writing. */
+    SvStorageStreamRef  OpenStream( SvStorage* pStrg, const String& rStrmName ) const;
+    /** Tries to open a new stream in the root storage for writing. */
+    SvStorageStreamRef  OpenStream( const String& rStrmName ) const;
 
     /** Returns the destination document (import) or source document (export). */
     inline ScDocument&          GetDoc() const { return mrData.mrDoc; }
@@ -201,10 +219,6 @@
     /** Returns the defined names container of the Calc document. */
     ScRangeName&                GetNamedRanges() const;
 
-    /** Returns the OLE2 root storage of the imported/exported file.
-        @return  Pointer to root storage or 0, if the file is a simple stream. */
-    SvStorage*                  GetRootStorage() const;
-
     /** Returns the edit engine for import/export of rich strings etc. */
     ScEditEngineDefaulter&      GetEditEngine() const;
     /** Returns the edit engine for import/export of headers/footers. */
@@ -267,8 +281,10 @@
         @param rRangeList  (In/out) The cell range list to check.
         @param rMaxPos  Highest valid cell address. */
     void                        CheckCellRangeList( ScRangeList& rRanges, const ScAddress& rMaxPos ) const;
-};
 
+private:
+    mutable XclRootData& mrData;    /// Reference to the global data struct.
+};
 
 // ============================================================================
 
Index: sc/source/filter/xcl97/XclExpChangeTrack.cxx
===================================================================
RCS file: /cvs/sc/sc/source/filter/xcl97/XclExpChangeTrack.cxx,v
retrieving revision 1.15
retrieving revision 1.14.6.3
diff -w -u -r1.15 -r1.14.6.3
--- sc/source/filter/xcl97/XclExpChangeTrack.cxx	4 Jun 2004 11:06:09 -0000	1.15
+++ sc/source/filter/xcl97/XclExpChangeTrack.cxx	14 Jul 2004 10:35:25 -0000	1.14.6.3
@@ -85,11 +85,6 @@
 #endif
 
 //___________________________________________________________________
-
-extern const sal_Char*	pRevLogStreamName;
-extern const sal_Char*	pUserNamesStreamName;
-
-//___________________________________________________________________
 // local functions
 
 void lcl_WriteDateTime( XclExpStream& rStrm, const DateTime& rDateTime )
@@ -1279,12 +1274,12 @@
 sal_Bool XclExpChangeTrack::WriteUserNamesStream()
 {
 	sal_Bool bRet = sal_False;
-	String sStreamName( pUserNamesStreamName, RTL_TEXTENCODING_ASCII_US );
-	SvStorageStreamRef xSvStrm = pExcRoot->pRootStorage->OpenStream( sStreamName, STREAM_READWRITE | STREAM_TRUNC );
+    const XclExpRoot& rRoot = *pExcRoot->pER;
+    SvStorageStreamRef xSvStrm = rRoot.OpenStream( EXC_STREAM_USERNAMES );
 	DBG_ASSERT( xSvStrm.Is(), "XclExpChangeTrack::WriteUserNamesStream - no stream" );
 	if( xSvStrm.Is() )
 	{
-        XclExpStream aXclStrm( *xSvStrm, *pExcRoot->pER );
+        XclExpStream aXclStrm( *xSvStrm, rRoot );
 		XclExpChTr0x0191().Save( aXclStrm );
 		XclExpChTr0x0198().Save( aXclStrm );
 		XclExpChTr0x0192().Save( aXclStrm );
@@ -1302,12 +1297,12 @@
 
 	if( WriteUserNamesStream() )
 	{
-		String sStreamName( pRevLogStreamName, RTL_TEXTENCODING_ASCII_US );
-		SvStorageStreamRef xSvStrm = pExcRoot->pRootStorage->OpenStream( sStreamName, STREAM_READWRITE | STREAM_TRUNC );
+        const XclExpRoot& rRoot = *pExcRoot->pER;
+        SvStorageStreamRef xSvStrm = rRoot.OpenStream( EXC_STREAM_REVLOG );
 		DBG_ASSERT( xSvStrm.Is(), "XclExpChangeTrack::Write - no stream" );
 		if( xSvStrm.Is() )
 		{
-            XclExpStream aXclStrm( *xSvStrm, *pExcRoot->pER, EXC_MAXRECSIZE_BIFF8 + 8 );
+            XclExpStream aXclStrm( *xSvStrm, rRoot, EXC_MAXRECSIZE_BIFF8 + 8 );
 			aRecList.Save( aXclStrm );
 			xSvStrm->Commit();
 		}
Index: sc/source/filter/xcl97/XclImpChangeTrack.cxx
===================================================================
RCS file: /cvs/sc/sc/source/filter/xcl97/XclImpChangeTrack.cxx,v
retrieving revision 1.21
retrieving revision 1.20.6.4
diff -w -u -r1.21 -r1.20.6.4
--- sc/source/filter/xcl97/XclImpChangeTrack.cxx	4 Jun 2004 11:06:45 -0000	1.21
+++ sc/source/filter/xcl97/XclImpChangeTrack.cxx	14 Jul 2004 10:35:34 -0000	1.20.6.4
@@ -96,47 +96,38 @@
 #endif
 
 //___________________________________________________________________
-
-extern const sal_Char* pRevLogStreamName;
-extern const sal_Char* pUserNamesStreamName;
-
-//___________________________________________________________________
 // class XclImpChangeTrack
 
-XclImpChangeTrack::XclImpChangeTrack( RootData* pRootData ) :
+XclImpChangeTrack::XclImpChangeTrack( RootData* pRootData, const XclImpStream& rBookStrm ) :
 	ExcRoot( pRootData ),
 	aRecHeader(),
 	sOldUsername(),
 	pChangeTrack( NULL ),
-	pInStrm( NULL ),
 	pStrm( NULL ),
 	nTabIdCount( 0 ),
 	bGlobExit( sal_False ),
 	eNestedMode( nmBase )
 {
-	String sStreamName( pRevLogStreamName, RTL_TEXTENCODING_ASCII_US );
-	SvStorage& rStorage = *pExcRoot->pRootStorage;
-
-	if( !rStorage.IsContained( sStreamName ) || !rStorage.IsStream( sStreamName ) )
-		return;
+    const XclImpRoot& rRoot = *pExcRoot->pIR;
 
 	// Verify that the User Names stream exists before going any further. Excel adds both
 	// "Revision Log" and "User Names" streams when Change Tracking is active but the Revision log
 	// remains if Change Tracking is turned off.
-	String sUserNamesStreamName( pUserNamesStreamName, RTL_TEXTENCODING_ASCII_US );
-	if( !rStorage.IsContained( sUserNamesStreamName ) || !rStorage.IsStream( sUserNamesStreamName ) )
+    SvStorageStreamRef xUserStrm = rRoot.OpenStream( EXC_STREAM_USERNAMES );
+    if( !xUserStrm.Is() )
 		return;
 
-	pInStrm = rStorage.OpenStream( sStreamName, STREAM_STD_READ );
-	if( pInStrm )
+    xInStrm = rRoot.OpenStream( EXC_STREAM_REVLOG );
+    if( xInStrm.Is() )
 	{
-		pInStrm->Seek( STREAM_SEEK_TO_END );
-		ULONG nStreamLen = pInStrm->Tell();
-		if( (pInStrm->GetErrorCode() == ERRCODE_NONE) && (nStreamLen != ~((ULONG)0)) )
-		{
-			pInStrm->Seek( STREAM_SEEK_TO_BEGIN );
-            pStrm = new XclImpStream( *pInStrm, *pExcRoot->pIR );
-            pChangeTrack = new ScChangeTrack( pExcRoot->pDoc );
+        xInStrm->Seek( STREAM_SEEK_TO_END );
+        ULONG nStreamLen = xInStrm->Tell();
+        if( (xInStrm->GetErrorCode() == ERRCODE_NONE) && (nStreamLen != STREAM_SEEK_TO_END) )
+		{
+            xInStrm->Seek( STREAM_SEEK_TO_BEGIN );
+            pStrm = new XclImpStream( *xInStrm, rRoot );
+            pStrm->CopyDecrypterFrom( rBookStrm );
+            pChangeTrack = new ScChangeTrack( rRoot.GetDocPtr() );
 
             sOldUsername = pChangeTrack->GetUser();
             pChangeTrack->SetUseFixDateTime( TRUE );
@@ -148,12 +139,8 @@
 
 XclImpChangeTrack::~XclImpChangeTrack()
 {
-	if( pChangeTrack )
 		delete pChangeTrack;
-	if( pStrm )
 		delete pStrm;
-	if( pInStrm )
-		delete pInStrm;
 }
 
 void XclImpChangeTrack::DoAcceptRejectAction( ScChangeAction* pAction )
@@ -372,6 +359,7 @@
 
 void XclImpChangeTrack::ReadChTrInfo()
 {
+    pStrm->DisableDecryption();
 	pStrm->Ignore( 32 );
     String sUsername( pStrm->ReadUniString() );
 	if( !pStrm->IsValid() ) return;
Index: sc/source/ui/docshell/docsh.cxx
===================================================================
RCS file: /cvs/sc/sc/source/ui/docshell/docsh.cxx,v
retrieving revision 1.69
retrieving revision 1.69.36.1
diff -w -u -r1.69 -r1.69.36.1
--- sc/source/ui/docshell/docsh.cxx	28 Jun 2004 12:41:49 -0000	1.69
+++ sc/source/ui/docshell/docsh.cxx	16 Jul 2004 17:38:26 -0000	1.69.36.1
@@ -163,6 +163,7 @@
 #include "scextopt.hxx"
 #include "compiler.hxx"
 #include "cfgids.hxx"
+#include "warnpassword.hxx"
 
 #include "docsh.hxx"
 
@@ -1866,6 +1867,7 @@
 	{
 		WaitObject aWait( GetDialogParent() );
 
+		BOOL bDo = TRUE;
 		ScTabViewShell* pViewShell = GetBestViewShell();
 		if( pViewShell )
 		{
@@ -1873,8 +1875,15 @@
             if( !pExtDocOpt )
                 aDocument.SetExtDocOptions( pExtDocOpt = new ScExtDocOptions );
 			pViewShell->GetViewData()->WriteExtOptions( *pExtDocOpt );
+
+		    // if the imported document contained an encrypted 
+		    // password - determineif we should save without it. 
+		    if(pExtDocOpt && pExtDocOpt->IsWinEncrypted() )
+                        bDo = ScWarnPassword::WarningOnPassword( rMed );
 		}
 
+        if(bDo)
+        {
 		BOOL bFake97 = ( aFltName.EqualsAscii(pFilterExcel97) || aFltName.EqualsAscii(pFilterEx97Temp) );
 		FltError eError = ScExportExcel5( rMed, &aDocument, bFake97, RTL_TEXTENCODING_MS_1252 );
 
@@ -1886,6 +1895,9 @@
 		else
 			bRet = eError == eERR_OK;
 	}
+	else
+	    SetError(ERRCODE_ABORT);
+    }
 	else if (aFltName.EqualsAscii(pFilterAscii))
 	{
 		SvStream* pStream = rMed.GetOutStream();
Index: sc/source/ui/src/scerrors.src
===================================================================
RCS file: /cvs/sc/sc/source/ui/src/scerrors.src,v
retrieving revision 1.43
retrieving revision 1.42.84.2
diff -w -u -r1.43 -r1.42.84.2
--- sc/source/ui/src/scerrors.src	26 Jun 2004 20:09:15 -0000	1.43
+++ sc/source/ui/src/scerrors.src	14 Jul 2004 11:36:29 -0000	1.42.84.2
@@ -62,99 +62,95 @@
 #include "scerrors.hxx"
 #include "sc.hrc"
 
-
-
-#define SH_MAX 0x7fff
-
 Resource RID_ERRHDLSC
 {
 	 //------------------------------------------------------------
 	 // ERRORS -----------------------------------------------------
 	 //------------------------------------------------------------
-	String SCERR_IMPORT_CONNECT & SH_MAX
+    String SCERR_IMPORT_CONNECT & ERRCODE_RES_MASK
 	{
 		Text [ de ] = "Es konnte keine Verbindung zu der Datei hergestellt werden." ;
 		Text [ en-US ] = "Impossible to connect to the file." ;
 		Text [ x-comment ] = " ";
 	};
-	String SCERR_IMPORT_OPEN & SH_MAX
+    String SCERR_IMPORT_OPEN & ERRCODE_RES_MASK
 	{
 		/* ### ACHTUNG: Neuer Text in Resource? Die Datei konnte nicht geffnet werden. : Die Datei konnte nicht geffnet werden. */
 		Text [ de ] = "Die Datei konnte nicht geffnet werden." ;
 		Text [ en-US ] = "File could not be opened." ;
 		Text [ x-comment ] = " ";
 	};
-	String SCERR_IMPORT_UNKNOWN & SH_MAX
+    String SCERR_IMPORT_UNKNOWN & ERRCODE_RES_MASK
 	{
 		Text [ de ] = "Ein unbekannter Fehler ist aufgetreten." ;
 		Text [ en-US ] = "An unknown error has occurred." ;
 		Text [ x-comment ] = " ";
 	};
-	String SCERR_IMPORT_OUTOFMEM & SH_MAX
+    String SCERR_IMPORT_OUTOFMEM & ERRCODE_RES_MASK
 	{
 		Text [ de ] = "Nicht genug Speicher beim Importieren." ;
 		Text [ en-US ] = "Not enough memory while importing." ;
 		Text [ x-comment ] = " ";
 	};
-	String SCERR_IMPORT_UNKNOWN_WK & SH_MAX
+    String SCERR_IMPORT_UNKNOWN_WK & ERRCODE_RES_MASK
 	{
 		Text [ de ] = "Unbekanntes Lotus-123-Dateiformat." ;
 		Text [ en-US ] = "Unknown Lotus1-2-3 file format." ;
 		Text [ x-comment ] = " ";
 	};
-	String SCERR_IMPORT_FORMAT & SH_MAX
+    String SCERR_IMPORT_FORMAT & ERRCODE_RES_MASK
 	{
 		Text [ de ] = "Fehler in Dateistruktur beim Importieren." ;
 		Text [ en-US ] = "Error in file structure while importing." ;
 		Text [ x-comment ] = " ";
 	};
-	String SCERR_IMPORT_NI & SH_MAX
+    String SCERR_IMPORT_NI & ERRCODE_RES_MASK
 	{
 		/* ### ACHTUNG: Neuer Text in Resource? Fr diesen Dateityp ist kein Filter implementiert. : Fr diesen Dateityp ist kein Filter implementiert. */
 		Text [ de ] = "Fr diesen Dateityp ist kein Filter implementiert." ;
 		Text [ en-US ] = "There is no filter available for this file type." ;
 		Text [ x-comment ] = " ";
 	};
-	String SCERR_IMPORT_UNKNOWN_BIFF & SH_MAX
+    String SCERR_IMPORT_UNKNOWN_BIFF & ERRCODE_RES_MASK
 	{
 		/* ### ACHTUNG: Neuer Text in Resource? Nicht untersttztes oder unbekanntes Excel-Dateiformat. : Nicht untersttztes oder unbekanntes Excel-Dateiformat. */
 		Text [ de ] = "Nicht untersttztes oder unbekanntes Excel-Dateiformat." ;
 		Text [ en-US ] = "Unknown or unsupported Excel file format." ;
 		Text [ x-comment ] = " ";
 	};
-	String SCERR_IMPORT_NI_BIFF & SH_MAX
+    String SCERR_IMPORT_NI_BIFF & ERRCODE_RES_MASK
 	{
 		Text [ de ] = "Noch nicht implementiertes Excel-Dateiformat." ;
 		Text [ en-US ] = "Excel file format not yet implemented." ;
 		Text [ x-comment ] = " ";
 	};
-	String SCERR_IMPORT_FILEPASSWD & SH_MAX
+    String SCERR_IMPORT_FILEPASSWD & ERRCODE_RES_MASK
 	{
 		/* ### ACHTUNG: Neuer Text in Resource? Die Datei ist durch ein Kennwort geschtzt. : Die Datei ist durch ein Kennwort geschtzt. */
 		Text [ de ] = "Die Datei ist durch ein Kennwort geschtzt." ;
 		Text [ en-US ] = "This file is password-protected." ;
 		Text [ x-comment ] = " ";
 	};
-	String SCERR_IMPORT_INTERNAL & SH_MAX
+    String SCERR_IMPORT_INTERNAL & ERRCODE_RES_MASK
 	{
 		Text [ de ] = "Interner Importfehler" ;
 		Text [ en-US ] = "Internal import error." ;
 		Text [ x-comment ] = " ";
 	};
-	String SCERR_IMPORT_8K_LIMIT & SH_MAX
+    String SCERR_IMPORT_8K_LIMIT & ERRCODE_RES_MASK
 	{
 		/* ### ACHTUNG: Neuer Text in Resource? Die Datei enthlt Daten unterhalb von Zeile 8192 und kann daher nicht gelesen werden. : Die Datei enthlt Daten unterhalb von Zeile 8192 und kann daher nicht gelesen werden. */
 		Text [ de ] = "Die Datei enthlt Daten unterhalb von Zeile 8192 und kann daher nicht gelesen werden." ;
 		Text [ en-US ] = "The file contains data after row 8192 and therefore can not be read." ;
 		Text [ x-comment ] = " ";
 	};
-	String SCERR_IMPORT_FILE_ROWCOL & SH_MAX
+    String SCERR_IMPORT_FILE_ROWCOL & ERRCODE_RES_MASK
 	{
 		Text [ de ] = "Formatfehler in Teildokument $(ARG1) an Position $(ARG2)(Zeile,Spalte) in der Datei entdeckt" ;
 		Text [ en-US ] = "Format error discovered in the file in sub-document $(ARG1) at $(ARG2)(row,col)";
 		Text [ x-comment ] = "; shou; should be the same text like in the writer";
 	};
-	String SCERR_IMPORT_FORMAT_ROWCOL & SH_MAX
+    String SCERR_IMPORT_FORMAT_ROWCOL & ERRCODE_RES_MASK
 	{
 		Text [ de ] = "Formatfehler an Position $(ARG1)(Zeile,Spalte) in der Datei entdeckt" ;
 		Text [ en-US ] = "File format error found at $(ARG1)(row,col)" ;
@@ -162,13 +158,13 @@
 	};
 
 	 // Export ----------------------------------------------------
-	String SCERR_EXPORT_CONNECT & SH_MAX
+    String SCERR_EXPORT_CONNECT & ERRCODE_RES_MASK
 	{
 		Text [ de ] = "Es konnte keine Verbindung zu der Datei hergestellt werden." ;
 		Text [ en-US ] = "Connection to the file could not be established." ;
 		Text [ x-comment ] = " ";
 	};
-	String SCERR_EXPORT_DATA & SH_MAX
+    String SCERR_EXPORT_DATA & ERRCODE_RES_MASK
 	{
 		Text [ de ] = "Die Daten konnten nicht geschrieben werden." ;
 		Text [ en-US ] = "Data could not be written." ;
@@ -177,120 +173,85 @@
 	 //------------------------------------------------------------
 	 // WARNINGS ---------------------------------------------------
 	 //------------------------------------------------------------
-	String SCWARN_EXPORT_ASCII & SH_MAX
+    String SCWARN_EXPORT_ASCII & ERRCODE_RES_MASK
 	{
 		Text [ de ] = "Es wurde nur die aktuelle Tabelle gespeichert." ;
 		Text [ en-US ] = "Only the active sheet was saved." ;
 		Text [ x-comment ] = " ";
 	};
-	String SCWARN_IMPORT_RANGE_OVERFLOW & SH_MAX
+    String SCWARN_IMPORT_RANGE_OVERFLOW & ERRCODE_RES_MASK
 	{
 		/* ### ACHTUNG: Neuer Text in Resource? Die Maximalanzahl von Zeilen wurde berschritten. berzhlige Zeilen wurden nicht mitimportiert! : Die Maximalanzahl von Zeilen wurde berschritten. berzhlige Zeilen wurden nicht mitimportiert! */
 		Text [ de ] = "Die Maximalanzahl von Zeilen wurde berschritten. berzhlige Zeilen wurden nicht mitimportiert!" ;
 		Text [ en-US ] = "The maximum number of rows has been exceeded. Excess rows were not imported!" ;
 		Text [ x-comment ] = " ";
 	};
-	String SCWARN_IMPORT_ROW_OVERFLOW & SH_MAX
+    String SCWARN_IMPORT_ROW_OVERFLOW & ERRCODE_RES_MASK
 	{
 		Text [ de ] = "Die Daten konnten nicht vollstndig geladen werden, da die maximale Anzahl von Tabellenzeilen berschritten wurde." ;
 		Text [ en-US ] = "The data could not be loaded completely because the maximum number of rows per sheet was exceeded." ;
 	};
-	String SCWARN_IMPORT_COLUMN_OVERFLOW & SH_MAX
+    String SCWARN_IMPORT_COLUMN_OVERFLOW & ERRCODE_RES_MASK
 	{
 		Text [ de ] = "Die Daten konnten nicht vollstndig geladen werden, da die maximale Anzahl von Tabellenspalten berschritten wurde." ;
 		Text [ en-US ] = "The data could not be loaded completely because the maximum number of columns per sheet was exceeded." ;
 	};
-	String SCWARN_IMPORT_SHEET_OVERFLOW & SH_MAX
+    String SCWARN_IMPORT_SHEET_OVERFLOW & ERRCODE_RES_MASK
 	{
 		Text [ de ] = "Einige Tabellen konnten nicht geladen werden, da die maximale Anzahl von Tabellen berschritten wurde." ;
 		Text [ en-US ] = "Some sheets could not be loaded because the maximum number of sheets was exceeded." ;
 	};
-	String SCWARN_IMPORT_OPEN_FM3 & SH_MAX
+    String SCWARN_IMPORT_OPEN_FM3 & ERRCODE_RES_MASK
 	{
 		/* ### ACHTUNG: Neuer Text in Resource? Zugehrige FM3-Datei konnte nicht geffnet werden. : Zugehrige FM3-Datei konnte nicht geffnet werden. */
 		Text [ de ] = "Zugehrige FM3-Datei konnte nicht geffnet werden." ;
 		Text [ en-US ] = "Corresponding FM3-File could not be opened." ;
 		Text [ x-comment ] = " ";
 	};
-	String SCWARN_IMPORT_WRONG_FM3 & SH_MAX
+    String SCWARN_IMPORT_WRONG_FM3 & ERRCODE_RES_MASK
 	{
 		/* ### ACHTUNG: Neuer Text in Resource? Fehler in Dateistruktur der zugehrigen FM3-Datei. : Fehler in Dateistruktur der zugehrigen FM3-Datei. */
 		Text [ de ] = "Fehler in Dateistruktur der zugehrigen FM3-Datei." ;
 		Text [ en-US ] = "Error in file structure of corresponding FM3-File." ;
 		Text [ x-comment ] = " ";
 	};
-	String SCWARN_CORE_HARD_RECALC & SH_MAX
+    String SCWARN_CORE_HARD_RECALC & ERRCODE_RES_MASK
 	{
 		/* ### ACHTUNG: Neuer Text in Resource? Dokument zu komplex fr automatische Berechnung. Neuberechnung mit F9. : Dokument zu komplex fr automatische Berechnung. Neuberechnung mit F9. */
 		Text [ de ] = "Dokument zu komplex fr automatische Berechnung. Neuberechnung mit F9." ;
 		Text [ en-US ] = "Document too complex for automatic calculation. Press F9 to recalculate." ;
 		Text [ x-comment ] = " ";
 	};
-	String SCWARN_EXPORT_MAXROW & SH_MAX
+    String SCWARN_EXPORT_MAXROW & ERRCODE_RES_MASK
 	{
 		/* ### ACHTUNG: Neuer Text in Resource? Das Dokument enthlt mehr Zeilen, als das Ausgabeformat untersttzt.\nberzhlige Zeilen wurden nicht gespeichert. : Das Dokument enthlt mehr Zeilen, als das Ausgabeformat untersttzt.\nberzhlige Zeilen wurden nicht gespeichert. */
 		Text [ de ] = "Das Dokument enthlt mehr Zeilen, als das Ausgabeformat untersttzt.\nberzhlige Zeilen wurden nicht gespeichert." ;
 		Text [ en-US ] = "The document contains more rows than supported in the selected format.\nAdditional rows were not saved." ;
 		Text [ x-comment ] = " ";
 	};
-	String SCWARN_IMPORT_INFOLOST & SH_MAX
+    String SCWARN_IMPORT_INFOLOST & ERRCODE_RES_MASK
 	{
 		/* ### ACHTUNG: Neuer Text in Resource? Das Dokument enthlt Informationen, die dieser Programmversion unbekannt sind.\nBei erneutem Speichern gehen diese Informationen verloren! : Das Dokument enthlt Informationen, die dieser Programmversion unbekannt sind.\nBei erneutem Speichern gehen diese Informationen verloren! */
 		Text [ de ] = "Das Dokument enthlt Informationen, die dieser Programmversion unbekannt sind.\nBei erneutem Speichern gehen diese Informationen verloren!" ;
 		Text [ en-US ] = "The document contains information not recognized by this program version.\nResaving the document will delete this information!" ;
 		Text [ x-comment ] = " ";
 	};
-	String SCWARN_EXPORT_DATALOST & SH_MAX
+    String SCWARN_EXPORT_DATALOST & ERRCODE_RES_MASK
 	{
 		Text [ de ] = "Es konnten nicht alle Zellinhalte in dem angegebenen Format gespeichert werden." ;
 		Text [ en-US ] = "Not all cell contents could be saved in the specified format." ;
 		Text [ x-comment ] = " ";
 	};
-    String SCWARN_EXPORT_NONCONVERTIBLE_CHARS & SH_MAX
+    String SCWARN_EXPORT_NONCONVERTIBLE_CHARS & ERRCODE_RES_MASK
 	{
         Text [ de ] = "Die folgenden Zeichen konnten nicht in den gewhlten Zeichensatz konvertiert werden\nund wurden in &#1234; Ersatzdarstellung geschrieben:\n\n$(ARG1)";
         Text [ en-US ] = "The following characters could not be converted to the selected character set\nand were written as &#1234; surrogates:\n\n$(ARG1)";
 	};
-	String SCWARN_IMPORT_FILE_ROWCOL & SH_MAX
+    String SCWARN_IMPORT_FILE_ROWCOL & ERRCODE_RES_MASK
 	{
 		Text [ de ] = "Formatfehler in Teildokument $(ARG1) an Position $(ARG2)(Zeile,Spalte) in der Datei entdeckt" ;
 		Text [ en-US ] = "Format error discovered in the file in sub-document $(ARG1) at $(ARG2)(row,col)";
 		Text [ x-comment ] = "; shou; should be the same text like in the writer";
 	};
 };
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
 
Index: sc/source/ui/unoobj/makefile.mk
===================================================================
RCS file: /cvs/sc/sc/source/ui/unoobj/makefile.mk,v
retrieving revision 1.15
retrieving revision 1.15.42.1
diff -w -u -r1.15 -r1.15.42.1
--- sc/source/ui/unoobj/makefile.mk	11 Feb 2004 09:57:39 -0000	1.15
+++ sc/source/ui/unoobj/makefile.mk	16 Jul 2004 17:36:44 -0000	1.15.42.1
@@ -121,7 +121,8 @@
         $(SLO)$/addruno.obj \
         $(SLO)$/listenercalls.obj \
         $(SLO)$/cellvaluebinding.obj \
-        $(SLO)$/celllistsource.obj
+        $(SLO)$/celllistsource.obj \
+        $(SLO)$/warnpassword.obj
 
 SLO2FILES = \
 	$(SLO)$/scdetect.obj								\
