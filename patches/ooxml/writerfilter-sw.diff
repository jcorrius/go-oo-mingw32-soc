--- sw/inc/cmdid.h	27 Jun 2007 13:12:47 -0000	1.72
+++ sw/inc/cmdid.h	12 Jul 2007 14:08:36 -0000
@@ -599,7 +599,7 @@
 #define FN_GOTO_NEXT_CELL           (FN_FORMAT + 145)  /* Table: go to next cell */
 #define FN_GOTO_PREV_CELL           (FN_FORMAT + 146)  /* Table: go to previous cell */
 
-
+#define FN_TABLE_HEADLINE_COUNT     (FN_FORMAT + 147) /* number of repeated headlines of tables */ 
 //hier geht's weiter !
 /*--------------------------------------------------------------------
 	Bereich: Ribbon
@@ -894,6 +894,7 @@
 #define FN_XFORMS_DESIGN_MODE               (FN_EXTRA2 + 100)
 
 #define FN_UNO_PARA_STYLE_CONDITIONS        (FN_EXTRA2 + 101)
+#define FN_UNO_GRAPHIC                      (FN_EXTRA2 + 102)
 
 #define FN_UNO_REPLACEMENT_GRAPHIC_URL      (FN_EXTRA2 + 102)
 
--- sw/inc/doc.hxx	27 Jun 2007 13:13:17 -0000	1.138
+++ sw/inc/doc.hxx	12 Jul 2007 14:08:37 -0000
@@ -160,6 +160,10 @@
 #include <stringhash.hxx>
 
 #include <svtools/embedhlp.hxx>
+#ifndef INCLUDED_VECTOR
+#include <vector>
+#define INCLUDED_VECTOR
+#endif
 
 class SfxObjectShell;
 class SfxObjectShellRef;
@@ -1566,6 +1570,9 @@
                                 const SwPaM& rRange, sal_Unicode cCh,
 								SwHoriOrient eAdjust,
                                 const SwTableAutoFmt* = 0 );
+    // text to table conversion - API support
+    const SwTable* TextToTable( const std::vector< std::vector<SwNodeRange> >& rTableNodes );
+
 		// erzeuge aus der Tabelle wieder normalen Text
 	sal_Bool TableToText( const SwTableNode* pTblNd, sal_Unicode cCh );
 		// einfuegen von Spalten/Zeilen in der Tabelle
--- sw/inc/ndarr.hxx	1 Dec 2006 15:32:55 -0000	1.16
+++ sw/inc/ndarr.hxx	12 Jul 2007 14:08:37 -0000
@@ -53,6 +53,11 @@
 
 #include <svtools/embedhlp.hxx>
 
+#ifndef INCLUDED_VECTOR
+#include <vector>
+#define INCLUDED_VECTOR
+#endif
+
 class Graphic;
 class GraphicObject;
 class String;
@@ -299,6 +304,14 @@
 								SwTableBoxFmt* pBoxFmt,
 								SwTxtFmtColl* pTxtColl,
 								SwUndoTxtToTbl* pUndo = 0 );
+    //create a table from a vector of NodeRanges - API support
+    SwTableNode* TextToTable( const std::vector< std::vector<SwNodeRange> >& rTableNodes, 
+                                SwTableFmt* pTblFmt,
+                                SwTableLineFmt* pLineFmt,
+                                SwTableBoxFmt* pBoxFmt,
+                                SwTxtFmtColl* pTxtColl
+                                /*, SwUndo... pUndo*/ );
+
 		// erzeuge aus der Tabelle wieder normalen Text
 	BOOL TableToText( const SwNodeRange& rRange, sal_Unicode cCh,
 						SwUndoTblToTxt* = 0 );
--- sw/inc/unofield.hxx	9 Mar 2007 13:14:15 -0000	1.17
+++ sw/inc/unofield.hxx	12 Jul 2007 14:08:38 -0000
@@ -157,7 +157,8 @@
 	const SwFmtFld* 			pFmtFld;
 	SwDoc* 						m_pDoc;
 
-	sal_Bool 						m_bIsDescriptor;
+    SwClient                    m_aFieldTypeClient; // required to access field master of not yet inserted fields
+    sal_Bool                        m_bIsDescriptor;
     sal_Bool                        m_bCallUpdate;
     sal_uInt16                      m_nServiceId;
 	SwFieldProperties_Impl* 	m_pProps;
--- sw/inc/unoframe.hxx	13 Oct 2006 11:08:29 -0000	1.20
+++ sw/inc/unoframe.hxx	12 Jul 2007 14:08:40 -0000
@@ -81,17 +81,19 @@
 >,
 	public SwClient
 {
-	SwEventListenerContainer		aLstnrCntnr;
-	SfxItemPropertySet				aPropSet;
-	const SfxItemPropertyMap* 		_pMap;
-	SwDoc*							mpDoc;
+	SwEventListenerContainer		m_aLstnrCntnr;
+	SfxItemPropertySet				m_aPropSet;
+	const SfxItemPropertyMap* 		m_pMap;
+	SwDoc*							m_pDoc;
 
-	const FlyCntType 				eType;
+	const FlyCntType 				m_eType;
 
 	// Descriptor-interface
-	BaseFrameProperties_Impl*		pProps;
-	sal_Bool 						bIsDescriptor;
-	String 							sName;
+	BaseFrameProperties_Impl*		m_pProps;
+	sal_Bool 						m_bIsDescriptor;
+	String 							m_sName;
+
+    SwPaM*                          m_pCopySource;
 
 protected:
 	com::sun::star::uno::Reference< ::com::sun::star::beans::XPropertySet >	mxStyleData;
@@ -164,10 +166,13 @@
 	{
 		return PTR_CAST ( SwFrmFmt, GetRegisteredIn() );
 	}
-	FlyCntType 		GetFlyCntType()const {return eType;}
+	FlyCntType 		GetFlyCntType()const {return m_eType;}
 
-	sal_Bool 			IsDescriptor() const {return bIsDescriptor;}
+	sal_Bool 		IsDescriptor() const {return m_bIsDescriptor;}
 	void			ResetDescriptor();
+
+    //copy text from a given source PaM
+    void            SetSelection(SwPaM& rCopySource);
 	static SdrObject *GetOrCreateSdrObject( SwFlyFrmFmt *pFmt );
 };
 /*-----------------20.02.98 11:28-------------------
--- sw/inc/unoobj.hxx	14 Aug 2006 15:37:08 -0000	1.43
+++ sw/inc/unoobj.hxx	12 Jul 2007 14:08:42 -0000
@@ -142,6 +142,11 @@
 #ifndef _COM_SUN_STAR_TEXT_XRELATIVETEXTCONTENTREMOVE_HPP_
 #include <com/sun/star/text/XRelativeTextContentRemove.hpp>
 #endif
+#ifndef _COM_SUN_STAR_TEXT_XTEXTAPPENDANDCONVERT_HPP_
+#include <com/sun/star/text/XTextAppendAndConvert.hpp>
+#endif
+
+
 #ifndef _CPPUHELPER_WEAK_HXX_
 #include <cppuhelper/weak.hxx>
 #endif
@@ -303,32 +308,38 @@
  * --------------------------------------------------*/
 class SwXTextRange;
 class SwXTextCursor;
-class SwXText : public ::com::sun::star::text::XText,
-                public ::com::sun::star::lang::XTypeProvider,
+class SwXText : public ::com::sun::star::lang::XTypeProvider,
                 public ::com::sun::star::text::XTextRangeCompare,
                 public ::com::sun::star::text::XRelativeTextContentInsert,
                 public ::com::sun::star::text::XRelativeTextContentRemove,
                 public ::com::sun::star::beans::XPropertySet,
-                public ::com::sun::star::lang::XUnoTunnel
+                public ::com::sun::star::lang::XUnoTunnel,
+                public ::com::sun::star::text::XTextAppendAndConvert
 {
-    SwDoc*                      pDoc;
-    BOOL                        bObjectValid;
-    CursorType                  eCrsrType;
-    const SfxItemPropertyMap*   _pMap;
+    SwDoc*                      m_pDoc;
+    sal_Bool                    m_bObjectValid;
+    CursorType                  m_eCrsrType;
+    const SfxItemPropertyMap*   m_pMap;
+
+    virtual ::com::sun::star::uno::Reference< ::com::sun::star::text::XTextRange > SAL_CALL finishOrAppendParagraph( 
+                bool bFinish,
+                const ::com::sun::star::uno::Sequence< ::com::sun::star::beans::PropertyValue > & CharacterAndParagraphProperties ) 
+                throw (::com::sun::star::lang::IllegalArgumentException, ::com::sun::star::uno::RuntimeException);
+
 protected:
 	virtual const SwStartNode *GetStartNode() const;
 public:
                 SwXText(SwDoc* pDc, CursorType eType);
 	virtual 	~SwXText();
 
-	const SwDoc* 			GetDoc()const {return pDoc;}
-	SwDoc* 					GetDoc() 	{return pDoc;}
+    const SwDoc*            GetDoc()const {return m_pDoc;}
+    SwDoc*                  GetDoc()    {return m_pDoc;}
 
 	// wenn ein SwXText attached wird, wird das Doc gesetzt
 	void					SetDoc(SwDoc* pDc)
-								{DBG_ASSERT(!pDoc || !pDc, "Doc schon gesetzt?")
-									pDoc = pDc;
-									bObjectValid = 0 != pDc;
+                                {DBG_ASSERT(!m_pDoc || !pDc, "Doc schon gesetzt?")
+                                    m_pDoc = pDc;
+                                    m_bObjectValid = 0 != pDc;
 								}
     virtual 	::com::sun::star::uno::Any SAL_CALL queryInterface( const ::com::sun::star::uno::Type& aType ) throw(::com::sun::star::uno::RuntimeException);
 
@@ -373,15 +384,33 @@
 	static const ::com::sun::star::uno::Sequence< sal_Int8 > & getUnoTunnelId();
 	virtual sal_Int64 SAL_CALL getSomething( const ::com::sun::star::uno::Sequence< sal_Int8 >& aIdentifier ) throw(::com::sun::star::uno::RuntimeException);
 
-	//
+    //XParagraphAppend
+    virtual ::com::sun::star::uno::Reference< ::com::sun::star::text::XTextRange >  SAL_CALL appendParagraph( const ::com::sun::star::uno::Sequence< ::com::sun::star::beans::PropertyValue > & CharacterAndParagraphProperties ) throw (::com::sun::star::lang::IllegalArgumentException, ::com::sun::star::uno::RuntimeException);
+    virtual ::com::sun::star::uno::Reference< ::com::sun::star::text::XTextRange >  SAL_CALL finishParagraph( const ::com::sun::star::uno::Sequence< ::com::sun::star::beans::PropertyValue > & CharacterAndParagraphProperties ) throw (::com::sun::star::lang::IllegalArgumentException, ::com::sun::star::uno::RuntimeException);
+    
+    //XTextPortionAppend
+    virtual ::com::sun::star::uno::Reference< ::com::sun::star::text::XTextRange > SAL_CALL appendTextPortion( const ::rtl::OUString& Text, const ::com::sun::star::uno::Sequence< ::com::sun::star::beans::PropertyValue > & CharacterAndParagraphProperties ) throw (::com::sun::star::lang::IllegalArgumentException, ::com::sun::star::uno::RuntimeException);
+    
+    //XTextContentAppend
+    virtual ::com::sun::star::uno::Reference< ::com::sun::star::text::XTextRange > SAL_CALL appendTextContent( const ::com::sun::star::uno::Reference< ::com::sun::star::text::XTextContent >& TextContent, const ::com::sun::star::uno::Sequence< ::com::sun::star::beans::PropertyValue >& CharacterAndParagraphProperties ) throw (::com::sun::star::lang::IllegalArgumentException, ::com::sun::star::uno::RuntimeException);
+
+    //XTextConvert
+    virtual ::com::sun::star::uno::Reference< ::com::sun::star::text::XTextContent > SAL_CALL convertToTextFrame( const ::com::sun::star::uno::Reference< ::com::sun::star::text::XTextRange >& Start, const ::com::sun::star::uno::Reference< ::com::sun::star::text::XTextRange >& End, const ::com::sun::star::uno::Sequence< ::com::sun::star::beans::PropertyValue >& FrameProperties ) throw (::com::sun::star::lang::IllegalArgumentException, ::com::sun::star::uno::RuntimeException);
+    virtual ::com::sun::star::uno::Reference< ::com::sun::star::text::XTextTable > SAL_CALL convertToTable( const ::com::sun::star::uno::Sequence< ::com::sun::star::uno::Sequence< ::com::sun::star::uno::Sequence< ::com::sun::star::uno::Reference< ::com::sun::star::text::XTextRange > > > >& TableRanges,
+		const ::com::sun::star::uno::Sequence< ::com::sun::star::uno::Sequence< ::com::sun::star::uno::Sequence< ::com::sun::star::beans::PropertyValue > > >& CellProperties, 
+		const ::com::sun::star::uno::Sequence< ::com::sun::star::uno::Sequence< ::com::sun::star::beans::PropertyValue > >& RowProperties, 
+		const ::com::sun::star::uno::Sequence< ::com::sun::star::beans::PropertyValue >& TableProperties 
+		) throw (::com::sun::star::lang::IllegalArgumentException, ::com::sun::star::uno::RuntimeException);
+
+    //
     virtual ::com::sun::star::uno::Reference< ::com::sun::star::text::XTextCursor >         createCursor()throw(::com::sun::star::uno::RuntimeException);
     INT16   ComparePositions(const ::com::sun::star::uno::Reference< ::com::sun::star::text::XTextRange>& xPos1, const ::com::sun::star::uno::Reference< ::com::sun::star::text::XTextRange>& xPos2) throw (com::sun::star::lang::IllegalArgumentException, com::sun::star::uno::RuntimeException);
 	BOOL	CheckForOwnMember(const SwXTextRange* pRange1, const OTextCursorHelper* pCursor1)throw(::com::sun::star::lang::IllegalArgumentException, ::com::sun::star::uno::RuntimeException);
 	//
-	void			Invalidate() {bObjectValid = sal_False;}
-	BOOL 			IsValid()const {return bObjectValid;}
+    void            Invalidate() {m_bObjectValid = sal_False;}
+    BOOL            IsValid()const {return m_bObjectValid;}
 
-	CursorType		GetTextType() {return eCrsrType;}
+    CursorType      GetTextType() {return m_eCrsrType;}
 };
 
 /* -----------------03.12.98 12:16-------------------
--- sw/inc/unoprnms.hxx	22 May 2007 16:22:03 -0000	1.120
+++ sw/inc/unoprnms.hxx	12 Jul 2007 14:08:42 -0000
@@ -780,14 +780,17 @@
 /* 0708 */   UNO_NAME_CHAR_AUTO_STYLE_NAME,
 /* 0709 */   UNO_NAME_PARA_AUTO_STYLE_NAME,
 // --> OD 2006-03-21 #b6375613#
-/* 0710 */  UNO_NAME_APPLY_WORKAROUND_FOR_B6375613,
-/* 0711 */  UNO_NAME_LAYOUT_SIZE,
+/* 0709 */  UNO_NAME_APPLY_WORKAROUND_FOR_B6375613,
+// <--
+/* 0710 */  UNO_NAME_LAYOUT_SIZE,
+/* 0711 */  UNO_NAME_INPUT,
 // --> HB #144146#
 /* 0712 */  UNO_NAME_HELP,
 /* 0713 */  UNO_NAME_TOOLTIP,
 // --> #i73329# / 2007-01-11 / frank.schoenheit@sun.com
 /* 0714 */  UNO_NAME_DIALOG_LIBRARIES,
-/* 0715 */  SW_PROPNAME_END
+/* 0715 */  UNO_NAME_HEADER_ROW_COUNT,
+/* 0716 */  SW_PROPNAME_END
 };
 
 
--- sw/prj/build.lst	27 Jun 2007 13:15:21 -0000	1.22
+++ sw/prj/build.lst	12 Jul 2007 14:08:42 -0000
@@ -1,4 +1,4 @@
-sw	sw	:	connectivity OOo:writerperfect svx stoc uui NULL
+sw      sw      :       connectivity OOo:writerperfect writerfilter svx stoc uui NULL
 sw	sw										usr1	-	all	sw_mkout NULL
 sw	sw\inc									nmake		-	all	sw_inc NULL
 sw	sw\prj									get		-	all	sw_prj NULL
--- sw/source/core/docnode/ndtbl.cxx	22 May 2007 16:26:23 -0000	1.45
+++ sw/source/core/docnode/ndtbl.cxx	12 Jul 2007 14:08:46 -0000
@@ -1232,6 +1232,322 @@
 	return pTblNd;
 }
 
+/*-- 18.05.2006 10:30:29---------------------------------------------------
+
+  -----------------------------------------------------------------------*/
+const SwTable* SwDoc::TextToTable( const std::vector< std::vector<SwNodeRange> >& rTableNodes )
+{
+    /* #106283# Save first node in the selection if it is a content node. */
+    SwCntntNode * pSttCntntNd = rTableNodes.begin()->begin()->aStart.GetNode().GetCntntNode();
+
+    /**debug**/
+    const SwNodeRange& rStartRange = *rTableNodes.begin()->begin();
+    const SwNodeRange& rEndRange = *rTableNodes.rbegin()->rbegin();
+    /**debug**/
+
+    //!!! not necessarily TextNodes !!!
+    SwPaM aOriginal( rTableNodes.begin()->begin()->aStart, rTableNodes.rbegin()->rbegin()->aEnd );
+    const SwPosition *pStt = aOriginal.GetMark();
+    const SwPosition *pEnd = aOriginal.GetPoint();
+
+#ifdef DEL_TABLE_REDLINES
+    lcl_DelRedlines aDelRedl( aOriginal );
+#endif
+
+    SwUndoTxtToTbl* pUndo = 0;
+    if( DoesUndo() )
+    {
+//        StartUndo( UNDO_TEXTTOTABLE );
+//        pUndo = new SwUndoTxtToTbl( aOriginal, rInsTblOpts, cCh, eAdjust, pTAFmt );
+//        AppendUndo( pUndo );
+
+        // das Splitten vom TextNode nicht in die Undohistory aufnehmen
+        DoUndo( FALSE );
+    }
+
+    // die Bookmarks loeschen und die Cursor der CrsrShell verschieben
+    _DelBookmarks( pStt->nNode, pEnd->nNode, 0,
+                    &pStt->nContent, &pEnd->nContent );
+    ::PaMCorrAbs( aOriginal, *pEnd );
+
+    // sorge dafuer, das der Bereich auf Node-Grenzen liegt
+    SwNodeRange aRg( pStt->nNode, pEnd->nNode );
+    if( pStt->nContent.GetIndex() )
+        SplitNode( *pStt, false );
+
+    BOOL bEndCntnt = 0 != pEnd->nContent.GetIndex();
+    // nicht splitten am Ende der Zeile (aber am Ende vom Doc!!)
+    if( bEndCntnt )
+    {
+        if( pEnd->nNode.GetNode().GetCntntNode()->Len() != pEnd->nContent.GetIndex()
+            || pEnd->nNode.GetIndex() >= GetNodes().GetEndOfContent().GetIndex()-1 )
+        {
+            SplitNode( *pEnd, false );
+            ((SwNodeIndex&)pEnd->nNode)--;
+            ((SwIndex&)pEnd->nContent).Assign(
+                                pEnd->nNode.GetNode().GetCntntNode(), 0 );
+            // ein Node und am Ende ??
+            if( pStt->nNode.GetIndex() >= pEnd->nNode.GetIndex() )
+                aRg.aStart--;
+        }
+        else
+            aRg.aEnd++;
+    }
+
+
+    if( aRg.aEnd.GetIndex() == aRg.aStart.GetIndex() )
+    {
+        ASSERT( FALSE, "Kein Bereich" );
+        aRg.aEnd++;
+    }
+
+    // Wir gehen jetzt immer ueber die Upper, um die Tabelle einzufuegen:
+    SwNode2Layout aNode2Layout( aRg.aStart.GetNode() );
+
+    DoUndo( 0 != pUndo );
+
+    // dann erstelle die Box/Line/Table-Struktur
+    SwTableBoxFmt* pBoxFmt = MakeTableBoxFmt();
+    SwTableLineFmt* pLineFmt = MakeTableLineFmt();
+    SwTableFmt* pTableFmt = MakeTblFrmFmt( GetUniqueTblName(), GetDfltFrmFmt() );
+
+    // alle Zeilen haben die Fill-Order von links nach rechts !
+    pLineFmt->SetAttr( SwFmtFillOrder( ATT_LEFT_TO_RIGHT ));
+    // die Tabelle bekommt USHRT_MAX als default SSize
+    pTableFmt->SetAttr( SwFmtFrmSize( ATT_VAR_SIZE, USHRT_MAX ));
+//    if( !(rInsTblOpts.mnInsMode & tabopts::SPLIT_LAYOUT) )
+//        pTableFmt->SetAttr( SwFmtLayoutSplit( FALSE ));
+
+    /* #106283# If the first node in the selection is a context node and if it
+       has an item FRAMEDIR set (no default) propagate the item to the
+       replacing table. */
+    if (pSttCntntNd)
+    {
+        const SwAttrSet & aNdSet = pSttCntntNd->GetSwAttrSet();
+        const SfxPoolItem *pItem = NULL;
+
+        if (SFX_ITEM_SET == aNdSet.GetItemState( RES_FRAMEDIR, TRUE, &pItem )
+            && pItem != NULL)
+        {
+            pTableFmt->SetAttr( *pItem );
+        }
+    }
+
+    SwTableNode* pTblNd = GetNodes().TextToTable(
+            rTableNodes, pTableFmt, pLineFmt, pBoxFmt,
+            GetTxtCollFromPool( RES_POOLCOLL_STANDARD )/*, pUndo*/ );
+
+    SwTable * pNdTbl = &pTblNd->GetTable();
+    ASSERT( pNdTbl, "kein Tabellen-Node angelegt."  )
+	pTableFmt->Add( pNdTbl );		// das Frame-Format setzen
+
+//    const USHORT nRowsToRepeat =
+//            tabopts::HEADLINE == (rInsTblOpts.mnInsMode & tabopts::HEADLINE) ?
+//            rInsTblOpts.mnRowsToRepeat :
+//            0;
+//    pNdTbl->SetRowsToRepeat( nRowsToRepeat );
+
+    BOOL bUseBoxFmt = FALSE;
+    if( !pBoxFmt->GetDepends() )
+    {
+        // die Formate an den Boxen haben schon die richtige Size, es darf
+        // also nur noch die richtige Umrandung/AutoFmt gesetzt werden.
+        bUseBoxFmt = TRUE;
+        pTableFmt->SetAttr( pBoxFmt->GetFrmSize() );
+        delete pBoxFmt;
+//        eAdjust = HORI_NONE;
+    }
+
+    //Orientation am Fmt der Table setzen
+//    pTableFmt->SetAttr( SwFmtHoriOrient( 0, eAdjust ) );
+//    pTableFmt->Add( pNdTbl );       // das Frame-Format setzen
+
+
+    ULONG nIdx = pTblNd->GetIndex();
+    aNode2Layout.RestoreUpperFrms( GetNodes(), nIdx, nIdx + 1 );
+
+    {
+//        SwPaM& rTmp = (SwPaM&)rRange;   // Point immer an den Anfang
+//        rTmp.DeleteMark();
+//        rTmp.GetPoint()->nNode = *pTblNd;
+//        SwCntntNode* pCNd = GetNodes().GoNext( &rTmp.GetPoint()->nNode );
+//        rTmp.GetPoint()->nContent.Assign( pCNd, 0 );
+    }
+
+//    if( pUndo )
+//        EndUndo( UNDO_TEXTTOTABLE );
+
+    SetModified();
+    SetFieldsDirty( true, NULL, 0 );
+    return pNdTbl;
+}
+
+/*-- 18.05.2006 08:23:28---------------------------------------------------
+
+  -----------------------------------------------------------------------*/
+SwTableNode* SwNodes::TextToTable( const std::vector< std::vector<SwNodeRange> >& rTableNodes,
+                                    SwTableFmt* pTblFmt,
+                                    SwTableLineFmt* pLineFmt,
+                                    SwTableBoxFmt* pBoxFmt,
+                                    SwTxtFmtColl* pTxtColl/*, SwUndo... pUndo*/  )
+{
+    if( !rTableNodes.size() )
+        return 0;
+
+    SwTableNode * pTblNd = new SwTableNode( rTableNodes.begin()->begin()->aStart );
+    //insert the end node after the last text node
+	SwNodeIndex aInsertIndex( rTableNodes.rbegin()->rbegin()->aEnd );
+	++aInsertIndex;
+	SwEndNode* pEndNd = new SwEndNode( aInsertIndex, *pTblNd );
+
+    /**debug**/
+    const SwNodeRange& rStartRange = *rTableNodes.begin()->begin();
+    const SwNodeRange& rEndRange = *rTableNodes.rbegin()->rbegin();
+    /**debug**/
+
+    SwDoc* pDoc = GetDoc();
+    SvUShorts aPosArr( 0, 16 );
+    SwTable * pTable = &pTblNd->GetTable();
+    SwTableLine* pLine;
+    SwTableBox* pBox;
+    USHORT nBoxes, nLines, nMaxBoxes = 0;
+
+//    SwHistory* pHistory = pUndo ? &pUndo->GetHistory() : 0;
+
+
+    SwNodeIndex aNodeIndex = rTableNodes.begin()->begin()->aStart;
+    // delete frames of all contained content nodes
+    for( nLines = 0; aNodeIndex <= rTableNodes.rbegin()->rbegin()->aEnd; ++aNodeIndex,++nLines )
+    {
+        SwNode& rNode = aNodeIndex.GetNode();
+        if( rNode.IsCntntNode() )
+        {
+            static_cast<SwCntntNode&>(rNode).DelFrms();
+            if(rNode.IsTxtNode())
+            {
+                SwTxtNode& rTxtNode = static_cast<SwTxtNode&>(rNode);
+                // setze den bei allen TextNode in der Tabelle den TableNode
+                // als StartNode
+                rTxtNode.pStartOfSection = pTblNd;
+                // remove PageBreaks/PageDesc/ColBreak
+                const SwAttrSet* pSet = rTxtNode.GetpSwAttrSet();
+                if( pSet )
+                {
+        // das entfernen der PageBreaks erst nach dem erzeugen der Tabelle
+        // erfolgen, denn sonst stehen sie falsch in der History !!!
+        //          SwRegHistory aRegH( pTxtNd, *pTxtNd, pHistory );
+                    const SfxPoolItem* pItem;
+                    if( SFX_ITEM_SET == pSet->GetItemState( RES_BREAK, FALSE, &pItem ) )
+                    {
+                        if( !nLines )
+                            pTblFmt->SetAttr( *pItem );
+                        rTxtNode.SwCntntNode::ResetAttr( RES_BREAK );
+                        pSet = rTxtNode.GetpSwAttrSet();
+                    }
+
+                    if( pSet && SFX_ITEM_SET == pSet->GetItemState(
+                        RES_PAGEDESC, FALSE, &pItem ) &&
+                        ((SwFmtPageDesc*)pItem)->GetPageDesc() )
+                    {
+                        if( !nLines )
+                            pTblFmt->SetAttr( *pItem );
+                        rTxtNode.SwCntntNode::ResetAttr( RES_PAGEDESC );
+                    }
+                }
+            }
+        }
+    }
+
+//    SwNodeIndex aSttIdx( *pTblNd, 1 );
+//    SwNodeIndex aEndIdx( rlNodes.rbegin()->aEnd, -1 );
+    std::vector<std::vector < SwNodeRange > >::const_iterator aRowIter = rTableNodes.begin();
+    for( nLines = 0, nBoxes = 0;
+        aRowIter != rTableNodes.end();
+        ++aRowIter, /*aSttIdx += 2, */nLines++, nBoxes = 0 )
+    {
+//        SwTxtNode* pTxtNd = aSttIdx.GetNode().GetTxtNode();
+//        ASSERT( pTxtNd, "nur TextNodes in der Tabelle aufnehmen" );
+
+        pLine = new SwTableLine( pLineFmt, 1, 0 );
+        pTable->GetTabLines().C40_INSERT( SwTableLine, pLine, nLines );
+
+//        SwStartNode* pSttNd;
+//        SwPosition aCntPos( aSttIdx, SwIndex( pTxtNd ));
+
+        std::vector< SwNodeRange >::const_iterator aCellIter = aRowIter->begin();
+//        SvULongs aBkmkArr( 15, 15 );
+//        _SaveCntntIdx( pDoc, aCellIter->aStart.GetIndex(), pTxtNd->GetTxt().Len(), aBkmkArr );
+//        const sal_Unicode* pTxt = pTxtNd->GetTxt().GetBuffer();
+
+        for( ; aCellIter != aRowIter->end(); ++aCellIter )
+        {
+//            aCellIter->aStart aCellIter->aEnd
+//                aCntPos.nContent = nChPos;
+//                SwCntntNode* pNewNd = pTxtNd->SplitNode( aCntPos );
+
+//        auch fürs undo?
+//                if( aBkmkArr.Count() )
+//                    _RestoreCntntIdx( aBkmkArr, *pNewNd, nChPos,
+//                                        nChPos + 1 );
+
+                const SwNodeIndex aTmpIdx( aCellIter->aStart, 0 );
+
+				SwNodeIndex aCellEndIdx(aCellIter->aEnd);
+				++aCellEndIdx;
+				SwStartNode* pSttNd = new SwStartNode( aTmpIdx, ND_STARTNODE,
+                                            SwTableBoxStartNode );
+                new SwEndNode( aCellEndIdx, *pSttNd );
+                //set the start node on all node of the current cell
+                SwNodeIndex aCellNodeIdx = aCellIter->aStart;
+                for(;aCellNodeIdx <= aCellIter->aEnd; ++aCellNodeIdx )
+                {
+                    aCellNodeIdx.GetNode().pStartOfSection = pSttNd;
+                    //skip start/end node pairs
+                    if( aCellNodeIdx.GetNode().IsStartNode() )
+                        aCellNodeIdx = SwNodeIndex( *aCellNodeIdx.GetNode().EndOfSectionNode() );
+                }
+
+
+                // Section der Box zuweisen
+                pBox = new SwTableBox( pBoxFmt, *pSttNd, pLine );
+                pLine->GetTabBoxes().C40_INSERT( SwTableBox, pBox, nBoxes++ );
+        }
+        if( nMaxBoxes < nBoxes )
+            nMaxBoxes = nBoxes;
+    }
+
+    // die Tabelle ausgleichen, leere Sections einfuegen
+    USHORT n;
+
+    if( aPosArr.Count() )
+    {
+        SwTableLines& rLns = pTable->GetTabLines();
+        USHORT nLastPos = 0;
+        for( n = 0; n < aPosArr.Count(); ++n )
+        {
+            SwTableBoxFmt *pNewFmt = pDoc->MakeTableBoxFmt();
+            pNewFmt->SetAttr( SwFmtFrmSize( ATT_VAR_SIZE,
+                                                aPosArr[ n ] - nLastPos ));
+            for( USHORT nLines = 0; nLines < rLns.Count(); ++nLines )
+                //JP 24.06.98: hier muss ein Add erfolgen, da das BoxFormat
+                //              von der rufenden Methode noch gebraucht wird!
+                pNewFmt->Add( rLns[ nLines ]->GetTabBoxes()[ n ] );
+
+            nLastPos = aPosArr[ n ];
+        }
+
+        // damit die Tabelle die richtige Groesse bekommt, im BoxFormat die
+        // Groesse nach "oben" transportieren.
+        ASSERT( !pBoxFmt->GetDepends(), "wer ist in dem Format noch angemeldet" );
+        pBoxFmt->SetAttr( SwFmtFrmSize( ATT_VAR_SIZE, nLastPos ));
+    }
+    else
+        pBoxFmt->SetAttr( SwFmtFrmSize( ATT_VAR_SIZE, USHRT_MAX / nMaxBoxes ));
+
+    // das wars doch wohl ??
+    return pTblNd;
+}
+
 //---------------- Tabelle -> Text -----------------------
 
 
--- sw/source/core/table/swtable.cxx	25 May 2007 13:01:16 -0000	1.5
+++ sw/source/core/table/swtable.cxx	12 Jul 2007 14:08:49 -0000
@@ -1458,7 +1458,7 @@
                 bGoOn = aRowSpanPos.size() > 0 && j+1 < rLines.Count();
             };
         }
-        ::lcl_AdjustWidthsInLine( rLines[nCurr], aOldNew, rParm, 0 );
+        ::lcl_AdjustWidthsInLine( rLines[nCurr], aOldNew, rParm, 1 );
     }
     else for( USHORT i = 0; i < rLines.Count(); ++i )
         ::lcl_AdjustWidthsInLine( rLines[i], aOldNew, rParm, COLFUZZY );
--- sw/source/core/unocore/unofield.cxx	5 Jun 2007 17:32:51 -0000	1.96
+++ sw/source/core/unocore/unofield.cxx	12 Jul 2007 14:08:51 -0000
@@ -745,6 +745,12 @@
 					pType = m_pDoc->InsertFldType(aType);
 				}
 				break;
+                case RES_DBFLD :
+                {    
+                    ::GetString( rValue, sParam3 );
+                    pType = GetFldType();
+                }
+                break;
 			}
 			if(pType)
 			{
@@ -1028,28 +1034,36 @@
 /*-- 14.12.98 11:08:36---------------------------------------------------
 
   -----------------------------------------------------------------------*/
-void SwXFieldMaster::addPropertyChangeListener(const OUString& PropertyName, const uno::Reference< beans::XPropertyChangeListener > & aListener) throw( beans::UnknownPropertyException, lang::WrappedTargetException, uno::RuntimeException )
+void SwXFieldMaster::addPropertyChangeListener(const OUString& /*PropertyName*/, 
+        const uno::Reference< beans::XPropertyChangeListener > & /*aListener*/) 
+            throw( beans::UnknownPropertyException, lang::WrappedTargetException, uno::RuntimeException )
 {
 	DBG_WARNING("not implemented")
 }
 /*-- 14.12.98 11:08:36---------------------------------------------------
 
   -----------------------------------------------------------------------*/
-void SwXFieldMaster::removePropertyChangeListener(const OUString& PropertyName, const uno::Reference< beans::XPropertyChangeListener > & aListener) throw( beans::UnknownPropertyException, lang::WrappedTargetException, uno::RuntimeException )
+void SwXFieldMaster::removePropertyChangeListener(const OUString& /*PropertyName*/, 
+        const uno::Reference< beans::XPropertyChangeListener > & /*aListener*/) 
+            throw( beans::UnknownPropertyException, lang::WrappedTargetException, uno::RuntimeException )
 {
 	DBG_WARNING("not implemented")
 }
 /*-- 14.12.98 11:08:37---------------------------------------------------
 
   -----------------------------------------------------------------------*/
-void SwXFieldMaster::addVetoableChangeListener(const OUString& PropertyName, const uno::Reference< beans::XVetoableChangeListener > & aListener) throw( beans::UnknownPropertyException, lang::WrappedTargetException, uno::RuntimeException )
+void SwXFieldMaster::addVetoableChangeListener(const OUString& /*PropertyName*/, 
+        const uno::Reference< beans::XVetoableChangeListener > & /*aListener*/) 
+            throw( beans::UnknownPropertyException, lang::WrappedTargetException, uno::RuntimeException )
 {
 	DBG_WARNING("not implemented")
 }
 /*-- 14.12.98 11:08:37---------------------------------------------------
 
   -----------------------------------------------------------------------*/
-void SwXFieldMaster::removeVetoableChangeListener(const OUString& PropertyName, const uno::Reference< beans::XVetoableChangeListener > & aListener) throw( beans::UnknownPropertyException, lang::WrappedTargetException, uno::RuntimeException )
+void SwXFieldMaster::removeVetoableChangeListener(const OUString& /*PropertyName*/, 
+        const uno::Reference< beans::XVetoableChangeListener > & /*aListener*/) 
+            throw( beans::UnknownPropertyException, lang::WrappedTargetException, uno::RuntimeException )
 {
 	DBG_WARNING("not implemented")
 }
@@ -1284,7 +1298,8 @@
 		m_pProps->bBool2 = sal_True;
     else if(SW_SERVICE_FIELDTYPE_TABLE_FORMULA == nServiceId)
         m_pProps->bBool1 = sal_True;
-
+    if(SW_SERVICE_FIELDTYPE_SET_EXP == nServiceId)
+        m_pProps->nUSHORT2 = USHRT_MAX;
 }
 /*-- 14.12.98 11:37:15---------------------------------------------------
 
@@ -1326,6 +1341,7 @@
 	if(pFieldType && pFieldType->Which() == lcl_ServiceIdToResId(m_nServiceId))
 	{
 		m_sTypeName = pFieldType->GetName();
+        pFieldType->Add( &m_aFieldTypeClient );
 	}
 	else
 		throw lang::IllegalArgumentException();
@@ -1337,9 +1353,17 @@
 uno::Reference< beans::XPropertySet >  SwXTextField::getTextFieldMaster(void) throw( uno::RuntimeException )
 {
 	vos::OGuard  aGuard(Application::GetSolarMutex());
-	if(!GetRegisteredIn())
-		throw uno::RuntimeException();
-	SwFieldType* pType = pFmtFld->GetFld()->GetTyp();
+    SwFieldType* pType = 0;
+    if( m_bIsDescriptor && m_aFieldTypeClient.GetRegisteredIn() )
+    {
+        pType = (SwFieldType*)m_aFieldTypeClient.GetRegisteredIn();
+    }            
+    else
+    {        
+        if(!GetRegisteredIn())
+            throw uno::RuntimeException();
+        pType = pFmtFld->GetFld()->GetTyp();
+    }
 	SwXFieldMaster* pMaster = (SwXFieldMaster*)
 				SwClientIter(*pType).First(TYPE(SwXFieldMaster));
 	if(!pMaster)
@@ -1713,7 +1737,8 @@
                         m_pProps->nFormat = -1;
                 pFld = new SwSetExpField((SwSetExpFieldType*)pFldType,
 					m_pProps->sPar2,
-                    m_pProps->nFormat);
+                    m_pProps->nUSHORT2 != USHRT_MAX ?
+                    m_pProps->nUSHORT2 : m_pProps->nFormat);
 
 				sal_uInt16	nSubType = pFld->GetSubType();
 				if(m_pProps->bBool2)
@@ -1891,6 +1916,8 @@
 		m_pDoc = pDoc;
 		m_pDoc->GetUnoCallBack()->Add(this);
 		m_bIsDescriptor = sal_False;
+        if(m_aFieldTypeClient.GetRegisteredIn())
+            const_cast<SwModify*>(m_aFieldTypeClient.GetRegisteredIn())->Remove(&m_aFieldTypeClient);
 		DELETEZ(m_pProps);
         if(m_bCallUpdate)
             update();
@@ -2318,28 +2345,36 @@
 /*-- 14.12.98 11:37:20---------------------------------------------------
 
   -----------------------------------------------------------------------*/
-void SwXTextField::addPropertyChangeListener(const OUString& PropertyName, const uno::Reference< beans::XPropertyChangeListener > & aListener) throw( beans::UnknownPropertyException, lang::WrappedTargetException, uno::RuntimeException )
+void SwXTextField::addPropertyChangeListener(const OUString& /*PropertyName*/, 
+        const uno::Reference< beans::XPropertyChangeListener > & /*aListener*/) 
+            throw( beans::UnknownPropertyException, lang::WrappedTargetException, uno::RuntimeException )
 {
 	DBG_WARNING("not implemented")
 }
 /*-- 14.12.98 11:37:20---------------------------------------------------
 
   -----------------------------------------------------------------------*/
-void SwXTextField::removePropertyChangeListener(const OUString& PropertyName, const uno::Reference< beans::XPropertyChangeListener > & aListener) throw( beans::UnknownPropertyException, lang::WrappedTargetException, uno::RuntimeException )
+void SwXTextField::removePropertyChangeListener(const OUString& /*PropertyName*/, 
+        const uno::Reference< beans::XPropertyChangeListener > & /*aListener*/) 
+            throw( beans::UnknownPropertyException, lang::WrappedTargetException, uno::RuntimeException )
 {
 	DBG_WARNING("not implemented")
 }
 /*-- 14.12.98 11:37:20---------------------------------------------------
 
   -----------------------------------------------------------------------*/
-void SwXTextField::addVetoableChangeListener(const OUString& PropertyName, const uno::Reference< beans::XVetoableChangeListener > & aListener) throw( beans::UnknownPropertyException, lang::WrappedTargetException, uno::RuntimeException )
+void SwXTextField::addVetoableChangeListener(const OUString& /*PropertyName*/, 
+        const uno::Reference< beans::XVetoableChangeListener > & /*aListener*/) 
+            throw( beans::UnknownPropertyException, lang::WrappedTargetException, uno::RuntimeException )
 {
 	DBG_WARNING("not implemented")
 }
 /*-- 14.12.98 11:37:20---------------------------------------------------
 
   -----------------------------------------------------------------------*/
-void SwXTextField::removeVetoableChangeListener(const OUString& PropertyName, const uno::Reference< beans::XVetoableChangeListener > & aListener) throw( beans::UnknownPropertyException, lang::WrappedTargetException, uno::RuntimeException )
+void SwXTextField::removeVetoableChangeListener(const OUString& /*PropertyName*/, 
+        const uno::Reference< beans::XVetoableChangeListener > & /*aListener*/) 
+            throw( beans::UnknownPropertyException, lang::WrappedTargetException, uno::RuntimeException )
 {
 	DBG_WARNING("not implemented")
 }
--- sw/source/core/unocore/unoframe.cxx	5 Jun 2007 17:33:19 -0000	1.111
+++ sw/source/core/unocore/unoframe.cxx	12 Jul 2007 14:08:55 -0000
@@ -57,19 +57,22 @@
 #ifndef _COM_SUN_STAR_EMBED_ASPECTS_HPP_
 #include <com/sun/star/embed/Aspects.hpp>
 #endif
+#ifndef _COM_SUN_STAR_GRAPHIC_XGRAPHICPROVIDER_HPP_
+#include <com/sun/star/graphic/XGraphicProvider.hpp>
+#endif
 
 #include <swtypes.hxx>
 #include <cmdid.h>
 
 #include <memory>
 
-#ifndef _HINTS_HXX //autogen
+#ifndef _HINTS_HXX
 #include <hints.hxx>
 #endif
-#ifndef _DOC_HXX //autogen
+#ifndef _DOC_HXX
 #include <doc.hxx>
 #endif
-#ifndef _DOCSH_HXX //autogen
+#ifndef _DOCSH_HXX
 #include <docsh.hxx>
 #endif
 #ifndef _EDITSH_HXX
@@ -81,28 +84,28 @@
 #ifndef _NDINDEX_HXX //autogen
 #include <ndindex.hxx>
 #endif
-#ifndef _PAM_HXX //autogen
+#ifndef _PAM_HXX
 #include <pam.hxx>
 #endif
-#ifndef _NDNOTXT_HXX //autogen
+#ifndef _NDNOTXT_HXX
 #include <ndnotxt.hxx>
 #endif
 #ifndef _SVX_UNOMID_HXX
 #include <svx/unomid.hxx>
 #endif
-#ifndef _UNOCRSR_HXX //autogen
+#ifndef _UNOCRSR_HXX
 #include <unocrsr.hxx>
 #endif
-#ifndef _DOCSTYLE_HXX //autogen
+#ifndef _DOCSTYLE_HXX
 #include <docstyle.hxx>
 #endif
 #ifndef _DCONTACT_HXX
 #include <dcontact.hxx>
 #endif
-#ifndef _FMTCNCT_HXX //autogen
+#ifndef _FMTCNCT_HXX
 #include <fmtcnct.hxx>
 #endif
-#ifndef _NDOLE_HXX //autogen
+#ifndef _NDOLE_HXX
 #include <ndole.hxx>
 #endif
 #ifndef _FRMFMT_HXX
@@ -162,7 +165,7 @@
 #ifndef _TL_POLY_HXX
 #include <tools/poly.hxx>
 #endif
-#ifndef _SWUNDO_HXX //autogen
+#ifndef _SWUNDO_HXX
 #include <swundo.hxx>
 #endif
 #ifndef _UNOSTYLE_HXX
@@ -174,43 +177,43 @@
 #ifndef _SVDPAGE_HXX
 #include <svx/svdpage.hxx>
 #endif
-#ifndef _SVX_BRSHITEM_HXX //autogen
+#ifndef _SVX_BRSHITEM_HXX
 #include <svx/brshitem.hxx>
 #endif
-#ifndef _SVX_PROTITEM_HXX //autogen
+#ifndef _SVX_PROTITEM_HXX
 #include <svx/protitem.hxx>
 #endif
-#ifndef _FMTORNT_HXX //autogen
+#ifndef _FMTORNT_HXX
 #include <fmtornt.hxx>
 #endif
-#ifndef _FMTURL_HXX //autogen
+#ifndef _FMTURL_HXX
 #include <fmturl.hxx>
 #endif
-#ifndef _SVX_LRSPITEM_HXX //autogen
+#ifndef _SVX_LRSPITEM_HXX
 #include <svx/lrspitem.hxx>
 #endif
-#ifndef _SVX_ULSPITEM_HXX //autogen
+#ifndef _SVX_ULSPITEM_HXX
 #include <svx/ulspitem.hxx>
 #endif
-#ifndef _SVX_BOXITEM_HXX //autogen
+#ifndef _SVX_BOXITEM_HXX
 #include <svx/boxitem.hxx>
 #endif
-#ifndef _SVX_OPAQITEM_HXX //autogen
+#ifndef _SVX_OPAQITEM_HXX
 #include <svx/opaqitem.hxx>
 #endif
-#ifndef _SVX_PRNTITEM_HXX //autogen
+#ifndef _SVX_PRNTITEM_HXX
 #include <svx/prntitem.hxx>
 #endif
-#ifndef _SVX_SHADITEM_HXX //autogen
+#ifndef _SVX_SHADITEM_HXX
 #include <svx/shaditem.hxx>
 #endif
-#ifndef _FMTSRND_HXX //autogen
+#ifndef _FMTSRND_HXX
 #include <fmtsrnd.hxx>
 #endif
-#ifndef _FMTFSIZE_HXX //autogen
+#ifndef _FMTFSIZE_HXX
 #include <fmtfsize.hxx>
 #endif
-#ifndef _GRFATR_HXX //autogen
+#ifndef _GRFATR_HXX
 #include <grfatr.hxx>
 #endif
 #ifndef _UNOFRAME_HXX
@@ -231,10 +234,10 @@
 #ifndef _NDGRF_HXX
 #include <ndgrf.hxx>
 #endif
-#ifndef _VOS_MUTEX_HXX_ //autogen
+#ifndef _VOS_MUTEX_HXX_
 #include <vos/mutex.hxx>
 #endif
-#ifndef _SV_SVAPP_HXX //autogen
+#ifndef _SV_SVAPP_HXX
 #include <vcl/svapp.hxx>
 #endif
 #ifndef _SFX_PRINTER_HXX
@@ -258,7 +261,7 @@
 #ifndef _URLOBJ_HXX
 #include <tools/urlobj.hxx>
 #endif
-#ifndef _SVX_FRMDIRITEM_HXX //autogen
+#ifndef _SVX_FRMDIRITEM_HXX
 #include <svx/frmdiritem.hxx>
 #endif
 // DVO, OD 01.10.2003 #i18732#
@@ -291,20 +294,20 @@
 DECLARE_TABLE(SwFrameAnyTable_Impl, uno::Any*)
 class BaseFrameProperties_Impl
 {
-    const SfxItemPropertyMap*       _pMap;
+    const SfxItemPropertyMap*       m_pMap;
     SwFrameAnyTable_Impl            aAnyTbl;
 
 public:
 
 	BaseFrameProperties_Impl ( const SfxItemPropertyMap* pMap ) :
-		_pMap(pMap) {}
+		m_pMap(pMap) {}
     ~BaseFrameProperties_Impl();
 
     void            SetProperty(USHORT nWID, BYTE nMemberId, uno::Any aVal);
     sal_Bool        GetProperty(USHORT nWID, BYTE nMemberId, uno::Any*& pAny );
     void        	GetProperty(const OUString &rPropertyName, const uno::Reference < beans::XPropertySet > &rxPropertySet, uno::Any& rAny );
 
-    const SfxItemPropertyMap*       GetMap() const {return _pMap;}
+    const SfxItemPropertyMap*       GetMap() const {return m_pMap;}
     sal_Bool                        FillBaseProperties(SfxItemSet& rToSet, const SfxItemSet &rFromSet, sal_Bool& rSizeFound);
 
     virtual sal_Bool                AnyToItemSet( SwDoc* pDoc, SfxItemSet& rFrmSet, SfxItemSet& rSet, sal_Bool& rSizeFound) = 0;
@@ -711,7 +714,7 @@
         BaseFrameProperties_Impl(pMap){}
 public:
     SwFrameProperties_Impl();
-    ~SwFrameProperties_Impl(){}
+    virtual ~SwFrameProperties_Impl(){}
 
     virtual sal_Bool        AnyToItemSet( SwDoc* pDoc, SfxItemSet& rFrmSet, SfxItemSet& rSet, sal_Bool& rSizeFound);
 };
@@ -780,7 +783,7 @@
 {
 public:
 	SwGraphicProperties_Impl();
-    ~SwGraphicProperties_Impl(){}
+    virtual ~SwGraphicProperties_Impl(){}
 
     virtual sal_Bool                AnyToItemSet( SwDoc* pDoc, SfxItemSet& rFrmSet, SfxItemSet& rSet, sal_Bool& rSizeFound);
 };
@@ -890,7 +893,7 @@
 public:
     SwOLEProperties_Impl() :
         SwFrameProperties_Impl(aSwMapProvider.GetPropertyMap(PROPERTY_MAP_EMBEDDED_OBJECT) ){}
-    ~SwOLEProperties_Impl(){}
+    virtual ~SwOLEProperties_Impl(){}
 
     virtual sal_Bool        AnyToItemSet( SwDoc* pDoc, SfxItemSet& rFrmSet, SfxItemSet& rSet, sal_Bool& rSizeFound);
 };
@@ -974,12 +977,13 @@
   -----------------------------------------------------------------------*/
 SwXFrame::SwXFrame(FlyCntType eSet, const SfxItemPropertyMap* pMap, SwDoc *pDoc)
 	:
-	aLstnrCntnr( (container::XNamed*)this),
-	eType(eSet),
-	aPropSet(pMap),
-	_pMap(pMap),
-	bIsDescriptor(sal_True),
-	mpDoc ( pDoc )
+	m_aLstnrCntnr( (container::XNamed*)this),
+	m_eType(eSet),
+	m_aPropSet(pMap),
+	m_pMap(pMap),
+	m_bIsDescriptor(sal_True),
+	m_pDoc ( pDoc ),
+    m_pCopySource( 0 )
 {
 	// Register ourselves as a listener to the document (via the page descriptor)
     pDoc->GetPageDescFromPool(RES_POOLPAGE_STANDARD)->Add(this);
@@ -995,28 +999,28 @@
 	aAny >>= mxStyleFamily;
 	// In the derived class, we'll ask mxStyleFamily for the relevant default style
 	// mxStyleFamily is initialised in the SwXFrame constructor
-	switch(eType)
+	switch(m_eType)
 	{
 		case FLYCNTTYPE_FRM:
 		{
 			uno::Any aAny = mxStyleFamily->getByName ( OUString ( RTL_CONSTASCII_USTRINGPARAM ( "Frame" ) ) );
 			aAny >>= mxStyleData;
-			pProps = new SwFrameProperties_Impl( );
+			m_pProps = new SwFrameProperties_Impl( );
 		}
 		break;
 		case FLYCNTTYPE_GRF:
 		{
 			uno::Any aAny = mxStyleFamily->getByName ( OUString ( RTL_CONSTASCII_USTRINGPARAM ( "Graphics" ) ) );
 			aAny >>= mxStyleData;
-			pProps = new SwGraphicProperties_Impl( );
+			m_pProps = new SwGraphicProperties_Impl( );
 		}
 		break;
 		case FLYCNTTYPE_OLE:
 		{
 			uno::Any aAny = mxStyleFamily->getByName ( OUString ( RTL_CONSTASCII_USTRINGPARAM ( "OLE" ) ) );
 			aAny >>= mxStyleData;
-			pProps = 0;
-            pProps = new SwOLEProperties_Impl( );
+			m_pProps = 0;
+            m_pProps = new SwOLEProperties_Impl( );
         }
 		break;
 	}
@@ -1026,13 +1030,14 @@
 
   -----------------------------------------------------------------------*/
 SwXFrame::SwXFrame(SwFrmFmt& rFrmFmt, FlyCntType eSet, const SfxItemPropertyMap* pMap) :
-	eType(eSet),
+	m_eType(eSet),
 	SwClient( &rFrmFmt ),
-	aLstnrCntnr( (container::XNamed*)this),
-	aPropSet(pMap),
-	_pMap(pMap),
-	bIsDescriptor(sal_False),
-	pProps(0)
+	m_aLstnrCntnr( (container::XNamed*)this),
+	m_aPropSet(pMap),
+	m_pMap(pMap),
+	m_bIsDescriptor(sal_False),
+	m_pProps(0),
+    m_pCopySource(0)
 {
 
 }
@@ -1041,7 +1046,8 @@
   -----------------------------------------------------------------------*/
 SwXFrame::~SwXFrame()
 {
-	delete pProps;
+	delete m_pCopySource;
+    delete m_pProps;
 }
 /*-- 11.12.98 15:05:03---------------------------------------------------
 
@@ -1056,8 +1062,8 @@
 	SwFrmFmt* pFmt = GetFrmFmt();
 	if(pFmt)
 		sRet = pFmt->GetName();
-	else if(bIsDescriptor)
-		sRet = sName;
+	else if(m_bIsDescriptor)
+		sRet = m_sName;
 	else
 		throw uno::RuntimeException();
 	return sRet;
@@ -1078,8 +1084,8 @@
 			throw uno::RuntimeException();
 		}
 	}
-	else if(bIsDescriptor)
-		sName = sTmpName;
+	else if(m_bIsDescriptor)
+		m_sName = sTmpName;
 	else
 		throw uno::RuntimeException();
 }
@@ -1092,26 +1098,38 @@
 	static uno::Reference< beans::XPropertySetInfo >  xFrmRef;
 	static uno::Reference< beans::XPropertySetInfo >  xGrfRef;
 	static uno::Reference< beans::XPropertySetInfo >  xOLERef;
-	switch(eType)
+    switch(m_eType)
 	{
 	case FLYCNTTYPE_FRM:
 		if( !xFrmRef.is() )
-			xFrmRef = aPropSet.getPropertySetInfo();
+			xFrmRef = m_aPropSet.getPropertySetInfo();
 		xRef = xFrmRef;
 		break;
 	case FLYCNTTYPE_GRF:
 		if( !xGrfRef.is() )
-			xGrfRef = aPropSet.getPropertySetInfo();
+			xGrfRef = m_aPropSet.getPropertySetInfo();
 		xRef = xGrfRef;
 		break;
 	case FLYCNTTYPE_OLE:
 		if( !xOLERef.is() )
-			xOLERef = aPropSet.getPropertySetInfo();
+			xOLERef = m_aPropSet.getPropertySetInfo();
 		xRef = xOLERef;
 		break;
 	}
 	return xRef;
 }
+/*-- 15.05.06 12:21:43---------------------------------------------------
+
+  -----------------------------------------------------------------------*/
+void SwXFrame::SetSelection(SwPaM& rCopySource)
+{
+    if(m_pCopySource)
+        delete m_pCopySource;
+    m_pCopySource = new SwPaM( *rCopySource.Start() );
+    m_pCopySource->SetMark();
+    *m_pCopySource->GetMark() = *rCopySource.End();
+}
+
 /*-- 11.12.98 15:05:04---------------------------------------------------
 
   -----------------------------------------------------------------------*/
@@ -1166,7 +1184,7 @@
 {
 	vos::OGuard aGuard(Application::GetSolarMutex());
 	SwFrmFmt* pFmt = GetFrmFmt();
-    const SfxItemPropertyMap* pCur = SfxItemPropertyMap::GetByName(_pMap, rPropertyName);
+    const SfxItemPropertyMap* pCur = SfxItemPropertyMap::GetByName(m_pMap, rPropertyName);
 
     if (!pCur)
         throw beans::UnknownPropertyException(OUString ( RTL_CONSTASCII_USTRINGPARAM ( "Unknown property: " ) ) + rPropertyName, static_cast < cppu::OWeakObject * > ( this ) );
@@ -1178,7 +1196,7 @@
             throw beans::PropertyVetoException( OUString ( RTL_CONSTASCII_USTRINGPARAM ( "Property is read-only: " ) ) + rPropertyName, static_cast < cppu::OWeakObject * > ( this ) );
 
 		SwDoc* pDoc = pFmt->GetDoc();
-		if(	eType == FLYCNTTYPE_GRF &&
+		if(	m_eType == FLYCNTTYPE_GRF &&
                     (pCur->nWID >=  RES_GRFATR_BEGIN &&
                         pCur->nWID < RES_GRFATR_END)||
 							pCur->nWID == FN_PARAM_COUNTOUR_PP ||
@@ -1244,7 +1262,7 @@
 				else
 				{
 					SfxItemSet aSet(pNoTxt->GetSwAttrSet());
-					aPropSet.setPropertyValue(*pCur, aValue, aSet);
+					m_aPropSet.setPropertyValue(*pCur, aValue, aSet);
 					pNoTxt->SetAttr(aSet);
 				}
 			}
@@ -1344,6 +1362,27 @@
 			}
 			delete pGrfObj;
 		}
+        else if( FN_UNO_GRAPHIC == pCur->nWID )
+        {
+            uno::Reference< graphic::XGraphic > xGraphic;
+            aValue >>= xGraphic;
+            if(xGraphic.is())
+            {
+                const SwNodeIndex* pIdx = pFmt->GetCntnt().GetCntntIdx();
+                if(pIdx)
+                {
+                    SwNodeIndex aIdx(*pIdx, 1);
+                    SwGrfNode* pGrfNode = aIdx.GetNode().GetGrfNode();
+                    if(!pGrfNode)
+                    {
+                        throw uno::RuntimeException();
+                    }
+                    SwPaM aGrfPaM(*pGrfNode);
+                    Graphic aGraphic( xGraphic );
+                    pFmt->GetDoc()->ReRead( aGrfPaM, String(), String(), &aGraphic, 0 );
+                }
+            }
+        }
         else if( FN_UNO_REPLACEMENT_GRAPHIC_URL == pCur->nWID )
 		{
 			GraphicObject *pGrfObj = 0;
@@ -1466,7 +1505,7 @@
 				0L);
 
 			aSet.SetParent(&pFmt->GetAttrSet());
-			aPropSet.setPropertyValue(*pCur, aValue, aSet);
+			m_aPropSet.setPropertyValue(*pCur, aValue, aSet);
             if(RES_ANCHOR == pCur->nWID && MID_ANCHOR_ANCHORTYPE == pCur->nMemberId)
             {
                 SwFmtAnchor aAnchor = (const SwFmtAnchor&)aSet.Get(pCur->nWID);
@@ -1530,7 +1569,7 @@
 	}
 	else if(IsDescriptor())
 	{
-        pProps->SetProperty(pCur->nWID, pCur->nMemberId, aValue);
+        m_pProps->SetProperty(pCur->nWID, pCur->nMemberId, aValue);
         if( FN_UNO_FRAME_STYLE_NAME == pCur->nWID )
         {
             OUString sStyleName;
@@ -1563,7 +1602,7 @@
 	vos::OGuard aGuard(Application::GetSolarMutex());
 	uno::Any aAny;
 	SwFrmFmt* pFmt = GetFrmFmt();
-    const SfxItemPropertyMap* pCur = SfxItemPropertyMap::GetByName(_pMap, rPropertyName);
+    const SfxItemPropertyMap* pCur = SfxItemPropertyMap::GetByName(m_pMap, rPropertyName);
     if (!pCur)
         throw beans::UnknownPropertyException(OUString ( RTL_CONSTASCII_USTRINGPARAM ( "Unknown property: " ) ) + rPropertyName, static_cast < cppu::OWeakObject * > ( this ) );
 
@@ -1580,7 +1619,7 @@
 	}
 	else if(pFmt)
 	{
-        if( ((eType == FLYCNTTYPE_GRF) || (eType == FLYCNTTYPE_OLE)) &&
+        if( ((m_eType == FLYCNTTYPE_GRF) || (m_eType == FLYCNTTYPE_OLE)) &&
 				pCur &&
 				((pCur->nWID >=  RES_GRFATR_BEGIN &&
 					pCur->nWID < RES_GRFATR_END )||
@@ -1628,7 +1667,7 @@
 				else
 				{
 					SfxItemSet aSet(pNoTxt->GetSwAttrSet());
-					aAny = aPropSet.getPropertyValue(*pCur, aSet);
+					aAny = m_aPropSet.getPropertyValue(*pCur, aSet);
 				}
 			}
 		}
@@ -1663,11 +1702,23 @@
 			pFmt->GetDoc()->GetGrfNms( *(SwFlyFrmFmt*)pFmt, 0, &sFltName );
 				aAny <<= OUString(sFltName);
 		}
+        else if( FN_UNO_GRAPHIC == pCur->nWID )
+        {
+            const SwNodeIndex* pIdx = pFmt->GetCntnt().GetCntntIdx();
+            if(pIdx)
+            {
+                SwNodeIndex aIdx(*pIdx, 1);
+                SwGrfNode* pGrfNode = aIdx.GetNode().GetGrfNode();
+                if(!pGrfNode)
+                    throw uno::RuntimeException();
+                aAny <<= pGrfNode->GetGrf().GetXGraphic();
+            }
+        }
         else if(FN_UNO_FRAME_STYLE_NAME == pCur->nWID)
 		{
 			aAny <<= OUString(SwStyleNameMapper::GetProgName(pFmt->DerivedFrom()->GetName(), GET_POOLID_FRMFMT ) );
 		}
-		else if(eType == FLYCNTTYPE_GRF &&
+		else if(m_eType == FLYCNTTYPE_GRF &&
 				(rPropertyName.equalsAsciiL( SW_PROP_NAME(UNO_NAME_ACTUAL_SIZE)) ||
                     FN_UNO_ALTERNATIVE_TEXT == pCur->nWID))
 		{
@@ -1736,7 +1787,7 @@
 		else if(WID_LAYOUT_SIZE == pCur->nWID)
 		{
             // format document completely in order to get correct value
-            mpDoc->GetEditShell()->CalcLayout();
+            m_pDoc->GetEditShell()->CalcLayout();
 
             SwClientIter aIter( *pFmt );
             SwClient* pC = aIter.First( TYPE( SwFrm ) );
@@ -1754,18 +1805,18 @@
 		else
 		{
 			const SwAttrSet& rSet = pFmt->GetAttrSet();
-			aAny = aPropSet.getPropertyValue(*pCur, rSet);
+			aAny = m_aPropSet.getPropertyValue(*pCur, rSet);
 		}
 	}
 	else if(IsDescriptor())
 	{
-		if ( ! mpDoc )
+        if ( !m_pDoc )
 			throw uno::RuntimeException();
 		if(WID_LAYOUT_SIZE != pCur->nWID)	// there is no LayoutSize in a descriptor
 		{
 			uno::Any* pAny = 0;
-			if( !pProps->GetProperty( pCur->nWID, pCur->nMemberId, pAny ) )
-				pProps->GetProperty( rPropertyName, mxStyleData, aAny );
+			if( !m_pProps->GetProperty( pCur->nWID, pCur->nMemberId, pAny ) )
+				m_pProps->GetProperty( rPropertyName, mxStyleData, aAny );
 			else if ( pAny )
 				aAny = *pAny;
 		}
@@ -1777,8 +1828,8 @@
 /*-- 11.12.98 15:05:04---------------------------------------------------
 
   -----------------------------------------------------------------------*/
-void SwXFrame::addPropertyChangeListener(const OUString& PropertyName,
-	const uno::Reference< beans::XPropertyChangeListener > & aListener)
+void SwXFrame::addPropertyChangeListener(const OUString& /*PropertyName*/,
+    const uno::Reference< beans::XPropertyChangeListener > & /*aListener*/)
 	throw( beans::UnknownPropertyException, lang::WrappedTargetException, uno::RuntimeException )
 {
 	DBG_WARNING("not implemented")
@@ -1786,8 +1837,8 @@
 /*-- 11.12.98 15:05:05---------------------------------------------------
 
   -----------------------------------------------------------------------*/
-void SwXFrame::removePropertyChangeListener(const OUString& PropertyName,
-	const uno::Reference< beans::XPropertyChangeListener > & aListener)
+void SwXFrame::removePropertyChangeListener(const OUString& /*PropertyName*/,
+    const uno::Reference< beans::XPropertyChangeListener > & /*aListener*/)
 	throw( beans::UnknownPropertyException, lang::WrappedTargetException, uno::RuntimeException )
 {
 	DBG_WARNING("not implemented")
@@ -1795,8 +1846,8 @@
 /*-- 11.12.98 15:05:05---------------------------------------------------
 
   -----------------------------------------------------------------------*/
-void SwXFrame::addVetoableChangeListener(const OUString& PropertyName,
-								const uno::Reference< beans::XVetoableChangeListener > & aListener)
+void SwXFrame::addVetoableChangeListener(const OUString& /*PropertyName*/,
+                                const uno::Reference< beans::XVetoableChangeListener > & /*aListener*/)
 	throw( beans::UnknownPropertyException, lang::WrappedTargetException, uno::RuntimeException )
 {
 	DBG_WARNING("not implemented")
@@ -1805,7 +1856,7 @@
 
   -----------------------------------------------------------------------*/
 void SwXFrame::removeVetoableChangeListener(
-	const OUString& PropertyName, const uno::Reference< beans::XVetoableChangeListener > & aListener)
+    const OUString& /*PropertyName*/, const uno::Reference< beans::XVetoableChangeListener > & /*aListener*/)
 		throw( beans::UnknownPropertyException, lang::WrappedTargetException, uno::RuntimeException )
 {
 	DBG_WARNING("not implemented")
@@ -1840,7 +1891,7 @@
 		const SwAttrSet& rFmtSet = pFmt->GetAttrSet();
 		for(int i = 0; i < aPropertyNames.getLength(); i++)
 		{
-			const SfxItemPropertyMap* pCur = SfxItemPropertyMap::GetByName(_pMap, pNames[i]);
+			const SfxItemPropertyMap* pCur = SfxItemPropertyMap::GetByName(m_pMap, pNames[i]);
 			if (!pCur)
 				throw beans::UnknownPropertyException(OUString ( RTL_CONSTASCII_USTRINGPARAM ( "Unknown property: " ) ) + pNames[i], static_cast < cppu::OWeakObject * > ( this ) );
 
@@ -1854,7 +1905,7 @@
 				pStates[i] = beans::PropertyState_DIRECT_VALUE;
 			else
 			{
-				if(eType == FLYCNTTYPE_GRF &&
+				if(m_eType == FLYCNTTYPE_GRF &&
 						pCur &&
 						(pCur->nWID >= RES_GRFATR_BEGIN &&
 							pCur->nWID <= RES_GRFATR_END))
@@ -1899,8 +1950,7 @@
 	SwFrmFmt* pFmt = GetFrmFmt();
 	if(pFmt)
 	{
-		const SwAttrSet& rFmtSet = pFmt->GetAttrSet();
-		const SfxItemPropertyMap* pCur = SfxItemPropertyMap::GetByName(_pMap, rPropertyName);
+		const SfxItemPropertyMap* pCur = SfxItemPropertyMap::GetByName(m_pMap, rPropertyName);
 		if (!pCur)
 			throw beans::UnknownPropertyException(OUString ( RTL_CONSTASCII_USTRINGPARAM ( "Unknown property: " ) ) + rPropertyName, static_cast < cppu::OWeakObject * > ( this ) );
 		if ( pCur->nFlags & beans::PropertyAttribute::READONLY)
@@ -1911,7 +1961,7 @@
 			pCur->nWID != FN_UNO_ANCHOR_TYPES &&
 			pCur->nWID != FN_PARAM_LINK_DISPLAY_NAME)
 		{
-			if(	eType == FLYCNTTYPE_GRF &&
+			if(	m_eType == FLYCNTTYPE_GRF &&
                         (FN_UNO_ALTERNATIVE_TEXT == pCur->nWID||
 						(pCur->nWID >= RES_GRFATR_BEGIN &&
                             pCur->nWID < RES_GRFATR_END)))
@@ -1972,7 +2022,7 @@
 	SwFrmFmt* pFmt = GetFrmFmt();
 	if(pFmt)
 	{
-		const SfxItemPropertyMap* pCur = SfxItemPropertyMap::GetByName(_pMap, rPropertyName);
+		const SfxItemPropertyMap* pCur = SfxItemPropertyMap::GetByName(m_pMap, rPropertyName);
 		if(pCur)
 		{
 			if ( pCur->nWID < RES_FRMATR_END )
@@ -1996,14 +2046,14 @@
 {
 	if(!GetRegisteredIn())
 		throw uno::RuntimeException();
-	aLstnrCntnr.AddListener(aListener);
+    m_aLstnrCntnr.AddListener(aListener);
 }
 /* -----------------22.04.99 14:59-------------------
  *
  * --------------------------------------------------*/
 void SwXFrame::removeEventListener(const uno::Reference< lang::XEventListener > & aListener) throw( uno::RuntimeException )
 {
-	if(!GetRegisteredIn() || !aLstnrCntnr.RemoveListener(aListener))
+    if(!GetRegisteredIn() || !m_aLstnrCntnr.RemoveListener(aListener))
 		throw uno::RuntimeException();
 }
 /*-- 11.12.98 15:05:06---------------------------------------------------
@@ -2016,8 +2066,8 @@
 	{
 		mxStyleData.clear();
 		mxStyleFamily.clear();
-		mpDoc = 0;
-		aLstnrCntnr.Disposing();
+		m_pDoc = 0;
+		m_aLstnrCntnr.Disposing();
 	}
 }
 
@@ -2081,10 +2131,10 @@
  * --------------------------------------------------*/
 void SwXFrame::ResetDescriptor()
 {
-	bIsDescriptor = sal_False;
+	m_bIsDescriptor = sal_False;
 	mxStyleData.clear();
 	mxStyleFamily.clear();
-	DELETEZ(pProps);
+	DELETEZ(m_pProps);
 }
 /* -----------------18.02.99 13:34-------------------
  *
@@ -2133,7 +2183,7 @@
 		SfxItemSet aFrmSet(pDoc->GetAttrPool(), aFrmAttrRange );
 		//jetzt muessen die passenden Items in den Set
         sal_Bool bSizeFound;
-        if(!pProps->AnyToItemSet( pDoc, aFrmSet, aGrSet, bSizeFound))
+        if(!m_pProps->AnyToItemSet( pDoc, aFrmSet, aGrSet, bSizeFound))
 			throw lang::IllegalArgumentException();
 		//der TextRange wird einzeln behandelt
 		*aPam.GetPoint() = *aIntPam.GetPoint();
@@ -2144,16 +2194,18 @@
 		}
 
 		const SfxPoolItem* pItem;
+        RndStdIds eAnchorId = FLY_AT_CNTNT;
 		if(SFX_ITEM_SET == aFrmSet.GetItemState(RES_ANCHOR, sal_False, &pItem) )
 		{
-			if( FLY_AT_FLY ==((const SwFmtAnchor*)pItem)->GetAnchorId() &&
+            eAnchorId = ((const SwFmtAnchor*)pItem)->GetAnchorId();
+            if( FLY_AT_FLY == eAnchorId &&
 				!aPam.GetNode()->FindFlyStartNode())
 			{
 				//rahmengebunden geht nur dort, wo ein Rahmen ist!
 				SwFmtAnchor aAnchor(FLY_AT_CNTNT);
 				aFrmSet.Put(aAnchor);
 			}
-			else if( FLY_PAGE ==((const SwFmtAnchor*)pItem)->GetAnchorId() &&
+            else if( FLY_PAGE == eAnchorId &&
 					 0 == ((const SwFmtAnchor*)pItem)->GetPageNum() )
 			{
 				SwFmtAnchor aAnchor( *((const SwFmtAnchor*)pItem) );
@@ -2164,31 +2216,57 @@
 
 		uno::Any* pStyle;
 		SwFrmFmt *pParentFrmFmt = 0;
-        if(pProps->GetProperty(FN_UNO_FRAME_STYLE_NAME, 0, pStyle))
+        if(m_pProps->GetProperty(FN_UNO_FRAME_STYLE_NAME, 0, pStyle))
 			pParentFrmFmt = lcl_GetFrmFmt( *pStyle, pDoc );
 
 		SwFlyFrmFmt* pFmt = 0;
-		if( eType == FLYCNTTYPE_FRM)
+		if( m_eType == FLYCNTTYPE_FRM)
 		{
 			UnoActionContext aCont(pDoc);
-			pFmt = pDoc->MakeFlySection( FLY_AT_CNTNT, aPam.GetPoint(),
+            if(m_pCopySource)
+            {
+                SwFmtAnchor* pAnchorItem = 0;
+                // the frame is inserted bound to page
+                // to prevent conflicts if the to-be-anchored position is part of the to-be-copied text
+                if(eAnchorId != FLY_PAGE)
+                {
+                    pAnchorItem = static_cast<SwFmtAnchor*>(aFrmSet.Get(RES_ANCHOR).Clone());
+                    aFrmSet.Put( SwFmtAnchor( FLY_PAGE, 1 ));
+                }
+
+                pFmt = pDoc->MakeFlyAndMove( *m_pCopySource, aFrmSet,
+								0,
+								pParentFrmFmt );
+                if(pAnchorItem && pFmt)
+                {
+                    pFmt->DelFrms();
+                    pAnchorItem->SetAnchor( m_pCopySource->Start() );
+                    SfxItemSet aAnchorSet( pDoc->GetAttrPool(), RES_ANCHOR, RES_ANCHOR );
+                    aAnchorSet.Put( *pAnchorItem );
+                    pDoc->SetFlyFrmAttr( *pFmt, aAnchorSet );
+                    delete pAnchorItem;
+                }
+                DELETEZ( m_pCopySource );
+            }
+            else
+                pFmt = pDoc->MakeFlySection( FLY_AT_CNTNT, aPam.GetPoint(),
 										 &aFrmSet, pParentFrmFmt );
 			if(pFmt)
 			{
 				pFmt->Add(this);
-				if(sName.Len())
-					pDoc->SetFlyName((SwFlyFrmFmt&)*pFmt, sName);
+				if(m_sName.Len())
+					pDoc->SetFlyName((SwFlyFrmFmt&)*pFmt, m_sName);
 			}
 			//den SwXText wecken
-			((SwXTextFrame*)this)->SetDoc( bIsDescriptor ? mpDoc : GetFrmFmt()->GetDoc() );
+			((SwXTextFrame*)this)->SetDoc( m_bIsDescriptor ? m_pDoc : GetFrmFmt()->GetDoc() );
 		}
-		else if( eType == FLYCNTTYPE_GRF)
+		else if( m_eType == FLYCNTTYPE_GRF)
 		{
 			UnoActionContext aCont(pDoc);
 			uno::Any* pGraphicURL;
 			String sGraphicURL;
 			GraphicObject *pGrfObj = 0;
-            if(pProps->GetProperty(FN_UNO_GRAPHIC_U_R_L, 0, pGraphicURL))
+            if(m_pProps->GetProperty(FN_UNO_GRAPHIC_U_R_L, 0, pGraphicURL))
 			{
 				OUString uTemp;
 				(*pGraphicURL) >>= uTemp;
@@ -2210,10 +2288,18 @@
 					sGraphicURL.Erase();
 				}
 			}
+            Graphic aGraphic;
+            uno::Any* pGraphic;
+            if( m_pProps->GetProperty( FN_UNO_GRAPHIC, 0, pGraphic ))
+            {
+                uno::Reference< graphic::XGraphic > xGraphic;
+                (*pGraphic) >>= xGraphic;
+                aGraphic = Graphic( xGraphic );
+            }
 
 			String sFltName;
 			uno::Any* pFilter;
-            if(pProps->GetProperty(FN_UNO_GRAPHIC_FILTER, 0, pFilter))
+            if(m_pProps->GetProperty(FN_UNO_GRAPHIC_FILTER, 0, pFilter))
 			{
 				OUString uTemp;
 				(*pFilter) >>= uTemp;
@@ -2223,7 +2309,7 @@
 			pFmt =
 				pGrfObj ? pDoc->Insert( aPam, *pGrfObj, &aFrmSet, &aGrSet,
 										pParentFrmFmt )
-				 		: pDoc->Insert( aPam, sGraphicURL, sFltName, 0,
+                        : pDoc->Insert( aPam, sGraphicURL, sFltName, &aGraphic,
 										&aFrmSet, &aGrSet, pParentFrmFmt  );
             delete pGrfObj;
 			if(pFmt)
@@ -2232,33 +2318,33 @@
                                             ->GetIndex()+1 ]->GetGrfNode();
                 pGrfNd->SetChgTwipSize( !bSizeFound );
                 pFmt->Add(this);
-				if(sName.Len())
-					pDoc->SetFlyName((SwFlyFrmFmt&)*pFmt, sName);
+				if(m_sName.Len())
+					pDoc->SetFlyName((SwFlyFrmFmt&)*pFmt, m_sName);
 
 			}
 			uno::Any* pSurroundContour;
-            if(pProps->GetProperty(RES_SURROUND, MID_SURROUND_CONTOUR, pSurroundContour))
+            if(m_pProps->GetProperty(RES_SURROUND, MID_SURROUND_CONTOUR, pSurroundContour))
 				setPropertyValue(C2U(SW_PROP_NAME_STR(UNO_NAME_SURROUND_CONTOUR)), *pSurroundContour);
 			uno::Any* pContourOutside;
-            if(pProps->GetProperty(RES_SURROUND, MID_SURROUND_CONTOUROUTSIDE, pContourOutside))
+            if(m_pProps->GetProperty(RES_SURROUND, MID_SURROUND_CONTOUROUTSIDE, pContourOutside))
 				setPropertyValue(C2U(SW_PROP_NAME_STR(UNO_NAME_CONTOUR_OUTSIDE)), *pContourOutside);
 			uno::Any* pContourPoly;
-            if(pProps->GetProperty(FN_PARAM_COUNTOUR_PP, 0, pContourPoly))
+            if(m_pProps->GetProperty(FN_PARAM_COUNTOUR_PP, 0, pContourPoly))
 				setPropertyValue(C2U(SW_PROP_NAME_STR(UNO_NAME_CONTOUR_POLY_POLYGON)), *pContourPoly);
 			uno::Any* pPixelContour;
-            if(pProps->GetProperty(FN_UNO_IS_PIXEL_CONTOUR, 0, pPixelContour))
+            if(m_pProps->GetProperty(FN_UNO_IS_PIXEL_CONTOUR, 0, pPixelContour))
 				setPropertyValue(C2U(SW_PROP_NAME_STR(UNO_NAME_IS_PIXEL_CONTOUR)), *pPixelContour);
 			uno::Any* pAutoContour;
-            if(pProps->GetProperty(FN_UNO_IS_AUTOMATIC_CONTOUR, 0, pAutoContour))
+            if(m_pProps->GetProperty(FN_UNO_IS_AUTOMATIC_CONTOUR, 0, pAutoContour))
 				setPropertyValue(C2U(SW_PROP_NAME_STR(UNO_NAME_IS_AUTOMATIC_CONTOUR)), *pAutoContour);
 			uno::Any* pAltText;
-            if(pProps->GetProperty(FN_UNO_ALTERNATIVE_TEXT, 0, pAltText))
+            if(m_pProps->GetProperty(FN_UNO_ALTERNATIVE_TEXT, 0, pAltText))
 				setPropertyValue(C2U(SW_PROP_NAME_STR(UNO_NAME_ALTERNATIVE_TEXT)), *pAltText);
 		}
 		else
 		{
             uno::Any* pCLSID;
-            if(!pProps->GetProperty(FN_UNO_CLSID, 0, pCLSID))
+            if(!m_pProps->GetProperty(FN_UNO_CLSID, 0, pCLSID))
                 throw uno::RuntimeException();
             OUString aCLSID;
             SvGlobalName aClassName;
@@ -2266,7 +2352,6 @@
             std::auto_ptr < comphelper::EmbeddedObjectContainer > pCnt;
             if( (*pCLSID) >>= aCLSID )
             {
-                sal_Bool bInternal = sal_True;
 				if( !aClassName.MakeId( aCLSID ) )
                 {
                     lang::IllegalArgumentException aExcept;
@@ -2333,15 +2418,15 @@
 
                 pDoc->EndUndo(UNDO_INSERT, NULL);
                 pFmt->Add(this);
-                if(sName.Len())
-                    pDoc->SetFlyName((SwFlyFrmFmt&)*pFmt, sName);
+                if(m_sName.Len())
+                    pDoc->SetFlyName((SwFlyFrmFmt&)*pFmt, m_sName);
             }
         }
 
 		if( pFmt && pDoc->GetDrawModel() )
 			GetOrCreateSdrObject( pFmt );
 		uno::Any* pOrder;
-        if( pProps->GetProperty(FN_UNO_Z_ORDER, 0, pOrder) )
+        if( m_pProps->GetProperty(FN_UNO_Z_ORDER, 0, pOrder) )
 			setPropertyValue(C2U(SW_PROP_NAME_STR(UNO_NAME_Z_ORDER)), *pOrder);
 	}
 	else
@@ -2400,7 +2485,7 @@
 /*-- 22.04.99 08:03:21---------------------------------------------------
 
   -----------------------------------------------------------------------*/
-void SwXFrame::setPosition(const awt::Point& aPosition) throw( uno::RuntimeException )
+void SwXFrame::setPosition(const awt::Point& /*aPosition*/) throw( uno::RuntimeException )
 {
 	vos::OGuard aGuard(Application::GetSolarMutex());
 	uno::RuntimeException aRuntime;
@@ -2597,12 +2682,6 @@
 
         SwXTextCursor* pXCrsr = new SwXTextCursor(this, *aPam.GetPoint(), CURSOR_FRAME, pFmt->GetDoc());
 		aRef =  (text::XWordCursor*)pXCrsr;
-		SwUnoCrsr*	pUnoCrsr = pXCrsr->GetCrsr();
-//		// no Cursor in protected sections
-//		SwCrsrSaveState aSave( *pUnoCrsr );
-//		if(pUnoCrsr->IsInProtectTable( sal_True ) ||
-//			pUnoCrsr->IsSelOvr( SELOVER_TOGGLE | SELOVER_CHANGEPOS ))
-//			throw  uno::RuntimeException() );
 	}
 	else
 		throw uno::RuntimeException();
@@ -2640,7 +2719,6 @@
 	vos::OGuard aGuard(Application::GetSolarMutex());
 	uno::Reference< container::XEnumeration >  aRef;
 	SwFrmFmt* pFmt = GetFrmFmt();
- uno::XInterface* pRet = 0;
 	if(pFmt)
 	{
 		SwPosition aPos(pFmt->GetCntnt().GetCntntIdx()->GetNode());
@@ -3296,7 +3374,7 @@
 SwXOLEListener::~SwXOLEListener()
 {}
 
-void SwXOLEListener::modified( const lang::EventObject& rEvent )
+void SwXOLEListener::modified( const lang::EventObject& /*rEvent*/ )
 										throw( uno::RuntimeException )
 {
 	vos::OGuard aGuard(Application::GetSolarMutex());
--- sw/source/core/unocore/unoftn.cxx	5 Jun 2007 17:33:36 -0000	1.25
+++ sw/source/core/unocore/unoftn.cxx	12 Jul 2007 14:08:56 -0000
@@ -326,8 +326,11 @@
 	if(pFmt)
 	{
 		const SwTxtFtn* pTxtFtn = pFmt->GetTxtFtn();
-        SwPosition aPos( pTxtFtn->GetTxtNode() );
-		aRef = SwXTextRange::CreateTextRangeFromPosition((SwDoc*)GetDoc(), aPos, 0);
+        SwPaM aPam( pTxtFtn->GetTxtNode(), *pTxtFtn->GetStart() );
+        SwPosition aMark( *aPam.Start() );
+        aPam.SetMark();
+        aPam.GetMark()->nContent++;
+        aRef = SwXTextRange::CreateTextRangeFromPosition((SwDoc*)GetDoc(), *aPam.Start(), aPam.End());
 	}
 	else
 		throw uno::RuntimeException();
--- sw/source/core/unocore/unomap.cxx	22 May 2007 16:34:29 -0000	1.198
+++ sw/source/core/unocore/unomap.cxx	12 Jul 2007 14:09:00 -0000
@@ -1020,6 +1020,7 @@
                     { SW_PROP_NMID(UNO_NAME_PAGE_DESC_NAME), RES_PAGEDESC,           CPPU_E2T(CPPUTYPE_OUSTRING),         PropertyAttribute::MAYBEVOID, 0xff},
 					{ SW_PROP_NMID(UNO_NAME_RELATIVE_WIDTH), FN_TABLE_RELATIVE_WIDTH,CPPU_E2T(CPPUTYPE_INT16)  ,  		PROPERTY_NONE, 0xff	},
 					{ SW_PROP_NMID(UNO_NAME_REPEAT_HEADLINE), FN_TABLE_HEADLINE_REPEAT,CPPU_E2T(CPPUTYPE_BOOLEAN), 		PROPERTY_NONE, 0xff},
+                    { SW_PROP_NMID(UNO_NAME_HEADER_ROW_COUNT), FN_TABLE_HEADLINE_COUNT,  CPPU_E2T(CPPUTYPE_INT32),      PROPERTY_NONE, 0xff},
 					{ SW_PROP_NMID(UNO_NAME_SHADOW_FORMAT), RES_SHADOW, 			CPPU_E2T(CPPUTYPE_SHADOWFMT), 	PROPERTY_NONE, 0},
 					{ SW_PROP_NMID(UNO_NAME_TOP_MARGIN), RES_UL_SPACE, 			CPPU_E2T(CPPUTYPE_INT32), PROPERTY_NONE, MID_UP_MARGIN|CONVERT_TWIPS},
 					{ SW_PROP_NMID(UNO_NAME_BOTTOM_MARGIN), RES_UL_SPACE, 			CPPU_E2T(CPPUTYPE_INT32), PROPERTY_NONE, MID_LO_MARGIN|CONVERT_TWIPS},
@@ -1224,6 +1225,7 @@
 					{ SW_PROP_NMID(UNO_NAME_VERT_MIRRORED), RES_GRFATR_MIRRORGRF,   CPPU_E2T(CPPUTYPE_BOOLEAN), 			PROPERTY_NONE,     MID_MIRROR_VERT			  },
                     { SW_PROP_NMID(UNO_NAME_GRAPHIC_URL), FN_UNO_GRAPHIC_U_R_L, CPPU_E2T(CPPUTYPE_OUSTRING), 0, 0 },
                     { SW_PROP_NMID(UNO_NAME_GRAPHIC_FILTER), FN_UNO_GRAPHIC_FILTER,      CPPU_E2T(CPPUTYPE_OUSTRING), 0, 0 },
+                    { SW_PROP_NMID(UNO_NAME_GRAPHIC), FN_UNO_GRAPHIC, CPPU_E2T(CPPUTYPE_REFXGRAPHIC), 0, 0 },
                     { SW_PROP_NMID(UNO_NAME_ACTUAL_SIZE), FN_UNO_ACTUAL_SIZE,    CPPU_E2T(CPPUTYPE_AWTSIZE),  PropertyAttribute::READONLY, CONVERT_TWIPS},
                     { SW_PROP_NMID(UNO_NAME_ALTERNATIVE_TEXT), FN_UNO_ALTERNATIVE_TEXT,CPPU_E2T(CPPUTYPE_OUSTRING),   PROPERTY_NONE , 0   },
 					{ SW_PROP_NMID(UNO_NAME_CONTOUR_POLY_POLYGON), FN_PARAM_COUNTOUR_PP, CPPU_E2T(CPPUTYPE_PNTSEQSEQ), PropertyAttribute::MAYBEVOID, 0 },
@@ -1872,7 +1874,9 @@
 					{SW_PROP_NMID(UNO_NAME_NUMBER_FORMAT),		FIELD_PROP_FORMAT,	CPPU_E2T(CPPUTYPE_INT32), PROPERTY_NONE,	0},
 					{SW_PROP_NMID(UNO_NAME_NUMBERING_TYPE), 	FIELD_PROP_USHORT2, CPPU_E2T(CPPUTYPE_INT16), PROPERTY_NONE,	0},
 					{SW_PROP_NMID(UNO_NAME_IS_INPUT), 		FIELD_PROP_BOOL1, 	CPPU_E2T(CPPUTYPE_BOOLEAN),	PROPERTY_NONE, 0},
-					{SW_PROP_NMID(UNO_NAME_IS_SHOW_FORMULA), FIELD_PROP_BOOL3,	CPPU_E2T(CPPUTYPE_BOOLEAN), PROPERTY_NONE,	0},
+                    // wrong name - UNO_NAME_IS_INPUT expanded to "Input" instead of "IsInput"
+                    {SW_PROP_NMID(UNO_NAME_INPUT),          FIELD_PROP_BOOL1,   CPPU_E2T(CPPUTYPE_BOOLEAN), PROPERTY_NONE, 0},
+                    {SW_PROP_NMID(UNO_NAME_IS_SHOW_FORMULA), FIELD_PROP_BOOL3,  CPPU_E2T(CPPUTYPE_BOOLEAN), PROPERTY_NONE,  0},
 					{SW_PROP_NMID(UNO_NAME_IS_VISIBLE),       FIELD_PROP_BOOL2,   CPPU_E2T(CPPUTYPE_BOOLEAN),    PROPERTY_NONE, 0},
 					//TODO: UNO_NAME_VARIABLE_NAME gibt es das wirklich?
 					{SW_PROP_NMID(UNO_NAME_SEQUENCE_VALUE),	FIELD_PROP_USHORT1, CPPU_E2T(CPPUTYPE_INT16), 	PROPERTY_NONE,	0},
@@ -2434,6 +2438,7 @@
                     // them as DataSource and it does not matter which one it is.
 
                     {SW_PROP_NMID(UNO_NAME_DATA_BASE_NAME ) ,  FIELD_PROP_PAR1, CPPU_E2T(CPPUTYPE_OUSTRING),   PROPERTY_NONE, 0},
+                    {SW_PROP_NMID(UNO_NAME_NAME),              FIELD_PROP_PAR3,  CPPU_E2T(CPPUTYPE_OUSTRING), PropertyAttribute::MAYBEVOID, 0},
                     {SW_PROP_NMID(UNO_NAME_DATA_TABLE_NAME  ), FIELD_PROP_PAR2, CPPU_E2T(CPPUTYPE_OUSTRING),   PROPERTY_NONE, 0},
                     {SW_PROP_NMID(UNO_NAME_DATA_COLUMN_NAME ), FIELD_PROP_PAR3, CPPU_E2T(CPPUTYPE_OUSTRING),   PROPERTY_NONE, 0},
                     {SW_PROP_NMID(UNO_NAME_INSTANCE_NAME),     FIELD_PROP_PAR4, CPPU_E2T(CPPUTYPE_OUSTRING), PropertyAttribute::READONLY, 0},
--- sw/source/core/unocore/unoobj2.cxx	5 Jun 2007 17:34:13 -0000	1.59
+++ sw/source/core/unocore/unoobj2.cxx	12 Jul 2007 14:09:03 -0000
@@ -971,9 +971,10 @@
   -----------------------------------------------------------------------*/
 void SwXTextCursor::SetCrsrAttr(SwPaM& rPam, const SfxItemSet& rSet, USHORT nAttrMode)
 {
-	sal_uInt16 nFlags = SETATTR_APICALL;
+	sal_uInt16 nFlags = SETATTR_APICALL | (nAttrMode & SETATTR_NOFORMATATTR);
     if(nAttrMode & CRSR_ATTR_MODE_DONTREPLACE)
         nFlags |= SETATTR_DONTREPLACE;
+    
 	SwDoc* pDoc = rPam.GetDoc();
 	//StartEndAction
 	UnoActionContext aAction(pDoc);
--- sw/source/core/unocore/unoprnms.cxx	22 May 2007 16:34:48 -0000	1.129
+++ sw/source/core/unocore/unoprnms.cxx	12 Jul 2007 14:09:03 -0000
@@ -329,7 +329,7 @@
 /* 0273 HYPER_LINK_EVENTS */			{MAP_CHAR_LEN("HyperLinkEvents")},
 /* 0274 INFO_TYPE */					{MAP_CHAR_LEN("InfoType")},
 /* 0275 INFO_FORMAT */					{MAP_CHAR_LEN("InfoFormat")},
-/* 0276 IS_INPUT */						{MAP_CHAR_LEN("Input")},
+/* 0276 IS_INPUT */                     {MAP_CHAR_LEN("IsInput")},
 /* 0277 LEVEL */						{MAP_CHAR_LEN("Level")},
 /* 0278 INTERVAL */						{MAP_CHAR_LEN("Interval")},
 /* 0279 LINK_REGION */					{MAP_CHAR_LEN("LinkRegion")},
@@ -761,15 +761,17 @@
 /* 0703 UNO_NAME_PARA_STYLE_CONDITIONS*/    {MAP_CHAR_LEN("ParaStyleConditions")},
 /* 0704 UNO_NAME_PRINT_EMPTY_PAGES*/    {MAP_CHAR_LEN("PrintEmptyPages")},
 /* 0705 UNO_NAME_ROLE */                {MAP_CHAR_LEN("Role")},
-/* 0706 UNO_NAME_FIELD_CODE*/           {MAP_CHAR_LEN("FieldCode")},
-/* 0707 UNO_NAME_HAS_VALID_SIGNATURES*/ {MAP_CHAR_LEN("HasValidSignatures")},
-/* 0708 UNO_CHAR_AUTO_STYLE_NAME */     {MAP_CHAR_LEN("CharAutoStyleName")},
-/* 0709 UNO_PARA_AUTO_STYLE_NAME */     {MAP_CHAR_LEN("ParaAutoStyleName")},
-/* 0710 UNO_NAME_APPLY_WORKAROUND_FOR_B6375613*/ {MAP_CHAR_LEN("ApplyWorkaroundForB6375613")},
-/* 0711 UNO_NAME_LAYOUT_SIZE*/ {MAP_CHAR_LEN("LayoutSize")},
+/* 0705 UNO_NAME_FIELD_CODE*/           {MAP_CHAR_LEN("FieldCode")},
+/* 0706 UNO_NAME_HAS_VALID_SIGNATURES*/ {MAP_CHAR_LEN("HasValidSignatures")},
+/* 0707 UNO_CHAR_AUTO_STYLE_NAME */     {MAP_CHAR_LEN("CharAutoStyleName")},
+/* 0708 UNO_PARA_AUTO_STYLE_NAME */     {MAP_CHAR_LEN("ParaAutoStyleName")},
+/* 0709 UNO_NAME_APPLY_WORKAROUND_FOR_B6375613*/ {MAP_CHAR_LEN("ApplyWorkaroundForB6375613")},
+/* 0710 UNO_NAME_LAYOUT_SIZE*/ {MAP_CHAR_LEN("LayoutSize")},
+/* 0711 UNO_NAME_INPUT */                {MAP_CHAR_LEN("Input")},
 /* 0712 UNO_NAME_HELP */ {MAP_CHAR_LEN("Help")},
 /* 0713 UNO_NAME_TOOLTIP */ {MAP_CHAR_LEN("Tooltip")},
-/* 0714 UNO_NAME_DIALOG_LIBRARIES*/     {MAP_CHAR_LEN("DialogLibraries")}
+/* 0714 UNO_NAME_DIALOG_LIBRARIES*/     {MAP_CHAR_LEN("DialogLibraries")},
+/* 0715 UNO_NAME_HEADER_ROW_COUNT*/     {MAP_CHAR_LEN("HeaderRowCount")}
 };
 
 const SwPropNameLen& SwGetPropName( USHORT nId )
--- sw/source/core/unocore/unostyle.cxx	5 Jun 2007 17:36:55 -0000	1.72
+++ sw/source/core/unocore/unostyle.cxx	12 Jul 2007 14:09:08 -0000
@@ -1610,6 +1610,8 @@
         if(pBase)
         {
             SwDocStyleSheet aBase(*(SwDocStyleSheet*)pBase);
+            //make it a 'real' style - necessary for pooled styles
+            aBase.GetItemSet();
             if(aBase.GetParent() != sParentStyle)
             {
                 bExcept = !aBase.SetParent(sParentStyle);
--- sw/source/core/unocore/unotbl.cxx	26 Jun 2007 10:43:32 -0000	1.104
+++ sw/source/core/unocore/unotbl.cxx	12 Jul 2007 14:09:12 -0000
@@ -268,13 +268,23 @@
 	switch(pMap->nWID)
 	{
 		case  FN_TABLE_HEADLINE_REPEAT:
-
+        case  FN_TABLE_HEADLINE_COUNT: 
 		{
 			SwTable* pTable = SwTable::FindTable( pFmt );
 			{
 				UnoActionContext aAction(pFmt->GetDoc());
-				sal_Bool bVal = *(sal_Bool*)aValue.getValue();
-                pFmt->GetDoc()->SetRowsToRepeat( *pTable, bVal ? 1 : 0 );  // TODO MULTIHEADER
+                if( pMap->nWID == FN_TABLE_HEADLINE_REPEAT)
+                {
+                    sal_Bool bVal = *(sal_Bool*)aValue.getValue();
+                    pFmt->GetDoc()->SetRowsToRepeat( *pTable, bVal ? 1 : 0 );  // TODO MULTIHEADER
+                }
+                else
+                {
+                    sal_Int32 nRepeat = 0;
+                    aValue >>= nRepeat;
+                    if( nRepeat > 0 && nRepeat < USHRT_MAX )
+                        pFmt->GetDoc()->SetRowsToRepeat( *pTable, (USHORT) nRepeat );
+                }    
 			}
 		}
 		break;
@@ -341,12 +351,19 @@
 	switch(pMap->nWID)
 	{
 		case  FN_TABLE_HEADLINE_REPEAT:
+        case  FN_TABLE_HEADLINE_COUNT: 
 		{
 			SwTable* pTable = SwTable::FindTable( pFmt );
-            BOOL bTemp = pTable->GetRowsToRepeat() > 0;  // TODO MULTIHEADER
-			aRet.setValue(&bTemp, ::getCppuBooleanType());
+            USHORT nRepeat = pTable->GetRowsToRepeat();
+            if(pMap->nWID == FN_TABLE_HEADLINE_REPEAT)
+            {
+                BOOL bTemp = nRepeat > 0;  
+                aRet.setValue(&bTemp, ::getCppuBooleanType());
+            }
+            else
+                aRet <<= (sal_Int32)nRepeat;
 		}
-		break;
+        break;
 		case  FN_TABLE_WIDTH:
 		case  FN_TABLE_IS_RELATIVE_WIDTH:
 		case  FN_TABLE_RELATIVE_WIDTH:
--- sw/source/core/unocore/unotext.cxx	5 Jun 2007 17:37:43 -0000	1.31
+++ sw/source/core/unocore/unotext.cxx	12 Jul 2007 14:09:14 -0000
@@ -83,6 +83,9 @@
 #ifndef _UNOMAP_HXX
 #include <unomap.hxx>
 #endif
+#ifndef _UNDOBJ_HXX
+#include <undobj.hxx>
+#endif
 #ifndef _UNOCRSRHELPER_HXX
 #include <unocrsrhelper.hxx>
 #endif
@@ -110,9 +113,16 @@
 #ifndef _FMTHBSH_HXX //autogen
 #include <fmthbsh.hxx>
 #endif
+#ifndef _FMTANCHR_HXX
+#include <fmtanchr.hxx>
+#endif
 #ifndef _CRSSKIP_HXX
 #include <crsskip.hxx>
 #endif
+#ifndef _NDTXT_HXX
+#include <ndtxt.hxx>
+#endif
+#include <memory>
 
 using namespace ::com::sun::star;
 using namespace ::rtl;
@@ -147,10 +157,10 @@
 
  ---------------------------------------------------------------------------*/
 SwXText::SwXText(SwDoc* pDc, CursorType eType) :
-    pDoc(pDc),
-    bObjectValid(0 != pDc),
-    eCrsrType(eType),
-    _pMap(aSwMapProvider.GetPropertyMap(PROPERTY_MAP_TEXT))
+    m_pDoc(pDc),
+    m_eCrsrType(eType),
+    m_bObjectValid( 0!=pDc ),
+    m_pMap(aSwMapProvider.GetPropertyMap(PROPERTY_MAP_TEXT))
 {
 }
 /*-- 09.12.98 12:43:55---------------------------------------------------
@@ -169,10 +179,17 @@
 	const uno::Type& rXSimpleTextType = ::getCppuType((const uno::Reference< XSimpleText >*)0);
 	const uno::Type& rXTextRangeType = ::getCppuType((uno::Reference< text::XTextRange >*)0);
 	const uno::Type& rXTypeProviderType = ::getCppuType((uno::Reference< lang::XTypeProvider >*)0);
-	const uno::Type& rXTextContentInsert = ::getCppuType((uno::Reference< text::XRelativeTextContentInsert >*)0);
-	const uno::Type& rXTextContentRemove = ::getCppuType((uno::Reference< text::XRelativeTextContentRemove >*)0);
-    const uno::Type& rXPropertySet = ::getCppuType((uno::Reference<beans::XPropertySet>*)0);
+
+    const uno::Type& rXTextContentInsert = ::getCppuType((uno::Reference< text::XRelativeTextContentInsert >*)0);
+    const uno::Type& rXTextContentRemove = ::getCppuType((uno::Reference< text::XRelativeTextContentRemove >*)0);
+    const uno::Type& rXPropertySet = ::getCppuType((uno::Reference< beans::XPropertySet>*)0);
     const uno::Type& rXUnoTunnel = ::getCppuType((uno::Reference< lang::XUnoTunnel >*)0);
+    const uno::Type& rXTextPortionAppend = ::getCppuType((uno::Reference< text::XTextPortionAppend >*)0);
+    const uno::Type& rXParagraphAppend = ::getCppuType((uno::Reference< text::XParagraphAppend >*)0);
+    const uno::Type& rXTextContentAppend = ::getCppuType((uno::Reference< text::XTextContentAppend >*)0);
+    const uno::Type& rXTextConvert = ::getCppuType((uno::Reference< text::XTextConvert >*)0);
+    const uno::Type& rXTextAppend = ::getCppuType((uno::Reference< text::XTextAppend >*)0);
+    const uno::Type& rXTextAppendAndConvert = ::getCppuType((uno::Reference< text::XTextAppendAndConvert >*)0);
 
 	uno::Any aRet;
 	if(rType == rXTextType)
@@ -220,6 +237,36 @@
 		uno::Reference< lang::XUnoTunnel > xRet = this;
 		aRet.setValue(&xRet, rXUnoTunnel);
 	}
+    else if(rType == rXTextAppendAndConvert )
+    {
+        uno::Reference< XTextAppendAndConvert > xRet = this;
+        aRet.setValue(&xRet, rXTextAppendAndConvert);
+    }
+    else if(rType == rXTextAppend )
+    {
+        uno::Reference< XTextAppend > xRet = this;
+        aRet.setValue(&xRet, rXTextAppend);
+    }
+    else if(rType == rXTextPortionAppend )
+    {
+        uno::Reference< XTextPortionAppend > xRet = this;
+        aRet.setValue(&xRet, rXTextPortionAppend);
+    }
+    else if(rType == rXParagraphAppend ) 
+    {
+        uno::Reference< XParagraphAppend > xRet = this;
+        aRet.setValue(&xRet, rXParagraphAppend );
+    }
+    else if(rType == rXTextConvert ) 
+    {
+        uno::Reference< XTextConvert > xRet = this;
+        aRet.setValue(&xRet, rXParagraphAppend );
+    }
+    else if(rType == rXTextContentAppend ) 
+    {
+        uno::Reference< XTextContentAppend > xRet = this;
+        aRet.setValue(&xRet, rXTextContentAppend );
+    }
 	return aRet;
 }
 /* -----------------------------15.03.00 17:42--------------------------------
@@ -227,14 +274,20 @@
  ---------------------------------------------------------------------------*/
 uno::Sequence< uno::Type > SAL_CALL SwXText::getTypes() throw(uno::RuntimeException)
 {
-    uno::Sequence< uno::Type > aRet(6);
+    uno::Sequence< uno::Type > aRet(12);
 	uno::Type* pTypes = aRet.getArray();
-	pTypes[0] = ::getCppuType((uno::Reference< text::XText >*)0);
-	pTypes[1] = ::getCppuType((uno::Reference< text::XTextRangeCompare >*)0);
-	pTypes[2] = ::getCppuType((uno::Reference< text::XRelativeTextContentInsert >*)0);
-	pTypes[3] = ::getCppuType((uno::Reference< text::XRelativeTextContentRemove >*)0);
-	pTypes[4] = ::getCppuType((uno::Reference< lang::XUnoTunnel >*)0);
+    pTypes[0] = ::getCppuType((uno::Reference< text::XText >*)0);
+    pTypes[1] = ::getCppuType((uno::Reference< text::XTextRangeCompare >*)0);
+    pTypes[2] = ::getCppuType((uno::Reference< text::XRelativeTextContentInsert >*)0);
+    pTypes[3] = ::getCppuType((uno::Reference< text::XRelativeTextContentRemove >*)0);
+    pTypes[4] = ::getCppuType((uno::Reference< lang::XUnoTunnel >*)0);
     pTypes[5] = ::getCppuType((uno::Reference< beans::XPropertySet >*)0);
+    pTypes[6] = ::getCppuType((uno::Reference< text::XTextPortionAppend >*)0);
+    pTypes[7] = ::getCppuType((uno::Reference< text::XParagraphAppend >*)0);
+    pTypes[8] = ::getCppuType((uno::Reference< text::XTextContentAppend >*)0);
+    pTypes[9] = ::getCppuType((uno::Reference< text::XTextConvert >*)0);
+    pTypes[10] = ::getCppuType((uno::Reference< text::XTextAppend >*)0);
+    pTypes[11] = ::getCppuType((uno::Reference< text::XTextAppendAndConvert >*)0);
 
 	return aRet;
 }
@@ -337,20 +390,20 @@
 			//Steuerzeichen einfuegen
 			SwPaM aTmp(*aPam.Start());
 			if(bAbsorb && aPam.HasMark())
-				pDoc->DeleteAndJoin(aPam);
+                m_pDoc->DeleteAndJoin(aPam);
 
 			sal_Unicode cIns = 0;
 			switch( nControlCharacter )
 			{
 				case text::ControlCharacter::PARAGRAPH_BREAK :
 					// eine Tabellen Zelle wird jetzt zu einer normalen Textzelle!
-					pDoc->ClearBoxNumAttrs( aTmp.GetPoint()->nNode );
-					pDoc->SplitNode( *aTmp.GetPoint(), sal_False );
+                    m_pDoc->ClearBoxNumAttrs( aTmp.GetPoint()->nNode );
+                    m_pDoc->SplitNode( *aTmp.GetPoint(), sal_False );
 					break;
 				case text::ControlCharacter::APPEND_PARAGRAPH:
 				{
-					pDoc->ClearBoxNumAttrs( aTmp.GetPoint()->nNode );
-					pDoc->AppendTxtNode( *aTmp.GetPoint() );
+                    m_pDoc->ClearBoxNumAttrs( aTmp.GetPoint()->nNode );
+                    m_pDoc->AppendTxtNode( *aTmp.GetPoint() );
 
 					uno::Reference<lang::XUnoTunnel> xRangeTunnel( xTextRange, uno::UNO_QUERY);
 					SwXTextRange* pRange = 0;
@@ -380,7 +433,7 @@
 				case text::ControlCharacter::HARD_SPACE:	cIns = CHAR_HARDBLANK;	break;
 			}
 			if( cIns )
-				pDoc->Insert( aTmp, cIns );
+                m_pDoc->Insert( aTmp, cIns );
 
 			if(bAbsorb)
 			{
@@ -466,7 +519,7 @@
 
 			const SwStartNode* pOwnStartNode = GetStartNode();
 			SwStartNodeType eSearchNodeType = SwNormalStartNode;
-			switch(eCrsrType)
+            switch(m_eCrsrType)
 			{
 				case CURSOR_FRAME:		eSearchNodeType = SwFlyStartNode;		break;
 				case CURSOR_TBLTEXT: 	eSearchNodeType = SwTableBoxStartNode;	break;
@@ -475,6 +528,7 @@
 				case CURSOR_FOOTER:		eSearchNodeType = SwFooterStartNode;	break;
 				//case CURSOR_INVALID:
 				//case CURSOR_BODY:
+                default:;//prevent warning
 			}
 
             const SwNode* pSrcNode = 0;
@@ -628,7 +682,7 @@
 													pShape->setPropertyValue(C2U("TextRange"), aPos);
 
 													uno::Reference<frame::XModel> xModel =
-																	pDoc->GetDocShell()->GetBaseModel();
+                                                                    m_pDoc->GetDocShell()->GetBaseModel();
 													uno::Reference<drawing::XDrawPageSupplier> xPageSupp(
 																xModel, uno::UNO_QUERY);
 
@@ -1035,7 +1089,7 @@
 	DBG_ASSERT(pOwnCursor, "OTextCursorHelper::getUnoTunnelId() ??? ")
     const SwStartNode* pOwnStartNode = pOwnCursor->GetPaM()->GetNode()->StartOfSectionNode();
 	SwStartNodeType eSearchNodeType = SwNormalStartNode;
-	switch(eCrsrType)
+    switch(m_eCrsrType)
 	{
 		case CURSOR_FRAME:		eSearchNodeType = SwFlyStartNode;		break;
 		case CURSOR_TBLTEXT: 	eSearchNodeType = SwTableBoxStartNode;	break;
@@ -1044,6 +1098,7 @@
 		case CURSOR_FOOTER:		eSearchNodeType = SwFooterStartNode;	break;
 		//case CURSOR_INVALID:
 		//case CURSOR_BODY:
+        default:;//prevent warning
 	}
 
 	const SwNode* pSrcNode;
@@ -1196,7 +1251,7 @@
     throw(uno::RuntimeException)
 {
     static uno::Reference< beans::XPropertySetInfo > xInfo =
-        new SfxItemPropertySetInfo(_pMap);
+        new SfxItemPropertySetInfo(m_pMap);
     return xInfo;
 }
 /*-- 15.03.2002 12:30:42---------------------------------------------------
@@ -1221,7 +1276,7 @@
     if(!IsValid())
         throw  uno::RuntimeException();
     const SfxItemPropertyMap*   pMap = SfxItemPropertyMap::GetByName(
-                                                    _pMap, rPropertyName);
+                                                    m_pMap, rPropertyName);
     uno::Any aRet;
     if(pMap)
     {
@@ -1406,6 +1461,636 @@
 		aRet = OWeakAggObject::queryAggregation( rType );
 	return aRet;
 }
+/*-- 23.06.2006 08:56:30---------------------------------------------------
+
+  -----------------------------------------------------------------------*/
+uno::Reference< text::XTextRange > SwXText::appendParagraph( 
+                const uno::Sequence< beans::PropertyValue > & rProperties ) 
+                throw (lang::IllegalArgumentException, uno::RuntimeException)
+{
+    return finishOrAppendParagraph(false, rProperties);
+}
+/*-- 23.06.2006 08:56:22---------------------------------------------------
+
+  -----------------------------------------------------------------------*/
+uno::Reference< text::XTextRange > SwXText::finishParagraph( 
+                const uno::Sequence< beans::PropertyValue > & rProperties ) 
+                throw (lang::IllegalArgumentException, uno::RuntimeException)
+{
+    return finishOrAppendParagraph(true, rProperties);
+}
+
+/*-- 08.05.2006 13:26:26---------------------------------------------------
+
+  -----------------------------------------------------------------------*/
+uno::Reference< text::XTextRange > SwXText::finishOrAppendParagraph( 
+        bool bFinish,
+        const uno::Sequence< beans::PropertyValue > & rProperties ) 
+            throw (lang::IllegalArgumentException, uno::RuntimeException)
+
+{
+    vos::OGuard aGuard(Application::GetSolarMutex());
+    if(!IsValid())
+        throw  uno::RuntimeException();
+    uno::Reference< text::XTextRange > xRet;
+    
+    const SwStartNode* pStartNode = GetStartNode();
+    if(!pStartNode)
+        throw  uno::RuntimeException();
+    {
+        bool bIllegalException = false;
+        bool bRuntimeException = false;
+        ::rtl::OUString sMessage;
+        m_pDoc->StartUndo(UNDO_START , NULL);
+        //find end node, go backward - don't skip tables because the new paragraph has to be the last node 
+        //aPam.Move( fnMoveBackward, fnGoNode );
+        SwPosition aInsertPosition( SwNodeIndex( *pStartNode->EndOfSectionNode(), -1 ) );
+        SwPaM aPam(aInsertPosition);
+        m_pDoc->AppendTxtNode( *aPam.GetPoint() );
+        //remove attributes from the previous paragraph
+        m_pDoc->ResetAttr(aPam);
+        //in case of finishParagraph the PaM needs to be moved to the previous paragraph
+        if(bFinish)
+            aPam.Move( fnMoveBackward, fnGoNode );
+        if(rProperties.getLength())
+        {        
+            // now set the properties
+            const SfxItemPropertyMap* pParagraphMap = aSwMapProvider.GetPropertyMap(PROPERTY_MAP_PARAGRAPH);
+            SfxItemPropertySet aParaPropSet(pParagraphMap);
+
+            const beans::PropertyValue* pValues = rProperties.getConstArray();
+
+            for( sal_Int32 nProp = 0; nProp < rProperties.getLength(); ++nProp)
+            {
+                // no sorting of property names required - results in performance issues as long as SfxItemPropertyMap::GetByName 
+                // is not able to hash the maps
+                const SfxItemPropertyMap*   pMap = SfxItemPropertyMap::GetByName( pParagraphMap, pValues[nProp].Name );
+                if(pMap)
+                {
+                    try
+                    {        
+                        SwXTextCursor::SetPropertyValue(
+                        aPam, 
+                        aParaPropSet, 
+                        pValues[nProp].Name,
+                        pValues[nProp].Value, 
+                        pMap, 0);
+                    }
+                    catch( lang::IllegalArgumentException& rIllegal )
+                    {
+                        sMessage = rIllegal.Message;
+                        bIllegalException = true;
+                    }        
+                    catch( uno::RuntimeException& rRuntime )
+                    {
+                        sMessage = rRuntime.Message;
+                        bRuntimeException = true;
+                    }
+                }
+                else
+                    bIllegalException = true;
+                if( bIllegalException || bRuntimeException )
+                {
+                    break;
+                }            
+            }
+        }
+        m_pDoc->EndUndo(UNDO_END, NULL);
+        if( bIllegalException || bRuntimeException )
+        {        
+            SwUndoIter aUndoIter( &aPam, 0 );
+            m_pDoc->Undo(aUndoIter);
+            if(bIllegalException)
+            {
+                lang::IllegalArgumentException aEx;
+                aEx.Message = sMessage;
+                throw aEx;
+            }
+            else //if(bRuntimeException)            
+            {
+                uno::RuntimeException aEx;
+                aEx.Message = sMessage;
+                throw aEx;
+            }            
+        }
+        SwUnoCrsr* pUnoCrsr = m_pDoc->CreateUnoCrsr(*aPam.Start(), sal_False);
+        xRet = new SwXParagraph(this, pUnoCrsr);
+    }
+
+    return xRet;
+}
+/*-- 08.05.2006 13:28:26---------------------------------------------------
+    Append text portions at the end of the last paragraph of the text 
+    interface. Support of import filters.
+  -----------------------------------------------------------------------*/
+uno::Reference< text::XTextRange > SwXText::appendTextPortion( 
+        const ::rtl::OUString& rText, 
+        const uno::Sequence< beans::PropertyValue > & rCharacterAndParagraphProperties ) 
+            throw (lang::IllegalArgumentException, uno::RuntimeException)
+{
+    vos::OGuard aGuard(Application::GetSolarMutex());
+    if(!IsValid())
+        throw  uno::RuntimeException();
+	uno::Reference< text::XTextRange > xRet;
+    uno::Reference< text::XTextCursor > xTextCursor = createCursor();
+    xTextCursor->gotoEnd(sal_False);
+    SwXTextCursor* pTextCursor = (SwXTextCursor*)
+        (uno::Reference< lang::XUnoTunnel >(xTextCursor, uno::UNO_QUERY_THROW))->getSomething(SwXTextCursor::getUnoTunnelId());
+    {
+        bool bIllegalException = false;
+        bool bRuntimeException = false;
+        ::rtl::OUString sMessage;
+        m_pDoc->StartUndo(UNDO_INSERT, NULL);
+        
+//        SwPaM aPam(*pStartNode->EndOfSectionNode());
+        //aPam.Move( fnMoveBackward, fnGoNode );
+        SwUnoCrsr*	pCursor = pTextCursor->GetCrsr();
+        pCursor->MovePara( fnParaCurr, fnParaEnd );
+        m_pDoc->DontExpandFmt( *pCursor->Start() );
+
+        if(rText.getLength())
+        {
+            xub_StrLen nContentPos = pCursor->GetPoint()->nContent.GetIndex();
+            SwUnoCursorHelper::DocInsertStringSplitCR( *m_pDoc, *pCursor, rText );
+            SwXTextCursor::SelectPam(*pCursor, sal_True);
+            pCursor->GetPoint()->nContent = nContentPos;
+        }
+    
+        if(rCharacterAndParagraphProperties.getLength())
+        {        
+
+            const beans::PropertyValue* pValues = rCharacterAndParagraphProperties.getConstArray();
+            for( sal_Int32 nProp = 0; nProp < rCharacterAndParagraphProperties.getLength(); ++nProp)
+            {
+                // no sorting of property names required - results in performance issues as long as SfxItemPropertyMap::GetByName 
+                // is not able to hash the maps
+                const SfxItemPropertyMap* pCursorMap = aSwMapProvider.GetPropertyMap(PROPERTY_MAP_TEXT_CURSOR);
+                SfxItemPropertySet aCursorPropSet(pCursorMap);
+                const SfxItemPropertyMap*   pMap = SfxItemPropertyMap::GetByName( pCursorMap, pValues[nProp].Name );
+                if(pMap)
+                {
+                    try
+                    {        
+                        SwXTextCursor::SetPropertyValue(
+                        *pCursor, 
+                        aCursorPropSet, 
+                        pValues[nProp].Name,
+                        pValues[nProp].Value, 
+                        pMap, SETATTR_NOFORMATATTR);
+                    }
+                    catch( lang::IllegalArgumentException& rIllegal )
+                    {
+                        sMessage = rIllegal.Message;
+                        bIllegalException = true;
+                    }        
+                    catch( uno::RuntimeException& rRuntime )
+                    {
+                        sMessage = rRuntime.Message;
+                        bRuntimeException = true;
+                    }
+                }
+                else
+                    bIllegalException = true;
+                if( bIllegalException || bRuntimeException )
+                {
+                    break;
+                }            
+            }
+        }
+        m_pDoc->EndUndo(UNDO_INSERT, NULL);
+        if( bIllegalException || bRuntimeException )
+        {        
+            SwUndoIter aUndoIter( pCursor, 0 );
+            m_pDoc->Undo(aUndoIter);
+            delete pCursor;
+            pCursor = 0;
+            if(bIllegalException)
+            {
+                lang::IllegalArgumentException aEx;
+                aEx.Message = sMessage;
+                throw aEx;
+            }
+            else //if(bRuntimeException)            
+            {
+                uno::RuntimeException aEx;
+                aEx.Message = sMessage;
+                throw aEx;
+            }            
+        }
+        xRet = new SwXTextRange(*pCursor, this);
+        delete pCursor;
+    }
+	return xRet;
+}
+/*-- 11.05.2006 15:46:26---------------------------------------------------
+    enable appending text contents like graphic objects, shapes and so on
+    to support import filters
+  -----------------------------------------------------------------------*/
+uno::Reference< text::XTextRange > SwXText::appendTextContent( 
+    const uno::Reference< text::XTextContent >& xTextContent,
+    const uno::Sequence< beans::PropertyValue >& rCharacterAndParagraphProperties ) 
+        throw (lang::IllegalArgumentException, uno::RuntimeException)
+{
+    vos::OGuard aGuard(Application::GetSolarMutex());
+    if(!IsValid())
+        throw  uno::RuntimeException();
+    const SwStartNode* pStartNode = GetStartNode();
+    if(!pStartNode)
+        throw  uno::RuntimeException();
+    uno::Reference< text::XTextRange > xRet;
+    {
+        m_pDoc->StartUndo(UNDO_INSERT, NULL);
+        //find end node, go backward - don't skip tables because the new paragraph has to be the last node 
+        SwPaM aPam(*pStartNode->EndOfSectionNode());
+        aPam.Move( fnMoveBackward, fnGoNode );
+        //set cursor to the end of the last text node
+        SwCursor* pCursor = new SwCursor( *aPam.Start() );
+        xRet = new SwXTextRange(*pCursor, this);
+        pCursor->MovePara( fnParaCurr, fnParaEnd );
+        m_pDoc->DontExpandFmt( *pCursor->Start() );
+        //now attach the text content here
+        insertTextContent( xRet, xTextContent, false );
+        //now apply the properties to the anchor
+        if( rCharacterAndParagraphProperties.getLength())
+        {
+            try
+            {
+                uno::Reference< beans::XPropertySet > xAnchor( xTextContent->getAnchor(), uno::UNO_QUERY);
+                if( xAnchor.is() )
+                {
+                    for( sal_Int32 nElement = 0; nElement < rCharacterAndParagraphProperties.getLength(); ++nElement )
+                    {
+                        xAnchor->setPropertyValue( rCharacterAndParagraphProperties[nElement].Name, rCharacterAndParagraphProperties[nElement].Value );
+                    }    
+                }
+                
+            }
+            catch(const uno::Exception&)
+            {
+                throw uno::RuntimeException();
+            }    
+        }    
+        delete pCursor;
+        m_pDoc->EndUndo(UNDO_INSERT, NULL);
+    }
+    return xRet;
+}
+/*-- 11.05.2006 15:46:26---------------------------------------------------
+    move previously appended paragraphs into a text frames
+    to support import filters
+  -----------------------------------------------------------------------*/
+uno::Reference< text::XTextContent > SwXText::convertToTextFrame( 
+    const uno::Reference< text::XTextRange >& xStart, 
+    const uno::Reference< text::XTextRange >& xEnd, 
+    const uno::Sequence< beans::PropertyValue >& rFrameProperties ) 
+        throw (lang::IllegalArgumentException, uno::RuntimeException)
+{
+    vos::OGuard aGuard(Application::GetSolarMutex());
+    if(!IsValid())
+        throw  uno::RuntimeException();
+    uno::Reference< text::XTextContent > xRet;
+	SwUnoInternalPaM aStartPam(*GetDoc());
+    std::auto_ptr < SwUnoInternalPaM > pEndPam( new SwUnoInternalPaM(*GetDoc()));
+	if(SwXTextRange::XTextRangeToSwPaM(aStartPam, xStart) && 
+        SwXTextRange::XTextRangeToSwPaM(*pEndPam, xEnd) )
+    {
+		m_pDoc->StartUndo( UNDO_START, NULL );
+        bool bIllegalException = false;
+        bool bRuntimeException = false;
+        ::rtl::OUString sMessage;
+        SwNode* pStartStartNode = aStartPam.GetNode()->StartOfSectionNode();
+	    while(pStartStartNode && pStartStartNode->IsSectionNode())
+	    {
+	    }
+        SwNode* pEndStartNode = pEndPam->GetNode()->StartOfSectionNode();
+	    while(pEndStartNode && pEndStartNode->IsSectionNode())
+	    {
+		    pEndStartNode = pEndStartNode->StartOfSectionNode();
+	    }
+        if(pStartStartNode != pEndStartNode || pStartStartNode != GetStartNode())
+            throw lang::IllegalArgumentException();
+        //make a selection from aStartPam to a EndPam
+        SwSelBoxes aBoxes;
+        SfxItemSet aFrameItemSet(m_pDoc->GetAttrPool(), 							
+                                    RES_FRMATR_BEGIN, RES_FRMATR_END-1,
+							        0 );
+
+        aStartPam.SetMark();
+        SwCntntNode* pEndContentNode = pEndPam->GetCntntNode(sal_True);
+        *aStartPam.End() = *pEndPam->End();
+        pEndPam.reset(0);
+       
+        SwXTextFrame* pNewFrame;
+        uno::Reference< text::XTextFrame > xNewFrame = pNewFrame = new SwXTextFrame( m_pDoc );
+        pNewFrame->SetSelection( aStartPam );
+        try
+        {
+            const beans::PropertyValue* pValues = rFrameProperties.getConstArray();
+            for(sal_Int32 nProp = 0; nProp < rFrameProperties.getLength(); ++nProp)
+                pNewFrame->SwXFrame::setPropertyValue(pValues[nProp].Name, pValues[nProp].Value);
+
+            uno::Reference< text::XTextRange> xInsertTextRange = new SwXTextRange(aStartPam, this);
+            pNewFrame->attach( xInsertTextRange );
+        }
+        catch( lang::IllegalArgumentException& rIllegal )
+        {
+            sMessage = rIllegal.Message;
+            bIllegalException = true;
+        }        
+        catch( uno::RuntimeException& rRuntime )
+        {
+            sMessage = rRuntime.Message;
+            bRuntimeException = true;
+        }
+        xRet = pNewFrame;
+        m_pDoc->EndUndo(UNDO_END, NULL);
+        if( bIllegalException || bRuntimeException )
+        {        
+            SwUndoIter aUndoIter( &aStartPam, 0 );
+            m_pDoc->Undo(aUndoIter);
+            if(bIllegalException)
+            {
+                lang::IllegalArgumentException aEx;
+                aEx.Message = sMessage;
+                throw aEx;
+            }
+            else //if(bRuntimeException)            
+            {
+                uno::RuntimeException aEx;
+                aEx.Message = sMessage;
+                throw aEx;
+            }            
+        }
+    }
+    else
+        throw lang::IllegalArgumentException();
+    return xRet;
+}
+/*-- 11.05.2006 15:46:26---------------------------------------------------
+    Move previously imported paragraphs into a new text table.
+    
+  -----------------------------------------------------------------------*/
+uno::Reference< text::XTextTable > SwXText::convertToTable( 
+    const uno::Sequence< uno::Sequence< uno::Sequence< uno::Reference< text::XTextRange > > > >& rTableRanges,
+	const uno::Sequence< uno::Sequence< uno::Sequence< beans::PropertyValue > > >& rCellProperties, 
+	const uno::Sequence< uno::Sequence< beans::PropertyValue > >& rRowProperties, 
+	const uno::Sequence< beans::PropertyValue >& rTableProperties ) 
+        throw (lang::IllegalArgumentException, uno::RuntimeException)
+{
+    vos::OGuard aGuard(Application::GetSolarMutex());
+    if(!IsValid())
+        throw  uno::RuntimeException();
+
+    //at first collect the text ranges as SwPaMs 
+    const uno::Sequence< uno::Sequence< uno::Reference< text::XTextRange > > >* pTableRanges = rTableRanges.getConstArray(); 
+    std::auto_ptr < SwPaM > pFirstPaM;
+    std::vector< std::vector<SwNodeRange> > aTableNodes;
+    bool bExcept = false;
+    SwPaM aLastPaM(m_pDoc->GetNodes());
+    for( sal_Int32 nRow = 0; !bExcept && (nRow < rTableRanges.getLength()); ++nRow)
+    {
+        std::vector<SwNodeRange> aRowNodes;
+        const uno::Sequence< uno::Sequence< uno::Reference< text::XTextRange > > >& rRow = pTableRanges[nRow];
+		const uno::Sequence< uno::Reference< text::XTextRange > >* pRow = pTableRanges[nRow].getConstArray();
+        
+        for( sal_Int32 nCell = 0; nCell < rRow.getLength(); ++nCell)
+        {
+            if( pRow[nCell].getLength() != 2 )
+                throw lang::IllegalArgumentException();
+            const uno::Reference< text::XTextRange > xStartRange = pRow[nCell][0];
+            const uno::Reference< text::XTextRange > xEndRange = pRow[nCell][1];
+            SwUnoInternalPaM aStartCellPam(*m_pDoc);
+            SwUnoInternalPaM aEndCellPam(*m_pDoc);
+    
+            // !!! TODO - PaMs in tables and sections do not work here - the same applies to PaMs in frames !!!
+            
+            if(!SwXTextRange::XTextRangeToSwPaM(aStartCellPam, xStartRange) || 
+                !SwXTextRange::XTextRangeToSwPaM(aEndCellPam, xEndRange) )
+                throw lang::IllegalArgumentException();
+            /** check the nodes between start and end
+                it is allowed to have pairs of StartNode/EndNodes 
+             */
+            if(aStartCellPam.Start()->nNode < aEndCellPam.End()->nNode)
+            {
+                const SwNode& rStartNode = aStartCellPam.Start()->nNode.GetNode();
+                if(!rStartNode.IsTxtNode() ||
+                        !aEndCellPam.End()->nNode.GetNode().IsTxtNode())
+                {
+                    //start and end of the cell must be on a SwTxtNode
+                    bExcept = true;
+                    break;
+                }
+                // increment on each StartNode and decrement on each EndNode
+                // we must reach zero at the end and must not go below zero
+                long nOpenNodeBlock = 0;
+                SwNodeIndex aCellIndex = aStartCellPam.Start()->nNode;
+                while( ++aCellIndex < aEndCellPam.End()->nNode.GetIndex())
+                {
+                    if( aCellIndex.GetNode().IsStartNode() )
+                        ++nOpenNodeBlock;
+                    else if(aCellIndex.GetNode().IsEndNode() )
+                        --nOpenNodeBlock;
+                    if( nOpenNodeBlock < 0 ) 
+                    {
+                        bExcept = true;
+                        break;
+                    }
+                }            
+                if( nOpenNodeBlock != 0)
+                {        
+                    bExcept = true;
+                    break;
+                }
+            }
+            
+            /** The vector<vector> NodeRanges has to contain consecutive nodes.
+                In rTableRanges the ranges don't need to be full paragraphs but they have to follow 
+                each other. To process the ranges they have to be aligned on paragraph borders
+                by inserting paragraph breaks. Non-consecutive ranges must initiate an 
+                exception.
+             
+             */
+            if(!nRow && !nCell)
+            {
+                //align the beginning - if necessary
+                if(aStartCellPam.Start()->nContent.GetIndex())
+                    m_pDoc->SplitNode(*aStartCellPam.Start(), sal_False);
+            }
+            else
+            {
+                //check the predecessor 
+                ULONG nLastNodeIndex = aLastPaM.End()->nNode.GetIndex();
+                ULONG nStartCellNodeIndex = aStartCellPam.Start()->nNode.GetIndex();
+                ULONG nLastNodeEndIndex = aLastPaM.End()->nNode.GetIndex();
+                if( nLastNodeIndex == nStartCellNodeIndex)
+                {
+                    //- same node as predecessor then equal nContent?
+                    if(aLastPaM.End()->nContent != aStartCellPam.Start()->nContent)
+                        bExcept = true;
+                    else
+                    {
+                        m_pDoc->SplitNode(*aStartCellPam.Start(), sal_False);
+                    }            
+                }
+                else if(nStartCellNodeIndex == ( nLastNodeEndIndex + 1))
+                {
+                    //next paragraph - now the content index of the new should be 0
+                    //and of the old one should be equal to the text length
+                    //but if it isn't we don't care - the cell is being inserted on the 
+                    //node border anyway
+                }
+                else  
+                    bExcept = true;    
+            }        
+			//now check if there's a need to insert another paragraph break
+            if( aEndCellPam.End()->nContent.GetIndex() < aEndCellPam.End()->nNode.GetNode().GetTxtNode()->Len())
+			{
+				m_pDoc->SplitNode(*aEndCellPam.End(), sal_False);
+                //take care that the new start/endcell is moved to the right position 
+				//aStartCellPam has to point to the start of the new (previous) node 
+				//aEndCellPam has to point the the end of the new (previous) node 
+                aStartCellPam.DeleteMark();
+                aStartCellPam.Move(fnMoveBackward, fnGoNode);
+				aStartCellPam.GetPoint()->nContent = 0;
+                aEndCellPam.DeleteMark();
+                aEndCellPam.Move(fnMoveBackward, fnGoNode);
+                aEndCellPam.GetPoint()->nContent = aEndCellPam.GetNode()->GetTxtNode()->Len();
+                
+			}
+
+            *aLastPaM.GetPoint() = *aEndCellPam.Start();
+            if( aStartCellPam.HasMark() )
+            {   
+                aLastPaM.SetMark();
+                *aLastPaM.GetMark() = *aEndCellPam.End();
+            }
+            else 
+                aLastPaM.DeleteMark();
+
+            SwNodeRange aCellRange( aStartCellPam.Start()->nNode, aEndCellPam.End()->nNode);
+            aRowNodes.push_back(aCellRange);
+            if( !nRow && !nCell )
+                pFirstPaM.reset( new SwPaM(*aStartCellPam.Start()));
+        } 
+        aTableNodes.push_back(aRowNodes);
+    }
+    
+    if(bExcept)
+    {
+        SwUndoIter aUndoIter( &aLastPaM, 0 );
+        m_pDoc->Undo(aUndoIter);
+        throw lang::IllegalArgumentException();
+    }
+    
+    const SwTable* pTable = m_pDoc->TextToTable( aTableNodes );
+    SwXTextTable* pTextTable = 0;
+    uno::Reference< text::XTextTable > xRet = pTextTable = new SwXTextTable( *pTable->GetFrmFmt() );
+    uno::Reference< beans::XPropertySet > xPrSet = pTextTable;
+    // set properties to the table - catch lang::WrappedTargetException and lang::IndexOutOfBoundsException
+    try
+    {
+        //apply table properties
+        const beans::PropertyValue* pTableProperties = rTableProperties.getConstArray();
+        sal_Int32 nProperty;
+        for( nProperty = 0; nProperty < rTableProperties.getLength(); ++nProperty)
+            xPrSet->setPropertyValue( pTableProperties[nProperty].Name, pTableProperties[nProperty].Value );
+        
+        //apply row properties
+        uno::Reference< table::XTableRows >  xRows = xRet->getRows();
+        const beans::PropertyValues* pRowProperties = rRowProperties.getConstArray();
+        sal_Int32 nRow;
+        for( nRow = 0; nRow < xRows->getCount(); ++nRow)
+        {
+            if( nRow >= rRowProperties.getLength())
+            {
+                break;
+            }    
+            uno::Reference< beans::XPropertySet > xRow;
+            xRows->getByIndex( nRow ) >>= xRow;
+            const beans::PropertyValue* pProperties = pRowProperties[nRow].getConstArray();
+            for( sal_Int32 nProperty = 0; nProperty < pRowProperties[nRow].getLength(); ++nProperty)
+                xRow->setPropertyValue(pProperties[nProperty].Name, pProperties[nProperty].Value);
+        }
+
+#ifdef DEBUG
+//-->debug cell properties of all rows
+    {
+        ::rtl::OUString sNames;
+        for( sal_Int32  nDebugRow = 0; nDebugRow < rCellProperties.getLength(); ++nDebugRow)
+        {
+            const uno::Sequence< beans::PropertyValues > aDebugCurrentRow = rCellProperties[nDebugRow];
+            sal_Int32 nDebugCells = aDebugCurrentRow.getLength();
+            (void) nDebugCells;
+            for( sal_Int32  nDebugCell = 0; nDebugCell < nDebugCells; ++nDebugCell)
+            {
+                const uno::Sequence< beans::PropertyValue >& aDebugCellProperties = aDebugCurrentRow[nDebugCell];
+                sal_Int32 nDebugCellProperties = aDebugCellProperties.getLength();
+                for( sal_Int32  nDebugProperty = 0; nDebugProperty < nDebugCellProperties; ++nDebugProperty)
+                {
+                    const ::rtl::OUString sName = aDebugCellProperties[nDebugProperty].Name;
+                    sNames += sName;
+                    sNames += ::rtl::OUString('-');
+                }
+                sNames += ::rtl::OUString('+');
+            }
+            sNames += ::rtl::OUString('|');
+        }
+        (void)sNames;
+    }
+//--<
+#endif
+
+        //apply cell properties
+        for( sal_Int32  nRow = 0; nRow < rCellProperties.getLength(); ++nRow)
+        {
+            const uno::Sequence< beans::PropertyValues > aCurrentRow = rCellProperties[nRow];
+            sal_Int32 nCells = aCurrentRow.getLength();
+            for( sal_Int32  nCell = 0; nCell < nCells; ++nCell)
+            {
+                const uno::Sequence< beans::PropertyValue >& aCellProperties = aCurrentRow[nCell];
+                sal_Int32 nCellProperties = aCellProperties.getLength();
+                uno::Reference< beans::XPropertySet > xCell( pTextTable->getCellByPosition(nCell, nRow), uno::UNO_QUERY );
+                for( sal_Int32 nProperty = 0; nProperty < nCellProperties; ++nProperty)
+                {
+                    xCell->setPropertyValue(aCellProperties[nProperty].Name, aCellProperties[nProperty].Value);
+                }
+            }
+        }
+    }
+    catch( const lang::WrappedTargetException& rWrapped )
+    {
+        (void)rWrapped;
+    }
+    catch ( const lang::IndexOutOfBoundsException& rBounds )
+    {
+        (void)rBounds;
+    }    
+    
+
+        bool bIllegalException = false;
+        bool bRuntimeException = false;
+        ::rtl::OUString sMessage;
+        m_pDoc->StartUndo(UNDO_START, NULL);
+        m_pDoc->EndUndo(UNDO_START, NULL);
+        if( bIllegalException || bRuntimeException )
+        {        
+            SwUndoIter aUndoIter( pFirstPaM.get(), 0 );
+            m_pDoc->Undo(aUndoIter);
+            if(bIllegalException)
+            {
+                lang::IllegalArgumentException aEx;
+                aEx.Message = sMessage;
+                throw aEx;
+            }
+            else //if(bRuntimeException)            
+            {
+                uno::RuntimeException aEx;
+                aEx.Message = sMessage;
+                throw aEx;
+            }            
+        }
+    return xRet;
+}
 
 /*-- 10.12.98 11:17:28---------------------------------------------------
 
@@ -1458,7 +2143,7 @@
 	if(IsValid())
 	{
 		SwNode& rNode = GetDoc()->GetNodes().GetEndOfContent();
-		//erstmal sicherstellen, dass wir nicht in einer Tabelle stehen
+		//the cursor has to skip tables contained in this text
 		SwPaM aPam(rNode);
 		aPam.Move( fnMoveBackward, fnGoDoc );
 		if(!bIgnoreTables)
--- sw/source/ui/dbui/dbmgr.cxx	6 Jun 2007 11:06:43 -0000	1.119
+++ sw/source/ui/dbui/dbmgr.cxx	12 Jul 2007 14:09:18 -0000
@@ -2251,8 +2251,10 @@
     if(pImpl->pMergeData)
 	{
         return !bMergeLock &&
-                rDataSource == (String)pImpl->pMergeData->sDataSource &&
-                    rTableOrQuery == (String)pImpl->pMergeData->sCommand &&
+                ((rDataSource == (String)pImpl->pMergeData->sDataSource &&
+                    rTableOrQuery == (String)pImpl->pMergeData->sCommand)
+                    ||(!rDataSource.Len() && !rTableOrQuery.Len()))
+                    &&
                     pImpl->pMergeData->xResultSet.is();
 	}
     else if(!bMergeOnly)
--- sw/source/ui/uiview/makefile.mk	6 Feb 2006 17:25:11 -0000	1.8
+++ sw/source/ui/uiview/makefile.mk	12 Jul 2007 14:09:19 -0000
@@ -79,7 +79,8 @@
         $(SLO)$/swcli.obj  \
         $(SLO)$/uivwimp.obj \
         $(SLO)$/view2.obj \
-        $(SLO)$/viewling.obj
+        $(SLO)$/viewling.obj \
+        $(SLO)$/formatclipboard.obj
 
 # --- Tagets -------------------------------------------------------
 
