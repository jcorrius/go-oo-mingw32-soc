Index: svtools/source/filter.vcl/wmf/enhwmf.cxx
===================================================================
RCS file: /cvs/util/svtools/source/filter.vcl/wmf/enhwmf.cxx,v
retrieving revision 1.21
retrieving revision 1.21.262.2
diff -u -p -u -p -r1.21 -r1.21.262.2
--- svtools/source/filter.vcl/wmf/enhwmf.cxx	17 Jun 2004 13:20:09 -0000	1.21
+++ svtools/source/filter.vcl/wmf/enhwmf.cxx	21 Jan 2005 11:10:25 -0000	1.21.262.2
@@ -848,8 +848,8 @@ BOOL EnhWMFReader::ReadEnhWMF() // SvStr
                     break;                  // todo: supporting all 256 ternary rasterops
 				}
 				pOut->Push();
-				UINT32 nOldRop = pOut->SetRasterOp( nNewRop );
-				pOut->DrawRect( Rectangle( aDestOrg, aDestExt ) );
+				sal_uInt32 nOldRop = pOut->SetRasterOp( nNewRop );
+				pOut->DrawRect( Rectangle( aDestOrg, aDestExt ), sal_False );	// SJ: 118798, not using edge for bitblit
 				pOut->SetRasterOp( nOldRop );
 				pOut->Pop();
 			}
@@ -868,6 +868,9 @@ BOOL EnhWMFReader::ReadEnhWMF() // SvStr
 						>> xformSrc >> nColor >> iUsageSrc >> offBmiSrc >> cbBmiSrc
 							>> offBitsSrc >> cbBitsSrc >> cxSrc >> cySrc;
 
+				cxDest = abs( cxDest );		// sj: i37894, size can be negative
+				cyDest = abs( cyDest );	
+
 				Bitmap		aBitmap;
 				Rectangle	aRect( Point( xDest, yDest ), Size( cxDest+1, cyDest+1 ) );
 
@@ -915,6 +918,9 @@ BOOL EnhWMFReader::ReadEnhWMF() // SvStr
 				*pWMF >> xDest >> yDest >> xSrc >> ySrc >> cxSrc >> cySrc >> offBmiSrc >> cbBmiSrc >> offBitsSrc
 					>> cbBitsSrc >> iUsageSrc >> dwRop >> cxDest >> cyDest;
 
+				cxDest = abs( cxDest );		// sj: i37894, size can be negative
+				cyDest = abs( cyDest );	
+
 				Bitmap		aBitmap;
 				Rectangle	aRect( Point( xDest, yDest ), Size( cxDest+1, cyDest+1 ) );
 
Index: xmloff/inc/EnhancedCustomShapeToken.hxx
===================================================================
RCS file: /cvs/xml/xmloff/inc/EnhancedCustomShapeToken.hxx,v
retrieving revision 1.4
retrieving revision 1.4.70.1
diff -u -p -u -p -r1.4 -r1.4.70.1
--- xmloff/inc/EnhancedCustomShapeToken.hxx	26 Nov 2004 14:08:42 -0000	1.4
+++ xmloff/inc/EnhancedCustomShapeToken.hxx	3 Feb 2005 18:53:44 -0000	1.4.70.1
@@ -109,7 +109,7 @@ namespace xmloff { namespace EnhancedCus
 		EAS_glue_point_leaving_directions,
 		EAS_text_path,
 		EAS_text_path_mode,
-		EAS_text_path_scale_x,
+		EAS_text_path_scale,
 		EAS_text_path_same_letter_heights,
 		EAS_modifiers,
 		EAS_equation,
Index: xmloff/inc/xmltoken.hxx
===================================================================
RCS file: /cvs/xml/xmloff/inc/xmltoken.hxx,v
retrieving revision 1.82
retrieving revision 1.81.28.2
diff -u -p -u -p -r1.82 -r1.81.28.2
--- xmloff/inc/xmltoken.hxx	28 Jan 2005 15:35:08 -0000	1.82
+++ xmloff/inc/xmltoken.hxx	4 Feb 2005 17:12:04 -0000	1.81.28.2
@@ -2291,7 +2291,7 @@ namespace xmloff { namespace token {
 		XML_GLUE_POINT_LEAVING_DIRECTIONS,
 		XML_TEXT_PATH,
 		XML_TEXT_PATH_MODE,
-		XML_TEXT_PATH_SCALE_X,
+		XML_TEXT_PATH_SCALE,
 		XML_TEXT_PATH_SAME_LETTER_HEIGHTS,
 		XML_MODIFIERS,
 		XML_EQUATION,
Index: xmloff/source/core/xmltoken.cxx
===================================================================
RCS file: /cvs/xml/xmloff/source/core/xmltoken.cxx,v
retrieving revision 1.87
retrieving revision 1.85.22.2
diff -u -p -u -p -r1.87 -r1.85.22.2
--- xmloff/source/core/xmltoken.cxx	28 Jan 2005 15:35:26 -0000	1.87
+++ xmloff/source/core/xmltoken.cxx	4 Feb 2005 17:12:35 -0000	1.85.22.2
@@ -2299,7 +2299,7 @@ namespace xmloff { namespace token {
 		TOKEN( "glue-point-leaving-direction" ,		XML_GLUE_POINT_LEAVING_DIRECTIONS ),
 		TOKEN( "text-path" ,							XML_TEXT_PATH ),
 		TOKEN( "text-path-mode" ,						XML_TEXT_PATH_MODE ),
-		TOKEN( "text-path-scale-x" ,					XML_TEXT_PATH_SCALE_X ),
+		TOKEN( "text-path-scale" ,					XML_TEXT_PATH_SCALE ),
 		TOKEN( "text-path-same-letter-heights" ,		XML_TEXT_PATH_SAME_LETTER_HEIGHTS ),
 		TOKEN( "modifiers" ,							XML_MODIFIERS ),
 		TOKEN( "equation" ,							XML_EQUATION ),
Index: xmloff/source/draw/EnhancedCustomShapeToken.cxx
===================================================================
RCS file: /cvs/xml/xmloff/source/draw/EnhancedCustomShapeToken.cxx,v
retrieving revision 1.5
retrieving revision 1.5.70.1
diff -u -p -u -p -r1.5 -r1.5.70.1
--- xmloff/source/draw/EnhancedCustomShapeToken.cxx	26 Nov 2004 14:09:29 -0000	1.5
+++ xmloff/source/draw/EnhancedCustomShapeToken.cxx	3 Feb 2005 18:54:32 -0000	1.5.70.1
@@ -133,7 +133,7 @@ static const TokenTable pTokenTableArray
 	{ "glue-point-leaving-directions",		EAS_glue_point_leaving_directions },
 	{ "text-path",							EAS_text_path },
 	{ "text-path-mode",						EAS_text_path_mode },
-	{ "text-path-scale-x",					EAS_text_path_scale_x },
+	{ "text-path-scale",					EAS_text_path_scale },
 	{ "text-path-same-letter-heights",		EAS_text_path_same_letter_heights },
 	{ "modifiers",							EAS_modifiers },
 	{ "equation",							EAS_equation },
Index: xmloff/source/draw/shapeexport4.cxx
===================================================================
RCS file: /cvs/xml/xmloff/source/draw/shapeexport4.cxx,v
retrieving revision 1.4
retrieving revision 1.4.70.1
diff -u -p -u -p -r1.4 -r1.4.70.1
--- xmloff/source/draw/shapeexport4.cxx	26 Nov 2004 14:10:00 -0000	1.4
+++ xmloff/source/draw/shapeexport4.cxx	3 Feb 2005 18:54:33 -0000	1.4.70.1
@@ -927,10 +927,12 @@ void ImpExportEnhancedGeometry( SvXMLExp
 									break;
 									case EAS_ScaleX :
 									{
-										sal_Bool bTextPathScaleX;
-										if ( rProp.Value >>= bTextPathScaleX )
-											rExport.AddAttribute( XML_NAMESPACE_DRAW, XML_TEXT_PATH_SCALE_X,
-												bTextPathScaleX ? GetXMLToken( XML_TRUE ) : GetXMLToken( XML_FALSE ) );
+										sal_Bool bScaleX;
+										if ( rProp.Value >>= bScaleX )
+										{
+											aStr = bScaleX ? GetXMLToken( XML_SHAPE ) : GetXMLToken( XML_PATH );
+											rExport.AddAttribute( XML_NAMESPACE_DRAW, XML_TEXT_PATH_SCALE, aStr );
+										}
 									}
 									break;
 									case EAS_SameLetterHeights :
Index: xmloff/source/draw/ximpcustomshape.cxx
===================================================================
RCS file: /cvs/xml/xmloff/source/draw/ximpcustomshape.cxx,v
retrieving revision 1.5
retrieving revision 1.5.70.1
diff -u -p -u -p -r1.5 -r1.5.70.1
--- xmloff/source/draw/ximpcustomshape.cxx	26 Nov 2004 14:10:19 -0000	1.5
+++ xmloff/source/draw/ximpcustomshape.cxx	3 Feb 2005 18:54:33 -0000	1.5.70.1
@@ -1148,8 +1148,14 @@ void XMLEnhancedCustomShapeContext::Star
 					maTextPath.push_back( aProp );
 				}
 				break;
-				case EAS_text_path_scale_x :
-					GetBool( maTextPath, rValue, EAS_ScaleX );
+				case EAS_text_path_scale :
+				{
+					sal_Bool bScaleX = IsXMLToken( rValue, XML_SHAPE );
+					beans::PropertyValue aProp;
+					aProp.Name = EASGet( EAS_ScaleX );
+					aProp.Value <<= bScaleX;
+					maTextPath.push_back( aProp );
+				}
 				break;
 				case EAS_text_path_same_letter_heights :
 					GetBool( maTextPath, rValue, EAS_SameLetterHeights );
Index: sd/source/filter/eppt/eppt.cxx
===================================================================
RCS file: /cvs/graphics/sd/source/filter/eppt/eppt.cxx,v
retrieving revision 1.47
retrieving revision 1.47.24.1
diff -u -p -u -p -r1.47 -r1.47.24.1
--- sd/source/filter/eppt/eppt.cxx	7 Jan 2005 09:04:50 -0000	1.47
+++ sd/source/filter/eppt/eppt.cxx	19 Jan 2005 14:25:41 -0000	1.47.24.1
@@ -1370,15 +1370,15 @@ sal_Bool PPTWriter::ImplCreateMaster( sa
 
     if ( aBuExMasterStream.Tell() )
     {
-		ppt::ExContainer aProgTags( *mpStrm, EPP_ProgTags );
+		EscherExContainer aProgTags( *mpStrm, EPP_ProgTags );
 		// v10
 
 		// v9
 		if ( aBuExMasterStream.Tell() )
 		{
-			ppt::ExContainer aProgBinaryTag( *mpStrm, EPP_ProgBinaryTag );
+			EscherExContainer aProgBinaryTag( *mpStrm, EPP_ProgBinaryTag );
 			{
-				ppt::ExAtom( *mpStrm, EPP_CString );
+				EscherExAtom( *mpStrm, EPP_CString );
                *mpStrm << (sal_uInt32)0x5f005f << (sal_uInt32)0x50005f
 					   << (sal_uInt32)0x540050 << (sal_uInt16)0x39;
 			}
@@ -1734,10 +1734,10 @@ sal_Bool PPTWriter::ImplCreateSlide( sal
 		sal_uInt32 nmsofbtAnimGroupSize = amsofbtAnimGroup.Tell();
 		if ( nmsofbtAnimGroupSize )
 		{
-			ppt::ExContainer aProgTags		( *mpStrm, EPP_ProgTags );
-			ppt::ExContainer aProgBinaryTag	( *mpStrm, EPP_ProgBinaryTag );
+			EscherExContainer aProgTags		( *mpStrm, EPP_ProgTags );
+			EscherExContainer aProgBinaryTag( *mpStrm, EPP_ProgBinaryTag );
 			{
-				ppt::ExAtom aCString( *mpStrm, EPP_CString );
+				EscherExAtom aCString( *mpStrm, EPP_CString );
 				*mpStrm << (sal_uInt32)0x5f005f
 						<< (sal_uInt32)0x50005f
 						<< (sal_uInt32)0x540050
@@ -1745,21 +1745,21 @@ sal_Bool PPTWriter::ImplCreateSlide( sal
 						<< (sal_uInt16)0x30;
 			}
 			{
-				ppt::ExAtom aBinaryTagData( *mpStrm, EPP_BinaryTagData );
+				EscherExAtom aBinaryTagData( *mpStrm, EPP_BinaryTagData );
 				{
 					{
-						ppt::ExAtom aMagic2( *mpStrm, 0x2eeb );
+						EscherExAtom aMagic2( *mpStrm, 0x2eeb );
 						*mpStrm << (sal_uInt32)0x01c45df9
 								<< (sal_uInt32)0xe1471b30;
 					}
 					{
-						ppt::ExAtom aMagic( *mpStrm, 0x2b00 );
+						EscherExAtom aMagic( *mpStrm, 0x2b00 );
 						*mpStrm << (sal_uInt32)0;
 					}
 				}
 				mpStrm->Write( amsofbtAnimGroup.GetData(), amsofbtAnimGroup.Tell() );
 				{
-					ppt::ExContainer aMagic2( *mpStrm, 0x2b02 );
+					EscherExContainer aMagic2( *mpStrm, 0x2b02 );
 				}
 			}
 		}
Index: sd/source/filter/eppt/epptso.cxx
===================================================================
RCS file: /cvs/graphics/sd/source/filter/eppt/epptso.cxx,v
retrieving revision 1.80
retrieving revision 1.80.62.1
diff -u -p -u -p -r1.80 -r1.80.62.1
--- sd/source/filter/eppt/epptso.cxx	26 Nov 2004 19:49:30 -0000	1.80
+++ sd/source/filter/eppt/epptso.cxx	19 Jan 2005 14:25:41 -0000	1.80.62.1
@@ -941,6 +941,21 @@ sal_Bool PPTWriter::ImplCloseDocument()
         mpPptEscherEx->PtReplaceOrInsert( EPP_Persist_CurrentPos, mpStrm->Tell() );
         mpStrm->Seek( nOfs );
 
+		// creating the TxMasterStyleAtom
+		SvMemoryStream aTxMasterStyleAtomStrm( 0x200, 0x200 );
+		{
+			EscherExAtom aTxMasterStyleAtom( aTxMasterStyleAtomStrm, EPP_TxMasterStyleAtom, EPP_TEXTTYPE_Other );
+			aTxMasterStyleAtomStrm << (sal_uInt16)5;		// paragraph count
+			sal_uInt16 nLev;
+			sal_Bool bFirst = sal_True;
+			for ( nLev = 0; nLev < 5; nLev++ )
+			{
+				mpStyleSheet->mpParaSheet[ EPP_TEXTTYPE_Other ]->Write( aTxMasterStyleAtomStrm, mpPptEscherEx, nLev, bFirst, sal_False, mXPagePropSet );
+				mpStyleSheet->mpCharSheet[ EPP_TEXTTYPE_Other ]->Write( aTxMasterStyleAtomStrm, mpPptEscherEx, nLev, bFirst, sal_False, mXPagePropSet );
+				bFirst = sal_False;
+			}
+        }
+
         mpExEmbed->Seek( STREAM_SEEK_TO_END );
         sal_uInt32 nExEmbedSize = mpExEmbed->Tell();
 
@@ -949,7 +964,7 @@ sal_Bool PPTWriter::ImplCloseDocument()
                                 + 8                                     // 1 FontCollection Container
                                 + 20                                    // SrKinsoku Container
                                 + 18                                    // 1 TxSiStyleAtom
-                                + 118                                   // 1 TxMasterStyleAtom;
+                                + aTxMasterStyleAtomStrm.Tell()			// 1 TxMasterStyleAtom;
                                 + mpStyleSheet->SizeOfTxCFStyleAtom();
 
         sal_uInt32 nBytesToInsert = nEnvironment + 8;
@@ -1057,23 +1072,12 @@ sal_Bool PPTWriter::ImplCloseDocument()
         mpPptEscherEx->AddAtom( 10, EPP_TxSIStyleAtom );
         *mpStrm << (sal_uInt32)7                        // ?
                 << (sal_Int16)2                         // ?
-                << (sal_uInt8)9                          // ?
-                << (sal_uInt8)8                          // ?
+                << (sal_uInt8)9                         // ?
+                << (sal_uInt8)8                         // ?
                 << (sal_Int16)0;                        // ?
-        mpPptEscherEx->AddAtom( 110, EPP_TxMasterStyleAtom, 0, 4 );
-        static sal_uInt8 aTxSuStyleAtom[ 110 ] =
-        {
-            0x05, 0x00, 0xff, 0xfd, 0x3f, 0x00, 0x00, 0x00, 0x22, 0x20, 0x00, 0x00, 0x64, 0x00, 0x00, 0x00,
-            0x00, 0x00, 0x00, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x02,
-            0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0xff, 0xff, 0xef, 0x00, 0x00, 0x00, 0x00, 0x00,
-            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x18, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x05,
-            0x00, 0x00, 0x20, 0x01, 0x20, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x40, 0x02,
-            0x40, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x60, 0x03, 0x60, 0x03, 0x00, 0x00,
-            0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x80, 0x04, 0x80, 0x04, 0x00, 0x00, 0x00, 0x00
-        };
-        mpStrm->Write( &aTxSuStyleAtom, 110 );
-        maSoundCollection.Write( *mpStrm );
 
+		mpStrm->Write( aTxMasterStyleAtomStrm.GetData(), aTxMasterStyleAtomStrm.Tell() );
+		maSoundCollection.Write( *mpStrm );
         mpPptEscherEx->WriteDrawingGroupContainer( *mpStrm );
         ImplMasterSlideListContainer( mpStrm );
         ImplDocumentListContainer( mpStrm );
@@ -3388,8 +3392,8 @@ void PPTWriter::ImplWriteObjectEffect( S
     ::com::sun::star::presentation::AnimationEffect eTe,
     sal_uInt16 nOrder )
 {
-	ppt::ExContainer aAnimationInfo( rSt, EPP_AnimationInfo );
-	ppt::ExAtom aAnimationInfoAtom( rSt, EPP_AnimationInfoAtom, 0, 1 );
+	EscherExContainer aAnimationInfo( rSt, EPP_AnimationInfo );
+	EscherExAtom aAnimationInfoAtom( rSt, EPP_AnimationInfoAtom, 0, 1 );
 	sal_uInt32  nDimColor = 0x7000000;  // color to use for dimming
 	sal_uInt32  nFlags = 0x4400;        // set of flags that determine type of build
 	sal_uInt32  nSoundRef = 0;          // 0 if storage is from clipboard. Otherwise index(ID) in SoundCollection list.
Index: sd/source/filter/eppt/pptexanimations.cxx
===================================================================
RCS file: /cvs/graphics/sd/source/filter/eppt/pptexanimations.cxx,v
retrieving revision 1.2
retrieving revision 1.2.62.1
diff -u -p -u -p -r1.2 -r1.2.62.1
--- sd/source/filter/eppt/pptexanimations.cxx	26 Nov 2004 19:50:21 -0000	1.2
+++ sd/source/filter/eppt/pptexanimations.cxx	19 Jan 2005 14:25:42 -0000	1.2.62.1
@@ -380,42 +380,6 @@ const sal_Char* transition::find( const 
 	return pRet;
 }
 
-ExContainer::ExContainer( SvStream& rSt, const sal_uInt16 nRecType, const sal_uInt16 nInstance ) :
-	rStrm	( rSt )
-{
-	rStrm << (sal_uInt32)( ( 0xf | ( nInstance << 4 ) ) | ( nRecType << 16 ) ) << (sal_uInt32)0;
-	nContPos = rStrm.Tell();
-}
-ExContainer::~ExContainer()
-{
-	sal_uInt32 nPos = rStrm.Tell();
-	sal_uInt32 nSize= nPos - nContPos;
-	if ( nSize )
-	{
-		rStrm.Seek( nContPos - 4 );
-		rStrm << nSize;
-		rStrm.Seek( nPos );
-	}
-}
-
-ExAtom::ExAtom( SvStream& rSt, const sal_uInt16 nRecType, const sal_uInt16 nInstance, const sal_uInt8 nVersion ) :
-	rStrm	( rSt )
-{
-	rStrm << (sal_uInt32)( ( nVersion | ( nInstance << 4 ) ) | ( nRecType << 16 ) ) << (sal_uInt32)0;
-	nContPos = rStrm.Tell();
-}
-ExAtom::~ExAtom()
-{
-	sal_uInt32 nPos = rStrm.Tell();
-	sal_uInt32 nSize= nPos - nContPos;
-	if ( nSize )
-	{
-		rStrm.Seek( nContPos - 4 );
-		rStrm << nSize;
-		rStrm.Seek( nPos );
-	}
-}
-
 SvStream& operator<<(SvStream& rOut, AnimationNode& rNode )
 {
 	rOut << rNode.mnU1;
@@ -503,7 +467,7 @@ void AnimationExporter::exportNode( SvSt
 	sal_Bool bTakeBackInteractiveSequenceTimingForChild = sal_False;
 	sal_Int16 nFillDefault = GetFillMode( xNode, nFDef );
 
-	ExContainer aContainer( rStrm, nContainerRecType, nInstance );
+	EscherExContainer aContainer( rStrm, nContainerRecType, nInstance );
 	switch( xNode->getType() )
 	{
 		case AnimationNodeType::CUSTOM :
@@ -546,7 +510,7 @@ void AnimationExporter::exportNode( SvSt
 		case AnimationNodeType::ITERATE :
 		{
 			{
-				ExAtom aAnimNodeExAtom( rStrm, DFF_msofbtAnimNode );
+				EscherExAtom aAnimNodeExAtom( rStrm, DFF_msofbtAnimNode );
 				AnimationNode aAnim;
 				rtl_zeroMemory( &aAnim, sizeof( aAnim ) );
 				aAnim.mnGroupType = mso_Anim_GroupType_PAR;
@@ -578,7 +542,7 @@ void AnimationExporter::exportNode( SvSt
 			exportAnimValue( rStrm, xNode, sal_False );
 
 /*
-			ExContainer aContainer( rStrm, DFF_msofbtAnimGroup, 1 );
+			EscherExContainer aContainer( rStrm, DFF_msofbtAnimGroup, 1 );
 			exportAnimNode( rStrm, xNode, pParent, nGroupLevel + 1, nFillDefault );
 			exportAnimPropertySet( rStrm, xNode );
 			exportAnimEvent( rStrm, xNode, 0 );
@@ -680,7 +644,7 @@ void AnimationExporter::exportNode( SvSt
 void AnimationExporter::exportAnimNode( SvStream& rStrm, const Reference< XAnimationNode >& xNode,
 		const ::com::sun::star::uno::Reference< ::com::sun::star::animations::XAnimationNode >* pParent, const sal_Int32 nGroupLevel, const sal_Int16 nFillDefault )
 {
-	ExAtom			aAnimNodeExAtom( rStrm, DFF_msofbtAnimNode );
+	EscherExAtom	aAnimNodeExAtom( rStrm, DFF_msofbtAnimNode );
 	AnimationNode	aAnim;
 	rtl_zeroMemory( &aAnim, sizeof( aAnim ) );
 
@@ -791,7 +755,7 @@ sal_Int16 AnimationExporter::exportAnimP
 {
 	sal_Int16 nNodeType = ::com::sun::star::presentation::EffectNodeType::DEFAULT;
 
-	ExContainer aAnimPropertySet( rStrm, DFF_msofbtAnimPropertySet );
+	EscherExContainer aAnimPropertySet( rStrm, DFF_msofbtAnimPropertySet );
 	const ::com::sun::star::uno::Any* pAny[ DFF_ANIM_PROPERTY_ID_COUNT ];
 	rtl_zeroMemory( pAny, sizeof( pAny ) );
 
@@ -1054,7 +1018,7 @@ sal_Bool AnimationExporter::exportAnimPr
 }
 void AnimationExporter::exportAnimPropertyString( SvStream& rStrm, const sal_uInt16 nPropertyId, const rtl::OUString& rVal, const TranslateMode eTranslateMode )
 {
-	ExAtom aExAtom( rStrm, DFF_msofbtAnimAttributeValue, nPropertyId );
+	EscherExAtom aExAtom( rStrm, DFF_msofbtAnimAttributeValue, nPropertyId );
 	sal_uInt8 nType = DFF_ANIM_PROP_TYPE_UNISTRING;
 	rStrm << nType;
 	rtl::OUString aStr( rVal );
@@ -1065,7 +1029,7 @@ void AnimationExporter::exportAnimProper
 
 void AnimationExporter::exportAnimPropertyFloat( SvStream& rStrm, const sal_uInt16 nPropertyId, const double& rVal, const TranslateMode eTranslateMode )
 {
-	ExAtom aExAtom( rStrm, DFF_msofbtAnimAttributeValue, nPropertyId );
+	EscherExAtom aExAtom( rStrm, DFF_msofbtAnimAttributeValue, nPropertyId );
 	sal_uInt8 nType = DFF_ANIM_PROP_TYPE_FLOAT;
 	float fFloat = (float)rVal;
 	rStrm << nType
@@ -1074,7 +1038,7 @@ void AnimationExporter::exportAnimProper
 
 void AnimationExporter::exportAnimPropertyuInt32( SvStream& rStrm, const sal_uInt16 nPropertyId, const sal_uInt32 nVal, const TranslateMode eTranslateMode )
 {
-	ExAtom aExAtom( rStrm, DFF_msofbtAnimAttributeValue, nPropertyId );
+	EscherExAtom aExAtom( rStrm, DFF_msofbtAnimAttributeValue, nPropertyId );
 	sal_uInt8 nType = DFF_ANIM_PROP_TYPE_INT32 ;
 	rStrm << nType
 		  << nVal;
@@ -1082,7 +1046,7 @@ void AnimationExporter::exportAnimProper
 
 void AnimationExporter::exportAnimPropertyByte( SvStream& rStrm, const sal_uInt16 nPropertyId, const sal_uInt8 nVal, const TranslateMode eTranslateMode )
 {
-	ExAtom aExAtom( rStrm, DFF_msofbtAnimAttributeValue, nPropertyId );
+	EscherExAtom aExAtom( rStrm, DFF_msofbtAnimAttributeValue, nPropertyId );
 	sal_uInt8 nType = DFF_ANIM_PROP_TYPE_BYTE;
 	rStrm << nType
 		  << nVal;
@@ -1098,7 +1062,7 @@ void AnimationExporter::writeZString( Sv
 
 void AnimationExporter::exportAnimAction( SvStream& rStrm, const Reference< XAnimationNode >& xNode )
 {
-	ExAtom aExAtom( rStrm, DFF_msofbtAnimAction );
+	EscherExAtom aExAtom( rStrm, DFF_msofbtAnimAction );
 
 	sal_Int32 nConcurrent = 1;
 	sal_Int32 nNextAction = 1;
@@ -1245,9 +1209,9 @@ void AnimationExporter::exportAnimEvent(
 		};
 		if ( bCreateEvent )
 		{
-			ExContainer aAnimEvent( rStrm, DFF_msofbtAnimEvent, i + 1 );
+			EscherExContainer aAnimEvent( rStrm, DFF_msofbtAnimEvent, i + 1 );
 			{
-				ExAtom aAnimTrigger( rStrm, DFF_msofbtAnimTrigger );
+				EscherExAtom aAnimTrigger( rStrm, DFF_msofbtAnimTrigger );
 				rStrm << nU1
 					  << nTrigger
 					  << nU3
@@ -1393,9 +1357,9 @@ void AnimationExporter::exportAnimateSet
 	Reference< XAnimateSet > xSet( xNode, UNO_QUERY );
 	if( xSet.is() )
 	{
-		ExContainer aAnimateSet( rStrm, DFF_msofbtAnimateSet, 0 );
+		EscherExContainer aAnimateSet( rStrm, DFF_msofbtAnimateSet, 0 );
 		{
-			ExAtom aAnimateSetData( rStrm, DFF_msofbtAnimateSetData );
+			EscherExAtom aAnimateSetData( rStrm, DFF_msofbtAnimateSetData );
 			sal_uInt32 nId1 = 1;			// ??
 			sal_uInt32 nId2 = 1;			// ??
 			rStrm << nId1 << nId2;
@@ -1472,9 +1436,9 @@ void AnimationExporter::exportAnimate( S
 		Any aFrom( xAnimate->getFrom() );
 		Any aTo  ( xAnimate->getTo() );
 
-		ExContainer aContainer( rStrm, DFF_msofbtAnimate, 0 );
+		EscherExContainer aContainer( rStrm, DFF_msofbtAnimate, 0 );
 		{
-			ExAtom	aAnimateData( rStrm, DFF_msofbtAnimateData );
+			EscherExAtom	aAnimateData( rStrm, DFF_msofbtAnimateData );
 			sal_uInt32 nBits = 0x38;
 			sal_Int16 nTmp = xAnimate->getCalcMode();
 			sal_uInt32 nCalcMode = /* (nTmp == AnimationCalcMode::FORMULA) ? 2 : */ (nTmp == AnimationCalcMode::LINEAR) ? 1 : 0;
@@ -1506,12 +1470,12 @@ void AnimationExporter::exportAnimate( S
 
 void AnimationExporter::exportAnimateTarget( SvStream& rStrm, const Reference< XAnimationNode >& xNode, const sal_uInt32 nForceAttributeNames )
 {
-	ExContainer aAnimateTarget( rStrm, DFF_msofbtAnimateTarget, 0 );
+	EscherExContainer aAnimateTarget( rStrm, DFF_msofbtAnimateTarget, 0 );
 	Reference< XAnimate > xAnimate( xNode, UNO_QUERY );
 	if ( xAnimate.is() )
 	{
 		{
-			ExAtom aAnimateTargetSettings( rStrm, DFF_msofbtAnimateTargetSettings, 0 );
+			EscherExAtom aAnimateTargetSettings( rStrm, DFF_msofbtAnimateTargetSettings, 0 );
 			// nBits %0001: additive, %0010: accumulate, %0100: attributeName, %1000: transformtype
 			// nAdditive 0 = base, 1 = sum, 2 = replace, 3 = multiply, 4 = none
 			// nAccumulate 0 = none, 1 = always
@@ -1549,7 +1513,7 @@ void AnimationExporter::exportAnimateTar
 		}
 		if ( xAnimate->getAttributeName().getLength() || nForceAttributeNames )
 		{
-			ExContainer aAnimateAttributeNames( rStrm, DFF_msofbtAnimateAttributeNames, 1 );
+			EscherExContainer aAnimateAttributeNames( rStrm, DFF_msofbtAnimateAttributeNames, 1 );
 			rtl::OUString aAttributeName( xAnimate->getAttributeName() );
 			if ( nForceAttributeNames )
 			{
@@ -1625,10 +1589,10 @@ void AnimationExporter::exportAnimateTar
 	}
 	if ( xShape.is() || bCreate2b01Atom )
 	{
-		ExContainer aAnimateTargetElement( rStrm, DFF_msofbtAnimateTargetElement );
+		EscherExContainer aAnimateTargetElement( rStrm, DFF_msofbtAnimateTargetElement );
 		if ( xShape.is() )
 		{
-			ExAtom aAnimReference( rStrm, DFF_msofbtAnimReference );
+			EscherExAtom aAnimReference( rStrm, DFF_msofbtAnimReference );
 
 			sal_uInt32 nRefType = 1;	// TODO: nRefType == 2 -> Sound;
 			sal_uInt32 nRefId = ((EscherSolverContainer&)mrSolverContainer).GetShapeId( xShape );
@@ -1641,7 +1605,7 @@ void AnimationExporter::exportAnimateTar
 		}
 		if ( bCreate2b01Atom )
 		{
-			ExAtom a2b01Atom( rStrm, 0x2b01 );
+			EscherExAtom a2b01Atom( rStrm, 0x2b01 );
 			rStrm << (sal_uInt32)1;		// ?
 		}
 	}
@@ -1654,12 +1618,12 @@ void AnimationExporter::exportAnimateKey
 	OUString aFormula( xAnimate->getFormula() );
 	if ( aKeyTimes.getLength() )
 	{
-		ExContainer aAnimKeyPoints( rStrm, DFF_msofbtAnimKeyPoints );
+		EscherExContainer aAnimKeyPoints( rStrm, DFF_msofbtAnimKeyPoints );
 		sal_Int32 i;
 		for ( i = 0; i < aKeyTimes.getLength(); i++ )
 		{
 			{
-				ExAtom aAnimKeyTime( rStrm, DFF_msofbtAnimKeyTime );
+				EscherExAtom aAnimKeyTime( rStrm, DFF_msofbtAnimKeyTime );
 				sal_Int32 nKeyTime = (sal_Int32)( aKeyTimes[ i ] * 1000.0 );
 				rStrm << nKeyTime;
 			}
@@ -1705,7 +1669,7 @@ void AnimationExporter::exportAnimValue(
 		fRepeatCount = (float)fRepeat;
 	if ( fRepeatCount != 0.0 )
 	{
-		ExAtom aExAtom( rStrm, DFF_msofbtAnimValue );
+		EscherExAtom aExAtom( rStrm, DFF_msofbtAnimValue );
 		sal_uInt32 nType = 0;
 		rStrm << nType
 			  << fRepeatCount;
@@ -1714,7 +1678,7 @@ void AnimationExporter::exportAnimValue(
 	float fAccelerate = (float)xNode->getAcceleration();
 	if ( bExportAlways || ( fAccelerate != 0.0 ) )
 	{
-		ExAtom aExAtom( rStrm, DFF_msofbtAnimValue );
+		EscherExAtom aExAtom( rStrm, DFF_msofbtAnimValue );
 		sal_uInt32 nType = 3;
 		rStrm << nType
 			  << fAccelerate;
@@ -1724,7 +1688,7 @@ void AnimationExporter::exportAnimValue(
 	float fDecelerate = (float)xNode->getDecelerate();
 	if ( bExportAlways || ( fDecelerate != 0.0 ) )
 	{
-		ExAtom aExAtom( rStrm, DFF_msofbtAnimValue );
+		EscherExAtom aExAtom( rStrm, DFF_msofbtAnimValue );
 		sal_uInt32 nType = 4;
 		rStrm << nType
 			  << fDecelerate;
@@ -1734,7 +1698,7 @@ void AnimationExporter::exportAnimValue(
 	sal_Bool bAutoReverse = xNode->getAutoReverse();
 	if ( bExportAlways || bAutoReverse )
 	{
-		ExAtom aExAtom( rStrm, DFF_msofbtAnimValue );
+		EscherExAtom aExAtom( rStrm, DFF_msofbtAnimValue );
 		sal_uInt32 nType = 5;
 		sal_uInt32 nVal  = bAutoReverse ? 1 : 0;
 		rStrm << nType
@@ -1747,9 +1711,9 @@ void AnimationExporter::exportTransition
 	Reference< XTransitionFilter > xFilter( xNode, UNO_QUERY );
 	if ( xFilter.is() )
 	{
-		ExContainer aAnimateFilter( rStrm, DFF_msofbtAnimateFilter );
+		EscherExContainer aAnimateFilter( rStrm, DFF_msofbtAnimateFilter );
 		{
-			ExAtom aAnimateFilterData( rStrm, DFF_msofbtAnimateFilterData );
+			EscherExAtom aAnimateFilterData( rStrm, DFF_msofbtAnimateFilterData );
 			sal_uInt32 nBits = 3;		// bit 0 -> use AnimAttributeValue
 										// bit 1 -> use nTransition
 
@@ -1772,10 +1736,10 @@ void AnimationExporter::exportAnimateMot
 	Reference< XAnimateMotion > xMotion( xNode, UNO_QUERY );
 	if ( xMotion.is() )
 	{
-		ExContainer aAnimateMotion( rStrm, DFF_msofbtAnimateMotion );
+		EscherExContainer aAnimateMotion( rStrm, DFF_msofbtAnimateMotion );
 		{
 			{	//SJ: Ignored from import filter
-				ExAtom aAnimateMotionData( rStrm, DFF_msofbtAnimateMotionData ); 
+				EscherExAtom aAnimateMotionData( rStrm, DFF_msofbtAnimateMotionData ); 
 				sal_uInt32 nBits = 0x98;
 				sal_uInt32 nOrigin = 0x2;
 				float fByX = 100.0;	// nBits&1
@@ -1788,7 +1752,7 @@ void AnimationExporter::exportAnimateMot
 			}
 /*			?
 			{
-				ExAtom aF137( rStrm, 0xf137 );
+				EscherExAtom aF137( rStrm, 0xf137 );
 			}
 */
 			OUString aStr;
@@ -1809,9 +1773,9 @@ void AnimationExporter::exportAnimateTra
 	{
 		if ( xTransform->getTransformType() ==  AnimationTransformType::SCALE )
 		{
-			ExContainer aAnimateScale( rStrm, DFF_msofbtAnimateScale );
+			EscherExContainer aAnimateScale( rStrm, DFF_msofbtAnimateScale );
 			{
-				ExAtom aAnimateScaleData( rStrm, DFF_msofbtAnimateScaleData );
+				EscherExAtom aAnimateScaleData( rStrm, DFF_msofbtAnimateScaleData );
 				sal_uInt32 nBits = 0;
 				sal_uInt32 nZoomContents = 1;
 				float fByX = 100.0;
@@ -1861,9 +1825,9 @@ void AnimationExporter::exportAnimateTra
 		}
 		else if ( xTransform->getTransformType() ==  AnimationTransformType::ROTATE )
 		{
-			ExContainer aAnimateRotation( rStrm, DFF_msofbtAnimateRotation );
+			EscherExContainer aAnimateRotation( rStrm, DFF_msofbtAnimateRotation );
 			{
-				ExAtom aAnimateRotationData( rStrm, DFF_msofbtAnimateRotationData );
+				EscherExAtom aAnimateRotationData( rStrm, DFF_msofbtAnimateRotationData );
 				sal_uInt32 nBits = 0;
 				sal_uInt32 nU1 = 0;
 				float fBy = 360.0;
@@ -1925,9 +1889,9 @@ void AnimationExporter::exportAnimateCol
 	Reference< XAnimateColor > xColor( xNode, UNO_QUERY );
 	if ( xColor.is() )
 	{
-		ExContainer aAnimateColor( rStrm, DFF_msofbtAnimateColor );
+		EscherExContainer aAnimateColor( rStrm, DFF_msofbtAnimateColor );
 		{
-			ExAtom aAnimateColorData( rStrm, DFF_msofbtAnimateColorData );
+			EscherExAtom aAnimateColorData( rStrm, DFF_msofbtAnimateColorData );
 			sal_uInt32 nBits = 8;
 
 			sal_Int32 nByMode, nByA, nByB, nByC;
@@ -1973,7 +1937,7 @@ void AnimationExporter::exportIterate( S
 	Reference< XIterateContainer > xIterate( xNode, UNO_QUERY );
 	if ( xIterate.is() )
 	{
-		ExAtom aAnimIteration( rStrm, DFF_msofbtAnimIteration );
+		EscherExAtom aAnimIteration( rStrm, DFF_msofbtAnimIteration );
 
 		float		fInterval = 10.0;
 		sal_Int32	nTextUnitEffect = 0;
Index: sd/source/filter/eppt/pptexanimations.hxx
===================================================================
RCS file: /cvs/graphics/sd/source/filter/eppt/pptexanimations.hxx,v
retrieving revision 1.2
retrieving revision 1.2.62.1
diff -u -p -u -p -r1.2 -r1.2.62.1
--- sd/source/filter/eppt/pptexanimations.hxx	26 Nov 2004 19:50:33 -0000	1.2
+++ sd/source/filter/eppt/pptexanimations.hxx	19 Jan 2005 14:25:42 -0000	1.2.62.1
@@ -98,23 +98,6 @@ typedef sal_uInt32 TranslateMode;
 #define TRANSLATE_MEASURE			4
 #define TRANSLATE_NUMBER_TO_STRING	8
 
-struct ExContainer
-{
-	sal_uInt32	nContPos;
-	SvStream&	rStrm;
-
-	ExContainer( SvStream& rSt, const sal_uInt16 nRecType, const sal_uInt16 nInstance = 0 );
-	~ExContainer();
-};
-struct ExAtom
-{
-	sal_uInt32	nContPos;
-	SvStream&	rStrm;
-
-	ExAtom( SvStream& rSt, const sal_uInt16 nRecType, const sal_uInt16 nInstance = 0, const sal_uInt8 nVersion = 0 );
-	~ExAtom();
-};
-
 class AnimationExporter
 {
 	::com::sun::star::uno::Any aTarget;
Index: sw/source/filter/ww8/ww8graf2.cxx
===================================================================
RCS file: /cvs/sw/sw/source/filter/ww8/ww8graf2.cxx,v
retrieving revision 1.61
retrieving revision 1.61.102.1
diff -u -p -u -p -r1.61 -r1.61.102.1
--- sw/source/filter/ww8/ww8graf2.cxx	11 Jan 2005 12:36:06 -0000	1.61
+++ sw/source/filter/ww8/ww8graf2.cxx	17 Feb 2005 12:07:15 -0000	1.61.102.1
@@ -398,6 +398,12 @@ bool SwWW8ImplReader::ReadGrafFile(Strin
 
     if (pWwFib->envr != 1) // !MAC als Creator
     {
+
+/* SJ: #i40742#, we will use the prefsize from the mtf directly.
+The scaling has been done in former days, because the wmf filter was sometimes not
+able to calculate the proper prefsize (especially if the wmf fileheader was missing)
+
+
         aWMF.SetPrefMapMode( MapMode( MAP_100TH_MM ) );
         // MetaFile auf neue Groesse skalieren und
         // neue Groesse am MetaFile setzen
@@ -411,7 +417,7 @@ bool SwWW8ImplReader::ReadGrafFile(Strin
             aWMF.Scale(aFracX, aFracY);
             aWMF.SetPrefSize(aNewSiz);
         }
-
+*/
         rpGraphic = new Graphic( aWMF );
         return true;
     }
Index: extras/source/gallery/gallery_system/sg24.sdg
===================================================================
RCS file: /cvs/installation/extras/source/gallery/gallery_system/sg24.sdg,v
retrieving revision 1.5
retrieving revision 1.5.10.1
diff -u -p -u -p -r1.5 -r1.5.10.1
Binary files /tmp/cvshVHEfB and /tmp/cvs6z1isX differ
Index: extras/source/gallery/gallery_system/sg24.sdv
===================================================================
RCS file: /cvs/installation/extras/source/gallery/gallery_system/sg24.sdv,v
retrieving revision 1.7
retrieving revision 1.7.10.1
diff -u -p -u -p -r1.7 -r1.7.10.1
Binary files /tmp/cvsD9t9Gj and /tmp/cvsCcan3F differ
Index: extras/source/gallery/gallery_system/sg24.thm
===================================================================
RCS file: /cvs/installation/extras/source/gallery/gallery_system/sg24.thm,v
retrieving revision 1.4
retrieving revision 1.4.10.1
diff -u -p -u -p -r1.4 -r1.4.10.1
Binary files /tmp/cvsz0zqt2 and /tmp/cvsMlNxTo differ
Index: extras/source/gallery/gallery_system/sg36.sdg
===================================================================
RCS file: /cvs/installation/extras/source/gallery/gallery_system/sg36.sdg,v
retrieving revision 1.4
retrieving revision 1.4.8.2
diff -u -p -u -p -r1.4 -r1.4.8.2
Binary files /tmp/cvsfgC6nL and /tmp/cvsvq1wT7 differ
Index: extras/source/gallery/gallery_system/sg36.sdv
===================================================================
RCS file: /cvs/installation/extras/source/gallery/gallery_system/sg36.sdv,v
retrieving revision 1.4
retrieving revision 1.4.8.2
diff -u -p -u -p -r1.4 -r1.4.8.2
Binary files /tmp/cvs2MKmqu and /tmp/cvsNoNc9Q differ
Index: extras/source/gallery/gallery_system/sg36.thm
===================================================================
RCS file: /cvs/installation/extras/source/gallery/gallery_system/sg36.thm,v
retrieving revision 1.4
retrieving revision 1.4.8.2
diff -u -p -u -p -r1.4 -r1.4.8.2
Binary files /tmp/cvsRVYoVd and /tmp/cvsdQZEHA differ
Index: svx/inc/escherex.hxx
===================================================================
RCS file: /cvs/graphics/svx/inc/escherex.hxx,v
retrieving revision 1.20
retrieving revision 1.19.140.3
diff -u -p -u -p -r1.20 -r1.19.140.3
--- svx/inc/escherex.hxx	21 Jan 2005 14:24:55 -0000	1.20
+++ svx/inc/escherex.hxx	9 Feb 2005 13:39:25 -0000	1.19.140.3
@@ -1017,6 +1017,23 @@ namespace com { namespace sun { namespac
 	}
 }}}
 
+struct SVX_DLLPUBLIC EscherExContainer
+{
+	sal_uInt32	nContPos;
+	SvStream&	rStrm;
+
+	EscherExContainer( SvStream& rSt, const sal_uInt16 nRecType, const sal_uInt16 nInstance = 0 );
+	~EscherExContainer();
+};
+struct SVX_DLLPUBLIC EscherExAtom
+{
+	sal_uInt32	nContPos;
+	SvStream&	rStrm;
+
+	EscherExAtom( SvStream& rSt, const sal_uInt16 nRecType, const sal_uInt16 nInstance = 0, const sal_uInt8 nVersion = 0 );
+	~EscherExAtom();
+};
+
 struct EscherPropertyValueHelper
 {
 		static sal_Bool GetPropertyValue(
Index: svx/inc/msdffimp.hxx
===================================================================
RCS file: /cvs/graphics/svx/inc/msdffimp.hxx,v
retrieving revision 1.25
retrieving revision 1.25.56.1
diff -u -p -u -p -r1.25 -r1.25.56.1
--- svx/inc/msdffimp.hxx	21 Jan 2005 14:57:56 -0000	1.25
+++ svx/inc/msdffimp.hxx	9 Feb 2005 15:20:57 -0000	1.25.56.1
@@ -491,11 +491,12 @@ protected :
 
 	// -----------------------------------------------------------------------
 
-	/*
-		folgende Methoden sind zum PowerPoint-Import zu ueberschreiben:
-	*/
 	FASTBOOL ReadDffString(SvStream& rSt, String& rTxt) const;
 	FASTBOOL ReadObjText(SvStream& rSt, SdrObject* pObj) const;
+
+	// SJ: New implementation of ReadObjText is used by Fontwork objects, because
+	// the old one does not properly import multiple paragraphs 
+	void ReadObjText( const String& rText, SdrObject* pObj ) const;
 	// -----------------------------------------------------------------------
 
 	/*
Index: svx/source/customshapes/EnhancedCustomShape2d.cxx
===================================================================
RCS file: /cvs/graphics/svx/source/customshapes/EnhancedCustomShape2d.cxx,v
retrieving revision 1.9
retrieving revision 1.8.82.2
diff -u -p -u -p -r1.9 -r1.8.82.2
--- svx/source/customshapes/EnhancedCustomShape2d.cxx	27 Jan 2005 16:16:16 -0000	1.9
+++ svx/source/customshapes/EnhancedCustomShape2d.cxx	4 Feb 2005 19:35:08 -0000	1.8.82.2
@@ -1521,8 +1521,19 @@ Rectangle EnhancedCustomShape2d::GetText
 		nIndex++;
 	Point aTopLeft( GetPoint( seqTextFrames[ nIndex ].TopLeft, sal_True, sal_True ) );
 	Point aBottomRight( GetPoint( seqTextFrames[ nIndex ].BottomRight, sal_True, sal_True ) );
+	if ( bFlipH )
+	{
+		aTopLeft.X() = aLogicRect.GetWidth() - aTopLeft.X();
+		aBottomRight.X() = aLogicRect.GetWidth() - aBottomRight.X();
+	}
+	if ( bFlipV )
+	{
+		aTopLeft.Y() = aLogicRect.GetHeight() - aTopLeft.Y();
+		aBottomRight.Y() = aLogicRect.GetHeight() - aBottomRight.Y();
+	}
 	Rectangle aRect( aTopLeft, aBottomRight );
 	aRect.Move( aLogicRect.Left(), aLogicRect.Top() );
+	aRect.Justify();
 	return aRect;
 }
 
@@ -2319,6 +2330,7 @@ SdrObject* EnhancedCustomShape2d::Create
 //		pRet->SetModel( pCustomShapeObj->GetModel() );
 		pRet->SetMergedItemSet( *this );
 	}
+/*
 	else if ( eSpType == mso_sptArc )
 	{	// the arc is something special, because sometimes the snaprect does not match
 		Rectangle aPolyBoundRect;
@@ -2428,6 +2440,7 @@ SdrObject* EnhancedCustomShape2d::Create
 			((SdrObjGroup*)pRet)->GetSubList()->NbcInsertObject( pObjCirc );
 		}
 	}
+*/
 	if ( !pRet )
 		pRet = CreatePathObj( bLineGeometryNeededOnly );
 
Index: svx/source/customshapes/EnhancedCustomShapeFontWork.cxx
===================================================================
RCS file: /cvs/graphics/svx/source/customshapes/EnhancedCustomShapeFontWork.cxx,v
retrieving revision 1.6
retrieving revision 1.6.44.1
diff -u -p -u -p -r1.6 -r1.6.44.1
--- svx/source/customshapes/EnhancedCustomShapeFontWork.cxx	7 Jan 2005 09:22:45 -0000	1.6
+++ svx/source/customshapes/EnhancedCustomShapeFontWork.cxx	28 Jan 2005 15:46:53 -0000	1.6.44.1
@@ -106,6 +106,10 @@
 #endif
 #define ITEMID_FONT         EE_CHAR_FONTINFO
 #define ITEMID_CHARSCALE_W	EE_CHAR_FONTWIDTH
+#define ITEMID_FRAMEDIR		EE_PARA_WRITINGDIR
+#ifndef _SVX_FRMDIRITEM_HXX
+#include <frmdiritem.hxx>
+#endif
 #ifndef _SVX_FONTITEM_HXX //autogen
 #include <fontitem.hxx>
 #endif
@@ -126,14 +130,30 @@
 #include <numeric>
 #include <algorithm>
 
+#ifndef _COMPHELPER_PROCESSFACTORY_HXX_
+#include <comphelper/processfactory.hxx>
+#endif
+#ifndef _COM_SUN_STAR_I18N_SCRIPTTYPE_HDL_
+#include <com/sun/star/i18n/ScriptType.hdl>
+#endif
+#ifndef _COM_SUN_STAR_I18N_XBREAKITERATOR_HPP_
+#include <com/sun/star/i18n/XBreakIterator.hpp>
+#endif
 #ifndef _BGFX_POLYPOLYGON_B2DPOLYGONTOOLS_HXX
 #include <basegfx/polygon/b2dpolypolygontools.hxx>
 #endif
+#ifndef _COM_SUN_STAR_LANG_XMULTISERVICEFACTORY_HPP_
+#include <com/sun/star/lang/XMultiServiceFactory.hpp>
+#endif
+#ifndef _COM_SUN_STAR_I18N_CHARACTERITERATORMODE_HDL_
+#include <com/sun/star/i18n/CharacterIteratorMode.hdl>
+#endif
 
 #ifndef _BGFX_POLYGON_B2DPOLYGONTOOLS_HXX
 #include <basegfx/polygon/b2dpolygontools.hxx>
 #endif
 
+using namespace com::sun::star;
 using namespace com::sun::star::uno;
 
 typedef std::vector< std::vector< double > > PolyPolygonDistances;
@@ -148,6 +168,7 @@ struct FWParagraphData					// representi
 	rtl::OUString						aString;
 	std::vector< FWCharacterData >		vCharacters;
 	Rectangle							aBoundRect;
+	sal_Int16							nFrameDirection;
 };
 struct FWTextArea						// representing multiple concluding paragraphs
 {
@@ -184,7 +205,6 @@ sal_Bool InitializeFontWorkData( const S
 		{
 			const EditTextObject& rTextObj = pParaObj->GetTextObject();
 			sal_Int16 nParagraphsLeft = rTextObj.GetParagraphCount();
-			sal_Int16 k = 0;
 
 			rFWData.nMaxParagraphsPerTextArea = ( ( nParagraphsLeft - 1 ) / nTextAreaCount ) + 1;
 
@@ -195,7 +215,10 @@ sal_Bool InitializeFontWorkData( const S
 				for ( i = 0; i < nParagraphs; i++ )
 				{
 					FWParagraphData aParagraphData;
-					aParagraphData.aString = rTextObj.GetText( k++ );
+					aParagraphData.aString = rTextObj.GetText( i );
+
+					const SfxItemSet& rParaSet = rTextObj.GetParaAttribs( i );	// retrieving some paragraph attributes
+					aParagraphData.nFrameDirection = ((SvxFrameDirectionItem&)rParaSet.Get( EE_PARA_WRITINGDIR )).GetValue();
 					aTextArea.vParagraphs.push_back( aParagraphData );
 				}
 				rFWData.vTextAreas.push_back( aTextArea );
@@ -316,12 +339,16 @@ void GetTextAreaOutline( const FWData& r
 			VirtualDevice aVirDev( 1 );
 			aVirDev.SetMapMode( MAP_100TH_MM );
 			aVirDev.SetFont( aFont );
+			aVirDev.EnableRTL( sal_True );
+			if ( aParagraphIter->nFrameDirection == FRMDIR_HORI_RIGHT_TOP )
+				aVirDev.SetLayoutMode( TEXT_LAYOUT_BIDI_RTL );
 
 			SvxCharScaleWidthItem& rCharScaleWidthItem = (SvxCharScaleWidthItem&)pCustomShape->GetMergedItem( EE_CHAR_FONTWIDTH );
 			sal_uInt16 nCharScaleWidth = rCharScaleWidthItem.GetValue();
 			long* pDXArry = NULL;
 			sal_Int32 nWidth = 0;
 
+			// VERTICAL
 			if ( bIsVertical )
 			{
 				// vertical _> each single character needs to be rotated by 90
@@ -388,16 +415,14 @@ void GetTextAreaOutline( const FWData& r
 					FontMetric aFontMetric( aVirDev.GetFontMetric() );
 					aFont.SetWidth( (sal_Int32)( (double)aFontMetric.GetWidth() * ( (double)100 / (double)nCharScaleWidth ) ) );
 					aVirDev.SetFont( aFont );
-				}
-
-
+				}		
 				FWCharacterData aCharacterData;
 				if ( aVirDev.GetTextOutlines( aCharacterData.vOutlines, rText, 0, 0, STRING_LEN, TRUE, nWidth, pDXArry ) )
 				{
 					aParagraphIter->vCharacters.push_back( aCharacterData );
 				}
 
-/*
+/* trying to retrieve each single character _> is not working well
 				sal_Int32 i;
 				for ( i = 0; i < rText.getLength(); i++ )
 				{
@@ -434,7 +459,8 @@ void GetTextAreaOutline( const FWData& r
 						rPolyPoly.Move( 0, nVerticalOffset );
 
 					// retrieving the boundrect for the paragraph
-					aParagraphIter->aBoundRect.Union( rPolyPoly.GetBoundRect() );
+					Rectangle aBoundRect( rPolyPoly.GetBoundRect() );
+					aParagraphIter->aBoundRect.Union( aBoundRect );
 				}
 				aCharacterIter++;
 			}
Index: svx/source/customshapes/EnhancedCustomShapeGeometry.cxx
===================================================================
RCS file: /cvs/graphics/svx/source/customshapes/EnhancedCustomShapeGeometry.cxx,v
retrieving revision 1.9
retrieving revision 1.8.82.2
diff -u -p -u -p -r1.9 -r1.8.82.2
--- svx/source/customshapes/EnhancedCustomShapeGeometry.cxx	27 Jan 2005 16:16:38 -0000	1.9
+++ svx/source/customshapes/EnhancedCustomShapeGeometry.cxx	4 Feb 2005 19:35:17 -0000	1.8.82.2
@@ -170,6 +170,27 @@ static const sal_Int32 mso_sptDefault162
 	2, 16200, 5400
 };
 
+static const SvxMSDffVertPair mso_sptArcVert[] =
+{
+	{ 0, 0 }, { 21600, 21600 }, { 3 MSO_I, 1 MSO_I }, { 7 MSO_I, 5 MSO_I }, { 10800, 10800 },
+	{ 0, 0 }, { 21600, 21600 }, { 3 MSO_I, 1 MSO_I }, { 7 MSO_I, 5 MSO_I }
+};
+static const sal_uInt16 mso_sptArcSegm[] =
+{
+	0xa504, 0xab00, 0x0001, 0x6001, 0x8000,
+	0xa504, 0xaa00, 0x8000
+};
+static const SvxMSDffCalculationData mso_sptArcCalc[] =
+{
+	{ 0x4009, 10800, DFF_Prop_adjustValue, 0 },
+	{ 0x2000, 0x400, 10800, 0 },
+	{ 0x400a, 10800, DFF_Prop_adjustValue, 0 },
+	{ 0x2000, 0x402, 10800, 0 },
+	{ 0x4009, 10800, DFF_Prop_adjust2Value, 0 },
+	{ 0x2000, 0x404, 10800, 0 },
+	{ 0x400a, 10800, DFF_Prop_adjust2Value, 0 },
+	{ 0x2000, 0x406, 10800, 0 }
+};
 static const sal_Int32 mso_sptArcDefault[] =
 {
 	2, 270, 0
@@ -180,16 +201,16 @@ static const SvxMSDffVertPair mso_sptSta
 };
 static const SvxMSDffHandle mso_sptArcHandle[] =
 {
-	{	MSDFF_HANDLE_FLAGS_POLAR,
-		10800, 0x100, 10800, 10800, 0x80000000, 0x7fffffff, 0x80000000, 0x7fffffff },
-	{	MSDFF_HANDLE_FLAGS_POLAR,
-		10800, 0x101, 10800, 10800, 0x80000000, 0x7fffffff, 0x80000000, 0x7fffffff }
+	{	MSDFF_HANDLE_FLAGS_POLAR | MSDFF_HANDLE_FLAGS_RADIUS_RANGE,
+		10800, 0x100, 10800, 10800, 10800, 10800, 0x80000000, 0x7fffffff },
+	{	MSDFF_HANDLE_FLAGS_POLAR | MSDFF_HANDLE_FLAGS_RADIUS_RANGE,
+		10800, 0x101, 10800, 10800, 10800, 10800, 0x80000000, 0x7fffffff }
 };
 static const mso_CustomShape msoArc =
 {
-	NULL, 0,
-	NULL, 0,
-	NULL, 0,
+	(SvxMSDffVertPair*)mso_sptArcVert, sizeof( mso_sptArcVert ) / sizeof( SvxMSDffVertPair ),
+	(sal_uInt16*)mso_sptArcSegm, sizeof( mso_sptArcSegm ) >> 1,
+	(SvxMSDffCalculationData*)mso_sptArcCalc, sizeof( mso_sptArcCalc ) / sizeof( SvxMSDffCalculationData ),
 	(sal_Int32*)mso_sptArcDefault,
 	NULL, 0,
 	21600, 21600,
Index: svx/source/msfilter/escherex.cxx
===================================================================
RCS file: /cvs/graphics/svx/source/msfilter/escherex.cxx,v
retrieving revision 1.50
retrieving revision 1.50.44.1
diff -u -p -u -p -r1.50 -r1.50.44.1
--- svx/source/msfilter/escherex.cxx	7 Jan 2005 09:23:47 -0000	1.50
+++ svx/source/msfilter/escherex.cxx	19 Jan 2005 14:24:15 -0000	1.50.44.1
@@ -257,6 +257,45 @@ using namespace vos;
 using namespace ::rtl;
 using namespace ::com::sun::star;
 
+
+// ---------------------------------------------------------------------------------------------
+
+EscherExContainer::EscherExContainer( SvStream& rSt, const sal_uInt16 nRecType, const sal_uInt16 nInstance ) :
+	rStrm	( rSt )
+{
+	rStrm << (sal_uInt32)( ( 0xf | ( nInstance << 4 ) ) | ( nRecType << 16 ) ) << (sal_uInt32)0;
+	nContPos = rStrm.Tell();
+}
+EscherExContainer::~EscherExContainer()
+{
+	sal_uInt32 nPos = rStrm.Tell();
+	sal_uInt32 nSize= nPos - nContPos;
+	if ( nSize )
+	{
+		rStrm.Seek( nContPos - 4 );
+		rStrm << nSize;
+		rStrm.Seek( nPos );
+	}
+}
+
+EscherExAtom::EscherExAtom( SvStream& rSt, const sal_uInt16 nRecType, const sal_uInt16 nInstance, const sal_uInt8 nVersion ) :
+	rStrm	( rSt )
+{
+	rStrm << (sal_uInt32)( ( nVersion | ( nInstance << 4 ) ) | ( nRecType << 16 ) ) << (sal_uInt32)0;
+	nContPos = rStrm.Tell();
+}
+EscherExAtom::~EscherExAtom()
+{
+	sal_uInt32 nPos = rStrm.Tell();
+	sal_uInt32 nSize= nPos - nContPos;
+	if ( nSize )
+	{
+		rStrm.Seek( nContPos - 4 );
+		rStrm << nSize;
+		rStrm.Seek( nPos );
+	}
+}
+
 // ---------------------------------------------------------------------------------------------
 
 EscherExClientRecord_Base::~EscherExClientRecord_Base()
Index: svx/source/msfilter/eschesdo.cxx
===================================================================
RCS file: /cvs/graphics/svx/source/msfilter/eschesdo.cxx,v
retrieving revision 1.26
retrieving revision 1.26.142.1
diff -u -p -u -p -r1.26 -r1.26.142.1
--- svx/source/msfilter/eschesdo.cxx	26 Nov 2004 14:28:29 -0000	1.26
+++ svx/source/msfilter/eschesdo.cxx	3 Feb 2005 14:27:48 -0000	1.26.142.1
@@ -205,8 +205,7 @@ Size ImplEESdrWriter::ImplMapSize( const
 
 // -------------------------------------------------------------------
 
-void ImplEESdrWriter::ImplFlipBoundingBox( ImplEESdrObject& rObj, EscherPropertyContainer& rPropOpt,
-											const Point& rRefPoint )
+void ImplEESdrWriter::ImplFlipBoundingBox( ImplEESdrObject& rObj, EscherPropertyContainer& rPropOpt )
 {
 	INT32 nAngle = rObj.GetAngle();
 	Rectangle aRect( rObj.GetRect() );
@@ -795,17 +794,8 @@ UINT32 ImplEESdrWriter::ImplWriteShape( 
 		}
 
 		if( rObj.GetAngle() )
-		{
-			if( rObj.ImplGetPropertyValue( ::rtl::OUString::createFromAscii("RotationPointX") ))
-			{
-				Point aRefPoint( *( (INT32*)rObj.GetUsrAny().getValue() ), 0 );
-				if( rObj.ImplGetPropertyValue( ::rtl::OUString::createFromAscii("RotationPointY") ))
-				{
-					aRefPoint.Y() = *( (INT32*)rObj.GetUsrAny().getValue() );
-					ImplFlipBoundingBox( rObj, aPropOpt, ImplMapPoint( aRefPoint ) );
-				}
-			}
-		}
+			ImplFlipBoundingBox( rObj, aPropOpt );
+
 		aPropOpt.Commit( mpEscherEx->GetStream() );
 		if( mpEscherEx->GetGroupLevel() > 1 )
 		{
@@ -879,7 +869,7 @@ void ImplEESdrWriter::ImplWriteAdditiona
 			if ( nAngle < 0 )
 				nAngle = ( 36000 + nAngle ) % 36000;
 			if ( nAngle )
-				ImplFlipBoundingBox( rObj, aPropOpt, rObj.GetRect().TopLeft() );
+				ImplFlipBoundingBox( rObj, aPropOpt );
 		}
 		else
 		{
Index: svx/source/msfilter/eschesdo.hxx
===================================================================
RCS file: /cvs/graphics/svx/source/msfilter/eschesdo.hxx,v
retrieving revision 1.8
retrieving revision 1.8.552.1
diff -u -p -u -p -r1.8 -r1.8.552.1
--- svx/source/msfilter/eschesdo.hxx	2 Apr 2004 14:08:26 -0000	1.8
+++ svx/source/msfilter/eschesdo.hxx	3 Feb 2005 14:28:12 -0000	1.8.552.1
@@ -199,8 +199,7 @@ protected:
 									EscherSolverContainer& rSolver,
 									ImplEESdrPageType ePageType );	// returns ShapeID
 
-			void				ImplFlipBoundingBox( ImplEESdrObject& rObj, EscherPropertyContainer& rPropOpt,
-													const Point& rRefPoint );
+			void				ImplFlipBoundingBox( ImplEESdrObject& rObj, EscherPropertyContainer& rPropOpt );
 			BOOL				ImplGetText( ImplEESdrObject& rObj );
 			void				ImplWriteAdditionalText(
 												ImplEESdrObject& rObj,
Index: svx/source/msfilter/msdffimp.cxx
===================================================================
RCS file: /cvs/graphics/svx/source/msfilter/msdffimp.cxx,v
retrieving revision 1.115
retrieving revision 1.112.18.7
diff -u -p -u -p -r1.115 -r1.112.18.7
--- svx/source/msfilter/msdffimp.cxx	31 Jan 2005 09:14:27 -0000	1.115
+++ svx/source/msfilter/msdffimp.cxx	10 Feb 2005 13:06:25 -0000	1.112.18.7
@@ -334,6 +334,10 @@
 #ifndef _MSDFFIMP_HXX
 #include "msdffimp.hxx" // extern sichtbare Header-Datei
 #endif
+#include "outliner.hxx"
+#include "outlobj.hxx"
+#include "editobj.hxx"
+#include "editeng.hxx"
 #ifndef _MSASHAPE_HXX
 #include "msashape.hxx"
 #endif
@@ -3922,6 +3926,71 @@ FASTBOOL SvxMSDffManager::ReadDffString(
 	return bRet;
 }
 
+// sj: I just want to set a string for a text object that may contain multiple
+// paragraphs. If I now take a look at the follwing code I get the impression that 
+// our outliner is too complicate to be used properly,
+void SvxMSDffManager::ReadObjText( const String& rText, SdrObject* pObj ) const
+{
+	SdrTextObj* pText = PTR_CAST( SdrTextObj, pObj );
+	if ( pText )
+	{
+        SdrOutliner& rOutliner = pText->ImpGetDrawOutliner();
+		rOutliner.Init( OUTLINERMODE_TEXTOBJECT );
+        rOutliner.SetMinDepth( 0 );
+
+		BOOL bOldUpdateMode = rOutliner.GetUpdateMode();
+		rOutliner.SetUpdateMode( FALSE );
+		rOutliner.SetVertical( pText->IsVerticalWriting() );
+
+		sal_uInt16 nParaIndex = 0;
+		sal_uInt32 nParaSize;
+		const sal_Unicode* pCurrent, *pBuf = rText.GetBuffer();
+		const sal_Unicode* pEnd = rText.GetBuffer() + rText.Len();
+		
+		while( pBuf < pEnd )
+		{
+			pCurrent = pBuf;
+
+			for ( nParaSize = 0, pCurrent = pBuf; pBuf < pEnd; pBuf )
+			{
+				sal_Unicode nChar = *pBuf++;
+				if ( nChar == 0xa )
+				{
+					if ( ( pBuf < pEnd ) && ( *pBuf == 0xd ) )
+						pBuf++;
+					break;
+				}
+				else if ( nChar == 0xd )
+				{
+					if ( ( pBuf < pEnd ) && ( *pBuf == 0xa ) )
+						pBuf++;
+					break;
+				}
+				else
+					nParaSize++;
+			}
+			ESelection aSelection( nParaIndex, 0, nParaIndex, 0 );
+			String aParagraph( pCurrent, (sal_uInt16)nParaSize );
+			if ( !nParaIndex && !aParagraph.Len() )					// SJ: we are crashing if the first paragraph is empty ?
+				aParagraph += (sal_Unicode)' ';						// otherwise these two lines can be removed.
+			rOutliner.Insert( aParagraph, nParaIndex, 0 );
+			rOutliner.SetParaAttribs( nParaIndex, rOutliner.GetEmptyItemSet() );
+
+			SfxItemSet aParagraphAttribs( rOutliner.GetEmptyItemSet() );
+			if ( !aSelection.nStartPos )
+				aParagraphAttribs.Put( SfxUInt16Item( EE_PARA_BULLETSTATE, FALSE ) );
+			aSelection.nStartPos = 0;
+			rOutliner.QuickSetAttribs( aParagraphAttribs, aSelection );
+			nParaIndex++;
+		}
+		OutlinerParaObject* pNewText = rOutliner.CreateParaObject();
+        rOutliner.Clear();
+        rOutliner.SetMinDepth( 0 );
+		rOutliner.SetUpdateMode( bOldUpdateMode );
+		pText->SetOutlinerParaObject( pNewText );
+	}
+}
+
 FASTBOOL SvxMSDffManager::ReadObjText(SvStream& rSt, SdrObject* pObj) const
 {
 	FASTBOOL bRet=FALSE;
@@ -4221,6 +4290,60 @@ static Size lcl_GetPrefSize(const Graphi
     return aRetSize;
 }
 
+// sj: if the parameter pSet is null, then the resulting crop bitmap will be stored in rGraf,
+// otherwise rGraf is untouched and pSet is used to store the corresponding SdrGrafCropItem
+static void lcl_ApplyCropping( const DffPropSet& rPropSet, SfxItemSet* pSet, Graphic& rGraf )
+{
+	sal_Int32 nCropTop		= (sal_Int32)rPropSet.GetPropertyValue( DFF_Prop_cropFromTop, 0 );
+	sal_Int32 nCropBottom	= (sal_Int32)rPropSet.GetPropertyValue( DFF_Prop_cropFromBottom, 0 );
+	sal_Int32 nCropLeft		= (sal_Int32)rPropSet.GetPropertyValue( DFF_Prop_cropFromLeft, 0 );
+	sal_Int32 nCropRight	= (sal_Int32)rPropSet.GetPropertyValue( DFF_Prop_cropFromRight, 0 );
+
+	if( nCropTop || nCropBottom || nCropLeft || nCropRight )
+	{
+		double      fFactor;
+		Size        aCropSize;
+		BitmapEx    aCropBitmap;
+		sal_uInt32  nTop( 0 ),  nBottom( 0 ), nLeft( 0 ), nRight( 0 );
+
+		if ( pSet )	// use crop attributes ?
+			aCropSize = lcl_GetPrefSize( rGraf, MAP_100TH_MM );
+		else
+		{
+			aCropBitmap = rGraf.GetBitmapEx();
+			aCropSize = aCropBitmap.GetSizePixel();
+		}
+		if ( nCropTop )
+		{
+			fFactor = (double)nCropTop / 65536.0;
+			nTop = (sal_uInt32)( ( (double)( aCropSize.Height() + 1 ) * fFactor ) + 0.5 );
+		}
+		if ( nCropBottom )
+		{
+			fFactor = (double)nCropBottom / 65536.0;
+			nBottom = (sal_uInt32)( ( (double)( aCropSize.Height() + 1 ) * fFactor ) + 0.5 );
+		}
+		if ( nCropLeft )
+		{
+			fFactor = (double)nCropLeft / 65536.0;
+			nLeft = (sal_uInt32)( ( (double)( aCropSize.Width() + 1 ) * fFactor ) + 0.5 );
+		}
+		if ( nCropRight )
+		{
+			fFactor = (double)nCropRight / 65536.0;
+			nRight = (sal_uInt32)( ( (double)( aCropSize.Width() + 1 ) * fFactor ) + 0.5 );
+		}
+		if ( pSet )	// use crop attributes ?
+			pSet->Put( SdrGrafCropItem( nLeft, nTop, nRight, nBottom ) );
+		else
+		{
+    		Rectangle aCropRect( nLeft, nTop, aCropSize.Width() - nRight, aCropSize.Height() - nBottom );
+	    	aCropBitmap.Crop( aCropRect );
+		    rGraf = aCropBitmap;
+		}
+	}
+}
+
 SdrObject* SvxMSDffManager::ImportGraphic( SvStream& rSt, SfxItemSet& rSet, Rectangle& aBoundRect, const DffObjData& rObjData ) const
 {
 	SdrObject*  pRet = NULL;
@@ -4268,59 +4391,11 @@ SdrObject* SvxMSDffManager::ImportGraphi
 			}
 		}
 		if ( bGrfRead )
-		{	// the writer is doing it's own cropping, so this part affects only impress and calc
+		{
+			// the writer is doing it's own cropping, so this part affects only impress and calc
 			if ( GetSvxMSDffSettings() & SVXMSDFF_SETTINGS_CROP_BITMAPS )
-			{
-				sal_Int32 nCropTop		= (sal_Int32)GetPropertyValue( DFF_Prop_cropFromTop, 0 );
-				sal_Int32 nCropBottom	= (sal_Int32)GetPropertyValue( DFF_Prop_cropFromBottom, 0 );
-				sal_Int32 nCropLeft		= (sal_Int32)GetPropertyValue( DFF_Prop_cropFromLeft, 0 );
-				sal_Int32 nCropRight	= (sal_Int32)GetPropertyValue( DFF_Prop_cropFromRight, 0 );
-
-				if( nCropTop || nCropBottom || nCropLeft || nCropRight )
-				{
-					double      fFactor;
-					Size        aCropSize;
-					BitmapEx    aCropBitmap;
-					sal_uInt32  nTop( 0 ),  nBottom( 0 ), nLeft( 0 ), nRight( 0 );
-					sal_Bool    bUseCropAttributes = ( rObjData.nSpFlags & SP_FOLESHAPE ) == 0; // we do not support cropping attributes on ole objects
+				lcl_ApplyCropping( *this, ( rObjData.nSpFlags & SP_FOLESHAPE ) == 0 ? &rSet : NULL, aGraf );
 
-					if (bUseCropAttributes)
-						aCropSize = lcl_GetPrefSize(aGraf, MAP_100TH_MM);
-					else
-					{
-						aCropBitmap = aGraf.GetBitmapEx();
-						aCropSize = aCropBitmap.GetSizePixel();
-					}
-					if ( nCropTop )
-					{
-						fFactor = (double)nCropTop / 65536.0;
-						nTop = (sal_uInt32)( ( (double)( aCropSize.Height() + 1 ) * fFactor ) + 0.5 );
-					}
-					if ( nCropBottom )
-					{
-						fFactor = (double)nCropBottom / 65536.0;
-						nBottom = (sal_uInt32)( ( (double)( aCropSize.Height() + 1 ) * fFactor ) + 0.5 );
-					}
-					if ( nCropLeft )
-					{
-						fFactor = (double)nCropLeft / 65536.0;
-						nLeft = (sal_uInt32)( ( (double)( aCropSize.Width() + 1 ) * fFactor ) + 0.5 );
-					}
-					if ( nCropRight )
-					{
-						fFactor = (double)nCropRight / 65536.0;
-						nRight = (sal_uInt32)( ( (double)( aCropSize.Width() + 1 ) * fFactor ) + 0.5 );
-					}
-					if ( bUseCropAttributes )
-						rSet.Put( SdrGrafCropItem( nLeft, nTop, nRight, nBottom ) );
-					else
-					{
-    					Rectangle aCropRect( nLeft, nTop, aCropSize.Width() - nRight, aCropSize.Height() - nBottom );
-	    				aCropBitmap.Crop( aCropRect );
-		    			aGraf = aCropBitmap;
-					}
-				}
-			}
 			if ( IsProperty( DFF_Prop_pictureTransparent ) )
 			{
 				UINT32 nTransColor = GetPropertyValue( DFF_Prop_pictureTransparent, 0 );
@@ -4539,7 +4614,13 @@ SdrObject* SvxMSDffManager::ImportGraphi
 	{
 		if( aLinkFileName.Len() )
 		    ((SdrGrafObj*)pRet)->SetGraphicLink( aLinkFileName, aLinkFilterName );
-		
+
+		if ( bLinkGrf && !bGrfRead )
+		{
+			((SdrGrafObj*)pRet)->ForceSwapIn();
+			Graphic aGraf(((SdrGrafObj*)pRet)->GetGraphic());
+			lcl_ApplyCropping( *this, &rSet, aGraf );
+		}
 		((SdrGrafObj*)pRet)->ForceSwapOut();
 	}
 	
@@ -4796,21 +4877,6 @@ SdrObject* SvxMSDffManager::ImportShape(
 			if ( bGraphic )
 			{
 				pRet = ImportGraphic( rSt, aSet, aBoundRect, aObjData );
-				if ( pRet )
-				{
-					sal_Bool bFilled = ( GetPropertyValue( DFF_Prop_fNoFillHitTest ) & 16 ) != 0;
-					if ( bFilled && !IsHardAttribute( DFF_Prop_fFilled ) )	// shapes are filled by default, but graphic objects not
-					{														// we are taking care of this here
-						sal_uInt32 nOpt = GetPropertyValue( DFF_Prop_fNoFillHitTest  );
-						SetPropertyValue( DFF_Prop_fNoFillHitTest, nOpt & ~16 );
-					}
-					BOOL bLine = ( GetPropertyValue( DFF_Prop_fNoLineDrawDash ) & 8 ) != 0;
-					if ( bLine && !IsHardAttribute( DFF_Prop_fLine ) )
-					{
-						sal_uInt32 nOpt = GetPropertyValue( DFF_Prop_fNoLineDrawDash );
-						SetPropertyValue( DFF_Prop_fNoFillHitTest, nOpt & ~8 );
-					}
-				}
 				nSpFlags &=~ ( SP_FFLIPH | SP_FFLIPV );			// #68396#
 			}
 			else
@@ -4828,23 +4894,21 @@ SdrObject* SvxMSDffManager::ImportShape(
 					{
 
 						ApplyAttributes( rSt, aSet, aObjData.eShapeType, aObjData.nSpFlags );
+
 // the com.sun.star.drawing.EnhancedCustomShapeEngine is default, so we do not need to set a hard attribute
 //						aSet.Put( SdrCustomShapeEngineItem( String::CreateFromAscii( "com.sun.star.drawing.EnhancedCustomShapeEngine" ) ) );
 						pRet = new SdrObjCustomShape();
 						pRet->SetModel( pSdrModel );
 
+						sal_Bool bIsFontwork = ( GetPropertyValue( DFF_Prop_gtextFStrikethrough, 0 ) & 0x4000 ) != 0;
+
 						// in case of a FontWork, the text is set by the escher import
-						if ( GetPropertyValue( DFF_Prop_gtextFStrikethrough, 0 ) & 0x4000 )	// Is FontWork
+						if ( bIsFontwork )
 						{
 							String				aObjectText;
 							String				aFontName;
 							MSO_GeoTextAlign	eGeoTextAlign;
 
-							if ( SeekToContent( DFF_Prop_gtextUNICODE, rSt ) )
-							{
-								MSDFFReadZString( rSt, aObjectText, GetPropertyValue( DFF_Prop_gtextUNICODE ), TRUE );
-								((SdrObjCustomShape*)pRet)->SetText( aObjectText );
-							}
 							if ( SeekToContent( DFF_Prop_gtextFont, rSt ) )
 							{
 								SvxFontItem aLatin, aAsian, aComplex;
@@ -4853,6 +4917,18 @@ SdrObject* SvxMSDffManager::ImportShape(
 								MSDFFReadZString( rSt, aFontName, GetPropertyValue( DFF_Prop_gtextFont ), TRUE );
 								aSet.Put( SvxFontItem( aLatin.GetFamily(), aFontName, aLatin.GetStyleName() ) );
 							}
+
+							// SJ TODO: Vertical Writing is not correct, instead this should be
+							// replaced through "CharacterRotation" by 90, therefore a new Item has to be
+							// supported by svx core, api and xml file format
+							((SdrObjCustomShape*)pRet)->SetVerticalWriting( ( GetPropertyValue( DFF_Prop_gtextFStrikethrough, 0 ) & 0x2000 ) != 0 );
+
+							if ( SeekToContent( DFF_Prop_gtextUNICODE, rSt ) )
+							{
+								MSDFFReadZString( rSt, aObjectText, GetPropertyValue( DFF_Prop_gtextUNICODE ), TRUE );
+								ReadObjText( aObjectText, pRet );
+							}
+
 							eGeoTextAlign = ( (MSO_GeoTextAlign)GetPropertyValue( DFF_Prop_gtextAlign, mso_alignTextCenter ) );
 							{
 								SdrTextHorzAdjust eHorzAdjust;
@@ -4882,16 +4958,220 @@ SdrObject* SvxMSDffManager::ImportShape(
 							}
 							if ( GetPropertyValue( DFF_Prop_gtextFStrikethrough, 0 ) & 0x1000 )	// SJ: Font Kerning On ?
 								aSet.Put( SvxKerningItem( 1, EE_CHAR_KERNING ) );
-
-							// SJ TODO: Vertical Writing is not correct, instead this should be
-							// replaced through "CharacterRotation" by 90, therefore a new Item has to be
-							// supported by svx core, api and xml file format
-							((SdrObjCustomShape*)pRet)->SetVerticalWriting( ( GetPropertyValue( DFF_Prop_gtextFStrikethrough, 0 ) & 0x2000 ) != 0 );
 						}
 						pRet->SetMergedItemSet( aSet );
-						((SdrObjCustomShape*)pRet)->MergeDefaultAttributes();
-						pRet->SetSnapRect( aBoundRect );
+						
+						// sj: taking care of rtl, ltr. In case of fontwork mso. seems not to be able to set
+						// proper text directions, instead the text default is depending to the string.
+						// so we have to calculate the a text direction from string:
+						if ( bIsFontwork )
+						{
+							OutlinerParaObject* pParaObj = ((SdrObjCustomShape*)pRet)->GetOutlinerParaObject();
+							if ( pParaObj )
+							{
+								SdrOutliner& rOutliner = ((SdrObjCustomShape*)pRet)->ImpGetDrawOutliner();
+								BOOL bOldUpdateMode = rOutliner.GetUpdateMode();
+								SdrModel* pModel = pRet->GetModel();
+								if ( pModel )
+									rOutliner.SetStyleSheetPool( (SfxStyleSheetPool*)pModel->GetStyleSheetPool() );
+								rOutliner.SetUpdateMode( FALSE );
+								rOutliner.SetMinDepth( 0 );
+								rOutliner.SetText( *pParaObj );
+								VirtualDevice aVirDev( 1 );
+								aVirDev.SetMapMode( MAP_100TH_MM );
+								sal_uInt32 i, nParagraphs = rOutliner.GetParagraphCount();
+								for ( i = 0; i < nParagraphs; i++ )
+								{
+									BOOL bIsRTL = aVirDev.GetTextIsRTL( rOutliner.GetText( rOutliner.GetParagraph( i ) ), 0, STRING_LEN );
+									if ( bIsRTL )
+									{
+										SfxItemSet aSet( rOutliner.GetParaAttribs( i ) );
+										aSet.Put( SvxFrameDirectionItem( FRMDIR_HORI_RIGHT_TOP, EE_PARA_WRITINGDIR ) );
+										rOutliner.SetParaAttribs( i, aSet, false );
+										OutlinerParaObject* pNewText = rOutliner.CreateParaObject();
+										rOutliner.Init( OUTLINERMODE_TEXTOBJECT );
+										((SdrObjCustomShape*)pRet)->NbcSetOutlinerParaObject( pNewText );
+									}
+								}
+						        rOutliner.Clear();
+								rOutliner.SetMinDepth( 0 );
+								rOutliner.SetUpdateMode( bOldUpdateMode );
+							}
+						}
 
+						// mso_sptArc special treating:
+						// sj: since we actually can't render the arc because of its weird SnapRect settings,
+						// we will create a new CustomShape, that can be saved/loaded without problems.
+						// We will change the shape type, so this code applys only if importing arcs from msoffice.
+						if ( aObjData.eShapeType == mso_sptArc )
+						{
+							const rtl::OUString	sAdjustmentValues( RTL_CONSTASCII_USTRINGPARAM ( "AdjustmentValues" ) );
+							const rtl::OUString	sCoordinates( RTL_CONSTASCII_USTRINGPARAM ( "Coordinates" ) );
+							const rtl::OUString	sHandles( RTL_CONSTASCII_USTRINGPARAM ( "Handles" ) );
+							const rtl::OUString	sEquations( RTL_CONSTASCII_USTRINGPARAM ( "Equations" ) );
+							const rtl::OUString	sViewBox( RTL_CONSTASCII_USTRINGPARAM ( "ViewBox" ) );
+							const rtl::OUString	sPath( RTL_CONSTASCII_USTRINGPARAM ( "Path" ) );
+							const rtl::OUString	sTextFrames( RTL_CONSTASCII_USTRINGPARAM ( "TextFrames" ) );
+							SdrCustomShapeGeometryItem aGeometryItem( (SdrCustomShapeGeometryItem&)((SdrObjCustomShape*)pRet)->GetMergedItem( SDRATTR_CUSTOMSHAPE_GEOMETRY ) );
+							com::sun::star::uno::Sequence< drafts::com::sun::star::drawing::EnhancedCustomShapeParameterPair> seqCoordinates;
+							com::sun::star::uno::Sequence< drafts::com::sun::star::drawing::EnhancedCustomShapeAdjustmentValue > seqAdjustmentValues;
+
+							// before clearing the GeometryItem we have to store the current Coordinates
+							const uno::Any* pAny = ((SdrCustomShapeGeometryItem&)aGeometryItem).GetPropertyValueByName( sPath, sCoordinates );
+							Rectangle aPolyBoundRect;							
+							if ( pAny && ( *pAny >>= seqCoordinates ) && ( seqCoordinates.getLength() >= 4 ) )
+							{
+								sal_Int32 nPtNum, nNumElemVert = seqCoordinates.getLength();
+								XPolygon aXP( (sal_uInt16)nNumElemVert );
+								const EnhancedCustomShapeParameterPair* pTmp = seqCoordinates.getArray();
+								for ( nPtNum = 0; nPtNum < nNumElemVert; nPtNum++ )
+								{
+									Point aP;
+									seqCoordinates[ nPtNum ].First.Value >>= aP.X();
+									seqCoordinates[ nPtNum ].Second.Value >>= aP.Y();
+									aXP[ (sal_uInt16)nPtNum ] = aP;
+								}
+								aPolyBoundRect = Rectangle( aXP.GetBoundRect() );
+							}
+							else
+								aPolyBoundRect = Rectangle( -21600, 0, 21600, 43200 );	// defaulting
+
+							// clearing items, so MergeDefaultAttributes will set the corresponding defaults from EnhancedCustomShapeGeometry
+							aGeometryItem.ClearPropertyValue( sHandles );
+							aGeometryItem.ClearPropertyValue( sEquations );
+							aGeometryItem.ClearPropertyValue( sViewBox );
+							aGeometryItem.ClearPropertyValue( sPath );
+
+							sal_Int32 nEndAngle = 9000;
+							sal_Int32 nStartAngle = 0;
+							pAny = ((SdrCustomShapeGeometryItem&)aGeometryItem).GetPropertyValueByName( sAdjustmentValues );
+							if ( pAny && ( *pAny >>= seqAdjustmentValues ) && seqAdjustmentValues.getLength() > 1 )
+							{
+								double fNumber;
+								if ( seqAdjustmentValues[ 0 ].State == com::sun::star::beans::PropertyState_DIRECT_VALUE )
+								{
+									seqAdjustmentValues[ 0 ].Value >>= fNumber;
+									nEndAngle = NormAngle360( - (sal_Int32)fNumber * 100 );
+								}
+								else
+								{
+									fNumber = 270.0;
+									seqAdjustmentValues[ 0 ].Value <<= fNumber;
+									seqAdjustmentValues[ 0 ].State = com::sun::star::beans::PropertyState_DIRECT_VALUE;		// so this value will properly be stored
+								}
+
+								if ( seqAdjustmentValues[ 1 ].State == com::sun::star::beans::PropertyState_DIRECT_VALUE )
+								{
+									seqAdjustmentValues[ 1 ].Value >>= fNumber;
+									nStartAngle = NormAngle360( - (sal_Int32)fNumber * 100 );
+								}
+								else
+								{
+									fNumber = 0.0;
+									seqAdjustmentValues[ 0 ].Value <<= fNumber;
+									seqAdjustmentValues[ 1 ].State = com::sun::star::beans::PropertyState_DIRECT_VALUE;
+								}
+								
+								PropertyValue aPropVal;
+								aPropVal.Name = sAdjustmentValues;
+								aPropVal.Value <<= seqAdjustmentValues;
+								aGeometryItem.SetPropertyValue( aPropVal );		// storing the angle attribute
+							}
+							if ( nStartAngle != nEndAngle )
+							{
+								XPolygon aXPoly( aPolyBoundRect.Center(), aPolyBoundRect.GetWidth() / 2, aPolyBoundRect.GetHeight() / 2,
+									(USHORT)nStartAngle / 10, (USHORT)nEndAngle / 10, TRUE );
+								Rectangle aPolyPieRect( aXPoly.GetBoundRect() );
+
+								double	fYScale, fXScale;
+								double	fYOfs, fXOfs;
+
+								Point aP( aBoundRect.Center() );
+								Size aS( aBoundRect.GetSize() );
+								aP.X() -= aS.Width() / 2;
+								aP.Y() -= aS.Height() / 2;
+								Rectangle aLogicRect( aP, aS );
+
+								fYOfs = fXOfs = 0.0;
+
+								if ( aPolyBoundRect.GetWidth() && aPolyPieRect.GetWidth() )
+								{
+									fXScale = (double)aLogicRect.GetWidth() / (double)aPolyPieRect.GetWidth();
+									if ( nSpFlags & SP_FFLIPH )
+										fXOfs = ( (double)aPolyPieRect.Right() - (double)aPolyBoundRect.Right() ) * fXScale;
+									else
+										fXOfs = ( (double)aPolyBoundRect.Left() - (double)aPolyPieRect.Left() ) * fXScale;
+								}
+								if ( aPolyBoundRect.GetHeight() && aPolyPieRect.GetHeight() )
+								{
+									fYScale = (double)aLogicRect.GetHeight() / (double)aPolyPieRect.GetHeight();
+									if ( nSpFlags & SP_FFLIPV )
+										fYOfs = ( (double)aPolyPieRect.Bottom() - (double)aPolyBoundRect.Bottom() ) * fYScale;
+									else
+										fYOfs = ((double)aPolyBoundRect.Top() - (double)aPolyPieRect.Top() ) * fYScale;
+								}
+
+								fXScale = (double)aPolyBoundRect.GetWidth() / (double)aPolyPieRect.GetWidth();
+								fYScale = (double)aPolyBoundRect.GetHeight() / (double)aPolyPieRect.GetHeight();
+
+								Rectangle aOldBoundRect( aBoundRect );
+								aBoundRect = Rectangle( Point( aLogicRect.Left() + (sal_Int32)fXOfs, aLogicRect.Top() + (sal_Int32)fYOfs ),
+								 	Size( (sal_Int32)( aLogicRect.GetWidth() * fXScale ), (sal_Int32)( aLogicRect.GetHeight() * fYScale ) ) );
+
+								// creating the text frame -> scaling into (0,0),(21600,21600) destination coordinate system
+								double fTextFrameScaleX = (double)21600 / (double)aPolyBoundRect.GetWidth();
+								double fTextFrameScaleY = (double)21600 / (double)aPolyBoundRect.GetHeight();
+								sal_Int32 nLeft  = (sal_Int32)(( aPolyPieRect.Left()  - aPolyBoundRect.Left() ) * fTextFrameScaleX );
+								sal_Int32 nTop   = (sal_Int32)(( aPolyPieRect.Top()   - aPolyBoundRect.Top() )  * fTextFrameScaleY );
+								sal_Int32 nRight = (sal_Int32)(( aPolyPieRect.Right() - aPolyBoundRect.Left() ) * fTextFrameScaleX );
+								sal_Int32 nBottom= (sal_Int32)(( aPolyPieRect.Bottom()- aPolyBoundRect.Top() )  * fTextFrameScaleY );
+								com::sun::star::uno::Sequence< drafts::com::sun::star::drawing::EnhancedCustomShapeTextFrame > aTextFrame( 1 );
+								EnhancedCustomShape2d::SetEnhancedCustomShapeParameter( aTextFrame[ 0 ].TopLeft.First,	   nLeft );
+								EnhancedCustomShape2d::SetEnhancedCustomShapeParameter( aTextFrame[ 0 ].TopLeft.Second,    nTop );
+								EnhancedCustomShape2d::SetEnhancedCustomShapeParameter( aTextFrame[ 0 ].BottomRight.First, nRight );
+								EnhancedCustomShape2d::SetEnhancedCustomShapeParameter( aTextFrame[ 0 ].BottomRight.Second,nBottom );
+								PropertyValue aProp;
+								aProp.Name = sTextFrames;
+								aProp.Value <<= aTextFrame;
+								aGeometryItem.SetPropertyValue( sPath, aProp );
+
+								// sj: taking care of the different rotation points, since the new arc is having a bigger snaprect
+								if ( mnFix16Angle )
+								{
+									sal_Int32 nAngle = mnFix16Angle;
+									if ( nSpFlags & SP_FFLIPH )
+										nAngle = 36000 - nAngle;
+									if ( nSpFlags & SP_FFLIPV )
+										nAngle = -nAngle;
+									double a = nAngle * F_PI18000;
+									double ss = sin( a );
+									double cc = cos( a );
+									Point aP1( aOldBoundRect.TopLeft() );
+									Point aC1( aBoundRect.Center() );
+									Point aP2( aOldBoundRect.TopLeft() );
+									Point aC2( aOldBoundRect.Center() );
+									RotatePoint( aP1, aC1, ss, cc );
+									RotatePoint( aP2, aC2, ss, cc );
+									aBoundRect.Move( aP2.X() - aP1.X(), aP2.Y() - aP1.Y() );
+								}
+							}
+							((SdrObjCustomShape*)pRet)->SetMergedItem( aGeometryItem );
+							((SdrObjCustomShape*)pRet)->MergeDefaultAttributes();
+
+							// now setting a new name, so the above correction is only done once when importing from ms
+							SdrCustomShapeGeometryItem aGeoName( (SdrCustomShapeGeometryItem&)((SdrObjCustomShape*)pRet)->GetMergedItem( SDRATTR_CUSTOMSHAPE_GEOMETRY ) );
+							const rtl::OUString	sType( RTL_CONSTASCII_USTRINGPARAM ( "Type" ) );
+							const rtl::OUString	sName( RTL_CONSTASCII_USTRINGPARAM ( "mso-spt100" ) );
+							PropertyValue aPropVal;
+							aPropVal.Name = sType;
+							aPropVal.Value <<= sName;
+							aGeoName.SetPropertyValue( aPropVal );
+							((SdrObjCustomShape*)pRet)->SetMergedItem( aGeoName );
+						}
+						else
+							((SdrObjCustomShape*)pRet)->MergeDefaultAttributes();
+
+						pRet->SetSnapRect( aBoundRect );
 						EnhancedCustomShape2d aCustomShape2d( pRet );
 						aTextRect = aCustomShape2d.GetTextRect();
 						bIsCustomShape = TRUE;
@@ -6753,7 +7033,13 @@ BOOL SvxMSDffManager::GetBLIPDirect(SvSt
 			String aEmptyStr;
 			nRes = pGF->ImportGraphic( rData, aEmptyStr, *pGrStream, GRFILTER_FORMAT_DONTKNOW );
 
-			if( bMtfBLIP && ( GRFILTER_OK == nRes ) && ( rData.GetType() == GRAPHIC_GDIMETAFILE ) )
+			// SJ: I40472, sometimes the aspect ratio (aMtfSize100) does not match and we get scaling problems,
+			// then it is better to use the prefsize that is stored within the metafile. Bug #72846# for what the
+			// scaling has been implemented does not happen anymore.
+			//
+			// For pict graphics we will furthermore scale the metafile, because font scaling leads to error if the
+			// dxarray is empty (this has been solved in wmf/emf but not for pict)
+			if( bMtfBLIP && ( GRFILTER_OK == nRes ) && ( rData.GetType() == GRAPHIC_GDIMETAFILE ) && ( ( nInst & 0xFFFE ) == 0x542 ) )
 			{
 				if ( ( aMtfSize100.Width() >= 1000 ) && ( aMtfSize100.Height() >= 1000 ) )
 				{	// #75956#, scaling does not work properly, if the graphic is less than 1cm
Index: svx/source/svdraw/svdoashp.cxx
===================================================================
RCS file: /cvs/graphics/svx/source/svdraw/svdoashp.cxx,v
retrieving revision 1.16
retrieving revision 1.13.44.2
diff -u -p -u -p -r1.16 -r1.13.44.2
--- svx/source/svdraw/svdoashp.cxx	28 Jan 2005 17:09:06 -0000	1.16
+++ svx/source/svdraw/svdoashp.cxx	4 Feb 2005 20:03:29 -0000	1.13.44.2
@@ -2881,6 +2881,11 @@ SdrObject* SdrObjCustomShape::CheckHit(c
 				pHitObj = (SdrObject*)this;
 		}
 	}
+	else if ( HasText() )
+	{
+		pHitObj = SdrTextObj::CheckHit( rPnt, nTol, pVisiLayer );
+	}
+
 	return pHitObj;
 }
 
Index: vcl/inc/outdev.hxx
===================================================================
RCS file: /cvs/gsl/vcl/inc/outdev.hxx,v
retrieving revision 1.55
retrieving revision 1.55.14.1
diff -u -p -u -p -r1.55 -r1.55.14.1
--- vcl/inc/outdev.hxx	13 Jan 2005 17:42:24 -0000	1.55
+++ vcl/inc/outdev.hxx	28 Jan 2005 15:42:58 -0000	1.55.14.1
@@ -130,6 +130,7 @@ class LineInfo;
 class AlphaMask;
 class FontCharMap;
 class SalLayout;
+class ImplLayoutArgs;
 
 #ifndef _COM_SUN_STAR_UNO_REFERENCE_H_
 #include <com/sun/star/uno/Reference.h>
@@ -454,9 +455,16 @@ public:
 	SAL_DLLPRIVATE static BOOL 	ImplSelectClipRegion( SalGraphics* pGraphics, const Region& rRegion, OutputDevice *pOutDev );
 	SAL_DLLPRIVATE void			ImplSetClipRegion( const Region* pRegion );
 
-    SAL_DLLPRIVATE SalLayout*   ImplLayout( const String& rOrigStr, xub_StrLen nIndex,
+    SAL_DLLPRIVATE SalLayout*   ImplLayout( const String&, xub_StrLen nIndex,
                                             xub_StrLen nLen, const Point& rLogicPos = Point(0,0),
-                                            long nLogicWidth=0, const sal_Int32* pLogicDXArray=NULL, bool bFilter = false ) const;
+                                            long nLogicWidth=0, const sal_Int32* pLogicDXArray=NULL,
+                                            bool bFilter = false ) const;
+    SAL_DLLPRIVATE ImplLayoutArgs ImplPrepareLayoutArgs( const String&,
+                                            xub_StrLen nIndex, xub_StrLen nLen,
+                                            long nPixelWidth,
+                                            const sal_Int32* pPixelDXArray ) const;
+    SAL_DLLPRIVATE SalLayout*   ImplGlyphFallbackLayout( SalLayout*, ImplLayoutArgs& ) const;
+
     SAL_DLLPRIVATE long         ImplGetTextWidth( const SalLayout& ) const;
     SAL_DLLPRIVATE void         ImplDrawTextBackground( const SalLayout& );
     SAL_DLLPRIVATE void         ImplDrawTextLines( SalLayout&, FontStrikeout eStrikeout, FontUnderline eUnderline, BOOL bWordLine, BOOL bUnderlineAbove );
@@ -989,6 +997,9 @@ public:
 
     USHORT              GetBitCount() const;
 
+    BOOL                GetTextIsRTL( const String&, xub_StrLen nIndex,
+                            xub_StrLen nLen ) const;
+    
     /** Query the existence and depth of the alpha channel
 
     	@return 0, if no alpha channel available, and the bit depth of
Index: vcl/source/gdi/outdev3.cxx
===================================================================
RCS file: /cvs/gsl/vcl/source/gdi/outdev3.cxx,v
retrieving revision 1.192
retrieving revision 1.189.10.3
diff -u -p -u -p -r1.192 -r1.189.10.3
--- vcl/source/gdi/outdev3.cxx	31 Jan 2005 13:23:19 -0000	1.192
+++ vcl/source/gdi/outdev3.cxx	4 Feb 2005 20:15:36 -0000	1.189.10.3
@@ -5888,66 +5888,19 @@ void OutputDevice::DrawStretchText( cons
 
 // -----------------------------------------------------------------------
 
-SalLayout* OutputDevice::ImplLayout( const String& rOrigStr,
-                                     xub_StrLen nMinIndex,
-                                     xub_StrLen nLen,
-                                     const Point& rLogicalPos,
-                                     long nLogicalWidth,
-                                     const sal_Int32* pDXArray,
-                                     bool bFilter
-                                     ) const
+ImplLayoutArgs OutputDevice::ImplPrepareLayoutArgs( const String& rStr,
+                                       xub_StrLen nMinIndex, xub_StrLen nLen,
+                                       long nPixelWidth, const sal_Int32* pDXArray ) const
 {
-    SalLayout* pSalLayout = NULL;
-
-    // we need a graphics
-    if( !mpGraphics )
-        if( !ImplGetGraphics() )
-            return NULL;
-
-    if( bFilter )
-    {
-        String aStr;
-        xub_StrLen nCutStart, nCutStop, nOrgLen = nLen;
-        bool bFiltered = mpGraphics->filterText( rOrigStr, aStr, nMinIndex, nLen, nCutStart, nCutStop );
-        if( ! nLen )
-            return NULL;
-
-        if( bFiltered && nCutStop != nCutStart && pDXArray )
-        {
-            if( nLen )
-            {
-                sal_Int32* pAry = (sal_Int32*)alloca(sizeof(sal_Int32)*nLen);
-                if( nCutStart > nMinIndex )
-                    memcpy( pAry, pDXArray, sizeof(sal_Int32)*(nCutStart-nMinIndex) );
-                memcpy( pAry+nCutStart-nMinIndex, pDXArray + nOrgLen - (nCutStop-nMinIndex), nLen - (nCutStop-nMinIndex) );
-                pDXArray = pAry;
-                return ImplLayout( aStr, nMinIndex, nLen, rLogicalPos, nLogicalWidth, pDXArray, false );
-            }
-            pDXArray = NULL;
-        }
-        return ImplLayout( rOrigStr, nMinIndex, nLen, rLogicalPos, nLogicalWidth, pDXArray, false );
-    }
-
-    // initialize font if needed
-    if( mbNewFont )
-        if( !ImplNewFont() )
-            return NULL;
-    if( mbInitFont )
-        ImplInitFont();
-
+	String aStr( rStr );
     // get string length for calculating extents
-    xub_StrLen nEndIndex = rOrigStr.Len();
+    xub_StrLen nEndIndex = aStr.Len();
     if( (ULONG)nMinIndex + nLen < nEndIndex )
         nEndIndex = nMinIndex + nLen;
 
     // don't bother if there is nothing to do
-    if( nMinIndex >= nEndIndex )
-        return NULL;
-
-    // recode string if needed
-    String aStr = rOrigStr;
-    if( mpFontEntry->mpConversion )
-        ImplRecodeString( mpFontEntry->mpConversion, aStr, 0, aStr.Len() );
+    if( nEndIndex < nMinIndex )
+        nEndIndex = nMinIndex;
 
     int nLayoutFlags = 0;
     if( mnTextLayoutMode & TEXT_LAYOUT_BIDI_RTL )
@@ -6035,30 +5988,81 @@ SalLayout* OutputDevice::ImplLayout( con
     int nOrientation = mpFontEntry ? mpFontEntry->mnOrientation : 0;
     aLayoutArgs.SetOrientation( nOrientation );
 
-    Point aPixelPos = ImplLogicToDevicePixel( rLogicalPos );
+    aLayoutArgs.SetLayoutWidth( nPixelWidth );
+    aLayoutArgs.SetDXArray( pDXArray );
+
+    return aLayoutArgs;
+}
+
+// -----------------------------------------------------------------------
+
+SalLayout* OutputDevice::ImplLayout( const String& rOrigStr,
+                                     xub_StrLen nMinIndex,
+                                     xub_StrLen nLen,
+                                     const Point& rLogicalPos,
+                                     long nLogicalWidth,
+                                     const sal_Int32* pDXArray,
+                                     bool bFilter ) const
+{
+    // we need a graphics
+    if( !mpGraphics )
+        if( !ImplGetGraphics() )
+            return NULL;
 
-    long nPixelWidth = 0;
-    if( nLogicalWidth )
+    String aStr = rOrigStr;
+    if( bFilter )
     {
-        nPixelWidth = ImplLogicWidthToDevicePixel( nLogicalWidth );
-        aLayoutArgs.SetLayoutWidth( nPixelWidth );
+        xub_StrLen nCutStart, nCutStop, nOrgLen = nLen;
+        bool bFiltered = mpGraphics->filterText( rOrigStr, aStr, nMinIndex, nLen, nCutStart, nCutStop );
+        if( !nLen )
+            return NULL;
+
+        if( bFiltered && nCutStop != nCutStart && pDXArray )
+        {
+            if( !nLen )
+                pDXArray = NULL;
+            else
+            {
+                sal_Int32* pAry = (sal_Int32*)alloca(sizeof(sal_Int32)*nLen);
+                if( nCutStart > nMinIndex )
+                    memcpy( pAry, pDXArray, sizeof(sal_Int32)*(nCutStart-nMinIndex) );
+                memcpy( pAry+nCutStart-nMinIndex, pDXArray + nOrgLen - (nCutStop-nMinIndex), nLen - (nCutStop-nMinIndex) );
+                pDXArray = pAry;
+            }
+        }
     }
 
-    int nLength = nEndIndex - nMinIndex;
+    // initialize font if needed
+    if( mbNewFont )
+        if( !ImplNewFont() )
+            return NULL;
+    if( mbInitFont )
+        ImplInitFont();
+
+    // convert from logical units to physical units
+    // recode string if needed
+    if( mpFontEntry->mpConversion )
+        ImplRecodeString( mpFontEntry->mpConversion, aStr, 0, aStr.Len() );
+
+    long nPixelWidth = nLogicalWidth;
+    if( nLogicalWidth && mbMap )
+        nPixelWidth = ImplLogicWidthToDevicePixel( nLogicalWidth );
     if( pDXArray && mbMap )
     {
         // convert from logical units to font units using a temporary array
-        sal_Int32* pTempDXAry = (sal_Int32*)alloca( nLength * sizeof(sal_Int32) );
+        sal_Int32* pTempDXAry = (sal_Int32*)alloca( nLen * sizeof(sal_Int32) );
         // using base position for better rounding a.k.a. "dancing characters"
         int nPixelXOfs = ImplLogicWidthToDevicePixel( rLogicalPos.X() );
-        for( int i = 0; i < nLength; ++i )
+        for( int i = 0; i < nLen; ++i )
             pTempDXAry[i] = ImplLogicWidthToDevicePixel( rLogicalPos.X() + pDXArray[i] ) - nPixelXOfs;
 
         pDXArray = pTempDXAry;
     }
-    aLayoutArgs.SetDXArray( pDXArray );
-
+    
+    ImplLayoutArgs aLayoutArgs = ImplPrepareLayoutArgs( aStr, nMinIndex, nLen, nPixelWidth, pDXArray );
+                                           
     // get matching layout object for base font
+    SalLayout* pSalLayout = NULL;
     if( mpPDFWriter )
         pSalLayout = mpPDFWriter->GetTextLayout( aLayoutArgs, &mpFontEntry->maFontSelData );
 
@@ -6072,127 +6076,147 @@ SalLayout* OutputDevice::ImplLayout( con
         pSalLayout = NULL;
     }
 
-    ImplLayoutRuns aLayoutRuns = aLayoutArgs.maRuns;
+    if( !pSalLayout )
+        return NULL;
+    
     // do glyph fallback if needed
     // #105768# avoid fallback for very small font sizes
-    if( mpFontEntry && (mpFontEntry->maFontSelData.mnHeight >= 6)
-    && (pSalLayout && aLayoutArgs.PrepareFallback()) )
-    {
-#if defined(HDU_DEBUG)
-        {
-            int nCharPos = -1;
-            bool bRTL = false;
-            fprintf(stderr,"OD:ImplLayout Glyph Fallback for");
-            for( int i=0; i<8 && aLayoutArgs.GetNextPos( &nCharPos, &bRTL); ++i )
-                fprintf(stderr," U+%04X", aLayoutArgs.mpStr[ nCharPos ] );
-            fprintf(stderr,"\n");
-            aLayoutArgs.ResetPos();
-        }
-#endif
+    if( aLayoutArgs.PrepareFallback() )
+        if( mpFontEntry && (mpFontEntry->maFontSelData.mnHeight >= 6) )
+            pSalLayout = ImplGlyphFallbackLayout( pSalLayout, aLayoutArgs );
+
+    // position, justify, etc. the layout
+    pSalLayout->AdjustLayout( aLayoutArgs );
+    pSalLayout->DrawBase() = ImplLogicToDevicePixel( rLogicalPos );
+    // adjust to right alignment if necessary
+    if( aLayoutArgs.mnFlags & SAL_LAYOUT_RIGHT_ALIGN )
+    {
+        long nRTLOffset;
+        if( pDXArray )
+            nRTLOffset = pDXArray[ nLen - 1 ];
+        else if( nPixelWidth )
+            nRTLOffset = nPixelWidth;
+        else
+            nRTLOffset = pSalLayout->GetTextWidth() / pSalLayout->GetUnitsPerPixel();
+        pSalLayout->DrawOffset().X() = -nRTLOffset;
+    }
 
-        // prepare multi level glyph fallback
-        MultiSalLayout* pMultiSalLayout = NULL;
-        aLayoutArgs.mnFlags |= SAL_LAYOUT_FOR_FALLBACK;
-
-        ImplFontSelectData aFontSelData = mpFontEntry->maFontSelData;
-        Size aFontSize( aFontSelData.mnWidth, aFontSelData.mnHeight );
-
-        // when device specific font substitution may have been performed
-        // the originally selected font then make sure that a fallback to
-        // this font is performed first
-        int nDevSpecificFallback = 0;
-        if( mpOutDevData && mpOutDevData->mpFirstFontSubstEntry )
-            nDevSpecificFallback = 1;
-
-        // try if fallback fonts support the missing unicodes
-        for( int nFallbackLevel = 1; nFallbackLevel < MAX_FALLBACK; ++nFallbackLevel )
-        {
-            // find a font family suited for glyph fallback
-            ImplFontEntry* pFallbackFont = mpFontCache->GetFallback( mpFontList,
-                maFont, aFontSize, nFallbackLevel-nDevSpecificFallback );
-            if( !pFallbackFont )
-                break;
+    return pSalLayout;
+}
 
-            aFontSelData.mpFontEntry = pFallbackFont;
-            aFontSelData.mpFontData = pFallbackFont->maFontSelData.mpFontData;
-            if( mpFontEntry )
-            {
-                // ignore falling font if it is the same as the original font
-                if( mpFontEntry->maFontSelData.mpFontData == aFontSelData.mpFontData )
-                {
-                    mpFontCache->Release( pFallbackFont );
-                    continue;
-                }
-            }
+// -----------------------------------------------------------------------
 
+SalLayout* OutputDevice::ImplGlyphFallbackLayout( SalLayout* pSalLayout, ImplLayoutArgs& rLayoutArgs ) const
+{
 #if defined(HDU_DEBUG)
-            {
-                ByteString aOrigFontName( maFont.GetName(), RTL_TEXTENCODING_UTF8);
-                ByteString aFallbackName( aFontSelData.mpFontData->GetFamilyName(),
-                    RTL_TEXTENCODING_UTF8);
-                fprintf(stderr,"\tGlyphFallback[lvl=%d] \"%s\" -> \"%s\" (q=%d)\n",
-                    nFallbackLevel, aOrigFontName.GetBuffer(), aFallbackName.GetBuffer(),
-                    aFontSelData.mpFontData->GetQuality());
-            }
+    {
+        int nCharPos = -1;
+        bool bRTL = false;
+        fprintf(stderr,"OD:ImplLayout Glyph Fallback for");
+        for( int i=0; i<8 && rLayoutArgs.GetNextPos( &nCharPos, &bRTL); ++i )
+            fprintf(stderr," U+%04X", rLayoutArgs.mpStr[ nCharPos ] );
+        fprintf(stderr,"\n");
+        rLayoutArgs.ResetPos();
+    }
 #endif
 
-            pFallbackFont->mnSetFontFlags = mpGraphics->SetFont( &aFontSelData, nFallbackLevel );
+    // prepare multi level glyph fallback
+    MultiSalLayout* pMultiSalLayout = NULL;
+    rLayoutArgs.mnFlags |= SAL_LAYOUT_FOR_FALLBACK;
+
+    ImplFontSelectData aFontSelData = mpFontEntry->maFontSelData;
+    Size aFontSize( aFontSelData.mnWidth, aFontSelData.mnHeight );
+
+    // when device specific font substitution may have been performed
+    // the originally selected font then make sure that a fallback to
+    // this font is performed first
+    int nDevSpecificFallback = 0;
+    if( mpOutDevData && mpOutDevData->mpFirstFontSubstEntry )
+        nDevSpecificFallback = 1;
+
+    // try if fallback fonts support the missing unicodes
+    ImplLayoutRuns aLayoutRuns = rLayoutArgs.maRuns;
+    for( int nFallbackLevel = 1; nFallbackLevel < MAX_FALLBACK; ++nFallbackLevel )
+    {
+        // find a font family suited for glyph fallback
+        ImplFontEntry* pFallbackFont = mpFontCache->GetFallback( mpFontList,
+            maFont, aFontSize, nFallbackLevel-nDevSpecificFallback );
+        if( !pFallbackFont )
+            break;
 
-            // create and add glyph fallback layout to multilayout
-            aLayoutArgs.ResetPos();
-            SalLayout* pFallback = mpGraphics->GetTextLayout( aLayoutArgs, nFallbackLevel );
-            if( pFallback )
+        aFontSelData.mpFontEntry = pFallbackFont;
+        aFontSelData.mpFontData = pFallbackFont->maFontSelData.mpFontData;
+        if( mpFontEntry )
+        {
+            // ignore falling font if it is the same as the original font
+            if( mpFontEntry->maFontSelData.mpFontData == aFontSelData.mpFontData )
             {
-                if( pFallback->LayoutText( aLayoutArgs ) )
-                {
-                    if( !pMultiSalLayout )
-                        pMultiSalLayout = new MultiSalLayout( *pSalLayout );
-                    pMultiSalLayout->AddFallback( *pFallback,
-                        aLayoutArgs.maRuns, aFontSelData.mpFontData );
-                }
-                else
-                    pFallback->Release();
+                mpFontCache->Release( pFallbackFont );
+                continue;
             }
-
-            mpFontCache->Release( pFallbackFont );
-
-            // break when this fallback was sufficient
-            if( !aLayoutArgs.PrepareFallback() )
-                break;
         }
 
-        // restore orig font settings
-        pSalLayout->InitFont();
+#if defined(HDU_DEBUG)
+        {
+            ByteString aOrigFontName( maFont.GetName(), RTL_TEXTENCODING_UTF8);
+            ByteString aFallbackName( aFontSelData.mpFontData->GetFamilyName(),
+                RTL_TEXTENCODING_UTF8);
+            fprintf(stderr,"\tGlyphFallback[lvl=%d] \"%s\" -> \"%s\" (q=%d)\n",
+                nFallbackLevel, aOrigFontName.GetBuffer(), aFallbackName.GetBuffer(),
+                aFontSelData.mpFontData->GetQuality());
+        }
+#endif
 
-        if( pMultiSalLayout && pMultiSalLayout->LayoutText( aLayoutArgs ) )
-            pSalLayout = pMultiSalLayout;
-    }
+        pFallbackFont->mnSetFontFlags = mpGraphics->SetFont( &aFontSelData, nFallbackLevel );
 
-    if( pSalLayout )
-    {
-        // position, justify, etc. the layout
-        aLayoutArgs.maRuns = aLayoutRuns;
-        pSalLayout->AdjustLayout( aLayoutArgs );
-        pSalLayout->DrawBase() = aPixelPos;
-        // adjust to right alignment if necessary
-        if( bRightAlign )
-        {
-            long nRTLOffset;
-            if( pDXArray )
-                nRTLOffset = pDXArray[ nLength-1 ];
-            else if( nPixelWidth )
-                nRTLOffset = nPixelWidth;
+        // create and add glyph fallback layout to multilayout
+        rLayoutArgs.ResetPos();
+        SalLayout* pFallback = mpGraphics->GetTextLayout( rLayoutArgs, nFallbackLevel );
+        if( pFallback )
+        {
+            if( pFallback->LayoutText( rLayoutArgs ) )
+            {
+                if( !pMultiSalLayout )
+                    pMultiSalLayout = new MultiSalLayout( *pSalLayout );
+                pMultiSalLayout->AddFallback( *pFallback,
+                    rLayoutArgs.maRuns, aFontSelData.mpFontData );
+            }
             else
-                nRTLOffset = pSalLayout->GetTextWidth() / pSalLayout->GetUnitsPerPixel();
-            pSalLayout->DrawOffset().X() = -nRTLOffset;
+                pFallback->Release();
         }
+
+        mpFontCache->Release( pFallbackFont );
+
+        // break when this fallback was sufficient
+        if( !rLayoutArgs.PrepareFallback() )
+            break;
     }
 
+    // restore orig font settings
+    pSalLayout->InitFont();
+    rLayoutArgs.maRuns = aLayoutRuns;
+
+    if( pMultiSalLayout && pMultiSalLayout->LayoutText( rLayoutArgs ) )
+        pSalLayout = pMultiSalLayout;
+    
     return pSalLayout;
 }
 
 // -----------------------------------------------------------------------
 
+BOOL OutputDevice::GetTextIsRTL(
+            const String& rString,
+            xub_StrLen nIndex, xub_StrLen nLen ) const
+{
+    ImplLayoutArgs aArgs = ImplPrepareLayoutArgs( rString, nIndex, nLen, 0, NULL );
+    bool bRTL = false;
+    int nCharPos = -1;
+    aArgs.GetNextPos( &nCharPos, &bRTL);
+    return (nCharPos != nIndex) ? TRUE : FALSE;
+}
+
+// -----------------------------------------------------------------------
+
 xub_StrLen OutputDevice::GetTextBreak( const String& rStr, long nTextWidth,
                                        xub_StrLen nIndex, xub_StrLen nLen,
                                        long nCharExtra, BOOL /*TODO: bCellBreaking*/ ) const
@@ -7565,8 +7589,6 @@ BOOL OutputDevice::GetTextOutlines( Poly
     {
         int nWidthFactor = pSalLayout->GetUnitsPerPixel();
         bRet = pSalLayout->GetOutline( *mpGraphics, rVector );
-        pSalLayout->Release();
-
         if( bRet )
         {
             PolyPolyVector::iterator aIt;
@@ -7578,7 +7600,6 @@ BOOL OutputDevice::GetTextOutlines( Poly
                 for( aIt = rVector.begin(); aIt != rVector.end(); ++aIt )
                     aIt->Move( aRotatedOfs.X(), aRotatedOfs.Y() );
             }
-
             if( nWidthFactor > 1 )
             {
                 double fFactor = 1.0 / nWidthFactor;
@@ -7586,6 +7607,7 @@ BOOL OutputDevice::GetTextOutlines( Poly
                     aIt->Scale( fFactor, fFactor );
             }
         }
+        pSalLayout->Release();
     }
 
     if( bOldMap )
