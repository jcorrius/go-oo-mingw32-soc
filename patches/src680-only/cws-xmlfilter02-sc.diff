--- sc/inc/ViewSettingsSequenceDefines.hxx	8 Sep 2005 17:20:50 -0000	1.5
+++ sc/inc/ViewSettingsSequenceDefines.hxx	11 Jun 2007 08:57:11 -0000	1.5.402.2
@@ -89,15 +89,19 @@
 #define SC_VERTICALSPLITMODE				"VerticalSplitMode"
 #define SC_HORIZONTALSPLITPOSITION			"HorizontalSplitPosition"
 #define SC_VERTICALSPLITPOSITION			"VerticalSplitPosition"
+#define SC_HORIZONTALSPLITPOSITION_TWIPS    "HorizontalSplitPositionTwips"
+#define SC_VERTICALSPLITPOSITION_TWIPS      "VerticalSplitPositionTwips"
 #define SC_ACTIVESPLITRANGE					"ActiveSplitRange"
 #define SC_POSITIONLEFT						"PositionLeft"
 #define SC_POSITIONRIGHT					"PositionRight"
 #define SC_POSITIONTOP						"PositionTop"
 #define SC_POSITIONBOTTOM					"PositionBottom"
+#define SC_TABLESELECTED                    "TableSelected"
 
 #define SC_TABLES							"Tables"
 #define SC_ACTIVETABLE						"ActiveTable"
 #define SC_HORIZONTALSCROLLBARWIDTH			"HorizontalScrollbarWidth"
+#define SC_RELHORIZONTALTABBARWIDTH         "RelativeHorizontalTabbarWidth"
 #define SC_ZOOMTYPE							"ZoomType"
 #define SC_ZOOMVALUE						"ZoomValue"
 #define SC_PAGEVIEWZOOMVALUE				"PageViewZoomValue"
--- sc/inc/addincol.hxx	27 Sep 2007 13:50:56 -0000	1.10
+++ sc/inc/addincol.hxx	4 Oct 2007 09:01:03 -0000	1.9.172.4
@@ -78,6 +78,10 @@
 #include <rtl/ustring.h>
 #endif
 
+#ifndef SC_SCMATRIX_HXX
+#include "scmatrix.hxx"
+#endif
+
 #include <hash_map>
 
 
@@ -162,6 +166,7 @@ public:
     USHORT                  GetHelpId() const           { return nHelpId; }
 
     const com::sun::star::uno::Sequence< com::sun::star::sheet::LocalizedName>&  GetCompNames() const;
+    BOOL                    GetExcelName( LanguageType eDestLang, String& rRetExcelName ) const;
 
     void    SetFunction( const com::sun::star::uno::Reference< com::sun::star::reflection::XIdlMethod>& rNewFunc,
                          const com::sun::star::uno::Any& rNewObj );
@@ -203,6 +208,12 @@ public:
                         // are initialized (component may have to be loaded).
     const ScUnoAddInFuncData*   GetFuncData( const String& rName, bool bComplete = false );
 
+                        /** For enumeration in ScCompiler::OpCodeMap::getAvailableMappings().
+                            @param nIndex
+                                0 <= nIndex < GetFuncCount()
+                         */
+    const ScUnoAddInFuncData*   GetFuncData( long nIndex );
+
     void                Clear();
 
 	void				LocalizeString( String& rName );	// modify rName - input: exact name
@@ -231,7 +242,7 @@ private:
 	BOOL						bHasString;
 	double						fValue;
 	String						aString;
-	ScMatrix*					pMatrix;
+	ScMatrixRef			        xMatrix;
 	com::sun::star::uno::Reference<com::sun::star::sheet::XVolatileResult> xVarRes;
 
 	void			ExecuteCallWithArgs(
@@ -258,11 +269,11 @@ public:
 
 	USHORT				GetErrCode() const		{ return nErrCode; }
 	BOOL				HasString() const		{ return bHasString; }
-	BOOL				HasMatrix() const		{ return ( pMatrix != NULL ); }
+	BOOL				HasMatrix() const		{ return ( xMatrix.Is() ); }
 	BOOL				HasVarRes() const		{ return ( xVarRes.is() ); }
 	double				GetValue() const		{ return fValue; }
 	const String&		GetString() const		{ return aString; }
-	const ScMatrix*		GetMatrix() const		{ return pMatrix; }
+	ScMatrixRef	        GetMatrix() const		{ return xMatrix; }
 	com::sun::star::uno::Reference<com::sun::star::sheet::XVolatileResult>
 						GetVarRes() const		{ return xVarRes; }
 };
--- sc/inc/cellsuno.hxx	22 May 2007 19:37:43 -0000	1.29
+++ sc/inc/cellsuno.hxx	22 Nov 2007 09:10:25 -0000	1.27.18.5
@@ -131,6 +131,12 @@
 #ifndef _COM_SUN_STAR_SHEET_XMULTIPLEOPERATION_HPP_
 #include <com/sun/star/sheet/XMultipleOperation.hpp>
 #endif
+#ifndef _COM_SUN_STAR_SHEET_XFORMULATOKENS_HPP_
+#include <com/sun/star/sheet/XFormulaTokens.hpp>
+#endif
+#ifndef _COM_SUN_STAR_SHEET_XARRAYFORMULATOKENS_HPP_
+#include <com/sun/star/sheet/XArrayFormulaTokens.hpp>
+#endif
 #ifndef _COM_SUN_STAR_SHEET_XCELLADDRESSABLE_HPP_
 #include <com/sun/star/sheet/XCellAddressable.hpp>
 #endif
@@ -212,6 +218,9 @@
 #ifndef _COM_SUN_STAR_BEANS_XTOLERANTMULTIPROPERTYSET_HPP_ 
 #include <com/sun/star/beans/XTolerantMultiPropertySet.hpp>
 #endif
+#ifndef _COM_SUN_STAR_SHEET_XEXTERNALSHEETNAME_HPP_
+#include <com/sun/star/sheet/XExternalSheetName.hpp>
+#endif
 
 #ifndef _CPPUHELPER_IMPLBASE2_HXX_
 #include <cppuhelper/implbase2.hxx>
@@ -709,6 +718,7 @@ class SC_DLLPUBLIC ScCellRangeObj : publ
 					   public com::sun::star::sheet::XCellRangeAddressable,
 					   public com::sun::star::sheet::XSheetCellRange,
 					   public com::sun::star::sheet::XArrayFormulaRange,
+					   public com::sun::star::sheet::XArrayFormulaTokens,
 					   public com::sun::star::sheet::XCellRangeData,
 					   public com::sun::star::sheet::XCellRangeFormula,
 					   public com::sun::star::sheet::XMultipleOperation,
@@ -776,6 +786,13 @@ public:
 	virtual void SAL_CALL 	setArrayFormula( const ::rtl::OUString& aFormula )
 								throw(::com::sun::star::uno::RuntimeException);
 
+                            // XArrayFormulaTokens
+    virtual ::com::sun::star::uno::Sequence< ::com::sun::star::sheet::FormulaToken > SAL_CALL getArrayTokens()
+                                throw (::com::sun::star::uno::RuntimeException);
+    virtual void SAL_CALL   setArrayTokens( const ::com::sun::star::uno::Sequence<
+                                    ::com::sun::star::sheet::FormulaToken >& aTokens )
+                                throw (::com::sun::star::uno::RuntimeException);
+
 							// XCellRangeData
 	virtual ::com::sun::star::uno::Sequence< ::com::sun::star::uno::Sequence<
 							::com::sun::star::uno::Any > > SAL_CALL getDataArray()
@@ -916,6 +933,7 @@ class ScCellObj : public ScCellRangeObj,
 				  public com::sun::star::text::XText,
 				  public com::sun::star::container::XEnumerationAccess,
 				  public com::sun::star::table::XCell,
+                  public com::sun::star::sheet::XFormulaTokens,
 				  public com::sun::star::sheet::XCellAddressable,
 				  public com::sun::star::sheet::XSheetAnnotationAnchor,
 				  public com::sun::star::text::XTextFieldsSupplier,
@@ -1027,6 +1045,13 @@ public:
 								throw(::com::sun::star::uno::RuntimeException);
 	virtual sal_Int32 SAL_CALL getError() throw(::com::sun::star::uno::RuntimeException);
 
+                            // XFormulaTokens
+    virtual ::com::sun::star::uno::Sequence< ::com::sun::star::sheet::FormulaToken > SAL_CALL getTokens()
+                                throw (::com::sun::star::uno::RuntimeException);
+    virtual void SAL_CALL   setTokens( const ::com::sun::star::uno::Sequence<
+                                    ::com::sun::star::sheet::FormulaToken >& aTokens )
+                                throw (::com::sun::star::uno::RuntimeException);
+
 							// XCellAddressable
 	virtual ::com::sun::star::table::CellAddress SAL_CALL getCellAddress()
 								throw(::com::sun::star::uno::RuntimeException);
@@ -1089,7 +1114,8 @@ class ScTableSheetObj : public ScCellRan
 						public com::sun::star::sheet::XSheetOutline,
 						public com::sun::star::util::XProtectable,
 						public com::sun::star::sheet::XScenario,
-						public com::sun::star::sheet::XScenarioEnhanced
+						public com::sun::star::sheet::XScenarioEnhanced,
+                        public com::sun::star::sheet::XExternalSheetName
 {
 	friend class ScTableSheetsObj;		// fuer insertByName()
 
@@ -1289,6 +1315,11 @@ public:
                             getRanges(  )
                                     throw(::com::sun::star::uno::RuntimeException);
 
+                            // XExternalSheetName
+    virtual void SAL_CALL   setExternalName( const ::rtl::OUString& aUrl, const ::rtl::OUString& aSheetName )
+                                throw (::com::sun::star::container::ElementExistException,
+                                       ::com::sun::star::uno::RuntimeException);
+
 							// XPropertySet ueberladen wegen Sheet-Properties
 	virtual ::com::sun::star::uno::Reference< ::com::sun::star::beans::XPropertySetInfo >
 							SAL_CALL getPropertySetInfo()
--- sc/inc/compiler.hrc	3 Jul 2007 15:46:06 -0000	1.16
+++ sc/inc/compiler.hrc	14 Aug 2007 18:32:01 -0000	1.16.14.1
@@ -40,7 +40,7 @@
 
 /*** Special commands ***/
 #define	SC_OPCODE_PUSH				  0		/* internal commands */
-#define	SC_OPCODE_JUMP				  1
+#define	SC_OPCODE_CALL				  1
 #define	SC_OPCODE_STOP				  2
 #define	SC_OPCODE_EXTERNAL			  3
 #define	SC_OPCODE_NAME				  4
--- sc/inc/compiler.hxx	24 Jul 2007 09:22:32 -0000	1.32
+++ sc/inc/compiler.hxx	15 Oct 2007 13:48:04 -0000	1.31.44.7
@@ -71,6 +71,20 @@
 #include <rtl/ustrbuf.hxx>
 #endif
 
+#ifndef _COM_SUN_STAR_UNO_SEQUENCE_HXX_
+#include <com/sun/star/uno/Sequence.hxx>
+#endif
+namespace com { namespace sun { namespace star {
+    namespace sheet {
+        struct FormulaOpCodeMapEntry;
+        struct FormulaToken;
+    }
+}}}
+
+#ifndef BOOST_SHARED_PTR_HPP_INCLUDED
+#include <boost/shared_ptr.hpp>
+#endif
+
 #ifndef INCLUDED_HASH_MAP
 #include <hash_map>
 #define INCLUDED_HASH_MAP
@@ -216,8 +230,9 @@ typedef ScSimpleIntrusiveReference< stru
 struct ScArrayStack;
 
 typedef ::std::hash_map< String, OpCode, ScStringHashCode, ::std::equal_to< String > > ScOpCodeHashMap;
+typedef ::std::hash_map< String, String, ScStringHashCode, ::std::equal_to< String > > ScExternalHashMap;
+
 
-using namespace ::com::sun::star::i18n;
 class SC_DLLPUBLIC ScCompiler
 {
 public:
@@ -239,19 +254,137 @@ public:
 								   xub_StrLen nSrcPos,
 								   const CharClass* pCharClass) const = 0;
 	};
+    friend struct Convention;
+
+    /** Mappings from strings to OpCodes and vice versa. */
+    class OpCodeMap
+    {
+        ScOpCodeHashMap   *mpHashMap;                     /// hash map of symbols, String -> OpCode
+        String            *mpTable;                       /// array of symbols, OpCode -> String, offset==OpCode
+        ScExternalHashMap *mpExternalHashMap;             /// hash map of ocExternal, Filter String -> AddIn String
+        ScExternalHashMap *mpReverseExternalHashMap;      /// hash map of ocExternal, AddIn String -> Filter String
+        USHORT             mnSymbols;                     /// Count of OpCode symbols
+        bool               mbEnglish                 : 1; /// If English symbols and external names
+        bool               mbCore                    : 1; /// If mapping was setup by core, not filters
+        bool               mbODF_11                  : 1; /// If ODF 1.1 compatibility mapping
+
+        OpCodeMap();                              // prevent usage
+        OpCodeMap( const OpCodeMap& );            // prevent usage
+        OpCodeMap& operator=( const OpCodeMap& ); // prevent usage
+
+    public:
+
+        OpCodeMap( USHORT nSymbols, bool bEnglish, bool bCore, bool bODF_11 ) :
+            mpHashMap( new ScOpCodeHashMap( nSymbols)),
+            mpTable( new String[ nSymbols ]),
+            mpExternalHashMap( new ScExternalHashMap),
+            mpReverseExternalHashMap( new ScExternalHashMap),
+            mnSymbols( nSymbols ),
+            mbEnglish( bEnglish ),
+            mbCore( bCore ),
+            mbODF_11( bODF_11 )
+        {}
+        ~OpCodeMap()
+        {
+            delete mpReverseExternalHashMap;
+            delete mpExternalHashMap;
+            delete [] mpTable;
+            delete mpHashMap;
+        }
+
+        /// Get the symbol String -> OpCode hash map for finds.
+        inline const ScOpCodeHashMap* getHashMap() const { return mpHashMap; }
+
+        /// Get the symbol String -> AddIn String hash map for finds.
+        inline const ScExternalHashMap* getExternalHashMap() const { return mpExternalHashMap; }
+
+        /// Get the AddIn String -> symbol String hash map for finds.
+        inline const ScExternalHashMap* getReverseExternalHashMap() const { return mpReverseExternalHashMap; }
+
+        /// Get the symbol string matching an OpCode.
+        inline const String& getSymbol( const OpCode eOp ) const
+        {
+            DBG_ASSERT( USHORT(eOp) < mnSymbols, "OpCodeMap::getSymbol: OpCode out of range");
+            if (USHORT(eOp) < mnSymbols)
+                return mpTable[ eOp ];
+            return EMPTY_STRING;
+        }
+
+        /// Get the symbol count.
+        inline USHORT getSymbolCount() const { return mnSymbols; }
+
+        /** Are these English symbols, as opposed to native language (which may
+            be English as well)? */
+        inline bool isEnglish() const { return mbEnglish; }
+
+        /// Is it an internal core mapping, or setup by filters?
+        inline bool isCore() const { return mbCore; }
+
+        /// Is it an ODF 1.1 compatibility mapping?
+        inline bool isODF_11() const { return mbODF_11; }
+
+        /// Does it have external symbol/name mappings?
+        inline bool hasExternals() const { return !mpExternalHashMap->empty(); }
+
+        /// Put entry of symbol String and OpCode pair.
+        void putOpCode( const String & rStr, const OpCode eOp );
+
+        /// Put entry of symbol String and AddIn international String pair.
+        void putExternal( const String & rSymbol, const String & rAddIn );
+
+        /** Put entry of symbol String and AddIn international String pair,
+            failing silently if rAddIn name already exists. */
+        void putExternalSoftly( const String & rSymbol, const String & rAddIn );
+
+        /// Core implementation of XFormulaOpCodeMapper::getMappings()
+        ::com::sun::star::uno::Sequence< ::com::sun::star::sheet::FormulaToken >
+            createSequenceOfFormulaTokens(
+                    const ::com::sun::star::uno::Sequence< ::rtl::OUString >& rNames ) const;
+
+        /// Core implementation of XFormulaOpCodeMapper::getAvailableMappings()
+        ::com::sun::star::uno::Sequence<
+            ::com::sun::star::sheet::FormulaOpCodeMapEntry >
+            createSequenceOfAvailableMappings( const sal_Int32 nGroup ) const;
 
-	static String*	pSymbolTableNative;				// array of native symbols, offset==OpCode
-	static String*	pSymbolTableEnglish; 			// array of English symbols, offset==OpCode
-	static USHORT	nAnzStrings;					// count of symbols
-    static ScOpCodeHashMap* pSymbolHashMapNative;   // hash map of native symbols
-    static ScOpCodeHashMap* pSymbolHashMapEnglish;  // hash map of English symbols
+        /** The value used in createSequenceOfAvailableMappings() and thus in
+            XFormulaOpCodeMapper::getMappings() for an unknown symbol. */
+        static inline sal_Int32 getOpCodeUnknown()
+        {
+            return kOpCodeUnknown;
+        }
+
+private:
+
+        static const sal_Int32 kOpCodeUnknown = -1;
+
+    };
+
+    typedef ::boost::shared_ptr< const OpCodeMap > OpCodeMapPtr;
+    typedef ::boost::shared_ptr< OpCodeMap > NonConstOpCodeMapPtr;
+
+private:
+
+    static NonConstOpCodeMapPtr  mxSymbolsODFF;                          // ODFF symbols
+    static NonConstOpCodeMapPtr  mxSymbolsODF_11;                        // ODF 1.1 symbols
+    static NonConstOpCodeMapPtr  mxSymbolsNative;                        // native symbols
+    static NonConstOpCodeMapPtr  mxSymbolsEnglish;                       // English symbols
     static CharClass* pCharClassEnglish;            // character classification for en_US locale
 	static const Convention *pConventions[ ScAddress::CONV_LAST ];
 
+    static struct AddInMap
+    {
+        const char* pODFF;
+        const char* pEnglish;
+        bool        bMapDupToInternal;      // when writing ODFF
+        const char* pOriginal;              // programmatical name
+        const char* pUpper;                 // upper case programmatical name
+    } maAddInMap[];
+    static const AddInMap* GetAddInMap();
+    static size_t GetAddInMapCount();
+
 	ScDocument*	pDoc;
 	ScAddress	aPos;
 
-private:
 	String		aCorrectedFormula;					// autocorrected Formula
 	String		aCorrectedSymbol;					// autocorrected Symbol
 	sal_Unicode	cSymbol[MAXSTRLEN];					// current Symbol
@@ -264,8 +397,7 @@ private:
 	OpCode		eLastOp;
 	ScToken** 	pCode;
 	ScArrayStack* pStack;
-	String*		pSymbolTable;				// which symbol table is used
-    ScOpCodeHashMap*    pSymbolHashMap;     // which symbol hash map is used
+    OpCodeMapPtr mxSymbols;                 // which symbols are used
     const CharClass*    pCharClass;         // which character classification is used for parseAnyToken
 	USHORT		pc;
 	short		nNumFmt;					// set during CompileTokenArray()
@@ -320,14 +452,28 @@ private:
     void AppendDouble( rtl::OUStringBuffer& rBuffer, double fVal );
     void AppendString( rtl::OUStringBuffer& rBuffer, const String & rStr );
 
+    static void InitCharClassEnglish();
+
 public:
 	ScCompiler(ScDocument* pDocument, const ScAddress& );
 
 	ScCompiler( ScDocument* pDocument, const ScAddress&,
 				const ScTokenArray& rArr );
 
-	static void Init();
-	static void DeInit();
+    static bool IsInitialized()
+    {
+        return mxSymbolsNative.get() && mxSymbolsEnglish.get();
+    }
+	static void InitSymbolsNative();    /// only SymbolsNative, on first document creation
+	static void InitSymbolsEnglish();   /// only SymbolsEnglish, maybe later
+private:
+	static void InitSymbolsODF_11();    /// only SymbolsODF_11, on demand
+	static void InitSymbolsODFF();      /// only SymbolsODFF, on demand
+    static void fillFromAddInMap( NonConstOpCodeMapPtr xMap, size_t nSymbolOffset );
+    static void fillFromAddInCollectionUpperName( NonConstOpCodeMapPtr xMap );
+    static void fillFromAddInCollectionEnglishName( NonConstOpCodeMapPtr xMap );
+public:
+	static void DeInit();               /// all
 
 	// for ScAddress::Format()
 	static void CheckTabQuotes( String& aTabName,
@@ -337,16 +483,48 @@ public:
 	static BOOL EnQuote( String& rStr );
 	static BOOL DeQuote( String& rStr );
 
+    static const String& GetNativeSymbol( OpCode eOp )
+    {
+        return mxSymbolsNative->getSymbol( eOp );
+    }
+
+    /** Get OpCode for English symbol.
+        Used in XFunctionAccess to create token array.
+        @param rName
+            Symbol to lookup. MUST be upper case.
+     */
+    static OpCode GetEnglishOpCode( const String& rName );
+
+    /** Get OpCodeMap for formula language.
+        @param nLanguage
+            One of ::com::sun::star::sheet::FormulaLanguage constants.
+        @return Map for nLanguage. If nLanguage is unknown, a NULL map is returned.
+     */
+    static OpCodeMapPtr GetOpCodeMap( sal_Int32 nLanguage );
+
 	//! _either_ CompileForFAP _or_ AutoCorrection, _not_ both
 	void			SetCompileForFAP( BOOL bVal )
 						{ bCompileForFAP = bVal; bIgnoreErrors = bVal; }
 	void 			SetAutoCorrection( BOOL bVal )
 						{ bAutoCorrect = bVal; bIgnoreErrors = bVal; }
     void            SetCloseBrackets( bool bVal ) { mbCloseBrackets = bVal; }
-	void			SetCompileEnglish( BOOL bVal );		// use English SymbolTable
+    /// Use English or native symbol table, overrides a previous SetFormulaLanguage() !
+	void			SetCompileEnglish( BOOL bVal );
 	void			SetRefConvention( const Convention *pConvP );
 	void			SetRefConvention( const ScAddress::Convention eConv );
 
+    /** Create an internal symbol map from API mapping.
+        @param bEnglish
+            Use English number parser / formatter instead of native.
+     */
+    static OpCodeMapPtr CreateOpCodeMap(
+            const ::com::sun::star::uno::Sequence<
+            const ::com::sun::star::sheet::FormulaOpCodeMapEntry > & rMapping,
+            bool bEnglish );
+
+    /// Set symbol map if not empty, overrides a previous SetCompileEnglish() !
+    void            SetFormulaLanguage( const OpCodeMapPtr & xMap );
+
 	void			SetCompileXML( BOOL bVal );	// Deprecate and move to an address conv
 	void			SetImportXML( BOOL bVal )
 						{ bImportXML = bVal; }
@@ -356,6 +534,8 @@ public:
 								 ScAddress::Convention eConv = ScAddress::CONV_UNSPECIFIED );
 	BOOL  CompileTokenArray();
 	short GetNumFormatType() { return nNumFmt; }
+    const ScDocument* GetDoc() const { return pDoc; }
+    const ScAddress& GetPos() const { return aPos; }
 
     static const String& GetStringFromOpCode( OpCode eOpCode, bool bEnglish = false );
 
@@ -466,6 +646,6 @@ private:
     };
 };
 
-SC_DLLPUBLIC String* GetScCompilerpSymbolTableNative(); //CHINA001
+SC_DLLPUBLIC String GetScCompilerNativeSymbol( OpCode eOp ); //CHINA001
 
 #endif
--- sc/inc/conditio.hxx	27 Feb 2007 11:54:31 -0000	1.10
+++ sc/inc/conditio.hxx	6 Aug 2007 21:56:39 -0000	1.10.18.1
@@ -148,6 +148,9 @@ public:
 
     void            SetSrcString( const String& rNew );     // for XML import
 
+    void            SetFormula1( const ScTokenArray& rArray );
+    void            SetFormula2( const ScTokenArray& rArray );
+
 	String			GetExpression( const ScAddress& rCursor, USHORT nPos, ULONG nNumFmt = 0,
 									BOOL bEnglish = FALSE, BOOL bCompileXML = FALSE,
 									BOOL bTextToReal = FALSE ) const;
--- sc/inc/document.hxx	27 Sep 2007 13:51:33 -0000	1.104
+++ sc/inc/document.hxx	7 Dec 2007 09:25:20 -0000	1.97.44.9
@@ -421,6 +421,12 @@ private:
 
     mutable BOOL        bStyleSheetUsageInvalid;
 
+    BOOL                bUndoEnabled;
+    bool                mbAdjustHeightEnabled;
+    bool                mbExecuteLinkEnabled;
+    bool                mbChangeReadOnlyEnabled;    // allow changes in read-only document (for API import filters)
+
+    sal_Int16           mnNamedRangesLockCount;
 
 	inline BOOL 		RowHidden( SCROW nRow, SCTAB nTab );		// FillInfo
 
@@ -919,7 +925,16 @@ SC_DLLPUBLIC	ScDBCollection*	GetDBCollec
 	BOOL			IsClipOrUndo() const 						{ return bIsClip || bIsUndo; }
 	BOOL			IsUndo() const								{ return bIsUndo; }
 	BOOL			IsClipboard() const 						{ return bIsClip; }
-	BOOL			IsUndoEnabled() const						{ return !bImportingXML; }
+	BOOL			IsUndoEnabled() const						{ return bUndoEnabled; }
+    void            EnableUndo( BOOL bVal )                     { bUndoEnabled = bVal; }
+    bool            IsAdjustHeightEnabled() const               { return mbAdjustHeightEnabled; }
+    void            EnableAdjustHeight( bool bVal )             { mbAdjustHeightEnabled = bVal; }
+    bool            IsExecuteLinkEnabled() const                { return mbExecuteLinkEnabled; }
+    void            EnableExecuteLink( bool bVal )              { mbExecuteLinkEnabled = bVal; }
+    bool            IsChangeReadOnlyEnabled() const             { return mbChangeReadOnlyEnabled; }
+    void            EnableChangeReadOnly( bool bVal )           { mbChangeReadOnlyEnabled = bVal; }
+    sal_Int16       GetNamedRangesLockCount() const             { return mnNamedRangesLockCount; }
+    void            SetNamedRangesLockCount( sal_Int16 nCount ) { mnNamedRangesLockCount = nCount; }
 	void			ResetClip( ScDocument* pSourceDoc, const ScMarkData* pMarks );
 	void			ResetClip( ScDocument* pSourceDoc, SCTAB nTab );
 	void			SetCutMode( BOOL bCut );
--- sc/inc/fmtuno.hxx	8 Sep 2005 17:40:53 -0000	1.7
+++ sc/inc/fmtuno.hxx	9 Aug 2007 04:28:38 -0000	1.7.402.5
@@ -73,6 +73,9 @@
 #include <com/sun/star/beans/XPropertySet.hpp>
 #endif
 
+#include <com/sun/star/sheet/XMultiFormulaTokens.hpp>
+#include <com/sun/star/sheet/FormulaToken.hpp>
+
 #ifndef _CPPUHELPER_IMPLBASE3_HXX_
 #include <cppuhelper/implbase3.hxx>
 #endif
@@ -90,7 +93,17 @@ class ScConditionalFormat;
 class ScValidationData;
 
 
-//	"erstmal" nur dummer Container
+struct ScCondFormatEntryItem
+{
+    ::com::sun::star::uno::Sequence< ::com::sun::star::sheet::FormulaToken > maTokens1;
+    ::com::sun::star::uno::Sequence< ::com::sun::star::sheet::FormulaToken > maTokens2;
+    String      maExpr1;
+    String      maExpr2;
+    String      maPosStr;   // formula position as text
+    String      maStyle;    // display name as stored in ScStyleSheet
+    ScAddress   maPos;
+    USHORT      mnMode;     // stores enum ScConditionMode
+};
 
 class ScTableConditionalFormat : public cppu::WeakImplHelper5<
 							com::sun::star::sheet::XSheetConditionalEntries,
@@ -103,9 +116,7 @@ private:
 	List	aEntries;
 
 	ScTableConditionalEntry*	GetObjectByIndex_Impl(USHORT nIndex) const;
-	void						AddEntry_Impl( USHORT nMode,
-									const String& rExpr1, const String& rExpr2,
-									const ScAddress& rPos, const String& rPosStr, const String& rStyle );
+    void                        AddEntry_Impl(const ScCondFormatEntryItem& aEntry);
 
 public:
 							ScTableConditionalFormat();
@@ -178,23 +189,15 @@ class ScTableConditionalEntry : public c
 {
 private:
 	ScTableConditionalFormat*	pParent;
-	USHORT						nMode;		// enum ScConditionMode
-	String						aExpr1;
-	String						aExpr2;
-	ScAddress					aSrcPos;
-    String                      aPosString; // formula position as text - set only in ctor
-	String						aStyle;		// display name as stored in ScStyleSheet
+    ScCondFormatEntryItem       aData;
 
 public:
 							ScTableConditionalEntry();
 							ScTableConditionalEntry( ScTableConditionalFormat* pPar,
-													 USHORT nM, const String& rEx1,
-													 const String& rEx2, const ScAddress& rPos,
-													 const String& rPosStr, const String& rSt );
+                                                    const ScCondFormatEntryItem& aItem);
 	virtual					~ScTableConditionalEntry();
 
-	void					GetData( USHORT& rM, String& rEx1, String& rEx2,
-										ScAddress& rPos, String& rPosStr, String& rSt ) const;
+    void                    GetData(ScCondFormatEntryItem& rData) const;
 
 							// XSheetCondition
 	virtual ::com::sun::star::sheet::ConditionOperator SAL_CALL getOperator()
@@ -228,8 +231,9 @@ public:
 
 
 
-class ScTableValidationObj : public cppu::WeakImplHelper4<
+class ScTableValidationObj : public cppu::WeakImplHelper5<
 							com::sun::star::sheet::XSheetCondition,
+                            com::sun::star::sheet::XMultiFormulaTokens,
 							com::sun::star::beans::XPropertySet,
 							com::sun::star::lang::XUnoTunnel,
 							com::sun::star::lang::XServiceInfo >
@@ -239,6 +243,8 @@ private:
 	USHORT				nMode;			// enum ScConditionMode
 	String				aExpr1;
 	String				aExpr2;
+    ::com::sun::star::uno::Sequence< ::com::sun::star::sheet::FormulaToken > aTokens1;
+    ::com::sun::star::uno::Sequence< ::com::sun::star::sheet::FormulaToken > aTokens2;
 	ScAddress			aSrcPos;
     String              aPosString;     // formula position as text
 	USHORT				nValMode;		// enum ScValidationMode
@@ -280,6 +286,15 @@ public:
 	virtual void SAL_CALL setSourcePosition( const ::com::sun::star::table::CellAddress& aSourcePosition )
 								throw(::com::sun::star::uno::RuntimeException);
 
+                            // XMultiFormulaTokens
+    virtual ::com::sun::star::uno::Sequence< ::com::sun::star::sheet::FormulaToken > 
+                            SAL_CALL getTokens( sal_Int32 nIndex ) 
+                                throw(::com::sun::star::uno::RuntimeException,::com::sun::star::lang::IndexOutOfBoundsException);
+    virtual void SAL_CALL setTokens( sal_Int32 nIndex, 
+                                     const ::com::sun::star::uno::Sequence< ::com::sun::star::sheet::FormulaToken >& aTokens )
+                                throw(::com::sun::star::uno::RuntimeException,::com::sun::star::lang::IndexOutOfBoundsException);
+    virtual sal_Int32 SAL_CALL getCount() throw(::com::sun::star::uno::RuntimeException);
+                    
 							// XPropertySet
 	virtual ::com::sun::star::uno::Reference< ::com::sun::star::beans::XPropertySetInfo >
 							SAL_CALL getPropertySetInfo()
--- sc/inc/linkuno.hxx	27 Feb 2007 11:56:50 -0000	1.5
+++ sc/inc/linkuno.hxx	29 Nov 2007 12:06:40 -0000	1.5.18.2
@@ -47,6 +47,12 @@
 #ifndef _COM_SUN_STAR_SHEET_XDDELINK_HPP_
 #include <com/sun/star/sheet/XDDELink.hpp>
 #endif
+#ifndef _COM_SUN_STAR_SHEET_XDDELINKRESULTS_HPP_
+#include <com/sun/star/sheet/XDDELinkResults.hpp>
+#endif
+#ifndef _COM_SUN_STAR_SHEET_XDDELINKS_HPP_
+#include <com/sun/star/sheet/XDDELinks.hpp>
+#endif
 #ifndef _COM_SUN_STAR_SHEET_XAREALINK_HPP_
 #include <com/sun/star/sheet/XAreaLink.hpp>
 #endif
@@ -81,6 +87,9 @@
 #ifndef _CPPUHELPER_IMPLBASE4_HXX_
 #include <cppuhelper/implbase4.hxx>
 #endif
+#ifndef _CPPUHELPER_IMPLBASE5_HXX_
+#include <cppuhelper/implbase5.hxx>
+#endif
 
 
 class ScAreaLink;
@@ -405,10 +414,11 @@ public:
 
 //!	order of XNamed and DDELink changed to avoid "duplicate comdat" symbols
 
-class ScDDELinkObj : public cppu::WeakImplHelper4<
+class ScDDELinkObj : public cppu::WeakImplHelper5<
 							com::sun::star::sheet::XDDELink,
 							com::sun::star::container::XNamed,
 							com::sun::star::util::XRefreshable,
+                            com::sun::star::sheet::XDDELinkResults,
 							com::sun::star::lang::XServiceInfo >,
 						public SfxListener
 {
@@ -447,6 +457,14 @@ public:
 									::com::sun::star::util::XRefreshListener >& l )
 								throw(::com::sun::star::uno::RuntimeException);
 
+                            // XDDELinkResults
+    virtual ::com::sun::star::uno::Sequence< ::com::sun::star::uno::Sequence< ::com::sun::star::uno::Any > >
+        SAL_CALL getResults(  )
+        throw (::com::sun::star::uno::RuntimeException);
+    virtual void SAL_CALL setResults(
+        const ::com::sun::star::uno::Sequence< ::com::sun::star::uno::Sequence< ::com::sun::star::uno::Any > >& aResults )
+        throw (::com::sun::star::uno::RuntimeException);
+
 							// XServiceInfo
 	virtual ::rtl::OUString SAL_CALL getImplementationName()
 								throw(::com::sun::star::uno::RuntimeException);
@@ -458,9 +476,9 @@ public:
 
 
 class ScDDELinksObj : public cppu::WeakImplHelper4<
-							com::sun::star::container::XNameAccess,
 							com::sun::star::container::XEnumerationAccess,
 							com::sun::star::container::XIndexAccess,
+                            com::sun::star::sheet::XDDELinks,
 							com::sun::star::lang::XServiceInfo >,
 						public SfxListener
 {
@@ -502,6 +520,12 @@ public:
 								throw(::com::sun::star::uno::RuntimeException);
 	virtual sal_Bool SAL_CALL hasElements() throw(::com::sun::star::uno::RuntimeException);
 
+                            // XDDELinks
+    virtual ::com::sun::star::uno::Reference< ::com::sun::star::sheet::XDDELink > SAL_CALL addDDELink(
+        const ::rtl::OUString& aApplication, const ::rtl::OUString& aTopic,
+        const ::rtl::OUString& aItem, ::com::sun::star::sheet::DDELinkMode nMode )
+        throw (::com::sun::star::uno::RuntimeException);
+
 							// XServiceInfo
 	virtual ::rtl::OUString SAL_CALL getImplementationName()
 								throw(::com::sun::star::uno::RuntimeException);
--- sc/inc/nameuno.hxx	8 Sep 2005 17:45:29 -0000	1.4
+++ sc/inc/nameuno.hxx	24 Jul 2007 09:04:11 -0000	1.4.402.3
@@ -56,6 +56,9 @@
 #ifndef _COM_SUN_STAR_SHEET_XNAMEDRANGE_HPP_
 #include <com/sun/star/sheet/XNamedRange.hpp>
 #endif
+#ifndef _COM_SUN_STAR_SHEET_XFORMULATOKENS_HPP_
+#include <com/sun/star/sheet/XFormulaTokens.hpp>
+#endif
 #ifndef _COM_SUN_STAR_SHEET_XNAMEDRANGES_HPP_
 #include <com/sun/star/sheet/XNamedRanges.hpp>
 #endif
@@ -71,6 +74,9 @@
 #ifndef _COM_SUN_STAR_BEANS_XPROPERTYSET_HPP_
 #include <com/sun/star/beans/XPropertySet.hpp>
 #endif
+#ifndef _COM_SUN_STAR_DOCUMENT_XACTIONLOCKABLE_HPP_
+#include <com/sun/star/document/XActionLockable.hpp>
+#endif
 
 #ifndef _CPPUHELPER_IMPLBASE2_HXX_
 #include <cppuhelper/implbase2.hxx>
@@ -78,16 +84,18 @@
 #ifndef _CPPUHELPER_IMPLBASE3_HXX_
 #include <cppuhelper/implbase3.hxx>
 #endif
-#ifndef _CPPUHELPER_IMPLBASE4_HXX_
-#include <cppuhelper/implbase4.hxx>
+#ifndef _CPPUHELPER_IMPLBASE5_HXX_
+#include <cppuhelper/implbase5.hxx>
 #endif
 
 class ScDocShell;
 class ScRangeData;
+class ScTokenArray;
 
 
-class ScNamedRangeObj : public ::cppu::WeakImplHelper4<
+class ScNamedRangeObj : public ::cppu::WeakImplHelper5<
 							::com::sun::star::sheet::XNamedRange,
+                            ::com::sun::star::sheet::XFormulaTokens,
 							::com::sun::star::sheet::XCellRangeReferrer,
 							::com::sun::star::beans::XPropertySet,
 							::com::sun::star::lang::XServiceInfo >,
@@ -99,7 +107,8 @@ private:
 
 private:
 	ScRangeData*			GetRangeData_Impl();
-	void					Modify_Impl( const String* pNewName, const String* pNewContent,
+	void					Modify_Impl( const String* pNewName,
+                                        const ScTokenArray* pNewTokens, const String* pNewContent,
 										const ScAddress* pNewPos, const sal_uInt16* pNewType );
 
 public:
@@ -120,6 +129,13 @@ public:
 	virtual sal_Int32		SAL_CALL getType() throw(::com::sun::star::uno::RuntimeException);
 	virtual void SAL_CALL	setType( sal_Int32 nType ) throw(::com::sun::star::uno::RuntimeException);
 
+                            // XFormulaTokens
+    virtual ::com::sun::star::uno::Sequence< ::com::sun::star::sheet::FormulaToken > SAL_CALL getTokens()
+                                throw (::com::sun::star::uno::RuntimeException);
+    virtual void SAL_CALL   setTokens( const ::com::sun::star::uno::Sequence<
+                                    ::com::sun::star::sheet::FormulaToken >& aTokens )
+                                throw (::com::sun::star::uno::RuntimeException);
+
 							// XNamed
 	virtual ::rtl::OUString SAL_CALL getName() throw(::com::sun::star::uno::RuntimeException);
 	virtual void SAL_CALL	setName( const ::rtl::OUString& aName )
@@ -180,10 +196,11 @@ public:
 };
 
 
-class ScNamedRangesObj : public ::cppu::WeakImplHelper4<
+class ScNamedRangesObj : public ::cppu::WeakImplHelper5<
 							::com::sun::star::sheet::XNamedRanges,
 							::com::sun::star::container::XEnumerationAccess,
 							::com::sun::star::container::XIndexAccess,
+                            ::com::sun::star::document::XActionLockable,
 							::com::sun::star::lang::XServiceInfo >,
 						public SfxListener
 {
@@ -193,6 +210,13 @@ private:
 	ScNamedRangeObj*		GetObjectByIndex_Impl(sal_uInt16 nIndex);
 	ScNamedRangeObj*		GetObjectByName_Impl(const ::rtl::OUString& aName);
 
+protected:
+    /** called from the XActionLockable interface methods on initial locking */
+    virtual void            lock();
+
+    /** called from the XActionLockable interface methods on final unlock */
+    virtual void            unlock();
+
 public:
 							ScNamedRangesObj(ScDocShell* pDocSh);
 	virtual					~ScNamedRangesObj();
@@ -237,6 +261,13 @@ public:
 								throw(::com::sun::star::uno::RuntimeException);
 	virtual sal_Bool SAL_CALL hasElements() throw(::com::sun::star::uno::RuntimeException);
 
+                            // XActionLockable
+    virtual sal_Bool SAL_CALL isActionLocked() throw(::com::sun::star::uno::RuntimeException);
+    virtual void SAL_CALL addActionLock() throw(::com::sun::star::uno::RuntimeException);
+    virtual void SAL_CALL removeActionLock() throw(::com::sun::star::uno::RuntimeException);
+    virtual void SAL_CALL setActionLocks( sal_Int16 nLock ) throw(::com::sun::star::uno::RuntimeException);
+    virtual sal_Int16 SAL_CALL resetActionLocks() throw(::com::sun::star::uno::RuntimeException);
+
 							// XServiceInfo
 	virtual ::rtl::OUString SAL_CALL getImplementationName()
 								throw(::com::sun::star::uno::RuntimeException);
--- sc/inc/opcode.hxx	6 Jul 2007 12:30:35 -0000	1.19
+++ sc/inc/opcode.hxx	14 Aug 2007 18:32:01 -0000	1.19.10.1
@@ -47,7 +47,7 @@ enum OpCodeEnum
 {
 	// Special commands
 		ocPush				= SC_OPCODE_PUSH,
-		ocJump				= SC_OPCODE_JUMP,
+		ocCall				= SC_OPCODE_CALL,
 		ocStop				= SC_OPCODE_STOP,
 		ocExternal			= SC_OPCODE_EXTERNAL,
 		ocName				= SC_OPCODE_NAME,
--- sc/inc/rangeseq.hxx	8 Sep 2005 17:50:20 -0000	1.4
+++ sc/inc/rangeseq.hxx	30 Aug 2007 09:24:13 -0000	1.4.402.1
@@ -44,10 +44,13 @@
 #include <com/sun/star/uno/Any.h>
 #endif
 
+#ifndef SC_MATRIX_HXX
+#include "scmatrix.hxx"
+#endif
+
 class SvNumberFormatter;
 class ScDocument;
 class ScRange;
-class ScMatrix;
 
 class ScRangeToSequence
 {
@@ -67,8 +70,50 @@ public:
 	static BOOL	FillMixedArray( com::sun::star::uno::Any& rAny,
 								ScDocument* pDoc, const ScRange& rRange,
 								BOOL bAllowNV = FALSE );
+
+    /** @param bDataTypes
+            Additionally to the differentiation between string and double allow
+            differentiation between other types such as as boolean. Needed for
+            implementation of XFormulaParser. If <FALSE/>, boolean values are
+            treated as ordinary double values 1 (true) and 0 (false).
+     */
 	static BOOL	FillMixedArray( com::sun::star::uno::Any& rAny,
-								const ScMatrix* pMatrix );
+								const ScMatrix* pMatrix, bool bDataTypes = false );
+};
+
+
+class ScApiTypeConversion
+{
+public:
+
+    /** Convert an uno::Any to double if possible, including integer types.
+        @param o_fVal
+            Out: the double value on successful conversion.
+        @param o_eClass
+            Out: the uno::TypeClass of rAny.
+        @returns <TRUE/> if successfully converted.
+     */
+    static  bool        ConvertAnyToDouble(
+                            double & o_fVal,
+                            com::sun::star::uno::TypeClass & o_eClass,
+                            const com::sun::star::uno::Any & rAny );
+
+};
+
+
+class ScSequenceToMatrix
+{
+public:
+
+    /** Convert a sequence of mixed elements to ScMatrix.
+
+        Precondition: rAny.getValueType().equals( getCppuType( (uno::Sequence< uno::Sequence< uno::Any > > *)0))
+
+        @returns a new'd ScMatrix as ScMatrixRef, NULL if rAny couldn't be read
+        as type Sequence<Sequence<Any>>
+     */
+    static  ScMatrixRef CreateMixedMatrix( const com::sun::star::uno::Any & rAny );
+
 };
 
 
--- sc/inc/sc.hrc	21 Sep 2007 09:22:29 -0000	1.55
+++ sc/inc/sc.hrc	4 Oct 2007 09:02:05 -0000	1.54.10.2
@@ -1156,7 +1156,7 @@
 #define RID_SC_FUNCTION_DESCRIPTIONS2	(SC_RESOURCE_START+44)
 #define RID_POPUP_CONTROL		(SC_RESOURCE_START+45)
 #define RID_POPUP_PAGEBREAK		(SC_RESOURCE_START+46)
-    // FREE
+#define RID_SC_FUNCTION_NAMES_ENGLISH_ODFF	(SC_RESOURCE_START+47)
 #define RID_POPUP_DRAWFORM		(SC_RESOURCE_START+48)
 #define RID_SC_ADDIN_ROT13		(SC_RESOURCE_START+50)
 #define RID_SC_ADDIN_DFA		(SC_RESOURCE_START+51)
--- sc/inc/scmatrix.hxx	13 Jun 2007 09:05:40 -0000	1.8
+++ sc/inc/scmatrix.hxx	30 Aug 2007 09:24:13 -0000	1.8.44.1
@@ -143,6 +143,12 @@ public:
         return nType <= SC_MATVAL_BOOLEAN;
     }
 
+    /// Boolean.
+    inline static bool IsBooleanType( ScMatValType nType )
+    {
+        return nType == SC_MATVAL_BOOLEAN;
+    }
+
     /// String, empty or empty path, but not value nor boolean.
     inline static bool IsStringType( ScMatValType nType )
     {
@@ -280,6 +286,10 @@ public:
         { return !mnValType || IsValueType( mnValType[ nC * nRowCount + nR ]) ||
             ((mnValType[ nC * nRowCount + nR ] & SC_MATVAL_EMPTY) ==
              SC_MATVAL_EMPTY); }
+    BOOL IsBoolean( SCSIZE nIndex ) const
+        { return mnValType && IsBooleanType( mnValType[nIndex]); }
+    BOOL IsBoolean( SCSIZE nC, SCSIZE nR ) const
+        { return mnValType && IsBooleanType( mnValType[ nC * nRowCount + nR ]); }
 
     /// @return <TRUE/> if entire matrix is numeric, including booleans, with no strings or empties
     BOOL IsNumeric() const
--- sc/inc/servuno.hxx	8 Sep 2005 17:56:51 -0000	1.12
+++ sc/inc/servuno.hxx	14 Aug 2007 18:32:01 -0000	1.12.402.2
@@ -100,7 +100,10 @@ class ScDocShell;
 // BM
 #define SC_SERVICE_CHDATAPROV   37
 
-#define SC_SERVICE_COUNT        38
+#define SC_SERVICE_FORMULAPARS  38
+#define SC_SERVICE_OPCODEMAPPER 39
+
+#define SC_SERVICE_COUNT        40
 #define SC_SERVICE_INVALID		USHRT_MAX
 
 
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ sc/inc/tokenuno.hxx	29 Aug 2007 11:58:50 -0000	1.1.2.6
@@ -0,0 +1,214 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+
+#ifndef SC_TOKENUNO_HXX
+#define SC_TOKENUNO_HXX
+
+#ifndef _SFXLSTNER_HXX
+#include <svtools/lstner.hxx>
+#endif
+
+#ifndef _COM_SUN_STAR_SHEET_FORMULATOKEN_HPP_
+#include <com/sun/star/sheet/FormulaToken.hpp>
+#endif
+#ifndef _COM_SUN_STAR_UNO_SEQUENCE_HXX_
+#include <com/sun/star/uno/Sequence.hxx>
+#endif
+
+#ifndef _COM_SUN_STAR_LANG_XSERVICEINFO_HPP_
+#include <com/sun/star/lang/XServiceInfo.hpp>
+#endif
+#ifndef _COM_SUN_STAR_BEANS_XPROPERTYSET_HPP_
+#include <com/sun/star/beans/XPropertySet.hpp>
+#endif
+#ifndef _COM_SUN_STAR_SHEET_XFORMULAPARSER_HPP_
+#include <com/sun/star/sheet/XFormulaParser.hpp>
+#endif
+#ifndef _COM_SUN_STAR_SHEET_XFORMULAOPCODEMAPPER_HPP_
+#include <com/sun/star/sheet/XFormulaOpCodeMapper.hpp>
+#endif
+#ifndef __com_sun_star_sheet_FormulaOpCodeMapEntry_idl__
+#include <com/sun/star/sheet/FormulaOpCodeMapEntry.hpp>
+#endif
+
+#ifndef _CPPUHELPER_IMPLBASE3_HXX_
+#include <cppuhelper/implbase3.hxx>
+#endif
+
+#ifndef _CPPUHELPER_IMPLBASE2_HXX_
+#include <cppuhelper/implbase2.hxx>
+#endif
+
+#ifndef SC_ADDRESS_HXX
+#include "address.hxx"
+#endif
+#ifndef SC_COMPILER_HXX
+#include "compiler.hxx"
+#endif
+
+class ScTokenArray;
+class ScDocShell;
+
+
+class ScTokenConversion
+{
+public:
+    static bool ConvertToTokenArray(
+                        ScTokenArray& rTokenArray,
+                        const com::sun::star::uno::Sequence< com::sun::star::sheet::FormulaToken >& rSequence );
+    static bool ConvertToTokenSequence(
+                        com::sun::star::uno::Sequence< com::sun::star::sheet::FormulaToken >& rSequence,
+                        const ScTokenArray& rTokenArray );
+};
+
+
+class ScFormulaParserObj : public ::cppu::WeakImplHelper3<
+                            ::com::sun::star::sheet::XFormulaParser,
+                            ::com::sun::star::beans::XPropertySet,
+                            ::com::sun::star::lang::XServiceInfo >,
+                        public SfxListener
+{
+private:
+    ::com::sun::star::uno::Sequence< const ::com::sun::star::sheet::FormulaOpCodeMapEntry > maOpCodeMapping;
+    ScCompiler::OpCodeMapPtr    mxOpCodeMap;
+    ScDocShell*         mpDocShell;
+    ScAddress           maRefPos;
+    bool                mbEnglish;
+    bool                mbR1C1;
+    bool                mbComp3D;
+    bool                mbIgnoreSpaces;
+
+    void                    SetCompilerFlags( ScCompiler& rCompiler ) const;
+
+public:
+                            ScFormulaParserObj(ScDocShell* pDocSh);
+    virtual                 ~ScFormulaParserObj();
+
+    virtual void            Notify( SfxBroadcaster& rBC, const SfxHint& rHint );
+
+                            // XFormulaParser
+    virtual ::com::sun::star::uno::Sequence< ::com::sun::star::sheet::FormulaToken > SAL_CALL parseFormula(
+                                    const ::rtl::OUString& aFormula )
+                                throw (::com::sun::star::uno::RuntimeException);
+    virtual ::rtl::OUString SAL_CALL printFormula( const ::com::sun::star::uno::Sequence<
+                                    ::com::sun::star::sheet::FormulaToken >& aTokens )
+                                throw (::com::sun::star::uno::RuntimeException);
+
+                            // XPropertySet
+    virtual ::com::sun::star::uno::Reference< ::com::sun::star::beans::XPropertySetInfo >
+                            SAL_CALL getPropertySetInfo()
+                                throw(::com::sun::star::uno::RuntimeException);
+    virtual void SAL_CALL   setPropertyValue( const ::rtl::OUString& aPropertyName,
+                                    const ::com::sun::star::uno::Any& aValue )
+                                throw(::com::sun::star::beans::UnknownPropertyException,
+                                    ::com::sun::star::beans::PropertyVetoException,
+                                    ::com::sun::star::lang::IllegalArgumentException,
+                                    ::com::sun::star::lang::WrappedTargetException,
+                                    ::com::sun::star::uno::RuntimeException);
+    virtual ::com::sun::star::uno::Any SAL_CALL getPropertyValue(
+                                    const ::rtl::OUString& PropertyName )
+                                throw(::com::sun::star::beans::UnknownPropertyException,
+                                    ::com::sun::star::lang::WrappedTargetException,
+                                    ::com::sun::star::uno::RuntimeException);
+    virtual void SAL_CALL   addPropertyChangeListener( const ::rtl::OUString& aPropertyName,
+                                    const ::com::sun::star::uno::Reference<
+                                        ::com::sun::star::beans::XPropertyChangeListener >& xListener )
+                                throw(::com::sun::star::beans::UnknownPropertyException,
+                                    ::com::sun::star::lang::WrappedTargetException,
+                                    ::com::sun::star::uno::RuntimeException);
+    virtual void SAL_CALL   removePropertyChangeListener( const ::rtl::OUString& aPropertyName,
+                                    const ::com::sun::star::uno::Reference<
+                                        ::com::sun::star::beans::XPropertyChangeListener >& aListener )
+                                throw(::com::sun::star::beans::UnknownPropertyException,
+                                    ::com::sun::star::lang::WrappedTargetException,
+                                    ::com::sun::star::uno::RuntimeException);
+    virtual void SAL_CALL   addVetoableChangeListener( const ::rtl::OUString& PropertyName,
+                                    const ::com::sun::star::uno::Reference<
+                                        ::com::sun::star::beans::XVetoableChangeListener >& aListener )
+                                throw(::com::sun::star::beans::UnknownPropertyException,
+                                    ::com::sun::star::lang::WrappedTargetException,
+                                    ::com::sun::star::uno::RuntimeException);
+    virtual void SAL_CALL   removeVetoableChangeListener( const ::rtl::OUString& PropertyName,
+                                    const ::com::sun::star::uno::Reference<
+                                        ::com::sun::star::beans::XVetoableChangeListener >& aListener )
+                                throw(::com::sun::star::beans::UnknownPropertyException,
+                                    ::com::sun::star::lang::WrappedTargetException,
+                                    ::com::sun::star::uno::RuntimeException);
+
+                            // XServiceInfo
+    virtual ::rtl::OUString SAL_CALL getImplementationName()
+                                throw(::com::sun::star::uno::RuntimeException);
+    virtual sal_Bool SAL_CALL supportsService( const ::rtl::OUString& ServiceName )
+                                throw(::com::sun::star::uno::RuntimeException);
+    virtual ::com::sun::star::uno::Sequence< ::rtl::OUString > SAL_CALL getSupportedServiceNames()
+                                throw(::com::sun::star::uno::RuntimeException);
+};
+
+
+class ScFormulaOpCodeMapperObj : public ::cppu::WeakImplHelper2<
+                            ::com::sun::star::sheet::XFormulaOpCodeMapper,
+                            ::com::sun::star::lang::XServiceInfo >
+{
+public:
+                            ScFormulaOpCodeMapperObj();
+    virtual                 ~ScFormulaOpCodeMapperObj();
+
+                            // XFormulaOpCodeMapper
+                            // Attributes
+    virtual ::sal_Int32 SAL_CALL getOpCodeExternal() throw (::com::sun::star::uno::RuntimeException);
+    virtual ::sal_Int32 SAL_CALL getOpCodeUnknown() throw (::com::sun::star::uno::RuntimeException);
+                            // Methods
+    virtual ::com::sun::star::uno::Sequence< ::com::sun::star::sheet::FormulaToken > SAL_CALL getMappings(
+                                    const ::com::sun::star::uno::Sequence< ::rtl::OUString >& rNames,
+                                    sal_Int32 nLanguage )
+                                throw ( ::com::sun::star::lang::IllegalArgumentException,
+                                        ::com::sun::star::uno::RuntimeException);
+    virtual ::com::sun::star::uno::Sequence< ::com::sun::star::sheet::FormulaOpCodeMapEntry > SAL_CALL getAvailableMappings(
+                                    sal_Int32 nLanguage, sal_Int32 nGroups )
+                                throw ( ::com::sun::star::lang::IllegalArgumentException,
+                                        ::com::sun::star::uno::RuntimeException);
+
+                            // XServiceInfo
+    virtual ::rtl::OUString SAL_CALL getImplementationName()
+                                throw(::com::sun::star::uno::RuntimeException);
+    virtual sal_Bool SAL_CALL supportsService( const ::rtl::OUString& ServiceName )
+                                throw(::com::sun::star::uno::RuntimeException);
+    virtual ::com::sun::star::uno::Sequence< ::rtl::OUString > SAL_CALL getSupportedServiceNames()
+                                throw(::com::sun::star::uno::RuntimeException);
+
+};
+
+#endif
+
--- sc/inc/unonames.hxx	6 Jul 2007 12:31:28 -0000	1.74
+++ sc/inc/unonames.hxx	7 Dec 2007 09:25:20 -0000	1.71.250.15
@@ -42,6 +42,10 @@
 #define SC_SERVICENAME_LISTSOURCE   "com.sun.star.table.CellRangeListSource"
 #define SC_SERVICENAME_CELLADDRESS  "com.sun.star.table.CellAddressConversion"
 #define SC_SERVICENAME_RANGEADDRESS "com.sun.star.table.CellRangeAddressConversion"
+
+#define SC_SERVICENAME_FORMULAPARS      "com.sun.star.sheet.FormulaParser"
+#define SC_SERVICENAME_OPCODEMAPPER     "com.sun.star.sheet.FormulaOpCodeMapper"
+
 #define SC_SERVICENAME_CHDATAPROV   "com.sun.star.chart2.data.DataProvider"
 #define SC_SERVICENAME_CHRANGEHILIGHT "com.sun.star.chart2.data.RangeHighlightListener"
 
@@ -294,6 +298,7 @@
 #define SC_UNONAME_ENABSORT         "EnableSort"
 #define SC_UNONAME_FROMSELECT       "FromSelection"
 #define SC_UNONAME_CONRES           "ConnectionResource"
+#define SC_UNONAME_TOKENINDEX       "TokenIndex"
 
 //	text fields
 #define SC_UNONAME_ANCTYPE			"AnchorType"
@@ -471,6 +476,12 @@
 #define SC_UNO_DIALOGLIBRARIES      "DialogLibraries"
 #define SC_UNO_RUNTIMEUID           "RuntimeUID"
 #define SC_UNO_HASVALIDSIGNATURES   "HasValidSignatures"
+#define SC_UNO_ISLOADED                 "IsLoaded"
+#define SC_UNO_ISUNDOENABLED            "IsUndoEnabled"
+#define SC_UNO_ISADJUSTHEIGHTENABLED    "IsAdjustHeightEnabled"
+#define SC_UNO_ISEXECUTELINKENABLED     "IsExecuteLinkEnabled"
+#define SC_UNO_ISCHANGEREADONLYENABLED  "IsChangeReadOnlyEnabled"
+#define SC_UNO_REFERENCEDEVICE          "ReferenceDevice"
 
 //	document properties from FormModel
 #define SC_UNO_APPLYFMDES			"ApplyFormDesignMode"
@@ -582,6 +593,14 @@
 #define SC_UNO_LOADREADONLY			"LoadReadonly"
 // <--
 
+// FormulaParser
+#define SC_UNO_REFERENCEPOS         "ReferencePosition"
+#define SC_UNO_COMPILEENGLISH       "CompileEnglish"
+#define SC_UNO_R1C1NOTATION         "R1C1Notation"
+#define SC_UNO_COMPATIBILITY3D      "Compatibility3DNotation"
+#define SC_UNO_IGNORELEADING        "IgnoreLeadingSpaces"
+#define SC_UNO_OPCODEMAP            "OpCodeMap"
+
 // Chart2
 #define SC_UNONAME_ISHIDDEN         "IsHidden"
 #define SC_UNONAME_ROLE             "Role"
--- sc/source/core/data/conditio.cxx	27 Feb 2007 12:00:49 -0000	1.21
+++ sc/source/core/data/conditio.cxx	21 Sep 2007 08:57:21 -0000	1.21.18.2
@@ -569,6 +569,26 @@ void ScConditionEntry::SetSrcString( con
     aSrcString = rNew;
 }
 
+void ScConditionEntry::SetFormula1( const ScTokenArray& rArray )
+{
+    DELETEZ( pFormula1 );
+    if( rArray.GetLen() > 0 )
+    {
+        pFormula1 = new ScTokenArray( rArray );
+        bRelRef1 = lcl_HasRelRef( pDoc, pFormula1 );
+    }
+}
+
+void ScConditionEntry::SetFormula2( const ScTokenArray& rArray )
+{
+    DELETEZ( pFormula2 );
+    if( rArray.GetLen() > 0 )
+    {
+        pFormula2 = new ScTokenArray( rArray );
+        bRelRef2 = lcl_HasRelRef( pDoc, pFormula2 );
+    }
+}
+
 void lcl_CondUpdateInsertTab( ScTokenArray& rCode, SCTAB nInsTab, SCTAB nPosTab, BOOL& rChanged )
 {
     //  Insert table: only update absolute table references.
--- sc/source/core/data/documen2.cxx	27 Sep 2007 13:52:23 -0000	1.67
+++ sc/source/core/data/documen2.cxx	7 Dec 2007 09:25:38 -0000	1.62.18.8
@@ -393,7 +393,12 @@ ScDocument::ScDocument( ScDocumentMode	e
         bInUnoBroadcast( FALSE ),
         bInUnoListenerCall( FALSE ),
         eAddrConv( ScAddress::CONV_OOO ),
-        bStyleSheetUsageInvalid( TRUE )
+        bStyleSheetUsageInvalid( TRUE ),
+        bUndoEnabled( TRUE ),
+        mbAdjustHeightEnabled( true ),
+        mbExecuteLinkEnabled( true ),
+        mbChangeReadOnlyEnabled( false ),
+        mnNamedRangesLockCount( 0 )
 {
 	eSrcSet = gsl_getSystemTextEncoding();
 
--- sc/source/core/data/documen3.cxx	21 Sep 2007 09:22:54 -0000	1.38
+++ sc/source/core/data/documen3.cxx	7 Dec 2007 09:25:39 -0000	1.38.16.1
@@ -1765,9 +1765,8 @@ BOOL ScDocument::IsDocProtected() const
 
 BOOL ScDocument::IsDocEditable() const
 {
-	// import into read-only document is possible - must be extended if other filters use api
-
-	return !bProtected && ( !pShell || !pShell->IsReadOnly() || bImportingXML );
+    // import into read-only document is possible
+    return !bProtected && ( bImportingXML || mbChangeReadOnlyEnabled || !pShell || !pShell->IsReadOnly() );
 }
 
 BOOL ScDocument::IsTabProtected( SCTAB nTab ) const
--- sc/source/core/data/documen4.cxx	27 Feb 2007 12:01:47 -0000	1.18
+++ sc/source/core/data/documen4.cxx	14 Aug 2007 18:32:01 -0000	1.18.18.1
@@ -237,8 +237,7 @@ void ScDocument::InsertTableOp(const ScT
 
     ScRefAddress aRef;
 	String aForString = '=';
-	if (ScCompiler::pSymbolTableNative)
-		aForString += ScCompiler::pSymbolTableNative[SC_OPCODE_TABLE_OP];
+    aForString += ScCompiler::GetNativeSymbol(ocTableOp);
 	aForString += '(';
 	if (rParam.nMode == 0)							// nur Spalte
 	{
--- sc/source/core/data/document.cxx	27 Sep 2007 13:52:38 -0000	1.80
+++ sc/source/core/data/document.cxx	7 Dec 2007 09:25:39 -0000	1.80.14.1
@@ -3575,8 +3575,8 @@ BOOL ScDocument::IsBlockEditable( SCTAB 
 										SCCOL nEndCol, SCROW nEndRow,
 										BOOL* pOnlyNotBecauseOfMatrix /* = NULL */ ) const
 {
-	// import into read-only document is possible - must be extended if other filters use api
-	if ( pShell && pShell->IsReadOnly() && !bImportingXML )
+    // import into read-only document is possible
+    if ( !bImportingXML && !mbChangeReadOnlyEnabled && pShell && pShell->IsReadOnly() )
 	{
 		if ( pOnlyNotBecauseOfMatrix )
 			*pOnlyNotBecauseOfMatrix = FALSE;
@@ -3599,8 +3599,8 @@ BOOL ScDocument::IsSelectedBlockEditable
 											SCCOL nEndCol, SCROW nEndRow,
 											const ScMarkData& rMark ) const
 {
-	// import into read-only document is possible - must be extended if other filters use api
-	if ( pShell && pShell->IsReadOnly() && !bImportingXML )
+    // import into read-only document is possible
+    if ( !bImportingXML && !mbChangeReadOnlyEnabled && pShell && pShell->IsReadOnly() )
 		return FALSE;
 
 	BOOL bOk = TRUE;
@@ -3617,8 +3617,8 @@ BOOL ScDocument::IsSelectedBlockEditable
 BOOL ScDocument::IsSelectionEditable( const ScMarkData& rMark,
 			BOOL* pOnlyNotBecauseOfMatrix /* = NULL */ ) const
 {
-	// import into read-only document is possible - must be extended if other filters use api
-	if ( pShell && pShell->IsReadOnly() && !bImportingXML )
+    // import into read-only document is possible
+    if ( !bImportingXML && !mbChangeReadOnlyEnabled && pShell && pShell->IsReadOnly() )
 	{
 		if ( pOnlyNotBecauseOfMatrix )
 			*pOnlyNotBecauseOfMatrix = FALSE;
@@ -3613,8 +3613,8 @@ BOOL ScDocument::IsSelectionOrBlockEdita
 										SCCOL nEndCol, SCROW nEndRow,
 										const ScMarkData& rMark ) const
 {
-	// import into read-only document is possible - must be extended if other filters use api
-	if ( pShell && pShell->IsReadOnly() && !bImportingXML )
+    // import into read-only document is possible
+    if ( !bImportingXML && !mbChangeReadOnlyEnabled && pShell && pShell->IsReadOnly() )
 		return FALSE;
 
 	BOOL bOk = TRUE;
@@ -3668,8 +3668,8 @@ BOOL ScDocument::IsSelectedOrBlockEditab
 											SCCOL nEndCol, SCROW nEndRow,
 											const ScMarkData& rMark ) const
 {
-	// import into read-only document is possible - must be extended if other filters use api
-	if ( pShell && pShell->IsReadOnly() && !bImportingXML )
+    // import into read-only document is possible
+    if ( !bImportingXML && !mbChangeReadOnlyEnabled && pShell && pShell->IsReadOnly() )
 		return FALSE;
 
 	BOOL bOk = TRUE;
--- sc/source/core/data/global.cxx	6 Jul 2007 12:33:19 -0000	1.52
+++ sc/source/core/data/global.cxx	15 Aug 2007 15:45:37 -0000	1.52.10.2
@@ -569,7 +569,7 @@ void ScGlobal::Init()
     pProtectedBrushItem = new SvxBrushItem( Color( COL_LIGHTGRAY ), ATTR_BACKGROUND );
 
 	UpdatePPT(NULL);
-	ScCompiler::Init();
+	ScCompiler::InitSymbolsNative();
     // ScParameterClassification _after_ Compiler, needs function resources if
     // arguments are to be merged in, which in turn need strings of function
     // names from the compiler.
@@ -1396,7 +1396,7 @@ ScFuncRes::ScFuncRes( ResId &aRes, ScFun
 			pDesc->aDefArgOpt[i] = (BOOL)GetNum();
 	}
 
-	pDesc->pFuncName = new String( ScCompiler::pSymbolTableNative[aRes.GetId()] );
+    pDesc->pFuncName = new String( ScCompiler::GetNativeSymbol( static_cast<OpCode>( aRes.GetId())));
 	pDesc->pFuncDesc = new String(ScResId(1));
 
 	if (nArgs)
--- sc/source/core/data/table1.cxx	27 Feb 2007 12:09:14 -0000	1.20
+++ sc/source/core/data/table1.cxx	20 Jul 2007 12:24:45 -0000	1.20.18.1
@@ -313,6 +313,11 @@ BOOL ScTable::SetOptimalHeight( SCROW nS
 {
 	DBG_ASSERT( nExtra==0 || bForce, "autom. OptimalHeight mit Extra" );
 
+    if ( !pDocument->IsAdjustHeightEnabled() )
+    {
+        return FALSE;
+    }
+
 	BOOL    bChanged = FALSE;
 	SCSIZE  nCount = static_cast<SCSIZE>(nEndRow-nStartRow+1);
 
--- sc/source/core/inc/parclass.hxx	8 Sep 2005 18:34:41 -0000	1.3
+++ sc/source/core/inc/parclass.hxx	23 Oct 2007 12:58:25 -0000	1.3.402.2
@@ -94,8 +94,9 @@ public:
                                     ForceArray. */
     static  inline  bool        HasForceArray( OpCode eOp)
                                     {
-                                        return eOp <= SC_OPCODE_LAST_OPCODE_ID
-                                            && pData[eOp].bHasForceArray;
+                                        return 0 <= (short)eOp &&
+                                            eOp <= SC_OPCODE_LAST_OPCODE_ID &&
+                                            pData[eOp].bHasForceArray;
                                     }
 
 private:
--- sc/source/core/src/compiler.src	3 Jul 2007 15:48:53 -0000	1.54
+++ sc/source/core/src/compiler.src	24 Aug 2007 19:19:09 -0000	1.54.14.3
@@ -1169,6 +1169,11 @@ Resource RID_SC_FUNCTION_NAMES
         Text [ en-US ] = "GETPIVOTDATA";
     };
 };
+
+
+// DO NOT CHANGE!
+// These English names are used internally to store/load ODF v1.0/v1.1 and for
+// API XFunctionAccess.
 Resource RID_SC_FUNCTION_NAMES_ENGLISH
 {
 	String SC_OPCODE_IF { Text = "IF" ; };
@@ -1474,3 +1479,310 @@ Resource RID_SC_FUNCTION_NAMES_ENGLISH
     String SC_OPCODE_GET_PIVOT_DATA { Text = "GETPIVOTDATA" ; };
 };
 
+
+// DO NOT CHANGE!
+// These English names are used internally to store/load ODFF as of ODF v1.2
+Resource RID_SC_FUNCTION_NAMES_ENGLISH_ODFF
+{
+	String SC_OPCODE_IF { Text = "IF" ; };
+	String SC_OPCODE_CHOSE { Text = "CHOOSE" ; };
+	String SC_OPCODE_OPEN { Text = "(" ; };
+	String SC_OPCODE_CLOSE { Text = ")" ; };
+    String SC_OPCODE_ARRAY_OPEN { Text = "{" ; };
+    String SC_OPCODE_ARRAY_CLOSE { Text = "}" ; };
+    String SC_OPCODE_ARRAY_ROW_SEP { Text = "|" ; };
+    String SC_OPCODE_ARRAY_COL_SEP { Text = ";" ; };
+	String SC_OPCODE_SEP { Text = ";" ; };
+    String SC_OPCODE_PERCENT_SIGN { Text = "%" ; };
+	String SC_OPCODE_ADD { Text = "+" ; };
+	String SC_OPCODE_SUB { Text = "-" ; };
+	String SC_OPCODE_MUL { Text = "*" ; };
+	String SC_OPCODE_DIV { Text = "/" ; };
+	String SC_OPCODE_AMPERSAND { Text = "&" ; };
+	String SC_OPCODE_POW { Text = "^" ; };
+	String SC_OPCODE_EQUAL { Text = "=" ; };
+	String SC_OPCODE_NOT_EQUAL { Text = "<>" ; };
+	String SC_OPCODE_LESS { Text = "<" ; };
+	String SC_OPCODE_GREATER { Text = ">" ; };
+	String SC_OPCODE_LESS_EQUAL { Text = "<=" ; };
+	String SC_OPCODE_GREATER_EQUAL { Text = ">=" ; };
+	String SC_OPCODE_AND { Text = "AND" ; };
+	String SC_OPCODE_OR { Text = "OR" ; };
+	String SC_OPCODE_INTERSECT { Text = "!" ; };
+	String SC_OPCODE_UNION { Text = "~" ; };
+	String SC_OPCODE_RANGE { Text = ":" ; };
+	String SC_OPCODE_NOT { Text = "NOT" ; };
+	String SC_OPCODE_NEG { Text = "NEG" ; };
+	String SC_OPCODE_NEG_SUB { Text = "-" ; };
+	String SC_OPCODE_PI { Text = "PI" ; };
+	String SC_OPCODE_RANDOM { Text = "RAND" ; };
+	String SC_OPCODE_TRUE { Text = "TRUE" ; };
+	String SC_OPCODE_FALSE { Text = "FALSE" ; };
+	String SC_OPCODE_GET_ACT_DATE { Text = "TODAY" ; };
+	String SC_OPCODE_GET_ACT_TIME { Text = "NOW" ; };
+	String SC_OPCODE_NO_VALUE { Text = "NA" ; };
+	String SC_OPCODE_CURRENT { Text = "ORG.OPENOFFICE.CURRENT" ; };
+	String SC_OPCODE_DEG { Text = "DEGREES" ; };
+	String SC_OPCODE_RAD { Text = "RADIANS" ; };
+	String SC_OPCODE_SIN { Text = "SIN" ; };
+	String SC_OPCODE_COS { Text = "COS" ; };
+	String SC_OPCODE_TAN { Text = "TAN" ; };
+	String SC_OPCODE_COT { Text = "COT" ; };
+	String SC_OPCODE_ARC_SIN { Text = "ASIN" ; };
+	String SC_OPCODE_ARC_COS { Text = "ACOS" ; };
+	String SC_OPCODE_ARC_TAN { Text = "ATAN" ; };
+	String SC_OPCODE_ARC_COT { Text = "ACOT" ; };
+	String SC_OPCODE_SIN_HYP { Text = "SINH" ; };
+	String SC_OPCODE_COS_HYP { Text = "COSH" ; };
+	String SC_OPCODE_TAN_HYP { Text = "TANH" ; };
+	String SC_OPCODE_COT_HYP { Text = "COTH" ; };
+	String SC_OPCODE_ARC_SIN_HYP { Text = "ASINH" ; };
+	String SC_OPCODE_ARC_COS_HYP { Text = "ACOSH" ; };
+	String SC_OPCODE_ARC_TAN_HYP { Text = "ATANH" ; };
+	String SC_OPCODE_ARC_COT_HYP { Text = "ACOTH" ; };
+	String SC_OPCODE_EXP { Text = "EXP" ; };
+	String SC_OPCODE_LN { Text = "LN" ; };
+	String SC_OPCODE_SQRT { Text = "SQRT" ; };
+	String SC_OPCODE_FACT { Text = "FACT" ; };
+	String SC_OPCODE_GET_YEAR { Text = "YEAR" ; };
+	String SC_OPCODE_GET_MONTH { Text = "MONTH" ; };
+	String SC_OPCODE_GET_DAY { Text = "DAY" ; };
+	String SC_OPCODE_GET_HOUR { Text = "HOUR" ; };
+	String SC_OPCODE_GET_MIN { Text = "MINUTE" ; };
+	String SC_OPCODE_GET_SEC { Text = "SECOND" ; };
+	String SC_OPCODE_PLUS_MINUS { Text = "SIGN" ; };
+	String SC_OPCODE_ABS { Text = "ABS" ; };
+	String SC_OPCODE_INT { Text = "INT" ; };
+	String SC_OPCODE_PHI { Text = "PHI" ; };
+	String SC_OPCODE_GAUSS { Text = "GAUSS" ; };
+	String SC_OPCODE_IS_EMPTY { Text = "ISBLANK" ; };
+	String SC_OPCODE_IS_STRING { Text = "ISTEXT" ; };
+	String SC_OPCODE_IS_NON_STRING { Text = "ISNONTEXT" ; };
+	String SC_OPCODE_IS_LOGICAL { Text = "ISLOGICAL" ; };
+	String SC_OPCODE_TYPE { Text = "TYPE" ; };
+	String SC_OPCODE_CELL { Text = "CELL" ; };
+	String SC_OPCODE_IS_REF { Text = "ISREF" ; };
+	String SC_OPCODE_IS_VALUE { Text = "ISNUMBER" ; };
+	String SC_OPCODE_IS_FORMULA { Text = "ISFORMULA" ; };
+	String SC_OPCODE_IS_NV { Text = "ISNA" ; };
+	String SC_OPCODE_IS_ERR { Text = "ISERR" ; };
+	String SC_OPCODE_IS_ERROR { Text = "ISERROR" ; };
+	String SC_OPCODE_IS_EVEN { Text = "ISEVEN" ; };
+	String SC_OPCODE_IS_ODD { Text = "ISODD" ; };
+	String SC_OPCODE_N { Text = "N" ; };
+	String SC_OPCODE_GET_DATE_VALUE { Text = "DATEVALUE" ; };
+	String SC_OPCODE_GET_TIME_VALUE { Text = "TIMEVALUE" ; };
+	String SC_OPCODE_CODE { Text = "CODE" ; };
+	String SC_OPCODE_TRIM { Text = "TRIM" ; };
+	String SC_OPCODE_UPPER { Text = "UPPER" ; };
+	String SC_OPCODE_PROPPER { Text = "PROPER" ; };
+	String SC_OPCODE_LOWER { Text = "LOWER" ; };
+	String SC_OPCODE_LEN { Text = "LEN" ; };
+	String SC_OPCODE_T { Text = "T" ; };
+	String SC_OPCODE_VALUE { Text = "VALUE" ; };
+	String SC_OPCODE_CLEAN { Text = "CLEAN" ; };
+	String SC_OPCODE_CHAR { Text = "CHAR" ; };
+	String SC_OPCODE_JIS { Text = "JIS" ; };
+	String SC_OPCODE_ASC { Text = "ASC" ; };
+	String SC_OPCODE_LOG10 { Text = "LOG10" ; };
+	String SC_OPCODE_EVEN { Text = "EVEN" ; };
+	String SC_OPCODE_ODD { Text = "ODD" ; };
+	String SC_OPCODE_STD_NORM_DIST { Text = "LEGACY.NORMSDIST" ; };
+	String SC_OPCODE_FISHER { Text = "FISHER" ; };
+	String SC_OPCODE_FISHER_INV { Text = "FISHERINV" ; };
+	String SC_OPCODE_S_NORM_INV { Text = "LEGACY.NORMSINV" ; };
+	String SC_OPCODE_GAMMA_LN { Text = "GAMMALN" ; };
+	String SC_OPCODE_ERROR_TYPE { Text = "ERROR.TYPE" ; };
+	String SC_OPCODE_ERR_CELL { Text = "ZellError" ; };  // TODO: ancient legacy only, remove?
+	String SC_OPCODE_FORMULA { Text = "FORMULA"; };
+	String SC_OPCODE_ARC_TAN_2 { Text = "ATAN2" ; };
+	String SC_OPCODE_CEIL { Text = "CEILING" ; };
+	String SC_OPCODE_FLOOR { Text = "FLOOR" ; };
+	String SC_OPCODE_ROUND { Text = "ROUND" ; };
+	String SC_OPCODE_ROUND_UP { Text = "ROUNDUP" ; };
+	String SC_OPCODE_ROUND_DOWN { Text = "ROUNDDOWN" ; };
+	String SC_OPCODE_TRUNC { Text = "TRUNC" ; };
+	String SC_OPCODE_LOG { Text = "LOG" ; };
+	String SC_OPCODE_POWER { Text = "POWER" ; };
+	String SC_OPCODE_GGT { Text = "GCD" ; };
+	String SC_OPCODE_KGV { Text = "LCM" ; };
+	String SC_OPCODE_MOD { Text = "MOD" ; };
+	String SC_OPCODE_SUM_PRODUCT { Text = "SUMPRODUCT" ; };
+	String SC_OPCODE_SUM_SQ { Text = "SUMSQ" ; };
+	String SC_OPCODE_SUM_X2MY2 { Text = "SUMX2MY2" ; };
+	String SC_OPCODE_SUM_X2DY2 { Text = "SUMX2PY2" ; };
+	String SC_OPCODE_SUM_XMY2 { Text = "SUMXMY2" ; };
+	String SC_OPCODE_GET_DATE { Text = "DATE" ; };
+	String SC_OPCODE_GET_TIME { Text = "TIME" ; };
+	String SC_OPCODE_GET_DIFF_DATE { Text = "DAYS" ; };
+	String SC_OPCODE_GET_DIFF_DATE_360 { Text = "DAYS360" ; };
+	String SC_OPCODE_MIN { Text = "MIN" ; };
+	String SC_OPCODE_MIN_A { Text = "MINA" ; };
+	String SC_OPCODE_MAX { Text = "MAX" ; };
+	String SC_OPCODE_MAX_A { Text = "MAXA" ; };
+	String SC_OPCODE_SUM { Text = "SUM" ; };
+	String SC_OPCODE_PRODUCT { Text = "PRODUCT" ; };
+	String SC_OPCODE_AVERAGE { Text = "AVERAGE" ; };
+	String SC_OPCODE_AVERAGE_A { Text = "AVERAGEA" ; };
+	String SC_OPCODE_COUNT { Text = "COUNT" ; };
+	String SC_OPCODE_COUNT_2 { Text = "COUNTA" ; };
+	String SC_OPCODE_NBW { Text = "NPV" ; };
+	String SC_OPCODE_IKV { Text = "IRR" ; };
+	String SC_OPCODE_MIRR { Text = "MIRR" ; };
+	String SC_OPCODE_ISPMT { Text = "ISPMT" ; };
+	String SC_OPCODE_VAR { Text = "VAR" ; };
+	String SC_OPCODE_VAR_A { Text = "VARA" ; };
+	String SC_OPCODE_VAR_P { Text = "VARP" ; };
+	String SC_OPCODE_VAR_P_A { Text = "VARPA" ; };
+	String SC_OPCODE_ST_DEV { Text = "STDEV" ; };
+	String SC_OPCODE_ST_DEV_A { Text = "STDEVA" ; };
+	String SC_OPCODE_ST_DEV_P { Text = "STDEVP" ; };
+	String SC_OPCODE_ST_DEV_P_A { Text = "STDEVPA" ; };
+	String SC_OPCODE_B { Text = "B" ; };
+	String SC_OPCODE_NORM_DIST { Text = "NORMDIST" ; };
+	String SC_OPCODE_EXP_DIST { Text = "EXPONDIST" ; };
+	String SC_OPCODE_BINOM_DIST { Text = "BINOMDIST" ; };
+	String SC_OPCODE_POISSON_DIST { Text = "POISSON" ; };
+	String SC_OPCODE_KOMBIN { Text = "COMBIN" ; };
+	String SC_OPCODE_KOMBIN_2 { Text = "COMBINA" ; };
+	String SC_OPCODE_VARIATIONEN { Text = "PERMUT" ; };
+	String SC_OPCODE_VARIATIONEN_2 { Text = "PERMUTATIONA" ; };
+	String SC_OPCODE_BW { Text = "PV" ; };
+	String SC_OPCODE_DIA { Text = "SYD" ; };
+	String SC_OPCODE_GDA { Text = "DDB" ; };
+	String SC_OPCODE_GDA_2 { Text = "DB" ; };
+	String SC_OPCODE_VBD { Text = "VDB" ; };
+	String SC_OPCODE_LAUFZ { Text = "PDURATION" ; };
+	String SC_OPCODE_LIA { Text = "SLN" ; };
+	String SC_OPCODE_RMZ { Text = "PMT" ; };
+	String SC_OPCODE_COLUMNS { Text = "COLUMNS" ; };
+	String SC_OPCODE_ROWS { Text = "ROWS" ; };
+	String SC_OPCODE_TABLES { Text = "SHEETS" ; };
+	String SC_OPCODE_COLUMN { Text = "COLUMN" ; };
+	String SC_OPCODE_ROW { Text = "ROW" ; };
+	String SC_OPCODE_TABLE { Text = "SHEET" ; };
+	String SC_OPCODE_ZGZ { Text = "ZGZ" ; };
+	String SC_OPCODE_ZW { Text = "FV" ; };
+	String SC_OPCODE_ZZR { Text = "NPER" ; };
+	String SC_OPCODE_ZINS { Text = "RATE" ; };
+	String SC_OPCODE_ZINS_Z { Text = "IPMT" ; };
+	String SC_OPCODE_KAPZ { Text = "PPMT" ; };
+	String SC_OPCODE_KUM_ZINS_Z { Text = "CUMIPMT" ; };
+	String SC_OPCODE_KUM_KAP_Z { Text = "CUMPRINC" ; };
+	String SC_OPCODE_EFFEKTIV { Text = "EFFECT" ; };
+	String SC_OPCODE_NOMINAL { Text = "NOMINAL" ; };
+	String SC_OPCODE_SUB_TOTAL { Text = "SUBTOTAL" ; };
+	String SC_OPCODE_DB_SUM { Text = "DSUM" ; };
+	String SC_OPCODE_DB_COUNT { Text = "DCOUNT" ; };
+	String SC_OPCODE_DB_COUNT_2 { Text = "DCOUNTA" ; };
+	String SC_OPCODE_DB_AVERAGE { Text = "DAVERAGE" ; };
+	String SC_OPCODE_DB_GET { Text = "DGET" ; };
+	String SC_OPCODE_DB_MAX { Text = "DMAX" ; };
+	String SC_OPCODE_DB_MIN { Text = "DMIN" ; };
+	String SC_OPCODE_DB_PRODUCT { Text = "DPRODUCT" ; };
+	String SC_OPCODE_DB_STD_DEV { Text = "DSTDEV" ; };
+	String SC_OPCODE_DB_STD_DEV_P { Text = "DSTDEVP" ; };
+	String SC_OPCODE_DB_VAR { Text = "DVAR" ; };
+	String SC_OPCODE_DB_VAR_P { Text = "DVARP" ; };
+	String SC_OPCODE_INDIRECT { Text = "INDIRECT" ; };
+	String SC_OPCODE_ADDRESS { Text = "ADDRESS" ; };
+	String SC_OPCODE_MATCH { Text = "MATCH" ; };
+	String SC_OPCODE_COUNT_EMPTY_CELLS { Text = "COUNTBLANK" ; };
+	String SC_OPCODE_COUNT_IF { Text = "COUNTIF" ; };
+	String SC_OPCODE_SUM_IF { Text = "SUMIF" ; };
+	String SC_OPCODE_LOOKUP { Text = "LOOKUP" ; };
+	String SC_OPCODE_V_LOOKUP { Text = "VLOOKUP" ; };
+	String SC_OPCODE_H_LOOKUP { Text = "HLOOKUP" ; };
+	String SC_OPCODE_MULTI_AREA { Text = "MULTIRANGE" ; };      // TODO: legacy for range list (union), remove if done.
+	String SC_OPCODE_OFFSET { Text = "OFFSET" ; };
+	String SC_OPCODE_INDEX { Text = "INDEX" ; };
+	String SC_OPCODE_AREAS { Text = "AREAS" ; };
+	String SC_OPCODE_CURRENCY { Text = "DOLLAR" ; };
+	String SC_OPCODE_REPLACE { Text = "REPLACE" ; };
+	String SC_OPCODE_FIXED { Text = "FIXED" ; };
+	String SC_OPCODE_FIND { Text = "FIND" ; };
+	String SC_OPCODE_EXACT { Text = "EXACT" ; };
+	String SC_OPCODE_LEFT { Text = "LEFT" ; };
+	String SC_OPCODE_RIGHT { Text = "RIGHT" ; };
+	String SC_OPCODE_SEARCH { Text = "SEARCH" ; };
+	String SC_OPCODE_MID { Text = "MID" ; };
+	String SC_OPCODE_TEXT { Text = "TEXT" ; };
+	String SC_OPCODE_SUBSTITUTE { Text = "SUBSTITUTE" ; };
+	String SC_OPCODE_REPT { Text = "REPT" ; };
+	String SC_OPCODE_CONCAT { Text = "CONCATENATE" ; };
+	String SC_OPCODE_MAT_VALUE { Text = "MVALUE" ; };
+	String SC_OPCODE_MAT_DET { Text = "MDETERM" ; };
+	String SC_OPCODE_MAT_INV { Text = "MINVERSE" ; };
+	String SC_OPCODE_MAT_MULT { Text = "MMULT" ; };
+	String SC_OPCODE_MAT_TRANS { Text = "TRANSPOSE" ; };
+	String SC_OPCODE_MATRIX_UNIT { Text = "MUNIT" ; };
+	String SC_OPCODE_BACK_SOLVER { Text = "GOALSEEK" ; };
+	String SC_OPCODE_HYP_GEOM_DIST { Text = "HYPGEOMDIST" ; };
+	String SC_OPCODE_LOG_NORM_DIST { Text = "LOGNORMDIST" ; };
+	String SC_OPCODE_T_DIST { Text = "TDIST" ; };
+	String SC_OPCODE_F_DIST { Text = "LEGACY.FDIST" ; };
+	String SC_OPCODE_CHI_DIST { Text = "LEGACY.CHIDIST" ; };
+	String SC_OPCODE_WEIBULL { Text = "WEIBULL" ; };
+	String SC_OPCODE_NEG_BINOM_VERT { Text = "NEGBINOMDIST" ; };
+	String SC_OPCODE_KRIT_BINOM { Text = "CRITBINOM" ; };
+	String SC_OPCODE_KURT { Text = "KURT" ; };
+	String SC_OPCODE_HAR_MEAN { Text = "HARMEAN" ; };
+	String SC_OPCODE_GEO_MEAN { Text = "GEOMEAN" ; };
+	String SC_OPCODE_STANDARD { Text = "STANDARDIZE" ; };
+	String SC_OPCODE_AVE_DEV { Text = "AVEDEV" ; };
+	String SC_OPCODE_SCHIEFE { Text = "SKEW" ; };
+	String SC_OPCODE_DEV_SQ { Text = "DEVSQ" ; };
+	String SC_OPCODE_MEDIAN { Text = "MEDIAN" ; };
+	String SC_OPCODE_MODAL_VALUE { Text = "MODE" ; };
+	String SC_OPCODE_Z_TEST { Text = "ZTEST" ; };
+	String SC_OPCODE_T_TEST { Text = "TTEST" ; };
+	String SC_OPCODE_RANK { Text = "RANK" ; };
+	String SC_OPCODE_PERCENTILE { Text = "PERCENTILE" ; };
+	String SC_OPCODE_PERCENT_RANK { Text = "PERCENTRANK" ; };
+	String SC_OPCODE_LARGE { Text = "LARGE" ; };
+	String SC_OPCODE_SMALL { Text = "SMALL" ; };
+	String SC_OPCODE_FREQUENCY { Text = "FREQUENCY" ; };
+	String SC_OPCODE_QUARTILE { Text = "QUARTILE" ; };
+	String SC_OPCODE_NORM_INV { Text = "NORMINV" ; };
+	String SC_OPCODE_CONFIDENCE { Text = "CONFIDENCE" ; };
+	String SC_OPCODE_F_TEST { Text = "FTEST" ; };
+	String SC_OPCODE_TRIM_MEAN { Text = "TRIMMEAN" ; };
+	String SC_OPCODE_PROB { Text = "PROB" ; };
+	String SC_OPCODE_CORREL { Text = "CORREL" ; };
+	String SC_OPCODE_COVAR { Text = "COVAR" ; };
+	String SC_OPCODE_PEARSON { Text = "PEARSON" ; };
+	String SC_OPCODE_RSQ { Text = "RSQ" ; };
+	String SC_OPCODE_STEYX { Text = "STEYX" ; };
+	String SC_OPCODE_SLOPE { Text = "SLOPE" ; };
+	String SC_OPCODE_INTERCEPT { Text = "INTERCEPT" ; };
+	String SC_OPCODE_TREND { Text = "TREND" ; };
+	String SC_OPCODE_GROWTH { Text = "GROWTH" ; };
+	String SC_OPCODE_RGP { Text = "LINEST" ; };
+	String SC_OPCODE_RKP { Text = "LOGEST" ; };
+	String SC_OPCODE_FORECAST { Text = "FORECAST" ; };
+	String SC_OPCODE_CHI_INV { Text = "LEGACY.CHIINV" ; };
+	String SC_OPCODE_GAMMA_DIST { Text = "GAMMADIST" ; };
+	String SC_OPCODE_GAMMA_INV { Text = "GAMMAINV" ; };
+	String SC_OPCODE_T_INV { Text = "TINV" ; };
+	String SC_OPCODE_F_INV { Text = "LEGACY.FINV" ; };
+	String SC_OPCODE_CHI_TEST { Text = "LEGACY.CHITEST" ; };
+	String SC_OPCODE_LOG_INV { Text = "LOGINV" ; };
+	String SC_OPCODE_TABLE_OP { Text = "MULTIPLE.OPERATIONS" ; };
+	String SC_OPCODE_BETA_DIST { Text = "BETADIST" ; };
+	String SC_OPCODE_BETA_INV { Text = "BETAINV" ; };
+	String SC_OPCODE_WEEK { Text = "ISOWEEKNUM" ; };
+	String SC_OPCODE_EASTERSUNDAY { Text = "EASTERSUNDAY" ; };
+	String SC_OPCODE_GET_DAY_OF_WEEK { Text = "WEEKDAY" ; };
+	String SC_OPCODE_NO_NAME { Text = "#NAME!" ; };
+	String SC_OPCODE_STYLE { Text = "ORG.OPENOFFICE.STYLE" ; };
+	String SC_OPCODE_DDE { Text = "DDE" ; };
+	String SC_OPCODE_BASE { Text = "BASE" ; };
+	String SC_OPCODE_DECIMAL { Text = "DECIMAL" ; };
+	String SC_OPCODE_CONVERT { Text = "ORG.OPENOFFICE.CONVERT" ; };
+	String SC_OPCODE_ROMAN { Text = "ROMAN" ; };
+	String SC_OPCODE_ARABIC { Text = "ARABIC" ; };
+	String SC_OPCODE_HYPERLINK { Text = "HYPERLINK" ; };
+    String SC_OPCODE_INFO { Text = "INFO" ; };
+    String SC_OPCODE_BAHTTEXT { Text = "COM.MICROSOFT.BAHTTEXT" ; };
+    String SC_OPCODE_GET_PIVOT_DATA { Text = "GETPIVOTDATA" ; };
+};
--- sc/source/core/tool/addincol.cxx	6 Jul 2007 12:34:33 -0000	1.22
+++ sc/source/core/tool/addincol.cxx	30 Aug 2007 09:24:13 -0000	1.22.10.3
@@ -70,6 +70,7 @@
 #include "optutil.hxx"
 #include "addincfg.hxx"
 #include "scmod.hxx"
+#include "rangeseq.hxx"
 
 using namespace com::sun::star;
 
@@ -205,6 +206,47 @@ void ScUnoAddInFuncData::SetCompNames( c
     bCompInitialized = TRUE;
 }
 
+BOOL ScUnoAddInFuncData::GetExcelName( LanguageType eDestLang, String& rRetExcelName ) const
+{
+    const uno::Sequence<sheet::LocalizedName>& rSequence = GetCompNames();
+    long nSeqLen = rSequence.getLength();
+    if ( nSeqLen )
+    {
+        const sheet::LocalizedName* pArray = rSequence.getConstArray();
+        long i;
+
+        rtl::OUString aLangStr, aCountryStr;
+        MsLangId::convertLanguageToIsoNames( eDestLang, aLangStr, aCountryStr );
+        rtl::OUString aUserLang = aLangStr.toAsciiLowerCase();
+        rtl::OUString aUserCountry = aCountryStr.toAsciiUpperCase();
+
+        //  first check for match of both language and country
+
+        for ( i=0; i<nSeqLen; i++)
+            if ( pArray[i].Locale.Language == aUserLang &&
+                    pArray[i].Locale.Country  == aUserCountry )
+            {
+                rRetExcelName = pArray[i].Name;
+                return TRUE;
+            }
+
+        //  second: check only language
+
+        for ( i=0; i<nSeqLen; i++)
+            if ( pArray[i].Locale.Language == aUserLang )
+            {
+                rRetExcelName = pArray[i].Name;
+                return TRUE;
+            }
+
+        //  third: use first (default) entry
+
+        rRetExcelName = pArray[0].Name;
+        return TRUE;
+    }
+    return FALSE;
+}
+
 void ScUnoAddInFuncData::SetFunction( const uno::Reference< reflection::XIdlMethod>& rNewFunc, const uno::Any& rNewObj )
 {
     xFunction = rNewFunc;
@@ -233,38 +275,6 @@ void ScUnoAddInFuncData::SetCallerPos( l
 
 //------------------------------------------------------------------------
 
-BOOL lcl_ConvertToDouble( const uno::Any& rAny, double& rOut )
-{
-    BOOL bRet = FALSE;
-    uno::TypeClass eClass = rAny.getValueTypeClass();
-    switch (eClass)
-    {
-        //! extract integer values
-        case uno::TypeClass_ENUM:
-        case uno::TypeClass_BOOLEAN:
-        case uno::TypeClass_CHAR:
-        case uno::TypeClass_BYTE:
-        case uno::TypeClass_SHORT:
-        case uno::TypeClass_UNSIGNED_SHORT:
-        case uno::TypeClass_LONG:
-        case uno::TypeClass_UNSIGNED_LONG:
-        case uno::TypeClass_FLOAT:
-        case uno::TypeClass_DOUBLE:
-            rAny >>= rOut;
-            bRet = TRUE;
-            break;
-        default:
-        {
-            // added to avoid warnings
-        }
-    }
-    if (!bRet)
-        rOut = 0.0;
-    return bRet;
-}
-
-//------------------------------------------------------------------------
-
 ScUnoAddInCollection::ScUnoAddInCollection() :
     nFuncCount( 0 ),
     ppFuncData( NULL ),
@@ -657,44 +667,7 @@ BOOL ScUnoAddInCollection::GetExcelName(
 {
     const ScUnoAddInFuncData* pFuncData = GetFuncData( rCalcName );
     if ( pFuncData )
-    {
-        const uno::Sequence<sheet::LocalizedName>& rSequence = pFuncData->GetCompNames();
-        long nSeqLen = rSequence.getLength();
-        if ( nSeqLen )
-        {
-            const sheet::LocalizedName* pArray = rSequence.getConstArray();
-            long i;
-
-            rtl::OUString aLangStr, aCountryStr;
-            MsLangId::convertLanguageToIsoNames( eDestLang, aLangStr, aCountryStr );
-            rtl::OUString aUserLang = aLangStr.toAsciiLowerCase();
-            rtl::OUString aUserCountry = aCountryStr.toAsciiUpperCase();
-
-            //  first check for match of both language and country
-
-            for ( i=0; i<nSeqLen; i++)
-                if ( pArray[i].Locale.Language == aUserLang &&
-                     pArray[i].Locale.Country  == aUserCountry )
-                {
-                    rRetExcelName = pArray[i].Name;
-                    return TRUE;
-                }
-
-            //  second: check only language
-
-            for ( i=0; i<nSeqLen; i++)
-                if ( pArray[i].Locale.Language == aUserLang )
-                {
-                    rRetExcelName = pArray[i].Name;
-                    return TRUE;
-                }
-
-            //  third: use first (default) entry
-
-            rRetExcelName = pArray[0].Name;
-            return TRUE;
-        }
-    }
+        return pFuncData->GetExcelName( eDestLang, rRetExcelName);
     return FALSE;
 }
 
@@ -1305,6 +1278,16 @@ const ScUnoAddInFuncData* ScUnoAddInColl
     return NULL;
 }
 
+const ScUnoAddInFuncData* ScUnoAddInCollection::GetFuncData( long nIndex )
+{
+    if (!bInitialized)
+        Initialize();
+
+    if (nIndex < nFuncCount)
+        return ppFuncData[nIndex];
+    return NULL;
+}
+
 void ScUnoAddInCollection::LocalizeString( String& rName )
 {
     if (!bInitialized)
@@ -1412,7 +1395,7 @@ ScUnoAddInCall::ScUnoAddInCall( ScUnoAdd
     nErrCode( errNoCode ),      // before function was called
     bHasString( TRUE ),
     fValue( 0.0 ),
-    pMatrix( NULL )
+    xMatrix( NULL )
 {
     pFuncData = rColl.GetFuncData( rName, true );           // need fully initialized data
     DBG_ASSERT( pFuncData, "Function Data missing" );
@@ -1447,9 +1430,6 @@ ScUnoAddInCall::ScUnoAddInCall( ScUnoAdd
 ScUnoAddInCall::~ScUnoAddInCall()
 {
     // pFuncData is deleted with ScUnoAddInCollection
-
-    if ( pMatrix )
-        pMatrix->Delete();
 }
 
 BOOL ScUnoAddInCall::ValidParamCount()
@@ -1638,8 +1618,11 @@ void ScUnoAddInCall::SetResult( const un
         case uno::TypeClass_UNSIGNED_LONG:
         case uno::TypeClass_FLOAT:
         case uno::TypeClass_DOUBLE:
-            lcl_ConvertToDouble( rNewRes, fValue );
+            {
+                uno::TypeClass eMyClass;
+                ScApiTypeConversion::ConvertAnyToDouble( fValue, eMyClass, rNewRes);
             bHasString = FALSE;
+            }
             break;
 
         case uno::TypeClass_STRING:
@@ -1688,9 +1671,10 @@ void ScUnoAddInCall::SetResult( const un
                     }
                     if ( nMaxColCount && nRowCount )
                     {
-                        pMatrix = new ScMatrix(
+                        xMatrix = new ScMatrix(
                                 static_cast<SCSIZE>(nMaxColCount),
                                 static_cast<SCSIZE>(nRowCount) );
+                        ScMatrix* pMatrix = xMatrix;
                         for (nRow=0; nRow<nRowCount; nRow++)
                         {
                             long nColCount = pRowArr[nRow].getLength();
@@ -1730,9 +1714,10 @@ void ScUnoAddInCall::SetResult( const un
                     }
                     if ( nMaxColCount && nRowCount )
                     {
-                        pMatrix = new ScMatrix(
+                        xMatrix = new ScMatrix(
                                 static_cast<SCSIZE>(nMaxColCount),
                                 static_cast<SCSIZE>(nRowCount) );
+                        ScMatrix* pMatrix = xMatrix;
                         for (nRow=0; nRow<nRowCount; nRow++)
                         {
                             long nColCount = pRowArr[nRow].getLength();
@@ -1772,9 +1757,10 @@ void ScUnoAddInCall::SetResult( const un
                     }
                     if ( nMaxColCount && nRowCount )
                     {
-                        pMatrix = new ScMatrix(
+                        xMatrix = new ScMatrix(
                                 static_cast<SCSIZE>(nMaxColCount),
                                 static_cast<SCSIZE>(nRowCount) );
+                        ScMatrix* pMatrix = xMatrix;
                         for (nRow=0; nRow<nRowCount; nRow++)
                         {
                             long nColCount = pRowArr[nRow].getLength();
@@ -1793,68 +1779,10 @@ void ScUnoAddInCall::SetResult( const un
             }
             else if ( aType.equals( getCppuType( (uno::Sequence< uno::Sequence<uno::Any> > *)0 ) ) )
             {
-                const uno::Sequence< uno::Sequence<uno::Any> >* pRowSeq = NULL;
-
-                //! use pointer from any!
-                uno::Sequence< uno::Sequence<uno::Any> > aSequence;
-                if ( rNewRes >>= aSequence )
-                    pRowSeq = &aSequence;
-
-                if ( pRowSeq )
-                {
-                    long nRowCount = pRowSeq->getLength();
-                    const uno::Sequence<uno::Any>* pRowArr = pRowSeq->getConstArray();
-                    long nMaxColCount = 0;
-                    long nCol, nRow;
-                    for (nRow=0; nRow<nRowCount; nRow++)
-                    {
-                        long nTmp = pRowArr[nRow].getLength();
-                        if ( nTmp > nMaxColCount )
-                            nMaxColCount = nTmp;
-                    }
-                    if ( nMaxColCount && nRowCount )
-                    {
-                        rtl::OUString aUStr;
-                        pMatrix = new ScMatrix(
-                                static_cast<SCSIZE>(nMaxColCount),
-                                static_cast<SCSIZE>(nRowCount) );
-                        for (nRow=0; nRow<nRowCount; nRow++)
-                        {
-                            long nColCount = pRowArr[nRow].getLength();
-                            const uno::Any* pColArr = pRowArr[nRow].getConstArray();
-                            for (nCol=0; nCol<nColCount; nCol++)
-                            {
-                                //Reflection* pRefl = pColArr[nCol].getReflection();
-                                //if ( pRefl->equals( *OUString_getReflection() ) )
-                                if ( pColArr[nCol] >>= aUStr )
-                                    pMatrix->PutString( String( aUStr ),
-                                        static_cast<SCSIZE>(nCol),
-                                        static_cast<SCSIZE>(nRow) );
-                                else
-                                {
-                                    // try to convert to double, empty if not possible
-
-                                    double fCellVal;
-                                    if ( lcl_ConvertToDouble( pColArr[nCol], fCellVal ) )
-                                        pMatrix->PutDouble( fCellVal,
-                                                static_cast<SCSIZE>(nCol),
-                                                static_cast<SCSIZE>(nRow) );
-                                    else
-                                        pMatrix->PutEmpty(
-                                                static_cast<SCSIZE>(nCol),
-                                                static_cast<SCSIZE>(nRow) );
-                                }
-                            }
-                            for (nCol=nColCount; nCol<nMaxColCount; nCol++)
-                                pMatrix->PutString( EMPTY_STRING,
-                                        static_cast<SCSIZE>(nCol),
-                                        static_cast<SCSIZE>(nRow) );
-                        }
-                    }
-                }
+                xMatrix = ScSequenceToMatrix::CreateMixedMatrix( rNewRes );
             }
 
-            if (!pMatrix)                       // no array found
+            if (!xMatrix)                       // no array found
                 nErrCode = errNoValue;          //! code for error in return type???
     }
 }
--- sc/source/core/tool/address.cxx	27 Feb 2007 12:11:39 -0000	1.9
+++ sc/source/core/tool/address.cxx	27 Jun 2007 15:40:35 -0000	1.9.18.1
@@ -272,7 +272,12 @@ lcl_ScRange_Parse_XL_Header( ScRange& r,
             nFlags |= SCA_VALID_TAB2 | SCA_TAB2_3D | SCA_TAB2_ABSOLUTE;
         }
         else
-            r.aEnd.SetTab( 0 );
+        {
+            // If only one sheet is given, the full reference is still valid,
+            // only the second 3D flag is not set.
+            nFlags |= SCA_VALID_TAB2 | SCA_TAB2_ABSOLUTE;
+            r.aEnd.SetTab( r.aStart.Tab() );
+        }
 
         if( *p++ != '!' )
             return start;   // syntax error
--- sc/source/core/tool/compiler.cxx	6 Jul 2007 12:34:52 -0000	1.70
+++ sc/source/core/tool/compiler.cxx	12 Oct 2007 15:51:45 -0000	1.68.18.17
@@ -47,6 +47,10 @@
 #include <tools/rc.hxx>
 #include <tools/solar.h>
 #include <unotools/charclass.hxx>
+#include <com/sun/star/sheet/FormulaOpCodeMapEntry.hpp>
+#include <com/sun/star/sheet/FormulaLanguage.hpp>
+#include <com/sun/star/sheet/FormulaMapGroup.hpp>
+#include <com/sun/star/sheet/FormulaMapGroupSpecialOffset.hpp>
 #ifndef _COMPHELPER_PROCESSFACTORY_HXX_
 #include <comphelper/processfactory.hxx>
 #endif
@@ -82,19 +86,47 @@
 #include "parclass.hxx"
 #include "autonamecache.hxx"
 
+using namespace ::com::sun::star;
+using rtl::OUString;
 
-String* ScCompiler::pSymbolTableNative = NULL;
-String* ScCompiler::pSymbolTableEnglish = NULL;
-USHORT  ScCompiler::nAnzStrings = 0;
-ScOpCodeHashMap* ScCompiler::pSymbolHashMapNative = NULL;
-ScOpCodeHashMap* ScCompiler::pSymbolHashMapEnglish = NULL;
+#if OSL_DEBUG_LEVEL > 1
+// For some unknown reason the identical dbg_dump utilities in
+// tools/source/string/debugprint.cxx tend to crash when called from within
+// gdb. Having them here also comes handy as libtl*.so doesn't have to be
+// replaced.
+const char* dbg_sc_dump( const ByteString & rStr )
+{
+    static ByteString aStr;
+    aStr = rStr;
+    aStr.Append(static_cast<char>(0));
+    return aStr.GetBuffer();
+}
+const char* dbg_sc_dump( const UniString & rStr )
+{
+    return dbg_sc_dump(ByteString(rStr, RTL_TEXTENCODING_UTF8));
+}
+const char* dbg_sc_dump( const sal_Unicode * pBuf )
+{
+    return dbg_sc_dump( UniString( pBuf));
+}
+const char* dbg_sc_dump( const sal_Unicode c )
+{
+    return dbg_sc_dump( UniString( c));
+}
+#endif
+
+ScCompiler::NonConstOpCodeMapPtr    ScCompiler::mxSymbolsODFF;
+ScCompiler::NonConstOpCodeMapPtr    ScCompiler::mxSymbolsODF_11;
+ScCompiler::NonConstOpCodeMapPtr    ScCompiler::mxSymbolsNative;
+ScCompiler::NonConstOpCodeMapPtr    ScCompiler::mxSymbolsEnglish;
 CharClass* ScCompiler::pCharClassEnglish = NULL;
-const ScCompiler::Convention* ScCompiler::pConventions[ ] = { NULL, NULL, NULL };
+const ScCompiler::Convention*       ScCompiler::pConventions[ ]   = { NULL, NULL, NULL, NULL };
 
 enum ScanState
 {
     ssGetChar,
     ssGetBool,
+    ssGetValue,
     ssGetString,
     ssSkipString,
     ssGetIdent,
@@ -188,10 +220,10 @@ short lcl_GetRetFormat( OpCode eOpCode )
 class ScOpCodeList : public Resource        // temp object for resource
 {
 public:
-    ScOpCodeList( USHORT, String[], ScOpCodeHashMap& );
+    ScOpCodeList( USHORT, ScCompiler::NonConstOpCodeMapPtr );
 };
 
-ScOpCodeList::ScOpCodeList( USHORT nRID, String pSymbolTable[], ScOpCodeHashMap& rHashMap )
+ScOpCodeList::ScOpCodeList( USHORT nRID, ScCompiler::NonConstOpCodeMapPtr xMap )
         :
         Resource( ScResId( nRID ) )
 {
@@ -200,10 +232,7 @@ ScOpCodeList::ScOpCodeList( USHORT nRID,
         ScResId aRes(i);
         aRes.SetRT(RSC_STRING);
         if (IsAvailableRes(aRes))
-        {
-            pSymbolTable[i] = aRes;
-            rHashMap.insert( ScOpCodeHashMap::value_type( pSymbolTable[i], (OpCode) i ) );
-        }
+            xMap->putOpCode( aRes, OpCode(i));
     }
     FreeResource();
 }
@@ -220,42 +249,154 @@ public:
 };
 
 
-void ScCompiler::Init()
+// static
+void ScCompiler::fillFromAddInMap( NonConstOpCodeMapPtr xMap, size_t nSymbolOffset )
 {
-    if (NULL != pSymbolTableNative)
-        return;
+    const AddInMap* pMap = GetAddInMap();
+    const AddInMap* const pStop = pMap + GetAddInMapCount();
+    for ( ; pMap < pStop; ++pMap)
+    {
+        char const * const * ppSymbol =
+            reinterpret_cast< char const * const * >(
+                    reinterpret_cast< char const * >(pMap) + nSymbolOffset);
+        xMap->putExternal( String::CreateFromAscii( *ppSymbol),
+                String::CreateFromAscii( pMap->pOriginal));
+    }
+}
 
-    pSymbolTableNative = new String[SC_OPCODE_LAST_OPCODE_ID+1];
-    pSymbolHashMapNative = new ScOpCodeHashMap( SC_OPCODE_LAST_OPCODE_ID+1 );
-    ScOpCodeList aOpCodeListNative( RID_SC_FUNCTION_NAMES, pSymbolTableNative,
-            *pSymbolHashMapNative );
-    nAnzStrings = SC_OPCODE_LAST_OPCODE_ID+1;
+// static
+void ScCompiler::fillFromAddInCollectionUpperName( NonConstOpCodeMapPtr xMap )
+{
+    ScUnoAddInCollection* pColl = ScGlobal::GetAddInCollection();
+    long nCount = pColl->GetFuncCount();
+    for (long i=0; i < nCount; ++i)
+    {
+        const ScUnoAddInFuncData* pFuncData = pColl->GetFuncData(i);
+        if (pFuncData)
+            xMap->putExternalSoftly( pFuncData->GetUpperName(),
+                    pFuncData->GetOriginalName());
+    }
 }
 
-void ScCompiler::DeInit()
+// static
+void ScCompiler::fillFromAddInCollectionEnglishName( NonConstOpCodeMapPtr xMap )
 {
-    if (pSymbolTableNative)
+    ScUnoAddInCollection* pColl = ScGlobal::GetAddInCollection();
+    long nCount = pColl->GetFuncCount();
+    for (long i=0; i < nCount; ++i)
     {
-        delete [] pSymbolTableNative;
-        pSymbolTableNative = NULL;
+        const ScUnoAddInFuncData* pFuncData = pColl->GetFuncData(i);
+        if (pFuncData)
+        {
+            String aName;
+            if (pFuncData->GetExcelName( LANGUAGE_ENGLISH_US, aName))
+                xMap->putExternalSoftly( aName, pFuncData->GetOriginalName());
+            else
+                xMap->putExternalSoftly( pFuncData->GetUpperName(),
+                        pFuncData->GetOriginalName());
     }
-    if (pSymbolTableEnglish)
+    }
+}
+
+
+// static
+void ScCompiler::InitSymbolsNative()
     {
-        delete [] pSymbolTableEnglish;
-        pSymbolTableEnglish = NULL;
+    if (mxSymbolsNative.get())
+        return;
+
+    // Not English (even if localization is English), Core, no ODF
+    mxSymbolsNative.reset( new OpCodeMap( SC_OPCODE_LAST_OPCODE_ID + 1, false, true, false));
+    ScOpCodeList aOpCodeListNative( RID_SC_FUNCTION_NAMES, mxSymbolsNative);
+
+    // No AddInMap for native core mapping.
     }
-    if ( pSymbolHashMapNative )
+
+// static
+void ScCompiler::InitSymbolsEnglish()
     {
-        pSymbolHashMapNative->clear();
-        delete pSymbolHashMapNative;
-        pSymbolHashMapNative = NULL;
+    if (mxSymbolsEnglish.get())
+        return;
+
+    // English, Core, no ODF
+    mxSymbolsEnglish.reset( new OpCodeMap( SC_OPCODE_LAST_OPCODE_ID + 1, true, true, false));
+    ScOpCodeList aOpCodeList( RID_SC_FUNCTION_NAMES_ENGLISH, mxSymbolsEnglish );
+
+    fillFromAddInMap( mxSymbolsEnglish, offsetof( AddInMap, pEnglish));
+    // Fill from collection for AddIns not already present.
+    fillFromAddInCollectionEnglishName( mxSymbolsEnglish);
     }
-    if ( pSymbolHashMapEnglish )
+
+// static
+void ScCompiler::InitSymbolsODF_11()
     {
-        pSymbolHashMapEnglish->clear();
-        delete pSymbolHashMapEnglish;
-        pSymbolHashMapEnglish = NULL;
+    if (mxSymbolsODF_11.get())
+        return;
+
+    // English, Core, ODF
+    mxSymbolsODF_11.reset( new OpCodeMap( SC_OPCODE_LAST_OPCODE_ID + 1, true, true, true));
+    // So far ODF_11 internal names are identical to English.
+    ScOpCodeList aOpCodeList( RID_SC_FUNCTION_NAMES_ENGLISH, mxSymbolsODF_11 );
+
+    fillFromAddInMap( mxSymbolsODF_11, offsetof( AddInMap, pUpper));
+    // Fill from collection for AddIns not already present.
+    fillFromAddInCollectionUpperName( mxSymbolsODF_11);
     }
+
+// static
+void ScCompiler::InitSymbolsODFF()
+{
+    if (mxSymbolsODFF.get())
+        return;
+
+    // English, not Core, no ODF
+    mxSymbolsODFF.reset( new OpCodeMap( SC_OPCODE_LAST_OPCODE_ID + 1, true, false, false));
+    ScOpCodeList aOpCodeList( RID_SC_FUNCTION_NAMES_ENGLISH_ODFF, mxSymbolsODFF );
+
+    fillFromAddInMap( mxSymbolsODFF, offsetof( AddInMap, pODFF));
+    // Fill from collection for AddIns not already present.
+    fillFromAddInCollectionUpperName( mxSymbolsODFF);
+}
+
+#ifdef erGENERATEMAPPING
+// Run in en-US UI by calling from within gdb, edit pODFF entries afterwards.
+void dbg_call_generateMappingODFF()
+{
+    // static ScCompiler members
+    fprintf( stdout, "%s", "static struct AddInMap\n{\n    const char* pODFF;\n    const char* pEnglish;\n    bool        bMapDupToInternal;\n    const char* pOriginal;\n    const char* pUpper;\n} maAddInMap[];\n");
+    fprintf( stdout, "%s", "static const AddInMap* GetAddInMap();\n");
+    fprintf( stdout, "%s", "static size_t GetAddInMapCount();\n");
+    fprintf( stdout, "addinfuncdata___:%s", "ScCompiler::AddInMap ScCompiler::maAddInMap[] =\n{\n");
+    ScUnoAddInCollection* pColl = ScGlobal::GetAddInCollection();
+    long nCount = pColl->GetFuncCount();
+    for (long i=0; i < nCount; ++i)
+    {
+        const ScUnoAddInFuncData* pFuncData = pColl->GetFuncData(i);
+        if (pFuncData)
+        {
+#define out(rStr) (ByteString( rStr, RTL_TEXTENCODING_UTF8).GetBuffer())
+            String aL = pFuncData->GetUpperLocal();
+            String aP = pFuncData->GetOriginalName();
+            String aU = pFuncData->GetUpperName();
+            fprintf( stdout, "addinfuncdata%3ld:    { \"%s\", \"%s\", false, \"%s\", \"%s\" },\n",
+                    i, out(aL), out(aL), out(aP), out(aU));
+#undef out
+        }
+    }
+    fprintf( stdout, "addinfuncdata___:%s", "};\n");
+    fprintf( stdout, "%s", "\n// static\nconst ScCompiler::AddInMap* ScCompiler::GetAddInMap()\n{\n    return maAddInMap;\n}\n");
+    fprintf( stdout, "%s", "\n// static\nsize_t ScCompiler::GetAddInMapCount()\n{\n    return sizeof(maAddInMap)/sizeof(maAddInMap[0]);\n}\n");
+    fflush( stdout);
+}
+#endif  // erGENERATEMAPPING
+
+// static
+void ScCompiler::DeInit()
+{
+    mxSymbolsNative.reset();
+    mxSymbolsEnglish.reset();
+    mxSymbolsODFF.reset();
+    mxSymbolsODF_11.reset();
     if (pCharClassEnglish)
     {
         delete pCharClassEnglish;
@@ -263,38 +404,452 @@ void ScCompiler::DeInit()
     }
 }
 
+
+// static
+void ScCompiler::InitCharClassEnglish()
+{
+    ::com::sun::star::lang::Locale aLocale(
+            OUString( RTL_CONSTASCII_USTRINGPARAM( "en")),
+            OUString( RTL_CONSTASCII_USTRINGPARAM( "US")),
+            OUString());
+    pCharClassEnglish = new CharClass(
+            ::comphelper::getProcessServiceFactory(), aLocale);
+}
+
+
 void ScCompiler::SetCompileEnglish( BOOL bCompileEnglish )
 {
     if ( bCompileEnglish )
     {
-        if ( !pSymbolTableEnglish )
+        // TODO: similar for mxSymbolsODFF !
+        /* TODO: On the other hand this could be entirely removed once all code
+           used SetFormulaLanguage( GetOpCodeMap( nLanguage)) or similar (could
+           need a shortcut SetFormulaLanguage( nLanguage) to not having to pass
+           the map around). */
+
+        /* In fact this was always used for XML and ODF_11 hence now is using
+         * mxSymbolsODF_11 instead of mxSymbolsEnglish. */
+
+        /* TODO: really change this to SetFormulaLanguage( sheet::FormulaLanguage )
+         * to clarify in calling code. */
+
+        if (!mxSymbolsODF_11.get())
+            InitSymbolsODF_11();
+        mxSymbols = mxSymbolsODF_11;
+        if (!pCharClassEnglish)
+            InitCharClassEnglish();
+        pCharClass = pCharClassEnglish;
+    }
+    else
         {
-            pSymbolTableEnglish = new String[SC_OPCODE_LAST_OPCODE_ID+1];
-            pSymbolHashMapEnglish = new ScOpCodeHashMap( SC_OPCODE_LAST_OPCODE_ID+1 );
-            ScOpCodeList aOpCodeListEnglish( RID_SC_FUNCTION_NAMES_ENGLISH,
-                pSymbolTableEnglish, *pSymbolHashMapEnglish );
+        mxSymbols = mxSymbolsNative;
+        pCharClass = ScGlobal::pCharClass;
         }
-        if (!pCharClassEnglish)
+}
+
+
+// static
+OpCode ScCompiler::GetEnglishOpCode( const String& rName )
         {
-            ::com::sun::star::lang::Locale aLocale(
-                    ::rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "en")),
-                    ::rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "US")),
-                    ::rtl::OUString());
-            pCharClassEnglish = new CharClass(
-                    ::comphelper::getProcessServiceFactory(), aLocale);
+    if (!mxSymbolsEnglish.get())
+        InitSymbolsEnglish();
+
+    ScOpCodeHashMap::const_iterator iLook( mxSymbolsEnglish->getHashMap()->find( rName ) );
+    bool bFound = (iLook != mxSymbolsEnglish->getHashMap()->end());
+    return bFound ? (*iLook).second : OpCode(ocNone);
         }
-        pSymbolTable = pSymbolTableEnglish;
-        pSymbolHashMap = pSymbolHashMapEnglish;
-        pCharClass = pCharClassEnglish;
+
+
+// static
+ScCompiler::OpCodeMapPtr ScCompiler::GetOpCodeMap( sal_Int32 nLanguage )
+{
+    ScCompiler::OpCodeMapPtr xMap;
+    using namespace ::com::sun::star::sheet;
+    switch (nLanguage)
+    {
+        case FormulaLanguage::ODFF :
+            if (!mxSymbolsODFF)
+                InitSymbolsODFF();
+            xMap = mxSymbolsODFF;
+            break;
+        case FormulaLanguage::ODF_11 :
+            if (!mxSymbolsODF_11)
+                InitSymbolsODF_11();
+            xMap = mxSymbolsODF_11;
+            break;
+        case FormulaLanguage::ENGLISH :
+            if (!mxSymbolsEnglish)
+                InitSymbolsEnglish();
+            xMap = mxSymbolsEnglish;
+            break;
+        case FormulaLanguage::NATIVE :
+            if (!mxSymbolsNative)
+                InitSymbolsNative();
+            xMap = mxSymbolsNative;
+            break;
+        default:
+            ;   // nothing, NULL map returned
+    }
+    return xMap;
     }
+
+
+// static
+ScCompiler::OpCodeMapPtr ScCompiler::CreateOpCodeMap(
+        const ::com::sun::star::uno::Sequence<
+        const ::com::sun::star::sheet::FormulaOpCodeMapEntry > & rMapping,
+        bool bEnglish )
+{
+    using ::com::sun::star::sheet::FormulaOpCodeMapEntry;
+    // Filter / API maps are never Core and never ODF 1.1
+    NonConstOpCodeMapPtr xMap( new OpCodeMap(
+                SC_OPCODE_LAST_OPCODE_ID + 1, bEnglish, false, false));
+    FormulaOpCodeMapEntry const * pArr = rMapping.getConstArray();
+    FormulaOpCodeMapEntry const * const pStop = pArr + rMapping.getLength();
+    for ( ; pArr < pStop; ++pArr)
+    {
+        OpCode eOp = OpCode(pArr->Token.OpCode);
+        if (eOp != ocExternal)
+            xMap->putOpCode( pArr->Name, eOp);
+        else
+        {
+            OUString aExternalName;
+            if (pArr->Token.Data >>= aExternalName)
+                xMap->putExternal( pArr->Name, aExternalName);
     else
+                DBG_ERRORFILE( "ScCompiler::CreateOpCodeMap: no Token.Data external name");
+        }
+    }
+    return xMap;
+}
+
+
+void ScCompiler::SetFormulaLanguage( const ScCompiler::OpCodeMapPtr & xMap )
+{
+    if (xMap.get())
     {
-        pSymbolTable = pSymbolTableNative;
-        pSymbolHashMap = pSymbolHashMapNative;
+        mxSymbols = xMap;
+        if (mxSymbols->isEnglish())
+        {
+            if (!pCharClassEnglish)
+                InitCharClassEnglish();
+            pCharClass = pCharClassEnglish;
+        }
+        else
         pCharClass = ScGlobal::pCharClass;
     }
 }
 
+
+//-----------------------------------------------------------------------------
+
+void ScCompiler::OpCodeMap::putOpCode( const String & rStr, const OpCode eOp )
+{
+    DBG_ASSERT( 0 < eOp && USHORT(eOp) < mnSymbols, "OpCodeMap::putOpCode: OpCode out of range");
+    if (0 < eOp && USHORT(eOp) < mnSymbols)
+    {
+        DBG_ASSERT( (mpTable[eOp].Len() == 0) || (mpTable[eOp] == rStr),
+            ByteString( "OpCodeMap::putOpCode: reusing OpCode ").
+            Append( ByteString::CreateFromInt32( sal_Int32( eOp))).Append( " (").
+            Append( ByteString( rStr, RTL_TEXTENCODING_ASCII_US)).Append( ')').GetBuffer());
+        mpTable[eOp] = rStr;
+        mpHashMap->insert( ScOpCodeHashMap::value_type( rStr, eOp));
+    }
+}
+
+void ScCompiler::OpCodeMap::putExternal( const String & rSymbol, const String & rAddIn )
+{
+    bool bOk = mpExternalHashMap->insert( ScExternalHashMap::value_type( rSymbol, rAddIn)).second;
+    if (bOk)
+        bOk = mpReverseExternalHashMap->insert( ScExternalHashMap::value_type( rAddIn, rSymbol)).second;
+    DBG_ASSERT( bOk, "OpCodeMap::putExternal: symbol not inserted");
+}
+
+void ScCompiler::OpCodeMap::putExternalSoftly( const String & rSymbol, const String & rAddIn )
+{
+    bool bOk = mpReverseExternalHashMap->insert( ScExternalHashMap::value_type( rAddIn, rSymbol)).second;
+    if (bOk)
+        mpExternalHashMap->insert( ScExternalHashMap::value_type( rSymbol, rAddIn)).second;
+}
+
+::com::sun::star::uno::Sequence< ::com::sun::star::sheet::FormulaToken >
+ScCompiler::OpCodeMap::createSequenceOfFormulaTokens(
+        const ::com::sun::star::uno::Sequence< ::rtl::OUString >& rNames ) const
+{
+    const sal_Int32 nLen = rNames.getLength();
+    uno::Sequence< sheet::FormulaToken > aTokens( nLen);
+    sheet::FormulaToken* pToken = aTokens.getArray();
+    OUString const * pName = rNames.getConstArray();
+    OUString const * const pStop = pName + nLen;
+    for ( ; pName < pStop; ++pName, ++pToken)
+    {
+        ScOpCodeHashMap::const_iterator iLook( mpHashMap->find( *pName));
+        if (iLook != mpHashMap->end())
+            pToken->OpCode = (*iLook).second;
+        else
+        {
+            OUString aIntName;
+            if (hasExternals())
+            {
+                ScExternalHashMap::const_iterator iExt(
+                        mpExternalHashMap->find( *pName));
+                if (iExt != mpExternalHashMap->end())
+                    aIntName = (*iExt).second;
+                // Check for existence not needed here, only name-mapping is of
+                // interest.
+            }
+            if (!aIntName.getLength())
+                aIntName = ScGlobal::GetAddInCollection()->FindFunction(
+                        *pName, !isEnglish());    // bLocalFirst=FALSE for english
+            if (!aIntName.getLength())
+                pToken->OpCode = getOpCodeUnknown();
+            else
+            {
+                pToken->OpCode = ocExternal;
+                pToken->Data <<= aIntName;
+            }
+        }
+    }
+    return aTokens;
+}
+
+namespace {
+
+inline void lclPushOpCodeMapEntry( ::std::vector< ::com::sun::star::sheet::FormulaOpCodeMapEntry >& rVec, const String* pTable, USHORT nOpCode )
+{
+    ::com::sun::star::sheet::FormulaOpCodeMapEntry aEntry;
+    aEntry.Token.OpCode = nOpCode;
+    aEntry.Name = pTable[nOpCode];
+    rVec.push_back( aEntry);
+}
+
+void lclPushOpCodeMapEntries( ::std::vector< ::com::sun::star::sheet::FormulaOpCodeMapEntry >& rVec, const String* pTable, USHORT nOpCodeBeg, USHORT nOpCodeEnd )
+{
+    for (USHORT nOpCode = nOpCodeBeg; nOpCode < nOpCodeEnd; ++nOpCode)
+        lclPushOpCodeMapEntry( rVec, pTable, nOpCode );
+}
+
+void lclPushOpCodeMapEntries( ::std::vector< ::com::sun::star::sheet::FormulaOpCodeMapEntry >& rVec, const String* pTable, const USHORT* pnOpCodes, size_t nCount )
+{
+    for (const USHORT* pnEnd = pnOpCodes + nCount; pnOpCodes < pnEnd; ++pnOpCodes)
+        lclPushOpCodeMapEntry( rVec, pTable, *pnOpCodes );
+}
+
+} // namespace
+
+
+#ifdef erDEBUG
+void dbg_call_testcreatemapping()
+{
+    using namespace ::com::sun::star::sheet;
+    ScCompiler::OpCodeMapPtr xMap = ScCompiler::GetOpCodeMap( FormulaLanguage::ODFF);
+    xMap->createSequenceOfAvailableMappings( FormulaMapGroup::FUNCTIONS);
+}
+#endif
+
+::com::sun::star::uno::Sequence< ::com::sun::star::sheet::FormulaOpCodeMapEntry >
+ScCompiler::OpCodeMap::createSequenceOfAvailableMappings( const sal_Int32 nGroups ) const
+{
+    using namespace ::com::sun::star::sheet;
+
+    // Unfortunately uno::Sequence can't grow without cumbersome reallocs. As
+    // we don't know in advance how many elements it will have we use a
+    // temporary vector to add elements and then copy to Sequence :-(
+    ::std::vector< FormulaOpCodeMapEntry > aVec;
+
+    if (nGroups == FormulaMapGroup::SPECIAL)
+    {
+        // Use specific order, keep in sync with
+        // offapi/com/sun/star/sheet/FormulaMapGroupSpecialOffset.idl
+        static const struct
+        {
+            sal_Int32 nOff;
+            OpCode    eOp;
+        } aMap[] = {
+            { FormulaMapGroupSpecialOffset::PUSH              , ocPush }           ,
+            { FormulaMapGroupSpecialOffset::CALL              , ocCall }           ,
+            { FormulaMapGroupSpecialOffset::STOP              , ocStop }           ,
+            { FormulaMapGroupSpecialOffset::EXTERNAL          , ocExternal }       ,
+            { FormulaMapGroupSpecialOffset::NAME              , ocName }           ,
+            { FormulaMapGroupSpecialOffset::NO_NAME           , ocNoName }         ,
+            { FormulaMapGroupSpecialOffset::MISSING           , ocMissing }        ,
+            { FormulaMapGroupSpecialOffset::BAD               , ocBad }            ,
+            { FormulaMapGroupSpecialOffset::SPACES            , ocSpaces }         ,
+            { FormulaMapGroupSpecialOffset::MAT_REF           , ocMatRef }         ,
+            { FormulaMapGroupSpecialOffset::DB_AREA           , ocDBArea }         ,
+            { FormulaMapGroupSpecialOffset::MACRO             , ocMacro }          ,
+            { FormulaMapGroupSpecialOffset::COL_ROW_NAME      , ocColRowName }     ,
+            { FormulaMapGroupSpecialOffset::COL_ROW_NAME_AUTO , ocColRowNameAuto }
+        };
+        const size_t nCount = sizeof(aMap)/sizeof(aMap[0]);
+        // Preallocate vector elements.
+        if (aVec.size() < nCount)
+        {
+            FormulaOpCodeMapEntry aEntry;
+            aEntry.Token.OpCode = getOpCodeUnknown();
+            aVec.resize( nCount, aEntry);
+        }
+        for (size_t i=0; i < nCount; ++i)
+        {
+            FormulaOpCodeMapEntry aEntry;
+            size_t nIndex = static_cast< size_t >( aMap[i].nOff );
+            if (aVec.size() <= nIndex)
+            {
+                // The offsets really should be aligned with the size, so if
+                // the vector was preallocated above this code to resize it is
+                // just a measure in case the table isn't in sync with the API,
+                // usually it isn't executed.
+                aEntry.Token.OpCode = getOpCodeUnknown();
+                aVec.resize( nIndex + 1, aEntry );
+            }
+            aEntry.Token.OpCode = aMap[i].eOp;
+            aVec[nIndex] = aEntry;
+        }
+    }
+    else
+    {
+        // Anything else but SPECIAL.
+        if ((nGroups & FormulaMapGroup::SEPARATORS) != 0)
+        {
+            static const USHORT aOpCodes[] = {
+                SC_OPCODE_OPEN,
+                SC_OPCODE_CLOSE,
+                SC_OPCODE_SEP,
+            };
+            lclPushOpCodeMapEntries( aVec, mpTable, aOpCodes, sizeof(aOpCodes)/sizeof(aOpCodes[0]) );
+        }
+        if ((nGroups & FormulaMapGroup::ARRAY_SEPARATORS) != 0)
+        {
+            static const USHORT aOpCodes[] = {
+                SC_OPCODE_ARRAY_OPEN,
+                SC_OPCODE_ARRAY_CLOSE,
+                SC_OPCODE_ARRAY_ROW_SEP,
+                SC_OPCODE_ARRAY_COL_SEP
+            };
+            lclPushOpCodeMapEntries( aVec, mpTable, aOpCodes, sizeof(aOpCodes)/sizeof(aOpCodes[0]) );
+        }
+        if ((nGroups & FormulaMapGroup::UNARY_OPERATORS) != 0)
+        {
+            // Due to the nature of the percent operator following its operand
+            // it isn't sorted into unary operators for compiler interna.
+            lclPushOpCodeMapEntry( aVec, mpTable, ocPercentSign );
+            // "+" can be used as unary operator too, push only if binary group is not set
+            if ((nGroups & FormulaMapGroup::BINARY_OPERATORS) == 0)
+                lclPushOpCodeMapEntry( aVec, mpTable, ocAdd );
+            // regular unary operators
+            for (USHORT nOp = SC_OPCODE_START_UN_OP; nOp < SC_OPCODE_END_UN_OP && nOp < mnSymbols; ++nOp)
+            {
+                switch (nOp)
+                {
+                    // NOT and NEG in fact are functions but for legacy reasons
+                    // are sorted into unary operators for compiler interna.
+                    case SC_OPCODE_NOT :
+                    case SC_OPCODE_NEG :
+                        break;   // nothing,
+                    default:
+                        lclPushOpCodeMapEntry( aVec, mpTable, nOp );
+                }
+            }
+        }
+        if ((nGroups & FormulaMapGroup::BINARY_OPERATORS) != 0)
+        {
+            for (USHORT nOp = SC_OPCODE_START_BIN_OP; nOp < SC_OPCODE_END_BIN_OP && nOp < mnSymbols; ++nOp)
+            {
+                switch (nOp)
+                {
+                    // AND and OR in fact are functions but for legacy reasons
+                    // are sorted into binary operators for compiler interna.
+                    case SC_OPCODE_AND :
+                    case SC_OPCODE_OR :
+                        break;   // nothing,
+                    default:
+                        lclPushOpCodeMapEntry( aVec, mpTable, nOp );
+                }
+            }
+        }
+        if ((nGroups & FormulaMapGroup::FUNCTIONS) != 0)
+        {
+            // Function names are not consecutive, skip the gaps between
+            // functions with no parameter, functions with 1 parameter
+            lclPushOpCodeMapEntries( aVec, mpTable, SC_OPCODE_START_NO_PAR, ::std::min< USHORT >( SC_OPCODE_END_NO_PAR, mnSymbols ) );
+            lclPushOpCodeMapEntries( aVec, mpTable, SC_OPCODE_START_1_PAR, ::std::min< USHORT >( SC_OPCODE_END_1_PAR, mnSymbols ) );
+            // Additional functions not within range of functions.
+            static const USHORT aOpCodes[] = {
+                SC_OPCODE_IF,
+                SC_OPCODE_CHOSE,
+                SC_OPCODE_AND,
+                SC_OPCODE_OR,
+                SC_OPCODE_NOT,
+                SC_OPCODE_NEG
+            };
+            lclPushOpCodeMapEntries( aVec, mpTable, aOpCodes, sizeof(aOpCodes)/sizeof(aOpCodes[0]) );
+            // functions with 2 or more parameters.
+            for (USHORT nOp = SC_OPCODE_START_2_PAR; nOp < SC_OPCODE_END_2_PAR && nOp < mnSymbols; ++nOp)
+            {
+                switch (nOp)
+                {
+                    // NO_NAME is in SPECIAL.
+                    case SC_OPCODE_NO_NAME :
+                        break;   // nothing,
+                    default:
+                        lclPushOpCodeMapEntry( aVec, mpTable, nOp );
+                }
+            }
+            // If AddIn functions are present in this mapping, use them, and only those.
+            if (hasExternals())
+            {
+                for (ScExternalHashMap::const_iterator it( mpExternalHashMap->begin());
+                        it != mpExternalHashMap->end(); ++it)
+                {
+                    FormulaOpCodeMapEntry aEntry;
+                    aEntry.Name = (*it).first;
+                    aEntry.Token.Data <<= OUString( (*it).second);
+                    aEntry.Token.OpCode = ocExternal;
+                    aVec.push_back( aEntry);
+                }
+            }
+            else
+            {
+                DBG_ASSERT( isCore(), "ScCompiler::OpCodeMap::createSequenceOfAvailableMappings: AddIn mapping only implemented for core languages");
+                // All known AddIn functions.
+                ScUnoAddInCollection* pColl = ScGlobal::GetAddInCollection();
+                long nCount = pColl->GetFuncCount();
+                for (long i=0; i < nCount; ++i)
+                {
+                    const ScUnoAddInFuncData* pFuncData = pColl->GetFuncData(i);
+                    if (pFuncData)
+                    {
+                        FormulaOpCodeMapEntry aEntry;
+                        if (isEnglish())
+                        {
+                            String aName;
+                            if (pFuncData->GetExcelName( LANGUAGE_ENGLISH_US, aName))
+                                aEntry.Name = aName;
+                            else
+                                aEntry.Name = pFuncData->GetUpperName();
+                        }
+                        else
+                            aEntry.Name = pFuncData->GetUpperLocal();
+                        aEntry.Token.Data <<= OUString( pFuncData->GetOriginalName());
+                        aEntry.Token.OpCode = ocExternal;
+                        aVec.push_back( aEntry);
+                    }
+                }
+                // FIXME: what about those old non-UNO AddIns?
+            }
+        }
+    }
+    size_t nLen = aVec.size();
+    uno::Sequence< FormulaOpCodeMapEntry > aSeq( nLen);
+    FormulaOpCodeMapEntry* pArr = aSeq.getArray();
+    for (size_t i=0; i < nLen; ++i, ++pArr)
+    {
+        *pArr = aVec[i];
+    }
+    return aSeq;
+}
+
+
 //-----------------------------------------------------------------------------
 
 ScCompiler::Convention::~Convention()
@@ -390,7 +945,7 @@ for (i = 97; i < 123; i++)
 /* ] */     t[93] |=   SC_COMPILER_C_WORD;
 /* { */     t[123]|=   SC_COMPILER_C_WORD;
 /* | */     t[124]|=   SC_COMPILER_C_WORD;
-/* } */     t[124]|=   SC_COMPILER_C_WORD;
+/* } */     t[125]|=   SC_COMPILER_C_WORD;
 /* ~ */     t[126]|=   SC_COMPILER_C_WORD;
 
         if( ScAddress::CONV_XL_R1C1 == meConv )
@@ -467,7 +1022,7 @@ struct ConventionOOO_A1 : public Convent
     static String MakeTabStr( const ScCompiler& rComp, SCTAB nTab, String& aDoc )
     {
         String aString;
-        if (!rComp.pDoc->GetName( nTab, aString ))
+        if (!rComp.GetDoc()->GetName( nTab, aString ))
             aString = ScGlobal::GetRscString(STR_NO_REF_TABLE);
         else
         {
@@ -505,9 +1060,9 @@ struct ConventionOOO_A1 : public Convent
         //  AdjustReference( aRef.Ref1 );
         //  if( !bSingleRef )
         //      AdjustReference( aRef.Ref2 );
-        aRef.Ref1.CalcAbsIfRel( rComp.aPos );
+        aRef.Ref1.CalcAbsIfRel( rComp.GetPos() );
         if( !bSingleRef )
-            aRef.Ref2.CalcAbsIfRel( rComp.aPos );
+            aRef.Ref2.CalcAbsIfRel( rComp.GetPos() );
         if( aRef.Ref1.IsFlag3D() )
         {
             if (aRef.Ref1.IsTabDeleted())
@@ -595,9 +1150,9 @@ struct ConventionOOO_A1_XML : public Con
 //  AdjustReference( aRef.Ref1 );
 //  if( !bSingleRef )
 //      AdjustReference( aRef.Ref2 );
-    aRef.Ref1.CalcAbsIfRel( rComp.aPos );
+    aRef.Ref1.CalcAbsIfRel( rComp.GetPos() );
     if( !bSingleRef )
-        aRef.Ref2.CalcAbsIfRel( rComp.aPos );
+        aRef.Ref2.CalcAbsIfRel( rComp.GetPos() );
     if( aRef.Ref1.IsFlag3D() )
     {
         if (aRef.Ref1.IsTabDeleted())
@@ -686,7 +1241,7 @@ struct ConventionXL
 
         rDocName.Erase();
         if (rRef.IsTabDeleted() ||
-            !rComp.pDoc->GetName( rRef.nTab, rTabName ))
+            !rComp.GetDoc()->GetName( rRef.nTab, rTabName ))
         {
             rTabName = ScGlobal::GetRscString( STR_NO_REF_TABLE );
             return false;
@@ -750,7 +1305,7 @@ struct ConventionXL
             }
 
             rBuf.append( aStartTabName );
-            if( !bSingleRef && aStartTabName != aEndTabName )
+            if( !bSingleRef && rRef.Ref2.IsFlag3D() && aStartTabName != aEndTabName )
             {
                 rBuf.append( sal_Unicode( ':' ) );
                 rBuf.append( aEndTabName );
@@ -775,7 +1330,7 @@ struct ConventionXL_A1 : public Conventi
 
         // Play fast and loose with invalid refs.  There is not much point in producing
         // Foo!A1:#REF! versus #REF! at this point
-        aRef.Ref1.CalcAbsIfRel( rComp.aPos );
+        aRef.Ref1.CalcAbsIfRel( rComp.GetPos() );
         if( aRef.Ref1.IsColDeleted() || aRef.Ref1.IsRowDeleted() )
         {
             rBuf.append(ScGlobal::GetRscString(STR_NO_REF_TABLE));
@@ -784,7 +1339,7 @@ struct ConventionXL_A1 : public Conventi
 
         if( !bSingleRef )
         {
-            aRef.Ref2.CalcAbsIfRel( rComp.aPos );
+            aRef.Ref2.CalcAbsIfRel( rComp.GetPos() );
             if( aRef.Ref2.IsColDeleted() || aRef.Ref2.IsRowDeleted() )
             {
                 rBuf.append(ScGlobal::GetRscString(STR_NO_REF_TABLE));
@@ -888,7 +1443,7 @@ struct ConventionXL_R1C1 : public ScComp
 
         // Play fast and loose with invalid refs.  There is not much point in producing
         // Foo!A1:#REF! versus #REF! at this point
-        aRef.Ref1.CalcAbsIfRel( rComp.aPos );
+        aRef.Ref1.CalcAbsIfRel( rComp.GetPos() );
         if( aRef.Ref1.IsColDeleted() || aRef.Ref1.IsRowDeleted() )
         {
             rBuf.append(ScGlobal::GetRscString(STR_NO_REF_TABLE));
@@ -897,7 +1452,7 @@ struct ConventionXL_R1C1 : public ScComp
 
         if( !bSingleRef )
         {
-            aRef.Ref2.CalcAbsIfRel( rComp.aPos );
+            aRef.Ref2.CalcAbsIfRel( rComp.GetPos() );
             if( aRef.Ref2.IsColDeleted() || aRef.Ref2.IsRowDeleted() )
             {
                 rBuf.append(ScGlobal::GetRscString(STR_NO_REF_TABLE));
@@ -963,8 +1518,7 @@ ScCompiler::ScCompiler( ScDocument* pDoc
                         const ScTokenArray& rArr )
         :
         aPos( rPos ),
-        pSymbolTable( pSymbolTableNative ),
-        pSymbolHashMap( pSymbolHashMapNative ),
+        mxSymbols( mxSymbolsNative ),
         pCharClass( ScGlobal::pCharClass ),
         nRecursion(0),
         bAutoCorrect( FALSE ),
@@ -973,8 +1527,11 @@ ScCompiler::ScCompiler( ScDocument* pDoc
         bIgnoreErrors( FALSE ),
         bImportXML ( FALSE )
 {
-    if (!nAnzStrings)
-        Init();
+    if (!mxSymbols.get())
+    {
+        InitSymbolsNative();
+        mxSymbols = mxSymbolsNative;
+    }
     pArr = (ScTokenArray*) &rArr;
     pDoc = pDocument;
 
@@ -991,8 +1548,7 @@ ScCompiler::ScCompiler( ScDocument* pDoc
 ScCompiler::ScCompiler(ScDocument* pDocument, const ScAddress& rPos )
         :
         aPos( rPos ),
-        pSymbolTable( pSymbolTableNative ),
-        pSymbolHashMap( pSymbolHashMapNative ),
+        mxSymbols( mxSymbolsNative ),
         pCharClass( ScGlobal::pCharClass ),
         nRecursion(0),
         bAutoCorrect( FALSE ),
@@ -1001,8 +1557,11 @@ ScCompiler::ScCompiler(ScDocument* pDocu
         bIgnoreErrors( FALSE ),
         bImportXML ( FALSE )
 {
-    if (!nAnzStrings)
-        Init();
+    if (!mxSymbols.get())
+    {
+        InitSymbolsNative();
+        mxSymbols = mxSymbolsNative;
+    }
     pArr = NULL;
     pDoc = pDocument;
 
@@ -1151,11 +1710,25 @@ xub_StrLen ScCompiler::NextSymbol()
     BOOL bQuote = FALSE;
     ScanState eState = ssGetChar;
     xub_StrLen nSpaces = 0;
+    sal_Unicode cSep = mxSymbols->getSymbol( ocSep).GetChar(0);
+    sal_Unicode cDecSep = (mxSymbols->isEnglish() ? '.' :
+            ScGlobal::pLocaleData->getNumDecimalSep().GetChar(0));
+    int nDecSeps = 0;
     // try to parse simple tokens before calling i18n parser
     while ((c != 0) && (eState != ssStop) )
     {
         pSrc++;
         ULONG nMask = GetCharTableFlags( c );
+        // The parameter separator ends things unconditionally if not in
+        // string.
+        if (c == cSep && eState != ssGetString)
+        {
+            if (eState == ssGetChar)
+                *pSym++ = c;
+            else
+                pSrc--;
+            eState = ssStop;
+        }
         switch (eState)
         {
             case ssGetChar :
@@ -1170,6 +1743,11 @@ xub_StrLen ScCompiler::NextSymbol()
                     *pSym++ = c;
                     eState = ssGetBool;
                 }
+				else if( nMask & SC_COMPILER_C_CHAR_VALUE )
+				{
+					*pSym++ = c;
+					eState = ssGetValue;
+				}
                 else if( nMask & SC_COMPILER_C_CHAR_STRING )
                 {
                     *pSym++ = c;
@@ -1208,9 +1786,6 @@ xub_StrLen ScCompiler::NextSymbol()
                 {   // High values need reparsing with i18n,
                     // single quoted $'sheet' names too (otherwise we'd had to
                     // implement everything twice).
-                    pSrc = pStart + nSrcPos + nSpaces;
-                    pSym = cSymbol;
-                    c = *pSrc;
                     bi18n = TRUE;
                     eState = ssStop;
                 }
@@ -1235,6 +1810,63 @@ xub_StrLen ScCompiler::NextSymbol()
                 }
             }
             break;
+            case ssGetValue :
+            {
+                if( pSym == &cSymbol[ MAXSTRLEN-1 ] )
+                {
+                    SetError(errStringOverflow);
+                    eState = ssStop;
+                }
+                else if (c == cDecSep)
+                {
+                    if (++nDecSeps > 1)
+                    {
+                        // reparse with i18n, may be numeric sheet name as well
+                        bi18n = TRUE;
+                        eState = ssStop;
+                    }
+                    else
+                        *pSym++ = c;
+                }
+                else if( nMask & SC_COMPILER_C_VALUE )
+                    *pSym++ = c;
+                else if( nMask & SC_COMPILER_C_VALUE_SEP )
+                {
+                    pSrc--;
+                    eState = ssStop;
+                }
+                else if (c == 'E' || c == 'e')
+                {
+                    if (GetCharTableFlags( pSrc[1] ) & SC_COMPILER_C_VALUE_EXP)
+                        *pSym++ = c;
+                    else
+                    {
+                        // reparse with i18n
+                        bi18n = TRUE;
+                        eState = ssStop;
+                    }
+                }
+                else if( nMask & SC_COMPILER_C_VALUE_SIGN )
+                {
+                    if (((cLast == 'E') || (cLast == 'e')) &&
+                            (GetCharTableFlags( pSrc[1] ) & SC_COMPILER_C_VALUE_VALUE))
+                    {
+                        *pSym++ = c;
+                    }
+                    else
+                    {
+                        pSrc--;
+                        eState = ssStop;
+                    }
+                }
+                else
+                {
+                    // reparse with i18n
+                    bi18n = TRUE;
+                    eState = ssStop;
+                }
+            }
+            break;
             case ssGetString :
             {
                 if( nMask & SC_COMPILER_C_STRING_SEP )
@@ -1336,16 +1968,39 @@ xub_StrLen ScCompiler::NextSymbol()
 
 BOOL ScCompiler::IsOpCode( const String& rName )
 {
-    ScOpCodeHashMap::const_iterator iLook( pSymbolHashMap->find( rName ) );
-    BOOL bFound = (iLook != pSymbolHashMap->end());
+    ScOpCodeHashMap::const_iterator iLook( mxSymbols->getHashMap()->find( rName));
+    BOOL bFound = (iLook != mxSymbols->getHashMap()->end());
     if (bFound)
     {
         ScRawToken aToken;
-        aToken.SetOpCode( iLook->second );
+        aToken.SetOpCode( (*iLook).second );
         pRawToken = aToken.Clone();
     }
     else
     {
+        String aIntName;
+        if (mxSymbols->hasExternals())
+        {
+            // If symbols are set by filters get mapping to exact name.
+            ScExternalHashMap::const_iterator iExt(
+                    mxSymbols->getExternalHashMap()->find( rName));
+            if (iExt != mxSymbols->getExternalHashMap()->end())
+            {
+                if (ScGlobal::GetAddInCollection()->GetFuncData( (*iExt).second))
+                    aIntName = (*iExt).second;
+            }
+            if (!aIntName.Len())
+            {
+                // If that isn't found we might continue with rName lookup as a
+                // last resort by just falling through to FindFunction(), but
+                // it shouldn't happen if the map was setup correctly. Don't
+                // waste time and bail out.
+                return FALSE;
+            }
+        }
+        if (!aIntName.Len())
+        {
+            // Old (deprecated) addins first for legacy.
         USHORT nIndex;
         bFound = ScGlobal::GetFuncCollection()->SearchFunc(cSymbol, nIndex);
         if( bFound )
@@ -1355,10 +2010,11 @@ BOOL ScCompiler::IsOpCode( const String&
             pRawToken = aToken.Clone();
         }
         else
-        {
-            // bLocalFirst=FALSE for english
-            String aIntName = ScGlobal::GetAddInCollection()->
-                    FindFunction( rName, ( pSymbolTable != pSymbolTableEnglish ) );
+                // bLocalFirst=FALSE for (English) upper full original name
+                // (service.function)
+                aIntName = ScGlobal::GetAddInCollection()->FindFunction(
+                        rName, !mxSymbols->isEnglish());
+        }
             if (aIntName.Len())
             {
                 ScRawToken aToken;
@@ -1369,14 +1369,20 @@
                 bFound = TRUE;
             }
         }
-    }
-    if ( bFound && pRawToken->GetOpCode() == ocSub &&
-            (eLastOp == ocOpen || eLastOp == ocSep || eLastOp == ocNegSub ||
-             (eLastOp > ocEndDiv && eLastOp < ocEndBinOp) ||
+    OpCode eOp;
+    if ( bFound && ((eOp = pRawToken->GetOpCode()) == ocSub || eOp == ocNegSub))
+    {
+    	bool bShouldBeNegSub = (eLastOp == ocOpen || eLastOp == ocSep || 
+	     eLastOp == ocNegSub ||
+             (SC_OPCODE_START_BIN_OP <= eLastOp && eLastOp < SC_OPCODE_END_BIN_OP) ||
              eLastOp == ocArrayOpen ||
-             eLastOp == ocArrayColSep || eLastOp == ocArrayRowSep))
+             eLastOp == ocArrayColSep || eLastOp == ocArrayRowSep);
+	if (bShouldBeNegSub && eOp == ocSub)
         pRawToken->NewOpCode( ocNegSub );
         //! if ocNegSub had ForceArray we'd have to set it here
+	else if (!bShouldBeNegSub && eOp == ocNegSub)
+	    pRawToken->NewOpCode( ocSub );
+    }
     return bFound;
 }
 
@@ -1397,7 +2058,7 @@ BOOL ScCompiler::IsOpCode2( const String
 BOOL ScCompiler::IsValue( const String& rSym )
 {
     double fVal;
-    sal_uInt32 nIndex = ( pSymbolTable == pSymbolTableEnglish ?
+    sal_uInt32 nIndex = ( mxSymbols->isEnglish() ?
         pDoc->GetFormatTable()->GetStandardIndex( LANGUAGE_ENGLISH_US ) : 0 );
 //  ULONG nIndex = 0;
 ////    ULONG nIndex = pDoc->GetFormatTable()->GetStandardIndex(ScGlobal::eLnge);
@@ -1454,7 +2115,7 @@ BOOL ScCompiler::IsReference( const Stri
 {
     // Has to be called before IsValue
     sal_Unicode ch1 = rName.GetChar(0);
-    sal_Unicode cDecSep = ( pSymbolTable == pSymbolTableEnglish ? '.' :
+    sal_Unicode cDecSep = ( mxSymbols->isEnglish() ? '.' :
         ScGlobal::pLocaleData->getNumDecimalSep().GetChar(0) );
     if ( ch1 == cDecSep )
         return FALSE;
@@ -1903,13 +2564,13 @@ BOOL ScCompiler::IsColRowName( const Str
 
 BOOL ScCompiler::IsBoolean( const String& rName )
 {
-    ScOpCodeHashMap::const_iterator iLook( pSymbolHashMap->find( rName ) );
-    if( iLook != pSymbolHashMap->end() &&
-        (iLook->second == ocTrue ||
-         iLook->second == ocFalse) )
+    ScOpCodeHashMap::const_iterator iLook( mxSymbols->getHashMap()->find( rName ) );
+    if( iLook != mxSymbols->getHashMap()->end() &&
+        ((*iLook).second == ocTrue ||
+         (*iLook).second == ocFalse) )
     {
         ScRawToken aToken;
-        aToken.SetOpCode( iLook->second );
+        aToken.SetOpCode( (*iLook).second );
         pRawToken = aToken.Clone();
         return TRUE;
     }
@@ -1951,7 +2612,7 @@ void ScCompiler::AutoCorrectParsedSymbol
         }
         else if ( nPos == 0 && (c1 == cx || c1 == cX) )
         {   // x => *
-            aCorrectedSymbol = pSymbolTable[ocMul];
+            aCorrectedSymbol = mxSymbols->getSymbol(ocMul);
             bCorrected = TRUE;
         }
         else if ( (GetCharTableFlags( c1 ) & SC_COMPILER_C_CHAR_VALUE)
@@ -1961,7 +2622,7 @@ void ScCompiler::AutoCorrectParsedSymbol
             if ( (nXcount = aCorrectedSymbol.GetTokenCount( cx )) > 1 )
             {   // x => *
                 xub_StrLen nIndex = 0;
-                sal_Unicode c = pSymbolTable[ocMul].GetChar(0);
+                sal_Unicode c = mxSymbols->getSymbol(ocMul).GetChar(0);
                 while ( (nIndex = aCorrectedSymbol.SearchAndReplace(
                         cx, c, nIndex )) != STRING_NOTFOUND )
                     nIndex++;
@@ -1970,7 +2631,7 @@ void ScCompiler::AutoCorrectParsedSymbol
             if ( (nXcount = aCorrectedSymbol.GetTokenCount( cX )) > 1 )
             {   // X => *
                 xub_StrLen nIndex = 0;
-                sal_Unicode c = pSymbolTable[ocMul].GetChar(0);
+                sal_Unicode c = mxSymbols->getSymbol(ocMul).GetChar(0);
                 while ( (nIndex = aCorrectedSymbol.SearchAndReplace(
                         cX, c, nIndex )) != STRING_NOTFOUND )
                     nIndex++;
@@ -2321,7 +2982,7 @@ ScTokenArray* ScCompiler::CompileString(
                 SetError(errCodeOverflow);
             }
             else if ( bAutoCorrect )
-                aCorrectedFormula += pSymbolTable[ocArrayClose];
+                aCorrectedFormula += mxSymbols->getSymbol(ocArrayClose);
         }
 
         // With ocBad the remaining formula is a string, too many parentheses
@@ -2334,7 +2995,7 @@ ScTokenArray* ScCompiler::CompileString(
                 SetError(errCodeOverflow); break;
             }
             if ( bAutoCorrect )
-                aCorrectedFormula += pSymbolTable[ocClose];
+                aCorrectedFormula += mxSymbols->getSymbol(ocClose);
         }
     }
     if ( nForced >= 2 )
@@ -2784,44 +3445,44 @@ OpCode ScCompiler::NextToken()
                         switch ( eOp )
                         {   // swap operators
                             case ocGreater:
-                                if ( c == pSymbolTable[ocEqual].GetChar(0) )
+                                if ( c == mxSymbols->getSymbol(ocEqual).GetChar(0) )
                                 {   // >= instead of =>
                                     aCorrectedFormula.SetChar( nPos,
-                                        pSymbolTable[ocGreater].GetChar(0) );
+                                        mxSymbols->getSymbol(ocGreater).GetChar(0) );
                                     aCorrectedSymbol = c;
                                     bCorrected = TRUE;
                                 }
                             break;
                             case ocLess:
-                                if ( c == pSymbolTable[ocEqual].GetChar(0) )
+                                if ( c == mxSymbols->getSymbol(ocEqual).GetChar(0) )
                                 {   // <= instead of =<
                                     aCorrectedFormula.SetChar( nPos,
-                                        pSymbolTable[ocLess].GetChar(0) );
+                                        mxSymbols->getSymbol(ocLess).GetChar(0) );
                                     aCorrectedSymbol = c;
                                     bCorrected = TRUE;
                                 }
-                                else if ( c == pSymbolTable[ocGreater].GetChar(0) )
+                                else if ( c == mxSymbols->getSymbol(ocGreater).GetChar(0) )
                                 {   // <> instead of ><
                                     aCorrectedFormula.SetChar( nPos,
-                                        pSymbolTable[ocLess].GetChar(0) );
+                                        mxSymbols->getSymbol(ocLess).GetChar(0) );
                                     aCorrectedSymbol = c;
                                     bCorrected = TRUE;
                                 }
                             break;
                             case ocMul:
-                                if ( c == pSymbolTable[ocSub].GetChar(0) )
+                                if ( c == mxSymbols->getSymbol(ocSub).GetChar(0) )
                                 {   // *- instead of -*
                                     aCorrectedFormula.SetChar( nPos,
-                                        pSymbolTable[ocMul].GetChar(0) );
+                                        mxSymbols->getSymbol(ocMul).GetChar(0) );
                                     aCorrectedSymbol = c;
                                     bCorrected = TRUE;
                                 }
                             break;
                             case ocDiv:
-                                if ( c == pSymbolTable[ocSub].GetChar(0) )
+                                if ( c == mxSymbols->getSymbol(ocSub).GetChar(0) )
                                 {   // /- instead of -/
                                     aCorrectedFormula.SetChar( nPos,
-                                        pSymbolTable[ocDiv].GetChar(0) );
+                                        mxSymbols->getSymbol(ocDiv).GetChar(0) );
                                     aCorrectedSymbol = c;
                                     bCorrected = TRUE;
                                 }
@@ -2952,7 +3613,7 @@ void ScCompiler::Factor()
                ? errNoName : errOperatorExpected );
             if ( bAutoCorrect && !pStack )
             {   // assume multiplication
-                aCorrectedFormula += pSymbolTable[ocMul];
+                aCorrectedFormula += mxSymbols->getSymbol(ocMul);
                 bCorrected = TRUE;
                 NextToken();
                 eOp = Expression();
@@ -4338,9 +4999,7 @@ ScRangeData* ScCompiler::UpdateMoveTab( 
 
 const String& ScCompiler::GetStringFromOpCode( OpCode eOpCode, bool bEnglish )
 {
-    if( static_cast< USHORT >( eOpCode ) < nAnzStrings )
-        return bEnglish ? pSymbolTableEnglish[ eOpCode ] : pSymbolTableNative[ eOpCode ];
-    return EMPTY_STRING;
+    return bEnglish ? mxSymbolsEnglish->getSymbol( eOpCode ) : mxSymbolsNative->getSymbol( eOpCode );
 }
 
 ScToken* ScCompiler::CreateStringFromToken( String& rFormula, ScToken* pTokenP,
@@ -4382,8 +5041,8 @@ ScToken* ScCompiler::CreateStringFromTok
     }
     else if( eOp >= ocInternalBegin && eOp <= ocInternalEnd )
         rBuffer.appendAscii( pInternal[ eOp - ocInternalBegin ] );
-    else if( (USHORT) eOp < nAnzStrings)        // Keyword:
-        rBuffer.append(pSymbolTable[eOp]);
+    else if( (USHORT) eOp < mxSymbolsNative->getSymbolCount())        // Keyword:
+        rBuffer.append(mxSymbols->getSymbol(eOp));
     else
     {
         DBG_ERROR("Unbekannter OpCode");
@@ -4445,7 +5104,7 @@ ScToken* ScCompiler::CreateStringFromTok
                     {
                         if (pData->HasType(RT_SHARED))
                             pData->UpdateSymbol( aBuffer, aPos,
-                                        pSymbolTable == pSymbolTableEnglish,
+                                        mxSymbols->isEnglish(),
                                         pConv == pConvOOO_A1_XML );
                         else
                             aBuffer.append(pData->GetName());
@@ -4470,9 +5129,19 @@ ScToken* ScCompiler::CreateStringFromTok
         }
         case svExternal:
         {
-            //  show translated name of StarOne AddIns
+            // mapped or translated name of AddIns
             String aAddIn( t->GetExternal() );
-            if ( pSymbolTable != pSymbolTableEnglish )
+            bool bMapped = mxSymbols->isODF_11();   // ODF 1.1 directly uses programmatical name
+            if (!bMapped && mxSymbols->hasExternals())
+            {
+                ScExternalHashMap::const_iterator iLook = mxSymbols->getReverseExternalHashMap()->find( aAddIn);
+                if (iLook != mxSymbols->getReverseExternalHashMap()->end())
+                {
+                    aAddIn = (*iLook).second;
+                    bMapped = true;
+                }
+            }
+            if (!bMapped && !mxSymbols->isEnglish())
                 ScGlobal::GetAddInCollection()->LocalizeString( aAddIn );
             rBuffer.append(aAddIn);
         }
@@ -4503,19 +5172,19 @@ void ScCompiler::CreateStringFromScMatri
 
     pMatrix->GetDimensions( nMaxC, nMaxR);
 
-    rBuffer.append( pSymbolTable[ocArrayOpen] );
+    rBuffer.append( mxSymbols->getSymbol(ocArrayOpen) );
     for( nR = 0 ; nR < nMaxR ; nR++)
     {
         if( nR > 0)
         {
-            rBuffer.append( pSymbolTable[ocArrayRowSep] );
+            rBuffer.append( mxSymbols->getSymbol(ocArrayRowSep) );
         }
 
         for( nC = 0 ; nC < nMaxC ; nC++)
         {
             if( nC > 0)
             {
-                rBuffer.append( pSymbolTable[ocArrayColSep] );
+                rBuffer.append( mxSymbols->getSymbol(ocArrayColSep) );
             }
 
             if( pMatrix->IsValue( nC, nR ) )
@@ -4540,16 +5209,17 @@ void ScCompiler::CreateStringFromScMatri
                 AppendString( rBuffer, pMatrix->GetString( nC, nR ) );
         }
     }
-    rBuffer.append( pSymbolTable[ocArrayClose] );
+    rBuffer.append( mxSymbols->getSymbol(ocArrayClose) );
 }
+
 void ScCompiler::AppendBoolean( rtl::OUStringBuffer& rBuffer, bool bVal )
 {
-    rBuffer.append( pSymbolTable[bVal ? ocTrue : ocFalse] );
+    rBuffer.append( mxSymbols->getSymbol(static_cast<OpCode>(bVal ? ocTrue : ocFalse)) );
 }
 
 void ScCompiler::AppendDouble( rtl::OUStringBuffer& rBuffer, double fVal )
 {
-    if ( pSymbolTable == pSymbolTableEnglish )
+    if ( mxSymbols->isEnglish() )
     {
         ::rtl::math::doubleToUStringBuffer( rBuffer, fVal,
                 rtl_math_StringFormat_Automatic,
@@ -4652,7 +5322,7 @@ BOOL ScCompiler::DeQuote( String& rStr )
 }
 
 
-String* GetScCompilerpSymbolTableNative()
+String GetScCompilerNativeSymbol( OpCode eOp )
 {
-    return ScCompiler::pSymbolTableNative;
+    return ScCompiler::GetNativeSymbol( eOp );
 }
--- sc/source/core/tool/interpr4.cxx	6 Jul 2007 12:35:56 -0000	1.51
+++ sc/source/core/tool/interpr4.cxx	30 Aug 2007 09:24:13 -0000	1.47.14.3
@@ -1088,6 +1088,7 @@ bool ScInterpreter::ConvertMatrixParamet
                 case svDouble:
                 case svString:
                 case svSingleRef:
+                case svMissing:
                     // nothing to do
                 break;
                 case svMatrix:
@@ -2272,19 +2273,8 @@ void ScInterpreter::ScExternal()
 			}
 			else if ( aCall.HasMatrix() )
 			{
-				const ScMatrix*	pLinkMat = aCall.GetMatrix();		// not NULL
-
-                // copy matrix result
-                SCSIZE nC, nR;
-                pLinkMat->GetDimensions(nC, nR);
-				ScMatrixRef pNewMat = GetNewMat( nC, nR);
-				if (pNewMat)
-				{
-					pLinkMat->MatCopy(*pNewMat);
-					PushMatrix( pNewMat );
-				}
-                else
-                    PushError();
+				ScMatrixRef xMat = aCall.GetMatrix();
+                PushMatrix( xMat );
 			}
 			else if ( aCall.HasString() )
 				PushString( aCall.GetString() );
--- sc/source/core/tool/makefile.mk	27 Sep 2007 13:54:07 -0000	1.24
+++ sc/source/core/tool/makefile.mk	4 Oct 2007 09:09:07 -0000	1.20.14.2
@@ -99,6 +99,7 @@ SLOFILES =  \
 		$(SLO)$/interpr6.obj \
 		$(SLO)$/lookupcache.obj \
 		$(SLO)$/navicfg.obj \
+		$(SLO)$/odffmap.obj \
 		$(SLO)$/optutil.obj \
 		$(SLO)$/parclass.obj \
 		$(SLO)$/printopt.obj \
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ sc/source/core/tool/odffmap.cxx	31 Aug 2007 10:33:03 -0000	1.1.2.4
@@ -0,0 +1,154 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+
+#include "compiler.hxx"
+
+// ODFF, English, Programmatical, ODF_11
+ScCompiler::AddInMap ScCompiler::maAddInMap[] =
+{
+    { "ORG.OPENOFFICE.WEEKS", "WEEKS", false, "com.sun.star.sheet.addin.DateFunctions.getDiffWeeks", "COM.SUN.STAR.SHEET.ADDIN.DATEFUNCTIONS.GETDIFFWEEKS" },
+    { "ORG.OPENOFFICE.MONTHS", "MONTHS", false, "com.sun.star.sheet.addin.DateFunctions.getDiffMonths", "COM.SUN.STAR.SHEET.ADDIN.DATEFUNCTIONS.GETDIFFMONTHS" },
+    { "ORG.OPENOFFICE.YEARS", "YEARS", false, "com.sun.star.sheet.addin.DateFunctions.getDiffYears", "COM.SUN.STAR.SHEET.ADDIN.DATEFUNCTIONS.GETDIFFYEARS" },
+    { "ORG.OPENOFFICE.ISLEAPYEAR", "ISLEAPYEAR", false, "com.sun.star.sheet.addin.DateFunctions.getIsLeapYear", "COM.SUN.STAR.SHEET.ADDIN.DATEFUNCTIONS.GETISLEAPYEAR" },
+    { "ORG.OPENOFFICE.DAYSINMONTH", "DAYSINMONTH", false, "com.sun.star.sheet.addin.DateFunctions.getDaysInMonth", "COM.SUN.STAR.SHEET.ADDIN.DATEFUNCTIONS.GETDAYSINMONTH" },
+    { "ORG.OPENOFFICE.DAYSINYEAR", "DAYSINYEAR", false, "com.sun.star.sheet.addin.DateFunctions.getDaysInYear", "COM.SUN.STAR.SHEET.ADDIN.DATEFUNCTIONS.GETDAYSINYEAR" },
+    { "ORG.OPENOFFICE.WEEKSINYEAR", "WEEKSINYEAR", false, "com.sun.star.sheet.addin.DateFunctions.getWeeksInYear", "COM.SUN.STAR.SHEET.ADDIN.DATEFUNCTIONS.GETWEEKSINYEAR" },
+    { "ORG.OPENOFFICE.ROT13", "ROT13", false, "com.sun.star.sheet.addin.DateFunctions.getRot13", "COM.SUN.STAR.SHEET.ADDIN.DATEFUNCTIONS.GETROT13" },
+    { "WORKDAY", "WORKDAY", false, "com.sun.star.sheet.addin.Analysis.getWorkday", "COM.SUN.STAR.SHEET.ADDIN.ANALYSIS.GETWORKDAY" },
+    { "YEARFRAC", "YEARFRAC", false, "com.sun.star.sheet.addin.Analysis.getYearfrac", "COM.SUN.STAR.SHEET.ADDIN.ANALYSIS.GETYEARFRAC" },
+    { "EDATE", "EDATE", false, "com.sun.star.sheet.addin.Analysis.getEdate", "COM.SUN.STAR.SHEET.ADDIN.ANALYSIS.GETEDATE" },
+    { "WEEKNUM", "WEEKNUM_ADD", false, "com.sun.star.sheet.addin.Analysis.getWeeknum", "COM.SUN.STAR.SHEET.ADDIN.ANALYSIS.GETWEEKNUM" },
+    { "EOMONTH", "EOMONTH", false, "com.sun.star.sheet.addin.Analysis.getEomonth", "COM.SUN.STAR.SHEET.ADDIN.ANALYSIS.GETEOMONTH" },
+    { "NETWORKDAYS", "NETWORKDAYS", false, "com.sun.star.sheet.addin.Analysis.getNetworkdays", "COM.SUN.STAR.SHEET.ADDIN.ANALYSIS.GETNETWORKDAYS" },
+    { "ISEVEN", "ISEVEN_ADD", true, "com.sun.star.sheet.addin.Analysis.getIseven", "COM.SUN.STAR.SHEET.ADDIN.ANALYSIS.GETISEVEN" },
+    { "ISODD", "ISODD_ADD", true, "com.sun.star.sheet.addin.Analysis.getIsodd", "COM.SUN.STAR.SHEET.ADDIN.ANALYSIS.GETISODD" },
+    { "MULTINOMIAL", "MULTINOMIAL", false, "com.sun.star.sheet.addin.Analysis.getMultinomial", "COM.SUN.STAR.SHEET.ADDIN.ANALYSIS.GETMULTINOMIAL" },
+    { "SERIESSUM", "SERIESSUM", false, "com.sun.star.sheet.addin.Analysis.getSeriessum", "COM.SUN.STAR.SHEET.ADDIN.ANALYSIS.GETSERIESSUM" },
+    { "QUOTIENT", "QUOTIENT", false, "com.sun.star.sheet.addin.Analysis.getQuotient", "COM.SUN.STAR.SHEET.ADDIN.ANALYSIS.GETQUOTIENT" },
+    { "MROUND", "MROUND", false, "com.sun.star.sheet.addin.Analysis.getMround", "COM.SUN.STAR.SHEET.ADDIN.ANALYSIS.GETMROUND" },
+    { "SQRTPI", "SQRTPI", false, "com.sun.star.sheet.addin.Analysis.getSqrtpi", "COM.SUN.STAR.SHEET.ADDIN.ANALYSIS.GETSQRTPI" },
+    { "RANDBETWEEN", "RANDBETWEEN", false, "com.sun.star.sheet.addin.Analysis.getRandbetween", "COM.SUN.STAR.SHEET.ADDIN.ANALYSIS.GETRANDBETWEEN" },
+    { "GCD", "GCD_ADD", true, "com.sun.star.sheet.addin.Analysis.getGcd", "COM.SUN.STAR.SHEET.ADDIN.ANALYSIS.GETGCD" },
+    { "LCM", "LCM_ADD", true, "com.sun.star.sheet.addin.Analysis.getLcm", "COM.SUN.STAR.SHEET.ADDIN.ANALYSIS.GETLCM" },
+    { "BESSELI", "BESSELI", false, "com.sun.star.sheet.addin.Analysis.getBesseli", "COM.SUN.STAR.SHEET.ADDIN.ANALYSIS.GETBESSELI" },
+    { "BESSELJ", "BESSELJ", false, "com.sun.star.sheet.addin.Analysis.getBesselj", "COM.SUN.STAR.SHEET.ADDIN.ANALYSIS.GETBESSELJ" },
+    { "BESSELK", "BESSELK", false, "com.sun.star.sheet.addin.Analysis.getBesselk", "COM.SUN.STAR.SHEET.ADDIN.ANALYSIS.GETBESSELK" },
+    { "BESSELY", "BESSELY", false, "com.sun.star.sheet.addin.Analysis.getBessely", "COM.SUN.STAR.SHEET.ADDIN.ANALYSIS.GETBESSELY" },
+    { "BIN2OCT", "BIN2OCT", false, "com.sun.star.sheet.addin.Analysis.getBin2Oct", "COM.SUN.STAR.SHEET.ADDIN.ANALYSIS.GETBIN2OCT" },
+    { "BIN2DEC", "BIN2DEC", false, "com.sun.star.sheet.addin.Analysis.getBin2Dec", "COM.SUN.STAR.SHEET.ADDIN.ANALYSIS.GETBIN2DEC" },
+    { "BIN2HEX", "BIN2HEX", false, "com.sun.star.sheet.addin.Analysis.getBin2Hex", "COM.SUN.STAR.SHEET.ADDIN.ANALYSIS.GETBIN2HEX" },
+    { "OCT2BIN", "OCT2BIN", false, "com.sun.star.sheet.addin.Analysis.getOct2Bin", "COM.SUN.STAR.SHEET.ADDIN.ANALYSIS.GETOCT2BIN" },
+    { "OCT2DEC", "OCT2DEC", false, "com.sun.star.sheet.addin.Analysis.getOct2Dec", "COM.SUN.STAR.SHEET.ADDIN.ANALYSIS.GETOCT2DEC" },
+    { "OCT2HEX", "OCT2HEX", false, "com.sun.star.sheet.addin.Analysis.getOct2Hex", "COM.SUN.STAR.SHEET.ADDIN.ANALYSIS.GETOCT2HEX" },
+    { "DEC2BIN", "DEC2BIN", false, "com.sun.star.sheet.addin.Analysis.getDec2Bin", "COM.SUN.STAR.SHEET.ADDIN.ANALYSIS.GETDEC2BIN" },
+    { "DEC2OCT", "DEC2OCT", false, "com.sun.star.sheet.addin.Analysis.getDec2Oct", "COM.SUN.STAR.SHEET.ADDIN.ANALYSIS.GETDEC2OCT" },
+    { "DEC2HEX", "DEC2HEX", false, "com.sun.star.sheet.addin.Analysis.getDec2Hex", "COM.SUN.STAR.SHEET.ADDIN.ANALYSIS.GETDEC2HEX" },
+    { "HEX2BIN", "HEX2BIN", false, "com.sun.star.sheet.addin.Analysis.getHex2Bin", "COM.SUN.STAR.SHEET.ADDIN.ANALYSIS.GETHEX2BIN" },
+    { "HEX2DEC", "HEX2DEC", false, "com.sun.star.sheet.addin.Analysis.getHex2Dec", "COM.SUN.STAR.SHEET.ADDIN.ANALYSIS.GETHEX2DEC" },
+    { "HEX2OCT", "HEX2OCT", false, "com.sun.star.sheet.addin.Analysis.getHex2Oct", "COM.SUN.STAR.SHEET.ADDIN.ANALYSIS.GETHEX2OCT" },
+    { "DELTA", "DELTA", false, "com.sun.star.sheet.addin.Analysis.getDelta", "COM.SUN.STAR.SHEET.ADDIN.ANALYSIS.GETDELTA" },
+    { "ERF", "ERF", false, "com.sun.star.sheet.addin.Analysis.getErf", "COM.SUN.STAR.SHEET.ADDIN.ANALYSIS.GETERF" },
+    { "ERFC", "ERFC", false, "com.sun.star.sheet.addin.Analysis.getErfc", "COM.SUN.STAR.SHEET.ADDIN.ANALYSIS.GETERFC" },
+    { "GESTEP", "GESTEP", false, "com.sun.star.sheet.addin.Analysis.getGestep", "COM.SUN.STAR.SHEET.ADDIN.ANALYSIS.GETGESTEP" },
+    { "FACTDOUBLE", "FACTDOUBLE", false, "com.sun.star.sheet.addin.Analysis.getFactdouble", "COM.SUN.STAR.SHEET.ADDIN.ANALYSIS.GETFACTDOUBLE" },
+    { "IMABS", "IMABS", false, "com.sun.star.sheet.addin.Analysis.getImabs", "COM.SUN.STAR.SHEET.ADDIN.ANALYSIS.GETIMABS" },
+    { "IMAGINARY", "IMAGINARY", false, "com.sun.star.sheet.addin.Analysis.getImaginary", "COM.SUN.STAR.SHEET.ADDIN.ANALYSIS.GETIMAGINARY" },
+    { "IMPOWER", "IMPOWER", false, "com.sun.star.sheet.addin.Analysis.getImpower", "COM.SUN.STAR.SHEET.ADDIN.ANALYSIS.GETIMPOWER" },
+    { "IMARGUMENT", "IMARGUMENT", false, "com.sun.star.sheet.addin.Analysis.getImargument", "COM.SUN.STAR.SHEET.ADDIN.ANALYSIS.GETIMARGUMENT" },
+    { "IMCOS", "IMCOS", false, "com.sun.star.sheet.addin.Analysis.getImcos", "COM.SUN.STAR.SHEET.ADDIN.ANALYSIS.GETIMCOS" },
+    { "IMDIV", "IMDIV", false, "com.sun.star.sheet.addin.Analysis.getImdiv", "COM.SUN.STAR.SHEET.ADDIN.ANALYSIS.GETIMDIV" },
+    { "IMEXP", "IMEXP", false, "com.sun.star.sheet.addin.Analysis.getImexp", "COM.SUN.STAR.SHEET.ADDIN.ANALYSIS.GETIMEXP" },
+    { "IMCONJUGATE", "IMCONJUGATE", false, "com.sun.star.sheet.addin.Analysis.getImconjugate", "COM.SUN.STAR.SHEET.ADDIN.ANALYSIS.GETIMCONJUGATE" },
+    { "IMLN", "IMLN", false, "com.sun.star.sheet.addin.Analysis.getImln", "COM.SUN.STAR.SHEET.ADDIN.ANALYSIS.GETIMLN" },
+    { "IMLOG10", "IMLOG10", false, "com.sun.star.sheet.addin.Analysis.getImlog10", "COM.SUN.STAR.SHEET.ADDIN.ANALYSIS.GETIMLOG10" },
+    { "IMLOG2", "IMLOG2", false, "com.sun.star.sheet.addin.Analysis.getImlog2", "COM.SUN.STAR.SHEET.ADDIN.ANALYSIS.GETIMLOG2" },
+    { "IMPRODUCT", "IMPRODUCT", false, "com.sun.star.sheet.addin.Analysis.getImproduct", "COM.SUN.STAR.SHEET.ADDIN.ANALYSIS.GETIMPRODUCT" },
+    { "IMREAL", "IMREAL", false, "com.sun.star.sheet.addin.Analysis.getImreal", "COM.SUN.STAR.SHEET.ADDIN.ANALYSIS.GETIMREAL" },
+    { "IMSIN", "IMSIN", false, "com.sun.star.sheet.addin.Analysis.getImsin", "COM.SUN.STAR.SHEET.ADDIN.ANALYSIS.GETIMSIN" },
+    { "IMSUB", "IMSUB", false, "com.sun.star.sheet.addin.Analysis.getImsub", "COM.SUN.STAR.SHEET.ADDIN.ANALYSIS.GETIMSUB" },
+    { "IMSUM", "IMSUM", false, "com.sun.star.sheet.addin.Analysis.getImsum", "COM.SUN.STAR.SHEET.ADDIN.ANALYSIS.GETIMSUM" },
+    { "IMSQRT", "IMSQRT", false, "com.sun.star.sheet.addin.Analysis.getImsqrt", "COM.SUN.STAR.SHEET.ADDIN.ANALYSIS.GETIMSQRT" },
+    { "COMPLEX", "COMPLEX", false, "com.sun.star.sheet.addin.Analysis.getComplex", "COM.SUN.STAR.SHEET.ADDIN.ANALYSIS.GETCOMPLEX" },
+    { "CONVERT", "CONVERT_ADD", false, "com.sun.star.sheet.addin.Analysis.getConvert", "COM.SUN.STAR.SHEET.ADDIN.ANALYSIS.GETCONVERT" },
+    { "AMORDEGRC", "AMORDEGRC", false, "com.sun.star.sheet.addin.Analysis.getAmordegrc", "COM.SUN.STAR.SHEET.ADDIN.ANALYSIS.GETAMORDEGRC" },
+    { "AMORLINC", "AMORLINC", false, "com.sun.star.sheet.addin.Analysis.getAmorlinc", "COM.SUN.STAR.SHEET.ADDIN.ANALYSIS.GETAMORLINC" },
+    { "ACCRINT", "ACCRINT", false, "com.sun.star.sheet.addin.Analysis.getAccrint", "COM.SUN.STAR.SHEET.ADDIN.ANALYSIS.GETACCRINT" },
+    { "ACCRINTM", "ACCRINTM", false, "com.sun.star.sheet.addin.Analysis.getAccrintm", "COM.SUN.STAR.SHEET.ADDIN.ANALYSIS.GETACCRINTM" },
+    { "RECEIVED", "RECEIVED", false, "com.sun.star.sheet.addin.Analysis.getReceived", "COM.SUN.STAR.SHEET.ADDIN.ANALYSIS.GETRECEIVED" },
+    { "DISC", "DISC", false, "com.sun.star.sheet.addin.Analysis.getDisc", "COM.SUN.STAR.SHEET.ADDIN.ANALYSIS.GETDISC" },
+    { "DURATION", "DURATION_ADD", false, "com.sun.star.sheet.addin.Analysis.getDuration", "COM.SUN.STAR.SHEET.ADDIN.ANALYSIS.GETDURATION" },
+    { "EFFECT", "EFFECT_ADD", true, "com.sun.star.sheet.addin.Analysis.getEffect", "COM.SUN.STAR.SHEET.ADDIN.ANALYSIS.GETEFFECT" },
+    { "CUMPRINC", "CUMPRINC_ADD", true, "com.sun.star.sheet.addin.Analysis.getCumprinc", "COM.SUN.STAR.SHEET.ADDIN.ANALYSIS.GETCUMPRINC" },
+    { "CUMIPMT", "CUMIPMT_ADD", true, "com.sun.star.sheet.addin.Analysis.getCumipmt", "COM.SUN.STAR.SHEET.ADDIN.ANALYSIS.GETCUMIPMT" },
+    { "PRICE", "PRICE", false, "com.sun.star.sheet.addin.Analysis.getPrice", "COM.SUN.STAR.SHEET.ADDIN.ANALYSIS.GETPRICE" },
+    { "PRICEDISC", "PRICEDISC", false, "com.sun.star.sheet.addin.Analysis.getPricedisc", "COM.SUN.STAR.SHEET.ADDIN.ANALYSIS.GETPRICEDISC" },
+    { "PRICEMAT", "PRICEMAT", false, "com.sun.star.sheet.addin.Analysis.getPricemat", "COM.SUN.STAR.SHEET.ADDIN.ANALYSIS.GETPRICEMAT" },
+    { "MDURATION", "MDURATION", false, "com.sun.star.sheet.addin.Analysis.getMduration", "COM.SUN.STAR.SHEET.ADDIN.ANALYSIS.GETMDURATION" },
+    { "NOMINAL", "NOMINAL_ADD", true, "com.sun.star.sheet.addin.Analysis.getNominal", "COM.SUN.STAR.SHEET.ADDIN.ANALYSIS.GETNOMINAL" },
+    { "DOLLARFR", "DOLLARFR", false, "com.sun.star.sheet.addin.Analysis.getDollarfr", "COM.SUN.STAR.SHEET.ADDIN.ANALYSIS.GETDOLLARFR" },
+    { "DOLLARDE", "DOLLARDE", false, "com.sun.star.sheet.addin.Analysis.getDollarde", "COM.SUN.STAR.SHEET.ADDIN.ANALYSIS.GETDOLLARDE" },
+    { "YIELD", "YIELD", false, "com.sun.star.sheet.addin.Analysis.getYield", "COM.SUN.STAR.SHEET.ADDIN.ANALYSIS.GETYIELD" },
+    { "YIELDDISC", "YIELDDISC", false, "com.sun.star.sheet.addin.Analysis.getYielddisc", "COM.SUN.STAR.SHEET.ADDIN.ANALYSIS.GETYIELDDISC" },
+    { "YIELDMAT", "YIELDMAT", false, "com.sun.star.sheet.addin.Analysis.getYieldmat", "COM.SUN.STAR.SHEET.ADDIN.ANALYSIS.GETYIELDMAT" },
+    { "TBILLEQ", "TBILLEQ", false, "com.sun.star.sheet.addin.Analysis.getTbilleq", "COM.SUN.STAR.SHEET.ADDIN.ANALYSIS.GETTBILLEQ" },
+    { "TBILLPRICE", "TBILLPRICE", false, "com.sun.star.sheet.addin.Analysis.getTbillprice", "COM.SUN.STAR.SHEET.ADDIN.ANALYSIS.GETTBILLPRICE" },
+    { "TBILLYIELD", "TBILLYIELD", false, "com.sun.star.sheet.addin.Analysis.getTbillyield", "COM.SUN.STAR.SHEET.ADDIN.ANALYSIS.GETTBILLYIELD" },
+    { "ODDFPRICE", "ODDFPRICE", false, "com.sun.star.sheet.addin.Analysis.getOddfprice", "COM.SUN.STAR.SHEET.ADDIN.ANALYSIS.GETODDFPRICE" },
+    { "ODDFYIELD", "ODDFYIELD", false, "com.sun.star.sheet.addin.Analysis.getOddfyield", "COM.SUN.STAR.SHEET.ADDIN.ANALYSIS.GETODDFYIELD" },
+    { "ODDLPRICE", "ODDLPRICE", false, "com.sun.star.sheet.addin.Analysis.getOddlprice", "COM.SUN.STAR.SHEET.ADDIN.ANALYSIS.GETODDLPRICE" },
+    { "ODDLYIELD", "ODDLYIELD", false, "com.sun.star.sheet.addin.Analysis.getOddlyield", "COM.SUN.STAR.SHEET.ADDIN.ANALYSIS.GETODDLYIELD" },
+    { "XIRR", "XIRR", false, "com.sun.star.sheet.addin.Analysis.getXirr", "COM.SUN.STAR.SHEET.ADDIN.ANALYSIS.GETXIRR" },
+    { "XNPV", "XNPV", false, "com.sun.star.sheet.addin.Analysis.getXnpv", "COM.SUN.STAR.SHEET.ADDIN.ANALYSIS.GETXNPV" },
+    { "INTRATE", "INTRATE", false, "com.sun.star.sheet.addin.Analysis.getIntrate", "COM.SUN.STAR.SHEET.ADDIN.ANALYSIS.GETINTRATE" },
+    { "COUPNCD", "COUPNCD", false, "com.sun.star.sheet.addin.Analysis.getCoupncd", "COM.SUN.STAR.SHEET.ADDIN.ANALYSIS.GETCOUPNCD" },
+    { "COUPDAYS", "COUPDAYS", false, "com.sun.star.sheet.addin.Analysis.getCoupdays", "COM.SUN.STAR.SHEET.ADDIN.ANALYSIS.GETCOUPDAYS" },
+    { "COUPDAYSNC", "COUPDAYSNC", false, "com.sun.star.sheet.addin.Analysis.getCoupdaysnc", "COM.SUN.STAR.SHEET.ADDIN.ANALYSIS.GETCOUPDAYSNC" },
+    { "COUPDAYBS", "COUPDAYBS", false, "com.sun.star.sheet.addin.Analysis.getCoupdaybs", "COM.SUN.STAR.SHEET.ADDIN.ANALYSIS.GETCOUPDAYBS" },
+    { "COUPPCD", "COUPPCD", false, "com.sun.star.sheet.addin.Analysis.getCouppcd", "COM.SUN.STAR.SHEET.ADDIN.ANALYSIS.GETCOUPPCD" },
+    { "COUPNUM", "COUPNUM", false, "com.sun.star.sheet.addin.Analysis.getCoupnum", "COM.SUN.STAR.SHEET.ADDIN.ANALYSIS.GETCOUPNUM" },
+    { "FVSCHEDULE", "FVSCHEDULE", false, "com.sun.star.sheet.addin.Analysis.getFvschedule", "COM.SUN.STAR.SHEET.ADDIN.ANALYSIS.GETFVSCHEDULE" },
+};
+
+// static
+const ScCompiler::AddInMap* ScCompiler::GetAddInMap()
+{
+    return maAddInMap;
+}
+
+// static
+size_t ScCompiler::GetAddInMapCount()
+{
+    return sizeof(maAddInMap)/sizeof(maAddInMap[0]);
+}
--- sc/source/core/tool/parclass.cxx	26 Apr 2007 07:39:05 -0000	1.8
+++ sc/source/core/tool/parclass.cxx	23 Oct 2007 16:17:56 -0000	1.7.18.5
@@ -49,6 +49,7 @@
 #if OSL_DEBUG_LEVEL > 1
 // the documentation thingy
 #include <stdio.h>
+#include <com/sun/star/sheet/FormulaLanguage.hpp>
 #include "compiler.hxx"
 #include "sc.hrc"   // VAR_ARGS
 #endif
@@ -306,7 +307,7 @@ ScParameterClassification::Type ScParame
             // added to avoid warnings
         }
     }
-    if ( eOp <= SC_OPCODE_LAST_OPCODE_ID )
+    if ( 0 <= (short)eOp && eOp <= SC_OPCODE_LAST_OPCODE_ID )
     {
         if ( nParameter < CommonData::nMaxParams )
         {
@@ -453,20 +454,19 @@ void ScParameterClassification::Generate
     if ( !getenv( aEnvVarName) )
         return;
     MergeArgumentsFromFunctionResource();
-    // only to initialize English resources
-    {
-        ScCompiler aComp( 0, ScAddress());
-        aComp.SetCompileEnglish( TRUE);
-    }
-    const String* pSym = ScCompiler::pSymbolTableEnglish;
+    ScCompiler::OpCodeMapPtr xMap( ScCompiler::GetOpCodeMap(
+                ::com::sun::star::sheet::FormulaLanguage::ENGLISH));
+    if (!xMap)
+        return;
     fflush( stderr);
-    for ( size_t i=0; i<ScCompiler::nAnzStrings; ++i )
-    {
-        if ( pSym[i].Len() )
+    size_t nCount = xMap->getSymbolCount();
+    for ( size_t i=0; i<nCount; ++i )
         {
             OpCode eOp = OpCode(i);
+        if ( xMap->getSymbol(eOp).Len() )
+        {
             fprintf( stdout, "%s: ", aEnvVarName);
-            ByteString aStr( pSym[i], RTL_TEXTENCODING_UTF8);
+            ByteString aStr( xMap->getSymbol(eOp), RTL_TEXTENCODING_UTF8);
             aStr += "(";
             ScByteToken aToken( eOp);
             BYTE nParams = GetMinimumParameters( eOp);
--- sc/source/core/tool/rangenam.cxx	27 Feb 2007 12:18:14 -0000	1.24
+++ sc/source/core/tool/rangenam.cxx	14 Aug 2007 18:32:02 -0000	1.24.18.1
@@ -536,7 +536,7 @@ void ScRangeData::UpdateTabRef(SCTAB nOl
 
 void ScRangeData::MakeValidName( String& rName )		// static
 {
-		ScCompiler::Init();
+    ScCompiler::InitSymbolsNative();
 
 	//	ungueltige Zeichen vorne weglassen
 	xub_StrLen nPos = 0;
--- sc/source/core/tool/rangeseq.cxx	21 Jul 2006 11:41:27 -0000	1.7
+++ sc/source/core/tool/rangeseq.cxx	30 Aug 2007 15:10:48 -0000	1.7.194.2
@@ -309,7 +309,7 @@ BOOL ScRangeToSequence::FillMixedArray( 
 }
 
 
-BOOL ScRangeToSequence::FillMixedArray( uno::Any& rAny, const ScMatrix* pMatrix )
+BOOL ScRangeToSequence::FillMixedArray( uno::Any& rAny, const ScMatrix* pMatrix, bool bDataTypes )
 {
 	if (!pMatrix)
 		return FALSE;
@@ -334,7 +334,13 @@ BOOL ScRangeToSequence::FillMixedArray( 
 				pColAry[nCol] <<= rtl::OUString( aStr );
 			}
 			else
-				pColAry[nCol] <<= (double) pMatrix->GetDouble( nCol, nRow );
+            {
+                double fVal = pMatrix->GetDouble( nCol, nRow );
+                if (bDataTypes && pMatrix->IsBoolean( nCol, nRow ))
+                    pColAry[nCol] <<= (fVal ? true : false);
+                else
+                    pColAry[nCol] <<= fVal;
+            }
 		}
 
 		pRowAry[nRow] = aColSeq;
@@ -344,6 +350,119 @@ BOOL ScRangeToSequence::FillMixedArray( 
 	return TRUE;
 }
 
+//------------------------------------------------------------------------
+
+// static
+bool ScApiTypeConversion::ConvertAnyToDouble( double & o_fVal,
+        com::sun::star::uno::TypeClass & o_eClass,
+        const com::sun::star::uno::Any & rAny )
+{
+    bool bRet = false;
+    o_eClass = rAny.getValueTypeClass();
+    switch (o_eClass)
+    {
+        //! extract integer values
+        case uno::TypeClass_ENUM:
+        case uno::TypeClass_BOOLEAN:
+        case uno::TypeClass_CHAR:
+        case uno::TypeClass_BYTE:
+        case uno::TypeClass_SHORT:
+        case uno::TypeClass_UNSIGNED_SHORT:
+        case uno::TypeClass_LONG:
+        case uno::TypeClass_UNSIGNED_LONG:
+        case uno::TypeClass_FLOAT:
+        case uno::TypeClass_DOUBLE:
+            rAny >>= o_fVal;
+            bRet = true;
+            break;
+        default:
+            ;   // nothing, avoid warning
+    }
+    if (!bRet)
+        o_fVal = 0.0;
+    return bRet;
+}
+
+//------------------------------------------------------------------------
+
+// static
+ScMatrixRef ScSequenceToMatrix::CreateMixedMatrix( const com::sun::star::uno::Any & rAny )
+{
+    ScMatrixRef xMatrix;
+    uno::Sequence< uno::Sequence< uno::Any > > aSequence;
+    if ( rAny >>= aSequence )
+    {
+        sal_Int32 nRowCount = aSequence.getLength();
+        const uno::Sequence<uno::Any>* pRowArr = aSequence.getConstArray();
+        sal_Int32 nMaxColCount = 0;
+        sal_Int32 nCol, nRow;
+        for (nRow=0; nRow<nRowCount; nRow++)
+        {
+            sal_Int32 nTmp = pRowArr[nRow].getLength();
+            if ( nTmp > nMaxColCount )
+                nMaxColCount = nTmp;
+        }
+        if ( nMaxColCount && nRowCount )
+        {
+            rtl::OUString aUStr;
+            xMatrix = new ScMatrix(
+                    static_cast<SCSIZE>(nMaxColCount),
+                    static_cast<SCSIZE>(nRowCount) );
+            ScMatrix* pMatrix = xMatrix;
+            SCSIZE nCols, nRows;
+            pMatrix->GetDimensions( nCols, nRows);
+            if (nCols != static_cast<SCSIZE>(nMaxColCount) || nRows != static_cast<SCSIZE>(nRowCount))
+            {
+                DBG_ERRORFILE( "ScSequenceToMatrix::CreateMixedMatrix: matrix exceeded max size, returning NULL matrix");
+                return NULL;
+            }
+            for (nRow=0; nRow<nRowCount; nRow++)
+            {
+                sal_Int32 nColCount = pRowArr[nRow].getLength();
+                const uno::Any* pColArr = pRowArr[nRow].getConstArray();
+                for (nCol=0; nCol<nColCount; nCol++)
+                {
+                    double fVal;
+                    uno::TypeClass eClass;
+                    if (ScApiTypeConversion::ConvertAnyToDouble( fVal, eClass, pColArr[nCol]))
+                    {
+                        if (eClass == uno::TypeClass_BOOLEAN)
+                            pMatrix->PutBoolean( (fVal ? true : false),
+                                    static_cast<SCSIZE>(nCol),
+                                    static_cast<SCSIZE>(nRow) );
+                        else
+                            pMatrix->PutDouble( fVal,
+                                    static_cast<SCSIZE>(nCol),
+                                    static_cast<SCSIZE>(nRow) );
+                    }
+                    else
+                    {
+                        // Try string, else use empty as last resort.
+
+                        //Reflection* pRefl = pColArr[nCol].getReflection();
+                        //if ( pRefl->equals( *OUString_getReflection() ) )
+                        if ( pColArr[nCol] >>= aUStr )
+                            pMatrix->PutString( String( aUStr ),
+                                    static_cast<SCSIZE>(nCol),
+                                    static_cast<SCSIZE>(nRow) );
+                        else
+                            pMatrix->PutEmpty(
+                                    static_cast<SCSIZE>(nCol),
+                                    static_cast<SCSIZE>(nRow) );
+                    }
+                }
+                for (nCol=nColCount; nCol<nMaxColCount; nCol++)
+                {
+                    pMatrix->PutEmpty(
+                            static_cast<SCSIZE>(nCol),
+                            static_cast<SCSIZE>(nRow) );
+                }
+            }
+        }
+    }
+    return xMatrix;
+}
+
 
 //------------------------------------------------------------------------
 
--- sc/source/filter/excel/xestyle.cxx	18 Jul 2007 11:55:28 -0000	1.30
+++ sc/source/filter/excel/xestyle.cxx	24 Jul 2007 21:19:45 -0000	1.28.6.2
@@ -385,7 +385,7 @@ XclExpPaletteImpl::XclExpPaletteImpl( co
     mnLastIdx( 0 )
 {
     // initialize maPalette with default colors
-    const sal_uInt16 nCount = static_cast< sal_uInt16 >( mrDefPal.GetColorCount() );
+    sal_uInt16 nCount = static_cast< sal_uInt16 >( mrDefPal.GetColorCount() );
     maPalette.reserve( nCount );
     for( sal_uInt16 nIdx = 0; nIdx < nCount; ++nIdx )
         maPalette.push_back( XclPaletteColor( mrDefPal.GetDefColor( GetXclIndex( nIdx ) ) ) );
--- sc/source/ui/dbgui/validate.cxx	27 Feb 2007 13:05:45 -0000	1.16
+++ sc/source/ui/dbgui/validate.cxx	14 Aug 2007 18:32:02 -0000	1.16.18.1
@@ -250,9 +250,9 @@ ScTPValidationValue::ScTPValidationValue
 
     // list separator in formulas
     //CHINA001 const String& rListSep = ScCompiler::pSymbolTableNative[ ocSep ];
-	const String& rListSep = ::GetScCompilerpSymbolTableNative()[ocSep]; //CHINA001 
-    DBG_ASSERT( rListSep.Len() == 1, "ScTPValidationValue::ScTPValidationValue - list separator error" );
-    mcFmlaSep = rListSep.Len() ? rListSep.GetChar( 0 ) : ';';
+	String aListSep = ::GetScCompilerNativeSymbol( ocSep ); //CHINA001 
+    DBG_ASSERT( aListSep.Len() == 1, "ScTPValidationValue::ScTPValidationValue - list separator error" );
+    mcFmlaSep = aListSep.Len() ? aListSep.GetChar( 0 ) : ';';
 }
 
 ScTPValidationValue::~ScTPValidationValue()
--- sc/source/ui/docshell/docfunc.cxx	27 Jun 2007 12:45:25 -0000	1.66
+++ sc/source/ui/docshell/docfunc.cxx	7 Dec 2007 09:25:55 -0000	1.65.16.6
@@ -137,6 +137,10 @@ BOOL ScDocFunc::AdjustRowHeight( const S
 		//	for XML import, all row heights are updated together after importing
 		return FALSE;
 	}
+    if ( !pDoc->IsAdjustHeightEnabled() )
+    {
+        return FALSE;
+    }
 
 	SCTAB nTab      = rRange.aStart.Tab();
 	SCROW nStartRow = rRange.aStart.Row();
@@ -2329,7 +2333,8 @@ BOOL ScDocFunc::SetWidthOrHeight( BOOL b
 	if ( bRecord && !pDoc->IsUndoEnabled() )
 		bRecord = FALSE;
 
-	if ( !rDocShell.IsEditable() )
+    // import into read-only document is possible
+    if ( !pDoc->IsChangeReadOnlyEnabled() && !rDocShell.IsEditable() )
 	{
 		if (!bApi)
 			rDocShell.ErrorMessage(STR_PROTECTIONERR);		//! eigene Meldung?
@@ -2925,6 +2930,7 @@ BOOL ScDocFunc::AutoFormat( const ScRang
 //------------------------------------------------------------------------
 
 BOOL ScDocFunc::EnterMatrix( const ScRange& rRange, const ScMarkData* pTabMark,
+                                const ScTokenArray* pTokenArray,
 								const String& rString, BOOL bApi, BOOL bEnglish )
 {
 	ScDocShellModificator aModificator( rDocShell );
@@ -2964,7 +2970,12 @@ BOOL ScDocFunc::EnterMatrix( const ScRan
 			pDoc->CopyToDocument( rRange, IDF_ALL, FALSE, pUndoDoc );
 		}
 
-		if ( pDoc->IsImportingXML() )
+        // use TokenArray if given, string (and flags) otherwise
+        if ( pTokenArray )
+        {
+            pDoc->InsertMatrixFormula(nStartCol,nStartRow,nEndCol,nEndRow,aMark,EMPTY_STRING,pTokenArray);
+        }
+        else if ( pDoc->IsImportingXML() )
 		{
 			ScTokenArray* pCode = lcl_ScDocFunc_CreateTokenArrayXML( rString );
 			pDoc->InsertMatrixFormula(nStartCol,nStartRow,nEndCol,nEndRow,aMark,EMPTY_STRING,pCode);
@@ -3612,7 +3623,7 @@ BOOL ScDocFunc::SetNewRangeNames( ScRang
     // #i55926# While loading XML, formula cells only have a single string token,
     // so CompileNameFormula would never find any name (index) tokens, and would
     // unnecessarily loop through all cells.
-    BOOL bCompile = !pDoc->IsImportingXML();
+    BOOL bCompile = ( !pDoc->IsImportingXML() && pDoc->GetNamedRangesLockCount() == 0 );
 
     if ( bCompile )
         pDoc->CompileNameFormula( TRUE );	// CreateFormulaString
@@ -3915,11 +3926,11 @@ BOOL ScDocFunc::ResizeMatrix( const ScRa
 
 		if ( DeleteContents( aMark, IDF_CONTENTS, TRUE, bApi ) )
 		{
-			bRet = EnterMatrix( aNewRange, &aMark, aFormula, bApi, FALSE );
+            bRet = EnterMatrix( aNewRange, &aMark, NULL, aFormula, bApi, FALSE );
 			if (!bRet)
 			{
 				//	versuchen, alten Zustand wiederherzustellen
-				EnterMatrix( rOldRange, &aMark, aFormula, bApi, FALSE );
+                EnterMatrix( rOldRange, &aMark, NULL, aFormula, bApi, FALSE );
 			}
 		}
 
--- sc/source/ui/docshell/docsh.cxx	3 Aug 2007 13:08:10 -0000	1.92
+++ sc/source/ui/docshell/docsh.cxx	4 Oct 2007 09:13:43 -0000	1.89.16.4
@@ -535,6 +535,7 @@ void ScDocShell::BeforeXMLLoading()
 	pModificator = new ScDocShellModificator( *this );
 
     aDocument.SetImportingXML( TRUE );
+    aDocument.EnableUndo( FALSE );
 	// prevent unnecessary broadcasts and "half way listeners"
 	aDocument.SetInsertingFromOtherDoc( TRUE );
 
@@ -614,6 +615,7 @@ void ScDocShell::AfterXMLLoading(sal_Boo
 		aDocument.SetInsertingFromOtherDoc( FALSE );
 
 	aDocument.SetImportingXML( FALSE );
+    aDocument.EnableUndo( TRUE );
     bIsEmpty = FALSE;
 
     if (pModificator)
--- sc/source/ui/docshell/docsh2.cxx	10 May 2007 16:55:49 -0000	1.23
+++ sc/source/ui/docshell/docsh2.cxx	29 May 2007 14:19:39 -0000	1.22.18.2
@@ -122,9 +122,9 @@ BOOL ScDocShell::IsEmpty() const
 }
 
 
-void ScDocShell::ResetEmpty()
+void ScDocShell::SetEmpty(BOOL bSet)
 {
-	bIsEmpty = FALSE;
+	bIsEmpty = bSet;
 }
 
 //------------------------------------------------------------------
--- sc/source/ui/docshell/docsh3.cxx	17 Jul 2007 13:34:17 -0000	1.30
+++ sc/source/ui/docshell/docsh3.cxx	24 Jul 2007 21:33:36 -0000	1.29.18.2
@@ -953,7 +953,7 @@ void ScDocShell::MergeDocument( ScDocume
 									aSourceRange.aEnd.SetRow( aPos.Row() + nRows - 1 );
 									aValue.Erase( 0, 1 );
 									aValue.Erase( aValue.Len()-1, 1 );
-									GetDocFunc().EnterMatrix( aSourceRange, NULL, aValue, FALSE, FALSE );
+                                    GetDocFunc().EnterMatrix( aSourceRange, NULL, NULL, aValue, FALSE, FALSE );
 								}
 								break;
 								case MM_REFERENCE :		// do nothing
--- sc/source/ui/drawfunc/drawsh2.cxx	6 Jul 2007 12:42:40 -0000	1.24
+++ sc/source/ui/drawfunc/drawsh2.cxx	24 Jul 2007 21:34:52 -0000	1.23.82.3
@@ -65,6 +65,7 @@
 #include "viewdata.hxx"
 #include "sc.hrc"
 #include "tabvwsh.hxx"
+#include "document.hxx"
 #include "drwlayer.hxx"
 #include "userdat.hxx"
 
@@ -86,7 +87,12 @@ ScDrawShell::ScDrawShell( ScViewData* pD
 	pViewData( pData )
 {
 	SetPool( &pViewData->GetScDrawView()->GetModel()->GetItemPool() );
-	SetUndoManager( pViewData->GetSfxDocShell()->GetUndoManager() );
+    SfxUndoManager* pMgr = pViewData->GetSfxDocShell()->GetUndoManager();
+    SetUndoManager( pMgr );
+    if ( !pViewData->GetDocument()->IsUndoEnabled() )
+    {
+        pMgr->SetMaxUndoActionCount( 0 );
+    }
 	SetHelpId( HID_SCSHELL_DRAWSH );
 	SetName(String::CreateFromAscii(RTL_CONSTASCII_STRINGPARAM("Drawing")));
 }
--- sc/source/ui/drawfunc/drtxtob.cxx	18 Jul 2007 09:44:35 -0000	1.32
+++ sc/source/ui/drawfunc/drtxtob.cxx	24 Jul 2007 21:35:11 -0000	1.29.18.5
@@ -130,7 +130,12 @@ ScDrawTextObjectBar::ScDrawTextObjectBar
 	SetPool( pViewData->GetScDrawView()->GetDefaultAttr().GetPool() );
 
 	//	UndoManager wird beim Umschalten in den Edit-Modus umgesetzt...
-	SetUndoManager( pViewData->GetSfxDocShell()->GetUndoManager() );
+    SfxUndoManager* pMgr = pViewData->GetSfxDocShell()->GetUndoManager();
+    SetUndoManager( pMgr );
+    if ( !pViewData->GetDocument()->IsUndoEnabled() )
+    {
+        pMgr->SetMaxUndoActionCount( 0 );
+    }
 
 	SetHelpId( HID_SCSHELL_DRTXTOB );
 	SetName(String::CreateFromAscii(RTL_CONSTASCII_STRINGPARAM("DrawText")));
--- sc/source/ui/inc/docfunc.hxx	25 Apr 2007 15:58:57 -0000	1.15
+++ sc/source/ui/inc/docfunc.hxx	24 Jul 2007 09:06:24 -0000	1.15.8.3
@@ -57,6 +57,7 @@ class ScPatternAttr;
 class ScRange;
 class ScRangeName;
 class ScBaseCell;
+class ScTokenArray;
 struct ScTabOpParam;
 
 
@@ -147,6 +148,7 @@ public:
 									USHORT nFormatNo, BOOL bRecord, BOOL bApi );
 
 	BOOL			EnterMatrix( const ScRange& rRange, const ScMarkData* pTabMark,
+                                    const ScTokenArray* pTokenArray,
 									const String& rString, BOOL bApi, BOOL bEnglish );
 
 	BOOL			TabOp( const ScRange& rRange, const ScMarkData* pTabMark,
--- sc/source/ui/inc/docsh.hxx	6 Jul 2007 12:43:58 -0000	1.43
+++ sc/source/ui/inc/docsh.hxx	24 Jul 2007 21:36:57 -0000	1.40.18.4
@@ -365,7 +365,7 @@ public:
 
 	void			SetInplace( BOOL bInplace );
 	BOOL			IsEmpty() const;
-	void			ResetEmpty();
+	void			SetEmpty(BOOL bSet);
 
 	BOOL			IsInUndo() const				{ return bIsInUndo; }
 	void			SetInUndo(BOOL bSet);
--- sc/source/ui/inc/viewdata.hxx	27 Feb 2007 13:28:47 -0000	1.20
+++ sc/source/ui/inc/viewdata.hxx	11 Jun 2007 08:57:35 -0000	1.20.18.2
@@ -95,6 +95,7 @@ class SfxDispatcher;
 class ScPatternAttr;
 class ScRangeListRef;
 class ScExtDocOptions;
+class ScViewData;
 
 //--------------------------------------------------------------------------
 
@@ -129,12 +129,15 @@ private:
 	BOOL			bOldCurValid;				// "virtuelle" Cursorpos. bei zusammengefassten
 
 					ScViewDataTable();
-					ScViewDataTable( const ScViewDataTable& rDataTable );
 					~ScViewDataTable();
 
-	void			WriteUserDataSequence(com::sun::star::uno::Sequence <com::sun::star::beans::PropertyValue>& rSettings);
-	void			ReadUserDataSequence(const com::sun::star::uno::Sequence <com::sun::star::beans::PropertyValue>& rSettings,
-	                                     bool& rHasZoom);
+    void            WriteUserDataSequence(
+                        com::sun::star::uno::Sequence <com::sun::star::beans::PropertyValue>& rSettings,
+                        const ScViewData& rViewData, SCTAB nTab );
+
+    void            ReadUserDataSequence(
+                        const com::sun::star::uno::Sequence <com::sun::star::beans::PropertyValue>& rSettings,
+                        bool& rHasZoom, ScViewData& rViewData, SCTAB nTab );
 };
 
 // ---------------------------------------------------------------------------
--- sc/source/ui/unoobj/cellsuno.cxx	25 Jul 2007 09:14:56 -0000	1.107
+++ sc/source/ui/unoobj/cellsuno.cxx	22 Nov 2007 09:13:30 -0000	1.100.18.7
@@ -91,6 +91,7 @@
 #include "convuno.hxx"
 #include "srchuno.hxx"
 #include "targuno.hxx"
+#include "tokenuno.hxx"
 #include "docsh.hxx"
 #include "markdata.hxx"
 #include "patattr.hxx"
@@ -4799,6 +4800,7 @@ uno::Any SAL_CALL ScCellRangeObj::queryI
 	SC_QUERYINTERFACE( table::XCellRange )
 	SC_QUERYINTERFACE( sheet::XSheetCellRange )
 	SC_QUERYINTERFACE( sheet::XArrayFormulaRange )
+	SC_QUERYINTERFACE( sheet::XArrayFormulaTokens )
 	SC_QUERYINTERFACE( sheet::XCellRangeData )
 	SC_QUERYINTERFACE( sheet::XCellRangeFormula )
 	SC_QUERYINTERFACE( sheet::XMultipleOperation )
@@ -4836,24 +4838,25 @@ uno::Sequence<uno::Type> SAL_CALL ScCell
 		long nParentLen = aParentTypes.getLength();
 		const uno::Type* pParentPtr = aParentTypes.getConstArray();
 
-		aTypes.realloc( nParentLen + 16 );
+		aTypes.realloc( nParentLen + 17 );
 		uno::Type* pPtr = aTypes.getArray();
 		pPtr[nParentLen + 0] = getCppuType((const uno::Reference<sheet::XCellRangeAddressable>*)0);
 		pPtr[nParentLen + 1] = getCppuType((const uno::Reference<sheet::XSheetCellRange>*)0);
 		pPtr[nParentLen + 2] = getCppuType((const uno::Reference<sheet::XArrayFormulaRange>*)0);
-		pPtr[nParentLen + 3] = getCppuType((const uno::Reference<sheet::XCellRangeData>*)0);
-		pPtr[nParentLen + 4] = getCppuType((const uno::Reference<sheet::XCellRangeFormula>*)0);
-		pPtr[nParentLen + 5] = getCppuType((const uno::Reference<sheet::XMultipleOperation>*)0);
-		pPtr[nParentLen + 6] = getCppuType((const uno::Reference<util::XMergeable>*)0);
-		pPtr[nParentLen + 7] = getCppuType((const uno::Reference<sheet::XCellSeries>*)0);
-		pPtr[nParentLen + 8] = getCppuType((const uno::Reference<table::XAutoFormattable>*)0);
-		pPtr[nParentLen + 9] = getCppuType((const uno::Reference<util::XSortable>*)0);
-		pPtr[nParentLen +10] = getCppuType((const uno::Reference<sheet::XSheetFilterableEx>*)0);
-		pPtr[nParentLen +11] = getCppuType((const uno::Reference<sheet::XSubTotalCalculatable>*)0);
-		pPtr[nParentLen +12] = getCppuType((const uno::Reference<table::XColumnRowRange>*)0);
-		pPtr[nParentLen +13] = getCppuType((const uno::Reference<util::XImportable>*)0);
-		pPtr[nParentLen +14] = getCppuType((const uno::Reference<sheet::XCellFormatRangesSupplier>*)0);
-		pPtr[nParentLen +15] = getCppuType((const uno::Reference<sheet::XUniqueCellFormatRangesSupplier>*)0);
+		pPtr[nParentLen + 3] = getCppuType((const uno::Reference<sheet::XArrayFormulaTokens>*)0);
+		pPtr[nParentLen + 4] = getCppuType((const uno::Reference<sheet::XCellRangeData>*)0);
+		pPtr[nParentLen + 5] = getCppuType((const uno::Reference<sheet::XCellRangeFormula>*)0);
+		pPtr[nParentLen + 6] = getCppuType((const uno::Reference<sheet::XMultipleOperation>*)0);
+		pPtr[nParentLen + 7] = getCppuType((const uno::Reference<util::XMergeable>*)0);
+		pPtr[nParentLen + 8] = getCppuType((const uno::Reference<sheet::XCellSeries>*)0);
+		pPtr[nParentLen + 9] = getCppuType((const uno::Reference<table::XAutoFormattable>*)0);
+		pPtr[nParentLen +10] = getCppuType((const uno::Reference<util::XSortable>*)0);
+		pPtr[nParentLen +11] = getCppuType((const uno::Reference<sheet::XSheetFilterableEx>*)0);
+		pPtr[nParentLen +12] = getCppuType((const uno::Reference<sheet::XSubTotalCalculatable>*)0);
+		pPtr[nParentLen +13] = getCppuType((const uno::Reference<table::XColumnRowRange>*)0);
+		pPtr[nParentLen +14] = getCppuType((const uno::Reference<util::XImportable>*)0);
+		pPtr[nParentLen +15] = getCppuType((const uno::Reference<sheet::XCellFormatRangesSupplier>*)0);
+		pPtr[nParentLen +16] = getCppuType((const uno::Reference<sheet::XUniqueCellFormatRangesSupplier>*)0);
 
 		for (long i=0; i<nParentLen; i++)
 			pPtr[i] = pParentPtr[i];				// parent types first
@@ -5102,7 +5105,7 @@ void SAL_CALL ScCellRangeObj::setArrayFo
 				throw uno::RuntimeException();
 			}
 
-			aFunc.EnterMatrix( aRange, NULL, aString, TRUE, TRUE );
+            aFunc.EnterMatrix( aRange, NULL, NULL, aString, TRUE, TRUE );
 		}
 		else
 		{
@@ -5115,6 +5118,72 @@ void SAL_CALL ScCellRangeObj::setArrayFo
 	}
 }
 
+// XArrayFormulaTokens
+
+uno::Sequence<sheet::FormulaToken> SAL_CALL ScCellRangeObj::getArrayTokens() throw(uno::RuntimeException)
+{
+    ScUnoGuard aGuard;
+
+    // same cell logic as in getArrayFormula
+
+    uno::Sequence<sheet::FormulaToken> aSequence;
+    ScDocShell* pDocSh = GetDocShell();
+    if ( pDocSh )
+    {
+        ScDocument* pDoc = pDocSh->GetDocument();
+        const ScBaseCell* pCell1 = pDoc->GetCell( aRange.aStart );
+        const ScBaseCell* pCell2 = pDoc->GetCell( aRange.aEnd );
+        if ( pCell1 && pCell2 && pCell1->GetCellType() == CELLTYPE_FORMULA &&
+                                 pCell2->GetCellType() == CELLTYPE_FORMULA )
+        {
+            const ScFormulaCell* pFCell1 = (const ScFormulaCell*)pCell1;
+            const ScFormulaCell* pFCell2 = (const ScFormulaCell*)pCell2;
+            ScAddress aStart1;
+            ScAddress aStart2;
+            if ( pFCell1->GetMatrixOrigin( aStart1 ) && pFCell2->GetMatrixOrigin( aStart2 ) )
+            {
+                if ( aStart1 == aStart2 )
+                {
+                    ScTokenArray* pTokenArray = pFCell1->GetCode();
+                    if ( pTokenArray )
+                        (void)ScTokenConversion::ConvertToTokenSequence( aSequence, *pTokenArray );
+                }
+            }
+        }
+    }
+    return aSequence;
+}
+
+void SAL_CALL ScCellRangeObj::setArrayTokens( const uno::Sequence<sheet::FormulaToken>& rTokens ) throw(uno::RuntimeException)
+{
+    ScUnoGuard aGuard;
+    ScDocShell* pDocSh = GetDocShell();
+    if ( pDocSh )
+    {
+        ScDocFunc aFunc(*pDocSh);
+        if ( rTokens.getLength() )
+        {
+            if ( ScTableSheetObj::getImplementation( (cppu::OWeakObject*)this ) )
+            {
+                throw uno::RuntimeException();
+            }
+
+            ScTokenArray aTokenArray;
+            (void)ScTokenConversion::ConvertToTokenArray( aTokenArray, rTokens );
+
+            aFunc.EnterMatrix( aRange, NULL, &aTokenArray, EMPTY_STRING, TRUE, TRUE );
+        }
+        else
+        {
+            //  empty sequence -> erase array formula
+            ScMarkData aMark;
+            aMark.SetMarkArea( aRange );
+            aMark.SelectTable( aRange.aStart.Tab(), TRUE );
+            aFunc.DeleteContents( aMark, IDF_CONTENTS, TRUE, TRUE );
+        }
+    }
+}
+
 // XCellRangeData
 
 uno::Sequence< uno::Sequence<uno::Any> > SAL_CALL ScCellRangeObj::getDataArray()
@@ -6022,6 +6091,7 @@ void ScCellObj::RefChanged()
 uno::Any SAL_CALL ScCellObj::queryInterface( const uno::Type& rType ) throw(uno::RuntimeException)
 {
 	SC_QUERYINTERFACE( table::XCell )
+    SC_QUERYINTERFACE( sheet::XFormulaTokens )
 	SC_QUERYINTERFACE( sheet::XCellAddressable )
 	SC_QUERYINTERFACE( text::XText )
 	SC_QUERYINTERFACE( text::XSimpleText )
@@ -6054,7 +6124,7 @@ uno::Sequence<uno::Type> SAL_CALL ScCell
 		long nParentLen = aParentTypes.getLength();
 		const uno::Type* pParentPtr = aParentTypes.getConstArray();
 
-		aTypes.realloc( nParentLen + 7 );
+		aTypes.realloc( nParentLen + 8 );
 		uno::Type* pPtr = aTypes.getArray();
 		pPtr[nParentLen + 0] = getCppuType((const uno::Reference<table::XCell>*)0);
 		pPtr[nParentLen + 1] = getCppuType((const uno::Reference<sheet::XCellAddressable>*)0);
@@ -6063,6 +6133,7 @@ uno::Sequence<uno::Type> SAL_CALL ScCell
 		pPtr[nParentLen + 4] = getCppuType((const uno::Reference<sheet::XSheetAnnotationAnchor>*)0);
 		pPtr[nParentLen + 5] = getCppuType((const uno::Reference<text::XTextFieldsSupplier>*)0);
 		pPtr[nParentLen + 6] = getCppuType((const uno::Reference<document::XActionLockable>*)0);
+		pPtr[nParentLen + 7] = getCppuType((const uno::Reference<sheet::XFormulaTokens>*)0);
 
 		for (long i=0; i<nParentLen; i++)
 			pPtr[i] = pParentPtr[i];				// parent types first
@@ -6461,6 +6532,43 @@ sal_Int32 SAL_CALL ScCellObj::getError()
 	return nError;
 }
 
+// XFormulaTokens
+
+uno::Sequence<sheet::FormulaToken> SAL_CALL ScCellObj::getTokens() throw(uno::RuntimeException)
+{
+	ScUnoGuard aGuard;
+    uno::Sequence<sheet::FormulaToken> aSequence;
+    ScDocShell* pDocSh = GetDocShell();
+    if ( pDocSh )
+	{
+        ScDocument* pDoc = pDocSh->GetDocument();
+        ScBaseCell* pCell = pDoc->GetCell( aCellPos );
+        if ( pCell && pCell->GetCellType() == CELLTYPE_FORMULA )
+        {
+            ScTokenArray* pTokenArray = static_cast<ScFormulaCell*>(pCell)->GetCode();
+            if ( pTokenArray )
+                (void)ScTokenConversion::ConvertToTokenSequence( aSequence, *pTokenArray );
+        }
+	}
+    return aSequence;
+}
+
+void SAL_CALL ScCellObj::setTokens( const uno::Sequence<sheet::FormulaToken>& rTokens ) throw(uno::RuntimeException)
+{
+	ScUnoGuard aGuard;
+    ScDocShell* pDocSh = GetDocShell();
+    if ( pDocSh )
+	{
+	    ScDocument* pDoc = pDocSh->GetDocument();
+	    ScTokenArray aTokenArray;
+	    (void)ScTokenConversion::ConvertToTokenArray( aTokenArray, rTokens );
+
+        ScDocFunc aFunc( *pDocSh );
+        ScBaseCell* pNewCell = new ScFormulaCell( pDoc, aCellPos, &aTokenArray );
+        (void)aFunc.PutCell( aCellPos, pNewCell, TRUE );
+	}
+}
+
 // XCellAddressable
 
 table::CellAddress SAL_CALL ScCellObj::getCellAddress() throw(uno::RuntimeException)
@@ -6723,6 +6831,7 @@ uno::Any SAL_CALL ScTableSheetObj::query
 	SC_QUERYINTERFACE( sheet::XScenario )
 	SC_QUERYINTERFACE( sheet::XScenarioEnhanced )
 	SC_QUERYINTERFACE( sheet::XSheetLinkable )
+    SC_QUERYINTERFACE( sheet::XExternalSheetName )
 
 	return ScCellRangeObj::queryInterface( rType );
 }
@@ -6746,7 +6855,7 @@ uno::Sequence<uno::Type> SAL_CALL ScTabl
 		long nParentLen = aParentTypes.getLength();
 		const uno::Type* pParentPtr = aParentTypes.getConstArray();
 
-		aTypes.realloc( nParentLen + 16 );
+		aTypes.realloc( nParentLen + 17 );
 		uno::Type* pPtr = aTypes.getArray();
 		pPtr[nParentLen + 0] = getCppuType((const uno::Reference<sheet::XSpreadsheet>*)0);
 		pPtr[nParentLen + 1] = getCppuType((const uno::Reference<container::XNamed>*)0);
@@ -6764,6 +6873,7 @@ uno::Sequence<uno::Type> SAL_CALL ScTabl
 		pPtr[nParentLen +13] = getCppuType((const uno::Reference<sheet::XScenario>*)0);
 		pPtr[nParentLen +14] = getCppuType((const uno::Reference<sheet::XScenarioEnhanced>*)0);
 		pPtr[nParentLen +15] = getCppuType((const uno::Reference<sheet::XSheetLinkable>*)0);
+        pPtr[nParentLen +16] = getCppuType((const uno::Reference<sheet::XExternalSheetName>*)0);
 
 		for (long i=0; i<nParentLen; i++)
 			pPtr[i] = pParentPtr[i];				// parent types first
@@ -7561,7 +7671,7 @@ void SAL_CALL ScTableSheetObj::link( con
 
 		//!	Undo fuer Link-Daten an der Table
 
-		if ( nLinkMode != SC_LINK_NONE )		// Link updaten
+		if ( nLinkMode != SC_LINK_NONE && pDoc->IsExecuteLinkEnabled() )		// Link updaten
 		{
 			//	Update immer, auch wenn der Link schon da war
 			//!	Update nur fuer die betroffene Tabelle???
@@ -8021,6 +8131,29 @@ uno::Sequence< table::CellRangeAddress >
     return uno::Sequence< table::CellRangeAddress > ();
 }
 
+// XExternalSheetName
+
+void ScTableSheetObj::setExternalName( const ::rtl::OUString& aUrl, const ::rtl::OUString& aSheetName )
+    throw (container::ElementExistException, uno::RuntimeException)
+{
+    ScUnoGuard aGuard;
+    ScDocShell* pDocSh = GetDocShell();
+    if ( pDocSh )
+    {
+        ScDocument* pDoc = pDocSh->GetDocument();
+        if ( pDoc )
+        {
+            const SCTAB nTab = GetTab_Impl();
+            const String aAbsDocName( ScGlobal::GetAbsDocName( aUrl, pDocSh ) );
+            const String aDocTabName( ScGlobal::GetDocTabName( aAbsDocName, aSheetName ) );
+            if ( !pDoc->RenameTab( nTab, aDocTabName, FALSE /*bUpdateRef*/, TRUE /*bExternalDocument*/ ) )
+            {
+                throw container::ElementExistException( ::rtl::OUString(), *this );
+            }
+        }
+    }
+}
+
 // XPropertySet erweitert fuer Sheet-Properties
 
 uno::Reference<beans::XPropertySetInfo> SAL_CALL ScTableSheetObj::getPropertySetInfo()
--- sc/source/ui/unoobj/datauno.cxx	5 Mar 2007 14:45:54 -0000	1.28
+++ sc/source/ui/unoobj/datauno.cxx	6 Jul 2007 10:10:44 -0000	1.28.48.1
@@ -143,6 +143,7 @@ const SfxItemPropertyMap* lcl_GetDBRange
         {MAP_CHAR_LEN(SC_UNONAME_MOVCELLS), 0,  &getBooleanCppuType(),                      0, 0},
         {MAP_CHAR_LEN(SC_UNONAME_REFPERIOD), 0, &getCppuType((sal_Int32*)0),                0, 0},
         {MAP_CHAR_LEN(SC_UNONAME_STRIPDAT), 0,  &getBooleanCppuType(),                      0, 0},
+        {MAP_CHAR_LEN(SC_UNONAME_TOKENINDEX),0, &getCppuType((sal_Int32*)0),     beans::PropertyAttribute::READONLY, 0 },
         {MAP_CHAR_LEN(SC_UNONAME_USEFLTCRT),0,  &getBooleanCppuType(),                      0, 0},
         {0,0,0,0,0,0}
 	};
@@ -2054,6 +2055,11 @@ uno::Any SAL_CALL ScDatabaseRangeObj::ge
         else if (aString.EqualsAscii( SC_UNONAME_CONRES ))
         {
         }
+        else if (aString.EqualsAscii( SC_UNONAME_TOKENINDEX ))
+        {
+            // get index for use in formula tokens (read-only)
+            aRet <<= static_cast<sal_Int32>(GetDBData_Impl()->GetIndex());
+        }
 	}
 	return aRet;
 }
--- sc/source/ui/unoobj/docuno.cxx	22 May 2007 20:11:28 -0000	1.62
+++ sc/source/ui/unoobj/docuno.cxx	7 Dec 2007 09:26:11 -0000	1.59.16.9
@@ -47,6 +47,7 @@
 
 #include <svtools/numuno.hxx>
 #include <svtools/smplhint.hxx>
+#include <svtools/undoopt.hxx>
 #include <sfx2/printer.hxx>
 #include <sfx2/bindings.hxx>
 #include <vcl/pdfextoutdevdata.hxx>
@@ -141,6 +142,12 @@ const SfxItemPropertyMap* lcl_GetDocOptP
         {MAP_CHAR_LEN(SC_UNO_REGEXENABLED),      0, &getBooleanCppuType(),                                    0, 0},
         {MAP_CHAR_LEN(SC_UNO_RUNTIMEUID),        0, &getCppuType(static_cast< const rtl::OUString * >(0)),    beans::PropertyAttribute::READONLY, 0},
         {MAP_CHAR_LEN(SC_UNO_HASVALIDSIGNATURES),0, &getBooleanCppuType(),                                    beans::PropertyAttribute::READONLY, 0},
+        {MAP_CHAR_LEN(SC_UNO_ISLOADED),          0, &getBooleanCppuType(),                                    0, 0},
+        {MAP_CHAR_LEN(SC_UNO_ISUNDOENABLED),     0, &getBooleanCppuType(),                                    0, 0},
+        {MAP_CHAR_LEN(SC_UNO_ISADJUSTHEIGHTENABLED), 0, &getBooleanCppuType(),                                0, 0},
+        {MAP_CHAR_LEN(SC_UNO_ISEXECUTELINKENABLED), 0, &getBooleanCppuType(),                                 0, 0},
+        {MAP_CHAR_LEN(SC_UNO_ISCHANGEREADONLYENABLED), 0, &getBooleanCppuType(),                              0, 0},
+        {MAP_CHAR_LEN(SC_UNO_REFERENCEDEVICE),   0, &getCppuType((uno::Reference<awt::XDevice>*)0),           beans::PropertyAttribute::READONLY, 0},
         {MAP_CHAR_LEN("BuildId"),                0, &::getCppuType(static_cast< const rtl::OUString * >(0)), 0, 0},
 
         {0,0,0,0,0,0}
@@ -1345,6 +1352,38 @@ void SAL_CALL ScModelObj::setPropertyVal
 			if (pBindings)
 				pBindings->Invalidate( SID_FM_AUTOCONTROLFOCUS );
 		}
+        else if ( aString.EqualsAscii( SC_UNO_ISLOADED ) )
+        {
+            pDocShell->SetEmpty( !ScUnoHelpFunctions::GetBoolFromAny( aValue ) );
+        }
+        else if ( aString.EqualsAscii( SC_UNO_ISUNDOENABLED ) )
+        {
+            BOOL bUndoEnabled = ScUnoHelpFunctions::GetBoolFromAny( aValue );
+            pDoc->EnableUndo( bUndoEnabled );
+            USHORT nCount = ( bUndoEnabled ?
+                static_cast< USHORT >( SvtUndoOptions().GetUndoCount() ) : 0 );
+            pDocShell->GetUndoManager()->SetMaxUndoActionCount( nCount );
+        }
+        else if ( aString.EqualsAscii( SC_UNO_ISADJUSTHEIGHTENABLED ) )
+        {
+            bool bAdjustHeightEnabled = ScUnoHelpFunctions::GetBoolFromAny( aValue );
+            pDoc->EnableAdjustHeight( bAdjustHeightEnabled );
+            if ( bAdjustHeightEnabled )
+            {
+                for ( SCTAB nTab = 0; nTab < pDoc->GetTableCount(); ++nTab )
+                {
+                    pDocShell->AdjustRowHeight( 0, MAXROW, nTab );
+                }
+            }
+        }
+        else if ( aString.EqualsAscii( SC_UNO_ISEXECUTELINKENABLED ) )
+        {
+            pDoc->EnableExecuteLink( ScUnoHelpFunctions::GetBoolFromAny( aValue ) );
+        }
+        else if ( aString.EqualsAscii( SC_UNO_ISCHANGEREADONLYENABLED ) )
+        {
+            pDoc->EnableChangeReadOnly( ScUnoHelpFunctions::GetBoolFromAny( aValue ) );
+        }
 		else if ( aString.EqualsAscii( "BuildId" ) )
 		{
 			aValue >>= maBuildId;
@@ -1480,6 +1519,32 @@ uno::Any SAL_CALL ScModelObj::getPropert
         {
             aRet <<= hasValidSignatures();
         }
+        else if ( aString.EqualsAscii( SC_UNO_ISLOADED ) )
+        {
+            ScUnoHelpFunctions::SetBoolInAny( aRet, !pDocShell->IsEmpty() );
+        }
+        else if ( aString.EqualsAscii( SC_UNO_ISUNDOENABLED ) )
+        {
+            ScUnoHelpFunctions::SetBoolInAny( aRet, pDoc->IsUndoEnabled() );
+        }
+        else if ( aString.EqualsAscii( SC_UNO_ISADJUSTHEIGHTENABLED ) )
+        {
+            ScUnoHelpFunctions::SetBoolInAny( aRet, pDoc->IsAdjustHeightEnabled() );
+        }
+        else if ( aString.EqualsAscii( SC_UNO_ISEXECUTELINKENABLED ) )
+        {
+            ScUnoHelpFunctions::SetBoolInAny( aRet, pDoc->IsExecuteLinkEnabled() );
+        }
+        else if ( aString.EqualsAscii( SC_UNO_ISCHANGEREADONLYENABLED ) )
+        {
+            ScUnoHelpFunctions::SetBoolInAny( aRet, pDoc->IsChangeReadOnlyEnabled() );
+        }
+        else if ( aString.EqualsAscii( SC_UNO_REFERENCEDEVICE ) )
+        {
+            VCLXDevice* pXDev = new VCLXDevice();
+            pXDev->SetOutputDevice( pDoc->GetRefDevice() );
+            aRet <<= uno::Reference< awt::XDevice >( pXDev );
+        }
         else if ( aString.EqualsAscii( "BuildId" ) )
 		{
 			aRet <<= maBuildId;
--- sc/source/ui/unoobj/fmtuno.cxx	27 Feb 2007 13:45:20 -0000	1.14
+++ sc/source/ui/unoobj/fmtuno.cxx	9 Aug 2007 11:35:20 -0000	1.14.18.7
@@ -53,6 +53,8 @@
 #include "unoguard.hxx"
 #include "unonames.hxx"
 #include "styleuno.hxx"		// ScStyleNameConversion
+#include "tokenarray.hxx"
+#include "tokenuno.hxx"
 
 using namespace com::sun::star;
 
@@ -153,14 +155,15 @@ ScTableConditionalFormat::ScTableConditi
 				USHORT nEntryCount = pFormat->Count();
 				for (USHORT i=0; i<nEntryCount; i++)
 				{
+                    ScCondFormatEntryItem aItem;
 					const ScCondFormatEntry* pFormatEntry = pFormat->GetEntry(i);
-					ScConditionMode eMode = pFormatEntry->GetOperation();
-                    ScAddress aPos(pFormatEntry->GetValidSrcPos());    // #b4974740# valid pos for expressions
-					String aExpr1(pFormatEntry->GetExpression( aPos, 0, 0, bEnglish, bCompileXML ));
-					String aExpr2(pFormatEntry->GetExpression( aPos, 1, 0, bEnglish, bCompileXML ));
-					String aStyle(pFormatEntry->GetStyle());
+                    aItem.mnMode = sal::static_int_cast<USHORT>(pFormatEntry->GetOperation());
+                    aItem.maPos = pFormatEntry->GetValidSrcPos();
+                    aItem.maExpr1 = pFormatEntry->GetExpression(aItem.maPos, 0, 0, bEnglish, bCompileXML);
+                    aItem.maExpr2 = pFormatEntry->GetExpression(aItem.maPos, 1, 0, bEnglish, bCompileXML);
+                    aItem.maStyle = pFormatEntry->GetStyle();
 
-                    AddEntry_Impl( sal::static_int_cast<USHORT>(eMode), aExpr1, aExpr2, aPos, EMPTY_STRING, aStyle );
+                    AddEntry_Impl(aItem);
 				}
 			}
 		}
@@ -177,18 +180,31 @@ void ScTableConditionalFormat::FillForma
 	for (USHORT i=0; i<nCount; i++)
 	{
 		ScTableConditionalEntry* pEntry = (ScTableConditionalEntry*)aEntries.GetObject(i);
-		if (pEntry)
+        if ( !pEntry )
+            continue;
+
+        ScCondFormatEntryItem aData;
+        pEntry->GetData(aData);
+        ScCondFormatEntry aCoreEntry( static_cast<ScConditionMode>(aData.mnMode),
+            aData.maExpr1, aData.maExpr2, pDoc, aData.maPos, aData.maStyle, bEnglish, bCompileXML );
+
+        if ( aData.maPosStr.Len() )
+            aCoreEntry.SetSrcString( aData.maPosStr );
+
+        if ( aData.maTokens1.getLength() )
 		{
-			USHORT nMode;
-			String aExpr1, aExpr2, aStyle, aPosStr;
-			ScAddress aPos;
-			pEntry->GetData( nMode, aExpr1, aExpr2, aPos, aPosStr, aStyle );
-			ScCondFormatEntry aCoreEntry( (ScConditionMode)nMode,
-								aExpr1, aExpr2, pDoc, aPos, aStyle, bEnglish, bCompileXML );
-            if ( aPosStr.Len() )
-                aCoreEntry.SetSrcString( aPosStr );
-			rFormat.AddEntry( aCoreEntry );
+            ScTokenArray aTokenArray;
+            if ( ScTokenConversion::ConvertToTokenArray(aTokenArray, aData.maTokens1) )
+                aCoreEntry.SetFormula1(aTokenArray);
 		}
+
+        if ( aData.maTokens2.getLength() )
+        {
+            ScTokenArray aTokenArray;
+            if ( ScTokenConversion::ConvertToTokenArray(aTokenArray, aData.maTokens2) )
+                aCoreEntry.SetFormula2(aTokenArray);
+        }
+        rFormat.AddEntry( aCoreEntry );
 	}
 }
 
@@ -200,12 +216,9 @@ ScTableConditionalFormat::~ScTableCondit
 		pEntry->release();
 }
 
-void ScTableConditionalFormat::AddEntry_Impl( USHORT nMode,
-						const String& rExpr1, const String& rExpr2,
-						const ScAddress& rPos, const String& rPosStr, const String& rStyle )
+void ScTableConditionalFormat::AddEntry_Impl(const ScCondFormatEntryItem& aEntry)
 {
-	ScTableConditionalEntry* pNew = new ScTableConditionalEntry(
-										this, nMode, rExpr1, rExpr2, rPos, rPosStr, rStyle );
+    ScTableConditionalEntry* pNew = new ScTableConditionalEntry(this, aEntry);
 	pNew->acquire();
 	aEntries.Insert( pNew, LIST_APPEND );
 }
@@ -227,12 +240,8 @@ void SAL_CALL ScTableConditionalFormat::
 					throw(uno::RuntimeException)
 {
 	ScUnoGuard aGuard;
-	ScConditionMode eMode = SC_COND_NONE;
-	String aExpr1;
-	String aExpr2;
-	ScAddress aPos;
-    String aPosStr;
-	String aStyle;
+    ScCondFormatEntryItem aEntry;
+    aEntry.mnMode = sal::static_int_cast<USHORT>(SC_COND_NONE);
 
 	const beans::PropertyValue* pPropArray = aConditionalEntry.getConstArray();
 	long nPropCount = aConditionalEntry.getLength();
@@ -245,37 +254,49 @@ void SAL_CALL ScTableConditionalFormat::
 		{
 			sheet::ConditionOperator eOper = (sheet::ConditionOperator)
 							ScUnoHelpFunctions::GetEnumFromAny( rProp.Value );
-			eMode = lcl_ConditionOperatorToMode( eOper );
+			aEntry.mnMode = sal::static_int_cast<USHORT>(lcl_ConditionOperatorToMode( eOper ));
 		}
 		else if ( aPropName.EqualsAscii( SC_UNONAME_FORMULA1 ) )
 		{
 			rtl::OUString aStrVal;
+            uno::Sequence<sheet::FormulaToken> aTokens;
 			if ( rProp.Value >>= aStrVal )
-				aExpr1 = String( aStrVal );
+                aEntry.maExpr1 = String( aStrVal );
+            else if ( rProp.Value >>= aTokens )
+            {
+                aEntry.maExpr1.Erase();
+                aEntry.maTokens1 = aTokens;
+            }
 		}
 		else if ( aPropName.EqualsAscii( SC_UNONAME_FORMULA2 ) )
 		{
 			rtl::OUString aStrVal;
+            uno::Sequence<sheet::FormulaToken> aTokens;
 			if ( rProp.Value >>= aStrVal )
-				aExpr2 = String( aStrVal );
+                aEntry.maExpr2 = String( aStrVal );
+            else if ( rProp.Value >>= aTokens )
+            {
+                aEntry.maExpr2.Erase();
+                aEntry.maTokens2 = aTokens;
+            }
 		}
 		else if ( aPropName.EqualsAscii( SC_UNONAME_SOURCEPOS ) )
 		{
 			table::CellAddress aAddress;
 			if ( rProp.Value >>= aAddress )
-				aPos = ScAddress( (SCCOL)aAddress.Column, (SCROW)aAddress.Row, aAddress.Sheet );
+				aEntry.maPos = ScAddress( (SCCOL)aAddress.Column, (SCROW)aAddress.Row, aAddress.Sheet );
 		}
         else if ( aPropName.EqualsAscii( SC_UNONAME_SOURCESTR ) )
         {
             rtl::OUString aStrVal;
             if ( rProp.Value >>= aStrVal )
-                aPosStr = String( aStrVal );
+                aEntry.maPosStr = String( aStrVal );
         }
 		else if ( aPropName.EqualsAscii( SC_UNONAME_STYLENAME ) )
 		{
 			rtl::OUString aStrVal;
 			if ( rProp.Value >>= aStrVal )
-				aStyle = ScStyleNameConversion::ProgrammaticToDisplayName(
+				aEntry.maStyle = ScStyleNameConversion::ProgrammaticToDisplayName(
 												aStrVal, SFX_STYLE_FAMILY_PARA );
 		}
 		else
@@ -285,7 +306,7 @@ void SAL_CALL ScTableConditionalFormat::
 		}
 	}
 
-    AddEntry_Impl( sal::static_int_cast<USHORT>(eMode), aExpr1, aExpr2, aPos, aPosStr, aStyle );
+    AddEntry_Impl(aEntry);
 	DataChanged();
 }
 
@@ -464,15 +485,9 @@ ScTableConditionalEntry::ScTableConditio
 }
 
 ScTableConditionalEntry::ScTableConditionalEntry( ScTableConditionalFormat* pPar,
-							 USHORT nM, const String& rEx1, const String& rEx2,
-							 const ScAddress& rPos, const String& rPosStr, const String& rSt ) :
+                                                 const ScCondFormatEntryItem& aItem) :
 	pParent( pPar ),
-	nMode( nM ),
-	aExpr1( rEx1 ),
-	aExpr2( rEx2 ),
-	aSrcPos( rPos ),
-    aPosString( rPosStr ),
-	aStyle( rSt )
+    aData( aItem )
 {
 	if (pParent)
 		pParent->acquire();
@@ -484,15 +499,9 @@ ScTableConditionalEntry::~ScTableConditi
 		pParent->release();
 }
 
-void ScTableConditionalEntry::GetData( USHORT& rM, String& rEx1, String& rEx2,
-										ScAddress& rPos, String& rPosStr, String& rSt ) const
+void ScTableConditionalEntry::GetData(ScCondFormatEntryItem& rData) const
 {
-	rM	 = nMode;
-	rEx1 = aExpr1;
-	rEx2 = aExpr2;
-	rPos = aSrcPos;
-    rPosStr = aPosString;
-	rSt  = aStyle;
+    rData = aData;
 }
 
 // XSheetCondition
@@ -501,14 +510,14 @@ sheet::ConditionOperator SAL_CALL ScTabl
 												throw(uno::RuntimeException)
 {
 	ScUnoGuard aGuard;
-	return lcl_ConditionModeToOperator( (ScConditionMode)nMode );
+	return lcl_ConditionModeToOperator( static_cast<ScConditionMode>(aData.mnMode) );
 }
 
 void SAL_CALL ScTableConditionalEntry::setOperator( sheet::ConditionOperator nOperator )
 												throw(uno::RuntimeException)
 {
 	ScUnoGuard aGuard;
-    nMode = sal::static_int_cast<USHORT>( lcl_ConditionOperatorToMode( nOperator ) );
+    aData.mnMode = sal::static_int_cast<USHORT>( lcl_ConditionOperatorToMode( nOperator ) );
 	if (pParent)
 		pParent->DataChanged();
 }
@@ -516,14 +525,14 @@ void SAL_CALL ScTableConditionalEntry::s
 rtl::OUString SAL_CALL ScTableConditionalEntry::getFormula1() throw(uno::RuntimeException)
 {
 	ScUnoGuard aGuard;
-	return aExpr1;
+	return aData.maExpr1;
 }
 
 void SAL_CALL ScTableConditionalEntry::setFormula1( const rtl::OUString& aFormula1 )
 												throw(uno::RuntimeException)
 {
 	ScUnoGuard aGuard;
-	aExpr1 = String( aFormula1 );
+	aData.maExpr1 = String( aFormula1 );
 	if (pParent)
 		pParent->DataChanged();
 }
@@ -531,14 +540,14 @@ void SAL_CALL ScTableConditionalEntry::s
 rtl::OUString SAL_CALL ScTableConditionalEntry::getFormula2() throw(uno::RuntimeException)
 {
 	ScUnoGuard aGuard;
-	return aExpr2;
+	return aData.maExpr2;
 }
 
 void SAL_CALL ScTableConditionalEntry::setFormula2( const rtl::OUString& aFormula2 )
 												throw(uno::RuntimeException)
 {
 	ScUnoGuard aGuard;
-	aExpr2 = String( aFormula2 );
+	aData.maExpr2 = String( aFormula2 );
 	if (pParent)
 		pParent->DataChanged();
 }
@@ -547,9 +556,9 @@ table::CellAddress SAL_CALL ScTableCondi
 {
 	ScUnoGuard aGuard;
 	table::CellAddress aRet;
-	aRet.Column = aSrcPos.Col();
-	aRet.Row    = aSrcPos.Row();
-	aRet.Sheet  = aSrcPos.Tab();
+	aRet.Column = aData.maPos.Col();
+	aRet.Row    = aData.maPos.Row();
+	aRet.Sheet  = aData.maPos.Tab();
 	return aRet;
 }
 
@@ -557,7 +566,7 @@ void SAL_CALL ScTableConditionalEntry::s
 											throw(uno::RuntimeException)
 {
 	ScUnoGuard aGuard;
-	aSrcPos.Set( (SCCOL)aSourcePosition.Column, (SCROW)aSourcePosition.Row, aSourcePosition.Sheet );
+	aData.maPos.Set( (SCCOL)aSourcePosition.Column, (SCROW)aSourcePosition.Row, aSourcePosition.Sheet );
 	if (pParent)
 		pParent->DataChanged();
 }
@@ -567,14 +576,14 @@ void SAL_CALL ScTableConditionalEntry::s
 rtl::OUString SAL_CALL ScTableConditionalEntry::getStyleName() throw(uno::RuntimeException)
 {
 	ScUnoGuard aGuard;
-	return ScStyleNameConversion::DisplayToProgrammaticName( aStyle, SFX_STYLE_FAMILY_PARA );
+	return ScStyleNameConversion::DisplayToProgrammaticName( aData.maStyle, SFX_STYLE_FAMILY_PARA );
 }
 
 void SAL_CALL ScTableConditionalEntry::setStyleName( const rtl::OUString& aStyleName )
 											throw(uno::RuntimeException)
 {
 	ScUnoGuard aGuard;
-	aStyle = ScStyleNameConversion::ProgrammaticToDisplayName( aStyleName, SFX_STYLE_FAMILY_PARA );
+	aData.maStyle = ScStyleNameConversion::ProgrammaticToDisplayName( aStyleName, SFX_STYLE_FAMILY_PARA );
 	if (pParent)
 		pParent->DataChanged();
 }
@@ -629,6 +638,20 @@ ScValidationData* ScTableValidationObj::
 	pRet->SetIgnoreBlank(bIgnoreBlank);
     pRet->SetListType(nShowList);
 
+    if ( aTokens1.getLength() )
+    {
+        ScTokenArray aTokenArray;
+        if ( ScTokenConversion::ConvertToTokenArray(aTokenArray, aTokens1) )
+            pRet->SetFormula1(aTokenArray);
+    }
+
+    if ( aTokens2.getLength() )
+    {
+        ScTokenArray aTokenArray;
+        if ( ScTokenConversion::ConvertToTokenArray(aTokenArray, aTokens2) )
+            pRet->SetFormula2(aTokenArray);
+    }
+
 	// set strings for error / input even if disabled (and disable afterwards)
 	pRet->SetInput( aInputTitle, aInputMessage );
 	if (!bShowInput)
@@ -733,6 +756,40 @@ void SAL_CALL ScTableValidationObj::setS
 	DataChanged();
 }
 
+uno::Sequence<sheet::FormulaToken> SAL_CALL ScTableValidationObj::getTokens( sal_Int32 nIndex )
+                                            throw(uno::RuntimeException,lang::IndexOutOfBoundsException)
+{
+	ScUnoGuard aGuard;
+    if (nIndex >= 2 || nIndex < 0)
+        throw lang::IndexOutOfBoundsException();
+
+    return nIndex == 0 ? aTokens1 : aTokens2;
+}
+
+void SAL_CALL ScTableValidationObj::setTokens( sal_Int32 nIndex, const uno::Sequence<sheet::FormulaToken>& aTokens )
+                                            throw(uno::RuntimeException,lang::IndexOutOfBoundsException)
+{
+	ScUnoGuard aGuard;
+    if (nIndex >= 2 || nIndex < 0)
+        throw lang::IndexOutOfBoundsException();
+
+    if (nIndex == 0)
+    {
+        aTokens1 = aTokens;
+        aExpr1.Erase();
+    }
+    else if (nIndex == 1)
+    {
+        aTokens2 = aTokens;
+        aExpr2.Erase();
+    }
+}
+
+sal_Int32 SAL_CALL ScTableValidationObj::getCount() throw(uno::RuntimeException)
+{
+    return 2;
+}
+
 uno::Reference<beans::XPropertySetInfo> SAL_CALL ScTableValidationObj::getPropertySetInfo()
 														throw(uno::RuntimeException)
 {
--- sc/source/ui/unoobj/funcuno.cxx	6 Jul 2007 12:45:57 -0000	1.18
+++ sc/source/ui/unoobj/funcuno.cxx	14 Aug 2007 18:32:03 -0000	1.18.10.1
@@ -331,14 +331,10 @@ BOOL lcl_AddFunctionToken( ScTokenArray&
 	// same options as in ScCompiler::IsOpCode:
 	// 1. built-in function name
 
-	DBG_ASSERT( ScCompiler::pSymbolHashMapEnglish, "no symbol hash map" );
-	if (!ScCompiler::pSymbolHashMapEnglish)
-		return FALSE;
-
-    ScOpCodeHashMap::const_iterator iLook( ScCompiler::pSymbolHashMapEnglish->find( aUpper ) );
-    if ( iLook != ScCompiler::pSymbolHashMapEnglish->end() )
+    OpCode eOp = ScCompiler::GetEnglishOpCode( aUpper );
+    if ( eOp != ocNone )
     {
-        rArray.AddOpCode( iLook->second );
+        rArray.AddOpCode( eOp );
         return TRUE;
     }
 
@@ -521,11 +517,8 @@ uno::Any SAL_CALL ScFunctionAccess::call
 	if ( !pDoc->HasTable( nTempSheet ) )
 		pDoc->MakeTable( nTempSheet );
 
-	if (!ScCompiler::pSymbolTableEnglish)
-	{
-		ScCompiler aComp( pDoc, ScAddress() );
-		aComp.SetCompileEnglish( TRUE );		// setup english symbol table
-	}
+	if (!ScCompiler::IsInitialized())
+        ScCompiler::InitSymbolsEnglish();
 
 	//
 	//	find function
--- sc/source/ui/unoobj/linkuno.cxx	5 Mar 2007 14:46:55 -0000	1.16
+++ sc/source/ui/unoobj/linkuno.cxx	29 Nov 2007 12:07:55 -0000	1.16.48.2
@@ -52,6 +52,7 @@
 #include "unoguard.hxx"
 #include "hints.hxx"
 #include "unonames.hxx"
+#include "rangeseq.hxx"
 
 using namespace com::sun::star;
 
@@ -1189,6 +1190,77 @@ void SAL_CALL ScDDELinkObj::removeRefres
 	}
 }
 
+// XDDELinkResults
+
+uno::Sequence< uno::Sequence< uno::Any > > ScDDELinkObj::getResults(  )
+    throw (uno::RuntimeException)
+{
+    ScUnoGuard aGuard;
+    uno::Sequence< uno::Sequence< uno::Any > > aReturn;
+    bool bSuccess = false;
+
+    if ( pDocShell )
+    {
+        ScDocument* pDoc = pDocShell->GetDocument();
+        if ( pDoc )
+        {
+            USHORT nPos = 0;
+            if ( pDoc->FindDdeLink( aAppl, aTopic, aItem, SC_DDE_IGNOREMODE, nPos ) )
+            {
+                const ScMatrix* pMatrix = pDoc->GetDdeLinkResultMatrix( nPos );
+                if ( pMatrix )
+                {
+                    uno::Any aAny;
+                    if ( ScRangeToSequence::FillMixedArray( aAny, pMatrix, true ) )
+                    {
+                        aAny >>= aReturn;
+                    }
+                }
+                bSuccess = true;
+            }
+        }
+    }
+
+    if ( !bSuccess )
+    {
+        throw uno::RuntimeException( ::rtl::OUString( RTL_CONSTASCII_USTRINGPARAM(
+            "ScDDELinkObj::getResults: failed to get results!" ) ),
+            uno::Reference< uno::XInterface >() );
+    }
+
+    return aReturn;
+}
+
+void ScDDELinkObj::setResults( const uno::Sequence< uno::Sequence< uno::Any > >& aResults )
+    throw (uno::RuntimeException)
+{
+    ScUnoGuard aGuard;
+    bool bSuccess = false;
+
+    if ( pDocShell )
+    {
+        ScDocument* pDoc = pDocShell->GetDocument();
+        if ( pDoc )
+        {
+            USHORT nPos = 0;
+            if ( pDoc->FindDdeLink( aAppl, aTopic, aItem, SC_DDE_IGNOREMODE, nPos ) )
+            {
+                uno::Any aAny;
+                aAny <<= aResults;
+                ScMatrixRef xMatrix = ScSequenceToMatrix::CreateMixedMatrix( aAny );
+                bSuccess = pDoc->SetDdeLinkResultMatrix( nPos, xMatrix );
+            }
+        }
+    }
+
+    if ( !bSuccess )
+    {
+        throw uno::RuntimeException( ::rtl::OUString( RTL_CONSTASCII_USTRINGPARAM(
+            "ScDDELinkObj::setResults: failed to set results!" ) ),
+            uno::Reference< uno::XInterface >() );
+    }
+}
+
 void ScDDELinkObj::Refreshed_Impl()
 {
 	lang::EventObject aEvent;
@@ -1356,8 +1428,61 @@ sal_Bool SAL_CALL ScDDELinksObj::hasByNa
 	return FALSE;
 }
 
-//------------------------------------------------------------------------
+// XDDELinks
 
+uno::Reference< sheet::XDDELink > ScDDELinksObj::addDDELink(
+    const ::rtl::OUString& aApplication, const ::rtl::OUString& aTopic,
+    const ::rtl::OUString& aItem, ::com::sun::star::sheet::DDELinkMode nMode )
+    throw (uno::RuntimeException)
+{
+    ScUnoGuard aGuard;
+    uno::Reference< sheet::XDDELink > xLink;
 
+    if ( pDocShell )
+    {
+        ScDocument* pDoc = pDocShell->GetDocument();
+        if ( pDoc )
+        {
+            BYTE nMod = SC_DDE_DEFAULT;
+            switch ( nMode )
+            {
+                case sheet::DDELinkMode_DEFAULT:
+                    {
+                        nMod = SC_DDE_DEFAULT;
+                    }
+                    break;
+                case sheet::DDELinkMode_ENGLISH:
+                    {
+                        nMod = SC_DDE_ENGLISH;
+                    }
+                    break;
+                case sheet::DDELinkMode_TEXT:
+                    {
+                        nMod = SC_DDE_TEXT;
+                    }
+                    break;
+                default:
+                    {
+                    }
+                    break;
+            }
+
+            if ( pDoc->CreateDdeLink( aApplication, aTopic, aItem, nMod ) )
+            {
+                const ::rtl::OUString aName( lcl_BuildDDEName( aApplication, aTopic, aItem ) );
+                xLink.set( GetObjectByName_Impl( aName ) );
+            }
+        }
+    }
 
+    if ( !xLink.is() )
+    {
+        throw uno::RuntimeException( ::rtl::OUString( RTL_CONSTASCII_USTRINGPARAM(
+            "ScDDELinksObj::addDDELink: cannot add DDE link!" ) ),
+            uno::Reference< uno::XInterface >() );
+    }
+
+    return xLink;
+}
 
+//------------------------------------------------------------------------
--- sc/source/ui/unoobj/makefile.mk	22 May 2007 20:11:40 -0000	1.18
+++ sc/source/ui/unoobj/makefile.mk	29 May 2007 15:02:02 -0000	1.17.402.2
@@ -61,6 +61,7 @@ SLO1FILES =  \
         $(SLO)$/defltuno.obj \
         $(SLO)$/drdefuno.obj \
         $(SLO)$/cellsuno.obj \
+        $(SLO)$/tokenuno.obj \
         $(SLO)$/textuno.obj \
         $(SLO)$/notesuno.obj \
         $(SLO)$/cursuno.obj \
--- sc/source/ui/unoobj/nameuno.cxx	27 Feb 2007 13:46:17 -0000	1.16
+++ sc/source/ui/unoobj/nameuno.cxx	24 Jul 2007 09:07:20 -0000	1.16.18.4
@@ -52,6 +52,8 @@ using namespace ::com::sun::star;
 #include "cellsuno.hxx"
 #include "convuno.hxx"
 #include "targuno.hxx"
+#include "tokenuno.hxx"
+#include "tokenarray.hxx"
 #include "docsh.hxx"
 #include "docfunc.hxx"
 #include "rangenam.hxx"
@@ -69,6 +71,7 @@ const SfxItemPropertyMap* lcl_GetNamedRa
 	{
 		{MAP_CHAR_LEN(SC_UNO_LINKDISPBIT),	0,	&getCppuType((uno::Reference<awt::XBitmap>*)0),	beans::PropertyAttribute::READONLY, 0 },
 		{MAP_CHAR_LEN(SC_UNO_LINKDISPNAME),	0,	&getCppuType((rtl::OUString*)0),				beans::PropertyAttribute::READONLY, 0 },
+        {MAP_CHAR_LEN(SC_UNONAME_TOKENINDEX),0, &getCppuType((sal_Int32*)0),                    beans::PropertyAttribute::READONLY, 0 },
         {0,0,0,0,0,0}
 	};
 	return aNamedRangeMap_Impl;
@@ -137,7 +140,7 @@ ScRangeData* ScNamedRangeObj::GetRangeDa
 
 // sheet::XNamedRange
 
-void ScNamedRangeObj::Modify_Impl( const String* pNewName, const String* pNewContent,
+void ScNamedRangeObj::Modify_Impl( const String* pNewName, const ScTokenArray* pNewTokens, const String* pNewContent,
 									const ScAddress* pNewPos, const sal_uInt16* pNewType )
 {
 	if (pDocShell)
@@ -166,8 +169,11 @@ void ScNamedRangeObj::Modify_Impl( const
 				if (pNewType)
 					nType = *pNewType;
 
-				ScRangeData* pNew = new ScRangeData( pDoc, aInsName, aContent,
-													aPos, nType, sal_True );
+                ScRangeData* pNew = NULL;
+                if ( pNewTokens )
+                    pNew = new ScRangeData( pDoc, aInsName, *pNewTokens, aPos, nType );
+                else
+                    pNew = new ScRangeData( pDoc, aInsName, aContent, aPos, nType, sal_True );
 				pNew->SetIndex( pOld->GetIndex() );
 
                 pNewRanges->AtFree( nPos );
@@ -202,7 +208,7 @@ void SAL_CALL ScNamedRangeObj::setName( 
 	//!	Formeln anpassen ?????
 
 	String aNewStr(aNewName);
-	Modify_Impl( &aNewStr, NULL, NULL, NULL );
+	Modify_Impl( &aNewStr, NULL, NULL, NULL, NULL );
 
 	if ( aName != aNewStr )					// some error occured...
 		throw uno::RuntimeException();		// no other exceptions specified
@@ -223,7 +229,7 @@ void SAL_CALL ScNamedRangeObj::setConten
 {
 	ScUnoGuard aGuard;
 	String aContStr(aContent);
-	Modify_Impl( NULL, &aContStr, NULL, NULL );
+	Modify_Impl( NULL, NULL, &aContStr, NULL, NULL );
 }
 
 table::CellAddress SAL_CALL ScNamedRangeObj::getReferencePosition()
@@ -257,7 +263,7 @@ void SAL_CALL ScNamedRangeObj::setRefere
 {
 	ScUnoGuard aGuard;
 	ScAddress aPos( (SCCOL)aReferencePosition.Column, (SCROW)aReferencePosition.Row, aReferencePosition.Sheet );
-	Modify_Impl( NULL, NULL, &aPos, NULL );
+	Modify_Impl( NULL, NULL, NULL, &aPos, NULL );
 }
 
 sal_Int32 SAL_CALL ScNamedRangeObj::getType() throw(uno::RuntimeException)
@@ -286,9 +292,34 @@ void SAL_CALL ScNamedRangeObj::setType( 
 	if ( nUnoType & sheet::NamedRangeFlag::COLUMN_HEADER )		nNewType |= RT_COLHEADER;
 	if ( nUnoType & sheet::NamedRangeFlag::ROW_HEADER )			nNewType |= RT_ROWHEADER;
 
-	Modify_Impl( NULL, NULL, NULL, &nNewType );
+	Modify_Impl( NULL, NULL, NULL, NULL, &nNewType );
+}
+
+// XFormulaTokens
+
+uno::Sequence<sheet::FormulaToken> SAL_CALL ScNamedRangeObj::getTokens() throw(uno::RuntimeException)
+{
+    ScUnoGuard aGuard;
+    uno::Sequence<sheet::FormulaToken> aSequence;
+    ScRangeData* pData = GetRangeData_Impl();
+    if (pData)
+    {
+        ScTokenArray* pTokenArray = pData->GetCode();
+        if ( pTokenArray )
+            (void)ScTokenConversion::ConvertToTokenSequence( aSequence, *pTokenArray );
+    }
+    return aSequence;
+}
+
+void SAL_CALL ScNamedRangeObj::setTokens( const uno::Sequence<sheet::FormulaToken>& rTokens ) throw(uno::RuntimeException)
+{
+    ScUnoGuard aGuard;
+    ScTokenArray aTokenArray;
+    (void)ScTokenConversion::ConvertToTokenArray( aTokenArray, rTokens );
+    Modify_Impl( NULL, &aTokenArray, NULL, NULL, NULL );
 }
 
+
 // XCellRangeSource
 
 uno::Reference<table::XCellRange> SAL_CALL ScNamedRangeObj::getReferredCells()
@@ -342,6 +373,13 @@ uno::Any SAL_CALL ScNamedRangeObj::getPr
 	}
 	else if ( aString.EqualsAscii( SC_UNO_LINKDISPNAME ) )
 		aRet <<= rtl::OUString( aName );
+    else if ( aString.EqualsAscii( SC_UNONAME_TOKENINDEX ) )
+    {
+        // get index for use in formula tokens (read-only)
+        ScRangeData* pData = GetRangeData_Impl();
+        if (pData)
+            aRet <<= static_cast<sal_Int32>(pData->GetIndex());
+    }
 	return aRet;
 }
 
@@ -654,6 +692,87 @@ sal_Bool SAL_CALL ScNamedRangesObj::hasB
 	return sal_False;
 }
 
+/** called from the XActionLockable interface methods on initial locking */
+void ScNamedRangesObj::lock()
+{
+    pDocShell->GetDocument()->CompileNameFormula( TRUE ); // CreateFormulaString
+}
+
+/** called from the XActionLockable interface methods on final unlock */
+void ScNamedRangesObj::unlock()
+{
+    pDocShell->GetDocument()->CompileNameFormula( FALSE ); // CompileFormulaString
+}
+
+// document::XActionLockable
+
+sal_Bool ScNamedRangesObj::isActionLocked() throw(uno::RuntimeException)
+{
+    ScUnoGuard aGuard;
+    return pDocShell->GetDocument()->GetNamedRangesLockCount() != 0;
+}
+
+void ScNamedRangesObj::addActionLock() throw(uno::RuntimeException)
+{
+    ScUnoGuard aGuard;
+    ScDocument* pDoc = pDocShell->GetDocument();
+    sal_Int16 nLockCount = pDoc->GetNamedRangesLockCount();
+    ++nLockCount;
+    if ( nLockCount == 1 )
+    {
+        lock();
+    }
+    pDoc->SetNamedRangesLockCount( nLockCount );
+}
+
+void ScNamedRangesObj::removeActionLock() throw(uno::RuntimeException)
+{
+    ScUnoGuard aGuard;
+    ScDocument* pDoc = pDocShell->GetDocument();
+    sal_Int16 nLockCount = pDoc->GetNamedRangesLockCount();
+    if ( nLockCount > 0 )
+    {
+        --nLockCount;
+        if ( nLockCount == 0 )
+        {
+            unlock();
+        }
+        pDoc->SetNamedRangesLockCount( nLockCount );
+    }
+}
+
+void ScNamedRangesObj::setActionLocks( sal_Int16 nLock ) throw(uno::RuntimeException)
+{
+    ScUnoGuard aGuard;
+    if ( nLock >= 0 )
+    {
+        ScDocument* pDoc = pDocShell->GetDocument();
+        sal_Int16 nLockCount = pDoc->GetNamedRangesLockCount();
+        if ( nLock == 0 && nLockCount > 0 )
+        {
+            unlock();
+        }
+        if ( nLock > 0 && nLockCount == 0 )
+        {
+            lock();
+        }
+        pDoc->SetNamedRangesLockCount( nLock );
+    }
+}
+
+sal_Int16 ScNamedRangesObj::resetActionLocks() throw(uno::RuntimeException)
+{
+    ScUnoGuard aGuard;
+    ScDocument* pDoc = pDocShell->GetDocument();
+    sal_Int16 nLockCount = pDoc->GetNamedRangesLockCount();
+    if ( nLockCount > 0 )
+    {
+        unlock();
+    }
+    pDoc->SetNamedRangesLockCount( 0 );
+    return nLockCount;
+}
+
 //------------------------------------------------------------------------
 
 ScLabelRangeObj::ScLabelRangeObj(ScDocShell* pDocSh, sal_Bool bCol, const ScRange& rR) :
--- sc/source/ui/unoobj/servuno.cxx	22 May 2007 20:11:51 -0000	1.15
+++ sc/source/ui/unoobj/servuno.cxx	14 Aug 2007 18:32:03 -0000	1.14.192.3
@@ -66,6 +66,7 @@
 #include "celllistsource.hxx"
 #include "addruno.hxx"
 #include "chart2uno.hxx"
+#include "tokenuno.hxx"
 
 // #100263# Support creation of GraphicObjectResolver and EmbeddedObjectResolver
 #ifndef _XMLEOHLP_HXX
@@ -125,7 +126,9 @@ static const sal_Char* __FAR_DATA aProvN
 
         "com.sun.star.sheet.DocumentSettings",      // SC_SERVICE_SHEETDOCSET
 
-        SC_SERVICENAME_CHDATAPROV                  // SC_SERVICE_CHDATAPROV
+        SC_SERVICENAME_CHDATAPROV,                  // SC_SERVICE_CHDATAPROV
+        SC_SERVICENAME_FORMULAPARS,                 // SC_SERVICE_FORMULAPARS
+        SC_SERVICENAME_OPCODEMAPPER                 // SC_SERVICE_OPCODEMAPPER
 	};
 
 //
@@ -175,7 +178,9 @@ static const sal_Char* __FAR_DATA aOldNa
 		"",											// SC_SERVICE_CELLADDRESS
 		"",											// SC_SERVICE_RANGEADDRESS
         "",                                         // SC_SERVICE_SHEETDOCSET
-		""											// SC_SERVICE_CHDATAPROV
+        "",                                         // SC_SERVICE_CHDATAPROV
+        "",                                         // SC_SERVICE_FORMULAPARS
+        ""                                          // SC_SERVICE_OPCODEMAPPER
 	};
 
 
@@ -203,12 +208,15 @@ sal_uInt16 ScServiceProvider::GetProvide
 				return i;
 
 		for (i=0; i<SC_SERVICE_COUNT; i++)
+        {
+            DBG_ASSERT( aOldNames[i], "ScServiceProvider::GetProviderType: no oldname => crash");
 			if (rServiceName.EqualsAscii( aOldNames[i] ))
 			{
 				DBG_ERROR("old service name used");
 				return i;
 			}
 	}
+	}
 	return SC_SERVICE_INVALID;
 }
 
@@ -356,6 +364,15 @@ uno::Reference<uno::XInterface> ScServic
             if (pDocShell && pDocShell->GetDocument())
                 xRet = *new ScChart2DataProvider( pDocShell->GetDocument() );
             break;
+
+        case SC_SERVICE_FORMULAPARS:
+            if (pDocShell)
+                xRet.set(static_cast<sheet::XFormulaParser*>(new ScFormulaParserObj( pDocShell )));
+            break;
+
+        case SC_SERVICE_OPCODEMAPPER:
+            xRet.set(static_cast<sheet::XFormulaOpCodeMapper*>(new ScFormulaOpCodeMapperObj));
+            break;
 	}
 	return xRet;
 }
--- sc/source/ui/unoobj/styleuno.cxx	10 May 2007 16:59:42 -0000	1.39
+++ sc/source/ui/unoobj/styleuno.cxx	22 Nov 2007 12:33:43 -0000	1.37.18.4
@@ -82,6 +82,7 @@
 #include "unonames.hxx"
 #include "unowids.hxx"
 #include "globstr.hrc"
+#include "cellsuno.hxx"
 
 using namespace ::com::sun::star;
 
@@ -1269,7 +1270,7 @@ const SfxItemSet* ScStyleObj::GetStyleIt
 			}
 		}
 		pMap = SfxItemPropertyMap::GetByName( aPropSet.getPropertyMap(), rPropName );
-		if ( pMap && IsScItemWid( pMap->nWID ) )
+		if ( pMap )
 		{
 			rpResultEntry = pMap;
 			return &pStyle->GetItemSet();
@@ -1293,6 +1294,12 @@ beans::PropertyState SAL_CALL ScStyleObj
 	if ( pItemSet && pResultEntry )
 	{
 		USHORT nWhich = pResultEntry->nWID;
+        if ( nWhich == SC_WID_UNO_TBLBORD )
+        {
+            nWhich = ATTR_BORDER;
+        }
+        if ( IsScItemWid( nWhich ) )
+        {
 		SfxItemState eState = pItemSet->GetItemState( nWhich, sal_False );
 
 //       //  if no rotate value is set, look at orientation
@@ -1309,6 +1316,7 @@ beans::PropertyState SAL_CALL ScStyleObj
 		else
 			DBG_ERROR("unbekannter ItemState");
 	}
+	}
 	return eRet;
 }
 
@@ -1356,6 +1364,8 @@ uno::Any SAL_CALL ScStyleObj::getPropert
 	{
 		USHORT nWhich = pResultEntry->nWID;
 
+        if ( IsScItemWid( nWhich ) )
+        {
 		//	Default ist Default vom ItemPool, nicht vom Standard-Style,
 		//	damit es zu setPropertyToDefault passt
 		SfxItemSet aEmptySet( *pStyleSet->GetPool(), pStyleSet->GetRanges() );
@@ -1403,6 +1413,31 @@ uno::Any SAL_CALL ScStyleObj::getPropert
 				aAny = aPropSet.getPropertyValue( *pResultEntry, *pItemSet );
 		}
 	}
+        else if ( IsScUnoWid( nWhich ) )
+        {
+            SfxItemSet aEmptySet( *pStyleSet->GetPool(), pStyleSet->GetRanges() );
+            const SfxItemSet* pItemSet = &aEmptySet;
+            switch ( nWhich )
+            {
+                case SC_WID_UNO_TBLBORD:
+                    {
+                        const SfxPoolItem* pItem = &pItemSet->Get( ATTR_BORDER );
+                        if ( pItem )
+                        {
+                            SvxBoxItem aOuter( *( static_cast<const SvxBoxItem*>( pItem ) ) );
+                            SvxBoxInfoItem aInner( ATTR_BORDER_INNER );
+                            table::TableBorder aBorder;
+                            ScHelperFunctions::FillTableBorder( aBorder, aOuter, aInner );
+                            aBorder.IsHorizontalLineValid = sal_False;
+                            aBorder.IsVerticalLineValid = sal_False;
+                            aBorder.IsDistanceValid = sal_False;
+                            aAny <<= aBorder;
+                        }
+                    }
+                    break;
+            }
+        }
+	}
 	return aAny;
 }
 
@@ -1646,7 +1681,9 @@ void ScStyleObj::SetOnePropertyValue( co
 		{
 			const SfxItemPropertyMap* pOwnMap =
 					SfxItemPropertyMap::GetByName( aPropSet.getPropertyMap(), aString );
-			if ( pOwnMap && IsScItemWid( pOwnMap->nWID ) )
+            if ( pOwnMap )
+            {
+			    if ( IsScItemWid( pOwnMap->nWID ) )
 			{
 				if (pValue)
 				{
@@ -1728,7 +1765,6 @@ void ScStyleObj::SetOnePropertyValue( co
                             break;
 						case ATTR_PAGE_SCALE:
 						case ATTR_PAGE_SCALETOPAGES:
-						case ATTR_PAGE_FIRSTPAGENO:
 							{
                                 rSet.ClearItem(ATTR_PAGE_SCALETOPAGES);
                                 rSet.ClearItem(ATTR_PAGE_SCALE);
@@ -1738,11 +1774,18 @@ void ScStyleObj::SetOnePropertyValue( co
 								rSet.Put( SfxUInt16Item( pOwnMap->nWID, nVal ) );
 							}
 							break;
+						    case ATTR_PAGE_FIRSTPAGENO:
+							    {
+                                    sal_Int16 nVal = 0;
+								    *pValue >>= nVal;
+                                    rSet.Put( SfxUInt16Item( ATTR_PAGE_FIRSTPAGENO, nVal ) );
+							    }
+							    break;
 						case ATTR_PAGE_CHARTS:
 						case ATTR_PAGE_OBJECTS:
 						case ATTR_PAGE_DRAWINGS:
 							{
-								sal_Bool bBool = sal_Bool();
+                                    sal_Bool bBool = sal_False;
 								*pValue >>= bBool;
 								//!	sal_Bool-MID fuer ScViewObjectModeItem definieren?
 								rSet.Put( ScViewObjectModeItem( pOwnMap->nWID,
@@ -1820,6 +1863,32 @@ void ScStyleObj::SetOnePropertyValue( co
 					//!	for ATTR_ROTATE_VALUE, also reset ATTR_ORIENTATION?
 				}
 			}
+                else if ( IsScUnoWid( pOwnMap->nWID ) )
+                {
+                    switch ( pOwnMap->nWID )
+                    {
+                        case SC_WID_UNO_TBLBORD:
+                            {
+                                if (pValue)
+                                {
+                                    table::TableBorder aBorder;
+                                    if ( *pValue >>= aBorder )
+                                    {
+                                        SvxBoxItem aOuter( ATTR_BORDER );
+                                        SvxBoxInfoItem aInner( ATTR_BORDER_INNER );
+                                        ScHelperFunctions::FillBoxItems( aOuter, aInner, aBorder );
+                                        rSet.Put( aOuter );
+                                    }
+                                }
+                                else
+                                {
+                                    rSet.ClearItem( ATTR_BORDER );
+                                }
+                            }
+                            break;
+                    }
+                }
+            }
 		}
 
 		//!	DocFunc-Funktion??
@@ -1864,6 +1933,8 @@ uno::Any SAL_CALL ScStyleObj::getPropert
 	{
 		USHORT nWhich = pResultEntry->nWID;
 
+        if ( IsScItemWid( nWhich ) )
+        {
 		switch ( nWhich )		// fuer Item-Spezial-Behandlungen
 		{
 			case ATTR_VALUE_FORMAT:
@@ -1942,6 +2013,29 @@ uno::Any SAL_CALL ScStyleObj::getPropert
 					aAny = aPropSet.getPropertyValue( *pResultEntry, *pItemSet );
 		}
 	}
+        else if ( IsScUnoWid( nWhich ) )
+        {
+            switch ( nWhich )
+            {
+                case SC_WID_UNO_TBLBORD:
+                    {
+                        const SfxPoolItem* pItem = &pItemSet->Get( ATTR_BORDER );
+                        if ( pItem )
+                        {
+                            SvxBoxItem aOuter( *( static_cast<const SvxBoxItem*>( pItem ) ) );
+                            SvxBoxInfoItem aInner( ATTR_BORDER_INNER );
+                            table::TableBorder aBorder;
+                            ScHelperFunctions::FillTableBorder( aBorder, aOuter, aInner );
+                            aBorder.IsHorizontalLineValid = sal_False;
+                            aBorder.IsVerticalLineValid = sal_False;
+                            aBorder.IsDistanceValid = sal_False;
+                            aAny <<= aBorder;
+                        }
+                    }
+                    break;
+            }
+        }
+	}
 	else if ( aString.EqualsAscii( SC_UNONAME_DISPNAME ) )		// read-only
 	{
 		//	core always has the display name
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ sc/source/ui/unoobj/tokenuno.cxx	30 Aug 2007 09:22:54 -0000	1.1.2.7
@@ -0,0 +1,547 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+
+// MARKER(update_precomp.py): autogen include statement, do not remove
+#include "precompiled_sc.hxx"
+
+
+#include <com/sun/star/sheet/ComplexReference.hpp>
+#include <com/sun/star/sheet/ReferenceFlags.hpp>
+#include <com/sun/star/table/CellAddress.hpp>
+
+#include <svtools/itemprop.hxx>
+
+#include "tokenuno.hxx"
+#include "miscuno.hxx"
+#include "convuno.hxx"
+#include "unonames.hxx"
+#include "unoguard.hxx"
+#include "compiler.hxx"
+#include "tokenarray.hxx"
+#include "docsh.hxx"
+#include "rangeseq.hxx"
+
+using namespace com::sun::star;
+
+//------------------------------------------------------------------------
+
+const SfxItemPropertyMap* lcl_GetFormulaParserMap()
+{
+    static SfxItemPropertyMap aFormulaParserMap_Impl[] =
+    {
+        {MAP_CHAR_LEN(SC_UNO_REFERENCEPOS),    0,  &getCppuType((table::CellAddress*)0),    0, 0 },
+        {MAP_CHAR_LEN(SC_UNO_COMPILEENGLISH),  0,  &getBooleanCppuType(),                   0, 0 },
+        {MAP_CHAR_LEN(SC_UNO_IGNORELEADING),   0,  &getBooleanCppuType(),                   0, 0 },
+        {MAP_CHAR_LEN(SC_UNO_COMPATIBILITY3D), 0,  &getBooleanCppuType(),                   0, 0 },
+        {MAP_CHAR_LEN(SC_UNO_R1C1NOTATION),    0,  &getBooleanCppuType(),                   0, 0 },
+        {MAP_CHAR_LEN(SC_UNO_OPCODEMAP),       0,  &getCppuType((uno::Sequence< sheet::FormulaOpCodeMapEntry >*)0), 0, 0 },
+        {0,0,0,0,0,0}
+    };
+    return aFormulaParserMap_Impl;
+}
+
+SC_SIMPLE_SERVICE_INFO( ScFormulaParserObj, "ScFormulaParserObj", SC_SERVICENAME_FORMULAPARS )
+
+//------------------------------------------------------------------------
+
+ScFormulaParserObj::ScFormulaParserObj(ScDocShell* pDocSh) :
+    mpDocShell( pDocSh ),
+    mbEnglish( false ),
+    mbR1C1( false ),
+    mbComp3D( false ),
+    mbIgnoreSpaces( true )
+{
+    mpDocShell->GetDocument()->AddUnoObject(*this);
+}
+
+ScFormulaParserObj::~ScFormulaParserObj()
+{
+    if (mpDocShell)
+        mpDocShell->GetDocument()->RemoveUnoObject(*this);
+}
+
+void ScFormulaParserObj::Notify( SfxBroadcaster&, const SfxHint& rHint )
+{
+    if ( rHint.ISA( SfxSimpleHint ) && ((const SfxSimpleHint&)rHint).GetId() == SFX_HINT_DYING )
+        mpDocShell = NULL;
+}
+
+// XFormulaParser
+
+void ScFormulaParserObj::SetCompilerFlags( ScCompiler& rCompiler ) const
+{
+    // If mxOpCodeMap is not empty it overrides mbEnglish, and vice versa. We
+    // don't need to initialize things twice.
+    if (mxOpCodeMap.get())
+        rCompiler.SetFormulaLanguage( mxOpCodeMap );
+    else
+        rCompiler.SetCompileEnglish( mbEnglish );
+
+    ScAddress::Convention eConv = ScAddress::CONV_UNSPECIFIED;
+    if ( mbR1C1 )
+    {
+        // R1C1 is available only with '!' sheet separator
+        eConv = ScAddress::CONV_XL_R1C1;
+    }
+    else
+    {
+        if ( mbComp3D )
+            eConv = ScAddress::CONV_XL_A1;      // '!' and A1
+        else
+            eConv = ScAddress::CONV_OOO;        // '.' and A1
+    }
+    rCompiler.SetRefConvention( eConv );
+}
+
+uno::Sequence<sheet::FormulaToken> SAL_CALL ScFormulaParserObj::parseFormula( const rtl::OUString& aFormula )
+                                throw (uno::RuntimeException)
+{
+    ScUnoGuard aGuard;
+    uno::Sequence<sheet::FormulaToken> aRet;
+
+    if (mpDocShell)
+    {
+        ScCompiler aCompiler( mpDocShell->GetDocument(), maRefPos );
+        SetCompilerFlags( aCompiler );
+
+        ScTokenArray* pCode = aCompiler.CompileString( aFormula );
+        (void)ScTokenConversion::ConvertToTokenSequence( aRet, *pCode );
+        delete pCode;
+    }
+
+    return aRet;
+}
+
+rtl::OUString SAL_CALL ScFormulaParserObj::printFormula( const uno::Sequence<sheet::FormulaToken>& aTokens )
+                                throw (uno::RuntimeException)
+{
+    ScUnoGuard aGuard;
+    rtl::OUString aRet;
+
+    if (mpDocShell)
+    {
+        ScTokenArray aCode;
+        (void)ScTokenConversion::ConvertToTokenArray( aCode, aTokens );
+        ScCompiler aCompiler( mpDocShell->GetDocument(), maRefPos, aCode );
+        SetCompilerFlags( aCompiler );
+
+        rtl::OUStringBuffer aBuffer;
+        aCompiler.CreateStringFromTokenArray( aBuffer );
+        aRet = aBuffer.makeStringAndClear();
+    }
+
+    return aRet;
+}
+
+// XPropertySet
+
+uno::Reference<beans::XPropertySetInfo> SAL_CALL ScFormulaParserObj::getPropertySetInfo()
+                                                        throw(uno::RuntimeException)
+{
+    ScUnoGuard aGuard;
+    static uno::Reference< beans::XPropertySetInfo > aRef(new SfxItemPropertySetInfo( lcl_GetFormulaParserMap() ));
+    return aRef;
+}
+
+void SAL_CALL ScFormulaParserObj::setPropertyValue(
+                        const rtl::OUString& aPropertyName, const uno::Any& aValue )
+                throw(beans::UnknownPropertyException, beans::PropertyVetoException,
+                        lang::IllegalArgumentException, lang::WrappedTargetException,
+                        uno::RuntimeException)
+{
+    ScUnoGuard aGuard;
+    String aString(aPropertyName);
+    if ( aString.EqualsAscii( SC_UNO_REFERENCEPOS ) )
+    {
+        table::CellAddress aAddress;
+        aValue >>= aAddress;
+        ScUnoConversion::FillScAddress( maRefPos, aAddress );
+    }
+    else if ( aString.EqualsAscii( SC_UNO_COMPILEENGLISH ) )
+    {
+        bool bOldEnglish = mbEnglish;
+        if (aValue >>= mbEnglish)
+        {
+            // Need to recreate the symbol map to change English property
+            // because the map is const. So for performance reasons set
+            // CompileEnglish _before_ OpCodeMap!
+            if (mxOpCodeMap.get() && mbEnglish != bOldEnglish)
+                mxOpCodeMap = ScCompiler::CreateOpCodeMap( maOpCodeMapping, mbEnglish);
+        }
+        else
+            throw lang::IllegalArgumentException();
+    }
+    else if ( aString.EqualsAscii( SC_UNO_R1C1NOTATION ) )
+    {
+        aValue >>= mbR1C1;
+    }
+    else if ( aString.EqualsAscii( SC_UNO_COMPATIBILITY3D ) )
+    {
+        aValue >>= mbComp3D;
+    }
+    else if ( aString.EqualsAscii( SC_UNO_IGNORELEADING ) )
+    {
+        aValue >>= mbIgnoreSpaces;
+    }
+    else if ( aString.EqualsAscii( SC_UNO_OPCODEMAP ) )
+    {
+        if (aValue >>= maOpCodeMapping)
+            mxOpCodeMap = ScCompiler::CreateOpCodeMap( maOpCodeMapping, mbEnglish);
+        else
+            throw lang::IllegalArgumentException();
+    }
+    else
+        throw beans::UnknownPropertyException();
+}
+
+uno::Any SAL_CALL ScFormulaParserObj::getPropertyValue( const rtl::OUString& aPropertyName )
+                throw(beans::UnknownPropertyException, lang::WrappedTargetException,
+                        uno::RuntimeException)
+{
+    ScUnoGuard aGuard;
+    uno::Any aRet;
+    String aString(aPropertyName);
+    if ( aString.EqualsAscii( SC_UNO_REFERENCEPOS ) )
+    {
+        table::CellAddress aAddress;
+        ScUnoConversion::FillApiAddress( aAddress, maRefPos );
+        aRet <<= aAddress;
+    }
+    else if ( aString.EqualsAscii( SC_UNO_COMPILEENGLISH ) )
+    {
+        aRet <<= mbEnglish;
+    }
+    else if ( aString.EqualsAscii( SC_UNO_R1C1NOTATION ) )
+    {
+        aRet <<= mbR1C1;
+    }
+    else if ( aString.EqualsAscii( SC_UNO_COMPATIBILITY3D ) )
+    {
+        aRet <<= mbComp3D;
+    }
+    else if ( aString.EqualsAscii( SC_UNO_IGNORELEADING ) )
+    {
+        aRet <<= mbIgnoreSpaces;
+    }
+    else if ( aString.EqualsAscii( SC_UNO_OPCODEMAP ) )
+    {
+        aRet <<= maOpCodeMapping;
+    }
+    else
+        throw beans::UnknownPropertyException();
+    return aRet;
+}
+
+SC_IMPL_DUMMY_PROPERTY_LISTENER( ScFormulaParserObj )
+
+//------------------------------------------------------------------------
+
+void lcl_SingleRefToCalc( SingleRefData& rRef, const sheet::SingleReference& rAPI )
+{
+    rRef.InitFlags();
+
+    rRef.nCol    = static_cast<SCsCOL>(rAPI.Column);
+    rRef.nRow    = static_cast<SCsROW>(rAPI.Row);
+    rRef.nTab    = static_cast<SCsTAB>(rAPI.Sheet);
+    rRef.nRelCol = static_cast<SCsCOL>(rAPI.RelativeColumn);
+    rRef.nRelRow = static_cast<SCsROW>(rAPI.RelativeRow);
+    rRef.nRelTab = static_cast<SCsTAB>(rAPI.RelativeSheet);
+
+    rRef.SetColRel(     ( rAPI.Flags & sheet::ReferenceFlags::COLUMN_RELATIVE ) != 0 );
+    rRef.SetRowRel(     ( rAPI.Flags & sheet::ReferenceFlags::ROW_RELATIVE    ) != 0 );
+    rRef.SetTabRel(     ( rAPI.Flags & sheet::ReferenceFlags::SHEET_RELATIVE  ) != 0 );
+    rRef.SetColDeleted( ( rAPI.Flags & sheet::ReferenceFlags::COLUMN_DELETED  ) != 0 );
+    rRef.SetRowDeleted( ( rAPI.Flags & sheet::ReferenceFlags::ROW_DELETED     ) != 0 );
+    rRef.SetTabDeleted( ( rAPI.Flags & sheet::ReferenceFlags::SHEET_DELETED   ) != 0 );
+    rRef.SetFlag3D(     ( rAPI.Flags & sheet::ReferenceFlags::SHEET_3D        ) != 0 );
+    rRef.SetRelName(    ( rAPI.Flags & sheet::ReferenceFlags::RELATIVE_NAME   ) != 0 );
+}
+
+void lcl_SingleRefToApi( sheet::SingleReference& rAPI, const SingleRefData& rRef )
+{
+    rAPI.Column         = rRef.nCol;
+    rAPI.Row            = rRef.nRow;
+    rAPI.Sheet          = rRef.nTab;
+    rAPI.RelativeColumn = rRef.nRelCol;
+    rAPI.RelativeRow    = rRef.nRelRow;
+    rAPI.RelativeSheet  = rRef.nRelTab;
+
+    sal_Int32 nFlags = 0;
+    if ( rRef.IsColRel() )     nFlags |= sheet::ReferenceFlags::COLUMN_RELATIVE;
+    if ( rRef.IsRowRel() )     nFlags |= sheet::ReferenceFlags::ROW_RELATIVE;
+    if ( rRef.IsTabRel() )     nFlags |= sheet::ReferenceFlags::SHEET_RELATIVE;
+    if ( rRef.IsColDeleted() ) nFlags |= sheet::ReferenceFlags::COLUMN_DELETED;
+    if ( rRef.IsRowDeleted() ) nFlags |= sheet::ReferenceFlags::ROW_DELETED;
+    if ( rRef.IsTabDeleted() ) nFlags |= sheet::ReferenceFlags::SHEET_DELETED;
+    if ( rRef.IsFlag3D() )     nFlags |= sheet::ReferenceFlags::SHEET_3D;
+    if ( rRef.IsRelName() )    nFlags |= sheet::ReferenceFlags::RELATIVE_NAME;
+    rAPI.Flags = nFlags;
+}
+
+// static
+bool ScTokenConversion::ConvertToTokenArray( ScTokenArray& rTokenArray,
+                        const uno::Sequence<sheet::FormulaToken>& rSequence )
+{
+    bool bError = false;
+    sal_Int32 nCount = rSequence.getLength();
+    for (sal_Int32 nPos=0; nPos<nCount; nPos++)
+    {
+        const sheet::FormulaToken& rAPI = rSequence[nPos];
+        OpCode eOpCode = static_cast<OpCode>(rAPI.OpCode);      //! assuming equal values for the moment
+
+        uno::TypeClass eClass = rAPI.Data.getValueTypeClass();
+        switch ( eClass )
+        {
+            case uno::TypeClass_VOID:
+                // empty data -> use AddOpCode (does some special cases)
+                rTokenArray.AddOpCode( eOpCode );
+                break;
+            case uno::TypeClass_DOUBLE:
+                // double is only used for "push"
+                if ( eOpCode == ocPush )
+                    rTokenArray.AddDouble( rAPI.Data.get<double>() );
+                else
+                    bError = true;
+                break;
+            case uno::TypeClass_LONG:
+                {
+                    // long is svIndex, used for name / database area, or "byte" for spaces
+                    sal_Int32 nValue = rAPI.Data.get<sal_Int32>();
+                    if ( eOpCode == ocName || eOpCode == ocDBArea )
+                        rTokenArray.AddToken( ScIndexToken( eOpCode, static_cast<USHORT>(nValue) ) );
+                    else if ( eOpCode == ocSpaces )
+                        rTokenArray.AddToken( ScByteToken( ocSpaces, static_cast<BYTE>(nValue) ) );
+                    else
+                        bError = true;
+                }
+                break;
+            case uno::TypeClass_STRING:
+                {
+                    String aStrVal( rAPI.Data.get<rtl::OUString>() );
+                    if ( eOpCode == ocPush )
+                        rTokenArray.AddString( aStrVal );
+                    else if ( eOpCode == ocBad )
+                        rTokenArray.AddBad( aStrVal );
+                    else if ( eOpCode == ocExternal || eOpCode == ocMacro )
+                        rTokenArray.AddToken( ScExternalToken( eOpCode, aStrVal ) );
+                    else
+                        bError = true;      // unexpected string: don't know what to do with it
+                }
+                break;
+            case uno::TypeClass_STRUCT:
+                {
+                    uno::Type aType = rAPI.Data.getValueType();
+                    if ( aType.equals( cppu::UnoType<sheet::SingleReference>::get() ) )
+                    {
+                        SingleRefData aSingleRef;
+                        sheet::SingleReference aApiRef;
+                        rAPI.Data >>= aApiRef;
+                        lcl_SingleRefToCalc( aSingleRef, aApiRef );
+
+                        if ( eOpCode == ocPush )
+                            rTokenArray.AddSingleReference( aSingleRef );
+                        else if ( eOpCode == ocColRowName )
+                            rTokenArray.AddColRowName( aSingleRef );
+                        else
+                            bError = true;
+                    }
+                    else if ( aType.equals( cppu::UnoType<sheet::ComplexReference>::get() ) )
+                    {
+                        ComplRefData aComplRef;
+                        sheet::ComplexReference aApiRef;
+                        rAPI.Data >>= aApiRef;
+                        lcl_SingleRefToCalc( aComplRef.Ref1, aApiRef.Reference1 );
+                        lcl_SingleRefToCalc( aComplRef.Ref2, aApiRef.Reference2 );
+
+                        if ( eOpCode == ocPush )
+                            rTokenArray.AddDoubleReference( aComplRef );
+                        else
+                            bError = true;
+                    }
+                    else
+                        bError = true;      // unknown struct
+                }
+                break;
+            case uno::TypeClass_SEQUENCE:
+                {
+                    if ( eOpCode != ocPush )
+                        bError = true;      // not an inline array
+                    else if (!rAPI.Data.getValueType().equals( getCppuType(
+                                    (uno::Sequence< uno::Sequence< uno::Any > > *)0)))
+                        bError = true;      // unexpected sequence type
+                    else
+                    {
+                        ScMatrixRef xMat = ScSequenceToMatrix::CreateMixedMatrix( rAPI.Data);
+                        if (xMat)
+                            rTokenArray.AddMatrix( xMat);
+                        else
+                            bError = true;
+                    }
+                }
+                break;
+            default:
+                bError = true;
+        }
+    }
+
+    return !bError;
+}
+
+// static
+bool ScTokenConversion::ConvertToTokenSequence( uno::Sequence<sheet::FormulaToken>& rSequence,
+                        const ScTokenArray& rTokenArray )
+{
+    bool bError = false;
+
+    sal_Int32 nLen = static_cast<sal_Int32>(rTokenArray.GetLen());
+    ScToken** pTokens = rTokenArray.GetArray();
+    if ( pTokens )
+    {
+        rSequence.realloc(nLen);
+        for (sal_Int32 nPos=0; nPos<nLen; nPos++)
+        {
+            const ScToken& rToken = *pTokens[nPos];
+            sheet::FormulaToken& rAPI = rSequence[nPos];
+
+            OpCode eOpCode = rToken.GetOpCode();
+            rAPI.OpCode = static_cast<sal_Int32>(eOpCode);      //! assuming equal values for the moment
+            switch ( rToken.GetType() )
+            {
+                case svByte:
+                    // Only the count of spaces is stored as "long". Parameter count is ignored.
+                    if ( eOpCode == ocSpaces )
+                        rAPI.Data <<= (sal_Int32) rToken.GetByte();
+                    else
+                        rAPI.Data.clear();      // no data
+                    break;
+                case svDouble:
+                    rAPI.Data <<= rToken.GetDouble();
+                    break;
+                case svString:
+                    rAPI.Data <<= rtl::OUString( rToken.GetString() );
+                    break;
+                case svExternal:
+                    // Function name is stored as string.
+                    // Byte (parameter count) is ignored.
+                    rAPI.Data <<= rtl::OUString( rToken.GetExternal() );
+                    break;
+                case svSingleRef:
+                    {
+                        sheet::SingleReference aSingleRef;
+                        lcl_SingleRefToApi( aSingleRef, rToken.GetSingleRef() );
+                        rAPI.Data <<= aSingleRef;
+                    }
+                    break;
+                case svDoubleRef:
+                    {
+                        sheet::ComplexReference aCompRef;
+                        lcl_SingleRefToApi( aCompRef.Reference1, rToken.GetSingleRef() );
+                        lcl_SingleRefToApi( aCompRef.Reference2, rToken.GetSingleRef2() );
+                        rAPI.Data <<= aCompRef;
+                    }
+                    break;
+                case svIndex:
+                    rAPI.Data <<= static_cast<sal_Int32>( rToken.GetIndex() );
+                    break;
+                case svMatrix:
+                    if (!ScRangeToSequence::FillMixedArray( rAPI.Data, rToken.GetMatrix(), true))
+                        rAPI.Data.clear();
+                    break;
+                default:
+                    rAPI.Data.clear();      // no data
+            }
+        }
+    }
+    else
+        rSequence.realloc(0);
+
+    return !bError;
+}
+
+
+//------------------------------------------------------------------------
+
+SC_SIMPLE_SERVICE_INFO( ScFormulaOpCodeMapperObj, "ScFormulaOpCodeMapperObj", SC_SERVICENAME_OPCODEMAPPER )
+
+//------------------------------------------------------------------------
+
+ScFormulaOpCodeMapperObj::ScFormulaOpCodeMapperObj()
+{
+}
+
+ScFormulaOpCodeMapperObj::~ScFormulaOpCodeMapperObj()
+{
+}
+
+
+::sal_Int32 SAL_CALL ScFormulaOpCodeMapperObj::getOpCodeExternal()
+    throw (::com::sun::star::uno::RuntimeException)
+{
+    return ocExternal;
+}
+
+
+::sal_Int32 SAL_CALL ScFormulaOpCodeMapperObj::getOpCodeUnknown()
+    throw (::com::sun::star::uno::RuntimeException)
+{
+    return ScCompiler::OpCodeMap::getOpCodeUnknown();
+}
+
+
+::com::sun::star::uno::Sequence< ::com::sun::star::sheet::FormulaToken >
+SAL_CALL ScFormulaOpCodeMapperObj::getMappings(
+        const ::com::sun::star::uno::Sequence< ::rtl::OUString >& rNames,
+        sal_Int32 nLanguage )
+    throw ( ::com::sun::star::lang::IllegalArgumentException,
+            ::com::sun::star::uno::RuntimeException)
+{
+    ScCompiler::OpCodeMapPtr xMap = ScCompiler::GetOpCodeMap( nLanguage);
+    if (!xMap)
+        throw lang::IllegalArgumentException();
+    return xMap->createSequenceOfFormulaTokens( rNames);
+}
+
+
+::com::sun::star::uno::Sequence< ::com::sun::star::sheet::FormulaOpCodeMapEntry >
+SAL_CALL ScFormulaOpCodeMapperObj::getAvailableMappings(
+        sal_Int32 nLanguage, sal_Int32 nGroups )
+    throw ( ::com::sun::star::lang::IllegalArgumentException,
+            ::com::sun::star::uno::RuntimeException)
+{
+    ScCompiler::OpCodeMapPtr xMap = ScCompiler::GetOpCodeMap( nLanguage);
+    if (!xMap)
+        throw lang::IllegalArgumentException();
+    return xMap->createSequenceOfAvailableMappings( nGroups);
+}
--- sc/source/ui/view/auditsh.cxx	21 Jul 2006 14:50:46 -0000	1.5
+++ sc/source/ui/view/auditsh.cxx	8 May 2007 16:08:31 -0000	1.5.194.2
@@ -51,6 +51,7 @@
 #include "tabvwsh.hxx"
 #include "scresid.hxx"
 #include "sc.hrc"
+#include "document.hxx"
 
 //------------------------------------------------------------------------
 
@@ -75,7 +76,12 @@ ScAuditingShell::ScAuditingShell(ScViewD
 	nFunction( SID_FILL_ADD_PRED )
 {
 	SetPool( &pViewData->GetViewShell()->GetPool() );
-	SetUndoManager( pViewData->GetSfxDocShell()->GetUndoManager() );
+    SfxUndoManager* pMgr = pViewData->GetSfxDocShell()->GetUndoManager();
+    SetUndoManager( pMgr );
+    if ( !pViewData->GetDocument()->IsUndoEnabled() )
+    {
+        pMgr->SetMaxUndoActionCount( 0 );
+    }
 	SetHelpId( HID_SCSHELL_AUDIT );
 	SetName(String::CreateFromAscii(RTL_CONSTASCII_STRINGPARAM("Auditing")));
 }
--- sc/source/ui/view/formatsh.cxx	18 Jul 2007 09:45:01 -0000	1.36
+++ sc/source/ui/view/formatsh.cxx	24 Jul 2007 21:45:28 -0000	1.33.18.5
@@ -180,7 +180,12 @@ ScFormatShell::ScFormatShell(ScViewData*
 	ScTabViewShell*	pTabViewShell = GetViewData()->GetViewShell();
 
 	SetPool( &pTabViewShell->GetPool() );
-	SetUndoManager( pViewData->GetSfxDocShell()->GetUndoManager() );
+    SfxUndoManager* pMgr = pViewData->GetSfxDocShell()->GetUndoManager();
+    SetUndoManager( pMgr );
+    if ( !pViewData->GetDocument()->IsUndoEnabled() )
+    {
+        pMgr->SetMaxUndoActionCount( 0 );
+    }
 	SetHelpId(HID_SCSHELL_FORMATSH);
 	SetName(String::CreateFromAscii(RTL_CONSTASCII_STRINGPARAM("Format")));
 }
--- sc/source/ui/view/gridwin.cxx	27 Sep 2007 13:56:11 -0000	1.85
+++ sc/source/ui/view/gridwin.cxx	4 Oct 2007 09:22:56 -0000	1.82.12.2
@@ -3798,7 +3798,7 @@ sal_Int8 ScGridWindow::DropTransferObj( 
 
                     //!	use tokens
                     String aFormula( '=' );
-                    aFormula += ScCompiler::pSymbolTableNative[SC_OPCODE_DDE];
+                    aFormula += ScCompiler::GetNativeSymbol(ocDde);
                     aFormula.AppendAscii(RTL_CONSTASCII_STRINGPARAM("(\""));
                     aFormula += aApp;
                     aFormula.AppendAscii(RTL_CONSTASCII_STRINGPARAM("\";\""));
--- sc/source/ui/view/pgbrksh.cxx	21 Jul 2006 15:06:15 -0000	1.4
+++ sc/source/ui/view/pgbrksh.cxx	8 May 2007 16:12:56 -0000	1.4.194.2
@@ -74,7 +74,13 @@ ScPageBreakShell::ScPageBreakShell( ScTa
 	SfxShell(pViewSh)
 {
 	SetPool( &pViewSh->GetPool() );
-	SetUndoManager( pViewSh->GetViewData()->GetSfxDocShell()->GetUndoManager() );
+    ScViewData* pViewData = pViewSh->GetViewData();
+    SfxUndoManager* pMgr = pViewData->GetSfxDocShell()->GetUndoManager();
+    SetUndoManager( pMgr );
+    if ( !pViewData->GetDocument()->IsUndoEnabled() )
+    {
+        pMgr->SetMaxUndoActionCount( 0 );
+    }
 	SetHelpId( HID_SCSHELL_PAGEBREAK );
 	SetName(String::CreateFromAscii(RTL_CONSTASCII_STRINGPARAM("PageBreak")));
 }
--- sc/source/ui/view/pivotsh.cxx	26 Apr 2007 09:57:21 -0000	1.8
+++ sc/source/ui/view/pivotsh.cxx	8 May 2007 16:13:27 -0000	1.7.194.3
@@ -83,7 +83,13 @@ ScPivotShell::ScPivotShell( ScTabViewShe
 	pViewShell( pViewSh )
 {
 	SetPool( &pViewSh->GetPool() );
-	SetUndoManager( pViewSh->GetViewData()->GetSfxDocShell()->GetUndoManager() );
+    ScViewData* pViewData = pViewSh->GetViewData();
+    SfxUndoManager* pMgr = pViewData->GetSfxDocShell()->GetUndoManager();
+    SetUndoManager( pMgr );
+    if ( !pViewData->GetDocument()->IsUndoEnabled() )
+    {
+        pMgr->SetMaxUndoActionCount( 0 );
+    }
 	SetHelpId( HID_SCSHELL_PIVOTSH );
 	SetName(String::CreateFromAscii(RTL_CONSTASCII_STRINGPARAM("Pivot")));
 }
--- sc/source/ui/view/tabvwsh4.cxx	17 Jul 2007 13:35:24 -0000	1.68
+++ sc/source/ui/view/tabvwsh4.cxx	24 Jul 2007 21:48:04 -0000	1.64.18.5
@@ -1163,7 +1163,15 @@ void ScTabViewShell::SetDrawTextUndo( Sf
 		pNewUndoMgr = GetViewData()->GetDocShell()->GetUndoManager();
 
 	if (pDrawTextShell)
+    {
 		pDrawTextShell->SetUndoManager(pNewUndoMgr);
+        ScDocShell* pDocSh = GetViewData()->GetDocShell();
+        if ( pNewUndoMgr == pDocSh->GetUndoManager() &&
+             !pDocSh->GetDocument()->IsUndoEnabled() )
+        {
+            pNewUndoMgr->SetMaxUndoActionCount( 0 );
+        }
+    }
 	else
 		DBG_ERROR("SetDrawTextUndo ohne DrawTextShell");
 }
@@ -1802,8 +1810,13 @@ void ScTabViewShell::Construct( BYTE nFo
 		MakeDrawView( nForceDesignMode );
 	ViewOptionsHasChanged(FALSE);	// legt auch evtl. DrawView an
 
-	SetUndoManager( pDocSh->GetUndoManager() );
-	pFormShell->SetUndoManager( pDocSh->GetUndoManager() );
+    SfxUndoManager* pMgr = pDocSh->GetUndoManager();
+    SetUndoManager( pMgr );
+    pFormShell->SetUndoManager( pMgr );
+    if ( !pDoc->IsUndoEnabled() )
+    {
+        pMgr->SetMaxUndoActionCount( 0 );
+    }
 	SetRepeatTarget( &aTarget );
 	pFormShell->SetRepeatTarget( &aTarget );
 	SetHelpId( HID_SCSHELL_TABVWSH );
@@ -1824,7 +1837,7 @@ void ScTabViewShell::Construct( BYTE nFo
 					pDoc->MakeTable(i);
 			}
 
-			pDocSh->ResetEmpty();			// #i6232# make sure this is done only once
+            pDocSh->SetEmpty( FALSE );          // #i6232# make sure this is done only once
 		}
 
 		// ReadExtOptions is now in Activate
--- sc/source/ui/view/viewdata.cxx	10 May 2007 17:03:57 -0000	1.59
+++ sc/source/ui/view/viewdata.cxx	27 Nov 2007 15:06:54 -0000	1.59.16.4
@@ -173,51 +173,11 @@ ScViewDataTable::ScViewDataTable() :
 	nPixPosY[0]=nPixPosY[1]=0;
 }
 
-ScViewDataTable::ScViewDataTable( const ScViewDataTable& rDataTable ) :
-                eZoomType( rDataTable.eZoomType ),
-                aZoomX( rDataTable.aZoomX ),
-                aZoomY( rDataTable.aZoomY ),
-                aPageZoomX( rDataTable.aPageZoomX ),
-                aPageZoomY( rDataTable.aPageZoomY ),
-				nHSplitPos( rDataTable.nHSplitPos ),
-				nVSplitPos( rDataTable.nVSplitPos ),
-				eHSplitMode( rDataTable.eHSplitMode ),
-				eVSplitMode( rDataTable.eVSplitMode ),
-				eWhichActive( rDataTable.eWhichActive ),
-				nFixPosX( rDataTable.nFixPosX ),
-				nFixPosY( rDataTable.nFixPosY ),
-				nCurX( rDataTable.nCurX ),
-				nCurY( rDataTable.nCurY ),
-				nOldCurX( rDataTable.nOldCurX ),
-				nOldCurY( rDataTable.nOldCurY ),
-				bOldCurValid( rDataTable.bOldCurValid )
-{
-	nPosX[0]=rDataTable.nPosX[0];
-	nPosX[1]=rDataTable.nPosX[1];
-	nPosY[0]=rDataTable.nPosY[0];
-	nPosY[1]=rDataTable.nPosY[1];
-
-	nTPosX[0]=rDataTable.nTPosX[0];
-	nTPosX[1]=rDataTable.nTPosX[1];
-	nTPosY[0]=rDataTable.nTPosY[0];
-	nTPosY[1]=rDataTable.nTPosY[1];
-
-	nMPosX[0]=rDataTable.nMPosX[0];
-	nMPosX[1]=rDataTable.nMPosX[1];
-	nMPosY[0]=rDataTable.nMPosY[0];
-	nMPosY[1]=rDataTable.nMPosY[1];
-
-	nPixPosX[0]=rDataTable.nPixPosX[0];
-	nPixPosX[1]=rDataTable.nPixPosX[1];
-	nPixPosY[0]=rDataTable.nPixPosY[0];
-	nPixPosY[1]=rDataTable.nPixPosY[1];
-}
-
 ScViewDataTable::~ScViewDataTable()
 {
 }
 
-void ScViewDataTable::WriteUserDataSequence(uno::Sequence <beans::PropertyValue>& rSettings)
+void ScViewDataTable::WriteUserDataSequence(uno::Sequence <beans::PropertyValue>& rSettings, const ScViewData& /*rViewData*/, SCTAB /*nTab*/)
 {
 	rSettings.realloc(SC_TABLE_VIEWSETTINGS_COUNT);
 	beans::PropertyValue* pSettings = rSettings.getArray();
@@ -223,16 +188,19 @@ void ScViewDataTable::WriteUserDataSeque
 	}
 }
 
-void ScViewDataTable::ReadUserDataSequence(const uno::Sequence <beans::PropertyValue>& aSettings,
-                                            bool& rHasZoom)
+void ScViewDataTable::ReadUserDataSequence(const uno::Sequence <beans::PropertyValue>& aSettings, bool& rHasZoom, ScViewData& rViewData, SCTAB nTab)
 {
     rHasZoom = false;
 
 	sal_Int32 nCount(aSettings.getLength());
 	sal_Int32 nTemp32(0);
 	sal_Int16 nTemp16(0);
 	sal_Int32 nTempPosV(0);
 	sal_Int32 nTempPosH(0);
+    sal_Int32 nTempPosVTw(0);
+    sal_Int32 nTempPosHTw(0);
+    bool bHasVSplitInTwips = false;
+    bool bHasHSplitInTwips = false;
 	for (sal_Int32 i = 0; i < nCount; i++)
 	{
 		rtl::OUString sName(aSettings[i].Name);
@@ -259,10 +229,22 @@ void ScViewDataTable::ReadUserDataSequen
 		else if (sName.compareToAscii(SC_HORIZONTALSPLITPOSITION) == 0)
 		{
 			aSettings[i].Value >>= nTempPosH;
+            bHasHSplitInTwips = false;
 		}
 		else if (sName.compareToAscii(SC_VERTICALSPLITPOSITION) == 0)
 		{
 			aSettings[i].Value >>= nTempPosV;
+            bHasVSplitInTwips = false;
+		}
+        else if (sName.compareToAscii(SC_HORIZONTALSPLITPOSITION_TWIPS) == 0)
+        {
+            aSettings[i].Value >>= nTempPosHTw;
+            bHasHSplitInTwips = true;
+        }
+        else if (sName.compareToAscii(SC_VERTICALSPLITPOSITION_TWIPS) == 0)
+        {
+            aSettings[i].Value >>= nTempPosVTw;
+            bHasVSplitInTwips = true;
 		}
 		else if (sName.compareToAscii(SC_ACTIVESPLITRANGE) == 0)
 		{
@@ -289,15 +271,23 @@ void ScViewDataTable::ReadUserDataSequen
 			aSettings[i].Value >>= nTemp32;
 			nPosY[SC_SPLIT_BOTTOM] = static_cast<SCROW>(nTemp32);
 		}
+        else if (sName.compareToAscii(SC_TABLESELECTED) == 0)
+        {
+            bool bSelected = false;
+            aSettings[i].Value >>= bSelected;
+            rViewData.GetMarkData().SelectTable( nTab, bSelected );
+        }
 	}
+
 	if (eHSplitMode == SC_SPLIT_FIX)
-		nFixPosX = static_cast<SCCOL>(nTempPosH);
+        nFixPosX = static_cast< SCCOL >( bHasHSplitInTwips ? nTempPosHTw : nTempPosH );
 	else
-		nHSplitPos = nTempPosH;
+        nHSplitPos = bHasHSplitInTwips ? static_cast< long >( nTempPosHTw * rViewData.GetPPTX() ) : nTempPosH;
+
 	if (eVSplitMode == SC_SPLIT_FIX)
-		nFixPosY = static_cast<SCROW>(nTempPosV);
+        nFixPosY = static_cast< SCROW >( bHasVSplitInTwips ? nTempPosVTw : nTempPosV );
 	else
-		nVSplitPos = nTempPosV;
+        nVSplitPos = bHasVSplitInTwips ? static_cast< long >( nTempPosVTw * rViewData.GetPPTY() ) : nTempPosV;
 }
 
 //==================================================================
@@ -2678,7 +2668,7 @@ void ScViewData::WriteUserDataSequence(u
 					if (pTabData[nTab])
 					{
 						uno::Sequence <beans::PropertyValue> aTableViewSettings;
-						pTabData[nTab]->WriteUserDataSequence(aTableViewSettings);
+                        pTabData[nTab]->WriteUserDataSequence(aTableViewSettings, *this, nTab);
 						String sTabName;
 						GetDocument()->GetName( nTab, sTabName );
 						rtl::OUString sOUName(sTabName);
@@ -2794,7 +2784,7 @@ void ScViewData::ReadUserDataSequence(co
 						{
 							pTabData[nTab] = new ScViewDataTable;
                             bool bHasZoom = false;
-                            pTabData[nTab]->ReadUserDataSequence(aTabSettings, bHasZoom);
+                            pTabData[nTab]->ReadUserDataSequence(aTabSettings, bHasZoom, *this, nTab);
                             aHasZoomVect[nTab] = bHasZoom;
 						}
 					}
@@ -2817,6 +2807,12 @@ void ScViewData::ReadUserDataSequence(co
 			if (rSettings[i].Value >>= nTemp32)
 				pView->SetTabBarWidth(nTemp32);
 		}
+        else if (sName.compareToAscii(SC_RELHORIZONTALTABBARWIDTH) == 0)
+        {
+            double fWidth = 0.0;
+            if (rSettings[i].Value >>= fWidth)
+                pView->SetPendingRelTabBarWidth( fWidth );
+        }
 		else if (sName.compareToAscii(SC_ZOOMTYPE) == 0)
 		{
 			if (rSettings[i].Value >>= nTemp16)
@@ -2853,6 +2849,9 @@ void ScViewData::ReadUserDataSequence(co
 			{
 				String aColorName;
 				Color aColor(static_cast<sal_uInt32>(nColor));
+                // #i47435# set automatic grid color explicitly
+                if( aColor.GetColor() == COL_AUTO )
+                    aColor.SetColor( SC_STD_GRIDCOLOR );
 				pOptions->SetGridColor(aColor, aColorName);
 			}
 		}
@@ -2864,6 +2863,24 @@ void ScViewData::ReadUserDataSequence(co
 			pOptions->SetOption(VOPT_TABCONTROLS, ScUnoHelpFunctions::GetBoolFromAny( rSettings[i].Value ) );
 		else if ( sName.compareToAscii( SC_UNO_OUTLSYMB ) == 0 )
 			pOptions->SetOption(VOPT_OUTLINER, ScUnoHelpFunctions::GetBoolFromAny( rSettings[i].Value ) );
+        else if ( sName.compareToAscii( SC_UNO_SHOWOBJ ) == 0 )
+        {
+            // #i80528# placeholders not supported anymore
+            if ( rSettings[i].Value >>= nTemp16 )
+                pOptions->SetObjMode( VOBJ_TYPE_OLE, (nTemp16 == 1) ? VOBJ_MODE_HIDE : VOBJ_MODE_SHOW );
+        }
+        else if ( sName.compareToAscii( SC_UNO_SHOWCHARTS ) == 0 )
+        {
+            // #i80528# placeholders not supported anymore
+            if ( rSettings[i].Value >>= nTemp16 )
+                pOptions->SetObjMode( VOBJ_TYPE_CHART, (nTemp16 == 1) ? VOBJ_MODE_HIDE : VOBJ_MODE_SHOW );
+        }
+        else if ( sName.compareToAscii( SC_UNO_SHOWDRAW ) == 0 )
+        {
+            // #i80528# placeholders not supported anymore
+            if ( rSettings[i].Value >>= nTemp16 )
+                pOptions->SetObjMode( VOBJ_TYPE_DRAW, (nTemp16 == 1) ? VOBJ_MODE_HIDE : VOBJ_MODE_SHOW );
+        }
 		else
 		{
 			ScGridOptions aGridOpt(pOptions->GetGridOptions());
--- sc/source/ui/view/viewfun5.cxx	26 Apr 2007 09:58:50 -0000	1.49
+++ sc/source/ui/view/viewfun5.cxx	14 Aug 2007 18:32:03 -0000	1.49.8.1
@@ -730,15 +730,9 @@ BOOL ScViewFunc::PasteDDE( const uno::Re
     String aTopic( aByteTopic, eSysEnc );
     String aItem( aByteItem, eSysEnc );
 
-	if (!ScCompiler::pSymbolTableNative)
-	{
-		DBG_ERROR("ScCompiler::pSymbolTableNative missing");
-		return FALSE;
-	}
-
 	//!	use tokens
 	String aFormula( '=' );
-	aFormula += ScCompiler::pSymbolTableNative[SC_OPCODE_DDE];
+	aFormula += ScCompiler::GetNativeSymbol(ocDde);
 	aFormula.AppendAscii(RTL_CONSTASCII_STRINGPARAM("(\""));
 	aFormula += aApp;
 	aFormula.AppendAscii(RTL_CONSTASCII_STRINGPARAM("\";\""));
--- sc/source/ui/view/viewfunc.cxx	10 May 2007 17:04:32 -0000	1.37
+++ sc/source/ui/view/viewfunc.cxx	28 Jun 2007 15:47:36 -0000	1.37.16.1
@@ -849,7 +849,7 @@ void ScViewFunc::EnterMatrix( const Stri
 	if (pData->GetSimpleArea(aRange))
 	{
 		ScDocShell* pDocSh = pData->GetDocShell();
-		BOOL bSuccess = pDocSh->GetDocFunc().EnterMatrix( aRange, &rMark, rString, FALSE, FALSE );
+        BOOL bSuccess = pDocSh->GetDocFunc().EnterMatrix( aRange, &rMark, NULL, rString, FALSE, FALSE );
 		if (bSuccess)
 			pDocSh->UpdateOle(GetViewData());
 	}
