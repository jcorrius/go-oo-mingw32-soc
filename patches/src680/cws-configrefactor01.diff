cvs [diff aborted]: connect to localhost(127.0.0.1):2401 failed: Connection refused
Index: configmgr/qa/unit/export.map
===================================================================
RCS file: configmgr/qa/unit/export.map
diff -N configmgr/qa/unit/export.map
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ configmgr/qa/unit/export.map	5 Feb 2007 15:21:44 -0000	1.1.2.1
@@ -0,0 +1,7 @@
+UDK_3.0 {
+    global:
+        registerAllTestFunction;
+
+    local:
+        *;
+};
Index: configmgr/qa/unit/makefile.mk
===================================================================
RCS file: configmgr/qa/unit/makefile.mk
diff -N configmgr/qa/unit/makefile.mk
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ configmgr/qa/unit/makefile.mk	8 Feb 2007 12:44:56 -0000	1.1.2.2
@@ -0,0 +1,64 @@
+#*************************************************************************
+#
+#   OpenOffice.org - a multi-platform office productivity suite
+#
+#   $RCSfile$
+#
+#   $Revision$
+#
+#   last change: $Author$ $Date$
+#
+#   The Contents of this file are made available subject to
+#   the terms of GNU Lesser General Public License Version 2.1.
+#
+#
+#     GNU Lesser General Public License Version 2.1
+#     =============================================
+#     Copyright 2007 by Sun Microsystems, Inc.
+#     901 San Antonio Road, Palo Alto, CA 94303, USA
+#
+#     This library is free software; you can redistribute it and/or
+#     modify it under the terms of the GNU Lesser General Public
+#     License version 2.1, as published by the Free Software Foundation.
+#
+#     This library is distributed in the hope that it will be useful,
+#     but WITHOUT ANY WARRANTY; without even the implied warranty of
+#     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+#     Lesser General Public License for more details.
+#
+#     You should have received a copy of the GNU Lesser General Public
+#     License along with this library; if not, write to the Free Software
+#     Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+#     MA  02111-1307  USA
+#
+#*************************************************************************
+
+PRJ := ..$/..
+PRJNAME := configmgr
+TARGET := qa_unit
+
+ENABLE_EXCEPTIONS := TRUE
+
+.INCLUDE: settings.mk
+
+DLLPRE = # no leading "lib" on .so files
+
+SHL1TARGET = $(TARGET)
+SHL1OBJS = $(SLO)$/performance.obj
+SHL1STDLIBS = $(CPPULIB) $(CPPUHELPERLIB) $(CPPUNITLIB) $(SALLIB)
+SHL1VERSIONMAP = export.map
+SHL1IMPLIB = i$(SHL1TARGET)
+DEF1NAME = $(SHL1TARGET)
+
+SLOFILES = $(SHL1OBJS)
+
+.INCLUDE: target.mk
+
+ALLTAR: test
+
+$(MISC)$/$(TARGET).rdb .ERRREMOVE:
+    $(COPY) $(SOLARBINDIR)$/types.rdb $@
+    regcomp -register -r $@ -c $(subst,$/,/ $(DLLDEST)$/configmgr2.uno$(DLLPOST))
+
+test .PHONY: $(SHL1TARGETN) $(MISC)$/$(TARGET).rdb
+    testshl2 $(SHL1TARGETN) -forward "$(MISC)$/$(TARGET).rdb#$(PWD)$/$(MISC)$/$(TARGET).registry"
Index: configmgr/qa/unit/performance.cxx
===================================================================
RCS file: configmgr/qa/unit/performance.cxx
diff -N configmgr/qa/unit/performance.cxx
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ configmgr/qa/unit/performance.cxx	8 Feb 2007 12:44:56 -0000	1.1.2.3
@@ -0,0 +1,138 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2007 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+
+// MARKER(update_precomp.py): autogen include statement, do not remove
+#include "precompiled_configmgr.hxx"
+
+#include "sal/config.h"
+
+#include <cstdlib>
+
+#include "com/sun/star/beans/XPropertySet.hpp"
+#include "com/sun/star/lang/XComponent.hpp"
+#include "com/sun/star/lang/XMultiComponentFactory.hpp"
+#include "com/sun/star/lang/XMultiServiceFactory.hpp"
+#include "com/sun/star/uno/Any.hxx"
+#include "com/sun/star/uno/Reference.hxx"
+#include "com/sun/star/uno/XComponentContext.hpp"
+#include "cppuhelper/component_context.hxx"
+#include "cppuhelper/servicefactory.hxx"
+#include "cppunit/simpleheader.hxx"
+#include "osl/file.hxx"
+#include "osl/thread.h"
+#include "rtl/string.h"
+#include "rtl/ustring.h"
+#include "rtl/ustring.hxx"
+#include "sal/types.h"
+
+namespace {
+
+namespace css = com::sun::star;
+
+class Test: public CppUnit::TestFixture {
+public:
+    virtual void setUp();
+
+    virtual void tearDown();
+
+    void testDummy();
+
+    CPPUNIT_TEST_SUITE(Test);
+    CPPUNIT_TEST(testDummy);
+    CPPUNIT_TEST_SUITE_END();
+
+private:
+    css::uno::Reference< css::uno::XComponentContext > m_context;
+};
+
+void Test::setUp() {
+    char const * f = getForwardString();
+    rtl::OUString args(
+        f, rtl_str_getLength(f), osl_getThreadTextEncoding());
+        //TODO: handle conversion failure
+    sal_Int32 i = args.indexOf('#');
+    if (i < 0) {
+        std::abort();
+    }
+    rtl::OUString rdb(args.copy(0, i));
+    rtl::OUString regpath(args.copy(i + 1));
+    rtl::OUString regurl;
+    if (osl::FileBase::getFileURLFromSystemPath(regpath, regurl) !=
+        osl::FileBase::E_None)
+    {
+        std::abort();
+    }
+    css::uno::Reference< css::beans::XPropertySet > factory(
+        cppu::createRegistryServiceFactory(rdb), css::uno::UNO_QUERY_THROW);
+    css::uno::Reference< css::uno::XComponentContext > context(
+        factory->getPropertyValue(
+            rtl::OUString(RTL_CONSTASCII_USTRINGPARAM("DefaultContext"))),
+        css::uno::UNO_QUERY_THROW);
+    cppu::ContextEntry_Init entry(
+        rtl::OUString(
+            RTL_CONSTASCII_USTRINGPARAM(
+                "/modules/com.sun.star.configuration/bootstrap/Strata")),
+        css::uno::makeAny(
+            rtl::OUString(
+                RTL_CONSTASCII_USTRINGPARAM(
+                    "com.sun.star.comp.configuration.backend.LocalStratum:"))
+            + regurl));
+    m_context = cppu::createComponentContext(&entry, 1, context);
+}
+
+void Test::tearDown() {
+    css::uno::Reference< css::lang::XComponent >(
+        m_context, css::uno::UNO_QUERY_THROW)->dispose();
+}
+
+void Test::testDummy() {
+/*SB TODO*/try{
+    css::uno::Reference< css::lang::XMultiServiceFactory > provider(
+        (css::uno::Reference< css::lang::XMultiComponentFactory >(
+            m_context->getServiceManager(), css::uno::UNO_QUERY_THROW)->
+         createInstanceWithContext(
+             rtl::OUString(
+                 RTL_CONSTASCII_USTRINGPARAM(
+                     "com.sun.star.configuration.ConfigurationProvider")),
+             m_context)),
+        css::uno::UNO_QUERY_THROW);
+/*SB TODO*/}catch(css::uno::Exception&e){fprintf(stderr,"exception <%s>\n",rtl::OUStringToOString(e.Message,RTL_TEXTENCODING_UTF8).getStr());throw;}
+}
+
+CPPUNIT_TEST_SUITE_NAMED_REGISTRATION(Test, "alltests");
+
+}
+
+NOADDITIONAL;
Index: configmgr/source/api/confeventhelpers.cxx
===================================================================
RCS file: /cvs/util/configmgr/source/api/confeventhelpers.cxx,v
retrieving revision 1.14
retrieving revision 1.14.24.1
diff -u -p -u -p -r1.14 -r1.14.24.1
--- configmgr/source/api/confeventhelpers.cxx	16 Sep 2006 14:52:51 -0000	1.14
+++ configmgr/source/api/confeventhelpers.cxx	12 Jan 2007 17:51:16 -0000	1.14.24.1
@@ -177,7 +177,6 @@ void ConfigChangesBroadcasterImpl::dispa
 (
 	INodeListenerRef const& pTarget, 
 	AbsolutePath const& _aTargetPath,
-    memory::Accessor const& _aChangedDataAccessor, 
 	Change const& rBaseChange, 
 	AbsolutePath const& _aChangeLocation,
 	sal_Bool , //_bError, 
@@ -198,10 +197,10 @@ void ConfigChangesBroadcasterImpl::dispa
 		OSL_ASSERT( !pTargetChange || matches(_aChangeLocation.compose(aLocalPath),_aTargetPath) );
 
 	    if (pRemoved)
-		    pTarget->nodeDeleted(_aChangedDataAccessor,_aChangeLocation.compose(aLocalPath), pSource);
+		    pTarget->nodeDeleted(_aChangeLocation.compose(aLocalPath), pSource);
 
         else if (pTargetChange)
-		    pTarget->nodeChanged(_aChangedDataAccessor,*pTargetChange, _aTargetPath, pSource);
+		    pTarget->nodeChanged(*pTargetChange, _aTargetPath, pSource);
 
     }
     catch (InvalidName& )
@@ -215,7 +214,6 @@ void ConfigChangesBroadcasterImpl::dispa
 (
 	INodeListenerRef const& pTarget, 
 	AbsolutePath const& _aTargetPath,
-    memory::Accessor const& _aChangedDataAccessor, 
 	Change const& rBaseChange, 
 	AbsolutePath const& _aChangeLocation,
 	sal_Bool , //_bError, 
@@ -226,13 +224,13 @@ void ConfigChangesBroadcasterImpl::dispa
 	OSL_ASSERT(pTarget.is());
     OSL_ASSERT( Path::hasPrefix( _aChangeLocation, _aTargetPath) );
 
-	pTarget->nodeChanged(_aChangedDataAccessor, rBaseChange, _aChangeLocation, pSource);
+	pTarget->nodeChanged(rBaseChange, _aChangeLocation, pSource);
 }
 
 /////////////////////////////////////////////////////////////////////////
-void ConfigChangesBroadcasterImpl::dispatch(memory::Accessor const& _aChangedDataAccessor, TreeChangeList const& rList_, sal_Bool _bError, IConfigBroadcaster* pSource)
+void ConfigChangesBroadcasterImpl::dispatch(TreeChangeList const& rList_, sal_Bool _bError, IConfigBroadcaster* pSource)
 {
-	dispatch(_aChangedDataAccessor, rList_.root, rList_.getRootNodePath(),_bError, pSource);
+	dispatch(rList_.root, rList_.getRootNodePath(),_bError, pSource);
 }
 /////////////////////////////////////////////////////////////////////////
 namespace
@@ -250,7 +248,6 @@ namespace
 /////////////////////////////////////////////////////////////////////////
 void ConfigChangesBroadcasterImpl::dispatch
 (
-    memory::Accessor const& _aChangedDataAccessor, 
 	Change const& rBaseChange, 
 	AbsolutePath const& _aChangeLocation,
 	sal_Bool _bError, 
@@ -305,10 +302,10 @@ void ConfigChangesBroadcasterImpl::dispa
 	aGuard.clear();
 
 	{for (DispatchTargets::const_iterator it = aOuterTargets.begin(); it != aOuterTargets.end(); ++it){
-		this->dispatchOuter(it->pTarget, *it->pDispatchPath, _aChangedDataAccessor, rBaseChange, _aChangeLocation, _bError, pSource);
+		this->dispatchOuter(it->pTarget, *it->pDispatchPath, rBaseChange, _aChangeLocation, _bError, pSource);
 	}}
 	{for (DispatchTargets::const_iterator it = aInnerTargets.begin(); it != aInnerTargets.end(); ++it){
-		this->dispatchInner(it->pTarget, *it->pDispatchPath, _aChangedDataAccessor, rBaseChange, _aChangeLocation, _bError, pSource);
+		this->dispatchInner(it->pTarget, *it->pDispatchPath, rBaseChange, _aChangeLocation, _bError, pSource);
 	}}
 }
 
Index: configmgr/source/api/confeventhelpers.hxx
===================================================================
RCS file: /cvs/util/configmgr/source/api/confeventhelpers.hxx,v
retrieving revision 1.10
retrieving revision 1.10.84.1
diff -u -p -u -p -r1.10 -r1.10.84.1
--- configmgr/source/api/confeventhelpers.hxx	8 Sep 2005 03:03:44 -0000	1.10
+++ configmgr/source/api/confeventhelpers.hxx	12 Jan 2007 17:51:16 -0000	1.10.84.1
@@ -199,8 +199,8 @@ namespace configmgr
 
 //			void removed(OUString const& aPath, bool bRemovedFromModel, IConfigBroadcaster* pSource);
 
-			void dispatch(memory::Accessor const& _aChangedDataAccessor, Change const& rBaseChange, AbsolutePath const& sChangeLocation, sal_Bool _bError, IConfigBroadcaster* pSource);
-			void dispatch(memory::Accessor const& _aChangedDataAccessor, TreeChangeList const& rList_, sal_Bool _bError, IConfigBroadcaster* pSource);
+			void dispatch(Change const& rBaseChange, AbsolutePath const& sChangeLocation, sal_Bool _bError, IConfigBroadcaster* pSource);
+			void dispatch(TreeChangeList const& rList_, sal_Bool _bError, IConfigBroadcaster* pSource);
 			void disposing(IConfigBroadcaster* pSource);
 		private:
 			typedef BroadcastImplHelper<NodeListenerInfo> Listeners;
@@ -209,8 +209,8 @@ namespace configmgr
 			Listeners m_aListeners;
 			PathMap m_aPathMap;
 		private:
-			void dispatchInner(INodeListenerRef const& pTarget, AbsolutePath const& sTargetPath, memory::Accessor const& _aChangedDataAccessor, Change const& rBaseChange, AbsolutePath const& sChangeLocation, sal_Bool _bError, IConfigBroadcaster* pSource);
-			void dispatchOuter(INodeListenerRef const& pTarget, AbsolutePath const& sTargetPath, memory::Accessor const& _aChangedDataAccessor, Change const& rBaseChange, AbsolutePath const& sChangeLocation, sal_Bool _bError, IConfigBroadcaster* pSource);
+			void dispatchInner(INodeListenerRef const& pTarget, AbsolutePath const& sTargetPath, Change const& rBaseChange, AbsolutePath const& sChangeLocation, sal_Bool _bError, IConfigBroadcaster* pSource);
+			void dispatchOuter(INodeListenerRef const& pTarget, AbsolutePath const& sTargetPath, Change const& rBaseChange, AbsolutePath const& sChangeLocation, sal_Bool _bError, IConfigBroadcaster* pSource);
 		};
 
 	/////////////////////////////////////////////////////////////////////////
Index: configmgr/source/api/confevents.cxx
===================================================================
RCS file: /cvs/util/configmgr/source/api/confevents.cxx,v
retrieving revision 1.9
retrieving revision 1.9.24.2
diff -u -p -u -p -r1.9 -r1.9.24.2
--- configmgr/source/api/confevents.cxx	16 Sep 2006 14:53:04 -0000	1.9
+++ configmgr/source/api/confevents.cxx	12 Jan 2007 17:51:16 -0000	1.9.24.2
@@ -63,7 +63,7 @@ namespace configmgr
 		ConfigChangeBroadcastHelper();
 		~ConfigChangeBroadcastHelper();
 		
-		void broadcast(memory::Accessor const& _aChangedDataAccessor, TreeChangeList const& anUpdate, sal_Bool bError, IConfigBroadcaster* pSource);
+		void broadcast(TreeChangeList const& anUpdate, sal_Bool bError, IConfigBroadcaster* pSource);
 
 	public:
 		// IConfigBroadcaster implementation helper
@@ -118,20 +118,12 @@ namespace configmgr
 		}
 	}
 
-/*	void ConfigChangeBroadcaster::removeNode(OUString const& aPath, const vos::ORef < OOptions >& _xOptions, bool bRemovedFromModel)
-	{ 
-		if (ConfigChangeBroadcastHelper* pHelper = getBroadcastHelper(_xOptions,false))
-		{
-			pHelper->removeNode(aPath, bRemovedFromModel, this); 
-		}
-	}
-*/
 	/////////////////////////////////////////////////////////////////////////
-	void ConfigChangeBroadcaster::fireChanges(memory::Accessor const& _aChangedDataAccessor, TreeChangeList const& rList_, sal_Bool bError_)
+	void ConfigChangeBroadcaster::fireChanges(TreeChangeList const& rList_, sal_Bool bError_)
 	{
 		if (ConfigChangeBroadcastHelper* pHelper = getBroadcastHelper(rList_.getOptions(),false))
 		{
-			pHelper->broadcast(_aChangedDataAccessor, rList_, bError_, this);
+			pHelper->broadcast(rList_, bError_, this);
 		}
 	}
 
@@ -167,9 +159,9 @@ namespace configmgr
 	}
 */
 	/////////////////////////////////////////////////////////////////////////
-	void ConfigChangeBroadcastHelper::broadcast(memory::Accessor const& _aChangedDataAccessor, TreeChangeList const& anUpdate, sal_Bool bError, IConfigBroadcaster* pSource)
+	void ConfigChangeBroadcastHelper::broadcast(TreeChangeList const& anUpdate, sal_Bool bError, IConfigBroadcaster* pSource)
 	{
-		m_changes.dispatch(_aChangedDataAccessor, anUpdate, bError, pSource);
+		m_changes.dispatch(anUpdate, bError, pSource);
 	}
 
 
Index: configmgr/source/api/confsvccomponent.cxx
===================================================================
RCS file: /cvs/util/configmgr/source/api/confsvccomponent.cxx,v
retrieving revision 1.6
retrieving revision 1.6.24.1
diff -u -p -u -p -r1.6 -r1.6.24.1
--- configmgr/source/api/confsvccomponent.cxx	16 Sep 2006 14:53:18 -0000	1.6
+++ configmgr/source/api/confsvccomponent.cxx	11 Jan 2007 20:15:55 -0000	1.6.24.1
@@ -49,14 +49,17 @@
 #include <osl/mutex.hxx>
 #endif
 
+#ifndef CONFIGMGR_UTILITY_HXX_
+#include "utility.hxx"
+#endif
+
 #include <map>
 
 namespace configmgr {
 
 
 	ServiceComponentImpl::ServiceComponentImpl(ServiceImplementationInfo const* aInfo)
-		: ServiceImplBase(m_aMutex)
-		, m_aMutex()
+		: ServiceImplBase(UnoApiLock::getLock())
 		, m_info(aInfo)
 	{
 	}
Index: configmgr/source/api2/accessimpl.cxx
===================================================================
RCS file: /cvs/util/configmgr/source/api2/accessimpl.cxx,v
retrieving revision 1.15
retrieving revision 1.15.24.1
diff -u -p -u -p -r1.15 -r1.15.24.1
--- configmgr/source/api2/accessimpl.cxx	16 Sep 2006 14:53:31 -0000	1.15
+++ configmgr/source/api2/accessimpl.cxx	12 Jan 2007 17:51:16 -0000	1.15.24.1
@@ -245,7 +245,7 @@ uno::Type implGetElementType(NodeSetInfo
 	{
 		GuardedNodeData<NodeSetInfoAccess> lock( rNode );
 
-		aRet = rNode.getElementInfo(lock.getDataAccessor()).getElementType();
+		aRet = rNode.getElementInfo().getElementType();
 	}
 	catch (configuration::Exception& ex)
 	{
@@ -891,7 +891,7 @@ OUString SAL_CALL implGetElementTemplate
 	throw(uno::RuntimeException)
 {
 	GuardedNodeData<NodeSetInfoAccess> lock(rNode);
-	return rNode.getElementInfo(lock.getDataAccessor()).getTemplateInfo().getTemplatePathString();
+	return rNode.getElementInfo().getTemplateInfo().getTemplatePathString();
 }
 
 //-----------------------------------------------------------------------------------
Index: configmgr/source/api2/apifactory.cxx
===================================================================
RCS file: /cvs/util/configmgr/source/api2/apifactory.cxx,v
retrieving revision 1.11
retrieving revision 1.11.24.1
diff -u -p -u -p -r1.11 -r1.11.24.1
--- configmgr/source/api2/apifactory.cxx	16 Sep 2006 14:53:57 -0000	1.11
+++ configmgr/source/api2/apifactory.cxx	11 Jan 2007 20:15:56 -0000	1.11.24.1
@@ -94,12 +94,6 @@ Factory::~Factory()
 }
 //-----------------------------------------------------------------------------
 inline
-osl::Mutex&	Factory::doGetMutex()
-{
-	return m_pRegistry->mutex();
-}
-//-----------------------------------------------------------------------------
-inline
 NodeElement* Factory::implFind(configuration::NodeID const& aNode)
 {
 	return m_pRegistry->findElement(aNode);
@@ -176,8 +170,6 @@ NodeElement* Factory::makeElement(Tree c
 	OSL_PRECOND( aTree.isValidNode(aNode), "ERROR: Configuration: NodeRef does not match Tree");
 	OSL_PRECOND( configuration::isStructuralNode(aTree,aNode), "ERROR: Configuration: Cannot make object for value node");
 
-	osl::MutexGuard aLock(this->doGetMutex());
-
 	NodeID aNodeID(aTree,aNode);
 	NodeElement* pRet = findElement(aNodeID);
 	if (pRet == 0)
@@ -214,32 +206,14 @@ UnoInterfaceRef Factory::findUnoElement(
 //-----------------------------------------------------------------------------
 NodeElement* Factory::findElement(NodeID const& aNodeID)
 {
-	osl::MutexGuard aLock(this->doGetMutex());
 	NodeElement* pReturn = implFind(aNodeID);
 	if (pReturn) pReturn->getUnoInstance()->acquire();
 	return pReturn;
 }
 //-----------------------------------------------------------------------------
-/*
-void Factory::registerElement(NodeID const& aNodeID, NodeElement& rElement)
-{
-	osl::MutexGuard aLock(this->doGetMutex());
-	if (NodeElement* pExist = implFind(aNodeID))
-	{
-		OSL_ENSURE(pExist == &rElement,"ERROR: A different Configuration Element was already registered for the same node");
-		OSL_ENSURE(false ,"WARNING: Configuration Element was already registered");
-	}
-	else
-	{
-		doRegisterElement(aNodeID, &rElement);
-	}
-}
-*/
-//-----------------------------------------------------------------------------
 
 void Factory::revokeElement(NodeID const& aNodeID)
 {
-	osl::MutexGuard aLock(this->doGetMutex());
 	if (NodeElement* pElement = implFind(aNodeID))
 		doRevokeElement(aNodeID, pElement);
 }
@@ -247,7 +221,6 @@ void Factory::revokeElement(NodeID const
 
 void Factory::revokeElement(NodeID const& aNodeID, NodeElement& rElement)
 {
-	osl::MutexGuard aLock(this->doGetMutex());
 	if (implFind(aNodeID) == &rElement)
 		doRevokeElement(aNodeID, &rElement);
 }
@@ -266,8 +239,6 @@ TreeElement* Factory::makeAccessRoot(Tre
 
 	OSL_PRECOND( configuration::isStructuralNode(aTree,aRoot), "ERROR: Configuration: Cannot make object for value node");
 
-	osl::MutexGuard aLock(this->doGetMutex());
-
 	NodeID aNodeID(aTree,aRoot);
 	// must be a tree element if it is a tree root
 	TreeElement* pRet = static_cast<TreeElement*>(findElement(aNodeID));
@@ -299,8 +270,6 @@ NodeElement* Factory::makeGroupMember(Tr
 	OSL_PRECOND( configuration::isStructuralNode(aTree,aNode), "ERROR: Configuration: Cannot make object for value node");
 	OSL_ENSURE(!aTree.isRootNode(aNode),"INTERNAL ERROR: Root of Tree should not be used for a group member object");
 
-	osl::MutexGuard aLock(this->doGetMutex());
-
 	NodeID aNodeID(aTree,aNode);
 	NodeElement* pRet = findElement(aNodeID);
 	if (0 == pRet)
@@ -342,8 +311,6 @@ SetElement* Factory::makeSetElement(Elem
 
 	OSL_ENSURE( configuration::isStructuralNode(aTree,aRoot), "ERROR: Configuration: Cannot make object for value node");
 
-	osl::MutexGuard aLock(this->doGetMutex());
-
 	NodeID aNodeID(aTree,aRoot);
 	// must be a set element if it wraps a ElementTree
 	SetElement* pRet = static_cast<SetElement*>( findElement(aNodeID) );
@@ -370,8 +337,6 @@ SetElement* Factory::findSetElement(conf
 	NodeRef aRoot = aTree.getRootNode();
 	OSL_ENSURE(aRoot.isValid(),"INTERNAL ERROR: Tree has no root node");
 	
-	osl::MutexGuard aLock(this->doGetMutex());
-
 	NodeID aNodeID(aTree,aRoot);
 	// must be a set element if it wraps a ElementTree
 	SetElement* pRet = static_cast<SetElement*>( findElement(aNodeID) );
Index: configmgr/source/api2/apifactory.hxx
===================================================================
RCS file: /cvs/util/configmgr/source/api2/apifactory.hxx,v
retrieving revision 1.8
retrieving revision 1.8.84.1
diff -u -p -u -p -r1.8 -r1.8.84.1
--- configmgr/source/api2/apifactory.hxx	8 Sep 2005 03:06:17 -0000	1.8
+++ configmgr/source/api2/apifactory.hxx	11 Jan 2007 20:15:56 -0000	1.8.84.1
@@ -54,7 +54,6 @@
 #include <cppuhelper/typeprovider.hxx>
 #endif
 
-namespace osl { class Mutex; }
 namespace configmgr
 {
 	namespace configuration 
@@ -140,8 +139,6 @@ namespace configmgr
 
 			static ApiTreeImpl& getImplementation(NodeElement& pElement);
 		private:
-			osl::Mutex&		doGetMutex();
-
 			static configuration::TemplateHolder implGetSetElementTemplate(configuration::Tree const& aTree, configuration::NodeRef const& aNode);
 			static UnoInterfaceRef implToUno(NodeElement* pNode);
 			void implHaveNewElement(configuration::NodeID aNodeID, NodeElement* pNode);
Index: configmgr/source/api2/apinodeaccess.cxx
===================================================================
RCS file: /cvs/util/configmgr/source/api2/apinodeaccess.cxx,v
retrieving revision 1.13
retrieving revision 1.13.24.6
diff -u -p -u -p -r1.13 -r1.13.24.6
--- configmgr/source/api2/apinodeaccess.cxx	16 Sep 2006 14:54:31 -0000	1.13
+++ configmgr/source/api2/apinodeaccess.cxx	16 Jan 2007 12:18:17 -0000	1.13.24.6
@@ -77,9 +77,9 @@ configuration::TreeRef	NodeAccess::getTr
 }
 //-----------------------------------------------------------------------------
 
-configuration::Tree	NodeAccess::getTree(data::Accessor const & _aAccessor) const
+configuration::Tree	NodeAccess::getTree() const
 {
-	return configuration::Tree(_aAccessor,getApiTree().getTree());
+	return configuration::Tree(getApiTree().getTree());
 }
 //-----------------------------------------------------------------------------
 
@@ -106,23 +106,7 @@ Notifier NodeAccess::getNotifier() const
 {
 	return getApiTree().getNotifier();
 }
-//-----------------------------------------------------------------------------
 
-osl::Mutex& NodeAccess::getDataLock() const
-{
-	return getApiTree().getDataLock();
-}
-//-----------------------------------------------------------------------------
-
-memory::Segment const* NodeAccess::getSourceData() const
-{
-	return getApiTree().getSourceData();
-}
-//-----------------------------------------------------------------------------
-osl::Mutex& NodeAccess::getApiLock()
-{
-	return getApiTree().getApiLock();
-}
 //-----------------------------------------------------------------------------
 
 UnoAny	makeElement(configapi::Factory& rFactory, configuration::Tree const& aTree, configuration::AnyNodeRef const& aNode)
@@ -200,7 +184,7 @@ configuration::ElementTree extractElemen
 {
     using namespace configuration;
     ElementRef aExtractedRef = extractElementRef(rFactory,aElement,aElementInfo.getTemplateInfo());
-    return aExtractedRef.getElementTree(aElementInfo.getSetDataAccessor());
+    return aExtractedRef.getElementTree();
 }
 //-----------------------------------------------------------------------------
 			
@@ -216,42 +200,17 @@ SetElement* findSetElement(Factory& rFac
 }
 //-----------------------------------------------------------------------------
 
-configuration::SetElementInfo NodeSetInfoAccess::getElementInfo(data::Accessor const& _aAccessor) const
+configuration::SetElementInfo NodeSetInfoAccess::getElementInfo() const
 {
 	using configuration::SetElementInfo;
 	using configuration::TemplateHolder;
 
-	TemplateHolder aTemplate = SetElementInfo::extractElementInfo(getTree(_aAccessor),getNodeRef());
+	TemplateHolder aTemplate = SetElementInfo::extractElementInfo(getTree(),getNodeRef());
 
 	OSL_ENSURE(aTemplate.is(), "ERROR: Set must have an element template");
 
-	return SetElementInfo(_aAccessor,aTemplate);
-}
-//-----------------------------------------------------------------------------
-
-NodeReadGuardImpl::NodeReadGuardImpl(NodeAccess& rNode)
-: m_aLock(rNode.getDataLock())
-, m_rNode(rNode)
-{
-	rNode.checkAlive();
+	return SetElementInfo(aTemplate);
 }
-//-----------------------------------------------------------------------------
 
-NodeReadGuardImpl::~NodeReadGuardImpl() throw ()
-{
-}
-//-----------------------------------------------------------------------------
-
-configuration::Tree NodeReadGuardImpl::getTree(data::Accessor const& _aAccessor) const
-{
-    return this->get().getTree(_aAccessor);
 }
-//-----------------------------------------------------------------------------
-
-configuration::NodeRef NodeReadGuardImpl::getNode() const
-{
-    return this->get().getNodeRef();
-}
-//-----------------------------------------------------------------------------
-	}
 }
Index: configmgr/source/api2/apinodeaccess.hxx
===================================================================
RCS file: /cvs/util/configmgr/source/api2/apinodeaccess.hxx,v
retrieving revision 1.10
retrieving revision 1.10.36.6
diff -u -p -u -p -r1.10 -r1.10.36.6
--- configmgr/source/api2/apinodeaccess.hxx	4 Aug 2006 10:01:32 -0000	1.10
+++ configmgr/source/api2/apinodeaccess.hxx	7 Feb 2007 12:14:53 -0000	1.10.36.6
@@ -44,19 +44,10 @@
 #include "noderef.hxx"
 #endif
 
-#ifndef CONFIGMGR_ACCESSOR_HXX
-#include <accessor.hxx>
-#endif
-
 namespace osl { class Mutex; }
 
 namespace configmgr
 {
-    namespace memory
-    {
-        class Accessor;
-        class Segment;
-    }
 	namespace configuration
 	{
 		class Name;
@@ -82,7 +73,7 @@ namespace configmgr
 		typedef uno::XInterface UnoInterface;
 		typedef uno::Any UnoAny;
 
-	// API object implementation wrappers
+        // API object implementation wrappers
 		// these objects just provide the pieces needed to navigate and manipulate trees and nodes
 
 		// The common part of all nodes, provides all you need to read and listen
@@ -94,7 +85,7 @@ namespace configmgr
 		// model access
 			configuration::NodeRef	getNodeRef() const;
             configuration::TreeRef	getTreeRef() const;
-            configuration::Tree	    getTree(memory::Accessor const& _aAccessor) const;
+            configuration::Tree	    getTree() const;
 
 		// self-locked methods for dispose handling
 			void checkAlive() const;
@@ -106,11 +97,6 @@ namespace configmgr
 			Factory&				getFactory() const;
 			Notifier				getNotifier() const;
 
-		// locking support
-            osl::Mutex&             getDataLock() const;
-			memory::Segment const*  getSourceData() const;
-			osl::Mutex&				getApiLock();
-
 		protected:
 			virtual configuration::NodeRef	doGetNode() const = 0;
 			virtual UnoInterface*	doGetUnoInstance() const = 0;
@@ -151,7 +137,7 @@ namespace configmgr
 		{
 			friend class SetElement;
 		public:
-			configuration::SetElementInfo getElementInfo(memory::Accessor const& _aAccessor) const;
+			configuration::SetElementInfo getElementInfo() const;
 		};
 
 		/** extracts a <type scope='configmgr::configuration'>ElementTree</type> from a <type scope='com::sun::star::uno'>Any</type>
@@ -167,21 +153,27 @@ namespace configmgr
 		/// finds a existing <type>SetElement</type> for a given <type scope='configmgr::configuration'>ElementTree</type>
 		SetElement* findSetElement(Factory& rFactory, configuration::ElementRef const& aElementTree);
 
-	// Guarding and locking implementations
-		/// guards a NodeAccess; provides an object (read) lock, ensures object was not disposed
+        // Guarding and locking implementations
+		/// guards a NodeAccess; provides an object (read) lock,
+        /// ensures object was not disposed
+
+// FIXME: can evaporate this class [ I think ]
 		class NodeReadGuardImpl : Noncopyable
 		{
-            osl::MutexGuard	    m_aLock;
-			NodeAccess&			m_rNode;
+			NodeAccess &m_rNode;
 		public:
-			NodeReadGuardImpl(NodeAccess& rNode);
-			~NodeReadGuardImpl() throw ();
+			NodeReadGuardImpl(NodeAccess& rNode)
+                : m_rNode(rNode)
+                { rNode.checkAlive(); }
+			~NodeReadGuardImpl()
+                {}
 		public:
 			NodeAccess&	get() const { return m_rNode; }
 
-            configuration::Tree     getTree(memory::Accessor const& _aAccessor) const;
-            configuration::NodeRef  getNode() const;
-            
+            configuration::Tree     getTree() const
+                { return m_rNode.getTree(); }
+            configuration::NodeRef  getNode() const
+                { return m_rNode.getNodeRef(); }
 		};
 
 	// Thin Wrappers around NodeAccesses: Provide guarding and convenient access
@@ -197,12 +189,13 @@ namespace configmgr
 		};
 		typedef GuardedNode<NodeAccess> GuardedNodeAccess;
 
-		/// wraps a NodeAccess; provides both object and provider (read) locks, ensures object was not disposed
+		/// wraps a NodeAccess; provides both object and provider (read) locks,
+        // ensures object was not disposed
 		template <class Access>
 		class GuardedNodeData
 		{	
-            memory::Accessor	    m_aDataAccess;
-			NodeReadGuardImpl	m_aViewLock;
+            UnoApiLock              m_aLock;
+			NodeReadGuardImpl       m_aViewLock;
 		public:
 			GuardedNodeData(Access& rNode);
 		public:
@@ -210,22 +203,19 @@ namespace configmgr
 
             configuration::Tree     getTree() const;
             configuration::NodeRef  getNode() const;
-
-            memory::Accessor const & getDataAccessor() const { return m_aDataAccess; }
 		};
 		typedef GuardedNodeData<NodeAccess> GuardedNodeDataAccess;
 
 		template <class Access>
 		GuardedNodeData<Access>::GuardedNodeData(Access& rNode)
-		: m_aDataAccess(rNode.getSourceData())
-		, m_aViewLock(rNode)
+		: m_aViewLock(rNode)
 		{
 		}
 
 		template <class Access>
         configuration::Tree GuardedNodeData<Access>::getTree() const
         {
-            return (configuration::Tree) m_aViewLock.getTree(m_aDataAccess);
+            return (configuration::Tree) m_aViewLock.getTree();
         }
 
 		template <class Access>
Index: configmgr/source/api2/apinodeupdate.cxx
===================================================================
RCS file: /cvs/util/configmgr/source/api2/apinodeupdate.cxx,v
retrieving revision 1.11
retrieving revision 1.11.24.4
diff -u -p -u -p -r1.11 -r1.11.24.4
--- configmgr/source/api2/apinodeupdate.cxx	16 Sep 2006 14:54:45 -0000	1.11
+++ configmgr/source/api2/apinodeupdate.cxx	12 Jan 2007 17:51:17 -0000	1.11.24.4
@@ -75,42 +75,42 @@ NodeGroupAccess& withDefaultData(NodeGro
 }
 //-----------------------------------------------------------------------------
 
-configuration::GroupUpdater NodeGroupAccess::getNodeUpdater(data::Accessor const& _aAccessor)
+configuration::GroupUpdater NodeGroupAccess::getNodeUpdater()
 {
-	return configuration::GroupUpdater(getTree(_aAccessor),getNodeRef(), getApiTree().getProvider().getTypeConverter());
+	return configuration::GroupUpdater(getTree(),getNodeRef(), getApiTree().getProvider().getTypeConverter());
 }
 //-----------------------------------------------------------------------------
 
-configuration::GroupDefaulter NodeGroupAccess::getNodeDefaulter(data::Accessor const& _aAccessor)
+configuration::GroupDefaulter NodeGroupAccess::getNodeDefaulter()
 {
-	return configuration::GroupDefaulter(getTree(_aAccessor),getNodeRef(), getApiTree().getDefaultProvider());
+	return configuration::GroupDefaulter(getTree(),getNodeRef(), getApiTree().getDefaultProvider());
 }
 //-----------------------------------------------------------------------------
 
-configuration::SetElementFactory NodeTreeSetAccess::getElementFactory(data::Accessor const& _aAccessor)
+configuration::SetElementFactory NodeTreeSetAccess::getElementFactory()
 {
 	using namespace configuration;
-	TemplateProvider aProvider = SetElementFactory::findTemplateProvider(getTree(_aAccessor),getNodeRef());
-	return SetElementFactory(_aAccessor,aProvider);
+	TemplateProvider aProvider = SetElementFactory::findTemplateProvider(getTree(),getNodeRef());
+	return SetElementFactory(aProvider);
 }
 //-----------------------------------------------------------------------------
 
-configuration::SetDefaulter NodeSetAccess::getNodeDefaulter(data::Accessor const& _aAccessor)
+configuration::SetDefaulter NodeSetAccess::getNodeDefaulter()
 {
-	return configuration::SetDefaulter(getTree(_aAccessor),getNodeRef(), getApiTree().getDefaultProvider());
+	return configuration::SetDefaulter(getTree(),getNodeRef(), getApiTree().getDefaultProvider());
 }
 //-----------------------------------------------------------------------------
 
-configuration::TreeSetUpdater NodeTreeSetAccess::getNodeUpdater(data::Accessor const& _aAccessor)
+configuration::TreeSetUpdater NodeTreeSetAccess::getNodeUpdater()
 {
-	return configuration::TreeSetUpdater(getTree(_aAccessor),getNodeRef(),getElementInfo(_aAccessor));
+	return configuration::TreeSetUpdater(getTree(),getNodeRef(),getElementInfo());
 }
 //-----------------------------------------------------------------------------
 
 
-configuration::ValueSetUpdater NodeValueSetAccess::getNodeUpdater(data::Accessor const& _aAccessor)
+configuration::ValueSetUpdater NodeValueSetAccess::getNodeUpdater()
 {
-	return configuration::ValueSetUpdater(getTree(_aAccessor),getNodeRef(),getElementInfo(_aAccessor), getApiTree().getProvider().getTypeConverter());
+	return configuration::ValueSetUpdater(getTree(),getNodeRef(),getElementInfo(), getApiTree().getProvider().getTypeConverter());
 }
 //-----------------------------------------------------------------------------
 
@@ -178,18 +178,14 @@ bool detachSetElement(Factory& rFactory,
 //-----------------------------------------------------------------------------
 
 UpdateGuardImpl::UpdateGuardImpl(NodeGroupAccess& rNode)
-: m_aDataAccess(rNode.getSourceData())
-, m_aViewLock(rNode.getDataLock())
-, m_rNode(rNode)
+: m_rNode(rNode)
 {
 	rNode.checkAlive();
 }
 //-----------------------------------------------------------------------------
 
 UpdateGuardImpl::UpdateGuardImpl(NodeSetAccess& rNode)
-: m_aDataAccess(rNode.getSourceData())
-, m_aViewLock(rNode.getDataLock())
-, m_rNode(rNode)
+: m_rNode(rNode)
 {
 }
 //-----------------------------------------------------------------------------
Index: configmgr/source/api2/apinodeupdate.hxx
===================================================================
RCS file: /cvs/util/configmgr/source/api2/apinodeupdate.hxx,v
retrieving revision 1.9
retrieving revision 1.9.84.3
diff -u -p -u -p -r1.9 -r1.9.84.3
--- configmgr/source/api2/apinodeupdate.hxx	8 Sep 2005 03:07:54 -0000	1.9
+++ configmgr/source/api2/apinodeupdate.hxx	12 Jan 2007 17:51:17 -0000	1.9.84.3
@@ -39,9 +39,6 @@
 #ifndef CONFIGMGR_API_NODEACCESS_HXX_
 #include "apinodeaccess.hxx"
 #endif
-#ifndef CONFIGMGR_ACCESSOR_HXX
-#include "accessor.hxx"
-#endif
 #ifndef CONFIGMGR_UTILITY_HXX_
 #include "utility.hxx"
 #endif
@@ -76,8 +73,8 @@ namespace configmgr
 		public:
             typedef configuration::GroupUpdater     NodeUpdater;
             typedef configuration::GroupDefaulter   NodeDefaulter;
-			NodeUpdater     getNodeUpdater(memory::Accessor const& _aAccessor);
-			NodeDefaulter   getNodeDefaulter(memory::Accessor const& _aAccessor);
+			NodeUpdater     getNodeUpdater();
+			NodeDefaulter   getNodeDefaulter();
 
 		    /** ensures that the default data for a group is loaded (if possible)
                 <p>Must be called outside of any locks !</p>
@@ -91,7 +88,7 @@ namespace configmgr
 		public:
             typedef struct SetUpdater_PlaceHolder   NodeUpdater;
             typedef configuration::SetDefaulter     NodeDefaulter;
-			NodeDefaulter     getNodeDefaulter(memory::Accessor const& _aAccessor);
+			NodeDefaulter     getNodeDefaulter();
 		};
 
 		// Updating access for Set Nodes containing whole trees
@@ -99,9 +96,9 @@ namespace configmgr
 		{
 		public:
             typedef configuration::TreeSetUpdater     NodeUpdater;
-			NodeUpdater     getNodeUpdater(memory::Accessor const& _aAccessor);
+			NodeUpdater     getNodeUpdater();
 
-			configuration::SetElementFactory	getElementFactory(memory::Accessor const& _aAccessor);
+			configuration::SetElementFactory	getElementFactory();
 		};
 
 		// Updating access for Set Nodes containing simple values
@@ -109,7 +106,7 @@ namespace configmgr
 		{
 		public:
             typedef configuration::ValueSetUpdater     NodeUpdater;
-			NodeUpdater     getNodeUpdater(memory::Accessor const& _aAccessor);
+			NodeUpdater     getNodeUpdater();
 		};
 
 		/// informs a <type>SetElement</type> that it should now link to the given SetElement
@@ -124,13 +121,11 @@ namespace configmgr
 		/// informs a <type>SetElement</type> that it should now unlink from its owning SetElement
 		bool detachSetElement(Factory& rFactory, configuration::ElementRef const& aElementTree);
 
-	// Guarding and locking implementations
+		/// Guarding and locking implementations
 		/// guards a NodeGroupAccess, or NodeSetAccess; provides an object (write)/provider(read) lock; ensures object was not disposed
 		class UpdateGuardImpl : Noncopyable
 		{
-            memory::Accessor		        m_aDataAccess;
-            osl::MutexGuard	            m_aViewLock;
-			NodeAccess&			        m_rNode;
+			NodeAccess&      m_rNode;
 		public:
 			UpdateGuardImpl(NodeGroupAccess& rNode);
 			UpdateGuardImpl(NodeSetAccess& rNode);
@@ -139,8 +134,6 @@ namespace configmgr
 			NodeAccess&	get()		 const { return m_rNode; }
 
 			void downgrade() {  }
-
-            memory::Accessor const& accessor() const { return m_aDataAccess; }
 		};
 
 	// Thin Wrappers around NodeAccesses: Provide guarding and convenient access
@@ -148,6 +141,7 @@ namespace configmgr
 		template <class Access>
 		class GuardedNodeUpdate
 		{
+            UnoApiLock      m_aLock;
 			UpdateGuardImpl m_aImpl;
 		public:
 			GuardedNodeUpdate(Access& rNode) : m_aImpl(rNode) {}
@@ -163,15 +157,13 @@ namespace configmgr
             Updater    getNodeUpdater() const;
             Defaulter  getNodeDefaulter() const;
 
-            memory::Accessor const& getDataAccessor() const { return m_aImpl.accessor(); }
-
 			void clearForBroadcast() { m_aImpl.downgrade(); }
 		};
 
 		template <class Access>
         configuration::Tree GuardedNodeUpdate<Access>::getTree() const
         {
-            return get().getTree(this->getDataAccessor());
+            return get().getTree();
         }
 
 		template <class Access>
@@ -183,13 +175,13 @@ namespace configmgr
 		template <class Access>
         typename GuardedNodeUpdate<Access>::Updater GuardedNodeUpdate<Access>::getNodeUpdater() const
         {
-            return get().getNodeUpdater(this->getDataAccessor());
+            return get().getNodeUpdater();
         }
 
 		template <class Access>
         typename GuardedNodeUpdate<Access>::Defaulter GuardedNodeUpdate<Access>::getNodeDefaulter() const
         {
-            return get().getNodeDefaulter(this->getDataAccessor());
+            return get().getNodeDefaulter();
         }
 
 		/// wraps a NodeGroupAccess; provides an object (write) lock, ensures object was not disposed
Index: configmgr/source/api2/apitreeaccess.cxx
===================================================================
RCS file: /cvs/util/configmgr/source/api2/apitreeaccess.cxx,v
retrieving revision 1.9
retrieving revision 1.9.24.5
diff -u -p -u -p -r1.9 -r1.9.24.5
--- configmgr/source/api2/apitreeaccess.cxx	16 Sep 2006 14:55:24 -0000	1.9
+++ configmgr/source/api2/apitreeaccess.cxx	16 Jan 2007 12:18:18 -0000	1.9.24.5
@@ -58,9 +58,9 @@ void NodeElement::checkAlive() const
 }
 //-----------------------------------------------------------------------------
 
-configuration::Tree	TreeElement::getTree(data::Accessor const& _aAccessor) const
+configuration::Tree	TreeElement::getTree() const
 {
-    return configuration::Tree(_aAccessor, this->getTreeRef());
+    return configuration::Tree(this->getTreeRef());
 }
 //-----------------------------------------------------------------------------
 
@@ -87,18 +87,6 @@ Notifier TreeElement::getNotifier()
 }
 //-----------------------------------------------------------------------------
 
-osl::Mutex& TreeElement::getDataLock() const
-{
-	return getApiTree().getDataLock();
-}
-//-----------------------------------------------------------------------------
-
-osl::Mutex&	TreeElement::getApiLock()
-{
-	return getApiTree().getApiLock();
-}
-//-----------------------------------------------------------------------------
-
 configuration::ElementRef SetElement::getElementRef() const
 {
 	return configuration::ElementRef::extract(getTreeRef());
@@ -130,12 +118,6 @@ bool RootElement::disposeTree() 
 }
 //-----------------------------------------------------------------------------
 
-memory::Segment const* RootElement::getSourceData()
-{
-	return getApiTree().getSourceData();
-}
-//-----------------------------------------------------------------------------
-
 Committer UpdateRootElement::getCommitter()
 {
 	return Committer(getRootTree());
@@ -143,8 +125,7 @@ Committer UpdateRootElement::getCommitte
 //-----------------------------------------------------------------------------
 
 TreeReadGuardImpl::TreeReadGuardImpl(TreeElement& rTree)
-: m_aViewLock(rTree.getDataLock())
-, m_rTree(rTree)
+: m_rTree(rTree)
 {
 	rTree.checkAlive();
 }
@@ -156,15 +137,14 @@ TreeReadGuardImpl::~TreeReadGuardImpl() 
 //-----------------------------------------------------------------------------
 
 GuardedRootElement::GuardedRootElement(RootElement& rTree)
-: m_aDataAccess(rTree.getSourceData())
-, m_aImpl(rTree)
+: m_aImpl(rTree)
 {
 }
 //-----------------------------------------------------------------------------
 
 configuration::Tree GuardedRootElement::getTree() const
 {
-    return this->get().getTree(m_aDataAccess);
+    return this->get().getTree();
 }
 
 //-----------------------------------------------------------------------------
Index: configmgr/source/api2/apitreeaccess.hxx
===================================================================
RCS file: /cvs/util/configmgr/source/api2/apitreeaccess.hxx,v
retrieving revision 1.10
retrieving revision 1.10.84.5
diff -u -p -u -p -r1.10 -r1.10.84.5
--- configmgr/source/api2/apitreeaccess.hxx	8 Sep 2005 03:09:23 -0000	1.10
+++ configmgr/source/api2/apitreeaccess.hxx	7 Feb 2007 12:14:54 -0000	1.10.84.5
@@ -36,9 +36,6 @@
 #ifndef CONFIGMGR_API_TREEACCESS_HXX_
 #define CONFIGMGR_API_TREEACCESS_HXX_
 
-#ifndef CONFIGMGR_ACCESSOR_HXX
-#include "accessor.hxx"
-#endif
 #ifndef CONFIGMGR_MISC_OPTIONS_HXX_
 #include "options.hxx"
 #endif
@@ -53,19 +50,12 @@ namespace configmgr
 //-----------------------------------------------------------------------------
 	struct ServiceImplementationInfo;
 //-----------------------------------------------------------------------------
-    namespace memory
-    {
-        class Accessor;
-        class Segment;
-    }
-//-----------------------------------------------------------------------------
 	namespace configuration 
 	{
 		class Name;
 		class Tree;
 		class TreeRef;
 		class ElementRef;
-//		class RootTree;
 
 		class TemplateInfo;
 	}
@@ -129,15 +119,12 @@ namespace configmgr
 		public:
 		// model access
 			configuration::TreeRef		getTreeRef() const;
-			configuration::Tree 		getTree(memory::Accessor const& _aAccessor) const;
+			configuration::Tree 		getTree() const;
 
 		// api object handling
 			Factory&					getFactory();
 			Notifier					getNotifier();
 
-		// locking support
-            osl::Mutex&             	getDataLock() const;
-			osl::Mutex&					getApiLock();
 		protected:
 			virtual ApiTreeImpl& getApiTree() const = 0;
 		};
@@ -162,8 +149,6 @@ namespace configmgr
 		{
 		public:
 			bool disposeTree();
-
-            memory::Segment const* getSourceData();
 		protected:
 			virtual ApiRootTreeImpl& getRootTree() = 0;
 		};
@@ -177,9 +162,9 @@ namespace configmgr
 		};
 //-----------------------------------------------------------------------------
 		/// guards a TreeElement; provides an object (read) lock, ensures object was not disposed
+        // FIXME: bin this ...
 		class TreeReadGuardImpl : Noncopyable
 		{
-            osl::MutexGuard	    m_aViewLock;
 			TreeElement&		m_rTree;
 		public:
 			TreeReadGuardImpl(TreeElement& rTree);
@@ -192,6 +177,7 @@ namespace configmgr
 		/// wraps a TreeElement; provides an object (read) lock, ensures object was not disposed
 		class GuardedTreeElement
 		{	
+            UnoApiLock          m_aLock;
 			TreeReadGuardImpl	m_aImpl;
 		public:
 			GuardedTreeElement(TreeElement& rTree) : m_aImpl(rTree) {}
@@ -201,7 +187,7 @@ namespace configmgr
 
 		class GuardedRootElement
 		{	
-            memory::Accessor      m_aDataAccess;
+            UnoApiLock          m_aLock;
 			TreeReadGuardImpl	m_aImpl;
 		public:
 			GuardedRootElement(RootElement& rTree);
@@ -209,8 +195,6 @@ namespace configmgr
 			RootElement& get() const { return static_cast<RootElement&>(m_aImpl.get()); }
 
             configuration::Tree getTree() const;
-
-            memory::Accessor const & getDataAccessor() const { return m_aDataAccess; };
 		};
 //-----------------------------------------------------------------------------
 	}
Index: configmgr/source/api2/apitreeimplobj.cxx
===================================================================
RCS file: /cvs/util/configmgr/source/api2/apitreeimplobj.cxx,v
retrieving revision 1.41
retrieving revision 1.41.24.5
diff -u -p -u -p -r1.41 -r1.41.24.5
--- configmgr/source/api2/apitreeimplobj.cxx	16 Sep 2006 14:55:43 -0000	1.41
+++ configmgr/source/api2/apitreeimplobj.cxx	16 Jan 2007 12:18:18 -0000	1.41.24.5
@@ -345,8 +345,8 @@ public:
 
 	// Interfaces
 	virtual void disposing(IConfigBroadcaster* pSource);
-	virtual void nodeChanged(data::Accessor const& _aChangedDataAccessor, Change const& aChange, AbsolutePath const& sPath, IConfigBroadcaster* pSource);
-	virtual void nodeDeleted(data::Accessor const& _aChangedDataAccessor, AbsolutePath const& sPath, IConfigBroadcaster* pSource);
+	virtual void nodeChanged(Change const& aChange, AbsolutePath const& sPath, IConfigBroadcaster* pSource);
+	virtual void nodeDeleted(AbsolutePath const& sPath, IConfigBroadcaster* pSource);
 };
 
 //-------------------------------------------------------------------------
@@ -479,12 +479,7 @@ void ApiTreeImpl::checkAlive() const
 {
 	m_aNotifier->m_aListeners.checkAlive( getUnoInstance() );
 }
-//-------------------------------------------------------------------------
 
-osl::Mutex& ApiTreeImpl::getApiLock() const
-{
-	return m_aNotifier->mutex();
-}
 //-------------------------------------------------------------------------
 
 Notifier ApiTreeImpl::getNotifier() const
@@ -514,9 +509,6 @@ bool ApiTreeImpl::disposeTree(bool bForc
     if (!isAlive())
         return false;
 
-    data::Accessor aSourceAccessor( getSourceData() );
-
-    osl::MutexGuard aLocalGuard(getDataLock());
 	if (!bForce)
 	{
 		if (m_pParentTree != 0)
@@ -528,7 +520,7 @@ bool ApiTreeImpl::disposeTree(bool bForc
 	else if (m_pParentTree)
 		setParentTree(NULL);
 
-    implDisposeTree(aSourceAccessor); // TODO: accessor from lock
+    implDisposeTree();
 	OSL_ASSERT(!isAlive()); // post condition
 
 	return true;
@@ -539,13 +531,7 @@ bool ApiTreeImpl::disposeTreeNow()
 {
 	CFG_TRACE_INFO("ApiTreeImpl: Disposing Tree Now (unless disposed)");
 	if (isAlive() )
-	{
-        data::Accessor aSourceAccessor( getSourceData() );
-
-        osl::MutexGuard aLocalGuard(getDataLock());
-
-        return implDisposeTree(aSourceAccessor); // TODO: accessor from lock
-	}
+        return implDisposeTree();
 	else
 		return false;
 }
@@ -576,7 +562,7 @@ bool ApiRootTreeImpl::disposeTree()
 	return bDisposed;
 }
 //-------------------------------------------------------------------------
-bool ApiTreeImpl::implDisposeTree(data::Accessor const& _aAccessor)
+bool ApiTreeImpl::implDisposeTree()
 {
 	OSL_ENSURE(m_pParentTree == 0,"WARNING: Disposing a tree that still has a parent tree set");
 
@@ -593,7 +579,7 @@ bool ApiTreeImpl::implDisposeTree(data::
 		Factory& rFactory = getFactory();
 
 		NodeIDList aChildNodes;
-        getAllContainedNodes( Tree(_aAccessor,m_aTree), aChildNodes);
+        getAllContainedNodes( Tree(m_aTree), aChildNodes);
 
 		for (NodeIDList::reverse_iterator it = aChildNodes.rbegin(), stop = aChildNodes.rend();
 			it != stop;
@@ -603,7 +589,7 @@ bool ApiTreeImpl::implDisposeTree(data::
 		}
 
 		CFG_TRACE_INFO_NI("ApiTreeImpl: Listeners are now informed");
-		aContainer.notifyDisposing(_aAccessor);
+		aContainer.notifyDisposing();
 
 		OSL_ASSERT(!aContainer.isDisposed());
 
@@ -624,19 +610,12 @@ bool ApiTreeImpl::implDisposeTree(data::
 //-------------------------------------------------------------------------
 void ApiTreeImpl::disposeNode(NodeRef const& aNode, UnoInterface* pInstance)
 {
+    // This used to contain 3 nested 'isAlive()' calls; why !?
 	if (isAlive())
-	{
-        data::Accessor aSourceAccessor( getSourceData() );
-        if (isAlive())
-        {
-            osl::MutexGuard aLocalGuard(getDataLock());
-            if (isAlive())
-                implDisposeNode(aSourceAccessor, aNode,pInstance);
-        }
-	}
+        implDisposeNode(aNode,pInstance);
 }
 //-------------------------------------------------------------------------
-void ApiTreeImpl::implDisposeNode(data::Accessor const & _anAccessor, NodeRef const& aNode, UnoInterface* )
+void ApiTreeImpl::implDisposeNode(NodeRef const& aNode, UnoInterface* )
 {
 	CFG_TRACE_INFO("ApiTreeImpl: Disposing a single node.");
 	OSL_ENSURE(aNode.isValid(),"INTERNAL ERROR: Disposing NULL node");
@@ -648,7 +627,7 @@ void ApiTreeImpl::implDisposeNode(data::
 
 	NodeID aNodeID(m_aTree,aNode);
 
-	if (m_aNotifier->m_aListeners.disposeOne(_anAccessor, aNodeID.toIndex()) )
+	if (m_aNotifier->m_aListeners.disposeOne(aNodeID.toIndex()) )
 	{
 		getFactory().revokeElement(aNodeID);
 	}
@@ -695,8 +674,6 @@ ApiTreeImpl const* ApiTreeImpl::getRootT
 //-------------------------------------------------------------------------
 void ApiTreeImpl::setParentTree(ApiTreeImpl*	pParentTree) // internal implementation
 {
-	osl::MutexGuard aLock(getApiLock());
-
 #if OSL_DEBUG_LEVEL > 0
 	if (pParentTree)
 	{
@@ -776,8 +753,6 @@ void ApiTreeImpl::disposing(com::sun::st
 //-------------------------------------------------------------------------
 IConfigBroadcaster* ApiRootTreeImpl::implSetNotificationSource(IConfigBroadcaster* pNew)
 {
-	osl::MutexGuard aGuard(getApiTree().getApiLock());
-
 	IConfigBroadcaster* pOld = m_pNotificationListener.is() ? m_pNotificationListener->getSource() : 0;
 	if (pOld != pNew)
 	{
@@ -795,8 +770,6 @@ IConfigBroadcaster* ApiRootTreeImpl::imp
 
 void ApiRootTreeImpl::implSetLocation(configuration::Tree const& _aTree)
 {
-	osl::MutexGuard aGuard(getApiTree().getApiLock());
-
     OSL_ASSERT( configuration::equalTreeRef(_aTree.getRef(), getApiTree().getTree()) );
 	if (!_aTree.isEmpty())
 	{
@@ -925,7 +898,7 @@ void disposeRemovedNodes(configuration::
 }
 // ---------------------------------------------------------------------------------------------------
 //INodeListener : IConfigListener
-void ApiRootTreeImpl::NodeListener::nodeChanged(data::Accessor const& _aChangedDataAccessor, Change const& aChange, AbsolutePath const& sPath, IConfigBroadcaster* _pSource)
+void ApiRootTreeImpl::NodeListener::nodeChanged(Change const& aChange, AbsolutePath const& sPath, IConfigBroadcaster* _pSource)
 {
 	osl::ClearableMutexGuard aGuard(mutex);
 
@@ -937,13 +910,13 @@ void ApiRootTreeImpl::NodeListener::node
 		ApiRootTreeImpl* pKeepParent = pParent;
 		aGuard.clear();
 
-		pKeepParent->nodeChanged(_aChangedDataAccessor,aChange,sPath,_pSource);
+		pKeepParent->nodeChanged(aChange,sPath,_pSource);
 	}
 }
 // ---------------------------------------------------------------------------------------------------
 
 //INodeListener : IConfigListener
-void ApiRootTreeImpl::nodeChanged(data::Accessor const& _aChangedDataAccessor, Change const& aChange, AbsolutePath const& aChangePath, IConfigBroadcaster* /*pSource*/)
+void ApiRootTreeImpl::nodeChanged(Change const& aChange, AbsolutePath const& aChangePath, IConfigBroadcaster* /*pSource*/)
 {
 	using configuration::AnyNodeRef;
 	using configuration::NodeChanges;
@@ -954,9 +927,7 @@ void ApiRootTreeImpl::nodeChanged(data::
 	if (m_aTreeImpl.isAlive())
 	try
 	{
-        osl::MutexGuard aLocalGuard(m_aTreeImpl.getDataLock());
-
-        configuration::Tree aTree( _aChangedDataAccessor,m_aTreeImpl.getTree() );
+        configuration::Tree aTree(m_aTreeImpl.getTree());
 
 		OSL_ENSURE(configuration::Path::hasPrefix(aChangePath, m_aLocationPath),
                     "'changed' Path does not indicate this tree or its context: ");
@@ -1049,7 +1020,7 @@ void ApiRootTreeImpl::nodeChanged(data::
 }
 // ---------------------------------------------------------------------------------------------------
 
-void ApiRootTreeImpl::NodeListener::nodeDeleted(data::Accessor const& _aChangedDataAccessor, AbsolutePath const& _aPath, IConfigBroadcaster* _pSource)
+void ApiRootTreeImpl::NodeListener::nodeDeleted(AbsolutePath const& _aPath, IConfigBroadcaster* _pSource)
 {
 	osl::ClearableMutexGuard aGuard(mutex);
 
@@ -1061,11 +1032,11 @@ void ApiRootTreeImpl::NodeListener::node
 		ApiRootTreeImpl* pKeepParent = pParent;
 		aGuard.clear();
 
-		pKeepParent->nodeDeleted(_aChangedDataAccessor,_aPath,_pSource);
+		pKeepParent->nodeDeleted(_aPath,_pSource);
 	}
 }
 // ---------------------------------------------------------------------------------------------------
-void ApiRootTreeImpl::nodeDeleted(data::Accessor const& /*_aChangedDataAccessor*/, AbsolutePath const& _aDeletedPath, IConfigBroadcaster* /*pSource*/)
+void ApiRootTreeImpl::nodeDeleted(AbsolutePath const& _aDeletedPath, IConfigBroadcaster* /*pSource*/)
 {
     { (void)_aDeletedPath; }
 
@@ -1073,13 +1044,8 @@ void ApiRootTreeImpl::nodeDeleted(data::
 	UnoInterfaceRef xKeepAlive( m_aTreeImpl.getUnoInstance() );
 
 #ifdef DBG_UTIL
-
-	{
-        osl::MutexGuard aLocalGuard(m_aTreeImpl.getDataLock());
-
-		OSL_ENSURE(configuration::Path::hasPrefix(m_aLocationPath, _aDeletedPath),
-                    "'deleted' Path does not indicate this tree or its context: ");
-	}
+    OSL_ENSURE(configuration::Path::hasPrefix(m_aLocationPath, _aDeletedPath),
+               "'deleted' Path does not indicate this tree or its context: ");
 #endif
 	// ensure our provider stays alive
 	UnoInterfaceRef xKeepProvider( m_aTreeImpl.getUnoProviderInstance() );
Index: configmgr/source/api2/apitreeimplobj.hxx
===================================================================
RCS file: /cvs/util/configmgr/source/api2/apitreeimplobj.hxx,v
retrieving revision 1.25
retrieving revision 1.25.84.4
diff -u -p -u -p -r1.25 -r1.25.84.4
--- configmgr/source/api2/apitreeimplobj.hxx	8 Sep 2005 03:09:54 -0000	1.25
+++ configmgr/source/api2/apitreeimplobj.hxx	16 Jan 2007 12:18:18 -0000	1.25.84.4
@@ -170,11 +170,6 @@ namespace configmgr
 			uno::XInterface*			getUnoInstance() const	{ return m_pInstance; }
 			ApiProvider&				getProvider()			{ return m_rProvider; }
 			UnoInterfaceRef				getUnoProviderInstance() const; //	{ return m_xProvider; }
-
-		// locking support
-            memory::Segment const *	    getSourceData() const   { return configuration::getRootSegment(m_aTree); }
-            osl::Mutex&     			getDataLock() const		{ return configuration::getRootLock(m_aTree); }
-			osl::Mutex&					getApiLock() const;
 			
 			/// wire this to a new parent tree
 			void						haveNewParent(ApiTreeImpl* pNewParent);
@@ -183,8 +178,8 @@ namespace configmgr
 			void setParentTree(ApiTreeImpl*	pNewParentTree);
 			void deinit();
 
-			bool implDisposeTree(data::Accessor const& _aAccessor);
-			void implDisposeNode(data::Accessor const & _anAccessor, configuration::NodeRef const& aNode, UnoInterface* pInstance);
+			bool implDisposeTree();
+			void implDisposeNode(configuration::NodeRef const& aNode, UnoInterface* pInstance);
 
 			friend class ComponentAdapter;
 			void disposing(com::sun::star::lang::EventObject const& rEvt) throw();
@@ -227,8 +222,8 @@ namespace configmgr
 		// IConfigListener
 			void disposing(IConfigBroadcaster* pSource) ;
 		//INodeListener : IConfigListener
-			void nodeChanged(data::Accessor const& _aChangedDataAccessor, Change const& aChange, AbsolutePath const& aPath, IConfigBroadcaster* pSource);
-			void nodeDeleted(data::Accessor const& _aChangedDataAccessor, AbsolutePath const& aPath, IConfigBroadcaster* pSource);
+			void nodeChanged(Change const& aChange, AbsolutePath const& aPath, IConfigBroadcaster* pSource);
+			void nodeDeleted(AbsolutePath const& aPath, IConfigBroadcaster* pSource);
 
 		private:
 			ApiTreeImpl				    m_aTreeImpl;
Index: configmgr/source/api2/broadcaster.cxx
===================================================================
RCS file: /cvs/util/configmgr/source/api2/broadcaster.cxx,v
retrieving revision 1.19
retrieving revision 1.19.24.3
diff -u -p -u -p -r1.19 -r1.19.24.3
--- configmgr/source/api2/broadcaster.cxx	16 Sep 2006 14:55:56 -0000	1.19
+++ configmgr/source/api2/broadcaster.cxx	12 Jan 2007 17:51:18 -0000	1.19.24.3
@@ -1071,8 +1071,7 @@ namespace configmgr
         for (NodeChangesInformation::Iterator pos = aRawInfos.begin(); pos != aRawInfos.end(); ++pos)
 		{
             NodeChangeInformation aInfo = *pos;
-
-			if( !configapi::rebaseChange(aInfo.accessor,aInfo.location,aBaseTree) )	
+			if( !configapi::rebaseChange(aInfo.location,aBaseTree) )	
 			{
 				OSL_TRACE("Change is not within expected tree - skipping for notification");
 				continue;
@@ -1080,7 +1079,7 @@ namespace configmgr
 		
             OSL_ENSURE(!pos->isEmptyChange(), "Empty Change Found for Notification");
 			// it actually is expected that elements may not be found - thus ignoring result
-            configapi::resolveToUno(aInfo.change, aInfo.accessor, rFactory);
+            configapi::resolveToUno(aInfo.change, rFactory);
             
             aNewInfos.push_back( aInfo );
 		}
@@ -1103,16 +1102,15 @@ namespace configmgr
 		for (NodeChangesInformation::Iterator it = aChanges.begin(); it != aChanges.end(); ++it)
 		{
 			NodeChangeInformation aInfo(*it);
-
 			// enabling the Single base optimization requires a base node (not only a base tree) for correct accessors
 			//if (!bSingleBase || !configuration::equalTree(aBaseTree,aNewChange.info.baseTree))
-			if( !configapi::rebaseChange(aInfo.accessor,aInfo.location,aBaseTree) )	
+			if( !configapi::rebaseChange(aInfo.location,aBaseTree) )	
 			{
 				OSL_TRACE("Change is not within expected tree - skipping for notification");
 				continue;
 			}
 
-			if( !configapi::resolveToUno(aInfo.change,aInfo.accessor,rFactory) )
+			if( !configapi::resolveToUno(aInfo.change,rFactory) )
 			{
 				// it actually is expected that elements may not be found
 				// OSL_TRACE("Cannot find affected elements of Change");
@@ -1133,8 +1131,6 @@ namespace configmgr
         ApiTreeRef pRootTree( m_aNotifierData.second->getRootTreeImpl() );
 		if (pRootTree.is())
 		{
-			osl::ClearableMutexGuard aGuardRoot( pRootTree->getApiLock() );
-
 			NotifierHolder aRootNotifier = BroadcasterHelper::getImpl(pRootTree->getNotifier());
 			if (aRootNotifier.isValid())
 			{
@@ -1162,7 +1158,6 @@ namespace configmgr
 
 					// now notify
 					ListenerContainerIterator< css::util::XChangesListener > aIter(*pContainer);
-					aGuardRoot.clear();
 
 					while (aIter.hasMoreElements())
                         try { aIter.next()->changesOccurred(aEvent); } catch (uno::Exception & ) {}
Index: configmgr/source/api2/committer.cxx
===================================================================
RCS file: /cvs/util/configmgr/source/api2/committer.cxx,v
retrieving revision 1.16
retrieving revision 1.16.24.6
diff -u -p -u -p -r1.16 -r1.16.24.6
--- configmgr/source/api2/committer.cxx	16 Sep 2006 14:56:12 -0000	1.16
+++ configmgr/source/api2/committer.cxx	16 Jan 2007 12:18:18 -0000	1.16.24.6
@@ -47,9 +47,6 @@
 #ifndef CONFIGMGR_API_PROVIDERIMPL2_HXX_
 #include "confproviderimpl2.hxx"
 #endif
-#ifndef CONFIGMGR_UPDATEACCESSOR_HXX
-#include "updateaccessor.hxx"
-#endif
 #ifndef CONFIGMGR_TREEACCESSOR_HXX
 #include "treeaccessor.hxx"
 #endif
@@ -117,44 +114,31 @@ void Committer::commit()
 	ITreeManager* pUpdateProvider = getUpdateProvider();
 	OSL_ASSERT(pUpdateProvider);
 
-    memory::Segment * pCacheSegment = pUpdateProvider->getDataSegment(m_rTree.getLocation(),aOptions);
-    OSL_ASSERT(rApiTree.getSourceData() == pCacheSegment);
-
-    memory::UpdateAccessor aUpdateAccessor(pCacheSegment);
-    osl::ClearableMutexGuard aLocalGuard(rApiTree.getDataLock());
-
-    Tree aTree( aUpdateAccessor.accessor(), rApiTree.getTree());
-	if (!aTree.hasChanges()) return;	
+    Tree aTree( rApiTree.getTree());
+    if (!aTree.hasChanges()) return;	
 	
-	TreeChangeList	aChangeList(aOptions,
-								aTree.getRootPath(),
-								aTree.getAttributes(aTree.getRootNode()));	
-
-    aTree.unbind();
+    TreeChangeList	aChangeList(aOptions,
+				    aTree.getRootPath(),
+				    aTree.getAttributes(aTree.getRootNode()));	
 
     // now do the commit
 	CommitHelper	aHelper(rApiTree.getTree());
-	if (aHelper.prepareCommit(aUpdateAccessor.accessor(),aChangeList))
-	try
+	if (aHelper.prepareCommit(aChangeList))
+    try
 	{
-		pUpdateProvider->updateTree(aUpdateAccessor,aChangeList);
-
-		aHelper.finishCommit(aUpdateAccessor.accessor(),aChangeList);
-
-		aLocalGuard.clear();		// done locally
+        pUpdateProvider->updateTree(aChangeList);
 
-        data::Accessor aNotifyAccessor = aUpdateAccessor.downgrade(); // keep a read lock for notification
+        aHelper.finishCommit(aChangeList);
 
-		NotifyDisabler	aDisableNotify(m_rTree);	// do not notify self
-		pUpdateProvider->saveAndNotifyUpdate(aNotifyAccessor,aChangeList);
+        NotifyDisabler  aDisableNotify(m_rTree);        // do not notify self
+        pUpdateProvider->saveAndNotifyUpdate(aChangeList);
 	}
 	catch(...)
 	{
 		// should be a special clean-up routine, but for now we just need a consistent state
 		try
 		{
-//			aHelper.finishCommit(aChangeList);
-			aHelper.failedCommit(aUpdateAccessor.accessor(),aChangeList);
+			aHelper.failedCommit(aChangeList);
 		}
 		catch(configuration::Exception&)
 		{
Index: configmgr/source/api2/confignotifier.cxx
===================================================================
RCS file: /cvs/util/configmgr/source/api2/confignotifier.cxx,v
retrieving revision 1.9
retrieving revision 1.9.24.2
diff -u -p -u -p -r1.9 -r1.9.24.2
--- configmgr/source/api2/confignotifier.cxx	16 Sep 2006 14:56:25 -0000	1.9
+++ configmgr/source/api2/confignotifier.cxx	7 Feb 2007 12:00:30 -0000	1.9.24.2
@@ -87,12 +87,6 @@ Notifier::~Notifier()
 }
 // ---------------------------------------------------------------------------------------------------
 
-osl::Mutex&	 Notifier::getMutex() const
-{
-	return m_aImpl->mutex();
-}
-// ---------------------------------------------------------------------------------------------------
-
 Broadcaster Notifier::makeBroadcaster(NodeChange const& aChange, bool bLocal) const
 {
 	return Broadcaster(*this,aChange,bLocal);
@@ -107,8 +101,7 @@ Broadcaster Notifier::makeBroadcaster(No
 // ---------------------------------------------------------------------------------------------------
 
 NotifierImpl::NotifierImpl(configuration::TreeRef const& aTree)
-: m_aMutex()
-, m_aListeners(m_aMutex, aTree.getContainedInnerNodeCount(), SubNodeToIndex(aTree))
+: m_aListeners(aTree.getContainedInnerNodeCount(), SubNodeToIndex(aTree))
 {
 }
 // ---------------------------------------------------------------------------------------------------
@@ -245,14 +238,12 @@ void Notifier::remove(NodeRef const& aNo
 // ---------------------------------------------------------------------------------------------------
 // ---------------------------------------------------------------------------------------------------
 
-DisposeGuardImpl::DisposeGuardImpl(NotifierImpl& rNotifierImpl) throw()
-: m_aLock(rNotifierImpl.mutex())
+DisposeGuardImpl::DisposeGuardImpl(NotifierImpl&) throw()
 {
 }
 // ---------------------------------------------------------------------------------------------------
 
-DisposeGuardImpl::DisposeGuardImpl(Notifier const& rNotifier) throw()
-: m_aLock(rNotifier.getMutex())
+DisposeGuardImpl::DisposeGuardImpl(Notifier const&) throw()
 {
 }
 // ---------------------------------------------------------------------------------------------------
Index: configmgr/source/api2/confignotifier.hxx
===================================================================
RCS file: /cvs/util/configmgr/source/api2/confignotifier.hxx,v
retrieving revision 1.8
retrieving revision 1.8.84.3
diff -u -p -u -p -r1.8 -r1.8.84.3
--- configmgr/source/api2/confignotifier.hxx	8 Sep 2005 03:11:25 -0000	1.8
+++ configmgr/source/api2/confignotifier.hxx	16 Jan 2007 12:18:18 -0000	1.8.84.3
@@ -125,11 +125,6 @@ namespace configmgr
 			Broadcaster makeBroadcaster(NodeChanges const& aChange, bool bLocal) const;		
 
 		// ---------------------------------------------------------------------------------------------------
-			osl::Mutex&			getMutex() const;
-			//configuration::Tree getTree() const { return m_aTree; }
-			//NotifierImpl&		getImpl() const { return m_aImpl.getBody(); }
-
-		// ---------------------------------------------------------------------------------------------------
 			bool checkAlive(uno::XInterface* pObject) const throw(css::lang::DisposedException);
 			
 		// ---------------------------------------------------------------------------------------------------
@@ -199,7 +194,6 @@ namespace configmgr
 		///  guards a NodeAccess; provides a simple lock for non-data access, does not check for disposed state
 		class DisposeGuardImpl : Noncopyable
 		{
-			osl::MutexGuard m_aLock;
 		public:
 			DisposeGuardImpl(NotifierImpl& rNotifierImpl) throw();
 			DisposeGuardImpl(Notifier const& rNotifier) throw();
@@ -209,6 +203,7 @@ namespace configmgr
 		/// wraps a Notifier (from a node or tree); provides a simple lock for notifier access, does not check for disposed state
 		class GuardedNotifier
 		{	
+            UnoApiLock          m_aLock;
 			Notifier			m_aNotifier;
 			DisposeGuardImpl	m_aImpl;
 		public:
@@ -226,6 +221,7 @@ namespace configmgr
 		class DisposeGuard
 		{
 			DisposeGuardImpl	m_aImpl;
+            UnoApiLock          m_aLock;
 		public:
 			DisposeGuard(NodeAccess& rNode) throw(css::lang::DisposedException);
 			DisposeGuard(TreeElement& rTree) throw(css::lang::DisposedException);
Index: configmgr/source/api2/confprovider2.cxx
===================================================================
RCS file: /cvs/util/configmgr/source/api2/confprovider2.cxx,v
retrieving revision 1.31
retrieving revision 1.31.24.1
diff -u -p -u -p -r1.31 -r1.31.24.1
--- configmgr/source/api2/confprovider2.cxx	16 Sep 2006 14:56:39 -0000	1.31
+++ configmgr/source/api2/confprovider2.cxx	11 Jan 2007 10:35:25 -0000	1.31.24.1
@@ -348,6 +348,7 @@ namespace configmgr
 	uno::Reference< uno::XInterface > SAL_CALL OConfigurationProvider::createInstance( const OUString& aServiceSpecifier ) 
 		throw(uno::Exception, uno::RuntimeException)
 	{		
+        UnoApiLock aLock;
 		// same as creating with empty sequence of arguments
 		return this->createInstanceWithArguments( aServiceSpecifier, uno::Sequence< uno::Any >() );
 	}
@@ -357,6 +358,8 @@ namespace configmgr
 		OConfigurationProvider::createInstanceWithArguments( const OUString& aServiceSpecifier, const uno::Sequence< uno::Any >& aArguments ) 
 			throw(uno::Exception, uno::RuntimeException)
 	{
+        UnoApiLock aLock;
+
 		OSL_ENSURE(m_pImpl, "OConfigurationProvider: no implementation available");
 		
 		if (ServiceCreationInfo const* pInfo = findCreationInfo(aServiceSpecifier))
@@ -379,6 +382,8 @@ namespace configmgr
 	uno::Sequence< OUString > SAL_CALL OConfigurationProvider::getAvailableServiceNames(  ) 
 		throw(uno::RuntimeException)
 	{
+        UnoApiLock aLock;
+
 		sal_Int32 nCount = 0;
 		{
 			for (int i= 0; i< getCreateServiceDataCount(); ++i)
@@ -414,15 +419,19 @@ namespace configmgr
     void SAL_CALL OConfigurationProvider::setLocale( const lang::Locale& eLocale ) 
         throw (uno::RuntimeException)
     {
+        UnoApiLock aLock;
+
 		OSL_ENSURE(m_pImpl, "OConfigurationProvider: no implementation available");
 
         m_pImpl->setDefaultLocale( eLocale );
     }
 
 	//-----------------------------------------------------------------------------
-    lang::Locale SAL_CALL OConfigurationProvider::getLocale(  ) 
+    lang::Locale SAL_CALL OConfigurationProvider::getLocale()
         throw (uno::RuntimeException)
     {
+        UnoApiLock aLock;
+
 		OSL_ENSURE(m_pImpl, "OConfigurationProvider: no implementation available");
         
         return m_pImpl->getDefaultOptions().getUnoLocale();
@@ -430,9 +439,11 @@ namespace configmgr
     
     //XRefreshable
     //-----------------------------------------------------------------------------
-	 void SAL_CALL OConfigurationProvider::refresh(  ) 
-                throw (uno::RuntimeException)
+    void SAL_CALL OConfigurationProvider::refresh()
+        throw (uno::RuntimeException)
      {
+        UnoApiLock aLock;
+
         OSL_ENSURE(m_pImpl, "OConfigurationProvider: no implementation available");
         
         try
@@ -471,20 +482,23 @@ namespace configmgr
          const uno::Reference< util::XRefreshListener >& aListener ) 
             throw (uno::RuntimeException)
      {
-         getBroadcastHelper().addListener(::getCppuType(&aListener), aListener);
+        UnoApiLock aLock;
+        getBroadcastHelper().addListener(::getCppuType(&aListener), aListener);
      }
      //-----------------------------------------------------------------------------
      void SAL_CALL OConfigurationProvider::removeRefreshListener( 
          const uno::Reference< util::XRefreshListener >& aListener ) 
             throw (uno::RuntimeException)
      {
-         getBroadcastHelper().removeListener(::getCppuType(&aListener), aListener);
+        UnoApiLock aLock;
+        getBroadcastHelper().removeListener(::getCppuType(&aListener), aListener);
      }
      //XFlushable
      //-----------------------------------------------------------------------------
 	 void SAL_CALL OConfigurationProvider::flush(  ) 
                 throw (uno::RuntimeException)
      {
+         UnoApiLock aLock;
          OSL_ENSURE(m_pImpl, "OConfigurationProvider: no implementation available");
          m_pImpl->flushAll();
 
@@ -514,6 +528,7 @@ namespace configmgr
          const uno::Reference< util::XFlushListener >& aListener ) 
             throw (uno::RuntimeException)
      {
+          UnoApiLock aLock;
           getBroadcastHelper().addListener(::getCppuType(&aListener), aListener);
      }
      //-----------------------------------------------------------------------------
@@ -521,13 +536,14 @@ namespace configmgr
          const uno::Reference< util::XFlushListener >& aListener ) 
             throw (uno::RuntimeException)
      {
+         UnoApiLock aLock;
          getBroadcastHelper().removeListener(::getCppuType(&aListener), aListener);
      }
     // XInterface
 	//-----------------------------------------------------------------------------
 	::com::sun::star::uno::Any SAL_CALL OConfigurationProvider::queryInterface( const ::com::sun::star::uno::Type & rType ) throw(::com::sun::star::uno::RuntimeException)
 	{
-		
+        UnoApiLock aLock;
 		uno::Any aRet( OProvider::queryInterface(rType) );
 		if ( !aRet.hasValue() )
 			aRet = queryPropertyInterface(rType);
@@ -549,6 +565,7 @@ namespace configmgr
 	// -------------------------------------------------------------------------
 	::cppu::IPropertyArrayHelper* OConfigurationProvider::createArrayHelper( ) const
 	{
+        UnoApiLock aLock;
 		uno::Sequence< beans::Property > aProps;
 		describeProperties(aProps);
 		return new ::cppu::OPropertyArrayHelper(aProps);
@@ -556,6 +573,7 @@ namespace configmgr
 	// -------------------------------------------------------------------------
 	::cppu::IPropertyArrayHelper & OConfigurationProvider::getInfoHelper()
 	{
+        UnoApiLock aLock;
 		return *const_cast<OConfigurationProvider*>(this)->getArrayHelper();
 	}
 
@@ -565,9 +583,10 @@ namespace configmgr
     void SAL_CALL OConfigurationProvider::setFastPropertyValue_NoBroadcast(	sal_Int32 nHandle, const ::com::sun::star::uno::Any& rValue)
 												 throw (::com::sun::star::uno::Exception)
 	{
+        UnoApiLock aLock;
+
 		OProvider::setFastPropertyValue_NoBroadcast( nHandle, rValue );
-		
-		
+
         switch(nHandle)
         {
             case ID_PREFETCH:
Index: configmgr/source/api2/elementaccess.cxx
===================================================================
RCS file: /cvs/util/configmgr/source/api2/elementaccess.cxx,v
retrieving revision 1.6
retrieving revision 1.6.24.1
diff -u -p -u -p -r1.6 -r1.6.24.1
--- configmgr/source/api2/elementaccess.cxx	16 Sep 2006 14:57:07 -0000	1.6
+++ configmgr/source/api2/elementaccess.cxx	11 Jan 2007 20:15:58 -0000	1.6.24.1
@@ -65,43 +65,41 @@ void SAL_CALL BasicRootElement	::acquire
 void SAL_CALL BasicUpdateElement::acquire() throw() { BaseImplHelper::acquire(); }
 //-----------------------------------------------------------------------------------
 
+// FIXME: this looks highly flaky wrt. weak-refs etc.
+#define LOCKED_RELEASE \
+    bool bLastRef = (1 == m_refCount); \
+    if (bLastRef) \
+    { \
+        UnoApiLock::acquire(); \
+		configapi::implDisposeObject( getNodeAccess(), getElementClass() ); \
+    } \
+	BaseImplHelper::release(); \
+    if (bLastRef) \
+        UnoApiLock::release()
+
+    
+
 void SAL_CALL BasicInnerElement::release() throw() 
 {
-	if (1 == m_refCount)
-	{
-		configapi::implDisposeObject( getNodeAccess(), getElementClass() );
-	} 
-	BaseImplHelper::release();
+    LOCKED_RELEASE;
 }
 //-----------------------------------------------------------------------------------
 
 void SAL_CALL BasicSetElement::release() throw() 
 {
-	if (1 == m_refCount)
-	{
-		configapi::implDisposeObject( getNodeAccess(), getElementClass() );
-	} 
-	BaseImplHelper::release();
+    LOCKED_RELEASE;
 }
 //-----------------------------------------------------------------------------------
 
 void SAL_CALL BasicRootElement::release() throw() 
 {
-	if (1 == m_refCount)
-	{
-		configapi::implDisposeObject( getNodeAccess(), getElementClass() );
-	} 
-	BaseImplHelper::release();
+    LOCKED_RELEASE;
 }
 //-----------------------------------------------------------------------------------
 
 void SAL_CALL BasicUpdateElement::release() throw() 
 {
-	if (1 == m_refCount)
-	{
-		configapi::implDisposeObject( getNodeAccess(), getElementClass() );
-	} 
-	BaseImplHelper::release();
+    LOCKED_RELEASE;
 }
 //-----------------------------------------------------------------------------------
 
Index: configmgr/source/api2/elementimpl.cxx
===================================================================
RCS file: /cvs/util/configmgr/source/api2/elementimpl.cxx,v
retrieving revision 1.15
retrieving revision 1.15.24.1
diff -u -p -u -p -r1.15 -r1.15.24.1
--- configmgr/source/api2/elementimpl.cxx	16 Sep 2006 14:57:21 -0000	1.15
+++ configmgr/source/api2/elementimpl.cxx	11 Jan 2007 10:35:25 -0000	1.15.24.1
@@ -200,6 +200,8 @@ Reference< uno::XInterface > implGetPare
 void implSetParent(NodeAccess& rNode, InnerElement& /*rElement*/, const Reference< uno::XInterface >& /*xParent*/ ) 
 	throw(NoSupportException, RuntimeException)
 {
+    UnoApiLock aLock;
+
 	rNode.checkAlive(); // Does locking internally, checks for disposed nodes
 
 	// TODO(?): allow for xParent == getParent()
@@ -213,6 +215,8 @@ void implSetParent(NodeAccess& rNode, In
 void implSetParent(NodeAccess& rNode, SetElement& rElement, const Reference< uno::XInterface >& xParent ) 
 	throw(NoSupportException, RuntimeException)
 {
+    UnoApiLock aLock;
+
 	//implSetParent(rNode,xParent);
 	// TODO: lock the whole transaction ???? - would need Uno Tunneling ?
 	using css::container::XNameContainer;
@@ -335,6 +339,8 @@ OUString implGetName(NodeAccess& rNode, 
 // UNSUPPORTED method
 void implSetName(NodeAccess & rNode, NodeElement& /*rElement*/, const OUString& /*aName*/ ) throw(RuntimeException)
 {
+    UnoApiLock aLock;
+
 	typedef RuntimeException CantRenameException;
 
 	rNode.checkAlive(); // Does locking internally, checks for disposed nodes
@@ -349,6 +355,8 @@ void implSetName(NodeAccess & rNode, Nod
 // TODO: Implementations for elements to be added to a container node
 void implSetName(NodeAccess& rNode, SetElement& rElement, const OUString& aName ) throw(RuntimeException)
 {
+    UnoApiLock aLock;
+
 	// TODO: Implement
 	NodeElement& rDelegate = rElement;
 	implSetName(rNode,rDelegate,aName); // delegate to unsupported version
@@ -362,6 +370,8 @@ void implSetName(NodeAccess& rNode, SetE
 
 void implDispose( SetElement& rElement) throw(uno::RuntimeException)
 {
+    UnoApiLock aLock;
+
 	if (!rElement.disposeTree(false))
 	{
 		throw uno::RuntimeException( 
@@ -373,6 +383,8 @@ void implDispose( SetElement& rElement) 
 
 void implDispose( RootElement& rElement) throw(uno::RuntimeException)
 {
+    UnoApiLock aLock;
+
 	if (!rElement.disposeTree())
 	{
 		throw lang::DisposedException( 
@@ -384,18 +396,24 @@ void implDispose( RootElement& rElement)
 
 void implDisposeObject( NodeAccess& ,SetElement& rElement) throw(uno::RuntimeException)
 {
+    UnoApiLock aLock;
+
 	rElement.disposeTree(true);
 }
 //-----------------------------------------------------------------------------
 
 void implDisposeObject( NodeAccess& , RootElement& rElement) throw(uno::RuntimeException)
 {
+    UnoApiLock aLock;
+
 	rElement.disposeTree();
 }
 //-----------------------------------------------------------------------------
 
 void implDisposeObject( NodeAccess& rNode, InnerElement& ) throw(uno::RuntimeException)
 {
+    UnoApiLock aLock;
+
 	rNode.disposeNode();
 }
 //-----------------------------------------------------------------------------
@@ -468,6 +486,7 @@ lang::Locale implGetLocale( RootElement&
 
 void implSetLocale( RootElement& rElement, const css::lang::Locale& /*eLocale*/ ) throw(uno::RuntimeException)
 {
+    UnoApiLock aLock;
 	// TODO: Implement if possible
 	rElement.checkAlive();
 
@@ -484,6 +503,8 @@ void implSetLocale( RootElement& rElemen
 
 void implCommitChanges( UpdateRootElement& rElement ) throw(css::lang::WrappedTargetException, uno::RuntimeException)
 {
+    UnoApiLock aLock;
+
 	// quick check to avoid big locks for nothing (has its own locking)
 	if (!implHasPendingChanges(rElement)) return;
 
Index: configmgr/source/api2/listenercontainer.hxx
===================================================================
RCS file: /cvs/util/configmgr/source/api2/listenercontainer.hxx,v
retrieving revision 1.17
retrieving revision 1.17.84.3
diff -u -p -u -p -r1.17 -r1.17.84.3
--- configmgr/source/api2/listenercontainer.hxx	8 Sep 2005 03:15:31 -0000	1.17
+++ configmgr/source/api2/listenercontainer.hxx	16 Jan 2007 12:18:19 -0000	1.17.84.3
@@ -47,6 +47,10 @@
 #include <cppuhelper/interfacecontainer.hxx>
 #endif
 
+#ifndef CONFIGMGR_UTILITY_HXX_
+#include "utility.hxx"
+#endif
+
 #include <osl/diagnose.h>
 
 namespace configmgr
@@ -132,7 +136,6 @@ namespace configmgr
 			typedef typename BasicContainerHelperArray::size_type	Index;
 
 			typedef Key_ Key;
-            typedef typename KeyToIndex_::KeyFinder KeyFinder;
 			typedef cppu::OMultiTypeInterfaceContainerHelperVar< Key_,KeyHash_,KeyEq_ >	SpecialContainerHelper;
 			typedef cppu::OBroadcastHelperVar< SpecialContainerHelper, Key >			SpecialBroadcastHelper;
 			typedef std::vector<Key> KeyList;
@@ -140,13 +143,9 @@ namespace configmgr
 		public:
 			/**
 			 * Create a container of interface containers.
-			 *
-			 * @param rMutex	the mutex to protect multi thread access.
-			 *					The lifetime must be longer than the lifetime
-			 *					of this object.
 			 */
-			SpecialListenerContainer(osl::Mutex& rMutex, Index nCount, KeyToIndex_ aMapper)
-			: m_aSpecialHelper(rMutex)
+			SpecialListenerContainer(Index nCount, KeyToIndex_ aMapper)
+			: m_aSpecialHelper(UnoApiLock::getLock())
 			, m_aContainers(nCount)
 			, m_aMapper(aMapper)
 			, m_bDisposeLock(false)
@@ -155,12 +154,8 @@ namespace configmgr
 			~SpecialListenerContainer()
 			{
 				OSL_ENSURE(isDisposed(), "ERROR: Object was not disposed properly");
-				if (m_bDisposeLock) mutex().release();
 			}
 		public:
-			/// get the mutex thatthis object uses
-			osl::Mutex& mutex() const { return m_aSpecialHelper.rMutex; }
-
 			/**
 			 * check whether this is disposed or still alive
 			 * @param pObject
@@ -182,20 +177,17 @@ namespace configmgr
 			/// return whether the object is present in this container
 			bool isAvailable(Index nIndex)  const throw()
 			{
-				osl::MutexGuard aGuard(mutex());
 				return nIndex < m_aContainers.size() && m_aContainers[nIndex].pInterface;
 			}
 
 			Index getSize() const
 			{
-				osl::MutexGuard aGuard(mutex());
 				return m_aContainers.size();
 			}
 
 			/// return the interface associated with an index
 			void setObjectAt(Index nIndex, UnoInterface* pInterface)
 			{
-				osl::MutexGuard aGuard(mutex());
 				OSL_ENSURE( !isDisposed(), "object is disposed" );
 
 				if (isAlive())
@@ -216,7 +208,6 @@ namespace configmgr
 			/// return the interface associated with an index
 			UnoInterfaceRef getObjectAt(Index nIndex) const
 			{
-				osl::MutexGuard aGuard(mutex());
 				UnoInterfaceRef xRet( nIndex < m_aContainers.size() ? m_aContainers[nIndex].pInterface : 0 );
 				return xRet;
 			}
@@ -224,7 +215,6 @@ namespace configmgr
 			/// return the interface associated with an index
 			UnoInterfaceRef getObjectForKey(Key const& aKey ) const
 			{
-				osl::MutexGuard aGuard(mutex());
 				Index nIndex = m_aMapper.findIndexForKey(aKey);
 				UnoInterfaceRef xRet( nIndex < m_aContainers.size() ? m_aContainers[nIndex].pInterface : 0 );
 				return xRet;
@@ -234,17 +224,17 @@ namespace configmgr
 			 * Call disposing on all object in all the containers that
 			 * support XEventListener. Then clear the container.
 			 */
-			bool disposeAll(KeyFinder _aFinder) throw();
+			bool disposeAll() throw();
 
 			/**
 			 * Call disposing on all object in all the container for anIndex
 			 * and in the containers for the associated indices
 			 * support XEventListener. Then clear the container.
 			 */
-			bool disposeOne( KeyFinder _aFinder, Index anIndex ) throw();
+			bool disposeOne( Index anIndex ) throw();
 
 			/**
-			 * Start disposing this object, leave the mutex locked for dispose processing
+			 * Start disposing this object
 			 * @return <TRUE/>
 			 *		if disposing has been started
 			 * @return <FALSE/>
@@ -252,7 +242,7 @@ namespace configmgr
 			 */
 			bool beginDisposing() throw();
 			/**
-			 * Continue disposing this object leave the mutex unlocked
+			 * Continue disposing this object
 			 * <p>	Call disposing on all object in all the containers that
 			 *		support XEventListener. Then clear the container.
 			 * </p>
@@ -261,7 +251,7 @@ namespace configmgr
 			 * @return <FALSE/>
 			 *		if disposing had already been started before
 			 */
-			void notifyDisposing(KeyFinder _aFinder) throw();
+			void notifyDisposing() throw();
 
 			/// mark the end of the dispose processing
 			void endDisposing() throw();
@@ -282,7 +272,6 @@ namespace configmgr
 			 */
 			BasicContainerHelper *  getContainerHelper( Index nIndex) const
 			{
-				osl::MutexGuard aGuard(mutex());
 				return ((nIndex < m_aContainers.size()) ? m_aContainers[nIndex].pContainer : 0 );
 			}
 			/**
@@ -292,7 +281,6 @@ namespace configmgr
 			 */
 			ListenerContainer *  getContainer( Index nIndex, const UnoType & aType) const
 			{
-				osl::MutexGuard aGuard(mutex());
 				BasicContainerHelper* pContainer = (nIndex < m_aContainers.size()) ? m_aContainers[nIndex].pContainer : 0 ;
 
 				return pContainer ? pContainer->getContainer(aType) : 0;
@@ -338,7 +326,7 @@ namespace configmgr
 			sal_Int32 removeSpecialListener( const Key_& aKey, uno::Reference< lang::XEventListener > const& xListener) throw();
 
 		private:
-			void implFillDisposer(DisposeNotifier& aNotifier, KeyFinder _aFinder, Index nIndex);
+			void implFillDisposer(DisposeNotifier& aNotifier, Index nIndex);
 
 			SpecialBroadcastHelper		m_aSpecialHelper;
 			BasicContainerHelperArray	m_aContainers;
@@ -381,7 +369,7 @@ namespace configmgr
 		}
 //-----------------------------------------------------------------------------
 		template <class Key_, class KeyHash_, class KeyEq_, class KeyToIndex_>
-		bool SpecialListenerContainer<Key_,KeyHash_,KeyEq_, KeyToIndex_>::disposeAll(KeyFinder _aFinder) throw()
+		bool SpecialListenerContainer<Key_,KeyHash_,KeyEq_, KeyToIndex_>::disposeAll() throw()
 		{
 			if (beginDisposing())
 			{
@@ -394,12 +382,9 @@ namespace configmgr
 		}
 //-----------------------------------------------------------------------------
 		template <class Key_, class KeyHash_, class KeyEq_, class KeyToIndex_>
-		bool SpecialListenerContainer<Key_,KeyHash_,KeyEq_, KeyToIndex_>::disposeOne(KeyFinder _aFinder, Index nIndex) throw()
+		bool SpecialListenerContainer<Key_,KeyHash_,KeyEq_, KeyToIndex_>::disposeOne(Index nIndex) throw()
 		{
 	//		OSL_ENSURE(!isDisposed(),"Object is already disposed in toto");
-
-			osl::ClearableMutexGuard aGuard(mutex());
-
 			if (isAlive())
 			{
 				if (nIndex < m_aContainers.size())
@@ -408,12 +393,10 @@ namespace configmgr
 					{
 						DisposeNotifier aNotifier(pObject);
 
-						implFillDisposer(aNotifier, _aFinder, nIndex);
+						implFillDisposer(aNotifier, nIndex);
 						m_aContainers[nIndex].pInterface = 0;
 						delete m_aContainers[nIndex].pContainer;
 
-						aGuard.clear();
-
 						aNotifier.notify();
 					}
 				}
@@ -426,10 +409,8 @@ namespace configmgr
 		template <class Key_, class KeyHash_, class KeyEq_, class KeyToIndex_>
 		bool SpecialListenerContainer<Key_,KeyHash_,KeyEq_, KeyToIndex_>::beginDisposing() throw()
 		{
-			osl::MutexGuard aGuard( mutex() );
 			if (isAlive())
 			{
-				mutex().acquire();
 				m_aSpecialHelper.bInDispose = sal_True;
 				m_bDisposeLock = true;
 
@@ -439,7 +420,7 @@ namespace configmgr
 		}
 //-----------------------------------------------------------------------------
 		template <class Key_, class KeyHash_, class KeyEq_, class KeyToIndex_>
-        void SpecialListenerContainer<Key_,KeyHash_,KeyEq_, KeyToIndex_>::notifyDisposing(KeyFinder _aFinder) throw()
+        void SpecialListenerContainer<Key_,KeyHash_,KeyEq_, KeyToIndex_>::notifyDisposing() throw()
 		{
 			OSL_ENSURE(isDisposing(),"Disposing isn't in progress on this object");
 			OSL_ENSURE(m_bDisposeLock,"Duplicate call for dispose notification or disposing is not taking place");
@@ -461,7 +442,7 @@ namespace configmgr
 						if (m_aContainers[ix].pInterface)
 						{
 							aNotifiers.push_back(DisposeNotifier(m_aContainers[ix].pInterface));
-							implFillDisposer(aNotifiers.back(), _aFinder, ix);
+							implFillDisposer(aNotifiers.back(), ix);
 							m_aContainers[ix].pInterface = 0;
 							delete m_aContainers[ix].pContainer;
 						}
@@ -469,7 +450,6 @@ namespace configmgr
 				}
 
 				m_bDisposeLock = false;
-				mutex().release();
 
 				for(Index jx = 0, count = aNotifiers.size(); jx < count; ++jx)
 				{
@@ -495,7 +475,6 @@ namespace configmgr
 				if (m_bDisposeLock)
 				{
 					m_bDisposeLock = false;
-					mutex().release();
 				}
 			}
 		}
@@ -503,14 +482,12 @@ namespace configmgr
 		template <class Key_, class KeyHash_, class KeyEq_, class KeyToIndex_>
 		sal_Int32 SpecialListenerContainer<Key_,KeyHash_,KeyEq_, KeyToIndex_>::addListener( Index nIndex, const UnoType& aType, const uno::Reference< lang::XEventListener > & xListener ) throw()
 		{
-			osl::ClearableMutexGuard aGuard( mutex() );
-
 			if ( nIndex < m_aContainers.size() && m_aContainers[nIndex].pInterface  )
 			{
 			    if ( isAlive() )
 			    {
 					if (m_aContainers[nIndex].pContainer == 0)
-						m_aContainers[nIndex].pContainer = new BasicContainerHelper(mutex());
+						m_aContainers[nIndex].pContainer = new BasicContainerHelper(UnoApiLock::getLock());
 
 					return m_aContainers[nIndex].pContainer->addInterface(aType,xListener);
 				}
@@ -518,7 +495,6 @@ namespace configmgr
                 else if (xListener.is())
                 {
                     lang::EventObject aEvent(m_aContainers[nIndex].pInterface);
-                    aGuard.clear();
                     try { xListener->disposing(aEvent); } catch (uno::Exception & ) {}
                 }
 
@@ -532,8 +508,6 @@ namespace configmgr
 		template <class Key_, class KeyHash_, class KeyEq_, class KeyToIndex_>
 		sal_Int32 SpecialListenerContainer<Key_,KeyHash_,KeyEq_, KeyToIndex_>::addSpecialListener( const Key_& aKey, const uno::Reference< lang::XEventListener > & xListener ) throw()
 		{
-			osl::ClearableMutexGuard aGuard( mutex() );
-
 			Index nIndex = m_aMapper.findIndexForKey(aKey);
 			if ( nIndex < m_aContainers.size() && m_aContainers[nIndex].pInterface  )
 			{
@@ -545,7 +519,6 @@ namespace configmgr
                 else if (xListener.is())
                 {
                     lang::EventObject aEvent(m_aContainers[nIndex].pInterface);
-                    aGuard.clear();
                     try { xListener->disposing(aEvent); } catch (uno::Exception & ) {}
                 }
 			}
@@ -559,7 +532,6 @@ namespace configmgr
 		template <class Key_, class KeyHash_, class KeyEq_, class KeyToIndex_>
 		sal_Int32 SpecialListenerContainer<Key_,KeyHash_,KeyEq_, KeyToIndex_>::removeListener( Index nIndex, const UnoType& aType, const uno::Reference< lang::XEventListener > & xListener ) throw()
 		{
-			osl::MutexGuard aGuard( mutex() );
 			OSL_ENSURE( !isDisposed(), "object is disposed" );
 
 			if ( isAlive() )
@@ -576,7 +548,6 @@ namespace configmgr
 		template <class Key_, class KeyHash_, class KeyEq_, class KeyToIndex_>
 		sal_Int32 SpecialListenerContainer<Key_,KeyHash_,KeyEq_, KeyToIndex_>::removeSpecialListener( const Key_& aKey, const uno::Reference< lang::XEventListener > & xListener ) throw()
 		{
-			osl::MutexGuard aGuard( mutex() );
 			OSL_ENSURE( !isDisposed(), "object is disposed" );
 
 			if ( isAlive() )
@@ -605,7 +576,7 @@ namespace configmgr
 *///-----------------------------------------------------------------------------
 	// relation function. Uses KeyToIndex
 		template <class Key_, class KeyHash_, class KeyEq_, class KeyToIndex_>
-        void SpecialListenerContainer<Key_,KeyHash_,KeyEq_, KeyToIndex_>::implFillDisposer(DisposeNotifier& aNotifier, KeyFinder _aFinder, Index nIndex)
+        void SpecialListenerContainer<Key_,KeyHash_,KeyEq_, KeyToIndex_>::implFillDisposer(DisposeNotifier& aNotifier, Index nIndex)
 		{
 			if (BasicContainerHelper* pMultiContainer = m_aContainers[nIndex].pContainer)
 			{
@@ -619,7 +590,7 @@ namespace configmgr
 				}
 			}
 			KeyList aKeys;
-			if (m_aMapper.findKeysForIndex(_aFinder, nIndex,aKeys))
+			if (m_aMapper.findKeysForIndex(nIndex,aKeys))
 			{
 				for(typename KeyList::iterator it = aKeys.begin(); it != aKeys.end(); ++it)
 				{
Index: configmgr/source/api2/notifierimpl.hxx
===================================================================
RCS file: /cvs/util/configmgr/source/api2/notifierimpl.hxx,v
retrieving revision 1.8
retrieving revision 1.8.42.5
diff -u -p -u -p -r1.8 -r1.8.42.5
--- configmgr/source/api2/notifierimpl.hxx	19 Jun 2006 23:16:03 -0000	1.8
+++ configmgr/source/api2/notifierimpl.hxx	16 Jan 2007 12:18:19 -0000	1.8.42.5
@@ -51,7 +51,6 @@
 #include "propertiesfilterednotifier.hxx"
 
 #include <vos/refernce.hxx>
-#include <osl/mutex.hxx>
 
 namespace configmgr
 {
@@ -62,8 +61,6 @@ namespace configmgr
 		/// manages collections of event listeners observing a whole config tree, thread-safe
 		class NotifierImpl : public vos::OReference
 		{
-		private:
-			mutable osl::Mutex m_aMutex;
 		public:
 			typedef configuration::SubNodeID        SubNodeID;
 			typedef configuration::SubNodeIDList    SubNodeList;
@@ -80,17 +77,16 @@ namespace configmgr
 			};
 			struct SubNodeToIndex 
 			{  
-                typedef data::Accessor const & KeyFinder;
 				configuration::TreeRef aTree;
 
 				SubNodeToIndex( configuration::TreeRef const& rTree ) : aTree(rTree) {}
 
-                bool findKeysForIndex(KeyFinder _anAccessor, NodeOffset nNode, SubNodeList& aList)
+				bool findKeysForIndex(NodeOffset nNode, SubNodeList& aList)
 				{
-                    using configuration::getAllChildrenHelper;
-                    using configuration::findNodeFromIndex;
+					using configuration::getAllChildrenHelper;
+					using configuration::findNodeFromIndex;
 					aList.clear();
-					getAllChildrenHelper(_anAccessor,findNodeFromIndex(aTree,nNode), aList);
+					getAllChildrenHelper(findNodeFromIndex(aTree,nNode), aList);
 					return !aList.empty();
 				}
 				NodeOffset findIndexForKey(SubNodeID const& aNode)
@@ -108,9 +104,6 @@ namespace configmgr
 			explicit
 			NotifierImpl(configuration::TreeRef const& aTree);
 			~NotifierImpl();
-
-			/// retrieve the mutex that is used by this
-			osl::Mutex& mutex() const { return m_aMutex; }
 			
 			/// Add a <type scope='com::sun::star::lang'>XEventListener</type> observing <var>aNode</var>.
 			void add(NodeID const& aNode, uno::Reference< css::lang::XEventListener > const& xListener)
Index: configmgr/source/api2/objectregistry.hxx
===================================================================
RCS file: /cvs/util/configmgr/source/api2/objectregistry.hxx,v
retrieving revision 1.7
retrieving revision 1.7.84.1
diff -u -p -u -p -r1.7 -r1.7.84.1
--- configmgr/source/api2/objectregistry.hxx	8 Sep 2005 03:16:14 -0000	1.7
+++ configmgr/source/api2/objectregistry.hxx	11 Jan 2007 20:15:58 -0000	1.7.84.1
@@ -74,8 +74,6 @@ namespace configmgr
 			ObjectRegistry() {}
 			~ObjectRegistry();
 
-			osl::Mutex& mutex() const { return m_aMutex; }
-
 			Element	findElement(Key const& aNode) const
 			{
 				ObjectMap::const_iterator aFound = m_aMap.find(aNode);
@@ -101,7 +99,6 @@ namespace configmgr
 				}
 			}
 		private:
-			mutable osl::Mutex m_aMutex;
 			ObjectMap m_aMap;
 		};
 //-----------------------------------------------------------------------------
Index: configmgr/source/api2/propsetaccessimpl.cxx
===================================================================
RCS file: /cvs/util/configmgr/source/api2/propsetaccessimpl.cxx,v
retrieving revision 1.21
retrieving revision 1.21.24.4
diff -u -p -u -p -r1.21 -r1.21.24.4
--- configmgr/source/api2/propsetaccessimpl.cxx	16 Sep 2006 14:59:10 -0000	1.21
+++ configmgr/source/api2/propsetaccessimpl.cxx	12 Jan 2007 17:51:18 -0000	1.21.24.4
@@ -215,75 +215,7 @@ CollectProperties::Result CollectPropert
 
 	return CONTINUE;
 }
-//-----------------------------------------------------------------------------------
-// another helper class - disabled, as it doesn't work well with Accessor changes
-//-----------------------------------------------------------------------------------
-#if 0
-
-class TreeNodePropertySetInfo 
-	:public ::cppu::WeakImplHelper1< beans::XPropertySetInfo >
-{
-	configapi::NodeAccess&	m_rNodeAccess;
-	configuration::Tree 	m_aTree;
-	configuration::NodeRef	m_aNode;
-	sal_Bool				m_bReadonly;
-
-public:
-	TreeNodePropertySetInfo(NodeGroupInfoAccess& _rNode, sal_Bool _bReadonly )
-		:m_rNodeAccess(_rNode)
-		,m_aTree(_rNode.getTree())
-		,m_aNode(_rNode.getNode())
-		,m_bReadonly(_bReadonly)
-	{
-		// TODO: need to be a event listener on the node
-	}
-
-	// XPropertySetInfo
-	virtual Sequence< Property > SAL_CALL getProperties() throw(RuntimeException);
-    virtual Property SAL_CALL	getPropertyByName(const OUString& _rPropertyName) throw(UnknownPropertyException, RuntimeException);
-    virtual sal_Bool SAL_CALL	hasPropertyByName(const OUString& _rPropertyName) throw(RuntimeException);
-};
-
-//-----------------------------------------------------------------------------------
-uno::Sequence< beans::Property > SAL_CALL TreeNodePropertySetInfo::getProperties() throw(RuntimeException)
-{
-	OReadSynchronized aGuard(m_rNodeAccess.getDataLock());
-	return CollectProperties(m_bReadonly).forChildren(m_aTree, m_aNode);
-}
-
-//-----------------------------------------------------------------------------------
-Property SAL_CALL TreeNodePropertySetInfo::getPropertyByName(const OUString& _rPropertyName) 
-	throw(UnknownPropertyException, RuntimeException)
-{
-	OReadSynchronized aGuard(m_rNodeAccess.getDataLock());
-
-    Name aName = configuration::makeNodeName(_rPropertyName, Name::NoValidate());
-
-	if (!m_aTree.hasChild(m_aNode, aName))
-	{
-		OUString sMessage = OUString::createFromAscii("Configuration - ");
-		sMessage += OUString::createFromAscii("No Property named '");
-		sMessage += _rPropertyName;
-		sMessage += OUString::createFromAscii("' in this PropertySetInfo");
-		throw UnknownPropertyException(sMessage, static_cast<XPropertySetInfo*>(this));
-	}
 
-	AnyNodeRef aNode = m_aTree.getAnyChild(m_aNode, aName);
-	OSL_ENSURE(aNode.isValid(), "NodePropertySetInfo::getPropertyByName: got no node although hasChild returned TRUE!");
-	return CollectProperties(m_bReadonly, 1).forNode(m_aTree, aNode);
-}
-
-//-----------------------------------------------------------------------------------
-sal_Bool SAL_CALL TreeNodePropertySetInfo::hasPropertyByName(const OUString& _rPropertyName)
-	throw(RuntimeException)
-{
-	OReadSynchronized aGuard(m_rNodeAccess.getDataLock());
-
-    Name aName = configuration::makeNodeName(_rPropertyName, Name::NoValidate());
-
-	return m_aTree.hasChild(m_aNode, aName);
-}
-#endif
 //-----------------------------------------------------------------------------------
 // yet another helper class (more robust, but can't well be extended to be a HierarchicalPropertySetInfo though)
 //-----------------------------------------------------------------------------------
@@ -299,7 +231,7 @@ public:
 	{
 	}
 
-    static NodePropertySetInfo* create(NodeGroupInfoAccess& _rNode, data::Accessor const& _aDataAccessor, sal_Bool _bReadonly ) throw(RuntimeException);
+    static NodePropertySetInfo* create(NodeGroupInfoAccess& _rNode, sal_Bool _bReadonly ) throw(RuntimeException);
 	Property const* begin() const throw() { return m_aProperties.getConstArray(); }
 	Property const* end()   const throw() { return m_aProperties.getConstArray() + m_aProperties.getLength(); }
 
@@ -313,11 +245,11 @@ public:
 
 //-----------------------------------------------------------------------------------
 //-----------------------------------------------------------------------------------
-NodePropertySetInfo* NodePropertySetInfo::create(NodeGroupInfoAccess& _rNode, data::Accessor const& _aDataAccessor, sal_Bool _bReadonly ) throw(RuntimeException)
+NodePropertySetInfo* NodePropertySetInfo::create(NodeGroupInfoAccess& _rNode, sal_Bool _bReadonly ) throw(RuntimeException)
 {
-    osl::MutexGuard aGuard(_rNode.getDataLock());
+    UnoApiLock aLock;
 
-	configuration::Tree aTree( _rNode.getTree(_aDataAccessor) );
+	configuration::Tree aTree( _rNode.getTree() );
 	OSL_ENSURE( !aTree.isEmpty(), "WARNING: Getting Tree information requires a valid tree");
 	if (aTree.isEmpty()) return NULL;
 
@@ -362,6 +294,8 @@ uno::Sequence< beans::Property > SAL_CAL
 Property SAL_CALL NodePropertySetInfo::getPropertyByName(const OUString& _rPropertyName) 
 	throw(UnknownPropertyException, RuntimeException)
 {
+    UnoApiLock aLock;
+
 	Property const* pFound = find(_rPropertyName);
 
 	if (pFound == this->end())
@@ -380,6 +314,8 @@ Property SAL_CALL NodePropertySetInfo::g
 sal_Bool SAL_CALL NodePropertySetInfo::hasPropertyByName(const OUString& _rPropertyName)
 	throw(RuntimeException)
 {
+    UnoApiLock aLock;
+
 	Property const* pFound = find(_rPropertyName);
 
 	return (pFound != this->end());
@@ -398,7 +334,7 @@ Reference< beans::XPropertySetInfo > imp
 	throw(RuntimeException)
 {
 	GuardedNodeDataAccess lock( rNode );
-	return NodePropertySetInfo::create(rNode, lock.getDataAccessor(), !_bWriteable);
+	return NodePropertySetInfo::create(rNode, !_bWriteable);
 }
 
 // XHierarchicalPropertySet & XHierarchicalMultiPropertySet
Index: configmgr/source/api2/provider.cxx
===================================================================
RCS file: /cvs/util/configmgr/source/api2/provider.cxx,v
retrieving revision 1.17
retrieving revision 1.17.24.2
diff -u -p -u -p -r1.17 -r1.17.24.2
--- configmgr/source/api2/provider.cxx	16 Sep 2006 14:59:24 -0000	1.17
+++ configmgr/source/api2/provider.cxx	16 Jan 2007 12:18:19 -0000	1.17.24.2
@@ -66,7 +66,6 @@
 #ifndef _COM_SUN_STAR_LANG_XEVENTLISTENER_HPP_ 
 #include <com/sun/star/lang/XEventListener.hpp>
 #endif
-
 #define THISREF() static_cast< ::cppu::OWeakObject* >(this)
 
 namespace configmgr
@@ -122,6 +121,7 @@ namespace configmgr
 	//-----------------------------------------------------------------------------
     void OProvider::attachToContext()
     {
+        UnoApiLock aLock;
 		::osl::MutexGuard aGuard(ServiceComponentImpl::rBHelper.rMutex);
         OSL_ASSERT(!m_xDisposeListener.is());
 		if (m_xContext.is())
@@ -142,6 +142,7 @@ namespace configmgr
 	//-----------------------------------------------------------------------------
     uno::Reference< lang::XComponent > OProvider::releaseContext()
 	{		
+        UnoApiLock aLock;
 		::osl::MutexGuard aGuard(ServiceComponentImpl::rBHelper.rMutex);
         
 		uno::Reference< lang::XComponent > xContextComp(m_xContext, uno::UNO_QUERY);	
@@ -170,6 +171,7 @@ namespace configmgr
 
     void OProvider::discardContext(uno::Reference< lang::XComponent > const & xContext)
     {
+        UnoApiLock aLock;
         if (xContext.is())
         {
             uno::Reference< uno::XComponentContext > xCC(xContext,uno::UNO_QUERY);
@@ -201,6 +203,7 @@ namespace configmgr
 	//-----------------------------------------------------------------------------
 	uno::Any SAL_CALL OProvider::queryInterface(uno::Type const& rType) throw(uno::RuntimeException) 
 	{
+        UnoApiLock aLock;
 		uno::Any aRet( ServiceComponentImpl::queryInterface(rType) );
 		if ( !aRet.hasValue() )
 			aRet = OProvider_Base::queryInterface(rType);
@@ -210,6 +213,7 @@ namespace configmgr
 	//-----------------------------------------------------------------------------
 	void OProvider::implConnect(OProviderImpl& _rFreshProviderImpl, const ContextReader& _rSettings) throw(uno::Exception)
 	{
+        UnoApiLock aLock;
 		if (!_rFreshProviderImpl.initSession(_rSettings))
             throw uno::Exception(::rtl::OUString::createFromAscii("Could not connect to the configuration. Please check your settings."), THISREF() );
     }
@@ -217,6 +221,7 @@ namespace configmgr
 	//-----------------------------------------------------------------------------
        void SAL_CALL OProvider::disposing(com::sun::star::lang::EventObject const& /*rEvt*/) throw()
 	{	
+        UnoApiLock aLock;
         releaseContext();
 		this->dispose();		
 	}
@@ -224,6 +229,7 @@ namespace configmgr
 	//-----------------------------------------------------------------------------
 	void SAL_CALL OProvider::disposing()
 	{		
+        UnoApiLock aLock;
         uno::Reference< lang::XComponent > xComp = releaseContext();
 		
 		ServiceComponentImpl::disposing();	
Index: configmgr/source/api2/providerimpl.cxx
===================================================================
RCS file: /cvs/util/configmgr/source/api2/providerimpl.cxx,v
retrieving revision 1.66
retrieving revision 1.65.14.5
diff -u -p -u -p -r1.66 -r1.65.14.5
--- configmgr/source/api2/providerimpl.cxx	21 Nov 2006 17:23:20 -0000	1.66
+++ configmgr/source/api2/providerimpl.cxx	7 Feb 2007 11:44:42 -0000	1.65.14.5
@@ -366,6 +366,7 @@ namespace configmgr
 	//-----------------------------------------------------------------------------
 	OProviderImpl::~OProviderImpl()
 	{	
+        UnoApiLock aLock; // hmm...
 		clearTreeManager();
 
         delete m_pNewProviders;		
@@ -423,13 +424,12 @@ namespace configmgr
                                                     RequestOptions const & _aOptions
 											      ) CFG_UNO_THROW_ALL(  )
 	{
-        rtl::Reference< TreeManager > xTreeManager = getTreeManager();
+	    rtl::Reference< TreeManager > xTreeManager = getTreeManager();
 
-        data::NodeAccess aTree = data::NodeAccess::emptyNode();
-		try
-		{
+        data::NodeAccess aTree( NULL );
+	    try
+	    {
 	        aTree = xTreeManager->requestSubtree(aSubtreePath, _aOptions);
-
 		}
 		catch(uno::Exception&e)
 		{
@@ -454,9 +454,9 @@ namespace configmgr
 	}
 
 	//-----------------------------------------------------------------------------
-	void OProviderImpl::updateTree(memory::UpdateAccessor& _aAccessToken, TreeChangeList& aChanges) CFG_UNO_THROW_ALL(  )
+	void OProviderImpl::updateTree(TreeChangeList& aChanges) CFG_UNO_THROW_ALL(  )
 	{
-		getTreeManager()->updateTree(_aAccessToken, aChanges);
+		getTreeManager()->updateTree(aChanges);
 	}	
 	
 	//-----------------------------------------------------------------------------
@@ -476,9 +476,9 @@ namespace configmgr
 	}
 
 	//-----------------------------------------------------------------------------
-	void OProviderImpl::saveAndNotifyUpdate(data::Accessor const& _aChangedDataAccessor, TreeChangeList const& aChanges) CFG_UNO_THROW_ALL(  )
+	void OProviderImpl::saveAndNotifyUpdate(TreeChangeList const& aChanges) CFG_UNO_THROW_ALL(  )
 	{
-		getTreeManager()->saveAndNotifyUpdate(_aChangedDataAccessor,aChanges);
+		getTreeManager()->saveAndNotifyUpdate(aChanges);
 	}
 
 	//-----------------------------------------------------------------------------
@@ -490,9 +490,9 @@ namespace configmgr
 	}
 
 	//-----------------------------------------------------------------------------
-	sal_Bool OProviderImpl::fetchDefaultData(memory::UpdateAccessor& _aAccessToken, AbsolutePath const& aSubtreePath, RequestOptions const& _aOptions) CFG_UNO_THROW_ALL(  )
+	sal_Bool OProviderImpl::fetchDefaultData(AbsolutePath const& aSubtreePath, RequestOptions const& _aOptions) CFG_UNO_THROW_ALL(  )
 	{
-		return getTreeManager()->fetchDefaultData(_aAccessToken, aSubtreePath, _aOptions);
+		return getTreeManager()->fetchDefaultData(aSubtreePath, _aOptions);
 	}
     //-----------------------------------------------------------------------------------
 	void OProviderImpl::refreshAll()CFG_UNO_THROW_ALL(  )
@@ -528,12 +528,6 @@ namespace configmgr
 		return static_cast<com::sun::star::lang::XMultiServiceFactory*>(m_pProvider);
 	}
 
-	//-----------------------------------------------------------------------------
-	memory::Segment* OProviderImpl::getDataSegment(AbsolutePath const& _rAccessor, RequestOptions const& _aOptions)
-	{ 
-		return getTreeManager()->getDataSegment(_rAccessor, _aOptions); 
-	}
-
 	//-----------------------------------------------------------------------------------
 	OUString OProviderImpl::getErrorMessage(AbsolutePath const& _rAccessor, RequestOptions const& _aOptions)
 	{
@@ -590,8 +584,7 @@ namespace configmgr
 	        RTL_LOGFILE_CONTEXT_AUTHOR(aLog2, "configmgr::OProviderImpl", "jb99855", "configmgr: createReadOnlyTree()");
 
 		    RootTree aRootTree( createReadOnlyTree(
-                    aAccessorPath, this->getDataSegment(aAccessorPath,_aOptions),
-				    aTree, nDepth, 
+                    aAccessorPath, aTree, nDepth, 
 				    TemplateProvider( this->getTemplateProvider(), _aOptions )
 			    ));
 
@@ -632,8 +625,7 @@ namespace configmgr
 	        RTL_LOGFILE_CONTEXT_AUTHOR(aLog2, "configmgr::OProviderImpl", "jb99855", "createUpdatableTree()");
 
 		    RootTree aRootTree( createUpdatableTree(
-                                    aAccessorPath, this->getDataSegment(aAccessorPath,_aOptions),
-								    aTree, nDepth, 
+                                    aAccessorPath, aTree, nDepth, 
 								    TemplateProvider( this->getTemplateProvider(), _aOptions )
 							    ));
 		    
@@ -908,6 +900,8 @@ namespace configmgr
 														RequestOptions & /* [in/out] */ _aOptions ) 
 		CFG_THROW1 (lang::IllegalArgumentException) 
 	{
+        UnoApiLock aLock;
+
 		_nLevels = treeop::ALL_LEVELS; // setting a fallback
 
 		// the args have to be a sequence of property or named values
Index: configmgr/source/api2/providerimpl.hxx
===================================================================
RCS file: /cvs/util/configmgr/source/api2/providerimpl.hxx,v
retrieving revision 1.18
retrieving revision 1.18.84.3
diff -u -p -u -p -r1.18 -r1.18.84.3
--- configmgr/source/api2/providerimpl.hxx	8 Sep 2005 03:19:47 -0000	1.18
+++ configmgr/source/api2/providerimpl.hxx	16 Jan 2007 12:18:19 -0000	1.18.84.3
@@ -203,12 +203,11 @@ namespace configmgr
         virtual ~OProviderImpl();
 
         /// ITreeManager
-        virtual memory::Segment* getDataSegment(AbsolutePath const& _rAccessor, const RequestOptions& _aOptions);
         virtual data::NodeAccess requestSubtree(AbsolutePath const& aSubtreePath, const RequestOptions& _aOptions) CFG_UNO_THROW_ALL(  );
-        virtual void updateTree(memory::UpdateAccessor& _aAccessToken, TreeChangeList& aChanges) CFG_UNO_THROW_ALL(  );       
+        virtual void updateTree(TreeChangeList& aChanges) CFG_UNO_THROW_ALL(  );       
 
         virtual void releaseSubtree( AbsolutePath const& aSubtreePath, const RequestOptions& _aOptions ) CFG_NOTHROW();
-        virtual void saveAndNotifyUpdate(memory::Accessor const& _aChangedDataAccessor, TreeChangeList const& aChanges) CFG_UNO_THROW_ALL(  );
+        virtual void saveAndNotifyUpdate(TreeChangeList const& aChanges) CFG_UNO_THROW_ALL(  );
         virtual void disposeData(const RequestOptions& _aOptions) CFG_NOTHROW();
         virtual void fetchSubtree(AbsolutePath const& aSubtreePath, const RequestOptions& _aOptions) CFG_NOTHROW();
         
@@ -217,8 +216,7 @@ namespace configmgr
         virtual void enableAsync(const sal_Bool& bEnableAsync) CFG_NOTHROW();
 
         /// IDefaultableTreeManager
-        virtual sal_Bool fetchDefaultData(  memory::UpdateAccessor& _aAccessToken, 
-                                            AbsolutePath const& aSubtreePath, const RequestOptions& _aOptions
+        virtual sal_Bool fetchDefaultData(AbsolutePath const& aSubtreePath, const RequestOptions& _aOptions
                                           ) CFG_UNO_THROW_ALL(  );
 
         // IInterface 
Index: configmgr/source/api2/translatechanges.cxx
===================================================================
RCS file: /cvs/util/configmgr/source/api2/translatechanges.cxx,v
retrieving revision 1.10
retrieving revision 1.10.24.3
diff -u -p -u -p -r1.10 -r1.10.24.3
--- configmgr/source/api2/translatechanges.cxx	16 Sep 2006 15:00:31 -0000	1.10
+++ configmgr/source/api2/translatechanges.cxx	12 Jan 2007 17:51:18 -0000	1.10.24.3
@@ -93,13 +93,13 @@ bool resolveChangeLocation(RelativePath&
 }
 bool resolveChangeLocation(RelativePath& aPath, NodeChangeLocation const& aChange, Tree const& aBaseTree, NodeRef const& aBaseNode)
 {
-	OSL_ENSURE(aChange.isValidLocation(aBaseTree.getDataAccessor()), "Trying to resolve against change location that wasn't set up properly");
+	OSL_ENSURE(aChange.isValidLocation(), "Trying to resolve against change location that wasn't set up properly");
 
     namespace Path = configuration::Path;
 
 	typedef Path::Iterator Iter;
 
-	Tree aChangeBaseTree = aChange.getBaseTree(aBaseTree.getDataAccessor());
+	Tree aChangeBaseTree = aChange.getBaseTree();
 
 	AbsolutePath aOuterBasePath		= aBaseTree.getAbsolutePath(aBaseNode);
 	AbsolutePath aChangeBasePath	= aChangeBaseTree.getAbsolutePath(aChange.getBaseNode());
@@ -154,18 +154,18 @@ bool resolveChangeLocation(RelativePath&
 
 // ---------------------------------------------------------------------------------------------------
 // change path and base settings to start from the given base
-bool rebaseChange(data::Accessor const& _aAccessor, NodeChangeLocation& aChange, TreeRef const& _aBaseTreeRef)
+bool rebaseChange(NodeChangeLocation& aChange, TreeRef const& _aBaseTreeRef)
 {
-	return rebaseChange(_aAccessor, aChange,_aBaseTreeRef,_aBaseTreeRef.getRootNode());
+	return rebaseChange(aChange,_aBaseTreeRef,_aBaseTreeRef.getRootNode());
 }
-bool rebaseChange(data::Accessor const& _aAccessor, NodeChangeLocation& aChange, TreeRef const& _aBaseTreeRef, NodeRef const& aBaseNode)
+bool rebaseChange(NodeChangeLocation& aChange, TreeRef const& _aBaseTreeRef, NodeRef const& aBaseNode)
 {
-	OSL_ENSURE(aChange.isValidLocation(_aAccessor), "Trying to rebase change location that wasn't set up properly");
+	OSL_ENSURE(aChange.isValidLocation(), "Trying to rebase change location that wasn't set up properly");
 
-    Tree aBaseTree(_aAccessor,_aBaseTreeRef);
+    Tree aBaseTree(_aBaseTreeRef);
 
 	RelativePath aNewPath;
-	if (resolveChangeLocation(aNewPath,aChange,aBaseTree, aBaseNode))
+	if (resolveChangeLocation(aNewPath,aChange,aBaseTree,aBaseNode))
 	{
 		aChange.setBase( aBaseTree, aBaseNode);
 		aChange.setAccessor( aNewPath );
@@ -177,7 +177,7 @@ bool rebaseChange(data::Accessor const& 
 // ---------------------------------------------------------------------------------------------------
 // resolve non-uno elements to Uno Objects
 bool resolveUnoObjects(UnoChange& aUnoChange, NodeChangeData const& aChange, 
-    const memory::Accessor& aAccessor, Factory& rFactory)
+                       Factory& rFactory)
 {
 	if (aChange.isSetChange())
 	{
@@ -195,8 +195,8 @@ bool resolveUnoObjects(UnoChange& aUnoCh
 
         //Check if complex or simple type
         Tree aTree = aChange.isRemoveSetChange()?
-            aChange.getOldElementTree(aAccessor):
-            aChange.getNewElementTree(aAccessor);
+            aChange.getOldElementTree():
+            aChange.getNewElementTree();
         
         NodeRef aNodeRef = aTree.getRootNode();
         
@@ -216,7 +216,7 @@ bool resolveUnoObjects(UnoChange& aUnoCh
             
             if (aChange.isReplaceSetChange() )
             {
-                Tree aOldTree = aChange.getOldElementTree(aAccessor);
+                Tree aOldTree = aChange.getOldElementTree();
             
                 aNodeRef = aOldTree.getRootNode();
                 OSL_ENSURE(!configuration::isStructuralNode(aOldTree, aNodeRef), "resolveUnoObject types mismatch"); 
@@ -239,10 +239,10 @@ bool resolveUnoObjects(UnoChange& aUnoCh
 }
 // ---------------------------------------------------------------------------------------------------
 // resolve non-uno elements to Uno Objects inplace
-bool resolveToUno(NodeChangeData& aChange, const memory::Accessor& aAccessor, Factory& rFactory)
+bool resolveToUno(NodeChangeData& aChange, Factory& rFactory)
 {
 	struct UnoChange aUnoChange;
-	if (resolveUnoObjects(aUnoChange,aChange, aAccessor, rFactory))
+	if (resolveUnoObjects(aUnoChange,aChange, rFactory))
 	{
 		aChange.unoData.newValue = aUnoChange.newValue;
 		aChange.unoData.oldValue = aUnoChange.oldValue;
@@ -275,7 +275,7 @@ void fillChange(util::ElementChange& rCh
 
 	UnoChange aUnoChange;
 
-    if (!resolveUnoObjects(aUnoChange, aInfo.change, aInfo.accessor, rFactory))
+    if (!resolveUnoObjects(aUnoChange, aInfo.change, rFactory))
 		OSL_ENSURE(false, "WARNING: Cannot find out old/new UNO objects involved in change");
 
 	rChange.Accessor		<<= aRelativePath.toString();
@@ -296,7 +296,7 @@ void fillChangeFromResolved(util::Elemen
 bool fillEventData(container::ContainerEvent& rEvent, NodeChangeInformation const& aInfo, Factory& rFactory)
 {
 	UnoChange aUnoChange;
-	if (!resolveUnoObjects(aUnoChange, aInfo.change, aInfo.accessor, rFactory))
+	if (!resolveUnoObjects(aUnoChange, aInfo.change, rFactory))
 	{
 		OSL_ENSURE(false, "WARNING: Cannot find out old/new UNO objects involved in change");
 		return false;
@@ -326,7 +326,7 @@ bool fillEventData(beans::PropertyChange
 		return false;
 
  	UnoChange aUnoChange;
-	if (!resolveUnoObjects(aUnoChange, aInfo.change, aInfo.accessor, rFactory))
+	if (!resolveUnoObjects(aUnoChange, aInfo.change, rFactory))
 		OSL_ENSURE(false, "WARNING: Cannot find out old/new UNO objects involved in change");
 
 	rEvent.PropertyName		= aInfo.location.getAccessor().getLocalName().getName().toString();
Index: configmgr/source/api2/translatechanges.hxx
===================================================================
RCS file: /cvs/util/configmgr/source/api2/translatechanges.hxx,v
retrieving revision 1.8
retrieving revision 1.8.84.1
diff -u -p -u -p -r1.8 -r1.8.84.1
--- configmgr/source/api2/translatechanges.hxx	8 Sep 2005 03:21:48 -0000	1.8
+++ configmgr/source/api2/translatechanges.hxx	12 Jan 2007 17:51:18 -0000	1.8.84.1
@@ -52,10 +52,6 @@ namespace configmgr
 	namespace beans		= css::beans;
 	namespace container	= css::container;
 // ---------------------------------------------------------------------------------------------------
-	namespace memory 
-	{
-        class Accessor;
-    }
 
 	namespace configuration 
 	{ 
@@ -92,22 +88,18 @@ namespace configmgr
 									configuration::NodeRef const& aBaseNode);
 
 		// change path and base settings to start from the given base tree (root)
-		bool rebaseChange(	memory::Accessor const& _aAccessor, 
-                            configuration::NodeChangeLocation& aChange, 
+		bool rebaseChange(	configuration::NodeChangeLocation& aChange, 
 							configuration::TreeRef const& _aBaseTreeRef);
 		// change path and base settings to start from the given base node
-		bool rebaseChange(	memory::Accessor const& _aAccessor, 
-                            configuration::NodeChangeLocation& aChange, 
+		bool rebaseChange(	configuration::NodeChangeLocation& aChange, 
 							configuration::TreeRef const& _aBaseTreeRef, 
 							configuration::NodeRef const& aBaseNode);
 		// resolve non-uno elements to Uno Objects
 		bool resolveUnoObjects(UnoChange& aUnoChange, 
                                configuration::NodeChangeData const& aChange,
-                               const memory::Accessor& aAccessor,
                                Factory& rFactory);
 		// resolve non-uno elements to Uno Objects inplace
         bool resolveToUno(configuration::NodeChangeData& aChange,
-                          const memory::Accessor& aAccessor, 
                           Factory& rFactory);
 
 	// building events
Index: configmgr/source/api2/updateimpl.cxx
===================================================================
RCS file: /cvs/util/configmgr/source/api2/updateimpl.cxx,v
retrieving revision 1.13
retrieving revision 1.13.24.2
diff -u -p -u -p -r1.13 -r1.13.24.2
--- configmgr/source/api2/updateimpl.cxx	16 Sep 2006 15:00:59 -0000	1.13
+++ configmgr/source/api2/updateimpl.cxx	12 Jan 2007 17:51:19 -0000	1.13.24.2
@@ -242,7 +242,7 @@ void implReplaceByName(NodeTreeSetAccess
 			throw NoSuchElementException( sMessage, xContext );
 		}
 
-		ElementTree aElementTree = configapi::extractElementTree(rNode.getFactory(), rElement, rNode.getElementInfo(lock.getDataAccessor()) );
+		ElementTree aElementTree = configapi::extractElementTree(rNode.getFactory(), rElement, rNode.getElementInfo());
 		if (!aElementTree.isValid())
 		{
 		    OUString sMessage( RTL_CONSTASCII_USTRINGPARAM("Configuration - Cannot replace Set Element: ") );
@@ -395,7 +395,7 @@ void implInsertByName(NodeTreeSetAccess&
 		}
 		OSL_ENSURE(!configuration::hasChildOrElement(aTree,aNode,aChildName),"ERROR: Configuration: Existing Set element not found by implementation");
 
-		ElementTree aElementTree = configapi::extractElementTree(rNode.getFactory(), rElement, rNode.getElementInfo(lock.getDataAccessor()) );
+		ElementTree aElementTree = configapi::extractElementTree(rNode.getFactory(), rElement, rNode.getElementInfo());
 		if (!aElementTree.isValid())
 		{
 		    OUString sMessage( RTL_CONSTASCII_USTRINGPARAM("Configuration - Cannot insert into Set: ") );
@@ -715,8 +715,7 @@ Reference< uno::XInterface > implCreateE
 	{
 		GuardedNodeData<NodeSetAccess> lock( rNode ); // no provider lock needed ? => if template lock is separate - OK
 
-        data::Accessor aDataAccess = lock.getDataAccessor();
-		ElementTree aNewElement( rNode.getElementFactory(aDataAccess).instantiateTemplate(rNode.getElementInfo(aDataAccess).getTemplate()) );
+		ElementTree aNewElement( rNode.getElementFactory().instantiateTemplate(rNode.getElementInfo().getTemplate()) );
 	
 		Any aAny = configapi::makeElement( rNode.getFactory(), aNewElement );
 		if (!(aAny >>= xRet)) // no parent available
Index: configmgr/source/backend/updatedata.hxx
===================================================================
RCS file: /cvs/util/configmgr/source/backend/updatedata.hxx,v
retrieving revision 1.7
retrieving revision 1.7.84.1
diff -u -p -u -p -r1.7 -r1.7.84.1
--- configmgr/source/backend/updatedata.hxx	8 Sep 2005 03:35:04 -0000	1.7
+++ configmgr/source/backend/updatedata.hxx	11 Jan 2007 20:15:59 -0000	1.7.84.1
@@ -50,8 +50,8 @@
 #include <rtl/ustring.hxx>
 #endif
 
-#ifndef _SALHELPER_SIMPLEREFERENCEOBJECT_HXX_
-#include <salhelper/simplereferenceobject.hxx>
+#ifndef CONFIGMGR_UTILITY_HXX_
+#include "utility.hxx"
 #endif
 
 #ifndef INCLUDED_SET
@@ -91,7 +91,7 @@ namespace configmgr
 
 // -----------------------------------------------------------------------------
 
-        class NamedUpdate : public salhelper::SimpleReferenceObject
+        class NamedUpdate : public configmgr::SimpleReferenceObject
         {
             OUString const  m_aName;
 
Index: configmgr/source/backend/updatedispatch.cxx
===================================================================
RCS file: /cvs/util/configmgr/source/backend/updatedispatch.cxx,v
retrieving revision 1.10
retrieving revision 1.10.24.1
diff -u -p -u -p -r1.10 -r1.10.24.1
--- configmgr/source/backend/updatedispatch.cxx	16 Sep 2006 15:07:29 -0000	1.10
+++ configmgr/source/backend/updatedispatch.cxx	11 Jan 2007 10:35:26 -0000	1.10.24.1
@@ -454,22 +454,21 @@ data::SetVisitor::Result UpdateDispatche
 }
 // -----------------------------------------------------------------------------
             
-bool UpdateDispatcher::testReplacedAndGetName(data::NodeAccessRef const & _aNode, OUString & _aName)
+bool UpdateDispatcher::testReplacedAndGetName(data::NodeAccess const & _aNode, OUString & _aName)
 {
     if (m_aElementName.getLength())
     {
-        OSL_ENSURE( _aNode.isLocalRoot(), "ERROR - UpdateDispatcher: Found orphaned 'element' name for inner node");
+        OSL_ENSURE( _aNode->isFragmentRoot(), "ERROR - UpdateDispatcher: Found orphaned 'element' name for inner node");
         _aName = m_aElementName;
         m_aElementName = OUString();
         return true;
     }
     else
     {
-        OSL_ENSURE(!_aNode.isLocalRoot(), "ERROR - UpdateDispatcher: Found no 'element' name for fragment root node");
+        OSL_ENSURE(!_aNode->isFragmentRoot(), "ERROR - UpdateDispatcher: Found no 'element' name for fragment root node");
         _aName = _aNode.getName().toString();
         return false;
     }
-    // return _aNode.isLocalRoot();
 }
 // -----------------------------------------------------------------------------
 
Index: configmgr/source/backend/updatedispatch.hxx
===================================================================
RCS file: /cvs/util/configmgr/source/backend/updatedispatch.hxx,v
retrieving revision 1.7
retrieving revision 1.7.42.1
diff -u -p -u -p -r1.7 -r1.7.42.1
--- configmgr/source/backend/updatedispatch.hxx	19 Jun 2006 23:20:52 -0000	1.7
+++ configmgr/source/backend/updatedispatch.hxx	11 Jan 2007 10:35:26 -0000	1.7.42.1
@@ -99,7 +99,7 @@ namespace configmgr
             sal_Int16 getUpdateAttributes(node::Attributes const & _aAttributes, bool bAdded);
             sal_Int16 getUpdateAttributeMask(node::Attributes const & _aAttributes);
 
-            bool testReplacedAndGetName(data::NodeAccessRef const & _aNode, OUString & _aName);
+            bool testReplacedAndGetName(data::NodeAccess const & _aNode, OUString & _aName);
         private:
             configuration::AbsolutePath const * m_pContextPath;
             UpdateHandler   m_xUpdateHandler;
Index: configmgr/source/data/anydata.cxx
===================================================================
RCS file: /cvs/util/configmgr/source/data/anydata.cxx,v
retrieving revision 1.6
retrieving revision 1.5.4.3
diff -u -p -u -p -r1.6 -r1.5.4.3
--- configmgr/source/data/anydata.cxx	21 Nov 2006 17:23:44 -0000	1.6
+++ configmgr/source/data/anydata.cxx	7 Feb 2007 11:45:02 -0000	1.5.4.3
@@ -44,10 +44,6 @@
 #ifndef INCLUDED_DATA_FLAGS_HXX
 #include "flags.hxx"
 #endif
-#ifndef CONFIGMGR_UPDATEACCESSOR_HXX
-#include "updateaccessor.hxx"
-#endif
-
 #ifndef CONFIGMGR_TYPECONVERTER_HXX
 #include "typeconverter.hxx"
 #endif
@@ -61,7 +57,6 @@ namespace configmgr
         namespace Type = data::Type;
         namespace uno = ::com::sun::star::uno;
         typedef AnyData::TypeCode TypeCode;
-        using memory::Pointer;
 //-----------------------------------------------------------------------------	
 
 TypeCode getTypeCode(uno::Type const & _aType)
@@ -200,7 +195,7 @@ uno::Type getUnoType( TypeCode _aType)
 //-----------------------------------------------------------------------------	
 
 static
-AnyData allocSimpleData(memory::Allocator const& _anAllocator, TypeCode _aSimpleType, uno::Any const & _aAny)
+AnyData allocSimpleData(TypeCode _aSimpleType, uno::Any const & _aAny)
 {
     OSL_ENSURE( _aSimpleType == (_aSimpleType & Type::mask_basetype), "Invalid type code" );
 
@@ -234,9 +229,7 @@ AnyData allocSimpleData(memory::Allocato
             sal_Int64 nValue = 0;
             OSL_VERIFY(_aAny >>= nValue);
 
-            Address aStorage = _anAllocator.allocate( sizeof nValue );
-            *static_cast<sal_Int64*>( _anAllocator.access(aStorage) ) = nValue;
-            aResult.longValue = aStorage;
+            aResult.longValue = new sal_Int64( nValue );
         }
         break;
 
@@ -245,9 +238,7 @@ AnyData allocSimpleData(memory::Allocato
             double dValue = 0;
             OSL_VERIFY(_aAny >>= dValue);
 
-            Address aStorage = _anAllocator.allocate( sizeof dValue );
-            *static_cast<double*>( _anAllocator.access(aStorage) ) = dValue;
-            aResult.doubleValue = aStorage;
+            aResult.doubleValue = new double( dValue );
         }
         break;
 
@@ -255,7 +246,7 @@ AnyData allocSimpleData(memory::Allocato
         {
             uno::Sequence<sal_Int8> aValue;
             OSL_VERIFY(_aAny >>= aValue);
-            aResult.binaryValue = allocBinary(_anAllocator,aValue);
+            aResult.binaryValue = allocBinary(aValue);
         }
         break;
 
@@ -290,7 +281,7 @@ sal_Sequence const * extractSequenceData
 //-----------------------------------------------------------------------------	
 
 static
-AnyData allocSequenceData(memory::Allocator const& _anAllocator, TypeCode _aSimpleType, uno::Any const & _aAny)
+AnyData allocSequenceData(TypeCode _aSimpleType, uno::Any const & _aAny)
 {
     OSL_ENSURE( _aSimpleType == (_aSimpleType & Type::mask_basetype), "Invalid type code" );
 
@@ -302,7 +293,7 @@ AnyData allocSequenceData(memory::Alloca
         {
             uno::Sequence<rtl::OUString> aSeqValue;
             if (sal_Sequence const * pData = extractSequenceData(aSeqValue,_aAny))
-                aSequence = allocSequence(_anAllocator,_aSimpleType,pData);
+                aSequence = allocSequence(_aSimpleType,pData);
         }
         break;
 
@@ -310,7 +301,7 @@ AnyData allocSequenceData(memory::Alloca
         {
             uno::Sequence<sal_Bool> aSeqValue;
             if (sal_Sequence const * pData = extractSequenceData(aSeqValue,_aAny))
-                aSequence = allocSequence(_anAllocator,_aSimpleType,pData);
+                aSequence = allocSequence(_aSimpleType,pData);
         }
         break;
 
@@ -318,7 +309,7 @@ AnyData allocSequenceData(memory::Alloca
         {
             uno::Sequence<sal_Int16> aSeqValue;
             if (sal_Sequence const * pData = extractSequenceData(aSeqValue,_aAny))
-                aSequence = allocSequence(_anAllocator,_aSimpleType,pData);
+                aSequence = allocSequence(_aSimpleType,pData);
         }
         break;
 
@@ -326,7 +317,7 @@ AnyData allocSequenceData(memory::Alloca
         {
             uno::Sequence<sal_Int32> aSeqValue;
             if (sal_Sequence const * pData = extractSequenceData(aSeqValue,_aAny))
-                aSequence = allocSequence(_anAllocator,_aSimpleType,pData);
+                aSequence = allocSequence(_aSimpleType,pData);
         }
         break;
 
@@ -334,7 +325,7 @@ AnyData allocSequenceData(memory::Alloca
         {
             uno::Sequence<sal_Int64> aSeqValue;
             if (sal_Sequence const * pData = extractSequenceData(aSeqValue,_aAny))
-                aSequence = allocSequence(_anAllocator,_aSimpleType,pData);
+                aSequence = allocSequence(_aSimpleType,pData);
         }
         break;
 
@@ -342,7 +333,7 @@ AnyData allocSequenceData(memory::Alloca
         {
             uno::Sequence<double> aSeqValue;
             if (sal_Sequence const * pData = extractSequenceData(aSeqValue,_aAny))
-                aSequence = allocSequence(_anAllocator,_aSimpleType,pData);
+                aSequence = allocSequence(_aSimpleType,pData);
         }
         break;
 
@@ -350,7 +341,7 @@ AnyData allocSequenceData(memory::Alloca
         {
             uno::Sequence<uno::Sequence<sal_Int8> > aSeqValue;
             if (sal_Sequence const * pData = extractSequenceData(aSeqValue,_aAny))
-                aSequence = allocSequence(_anAllocator,_aSimpleType,pData);
+                aSequence = allocSequence(_aSimpleType,pData);
         }
         break;
 
@@ -366,28 +357,20 @@ AnyData allocSequenceData(memory::Alloca
 }
 //-----------------------------------------------------------------------------	
 
-AnyData allocData(memory::Allocator const& _anAllocator, TypeCode _aType, uno::Any const & _aAny)
+AnyData allocData(TypeCode _aType, uno::Any const & _aAny)
 {
     OSL_ENSURE( _aType == (_aType & Type::mask_valuetype), "Invalid type code" );
     OSL_ENSURE( _aType == getTypeCode(_aAny.getValueType()), "Type code does not match value" );
 
     if (_aType & Type::flag_sequence)
-        return allocSequenceData(_anAllocator,TypeCode( _aType & Type::mask_basetype),_aAny);
-
+        return allocSequenceData(TypeCode( _aType & Type::mask_basetype),_aAny);
     else
-        return allocSimpleData(_anAllocator,_aType,_aAny);
+        return allocSimpleData(_aType,_aAny);
 }
 //-----------------------------------------------------------------------------	
-/*
-AnyData copyData(memory::Allocator const& _anAllocator, TypeCode _aType, AnyData _aData)
-{
-    OSL_ENSURE( _aType == (_aType & Type::mask_valuetype), "Invalid type code" );
-}
-*/
-//-----------------------------------------------------------------------------	
 
 static
-void freeSimpleData(memory::Allocator const& _anAllocator, TypeCode _aSimpleType, AnyData const & _aData)
+void freeSimpleData(TypeCode _aSimpleType, AnyData const & _aData)
 {
     OSL_ENSURE( _aSimpleType == (_aSimpleType & Type::mask_basetype), "Invalid type code" );
 
@@ -405,15 +388,15 @@ void freeSimpleData(memory::Allocator co
 
         // free memory for oversized values
     case Type::value_long:
-        _anAllocator.deallocate(_aData.longValue);
+        delete _aData.longValue;
         break;
 
     case Type::value_double:
-        _anAllocator.deallocate(_aData.doubleValue);
+        delete _aData.doubleValue;
         break;
 
     case Type::value_binary:
-        freeBinary(_anAllocator, _aData.binaryValue);
+        freeBinary(_aData.binaryValue);
         break;
 
     case Type::value_any: 
@@ -427,20 +410,20 @@ void freeSimpleData(memory::Allocator co
 }
 //-----------------------------------------------------------------------------	
 
-void    freeData(memory::Allocator const& _anAllocator, TypeCode _aType, AnyData _aData)
+void    freeData(TypeCode _aType, AnyData _aData)
 {
     OSL_ENSURE( _aType == (_aType & Type::mask_valuetype), "Invalid type code" );
 
     if (_aType & Type::flag_sequence)
-        freeSequence(_anAllocator,TypeCode(_aType & Type::mask_basetype),_aData.sequenceValue);
+        freeSequence(TypeCode(_aType & Type::mask_basetype),_aData.sequenceValue);
 
     else
-        freeSimpleData(_anAllocator,_aType,_aData);
+        freeSimpleData(_aType,_aData);
 }
 //-----------------------------------------------------------------------------	
 
 static
-uno::Any readSimpleData(memory::Accessor const& _anAccessor, TypeCode _aSimpleType, AnyData const & _aData)
+uno::Any readSimpleData(TypeCode _aSimpleType, AnyData const & _aData)
 {
     OSL_ENSURE( _aSimpleType == (_aSimpleType & Type::mask_basetype), "Invalid type code" );
 
@@ -462,22 +445,14 @@ uno::Any readSimpleData(memory::Accessor
         return uno::makeAny( _aData.intValue );
 
     case Type::value_long:
-        {
-            void const * pStorage = _anAccessor.validate( Pointer(_aData.longValue) );
-            sal_Int64 const * pValue = static_cast<sal_Int64 const *>(pStorage);
-            return uno::makeAny( *pValue );
-        }
+	return uno::makeAny( *_aData.longValue );
 
     case Type::value_double:
-        {
-            void const * pStorage = _anAccessor.validate( Pointer(_aData.doubleValue) );
-            double const * pValue = static_cast<double const *>(pStorage);
-            return uno::makeAny( *pValue );
-        }
+	return uno::makeAny( *_aData.doubleValue );
 
     case Type::value_binary:
         {
-            uno::Sequence<sal_Int8> aValue = readBinary( _anAccessor, _aData.binaryValue );
+            uno::Sequence<sal_Int8> aValue = readBinary( _aData.binaryValue );
             return uno::makeAny( aValue );
         }
 
@@ -491,15 +466,15 @@ uno::Any readSimpleData(memory::Accessor
 }
 //-----------------------------------------------------------------------------	
 
-uno::Any readData(memory::Accessor const& _anAccessor, TypeCode _aType, AnyData _aData)
+uno::Any readData(TypeCode _aType, AnyData _aData)
 {
     OSL_ENSURE( _aType == (_aType & Type::mask_valuetype), "Invalid type code" );
 
     if (_aType & Type::flag_sequence)
-        return readAnySequence(_anAccessor,TypeCode(_aType & Type::mask_basetype),_aData.sequenceValue);
+        return readAnySequence(TypeCode(_aType & Type::mask_basetype),_aData.sequenceValue);
 
     else
-        return readSimpleData(_anAccessor,_aType,_aData);
+        return readSimpleData(_aType,_aData);
 }
 
 //-----------------------------------------------------------------------------	
Index: configmgr/source/data/makefile.mk
===================================================================
RCS file: /cvs/util/configmgr/source/data/makefile.mk,v
retrieving revision 1.4
retrieving revision 1.4.84.1
diff -u -p -u -p -r1.4 -r1.4.84.1
--- configmgr/source/data/makefile.mk	8 Sep 2005 03:39:27 -0000	1.4
+++ configmgr/source/data/makefile.mk	11 Jan 2007 10:35:28 -0000	1.4.84.1
@@ -48,14 +48,8 @@ ENABLE_EXCEPTIONS=TRUE
 # --- Files -------------------------------------
 
 SLOFILES=	\
-		$(SLO)$/simpleheap.obj	\
-		$(SLO)$/heap.obj	\
-		$(SLO)$/segmentheap.obj	\
 		$(SLO)$/anydata.obj	\
-		$(SLO)$/sequence.obj	\
-		$(SLO)$/types.obj	\
-		$(SLO)$/accessor.obj		\
-		$(SLO)$/updateaccessor.obj		\
+		$(SLO)$/sequence.obj
 
 # --- Targets ----------------------------------
 
Index: configmgr/source/data/sequence.cxx
===================================================================
RCS file: /cvs/util/configmgr/source/data/sequence.cxx,v
retrieving revision 1.7
retrieving revision 1.7.14.6
diff -u -p -u -p -r1.7 -r1.7.14.6
--- configmgr/source/data/sequence.cxx	6 Nov 2006 14:47:26 -0000	1.7
+++ configmgr/source/data/sequence.cxx	16 Jan 2007 12:18:20 -0000	1.7.14.6
@@ -41,9 +41,6 @@
 #ifndef INCLUDED_DATA_FLAGS_HXX
 #include "flags.hxx"
 #endif
-#ifndef CONFIGMGR_UPDATEACCESSOR_HXX
-#include "updateaccessor.hxx"
-#endif
 
 #ifndef INCLUDED_ALGORITHM
 #include <algorithm>
@@ -55,6 +52,8 @@
 #define INCLUDED_STRING_H
 #endif
 
+#include "utility.hxx"
+
 namespace configmgr
 {
 //-----------------------------------------------------------------------------	
@@ -64,9 +63,6 @@ namespace configmgr
         namespace Type = data::Type;
         namespace uno = ::com::sun::star::uno;
         typedef AnyData::TypeCode TypeCode;
-        using memory::Allocator;
-        using memory::Accessor;
-        using memory::Pointer;
 //-----------------------------------------------------------------------------	
 static 
 sal_uInt32 implGetElementSize(TypeCode _aElementType)
@@ -108,32 +104,20 @@ sal_uInt32 implGetHeaderSize(sal_uInt32 
 //-----------------------------------------------------------------------------	
 static 
 inline
-sal_Int32& implGetSize(Allocator const& _anAllocator, Sequence _aSeq)
-{
-    OSL_ASSERT(_aSeq != 0);
-    void * pBase = _anAllocator.access(_aSeq);
-    return * static_cast<sal_Int32 *>(pBase);
-}
-
-//-----------------------------------------------------------------------------	
-static 
-inline
-sal_Int32 implGetSize(Accessor const& _anAccessor, Sequence _aSeq)
+sal_Int32& implGetSize(Sequence _aSeq)
 {
-    OSL_ASSERT(_aSeq != 0);
-    void const * pBase = _anAccessor.access( Pointer(_aSeq) );
-    return * static_cast<sal_Int32 const *>(pBase);
+    return * (sal_Int32 *) _aSeq;
 }
 
 //-----------------------------------------------------------------------------	
 static 
-Sequence implSeqAlloc(Allocator const& _anAllocator, sal_Int32 _nElements, sal_uInt32 _nElemSize)
+Sequence implSeqAlloc(sal_Int32 _nElements, sal_uInt32 _nElemSize)
 {
     sal_uInt32 nTotalSize = implGetHeaderSize(_nElemSize) + _nElements * _nElemSize;
 
-    Sequence aResult = _anAllocator.allocate(nTotalSize);
+    Sequence aResult = (Sequence) (new sal_uInt8[nTotalSize]);
 
-    implGetSize(_anAllocator,aResult) = _nElements;
+    implGetSize(aResult) = _nElements;
 
     return aResult;
 }
@@ -141,7 +125,7 @@ Sequence implSeqAlloc(Allocator const& _
 //-----------------------------------------------------------------------------	
 
 static
-void allocSeqData(Allocator const& _anAllocator, Address _aDestAddr, 
+void allocSeqData(sal_uInt8 *_pDestAddr, 
                  TypeCode _aElementType, 
                  sal_Int32 _nElements, sal_uInt32 _nElementSize, 
                  void const * _pSourceData)
@@ -155,7 +139,7 @@ void allocSeqData(Allocator const& _anAl
     case Type::value_int:
     case Type::value_long:
     case Type::value_double:
-        ::memcpy(_anAllocator.access(_aDestAddr),_pSourceData,_nElements * _nElementSize);
+        ::memcpy(_pDestAddr,_pSourceData,_nElements * _nElementSize);
         break;
 
     case Type::value_string: 
@@ -168,11 +152,11 @@ void allocSeqData(Allocator const& _anAl
             {
                 String aElement = allocString(*pSource);
 
-                String * pDest = static_cast<String*>( _anAllocator.access(_aDestAddr) );
+                String * pDest = reinterpret_cast<String*>(_pDestAddr);
                 *pDest = aElement;
                 
                 ++pSource;
-                _aDestAddr += sizeof *pDest;
+                _pDestAddr += sizeof *pDest;
             }
         }
         break;
@@ -186,13 +170,13 @@ void allocSeqData(Allocator const& _anAl
 
             while (--_nElements >= 0)
             {
-                Vector aElement = allocBinary(_anAllocator,*pSource);
+                Vector aElement = allocBinary(*pSource);
 
-                Vector * pDest = static_cast<Vector*>( _anAllocator.access(_aDestAddr) );
+                Vector * pDest = (Vector *) _pDestAddr;
                 *pDest = aElement;
                 
                 ++pSource;
-                _aDestAddr += sizeof *pDest;
+                _pDestAddr += sizeof *pDest;
             }
         }
         break;
@@ -205,7 +189,7 @@ void allocSeqData(Allocator const& _anAl
 }
 
 //-----------------------------------------------------------------------------	
-Sequence allocSequence(Allocator const& _anAllocator, TypeCode _aElementType, ::sal_Sequence const * _pSeqData)
+Sequence allocSequence(TypeCode _aElementType, ::sal_Sequence const * _pSeqData)
 {
     OSL_ENSURE(_aElementType == (_aElementType & Type::mask_valuetype), "Invalid type code");
 
@@ -218,10 +202,10 @@ Sequence allocSequence(Allocator const& 
     sal_uInt32 const nElementSize = implGetElementSize(_aElementType);
     sal_Int32  const nElements = _pSeqData->nElements;
 
-    Sequence aResult = implSeqAlloc(_anAllocator,nElements,nElementSize);
+    Sequence aResult = implSeqAlloc(nElements,nElementSize);
 
     if (aResult)
-        allocSeqData( _anAllocator, aResult + implGetHeaderSize(nElementSize), 
+        allocSeqData( aResult + implGetHeaderSize(nElementSize), 
                         _aElementType, nElements, nElementSize,
                         _pSeqData->elements);
 
@@ -229,31 +213,25 @@ Sequence allocSequence(Allocator const& 
 }
 
 //-----------------------------------------------------------------------------	
-Sequence allocBinary(Allocator const& _anAllocator, uno::Sequence<sal_Int8> const & _aBinaryValue)
+Sequence allocBinary(uno::Sequence<sal_Int8> const & _aBinaryValue)
 {
     sal_uInt32 const nElementSize = 1;
     sal_Int32  const nLength = _aBinaryValue.getLength();
 
-    Sequence aResult = implSeqAlloc(_anAllocator,nLength,nElementSize);
+    Sequence aResult = implSeqAlloc(nLength,nElementSize);
 
     if (aResult)
     {
-        Address aElementBaseAddr = aResult + implGetHeaderSize(nElementSize);
-        ::memcpy(_anAllocator.access(aElementBaseAddr), _aBinaryValue.getConstArray(), nLength);
+        sal_uInt8 *pElementBaseAddr = aResult + implGetHeaderSize(nElementSize);
+        ::memcpy(pElementBaseAddr, _aBinaryValue.getConstArray(), nLength);
     }
 
     return aResult;
 }
 
 //-----------------------------------------------------------------------------	
-// Sequence copySequence(Allocator const& _anAllocator, TypeCode _aElementType, Sequence _aSeq)
-
-//-----------------------------------------------------------------------------	
-// Sequence copyBinary(Allocator const& _anAllocator, Sequence _aSeq)
-
-//-----------------------------------------------------------------------------	
 static
-void freeSeqData(Allocator const& _anAllocator, Address _aDataAddr, 
+void freeSeqData(sal_uInt8 *_pDataAddr, 
                  TypeCode _aElementType, sal_Int32 _nElements)
 {
     OSL_ASSERT(_aElementType == (_aElementType & Type::mask_basetype));
@@ -270,7 +248,7 @@ void freeSeqData(Allocator const& _anAll
 
     case Type::value_string: 
         {
-            String * pElements = static_cast<String*>( _anAllocator.access(_aDataAddr) );
+            String * pElements = reinterpret_cast<String*>( _pDataAddr );
 
             for (sal_Int32 i = 0; i < _nElements; ++i)
             {
@@ -281,11 +259,11 @@ void freeSeqData(Allocator const& _anAll
 
     case Type::value_binary:
         {
-            Vector * pElements = static_cast<Vector*>( _anAllocator.access(_aDataAddr) );
+            Vector * pElements = reinterpret_cast<Vector*>( _pDataAddr );
 
             for (sal_Int32 i = 0; i < _nElements; ++i)
             {
-                freeBinary(_anAllocator,pElements[i]);
+                freeBinary(pElements[i]);
             }
         }
         break;
@@ -298,7 +276,7 @@ void freeSeqData(Allocator const& _anAll
 }
 
 //-----------------------------------------------------------------------------	
-void freeSequence(Allocator const& _anAllocator, TypeCode _aElementType, Sequence _aSeq)
+void freeSequence(TypeCode _aElementType, Sequence _aSeq)
 {
     OSL_ENSURE(_aElementType == (_aElementType & Type::mask_valuetype), "Invalid type code");
 
@@ -310,18 +288,18 @@ void freeSequence(Allocator const& _anAl
 
     sal_uInt32 nHeaderSize = implGetHeaderSize( implGetElementSize( _aElementType ) );
 
-    freeSeqData(_anAllocator,_aSeq + nHeaderSize, _aElementType, implGetSize(_anAllocator,_aSeq));
+    freeSeqData(_aSeq + nHeaderSize, _aElementType, implGetSize(_aSeq));
 
-    _anAllocator.deallocate(_aSeq);
+    delete[] (sal_uInt8 *)_aSeq;
 }
 
 //-----------------------------------------------------------------------------	
-void freeBinary(memory::Allocator const& _anAllocator, Sequence _aSeq)
+void freeBinary(Sequence _aSeq)
 {
     OSL_ENSURE(_aSeq, "ERROR: Trying to free a NULL sequence");
     if (_aSeq == 0) return;
 
-    _anAllocator.deallocate(_aSeq);
+    delete[] (sal_uInt8 *)_aSeq;
 }
 
 //-----------------------------------------------------------------------------	
@@ -342,11 +320,11 @@ sal_Sequence * implCreateSequence(void c
 
 //-----------------------------------------------------------------------------	
 static
-sal_Sequence * readSeqData(Accessor const & _anAccessor, Address _aDataAddr, TypeCode _aElementType, sal_Int32 _nElements)
+sal_Sequence * readSeqData(sal_uInt8 *_pDataAddr, TypeCode _aElementType, sal_Int32 _nElements)
 {
     OSL_ASSERT(_aElementType == (_aElementType & Type::mask_basetype));
 
-    void const * pElementData = _anAccessor.validate( Pointer(_aDataAddr) );
+    void const * pElementData = (void const *)_pDataAddr;
     switch (_aElementType)
     {
     case Type::value_boolean:
@@ -384,7 +362,7 @@ sal_Sequence * readSeqData(Accessor cons
 
             for (sal_Int32 i = 0; i < _nElements; ++i)
             {
-                pResult[i] = readBinary(_anAccessor,pElements[i]);
+                pResult[i] = readBinary(pElements[i]);
             }
 
             sal_Sequence * pRet = aResult.get();
@@ -401,7 +379,7 @@ sal_Sequence * readSeqData(Accessor cons
 
 //-----------------------------------------------------------------------------	
 
-::sal_Sequence * readSequence(Accessor const& _anAccessor, TypeCode _aElementType, Sequence _aSeq)
+::sal_Sequence * readSequence(TypeCode _aElementType, Sequence _aSeq)
 {
     OSL_ENSURE(_aElementType == (_aElementType & Type::mask_valuetype), "Invalid type code");
 
@@ -413,13 +391,14 @@ sal_Sequence * readSeqData(Accessor cons
 
     sal_uInt32 nHeaderSize = implGetHeaderSize( implGetElementSize( _aElementType ) );
 
-    return readSeqData(_anAccessor,_aSeq + nHeaderSize, _aElementType, implGetSize(_anAccessor,_aSeq));
+    // URG - accidentally removed an accessor instead of an allocator ... :-)
+    return readSeqData(_aSeq + nHeaderSize, _aElementType, implGetSize(_aSeq));
 }
 
 //-----------------------------------------------------------------------------	
-uno::Any readAnySequence(Accessor const& _anAccessor, TypeCode _aElementType, Sequence _aSeq)
+uno::Any readAnySequence(TypeCode _aElementType, Sequence _aSeq)
 {
-    sal_Sequence * pRawSequence = readSequence(_anAccessor, _aElementType, _aSeq);
+    sal_Sequence * pRawSequence = readSequence(_aElementType, _aSeq);
 
     uno::Any aResult;
 
@@ -487,24 +466,49 @@ uno::Any readAnySequence(Accessor const&
 }
 
 //-----------------------------------------------------------------------------	
-uno::Sequence<sal_Int8> readBinary(Accessor const& _anAccessor, Sequence _aSeq)
+uno::Sequence<sal_Int8> readBinary(Sequence _aSeq)
 {
     OSL_ENSURE(_aSeq, "ERROR: Trying to read from a NULL sequence");
     if (_aSeq == 0) return uno::Sequence<sal_Int8>();
 
-    sal_Int32 const nElements = implGetSize(_anAccessor,_aSeq);
-
-    void const * const pElementData = _anAccessor.validate( Pointer(_aSeq + implGetHeaderSize(1)) );
-
-    sal_Int8 const * const pBinaryData = static_cast<sal_Int8 const *>(pElementData);
-
-    uno::Sequence< sal_Int8 > aSequence(pBinaryData,nElements); 
-
-    return aSequence;
+    return uno::Sequence< sal_Int8 >((const sal_Int8 *)(_aSeq + implGetHeaderSize(1)),
+				     implGetSize(_aSeq));
 }
 
 //-----------------------------------------------------------------------------	
     }
 //-----------------------------------------------------------------------------	
 } // namespace
- 
+
+// Remaining 'global' mutex bits - should move to api2 ...
+namespace configmgr
+{
+    osl::Mutex UnoApiLock::aCoreLock;
+    volatile oslInterlockedCount UnoApiLock::nHeld = 0;
+
+#ifndef SIMPLE_REFERENCE_FAST
+    void SimpleReferenceObject::acquire() SAL_THROW(())
+    {
+        if (!UnoApiLock::isHeld())
+        {
+            fprintf (stderr, "Locking disaster\n");
+            fscanf (stdin, "");
+        }
+        m_nCount++;
+    }
+    void SimpleReferenceObject::release() SAL_THROW(())
+    {
+        if (!UnoApiLock::isHeld())
+        {
+            fprintf (stderr, "Locking disaster\n");
+            fscanf (stdin, "");
+        }
+        if (--m_nCount == 0)
+            delete this;
+    }
+#endif
+    SimpleReferenceObject::~SimpleReferenceObject() SAL_THROW(())
+    {
+        OSL_ASSERT(m_nCount == 0);
+    }
+} // namespace configmgr
Index: configmgr/source/inc/anydata.hxx
===================================================================
RCS file: /cvs/util/configmgr/source/inc/anydata.hxx,v
retrieving revision 1.2
retrieving revision 1.2.84.2
diff -u -p -u -p -r1.2 -r1.2.84.2
--- configmgr/source/inc/anydata.hxx	8 Sep 2005 03:41:13 -0000	1.2
+++ configmgr/source/inc/anydata.hxx	7 Feb 2007 12:00:31 -0000	1.2.84.2
@@ -51,28 +51,23 @@ namespace configmgr
 {
 //-----------------------------------------------------------------------------
 
-    namespace memory { class Allocator; class Accessor; }
-    //-----------------------------------------------------------------------------
-
     namespace sharable
     {
     //-----------------------------------------------------------------------------
 
-        //typedef Address AnyData; // data that fits is stored inline
         union AnyData
         {
-            typedef Byte TypeCode;
+            typedef sal_uInt8 TypeCode;
 
-            Address     data;
             sal_Bool    boolValue;
             sal_Int16   shortValue;
             sal_Int32   intValue;
-            Address     longValue;      // points to sal_Int64
-            Address     doubleValue;    // points to double (IEEE 8-bit) ...
-       //     float       floatValue;     // ... or should we use float (IEEE 4-bit) ?  
+            sal_Int64  *longValue;
+            double     *doubleValue;
             Vector      binaryValue;    // points to counted sal_(u)Int8 []
             String      stringValue;    // points to counted sal_Unicode []
             Vector      sequenceValue;  // points to counted AnyData [] (or SomeType [] ?)
+            void       *data;           // used to initialize to 0
         };
 
     //-----------------------------------------------------------------------------
@@ -80,10 +75,9 @@ namespace configmgr
         AnyData::TypeCode getTypeCode(::com::sun::star::uno::Type const & _aType);
         ::com::sun::star::uno::Type getUnoType( AnyData::TypeCode _aType);
 
-        AnyData allocData(memory::Allocator const& _anAllocator, AnyData::TypeCode _aType, ::com::sun::star::uno::Any const & _aAny);
-    //    AnyData copyData(memory::Allocator const& _anAllocator, AnyData::TypeCode _aType, AnyData _aData);
-        void    freeData(memory::Allocator const& _anAllocator, AnyData::TypeCode _aType, AnyData _aData);
-        ::com::sun::star::uno::Any readData(memory::Accessor const& _anAccessor, AnyData::TypeCode _aType, AnyData _aData);
+        AnyData allocData(AnyData::TypeCode _aType, ::com::sun::star::uno::Any const & _aAny);
+        void    freeData(AnyData::TypeCode _aType, AnyData _aData);
+        ::com::sun::star::uno::Any readData(AnyData::TypeCode _aType, AnyData _aData);
 
     //-----------------------------------------------------------------------------
     } 
Index: configmgr/source/inc/autoobject.hxx
===================================================================
RCS file: /cvs/util/configmgr/source/inc/autoobject.hxx,v
retrieving revision 1.2
retrieving revision 1.2.84.1
diff -u -p -u -p -r1.2 -r1.2.84.1
--- configmgr/source/inc/autoobject.hxx	8 Sep 2005 03:42:21 -0000	1.2
+++ configmgr/source/inc/autoobject.hxx	11 Jan 2007 20:16:00 -0000	1.2.84.1
@@ -39,9 +39,6 @@
 #ifndef CONFIGMGR_UTILITY_HXX_
 #include "utility.hxx"
 #endif
-#ifndef _OSL_MUTEX_HXX_
-#include <osl/mutex.hxx>
-#endif
 
 namespace configmgr
 {
@@ -49,7 +46,6 @@ namespace configmgr
 	using ::rtl::OUString;
 
 //-----------------------------------------------------------------------------
-
     template < class Object >
     class AutoObject : Noncopyable
 	{
@@ -64,12 +60,9 @@ namespace configmgr
         bool is()   const;
         Ptr get()   const;
         Ptr getOrCreate();
-
-        osl::Mutex & mutex() const { return m_aMutex; }
     private:
         Ptr internalCreate();
     private:
-		mutable osl::Mutex  m_aMutex;
         Ptr  m_pObject;
 	};
 //-----------------------------------------------------------------------------
@@ -78,7 +71,6 @@ namespace configmgr
     inline
     Object * AutoObject<Object>::get() const
     {
-        // osl::MutexGuard aGuard(m_aMutex);
         return m_pObject;
     }
 //-----------------------------------------------------------------------------
@@ -102,7 +94,6 @@ namespace configmgr
     template < class Object >
     Object * AutoObject<Object>::internalCreate()
     {    
-        osl::MutexGuard aGuard(m_aMutex);
         if (m_pObject == NULL)
             m_pObject = new Object();
         return m_pObject;
Index: configmgr/source/inc/autoreferencemap.hxx
===================================================================
RCS file: /cvs/util/configmgr/source/inc/autoreferencemap.hxx,v
retrieving revision 1.4
retrieving revision 1.4.84.1
diff -u -p -u -p -r1.4 -r1.4.84.1
--- configmgr/source/inc/autoreferencemap.hxx	8 Sep 2005 03:42:36 -0000	1.4
+++ configmgr/source/inc/autoreferencemap.hxx	11 Jan 2007 20:16:00 -0000	1.4.84.1
@@ -36,13 +36,9 @@
 #ifndef CONFIGMGR_AUTOREFERENCEMAP_HXX
 #define CONFIGMGR_AUTOREFERENCEMAP_HXX
 
-#ifndef _OSL_MUTEX_HXX_
-#include <osl/mutex.hxx>
-#endif
 #ifndef _RTL_REF_HXX_
 #include <rtl/ref.hxx>
 #endif
-
 #ifndef INCLUDED_MAP
 #include <map>
 #define INCLUDED_MAP
@@ -91,7 +87,6 @@ namespace configmgr
         Ref insert(Key const & _aKey, Ref const & _anEntry);
         Ref remove(Key const & _aKey);
 
-        osl::Mutex & mutex() const { return m_aMutex; }
     private:
         Ref internalGet(Key const & _aKey) const
         {
@@ -110,7 +105,6 @@ namespace configmgr
             m_aMap.erase(_aKey);
         }
 	private:
-		mutable osl::Mutex  m_aMutex;
         Map                 m_aMap;
 	};
 //-----------------------------------------------------------------------------
@@ -118,7 +112,6 @@ namespace configmgr
     template < class Key, class Object, class KeyCompare >
     bool AutoReferenceMap<Key,Object,KeyCompare>::has(Key const & _aKey) const
     {
-        osl::MutexGuard aGuard(m_aMutex);
         return internalGet(_aKey).is();
     }
 //-----------------------------------------------------------------------------
@@ -126,7 +119,6 @@ namespace configmgr
     template < class Key, class Object, class KeyCompare >
     rtl::Reference<Object> AutoReferenceMap<Key,Object,KeyCompare>::get(Key const & _aKey) const
     {
-        osl::MutexGuard aGuard(m_aMutex);
         return internalGet(_aKey);
     }
 //-----------------------------------------------------------------------------
@@ -134,7 +126,6 @@ namespace configmgr
     template < class Key, class Object, class KeyCompare >
     rtl::Reference<Object> AutoReferenceMap<Key,Object,KeyCompare>::insert(Key const & _aKey, Ref const & _anEntry)
     {    
-        osl::MutexGuard aGuard(m_aMutex);
         Ref aRef = internalAdd(_aKey,_anEntry);
         return aRef;
 
@@ -144,7 +135,6 @@ namespace configmgr
     template < class Key, class Object, class KeyCompare >
     rtl::Reference<Object> AutoReferenceMap<Key,Object,KeyCompare>::remove(Key const & _aKey)
     {
-        osl::MutexGuard aGuard(m_aMutex);
         Ref aRef = internalGet(_aKey);
         internalDrop(_aKey);
         return aRef;
Index: configmgr/source/inc/bootstrapcontext.hxx
===================================================================
RCS file: /cvs/util/configmgr/source/inc/bootstrapcontext.hxx,v
retrieving revision 1.6
retrieving revision 1.6.42.1
diff -u -p -u -p -r1.6 -r1.6.42.1
--- configmgr/source/inc/bootstrapcontext.hxx	19 Jun 2006 23:23:35 -0000	1.6
+++ configmgr/source/inc/bootstrapcontext.hxx	11 Jan 2007 20:16:00 -0000	1.6.42.1
@@ -147,12 +147,9 @@ namespace configmgr 
         bool lookupInContext  ( uno::Any & _rValue, const OUString& _aName ) const;
         bool lookupInBootstrap( uno::Any & _rValue, const OUString& _aName ) const;
 
-        osl::Mutex & mutex() const { return m_aMutex; }
-        Context const & basecontext() const { osl::MutexGuard lock(mutex()); return m_xContext; }
+        Context const & basecontext() const { return m_xContext; }
 
     private:
-        /// The mutex protecting this component
-        mutable osl::Mutex  m_aMutex;
         /// The context that most requests are delegated to
         Context             m_xContext;
         /// The bootstrap data consulted as fallback
Index: configmgr/source/inc/builddata.hxx
===================================================================
RCS file: /cvs/util/configmgr/source/inc/builddata.hxx,v
retrieving revision 1.2
retrieving revision 1.2.84.3
diff -u -p -u -p -r1.2 -r1.2.84.3
--- configmgr/source/inc/builddata.hxx	8 Sep 2005 03:43:35 -0000	1.2
+++ configmgr/source/inc/builddata.hxx	7 Feb 2007 12:00:31 -0000	1.2.84.3
@@ -36,6 +36,9 @@
 #ifndef CONFIGMGR_BUILDDATA_HXX
 #define CONFIGMGR_BUILDDATA_HXX
 
+#ifndef INCLUDED_SHARABLE_TREEFRAGMENT_HXX
+#include "treefragment.hxx"
+#endif
 #ifndef INCLUDED_MEMORY
 #define INCLUDED_MEMORY
 #include <memory>
@@ -50,23 +53,21 @@ namespace configmgr
     class ISubtree;
     class ValueNode;
 //-----------------------------------------------------------------------------
-    namespace memory { class Accessor; class UpdateAccessor; }
-//-----------------------------------------------------------------------------
+    namespace sharable { struct TreeFragment; }
     namespace data
     {
 //-----------------------------------------------------------------------------
-        class TreeAddress;
         class TreeAccessor;
 //-----------------------------------------------------------------------------
-        TreeAddress buildTree(memory::UpdateAccessor& _aTargetMemory, TreeAccessor const& _aTree);
+        TreeAddress buildTree(TreeAccessor const& _aTree);
 //-----------------------------------------------------------------------------
-        TreeAddress buildTree(memory::UpdateAccessor& _aTargetMemory, rtl::OUString const & _aTreeName, INode const& _aNode, bool _bWithDefaults);
+        TreeAddress buildTree(rtl::OUString const & _aTreeName, INode const& _aNode, bool _bWithDefaults);
 //-----------------------------------------------------------------------------
-        TreeAddress buildElementTree(memory::UpdateAccessor& _aTargetMemory, INode const& _aNode, rtl::OUString const & _aTypeName, bool _bWithDefaults);
+        TreeAddress buildElementTree(INode const& _aNode, rtl::OUString const & _aTypeName, bool _bWithDefaults);
 //-----------------------------------------------------------------------------
-        void mergeDefaults(memory::UpdateAccessor& _aTargetMemory, TreeAddress _aBaseAddress, INode const& _aDefaultNode);
+        void mergeDefaults(TreeAddress _aBaseAddress, INode const& _aDefaultNode);
 //-----------------------------------------------------------------------------
-        void destroyTree(memory::UpdateAccessor& _aTreeMemory, TreeAddress _aBaseAddress);
+        void destroyTree(TreeAddress _aBaseAddress);
 //-----------------------------------------------------------------------------
         std::auto_ptr<INode> convertTree(TreeAccessor const & _aTree, bool _bUseTreeName);
 //-----------------------------------------------------------------------------
Index: configmgr/source/inc/cacheddataprovider.hxx
===================================================================
RCS file: /cvs/util/configmgr/source/inc/cacheddataprovider.hxx,v
retrieving revision 1.5
retrieving revision 1.5.84.3
diff -u -p -u -p -r1.5 -r1.5.84.3
--- configmgr/source/inc/cacheddataprovider.hxx	8 Sep 2005 03:43:49 -0000	1.5
+++ configmgr/source/inc/cacheddataprovider.hxx	16 Jan 2007 12:18:20 -0000	1.5.84.3
@@ -45,15 +45,11 @@
 #ifndef CONFIGMGR_BACKEND_REQUESTTYPES_HXX_
 #include "requesttypes.hxx"
 #endif
-#ifndef CONFIGMGR_SEGMENT_HXX
-#include "segment.hxx"
-#endif
 #ifndef CONFIGMGR_UTILITY_HXX_
 #include "utility.hxx"
 #endif
-
-#ifndef _SALHELPER_SIMPLEREFERENCEOBJECT_HXX_
-#include <salhelper/simplereferenceobject.hxx>
+#ifndef INCLUDED_SHARABLE_TREEFRAGMENT_HXX
+#include "treefragment.hxx"
 #endif
 #ifndef _RTL_REF_HXX_
 #include <rtl/ref.hxx>
@@ -65,13 +61,7 @@ namespace configmgr
     namespace backend
     {
 // ---------------------------------------------------------------------------
-    struct CacheLocation
-    {
-        memory::SegmentAddress          segment;
-        memory::SegmentHeap::Address    address;
-            
-        bool isNull() const { return segment.isNull() || address == 0; }
-    };
+    typedef data::TreeAddress CacheLocation;
 // ---------------------------------------------------------------------------
     struct IDirectDataProvider;
     struct ICachedDataNotifier;
Index: configmgr/source/inc/change.hxx
===================================================================
RCS file: /cvs/util/configmgr/source/inc/change.hxx,v
retrieving revision 1.25
retrieving revision 1.25.22.1
diff -u -p -u -p -r1.25 -r1.25.22.1
--- configmgr/source/inc/change.hxx	25 Sep 2006 12:48:57 -0000	1.25
+++ configmgr/source/inc/change.hxx	8 Jan 2007 20:48:54 -0000	1.25.22.1
@@ -45,9 +45,6 @@
 #ifndef CONFIGMGR_TREESEGMENT_HXX
 #include "treesegment.hxx"
 #endif
-#ifndef CONFIGMGR_TREEADDRESS_HXX
-#include "treeaddress.hxx"
-#endif
 
 #ifndef _SAL_TYPES_H_
 #include <sal/types.h>
@@ -242,7 +239,7 @@ namespace configmgr
 		bool isReplacing() const { return m_bReplacing; }
 
 		/// has this been applied and inserted
-		bool wasInserted() const { return m_aInsertedTree.is(); }
+		bool wasInserted() const { return m_aInsertedTree != NULL; }
 
 		/** returns the node this change represents, even if this node does not own the new Node object any more. 
 			This is somewhat dangerous if the node referenced by this object dies before the object itself does.<BR>
Index: configmgr/source/inc/confevents.hxx
===================================================================
RCS file: /cvs/util/configmgr/source/inc/confevents.hxx,v
retrieving revision 1.8
retrieving revision 1.8.84.4
diff -u -p -u -p -r1.8 -r1.8.84.4
--- configmgr/source/inc/confevents.hxx	8 Sep 2005 03:44:58 -0000	1.8
+++ configmgr/source/inc/confevents.hxx	7 Feb 2007 12:00:31 -0000	1.8.84.4
@@ -36,8 +36,8 @@
 #ifndef CONFIGMGR_API_EVENTS_HXX_
 #define CONFIGMGR_API_EVENTS_HXX_
 
-#ifndef _SALHELPER_SIMPLEREFERENCEOBJECT_HXX_
-#include <salhelper/simplereferenceobject.hxx>
+#ifndef CONFIGMGR_UTILITY_HXX_
+#include "utility.hxx"
 #endif
 #ifndef _RTL_REF_HXX_
 #include <rtl/ref.hxx>
@@ -51,19 +51,18 @@ namespace configmgr
 	struct TreeChangeList;
     class RequestOptions;
 
-    namespace memory { class Accessor; }
     namespace configuration { class AbsolutePath; }
     using configuration::AbsolutePath;
 
 	struct IConfigBroadcaster;
-	struct IConfigListener : public virtual salhelper::SimpleReferenceObject
+	struct IConfigListener : public virtual configmgr::SimpleReferenceObject
 	{
 		virtual void disposing(IConfigBroadcaster* pSource) = 0;
 	};
 	struct INodeListener : IConfigListener
 	{
-		virtual void nodeChanged(memory::Accessor const& _aChangedDataAccessor, Change const& aChange, AbsolutePath const& aPath, IConfigBroadcaster* pSource) = 0;
-		virtual void nodeDeleted(memory::Accessor const& _aChangedDataAccessor, AbsolutePath const& aPath, IConfigBroadcaster* pSource) = 0;
+		virtual void nodeChanged(Change const& aChange, AbsolutePath const& aPath, IConfigBroadcaster* pSource) = 0;
+		virtual void nodeDeleted(AbsolutePath const& aPath, IConfigBroadcaster* pSource) = 0;
 	};
 	typedef rtl::Reference<INodeListener> INodeListenerRef;
 
@@ -89,7 +88,7 @@ namespace configmgr
 		virtual void removeListener(const RequestOptions& _aOptions, INodeListenerRef const& pListener);
 
 	protected:
-		virtual void fireChanges(memory::Accessor const& _aChangedDataAccessor, TreeChangeList const& _aChanges, sal_Bool _bError);
+		virtual void fireChanges(TreeChangeList const& _aChanges, sal_Bool _bError);
 	protected:
 		virtual ConfigChangeBroadcastHelper* getBroadcastHelper(const RequestOptions& _aOptions, bool bCreate) = 0;
 		ConfigChangeBroadcastHelper* newBroadcastHelper(); // needed to implement the preceding
Index: configmgr/source/inc/configdefaultprovider.hxx
===================================================================
RCS file: /cvs/util/configmgr/source/inc/configdefaultprovider.hxx,v
retrieving revision 1.6
retrieving revision 1.6.84.1
diff -u -p -u -p -r1.6 -r1.6.84.1
--- configmgr/source/inc/configdefaultprovider.hxx	8 Sep 2005 03:45:12 -0000	1.6
+++ configmgr/source/inc/configdefaultprovider.hxx	11 Jan 2007 10:35:29 -0000	1.6.84.1
@@ -63,11 +63,6 @@ namespace configmgr
 
     namespace uno = com::sun::star::uno;
 //-----------------------------------------------------------------------------
-    namespace memory
-    {
-        class UpdateAccessor;
-    }
-//-----------------------------------------------------------------------------
 	namespace configuration
 	{
 //-----------------------------------------------------------------------------
@@ -103,7 +98,7 @@ namespace configmgr
             bool isValid() const { return !! m_aProxy.is(); }
 
 		/// tries to load a default instance of the specified node
-            std::auto_ptr<ISubtree> getDefaultTree(memory::UpdateAccessor& _aDestinationSpace, Tree const& _aTree, NodeRef const& _aNode) const CFG_UNO_THROW_ALL();
+            std::auto_ptr<ISubtree> getDefaultTree(Tree const& _aTree, NodeRef const& _aNode) const CFG_UNO_THROW_ALL();
 
         /// tries to load default data into the specified tree
             bool fetchDefaultData(TreeRef const& _aTreeRef) const CFG_UNO_THROW_ALL();
Index: configmgr/source/inc/configset.hxx
===================================================================
RCS file: /cvs/util/configmgr/source/inc/configset.hxx,v
retrieving revision 1.15
retrieving revision 1.15.84.4
diff -u -p -u -p -r1.15 -r1.15.84.4
--- configmgr/source/inc/configset.hxx	8 Sep 2005 03:46:23 -0000	1.15
+++ configmgr/source/inc/configset.hxx	12 Jan 2007 17:51:19 -0000	1.15.84.4
@@ -107,8 +107,7 @@ namespace configmgr
 
 			TemplateHolder getTemplate() const;
 
-			ElementTree getElementTree(data::Accessor const& _accessor) const;
-            osl::Mutex& getTreeLock() const;
+			ElementTree getElementTree() const;
 
 			TreeRef getTreeRef() const;
 
@@ -120,12 +119,11 @@ namespace configmgr
 		class ElementTree
 		{
 			ElementTreeHolder m_aTreeHolder;
-            data::Accessor    m_accessor;
 		public:
             static ElementTree emptyElement() { return ElementTree(); }
 
-			ElementTree(data::Accessor const& _accessor, ElementTreeImpl* pTree);
-			ElementTree(data::Accessor const& _accessor, ElementTreeHolder const& pTree);
+			ElementTree(ElementTreeImpl* pTree);
+			ElementTree(ElementTreeHolder const& pTree);
 			ElementTree(ElementTree const& aOther);
 			ElementTree& operator=(ElementTree const& aOther);
 			~ElementTree();
@@ -171,17 +169,14 @@ namespace configmgr
         class SetElementInfo
 		{
             TemplateInfo    m_aTemplateInfo;
-            data::Accessor  m_aSetAccessor;
 		public:
-			SetElementInfo(data::Accessor const& _aSetAccessor, TemplateHolder const& aTemplate);
+			SetElementInfo(TemplateHolder const& aTemplate);
 
 			TemplateHolder getTemplate()        const;
 			TemplateInfo   getTemplateInfo()    const;
 
             UnoType	 getElementType() const { return m_aTemplateInfo.getType(); }
 
-            data::Accessor  getSetDataAccessor() const { return m_aSetAccessor; }
-
 			static TemplateHolder extractElementInfo(Tree const& aTree, NodeRef const& aNode);
 		};
 //-----------------------------------------------------------------------------
@@ -189,11 +184,8 @@ namespace configmgr
 		class SetElementFactory
 		{
 			TemplateProvider m_aProvider;
-            data::Accessor m_aDataAccessor;
-
-            data::Accessor const& getDataAccessor() const { return m_aDataAccessor; };
 		public:
-			SetElementFactory(data::Accessor const& _aDataAccessor, TemplateProvider const& aProvider);
+			SetElementFactory(TemplateProvider const& aProvider);
 			SetElementFactory(SetElementFactory const& aOther);
 			SetElementFactory& operator=(SetElementFactory const& aOther);
 			~SetElementFactory();
Index: configmgr/source/inc/confsvccomponent.hxx
===================================================================
RCS file: /cvs/util/configmgr/source/inc/confsvccomponent.hxx,v
retrieving revision 1.4
retrieving revision 1.4.84.1
diff -u -p -u -p -r1.4 -r1.4.84.1
--- configmgr/source/inc/confsvccomponent.hxx	8 Sep 2005 03:46:36 -0000	1.4
+++ configmgr/source/inc/confsvccomponent.hxx	11 Jan 2007 20:16:00 -0000	1.4.84.1
@@ -75,7 +75,6 @@ namespace configmgr 
 		: public ServiceImplBase
 	{
 	protected:
-		::osl::Mutex m_aMutex;
 		ServiceImplementationInfo const*const     m_info;
 	public:
 		ServiceComponentImpl(ServiceImplementationInfo const* aInfo);
Index: configmgr/source/inc/datalock.hxx
===================================================================
RCS file: /cvs/util/configmgr/source/inc/datalock.hxx,v
retrieving revision 1.3
retrieving revision 1.3.84.2
diff -u -p -u -p -r1.3 -r1.3.84.2
--- configmgr/source/inc/datalock.hxx	8 Sep 2005 03:46:50 -0000	1.3
+++ configmgr/source/inc/datalock.hxx	16 Jan 2007 12:18:20 -0000	1.3.84.2
@@ -33,31 +33,26 @@
  *
  ************************************************************************/
 
-#ifndef CONFIGMGR_DATALOCK_HXX
-#define CONFIGMGR_DATALOCK_HXX
+#ifndef CONFIGMGR_DATALOCK_HXX_
+#define CONFIGMGR_DATALOCK_HXX_
 
-namespace configmgr
-{
-// -----------------------------------------------------------------------------	
-    namespace memory
-    {
-    // -------------------------------------------------------------------------	
-
-        /// class controlling access to a memory::Segment
-        struct DataLock
-        {
-	        virtual void acquireReadAccess() = 0;
-	        virtual void releaseReadAccess() = 0;
+#include <osl/mutex.hxx>
+namespace configmgr {
 
-	        virtual void acquireWriteAccess() = 0; 	        
-	        virtual void releaseWriteAccess() = 0;
-        protected:
-            virtual ~DataLock() {}
-        };
-    // -------------------------------------------------------------------------	
-    }
-// -----------------------------------------------------------------------------	
-} // namespace configmgr
+    class UnoApiLock
+    {
+        static osl::Mutex aCoreLock;
+        static volatile oslInterlockedCount nHeld;
+    public:
+        UnoApiLock()  { acquire(); }
+        ~UnoApiLock() { release(); }
 
-#endif // CONFIGMGR_DATALOCK_HXX
+        static osl::Mutex &getLock() { return aCoreLock; }
+        static void acquire() { aCoreLock.acquire(); nHeld++; }
+        static void release() { nHeld--; aCoreLock.release(); }
+        static bool isHeld() { return nHeld != 0; }
+    };
+}
+using configmgr::UnoApiLock;
 
+#endif // CONFIGMGR_DATALOCK_HXX_
Index: configmgr/source/inc/defaultprovider.hxx
===================================================================
RCS file: /cvs/util/configmgr/source/inc/defaultprovider.hxx,v
retrieving revision 1.6
retrieving revision 1.6.84.3
diff -u -p -u -p -r1.6 -r1.6.84.3
--- configmgr/source/inc/defaultprovider.hxx	8 Sep 2005 03:47:05 -0000	1.6
+++ configmgr/source/inc/defaultprovider.hxx	7 Feb 2007 12:14:54 -0000	1.6.84.3
@@ -68,11 +68,6 @@ namespace configmgr
         class AbsolutePath;
     }
     //-------------------------
-    namespace memory
-    {
-        class Segment;
-    }
-    //-------------------------
     class ISubtree;
     class RequestOptions;
 	//==========================================================================
@@ -111,10 +106,6 @@ namespace configmgr
 	class SAL_NO_VTABLE IDefaultableTreeManager
 	{
 	public:
-        /// get a data segment to host the given location - also available in ITreeManager
-        virtual memory::Segment* getDataSegment(configuration::AbsolutePath const& _rAccessor, 
-                                                const RequestOptions& _aOptions) = 0;
-
         /** attempt to load default data into the tree named by a path using certain options 
             and requiring a specific loading depth.
 
@@ -122,10 +113,9 @@ namespace configmgr
                 <TRUE/>,  if some default data is available within the tree
                 <FALSE/>, if no default data is available for the tree
         */
-        virtual sal_Bool fetchDefaultData(  memory::UpdateAccessor& _aAccessToken, 
-                                            configuration::AbsolutePath const& aSubtreePath, 
-									        const RequestOptions& _xOptions
-									     ) CFG_UNO_THROW_ALL(  ) = 0;
+        virtual sal_Bool fetchDefaultData(configuration::AbsolutePath const& aSubtreePath, 
+                                          const RequestOptions& _xOptions
+                                          ) CFG_UNO_THROW_ALL(  ) = 0;
 
 	};
 
Index: configmgr/source/inc/groupnodeaccess.hxx
===================================================================
RCS file: /cvs/util/configmgr/source/inc/groupnodeaccess.hxx,v
retrieving revision 1.6
retrieving revision 1.6.14.2
diff -u -p -u -p -r1.6 -r1.6.14.2
--- configmgr/source/inc/groupnodeaccess.hxx	6 Nov 2006 14:47:55 -0000	1.6
+++ configmgr/source/inc/groupnodeaccess.hxx	11 Jan 2007 10:35:29 -0000	1.6.14.2
@@ -49,85 +49,59 @@ namespace configmgr
         class GroupNodeAccess
 	    {
         public:
-            typedef NodeAccess::Name        Name;
-            typedef NodeAccess::Attributes  Attributes;
-            typedef GroupNodeAddress                    NodeAddressType;
-            typedef GroupNodeAddress::AddressType       AddressType;
-            typedef GroupNodeAddress::DataType const    DataType;
-            typedef DataType * NodePointerType;
-            typedef NodeAddress                         ChildAddressType;
-            typedef NodeAccessRef                       ChildAccessType;
-
-            GroupNodeAccess(Accessor const& _aAccessor, NodeAddressType const& _aNodeRef) 
-            : m_aAccessor(_aAccessor)
-            , m_pData(_aNodeRef.m_pData) 
-            {}
-
-            GroupNodeAccess(Accessor const& _aAccessor, NodePointerType _pNode) 
-            : m_aAccessor(_aAccessor)
-            , m_pData(check(_aAccessor,_pNode)) 
+            GroupNodeAccess(const sharable::GroupNode *_pNodeRef)
+            : m_pData((GroupNodeAddress)_pNodeRef) 
             {}
 
             explicit
             GroupNodeAccess(NodeAccess const & _aNode) 
-            : m_aAccessor(_aNode.accessor())
-            , m_pData(check(_aNode)) 
-            {
-            }
+            : m_pData(check(_aNode)) 
+            {}
 
-            explicit
-            GroupNodeAccess(NodeAccessRef const & _aNode) 
-            : m_aAccessor(_aNode.accessor())
-            , m_pData(check(_aNode)) 
-            {
-            }
-
-            static bool isInstance(NodeAccessRef const & _aNode) 
-            {
-                return check(_aNode) != NULL;
-            }
+            ~GroupNodeAccess() {}
+
+            static bool isInstance(NodeAccess const & _aNode) 
+                { return check(_aNode) != NULL; }
 
             bool isValid() const { return m_pData != NULL; }
 
-            Name getName() const;
-            Attributes getAttributes() const;
+            configuration::Name getName() const;
+            node::Attributes getAttributes() const;
 
             bool isDefault()   const;
 
-            bool hasChild(Name const& _aName) const 
-            { return implGetChild(_aName).is(); }
+            bool hasChild(configuration::Name const& _aName) const 
+                { return implGetChild(_aName) != NULL; }
           
-            bool hasChildren() const;
-
-            ChildAccessType getChildNode(Name const& _aName) const
-            { return NodeAccessRef(&m_aAccessor, implGetChild(_aName)); }
+            bool hasChildren() const
+                { return m_pData->numDescendants > 0 ? true : false; }
 
-            NodeAddressType address()   const { return NodeAddressType(m_pData); }
-            Accessor const& accessor()  const { return m_aAccessor; }
+            NodeAccess getChildNode(configuration::Name const& _aName) const
+                { return NodeAccess(implGetChild(_aName)); }
 
-            operator NodeAccessRef()    const { return NodeAccessRef(&m_aAccessor,NodeAddress(m_pData)); }
+            operator NodeAccess() const { return NodeAccess(NodeAddress(m_pData)); }
 
-            DataType& data() const { return *static_cast<NodePointerType>(m_aAccessor.validate(m_pData)); }
+            sharable::GroupNode& data() const { return *m_pData; }
+            operator GroupNodeAddress () const { return (GroupNodeAddress)m_pData; }
 
         private:
-            static AddressType check(NodeAccessRef const&);
-            static AddressType check(Accessor const&, NodePointerType);
-
-            ChildAddressType implGetChild(Name const& _aName) const;
+            NodeAddress implGetChild(configuration::Name const& _aName) const;
+            static GroupNodeAddress check(sharable::Node *pNode)
+                { return pNode ? const_cast<GroupNodeAddress>(pNode->groupData()) : NULL; }
+            static GroupNodeAddress check(NodeAccess const&aRef)
+                { return check(static_cast<sharable::Node *>(aRef)); }
 
-            Accessor    m_aAccessor;
-		    AddressType m_pData;
+            GroupNodeAddress m_pData;
         };
 
-        GroupNodeAddress toGroupNodeAddress(memory::Accessor const & _aAccess, NodeAddress const & _aNodeAddr);
-        GroupNodeAddress toGroupNodeAddress(memory::UpdateAccessor & _aAccess, NodeAddress const & _aNodeAddr);
+        GroupNodeAddress toGroupNodeAddress(NodeAddress const & _aNodeAddr);
     // -------------------------------------------------------------------------
         inline 
-        NodeAccess::Name GroupNodeAccess::getName() const 
+        configuration::Name GroupNodeAccess::getName() const 
         { return NodeAccess::wrapName( data().info.getName() ); }
         
         inline           
-        NodeAccess::Attributes GroupNodeAccess::getAttributes() const 
+        node::Attributes GroupNodeAccess::getAttributes() const 
         { return sharable::node(data()).getAttributes(); }
 
         inline           
Index: configmgr/source/inc/mergechange.hxx
===================================================================
RCS file: /cvs/util/configmgr/source/inc/mergechange.hxx,v
retrieving revision 1.8
retrieving revision 1.8.84.2
diff -u -p -u -p -r1.8 -r1.8.84.2
--- configmgr/source/inc/mergechange.hxx	8 Sep 2005 03:49:58 -0000	1.8
+++ configmgr/source/inc/mergechange.hxx	11 Jan 2007 10:35:29 -0000	1.8.84.2
@@ -49,18 +49,14 @@
 
 namespace configmgr 
 {
-	// -----------------------------------------------------------------------------
-    namespace memory    { class UpdateAccessor; }
-    namespace data      { class NodeAddress; }
+    // method that applies changes on a existing subtree
+    void applyUpdateWithAdjustment(TreeChangeList & _anUpdate, data::NodeAddress const & _aBaseAddress);
+    bool adjustUpdate(TreeChangeList & _anUpdate, data::NodeAddress const & _aBaseAddress);
+    void mergeLayer         (TreeChangeList & _aLayer,      ISubtree& _aTree);
+    void combineUpdates     (SubtreeChange  const& _anUpdate, SubtreeChange& _aCombinedUpdate);
+    void applyLayerUpdate   (TreeChangeList const& _anUpdate, TreeChangeList& _aLayer);
 
-	// method that applies changes on a existing subtree
-    void applyUpdateWithAdjustment(TreeChangeList & _anUpdate, memory::UpdateAccessor& _aUpdateAccess, data::NodeAddress const & _aBaseAddress);
-    bool adjustUpdate(TreeChangeList & _anUpdate, memory::UpdateAccessor& _aUpdateAccess, data::NodeAddress const & _aBaseAddress);
-	void mergeLayer         (TreeChangeList & _aLayer,      ISubtree& _aTree);
-	void combineUpdates     (SubtreeChange  const& _anUpdate, SubtreeChange& _aCombinedUpdate);
-	void applyLayerUpdate   (TreeChangeList const& _anUpdate, TreeChangeList& _aLayer);
-
-	// -----------------------------------------------------------------------------
+    // -----------------------------------------------------------------------------
     class OStripDefaults : private ChangeTreeModification
     {
         SubtreeChange& m_rParent;
Index: configmgr/source/inc/node.hxx
===================================================================
RCS file: /cvs/util/configmgr/source/inc/node.hxx,v
retrieving revision 1.6
retrieving revision 1.5.10.3
diff -u -p -u -p -r1.6 -r1.5.10.3
--- configmgr/source/inc/node.hxx	20 Dec 2006 18:44:28 -0000	1.6
+++ configmgr/source/inc/node.hxx	7 Feb 2007 12:00:31 -0000	1.5.10.3
@@ -93,42 +93,35 @@ namespace configmgr
 
             Node * getFirstChild();
             Node * getNextChild(Node * _pChild);
-
             Node const * getFirstChild()  const;
             Node const * getNextChild(Node const * _pChild) const;
+
         };
     //-----------------------------------------------------------------------------
+        typedef sal_uInt8 * SetElementAddress;
         struct SetNode
         {
+
             NodeInfo info;
-            Address  elementType; // points to template
+            SetElementAddress  elementType; // points to template [MM:SetNode *?]
             List     elements;    // points to first element (TreeFragmentHeader)
 
             bool isLocalizedValue() const;
 
-		    rtl::OUString getElementTemplateName  (memory::Accessor const & _anAccessor) const;		
-		    rtl::OUString getElementTemplateModule(memory::Accessor const & _anAccessor) const;
+		    rtl::OUString getElementTemplateName() const;		
+		    rtl::OUString getElementTemplateModule() const;
 
-            TreeFragment const  * getFirstElement(memory::Accessor const & _anAccessor) const;
-            TreeFragment const  * getNextElement(memory::Accessor const & _anAccessor, TreeFragment const * _pElement) const;
+            TreeFragment const  * getFirstElement() const;
+            TreeFragment const  * getNextElement(TreeFragment const * _pElement) const;
 
             // low-level helper for template data abstraction
             static
-            Address allocTemplateData(memory::Allocator const & _anAllocator,
-									  const rtl::OUString &rName,
+            SetElementAddress allocTemplateData(const rtl::OUString &rName,
 									  const rtl::OUString &rModule);
             static 
-			Address copyTemplateData(memory::Allocator const & _anAllocator,
-									 Address _aTemplateData);
-            static
-            void releaseTemplateData(memory::Allocator const & _anAllocator, Address _aTemplateData);
-
+			SetElementAddress copyTemplateData(SetElementAddress _aTemplateData);
             static
-            rtl::OUString getTemplateDataName(memory::Accessor const & _anAccessor,
-											  Address _aTemplateData);
-            static
-            rtl::OUString getTemplateDataModule(memory::Accessor const & _anAccessor,
-												Address _aTemplateData);
+            void releaseTemplateData(SetElementAddress _aTemplateData);
         };
     //-----------------------------------------------------------------------------
         struct ValueNode
@@ -141,10 +134,10 @@ namespace configmgr
 		    bool isNull()       const;
 		    bool hasUsableDefault()   const;
 		    
-		    uno::Type   getValueType()  const;
-		    uno::Any    getValue(memory::Accessor const & _aAccessor)      const;
-		    uno::Any    getUserValue(memory::Accessor const & _aAccessor)    const;
-		    uno::Any    getDefaultValue(memory::Accessor const & _aAccessor) const;
+		    uno::Any    getValue() const;
+		    uno::Type   getValueType() const;
+		    uno::Any    getUserValue() const;
+		    uno::Any    getDefaultValue() const;
         };
     //-----------------------------------------------------------------------------
         // TODO: optimized representation of localized values (now as set; mapping locale->element-name)
@@ -165,17 +158,17 @@ namespace configmgr
             bool isLocalized() const;
 
             // type checks
-            bool isGroup()  const;
-            bool isSet()    const;
-            bool isValue()  const;
+            bool isGroup()  const  { return typeIs (Type::nodetype_group); }
+            bool isSet()    const  { return typeIs (Type::nodetype_set); }
+            bool isValue()  const  { return typeIs (Type::nodetype_value); }
 
             // checked access
-            GroupNode       * groupData();
-            SetNode         * setData();
-            ValueNode       * valueData();
-            GroupNode const * groupData() const;
-            SetNode   const * setData()   const;
-            ValueNode const * valueData() const;
+            inline GroupNode       * groupData();
+            inline GroupNode const * groupData() const;
+            inline SetNode         * setData();
+            inline SetNode   const * setData()   const;
+            inline ValueNode       * valueData();
+            inline ValueNode const * valueData() const;
 
             // navigation
             bool isFragmentRoot() const;
@@ -185,8 +178,25 @@ namespace configmgr
 
             TreeFragment        * getTreeFragment();
             TreeFragment const  * getTreeFragment() const;
+            private:
+            bool typeIs(Type::Type eType) const
+                { return (node.info.type & Type::mask_nodetype) == eType; }
         };
+
     //-----------------------------------------------------------------------------
+        inline GroupNode       * Node::groupData()
+            { return isGroup() ? &this->group : NULL; }
+        inline GroupNode const * Node::groupData() const
+            { return isGroup() ? &this->group : NULL; }
+        inline SetNode       * Node::setData()
+            { return isSet() ? &this->set : NULL; }
+        inline SetNode const * Node::setData()   const
+            { return isSet() ? &this->set : NULL; }
+        inline ValueNode       * Node::valueData()
+            { return isValue() ? &this->value : NULL; }
+        inline ValueNode const * Node::valueData() const
+            { return isValue() ? &this->value : NULL; }
+
         inline Node * node(ValueNode * pNode)        
         { return reinterpret_cast<Node*>(pNode); }
         inline Node * node(GroupNode * pNode)        
@@ -215,6 +225,13 @@ namespace configmgr
         inline Node const & node(SetNode const& pNode)   
         { return reinterpret_cast<Node const&>(pNode); }
     //-----------------------------------------------------------------------------
+    }
+
+    namespace data {
+        typedef sharable::Node      * NodeAddress;
+        typedef sharable::ValueNode * ValueNodeAddress;
+        typedef sharable::GroupNode * GroupNodeAddress;
+        typedef sharable::SetNode   * SetNodeAddress;
     }
 //-----------------------------------------------------------------------------
 }
Index: configmgr/source/inc/nodeaccess.hxx
===================================================================
RCS file: /cvs/util/configmgr/source/inc/nodeaccess.hxx,v
retrieving revision 1.6
retrieving revision 1.6.14.4
diff -u -p -u -p -r1.6 -r1.6.14.4
--- configmgr/source/inc/nodeaccess.hxx	6 Nov 2006 14:48:21 -0000	1.6
+++ configmgr/source/inc/nodeaccess.hxx	7 Feb 2007 12:00:31 -0000	1.6.14.4
@@ -36,13 +36,9 @@
 #ifndef CONFIGMGR_NODEACCESS_HXX
 #define CONFIGMGR_NODEACCESS_HXX
 
-#ifndef CONFIGMGR_NODEADDRESS_HXX
-#include "nodeaddress.hxx"
+#ifndef INCLUDED_SHARABLE_NODE_HXX
+#include "node.hxx"
 #endif
-#ifndef CONFIGMGR_ACCESSOR_HXX
-#include "accessor.hxx"
-#endif
-
 #ifndef _CONFIGMGR_TREE_VALUENODE_HXX
 #include "valuenode.hxx"
 #endif
@@ -52,120 +48,37 @@
 
 namespace configmgr
 {
-// -----------------------------------------------------------------------------	
+// -----------------------------------------------------------------------------		
     namespace data
     {
-    // -------------------------------------------------------------------------
-        using memory::Accessor;
-    // -------------------------------------------------------------------------
-    // -------------------------------------------------------------------------	
+        // -------------------------------------------------------------------------	
         class NodeAccess
-	    {
+        {
         public:
-            typedef configuration::Name     Name;
-            typedef node::Attributes        Attributes;
-
-            typedef NodeAddress                     NodeAddressType;
-            typedef NodeAddress::AddressType        AddressType;
-            typedef NodeAddress::DataType const     DataType;
-            typedef DataType * NodePointerType;
-
-            static NodeAccess emptyNode() { return NodeAccess(); }
-
-            NodeAccess(Accessor const& _aAccessor, NodeAddressType const& _aNodeRef) 
-            : m_aAccessor(_aAccessor)
-            , m_pData(_aNodeRef.m_pData) 
-            {}
+             NodeAccess(const sharable::Node *_pNode)
+                 : m_pData((sharable::Node *)_pNode) {}
 
-            NodeAccess(Accessor const& _aAccessor, NodePointerType _pNode) 
-            : m_aAccessor(_aAccessor)
-            , m_pData(_aAccessor.address(_pNode)) 
-            {}
+             bool isValid() const { return m_pData != NULL; }
 
-            bool isValid() const { return m_pData.is(); }
-            bool isLocalRoot() const { return data().isFragmentRoot(); }
+             configuration::Name getName() const { return wrapName( m_pData->getName() ); }
+             static configuration::Name wrapName(rtl::OUString const& _aNameString)
+                 { return configuration::makeName( _aNameString, configuration::Name::NoValidate() ); }
+
+            // make it look like a pointer ...
+            operator sharable::Node *() const { return (sharable::Node *)m_pData; }
+            operator const sharable::Node * () const { return m_pData; }
+            sharable::Node* operator->() const { return (sharable::Node *)m_pData; }
+            bool operator == (const sharable::Node *pData) const { return pData == m_pData; }
+            bool operator != (const sharable::Node *pData) const { return pData != m_pData; }
 
-            Name getName() const { return wrapName( data().getName() ); }
-            Attributes getAttributes() const { return data().getAttributes(); }
-
-            bool isDefault()   const { return data().isDefault(); }
-            bool isLocalized() const { return data().isLocalized(); }
-
-            NodeAddressType address() const { return NodeAddressType(m_pData); }
-            Accessor const& accessor() const { return m_aAccessor; }
-
-            DataType& data() const { return *static_cast<NodePointerType>(m_aAccessor.validate(m_pData)); }
-            NodePointerType getDataPtr() const { return static_cast<NodePointerType>(m_aAccessor.access(m_pData)); }
-
-            AddressType rawAddress() const { return m_pData; }
-
-            static Name wrapName(rtl::OUString const& _aNameString)
-            { return configuration::makeName( _aNameString, Name::NoValidate() ); }
-
-            static NodeAddress::DataType* access(NodeAddressType const& _aNodeRef, memory::UpdateAccessor& _rUpdateAccess);
-            static NodeAddress::DataType const* access(NodeAddressType const& _aNodeRef, Accessor const& _rReaderAccess)
-            { return static_cast<NodePointerType>(_rReaderAccess.access(_aNodeRef.m_pData)); }
         private:
-            NodeAccess() : m_aAccessor(NULL), m_pData() {}
-
-            Accessor    m_aAccessor;
-		    AddressType m_pData;
+            const sharable::Node * m_pData;
         };
-    // -------------------------------------------------------------------------	
-        class NodeAccessRef
-	    {
-        public:
-            typedef NodeAccess::Name                Name;
-            typedef NodeAccess::Attributes          Attributes;
-
-            typedef NodeAccess::NodeAddressType     NodeAddressType;
-            typedef NodeAccess::AddressType         AddressType;
-            typedef NodeAccess::DataType            DataType;
-            typedef NodeAccess::NodePointerType     NodePointerType;
-
-            NodeAccessRef(NodeAccess const& _aNodeAccess) 
-            : m_pAccessor(&_aNodeAccess.accessor())
-            , m_pData(_aNodeAccess.rawAddress()) 
-            {}
-
-            NodeAccessRef(Accessor const * _pAccessor, NodeAddressType const& _aNodeRef) 
-            : m_pAccessor(_pAccessor)
-            , m_pData(_aNodeRef.m_pData) 
-            {}
-
-            NodeAccessRef(Accessor const * _pAccessor, NodePointerType _pNode) 
-            : m_pAccessor(_pAccessor)
-            , m_pData(_pAccessor->address(_pNode)) 
-            {}
-
-            NodeAccess toNodeAccess () const { return NodeAccess(accessor(),address()); }
-
-            bool isValid() const { return m_pData.is(); }
-            bool isLocalRoot() const { return data().isFragmentRoot(); }
 
-            Name getName() const { return NodeAccess::wrapName( data().getName() ); }
-            Attributes getAttributes() const { return data().getAttributes(); }
-
-            bool isDefault()   const { return data().isDefault(); }
-            bool isLocalized() const { return data().isLocalized(); }
-
-            NodeAddressType address() const { return NodeAddressType(m_pData); }
-            Accessor const& accessor() const { return *m_pAccessor; }
-
-            DataType& data() const { return *static_cast<NodePointerType>(m_pAccessor->validate(m_pData)); }
-            NodePointerType getDataPtr() const { return static_cast<NodePointerType>(m_pAccessor->access(m_pData)); }
-
-            AddressType rawAddress() const { return m_pData; }
-
-        private:
-            Accessor const *   m_pAccessor;
-		    AddressType m_pData;
-        };
     // -------------------------------------------------------------------------
     // helper - finds child or element
-        NodeAccess  getSubnode(NodeAccessRef const & _aNode, NodeAccess::Name const & _aName);
-        NodeAddress getSubnodeAddress(memory::Accessor const& _aAccess, NodeAddress const & _aNodeAddress, NodeAccess::Name const & _aName);
-        NodeAddress getSubnodeAddress(memory::UpdateAccessor& _aAccess, NodeAddress const & _aNodeAddress, NodeAccess::Name const & _aName);
+    NodeAccess  getSubnode(NodeAccess const & _aNode, configuration::Name const & _aName);
+    NodeAddress getSubnodeAddress(NodeAddress const & _aNodeAddress, configuration::Name const & _aName);
     // -------------------------------------------------------------------------
     }
 // -----------------------------------------------------------------------------	
Index: configmgr/source/inc/nodechangeinfo.hxx
===================================================================
RCS file: /cvs/util/configmgr/source/inc/nodechangeinfo.hxx,v
retrieving revision 1.9
retrieving revision 1.9.22.3
diff -u -p -u -p -r1.9 -r1.9.22.3
--- configmgr/source/inc/nodechangeinfo.hxx	25 Sep 2006 12:49:10 -0000	1.9
+++ configmgr/source/inc/nodechangeinfo.hxx	12 Jan 2007 14:50:44 -0000	1.9.22.3
@@ -128,8 +128,8 @@ namespace configmgr
 
 		//-------------------------------------------------
 		// wrapper object creation 
-			Tree	getNewElementTree(data::Accessor const& aAccessor) const;
-			Tree	getOldElementTree(data::Accessor const& aAccessor) const;
+			Tree	getNewElementTree() const;
+			Tree	getOldElementTree() const;
 
 			NodeRef getNewElementNodeRef() const;
 			NodeRef getOldElementNodeRef() const;
@@ -166,19 +166,19 @@ namespace configmgr
 			bool isValidData() const;
 
 			/// check whether the location is for a valid object
-			bool isValidLocation(data::Accessor const& aAccessor) const;
+			bool isValidLocation() const;
 
 		//-------------------------------------------------
 			/// retrieve the path from the base node to the changed node (which might be a child of the affected node)
 			RelativePath getAccessor() const { return m_path; }
 
 			/// retrieve the tree where the change is actually initiated/reported
-			Tree getBaseTree(data::Accessor const& aAccessor) const;
+			Tree getBaseTree() const;
 			/// retrieve the node where the change is actually initiated/reported
 			NodeRef getBaseNode() const;
 
 			/// retrieve the tree where the change is actually taking place (may be Empty, if the tree has never been accessed)
-			Tree getAffectedTree(data::Accessor const& aAccessor) const;
+			Tree getAffectedTree() const;
 			/// retrieve the tree where the change is actually taking place (may be Empty, if the tree has never been accessed)
 			TreeRef getAffectedTreeRef() const;
 			/// retrieve the node where the change is actually taking place (if the affected Tree is not empty)
@@ -220,19 +220,17 @@ namespace configmgr
 		public:
 		//-------------------------------------------------
             explicit
-            NodeChangeInformation(data::Accessor const& _accessor)
-            : accessor(_accessor)
-            , change()
+            NodeChangeInformation()
+            : change()
             , location()
             {
             }
 		//-------------------------------------------------
-            data::Accessor      accessor;
 			NodeChangeData		change;
 			NodeChangeLocation	location;
 
 		//-------------------------------------------------
-			bool hasValidLocation() const { return location.isValidLocation(accessor); }
+			bool hasValidLocation() const { return location.isValidLocation(); }
 			bool isDataChange()		const { return change.isDataChange(); }
 
 			bool isEmptyChange()	const { return change.isEmptyChange(); }
Index: configmgr/source/inc/noderef.hxx
===================================================================
RCS file: /cvs/util/configmgr/source/inc/noderef.hxx,v
retrieving revision 1.18
retrieving revision 1.18.62.7
diff -u -p -u -p -r1.18 -r1.18.62.7
--- configmgr/source/inc/noderef.hxx	19 Jan 2006 17:53:48 -0000	1.18
+++ configmgr/source/inc/noderef.hxx	7 Feb 2007 12:14:54 -0000	1.18.62.7
@@ -42,9 +42,6 @@
 #ifndef CONFIGMGR_CONFIGPATH_HXX_
 #include "configpath.hxx"
 #endif
-#ifndef CONFIGMGR_ACCESSOR_HXX
-#include "accessor.hxx"
-#endif
 
 #ifndef INCLUDED_VECTOR
 #include <vector>
@@ -53,18 +50,18 @@
 
 namespace configmgr
 {
-	class INode;
+    class INode;
 
-    namespace data      { using memory::Accessor; class TreeAccessor; }
-	namespace view      { class ViewTreeAccess; }
-	namespace configapi { class Factory; }
-	namespace node      { struct Attributes; }
-	namespace configuration
-	{
+    namespace data      { class TreeAccessor; }
+    namespace view      { class ViewTreeAccess; }
+    namespace configapi { class Factory; }
+    namespace node      { struct Attributes; }
+    namespace configuration
+    {
 	//-------------------------------------------------------------------------
-		class Name;
-		class AbsolutePath;
-		class RelativePath;
+	class Name;
+	class AbsolutePath;
+	class RelativePath;
         namespace Path { class Component; }
 
 		class NodeChange;
@@ -222,9 +219,8 @@ namespace configmgr
             typedef node::Attributes NodeAttributes;
 		public:
 			/// create a tree with a given implementation
-            Tree(data::Accessor const& _accessor, TreeImpl* pImpl);
-			/// create a tree with a given implementation
-            Tree(data::Accessor const& _accessor, TreeRef const& _aTree);
+            Tree(TreeImpl* pImpl);
+            Tree(TreeRef const& _aTree);
 
 			/// checks, if this refers to an existing tree
 			bool isValid() const
@@ -467,18 +463,13 @@ namespace configmgr
 
         // view & data layer binding
         public:
-            data::Accessor const & getDataAccessor() const { return m_accessor; }
-
             view::ViewTreeAccess getView() const;
 
-			void rebind(data::Accessor const& _aAccessor);
-			void unbind();
 		// Comparison
 		public:
 			friend bool equalTree(Tree const& lhs, Tree const& rhs) { return equalTreeRef(lhs.m_ref, rhs.m_ref); }
 		private:
 			friend class TreeImplHelper;
-            data::Accessor  m_accessor;
 			TreeRef         m_ref;
 		};
 	//-------------------------------------------------------------------------
@@ -615,9 +606,6 @@ namespace configmgr
 
 		/// test whether the given inner node is a set node
 		bool isSetNode(Tree const& aTree, NodeRef const& aNode);
-
-        osl::Mutex&             getRootLock(TreeRef const& aTree);
-        memory::Segment const * getRootSegment(TreeRef const& aTree);
 
 		typedef std::vector<NodeID>		NodeIDList;
 
Index: configmgr/source/inc/nodevisitor.hxx
===================================================================
RCS file: /cvs/util/configmgr/source/inc/nodevisitor.hxx,v
retrieving revision 1.5
retrieving revision 1.5.42.1
diff -u -p -u -p -r1.5 -r1.5.42.1
--- configmgr/source/inc/nodevisitor.hxx	19 Jun 2006 23:24:01 -0000	1.5
+++ configmgr/source/inc/nodevisitor.hxx	11 Jan 2007 10:35:30 -0000	1.5.42.1
@@ -36,13 +36,15 @@
 #ifndef CONFIGMGR_NODEVISITOR_HXX
 #define CONFIGMGR_NODEVISITOR_HXX
 
+#include "nodeaccess.hxx"
+
 namespace configmgr
 {
 // -----------------------------------------------------------------------------	
     namespace data
     {
     // -------------------------------------------------------------------------	
-        class NodeAccessRef;
+      //        class NodeAccess;
             class ValueNodeAccess;
             class GroupNodeAccess;
             class SetNodeAccess;
@@ -65,11 +67,11 @@ namespace configmgr
             Result visitChildren(GroupNodeAccess const& _aNode);
 
             /// dispatch to <var>aNode</var> as the proper type
-            Result visitNode(NodeAccessRef const& _aNode);
+            Result visitNode(NodeAccess const& _aNode);
 
         protected:
 			/// do the operation on <var>aNode</var>. Default implementation returns CONTINUE.
-			virtual Result handle(NodeAccessRef const& _aNode);
+			virtual Result handle(NodeAccess const& _aNode);
 
 			/// do the operation on <var>aNode</var>. Default implementation calls handle(NodeAccess(_aNode));
 			virtual Result handle(ValueNodeAccess const& _aNode);
Index: configmgr/source/inc/options.hxx
===================================================================
RCS file: /cvs/util/configmgr/source/inc/options.hxx,v
retrieving revision 1.20
retrieving revision 1.20.42.1
diff -u -p -u -p -r1.20 -r1.20.42.1
--- configmgr/source/inc/options.hxx	19 Jun 2006 23:24:15 -0000	1.20
+++ configmgr/source/inc/options.hxx	11 Jan 2007 20:16:01 -0000	1.20.42.1
@@ -47,8 +47,8 @@
 #include <com/sun/star/uno/Reference.hxx>
 #endif
 
-#ifndef _SALHELPER_SIMPLEREFERENCEOBJECT_HXX_
-#include <salhelper/simplereferenceobject.hxx>
+#ifndef CONFIGMGR_UTILITY_HXX_
+#include "utility.hxx"
 #endif
 #ifndef _VOS_REF_HXX_
 #include <vos/ref.hxx>
@@ -66,7 +66,7 @@ namespace configmgr
 	   the new options or important options etc.
 	*/
 	
-	class OOptions : public salhelper::SimpleReferenceObject
+	class OOptions : public configmgr::SimpleReferenceObject
 	{
         RequestOptions  m_aRequestOptions;  // current options to use
 
@@ -86,7 +86,7 @@ namespace configmgr
 		}
 		
 		OOptions(const OOptions& _aOtherOptions)
-		: salhelper::SimpleReferenceObject()
+        : configmgr::SimpleReferenceObject()
         , m_aRequestOptions(_aOtherOptions.m_aRequestOptions)
 		{
 		}
Index: configmgr/source/inc/pointer.hxx
===================================================================
RCS file: /cvs/util/configmgr/source/inc/pointer.hxx,v
retrieving revision 1.5
retrieving revision 1.5.68.1
diff -u -p -u -p -r1.5 -r1.5.68.1
--- configmgr/source/inc/pointer.hxx	28 Dec 2005 17:30:54 -0000	1.5
+++ configmgr/source/inc/pointer.hxx	8 Jan 2007 20:48:56 -0000	1.5.68.1
@@ -32,59 +32,3 @@
  *    MA  02111-1307  USA
  *
  ************************************************************************/
-
-#ifndef CONFIGMGR_POINTER_HXX
-#define CONFIGMGR_POINTER_HXX
-
-#ifndef CONFIGMGR_MEMORYMODEL_HXX
-#include "memorymodel.hxx"
-#endif
-
-namespace configmgr
-{
-// -----------------------------------------------------------------------------	
-    namespace memory
-    {
-    // -------------------------------------------------------------------------
-        class Accessor;
-        class UpdateAccessor;
-    // -------------------------------------------------------------------------	
-        /// class mediating read-only access to a memory::Segment
-        class Pointer 
-        {
-            friend class Accessor;
-            friend class UpdateAccessor;
-
-            typedef memory::Address AddressType;
-
-            AddressType m_value;
-
-            struct Opaque_;
-        public:
-            typedef AddressType RawAddress;
-
-            Pointer() : m_value(0) {}
-            explicit Pointer(AddressType p) : m_value(p) {}
-
-            RawAddress value() const { return m_value; }
-
-            bool isNull()   const { return m_value == 0; }
-            bool is()       const { return m_value != 0; }
-
-            operator Opaque_ const * () const { return reinterpret_cast<Opaque_ const *>(m_value); }
-
-            friend bool operator == (Pointer lhs, Pointer rhs)
-            { return lhs.value() == rhs.value(); }
-
-            friend bool operator != (Pointer lhs, Pointer rhs)
-            { return lhs.value() != rhs.value(); }
-        };
-
-    // -------------------------------------------------------------------------	
-    }
-// -----------------------------------------------------------------------------	
-} // namespace configmgr
-// -----------------------------------------------------------------------------
-
-#endif // CONFIGMGR_POINTER_HXX
-
Index: configmgr/source/inc/requesttypes.hxx
===================================================================
RCS file: /cvs/util/configmgr/source/inc/requesttypes.hxx,v
retrieving revision 1.8
retrieving revision 1.8.84.1
diff -u -p -u -p -r1.8 -r1.8.84.1
--- configmgr/source/inc/requesttypes.hxx	8 Sep 2005 03:54:19 -0000	1.8
+++ configmgr/source/inc/requesttypes.hxx	11 Jan 2007 20:16:01 -0000	1.8.84.1
@@ -46,8 +46,8 @@
 #include "configpath.hxx"
 #endif
 
-#ifndef _SALHELPER_SIMPLEREFERENCEOBJECT_HXX_
-#include <salhelper/simplereferenceobject.hxx>
+#ifndef _CONFIGMGR_UTILITY_HXX_
+#include <utility.hxx>
 #endif
 
 #ifndef INCLUDED_MEMORY
@@ -218,9 +218,10 @@ namespace configmgr
         template <class Instance_>
         class ResultHolder
         {
-            struct RCInstance : public salhelper::SimpleReferenceObject
+            struct RCInstance : public configmgr::SimpleReferenceObject
             {
-                RCInstance(Instance_ & _instance) : instance(_instance) {}
+                RCInstance(Instance_ & _instance)
+                    : instance(_instance) {}
                 Instance_ instance;
             };
             typedef rtl::Reference< RCInstance > InstanceRef;
Index: configmgr/source/inc/roottree.hxx
===================================================================
RCS file: /cvs/util/configmgr/source/inc/roottree.hxx,v
retrieving revision 1.12
retrieving revision 1.12.84.3
diff -u -p -u -p -r1.12 -r1.12.84.3
--- configmgr/source/inc/roottree.hxx	8 Sep 2005 03:54:35 -0000	1.12
+++ configmgr/source/inc/roottree.hxx	7 Feb 2007 12:14:54 -0000	1.12.84.3
@@ -53,13 +53,6 @@ namespace configmgr
 	struct TreeChangeList;
 //-----------------------------------------------------------------------------
 
-    namespace memory
-    {
-        class Segment;
-        class Accessor;
-    }
-//-----------------------------------------------------------------------------
-
     namespace data
     {
         class NodeAccess;
@@ -82,13 +75,11 @@ namespace configmgr
 //-----------------------------------------------------------------------------
 
 		RootTree createReadOnlyTree(	AbsolutePath const& aRootPath, 
-                                        memory::Segment const* _pDataSegment, 
                                         data::NodeAccess const& _aCacheNode, 
                                         TreeDepth nDepth,
 										TemplateProvider const& aTemplateProvider);
 
 		RootTree createUpdatableTree(	AbsolutePath const& aRootPath, 
-                                        memory::Segment const* _pDataSegment, 
                                         data::NodeAccess const& _aCacheNode, 
                                         TreeDepth nDepth,
 										TemplateProvider const& aTemplateProvider);
@@ -105,14 +96,14 @@ namespace configmgr
 			~CommitHelper();
 
 			// collect all changes into rChangeList
-            bool prepareCommit(memory::Accessor const & _aAccessor, TreeChangeList& rChangeList);
+            bool prepareCommit(TreeChangeList& rChangeList);
 
 			// finish and clean up the changes in rChangeList after they are integrated
-			void finishCommit(memory::Accessor const & _aAccessor, TreeChangeList& rChangeList);
+			void finishCommit(TreeChangeList& rChangeList);
 			// restore the changes in rChangeList as pending
-			void revertCommit(memory::Accessor const & _aAccessor, TreeChangeList& rChangeList);
+			void revertCommit(TreeChangeList& rChangeList);
 			// throw away and clean up the changes in rChangeList after a commit failed
-			void failedCommit(memory::Accessor const & _aAccessor, TreeChangeList& rChangeList);
+			void failedCommit(TreeChangeList& rChangeList);
 
 			// dispose of auxiliary data for a commit operation
 			void reset();
Index: configmgr/source/inc/sequence.hxx
===================================================================
RCS file: /cvs/util/configmgr/source/inc/sequence.hxx,v
retrieving revision 1.2
retrieving revision 1.2.84.2
diff -u -p -u -p -r1.2 -r1.2.84.2
--- configmgr/source/inc/sequence.hxx	8 Sep 2005 03:55:37 -0000	1.2
+++ configmgr/source/inc/sequence.hxx	12 Jan 2007 17:51:20 -0000	1.2.84.2
@@ -56,19 +56,17 @@ namespace configmgr
         typedef Vector Sequence; // alternative name
     //-----------------------------------------------------------------------------
        
-        Sequence allocSequence(memory::Allocator const& _anAllocator, AnyData::TypeCode _aElementType, ::sal_Sequence const * _pSeqData);
-    //    Sequence copySequence(memory::Allocator const& _anAllocator, AnyData::TypeCode _aElementType, Sequence _aSeq);
-        void     freeSequence(memory::Allocator const& _anAllocator, AnyData::TypeCode _aElementType, Sequence _aSeq);
+        Sequence allocSequence(AnyData::TypeCode _aElementType, ::sal_Sequence const * _pSeqData);
+        void     freeSequence(AnyData::TypeCode _aElementType, Sequence _aSeq);
 
-        ::sal_Sequence * readSequence(memory::Accessor const& _anAccessor, AnyData::TypeCode _aElementType, Sequence _aSeq);
-        ::com::sun::star::uno::Any readAnySequence(memory::Accessor const& _anAccessor, AnyData::TypeCode _aElementType, Sequence _aSeq);
+        ::sal_Sequence * readSequence(AnyData::TypeCode _aElementType, Sequence _aSeq);
+        ::com::sun::star::uno::Any readAnySequence(AnyData::TypeCode _aElementType, Sequence _aSeq);
     //-----------------------------------------------------------------------------
 
-        Sequence allocBinary(memory::Allocator const& _anAllocator, ::com::sun::star::uno::Sequence<sal_Int8> const & _aBinaryValue);
-    //    Sequence copyBinary(memory::Allocator const& _anAllocator, Sequence _aSeq);
-        void freeBinary(memory::Allocator const& _anAllocator, Sequence _aSeq);
+        Sequence allocBinary(::com::sun::star::uno::Sequence<sal_Int8> const & _aBinaryValue);
+        void freeBinary(Sequence _aSeq);
 
-        ::com::sun::star::uno::Sequence<sal_Int8> readBinary(memory::Accessor const& _anAccessor, Sequence _aSeq);
+        ::com::sun::star::uno::Sequence<sal_Int8> readBinary(Sequence _aSeq);
     //-----------------------------------------------------------------------------
 
         template <class ET>
@@ -80,19 +78,19 @@ namespace configmgr
         }
 
         template <class ET>
-        Sequence allocSequence(memory::Allocator const& _anAllocator, ::com::sun::star::uno::Sequence<ET> const & _aSeq)
+        Sequence allocSequence(::com::sun::star::uno::Sequence<ET> const & _aSeq)
         {
             AnyData::TypeCode aTC = getElementTypeCode(_aSeq);
             ::sal_Sequence const * pSeqData = _aSeq.get();
-            return allocSequence(_anAllocator, aTC, pSeqData);
+            return allocSequence(aTC, pSeqData);
         }
 
         template <class ET>
-        void readSequence(::com::sun::star::uno::Sequence<ET> & _rSeq, memory::Accessor const& _anAccessor, Sequence _aSeq)
+        void readSequence(::com::sun::star::uno::Sequence<ET> & _rSeq, Sequence _aSeq)
         {
             AnyData::TypeCode aElementType = getElementTypeCode(_rSeq);
 
-            ::sal_Sequence * pNewSequence = readSequence(_anAccessor, aElementType, _aSeq);
+            ::sal_Sequence * pNewSequence = readSequence(aElementType, _aSeq);
 
             if (!pNewSequence) return;
 
@@ -102,11 +100,11 @@ namespace configmgr
         }
 
         template <class ET>
-        bool readSequence(::com::sun::star::uno::Sequence<ET> & _rSeq, memory::Accessor const& _anAccessor, AnyData::TypeCode _aElementType, Sequence _aSeq)
+        bool readSequence(::com::sun::star::uno::Sequence<ET> & _rSeq, AnyData::TypeCode _aElementType, Sequence _aSeq)
         {
             if (getElementTypeCode(_rSeq) != _aElementType) return false;
 
-            ::sal_Sequence * pNewSequence = readSequence(_anAccessor, _aElementType, _aSeq);
+            ::sal_Sequence * pNewSequence = readSequence(_aElementType, _aSeq);
 
             if (!pNewSequence) return false;
 
Index: configmgr/source/inc/setnodeaccess.hxx
===================================================================
RCS file: /cvs/util/configmgr/source/inc/setnodeaccess.hxx,v
retrieving revision 1.5
retrieving revision 1.5.14.2
diff -u -p -u -p -r1.5 -r1.5.14.2
--- configmgr/source/inc/setnodeaccess.hxx	6 Nov 2006 14:48:34 -0000	1.5
+++ configmgr/source/inc/setnodeaccess.hxx	11 Jan 2007 10:35:31 -0000	1.5.14.2
@@ -39,6 +39,11 @@
 #ifndef CONFIGMGR_NODEACCESS_HXX
 #include "nodeaccess.hxx"
 #endif
+#ifndef INCLUDED_SHARABLE_TREEFRAGMENT_HXX
+#include "treefragment.hxx"
+#endif
+
+#include "treeaccessor.hxx"
 
 namespace configmgr
 {
@@ -46,7 +51,6 @@ namespace configmgr
     namespace data
     {
     // -------------------------------------------------------------------------
-        class TreeAddress;
         class TreeAccessor;
     // -------------------------------------------------------------------------
         /** class that mediates access to the data of a Set node
@@ -55,95 +59,78 @@ namespace configmgr
         class SetNodeAccess
 	    {
         public:
-            typedef NodeAccess::Name        Name;
-            typedef NodeAccess::Attributes  Attributes;
-            typedef SetNodeAddress                    NodeAddressType;
-            typedef SetNodeAddress::AddressType       AddressType;
-            typedef SetNodeAddress::DataType const    DataType;
-            typedef DataType * NodePointerType;
-            typedef TreeAddress                       ElementAddress;
-            typedef TreeAccessor                      ElementAccess;
-
-            SetNodeAccess(Accessor const& _aAccessor, NodeAddressType const& _aNodeRef) 
-            : m_aAccessor(_aAccessor)
-            , m_pData(_aNodeRef.m_pData) 
+            typedef TreeAddress    ElementAddress;
+            typedef TreeAccessor   ElementAccess;
+
+            SetNodeAccess(const sharable::SetNode *_pNodeRef) 
+                : m_pData((SetNodeAddress)_pNodeRef) 
             {}
 
-            SetNodeAccess(Accessor const& _aAccessor, NodePointerType _pNode) 
-            : m_aAccessor(_aAccessor)
-            , m_pData(check(_aAccessor,_pNode)) 
+            SetNodeAccess(const sharable::Node *_pNodeRef) 
+                : m_pData(check(_pNodeRef))
             {}
 
             explicit
             SetNodeAccess(NodeAccess const & _aNode) 
-            : m_aAccessor(_aNode.accessor())
-            , m_pData(check(_aNode)) 
-            {
-            }
+                : m_pData(check(_aNode)) 
+            {}
 
-            explicit
-            SetNodeAccess(NodeAccessRef const & _aNode) 
-            : m_aAccessor(_aNode.accessor())
-            , m_pData(check(_aNode)) 
-            {
-            }
-
-            static bool isInstance(NodeAccessRef const & _aNode) 
-            {
-                return check(_aNode) != NULL;
-            }
+            static bool isInstance(NodeAccess const & _aNode) 
+                { return check(_aNode) != NULL; }
 
             bool isValid() const { return m_pData != NULL; }
 
-            Name getName() const;
-            Attributes getAttributes() const;
+            configuration::Name getName() const;
+            node::Attributes getAttributes() const;
 
             bool isDefault()   const;
 
-		    bool isLocalizedValueSetNode() const;
-
-		    Name getElementTemplateName()   const;		
-		    Name getElementTemplateModule() const;	
+            bool isLocalizedValueSetNode() const;
 
-            bool            hasElement      (Name const& _aName) const; 
-            ElementAccess   getElementTree  (Name const& _aName) const;
+            configuration::Name getElementTemplateName()   const;		
+            configuration::Name getElementTemplateModule() const;	
 
-            NodeAddressType address()   const { return NodeAddressType(m_pData); }
-            Accessor const& accessor()  const { return m_aAccessor; }
+            bool            hasElement      (configuration::Name const& _aName) const
+                { return SetNodeAccess::implGetElement(_aName) != NULL; }
+            ElementAccess   getElementTree  (configuration::Name const& _aName) const
+                { return TreeAccessor(implGetElement(_aName)); }
 
-            operator NodeAccessRef() const { return NodeAccessRef(&m_aAccessor,NodeAddress(m_pData)); }
+            operator NodeAccess() const { return NodeAccess(NodeAddress(m_pData)); }
 
-            DataType& data() const { return *static_cast<NodePointerType>(m_aAccessor.validate(m_pData)); }
+            sharable::SetNode & data() const { return *m_pData; }
+            operator SetNodeAddress () const { return (SetNodeAddress)m_pData; }
+            operator NodeAddress () const { return (NodeAddress)m_pData; }
 
-            static void addElement(memory::UpdateAccessor & _aAccessor, SetNodeAddress _aSetAddress, ElementAddress _aNewElement);
-            static ElementAddress removeElement(memory::UpdateAccessor & _aAccessor, SetNodeAddress _aSetAddress, Name const & _aName);
+            static void addElement(SetNodeAddress _aSetAddress, ElementAddress _aNewElement);
+            static ElementAddress removeElement(SetNodeAddress _aSetAddress,
+						configuration::Name const & _aName);
         private:
-            static AddressType check(NodeAccessRef const&);
-            static AddressType check(Accessor const&, NodePointerType);
+            static SetNodeAddress check(sharable::Node *pNode)
+                { return pNode ? const_cast<SetNodeAddress>(pNode->setData()) : NULL; }
+            static SetNodeAddress check(NodeAccess const&aRef)
+                { return check(static_cast<sharable::Node *>(aRef)); }
 
-            ElementAddress implGetElement(Name const& _aName) const;
+            ElementAddress implGetElement(configuration::Name const& _aName) const;
 
-            Accessor    m_aAccessor;
-		    AddressType m_pData;
+            SetNodeAddress m_pData;
         };
 
-        SetNodeAddress toSetNodeAddress(memory::Accessor const & _aAccess, NodeAddress const & _aNodeAddr);
-        SetNodeAddress toSetNodeAddress(memory::UpdateAccessor & _aAccess, NodeAddress const & _aNodeAddr);
+        SetNodeAddress toSetNodeAddress(NodeAddress const & _aNodeAddr);
     // -------------------------------------------------------------------------
         inline 
-        NodeAccess::Name SetNodeAccess::getName() const 
+        configuration::Name SetNodeAccess::getName() const 
         { return NodeAccess::wrapName( data().info.getName() ); }
         
         inline 
-		NodeAccess::Name SetNodeAccess::getElementTemplateName()   const 
-        { return NodeAccess::wrapName( data().getElementTemplateName(m_aAccessor) ); }	
+        configuration::Name SetNodeAccess::getElementTemplateName()   const 
+        { return NodeAccess::wrapName( data().getElementTemplateName() ); }	
         
         inline 
-		NodeAccess::Name SetNodeAccess::getElementTemplateModule() const 
-        { return NodeAccess::wrapName( data().getElementTemplateModule(m_aAccessor) ); }	
+        configuration::Name SetNodeAccess::getElementTemplateModule() const 
+        { return NodeAccess::wrapName( data().getElementTemplateModule() ); }	
         
         inline           
-        NodeAccess::Attributes SetNodeAccess::getAttributes() const 
+        node::Attributes SetNodeAccess::getAttributes() const 
         { return sharable::node(data()).getAttributes(); }
 
         inline           
Index: configmgr/source/inc/template.hxx
===================================================================
RCS file: /cvs/util/configmgr/source/inc/template.hxx,v
retrieving revision 1.12
retrieving revision 1.12.84.2
diff -u -p -u -p -r1.12 -r1.12.84.2
--- configmgr/source/inc/template.hxx	8 Sep 2005 03:57:48 -0000	1.12
+++ configmgr/source/inc/template.hxx	12 Jan 2007 17:51:20 -0000	1.12.84.2
@@ -43,15 +43,11 @@
 #include "configpath.hxx"
 #endif
 
-#ifndef CONFIGMGR_ACCESSOR_HXX
-#include "accessor.hxx"
-#endif
-
 #ifndef _RTL_REF_HXX_
 #include <rtl/ref.hxx>
 #endif
-#ifndef _SALHELPER_SIMPLEREFERENCEOBJECT_HXX_
-#include <salhelper/simplereferenceobject.hxx>
+#ifndef _CONFIGMGR_UTILITY_HXX_
+#include <utility.hxx>
 #endif
 
 namespace configmgr
@@ -116,7 +112,7 @@ namespace configmgr
 		typedef rtl::Reference<Template> TemplateHolder;
 
 		/// provides information about the elements of a <type>Node</type> that is a Container ("set").
-		class Template : public salhelper::SimpleReferenceObject
+		class Template : public configmgr::SimpleReferenceObject
 		{
 			Name		m_aName;
 			Name		m_aModule;
Index: configmgr/source/inc/treeaccessor.hxx
===================================================================
RCS file: /cvs/util/configmgr/source/inc/treeaccessor.hxx,v
retrieving revision 1.6
retrieving revision 1.6.14.2
diff -u -p -u -p -r1.6 -r1.6.14.2
--- configmgr/source/inc/treeaccessor.hxx	6 Nov 2006 14:48:46 -0000	1.6
+++ configmgr/source/inc/treeaccessor.hxx	11 Jan 2007 10:35:31 -0000	1.6.14.2
@@ -36,108 +36,62 @@
 #ifndef CONFIGMGR_TREEACCESSOR_HXX
 #define CONFIGMGR_TREEACCESSOR_HXX
 
-#ifndef CONFIGMGR_TREEADDRESS_HXX
-#include "treeaddress.hxx"
-#endif
-#ifndef CONFIGMGR_ACCESSOR_HXX
-#include "accessor.hxx"
-#endif
 #ifndef CONFIGMGR_NODEACCESS_HXX
 #include "nodeaccess.hxx"
 #endif
+#ifndef INCLUDED_SHARABLE_TREEFRAGMENT_HXX
+#include "treefragment.hxx"
+#endif
 
 #ifndef INCLUDED_CSTDDEF
 #include <cstddef>
 #define INCLUDED_CSTDDEF
 #endif
+#ifndef CONFIGMGR_BUILDDATA_HXX
+#include <builddata.hxx>
+#endif
 
 namespace configmgr
 {
 // -----------------------------------------------------------------------------	
        
-    namespace memory { class UpdateAccessor; }
 // -----------------------------------------------------------------------------	
     namespace data
     {
     // -------------------------------------------------------------------------
-        using memory::Accessor;
-    // -------------------------------------------------------------------------
-        class ValueNodeAccess;
-        class GroupNodeAccess;
-        class SetNodeAccess;
-    // -------------------------------------------------------------------------
+//      typedef sharable::TreeFragment * TreeAddress;
+
         /** class that mediates access to the data of a tree fragment
         */
         class TreeAccessor
 	    {
         public:
-            typedef configuration::Name     Name;
-            typedef node::Attributes        Attributes;
-            typedef TreeAddress                 DataAddressType;
-            typedef TreeAddress::DataType const DataType;
-            typedef DataType  * DataPointerType;
-
-            static TreeAccessor emptyTree() { return TreeAccessor(); }
-
-            TreeAccessor(Accessor const& _aAccessor, DataAddressType const& _aTreeRef) 
-            : m_aAccessor(_aAccessor)
-            , m_pBase(_aTreeRef.m_pData) 
-            {}
-
-            TreeAccessor(Accessor const& _aAccessor, DataPointerType _pTree) 
-            : m_aAccessor(_aAccessor)
-            , m_pBase(_aAccessor.address(_pTree)) 
-            {}
-
-            bool isValid() const { return m_pBase.is(); }
-
-            bool isDefault() const { return data().isDefault(); }
-
-            Attributes getAttributes() const { return data().getAttributes(); }
-            Name getName() const;
+            TreeAccessor(sharable::TreeFragment *_aTreeRef)
+                : m_pTree(_aTreeRef) {}
+            TreeAccessor(const sharable::TreeFragment * _pTree) 
+                : m_pTree((sharable::TreeFragment *)_pTree) {}
+
+            inline configuration::Name getName() const
+                { return configuration::makeName( m_pTree->getName(),
+                                                  configuration::Name::NoValidate() ); }
+
+            NodeAccess getRootNode() const
+                { return NodeAccess(m_pTree ? const_cast<sharable::Node *>(m_pTree->nodes) : NULL); }
+
+            TreeAddress copyTree() const
+                { return data::buildTree(*this); }
+            static void freeTree(TreeAddress _aTree)
+                { data::destroyTree(_aTree); }
+
+            // make it look like a pointer ...
+            operator sharable::TreeFragment *() const { return (sharable::TreeFragment *)m_pTree; }
+            sharable::TreeFragment* operator->() const { return m_pTree; }
+            bool operator == (sharable::TreeFragment *pTree) const { return pTree == m_pTree; }
+            bool operator != (sharable::TreeFragment *pTree) const { return pTree != m_pTree; }
 
-            NodeAccessRef getRootNode() const { return NodeAccessRef(&m_aAccessor,rootAddress(m_pBase)); }
-
-            DataAddressType address() const { return m_pBase; }
-            Accessor const& accessor() const { return m_aAccessor; }
-
-            DataType& data() const { return *static_cast<DataPointerType>(m_aAccessor.validate(m_pBase.m_pData)); }
-            DataPointerType getDataPtr() const { return access(m_pBase,m_aAccessor); }
-
-            TreeAddress copyTree(memory::UpdateAccessor & _aTargetSpace) const;
-            static void freeTree(memory::UpdateAccessor & _aTargetSpace, TreeAddress _aTree);
-
-            static Name wrapName(rtl::OUString const& _aNameString)
-            { return configuration::makeName( _aNameString, Name::NoValidate() ); }
-
-            static TreeAddress::DataType* access(DataAddressType const& _aTreeRef, memory::UpdateAccessor& _rUpdateAccess);
-            static TreeAddress::DataType const* access(DataAddressType const& _aTreeRef, Accessor const& _rReaderAccess)
-            { return static_cast<DataPointerType>(_rReaderAccess.access(_aTreeRef.m_pData)); }
-        private:
-            NodeAddress rootAddress(DataAddressType const& p) const;
-
-            TreeAccessor();
         private:
-            Accessor            m_aAccessor;
-		    DataAddressType     m_pBase;
+            TreeAddress  m_pTree;
         };
-    // -------------------------------------------------------------------------
-    // -------------------------------------------------------------------------
-        inline
-        TreeAccessor::Name TreeAccessor::getName() const 
-        { 
-            return wrapName( data().getName() );
-        }
-    // -------------------------------------------------------------------------
-        inline
-        NodeAddress TreeAccessor::rootAddress(DataAddressType const& p) const 
-        { 
-            sharable::Address aAddr = p.addressValue();
-
-            if (aAddr) aAddr += offsetof(TreeAddress::DataType,nodes);
-
-            return NodeAddress( memory::Pointer(aAddr) ); 
-        }
     // -------------------------------------------------------------------------
     }
 // -----------------------------------------------------------------------------	
Index: configmgr/source/inc/treefragment.hxx
===================================================================
RCS file: /cvs/util/configmgr/source/inc/treefragment.hxx,v
retrieving revision 1.5
retrieving revision 1.5.14.1
diff -u -p -u -p -r1.5 -r1.5.14.1
--- configmgr/source/inc/treefragment.hxx	6 Nov 2006 14:49:00 -0000	1.5
+++ configmgr/source/inc/treefragment.hxx	8 Jan 2007 20:48:57 -0000	1.5.14.1
@@ -79,16 +79,16 @@ namespace configmgr
     */
         struct TreeFragmentHeader
         {
-            List            next;       // next sibling set element or template
-            String          name;       // element-name/template name
+            struct TreeFragment *next;       // next sibling set element or template
+            String               name;       // element-name/template name
             union // context
             {
-                Address     parent;     // parent node
-                String      component;  // component name 
+                union Node *parent;          // parent node
+                String      component;       // component name 
             };
-            Offset          count;      // number of contained nodes
-            State::Field    state;      
-            Byte            reserved;
+            Offset               count;      // number of contained nodes
+            State::Field         state;      
+            sal_uInt8            reserved;
        };
     //-----------------------------------------------------------------------------
     /* a tree fragment is stored as a variable-sized struct
@@ -138,9 +138,16 @@ namespace configmgr
 
             rtl::OUString               getName() const;
             configmgr::node::Attributes getAttributes()const;
+
+            static TreeFragment *allocate(sal_uInt32 nFragments);
+            static void free_shallow( TreeFragment *pFragment );
         };
     //-----------------------------------------------------------------------------
+
     }
+  namespace data {
+    typedef sharable::TreeFragment * TreeAddress;
+  }
 //-----------------------------------------------------------------------------
 }
 
Index: configmgr/source/inc/treemanager.hxx
===================================================================
RCS file: /cvs/util/configmgr/source/inc/treemanager.hxx,v
retrieving revision 1.5
retrieving revision 1.5.84.4
diff -u -p -u -p -r1.5 -r1.5.84.4
--- configmgr/source/inc/treemanager.hxx	8 Sep 2005 03:59:42 -0000	1.5
+++ configmgr/source/inc/treemanager.hxx	16 Jan 2007 12:18:21 -0000	1.5.84.4
@@ -104,17 +104,12 @@ namespace configmgr
 		/** ctor
 		*/
         explicit
-        TreeManager(BackendCacheRef const & _xBackend, memory::HeapManager & _rCacheHeapManager);
+        TreeManager(BackendCacheRef const & _xBackend);
 
 		// disposing the cache before destroying		
 		void dispose();
-		
-        memory::HeapManager & getCacheHeapManager() const;
 
 		// ITreeManager
-        virtual memory::Segment* getDataSegment(AbsolutePath const& _rAccessor, 
-                                                RequestOptions const& _aOptions);
-
 		/** requests a node given by it's path. Basicly, this means
 			that the node is fetch from the cache when it contains it else it ask the server
 			system into it's cache.
@@ -126,10 +121,9 @@ namespace configmgr
                                                 RequestOptions const& _aOptions
                                                ) CFG_UNO_THROW_ALL(  );
 
-		virtual void updateTree(memory::UpdateAccessor& _aAccessToken, TreeChangeList& aChanges) CFG_UNO_THROW_ALL(  );
+		virtual void updateTree(TreeChangeList& aChanges) CFG_UNO_THROW_ALL(  );
 
-		virtual void saveAndNotifyUpdate(memory::Accessor const& _aChangedDataAccessor, 
-                                            TreeChangeList const& aChanges) CFG_UNO_THROW_ALL(  );
+		virtual void saveAndNotifyUpdate(TreeChangeList const& aChanges) CFG_UNO_THROW_ALL(  );
 
 		virtual void releaseSubtree(AbsolutePath const& aSubtreePath, 
                                     RequestOptions const& _aOptions ) CFG_NOTHROW();
@@ -145,8 +139,7 @@ namespace configmgr
         virtual void enableAsync(const sal_Bool& bEnableAsync) CFG_NOTHROW() ;
         
 		// IDefaultableTreeManager
-        virtual sal_Bool fetchDefaultData(  memory::UpdateAccessor& _aAccessToken, 
-                                            AbsolutePath const& aSubtreePath, 
+        virtual sal_Bool fetchDefaultData(  AbsolutePath const& aSubtreePath, 
 									        RequestOptions const& _aOptions
 									     ) CFG_UNO_THROW_ALL(  );
 
@@ -155,8 +148,7 @@ namespace configmgr
 										                    const RequestOptions& _aOptions
 										                  ) CFG_UNO_THROW_ALL(  );
 		// ITemplateManager
-        virtual data::TreeAccessor requestTemplate( memory::Accessor const& _aAccessor,
-                                                    Name const& aName, Name const& aModule
+        virtual data::TreeAccessor requestTemplate( Name const& aName, Name const& aModule
 										          ) CFG_UNO_THROW_ALL(  );		
 		
 		IConfigBroadcaster* getBroadcaster() { return this; }
@@ -173,7 +165,7 @@ namespace configmgr
 
 		AbsolutePath encodeTemplateLocation(const Name& _rLogicalTemplateName, const Name &_rModule);
 
-		void fireChanges(memory::Accessor const& _aChangedDataAccessor, TreeChangeList const& aChangeTree, sal_Bool _bError);
+		void fireChanges(TreeChangeList const& aChangeTree, sal_Bool _bError);
 
 	private:
         CacheRef getCacheAlways(RequestOptions const & _aOptions);
Index: configmgr/source/inc/treeprovider.hxx
===================================================================
RCS file: /cvs/util/configmgr/source/inc/treeprovider.hxx,v
retrieving revision 1.21
retrieving revision 1.21.84.5
diff -u -p -u -p -r1.21 -r1.21.84.5
--- configmgr/source/inc/treeprovider.hxx	8 Sep 2005 04:00:12 -0000	1.21
+++ configmgr/source/inc/treeprovider.hxx	7 Feb 2007 12:14:55 -0000	1.21.84.5
@@ -76,13 +76,6 @@ namespace configmgr
         class AbsolutePath;
     }
     //-------------------------
-    namespace memory
-    {
-        class Segment;
-        class Accessor;
-        class UpdateAccessor;
-    }
-    //-------------------------
     namespace data
     {
         class NodeAccess;
@@ -104,10 +97,6 @@ namespace configmgr
     public:
         typedef configuration::AbsolutePath AbsolutePath;
 
-        /// get a data segment to host the given location
-        virtual memory::Segment* getDataSegment(  AbsolutePath const& _rAccessor, 
-                                                    const RequestOptions& _aOptions) = 0;
-
        /** request that the tree named by a path is added to the collection of managed trees
             respecting certain options and requiring a specific loading depth.
             Return a reference to that managed tree.
@@ -123,10 +112,10 @@ namespace configmgr
 								  const RequestOptions& _aOptions) CFG_NOTHROW() = 0;
 
         /// update the managed data according to a changes list - update the changes list accordingly with old values
-		virtual void updateTree(memory::UpdateAccessor& _aAccessToken, TreeChangeList& aChanges) CFG_UNO_THROW_ALL(  ) = 0;
+		virtual void updateTree(TreeChangeList& aChanges) CFG_UNO_THROW_ALL(  ) = 0;
 
 		// notification
-		virtual void saveAndNotifyUpdate(memory::Accessor const& _aChangedDataAccessor, TreeChangeList const& aChanges ) CFG_UNO_THROW_ALL(  ) = 0;
+		virtual void saveAndNotifyUpdate(TreeChangeList const& aChanges ) CFG_UNO_THROW_ALL(  ) = 0;
 
 		// bookkeeping support
 		virtual void releaseSubtree(AbsolutePath const& aSubtreePath, 
@@ -172,9 +161,8 @@ namespace configmgr
         typedef configuration::Name         Name;
 
         virtual data::TreeAccessor requestTemplate(
-                                            memory::Accessor const& _aAccessor,
-                                            Name const& aName, Name const& aModule 
-                                        ) CFG_UNO_THROW_ALL( ) = 0;		
+            Name const& aName, Name const& aModule 
+            ) CFG_UNO_THROW_ALL( ) = 0;		
 		
 	};
 
Index: configmgr/source/inc/treesegment.hxx
===================================================================
RCS file: /cvs/util/configmgr/source/inc/treesegment.hxx,v
retrieving revision 1.5
retrieving revision 1.5.84.5
diff -u -p -u -p -r1.5 -r1.5.84.5
--- configmgr/source/inc/treesegment.hxx	8 Sep 2005 04:00:27 -0000	1.5
+++ configmgr/source/inc/treesegment.hxx	7 Feb 2007 12:14:55 -0000	1.5.84.5
@@ -43,12 +43,15 @@
 #ifndef _RTL_REF_HXX_
 #include <rtl/ref.hxx>
 #endif
-
+#ifndef INCLUDED_SHARABLE_TREEFRAGMENT_HXX
+#include "treefragment.hxx"
+#endif
 #ifndef INCLUDED_MEMORY
 #include <memory>
 #define INCLUDED_MEMORY
 #endif // INCLUDED_MEMORY
 
+
 // -----------------------------------------------------------------------------
 namespace rtl { class OUString; }
 // -----------------------------------------------------------------------------
@@ -59,18 +62,10 @@ namespace configmgr
     namespace sharable { struct TreeFragment; union Node; } // for TreeData (sharable)
 // -----------------------------------------------------------------------------
     namespace configuration { class Name; }
-// -----------------------------------------------------------------------------	
-    namespace memory
-    {
-        class Segment;
-        class Accessor;
-        class UpdateAccessor;
-    }
     // -------------------------------------------------------------------------	
     namespace data
     {
     // -------------------------------------------------------------------------	
-        class TreeAddress;
         class TreeAccessor;
     // -------------------------------------------------------------------------	
         class TreeSegment
@@ -108,10 +103,6 @@ namespace configmgr
             Name getName() const;
             void setName(Name const & _aNewName);
 			void markRemovable();
-			
-
-            memory::Segment * getSegment() const;
-            memory::Accessor  getAccessor() const;
 
             TreeAddress     getBaseAddress() const;
             TreeAccessor    getTreeAccess() const;
@@ -123,7 +114,7 @@ namespace configmgr
             TreeDataPtr getTreeData() const;
             NodeDataPtr getSegmentRootNode() const;
         private:
-            TreeDataUpdatePtr getTreeDataForUpdate(memory::UpdateAccessor& _anUpdater) const;
+            TreeDataUpdatePtr getTreeDataForUpdate() const;
 
         private:
             bool hasData() const { return !!m_pImpl.is(); }
Index: configmgr/source/inc/types.hxx
===================================================================
RCS file: /cvs/util/configmgr/source/inc/types.hxx,v
retrieving revision 1.4
retrieving revision 1.4.14.2
diff -u -p -u -p -r1.4 -r1.4.14.2
--- configmgr/source/inc/types.hxx	6 Nov 2006 14:49:13 -0000	1.4
+++ configmgr/source/inc/types.hxx	11 Jan 2007 10:35:31 -0000	1.4.14.2
@@ -36,15 +36,11 @@
 #ifndef INCLUDED_SHARABLE_BASETYPES_HXX
 #define INCLUDED_SHARABLE_BASETYPES_HXX
 
-#ifndef CONFIGMGR_MEMORYMODEL_HXX
-#include "memorymodel.hxx"
-#endif
-
 #ifndef _SAL_TYPES_H_
 #include <sal/types.h>
 #endif
-#ifndef _RTL_USTRING_H_
-#include <rtl/ustring.h>
+#ifndef _RTL_USTRING_HXX_
+#include <rtl/ustring.hxx>
 #endif
 
 //-----------------------------------------------------------------------------
@@ -55,35 +51,40 @@ namespace configmgr
 {
     namespace sharable
     {
-    //-----------------------------------------------------------------------------
-    // some base types
-        typedef memory::Address  Address;  // points to absolute location in memory segment
-        typedef memory::HeapSize HeapSize; // size of memory block within heap
+	//-----------------------------------------------------------------------------
+	// some base types
         typedef sal_uInt16 Offset;  // Offset relative to 'this' in array of nodes
-        typedef sal_uInt8  Byte;  
 
-    // some derived types 
+	// some derived types 
         typedef rtl_uString *  Name;
         typedef rtl_uString *  String;
-        typedef Address List;    // singly linked intrusive, used for set elements
-        typedef Address Vector;   // points to counted sequence of some type
-
-    //-----------------------------------------------------------------------------
+        typedef struct TreeFragment * List;	// singly linked intrusive, used for set elements
+        typedef sal_uInt8 *           Vector;	// points to counted sequence of some type
 
-        Name allocName(::rtl::OUString const & _sString);
-        void freeName(Name _aName);
-        ::rtl::OUString readName(Name _aName);
+	//-----------------------------------------------------------------------------
 
-    //-----------------------------------------------------------------------------
+        inline String allocString(::rtl::OUString const & _sString)
+        {
+            rtl_uString_acquire(_sString.pData);
+            return _sString.pData;
+        }
+        inline void freeString(String _aString)
+        {   rtl_uString_release(_aString);    }
+        inline ::rtl::OUString readString(String _aString)
+        {   return rtl::OUString(_aString);   }
+
+	//-----------------------------------------------------------------------------
+
+        inline Name allocName(::rtl::OUString const & _aName)
+        {   return allocString(_aName); }
+        inline void freeName(Name _aName)
+        {   freeString(_aName); }
+        inline ::rtl::OUString readName(Name _aName)
+        {   return readString(_aName); }
 
-        String allocString(::rtl::OUString const & _sString);
-        void   freeString(String _aString);
-        ::rtl::OUString readString(String _aString);
-
-    //-----------------------------------------------------------------------------
+	//-----------------------------------------------------------------------------
     }
 //-----------------------------------------------------------------------------
 }
-
 
 #endif // INCLUDED_SHARABLE_BASETYPES_HXX 
Index: configmgr/source/inc/updatehelper.hxx
===================================================================
RCS file: /cvs/util/configmgr/source/inc/updatehelper.hxx,v
retrieving revision 1.5
retrieving revision 1.5.84.2
diff -u -p -u -p -r1.5 -r1.5.84.2
--- configmgr/source/inc/updatehelper.hxx	8 Sep 2005 04:01:35 -0000	1.5
+++ configmgr/source/inc/updatehelper.hxx	11 Jan 2007 10:35:32 -0000	1.5.84.2
@@ -40,29 +40,27 @@
 #include "change.hxx"
 #endif
 
+#include "nodeaccess.hxx"
+
 //..........................................................................
 namespace configmgr
 {
 //..........................................................................
-    namespace memory    { class UpdateAccessor; }
-    namespace data      { class NodeAddress; class NodeAccessRef; }
-
-//..........................................................................
 
 // adjust a set of changes to the target tree, return true, if there are changes left
-    bool adjustUpdateToTree(SubtreeChange & _rUpdateTree, data::NodeAccessRef const & _aRootNode);
+    bool adjustUpdateToTree(SubtreeChange & _rUpdateTree, data::NodeAccess const & _aRootNode);
 
 // adjust a set of changes to the target tree, return true, if there are changes left
-    bool adjustUpdateToTree(SubtreeChange & _rUpdateTree, memory::UpdateAccessor& _anUpdateAccess, data::NodeAddress _aRootNode);
+    bool adjustUpdateToTree(SubtreeChange & _rUpdateTree, data::NodeAddress _aRootNode);
 
 // apply a already matching set of changes to the target tree
-    void applyUpdateToTree(SubtreeChange& _anUpdateTree, memory::UpdateAccessor& _anUpdateAccess, data::NodeAddress _aRootNode);
+    void applyUpdateToTree(SubtreeChange& _anUpdateTree, data::NodeAddress _aRootNode);
 
 // apply a set of changes to the target tree
-    void applyUpdateWithAdjustmentToTree(SubtreeChange& _anUpdateTree, memory::UpdateAccessor& _anUpdateAccess, data::NodeAddress _aRootNode);
+    void applyUpdateWithAdjustmentToTree(SubtreeChange& _anUpdateTree, data::NodeAddress _aRootNode);
 
 // apply a set of changes to the target tree, return true, if there are changes found
-    bool createUpdateFromDifference(SubtreeChange& _rResultingUpdateTree, data::NodeAccessRef const & _aExistingData, ISubtree const & _aNewData);
+    bool createUpdateFromDifference(SubtreeChange& _rResultingUpdateTree, data::NodeAccess const & _aExistingData, ISubtree const & _aNewData);
 
 //..........................................................................
 }	// namespace configmgr
Index: configmgr/source/inc/utility.hxx
===================================================================
RCS file: /cvs/util/configmgr/source/inc/utility.hxx,v
retrieving revision 1.7
retrieving revision 1.7.22.3
diff -u -p -u -p -r1.7 -r1.7.22.3
--- configmgr/source/inc/utility.hxx	25 Sep 2006 12:49:38 -0000	1.7
+++ configmgr/source/inc/utility.hxx	16 Jan 2007 12:18:22 -0000	1.7.22.3
@@ -45,6 +45,9 @@
 #ifndef _SALHELPER_SIMPLEREFERENCEOBJECT_HXX_
 #include <salhelper/simplereferenceobject.hxx>
 #endif
+#include "datalock.hxx"
+
+#include "osl/diagnose.h"
 
 #define CFG_NOTHROW() SAL_THROW( () )
 
@@ -97,11 +100,41 @@ namespace configmgr
 		void operator=	(Noncopyable& notImplemented);
 	};
 
-    struct Refcounted
-    : virtual salhelper::SimpleReferenceObject
+    // Used for internal, non-UNO objects
+    class SimpleReferenceObject
+    {
+    public:
+        inline SimpleReferenceObject() SAL_THROW(()): m_nCount(0) {}
+#define SIMPLE_REFERENCE_FAST
+#ifdef SIMPLE_REFERENCE_FAST
+        inline void acquire() SAL_THROW(())
+        {
+            OSL_ASSERT(UnoApiLock::isHeld());
+            m_nCount++;
+        }
+        inline void release() SAL_THROW(())
+        {
+            OSL_ASSERT(UnoApiLock::isHeld());
+            if (--m_nCount == 0)
+                delete this;
+        }
+#else
+        void acquire() SAL_THROW(());
+        void release() SAL_THROW(());
+#endif
+
+    protected:
+        virtual ~SimpleReferenceObject() SAL_THROW(());
+    private:
+        sal_uInt32 m_nCount;
+        // not implemented:
+        SimpleReferenceObject(SimpleReferenceObject &);
+        void operator =(SimpleReferenceObject);
+    };
+
+    struct Refcounted : virtual configmgr::SimpleReferenceObject
 	{
 	};
-
 }
 
 #endif // CONFIGMGR_UTILITY_HXX_
Index: configmgr/source/inc/valuenode.hxx
===================================================================
RCS file: /cvs/util/configmgr/source/inc/valuenode.hxx,v
retrieving revision 1.29
retrieving revision 1.29.42.1
diff -u -p -u -p -r1.29 -r1.29.42.1
--- configmgr/source/inc/valuenode.hxx	19 Jun 2006 23:24:42 -0000	1.29
+++ configmgr/source/inc/valuenode.hxx	5 Feb 2007 15:21:45 -0000	1.29.42.1
@@ -102,8 +102,8 @@ namespace configmgr
 
 	class INode
 	{
-		OUString						m_aName;
-		node::Attributes			m_aAttributes;
+		OUString          m_aName;
+		node::Attributes  m_aAttributes;
 
 	protected:
 		INode(){}
@@ -207,7 +207,6 @@ namespace configmgr
         using INode::markAsDefault;
 
         sal_Int16 getLevel()         const { return m_nLevel; }
-        sal_Int16 getDefaultsLevel() const { return m_nDefaultLevels; }
 
         void setLevels(sal_Int16 _nLevel,sal_Int16 _nDefaultsLevel);
 
Index: configmgr/source/inc/valuenodeaccess.hxx
===================================================================
RCS file: /cvs/util/configmgr/source/inc/valuenodeaccess.hxx,v
retrieving revision 1.5
retrieving revision 1.5.14.2
diff -u -p -u -p -r1.5 -r1.5.14.2
--- configmgr/source/inc/valuenodeaccess.hxx	6 Nov 2006 14:49:26 -0000	1.5
+++ configmgr/source/inc/valuenodeaccess.hxx	11 Jan 2007 10:35:32 -0000	1.5.14.2
@@ -47,48 +47,24 @@ namespace configmgr
     {
     // -------------------------------------------------------------------------
         class ValueNodeAccess
-	    {
-        public:
-            typedef NodeAccess::Name        Name;
-            typedef NodeAccess::Attributes  Attributes;
-            typedef ValueNodeAddress                    NodeAddressType;
-            typedef ValueNodeAddress::AddressType       AddressType;
-            typedef ValueNodeAddress::DataType const    DataType;
-            typedef DataType * NodePointerType;
-
-            ValueNodeAccess(Accessor const& _aAccessor, NodeAddressType const& _aNodeRef) 
-            : m_aAccessor(_aAccessor)
-            , m_pData(_aNodeRef.m_pData) 
-            {}
-
-            ValueNodeAccess(Accessor const& _aAccessor, NodePointerType _pNode) 
-            : m_aAccessor(_aAccessor)
-            , m_pData(check(_aAccessor,_pNode)) 
-            {}
-
+	{
+	public:
+            ValueNodeAccess(const sharable::ValueNode *_pNodeRef) 
+                : m_pData(((sharable::Node *)_pNodeRef)->valueData()) {}
+    
             explicit
             ValueNodeAccess(NodeAccess const & _aNode) 
-            : m_aAccessor(_aNode.accessor())
-            , m_pData(check(_aNode)) 
-            {
-            }
-
-            explicit
-            ValueNodeAccess(NodeAccessRef const & _aNode) 
-            : m_aAccessor(_aNode.accessor())
-            , m_pData(check(_aNode)) 
-            {
-            }
+                : m_pData(check(_aNode)) {}
 
-            static bool isInstance(NodeAccessRef const & _aNode) 
+            static bool isInstance(NodeAccess const & _aNode) 
             {
                 return check(_aNode) != NULL;
             }
 
             bool isValid() const { return m_pData != NULL; }
 
-            Name getName() const;
-            Attributes getAttributes() const;
+            configuration::Name getName() const;
+            node::Attributes getAttributes() const;
 
             bool isEmpty()     const { return data().isEmpty(); }
 
@@ -103,34 +79,33 @@ namespace configmgr
             uno::Any    getUserValue()      const;
             uno::Any    getDefaultValue()   const;
 
-		    static void setValue(memory::UpdateAccessor & _aUpdater, NodeAddressType _aValueNode, uno::Any const& _aValue);
-		    static void setToDefault(memory::UpdateAccessor & _aUpdater, NodeAddressType _aValueNode);
-		    static void changeDefault(memory::UpdateAccessor & _aUpdater, NodeAddressType _aValueNode, uno::Any const& _aValue);
-
-            NodeAddressType address()   const { return NodeAddressType(m_pData); }
-            Accessor const& accessor()  const { return m_aAccessor; }
-
-            DataType& data() const { return *static_cast<NodePointerType>(m_aAccessor.validate(m_pData)); }
-
-            operator NodeAccessRef() const { return NodeAccessRef(&m_aAccessor,NodeAddress(m_pData)); }
+	    static void setValue(ValueNodeAddress _aValueNode, uno::Any const& _aValue);
+	    static void setToDefault(ValueNodeAddress _aValueNode);
+	    static void changeDefault(ValueNodeAddress _aValueNode, uno::Any const& _aValue);
+
+            sharable::ValueNode& data() const { return *m_pData; }
+            operator ValueNodeAddress () const { return (ValueNodeAddress)m_pData; }
+
+            operator NodeAccess() const { return NodeAccess(NodeAddress(m_pData)); }
+            bool operator == (const NodeAddress &rAddr) const { return NodeAddress(m_pData) == rAddr; }
+            bool operator == (const ValueNodeAddress &rAddr) const { return m_pData == rAddr; }
         private:
-            static AddressType check(Accessor const& _acc, NodePointerType _p) { return _acc.address(_p); }
-            static AddressType check(NodeAccessRef const& _aNodeData);
+            static ValueNodeAddress check(sharable::Node *pNode)
+		{ return pNode ? const_cast<ValueNodeAddress>(pNode->valueData()) : NULL; }
+            static ValueNodeAddress check(NodeAccess const&aRef)
+		{ return check(static_cast<sharable::Node *>(aRef)); }
 
-            Accessor    m_aAccessor;
-		    AddressType m_pData;
+            ValueNodeAddress m_pData;
         };
 
-        ValueNodeAddress toValueNodeAddress(memory::Accessor const & _aAccess, NodeAddress const & _aNodeAddr);
-        ValueNodeAddress toValueNodeAddress(memory::UpdateAccessor & _aAccess, NodeAddress const & _aNodeAddr);
     // -------------------------------------------------------------------------
 
         inline 
-        NodeAccess::Name ValueNodeAccess::getName() const 
+        configuration::Name ValueNodeAccess::getName() const 
         { return NodeAccess::wrapName( data().info.getName() ); }
         
         inline           
-        NodeAccess::Attributes ValueNodeAccess::getAttributes() const 
+        node::Attributes ValueNodeAccess::getAttributes() const 
         { return sharable::node(data()).getAttributes(); }
 
         inline           
@@ -143,15 +118,15 @@ namespace configmgr
 
         inline           
         uno::Any    ValueNodeAccess::getValue()      const 
-        { return data().getValue(m_aAccessor); }
+        { return data().getValue(); }
 
         inline           
         uno::Any    ValueNodeAccess::getUserValue()    const 
-        { return data().getUserValue(m_aAccessor); }
+        { return data().getUserValue(); }
 
         inline           
         uno::Any    ValueNodeAccess::getDefaultValue()    const 
-        { return data().getDefaultValue(m_aAccessor); }
+        { return data().getDefaultValue(); }
 
     // -------------------------------------------------------------------------
     }
Index: configmgr/source/inc/valueref.hxx
===================================================================
RCS file: /cvs/util/configmgr/source/inc/valueref.hxx,v
retrieving revision 1.4
retrieving revision 1.4.84.2
diff -u -p -u -p -r1.4 -r1.4.84.2
--- configmgr/source/inc/valueref.hxx	8 Sep 2005 04:02:40 -0000	1.4
+++ configmgr/source/inc/valueref.hxx	12 Jan 2007 14:50:44 -0000	1.4.84.2
@@ -125,7 +125,7 @@ namespace configmgr
 			// checking
 			bool isEmpty() const;
 			// checking
-			bool isValidNode(data::Accessor const& _accessor) const;
+			bool isValidNode() const;
 			// hashing
 			size_t hashCode() const;
 			// containing node this
@@ -141,7 +141,7 @@ namespace configmgr
 	//-------------------------------------------------------------------------
 
 		typedef std::vector<SubNodeID>		SubNodeIDList;
-		void getAllChildrenHelper(data::Accessor const& _aAccessor, NodeID const& aNode, SubNodeIDList& aList);
+		void getAllChildrenHelper(NodeID const& aNode, SubNodeIDList& aList);
 
 	//-------------------------------------------------------------------------
 		inline bool operator!=(SubNodeID const& lhs, SubNodeID const& rhs)
Index: configmgr/source/localbe/localfilehelper.cxx
===================================================================
RCS file: /cvs/util/configmgr/source/localbe/localfilehelper.cxx,v
retrieving revision 1.4
retrieving revision 1.4.24.2
diff -u -p -u -p -r1.4 -r1.4.24.2
Index: configmgr/source/localbe/localmultistratum.cxx
===================================================================
RCS file: /cvs/util/configmgr/source/localbe/localmultistratum.cxx,v
retrieving revision 1.8
retrieving revision 1.8.24.2
diff -u -p -u -p -r1.8 -r1.8.24.2
Index: configmgr/source/misc/bootstrap.cxx
===================================================================
RCS file: /cvs/util/configmgr/source/misc/bootstrap.cxx,v
retrieving revision 1.32
retrieving revision 1.32.24.1
diff -u -p -u -p -r1.32 -r1.32.24.1
--- configmgr/source/misc/bootstrap.cxx	16 Sep 2006 15:14:14 -0000	1.32
+++ configmgr/source/misc/bootstrap.cxx	11 Jan 2007 20:16:02 -0000	1.32.24.1
@@ -363,117 +363,9 @@ uno::Any SAL_CALL 
             bFound = lookupInBootstrap( aResult, makeBootstrapName(aName) );
         }
     }
-#if 0
-    if (!bFound && bOurName)
-    {
-        OSL_TRACE( "configmgr: Cannot find bootstrap data item: %s",
-                    rtl::OUStringToOString(aName,RTL_TEXTENCODING_ASCII_US).getStr() );
-    }
-#endif
     return aResult;
 }
-// ---------------------------------------------------------------------------
 
-#if 0
-uno::Any BootstrapContext::makeDefaultProvider()
-{
-    {
-        osl::MutexGuard lock(mutex());
-        if (m_xDefaultProvider.is())
-            return uno::makeAny(m_xDefaultProvider);
-    }
-
-    if (isPassthrough()) 
-    {
-        Context xDelegate = basecontext();
-        if (!xDelegate.is())
-            throw lang::DisposedException(NAME("BootstrapContext: No base context"),*this);
-
-        uno::Any aResult = xDelegate->getValueByName( SINGLETON(A_DefaultProviderSingletonName) );
-    
-        osl::MutexGuard relock(mutex());
-        if (!m_xDefaultProvider.is())
-        {
-            aResult >>= m_xDefaultProvider;
-            return aResult;
-        }
-        else
-            return uno::makeAny(m_xDefaultProvider);
-    }
-    else 
-    {
-        ServiceManager xMgr = this->getServiceManager();
-        if (!xMgr.is())
-            throw lang::DisposedException(NAME("BootstrapContext: No service factory"),*this);
-
-        try
-        {
-            uno::Reference<uno::XInterface> xDefaultProvider = xMgr->createInstanceWithContext(NAME(A_DefaultProviderServiceAndImplName),this);
-        
-            osl::MutexGuard relock(mutex());
-            if (!m_xDefaultProvider.is())
-                m_xDefaultProvider = xDefaultProvider;
-
-            return uno::makeAny(m_xDefaultProvider);
-        }
-        catch (uno::RuntimeException &) { throw; }
-        catch (uno::Exception & ) 
-        { 
-            throw uno::RuntimeException(NAME("BootstrapContext:Exception occurred while instantiating DefaultProvider"),*this); 
-        }
-    }
-}
-// ---------------------------------------------------------------------------
-
-uno::Any BootstrapContext::makeDefaultBackend()
-{
-    {
-        osl::MutexGuard lock(mutex());
-        if (m_xDefaultBackend.is())
-            return uno::makeAny(m_xDefaultBackend);
-    }
-
-    if (isPassthrough()) 
-    {
-        Context xDelegate = basecontext();
-        if (!xDelegate.is())
-            throw lang::DisposedException(NAME("BootstrapContext: No base context"),*this);
-
-        uno::Any aResult = xDelegate->getValueByName( SINGLETON(K_DefaultBackendSingletonName) );
-        
-        osl::MutexGuard relock(mutex());
-        if (!m_xDefaultBackend.is())
-        {
-            aResult >>= m_xDefaultBackend;
-            return aResult;
-        }
-        else
-            return uno::makeAny(m_xDefaultBackend);
-    }
-    else
-    {
-        ServiceManager xMgr = this->getServiceManager();
-        if (!xMgr.is())
-            throw lang::DisposedException(NAME("BootstrapContext: No service factory"),*this);
-
-        try
-        {
-            uno::Reference<uno::XInterface> xDefaultBackend = xMgr->createInstanceWithContext(NAME(K_DefaultBackendServiceAndImplName),this);
-        
-            osl::MutexGuard relock(mutex());
-            if (!m_xDefaultBackend.is())
-                m_xDefaultBackend = xDefaultBackend;
-            return uno::makeAny(m_xDefaultBackend);
-        }
-        catch (uno::RuntimeException &) { throw; }
-        catch (uno::Exception & ) 
-        { 
-            throw uno::RuntimeException(NAME("BootstrapContext:Exception occurred while instantiating DefaultBackend"),*this); 
-        }
-    }
-}
-// ---------------------------------------------------------------------------
-#endif
 // ---------------------------------------------------------------------------
 // class ContextReader
 // ---------------------------------------------------------------------------
Index: configmgr/source/misc/bootstrapcontext.cxx
===================================================================
RCS file: /cvs/util/configmgr/source/misc/bootstrapcontext.cxx,v
retrieving revision 1.6
retrieving revision 1.6.24.1
diff -u -p -u -p -r1.6 -r1.6.24.1
--- configmgr/source/misc/bootstrapcontext.cxx	16 Sep 2006 15:14:28 -0000	1.6
+++ configmgr/source/misc/bootstrapcontext.cxx	11 Jan 2007 20:16:02 -0000	1.6.24.1
@@ -59,6 +59,9 @@
 #ifndef _COM_SUN_STAR_LANG_DISPOSEDEXCEPTION_HPP_
 #include <com/sun/star/lang/DisposedException.hpp>
 #endif
+#ifndef CONFIGMGR_UTILITY_HXX_
+#include "utility.hxx"
+#endif
 
 namespace configmgr
 {
@@ -81,8 +84,7 @@ static void testComplete()
 // ---------------------------------------------------------------------------
 
 ComponentContext::ComponentContext(Context const & _xContext)
-: ComponentContext_Base(m_aMutex)
-, m_aMutex()
+: ComponentContext_Base(UnoApiLock::getLock())
 , m_xContext(_xContext)
 , m_hBootstrapData(NULL)
 , m_xServiceManager()
@@ -98,15 +100,13 @@ ComponentContext::~ComponentContext()
 
 void ComponentContext::initialize( const OUString& _aURL )
 {
-    osl::ClearableMutexGuard lock(mutex());
+    UnoApiLock aLock;
 
     OSL_ASSERT(!m_hBootstrapData);
     m_hBootstrapData = rtl_bootstrap_args_open(_aURL.pData);
 
     uno::Reference< lang::XComponent > xOwner(m_xContext, uno::UNO_QUERY);
 
-    lock.clear();
-
     if (xOwner.is()) DisposingForwarder::forward(xOwner,this);
 
     if (!m_xContext.is())
@@ -120,7 +120,7 @@ void ComponentContext::initialize( const
 // ComponentHelper
 void SAL_CALL ComponentContext::disposing()
 {
-    osl::MutexGuard lock(mutex());
+    UnoApiLock aLock;
 
     m_xContext.clear();
 
@@ -136,7 +136,8 @@ OUString ComponentContext::getBootstrapU
 {
     OUString aResult;
 
-    osl::MutexGuard lock(mutex());
+    UnoApiLock aLock;
+
     if (m_hBootstrapData)
     {
         rtl_bootstrap_get_iniName_from_handle(m_hBootstrapData,&aResult.pData);
@@ -152,7 +153,7 @@ OUString ComponentContext::getBootstrapU
 
 void ComponentContext::changeBootstrapURL( const OUString& _aURL )
 {
-    osl::MutexGuard lock(mutex());
+    UnoApiLock aLock;
 
     if (rtlBootstrapHandle hNew = rtl_bootstrap_args_open(_aURL.pData))
     {
@@ -170,7 +171,7 @@ uno::Reference< lang::XMultiComponentFac
     ComponentContext::getServiceManager(  ) 
         throw (uno::RuntimeException)
 {
-    osl::MutexGuard lock(mutex());
+    UnoApiLock aLock;
 
     if (!m_xServiceManager.is())
     {
@@ -262,7 +263,7 @@ bool ComponentContext::lookupInContext( 
 
 bool ComponentContext::lookupInBootstrap( uno::Any & _rValue, const OUString& _aName ) const
 {
-    osl::MutexGuard lock(mutex());
+    UnoApiLock aLock;
     OUString sResult;
     if ( rtl_bootstrap_get_from_handle( m_hBootstrapData, _aName.pData, &sResult.pData, 0) )
     {
Index: configmgr/source/misc/filehelper.cxx
===================================================================
RCS file: /cvs/util/configmgr/source/misc/filehelper.cxx,v
retrieving revision 1.17
retrieving revision 1.17.24.2
diff -u -p -u -p -r1.17 -r1.17.24.2
Index: configmgr/source/misc/mergechange.cxx
===================================================================
RCS file: /cvs/util/configmgr/source/misc/mergechange.cxx,v
retrieving revision 1.24
retrieving revision 1.24.24.2
diff -u -p -u -p -r1.24 -r1.24.24.2
--- configmgr/source/misc/mergechange.cxx	16 Sep 2006 15:16:11 -0000	1.24
+++ configmgr/source/misc/mergechange.cxx	11 Jan 2007 10:35:32 -0000	1.24.24.2
@@ -93,20 +93,20 @@ namespace configmgr
 // -----------------------------------------------------------------------------
     // -----------------------------------------------------------------------------
     // TODO: check name match
-	void applyUpdateWithAdjustment(TreeChangeList & _anUpdate, memory::UpdateAccessor& _aUpdateAccess, data::NodeAddress const & _aBaseAddress)
+    void applyUpdateWithAdjustment(TreeChangeList & _anUpdate, data::NodeAddress const & _aBaseAddress)
     {
-        OSL_ASSERT(_aBaseAddress.is());
+        OSL_ASSERT(_aBaseAddress != NULL);
 
-        applyUpdateWithAdjustmentToTree(_anUpdate.root,_aUpdateAccess,_aBaseAddress);
+        applyUpdateWithAdjustmentToTree(_anUpdate.root,_aBaseAddress);
     }
 
-	// -----------------------------------------------------------------------------
+    // -----------------------------------------------------------------------------
     // TODO: check name match
-	bool adjustUpdate(TreeChangeList & _anUpdate, memory::UpdateAccessor& _aUpdateAccess, data::NodeAddress const & _aBaseAddress)
+    bool adjustUpdate(TreeChangeList & _anUpdate, data::NodeAddress const & _aBaseAddress)
     {
-        OSL_ASSERT(_aBaseAddress.is());
+        OSL_ASSERT(_aBaseAddress != NULL);
 
-        return adjustUpdateToTree(_anUpdate.root,_aUpdateAccess,_aBaseAddress);
+        return adjustUpdateToTree(_anUpdate.root,_aBaseAddress);
     }
     // -----------------------------------------------------------------------------
 // -----------------------------------------------------------------------------
Index: configmgr/source/registry/cfgregistrykey.cxx
===================================================================
RCS file: /cvs/util/configmgr/source/registry/cfgregistrykey.cxx,v
retrieving revision 1.14
retrieving revision 1.13.14.2
diff -u -p -u -p -r1.14 -r1.13.14.2
--- configmgr/source/registry/cfgregistrykey.cxx	21 Nov 2006 17:23:57 -0000	1.14
+++ configmgr/source/registry/cfgregistrykey.cxx	7 Feb 2007 11:45:13 -0000	1.13.14.2
@@ -177,8 +177,7 @@ OConfigurationRegistryKey::OConfiguratio
 			,sal_Bool _bWriteable
 			,SubtreeRoot
 			)
-	:m_aMutex()
-	,m_bReadOnly(!_bWriteable)
+	:m_bReadOnly(!_bWriteable)
 	,m_xNode(_rxRootNode)
 	,m_xParentNode()
 	,m_sLocalName() // this will be treated as root - maybe use hierarchical name ()
@@ -191,8 +190,7 @@ OConfigurationRegistryKey::OConfiguratio
 			(const Reference< XNameAccess >& _rxNode
 			,sal_Bool _bWriteable
 			)
-	:m_aMutex()
-	,m_bReadOnly(!_bWriteable)
+	:m_bReadOnly(!_bWriteable)
 	,m_xNode(_rxNode)
 	,m_xParentNode()
 	,m_sLocalName( getNodeName(_rxNode) ) // this will not be treated as root
@@ -205,8 +203,7 @@ OConfigurationRegistryKey::OConfiguratio
 			const Reference< XNameAccess >& _rxParentNode,
 			const ::rtl::OUString& _rLocalName,
 			sal_Bool _bWriteable)
-	:m_aMutex()
-	,m_bReadOnly(!_bWriteable)
+	:m_bReadOnly(!_bWriteable)
 	,m_xNode()
 	,m_xParentNode(_rxParentNode)
 	,m_sLocalName(_rLocalName)
@@ -222,8 +219,7 @@ OConfigurationRegistryKey::OConfiguratio
 				const Reference< XNameAccess >& _rxParentNode,
 				const ::rtl::OUString& _rLocalName,
 				sal_Bool _bWriteable)
-	:m_aMutex()
-	,m_bReadOnly(!_bWriteable)
+	:m_bReadOnly(!_bWriteable)
 	,m_xNode()
 	,m_xParentNode(_rxParentNode)
 	,m_sLocalName(_rLocalName)
@@ -746,17 +742,17 @@ void OConfigurationRegistryKey::implSetV
 }
 
 //--------------------------------------------------------------------------
-sal_Bool SAL_CALL OConfigurationRegistryKey::isReadOnly(  ) throw(InvalidRegistryException, RuntimeException)
+sal_Bool SAL_CALL OConfigurationRegistryKey::isReadOnly() throw(InvalidRegistryException, RuntimeException)
 {
-	MutexGuard aGuard(m_aMutex);
+    OSL_ASSERT(UnoApiLock::isHeld());
 	checkValid(KAT_META);
 	return m_bReadOnly;
 }
 
 //--------------------------------------------------------------------------
-sal_Bool SAL_CALL OConfigurationRegistryKey::isValid(  ) throw(RuntimeException)
+sal_Bool SAL_CALL OConfigurationRegistryKey::isValid() throw(RuntimeException)
 {
-	MutexGuard aGuard(m_aMutex);
+    OSL_ASSERT(UnoApiLock::isHeld());
 	// TODO : perhaps if the registry we're a part of is closed ....
 	return implIsValid();
 }
@@ -764,7 +760,7 @@ sal_Bool SAL_CALL OConfigurationRegistry
 //--------------------------------------------------------------------------
 RegistryKeyType SAL_CALL OConfigurationRegistryKey::getKeyType( const ::rtl::OUString& /*_rKeyName*/ ) throw(InvalidRegistryException, RuntimeException)
 {
-	MutexGuard aGuard(m_aMutex);
+    OSL_ASSERT(UnoApiLock::isHeld());
 
 	// no further checks are made (for performance reasons) ...
 	// Maybe we should check only KAT_META for consistency ?
@@ -774,9 +770,8 @@ RegistryKeyType SAL_CALL OConfigurationR
 }
 
 //--------------------------------------------------------------------------
-RegistryValueType SAL_CALL OConfigurationRegistryKey::getValueType(  ) throw(InvalidRegistryException, RuntimeException)
+RegistryValueType SAL_CALL OConfigurationRegistryKey::getValueType() throw(InvalidRegistryException, RuntimeException)
 {
-	MutexGuard aGuard(m_aMutex);
 	checkValid(KAT_META);
 
 	const Type aUnoType = implGetUnoType();
@@ -879,10 +874,8 @@ Any OConfigurationRegistryKey::implGetVa
 }
 
 //--------------------------------------------------------------------------
-sal_Int32 SAL_CALL OConfigurationRegistryKey::getLongValue(  ) throw(InvalidRegistryException, InvalidValueException, RuntimeException)
+sal_Int32 SAL_CALL OConfigurationRegistryKey::getLongValue() throw(InvalidRegistryException, InvalidValueException, RuntimeException)
 {
-	MutexGuard aGuard(m_aMutex);
-
 	Any aValue = implGetValue();
 
 	sal_Int32 nLongValue(0);
@@ -999,16 +992,12 @@ sal_Int32 SAL_CALL OConfigurationRegistr
 //--------------------------------------------------------------------------
 void SAL_CALL OConfigurationRegistryKey::setLongValue( sal_Int32 _nValue ) throw(InvalidRegistryException, RuntimeException)
 {
-	MutexGuard aGuard(m_aMutex);
-
 	implSetValue(makeAny(_nValue));
 }
 
 //--------------------------------------------------------------------------
-Sequence< sal_Int32 > SAL_CALL OConfigurationRegistryKey::getLongListValue(  ) throw(InvalidRegistryException, InvalidValueException, RuntimeException)
+Sequence< sal_Int32 > SAL_CALL OConfigurationRegistryKey::getLongListValue() throw(InvalidRegistryException, InvalidValueException, RuntimeException)
 {
-	MutexGuard aGuard(m_aMutex);
-
 	Any aValue = implGetValue();
 
 	Sequence< sal_Int32 > aReturn;
@@ -1028,13 +1017,11 @@ Sequence< sal_Int32 > SAL_CALL OConfigur
 //--------------------------------------------------------------------------
 void SAL_CALL OConfigurationRegistryKey::setLongListValue( const Sequence< sal_Int32 >& _seqValue ) throw(InvalidRegistryException, RuntimeException)
 {
-	MutexGuard aGuard(m_aMutex);
-
 	implSetValue(makeAny(_seqValue));
 }
 
 //--------------------------------------------------------------------------
-OUString SAL_CALL OConfigurationRegistryKey::getAsciiValue(  ) throw(InvalidRegistryException, InvalidValueException, RuntimeException)
+OUString SAL_CALL OConfigurationRegistryKey::getAsciiValue() throw(InvalidRegistryException, InvalidValueException, RuntimeException)
 {
 	OUString sReturn = getStringValue();
 
@@ -1053,7 +1040,7 @@ void SAL_CALL OConfigurationRegistryKey:
 }
 
 //--------------------------------------------------------------------------
-Sequence< OUString > SAL_CALL OConfigurationRegistryKey::getAsciiListValue(  ) throw(InvalidRegistryException, InvalidValueException, RuntimeException)
+Sequence< OUString > SAL_CALL OConfigurationRegistryKey::getAsciiListValue() throw(InvalidRegistryException, InvalidValueException, RuntimeException)
 {
 	Sequence<OUString> aReturn = getStringListValue();
 
@@ -1072,10 +1059,8 @@ void SAL_CALL OConfigurationRegistryKey:
 }
 
 //--------------------------------------------------------------------------
-::rtl::OUString SAL_CALL OConfigurationRegistryKey::getStringValue(  ) throw(InvalidRegistryException, InvalidValueException, RuntimeException)
+::rtl::OUString SAL_CALL OConfigurationRegistryKey::getStringValue() throw(InvalidRegistryException, InvalidValueException, RuntimeException)
 {
-	MutexGuard aGuard(m_aMutex);
-
 	Any aValue = implGetValue();
 
 	OUString sReturn;
@@ -1091,16 +1076,12 @@ void SAL_CALL OConfigurationRegistryKey:
 //--------------------------------------------------------------------------
 void SAL_CALL OConfigurationRegistryKey::setStringValue( const ::rtl::OUString& _rValue ) throw(InvalidRegistryException, RuntimeException)
 {
-	MutexGuard aGuard(m_aMutex);
-
 	implSetValue(makeAny(_rValue));
 }
 
 //--------------------------------------------------------------------------
-Sequence< ::rtl::OUString > SAL_CALL OConfigurationRegistryKey::getStringListValue(  ) throw(InvalidRegistryException, InvalidValueException, RuntimeException)
+Sequence< ::rtl::OUString > SAL_CALL OConfigurationRegistryKey::getStringListValue() throw(InvalidRegistryException, InvalidValueException, RuntimeException)
 {
-	MutexGuard aGuard(m_aMutex);
-
 	Any aValue = implGetValue();
 
 	Sequence< OUString > aReturn;
@@ -1116,16 +1097,12 @@ Sequence< ::rtl::OUString > SAL_CALL OCo
 //--------------------------------------------------------------------------
 void SAL_CALL OConfigurationRegistryKey::setStringListValue( const Sequence< ::rtl::OUString >& _seqValue ) throw(InvalidRegistryException, RuntimeException)
 {
-	MutexGuard aGuard(m_aMutex);
-
 	implSetValue(makeAny(_seqValue));
 }
 
 //--------------------------------------------------------------------------
-Sequence< sal_Int8 > SAL_CALL OConfigurationRegistryKey::getBinaryValue(  ) throw(InvalidRegistryException, InvalidValueException, RuntimeException)
+Sequence< sal_Int8 > SAL_CALL OConfigurationRegistryKey::getBinaryValue() throw(InvalidRegistryException, InvalidValueException, RuntimeException)
 {
-	MutexGuard aGuard(m_aMutex);
-
 	Any aValue = implGetValue();
 
 	Sequence< sal_Int8 > aReturn;
@@ -1141,8 +1118,6 @@ Sequence< sal_Int8 > SAL_CALL OConfigura
 //--------------------------------------------------------------------------
 void SAL_CALL OConfigurationRegistryKey::setBinaryValue( const Sequence< sal_Int8 >& _rValue ) throw(InvalidRegistryException, RuntimeException)
 {
-	MutexGuard aGuard(m_aMutex);
-
 	implSetValue(makeAny(_rValue));
 }
 
@@ -1213,7 +1188,6 @@ Reference< XRegistryKey > OConfiguration
 //--------------------------------------------------------------------------
 Reference< XRegistryKey > SAL_CALL OConfigurationRegistryKey::openKey( const ::rtl::OUString& _rKeyName ) throw(InvalidRegistryException, RuntimeException)
 {
-	MutexGuard aGuard(m_aMutex);
 	checkValid(KAT_CHILD);
 
 	return implGetKey(_rKeyName);
@@ -1288,7 +1262,6 @@ bool OConfigurationRegistryKey::checkRel
 //--------------------------------------------------------------------------
 Reference< XRegistryKey > SAL_CALL OConfigurationRegistryKey::createKey( const ::rtl::OUString& _rKeyName ) throw(InvalidRegistryException, RuntimeException)
 {
-	MutexGuard aGuard(m_aMutex);
 	checkValid(KAT_CHILD);
 
 	if (m_bReadOnly)
@@ -1411,10 +1384,9 @@ Reference< XRegistryKey > SAL_CALL OConf
 }
 
 //--------------------------------------------------------------------------
-void SAL_CALL OConfigurationRegistryKey::closeKey(  ) throw(InvalidRegistryException, RuntimeException)
+void SAL_CALL OConfigurationRegistryKey::closeKey() throw(InvalidRegistryException, RuntimeException)
 {
-	MutexGuard aGuard(m_aMutex);
-
+    OSL_ASSERT(UnoApiLock::isHeld());
 	checkValid(KAT_META);
 
     bool bRoot = (m_sLocalName.getLength() == 0);
@@ -1430,8 +1402,6 @@ void SAL_CALL OConfigurationRegistryKey:
 //--------------------------------------------------------------------------
 void SAL_CALL OConfigurationRegistryKey::deleteKey( const OUString& _rKeyName ) throw(InvalidRegistryException, RuntimeException)
 {
-	MutexGuard aGuard(m_aMutex);
-
 	checkValid(KAT_CHILD);
 	if (m_bReadOnly)
 		throw InvalidRegistryException(UNISTRING("The key is read only."), THISREF());
@@ -1483,9 +1453,8 @@ void SAL_CALL OConfigurationRegistryKey:
 }
 
 //--------------------------------------------------------------------------
-Sequence< Reference< XRegistryKey > > SAL_CALL OConfigurationRegistryKey::openKeys(  ) throw(InvalidRegistryException, RuntimeException)
+Sequence< Reference< XRegistryKey > > SAL_CALL OConfigurationRegistryKey::openKeys() throw(InvalidRegistryException, RuntimeException)
 {
-	MutexGuard aGuard(m_aMutex);
 	checkValid(KAT_CHILD);
 
 	Sequence< ::rtl::OUString > aNames(m_xNode->getElementNames());
@@ -1501,9 +1470,8 @@ Sequence< Reference< XRegistryKey > > SA
 }
 
 //--------------------------------------------------------------------------
-Sequence< ::rtl::OUString > SAL_CALL OConfigurationRegistryKey::getKeyNames(  ) throw(InvalidRegistryException, RuntimeException)
+Sequence< ::rtl::OUString > SAL_CALL OConfigurationRegistryKey::getKeyNames() throw(InvalidRegistryException, RuntimeException)
 {
-	MutexGuard aGuard(m_aMutex);
 	checkValid(KAT_CHILD);
 	return m_xNode->getElementNames();
 }
@@ -1511,28 +1479,24 @@ Sequence< ::rtl::OUString > SAL_CALL OCo
 //--------------------------------------------------------------------------
 sal_Bool SAL_CALL OConfigurationRegistryKey::createLink( const ::rtl::OUString& /*aLinkName*/, const ::rtl::OUString& /*aLinkTarget*/ ) throw(InvalidRegistryException, RuntimeException)
 {
-	MutexGuard aGuard(m_aMutex);
 	throw InvalidRegistryException(UNISTRING("This registry, which is base on a configuration tree, does not support links."), THISREF());
 }
 
 //--------------------------------------------------------------------------
 void SAL_CALL OConfigurationRegistryKey::deleteLink( const ::rtl::OUString& /*rLinkName*/ ) throw(InvalidRegistryException, RuntimeException)
 {
-	MutexGuard aGuard(m_aMutex);
 	throw InvalidRegistryException(UNISTRING("This registry, which is base on a configuration tree, does not support links."), THISREF());
 }
 
 //--------------------------------------------------------------------------
 ::rtl::OUString SAL_CALL OConfigurationRegistryKey::getLinkTarget( const ::rtl::OUString& /*rLinkName*/ ) throw(InvalidRegistryException, RuntimeException)
 {
-	MutexGuard aGuard(m_aMutex);
 	throw InvalidRegistryException(UNISTRING("This registry, which is base on a configuration tree, does not support links."), THISREF());
 }
 
 //--------------------------------------------------------------------------
 ::rtl::OUString SAL_CALL OConfigurationRegistryKey::getResolvedName( const ::rtl::OUString& /*aKeyName*/ ) throw(InvalidRegistryException, RuntimeException)
 {
-	MutexGuard aGuard(m_aMutex);
 	throw InvalidRegistryException(UNISTRING("This registry, which is base on a configuration tree, does not support links."), THISREF());
 }
 //--------------------------------------------------------------------------
Index: configmgr/source/registry/cfgregistrykey.hxx
===================================================================
RCS file: /cvs/util/configmgr/source/registry/cfgregistrykey.hxx,v
retrieving revision 1.6
retrieving revision 1.6.84.1
diff -u -p -u -p -r1.6 -r1.6.84.1
--- configmgr/source/registry/cfgregistrykey.hxx	8 Sep 2005 04:14:56 -0000	1.6
+++ configmgr/source/registry/cfgregistrykey.hxx	11 Jan 2007 20:16:02 -0000	1.6.84.1
@@ -53,10 +53,6 @@
 #include <com/sun/star/beans/XPropertySetInfo.hpp>
 #endif
 
-#ifndef _OSL_MUTEX_HXX_
-#include <osl/Mutex.hxx>
-#endif
-
 //..........................................................................
 namespace configmgr
 {
@@ -73,7 +69,6 @@ typedef ::cppu::WeakImplHelper1	<	::com:
 class OConfigurationRegistryKey
 		:public OConfigurationRegistryKey_Base
 {
-	::osl::Mutex	m_aMutex;			/// access safety
 	sal_Bool		m_bReadOnly;		/// is the key readonly ?
 
 	::com::sun::star::uno::Reference< ::com::sun::star::container::XNameAccess >
Index: configmgr/source/registry/configregistry.cxx
===================================================================
RCS file: /cvs/util/configmgr/source/registry/configregistry.cxx,v
retrieving revision 1.11
retrieving revision 1.11.24.1
diff -u -p -u -p -r1.11 -r1.11.24.1
--- configmgr/source/registry/configregistry.cxx	16 Sep 2006 15:19:38 -0000	1.11
+++ configmgr/source/registry/configregistry.cxx	11 Jan 2007 20:16:02 -0000	1.11.24.1
@@ -46,6 +46,9 @@
 #ifndef CONFIGMGR_API_FACTORY_HXX_
 #include "confapifactory.hxx"
 #endif
+#ifndef CONFIGMGR_UTILITY_HXX_
+#include "utility.hxx"
+#endif
 
 #ifndef _COMPHELPER_SEQUENCE_HXX_
 #include <comphelper/sequence.hxx>
@@ -197,7 +200,7 @@ Sequence< sal_Int8 > SAL_CALL OConfigura
 //--------------------------------------------------------------------------
 ::rtl::OUString SAL_CALL OConfigurationRegistry::getURL() throw(RuntimeException)
 {
-	MutexGuard aGuard(m_aMutex);
+    UnoApiLock aLock;
 	return m_sLocation;
 }
 
@@ -213,7 +216,7 @@ void OConfigurationRegistry::implCheckOp
 //--------------------------------------------------------------------------
 void SAL_CALL OConfigurationRegistry::open( const ::rtl::OUString& _rURL, sal_Bool _bReadOnly, sal_Bool /*_bCreate*/ ) throw(InvalidRegistryException, RuntimeException)
 {
-	MutexGuard aGuard(m_aMutex);
+    UnoApiLock aLock;
 
 	if (implIsOpen())
 		close();
@@ -272,7 +275,7 @@ void SAL_CALL OConfigurationRegistry::op
 //--------------------------------------------------------------------------
 sal_Bool SAL_CALL OConfigurationRegistry::isValid(  ) throw(RuntimeException)
 {
-	MutexGuard aGuard(m_aMutex);
+    UnoApiLock aLock;
 	return implIsOpen();
 }
 
@@ -285,7 +288,7 @@ sal_Bool OConfigurationRegistry::implIsO
 //--------------------------------------------------------------------------
 void SAL_CALL  OConfigurationRegistry::close(  ) throw(InvalidRegistryException, RuntimeException)
 {
-	ClearableMutexGuard aGuard(m_aMutex);
+    UnoApiLock aLock;
 
 	Reference< XRegistryKey > xRootKey(m_xRootKey);
 	m_xRootKey = NULL;
@@ -296,8 +299,6 @@ void SAL_CALL  OConfigurationRegistry::c
 
 	m_sLocation = ::rtl::OUString();
 
-	aGuard.clear();
-
 	if (xRootKey.is())
 		xRootKey->closeKey();
 
@@ -311,7 +312,7 @@ void SAL_CALL OConfigurationRegistry::di
 	close();
 
 	{
-		MutexGuard aGuard(m_aMutex);
+        UnoApiLock aLock;
 
 		m_xConfigurationProvider.clear();
 		m_xORB.clear();
@@ -323,7 +324,7 @@ void SAL_CALL OConfigurationRegistry::di
 //--------------------------------------------------------------------------
 void SAL_CALL OConfigurationRegistry::destroy(  ) throw(InvalidRegistryException, RuntimeException)
 {
-	MutexGuard aGuard(m_aMutex);
+    UnoApiLock aLock;
 	implCheckOpen();
 
 	throw InvalidRegistryException(UNISTRING("This registry is a wrapper for a configuration access. It can not be destroyed."), THISREF());
@@ -332,7 +333,7 @@ void SAL_CALL OConfigurationRegistry::de
 //--------------------------------------------------------------------------
 Reference< XRegistryKey > SAL_CALL OConfigurationRegistry::getRootKey(  ) throw(InvalidRegistryException, RuntimeException)
 {
-	MutexGuard aGuard(m_aMutex);
+    UnoApiLock aLock;
 	implCheckOpen();
 
 	return m_xRootKey;
@@ -341,7 +342,7 @@ Reference< XRegistryKey > SAL_CALL OConf
 //--------------------------------------------------------------------------
 sal_Bool SAL_CALL OConfigurationRegistry::isReadOnly(  ) throw(InvalidRegistryException, RuntimeException)
 {
-	MutexGuard aGuard(m_aMutex);
+    UnoApiLock aLock;
 	implCheckOpen();
 
 	return !m_xUpdateRoot.is();
@@ -351,7 +352,7 @@ sal_Bool SAL_CALL OConfigurationRegistry
 //--------------------------------------------------------------------------
 void SAL_CALL OConfigurationRegistry::mergeKey( const ::rtl::OUString& /*aKeyName*/, const ::rtl::OUString& /*aUrl*/ ) throw(InvalidRegistryException, MergeConflictException, RuntimeException)
 {
-	MutexGuard aGuard(m_aMutex);
+    UnoApiLock aLock;
 	implCheckOpen();
 
 	// not supported. but we can't throw an NoSupportException here ...
@@ -362,7 +363,7 @@ void SAL_CALL OConfigurationRegistry::me
 void SAL_CALL OConfigurationRegistry::flush(  ) throw(RuntimeException)
 {
 	{
-		MutexGuard aGuard(m_aMutex);
+        UnoApiLock aLock;
 		if (m_xUpdateRoot.is())
 		{
 			try
Index: configmgr/source/registry/configregistry.hxx
===================================================================
RCS file: /cvs/util/configmgr/source/registry/configregistry.hxx,v
retrieving revision 1.6
retrieving revision 1.6.84.1
diff -u -p -u -p -r1.6 -r1.6.84.1
--- configmgr/source/registry/configregistry.hxx	8 Sep 2005 04:15:29 -0000	1.6
+++ configmgr/source/registry/configregistry.hxx	11 Jan 2007 20:16:03 -0000	1.6.84.1
@@ -39,9 +39,6 @@
 #ifndef _CPPUHELPER_IMPLBASE2_HXX_
 #include <cppuhelper/implbase2.hxx>
 #endif
-#ifndef _OSL_MUTEX_HXX_ 
-#include <osl/mutex.hxx>
-#endif
 
 #ifndef CONFIGMGR_API_SVCCOMPONENT_HXX_
 #include "confsvccomponent.hxx"
Index: configmgr/source/tree/builddata.cxx
===================================================================
RCS file: /cvs/util/configmgr/source/tree/builddata.cxx,v
retrieving revision 1.11
retrieving revision 1.10.10.3
diff -u -p -u -p -r1.11 -r1.10.10.3
--- configmgr/source/tree/builddata.cxx	20 Dec 2006 18:44:39 -0000	1.11
+++ configmgr/source/tree/builddata.cxx	12 Jan 2007 17:51:20 -0000	1.10.10.3
@@ -38,18 +38,9 @@
 
 #include "builddata.hxx"
 
-#ifndef CONFIGMGR_TREEADDRESS_HXX
-#include "treeaddress.hxx"
-#endif
 #ifndef CONFIGMGR_TREEACCESSOR_HXX
 #include "treeaccessor.hxx"
 #endif
-#ifndef CONFIGMGR_ACCESSOR_HXX
-#include "accessor.hxx"
-#endif
-#ifndef CONFIGMGR_UPDATEACCESSOR_HXX
-#include "updateaccessor.hxx"
-#endif
 
 #ifndef CONFIGMGR_NODEACCESS_HXX
 #include "nodeaccess.hxx"
@@ -100,30 +91,24 @@ namespace configmgr
     {
     //-------------------------------------------------------------------------
         using namespace sharable;
-        using memory::Pointer;
-        using memory::Accessor;
-        using memory::Allocator;
-        using memory::UpdateAccessor;
 //-----------------------------------------------------------------------------
 
     static 
     inline
     NodeAddress offsetNodeBy(NodeAddress _aNode, Offset _nOffset)
     {
-        Address aRawAddr = _aNode.addressValue() + _nOffset * sizeof(Node);
-
-        return NodeAddress(Pointer(aRawAddr));
+	sharable::Node *pNode = _aNode;
+	pNode += _nOffset;
+        return NodeAddress(pNode);
     }
 
     static 
     inline
     NodeAddress addressOfNodeAt(TreeAddress _aTree, Offset _nOffset)
     {
-        Address aRawAddr = _aTree.addressValue() + 
-                            offsetof(TreeFragment,nodes) + 
-                            _nOffset * sizeof(Node);
-
-        return NodeAddress(Pointer(aRawAddr));
+        sharable::TreeFragment *pRaw = _aTree;
+//        return NodeAddress( (memory::Address)( pRaw->nodes + _nOffset ));
+	return &pRaw->nodes[_nOffset];
     }
 
 //-----------------------------------------------------------------------------
@@ -147,12 +132,12 @@ namespace configmgr
         void resetTreeFragment();
         void resetTreeFragment(sharable::String _treeName, State::Field _state);
 
-        TreeAddress createTreeFragment(UpdateAccessor & _anUpdater);
+        TreeAddress createTreeFragment();
 
         Offset  startGroup( Name _aName, Flags::Field _aFlags ); 
         void    endGroup( Offset _nPos ); 
 
-        void    addSet( Name _aName, Flags::Field _aFlags, Address _aElementType ); 
+        void    addSet( Name _aName, Flags::Field _aFlags, SetElementAddress _aElementType ); 
 
         void    addValue( Name _aName, Flags::Field _aFlags, 
                             AnyData::TypeCode _aValueType, 
@@ -163,8 +148,8 @@ namespace configmgr
         class LinkSetNodes;
 
     private: 
-        TreeAddress allocTreeFragment(UpdateAccessor & _anUpdater);
-        void linkTreeFragment(UpdateAccessor & _anUpdater, TreeAddress _aTreeAddr);
+	TreeAddress allocTreeFragment();
+        void linkTreeFragment(TreeAddress _aTreeAddr);
 
         Offset addNode(Name _aName, Flags::Field _aFlags, Type::Field _aType);
         void checkOffset(Offset _pos);
@@ -173,34 +158,23 @@ namespace configmgr
 
     class TreeNodeBuilder::CollectSetElements
     {
-        UpdateAccessor &    m_updater;
         TreeAddress         m_head;
     public:
         explicit
-        CollectSetElements(UpdateAccessor & _anUpdater)
-        : m_updater(_anUpdater)
-        {
-        }
+        CollectSetElements() : m_head(NULL) {}
 
         void resetElementList();
         void addElement(TreeAddress _aNewElement);
         List getElementListAndClear();
-
-        UpdateAccessor &    updater()   const { return m_updater; }
     };
 //-----------------------------------------------------------------------------
 
     class TreeNodeBuilder::LinkSetNodes : private SetVisitor
     {
-        UpdateAccessor &    m_updater;
         NodeAddress         m_aParentAddr;
     public:
         explicit
-        LinkSetNodes(UpdateAccessor & _anUpdater)
-        : m_updater(_anUpdater)
-        , m_aParentAddr()
-        {
-        }
+        LinkSetNodes() : m_aParentAddr(NULL) {}
 
         Result  linkTree(TreeAddress const & _aFragment);
         Result  linkSet(SetNodeAccess const & _aSet);
@@ -218,19 +192,13 @@ namespace configmgr
     {
     public:
         explicit
-        BasicDataTreeBuilder(UpdateAccessor & _anUpdater)
-        : m_updater(_anUpdater)
-        {}
+        BasicDataTreeBuilder() {}
 
-        TreeAddress createTree() { return m_builder.createTreeFragment(m_updater); }
+        TreeAddress createTree() { return m_builder.createTreeFragment(); }
 
     protected:
         TreeNodeBuilder&    builder()         { return m_builder; }
-        UpdateAccessor &    updater()   const { return m_updater; }
-        Accessor            accessor()  const { return m_updater.accessor(); }
-        Allocator           allocator() const { return m_updater.allocator(); }
     private:
-        UpdateAccessor &    m_updater;
         TreeNodeBuilder     m_builder;
     };
 //-----------------------------------------------------------------------------
@@ -241,9 +209,7 @@ namespace configmgr
         bool m_bWithDefaults;
     public:
         explicit
-        ConvertingDataTreeBuilder(UpdateAccessor & _anUpdater)
-        : BasicDataTreeBuilder(_anUpdater)
-        {}
+        ConvertingDataTreeBuilder() : BasicDataTreeBuilder() {}
         
         TreeAddress buildTree(OUString const & _aTreeName, INode const& _aNode, bool _bWithDefault);
         TreeAddress buildElement(INode const& _aNode, OUString const & _aTypeName, bool _bWithDefault);
@@ -253,7 +219,7 @@ namespace configmgr
         virtual void handle(ISubtree  const & _aNode);
         virtual void handle(OValueNode const & _aNode);
 
-        Address makeTemplateData(rtl::OUString const & _aTemplateName, rtl::OUString const & _aTemplateModule);
+        SetElementAddress makeTemplateData(rtl::OUString const & _aTemplateName, rtl::OUString const & _aTemplateModule);
 
         Name allocName(INode const & _aNode);
         State::Field makeState(node::Attributes const & _aAttributes);
@@ -269,13 +235,13 @@ namespace configmgr
         bool            m_bWithDefaults;
     public:
         explicit
-        ElementListBuilder(UpdateAccessor & _anUpdater)
-        : m_aCollector(_anUpdater)
+        ElementListBuilder()
+        : m_aCollector()
         , m_sTypeName()
         , m_bWithDefaults()
         {}
 
-        List buildElementList(ISubtree const & _aSet, bool _bWithDefaults);
+        TreeFragment *buildElementList(ISubtree const & _aSet, bool _bWithDefaults);
     private:
         void handleNode(INode const & _aSourceNode);
 
@@ -288,9 +254,7 @@ namespace configmgr
     {
     public:
         explicit
-        CopyingDataTreeBuilder(UpdateAccessor & _anUpdater)
-        : BasicDataTreeBuilder(_anUpdater)
-        {}
+        CopyingDataTreeBuilder() : BasicDataTreeBuilder() {}
         
         TreeAddress buildTree(TreeAccessor const & _aSourceTree);
 
@@ -304,7 +268,7 @@ namespace configmgr
         Result handle(GroupNodeAccess const & _aNode);
         Result handle(SetNodeAccess const & _aNode);
 
-		Address makeTemplateData(Accessor const & _aSourceAccessor, Address _aSourceTemplate);
+        SetElementAddress makeTemplateData(SetElementAddress _aSourceTemplate);
     };
 //-----------------------------------------------------------------------------
 
@@ -313,9 +277,7 @@ namespace configmgr
         TreeNodeBuilder::CollectSetElements m_aCollector;
     public:
         explicit
-        ElementListBuilder(UpdateAccessor & _anUpdater)
-        : m_aCollector(_anUpdater)
-        {}
+        ElementListBuilder() : m_aCollector() {}
 
         List buildElementList(SetNodeAccess const & _aSet);
     protected:
@@ -339,15 +301,15 @@ namespace configmgr
         }
 
         std::auto_ptr<INode>        buildNode(TreeAccessor  const& _aTree, bool _bUseTreeName);
-        std::auto_ptr<INode>        buildNode(NodeAccessRef  const& _aTree);
+        std::auto_ptr<INode>        buildNode(NodeAccess  const& _aTree);
 
         std::auto_ptr<ISubtree>     buildNodeTree(GroupNodeAccess const& _aGroupNode) const;
         std::auto_ptr<ISubtree>     buildNodeTree(SetNodeAccess const& _aSetNode) const;
         std::auto_ptr<OValueNode>   buildNodeTree(ValueNodeAccess const& _aValueNode) const
         { return this->convertNode(_aValueNode); }
 
-        static node::Attributes convertAttributes(NodeAccessRef const& _aNode)
-        { return _aNode.getAttributes(); }
+        static node::Attributes convertAttributes(NodeAccess const& _aNode)
+        { return _aNode->getAttributes(); }
     protected:
         using NodeVisitor::handle;
 
@@ -380,7 +342,7 @@ namespace configmgr
 
     private:
         Result handle(TreeAccessor const & _aElement);
-        Result handle(NodeAccessRef const & _aMember);
+        Result handle(NodeAccess const & _aMember);
     };
 //-----------------------------------------------------------------------------
 
@@ -388,20 +350,12 @@ namespace configmgr
     {
     public:
         explicit
-        DataTreeDefaultMerger(UpdateAccessor & _anUpdater)
-        : m_updater(_anUpdater)
-        {}
+        DataTreeDefaultMerger() {}
 
         void mergeDefaults(TreeAddress _aBaseAddress, INode const& _aDefaultNode);
     private:
         void handle(OValueNode const & _aNode);
         void handle(ISubtree  const & _aNode);
-    protected:
-        UpdateAccessor &    updater()   const { return m_updater; }
-        Accessor            accessor()  const { return m_updater.accessor(); }
-        Allocator           allocator() const { return m_updater.allocator(); }
-    private:
-        UpdateAccessor &    m_updater;
     };
 
 //-----------------------------------------------------------------------------
@@ -410,9 +364,7 @@ namespace configmgr
     {
     public:
         explicit
-        DataTreeCleanup(UpdateAccessor & _anUpdater)
-        : m_updater(_anUpdater)
-        {}
+        DataTreeCleanup() {}
 
         TreeAddress destroyTree(TreeAddress _aBaseAddress);
     private:
@@ -424,20 +376,14 @@ namespace configmgr
         void destroyData(sharable::GroupNode * _pNode);
         void destroyData(sharable::ValueNode * _pNode);
         void destroyData(sharable::SetNode   * _pNode);
-    private:
-        UpdateAccessor &    updater()   const { return m_updater; }
-        Accessor            accessor()  const { return m_updater.accessor(); }
-        Allocator           allocator() const { return m_updater.allocator(); }
-    private:
-        UpdateAccessor &    m_updater;
     };
 
 //-----------------------------------------------------------------------------
 //-----------------------------------------------------------------------------
 
-TreeAddress buildTree(memory::UpdateAccessor& _aTargetMemory, TreeAccessor const& _aTree)
+TreeAddress buildTree(TreeAccessor const& _aTree)
 {
-    CopyingDataTreeBuilder aBuilder(_aTargetMemory);
+    CopyingDataTreeBuilder aBuilder;
 
     TreeAddress aResult = aBuilder.buildTree(_aTree);
 
@@ -445,9 +391,9 @@ TreeAddress buildTree(memory::UpdateAcce
 }
 //-----------------------------------------------------------------------------
 
-TreeAddress buildTree(memory::UpdateAccessor& _aTargetMemory, rtl::OUString const & _aTreeName, INode const& _aNode, bool _bWithDefaults)
+TreeAddress buildTree(rtl::OUString const & _aTreeName, INode const& _aNode, bool _bWithDefaults)
 {
-    ConvertingDataTreeBuilder aBuilder(_aTargetMemory);
+    ConvertingDataTreeBuilder aBuilder;
 
     TreeAddress aResult = aBuilder.buildTree(_aTreeName, _aNode,_bWithDefaults);
 
@@ -455,9 +401,9 @@ TreeAddress buildTree(memory::UpdateAcce
 }
 //-----------------------------------------------------------------------------
 
-TreeAddress buildElementTree(memory::UpdateAccessor& _aTargetMemory, INode const& _aNode, rtl::OUString const & _aTypeName, bool _bWithDefaults)
+TreeAddress buildElementTree(INode const& _aNode, rtl::OUString const & _aTypeName, bool _bWithDefaults)
 {
-    ConvertingDataTreeBuilder aBuilder(_aTargetMemory);
+    ConvertingDataTreeBuilder aBuilder;
 
     TreeAddress aResult = aBuilder.buildElement(_aNode, _aTypeName, _bWithDefaults);
 
@@ -465,17 +411,17 @@ TreeAddress buildElementTree(memory::Upd
 }
 //-----------------------------------------------------------------------------
  
-void mergeDefaults(memory::UpdateAccessor& _aTargetMemory, TreeAddress _aBaseAddress, INode const& _aDefaultNode)
+void mergeDefaults(TreeAddress _aBaseAddress, INode const& _aDefaultNode)
 {
-    DataTreeDefaultMerger aMergeHelper(_aTargetMemory);
+    DataTreeDefaultMerger aMergeHelper;
 
     aMergeHelper.mergeDefaults(_aBaseAddress, _aDefaultNode);
 }
 //-----------------------------------------------------------------------------
 
-void destroyTree(memory::UpdateAccessor& _aTreeMemory, TreeAddress _aBaseAddress)
+void destroyTree(TreeAddress _aBaseAddress)
 {
-    DataTreeCleanup aCleaner(_aTreeMemory);
+    DataTreeCleanup aCleaner;
 
     aCleaner.destroyTree(_aBaseAddress);
 }
@@ -493,25 +439,25 @@ std::auto_ptr<INode> convertTree(TreeAcc
 inline 
 void TreeNodeBuilder::CollectSetElements::resetElementList()
 {
-    OSL_ENSURE(m_head.isNull(), "Joining to a element list that was forgotten");
+    OSL_ENSURE(m_head == NULL, "Joining to a element list that was forgotten");
 }
 //-----------------------------------------------------------------------------
 
 inline 
 List TreeNodeBuilder::CollectSetElements::getElementListAndClear()
 {
-    List aResult = m_head.addressValue();
-    m_head = TreeAddress();
+    List aResult = m_head;
+    m_head = NULL;
     return aResult;
 }
 //-----------------------------------------------------------------------------
 
 void TreeNodeBuilder::CollectSetElements::addElement(TreeAddress _aNewElement)
 {
-    if (TreeFragment * pNewFragment = TreeAccessor::access(_aNewElement,m_updater))
+    if (TreeFragment * pNewFragment = _aNewElement)
     {
         pNewFragment->header.parent = 0; // data not available here
-        pNewFragment->header.next   = m_head.addressValue();
+        pNewFragment->header.next   = m_head;
 
         m_head = _aNewElement;
     }
@@ -523,19 +469,19 @@ void TreeNodeBuilder::CollectSetElements
 
 NodeVisitor::Result TreeNodeBuilder::LinkSetNodes::linkTree(TreeAddress const & _aTree)
 {
-    TreeAccessor aTreeAccess(m_updater.accessor(), _aTree);
+    TreeAccessor aTreeAccess(_aTree);
 
-    TreeFragment const & rTreeData = aTreeAccess.data();
+    TreeFragment const & rTreeData = *aTreeAccess;
 
     NodeAddress aOldParent = m_aParentAddr;
-    m_aParentAddr = NodeAddress();
+    m_aParentAddr = NULL;
 
     Result eResult = CONTINUE;
 
     Offset nCount = rTreeData.header.count;
     for(Offset i=0; i < nCount; ++i)
     {
-        NodeAccessRef aNode(&aTreeAccess.accessor(),&rTreeData.nodes[i]);
+        NodeAccess aNode(&rTreeData.nodes[i]);
         eResult =this->visitNode( aNode );
 
         if (eResult == DONE) break;
@@ -549,12 +495,12 @@ NodeVisitor::Result TreeNodeBuilder::Lin
 
 NodeVisitor::Result TreeNodeBuilder::LinkSetNodes::linkSet(SetNodeAccess const & _aSet)
 {
-    OSL_ENSURE(m_aParentAddr.isNull(),"Linking set data already in progress");
-    m_aParentAddr = _aSet.address();
+    OSL_ENSURE(m_aParentAddr == NULL,"Linking set data already in progress");
+    m_aParentAddr = _aSet;
 
     Result aResult = this->visitElements(_aSet);
 
-    m_aParentAddr = NodeAddress();
+    m_aParentAddr = NULL;
 
     return aResult;
 }
@@ -562,11 +508,12 @@ NodeVisitor::Result TreeNodeBuilder::Lin
 
 NodeVisitor::Result TreeNodeBuilder::LinkSetNodes::handle(TreeAccessor const & _aSourceTree)
 {
-    OSL_ENSURE(m_aParentAddr.is(),"Cannot link set element without parent address");
+    OSL_ENSURE(m_aParentAddr != NULL,"Cannot link set element without parent address");
 
-    TreeFragment * pFragment = _aSourceTree.access(_aSourceTree.address(), m_updater);
+    //    TreeFragment * pFragment = _aSourceTree;
 
-    pFragment->header.parent = m_aParentAddr.addressValue();
+    //    pFragment->header.parent = m_aParentAddr;
+    _aSourceTree->header.parent = m_aParentAddr;
 
     return CONTINUE;
 }
@@ -638,41 +585,31 @@ void TreeNodeBuilder::resetTreeFragment(
 }
 //-----------------------------------------------------------------------------
 
-TreeAddress TreeNodeBuilder::allocTreeFragment(UpdateAccessor & _anUpdater)
+TreeAddress TreeNodeBuilder::allocTreeFragment()
 {
     OSL_ENSURE(m_nodes.size() == m_header.count, "TreeNodeBuilder: node count mismatch");
 
-    sal_uInt32 const nFragmentSize = sizeof(TreeFragment) + (m_header.count-1)*sizeof(Node);
-
-    OSL_ASSERT(nFragmentSize >= sizeof m_header + m_header.count*sizeof(Node));
+    TreeFragment *pFragment = TreeFragment::allocate(m_header.count);
+    pFragment->header = m_header;
+    std::copy(m_nodes.begin(),m_nodes.end(),pFragment->nodes);
 
-    Address aBaseAddress = _anUpdater.allocator().allocate(nFragmentSize);
-
-    TreeAddress aResult = TreeAddress( memory::Pointer(aBaseAddress) );
-
-    if (TreeFragment * pFragment = TreeAccessor::access(aResult,_anUpdater))
-    {
-        pFragment->header = m_header;
-        std::copy(m_nodes.begin(),m_nodes.end(),pFragment->nodes);
-    }
-    
-    return aResult;
+    return TreeAddress( pFragment );
 }
 //-----------------------------------------------------------------------------
 
-void TreeNodeBuilder::linkTreeFragment(UpdateAccessor & _anUpdater, TreeAddress _aTreeFragment)
+void TreeNodeBuilder::linkTreeFragment(TreeAddress _aTreeFragment)
 {
-    LinkSetNodes(_anUpdater).linkTree(_aTreeFragment);
+    LinkSetNodes().linkTree(_aTreeFragment);
 }
 //-----------------------------------------------------------------------------
 
-TreeAddress TreeNodeBuilder::createTreeFragment(UpdateAccessor & _anUpdater)
+TreeAddress TreeNodeBuilder::createTreeFragment()
 {
-    TreeAddress aResult = allocTreeFragment(_anUpdater);
+    TreeAddress aResult = allocTreeFragment();
 
-    if (aResult.is())
+    if (aResult != NULL)
     {
-        linkTreeFragment(_anUpdater,aResult);
+        linkTreeFragment(aResult);
 
         m_nodes.clear(); // ownership of indirect data has gone ...
     }
@@ -708,7 +645,7 @@ void TreeNodeBuilder::endGroup( Offset _
 }
 //-----------------------------------------------------------------------------
 
-void TreeNodeBuilder::addSet( Name _aName, Flags::Field _aFlags, Address _aElementType ) 
+void TreeNodeBuilder::addSet( Name _aName, Flags::Field _aFlags, SetElementAddress _aElementType ) 
 {
     addNode(_aName,_aFlags,Type::nodetype_set);
 
@@ -738,10 +675,10 @@ void TreeNodeBuilder::addValue( Name _aN
 
 TreeAddress CopyingDataTreeBuilder::buildTree(TreeAccessor const & _aSourceTree)
 {
-    OSL_ENSURE(_aSourceTree.isValid(), "Trying to build a tree from  NULL data");
-    if (!_aSourceTree.isValid()) return TreeAddress();
+    OSL_ENSURE(_aSourceTree != NULL, "Trying to build a tree from  NULL data");
+    if (_aSourceTree == NULL) return NULL;
 
-    TreeFragment const & aSrc = _aSourceTree.data();
+    TreeFragment const & aSrc = *_aSourceTree;
 
     sharable::String aTreeName = allocString( aSrc.getName());
     this->builder().resetTreeFragment(aTreeName, aSrc.header.state);
@@ -763,12 +700,12 @@ NodeVisitor::Result CopyingDataTreeBuild
 
     AnyData aNewValue, aNewDefault;
     if (aFlags & Flags::valueAvailable)   
-        aNewValue = allocData(allocator(), aType, aSrc.getUserValue(_aNode.accessor()));
+        aNewValue = allocData(aType, aSrc.getUserValue());
     else
         aNewValue.data = 0;
 
     if (aFlags & Flags::defaultAvailable)   
-        aNewDefault = allocData(allocator(), aType, aSrc.getDefaultValue(_aNode.accessor()));
+        aNewDefault = allocData(aType, aSrc.getDefaultValue());
     else
         aNewDefault.data = 0;
     
@@ -799,25 +736,22 @@ NodeVisitor::Result CopyingDataTreeBuild
 
     sharable::Name aNodeName = allocName( aSrc.info.getName());
     Flags::Field aFlags = aSrc.info.flags;
-    Address aTemplate = this->makeTemplateData(_aNode.accessor(), aSrc.elementType);
+    SetElementAddress aTemplate = this->makeTemplateData(aSrc.elementType);
     
     this->builder().addSet(aNodeName,aFlags,aTemplate);
 
     OSL_ASSERT( this->builder().lastNode().isSet() );
     SetNode& _aNewSet = this->builder().lastNode().set;
 
-    _aNewSet.elements = ElementListBuilder( this->updater() ).buildElementList(_aNode);
+    _aNewSet.elements = ElementListBuilder().buildElementList(_aNode);
 
     return CONTINUE;
 }
 //-----------------------------------------------------------------------------
         
-Address CopyingDataTreeBuilder::makeTemplateData(Accessor const & _aSourceAccessor, Address _aSourceTemplate)
+SetElementAddress CopyingDataTreeBuilder::makeTemplateData(SetElementAddress _aSourceTemplate)
 {
-    rtl::OUString aTemplateName      = SetNode::getTemplateDataName(_aSourceAccessor,_aSourceTemplate);
-    rtl::OUString aTemplateModule    = SetNode::getTemplateDataModule(_aSourceAccessor,_aSourceTemplate);
-
-    return SetNode::allocTemplateData(allocator(), aTemplateName, aTemplateModule );
+    return SetNode::copyTemplateData(_aSourceTemplate);
 }
 //-----------------------------------------------------------------------------
 
@@ -835,7 +769,7 @@ List CopyingDataTreeBuilder::ElementList
 
 NodeVisitor::Result CopyingDataTreeBuilder::ElementListBuilder::handle(TreeAccessor const & _aSourceTree)
 {
-    TreeAddress aNewElement = CopyingDataTreeBuilder(m_aCollector.updater()).buildTree(_aSourceTree);
+    TreeAddress aNewElement = CopyingDataTreeBuilder().buildTree(_aSourceTree);
 
     m_aCollector.addElement(aNewElement);
 
@@ -895,14 +829,15 @@ void ConvertingDataTreeBuilder::handle(I
 
     if (_aNode.isSetNode())
     {
-        Address aTemplate = this->makeTemplateData(_aNode.getElementTemplateName(),_aNode.getElementTemplateModule());
+        SetElementAddress aTemplate = this->makeTemplateData(_aNode.getElementTemplateName(),
+							     _aNode.getElementTemplateModule());
     
         this->builder().addSet(aNodeName,aFlags,aTemplate);
 
         OSL_ASSERT( this->builder().lastNode().isSet() );
         SetNode& _aNewSet = this->builder().lastNode().set;
 
-        _aNewSet.elements = ElementListBuilder(this->updater()).buildElementList(_aNode, m_bWithDefaults);
+        _aNewSet.elements = ElementListBuilder().buildElementList(_aNode, m_bWithDefaults);
     }
     else
     {
@@ -930,7 +865,7 @@ void ConvertingDataTreeBuilder::handle(O
         uno::Any aValue = _aNode.getValue();
         if (aValue.hasValue())
         {
-            aNewValue = allocData(allocator(), aType, aValue);
+            aNewValue = allocData(aType, aValue);
             aFlags |= Flags::valueAvailable;
         }
     }
@@ -940,7 +875,7 @@ void ConvertingDataTreeBuilder::handle(O
         uno::Any aDefault = _aNode.getDefault();
         if (aDefault.hasValue())
         {
-            aNewDefault = allocData(allocator(), aType, aDefault);
+            aNewDefault = allocData(aType, aDefault);
             aFlags |= Flags::defaultAvailable;
         }
     }
@@ -1005,9 +940,9 @@ Flags::Field ConvertingDataTreeBuilder::
 }
 //-----------------------------------------------------------------------------
 
-Address ConvertingDataTreeBuilder::makeTemplateData(rtl::OUString const & _aTemplateName, rtl::OUString const & _aTemplateModule)
+SetElementAddress ConvertingDataTreeBuilder::makeTemplateData(rtl::OUString const & _aTemplateName, rtl::OUString const & _aTemplateModule)
 {
-    return SetNode::allocTemplateData(allocator(), _aTemplateName, _aTemplateModule );
+    return SetNode::allocTemplateData(_aTemplateName, _aTemplateModule );
 }
 //-----------------------------------------------------------------------------
 
@@ -1028,7 +963,7 @@ List ConvertingDataTreeBuilder::ElementL
 
 void ConvertingDataTreeBuilder::ElementListBuilder::handleNode(INode const & _aSourceNode)
 {
-    TreeAddress aNewElement = ConvertingDataTreeBuilder(m_aCollector.updater())
+    TreeAddress aNewElement = ConvertingDataTreeBuilder()
                                  .buildElement(_aSourceNode,m_sTypeName,m_bWithDefaults);
 
     m_aCollector.addElement(aNewElement);
@@ -1062,7 +997,7 @@ std::auto_ptr<INode> ConvertingNodeBuild
 }
 //-----------------------------------------------------------------------------
 
-std::auto_ptr<INode> ConvertingNodeBuilder::buildNode(NodeAccessRef const & _aSourceNode)
+std::auto_ptr<INode> ConvertingNodeBuilder::buildNode(NodeAccess const & _aSourceNode)
 {
     OSL_ENSURE( !m_pNode.get(), "Old node tree will be dropped");
     this->visitNode(_aSourceNode);
@@ -1164,7 +1099,7 @@ NodeVisitor::Result ConvertingSubnodeBui
 }
 //-----------------------------------------------------------------------------
 
-NodeVisitor::Result ConvertingSubnodeBuilder::handle(NodeAccessRef const & _aMember)
+NodeVisitor::Result ConvertingSubnodeBuilder::handle(NodeAccess const & _aMember)
 {
     OSL_ASSERT(!m_rParentNode.isSetNode());
     m_rParentNode.addChild( m_aSubnodeBuilder.buildNode(_aMember) );
@@ -1191,9 +1126,9 @@ void DataTreeDefaultMerger::handle(OValu
 
 TreeAddress DataTreeCleanup::destroyTree(TreeAddress _aBaseAddress)
 {
-    TreeFragment * pData = TreeAccessor::access(_aBaseAddress,updater());
+    TreeFragment *pData = _aBaseAddress;
 
-    List aNext = pData->header.next;
+    TreeFragment *pNext = pData->header.next;
 
     Offset const nCount = pData->header.count;
 
@@ -1204,15 +1139,15 @@ TreeAddress DataTreeCleanup::destroyTree
         destroyNode( addressOfNodeAt(_aBaseAddress,i) );
     }
 
-    allocator().deallocate( _aBaseAddress.addressValue() );
+    TreeFragment::free_shallow( pData );
 
-    return TreeAddress( Pointer(aNext) );
+    return TreeAddress( pNext );
 }
 //-----------------------------------------------------------------------------
 
 void DataTreeCleanup::destroyNode(NodeAddress _aNodeAddress)
 {
-    Node * pNode = NodeAccess::access(_aNodeAddress,updater());
+    Node * pNode = _aNodeAddress;
 
     Type::Field aTypeTag = pNode->node.info.type;
     switch ( aTypeTag & Type::mask_nodetype )
@@ -1253,16 +1188,16 @@ void DataTreeCleanup::destroyData(NodeIn
 
 void DataTreeCleanup::destroyData(sharable::SetNode * _pNode)
 {
-    TreeAddress aElement( Pointer( _pNode->elements ) );
+    TreeAddress aElement( _pNode->elements );
 
-    Address aTemplate = _pNode->elementType;;
+    SetElementAddress aTemplate = _pNode->elementType;;
 
     destroyData(&_pNode->info);
 
-    while (aElement.is())
+    while (aElement != NULL)
         aElement = destroyTree(aElement);
 
-    SetNode::releaseTemplateData( allocator(), aTemplate );
+    SetNode::releaseTemplateData( aTemplate );
 }
 //-----------------------------------------------------------------------------
 	
@@ -1281,10 +1216,10 @@ void DataTreeCleanup::destroyData(sharab
     destroyData(&_pNode->info);
 
     if (aFlags & Flags::valueAvailable) 
-        freeData( allocator(), aValueType, _pNode->value );
+        freeData( aValueType, _pNode->value );
 
     if (aFlags & Flags::defaultAvailable) 
-        freeData( allocator(), aValueType, _pNode->defaultValue );
+        freeData( aValueType, _pNode->defaultValue );
     
 }
 //-----------------------------------------------------------------------------
Index: configmgr/source/tree/changes.cxx
===================================================================
RCS file: /cvs/util/configmgr/source/tree/changes.cxx,v
retrieving revision 1.19
retrieving revision 1.19.24.1
diff -u -p -u -p -r1.19 -r1.19.24.1
--- configmgr/source/tree/changes.cxx	16 Sep 2006 15:20:06 -0000	1.19
+++ configmgr/source/tree/changes.cxx	8 Jan 2007 20:48:59 -0000	1.19.24.1
@@ -259,7 +259,7 @@ AddNode::AddNode(TreeSegment const & _aA
 	:Change(_rName,_bToDefault)
 	,m_aOwnNewNode(_aAddedTree)
 	,m_aOwnOldNode()
-	,m_aInsertedTree()
+	,m_aInsertedTree(NULL)
 	,m_bReplacing(false)
 {
 }
@@ -288,7 +288,7 @@ std::auto_ptr<Change> AddNode::clone() c
 //--------------------------------------------------------------------------
 void AddNode::setInsertedAddress(data::TreeAddress const & _aInsertedTree)	
 {  
-    OSL_ENSURE( !m_aInsertedTree.is(), "AddNode already was applied - inserted a second time ?");
+    OSL_ENSURE( m_aInsertedTree == NULL, "AddNode already was applied - inserted a second time ?");
     m_aInsertedTree = _aInsertedTree;
 }
 //--------------------------------------------------------------------------
Index: configmgr/source/tree/cmtree.cxx
===================================================================
RCS file: /cvs/util/configmgr/source/tree/cmtree.cxx,v
retrieving revision 1.38
retrieving revision 1.38.14.3
diff -u -p -u -p -r1.38 -r1.38.14.3
--- configmgr/source/tree/cmtree.cxx	6 Nov 2006 14:49:54 -0000	1.38
+++ configmgr/source/tree/cmtree.cxx	6 Feb 2007 14:46:54 -0000	1.38.14.3
@@ -79,6 +79,7 @@
 #include <set>
 #define INCLUDED_SET
 #endif
+#include <algorithm>
 
 using namespace std;
 using namespace rtl;
@@ -89,24 +90,79 @@ namespace configmgr
 
 // ------------------------ ChildListSet implementations ------------------------
     ChildListSet::ChildListSet(ChildListSet const& aSet, treeop::DeepChildCopy)
+        : m_aChildList(0)
 	{
-		for(ChildList::iterator it = aSet.GetSet().begin();
-			it != aSet.GetSet().end();
-			++it)
+        for (size_t i = 0; i < aSet.m_aChildList.size(); i++)
         {
-            INode* pOrg = *it;
-            std::auto_ptr<INode> aCopy = pOrg->clone();
-			m_aChildList.insert(m_aChildList.end(), aCopy.release());
+			m_aChildList.insert(m_aChildList.end(),
+                                aSet.m_aChildList[i]->clone().release());
         }
 	}
 	ChildListSet::~ChildListSet()
 	{
-		for(ChildList::iterator it = m_aChildList.begin();
-			it != m_aChildList.end();
-			++it)
-			delete *it;
+        for (size_t i = 0; i < m_aChildList.size(); i++)
+            delete m_aChildList[i];
 	}
 
+	struct ltNode
+	{
+		bool operator()(const configmgr::INode* n1, const configmgr::INode* n2) const
+        {
+            return n1->getName().compareTo(n2->getName()) < 0;
+        }
+	};
+
+    ChildList::iterator ChildListSet::find(INode *pNode) const
+    {
+        ChildList &rList = const_cast<ChildList &>(m_aChildList);
+        std::pair<ChildList::iterator, ChildList::iterator> aRange;
+        ltNode aCompare;
+        aRange = equal_range(rList.begin(), rList.end(), pNode, aCompare);
+        if (aRange.second - aRange.first == 0)
+            return rList.end();
+        else
+            return aRange.first;
+    }
+    
+    // Keep the list sorted ...
+    std::pair<ChildList::iterator, bool> ChildListSet::insert(INode *pNode)
+    {
+        // Inserted records are (mostly) already in order
+        if (m_aChildList.size() > 0)
+        {
+            sal_Int32 nCmp = pNode->getName().compareTo(
+                m_aChildList.back()->getName());
+            if (nCmp == 0)
+            {
+                return std::pair<ChildList::iterator, bool>(m_aChildList.end(), false);
+            }
+            else if (nCmp < 0)
+            { 
+                ChildList::iterator aIns;
+                ltNode aCompare;
+                aIns = lower_bound(m_aChildList.begin(), m_aChildList.end(), pNode, aCompare);
+                if (aIns != m_aChildList.end() && pNode->getName().compareTo((*aIns)->getName()) == 0)
+                    return std::pair<ChildList::iterator, bool>(m_aChildList.end(), false);
+                return std::pair<ChildList::iterator, bool>(m_aChildList.insert(aIns, pNode), true);
+            }
+        }
+        // simple append - the common case.
+        return std::pair<ChildList::iterator, bool>(m_aChildList.insert(m_aChildList.end(), pNode), true);
+    }
+
+    INode *ChildListSet::erase(INode *pNode)
+    {
+        ChildList::iterator aIter = find(pNode);
+        
+        if (aIter != m_aChildList.end())
+        {
+            INode *pCopy = *aIter;
+            m_aChildList.erase(aIter);
+            return pCopy;
+        }
+        else
+            return NULL;
+    }
 
 // ---------------------------- Node implementation ----------------------------
 
@@ -246,30 +302,15 @@ namespace configmgr
 	{
 		SearchNode searchObj(aName);
 
-#if OSL_DEBUG_LEVEL > 1
-		for (ChildList::iterator it2 = m_aChildren.GetSet().begin();
-			it2 != m_aChildren.GetSet().end();
-			++it2)
-		{
-			INode* pINode = *it2;
-			OUString aName2 = pINode->getName();
-			volatile int dummy;
-            dummy = 0;
-		}
-#endif
-
-		ChildList::iterator it = m_aChildren.GetSet().find(&searchObj);
-		if (it == m_aChildren.GetSet().end())
-			return NULL;
-		else
-			return *it;
+        ChildList::iterator aIter = m_aChildren.find(&searchObj);
+        return aIter != m_aChildren.end() ? *aIter : NULL;
 	}
 
 	INode* Subtree::addChild(std::auto_ptr<INode> aNode)	// takes ownership
 	{
 		OUString aName = aNode->getName();
 		std::pair<ChildList::iterator, bool> aInserted =
-			m_aChildren.GetSet().insert(aNode.get());
+			m_aChildren.insert(aNode.get());
 		if (aInserted.second)
 			aNode.release();
 		return *aInserted.first;
@@ -278,30 +319,22 @@ namespace configmgr
 	::std::auto_ptr<INode> Subtree::removeChild(OUString const& aName)
 	{
 		SearchNode searchObj(aName);
-		ChildList::const_iterator it = m_aChildren.GetSet().find(&searchObj);
-
-		::std::auto_ptr<INode> aReturn;
-		if (m_aChildren.GetSet().end() != it)
-		{
-			aReturn = ::std::auto_ptr<INode>(*it);
-			m_aChildren.GetSet().erase(it);
-		}
-		return aReturn;
+        return ::std::auto_ptr<INode>(m_aChildren.erase(&searchObj));
 	}
 //  // -------------------------- ValueNode implementation --------------------------
 
 	void Subtree::forEachChild(NodeAction& anAction) const
     {
-		for(ChildList::const_iterator it = m_aChildren.GetSet().begin();
-			it != m_aChildren.GetSet().end();
+		for(ChildList::const_iterator it = m_aChildren.begin();
+			it != m_aChildren.end();
 			++it)
 			(**it).dispatch(anAction);
 	}
 
 	void Subtree::forEachChild(NodeModification& anAction)
     {
-		ChildList::iterator it = m_aChildren.GetSet().begin();
-		while( it != m_aChildren.GetSet().end() )
+		ChildList::iterator it = m_aChildren.begin();
+		while( it != m_aChildren.end() )
         {
             // modification-safe iteration
 			(**it++).dispatch(anAction);
Index: configmgr/source/tree/makefile.mk
===================================================================
RCS file: /cvs/util/configmgr/source/tree/makefile.mk,v
retrieving revision 1.11
retrieving revision 1.11.58.2
diff -u -p -u -p -r1.11 -r1.11.58.2
--- configmgr/source/tree/makefile.mk	8 Mar 2006 14:01:27 -0000	1.11
+++ configmgr/source/tree/makefile.mk	11 Jan 2007 10:35:34 -0000	1.11.58.2
@@ -57,10 +57,7 @@ SLOFILES=\
 	$(SLO)$/treesegment.obj		\
 	$(SLO)$/nodevisitor.obj		\
 	$(SLO)$/nodeaccess.obj		\
-	$(SLO)$/treeaccessor.obj	\
 	$(SLO)$/valuenodeaccess.obj	\
-	$(SLO)$/groupnodeaccess.obj	\
-	$(SLO)$/setnodeaccess.obj	\
 	$(SLO)$/changes.obj			\
 	$(SLO)$/treenodefactory.obj			\
 	$(SLO)$/treechangefactory.obj		\
Index: configmgr/source/tree/node.cxx
===================================================================
RCS file: /cvs/util/configmgr/source/tree/node.cxx,v
retrieving revision 1.10
retrieving revision 1.9.10.5
diff -u -p -u -p -r1.10 -r1.9.10.5
--- configmgr/source/tree/node.cxx	20 Dec 2006 18:44:50 -0000	1.10
+++ configmgr/source/tree/node.cxx	7 Feb 2007 12:00:33 -0000	1.9.10.5
@@ -45,12 +45,6 @@
 #ifndef INCLUDED_SHARABLE_TREEFRAGMENT_HXX
 #include "treefragment.hxx"
 #endif
-#ifndef CONFIGMGR_ACCESSOR_HXX
-#include "accessor.hxx"
-#endif
-#ifndef CONFIGMGR_UPDATEACCESSOR_HXX
-#include "updateaccessor.hxx"
-#endif
 
 #ifndef CONFIGMGR_CONFIGURATION_ATTRIBUTES_HXX_
 #include "attributes.hxx"
@@ -226,82 +220,55 @@ struct SetNodeTemplateData 
 };
 //-----------------------------------------------------------------------------
 static inline
-SetNodeTemplateData * readTemplateData(memory::Allocator const & _anAllocator, Address _aTemplateData)
-{
-    return static_cast<SetNodeTemplateData *>( _anAllocator.access(_aTemplateData) );
-}
-//-----------------------------------------------------------------------------
-static inline
-SetNodeTemplateData const * readTemplateData(memory::Accessor const & _anAccessor, Address _aTemplateData)
+SetNodeTemplateData * readTemplateData(SetElementAddress _aTemplateData)
 {
-    return static_cast<SetNodeTemplateData const*>( _anAccessor.access(memory::Pointer(_aTemplateData)) );
+    return reinterpret_cast<SetNodeTemplateData *>( _aTemplateData );
 }
 //-----------------------------------------------------------------------------
 
-Address SetNode::allocTemplateData(memory::Allocator const & _anAllocator,
-								   const rtl::OUString &rName,
+SetElementAddress SetNode::allocTemplateData(const rtl::OUString &rName,
 								   const rtl::OUString &rModule)
 {
-    Address aData = _anAllocator.allocate(sizeof(SetNodeTemplateData));
+    SetNodeTemplateData * pData = new SetNodeTemplateData();
 
-    if (aData)
-    {
-        SetNodeTemplateData * pData = readTemplateData(_anAllocator,aData);
-
-        OSL_ENSURE(pData, "Creating template data: unexpected NULL data");
+    OSL_ENSURE(pData, "Creating template data: unexpected NULL data");
     
-        pData->name   = allocName(rName);
-        pData->module = allocName(rModule);
-    }
-    return aData;
+    pData->name   = allocName(rName);
+    pData->module = allocName(rModule);
+
+    return reinterpret_cast<SetElementAddress>( pData );
 }
 
-Address SetNode::copyTemplateData(memory::Allocator const & _anAllocator, 
-								  Address _aTemplateData)
+SetElementAddress SetNode::copyTemplateData(SetElementAddress _aTemplateData)
 {
-    SetNodeTemplateData const * pData = readTemplateData(_anAllocator,_aTemplateData);
+    SetNodeTemplateData const * pData = readTemplateData(_aTemplateData);
 
     OSL_ENSURE(pData, "Copying template data: unexpected NULL data");
 
-    return allocTemplateData(_anAllocator, readName(pData->name),
-							 readName(pData->module));
+    return allocTemplateData(readName(pData->name), readName(pData->module));
 }
 
 //-----------------------------------------------------------------------------
 
-void SetNode::releaseTemplateData(memory::Allocator const & _anAllocator, Address _aTemplateData)
+void SetNode::releaseTemplateData(SetElementAddress _aTemplateData)
 {
     if (!_aTemplateData) return;
 
-    SetNodeTemplateData const * pData = readTemplateData(_anAllocator,_aTemplateData);
+    SetNodeTemplateData const * pData = readTemplateData(_aTemplateData);
 
     OSL_ENSURE(pData, "Freeing template data: unexpected NULL data");
     
     freeName(pData->name);
     freeName(pData->module);
 
-    _anAllocator.deallocate(_aTemplateData);
-}
-
-rtl::OUString SetNode::getTemplateDataName(memory::Accessor const & _anAccessor,
-										   Address _aTemplateData)
-{
-    SetNodeTemplateData const * pData = readTemplateData(_anAccessor,_aTemplateData);
-	return pData->name;
-}
-
-rtl::OUString SetNode::getTemplateDataModule(memory::Accessor const & _anAccessor,
-											 Address _aTemplateData)
-{
-    SetNodeTemplateData const * pData = readTemplateData(_anAccessor,_aTemplateData);
-	return pData->module;
+    delete pData;
 }
 
 //-----------------------------------------------------------------------------
 
-rtl::OUString SetNode::getElementTemplateName(memory::Accessor const & _anAccessor)   const
+rtl::OUString SetNode::getElementTemplateName() const
 {
-    SetNodeTemplateData const * pData = readTemplateData(_anAccessor,this->elementType);
+    SetNodeTemplateData const * pData = readTemplateData(this->elementType);
 
     OSL_ENSURE(pData, "ERROR: No template data found for set");
     
@@ -309,9 +276,9 @@ rtl::OUString SetNode::getElementTemplat
 }
 //-----------------------------------------------------------------------------
 
-rtl::OUString SetNode::getElementTemplateModule(memory::Accessor const & _anAccessor) const
+rtl::OUString SetNode::getElementTemplateModule() const
 {
-    SetNodeTemplateData const * pData = readTemplateData(_anAccessor,this->elementType);
+    SetNodeTemplateData const * pData = readTemplateData(this->elementType);
 
     OSL_ENSURE(pData, "ERROR: No template data found for set");
     
@@ -320,25 +287,25 @@ rtl::OUString SetNode::getElementTemplat
 //-----------------------------------------------------------------------------
 
 static inline
-TreeFragment const * implGetFragmentFromList(memory::Accessor const & _anAccessor, List _aListEntry)
+TreeFragment const * implGetFragmentFromList(List _aListEntry)
 {
-    return static_cast<TreeFragment const *>(_anAccessor.access(memory::Pointer(_aListEntry)));
+    return reinterpret_cast<TreeFragment const *>(_aListEntry);
 }
 //-----------------------------------------------------------------------------
 
-TreeFragment const  * SetNode::getFirstElement(memory::Accessor const & _anAccessor) const   
+TreeFragment const  * SetNode::getFirstElement() const   
 {
-    return implGetFragmentFromList(_anAccessor, this->elements);
+    return implGetFragmentFromList(this->elements);
 }
 //-----------------------------------------------------------------------------
 
-TreeFragment const  * SetNode::getNextElement(memory::Accessor const & _anAccessor, TreeFragment const * _pElement) const    
+TreeFragment const  * SetNode::getNextElement(TreeFragment const * _pElement) const    
 {
     OSL_PRECOND(_pElement, "getNextElement: previous element must not be NULL");
-    OSL_PRECOND(_pElement->header.parent == _anAccessor.address(this).value(), 
+    OSL_PRECOND(_pElement->header.parent == (Node *)this, 
                 "getNextElement: not an element of this node");
 
-    return implGetFragmentFromList(_anAccessor, _pElement->header.next);
+    return implGetFragmentFromList(_pElement->header.next);
 }
 //-----------------------------------------------------------------------------
 
@@ -367,7 +334,7 @@ bool ValueNode::hasUsableDefault() const
 }
 //-----------------------------------------------------------------------------
 	
-uno::Type   ValueNode::getValueType()  const
+uno::Type ValueNode::getValueType() const
 {
     AnyData::TypeCode aType = AnyData::TypeCode( info.type & Type::mask_valuetype );
 
@@ -375,36 +342,36 @@ uno::Type   ValueNode::getValueType()  c
 }
 //-----------------------------------------------------------------------------
 
-uno::Any    ValueNode::getValue(memory::Accessor const & _aAccessor)      const
+uno::Any ValueNode::getValue() const
 {
     if (info.flags & Flags::defaulted) 
-        return getDefaultValue(_aAccessor);
+        return getDefaultValue();
 
     else
-        return getUserValue(_aAccessor);
+        return getUserValue();
 }
 //-----------------------------------------------------------------------------
 
-uno::Any    ValueNode::getUserValue(memory::Accessor const & _aAccessor)      const
+uno::Any ValueNode::getUserValue() const
 {
     if (info.flags & Flags::valueAvailable)
     {
         AnyData::TypeCode aType = AnyData::TypeCode( info.type & Type::mask_valuetype );
 
-        return readData(_aAccessor,aType,this->value);
+        return readData(aType,this->value);
     }
     else
         return uno::Any();
 }
 //-----------------------------------------------------------------------------
 
-uno::Any    ValueNode::getDefaultValue(memory::Accessor const & _aAccessor)    const
+uno::Any ValueNode::getDefaultValue() const
 {
     if (info.flags & Flags::defaultAvailable)
     {
         AnyData::TypeCode aType = AnyData::TypeCode( info.type & Type::mask_valuetype );
 
-        return readData(_aAccessor,aType,this->defaultValue);
+        return readData(aType,this->defaultValue);
     }
     else
         return uno::Any();
@@ -413,7 +380,18 @@ uno::Any    ValueNode::getDefaultValue(m
 
 bool Node::isNamed(rtl::OUString const & _aName) const
 {
-    return _aName == readName(node.info.name);
+    rtl_uString *pCmpData = _aName.pData;
+    rtl_uString *pNodeData = node.info.name;
+
+    // Creating an OUString does rather expensive interlocking here.
+    if (pCmpData == pNodeData)
+        return true;
+    if (pCmpData->length != pNodeData->length)
+        return false;
+    return !rtl_ustr_compare_WithLength( pCmpData->buffer,
+                                         pCmpData->length,
+                                         pNodeData->buffer,
+                                         pNodeData->length);
 }
 //-----------------------------------------------------------------------------
 
@@ -446,57 +424,7 @@ bool Node::isLocalized() const
 {
     return node.info.isLocalized();
 }
-//-----------------------------------------------------------------------------
-
-bool Node::isGroup()  const
-{
-    return (node.info.type & Type::mask_nodetype) == Type::nodetype_group;
-}
-//-----------------------------------------------------------------------------
-
-bool Node::isSet()    const
-{
-    return (node.info.type & Type::mask_nodetype) == Type::nodetype_set;
-}
-//-----------------------------------------------------------------------------
-
-bool Node::isValue()  const
-{
-    return (node.info.type & Type::mask_nodetype) == Type::nodetype_value;
-}
-//-----------------------------------------------------------------------------
-
-GroupNode       * Node::groupData()
-{ 
-    return isGroup() ? &this->group : NULL;
-}
-//-----------------------------------------------------------------------------
-
-GroupNode const * Node::groupData() const
-{ 
-    return isGroup() ? &this->group : NULL;
-}
-//-----------------------------------------------------------------------------
 
-SetNode         * Node::setData()
-{ 
-    return isSet() ? &this->set : NULL;
-}
-//-----------------------------------------------------------------------------
-SetNode   const * Node::setData()   const
-{ 
-    return isSet() ? &this->set : NULL;
-}
-//-----------------------------------------------------------------------------
-ValueNode       * Node::valueData()
-{ 
-    return isValue() ? &this->value : NULL;
-}
-//-----------------------------------------------------------------------------
-ValueNode const * Node::valueData() const
-{ 
-    return isValue() ? &this->value : NULL;
-}
 //-----------------------------------------------------------------------------
 
 bool Node::isFragmentRoot() const
Index: configmgr/source/tree/nodeaccess.cxx
===================================================================
RCS file: /cvs/util/configmgr/source/tree/nodeaccess.cxx,v
retrieving revision 1.4
retrieving revision 1.4.24.2
diff -u -p -u -p -r1.4 -r1.4.24.2
--- configmgr/source/tree/nodeaccess.cxx	16 Sep 2006 15:21:45 -0000	1.4
+++ configmgr/source/tree/nodeaccess.cxx	11 Jan 2007 10:35:34 -0000	1.4.24.2
@@ -38,10 +38,6 @@
 
 #include "nodeaccess.hxx"
 
-#ifndef CONFIGMGR_UPDATEACCESSOR_HXX
-#include "updateaccessor.hxx"
-#endif
-
 #ifndef CONFIGMGR_TREEACCESSOR_HXX
 #include "treeaccessor.hxx"
 #endif
@@ -66,88 +62,138 @@ namespace configmgr
 // -----------------------------------------------------------------------------	
     namespace data
     {
-    // -------------------------------------------------------------------------
-        
-        NodeAddress::DataType* NodeAccess::access(NodeAddressType const& _aNodeRef, memory::UpdateAccessor& _rUpdateAccess)
-        { 
-            return static_cast<NodeAddress::DataType*>(_rUpdateAccess.access(_aNodeRef.m_pData)); 
-        }
-    // -------------------------------------------------------------------------
+        // -------------------------------------------------------------------------
 
-        NodeAccess getSubnode(NodeAccessRef const & _aParent, NodeAccess::Name const & _aName)
+        NodeAccess getSubnode(NodeAccess const & _aParent, configuration::Name const & _aName)
         {
             if (GroupNodeAccess::isInstance(_aParent))
             {
-                return GroupNodeAccess(_aParent).getChildNode(_aName).toNodeAccess();
+                return GroupNodeAccess(_aParent).getChildNode(_aName);
             }
             else if (SetNodeAccess::isInstance(_aParent))
             {
                 TreeAccessor aElement = SetNodeAccess(_aParent).getElementTree(_aName);
-                return aElement.isValid() ? aElement.getRootNode().toNodeAccess() : NodeAccess::emptyNode();
+                return aElement != NULL ? aElement.getRootNode() : NodeAccess(NULL);
             }
             else 
             {
                 OSL_ENSURE( ValueNodeAccess::isInstance(_aParent),"ERROR: Unknown node type");
                 OSL_ENSURE(!ValueNodeAccess::isInstance(_aParent),"ERROR: Trying to access child of value node");
-                return NodeAccess::emptyNode();
+                return NULL;
             }
         }
-    // -------------------------------------------------------------------------
-
-        NodeAddress getSubnodeAddress(memory::Accessor const& _aAccess, NodeAddress const & _aNodeAddress, NodeAccess::Name const & _aName)
-        {
-            return getSubnode( NodeAccessRef(&_aAccess,_aNodeAddress), _aName ).address();
-        }
-    // -------------------------------------------------------------------------
+        // -------------------------------------------------------------------------
 
-        NodeAddress getSubnodeAddress(memory::UpdateAccessor& _aAccess, NodeAddress const & _aNodeAddress, NodeAccess::Name const & _aName)
+        NodeAddress getSubnodeAddress(NodeAddress const & _aNodeAddress, configuration::Name const & _aName)
         {
-            memory::Accessor aAccess = _aAccess.accessor();
-            return getSubnode( NodeAccessRef(&aAccess,_aNodeAddress), _aName ).address();
+            return getSubnode( NodeAccess(_aNodeAddress), _aName );
         }
-    // -------------------------------------------------------------------------
-    
-        SetNodeAddress toSetNodeAddress(memory::Accessor const & _aAccess, NodeAddress const & _aNodeAddr)
+        // -------------------------------------------------------------------------
+     
+        SetNodeAddress toSetNodeAddress(NodeAddress const & _aNodeAddr)
         {
-            SetNodeAccess aNodeAccess( NodeAccessRef(&_aAccess,_aNodeAddr) );
-            return aNodeAccess.address();
+            SetNodeAccess aNodeAccess(_aNodeAddr);
+            return aNodeAccess;
         }
-    // -------------------------------------------------------------------------
-     
-        SetNodeAddress toSetNodeAddress(memory::UpdateAccessor & _aAccess, NodeAddress const & _aNodeAddr)
+        // -------------------------------------------------------------------------
+
+        GroupNodeAddress toGroupNodeAddress(NodeAddress const & _aNodeAddr)
         {
-            SetNodeAccess aNodeAccess( NodeAccess(_aAccess.accessor(),_aNodeAddr) );
-            return aNodeAccess.address();
+            GroupNodeAccess aNodeAccess( _aNodeAddr );
+            return aNodeAccess;
         }
-    // -------------------------------------------------------------------------
 
-        GroupNodeAddress toGroupNodeAddress(memory::Accessor const & _aAccess, NodeAddress const & _aNodeAddr)
+        // -------------------------------------------------------------------------
+        // GroupNodeAccess ...
+        // -------------------------------------------------------------------------
+
+        NodeAddress GroupNodeAccess::implGetChild(configuration::Name const& _aName) const
         {
-            GroupNodeAccess aNodeAccess( NodeAccess(_aAccess,_aNodeAddr) );
-            return aNodeAccess.address();
+            using namespace sharable;
+            rtl::OUString aNodeName = _aName.toString();
+
+            GroupNode const  & aNode = data();
+            for (Node const * pChild = aNode.getFirstChild();
+                              pChild != NULL;
+                              pChild = aNode.getNextChild(pChild))
+            {
+                if (pChild->isNamed(aNodeName))
+                {
+                    NodeAccess aChildNode(pChild);
+                    return aChildNode;
+                }            
+            }
+            return NodeAddress();
         }
-    // -------------------------------------------------------------------------
 
-        GroupNodeAddress toGroupNodeAddress(memory::UpdateAccessor & _aAccess, NodeAddress const & _aNodeAddr)
+        // -------------------------------------------------------------------------
+        // SetNodeAccess ...
+        // -------------------------------------------------------------------------
+
+        TreeAddress SetNodeAccess::implGetElement(configuration::Name const& _aName) const
         {
-            GroupNodeAccess aNodeAccess( NodeAccess(_aAccess.accessor(),_aNodeAddr) );
-            return aNodeAccess.address();
+            using namespace sharable;
+            SetNode const  & aNode = data();
+            for (TreeFragment const * pElement = aNode.getFirstElement();
+                 pElement  != NULL;
+                 pElement  = aNode.getNextElement(pElement))
+            {
+                if (pElement->isNamed(_aName.toString()))
+                    return (TreeAddress)pElement;
+            }
+            return NULL;
         }
-    // -------------------------------------------------------------------------
+    // -------------------------------------------------------------------------*/
         
-        ValueNodeAddress toValueNodeAddress(memory::Accessor const & _aAccess, NodeAddress const & _aNodeAddr)
+        void SetNodeAccess::addElement(SetNodeAddress _aSetAddress,
+				       ElementAddress _aNewElement)
         {
-            ValueNodeAccess aNodeAccess( NodeAccess(_aAccess,_aNodeAddr) );
-            return aNodeAccess.address();
+            using namespace sharable;
+
+            SetNode * pNode = _aSetAddress;
+            OSL_ENSURE(pNode, "ERROR: Trying to add an element to a NULL set node");
+
+            // To do (?): insert sorted - find location here
+            TreeFragment * pElement = _aNewElement;
+            OSL_ENSURE(pElement, "ERROR: Trying to add a NULL element to a set node");
+
+            pElement->header.next   = pNode->elements;
+            pElement->header.parent = reinterpret_cast<Node *>(pNode);
+
+            pNode->elements = _aNewElement;
         }
-    // -------------------------------------------------------------------------
+    // -------------------------------------------------------------------------*/
         
-        ValueNodeAddress toValueNodeAddress(memory::UpdateAccessor & _aAccess, NodeAddress const & _aNodeAddr)
+        TreeAddress SetNodeAccess::removeElement(SetNodeAddress _aSetAddress,
+						 configuration::Name const & _aName)
         {
-            ValueNodeAccess aNodeAccess( NodeAccess(_aAccess.accessor(),_aNodeAddr) );
-            return aNodeAccess.address();
+            using namespace sharable;
+            
+            SetNode * pNode = _aSetAddress;
+            OSL_ENSURE(pNode, "ERROR: Trying to add an element to a NULL set node");
+
+            TreeAddress aRemoved = NULL;
+            
+            List * pLink = & pNode->elements;
+            while( TreeFragment * pElement = reinterpret_cast<TreeFragment *>(*pLink) )
+            {
+                if (pElement->isNamed(_aName.toString()))
+                {
+                    aRemoved = *pLink;
+
+                    *pLink = pElement->header.next;
+                    pElement->header.next   = 0;
+                    pElement->header.parent = 0;
+
+                    break;
+                }
+
+                pLink = & pElement->header.next;
+            }
+
+            return aRemoved;
         }
-    // -------------------------------------------------------------------------
+
     }
 // -----------------------------------------------------------------------------	
 } // namespace configmgr
Index: configmgr/source/tree/nodevisitor.cxx
===================================================================
RCS file: /cvs/util/configmgr/source/tree/nodevisitor.cxx,v
retrieving revision 1.6
retrieving revision 1.6.24.2
diff -u -p -u -p -r1.6 -r1.6.24.2
--- configmgr/source/tree/nodevisitor.cxx	16 Sep 2006 15:22:12 -0000	1.6
+++ configmgr/source/tree/nodevisitor.cxx	11 Jan 2007 10:35:34 -0000	1.6.24.2
@@ -77,14 +77,12 @@ typedef NodeVisitor::Result Result;
     struct NodeVisitor::Dispatcher
     {
         NodeVisitor& m_target;
-        Accessor const & m_accessor;
         Result       m_result;
 
-        Dispatcher(NodeVisitor& _rTarget, Accessor const * _pAccessor)
-        : m_target(_rTarget)
-        , m_accessor(*_pAccessor)
-        , m_result(NodeVisitor::CONTINUE)
-        {}
+	Dispatcher(NodeVisitor& _rTarget)
+	    : m_target(_rTarget)
+	    , m_result(NodeVisitor::CONTINUE)
+            {}
 
         void applyToNode(sharable::Node const & _aNode);
         void applyToChildren(sharable::GroupNode const & _aNode);
@@ -96,19 +94,17 @@ typedef NodeVisitor::Result Result;
     struct SetVisitor::Dispatcher
     {
         SetVisitor&  m_target;
-        Accessor const & m_accessor;
         Result       m_result;
 
-        Dispatcher(SetVisitor& _rTarget, Accessor const * _pAccessor)
+        Dispatcher(SetVisitor& _rTarget)
         : m_target(_rTarget)
-        , m_accessor(*_pAccessor)
         , m_result(NodeVisitor::CONTINUE)
         {}
 
         void applyToTree(sharable::TreeFragment const & _aElement);
         void applyToElements(sharable::SetNode const & _aNode);
 
-	    Result dispatch(sharable::TreeFragment const& _aElement);
+	Result dispatch(sharable::TreeFragment const & _aElement);
     };
 
     // -------------------------------------------------------------------------
@@ -120,17 +116,17 @@ typedef NodeVisitor::Result Result;
         switch (_aNode.node.info.type & mask_nodetype)
         {
         case nodetype_value:
-            return m_target.handle( ValueNodeAccess(m_accessor, &_aNode.value) );
+            return m_target.handle( ValueNodeAccess(&_aNode.value) );
 
         case nodetype_group:
-            return m_target.handle( GroupNodeAccess(m_accessor, &_aNode.group) );
+            return m_target.handle( GroupNodeAccess(&_aNode.group) );
 
         case nodetype_set:
-            return m_target.handle( SetNodeAccess(m_accessor, &_aNode.set) );
+            return m_target.handle( SetNodeAccess(&_aNode.set) );
 
         default:
             OSL_ENSURE(false,"NodeVisitor: invalid node type detected"); // invalid node
-            return m_target.handle( NodeAccessRef(&m_accessor, &_aNode) );
+            return m_target.handle( NodeAccess(&_aNode) );
         }
     }
     // -------------------------------------------------------------------------
@@ -138,7 +134,8 @@ typedef NodeVisitor::Result Result;
     inline
     Result SetVisitor::Dispatcher::dispatch(sharable::TreeFragment const& _aElement)
     {
-        return m_target.handle( TreeAccessor(m_accessor, &_aElement) );
+        return m_target.handle
+	  (TreeAccessor((sharable::TreeFragment *)(& _aElement )));
     }
     // -------------------------------------------------------------------------
 
@@ -169,20 +166,20 @@ typedef NodeVisitor::Result Result;
     void SetVisitor::Dispatcher::applyToElements(sharable::SetNode const & _aNode)
     {
         using sharable::TreeFragment;
-        for (TreeFragment const * pElement = _aNode.getFirstElement(m_accessor);
+        for (TreeFragment const * pElement = _aNode.getFirstElement();
                 pElement != NULL && m_result != NodeVisitor::DONE;
-                pElement = _aNode.getNextElement(m_accessor,pElement) )
+                pElement = _aNode.getNextElement(pElement) )
             m_result = dispatch(*pElement);
 
     }
     // -------------------------------------------------------------------------
 // -------------------------------------------------------------------------
 
-Result NodeVisitor::visitNode(NodeAccessRef const& _aNode)
+Result NodeVisitor::visitNode(NodeAccess const& _aNode)
 {
-    Dispatcher aDispatcher(*this, &_aNode.accessor());
+    Dispatcher aDispatcher(*this);
 
-    aDispatcher.applyToNode(_aNode.data());
+    aDispatcher.applyToNode(*static_cast<configmgr::sharable::Node *>(_aNode));
 
     return aDispatcher.m_result;
 }
@@ -190,9 +187,9 @@ Result NodeVisitor::visitNode(NodeAccess
 
 Result SetVisitor::visitTree(TreeAccessor const& _aNode)
 {
-    Dispatcher aDispatcher(*this, &_aNode.accessor());
+    Dispatcher aDispatcher(*this);
 
-    aDispatcher.applyToTree(_aNode.data());
+    aDispatcher.applyToTree(*_aNode);
 
     return aDispatcher.m_result;
 }
@@ -200,7 +197,7 @@ Result SetVisitor::visitTree(TreeAccesso
 
 Result NodeVisitor::visitChildren(GroupNodeAccess const& _aNode)
 {
-    Dispatcher aDispatcher(*this, &_aNode.accessor());
+    Dispatcher aDispatcher(*this);
 
     aDispatcher.applyToChildren(_aNode.data());
 
@@ -210,7 +207,7 @@ Result NodeVisitor::visitChildren(GroupN
 
 Result SetVisitor::visitElements(SetNodeAccess const& _aNode)
 {
-    Dispatcher aDispatcher(*this, &_aNode.accessor());
+    Dispatcher aDispatcher(*this);
 
     aDispatcher.applyToElements(_aNode.data());
 
@@ -218,7 +215,7 @@ Result SetVisitor::visitElements(SetNode
 }
 // -------------------------------------------------------------------------
 
-Result NodeVisitor::handle(NodeAccessRef const& /*_aNode*/)
+Result NodeVisitor::handle(NodeAccess const& /*_aNode*/)
 {
     return CONTINUE;
 }
@@ -226,19 +223,19 @@ Result NodeVisitor::handle(NodeAccessRef
 
 Result NodeVisitor::handle(ValueNodeAccess const& _aNode)
 {
-    return handle(static_cast<NodeAccessRef>(_aNode));
+    return handle(NodeAccess(_aNode));
 }
 // -------------------------------------------------------------------------
 
 Result NodeVisitor::handle(GroupNodeAccess const& _aNode)
 {
-    return handle(static_cast<NodeAccessRef>(_aNode));
+    return handle(NodeAccess(_aNode));
 }
 // -------------------------------------------------------------------------
 
 Result NodeVisitor::handle(SetNodeAccess const& _aNode)
 {
-    return handle(static_cast<NodeAccessRef>(_aNode));
+    return handle(NodeAccess(static_cast<const sharable::Node *>(_aNode)));
 }
 // -------------------------------------------------------------------------
 
Index: configmgr/source/tree/subtree.hxx
===================================================================
RCS file: /cvs/util/configmgr/source/tree/subtree.hxx,v
retrieving revision 1.7
retrieving revision 1.7.42.2
diff -u -p -u -p -r1.7 -r1.7.42.2
--- configmgr/source/tree/subtree.hxx	19 Jun 2006 23:30:16 -0000	1.7
+++ configmgr/source/tree/subtree.hxx	6 Feb 2007 14:46:55 -0000	1.7.42.2
@@ -44,22 +44,12 @@
 
 #include <memory>
 #include <set>
+#include <vector>
 
 namespace configmgr
 {
-
-// ---------------------------------- STL set ----------------------------------
-	struct ltNode
-	{
-		bool operator()(const configmgr::INode* n1, const configmgr::INode* n2) const
-			{
-				// return strcmp(n1->GetName(), n2->GetName()) < 0;
-				return (n1->getName().compareTo(n2->getName()) < 0) ? 1 : 0;
-			}
-	};
-	
-	
-	typedef std::set<INode*, ltNode> ChildList;
+    // List sorted by name for binary search
+    typedef std::vector< INode* > ChildList;
 	
 	class ChildListSet {
 		ChildList m_aChildList;
@@ -67,10 +57,13 @@ namespace configmgr
 		ChildListSet(ChildListSet const&);
         ChildListSet& operator=(ChildListSet const& aSet);
 	public:
-		ChildList& GetSet() {return m_aChildList;}
-		ChildList const& GetSet() const {return m_aChildList;}
+        ChildList::iterator begin() const { return const_cast<configmgr::INode **>(m_aChildList.begin()); }
+        ChildList::iterator end()   const { return const_cast<configmgr::INode **>(m_aChildList.end()); }
+        INode *erase(INode *pNode);
+        ChildList::iterator find(INode *pNode) const;
+        std::pair<ChildList::iterator, bool> insert(INode *aInsert);
 
-		ChildListSet() {}
+		ChildListSet() : m_aChildList(0) {}
         ChildListSet(ChildListSet const&, treeop::DeepChildCopy);
 		~ChildListSet();
 	};	
@@ -78,8 +71,7 @@ namespace configmgr
 // Inner Node
 	class Subtree : public ISubtree
 	{
-		//	set<Node*> children;
-		ChildListSet		m_aChildren;		
+		ChildListSet   m_aChildren;		
 		virtual INode* doGetChild(OUString const& name) const;
 
 	public:		
Index: configmgr/source/tree/treefragment.cxx
===================================================================
RCS file: /cvs/util/configmgr/source/tree/treefragment.cxx,v
retrieving revision 1.6
retrieving revision 1.6.14.2
diff -u -p -u -p -r1.6 -r1.6.14.2
--- configmgr/source/tree/treefragment.cxx	6 Nov 2006 14:51:00 -0000	1.6
+++ configmgr/source/tree/treefragment.cxx	5 Feb 2007 15:21:45 -0000	1.6.14.2
@@ -46,6 +46,9 @@
 #include <rtl/ustring.hxx>
 #endif
 
+// memset
+#include <string.h>
+
 namespace configmgr
 {
 //-----------------------------------------------------------------------------
@@ -125,6 +128,19 @@ configmgr::node::Attributes TreeFragment
     aResult.setLocalized ( !!(aRootNodeInfo.flags & Flags::localized));
 
     return aResult;
+}
+
+TreeFragment *TreeFragment::allocate(sal_uInt32 nFragments)
+{
+    sal_uInt32 nSize = sizeof(TreeFragment) + sizeof(Node) * (nFragments-1);
+    sal_uInt8 *pMem = new sal_uInt8 [nSize];
+    memset (pMem, 0, nSize);
+    return reinterpret_cast<TreeFragment *>(pMem);
+}
+
+void TreeFragment::free_shallow(TreeFragment *pFragment )
+{
+    delete[] (sal_uInt8 *) pFragment;
 }
 
 //-----------------------------------------------------------------------------
Index: configmgr/source/tree/treesegment.cxx
===================================================================
RCS file: /cvs/util/configmgr/source/tree/treesegment.cxx,v
retrieving revision 1.6
retrieving revision 1.6.14.7
diff -u -p -u -p -r1.6 -r1.6.14.7
--- configmgr/source/tree/treesegment.cxx	6 Nov 2006 14:51:12 -0000	1.6
+++ configmgr/source/tree/treesegment.cxx	21 Feb 2007 12:49:03 -0000	1.6.14.7
@@ -41,25 +41,13 @@
 #ifndef CONFIGMGR_BUILDDATA_HXX
 #include "builddata.hxx"
 #endif
-#ifndef CONFIGMGR_SEGMENT_HXX
-#include "segment.hxx"
-#endif
-#ifndef CONFIGMGR_HEAPFACTORY_HXX
-#include "heapfactory.hxx"
-#endif
-#ifndef CONFIGMGR_ACCESSOR_HXX
-#include "accessor.hxx"
-#endif
-#ifndef CONFIGMGR_UPDATEACCESSOR_HXX
-#include "updateaccessor.hxx"
-#endif
 #ifndef CONFIGMGR_TREEACCESSOR_HXX
 #include "treeaccessor.hxx"
 #endif
-
-#ifndef _SALHELPER_SIMPLEREFERENCEOBJECT_HXX_
-#include <salhelper/simplereferenceobject.hxx>
+#ifndef CONFIGMGR_UTILITY_HXX_
+#include "utility.hxx"
 #endif
+
 #ifndef _OSL_DIAGNOSE_H_
 #include <osl/diagnose.h>
 #endif
@@ -72,23 +60,13 @@ namespace configmgr
     namespace data
     {
 // -----------------------------------------------------------------------------	
-
-//        typedef std::auto_ptr<INode> RawTreeData;
-//        typedef configuration::Name  Name;
-        using memory::Pointer;
-
-// -----------------------------------------------------------------------------	
-// -----------------------------------------------------------------------------	
-struct TreeSegment::Impl : salhelper::SimpleReferenceObject
+struct TreeSegment::Impl : configmgr::SimpleReferenceObject
 {
-    Impl() : data( memory::localHeap() ), base() {}
+    Impl() : base() {}
     ~Impl();
 
-    memory::Segment     data;
     data::TreeAddress   base;
 };
-// -----------------------------------------------------------------------------	
-// -----------------------------------------------------------------------------	
 
 // -----------------------------------------------------------------------------	
 TreeSegment::TreeSegment()
@@ -127,32 +105,17 @@ void TreeSegment::clear()
 }
 
 // -----------------------------------------------------------------------------	
-memory::Segment * TreeSegment::getSegment() const
-{
-    return is() ? &m_pImpl->data : 0;
-}
-
-// -----------------------------------------------------------------------------	
-memory::Accessor  TreeSegment::getAccessor() const
+TreeAccessor TreeSegment::getTreeAccess() const
 {
-    return memory::Accessor(getSegment());
-}
-
-// -----------------------------------------------------------------------------	
-TreeAccessor    TreeSegment::getTreeAccess() const
-{
-    return TreeAccessor( getAccessor(), getTreeData() );
+    return TreeAccessor(getTreeData());
 }
 
 // -----------------------------------------------------------------------------	
 // -----------------------------------------------------------------------------	
 TreeSegment::Impl::~Impl()
 {   
-    if (base.is())
-    {
-        memory::UpdateAccessor aAccess( & this->data );
-        destroyTree(aAccess,base);
-    }
+    if (base != NULL)
+        destroyTree(base);
 }
 
 // -----------------------------------------------------------------------------	
@@ -162,11 +125,9 @@ TreeSegment::Impl* TreeSegment::createNe
 
     std::auto_ptr<Impl> aNewImpl( new Impl );
 
-    memory::UpdateAccessor aNewAccess( & aNewImpl->data );
-
-    aNewImpl->base = buildElementTree(aNewAccess,*_aTree,_aTypeName,false); // no defaults for set element trees
+    aNewImpl->base = buildElementTree(*_aTree,_aTypeName,false); // no defaults for set element trees
 
-    if (!aNewImpl->base.is()) aNewImpl.reset();
+    if (aNewImpl->base == NULL) aNewImpl.reset();
 
     return aNewImpl.release();
 }
@@ -178,11 +139,9 @@ TreeSegment::Impl* TreeSegment::createNe
 
     std::auto_ptr<Impl> aNewImpl( new Impl );
 
-    memory::UpdateAccessor aNewAccess( & aNewImpl->data );
+    aNewImpl->base = buildTree(_aTreeName,*_aTree,false); // no defaults for set element trees
 
-    aNewImpl->base = buildTree(aNewAccess,_aTreeName,*_aTree,false); // no defaults for set element trees
-
-    if (!aNewImpl->base.is()) aNewImpl.reset();
+    if (aNewImpl->base == NULL) aNewImpl.reset();
 
     return aNewImpl.release();
 }
@@ -191,15 +150,13 @@ TreeSegment::Impl* TreeSegment::createNe
 // -----------------------------------------------------------------------------	
 TreeSegment::Impl* TreeSegment::createNewSegment(TreeAccessor const & _aTree)
 {
-    if (!_aTree.isValid()) return NULL;
+    if (_aTree == NULL) return NULL;
 
     std::auto_ptr<Impl> aNewImpl( new Impl );
 
-    memory::UpdateAccessor aNewAccess( & aNewImpl->data );
-
-    aNewImpl->base = _aTree.copyTree(aNewAccess);
+    aNewImpl->base = _aTree.copyTree();
 
-    if (!aNewImpl->base.is()) aNewImpl.reset();
+    if (aNewImpl->base == NULL) aNewImpl.reset();
 
     return aNewImpl.release();
 }
@@ -207,7 +164,7 @@ TreeSegment::Impl* TreeSegment::createNe
 // -----------------------------------------------------------------------------	
 TreeSegment::RawTreeData TreeSegment::cloneData(bool _bUseTreeName) const
 {
-    return convertTree( this->getTreeAccess(), _bUseTreeName );
+    return convertTree(this->getTreeAccess(),_bUseTreeName);
 }
 
 // -----------------------------------------------------------------------------	
@@ -221,7 +178,7 @@ TreeSegment TreeSegment::cloneSegment() 
 // -----------------------------------------------------------------------------	
 bool TreeSegment::is() const
 {
-    return hasData() && m_pImpl->base.is();
+    return hasData() && m_pImpl->base != NULL;
 }
 
 // -----------------------------------------------------------------------------	
@@ -241,13 +198,11 @@ void TreeSegment::setName(Name const & _
 
     if (is()) 
     {
-        memory::UpdateAccessor aUpdater( this->getSegment() );
-
-        sharable::String aOldName = getTreeDataForUpdate(aUpdater)->header.name;
+        sharable::String aOldName = getTreeDataForUpdate()->header.name;
 
         sharable::String aNewName = sharable::allocString(_aNewName.toString());
 
-        getTreeDataForUpdate(aUpdater)->header.name = aNewName;
+        getTreeDataForUpdate()->header.name = aNewName;
 
         sharable::freeString(aOldName);
     }
@@ -258,15 +213,12 @@ void TreeSegment::markRemovable()
     OSL_ENSURE(is(), "Operation requires a valid tree");
 
     if (is()) 
-    {
-        memory::UpdateAccessor aUpdater( this->getSegment() );
-		getTreeDataForUpdate(aUpdater)->header.state |= State::flag_removable;
-    }
+        getTreeDataForUpdate()->header.state |= State::flag_removable;
 }
 // -----------------------------------------------------------------------------	
 TreeAddress TreeSegment::getBaseAddress() const
 {
-    return hasData() ? m_pImpl->base : TreeAddress();
+    return hasData() ? m_pImpl->base : NULL;
 }
 
 // -----------------------------------------------------------------------------	
@@ -274,18 +226,17 @@ TreeSegment::TreeDataPtr TreeSegment::ge
 {
     if (!is()) return NULL;
 
-    return TreeAccessor::access(m_pImpl->base, this->getAccessor());
+    return m_pImpl->base;
 }
 
 // -----------------------------------------------------------------------------	
-TreeSegment::TreeDataUpdatePtr TreeSegment::getTreeDataForUpdate(memory::UpdateAccessor& _anUpdater) const
+TreeSegment::TreeDataUpdatePtr TreeSegment::getTreeDataForUpdate() const
 {
-    OSL_ASSERT(_anUpdater.is());
     OSL_ASSERT(this->is());
 
     if (!is()) return NULL;
 
-    return TreeAccessor::access(m_pImpl->base,_anUpdater);
+    return m_pImpl->base;
 }
 
 // -----------------------------------------------------------------------------	
Index: configmgr/source/tree/updatehelper.cxx
===================================================================
RCS file: /cvs/util/configmgr/source/tree/updatehelper.cxx,v
retrieving revision 1.11
retrieving revision 1.11.24.2
diff -u -p -u -p -r1.11 -r1.11.24.2
--- configmgr/source/tree/updatehelper.cxx	16 Sep 2006 15:24:10 -0000	1.11
+++ configmgr/source/tree/updatehelper.cxx	11 Jan 2007 10:35:35 -0000	1.11.24.2
@@ -60,9 +60,6 @@
 #endif
 
 // -----------------------------------------------------------------------------	
-#ifndef CONFIGMGR_UPDATEACCESSOR_HXX
-#include "updateaccessor.hxx"
-#endif
 #ifndef INCLUDED_SHARABLE_NODE_HXX
 #include "node.hxx"
 #endif
@@ -115,28 +112,28 @@ namespace configmgr
 class AdjustUpdate : ChangeTreeModification
 {
 	SubtreeChange&      m_rChangeList;	// list which containes changes merged with the existing nodes
-    data::NodeAccessRef	m_aRefNode;		// reference node needed for merging
+    data::NodeAccess	m_aRefNode;		// reference node needed for merging
     OTreeNodeConverter  m_aNodeConverter;
 public:
     static bool adjust(SubtreeChange& _rResultTree, SubtreeChange& _aUpdateTree, 
-                        data::NodeAccessRef const& _aTargetNode)
+                        data::NodeAccess const& _aTargetNode)
     {
         return AdjustUpdate(_rResultTree,_aTargetNode).impl_adjust(_aUpdateTree);
     }
     static bool adjust(SubtreeChange& _rResultTree, SubtreeChange& _aUpdateTree, 
-                        data::NodeAccessRef const& _aTargetNode, 
+                        data::NodeAccess const& _aTargetNode, 
                         OTreeNodeFactory& _rNodeFactory)
     {
         return AdjustUpdate(_rResultTree,_aTargetNode,_rNodeFactory).impl_adjust(_aUpdateTree);
     }
 private:
-	AdjustUpdate(SubtreeChange& rList, data::NodeAccessRef const & _aNode)
+	AdjustUpdate(SubtreeChange& rList, data::NodeAccess const & _aNode)
 		:m_rChangeList(rList)
 		,m_aRefNode(_aNode)
         ,m_aNodeConverter()
     {}
 	
-	AdjustUpdate(SubtreeChange& rList, data::NodeAccessRef const & _aNode, OTreeNodeFactory& _rNodeFactory)
+	AdjustUpdate(SubtreeChange& rList, data::NodeAccess const & _aNode, OTreeNodeFactory& _rNodeFactory)
 		:m_rChangeList(rList)
 		,m_aRefNode(_aNode)
         ,m_aNodeConverter(_rNodeFactory)
@@ -157,12 +154,10 @@ private:
 
 class ApplyUpdate : public ChangeTreeModification
 {
-    memory::UpdateAccessor &    m_rUpdateAccess;
     data::NodeAddress           m_aCurrentNode;
 public:
-    ApplyUpdate(memory::UpdateAccessor & _rUpdateAccess, data::NodeAddress _aNode) 
-    : m_rUpdateAccess(_rUpdateAccess)
-    , m_aCurrentNode(_aNode) 
+    ApplyUpdate(data::NodeAddress _aNode) 
+    : m_aCurrentNode(_aNode) 
     {}
 	
 	void handle(ValueChange& aValueNode);
@@ -171,7 +166,7 @@ public:
 	void handle(SubtreeChange& aSubtree);
 
     static 
-    void applyChange(ValueChange& _rValueChange, memory::UpdateAccessor & _rUpdateAccess, data::ValueNodeAddress & _aValueNodeAddr);
+    void applyChange(ValueChange& _rValueChange, data::ValueNodeAddress & _aValueNodeAddr);
 };
 //--------------------------------------------------------------------------
 class ApplyValueChange
@@ -181,26 +176,26 @@ class ApplyValueChange
 
 public:
     static 
-    data::ValueNodeAccess node(memory::UpdateAccessor & _rUpdateAccess, data::ValueNodeAddress & _aValueNodeAddr)
-    { return data::ValueNodeAccess(_rUpdateAccess.accessor(),_aValueNodeAddr); }
+    data::ValueNodeAccess node(data::ValueNodeAddress & _aValueNodeAddr)
+    { return data::ValueNodeAccess(_aValueNodeAddr); }
 
     static 
-    uno::Any getValue(memory::UpdateAccessor & _rUpdateAccess, data::ValueNodeAddress & _aValueNodeAddr)
-    { return node(_rUpdateAccess,_aValueNodeAddr).getValue(); }
+    uno::Any getValue(data::ValueNodeAddress & _aValueNodeAddr)
+    { return node(_aValueNodeAddr).getValue(); }
 
     static 
-    uno::Any getDefault(memory::UpdateAccessor & _rUpdateAccess, data::ValueNodeAddress & _aValueNodeAddr)
-    { return node(_rUpdateAccess,_aValueNodeAddr).getDefaultValue(); }
+    uno::Any getDefault(data::ValueNodeAddress & _aValueNodeAddr)
+    { return node(_aValueNodeAddr).getDefaultValue(); }
 
     static 
-    void apply(ValueChange& _rValueChange, memory::UpdateAccessor & _rUpdateAccess, data::ValueNodeAddress & _aValueNodeAddr);
+    void apply(ValueChange& _rValueChange, data::ValueNodeAddress & _aValueNodeAddr);
 };
 //--------------------------------------------------------------------------
 //--------------------------------------------------------------------------
 
 
 // adjust a set of changes to the target tree, return true, if there are changes left
-    bool adjustUpdateToTree(SubtreeChange & _rUpdateTree, data::NodeAccessRef const & _aRootNode)
+    bool adjustUpdateToTree(SubtreeChange & _rUpdateTree, data::NodeAccess const & _aRootNode)
     {
         SubtreeChange aResultTree(_rUpdateTree, SubtreeChange::NoChildCopy());
 
@@ -213,38 +208,37 @@ public:
 //--------------------------------------------------------------------------
 
 // adjust a set of changes to the target tree, return true, if there are changes left
-    bool adjustUpdateToTree(SubtreeChange & _rUpdateTree, memory::UpdateAccessor& _anUpdateAccess, data::NodeAddress _aRootNode)
+    bool adjustUpdateToTree(SubtreeChange & _rUpdateTree, data::NodeAddress _aRootNode)
     {
-        data::NodeAccess aTargetNode(_anUpdateAccess.accessor(),_aRootNode);
+        data::NodeAccess aTargetNode(_aRootNode);
         return adjustUpdateToTree(_rUpdateTree, aTargetNode);
     }
 //--------------------------------------------------------------------------
 
 // apply a already matching set of changes to the target tree
-    void applyUpdateToTree(SubtreeChange& _anUpdateTree, memory::UpdateAccessor& _anUpdateAccess, data::NodeAddress _aRootNode)
+    void applyUpdateToTree(SubtreeChange& _anUpdateTree, data::NodeAddress _aRootNode)
     {
-        ApplyUpdate aUpdater(_anUpdateAccess,_aRootNode);
+        ApplyUpdate aUpdater(_aRootNode);
         _anUpdateTree.forEachChange(aUpdater);
-
     }
 //--------------------------------------------------------------------------
     static inline 
     bool adjust_helper(SubtreeChange& _rResultTree, SubtreeChange& _aUpdateTree, 
-                        memory::UpdateAccessor& _anUpdateAccess, data::NodeAddress _aTargetAddress )
+		       data::NodeAddress _aTargetAddress )
     {
-        data::NodeAccess aTargetNode(_anUpdateAccess.accessor(),_aTargetAddress);
+        data::NodeAccess aTargetNode(_aTargetAddress);
         return AdjustUpdate::adjust(_rResultTree, _aUpdateTree, aTargetNode);
     }
 //--------------------------------------------------------------------------
 // apply a set of changes to the target tree
-    void applyUpdateWithAdjustmentToTree(SubtreeChange& _anUpdateTree, memory::UpdateAccessor& _anUpdateAccess, data::NodeAddress _aRootNode)
+    void applyUpdateWithAdjustmentToTree(SubtreeChange& _anUpdateTree, data::NodeAddress _aRootNode)
     {
-	    // POST: pSubtree = pSubtree + aChangeList
-	    SubtreeChange aActualChanges(_anUpdateTree, SubtreeChange::NoChildCopy());
+	// POST: pSubtree = pSubtree + aChangeList
+	SubtreeChange aActualChanges(_anUpdateTree, SubtreeChange::NoChildCopy());
 	    
-        if ( adjust_helper(aActualChanges,_anUpdateTree, _anUpdateAccess, _aRootNode) )
+        if ( adjust_helper(aActualChanges,_anUpdateTree, _aRootNode) )
         {
-		    applyUpdateToTree(aActualChanges, _anUpdateAccess, _aRootNode);
+	    applyUpdateToTree(aActualChanges, _aRootNode);
         }    
         _anUpdateTree.swap(aActualChanges);
         
@@ -295,7 +289,7 @@ void AdjustUpdate::handle(ValueChange& _
     {
 	    // We need to find the element in the tree
         data::NodeAccess aChildNodeAcc = data::getSubnode(m_aRefNode, getChangeNodeName(_rChange));		
-        data::NodeAccessRef aChildNode(aChildNodeAcc);		
+        data::NodeAccess aChildNode(aChildNodeAcc);		
 	    
 	    // We have a node so we can keep the Change and the values do not differ
 	    if (aChildNode.isValid()) 
@@ -331,7 +325,7 @@ void AdjustUpdate::handle(SubtreeChange&
     {
 	    // We need to find the element in the tree
         data::NodeAccess aChildNodeAcc = data::getSubnode(m_aRefNode, getChangeNodeName(_rChange));		
-        data::NodeAccessRef aChildNode(aChildNodeAcc);		
+        data::NodeAccess aChildNode(aChildNodeAcc);		
 	    
 	    // if there is a node we continue
 	    if (aChildNode.isValid()) 
@@ -421,29 +415,29 @@ void ApplyValueChange::adjust(uno::Any& 
 
 //--------------------------------------------------------------------------
 // _rValueChange.applyTo(_aValueNode)
-void ApplyValueChange::apply(ValueChange& _rValueChange, memory::UpdateAccessor & _rUpdateAccess, data::ValueNodeAddress & _aValueNodeAddr)
+void ApplyValueChange::apply(ValueChange& _rValueChange, data::ValueNodeAddress & _aValueNodeAddr)
 {
     using data::ValueNodeAccess;
 
 	switch (_rValueChange.getMode())
 	{
     case ValueChange::wasDefault:
-        OSL_ASSERT(node(_rUpdateAccess,_aValueNodeAddr).isDefault());
+        OSL_ASSERT(node(_aValueNodeAddr).isDefault());
 
 	case ValueChange::changeValue:
-		adjust( _rValueChange.m_aOldValue, getValue(_rUpdateAccess,_aValueNodeAddr));
-        ValueNodeAccess::setValue(_rUpdateAccess,_aValueNodeAddr,_rValueChange.getNewValue());
+		adjust( _rValueChange.m_aOldValue, getValue(_aValueNodeAddr));
+        ValueNodeAccess::setValue(_aValueNodeAddr,_rValueChange.getNewValue());
 		break;
 
 	case ValueChange::setToDefault:
-		adjust( _rValueChange.m_aOldValue,	getValue(_rUpdateAccess,_aValueNodeAddr));
-		adjust( _rValueChange.m_aValue,		getDefault(_rUpdateAccess,_aValueNodeAddr));
-		ValueNodeAccess::setToDefault(_rUpdateAccess,_aValueNodeAddr);
+		adjust( _rValueChange.m_aOldValue,	getValue(_aValueNodeAddr));
+		adjust( _rValueChange.m_aValue,		getDefault(_aValueNodeAddr));
+		ValueNodeAccess::setToDefault(_aValueNodeAddr);
 		break;
 
 	case ValueChange::changeDefault:
-		adjust( _rValueChange.m_aOldValue,	getDefault(_rUpdateAccess,_aValueNodeAddr));
-		ValueNodeAccess::changeDefault(_rUpdateAccess,_aValueNodeAddr,_rValueChange.getNewValue());
+		adjust( _rValueChange.m_aOldValue,	getDefault(_aValueNodeAddr));
+		ValueNodeAccess::changeDefault(_aValueNodeAddr,_rValueChange.getNewValue());
 		break;
 
 	default:
@@ -455,35 +449,35 @@ void ApplyValueChange::apply(ValueChange
 
 void ApplyUpdate::handle(ValueChange& _rChange)
 {
-	// Change a Value
-	OSL_ENSURE(m_aCurrentNode.is(),"Cannot apply ValueChange without node");
+    // Change a Value
+    OSL_ENSURE(m_aCurrentNode != NULL,"Cannot apply ValueChange without node");
 
-    data::NodeAddress aChildNodeAddr = data::getSubnodeAddress(m_rUpdateAccess, m_aCurrentNode, getChangeNodeName(_rChange));		
-	OSL_ENSURE(aChildNodeAddr.is(),"Cannot apply Change: No node to change");
+    data::NodeAddress aChildNodeAddr = data::getSubnodeAddress(m_aCurrentNode, getChangeNodeName(_rChange));		
+    OSL_ENSURE(aChildNodeAddr != NULL,"Cannot apply Change: No node to change");
 
-    data::ValueNodeAddress aValueAddr = data::toValueNodeAddress(m_rUpdateAccess, aChildNodeAddr);
-	OSL_ENSURE(aValueAddr.is(),"Cannot apply ValueChange: Node is not a value");
+    data::ValueNodeAddress aValueAddr = aChildNodeAddr->valueData();
+    OSL_ENSURE(aValueAddr != NULL,"Cannot apply ValueChange: Node is not a value");
 
-	if (aValueAddr.is())
-		ApplyValueChange::apply(_rChange,m_rUpdateAccess,aValueAddr);
+    if (aValueAddr != NULL)
+	ApplyValueChange::apply(_rChange,aValueAddr);
 }
 //--------------------------------------------------------------------------
 	
 void ApplyUpdate::handle(SubtreeChange& _rChange)
 {
-	// handle traversion
-	OSL_ENSURE(m_aCurrentNode.is(),"Cannot apply SubtreeChange without node");
+    // handle traversion
+    OSL_ENSURE(m_aCurrentNode != NULL,"Cannot apply SubtreeChange without node");
 
-    data::NodeAddress aChildNodeAddr = data::getSubnodeAddress(m_rUpdateAccess, m_aCurrentNode, getChangeNodeName(_rChange));		
-	OSL_ENSURE(aChildNodeAddr.is(),"Cannot apply Change: No node to change");
+    data::NodeAddress aChildNodeAddr = data::getSubnodeAddress(m_aCurrentNode, getChangeNodeName(_rChange));		
+    OSL_ENSURE(aChildNodeAddr != NULL,"Cannot apply Change: No node to change");
 
-	OSL_ENSURE( data::toGroupNodeAddress(m_rUpdateAccess, aChildNodeAddr).is() ||
-                data::toSetNodeAddress(m_rUpdateAccess, aChildNodeAddr).is() ,
+    OSL_ENSURE( data::toGroupNodeAddress(aChildNodeAddr) != NULL ||
+                data::toSetNodeAddress(aChildNodeAddr) != NULL ,
                 "Cannot Apply SubtreeChange: Node is not an inner node");
 
-    if (aChildNodeAddr.is())
+    if (aChildNodeAddr != NULL)
     {
-        data::NodeAccess::access(aChildNodeAddr, m_rUpdateAccess)->node.info.markAsDefault( _rChange.isToDefault() );
+        aChildNodeAddr->node.info.markAsDefault( _rChange.isToDefault() );
 
         data::NodeAddress aOldNode = m_aCurrentNode;
         m_aCurrentNode = aChildNodeAddr;
@@ -497,29 +491,29 @@ void ApplyUpdate::handle(SubtreeChange& 
 
 void ApplyUpdate::handle(AddNode& _rChange)
 {
-	OSL_ENSURE(m_aCurrentNode.is(),"Cannot apply AddNode without node");
+    OSL_ENSURE(m_aCurrentNode != NULL,"Cannot apply AddNode without node");
 
-    data::SetNodeAddress aSetNodeAddr = data::toSetNodeAddress(m_rUpdateAccess, m_aCurrentNode);		
-	OSL_ENSURE(aSetNodeAddr.is(),"Cannot apply AddNode: Node is not a set node");
+    data::SetNodeAddress aSetNodeAddr = data::toSetNodeAddress(m_aCurrentNode);		
+    OSL_ENSURE(aSetNodeAddr != NULL,"Cannot apply AddNode: Node is not a set node");
 
-	// Add a new element
-	if (aSetNodeAddr.is())
+    // Add a new element
+    if (aSetNodeAddr != NULL)
+    {
+	if (_rChange.isReplacing())
 	{
-		if (_rChange.isReplacing())
-		{
             data::TreeAddress aOldNodeAddr = 
-                data::SetNodeAccess::removeElement(m_rUpdateAccess,aSetNodeAddr,getChangeNodeName(_rChange));
+                data::SetNodeAccess::removeElement(aSetNodeAddr,getChangeNodeName(_rChange));
 
-            OSL_ENSURE(aOldNodeAddr.is(), "ApplyUpdate: AddNode: can't recover node being replaced");
+            OSL_ENSURE(aOldNodeAddr != NULL, "ApplyUpdate: AddNode: can't recover node being replaced");
 
-            data::TreeAccessor aOldNodeAccess(m_rUpdateAccess.accessor(),aOldNodeAddr);
+            data::TreeAccessor aOldNodeAccess(aOldNodeAddr);
             _rChange.takeReplacedTree( data::TreeSegment::createNew(aOldNodeAccess) );
 		}
 
-        data::TreeAddress aNewAddress = data::buildTree(m_rUpdateAccess, _rChange.getNewTree().getTreeAccess());
-        OSL_ENSURE(aNewAddress.is(), "ApplyUpdate: AddNode: could not create new element");
+        data::TreeAddress aNewAddress = data::buildTree(_rChange.getNewTree().getTreeAccess());
+        OSL_ENSURE(aNewAddress != NULL, "ApplyUpdate: AddNode: could not create new element");
 
-        data::SetNodeAccess::addElement(m_rUpdateAccess,aSetNodeAddr,aNewAddress);
+        data::SetNodeAccess::addElement(aSetNodeAddr,aNewAddress);
 
         _rChange.setInsertedAddress( aNewAddress );
 	}	
@@ -528,20 +522,20 @@ void ApplyUpdate::handle(AddNode& _rChan
 	
 void ApplyUpdate::handle(RemoveNode& _rChange)
 {
-	OSL_ENSURE(m_aCurrentNode.is(),"Cannot apply RemoveNode without node");
+    OSL_ENSURE(m_aCurrentNode != NULL,"Cannot apply RemoveNode without node");
 
-    data::SetNodeAddress aSetNodeAddr = data::toSetNodeAddress(m_rUpdateAccess, m_aCurrentNode);		
-	OSL_ENSURE(aSetNodeAddr.is(),"Cannot apply RemoveNode: Node is not a set node");
+    data::SetNodeAddress aSetNodeAddr = data::toSetNodeAddress(m_aCurrentNode);		
+    OSL_ENSURE(aSetNodeAddr != NULL,"Cannot apply RemoveNode: Node is not a set node");
 
-	// Remove an element
-	if (aSetNodeAddr.is())
-	{
+    // Remove an element
+    if (aSetNodeAddr != NULL)
+    {
         data::TreeAddress aOldNodeAddr = 
-            data::SetNodeAccess::removeElement(m_rUpdateAccess,aSetNodeAddr,getChangeNodeName(_rChange));
+            data::SetNodeAccess::removeElement(aSetNodeAddr,getChangeNodeName(_rChange));
 
-        OSL_ENSURE(aOldNodeAddr.is(), "ApplyUpdate: Remove: can't recover node being removed");
+        OSL_ENSURE(aOldNodeAddr != NULL, "ApplyUpdate: Remove: can't recover node being removed");
 
-        data::TreeAccessor aOldNodeAccess(m_rUpdateAccess.accessor(),aOldNodeAddr);
+        data::TreeAccessor aOldNodeAccess(aOldNodeAddr);
         _rChange.takeRemovedTree( data::TreeSegment::createNew(aOldNodeAccess) );
 	}
 }
@@ -552,10 +546,10 @@ void ApplyUpdate::handle(RemoveNode& _rC
 	{
 	protected:
 		SubtreeChange&      m_rChangeList;
-        data::NodeAccessRef	m_aCacheNode;
+        data::NodeAccess	m_aCacheNode;
         
     public:
-        ForwardTreeDifferenceBuilder(SubtreeChange& rList, data::NodeAccessRef const & _aCacheNode)
+        ForwardTreeDifferenceBuilder(SubtreeChange& rList, data::NodeAccess const & _aCacheNode)
 		: m_rChangeList(rList)
 		, m_aCacheNode(_aCacheNode)
 		{
@@ -655,7 +649,7 @@ void ApplyUpdate::handle(RemoveNode& _rC
 		{
 		}
 		
-        Result applyToChildren(data::NodeAccessRef const & _aCacheNode)
+        Result applyToChildren(data::NodeAccess const & _aCacheNode)
         {
             if (data::GroupNodeAccess::isInstance(_aCacheNode))
             {
@@ -691,7 +685,7 @@ void ApplyUpdate::handle(RemoveNode& _rC
             return CONTINUE;
         }
 
-		virtual Result handle(data::NodeAccessRef const & _aCacheNode)
+		virtual Result handle(data::NodeAccess const & _aCacheNode)
 		{
             // value nodes are handled separately
             OSL_ASSERT(!data::ValueNodeAccess::isInstance(_aCacheNode));
@@ -762,7 +756,8 @@ void ApplyUpdate::handle(RemoveNode& _rC
             else
 			{
 				// Remove Node
-                std::auto_ptr<Change> pRemove(new RemoveNode(aElementName,_aCacheElement.data().isNew()));
+                std::auto_ptr<Change> pRemove(new RemoveNode(aElementName,
+							     _aCacheElement->isNew()));
 
 				m_rChangeList.addChange(pRemove);
 
@@ -774,7 +769,7 @@ void ApplyUpdate::handle(RemoveNode& _rC
 //--------------------------------------------------------------------------
 
 // apply a set of changes to the target tree, return true, if there are changes found
-    bool createUpdateFromDifference(SubtreeChange& _rResultingUpdateTree, data::NodeAccessRef const & _aExistingData, ISubtree const & _aNewData)
+    bool createUpdateFromDifference(SubtreeChange& _rResultingUpdateTree, data::NodeAccess const & _aExistingData, ISubtree const & _aNewData)
     {
         OSL_ENSURE( _aExistingData.isValid(), "Trying to create diffrence for empty data" );
 	// create the differences
Index: configmgr/source/tree/valuenodeaccess.cxx
===================================================================
RCS file: /cvs/util/configmgr/source/tree/valuenodeaccess.cxx,v
retrieving revision 1.6
retrieving revision 1.6.24.2
diff -u -p -u -p -r1.6 -r1.6.24.2
--- configmgr/source/tree/valuenodeaccess.cxx	16 Sep 2006 15:24:22 -0000	1.6
+++ configmgr/source/tree/valuenodeaccess.cxx	11 Jan 2007 10:35:35 -0000	1.6.24.2
@@ -38,10 +38,6 @@
 
 #include "valuenodeaccess.hxx"
 
-#ifndef CONFIGMGR_UPDATEACCESSOR_HXX
-#include "updateaccessor.hxx"
-#endif
-
 #ifndef _OSL_DIAGNOSE_H_
 #include <osl/diagnose.h>
 #endif
@@ -53,30 +49,11 @@ namespace configmgr
 // -----------------------------------------------------------------------------	
     namespace data
     {
-    // -------------------------------------------------------------------------
-        using memory::Pointer;
-    // -------------------------------------------------------------------------
-        static 
-        ValueNodeAddress::DataType* accessValue(Pointer const& _p, memory::UpdateAccessor& _rUpdateAccess)
-        {
-            return static_cast<ValueNodeAddress::DataType*>( _rUpdateAccess.validate(_p) );
-        }
-    // -------------------------------------------------------------------------
-    // -------------------------------------------------------------------------
-
-        Pointer ValueNodeAccess::check(NodeAccessRef const& _aNode)
-        {
-            if (sharable::Node const* pNode = _aNode.getDataPtr())
-                return _aNode.accessor().address(pNode->valueData());
 
-            else
-                return Pointer();
-        }
-    // -------------------------------------------------------------------------
-		    
-void ValueNodeAccess::setValue(memory::UpdateAccessor & _aUpdater, NodeAddressType _aValueNode, uno::Any const& _aValue)
+void ValueNodeAccess::setValue(ValueNodeAddress _aValueNode,
+                               uno::Any const& _aValue)
 {
-    sharable::ValueNode * node = accessValue(_aValueNode.m_pData,_aUpdater);
+    sharable::ValueNode * node = _aValueNode;
 
     using namespace sharable;
     AnyData::TypeCode aType = AnyData::TypeCode( node->info.type & Type::mask_valuetype );
@@ -86,8 +63,8 @@ void ValueNodeAccess::setValue(memory::U
     {
         OSL_ASSERT(aType != Type::value_any);
 
-        freeData(_aUpdater.allocator(),aType,node->value);
-        node = accessValue(_aValueNode.m_pData,_aUpdater);
+        freeData(aType,node->value);
+        node = _aValueNode;
 
         node->value.data = 0;
         node->info.flags ^= Flags::valueAvailable;
@@ -114,8 +91,8 @@ void ValueNodeAccess::setValue(memory::U
         if (aType == aNewType)
         {
             // store the data
-            sharable::AnyData aNewData = allocData(_aUpdater.allocator(),aType,_aValue);
-            node = accessValue(_aValueNode.m_pData,_aUpdater);
+            sharable::AnyData aNewData = allocData(aType,_aValue);
+            node = _aValueNode;
 
             node->value = aNewData;
             node->info.flags |= Flags::valueAvailable;
@@ -125,9 +102,9 @@ void ValueNodeAccess::setValue(memory::U
 }
 //-----------------------------------------------------------------------------
 
-void ValueNodeAccess::setToDefault(memory::UpdateAccessor & _aUpdater, NodeAddressType _aValueNode)
+void ValueNodeAccess::setToDefault(ValueNodeAddress _aValueNode)
 {
-    sharable::ValueNode * node = accessValue(_aValueNode.m_pData,_aUpdater);
+    sharable::ValueNode * node = _aValueNode;
 
     using namespace sharable;
     OSL_ENSURE(node->hasUsableDefault(), "ERROR: setToDefault() - Value does not have a default");
@@ -138,8 +115,8 @@ void ValueNodeAccess::setToDefault(memor
         AnyData::TypeCode aType = AnyData::TypeCode( node->info.type & Type::mask_valuetype );
         OSL_ASSERT(aType != Type::value_any);
 
-        freeData(_aUpdater.allocator(),aType,node->value);
-        node = accessValue(_aValueNode.m_pData,_aUpdater);
+        freeData(aType,node->value);
+        node = _aValueNode;
 
         node->value.data = 0;
         node->info.flags ^= Flags::valueAvailable;
@@ -149,9 +126,10 @@ void ValueNodeAccess::setToDefault(memor
 }
 //-----------------------------------------------------------------------------
 
-void ValueNodeAccess::changeDefault(memory::UpdateAccessor & _aUpdater, NodeAddressType _aValueNode, uno::Any const& _aValue)
+void ValueNodeAccess::changeDefault(ValueNodeAddress _aValueNode,
+                                    uno::Any const& _aValue)
 {
-    sharable::ValueNode * node = accessValue(_aValueNode.m_pData,_aUpdater);
+    sharable::ValueNode * node = _aValueNode;
 
     using namespace sharable;
     AnyData::TypeCode aType = AnyData::TypeCode( node->info.type & Type::mask_valuetype );
@@ -161,8 +139,8 @@ void ValueNodeAccess::changeDefault(memo
     {
         OSL_ASSERT(aType != Type::value_any);
 
-        freeData(_aUpdater.allocator(),aType,node->defaultValue);
-        node = accessValue(_aValueNode.m_pData,_aUpdater);
+        freeData(aType,node->defaultValue);
+        node = _aValueNode;
 
         node->defaultValue.data = 0;
         node->info.flags ^= Flags::defaultAvailable;
@@ -189,8 +167,8 @@ void ValueNodeAccess::changeDefault(memo
         if (aType == aNewType)
         {
             // store the data
-            sharable::AnyData aNewData = allocData(_aUpdater.allocator(),aType,_aValue);
-            node = accessValue(_aValueNode.m_pData,_aUpdater);
+            sharable::AnyData aNewData = allocData(aType,_aValue);
+            node = _aValueNode;
 
             node->defaultValue = aNewData;
             node->info.flags |= Flags::defaultAvailable;
@@ -198,32 +176,7 @@ void ValueNodeAccess::changeDefault(memo
     }
 }
 
-//-----------------------------------------------------------------------------
-/*
-void ValueNode::clearData(data::Allocator const & _aAlloc)
-{
-    AnyData::TypeCode aType = info.type & Type::mask_valuetype;
-
-    if (info.flags & Flags::valueAvailable)
-    {
-        OSL_ASSERT(aType != Type::value_any);
-        freeData(_aAlloc,aType,this->value);
-        info.flags ^= Flags::valueAvailable;
-        this->value.data = 0;
-    }
-
-    if (info.flags & Flags::defaultAvailable)
-    {
-        OSL_ASSERT(aType != Type::value_any);
-        freeData(_aAlloc,aType,this->defaultValue);
-        info.flags ^= Flags::defaultAvailable;
-        this->defaultValue.data = 0;
-    }
-}
-*/
-//-----------------------------------------------------------------------------
-    }
-// -----------------------------------------------------------------------------	
+    } // namespace data
 } // namespace configmgr
 
 
Index: configmgr/source/treecache/cacheaccess.cxx
===================================================================
RCS file: /cvs/util/configmgr/source/treecache/cacheaccess.cxx,v
retrieving revision 1.9
retrieving revision 1.9.24.6
diff -u -p -u -p -r1.9 -r1.9.24.6
--- configmgr/source/treecache/cacheaccess.cxx	16 Sep 2006 15:24:36 -0000	1.9
+++ configmgr/source/treecache/cacheaccess.cxx	16 Jan 2007 12:18:23 -0000	1.9.24.6
@@ -38,12 +38,6 @@
 
 #include "cacheaccess.hxx"
 
-#ifndef CONFIGMGR_ACCESSOR_HXX
-#include "accessor.hxx"
-#endif
-#ifndef CONFIGMGR_NODEADDRESS_HXX
-#include "nodeaddress.hxx"
-#endif
 #ifndef CONFIGMGR_NODEACCESS_HXX
 #include "nodeaccess.hxx"
 #endif
@@ -62,11 +56,8 @@ namespace configmgr
 
 // -------------------------------------------------------------------------
 
-CacheClientAccess::CacheClientAccess(memory::HeapManager & _rHeapManager,
-                                     ConfigChangeBroadcastHelper *  _pBroadcastHelper)
-: m_aMutex()
-, m_aData(_rHeapManager)
-, m_pBroadcastHelper( _pBroadcastHelper )
+CacheClientAccess::CacheClientAccess(ConfigChangeBroadcastHelper *  _pBroadcastHelper)
+: m_pBroadcastHelper( _pBroadcastHelper )
 {
 }
 // -------------------------------------------------------------------------
@@ -79,65 +70,37 @@ CacheClientAccess::~CacheClientAccess()
 
 ConfigChangeBroadcastHelper *  CacheClientAccess::releaseBroadcaster()
 {
-    osl::MutexGuard aGuard(m_aMutex);
     ConfigChangeBroadcastHelper * pRet = m_pBroadcastHelper;
     m_pBroadcastHelper = NULL;
     return pRet;
 }
-// -------------------------------------------------------------------------
 
-/// gets a data segment reference for the given path - creates if necessary
-memory::Segment * CacheLoadingAccess::createNewDataSegment(ModuleName const & _aModule)
-{
-	osl::MutexGuard aGuard( this->m_aMutex );
-
-    return this->m_aData.createDataSegment(_aModule);
-}
 // -------------------------------------------------------------------------
 
-/// gets a data segment reference for the given path - creates if necessary
-memory::Segment * CacheClientAccess::attachDataSegment(const memory::SegmentAddress & _aSegment, const Path& _aLocation)
+bool CacheClientAccess::hasModule(const CacheLine::Path& _aLocation)
 {
-	osl::MutexGuard aGuard( this->m_aMutex );
-
-    return this->m_aData.attachDataSegment(_aSegment,_aLocation.getModuleName());
+    return this->m_aData.hasModule(_aLocation.getModuleName());
 }
 // -------------------------------------------------------------------------
 
-/// gets a data segment reference for the given path if exists
-memory::Segment * CacheClientAccess::getDataSegment(const Path& _aLocation)
+bool CacheClientAccess::hasModuleDefaults(CacheLine::Path const& _aLocation)
 {
-	osl::MutexGuard aGuard( this->m_aMutex );
-
-    return this->m_aData.getDataSegment(_aLocation.getModuleName());
+    return this->m_aData.hasModuleDefaults(_aLocation.getModuleName());
 }
 // -------------------------------------------------------------------------
-
-bool CacheClientAccess::hasModule(const Path& _aLocation)
+void CacheClientAccess::attachModule(data::TreeAddress _aLocation, CacheLine::Name const & _aModule)
 {
-	osl::MutexGuard aGuard( this->m_aMutex );
-
-    return this->m_aData.hasModule(_aLocation.getModuleName());
+    this->m_aData.attachModule(_aLocation, _aModule);
 }
 // -------------------------------------------------------------------------
 
-bool CacheClientAccess::hasModuleDefaults(memory::Accessor const& _aAccessor, Path const& _aLocation)
+data::NodeAddress CacheClientAccess::acquireNode(CacheLine::Path const& rLocation )
 {
-	osl::MutexGuard aGuard( this->m_aMutex );
-
-    return this->m_aData.hasModuleDefaults(_aAccessor, _aLocation.getModuleName());
-}
-// -------------------------------------------------------------------------
-
-data::NodeAddress CacheClientAccess::acquireNode(memory::Accessor const& _aAccessor, Path const& rLocation )
-{
-	osl::MutexGuard aGuard( this->m_aMutex );
-
 	CFG_TRACE_INFO("CacheClientAccess: Requesting data for path '%s'", OUSTRING2ASCII(rLocation.toString()) );
 
-    data::NodeAddress aResult = this->m_aData.acquireNode(_aAccessor,rLocation);
+    data::NodeAddress aResult = this->m_aData.acquireNode(rLocation);
 
-	if (aResult.is())
+	if (aResult != NULL)
 	{
 		CFG_TRACE_INFO_NI("- Data is available - returning Subtree");
 	}
@@ -148,35 +111,29 @@ data::NodeAddress CacheClientAccess::acq
 }
 // -------------------------------------------------------------------------
 
-CacheLine::RefCount CacheClientAccess::releaseNode( Path const& rLocation )
+oslInterlockedCount CacheClientAccess::releaseNode( CacheLine::Path const& rLocation )
 {
-	osl::MutexGuard aGuard( this->m_aMutex );
-
 	CFG_TRACE_INFO("Tree Info: Releasing subtree data for path '%s'", OUSTRING2ASCII(rLocation.toString()) );
 
-	Module::RefCount nRet = this->m_aData.releaseModule(rLocation.getModuleName(),false);
+	oslInterlockedCount nRet = this->m_aData.releaseModule(rLocation.getModuleName(),false);
 
 	return nRet;
 }
 // -----------------------------------------------------------------------------
 
-void CacheClientAccess::applyUpdate(memory::UpdateAccessor& _aUpdateToken,  backend::UpdateInstance & _aUpdate) CFG_UNO_THROW_RTE( )
+void CacheClientAccess::applyUpdate(backend::UpdateInstance & _aUpdate) CFG_UNO_THROW_RTE( )
 {
-	osl::MutexGuard aGuard( this->m_aMutex ); // needed to protect the map access in the Tree
-
 	CFG_TRACE_INFO("CacheClientAccess: Merging changes into subtree '%s'", OUSTRING2ASCII(_aUpdate.root().toString()) );
 
-	this->m_aData.applyUpdate(_aUpdateToken, _aUpdate );
+	this->m_aData.applyUpdate(_aUpdate );
 }
 
 // -----------------------------------------------------------------------------
-data::NodeAddress CacheClientAccess::findInnerNode( data::Accessor const& _aAccess, Path const& aComponentName )
+data::NodeAddress CacheClientAccess::findInnerNode( CacheLine::Path const& aComponentName )
 {
-	osl::MutexGuard aGuard( this->m_aMutex ); // needed to protect the map access in the Tree
-
-    data::NodeAddress aNode = this->m_aData.getNode(_aAccess, aComponentName);
+    data::NodeAddress aNode = this->m_aData.getNode(aComponentName);
 
-    if (aNode.is() && data::NodeAccessRef(&_aAccess,aNode).data().isValue() )
+    if (aNode != NULL && data::NodeAccess(aNode)->isValue() )
         aNode = data::NodeAddress();
 
     return aNode;
@@ -184,22 +141,17 @@ data::NodeAddress CacheClientAccess::fin
 
 // -------------------------------------------------------------------------
 
-bool CacheClientAccess::insertDefaults( memory::UpdateAccessor& _aAccessToken,
-                                        backend::NodeInstance const & _aDefaultData ) CFG_UNO_THROW_RTE(  )
+bool CacheClientAccess::insertDefaults( backend::NodeInstance const & _aDefaultData ) CFG_UNO_THROW_RTE(  )
 {
-	osl::MutexGuard aGuard( this->m_aMutex );
-
 	CFG_TRACE_INFO("Tree Info: Adding default data for path '%s'", OUSTRING2ASCII(_aDefaultData.root().toString()) );
 
-    return this->m_aData.insertDefaults(_aAccessToken, _aDefaultData);
+    return this->m_aData.insertDefaults(_aDefaultData);
 }
 // -------------------------------------------------------------------------
 
 bool CacheClientAccess::isEmpty()
 {
-	osl::MutexGuard aGuard( this->m_aMutex );
-
-	Data::ModuleList& rModules = this->m_aData.accessModuleList();
+	CacheData::ModuleList& rModules = this->m_aData.accessModuleList();
 
 	bool bRet = rModules.empty();
 
@@ -210,10 +162,8 @@ bool CacheClientAccess::isEmpty()
 // -------------------------------------------------------------------------
 // -------------------------------------------------------------------------
 
-CacheLoadingAccess::CacheLoadingAccess(memory::HeapManager & _rHeapManager)
-: m_aMutex()
-, m_aData(_rHeapManager)
-, m_aDeadModules()
+CacheLoadingAccess::CacheLoadingAccess()
+: m_aDeadModules()
 {
 }
 // -------------------------------------------------------------------------
@@ -221,70 +171,49 @@ CacheLoadingAccess::CacheLoadingAccess(m
 CacheLoadingAccess::~CacheLoadingAccess()
 {
 }
-// -------------------------------------------------------------------------
 
-/// gets a data segment reference for the given path - creates if necessary
-memory::Segment * CacheLoadingAccess::attachDataSegment(const memory::SegmentAddress & _aSegment, ModuleName const & _aModule)
-{
-	osl::MutexGuard aGuard( this->m_aMutex );
-
-    return this->m_aData.attachDataSegment(_aSegment,_aModule);
-}
 // -------------------------------------------------------------------------
 
-/// gets a data segment reference for the given path if exists
-memory::Segment * CacheLoadingAccess::getDataSegment(ModuleName const & _aModule)
+/// gets a tree reference for the given path if exists
+data::TreeAddress CacheLoadingAccess::getTreeAddress(CacheLine::Name const & _aModule)
 {
-	osl::MutexGuard aGuard( this->m_aMutex );
-
-    return this->m_aData.getDataSegment(_aModule);
+    return this->m_aData.getTreeAddress(_aModule);
 }
 // -------------------------------------------------------------------------
-
-/// gets a data segment reference for the given path if exists
-memory::SegmentAddress CacheLoadingAccess::getDataSegmentAddress(ModuleName const & _aModule)
+void CacheLoadingAccess::createModule(CacheLine::Name const & _aModule)
 {
-	osl::MutexGuard aGuard( this->m_aMutex );
-
-    return this->m_aData.getDataSegmentAddress(_aModule);
+    this->m_aData.createModule(_aModule);
 }
 // -------------------------------------------------------------------------
-
-bool CacheLoadingAccess::hasModule(ModuleName const & _aModule)
+bool CacheLoadingAccess::hasModule(CacheLine::Name const & _aModule)
 {
-	osl::MutexGuard aGuard( this->m_aMutex );
-
     return this->m_aData.hasModule(_aModule);
 }
 // -------------------------------------------------------------------------
 
-data::TreeAddress CacheLoadingAccess::acquireModule(ModuleName const & _aModule )
+bool CacheLoadingAccess::acquireModule(CacheLine::Name const & _aModule)
 {
-	osl::MutexGuard aGuard( this->m_aMutex );
-
-	CFG_TRACE_INFO("Tree Info: Requesting data for module '%s'", OUSTRING2ASCII(_aModule.toString()) );
-
-    data::TreeAddress aResult = this->m_aData.acquireModule(_aModule);
-
-	if (aResult.is())
-	{
-		m_aDeadModules.erase( _aModule );
-		CFG_TRACE_INFO_NI("- Data is available - returning Subtree");
-	}
-	else
-		CFG_TRACE_INFO_NI("- Data is not available - returning NULL");
+    CFG_TRACE_INFO("Tree Info: Requesting data for module '%s'", OUSTRING2ASCII(_aModule.toString()));
 
-    return aResult;
+    if (this->m_aData.acquireModule(_aModule))
+    {
+	m_aDeadModules.erase( _aModule );
+	CFG_TRACE_INFO_NI("- Data is available - returning Subtree");
+	return true;
+    }
+    else
+    {
+	CFG_TRACE_INFO_NI("- Data is not available - returning NULL");
+	return false;
+    }
 }
 // -------------------------------------------------------------------------
 
-CacheLine::RefCount CacheLoadingAccess::releaseModule( ModuleName const & _aModule )
+oslInterlockedCount CacheLoadingAccess::releaseModule( CacheLine::Name const & _aModule )
 {
-	osl::MutexGuard aGuard( this->m_aMutex );
-
 	CFG_TRACE_INFO("Tree Info: Releasing data for module '%s'", OUSTRING2ASCII(_aModule.toString()) );
 
-	Module::RefCount nRet = this->m_aData.releaseModule(_aModule,true); // keep
+	oslInterlockedCount nRet = this->m_aData.releaseModule(_aModule,true); // keep
     if (nRet == 0)
 	{
         m_aDeadModules[ _aModule ] = TimeStamp::getCurrentTime();
@@ -295,21 +224,17 @@ CacheLine::RefCount CacheLoadingAccess::
 }
 // -----------------------------------------------------------------------------
 
-void CacheLoadingAccess::applyUpdate(memory::UpdateAccessor& _aUpdateToken,  backend::UpdateInstance & _aUpdate) CFG_UNO_THROW_RTE( )
+void CacheLoadingAccess::applyUpdate(backend::UpdateInstance & _aUpdate) CFG_UNO_THROW_RTE( )
 {
-	osl::MutexGuard aGuard( this->m_aMutex ); // needed to protect the map access in the Tree
-
 	CFG_TRACE_INFO("CacheLoadingAccess: Merging changes into subtree '%s'", OUSTRING2ASCII(_aUpdate.root().toString()) );
 
-	this->m_aData.applyUpdate(_aUpdateToken, _aUpdate);
+	this->m_aData.applyUpdate(_aUpdate);
 }
 
 // -----------------------------------------------------------------------------
-data::NodeAddress CacheLoadingAccess::findNode( data::Accessor const& _aAccess, Path const& aComponentName )
+data::NodeAddress CacheLoadingAccess::findNode( CacheLine::Path const& aComponentName )
 {
-	osl::MutexGuard aGuard( this->m_aMutex ); // needed to protect the map access in the Tree
-
-    data::NodeAddress aNode = this->m_aData.getNode(_aAccess, aComponentName);
+    data::NodeAddress aNode = this->m_aData.getNode(aComponentName);
 
     return aNode;
 }
@@ -318,9 +243,7 @@ data::NodeAddress CacheLoadingAccess::fi
 
 bool CacheLoadingAccess::isEmpty()
 {
-	osl::MutexGuard aGuard( this->m_aMutex );
-
-	Data::ModuleList& rModules = this->m_aData.accessModuleList();
+	ExtendedCacheData::ModuleList& rModules = this->m_aData.accessModuleList();
 
 	bool bRet = rModules.empty();
 
@@ -331,18 +254,16 @@ bool CacheLoadingAccess::isEmpty()
 }
 // -------------------------------------------------------------------------
 
-data::TreeAddress CacheLoadingAccess::addComponentData( memory::UpdateAccessor& _aAccessToken,
-                                                        backend::ComponentInstance const & _aComponentInstance,
+data::TreeAddress CacheLoadingAccess::addComponentData( backend::ComponentInstance const & _aComponentInstance,
                                                         bool _bIncludesDefaults
                                                        ) CFG_UNO_THROW_RTE()
 {
-	osl::MutexGuard aGuard( this->m_aMutex );
     CFG_TRACE_INFO("CacheLoadingAccess: Adding component data for module '%s' : %s",
                     OUSTRING2ASCII(_aComponentInstance.component().toString()),
                     _bIncludesDefaults ? "Data includes defaults." : "Data does not include defaults." );
 
-    data::TreeAddress aResult = this->m_aData.addComponentData(_aAccessToken, _aComponentInstance, _bIncludesDefaults);
-	if (aResult.is())
+    data::TreeAddress aResult = this->m_aData.addComponentData(_aComponentInstance, _bIncludesDefaults);
+	if (aResult != NULL)
 	{
 		m_aDeadModules.erase( _aComponentInstance.component() );
 		CFG_TRACE_INFO_NI("- Data added successfully - returning Subtree");
@@ -357,26 +278,21 @@ data::TreeAddress CacheLoadingAccess::ad
 void CacheLoadingAccess::addChangesToPending( backend::ConstUpdateInstance const& _anUpdate ) CFG_UNO_THROW_RTE(  )
 {
 	// NICE: m_pPending[_rLocation] += pSubtreeChange;
-
-	osl::MutexGuard aGuard( this->m_aMutex ); // needed to protect the map access in the Data
-
     CFG_TRACE_INFO("CacheLoadingAccess: Adding pending changes for subtree '%s'", OUSTRING2ASCII(_anUpdate.root().toString()) );
 
 	this->m_aData.addPending(_anUpdate);
 }
 
 // -----------------------------------------------------------------------------
-std::auto_ptr<SubtreeChange> CacheLoadingAccess::releasePendingChanges(ModuleName const& _aComponentName)
+std::auto_ptr<SubtreeChange> CacheLoadingAccess::releasePendingChanges(CacheLine::Name const& _aComponentName)
 {
-	osl::MutexGuard aGuard( this->m_aMutex ); // needed to protect the map access in the Data
 	CFG_TRACE_INFO("Tree Info: extract pending changes from subtree '%s'", OUSTRING2ASCII(_aComponentName.toString()) );
 	return this->m_aData.releasePending(_aComponentName);
 }
 
 // -----------------------------------------------------------------------------
-bool CacheLoadingAccess::findPendingChangedModules( Data::PendingModuleList & _rPendingList )
+bool CacheLoadingAccess::findPendingChangedModules( ExtendedCacheData::PendingModuleList & _rPendingList )
 {
-	osl::MutexGuard aGuard( this->m_aMutex ); // needed to protect the map access in the Data
     this->m_aData.findPendingModules(_rPendingList);
     return !_rPendingList.empty();
 }
@@ -384,11 +300,9 @@ bool CacheLoadingAccess::findPendingChan
 // -----------------------------------------------------------------------------
 void CacheLoadingAccess::clearData(DisposeList& _rList) CFG_NOTHROW()
 {
-	osl::MutexGuard aGuard( this->m_aMutex );
-
 	CFG_TRACE_INFO("Tree Info: Removing all module trees for cleanup" );
 
-	typedef Data::ModuleList ModuleList;
+	typedef ExtendedCacheData::ModuleList ModuleList;
 
 	ModuleList& rModules = this->m_aData.accessModuleList();
 
@@ -409,11 +323,9 @@ TimeStamp CacheLoadingAccess::collectDis
 {
     TimeStamp aRetTime = TimeStamp::never();
 
-	osl::MutexGuard aGuard( this->m_aMutex );
-
 	CFG_TRACE_INFO("Tree Info: Collecting disposable module trees for cleanup" );
 
-	Data::ModuleList& rActiveModules = this->m_aData.accessModuleList();
+	ExtendedCacheData::ModuleList& rActiveModules = this->m_aData.accessModuleList();
 
 	DeadModuleList::iterator it = m_aDeadModules.begin();
 
@@ -429,11 +341,11 @@ TimeStamp CacheLoadingAccess::collectDis
         TimeStamp aExpireTime = current->second + _aDelay;
 		if (aExpireTime <= _aLimitTime)
 		{
-            Data::ModuleList::iterator itModule = rActiveModules.find( current->first );
+            ExtendedCacheData::ModuleList::iterator itModule = rActiveModules.find( current->first );
 
 			if (itModule != rActiveModules.end())
 			{
-				ModuleRef xModule = itModule->second;
+				CacheLineRef xModule = itModule->second;
 
 				bool bHandled = false;
 
Index: configmgr/source/treecache/cacheaccess.hxx
===================================================================
RCS file: /cvs/util/configmgr/source/treecache/cacheaccess.hxx,v
retrieving revision 1.6
retrieving revision 1.6.84.5
diff -u -p -u -p -r1.6 -r1.6.84.5
--- configmgr/source/treecache/cacheaccess.hxx	8 Sep 2005 04:21:46 -0000	1.6
+++ configmgr/source/treecache/cacheaccess.hxx	16 Jan 2007 12:18:23 -0000	1.6.84.5
@@ -48,8 +48,8 @@
 #ifndef _OSL_MUTEX_HXX_
 #include <osl/mutex.hxx>
 #endif
-#ifndef _SALHELPER_SIMPLEREFERENCEOBJECT_HXX_
-#include <salhelper/simplereferenceobject.hxx>
+#ifndef _CONFIGMGR_UTILITY_HXX_
+#include <utility.hxx>
 #endif
 #ifndef _RTL_REF_HXX_
 #include <rtl/ref.hxx>
@@ -67,23 +67,15 @@ namespace configmgr
     }
 //-----------------------------------------------------------------------------
 
-    class CacheClientAccess : public salhelper::SimpleReferenceObject, Noncopyable
+    class CacheClientAccess : public configmgr::SimpleReferenceObject, Noncopyable
 	{
-	public:
-        typedef CacheData   Data;
-        typedef Data::Module       Module;
-        typedef Data::ModuleRef    ModuleRef;
-        typedef Data::ModuleName   ModuleName;
-        typedef Data::Path         Path;
 	private:
-		osl::Mutex			m_aMutex;
-		Data			    m_aData;		
+	    CacheData   m_aData;
 
 		ConfigChangeBroadcastHelper* m_pBroadcastHelper;
 	public:
         explicit
-		CacheClientAccess(memory::HeapManager & _rHeapManager,
-                          ConfigChangeBroadcastHelper* _pBroadcastHelper);
+		CacheClientAccess(ConfigChangeBroadcastHelper* _pBroadcastHelper);
 
 		~CacheClientAccess();
 		
@@ -94,89 +86,74 @@ namespace configmgr
         /// removes an existing broadcast helper 
         ConfigChangeBroadcastHelper * releaseBroadcaster();
 
-        /// gets a data segment reference for the given path - creates if necessary
-        memory::Segment * attachDataSegment(const memory::SegmentAddress & _aSegment, const Path& _aLocation);
-        /// gets a data segment reference for the given path if exists
-        memory::Segment * getDataSegment(const Path& _aLocation);
-
 		/// return TRUE if there is no data (left) in this object's cache data 
 		bool isEmpty();
 
+        // attach a module with a given name
+        void attachModule(data::TreeAddress _aLocation, CacheLine::Name const & _aModule);
         /// check if the given module exists already (and is not empty)
-        bool hasModule(const Path& _aLocation);
+        bool hasModule(const CacheLine::Path& _aLocation);
         /// checks if the given module exists and has defaults available
-        bool hasModuleDefaults(memory::Accessor const & _aAccessor, Path const & _aLocation);
+        bool hasModuleDefaults(CacheLine::Path const & _aLocation);
 
 		/// retrieve the subtree at _aPath (maybe if it has the requested defaults) and clientAcquire() it
-		data::NodeAddress acquireNode(memory::Accessor const& _aAccessToken, Path const& _aPath); 
+		data::NodeAddress acquireNode(CacheLine::Path const& _aPath); 
 
 		/** add or merge the given subtree at the given location,
 			return <TRUE/> if the tree has defaults then
 		*/
-        bool insertDefaults(memory::UpdateAccessor& _aUpdateToken, backend::NodeInstance const & _aDefaultData ) CFG_UNO_THROW_RTE(  );
+        bool insertDefaults( backend::NodeInstance const & _aDefaultData ) CFG_UNO_THROW_RTE(  );
 
 		/// clientRelease() the tree at aComponentName, and return the resulting reference count
-        CacheLine::RefCount releaseNode( Path const& _aPath ); 
+        oslInterlockedCount releaseNode( CacheLine::Path const& _aPath ); 
 
 		/// retrieve the given subtree without changing its ref count
-		data::NodeAddress	findInnerNode(memory::Accessor const& _aAccessToken, Path const& _aPath );
+		data::NodeAddress	findInnerNode(CacheLine::Path const& _aPath );
 
 		/// merge the given change list into this tree - reflects old data to _aUpdate
-        void applyUpdate(memory::UpdateAccessor& _aUpdateToken,  backend::UpdateInstance & _aUpdate) CFG_UNO_THROW_RTE( );	
+        void applyUpdate(backend::UpdateInstance & _aUpdate) CFG_UNO_THROW_RTE( );	
 	};
 
 
 ////////////////////////////////////////////////////////////////////////////////
 	
-    class CacheLoadingAccess : public salhelper::SimpleReferenceObject, Noncopyable
+    class CacheLoadingAccess : public configmgr::SimpleReferenceObject, Noncopyable
 	{
-	public:
-        typedef ExtendedCacheData  Data;
-        typedef Data::Module       Module;
-        typedef Data::ModuleRef    ModuleRef;
-        typedef Data::ModuleName   ModuleName;
-        typedef Data::Path         Path;
-
-		typedef std::vector< ModuleRef >  DisposeList;
+    public:
+		typedef std::vector< CacheLineRef >  DisposeList;
         friend class backend::CacheController;
 	private:
         friend class CacheDisposeScheduler;
-        typedef std::map< ModuleName, TimeStamp > DeadModuleList;
+        typedef std::map< CacheLine::Name, TimeStamp > DeadModuleList;
 
-		osl::Mutex			m_aMutex;
-		Data			    m_aData;		
+		ExtendedCacheData   m_aData;		
 		DeadModuleList		m_aDeadModules;			/// list of nodes which are registered for throwing away
 	public:
         explicit
-		CacheLoadingAccess(memory::HeapManager & _rHeapManager);
+		CacheLoadingAccess();
 		~CacheLoadingAccess();
 		
-        /// gets a data segment reference for the given path if exists
-        memory::Segment * createNewDataSegment(ModuleName const & _aModule);
-        /// gets a data segment reference for the given path - creates if necessary
-        memory::Segment * attachDataSegment(const memory::SegmentAddress & _aSegment, ModuleName const & _aModule);
-        /// gets a data segment reference for the given path if exists
-        memory::Segment * getDataSegment(ModuleName const & _aModule);
-        /// gets a data segment address for the given module if it exists
-        memory::SegmentAddress getDataSegmentAddress(ModuleName const & _aModule);
+        /// gets a tree address for the given module if it exists
+        data::TreeAddress getTreeAddress(CacheLine::Name const & _aModule);
 
 		/// return TRUE if there is no data (left) in this object's cache data 
 		bool isEmpty();
 
+        // create a module with a given name
+        void createModule(CacheLine::Name const & _aModule);
         /// check if the given module exists already (and is not empty)
-        bool hasModule(ModuleName const & _aLocation);
-
-		/// retrieve the subtree at aComponentName and clientAcquire() it
-		data::TreeAddress acquireModule(ModuleName const & _aModule); 
+        bool hasModule(CacheLine::Name const & _aLocation);
+		/// retrieve the subtree at aComponentName and clientAcquire() it, true if succeeded
+		bool acquireModule(CacheLine::Name const & _aModule); 
 
 		/// clientRelease() the tree at aComponentName, and return the resulting reference count
-        CacheLine::RefCount releaseModule( ModuleName const & _aModule ); 
+        oslInterlockedCount releaseModule( CacheLine::Name const & _aModule ); 
 
 		/// retrieve the given subtree without changing its ref count
-		data::NodeAddress	findNode(memory::Accessor const& _aAccessToken, Path const& _aPath );
+		data::NodeAddress	findNode(CacheLine::Path const& _aPath );
 
 		/// merge the given change list into this tree - reflects old data to _aUpdate
-        void applyUpdate(memory::UpdateAccessor& _aUpdateToken,  backend::UpdateInstance & _aUpdate) CFG_UNO_THROW_RTE( );	
+        void applyUpdate(backend::UpdateInstance & _aUpdate) CFG_UNO_THROW_RTE( );	
 
         /// collect the modules that can be disposed now (i.e. released after _rLimitReleaseTime)
         TimeStamp collectDisposeList(CacheLoadingAccess::DisposeList & _rList, 
@@ -190,21 +167,17 @@ namespace configmgr
 		/** add the given subtree at the given location,
 			return the tree that is then pertinent and clientAcquire() it once
 		*/
-        data::TreeAddress addComponentData( memory::UpdateAccessor& _aAccessToken, 
-                                            backend::ComponentInstance const & _aComponentInstance, 
+        data::TreeAddress addComponentData( backend::ComponentInstance const & _aComponentInstance, 
                                             bool _bIncludesDefaults
                                            ) CFG_UNO_THROW_RTE();
 
 		/// merge the given change list into the pending change list of this tree
 		void addChangesToPending( backend::ConstUpdateInstance const& _anUpdate ) CFG_UNO_THROW_RTE(  );
 		/// retrieve accumulated pending changes
-		std::auto_ptr<SubtreeChange> releasePendingChanges(ModuleName const& _aModule);
+		std::auto_ptr<SubtreeChange> releasePendingChanges(CacheLine::Name const& _aModule);
 
         /// find the modules having pending changes
-        bool findPendingChangedModules( Data::PendingModuleList & _rPendingList );
-
-        /// get a local lock for this cache line
-        osl::Mutex & mutex() { return m_aMutex; }
+        bool findPendingChangedModules( ExtendedCacheData::PendingModuleList & _rPendingList );
 	};
 
 
Index: configmgr/source/treecache/cachecontroller.cxx
===================================================================
RCS file: /cvs/util/configmgr/source/treecache/cachecontroller.cxx,v
retrieving revision 1.18
retrieving revision 1.18.24.7
diff -u -p -u -p -r1.18 -r1.18.24.7
--- configmgr/source/treecache/cachecontroller.cxx	16 Sep 2006 15:24:50 -0000	1.18
+++ configmgr/source/treecache/cachecontroller.cxx	7 Feb 2007 12:00:33 -0000	1.18.24.7
@@ -45,15 +45,6 @@
 #include "cachewritescheduler.hxx"
 #endif
 
-#ifndef CONFIGMGR_ACCESSOR_HXX
-#include "accessor.hxx"
-#endif
-#ifndef CONFIGMGR_UPDATEACCESSOR_HXX
-#include "updateaccessor.hxx"
-#endif
-#ifndef CONFIGMGR_TREEADDRESS_HXX
-#include "treeaddress.hxx"
-#endif
 #ifndef CONFIGMGR_TREEACCESSOR_HXX
 #include "treeaccessor.hxx"
 #endif
@@ -142,43 +133,33 @@ OCacheWriteScheduler* CacheController::c
 
 CacheController::CacheRef CacheController::getCacheAlways(RequestOptions const & _aOptions)
 {
-    osl::MutexGuard aGuard( m_aCacheList.mutex() );
-
-    CacheRef aResult = m_aCacheList.get(_aOptions);
+    CacheRef aResult = m_aCacheMap.get(_aOptions);
     if (!aResult.is())
     {
-        CacheRef aNewCache( new Cache(getCacheHeapManager()) );
-        aResult = m_aCacheList.insert(_aOptions,aNewCache);
+        CacheRef aNewCache( new Cache() );
+        aResult = m_aCacheMap.insert(_aOptions,aNewCache);
     }
     return aResult;
 }
 
 // -------------------------------------------------------------------------
 
-memory::HeapManager & CacheController::getCacheHeapManager() const
-{
-    return m_aTemplates.getHeapManager();
-}
-// -------------------------------------------------------------------------
-
 // disposing
 // -------------------------------------------------------------------------
 void CacheController::disposeAll(bool _bFlushRemainingUpdates)
 {
 	CFG_TRACE_INFO("CacheController: Disposing all data" );
-    CacheList::Map aReleaseList;
+    CacheMap::Map aReleaseList;
 
 	if (m_pDisposer)
 	{
-		osl::MutexGuard aShotGuard(m_pDisposer->getShotMutex());
-		osl::MutexGuard aGuard(m_aCacheList.mutex());
 		m_pDisposer->stopAndClearTasks();
-		m_aCacheList.swap(aReleaseList); // move data out of m_aCacheList and empty m_aCacheList
+		m_aCacheMap.swap(aReleaseList); // move data out of m_aCacheMap and empty m_aCacheMap
 	}
 
     if (_bFlushRemainingUpdates)
     {
-        for (CacheList::Map::iterator it = aReleaseList.begin(); it != aReleaseList.end(); ++it)
+        for (CacheMap::Map::iterator it = aReleaseList.begin(); it != aReleaseList.end(); ++it)
             saveAllPendingChanges(it->second,it->first);
     }
 	// free all the trees
@@ -188,6 +169,8 @@ void CacheController::disposeAll(bool _b
 // -------------------------------------------------------------------------
 void CacheController::dispose() CFG_UNO_THROW_RTE()
 {
+    UnoApiLock aLock;
+
 	CFG_TRACE_INFO("CacheController: dispose()" );
 
 	RTL_LOGFILE_CONTEXT_AUTHOR(aLog, "configmgr::backend::CacheController", "jb99855", "configmgr: CacheController::dispose(), disable lazy write cache.");
@@ -203,8 +186,6 @@ void CacheController::dispose() CFG_UNO_
 // -------------------------------------------------------------------------
 void CacheController::disposeOne(RequestOptions const & _aOptions, bool _bFlushUpdates)
 {
-	osl::ClearableMutexGuard aGuard(m_aCacheList.mutex());
-
 	CFG_TRACE_INFO("CacheController: Disposing data and TreeInfo for user '%s' with locale '%s'",
 					OUSTRING2ASCII(_aOptions.getEntity()), OUSTRING2ASCII(_aOptions.getLocale()) );
 
@@ -218,12 +199,11 @@ void CacheController::disposeOne(Request
 		CFG_TRACE_WARNING_NI("Found orphaned Changes in the cache - Discarding.");
     }
 
-    CacheRef aRemoved = m_aCacheList.remove(_aOptions);
+    CacheRef aRemoved = m_aCacheMap.remove(_aOptions);
 	
 	if (aRemoved.is())
 	{
 		// got it out of reachability - now dispose/notify without lock
-		aGuard.clear();
 		implDisposeOne(aRemoved, _aOptions, _bFlushUpdates);
 	}
 	else
@@ -233,8 +213,6 @@ void CacheController::disposeOne(Request
 // -------------------------------------------------------------------------
 void CacheController::disposeUser(RequestOptions const & _aUserOptions, bool _bFlushUpdates)
 {
-	osl::ClearableMutexGuard aGuard(m_aCacheList.mutex());
-
 	CFG_TRACE_INFO("CacheController: Disposing data and TreeInfo(s) for user '%s'",
 					OUSTRING2ASCII(_aUserOptions.getEntity()) );
 
@@ -250,14 +228,14 @@ void CacheController::disposeUser(Reques
 		// so that all options belonging to one user are together
 		// (and that options with only a user set, sort first)
 
-        CacheList::Map aCacheData;
-        m_aCacheList.swap(aCacheData);
+        CacheMap::Map aCacheData;
+        m_aCacheMap.swap(aCacheData);
 
 		// find the lower_bound of all options for the user
-		CacheList::Map::iterator const aFirst = aCacheData.lower_bound(_aUserOptions);
+		CacheMap::Map::iterator const aFirst = aCacheData.lower_bound(_aUserOptions);
 
 		// find the upper_bound of all options for the user (using the lower one)
-		CacheList::Map::iterator aLast = aFirst;
+		CacheMap::Map::iterator aLast = aFirst;
 		while (aLast != aCacheData.end() && aLast->first.getEntity() == sUser)
 			++aLast;
 
@@ -267,7 +245,7 @@ void CacheController::disposeUser(Reques
 
 			bool bHasPendingChanges = false;
 
-			for (CacheList::Map::iterator it = aFirst; it != aLast; ++it)
+			for (CacheMap::Map::iterator it = aFirst; it != aLast; ++it)
 			{
 				CFG_TRACE_INFO_NI("- Found TreeInfo for locale '%s'", OUSTRING2ASCII(it->first.getLocale()) );
 				m_pDisposer->clearTasks(it->first);
@@ -295,12 +273,10 @@ void CacheController::disposeUser(Reques
 			CFG_TRACE_INFO_NI("- No affected TreeInfo found" );
 
         // replace the data into the map
-        m_aCacheList.swap(aCacheData);
+        m_aCacheMap.swap(aCacheData);
 	}
 
 	// got all out of external reach - now dispose/notify without lock
-	aGuard.clear();
-
 	for (DisposeList::iterator i = aDisposeList.begin(); i != aDisposeList.end(); ++i)
 	{
 		if (i->second.is())
@@ -343,12 +319,11 @@ void CacheController::implDisposeOne(Cac
 
 // -------------------------------------------------------------------------
 CacheController::CacheController(BackendRef const & _xBackend, 
-								 memory::HeapManager & _rCacheHeapManager,
 								 const uno::Reference<uno::XComponentContext>& xContext)
 : m_aNotifier()
 , m_xBackend(_xBackend)
-, m_aCacheList()
-, m_aTemplates(_rCacheHeapManager)
+, m_aCacheMap()
+, m_aTemplates()
 , m_pDisposer()
 , m_pCacheWriter()
 , m_bDisposing(false)
@@ -406,22 +381,7 @@ std::auto_ptr<ISubtree> reduceSubtreeFor
     return aRet;
 }
 #endif
-// -------------------------------------------------------------------------
-
-static
-CacheLocation makeCacheLocation(memory::SegmentAddress const & _aSegment, memory::Heap::Address const & _anAddress)
-{
-    OSL_PRECOND(!_aSegment.isNull() || _anAddress == 0,"ERROR: Got Non-null address for NULL segment ?!");
-
-    CacheLocation aResult;
-
-    aResult.segment = _aSegment;
-    aResult.address = _anAddress;
 
-    OSL_ASSERT(!_aSegment.isNull() || aResult.isNull());
-
-    return aResult;
-}
 // -------------------------------------------------------------------------
 CacheLocation CacheController::loadComponent(ComponentRequest const & _aRequest)
 {
@@ -434,9 +394,6 @@ CacheLocation CacheController::loadCompo
 
 	OSL_ENSURE(aCache.is(), "Could not create CacheAccess");
 
-    osl::MutexGuard aCacheLineGuard(aCache->mutex());
-
-    data::TreeAddress aResultAddress;
     data::TreeAddress aTemplateResultAdddress;
 
 	OSL_ENSURE(!_aRequest.isForcingReload(),"CacheController: No support for forced requests");
@@ -447,30 +404,27 @@ CacheLocation CacheController::loadCompo
         {
             refreshComponent(_aRequest);
         }
-        aResultAddress = aCache->acquireModule(_aRequest.getComponentName());
+        aCache->acquireModule(_aRequest.getComponentName());
     }
     else
-	{
+    {
         ComponentResult aData = this->loadDirectly(_aRequest,true);
 
         bool bWithDefaults = ! m_xBackend->isStrippingDefaults();
 
 		CFG_TRACE_INFO_NI("CacheController: adding loaded data to the cache");
 
-        memory::UpdateAccessor aTargetSpace( aCache->createNewDataSegment(_aRequest.getComponentName()) );
+        aCache->createModule(_aRequest.getComponentName());
 
-        aResultAddress = aCache->addComponentData(aTargetSpace, aData.instance(), bWithDefaults);
+        aCache->addComponentData(aData.instance(), bWithDefaults);
         if (aData.instance().templateData().get()!=NULL)
-        {
-            aTemplateResultAdddress = addTemplates(aData.mutableInstance().componentTemplateData () );
-        }
+            aTemplateResultAdddress = addTemplates(aData.mutableInstance().componentTemplateData() );
+
         // notify the new data to all clients
         m_aNotifier.notifyCreated(_aRequest);
 	}
 
-    return makeCacheLocation( aCache->getDataSegmentAddress(_aRequest.getComponentName()),
-                              aResultAddress.addressValue());
-
+    return aCache->getTreeAddress(_aRequest.getComponentName());
 }
 // -------------------------------------------------------------------------
 
@@ -478,11 +432,10 @@ ComponentResult CacheController::getComp
 												  bool _bAddListenter ) CFG_UNO_THROW_ALL()
 {
     // TODO: Insert check here, if the data is in the cache already - and then clone
-	RTL_LOGFILE_CONTEXT_AUTHOR(aLog, "configmgr::backend::CacheController", "jb99855", "configmgr: CacheController::getComponentData()");
-	RTL_LOGFILE_CONTEXT_TRACE1(aLog, "component: %s", RTL_LOGFILE_OU2A(_aRequest.getComponentName().toString()) );
+    RTL_LOGFILE_CONTEXT_AUTHOR(aLog, "configmgr::backend::CacheController", "jb99855", "configmgr: CacheController::getComponentData()");
+    RTL_LOGFILE_CONTEXT_TRACE1(aLog, "component: %s", RTL_LOGFILE_OU2A(_aRequest.getComponentName().toString()) );
 
-    
-	ComponentResult aRet = this->loadDirectly(_aRequest, _bAddListenter);
+    ComponentResult aRet = this->loadDirectly(_aRequest, _bAddListenter);
 
     return aRet;
 }
@@ -491,8 +444,8 @@ ComponentResult CacheController::getComp
 NodeResult CacheController::getDefaultData(NodeRequest const & _aRequest) CFG_UNO_THROW_ALL(  )
 {
     // TODO: Insert check here, if the data is in the cache already - and then clone
-	RTL_LOGFILE_CONTEXT_AUTHOR(aLog, "configmgr::backend::CacheController", "jb99855", "configmgr: CacheController::getDefaultData()");
-	RTL_LOGFILE_CONTEXT_TRACE1(aLog, "path: %s", RTL_LOGFILE_OU2A(_aRequest.getPath().toString()) );
+    RTL_LOGFILE_CONTEXT_AUTHOR(aLog, "configmgr::backend::CacheController", "jb99855", "configmgr: CacheController::getDefaultData()");
+    RTL_LOGFILE_CONTEXT_TRACE1(aLog, "path: %s", RTL_LOGFILE_OU2A(_aRequest.getPath().toString()) );
 
     NodeResult aRet = this->loadDefaultsDirectly(_aRequest);
 
@@ -514,7 +467,7 @@ AbsolutePath CacheController::encodeTemp
     aResult.prepend(aTemplateModule);
 //    aResult.prepend(aTemplateRoot);
 
-	return AbsolutePath(aResult);
+    return AbsolutePath(aResult);
 }
 // -------------------------------------------------------------------------
 #if 0
@@ -563,17 +516,17 @@ std::auto_ptr<ISubtree> CacheController:
 data::TreeAddress CacheController::addTemplates ( backend::ComponentData const & _aComponentInstance )
 {
     OSL_PRECOND(_aComponentInstance.data.get(), "addTemplates: Data must not be NULL");
-    osl::MutexGuard aGuard(m_aTemplatesMutex);
-    TemplateCacheData::ModuleName aModuleName = _aComponentInstance.name;
-    memory::UpdateAccessor aTemplatesUpdater( m_aTemplates.createDataSegment(aModuleName) );
+    CacheLine::Name aModuleName = _aComponentInstance.name;
+    m_aTemplates.createModule(aModuleName);
     AbsolutePath aTemplateLocation = AbsolutePath::makeModulePath(_aComponentInstance.name , AbsolutePath::NoValidate());
-    data::TreeAddress aTemplateAddr;
-    if (!m_aTemplates.hasNode(aTemplatesUpdater.accessor(),aTemplateLocation ))
+    data::TreeAddress aTemplateAddr = NULL;
+
+    if (!m_aTemplates.hasNode(aTemplateLocation ))
     {
         CFG_TRACE_INFO_NI("CacheController: cache miss for that template - loading from backend");
-        aTemplateAddr = m_aTemplates.addTemplates(aTemplatesUpdater, _aComponentInstance );
+        aTemplateAddr = m_aTemplates.addTemplates(_aComponentInstance );
     }
-    OSL_ASSERT (aTemplateAddr.is());
+    OSL_ASSERT (aTemplateAddr != NULL);
     return aTemplateAddr;
  }
 // -------------------------------------------------------------------------
@@ -591,15 +544,13 @@ CacheLocation CacheController::loadTempl
 
     AbsolutePath aTemplateLocation = encodeTemplateLocation(_aRequest.getTemplateName(), _aRequest.getComponentName());
 
-    TemplateCacheData::ModuleName aModuleName =  aTemplateLocation.getModuleName();
-    osl::MutexGuard aGuard(m_aTemplatesMutex);
-    memory::Accessor aTemplatesAccessor( m_aTemplates.getDataSegment(aModuleName) );
+    CacheLine::Name aModuleName =  aTemplateLocation.getModuleName();
+
     AbsolutePath aTemplateParent (aTemplateLocation.getParentPath());
 
     //Load-if-not-there (componentwise)
-    if (!m_aTemplates.hasNode(aTemplatesAccessor, aTemplateParent))
+    if (!m_aTemplates.hasNode(aTemplateParent))
     {
-        aTemplatesAccessor.clear();
         OSL_ENSURE(aTemplateLocation.getDepth() > 1, "CacheController::ensureTemplate : invalid template location !");
 	    TemplateRequest aTemplateRequest = TemplateRequest::forComponent(_aRequest.getComponentName());
 
@@ -608,40 +559,33 @@ CacheLocation CacheController::loadTempl
         addTemplates(backend::ComponentData(aMultiTemplates, aModuleName));
 
     }
-    memory::Accessor aTemplateAccessor( m_aTemplates.getDataSegment(aModuleName) );
-    data::TreeAddress aTemplateAddr = m_aTemplates.getTemplateTree(aTemplateAccessor,aTemplateLocation);
-	if (aTemplateAddr.isNull())
-		throw uno::Exception(::rtl::OUString::createFromAscii("Unknown template. Type description could not be found in the given module."), NULL);
+    data::TreeAddress aTemplateAddr = m_aTemplates.getTemplateTree(aTemplateLocation);
+    if (aTemplateAddr == NULL)
+        throw uno::Exception(::rtl::OUString::createFromAscii("Unknown template. Type description could not be found in the given module."), NULL);
 
-    return makeCacheLocation( m_aTemplates.getDataSegmentAddress(aTemplateLocation.getModuleName()) , aTemplateAddr.addressValue());
+    return m_aTemplates.getTreeAddress(aTemplateLocation.getModuleName());
 }
 // -----------------------------------------------------------------------------
 
 TemplateResult CacheController::getTemplateData(TemplateRequest const & _aRequest)
     CFG_UNO_THROW_ALL()
 {
-	RTL_LOGFILE_CONTEXT_AUTHOR(aLog, "configmgr::backend::CacheController", "jb99855", "configmgr: CacheController::getTemplateData()");
-	RTL_LOGFILE_CONTEXT_TRACE2(aLog, "requested template: %s/%s",
-                                    RTL_LOGFILE_OU2A(_aRequest.getComponentName().toString()) ,
-                                    _aRequest.isComponentRequest() ?
-                                        "*" : RTL_LOGFILE_OU2A(_aRequest.getComponentName().toString()) );
-
-
+    RTL_LOGFILE_CONTEXT_AUTHOR(aLog, "configmgr::backend::CacheController", "jb99855", "configmgr: CacheController::getTemplateData()");
+    RTL_LOGFILE_CONTEXT_TRACE2(aLog, "requested template: %s/%s",
+			       RTL_LOGFILE_OU2A(_aRequest.getComponentName().toString()) ,
+			       _aRequest.isComponentRequest() ?
+			       "*" : RTL_LOGFILE_OU2A(_aRequest.getComponentName().toString()) );
 
     AbsolutePath aTemplateLocation = encodeTemplateLocation(_aRequest.getTemplateName(), _aRequest.getComponentName());
 
     loadTemplate(_aRequest);
     //AbsolutePath aTemplateLocation = ensureTemplate(_aRequest.getTemplateName(), _aRequest.getComponentName());
 
-    memory::Segment * pTemplatesSegment = m_aTemplates.getDataSegment(aTemplateLocation.getModuleName());
-
-    memory::Accessor aTemplatesAccessor( pTemplatesSegment );
-
-    data::TreeAddress aTemplateAddr = m_aTemplates.getTemplateTree(aTemplatesAccessor,aTemplateLocation);
-	if (aTemplateAddr.isNull())
-		throw uno::Exception(::rtl::OUString::createFromAscii("Unknown template. Type description could not be found in the given module."), NULL);
+    data::TreeAddress aTemplateAddr = m_aTemplates.getTemplateTree(aTemplateLocation);
+    if (aTemplateAddr == NULL)
+	throw uno::Exception(::rtl::OUString::createFromAscii("Unknown template. Type description could not be found in the given module."), NULL);
 
-    data::TreeAccessor aTemplateTree(aTemplatesAccessor,aTemplateAddr);
+    data::TreeAccessor aTemplateTree(aTemplateAddr);
 
     std::auto_ptr<INode> aResultTree = data::convertTree(aTemplateTree, true);
 
@@ -661,7 +605,7 @@ void CacheController::saveAndNotify(Upda
 	    // caller must own a read lock on this cache line
 	    CFG_TRACE_INFO("CacheController: saving an update for '%s'",OUSTRING2ASCII(_anUpdate.getUpdateRoot().toString()));
 
-        CacheRef aCache = m_aCacheList.get(_anUpdate.getOptions());
+        CacheRef aCache = m_aCacheMap.get(_anUpdate.getOptions());
 
 	    OSL_ENSURE(aCache.is(), "No cache data to update in saveAndNotify");
 
@@ -697,11 +641,9 @@ void CacheController::saveAndNotify(Upda
 
 void CacheController::flushPendingUpdates()CFG_UNO_THROW_ALL()
 {
-    osl::ClearableMutexGuard aGuard(m_aCacheList.mutex());
-    CacheList::Map aFlushList = m_aCacheList.copy();
-    aGuard.clear();
+    CacheMap::Map aFlushList = m_aCacheMap.copy();
 
-    for (CacheList::Map::iterator it = aFlushList.begin(); it != aFlushList.end(); ++it)
+    for (CacheMap::Map::iterator it = aFlushList.begin(); it != aFlushList.end(); ++it)
         saveAllPendingChanges(it->second,it->first);
 }
 
@@ -711,8 +653,6 @@ void CacheController::flushCacheWriter()
 
     if (m_pCacheWriter)
     {
-	    osl::MutexGuard aShotGuard(m_pCacheWriter->getShotMutex());
-
 	    CFG_TRACE_INFO("CacheController: flushing all pending updates");
 
 	    m_pCacheWriter->stopAndWriteCache();
@@ -754,13 +694,13 @@ bool CacheController::normalizeResult(st
 
 ComponentResult CacheController::loadDirectly(ComponentRequest const & _aRequest, bool _bAddListenter) CFG_UNO_THROW_ALL(  )
 {
-	CFG_TRACE_INFO("CacheController: loading data for component '%s' from the backend", OUSTRING2ASCII(_aRequest.getComponentName().toString()));
+    CFG_TRACE_INFO("CacheController: loading data for component '%s' from the backend", OUSTRING2ASCII(_aRequest.getComponentName().toString()));
 
     AbsolutePath aRequestPath = AbsolutePath::makeModulePath(_aRequest.getComponentName(), AbsolutePath::NoValidate());
 
     NodeRequest aNodeRequest(aRequestPath, _aRequest.getOptions());
 
-	ComponentResult aResult = m_xBackend->getNodeData(_aRequest, this, _bAddListenter?this:NULL);
+    ComponentResult aResult = m_xBackend->getNodeData(_aRequest, this, _bAddListenter?this:NULL);
 
     OSL_PRECOND(aResult.mutableInstance().mutableData().get(), "loadDirectly: Data must not be NULL");
 
@@ -768,7 +708,7 @@ ComponentResult CacheController::loadDir
 
     if (!normalizeResult( aResult.mutableInstance().mutableData(),_aRequest.getOptions()))
     {
-	    CFG_TRACE_ERROR_NI(" - cannot normalized result: failing");
+	CFG_TRACE_ERROR_NI(" - cannot normalized result: failing");
 
         OUString sMsg(RTL_CONSTASCII_USTRINGPARAM("Requested data at '"));
         sMsg += aRequestPath.toString();
@@ -777,7 +717,7 @@ ComponentResult CacheController::loadDir
         throw com::sun::star::container::NoSuchElementException(sMsg,NULL);
     }
 
-	CFG_TRACE_INFO_NI(" - returning normalized defaults");
+    CFG_TRACE_INFO_NI(" - returning normalized defaults");
 
     return aResult;
 }
@@ -785,15 +725,15 @@ ComponentResult CacheController::loadDir
 
 NodeResult CacheController::loadDefaultsDirectly(NodeRequest const & _aRequest) CFG_UNO_THROW_ALL(  )
 {
-	CFG_TRACE_INFO("CacheController: loading defaults for '%s' from the backend", OUSTRING2ASCII(_aRequest.getPath().toString()));
+    CFG_TRACE_INFO("CacheController: loading defaults for '%s' from the backend", OUSTRING2ASCII(_aRequest.getPath().toString()));
 
     NodeResult aResult = m_xBackend->getDefaultData(_aRequest);
 
-	CFG_TRACE_INFO_NI("- loading defaultscompleted - normalizing result");
+    CFG_TRACE_INFO_NI("- loading defaultscompleted - normalizing result");
 
     normalizeResult(aResult.mutableInstance().mutableData(),_aRequest.getOptions());
 
-	CFG_TRACE_INFO_NI(" - returning normalized defaults");
+    CFG_TRACE_INFO_NI(" - returning normalized defaults");
 
     return aResult;
 }
@@ -801,23 +741,23 @@ NodeResult CacheController::loadDefaults
 
 void CacheController::saveDirectly(UpdateRequest const & _anUpdate) CFG_UNO_THROW_ALL(  )
 {
-        m_xBackend->updateNodeData(_anUpdate);
+    m_xBackend->updateNodeData(_anUpdate);
 }
 // -----------------------------------------------------------------------------
 
 void CacheController::savePendingChanges(CacheRef const & _aCache, ComponentRequest const & _aComponent) CFG_UNO_THROW_ALL(  )
 {
-	CFG_TRACE_INFO("CacheController: saving updates for tree: '%s'", OUSTRING2ASCII(_aComponent.getComponentName().toString()));
+    CFG_TRACE_INFO("CacheController: saving updates for tree: '%s'", OUSTRING2ASCII(_aComponent.getComponentName().toString()));
 
-	try
-	{
-		CFG_TRACE_INFO2("CacheController: saving updates for tree: '%s'", OUSTRING2ASCII(_aComponent.getComponentName().toString()));
+    try
+    {
+	CFG_TRACE_INFO2("CacheController: saving updates for tree: '%s'", OUSTRING2ASCII(_aComponent.getComponentName().toString()));
 
-  		std::auto_ptr<SubtreeChange> aChangeData = _aCache->releasePendingChanges(_aComponent.getComponentName());
+	std::auto_ptr<SubtreeChange> aChangeData = _aCache->releasePendingChanges(_aComponent.getComponentName());
 
         if (aChangeData.get())
         {
-			CFG_TRACE_INFO_NI("- found changes - sending to backend");
+	    CFG_TRACE_INFO_NI("- found changes - sending to backend");
 
             AbsolutePath aRootPath = AbsolutePath::makeModulePath(_aComponent.getComponentName(), AbsolutePath::NoValidate());
 
@@ -827,23 +767,23 @@ void CacheController::savePendingChanges
 
             this->saveDirectly(anUpdateSpec);
 
-			CFG_TRACE_INFO_NI("- saving changes completed successfully");
+	    CFG_TRACE_INFO_NI("- saving changes completed successfully");
         }
         else
-			CFG_TRACE_WARNING_NI("- no changes found - cannot save");
-	}
-	catch(uno::Exception& e)
-	{
-            (void)e;
-		CFG_TRACE_ERROR_NI("CacheController: saving tree '%s' failed: %s",
-                                OUSTRING2ASCII(_aComponent.getComponentName().toString()),
-                                OUSTRING2ASCII(e.Message) );
+	    CFG_TRACE_WARNING_NI("- no changes found - cannot save");
+    }
+    catch(uno::Exception& e)
+    {
+	(void)e;
+	CFG_TRACE_ERROR_NI("CacheController: saving tree '%s' failed: %s",
+			   OUSTRING2ASCII(_aComponent.getComponentName().toString()),
+			   OUSTRING2ASCII(e.Message) );
 
-        this->invalidateComponent(_aComponent);
-		CFG_TRACE_INFO_NI("- component data invalidated");
+	this->invalidateComponent(_aComponent);
+	CFG_TRACE_INFO_NI("- component data invalidated");
 
-	    throw;
-	}
+	throw;
+    }
 }
 // -----------------------------------------------------------------------------
 
@@ -853,7 +793,7 @@ bool CacheController::saveAllPendingChan
     CFG_TRACE_INFO("CacheController: Saving all pending changes for cache line");
     OSL_ASSERT(_aCache.is());
 
-    typedef Cache::Data::PendingModuleList PMList;
+    typedef ExtendedCacheData::PendingModuleList PMList;
 
     PMList aPendingModules;
     _aCache->findPendingChangedModules(aPendingModules);
@@ -890,7 +830,7 @@ void CacheController::freeComponent(Comp
                     OUSTRING2ASCII(_aRequest.getOptions().getEntity()),
                     OUSTRING2ASCII(_aRequest.getOptions().getLocale()) );
 
-    CacheRef aCache = m_aCacheList.get(_aRequest.getOptions());
+    CacheRef aCache = m_aCacheMap.get(_aRequest.getOptions());
 
     OSL_ENSURE(aCache.is(), "Releasing a nonexisting module");
 
@@ -911,11 +851,9 @@ void CacheController::dataChanged(const 
 // -----------------------------------------------------------------------------
 void CacheController::refreshAllComponents() CFG_UNO_THROW_ALL()
 {
-    osl::ClearableMutexGuard aGuard(m_aCacheList.mutex());
-    CacheList::Map aRefreshList = m_aCacheList.copy();
-    aGuard.clear();
+    CacheMap::Map aRefreshList = m_aCacheMap.copy();
 
-    for (CacheList::Map::iterator i = aRefreshList.begin(); 
+    for (CacheMap::Map::iterator i = aRefreshList.begin(); 
         i != aRefreshList.end(); ++i)
 	{
         if (!i->second->isEmpty())
@@ -946,45 +884,6 @@ void CacheController::refreshAllComponen
         }
     }
 }
-// INotifyListener
-// ----------------------------------------------------------------------------
-/*
-void CacheController::nodeUpdated(TreeChangeList& _rChanges)
-{
-	CFG_TRACE_INFO("cache manager: updating the tree from a notification");
-	try
-	{
-		if (TreeInfo* pInfo = requestTreeInfo(_rChanges.getOptions(),false))
-		{
-			// first approve the changes and merge them with the current tree
-			AbsolutePath aSubtreeName = _rChanges.getRootNodePath();
-
-            memory::UpdateAccessor aUpdateAccess( pInfo->getDataSegment(aSubtreeName) );
-            OSL_ENSURE(aUpdateAccess.is(), "CacheController::nodeUpdated : missing cache line!");
-
-            data::NodeAddress aCacheTree = pInfo->getSubtree(aUpdateAccess.accessor(),aSubtreeName);
-            OSL_ENSURE(aCacheTree.is(), "CacheController::nodeUpdated : node not found in cache!");
-
-			if (aCacheTree.is())
-			{
-				if (adjustUpdate(_rChanges,aUpdateAccess,aCacheTree))
-                {
-					pInfo->updateTree(aUpdateAccess,_rChanges);
-
-                    data::Accessor aNotifyLock = aUpdateAccess.downgrade(); // keep a read lock during notification
-
-			        notifyUpdate(aNotifyLock,_rChanges);
-                }
-			}
-		}
-	}
-	catch (uno::RuntimeException&)
-	{
-		CFG_TRACE_ERROR("CacheController::nodeUpdated : could not insert notifications, data may be inconsistent !");
-	}
-}
-*/
-
 
 // -------------------------------------------------------------------------
     } // namespace
Index: configmgr/source/treecache/cachecontroller.hxx
===================================================================
RCS file: /cvs/util/configmgr/source/treecache/cachecontroller.hxx,v
retrieving revision 1.10
retrieving revision 1.10.84.3
diff -u -p -u -p -r1.10 -r1.10.84.3
--- configmgr/source/treecache/cachecontroller.hxx	8 Sep 2005 04:22:14 -0000	1.10
+++ configmgr/source/treecache/cachecontroller.hxx	12 Jan 2007 11:48:33 -0000	1.10.84.3
@@ -85,7 +85,7 @@ namespace configmgr
 
     : public ICachedDataProvider
     , public IDirectDataProvider // Refcounted
-	, public INodeDataListener
+    , public INodeDataListener
 	{
         typedef backend::IMergedDataProvider Backend;
         typedef rtl::Reference< Backend > BackendRef;
@@ -96,7 +96,6 @@ namespace configmgr
 		*/
         explicit
         CacheController(BackendRef const & _xBackend, 
-						memory::HeapManager & _rCacheHeapManager,
 						const uno::Reference<uno::XComponentContext>& xContext);
 
     // ICachedDataProvider implementation
@@ -309,8 +308,6 @@ namespace configmgr
 	protected:
 		// ref counted, that's why no public dtor
 		~CacheController();
-
-        memory::HeapManager & getCacheHeapManager() const;
     // implementation 
     private:
         typedef CacheLoadingAccess      Cache;
@@ -364,17 +361,12 @@ namespace configmgr
  
         void closeModules(Cache::DisposeList & _aList, RequestOptions const & _aOptions);
     private:
-        typedef AutoReferenceMap<RequestOptions,Cache,lessRequestOptions>   CacheList;
-        typedef TemplateCacheData TemplateCache;
-
+        typedef AutoReferenceMap<RequestOptions,Cache,lessRequestOptions>   CacheMap;
 
         CacheChangeMulticaster  m_aNotifier;
-		BackendRef			    m_xBackend;  
-
-		CacheList				m_aCacheList; // Map
-		TemplateCache			m_aTemplates;
-		
-        osl::Mutex              m_aTemplatesMutex;
+        BackendRef		m_xBackend;  
+        CacheMap		m_aCacheMap;
+        TemplateCacheData	m_aTemplates;
 
 		OTreeDisposeScheduler*	m_pDisposer;
 		OCacheWriteScheduler *  m_pCacheWriter;
Index: configmgr/source/treecache/cachedata.cxx
===================================================================
RCS file: /cvs/util/configmgr/source/treecache/cachedata.cxx,v
retrieving revision 1.7
retrieving revision 1.7.24.5
diff -u -p -u -p -r1.7 -r1.7.24.5
--- configmgr/source/treecache/cachedata.cxx	16 Sep 2006 15:25:09 -0000	1.7
+++ configmgr/source/treecache/cachedata.cxx	16 Jan 2007 12:18:23 -0000	1.7.24.5
@@ -38,17 +38,8 @@
 
 #include "cachedata.hxx"
 
-#ifndef CONFIGMGR_ACCESSOR_HXX
-#include "accessor.hxx"
-#endif
-#ifndef CONFIGMGR_UPDATEACCESSOR_HXX
-#include "updateaccessor.hxx"
-#endif
-#ifndef CONFIGMGR_NODEADDRESS_HXX
-#include "nodeaddress.hxx"
-#endif
-#ifndef CONFIGMGR_TREEADDRESS_HXX
-#include "treeaddress.hxx"
+#ifndef INCLUDED_SHARABLE_NODE_HXX
+#include "node.hxx"
 #endif
 #ifndef CONFIGMGR_NODEACCESS_HXX
 #include "nodeaccess.hxx"
@@ -120,15 +111,14 @@ namespace configmgr
 	};
 
 // -----------------------------------------------------------------------------
-    static inline CacheData::ModuleName implExtractModuleName(CacheData::Path const& aConfigPath)
+    static inline CacheLine::Name implExtractModuleName(CacheLine::Path const& aConfigPath)
 	{
 		return aConfigPath.getModuleName();
 	}
 
 // -----------------------------------------------------------------------------
 	
-	CacheData::CacheData(memory::HeapManager & _rHeapManager)
-    : m_rHeapManager(_rHeapManager)
+	CacheData::CacheData()
 	{
 	}
 // -----------------------------------------------------------------------------
@@ -139,13 +129,13 @@ namespace configmgr
 	}
 // -----------------------------------------------------------------------------
 
-	CacheData::ModuleName CacheData::extractModuleName(Path const& _aPath)
+	CacheLine::Name CacheData::extractModuleName(CacheLine::Path const& _aPath)
 	{
 		return implExtractModuleName(_aPath);
 	}
 // -----------------------------------------------------------------------------
 	inline
-    CacheLineRef CacheData::internalGetModule(const ModuleName& _aModuleName ) const
+    CacheLineRef CacheData::internalGetModule(const CacheLine::Name& _aModuleName ) const
 	{
 		OSL_ASSERT(!_aModuleName.isEmpty());
 
@@ -155,14 +145,14 @@ namespace configmgr
 	}
 // -----------------------------------------------------------------------------
 	inline
-    CacheLineRef CacheData::internalGetModule(const Path&  _aPath) const
+    CacheLineRef CacheData::internalGetModule(const CacheLine::Path&  _aPath) const
 	{
 		return internalGetModule( implExtractModuleName(_aPath) );
 	}
 // -----------------------------------------------------------------------------
 
 	inline
-    void CacheData::internalAddModule(const ModuleName& _aName, const ModuleRef & _aModule)
+    void CacheData::internalAddModule(const CacheLine::Name& _aName, const CacheLineRef & _aModule)
 	{
 		//OSL_PRECOND(m_aModules.find(_aName) == m_aModules.end(), "ERROR: Module already present in CacheData");
 
@@ -173,50 +163,39 @@ namespace configmgr
 // -----------------------------------------------------------------------------
 // -----------------------------------------------------------------------------
 
-    CacheLineRef CacheData::internalAttachModule(const memory::SegmentAddress & _aLocation, const ModuleName& _aName) CFG_UNO_THROW_RTE(  )
+    CacheLineRef CacheData::internalAttachModule(data::TreeAddress _aLocation, const CacheLine::Name& _aName) CFG_UNO_THROW_RTE(  )
 	{
-        CacheLineRef aNewModule = doCreateAttachedModule(this->internalHeapManager(), _aLocation,_aName);
+        CacheLineRef aNewModule = doCreateAttachedModule(_aLocation,_aName);
 
 		internalAddModule( _aName, aNewModule );
 		
 		return aNewModule;
 	}
-// -----------------------------------------------------------------------------
 
-    /// creates a new data segment reference for the given path - creates if necessary
-    memory::Segment * CacheData::attachDataSegment(memory::SegmentAddress const & _aLocation, ModuleName const & _aModule)
-    {
-        CacheLineRef aModule = this->internalAttachModule(_aLocation,_aModule);
-
-        return aModule.is() ? aModule->getDataSegment() : NULL;
-    }
 // -------------------------------------------------------------------------
 
-    CacheLineRef CacheData::doCreateAttachedModule(memory::HeapManager & _rHeapManager, const memory::SegmentAddress & _aLocation, const ModuleName& _aName) CFG_UNO_THROW_RTE(  )
+    void CacheData::attachModule(data::TreeAddress _aLocation, CacheLine::Name const & _aModule)
     {
-        return CacheLine::createAttached( _aName, _rHeapManager, _aLocation ); 
+        this->internalAttachModule(_aLocation,_aModule);
     }
-// -----------------------------------------------------------------------------
+// -------------------------------------------------------------------------
 
-    /// gets a data segment reference for the given path if exists
-    memory::Segment * CacheData::getDataSegment(const ModuleName & _aModule)
+    CacheLineRef CacheData::doCreateAttachedModule(data::TreeAddress _aLocation, const CacheLine::Name& _aName) CFG_UNO_THROW_RTE(  )
     {
-        CacheLineRef aModule = internalGetModule(_aModule);
-
-        return aModule.is() ? aModule->getDataSegment() : NULL;
+        return CacheLine::createAttached( _aName, _aLocation ); 
     }
-// -------------------------------------------------------------------------
+// -----------------------------------------------------------------------------
 
     /// gets a data segment reference for the given path if exists
-    memory::SegmentAddress CacheData::getDataSegmentAddress(const ModuleName & _aModule) const
+    data::TreeAddress CacheData::getTreeAddress(const CacheLine::Name & _aModule) const
     {
         CacheLineRef aModule = internalGetModule(_aModule);
 
-        return aModule.is() ? aModule->getDataSegmentAddress() : memory::SegmentAddress();
+        return aModule.is() ? aModule->getTreeAddress() : NULL;
     }
 // -------------------------------------------------------------------------
         
-    bool CacheData::hasModule(const ModuleName & _aModule) const
+    bool CacheData::hasModule(const CacheLine::Name & _aModule) const
     {
         CacheLineRef aModule = internalGetModule(_aModule);
 
@@ -224,27 +203,27 @@ namespace configmgr
     }
 // -------------------------------------------------------------------------
         
-    bool CacheData::hasModuleDefaults(memory::Accessor const & _aAccessor, const ModuleName & _aModule) const
+    bool CacheData::hasModuleDefaults(const CacheLine::Name & _aModule) const
     {
         CacheLineRef aModule = internalGetModule(_aModule);
 
-        return aModule.is() && !aModule->hasDefaults(_aAccessor);
+        return aModule.is() && !aModule->hasDefaults();
     }
 // -------------------------------------------------------------------------
 
-    data::TreeAddress CacheData::internalGetPartialTree(memory::Accessor const & _aAccessor, const Path& aComponentName ) const
-	{
-		CacheLineRef xModule = internalGetModule(aComponentName);
+    data::TreeAddress CacheData::internalGetPartialTree(const CacheLine::Path& aComponentName ) const
+    {
+	CacheLineRef xModule = internalGetModule(aComponentName);
 		
-		if ( !xModule.is() )
-            return data::TreeAddress();
+	if ( !xModule.is() )
+            return NULL;
 
-        data::TreeAddress pSubtree = xModule->getPartialTree(_aAccessor,aComponentName);
+        data::TreeAddress pSubtree = xModule->getPartialTree(aComponentName);
 
-		OSL_ENSURE( pSubtree.isNull() || xModule->clientReferences() != 0 , 
+		OSL_ENSURE( pSubtree == NULL || xModule->clientReferences() != 0 , 
 					"WARNING: returning subtree from module without clients\n" );
 #ifdef CFG_ENABLE_TRACING
-		if( pSubtree.is() && xModule->clientReferences() == 0) 
+		if( pSubtree != NULL && xModule->clientReferences() == 0) 
 		{
 			CFG_TRACE_WARNING("CacheData data: returning subtree %s from module without clients", OUSTRING2ASCII( aComponentName.toString() ) );
 		}
@@ -253,7 +232,7 @@ namespace configmgr
 		return pSubtree;	
 	}
 // -----------------------------------------------------------------------------
-    data::NodeAddress CacheData::internalGetNode(memory::Accessor const & _aAccessor, const Path& aComponentName ) const
+    data::NodeAddress CacheData::internalGetNode(const CacheLine::Path& aComponentName ) const
 	{
 		CacheLineRef xModule = internalGetModule(aComponentName);
 		
@@ -263,12 +242,12 @@ namespace configmgr
 		if ( xModule->isEmpty() )
             return data::NodeAddress();
 
-        data::NodeAddress pNode = xModule->getNode(_aAccessor,aComponentName);
+        data::NodeAddress pNode = xModule->getNode(aComponentName);
 
-		OSL_ENSURE( pNode.isNull() || xModule->clientReferences() != 0, 
+		OSL_ENSURE( pNode == NULL || xModule->clientReferences() != 0, 
 					"WARNING: returning node from module without clients\n" );
 	#ifdef CFG_ENABLE_TRACING
-		if( pNode.is() && xModule->clientReferences() == 0) 
+		if( pNode != NULL && xModule->clientReferences() == 0) 
 		{
 			CFG_TRACE_WARNING("CacheData data: returning node %s from module without clients", OUSTRING2ASCII( aComponentName.toString() ) );
 		}
@@ -278,43 +257,41 @@ namespace configmgr
 	}
 // -----------------------------------------------------------------------------
 // -----------------------------------------------------------------------------	
-    data::TreeAddress CacheData::acquireModule(ModuleName const & _aModule)
-	{
+    bool CacheData::acquireModule(CacheLine::Name const & _aModule)
+    {
         CacheLineRef xModule = internalGetModule(_aModule);
 
-		CacheLineClientRef aClientRef(xModule);
-
-        data::TreeAddress aModuleAddr = xModule.is() ? xModule->getModuleRootAddress() : data::TreeAddress();
-
-		if (aModuleAddr.is()) 
+        if (xModule.is())
+        {
+            CacheLineClientRef aClientRef(xModule);
             aClientRef.keep();
-
-        return aModuleAddr;
-	}
+        }
+        
+        return xModule.is();
+    }
 // -----------------------------------------------------------------------------	
-    data::NodeAddress CacheData::acquireNode(memory::Accessor const & _aAccessor, Path const& _aPath)
-	{
-		CacheLineClientRef aClientRef(internalGetModule(_aPath));
+    data::NodeAddress CacheData::acquireNode(CacheLine::Path const& _aPath)
+    {
+	CacheLineClientRef aClientRef(internalGetModule(_aPath));
 
-        data::NodeAddress aNodeAddr = internalGetNode(_aAccessor,_aPath);
+        data::NodeAddress aNodeAddr = internalGetNode(_aPath);
 
-        if (sharable::Node const * pNode = data::NodeAccess::access(aNodeAddr,_aAccessor))
-		{
+        if (sharable::Node const * pNode = aNodeAddr)
+	{
             if (pNode->isValue())
                 aNodeAddr = data::NodeAddress(); // invalid: cannot acquire single value
-		}
+	}
         else
-            OSL_ASSERT( !aNodeAddr.is() );
+            OSL_ASSERT( aNodeAddr == NULL );
 
-		if (aNodeAddr.is()) 
+		if (aNodeAddr != NULL) 
             aClientRef.keep();
 
         return aNodeAddr;
 	}
 // -----------------------------------------------------------------------------	
 
-    bool CacheData::insertDefaults( memory::UpdateAccessor& _aAccessToken, 
-                                    backend::NodeInstance const & _aDefaultInstance) CFG_UNO_THROW_RTE(  )
+    bool CacheData::insertDefaults( backend::NodeInstance const & _aDefaultInstance) CFG_UNO_THROW_RTE(  )
 	{
         OSL_PRECOND(_aDefaultInstance.data().get(), "insertDefaults: Data must not be NULL");
         OSL_PRECOND(_aDefaultInstance.root().isModuleRoot(), "insertDefaults: Default tree being added must be for module");
@@ -327,22 +304,22 @@ namespace configmgr
         if (!xModule.is()) return false;
 
         // make sure to keep the module alive
-		CacheLineClientRef( xModule ).keep();
+	CacheLineClientRef( xModule ).keep();
 
-        data::TreeAddress aResultTree = xModule->insertDefaults(_aAccessToken, _aDefaultInstance);
+	data::TreeAddress aResultTree = xModule->insertDefaults(_aDefaultInstance);
 
-		return aResultTree.is();
-	}
+	return aResultTree != NULL;
+    }
 // -----------------------------------------------------------------------------
 
-    void CacheData::applyUpdate(memory::UpdateAccessor & _aAccessToken, backend::UpdateInstance & _anUpdate ) CFG_UNO_THROW_RTE(  )
+    void CacheData::applyUpdate( backend::UpdateInstance & _anUpdate ) CFG_UNO_THROW_RTE(  )
 	{
 		// request the subtree, atleast one level must exist!
-        data::NodeAddress aNodeAddr = internalGetNode(_aAccessToken.accessor(),_anUpdate.root().location());
+        data::NodeAddress aNodeAddr = internalGetNode(_anUpdate.root().location());
 
-		if (aNodeAddr.is())
+		if (aNodeAddr != NULL)
 		{
-            applyUpdateToTree(*_anUpdate.data(),_aAccessToken,aNodeAddr);
+		    applyUpdateToTree(*_anUpdate.data(),aNodeAddr);
 		}
 		else
 		{
@@ -355,18 +332,18 @@ namespace configmgr
 		}
 	}
 // -----------------------------------------------------------------------------	
-    CacheLine::RefCount CacheData::releaseModule( ModuleName const & _aModule, bool _bKeepDeadModule )
+    oslInterlockedCount CacheData::releaseModule( CacheLine::Name const & _aModule, bool _bKeepDeadModule )
 	{
 		CacheLineRef xModule = internalGetModule(_aModule);
 
-		const CacheLine::RefCount c_nErrorCount = -1;
+		const oslInterlockedCount c_nErrorCount = -1;
 		
 		OSL_ENSURE( xModule.is(), "ERROR: Releasing non-existent subtree");
 		if ( !xModule.is()) return c_nErrorCount;
 		
 		OSL_ENSURE( xModule->clientReferences() > 0, "ERROR: Releasing non-referenced subtree");
 
-		CacheLine::RefCount nResult = xModule->clientRelease();
+		oslInterlockedCount nResult = xModule->clientRelease();
 
         if (nResult == 0 && !_bKeepDeadModule)
         {
@@ -376,43 +353,32 @@ namespace configmgr
 	}
 
 // -----------------------------------------------------------------------------
-    data::TreeAddress CacheData::getTemplateTree( memory::Accessor const & _aAccessor, Path const& aTemplateName ) const
+    data::TreeAddress CacheData::getTemplateTree(CacheLine::Path const& aTemplateName ) const
 	{
-		return internalGetPartialTree(_aAccessor,aTemplateName);
+		return internalGetPartialTree(aTemplateName);
 	}
 // -----------------------------------------------------------------------------
-    data::NodeAddress CacheData::getNode(memory::Accessor const & _aAccessor, const Path& _rPath)
+    data::NodeAddress CacheData::getNode(const CacheLine::Path& _rPath)
 	{
-		return internalGetNode(_aAccessor,_rPath);
+		return internalGetNode(_rPath);
 	}
 // -----------------------------------------------------------------------------
-    bool CacheData::hasNode(memory::Accessor const & _aAccessor, const Path& _rPath) const
+    bool CacheData::hasNode(const CacheLine::Path& _rPath) const
 	{
-		return internalGetNode(_aAccessor,_rPath).is();
+		return internalGetNode(_rPath) != NULL;
 	}
 // -----------------------------------------------------------------------------
-// -----------------------------------------------------------------------------
-
-    /// gets a data segment reference for the given path - creates if necessary
-    memory::Segment * TemplateCacheData::createDataSegment(ModuleName const & _aModule)
-    {
-        CacheLineRef aModule = implNewCacheLine(_aModule);
 
-        return aModule.is() ? aModule->getDataSegment() : NULL;
-    }
-// -------------------------------------------------------------------------
-
-    data::TreeAddress TemplateCacheData::addTemplates(  memory::UpdateAccessor& _aUpdateToken, 
-                                                        backend::ComponentData const & _aComponentInstance) CFG_UNO_THROW_RTE(  )
+    data::TreeAddress TemplateCacheData::addTemplates( backend::ComponentData const & _aComponentInstance) CFG_UNO_THROW_RTE(  )
 	{
         OSL_PRECOND(_aComponentInstance.data.get(), "addTemplates: Data must not be NULL");
         // we should already have the module in cache !
-		ModuleName aModuleName ( _aComponentInstance.name); 
+		CacheLine::Name aModuleName ( _aComponentInstance.name); 
         CacheLineRef xModule = internalGetModule(aModuleName);
 
 		OSL_ENSURE( xModule.is(), "ExtendedCacheData::addTemplates: No module to add the templates to - where did the data segment come from ?");
 		
-        if (!xModule.is()) return data::TreeAddress();
+        if (!xModule.is()) return NULL;
 
         // make sure to keep the module alive
 		CacheLineClientRef( xModule ).keep();
@@ -421,31 +387,27 @@ namespace configmgr
         static const OUString aDummyTemplateModule(RTL_CONSTASCII_USTRINGPARAM("cfg:Templates"));
         _aComponentInstance.data->makeSetNode(aDummyTemplateName,aDummyTemplateModule);
 
-        data::TreeAddress aResult = xModule->setComponentData(_aUpdateToken, _aComponentInstance, true);
+        data::TreeAddress aResult = xModule->setComponentData(_aComponentInstance, true);
         
-        OSL_ASSERT(aResult.is());
+        OSL_ASSERT(aResult != NULL);
 
-		return aResult;
-	}
+	return aResult;
+    }
 // -----------------------------------------------------------------------------
 
-    CacheLineRef TemplateCacheData::doCreateAttachedModule(memory::HeapManager & _rHeapManager, const memory::SegmentAddress & _aLocation, const ModuleName& _aName) CFG_UNO_THROW_RTE(  )
+    CacheLineRef TemplateCacheData::doCreateAttachedModule(data::TreeAddress _aLocation, const CacheLine::Name& _aName) CFG_UNO_THROW_RTE(  )
     {
-        CacheLineRef aNewModule = 
-            CacheLine::createAttached(_aName, _rHeapManager, _aLocation);
+        CacheLineRef aNewModule =  CacheLine::createAttached(_aName, _aLocation);
 
         return aNewModule.get();
     }
 // -----------------------------------------------------------------------------
 
-	CacheLineRef TemplateCacheData::implNewCacheLine(const ModuleName& _aModule) CFG_UNO_THROW_RTE(  )
+	void TemplateCacheData::createModule(const CacheLine::Name& _aModule) CFG_UNO_THROW_RTE()
 	{
-        CacheLineRef aNewModule = 
-            CacheLine::createNew(_aModule, this->internalHeapManager());
+        CacheLineRef aNewModule = CacheLine::createNew(_aModule);
 
 		internalAddModule( _aModule, aNewModule.get() );
-
-		return aNewModule;
 	}
 // -----------------------------------------------------------------------------
 // -----------------------------------------------------------------------------
@@ -459,38 +421,25 @@ namespace configmgr
 
 // -----------------------------------------------------------------------------
 
-    CacheLineRef ExtendedCacheData::doCreateAttachedModule(memory::HeapManager & _rHeapManager, const memory::SegmentAddress & _aLocation, const ModuleName& _aName) CFG_UNO_THROW_RTE(  )
+    CacheLineRef ExtendedCacheData::doCreateAttachedModule(data::TreeAddress _aLocation, const CacheLine::Name& _aName) CFG_UNO_THROW_RTE(  )
     {
         ExtendedCacheLineRef aNewModule = 
-            ExtendedCacheLine::createAttached(_aName, _rHeapManager, _aLocation);
+            ExtendedCacheLine::createAttached(_aName, _aLocation);
 
         return CacheLineRef( aNewModule.get() );
     }
 // -----------------------------------------------------------------------------
 
-	ExtendedCacheLineRef ExtendedCacheData::implNewCacheLine(const ModuleName& _aModule) CFG_UNO_THROW_RTE(  )
+	void ExtendedCacheData::createModule(const CacheLine::Name& _aModule) CFG_UNO_THROW_RTE()
 	{
-        ExtendedCacheLineRef aNewModule = 
-            ExtendedCacheLine::createNew(_aModule, this->internalHeapManager());
+        ExtendedCacheLineRef aNewModule = ExtendedCacheLine::createNew(_aModule);
 
 		internalAddModule( _aModule, aNewModule.get() );
-
-		return aNewModule;
 	}
 // -----------------------------------------------------------------------------
 
-    /// gets a data segment reference for the given path - creates if necessary
-    memory::Segment * ExtendedCacheData::createDataSegment(ModuleName const & _aModule)
-    {
-        ExtendedCacheLineRef aModule = implNewCacheLine(_aModule);
-
-        return aModule.is() ? aModule->getDataSegment() : NULL;
-    }
-// -------------------------------------------------------------------------
-
-    data::TreeAddress ExtendedCacheData::addComponentData(memory::UpdateAccessor& _aUpdateToken, 
-                                                    backend::ComponentInstance const & _aComponentInstance, 
-                                                    bool _bWithDefaults) CFG_UNO_THROW_RTE(  )
+    data::TreeAddress ExtendedCacheData::addComponentData(backend::ComponentInstance const & _aComponentInstance, 
+							  bool _bWithDefaults) CFG_UNO_THROW_RTE(  )
 	{
         OSL_PRECOND(_aComponentInstance.data().get(), "addComponentData: Data must not be NULL");
         // we should already have the module in cache !
@@ -499,18 +448,18 @@ namespace configmgr
 		
         OSL_ENSURE( xModule.is(), "ExtendedCacheData::addComponentData: No module to add the subtree to - where did the data segment come from ?");
 		
-        if (!xModule.is()) return data::TreeAddress();
+        if (!xModule.is()) return NULL;
 
 		CacheLineClientRef aClientRef( xModule );
 
-        data::TreeAddress aResult = xModule->setComponentData(_aUpdateToken,_aComponentInstance.componentNodeData(), _bWithDefaults);
+        data::TreeAddress aResult = xModule->setComponentData(_aComponentInstance.componentNodeData(), _bWithDefaults);
 
-        OSL_ASSERT(aResult.is());
+        OSL_ASSERT(aResult != NULL);
 
-		if (aResult.is()) aClientRef.keep();
+	if (aResult != NULL) aClientRef.keep();
 
-		return aResult;
-	}
+	return aResult;
+    }
 // -----------------------------------------------------------------------------
 
     void ExtendedCacheData::addPending(backend::ConstUpdateInstance const & _anUpdate) CFG_UNO_THROW_RTE(  )
@@ -529,7 +478,7 @@ namespace configmgr
 	}
 // -----------------------------------------------------------------------------
     
-    std::auto_ptr<SubtreeChange> ExtendedCacheData::releasePending(ModuleName const& _aModule)
+    std::auto_ptr<SubtreeChange> ExtendedCacheData::releasePending(CacheLine::Name const& _aModule)
 	{
 		ExtendedCacheLineRef xModule = implExtended(internalGetModule(_aModule));
 
@@ -548,12 +497,13 @@ namespace configmgr
 	}
 // -----------------------------------------------------------------------------	
         
-    bool ExtendedCacheData::hasPending(ModuleName const & _aModule)
+    bool ExtendedCacheData::hasPending(CacheLine::Name const & _aModule)
     {		
-		ExtendedCacheLineRef xModule = implExtended(internalGetModule(_aModule));
+        ExtendedCacheLineRef xModule = implExtended(internalGetModule(_aModule));
 
-        return xModule.is() && xModule->hasPending();
+	return xModule.is() && xModule->hasPending();
     }
+
 // -----------------------------------------------------------------------------	
         
     void ExtendedCacheData::findPendingModules( PendingModuleList & _rPendingList )
Index: configmgr/source/treecache/cachedata.hxx
===================================================================
RCS file: /cvs/util/configmgr/source/treecache/cachedata.hxx,v
retrieving revision 1.7
retrieving revision 1.7.84.4
diff -u -p -u -p -r1.7 -r1.7.84.4
--- configmgr/source/treecache/cachedata.hxx	8 Sep 2005 04:22:46 -0000	1.7
+++ configmgr/source/treecache/cachedata.hxx	16 Jan 2007 12:18:23 -0000	1.7.84.4
@@ -53,7 +53,7 @@
 namespace configmgr
 {
 ////////////////////////////////////////////////////////////////////////////////
-	using ::rtl::OUString;
+    using ::rtl::OUString;
 
     namespace backend
     {
@@ -70,74 +70,61 @@ namespace configmgr
 	class CacheData			
 	{
 	public:
-        typedef CacheLine        Module;
-        typedef CacheLineRef     ModuleRef;
-        typedef CacheLine::Path     Path;
-        typedef CacheLine::Name     ModuleName;
-	public:
-		CacheData(memory::HeapManager & _rHeapManager);
+		CacheData();
 		virtual ~CacheData();
 
 		/// retrieve the module tree name for the given path
-		static ModuleName extractModuleName(Path const& _aPath);
+		static CacheLine::Name extractModuleName(CacheLine::Path const& _aPath);
 
+        // attach a module with a given name
+        void attachModule(data::TreeAddress _aLocation, CacheLine::Name const & _aModule);
         /// check if the given module exists already (and is not empty)
-        bool hasModule(ModuleName const & _aModule) const;
+        bool hasModule(CacheLine::Name const & _aModule) const;
         /// checks if the given module exists and has defaults available
-        bool hasModuleDefaults(memory::Accessor const & _aAccessor, ModuleName const & _aModule) const;
+        bool hasModuleDefaults(CacheLine::Name const & _aModule) const;
 
-        /// creates a new data segment reference for the given path if exists
-        memory::Segment * attachDataSegment(memory::SegmentAddress const & _aLocation, ModuleName const & _aModule);
-        /// gets a data segment reference for the given path if it exists
-        memory::Segment * getDataSegment(ModuleName const & _aModule);
-        /// gets a data segment address for the given module if it exists
-        memory::SegmentAddress getDataSegmentAddress(ModuleName const & _aModule) const;
+        /// gets a tree address for the given module if it exists
+        data::TreeAddress getTreeAddress(CacheLine::Name const & _aModule) const;
 
         /// checks whether a certain node exists in the tree
-        bool  hasNode(memory::Accessor const & _aAccessor, Path const & _aLocation) const;
+        bool  hasNode(CacheLine::Path const & _aLocation) const;
 
 		/// retrieve the given node without changing its ref count
-		data::NodeAddress   getNode(memory::Accessor const & _aAccessor, Path const & _rPath);
+		data::NodeAddress   getNode(CacheLine::Path const & _rPath);
 		/// retrieve the given template tree without changing its ref count
-		data::TreeAddress	getTemplateTree(memory::Accessor const & _aAccessor, Path const & aTemplateName ) const;
+		data::TreeAddress	getTemplateTree( CacheLine::Path const & aTemplateName ) const;
 
 		/// retrieve the subtree at _aPath and clientAcquire() it
-        data::NodeAddress acquireNode(memory::Accessor const & _aAccessor, Path const & _aPath ); 
-		/// retrieve the subtree at _aPath and clientAcquire() it
-        data::TreeAddress acquireModule( ModuleName const & _aModule ); 
+        data::NodeAddress acquireNode(CacheLine::Path const & _aPath ); 
+		/// retrieve the subtree at _aPath and clientAcquire() it, return true on success
+        bool acquireModule( CacheLine::Name const & _aModule ); 
 		/// clientRelease() the tree at aComponentName, and return the resulting reference count
-        CacheLine::RefCount releaseModule( ModuleName const & _aModule, bool _bKeepDeadModule = false ); 
+        oslInterlockedCount releaseModule( CacheLine::Name const & _aModule, bool _bKeepDeadModule = false ); 
 
-        bool insertDefaults( memory::UpdateAccessor& _aAccessToken, 
-                             backend::NodeInstance const & _aDefaultInstance
+        bool insertDefaults( backend::NodeInstance const & _aDefaultInstance
                            ) CFG_UNO_THROW_RTE();
 
 		/// merge the given changes into this tree - reflects old values to _anUpdate
-        void applyUpdate(   memory::UpdateAccessor& _aUpdateToken, 
-                            backend::UpdateInstance & _anUpdate) CFG_UNO_THROW_RTE(  );
+        void applyUpdate( backend::UpdateInstance & _anUpdate) CFG_UNO_THROW_RTE(  );
 
 		// low-level interface for cache management
-        typedef std::map<ModuleName, ModuleRef> ModuleList;
+        typedef std::map<CacheLine::Name, CacheLineRef> ModuleList;
 		ModuleList& accessModuleList() { return m_aModules; }
 
-        memory::HeapManager & getHeapManager() const { return m_rHeapManager; }
 	protected:
-        virtual ModuleRef doCreateAttachedModule(memory::HeapManager & _rHeapManager, const memory::SegmentAddress & _aLocation, const ModuleName& _aName) CFG_UNO_THROW_RTE(  );
+        virtual CacheLineRef doCreateAttachedModule(data::TreeAddress _aLocation, const CacheLine::Name& _aName) CFG_UNO_THROW_RTE(  );
 
-        data::TreeAddress internalGetPartialTree(memory::Accessor const & _aAccessor, Path const & _aPath ) const;
-		data::NodeAddress internalGetNode(memory::Accessor const & _aAccessor, const Path& _rPath) const;
+        data::TreeAddress internalGetPartialTree(CacheLine::Path const & _aPath ) const;
+		data::NodeAddress internalGetNode(const CacheLine::Path& _rPath) const;
 
-        ModuleRef internalAttachModule(const memory::SegmentAddress & _aLocation, const ModuleName& _aName) CFG_UNO_THROW_RTE(  );
-        void internalAddModule(ModuleName const & _aName, ModuleRef const & _aModule);
+        CacheLineRef internalAttachModule(data::TreeAddress _aLocation, const CacheLine::Name& _aName) CFG_UNO_THROW_RTE(  );
+        void internalAddModule(CacheLine::Name const & _aName, CacheLineRef const & _aModule);
 
-		ModuleRef internalGetModule(const ModuleName& _aName) const;
-		ModuleRef internalGetModule(const Path& _aLocation) const;
+		CacheLineRef internalGetModule(const CacheLine::Name& _aName) const;
+		CacheLineRef internalGetModule(const CacheLine::Path& _aLocation) const;
 
-        memory::HeapManager & internalHeapManager() { return m_rHeapManager; }
 	private:
 		ModuleList m_aModules;
-
-        memory::HeapManager & m_rHeapManager;
 	};
 ////////////////////////////////////////////////////////////////////////////////
 	/** A collection of CacheLines for templates
@@ -146,25 +133,20 @@ namespace configmgr
     class TemplateCacheData : public CacheData	
 	{
 	public:
-		TemplateCacheData(memory::HeapManager & _rHeapManager)
-        : CacheData(_rHeapManager)
+		TemplateCacheData() : CacheData()
         {
         }
 
-        /// gets a data segment reference for the given path - creates if necessary 
-        memory::Segment * createDataSegment(ModuleName const & _aModule);
-
 		/** add the given template tree at the given location,
 			return the tree that is now pertinent and clientAcquire() it once
 		*/
-        data::TreeAddress addTemplates( memory::UpdateAccessor& _aAccessToken,
-                                        backend::ComponentData const & _aComponentInstance  
+        data::TreeAddress addTemplates( backend::ComponentData const & _aComponentInstance  
                                        ) CFG_UNO_THROW_RTE();
 
+        // create a new module with the given name
+        void createModule(CacheLine::Name const & _aModule) CFG_UNO_THROW_RTE();
 	private:
-        virtual ModuleRef doCreateAttachedModule(memory::HeapManager & _rHeapManager, const memory::SegmentAddress & _aLocation, const ModuleName& _aName) CFG_UNO_THROW_RTE(  );
-
-		CacheLineRef implNewCacheLine(ModuleName const & _aModule) CFG_UNO_THROW_RTE(  );
+        virtual CacheLineRef doCreateAttachedModule(data::TreeAddress _aLocation, const CacheLine::Name& _aName) CFG_UNO_THROW_RTE(  );
 	};
 //-----------------------------------------------------------------------------
 	/** A collection of CacheLines
@@ -173,38 +155,35 @@ namespace configmgr
     class ExtendedCacheData : public CacheData	
 	{
 	public:
-		ExtendedCacheData(memory::HeapManager & _rHeapManager)
-        : CacheData(_rHeapManager)
+		ExtendedCacheData() : CacheData()
         {
         }
 
-        /// gets a data segment reference for the given path - creates if necessary 
-        memory::Segment * createDataSegment(ModuleName const & _aModule);
-
 		/** add the given subtree at the given location,
 			return the tree that is now pertinent and clientAcquire() it once
 		*/
-        data::TreeAddress addComponentData( memory::UpdateAccessor& _aAccessToken, 
-                                            backend::ComponentInstance const & _aComponentInstance, 
+        data::TreeAddress addComponentData( backend::ComponentInstance const & _aComponentInstance, 
                                             bool _bWithDefaults
                                            ) CFG_UNO_THROW_RTE();
 
-		typedef std::vector< ModuleName >  PendingModuleList;
+		typedef std::vector< CacheLine::Name >  PendingModuleList;
+
         /// find the modules having pending changes
-        bool hasPending(ModuleName const & _aModule);
+        bool hasPending(CacheLine::Name const & _aModule);
         /// find the modules having pending changes
         void findPendingModules( PendingModuleList & _rPendingList );
 
 		/// add or merge the given subtreechange at the given location
 		void addPending(backend::ConstUpdateInstance const & _anUpdate) CFG_UNO_THROW_RTE(  );
 		/// remove and return pending changes for the given component
-		std::auto_ptr<SubtreeChange> releasePending(ModuleName const & _aModule) CFG_UNO_THROW_RTE(  );
-	private:
-        virtual ModuleRef doCreateAttachedModule(memory::HeapManager & _rHeapManager, const memory::SegmentAddress & _aLocation, const ModuleName& _aName) CFG_UNO_THROW_RTE(  );
+		std::auto_ptr<SubtreeChange> releasePending(CacheLine::Name const & _aModule) CFG_UNO_THROW_RTE(  );
 
-		ExtendedCacheLineRef implNewCacheLine(ModuleName const & _aModule) CFG_UNO_THROW_RTE(  );
+        // create a new module with the given name
+        void createModule(CacheLine::Name const & _aModule) CFG_UNO_THROW_RTE();
+	private:
+        virtual CacheLineRef doCreateAttachedModule(data::TreeAddress _aLocation, const CacheLine::Name& _aName) CFG_UNO_THROW_RTE(  );
 
-		ExtendedCacheLineRef implExtended(ModuleRef const & _aSimpleRef) const;
+		ExtendedCacheLineRef implExtended(CacheLineRef const & _aSimpleRef) const;
 	};
 //-----------------------------------------------------------------------------
 	
Index: configmgr/source/treecache/cachefactory.cxx
===================================================================
RCS file: /cvs/util/configmgr/source/treecache/cachefactory.cxx,v
retrieving revision 1.8
retrieving revision 1.8.24.2
diff -u -p -u -p -r1.8 -r1.8.24.2
--- configmgr/source/treecache/cachefactory.cxx	16 Sep 2006 15:25:24 -0000	1.8
+++ configmgr/source/treecache/cachefactory.cxx	21 Feb 2007 12:49:03 -0000	1.8.24.2
@@ -44,9 +44,6 @@
 #ifndef CONFIGMGR_BACKEND_CACHECONTROLLER_HXX
 #include "cachecontroller.hxx"
 #endif
-#ifndef CONFIGMGR_HEAPFACTORY_HXX
-#include "heapfactory.hxx"
-#endif
 #ifndef CONFIGMGR_BACKENDFACTORY_HXX_
 #include "backendfactory.hxx"
 #endif
@@ -66,12 +63,10 @@ namespace configmgr
 
         if (_xBackend.is())
         {
-            memory::HeapManager & rHeap = memory::cacheHeap();
-
             rtl::Reference< backend::ICachedDataProvider > xLoader
-                = new backend::CacheController(_xBackend.get(),rHeap, _xContext);
+                = new backend::CacheController(_xBackend.get(), _xContext);
 
-            xCache.set( new TreeManager(xLoader.get(),rHeap) );
+            xCache.set( new TreeManager(xLoader.get()) );
         }
 
         return xCache;
Index: configmgr/source/treecache/cacheline.cxx
===================================================================
RCS file: /cvs/util/configmgr/source/treecache/cacheline.cxx,v
retrieving revision 1.9
retrieving revision 1.9.24.4
diff -u -p -u -p -r1.9 -r1.9.24.4
--- configmgr/source/treecache/cacheline.cxx	16 Sep 2006 15:25:36 -0000	1.9
+++ configmgr/source/treecache/cacheline.cxx	16 Jan 2007 12:18:23 -0000	1.9.24.4
@@ -80,48 +80,33 @@ namespace configmgr
 
 // -----------------------------------------------------------------------------	
 
-    CacheLine::CacheLine(Name const & _aModuleName, memory::HeapManager & _rHeapImpl)
-    : m_storage(_rHeapImpl  )
-    , m_base()
+    CacheLine::CacheLine(Name const & _aModuleName)
+    : m_base(NULL)
     , m_name(_aModuleName)
     , m_nDataRefs(0)
 	{
 	}
 // -----------------------------------------------------------------------------	
-	
-    CacheLine::CacheLine(Name const & _aModuleName, memory::HeapManager & _rHeapImpl, 
-                            memory::SegmentAddress const & _aSegment)
-    : m_storage(_rHeapImpl,_aSegment.id)
-    , m_base( memory::Pointer(_aSegment.base) )
+
+    CacheLine::CacheLine(Name const & _aModuleName, data::TreeAddress _pSegment)
+    : m_base(_pSegment)
     , m_name(_aModuleName)
     , m_nDataRefs(0)
 	{
 	}
-// -----------------------------------------------------------------------------
-
-    memory::SegmentAddress CacheLine::getDataSegmentAddress() const
-    {
-        memory::SegmentAddress aResult;
-
-        aResult.id      = m_storage.getId();
-        aResult.base    = m_base.addressValue();
-
-        return aResult;
-    }
 
 // -----------------------------------------------------------------------------
 
     void CacheLine::setBase(data::TreeAddress _base)
-	{
-        OSL_PRECOND(!m_base.is(), "CacheLine: Data base address was already set");
-        OSL_PRECOND(  _base.is(), "CacheLine: Cannot set NULL base address");
+    {
+        OSL_PRECOND(m_base == NULL, "CacheLine: Data base address was already set");
+        OSL_PRECOND( _base != NULL, "CacheLine: Cannot set NULL base address");
         m_base = _base;
     }
 // -----------------------------------------------------------------------------
    
     CacheLineRef CacheLine::createAttached( Name const & _aModuleName, 
-                                            memory::HeapManager & _rHeapImpl, 
-                                            memory::SegmentAddress const & _aSegment
+                                            data::TreeAddress _aSegment
                                           ) CFG_UNO_THROW_RTE(  )
 	{
 		if (_aModuleName.isEmpty())
@@ -129,20 +114,19 @@ namespace configmgr
 			OSL_ENSURE(false, "Cannot make a cache line without a name");
 			return NULL;
 		}
-		if (_aSegment.isNull())
+		if (_aSegment == NULL)
 		{
 			OSL_ENSURE(false, "Cannot attach a cache line to a NULL segment");
 			return NULL;
 		}
 
-		CacheLineRef xResult = new CacheLine(_aModuleName,_rHeapImpl,_aSegment);
+		CacheLineRef xResult = new CacheLine(_aModuleName,_aSegment);
 
 		return xResult;
 	}
 // -----------------------------------------------------------------------------
  
-    CacheLineRef CacheLine::createNew(  Name const & _aModuleName, 
-                                        memory::HeapManager & _rHeapImpl
+    CacheLineRef CacheLine::createNew(  Name const & _aModuleName
                                       ) CFG_UNO_THROW_RTE(  )
 	{
 		if (_aModuleName.isEmpty())
@@ -151,7 +135,7 @@ namespace configmgr
 			return NULL;
 		}
 
-		CacheLineRef xResult = new CacheLine(_aModuleName,_rHeapImpl);
+		CacheLineRef xResult = new CacheLine(_aModuleName);
 
 		return xResult;
 	}
@@ -163,90 +147,88 @@ namespace configmgr
 	}
 // -----------------------------------------------------------------------------
    
-    data::TreeAddress CacheLine::getPartialTree(memory::Accessor const & _aAccessor, Path const& aConfigName) const
+    data::TreeAddress CacheLine::getPartialTree(Path const& aConfigName) const
 	{
-        data::SetNodeAccess aParentSet( internalGetNode(_aAccessor, aConfigName.getParentPath()) );
+        data::SetNodeAccess aParentSet( internalGetNode(aConfigName.getParentPath()) );
 
         if (aParentSet.isValid())
-            return aParentSet.getElementTree(aConfigName.getLocalName().getName()).address();
+            return aParentSet.getElementTree(aConfigName.getLocalName().getName());
         else
-            return data::TreeAddress();
+            return NULL;
 	}
 // -----------------------------------------------------------------------------
   
-    bool CacheLine::hasDefaults(memory::Accessor const & _anAccessor) const
-	{
-		if ( !m_base.is() ) return false; // cannot get defaults without data
+    bool CacheLine::hasDefaults() const
+    {
+	if ( m_base != NULL ) return false; // cannot get defaults without data
 
-        data::TreeAccessor aModuleTree(_anAccessor, m_base);
-		OSL_ASSERT( aModuleTree.isValid());
+        data::TreeAccessor aModuleTree(m_base);
+	OSL_ASSERT( aModuleTree != NULL);
         
-        return aModuleTree.data().hasDefaultsAvailable();
+        return aModuleTree->hasDefaultsAvailable();
     }
 // -----------------------------------------------------------------------------
-    data::NodeAccess CacheLine::internalGetNode(memory::Accessor const & _anAccessor, Path const& aConfigName) const
-	{
-		OSL_ENSURE( m_base.is(), "Cannot get a node from a dataless module");
+    data::NodeAccess CacheLine::internalGetNode(Path const& aConfigName) const
+    {
+	OSL_ENSURE( m_base != NULL, "Cannot get a node from a dataless module");
 
-        data::TreeAccessor aModuleTree(_anAccessor, m_base);
-		OSL_ASSERT( aModuleTree.isValid());
+        data::TreeAccessor aModuleTree(m_base);
+	OSL_ASSERT(aModuleTree != NULL);
 
-        data::NodeAccess aNode = aModuleTree.getRootNode().toNodeAccess();
-		OSL_ENSURE( aNode.isValid(), "CacheLine contains no nodes");
+        data::NodeAccess aNode = aModuleTree.getRootNode();
+	OSL_ENSURE( aNode.isValid(), "CacheLine contains no nodes");
 
-		Path::Iterator it = aConfigName.begin();
-		OSL_ENSURE( it != aConfigName.end(), "Empty Path can't match any module");
-		OSL_ENSURE( aNode.getName() == it->getInternalName(), "Module part in config path does not match selected CacheLine");
+	Path::Iterator it = aConfigName.begin();
+	OSL_ENSURE( it != aConfigName.end(), "Empty Path can't match any module");
+	OSL_ENSURE( aNode.isValid() && aNode.getName() == it->getInternalName(), "Module part in config path does not match selected CacheLine");
 
         // find child of node
         // might be done using a visitor
-		while(aNode.isValid() && ++it != aConfigName.end())
-		{
+	while(aNode.isValid() && ++it != aConfigName.end())
+	{
             aNode = data::getSubnode(aNode,it->getName());
-		}
-        return aNode;
 	}
+        return aNode;
+    }
 // -----------------------------------------------------------------------------
    
-    data::NodeAddress CacheLine::getNode(memory::Accessor const & _aAccessor, Path const& aConfigName) const
-	{
-        data::NodeAccess aNode = internalGetNode(_aAccessor, aConfigName);
-        return aNode.address();
-	}
+    data::NodeAddress CacheLine::getNode(Path const& aConfigName) const
+    {
+        data::NodeAccess aNode = internalGetNode(aConfigName);
+        return aNode;
+    }
 // -------------------------------------------------------------------------
 
-    data::TreeAddress CacheLine::setComponentData( memory::UpdateAccessor& _aAccessToken,
-                                                           backend::ComponentData const & _aComponentInstance, 
-                                                           bool _bWithDefaults
-                                                         ) CFG_UNO_THROW_RTE(  )
+    data::TreeAddress CacheLine::setComponentData( backend::ComponentData const & _aComponentInstance, 
+                                                   bool _bWithDefaults
+                                                   ) CFG_UNO_THROW_RTE(  )
 	{
 		OSL_PRECOND(_aComponentInstance.data.get(), "CacheLine::insertDefaults: inserting NULL defaults !");
         OSL_PRECOND(_aComponentInstance.name == this->getModuleName(),"Data location does not match module");
 	
-        OSL_PRECOND(!base().is(), "Data is already loaded");
+        OSL_PRECOND(base() == NULL, "Data is already loaded");
 
-        if (!base().is()) // no data yet
+        if (base() == NULL) // no data yet
         {
-            this->setBase( data::buildTree(_aAccessToken, _aComponentInstance.data->getName(), *_aComponentInstance.data, _bWithDefaults) );
+            this->setBase( data::buildTree(_aComponentInstance.data->getName(), *_aComponentInstance.data, _bWithDefaults) );
         }
 
         return this->base();
     }
 // -----------------------------------------------------------------------------
 
-    data::TreeAddress CacheLine::insertDefaults( memory::UpdateAccessor& _aAccessToken,
-                                                 backend::NodeInstance const & _aDefaultInstance
+    data::TreeAddress CacheLine::insertDefaults( backend::NodeInstance const & _aDefaultInstance
                                                ) CFG_UNO_THROW_RTE(  )
 	{
 		OSL_PRECOND(_aDefaultInstance.data().get(), "CacheLine::insertDefaults: inserting NULL defaults !");
         OSL_PRECOND(_aDefaultInstance.root().isModuleRoot(), "Should have complete component to fill tree with defaults");
         OSL_PRECOND(_aDefaultInstance.root().getModuleName() == this->getModuleName(),"Data location does not match module");
 
-        OSL_PRECOND(m_base.is(), "Data must already be loaded to insert defaults");
+        OSL_PRECOND(m_base != NULL, "Data must already be loaded to insert defaults");
 
-        if (m_base.is()) 
+        if (m_base != NULL) 
         {
-            data::mergeDefaults(_aAccessToken,m_base,*_aDefaultInstance.data());
+            data::mergeDefaults(m_base,*_aDefaultInstance.data());
         }
 
         return m_base;
@@ -254,17 +236,17 @@ namespace configmgr
 // -----------------------------------------------------------------------------	
 // -----------------------------------------------------------------------------	
 
-    ExtendedCacheLine::ExtendedCacheLine(Name const & _aModuleName, memory::HeapManager & _rHeapImpl)
-    : CacheLine(_aModuleName,_rHeapImpl)
+    ExtendedCacheLine::ExtendedCacheLine(Name const & _aModuleName)
+    : CacheLine(_aModuleName)
     , m_pPending()
 	{
 	}
 
 // -----------------------------------------------------------------------------	
 
-    ExtendedCacheLine::ExtendedCacheLine(Name const & _aModuleName, memory::HeapManager & _rHeapImpl, 
-                                            memory::SegmentAddress const & _aSegment)
-    : CacheLine(_aModuleName,_rHeapImpl,_aSegment)
+    ExtendedCacheLine::ExtendedCacheLine(Name const & _aModuleName,
+                                         data::TreeAddress _aSegment)
+    : CacheLine(_aModuleName,_aSegment)
     , m_pPending()
 	{
 	}
@@ -272,8 +254,7 @@ namespace configmgr
 // -----------------------------------------------------------------------------
   
     ExtendedCacheLineRef ExtendedCacheLine::createAttached( Name const & _aModuleName, 
-                                                            memory::HeapManager & _rHeapImpl, 
-                                                            memory::SegmentAddress const & _aSegment
+                                                            data::TreeAddress _aSegment
                                                           ) CFG_UNO_THROW_RTE(  )
 	{
 		if (_aModuleName.isEmpty())
@@ -281,20 +262,19 @@ namespace configmgr
 			OSL_ENSURE(false, "Cannot make a cache line without a name");
 			return NULL;
 		}
-		if (_aSegment.isNull())
+		if (_aSegment == NULL)
 		{
 			OSL_ENSURE(false, "Cannot attach a cache line to a NULL segment");
 			return NULL;
 		}
 
-		ExtendedCacheLineRef xResult = new ExtendedCacheLine(_aModuleName,_rHeapImpl,_aSegment);
+		ExtendedCacheLineRef xResult = new ExtendedCacheLine(_aModuleName,_aSegment);
 
 		return xResult;
 	}
 // -----------------------------------------------------------------------------
  
-    ExtendedCacheLineRef ExtendedCacheLine::createNew(  Name const & _aModuleName, 
-                                                        memory::HeapManager & _rHeapImpl
+ExtendedCacheLineRef ExtendedCacheLine::createNew(  Name const & _aModuleName
                                                       ) CFG_UNO_THROW_RTE(  )
 	{
 		if (_aModuleName.isEmpty())
@@ -303,7 +283,7 @@ namespace configmgr
 			return NULL;
 		}
 
-		ExtendedCacheLineRef xResult = new ExtendedCacheLine(_aModuleName,_rHeapImpl);
+		ExtendedCacheLineRef xResult = new ExtendedCacheLine(_aModuleName);
 
 		return xResult;
 	}
Index: configmgr/source/treecache/cacheline.hxx
===================================================================
RCS file: /cvs/util/configmgr/source/treecache/cacheline.hxx,v
retrieving revision 1.5
retrieving revision 1.5.84.5
diff -u -p -u -p -r1.5 -r1.5.84.5
--- configmgr/source/treecache/cacheline.hxx	8 Sep 2005 04:23:30 -0000	1.5
+++ configmgr/source/treecache/cacheline.hxx	16 Jan 2007 12:18:24 -0000	1.5.84.5
@@ -36,12 +36,6 @@
 #ifndef CONFIGMGR_CACHELINE_HXX
 #define CONFIGMGR_CACHELINE_HXX
 
-#ifndef CONFIGMGR_TREEADDRESS_HXX
-#include "treeaddress.hxx"
-#endif
-#ifndef CONFIGMGR_SEGMENT_HXX
-#include "segment.hxx"
-#endif
 #ifndef CONFIGMGR_CONFIGPATH_HXX_
 #include "configpath.hxx"
 #endif
@@ -51,13 +45,13 @@
 #ifndef CONFIGMGR_UTILITY_HXX_
 #include "utility.hxx"
 #endif
+#ifndef INCLUDED_SHARABLE_TREEFRAGMENT_HXX
+#include "treefragment.hxx"
+#endif
 
 #ifndef _OSL_INTERLOCK_H_
 #include <osl/interlck.h>
 #endif
-#ifndef _SALHELPER_SIMPLEREFERENCEOBJECT_HXX_
-#include <salhelper/simplereferenceobject.hxx>
-#endif
 #ifndef _RTL_REF_HXX_
 #include <rtl/ref.hxx>
 #endif
@@ -67,76 +61,65 @@ namespace configmgr
 ////////////////////////////////////////////////////////////////////////////////
 	using ::rtl::OUString;
 
-    namespace data { class NodeAddress; class TreeAddress; class NodeAccess; }
+    namespace data { 
+        /* class NodeAddress; */ class NodeAccess;
+    }
 ////////////////////////////////////////////////////////////////////////////////
 	/** This object represents a cache line for a single configuration tree
 	*/
-    class CacheLine : public salhelper::SimpleReferenceObject, Noncopyable
+    class CacheLine : public configmgr::SimpleReferenceObject, Noncopyable
 	{
 	public:
-        typedef oslInterlockedCount RefCount;
-
         typedef configuration::Name         Name;
         typedef configuration::AbsolutePath Path;
 
         // create a new CacheLine for the given component name
         static rtl::Reference<CacheLine> 
-            createNew( Name const & _aModuleName, memory::HeapManager & _rHeapImpl ); 
+            createNew( Name const & _aModuleName ); 
        
         // create a new CacheLine attached to the given memory location
         static rtl::Reference<CacheLine> 
-            createAttached( Name const & _aModuleName, memory::HeapManager & _rHeapImpl, 
-                            memory::SegmentAddress const & _aLocation ); 
-       
-        memory::Segment * getDataSegment();
-
-        memory::SegmentAddress getDataSegmentAddress() const;
+            createAttached( Name const & _aModuleName, data::TreeAddress _aLocation );
 
-        bool isEmpty() const { return m_base.isNull(); }
+        bool hasDefaults() const;
 
-        bool hasDefaults(memory::Accessor const & _aAccessor) const;
+        bool isEmpty() const { return m_base == NULL; }
+        data::TreeAddress   getTreeAddress() const { return m_base; }
+		data::TreeAddress	getPartialTree(Path const & _aTemplatePath ) const;
+        data::NodeAddress	getNode(Path const & _aPath) const;
 
-        data::TreeAddress getModuleRootAddress( ) const { return m_base; }
-
-		data::TreeAddress	getPartialTree(memory::Accessor const & _aAccessor, Path const & _aTemplatePath ) const;
-        data::NodeAddress	getNode(memory::Accessor const & _aAccessor, Path const & _aPath) const;
-
-        data::TreeAddress   setComponentData( memory::UpdateAccessor& _aAccessToken,
-                                              backend::ComponentData const & _aComponentInstance, 
+        data::TreeAddress   setComponentData( backend::ComponentData const & _aComponentInstance, 
                                               bool _bWithDefaults
                                            ) CFG_UNO_THROW_RTE();
 
-        data::TreeAddress   insertDefaults(   memory::UpdateAccessor& _aAccessToken, 
-                                              backend::NodeInstance const & _aDefaultInstance
+        data::TreeAddress   insertDefaults(   backend::NodeInstance const & _aDefaultInstance
                                            ) CFG_UNO_THROW_RTE();
 
         // get the module name for this component
 		Name getModuleName() const;
 
 		/// add a client for this module's data
-		RefCount clientReferences() const { return m_nDataRefs; }
+		oslInterlockedCount clientReferences() const { return m_nDataRefs; }
 		/// add a client for this modules data
-		RefCount clientAcquire() { return osl_incrementInterlockedCount(&m_nDataRefs); }			
+		oslInterlockedCount clientAcquire() { return osl_incrementInterlockedCount(&m_nDataRefs); }			
 		/// subtract a client for this modules data
-		RefCount clientRelease() { return osl_decrementInterlockedCount(&m_nDataRefs); }		
+		oslInterlockedCount clientRelease() { return osl_decrementInterlockedCount(&m_nDataRefs); }		
 
     protected:
         // create a new CacheLine attached to the given memory location
         explicit 
-        CacheLine( Name const & _aModuleName, memory::HeapManager & _rHeapImpl, 
-                    memory::SegmentAddress const & _aLocation ); 
+        CacheLine( Name const & _aModuleName, data::TreeAddress _pLocation );
        
         // create a new empty CacheLine for the given component name
         explicit 
-        CacheLine( Name const & _aModuleName, memory::HeapManager & _rHeapImpl ); 
+        CacheLine( Name const & _aModuleName );
 
-        data::NodeAccess internalGetNode(memory::Accessor const & _anAccessor, Path const & _rPath) const;
+        data::NodeAccess internalGetNode(Path const & _rPath) const;
 
         data::TreeAddress base() const { return m_base; }
         void setBase(data::TreeAddress _base); 
 
 	private:
-        memory::Segment     m_storage;
         data::TreeAddress   m_base;
         Name                m_name;
 
@@ -152,12 +135,12 @@ namespace configmgr
 	public:
         // create a new CacheLine for the given component name
         static rtl::Reference<ExtendedCacheLine> 
-            createNew( Name const & _aModuleName, memory::HeapManager & _rHeapImpl ); 
+            createNew( Name const & _aModuleName ); 
        
         // create a new CacheLine attached to the given memory location
         static rtl::Reference<ExtendedCacheLine> 
-            createAttached( Name const & _aModuleName, memory::HeapManager & _rHeapImpl, 
-                            memory::SegmentAddress const & _aLocation ); 
+            createAttached( Name const & _aModuleName,
+                            data::TreeAddress _aLocation );
        
     // management of pending changes
 		bool hasPending() const {return m_pPending.get() != NULL;}
@@ -168,24 +151,17 @@ namespace configmgr
     private:
         // create a new empty CacheLine for the given component name
         explicit 
-        ExtendedCacheLine( Name const & _aModuleName, memory::HeapManager & _rHeapImpl );
+        ExtendedCacheLine( Name const & _aModuleName );
         
         // create a new CacheLine attached to the given memory location
         explicit 
-        ExtendedCacheLine( Name const & _aModuleName, memory::HeapManager & _rHeapImpl, 
-                            memory::SegmentAddress const & _aLocation ); 
+        ExtendedCacheLine( Name const & _aModuleName, 
+                           data::TreeAddress _aLocation );
 
     private:
 		std::auto_ptr<SubtreeChange> m_pPending;
 	};
     typedef rtl::Reference<ExtendedCacheLine> ExtendedCacheLineRef;
-////////////////////////////////////////////////////////////////////////////////
-
-    inline
-    memory::Segment * CacheLine::getDataSegment() 
-    { return &m_storage; }
-
-////////////////////////////////////////////////////////////////////////////////
 	
 } // namespace configmgr
 
Index: configmgr/source/treecache/cachewritescheduler.cxx
===================================================================
RCS file: /cvs/util/configmgr/source/treecache/cachewritescheduler.cxx,v
retrieving revision 1.8
retrieving revision 1.8.24.2
diff -u -p -u -p -r1.8 -r1.8.24.2
--- configmgr/source/treecache/cachewritescheduler.cxx	16 Sep 2006 15:26:03 -0000	1.8
+++ configmgr/source/treecache/cachewritescheduler.cxx	11 Jan 2007 20:16:04 -0000	1.8.24.2
@@ -59,34 +59,26 @@ OCacheWriteScheduler::~OCacheWriteSchedu
 
 void OCacheWriteScheduler::stopAndWriteCache()
 {
-	// PRE: if m_xTime.isValid() => The timer's shot mutex is acquired
-	osl::ClearableMutexGuard aOwnGuard( m_aMutex );
-	
+    OSL_ASSERT(UnoApiLock::isHeld());
 	CFG_TRACE_INFO("Cancelling all cache writings, Stopping timer");
 	
 	if (m_xTimer.isValid())
 		m_xTimer->dispose(); // just to be sure	
 
-	aOwnGuard.clear();
-	
 	runWriter();
 
-	osl::MutexGuard aClearGuard( m_aMutex );
     m_aWriteList.clear();
 }
 
 // -------------------------------------------------------------------------
 void OCacheWriteScheduler::Timer::onShot()
 {
-	osl::MutexGuard aGuard(m_aMutex);
+    UnoApiLock aLock;
+
 	if (pParent)
 		pParent->onTimerShot();
-
     else
-    {
 	    CFG_TRACE_WARNING("Timer shot for disposed cache writer");
-    }
-
 }
 
 // -----------------------------------------------------------------------------
@@ -109,20 +101,17 @@ void OCacheWriteScheduler::onTimerShot()
 
 	TimeStamp aNewTime = implGetScheduleTime(TimeStamp::getCurrentTime(), m_aWriteInterval);
 
-	osl::MutexGuard aGuard(m_aMutex);
 	implStartBefore(aNewTime);
 }
 // -------------------------------------------------------------------------
 void OCacheWriteScheduler::runWriter()
 {
 	// Write Cache
+    OSL_ASSERT(UnoApiLock::isHeld());
 	CFG_TRACE_INFO("Running write operations");
-//	osl::ClearableMutexGuard aGuard( m_rTreeManager.m_aUpdateMutex );
 	
-    osl::ClearableMutexGuard aListGuard( m_aMutex );
     CacheWriteList aPendingWrites;
     m_aWriteList.swap(aPendingWrites);
-    aListGuard.clear();
 
 	CFG_TRACE_INFO_NI("Found %d sections to write", int(aPendingWrites.size()));
 	for (CacheWriteList::iterator it = aPendingWrites.begin();
@@ -147,18 +136,18 @@ void OCacheWriteScheduler::runWriter()
 // -----------------------------------------------------------------------------
 void OCacheWriteScheduler::writeOneTreeFoundByOption(RequestOptions const& _aOptions) CFG_UNO_THROW_ALL(  )
 {
-	CFG_TRACE_INFO("Writeing one cache tree for user '%s' with locale '%s'", 
-					OUSTRING2ASCII(_aOptions.getEntity()), 
-                    OUSTRING2ASCII(_aOptions.getLocale()));
+    CFG_TRACE_INFO("Writeing one cache tree for user '%s' with locale '%s'", 
+		   OUSTRING2ASCII(_aOptions.getEntity()), 
+                   OUSTRING2ASCII(_aOptions.getLocale()));
+
+    backend::CacheController::CacheRef aCache;
+    aCache = m_rTreeManager.m_aCacheMap.get(_aOptions);
 
-	// PRE: m_aUpdateMutex of TreeMgr must be acuired
-    CacheManager::CacheRef aCache = m_rTreeManager.m_aCacheList.get(_aOptions);
     if (aCache.is())
 	{
 		CFG_TRACE_INFO_NI("- Found matching data container  - starting write task");		
         if (!m_rTreeManager.saveAllPendingChanges(aCache,_aOptions))
         {
-            osl::MutexGuard aListGuard( m_aMutex );
 	        m_aWriteList.insert(_aOptions);
 
 		    CFG_TRACE_INFO_NI("- Write task incomplete -reregistering");		
@@ -178,8 +167,6 @@ void OCacheWriteScheduler::writeOneTreeF
 // -----------------------------------------------------------------------------
 bool OCacheWriteScheduler::clearTasks(RequestOptions const& _aOptions)
 {
-//	osl::MutexGuard aGuard( m_rTreeManager.m_aUpdateMutex );
-
 	// sadly list::remove doesn't return an indication of what it did
 	bool bFound = m_aWriteList.erase(_aOptions) !=0;	
     if (bFound)
@@ -222,10 +209,7 @@ void OCacheWriteScheduler::implStartBefo
 // -----------------------------------------------------------------------------
 void OCacheWriteScheduler::scheduleWrite(backend::ComponentRequest _aComponent)  CFG_UNO_THROW_ALL(  )
 {
-	// PRE: m_aUpdateMutex of TreeMgr must be acuired
 	OSL_ENSURE(_aComponent.getOptions().hasLocale(), "ERROR: OTreeDisposeScheduler: cannot handle complete user scheduling");
-
-	osl::MutexGuard aGuard( m_aMutex );
 
 	CFG_TRACE_INFO("Scheduling cache write for user '%s' with locale '%s'", 
 					OUSTRING2ASCII(_aComponent.getOptions().getEntity()), 
Index: configmgr/source/treecache/cachewritescheduler.hxx
===================================================================
RCS file: /cvs/util/configmgr/source/treecache/cachewritescheduler.hxx,v
retrieving revision 1.5
retrieving revision 1.5.84.2
diff -u -p -u -p -r1.5 -r1.5.84.2
--- configmgr/source/treecache/cachewritescheduler.hxx	8 Sep 2005 04:24:23 -0000	1.5
+++ configmgr/source/treecache/cachewritescheduler.hxx	11 Jan 2007 20:16:04 -0000	1.5.84.2
@@ -73,11 +73,9 @@ namespace configmgr
 	class OCacheWriteScheduler
 	{
 		typedef std::set< RequestOptions, lessRequestOptions > CacheWriteList; // fire and forget!
-        typedef backend::CacheController CacheManager;
 
 		class Timer : public vos::OTimer
 		{
-			osl::Mutex	m_aMutex;
 		public:
 			OCacheWriteScheduler* pParent;
 
@@ -86,9 +84,6 @@ namespace configmgr
 			// vos::OTimer
 			virtual void SAL_CALL onShot();
 
-			// 
-			osl::Mutex&		getShotMutex() {return m_aMutex;}
-
 			// stop the scheduling
 			void dispose() {
 				stop();
@@ -98,18 +93,15 @@ namespace configmgr
 		};
 		friend void Timer::onShot();
 	private:
-		mutable osl::Mutex	m_aMutex;
-		vos::ORef<Timer>	m_xTimer;
-		CacheManager&		m_rTreeManager;
-
-		CacheWriteList		m_aWriteList;
-
-        TimeInterval m_aWriteInterval;		
+	    vos::ORef<Timer>	      m_xTimer;
+	    backend::CacheController &m_rTreeManager;
+	    CacheWriteList	      m_aWriteList;
+	    TimeInterval	      m_aWriteInterval;
 		
 	public:
 	//-------- Construction and destruction -----------------------------------
 		explicit
-		OCacheWriteScheduler(CacheManager& _rTreeManager, TimeInterval const& _aWriteInterval) 
+		OCacheWriteScheduler(backend::CacheController& _rTreeManager, TimeInterval const& _aWriteInterval) 
 			: m_rTreeManager(_rTreeManager)
 			, m_aWriteInterval(_aWriteInterval)			
 		{
@@ -121,7 +113,7 @@ namespace configmgr
 		/// retrieves the recurrance interval used for cleanup
 		TimeInterval const& getWriteInterval() const 
 		{ 
-			osl::MutexGuard aGuard(m_aMutex);
+            UnoApiLock aLock;
 			return m_aWriteInterval; 
 		}
 
@@ -137,10 +129,6 @@ namespace configmgr
 
 		/// stop and discard pending activities
 		void stopAndWriteCache();
-
-		/// mutex for synchronisation 
-		osl::Mutex&		getShotMutex() {return m_xTimer->getShotMutex();}
-
 	private:
 		// vos::OTimer
 		void onTimerShot();
Index: configmgr/source/treecache/disposetimer.cxx
===================================================================
RCS file: /cvs/util/configmgr/source/treecache/disposetimer.cxx,v
retrieving revision 1.22
retrieving revision 1.22.24.2
diff -u -p -u -p -r1.22 -r1.22.24.2
--- configmgr/source/treecache/disposetimer.cxx	16 Sep 2006 15:26:19 -0000	1.22
+++ configmgr/source/treecache/disposetimer.cxx	11 Jan 2007 20:16:04 -0000	1.22.24.2
@@ -68,8 +68,6 @@ void OTreeDisposeScheduler::scheduleClea
 {
 	OSL_ENSURE(_aOptions.hasLocale(), "ERROR: OTreeDisposeScheduler: cannot handle complete user scheduling");
 
-	osl::MutexGuard aGuard( m_aMutex );
-
 	CFG_TRACE_INFO("Scheduling data cleanup for user '%s' with locale '%s'",
 					OUSTRING2ASCII(_aOptions.getEntity()),
                     OUSTRING2ASCII(_aOptions.getLocale()));
@@ -99,8 +97,6 @@ bool equivalentOptions(RequestOptions co
 
 void OTreeDisposeScheduler::clearTasks(RequestOptions const& _aOptions)
 {
-	osl::MutexGuard aOwnGuard( m_aMutex );
-
 	CFG_TRACE_INFO("Cancelling all data cleanup tasks for user '%s' with locale '%s'",
 					OUSTRING2ASCII(_aOptions.getEntity()),
                     OUSTRING2ASCII(_aOptions.getLocale()));
@@ -120,8 +116,6 @@ void OTreeDisposeScheduler::clearTasks(R
 
 void OTreeDisposeScheduler::stopAndClearTasks()
 {
-	osl::MutexGuard aOwnGuard( m_aMutex );
-
 	CFG_TRACE_INFO("Cancelling all data cleanup tasks, Stopping Cleanup timer");
 	CFG_TRACE_INFO_NI("- %d cleanup tasks were pending", int(m_aAgenda.size()) );
 
@@ -136,7 +130,6 @@ OTreeDisposeScheduler::Task OTreeDispose
 {
 	OSL_ASSERT( _rNextTime.isNever() ); // internal contract, we set this only in the positive case
 
-	osl::MutexGuard aOwnGuard( m_aMutex );
     Task aTask( false, RequestOptions() );
 
 	if (!m_aAgenda.empty())
@@ -163,7 +156,7 @@ OTreeDisposeScheduler::Task OTreeDispose
 
 void OTreeDisposeScheduler::Timer::onShot()
 {
-	osl::MutexGuard aGuard(m_aMutex);
+    UnoApiLock aLock;
 	if (pParent)
 		pParent->onTimerShot();
 }
@@ -197,18 +190,18 @@ void OTreeDisposeScheduler::onTimerShot(
 		OSL_ENSURE(false, "ERROR: Unknown Exception left a disposer");
 	}
 
-	osl::MutexGuard aGuard(m_aMutex);
-	implStartBefore(aNextTime);
+    OSL_ASSERT(UnoApiLock::isHeld());
+    implStartBefore(aNextTime);
 }
 // -------------------------------------------------------------------------
 
 // this really should be a member of the TreeManager (see TreeManager::disposeOne etc.)
 TimeStamp OTreeDisposeScheduler::runDisposer(TimeStamp const& _aActualTime)
 {
-	TimeStamp aNextTime = TimeStamp::never();
-	OSL_ASSERT(aNextTime.isNever());
+    TimeStamp aNextTime = TimeStamp::never();
+    OSL_ASSERT(aNextTime.isNever());
 
-	osl::ClearableMutexGuard aGuard( m_rTreeManager.m_aCacheList.mutex() );
+    OSL_ASSERT(UnoApiLock::isHeld());
 
     Task aTask = this->getTask( _aActualTime, aNextTime );
     if (aTask.first)
@@ -219,7 +212,7 @@ TimeStamp OTreeDisposeScheduler::runDisp
 						OUSTRING2ASCII(rTaskOptions.getEntity()),
                         OUSTRING2ASCII(rTaskOptions.getLocale()));
 
-        CacheManager::CacheRef aCache = m_rTreeManager.m_aCacheList.get(rTaskOptions);
+        CacheManager::CacheRef aCache = m_rTreeManager.m_aCacheMap.get(rTaskOptions);
         if (aCache.is())
 		{
 			CFG_TRACE_INFO_NI("- Found matching data container (TreeInfo) - collecting data");
@@ -235,7 +228,7 @@ TimeStamp OTreeDisposeScheduler::runDisp
 				OSL_ENSURE( !aCache->isEmpty(), "ERROR: Empty TreeInfo returning finite dispose time");
 
 				// repost with new time
-				osl::MutexGuard aOwnGuard( m_aMutex );
+                OSL_ASSERT(UnoApiLock::isHeld());
 
 				CFG_TRACE_INFO_NI("- Rescheduling current option set" );
 
@@ -271,9 +264,6 @@ TimeStamp OTreeDisposeScheduler::runDisp
 			else
 				CFG_TRACE_INFO_NI("- Currently no more cleanup tasks for this options set" );
 
-			// clear the guard and throw away the nodes
-			aGuard.clear();
-
 			if (!aDisposeList.empty())
 			{
 				CFG_TRACE_INFO_NI("- Closing %d modules", int(aDisposeList.size()) );
@@ -354,15 +344,14 @@ void OTreeDisposeScheduler::implStartBef
 }
 // -------------------------------------------------------------------------
 
-// should be called guarded only (m_aMutex must be locked)
 TimeStamp OTreeDisposeScheduler::implAddTask(RequestOptions const& _aOptions, TimeStamp const& _aTime)
 {
-	typedef Agenda::value_type AgendaType;
+    OSL_ASSERT(UnoApiLock::isHeld());
 
 	// try to insert after euivalent entries (but STL may ignore the hint)
 	Agenda::iterator where = m_aAgenda.upper_bound(_aTime);
 
-	m_aAgenda.insert(where, AgendaType(_aTime,_aOptions));
+	m_aAgenda.insert(where, Agenda::value_type(_aTime,_aOptions));
 
 	OSL_ASSERT(!m_aAgenda.empty());
 
Index: configmgr/source/treecache/disposetimer.hxx
===================================================================
RCS file: /cvs/util/configmgr/source/treecache/disposetimer.hxx,v
retrieving revision 1.13
retrieving revision 1.13.84.1
diff -u -p -u -p -r1.13 -r1.13.84.1
--- configmgr/source/treecache/disposetimer.hxx	8 Sep 2005 04:24:50 -0000	1.13
+++ configmgr/source/treecache/disposetimer.hxx	11 Jan 2007 20:16:04 -0000	1.13.84.1
@@ -88,7 +88,6 @@ namespace configmgr
 
 		class Timer : public vos::OTimer
 		{
-			osl::Mutex	m_aMutex;
 		public:
 			OTreeDisposeScheduler* pParent;
 
@@ -97,20 +96,13 @@ namespace configmgr
 			// vos::OTimer
 			virtual void SAL_CALL onShot();
 
-			// 
-			osl::Mutex&		getShotMutex() {return m_aMutex;}
-
 			// stop the scheduling
 			void dispose() {stop(); pParent = NULL;}
-
 		};
 		friend void Timer::onShot();
 
 	private:
-		mutable osl::Mutex	m_aMutex;
-		
-		Agenda				m_aAgenda;
-
+        Agenda				m_aAgenda;
 		vos::ORef<Timer>	m_xTimer;
 		CacheManager&		m_rTreeManager;
 
@@ -138,18 +130,16 @@ namespace configmgr
 
 		~OTreeDisposeScheduler() { stopAndClearTasks(); }
 		
-	//-------- Delay and Interval ---------------------------------------------
+        //-------- Delay and Interval ---------------------------------------------
 		/// sets the initial delay to be used for cleanup in the future, does not affect an already started process
 		void setCleanupDelay(TimeInterval const& _aCleanupDelay)  
 		{ 
-			osl::MutexGuard aGuard(m_aMutex);
 			m_aCleanupDelay = _aCleanupDelay; 
 		}
 
 		/// sets the initial delay and recurrance interval to be used for cleanup in the future, does not affect an already started process
 		void setCleanupDelay(TimeInterval const& _aCleanupDelay, TimeInterval const& _aCleanupInterval)  
 		{ 
-			osl::MutexGuard aGuard(m_aMutex);
 			m_aCleanupDelay = _aCleanupDelay; 
 			m_aCleanupInterval = _aCleanupInterval; 
 		}
@@ -157,21 +147,18 @@ namespace configmgr
 		/// sets the recurrance interval to be used for cleanup in the future, does not affect an already started process
 		void setCleanupInterval(TimeInterval const& _aCleanupInterval)  
 		{ 
-			osl::MutexGuard aGuard(m_aMutex);
 			m_aCleanupInterval = _aCleanupInterval; 
 		}
 
 		/// retrieves the initial delay used for cleanup
 		TimeInterval const& getCleanupDelay() const 
 		{ 
-			osl::MutexGuard aGuard(m_aMutex);
 			return m_aCleanupDelay; 
 		}
 
 		/// retrieves the recurrance interval used for cleanup
 		TimeInterval const& getCleanupInterval() const 
 		{ 
-			osl::MutexGuard aGuard(m_aMutex);
 			return m_aCleanupInterval; 
 		}
 
@@ -184,9 +171,6 @@ namespace configmgr
 
 		/// stop and discard pending activities
 		void stopAndClearTasks();
-
-		/// mutex for synchronisation 
-		osl::Mutex&		getShotMutex() {return m_xTimer->getShotMutex();}
 
 	private:
 		// vos::OTimer
Index: configmgr/source/treecache/invalidatetree.cxx
===================================================================
RCS file: /cvs/util/configmgr/source/treecache/invalidatetree.cxx,v
retrieving revision 1.21
retrieving revision 1.21.24.4
diff -u -p -u -p -r1.21 -r1.21.24.4
--- configmgr/source/treecache/invalidatetree.cxx	16 Sep 2006 15:26:33 -0000	1.21
+++ configmgr/source/treecache/invalidatetree.cxx	16 Jan 2007 12:18:24 -0000	1.21.24.4
@@ -56,9 +56,6 @@
 #ifndef CONFIGMGR_TREEACCESSOR_HXX
 #include "treeaccessor.hxx"
 #endif
-#ifndef CONFIGMGR_UPDATEACCESSOR_HXX
-#include "updateaccessor.hxx"
-#endif
 
 #ifndef _CONFIGMGR_TRACER_HXX_
 #include "tracer.hxx"
@@ -93,7 +90,7 @@ namespace configmgr
 namespace backend
 {
 // -----------------------------------------------------------------------------	
-std::auto_ptr<SubtreeChange> createDiffs(data::NodeAccessRef const& _aCachedNode, 
+std::auto_ptr<SubtreeChange> createDiffs(data::NodeAccess const& _aCachedNode, 
                                             ISubtree const * _pLoadedSubtree,
                                             AbsolutePath const& _aAbsoluteSubtreePath)
 {
@@ -152,7 +149,8 @@ class OInvalidateTreeThread: public vos:
 	RequestOptions      m_aOptions;
 
 public:
-	OInvalidateTreeThread(CacheManager* _rTreeManager,  Name const & _aComponentName, 
+	OInvalidateTreeThread(CacheManager* _rTreeManager,
+                          Name const & _aComponentName, 
 						  const RequestOptions& _aOptions)
 	: m_rTreeManager(_rTreeManager)
 	, m_aComponentName(_aComponentName)
@@ -193,13 +191,11 @@ void CacheController::invalidateComponen
 
 CacheLocation CacheController::refreshComponent(ComponentRequest const & _aRequest) CFG_UNO_THROW_ALL()
 {
-    if (m_bDisposing) return CacheLocation();
+    if (m_bDisposing) return NULL;
 
     CacheRef aCache = this->getCacheAlways(_aRequest.getOptions());
 
-    if (!aCache.is()) return CacheLocation();
-	
-    osl::MutexGuard aCacheLineGuard(aCache->mutex());
+    if (!aCache.is()) return NULL;
 	
     // load the Node direct from the session, without using the cache
     ComponentRequest aForcedRequest(_aRequest);
@@ -210,39 +206,32 @@ CacheLocation CacheController::refreshCo
     NodeInstance aNodeInstance(aLoadedInstance.mutableInstance().mutableData(),aRequestPath) ;
     NodeResult aLoadedNodeInstance(aNodeInstance) ;
     
-    CacheLocation aResult;
-	if (aLoadedNodeInstance.is())
-	{
+    data::TreeAddress aResult = NULL;
+    if (aLoadedNodeInstance.is())
+    {
         Name aModuleName = aLoadedNodeInstance->root().getModuleName();
 
-        memory::UpdateAccessor aChangingAccessor( aCache->getDataSegment(aModuleName) ); 
-        OSL_ENSURE(aChangingAccessor.is(), "No existing cache line for tree being refreshed");
-
-        data::TreeAddress aCachedTreeAddress = aCache->acquireModule(aModuleName);
-
-        aResult.segment = aCache->getDataSegmentAddress(aModuleName);
-        aResult.address = aCachedTreeAddress.addressValue();
+        bool bAcquired = aCache->acquireModule(aModuleName);
+        aResult = CacheLocation( aCache->getTreeAddress(aModuleName) );
 
-        if (aCachedTreeAddress.is())
+        if (bAcquired)
         try
-		{
+	{
             std::auto_ptr<SubtreeChange> aTreeChanges;
             data::NodeAddress aRootAddress;
 
             {
-                data::TreeAccessor aTreeAccess(aChangingAccessor.accessor(),aCachedTreeAddress);
-                data::NodeAccessRef aRootNode = aTreeAccess.getRootNode();
+                data::TreeAccessor aTreeAccess(aResult);
+                data::NodeAccess aRootNode = aTreeAccess.getRootNode();
 
                 aTreeChanges = createDiffs(aRootNode, aLoadedNodeInstance->data().get(), aLoadedNodeInstance->root().location());
-                aRootAddress = aRootNode.address();
+                aRootAddress = aRootNode;
             }
 
             if (aTreeChanges.get() != NULL)
             {
-				// change all Values... found in the Subtree in the CacheTree
-				applyUpdateWithAdjustmentToTree(*aTreeChanges, aChangingAccessor, aRootAddress);
-				
-                data::Accessor aNotifyLock = aChangingAccessor.downgrade(); // keep a read lock during notification
+		// change all Values... found in the Subtree in the CacheTree
+		applyUpdateWithAdjustmentToTree(*aTreeChanges, aRootAddress);
 				
                 UpdateRequest anUpdateReq(  aTreeChanges.get(),
                                             aLoadedNodeInstance->root().location(),
@@ -251,15 +240,14 @@ CacheLocation CacheController::refreshCo
 
                 m_aNotifier.notifyChanged(anUpdateReq);
             }
-
-			aCache->releaseModule(aModuleName);
+	    aCache->releaseModule(aModuleName);
         }
         catch (...)
         {
-			aCache->releaseModule(aModuleName);
+	    aCache->releaseModule(aModuleName);
             throw;
         }
-	}
+    }
     return aResult;
 }
 
@@ -268,6 +256,7 @@ void OInvalidateTreeThread::run()
 {
 	try
 	{
+        UnoApiLock aLock;
         ComponentRequest aRequest(m_aComponentName, m_aOptions);
 		m_rTreeManager->refreshComponent(aRequest);
 	}
Index: configmgr/source/treecache/treemanager.cxx
===================================================================
RCS file: /cvs/util/configmgr/source/treecache/treemanager.cxx,v
retrieving revision 1.11
retrieving revision 1.11.24.5
diff -u -p -u -p -r1.11 -r1.11.24.5
--- configmgr/source/treecache/treemanager.cxx	16 Sep 2006 15:27:00 -0000	1.11
+++ configmgr/source/treecache/treemanager.cxx	16 Jan 2007 12:18:24 -0000	1.11.24.5
@@ -51,9 +51,6 @@
 #ifndef CONFIGMGR_TREEACCESSOR_HXX
 #include "treeaccessor.hxx"
 #endif
-#ifndef CONFIGMGR_UPDATEACCESSOR_HXX
-#include "updateaccessor.hxx"
-#endif
 
 #ifndef _COM_SUN_STAR_CONTAINER_NOSUCHELEMENTEXCEPTION_HPP_
 #include <com/sun/star/container/NoSuchElementException.hpp>
@@ -110,10 +107,7 @@ void TreeManager::disposeAll()
 	CFG_TRACE_INFO("TreeManager: Disposing all data" );			
     CacheList::Map aReleaseList;
 	
-	{
-		osl::MutexGuard aGuard(m_aCacheList.mutex());			
-		m_aCacheList.swap(aReleaseList);			 // move data out of m_aCacheList		
-	}
+    m_aCacheList.swap(aReleaseList);			 // move data out of m_aCacheList		
 
 	// free all the trees - not exception safe !! (i.e. disposeBroadcastHelper() must not throw)
 	for (CacheList::Map::iterator i = aReleaseList.begin(); i != aReleaseList.end(); ++i)
@@ -161,8 +155,6 @@ void TreeManager::disposeOne(RequestOpti
 // -------------------------------------------------------------------------
 void TreeManager::disposeUser(RequestOptions const& _aUserOptions)
 {
-	osl::ClearableMutexGuard aGuard(m_aCacheList.mutex());
-	
 	CFG_TRACE_INFO("TreeManager: Disposing data and TreeInfo(s) for user '%s'", 
 					OUSTRING2ASCII(_aUserOptions.getEntity()) );
 
@@ -206,9 +198,6 @@ void TreeManager::disposeUser(RequestOpt
         m_aCacheList.swap(aCacheData);
 	}
 
-	// got all out of external reach - now dispose/notify without lock
-	aGuard.clear();
-
 	for (DisposeList::iterator i = aDisposeList.begin(); i != aDisposeList.end(); ++i)
 	{
 		if (i->second.is())
@@ -241,10 +230,10 @@ ConfigChangeBroadcastHelper* TreeManager
 
 
 // -------------------------------------------------------------------------
-TreeManager::TreeManager(BackendCacheRef const & _xBackend, memory::HeapManager & _rCacheHeapManager) 
+TreeManager::TreeManager(BackendCacheRef const & _xBackend) 
 : m_xCacheController(_xBackend)
 , m_aCacheList()
-, m_aTemplates(new CacheData(_rCacheHeapManager))
+, m_aTemplates(new CacheData())
 , m_bEnableAsync(true)
 {
     OSL_PRECOND(_xBackend.is(),"Trying to create a TreeManager without a backend");
@@ -293,115 +282,84 @@ void TreeManager::disposeBackendCache() 
 
 // -------------------------------------------------------------------------
 
-memory::HeapManager & TreeManager::getCacheHeapManager() const
-{
-    return m_aTemplates.get()->getHeapManager();
-}
-// -------------------------------------------------------------------------
-
 TreeManager::CacheRef TreeManager::getCacheAlways(RequestOptions const & _aOptions)
 {
-    osl::MutexGuard aGuard( m_aCacheList.mutex() );
-
     CacheRef aResult = m_aCacheList.get(_aOptions);
     if (!aResult.is())
     {
-        CacheRef aNewCache( new Cache(getCacheHeapManager(), ConfigChangeBroadcaster::newBroadcastHelper()) );
+        CacheRef aNewCache( new Cache(ConfigChangeBroadcaster::newBroadcastHelper()) );
         aResult = m_aCacheList.insert(_aOptions,aNewCache);
     }
     return aResult;
 }
 
 // -------------------------------------------------------------------------
-memory::Segment* TreeManager::getDataSegment(AbsolutePath const& _rAccessor, 
-                                             const RequestOptions& _aOptions)
-{
-    CacheRef aCache = m_aCacheList.get(_aOptions);
-
-	OSL_ENSURE(aCache.is(), "No cache data to get segment for");
-
-    if (aCache.is())
-        return aCache->getDataSegment(_rAccessor);
-
-    else
-        return NULL;
-}
-// -------------------------------------------------------------------------
 
 data::NodeAccess TreeManager::requestSubtree(AbsolutePath const& aSubtreePath, 
-									            const RequestOptions& _aOptions)  
-                                             CFG_UNO_THROW_ALL(  )
+					     const RequestOptions& _aOptions)  
+						CFG_UNO_THROW_ALL()
 {
-	CFG_TRACE_INFO("TreeManager: request for subtree '%s'", OUSTRING2ASCII(aSubtreePath.toString()));
+    CFG_TRACE_INFO("TreeManager: request for subtree '%s'", OUSTRING2ASCII(aSubtreePath.toString()));
 
     CacheRef aCache = getCacheAlways(_aOptions);
-	OSL_ENSURE(aCache.is(),"TreeManager: Cannot create cache access for loading node");
+    OSL_ENSURE(aCache.is(),"TreeManager: Cannot create cache access for loading node");
 
-    data::Accessor aAccessor(NULL);
-    
     if (!aCache->hasModule(aSubtreePath))
     {
-		CFG_TRACE_INFO_NI("TreeManager: cache miss. going to load the node");
+	CFG_TRACE_INFO_NI("TreeManager: cache miss. going to load the node");
         backend::ComponentRequest aQuery( aSubtreePath.getModuleName(), _aOptions );
 
         backend::CacheLocation aLoadedLocation = getCacheLoader()->loadComponent(aQuery);
-        if (aLoadedLocation.isNull())
+        if (aLoadedLocation == NULL)
         {
-		    CFG_TRACE_WARNING_NI("TreeManager: requested component not found");
+            CFG_TRACE_WARNING_NI("TreeManager: requested component not found");
             throw com::sun::star::container::
                     NoSuchElementException( MAKEUSTRING("Requested component not found"), NULL);
         }
 
-		CFG_TRACE_INFO_NI("TreeManager: attaching loaded cache segment ");
-
-        aAccessor = data::Accessor(aCache->attachDataSegment(aLoadedLocation.segment,aSubtreePath));
-        OSL_ENSURE(aAccessor.is(),"Cannot attach to loaded component");
+	CFG_TRACE_INFO_NI("TreeManager: attaching loaded cache segment ");
+        aCache->attachModule(aLoadedLocation,aSubtreePath.getModuleName());
     }
     else
-	{ 
-	    CFG_TRACE_INFO_NI("TreeManager: found node in cache");
+    { 
+	CFG_TRACE_INFO_NI("TreeManager: found node in cache");
         if (_aOptions.isRefreshEnabled())
         {
              backend::ComponentRequest aRequest( aSubtreePath.getModuleName(), _aOptions );
              getCacheLoader()->refreshComponent(aRequest);
         }
-       
-        aAccessor = data::Accessor(aCache->getDataSegment(aSubtreePath));
-        OSL_ENSURE(aAccessor.is(),"Cannot get accessor for existing component");
-        
     }
 
-    data::NodeAddress aResultAddress = aCache->acquireNode(aAccessor,aSubtreePath);
+    data::NodeAddress aResultAddress = aCache->acquireNode(aSubtreePath);
 
-    return data::NodeAccess(aAccessor,aResultAddress);
+    return data::NodeAccess(aResultAddress);
 }
 
 // -------------------------------------------------------------------------
 void TreeManager::fetchSubtree(AbsolutePath const& aSubtreePath, const RequestOptions&  ) CFG_NOTHROW()
 {
     (void) aSubtreePath; // avoid warning about unused parameter
-	CFG_TRACE_WARNING("TreeManager: Prefetching not implemented. (Request to prefetch component %s.", OUSTRING2ASCII(aSubtreePath.toString()));
+    CFG_TRACE_WARNING("TreeManager: Prefetching not implemented. (Request to prefetch component %s.", OUSTRING2ASCII(aSubtreePath.toString()));
 }
 
 // -------------------------------------------------------------------------
-sal_Bool TreeManager::fetchDefaultData( memory::UpdateAccessor& _aAccessToken, 
-                                        AbsolutePath const& aSubtreePath, 
-									    const RequestOptions& _aOptions
-									  ) CFG_UNO_THROW_ALL(  )
+sal_Bool TreeManager::fetchDefaultData( AbsolutePath const& aSubtreePath, 
+                                        const RequestOptions& _aOptions
+    ) CFG_UNO_THROW_ALL()
 {
-	CFG_TRACE_INFO("tree manager: checking the cache for defaults");
+    CFG_TRACE_INFO("tree manager: checking the cache for defaults");
 
     CacheRef aCache = m_aCacheList.get(_aOptions);
 
     if (!aCache.is())
     {
-	    OSL_ENSURE(aCache.is(),"TreeManager: Cache access to fetch defaults for does not exist ! Where does the node access come from ?");
+	OSL_ENSURE(aCache.is(),"TreeManager: Cache access to fetch defaults for does not exist ! Where does the node access come from ?");
         return false;
     }
 
-    if (aCache->hasModuleDefaults(_aAccessToken.accessor(),aSubtreePath))
+    if (aCache->hasModuleDefaults(aSubtreePath))
     {
-		CFG_TRACE_INFO_NI("TreeManager: found default data in cache");
+        CFG_TRACE_INFO_NI("TreeManager: found default data in cache");
         return true;
     }
 
@@ -412,15 +370,15 @@ sal_Bool TreeManager::fetchDefaultData( 
     backend::NodeResult aDefaults = getCacheLoader()->getDirectDataProvider().getDefaultData( aRequest );
 
     if (!aDefaults.is())
-	{
-		CFG_TRACE_INFO_NI("TreeManager: merging loaded defaults into cache");
-        return aCache->insertDefaults(_aAccessToken,aDefaults.instance());
-	}
-	else
-	{
+    {
+        CFG_TRACE_INFO_NI("TreeManager: merging loaded defaults into cache");
+        return aCache->insertDefaults(aDefaults.instance());
+    }
+    else
+    {
         CFG_TRACE_WARNING_NI("TreeManager: cannot load defaults: no data available or not supported");
         return false;
-	}
+    }
 }
 
 // -------------------------------------------------------------------------
@@ -429,7 +387,7 @@ std::auto_ptr<ISubtree> TreeManager::req
 										               ) CFG_UNO_THROW_ALL(  )
 {
     // to do: check cache for existing default data (?!)
-	CFG_TRACE_INFO_NI("TreeManager: loading default data directly");
+    CFG_TRACE_INFO_NI("TreeManager: loading default data directly");
 
     backend::NodeRequest aRequest(aSubtreePath,_aOptions);
 
@@ -453,13 +411,12 @@ AbsolutePath TreeManager::encodeTemplate
     aResult.prepend(aTemplateModule);
 //    aResult.prepend(aTemplateRoot);
 
-	return AbsolutePath(aResult);
+    return AbsolutePath(aResult);
 }
         
 // -------------------------------------------------------------------------
-data::TreeAccessor TreeManager::requestTemplate(data::Accessor const& /*_aSourceAccessor*/,
-                                                Name const& _rName, Name const& _rModule
-												) CFG_UNO_THROW_ALL(  )
+data::TreeAccessor TreeManager::requestTemplate(Name const& _rName,
+                                                Name const& _rModule) CFG_UNO_THROW_ALL(  )
 {
 	OSL_ENSURE(!_rName.isEmpty(), "TreeManager::requestTemplate : invalid template name !");
 
@@ -468,51 +425,43 @@ data::TreeAccessor TreeManager::requestT
 	AbsolutePath aTemplateLocation = encodeTemplateLocation(_rName, _rModule);
 	Name aCacheModule = aTemplateLocation.getModuleName();
 
-	osl::MutexGuard aGuard(m_aTemplates.mutex());
-
-    data::Accessor aTemplatesAccessor( getTemplates().getDataSegment(aCacheModule) );
-
-    if (!getTemplates().hasNode(aTemplatesAccessor,aTemplateLocation))
+    if (!getTemplates().hasNode(aTemplateLocation))
     {
-        aTemplatesAccessor.clear();
-
-		CFG_TRACE_INFO_NI("TreeManager: cache miss. going to load the template");
+    	CFG_TRACE_INFO_NI("TreeManager: cache miss. going to load the template");
         backend::TemplateRequest aQuery( _rName, _rModule );
 
         backend::CacheLocation aLoadedLocation = getCacheLoader()->loadTemplate(aQuery);
-        if (aLoadedLocation.isNull())
+        if (aLoadedLocation == NULL)
         {
-		    CFG_TRACE_ERROR_NI("TreeManager: requested template module not found");
+            CFG_TRACE_ERROR_NI("TreeManager: requested template module not found");
             throw com::sun::star::container::
                     NoSuchElementException( MAKEUSTRING("Requested template module not found"), NULL);
         }
 
-		CFG_TRACE_INFO_NI("TreeManager: attaching to loaded template module");
+        CFG_TRACE_INFO_NI("TreeManager: attaching to loaded template module");
 
-        aTemplatesAccessor = data::Accessor(getTemplates().attachDataSegment(aLoadedLocation.segment,aCacheModule));
-        OSL_ENSURE(aTemplatesAccessor.is(),"Cannot attach to loaded component");
+        getTemplates().attachModule(aLoadedLocation,aCacheModule);
 
         // create a client ref count on the template module
-        getTemplates().acquireNode(aTemplatesAccessor,aTemplateLocation);
+        getTemplates().acquireNode(aTemplateLocation);
     }
     else
-	{ 
-		CFG_TRACE_INFO_NI("TreeManager: template module found in cache");
-        OSL_ENSURE(aTemplatesAccessor.is(),"No accessor for existing data ?");
+    { 
+        CFG_TRACE_INFO_NI("TreeManager: template module found in cache");
     }
 
-    data::TreeAddress aTemplateAddr = getTemplates().getTemplateTree(aTemplatesAccessor,aTemplateLocation);
-	if (aTemplateAddr.isNull())
+    data::TreeAddress aTemplateAddr = getTemplates().getTemplateTree(aTemplateLocation);
+    if (aTemplateAddr == NULL)
     {
 		CFG_TRACE_ERROR_NI("TreeManager: template not found in module");
 		throw com::sun::star::container::
                     NoSuchElementException( MAKEUSTRING("Unknown template. Type description could not be found in the given module."), NULL);
     }
-    return data::TreeAccessor(aTemplatesAccessor,aTemplateAddr);
+    return data::TreeAccessor(aTemplateAddr);
 }
 
 // -------------------------------------------------------------------------
-void TreeManager::saveAndNotifyUpdate(data::Accessor const& /*_aChangedDataAccessor*/, TreeChangeList const& aChangeTree) CFG_UNO_THROW_ALL(  )
+void TreeManager::saveAndNotifyUpdate(TreeChangeList const& aChangeTree) CFG_UNO_THROW_ALL(  )
 {
     {
 	    CFG_TRACE_INFO("TreeManager: committing an Update to the cache controller");
@@ -529,20 +478,17 @@ void TreeManager::saveAndNotifyUpdate(da
         getCacheLoader()->saveAndNotify(anUpdate);
 	    CFG_TRACE_INFO_NI("TreeManager: committing done");
     }
-
-    // notification should be done via the cache loader
-	// this->ConfigChangeBroadcaster::fireChanges(_aChangedDataAccessor, aChangeTree, false);
 }
 
 // -------------------------------------------------------------------------
-void TreeManager::fireChanges(data::Accessor const& _aChangedDataAccessor, TreeChangeList const& aChangeTree, sal_Bool _bError)
+void TreeManager::fireChanges(TreeChangeList const& aChangeTree, sal_Bool _bError)
 {
 	CFG_TRACE_INFO("TreeManager: broadcasting changes");
-	ConfigChangeBroadcaster::fireChanges(_aChangedDataAccessor, aChangeTree, _bError);
+	ConfigChangeBroadcaster::fireChanges(aChangeTree, _bError);
 }
 
 // -----------------------------------------------------------------------------
-void TreeManager::updateTree(memory::UpdateAccessor& _aAccessToken, TreeChangeList& _aChanges) CFG_UNO_THROW_ALL(  )
+void TreeManager::updateTree(TreeChangeList& _aChanges) CFG_UNO_THROW_ALL(  )
 {
 	CFG_TRACE_INFO("TreeManager: updating the cache from a changes list");
 	    
@@ -558,7 +504,7 @@ void TreeManager::updateTree(memory::Upd
     }
 
 	// merge the changes into the tree
-	aCache->applyUpdate(_aAccessToken, anUpdate);
+	aCache->applyUpdate(anUpdate);
 
 	CFG_TRACE_INFO_NI("TreeManager: cache update done");
 }
@@ -635,31 +581,28 @@ void TreeManager::disposeData(const Requ
 // ----------------------------------------------------------------------------
 void TreeManager::nodeUpdated(TreeChangeList& _rChanges)
 {
-	CFG_TRACE_INFO("TreeManager: nodeUpdated");	
-	try
-	{		
-        CacheRef aCache = m_aCacheList.get(_rChanges.getOptions());
+    CFG_TRACE_INFO("TreeManager: nodeUpdated");	
+    try
+    {		
+	CacheRef aCache = m_aCacheList.get(_rChanges.getOptions());
 
-		if (aCache.is())
-		{
-			// first approve the changes and merge them with the current tree
-			AbsolutePath aSubtreeName = _rChanges.getRootNodePath();
-
-            memory::Accessor aAccessor( aCache->getDataSegment(aSubtreeName) );
-            OSL_ENSURE(aAccessor.is(), "TreeManager::nodeUpdated : cannot access cache !"); 
+	if (aCache.is())
+	{
+	    // first approve the changes and merge them with the current tree
+	    AbsolutePath aSubtreeName = _rChanges.getRootNodePath();
 
-            data::NodeAddress aCacheTree = aCache->findInnerNode(aAccessor,aSubtreeName);
-            OSL_ENSURE(aCacheTree.is(), "TreeManager::nodeUpdated : node not found in cache!");
+        data::NodeAddress aCacheTree = aCache->findInnerNode(aSubtreeName);
+        OSL_ENSURE(aCacheTree != NULL, "TreeManager::nodeUpdated : node not found in cache!");
 
-			if (aCacheTree.is())
-			    this->fireChanges(aAccessor,_rChanges,false);
-		}	
-	}
-	catch (uno::RuntimeException&)
-	{
-		CFG_TRACE_ERROR_NI("TreeManager::nodeUpdated : could not notify !");
-	}
-	CFG_TRACE_INFO_NI("TreeManager: nodeUpdated done");	
+	    if (aCacheTree != NULL)
+            this->fireChanges(_rChanges,false);
+	}	
+    }
+    catch (uno::RuntimeException&)
+    {
+	CFG_TRACE_ERROR_NI("TreeManager::nodeUpdated : could not notify !");
+    }
+    CFG_TRACE_INFO_NI("TreeManager: nodeUpdated done");	
 }
 
 // ----------------------------------------------------------------------------
Index: configmgr/source/treemgr/collectchanges.cxx
===================================================================
RCS file: /cvs/util/configmgr/source/treemgr/collectchanges.cxx,v
retrieving revision 1.9
retrieving revision 1.9.24.2
diff -u -p -u -p -r1.9 -r1.9.24.2
--- configmgr/source/treemgr/collectchanges.cxx	16 Sep 2006 15:27:12 -0000	1.9
+++ configmgr/source/treemgr/collectchanges.cxx	12 Jan 2007 14:50:45 -0000	1.9.24.2
@@ -102,14 +102,12 @@ bool convertNodeChange(NodeChangeData& a
 //-----------------------------------------------------------------------------
 
 CollectChanges::CollectChanges(	NodeChangesInformation& rTargetList_, 
-                data::Accessor const& _aDataAccessor,
 				TreeImpl& rStartTree_, NodeOffset nStartNode_,
                 TemplateHolder aElementTemplate_,
 				TreeDepth nMaxDepth) 
 : m_rTargetList(rTargetList_)
 , m_aAccessor()
 , m_aContextTypeName()
-, m_aDataAccessor(_aDataAccessor)
 , m_pBaseTree(&rStartTree_)
 , m_nBaseNode(nStartNode_)
 , m_nDepthLeft( nMaxDepth ) 
@@ -123,7 +121,6 @@ CollectChanges::CollectChanges(	CollectC
 : m_rTargetList(rBase.m_rTargetList)
 , m_aAccessor(rBase.m_aAccessor.compose(rChildName))
 , m_aContextTypeName(aSubTypeName_)
-, m_aDataAccessor(rBase.m_aDataAccessor)
 , m_pBaseTree(rBase.m_pBaseTree)
 , m_nBaseNode(rBase.m_nBaseNode)
 , m_nDepthLeft(childDepth(rBase.m_nDepthLeft)) 
@@ -149,7 +146,7 @@ Path::Component CollectChanges::implGetN
 //-----------------------------------------------------------------------------
 void CollectChanges::collectFrom(ValueChange const& aChange_)
 { 
-	NodeChangeInformation aInfo(m_aDataAccessor);
+	NodeChangeInformation aInfo;
 
 	if ( convertNodeChange( aInfo.change, aChange_ ) &&
 		 implSetLocation( aInfo.location, aChange_, false ) )
@@ -161,7 +158,7 @@ void CollectChanges::collectFrom(ValueCh
 //-----------------------------------------------------------------------------
 void CollectChanges::collectFrom(AddNode const& aChange_)
 { 
-	NodeChangeInformation aInfo(m_aDataAccessor);
+	NodeChangeInformation aInfo;
 
 	if ( convertNodeChange( aInfo.change, aChange_ ) &&
 		 implSetLocation( aInfo.location, aChange_, true ) )
@@ -173,7 +170,7 @@ void CollectChanges::collectFrom(AddNode
 //-----------------------------------------------------------------------------
 void CollectChanges::collectFrom(RemoveNode const& aChange_)
 { 
-	NodeChangeInformation aInfo(m_aDataAccessor);
+	NodeChangeInformation aInfo;
 
 	if ( convertNodeChange( aInfo.change, aChange_ ) &&
 		 implSetLocation( aInfo.location, aChange_, true ) )
Index: configmgr/source/treemgr/collectchanges.hxx
===================================================================
RCS file: /cvs/util/configmgr/source/treemgr/collectchanges.hxx,v
retrieving revision 1.5
retrieving revision 1.5.84.2
diff -u -p -u -p -r1.5 -r1.5.84.2
--- configmgr/source/treemgr/collectchanges.hxx	8 Sep 2005 04:26:35 -0000	1.5
+++ configmgr/source/treemgr/collectchanges.hxx	12 Jan 2007 14:50:45 -0000	1.5.84.2
@@ -72,7 +72,6 @@ namespace configmgr
 			NodeChangesInformation&	m_rTargetList;
 			RelativePath			m_aAccessor;
             Name                    m_aContextTypeName;
-            data::Accessor          m_aDataAccessor;
 			TreeImpl*				m_pBaseTree;
 			NodeOffset				m_nBaseNode;
 			TreeDepth				m_nDepthLeft;
@@ -80,7 +79,6 @@ namespace configmgr
 		public:
 			/// Constructs a Visitor object, sets the output target list and context
 			CollectChanges(	NodeChangesInformation& rTargetList_, 
-                            data::Accessor const& _aDataAccessor,
 							TreeImpl& rStartTree_, NodeOffset nStartNode_, 
                             TemplateHolder aElementTemplate_,
 							TreeDepth nMaxDepth = c_TreeDepthAll);
Index: configmgr/source/treemgr/configdefaultprovider.cxx
===================================================================
RCS file: /cvs/util/configmgr/source/treemgr/configdefaultprovider.cxx,v
retrieving revision 1.8
retrieving revision 1.8.24.3
diff -u -p -u -p -r1.8 -r1.8.24.3
--- configmgr/source/treemgr/configdefaultprovider.cxx	16 Sep 2006 15:27:26 -0000	1.8
+++ configmgr/source/treemgr/configdefaultprovider.cxx	16 Jan 2007 12:18:24 -0000	1.8.24.3
@@ -51,9 +51,6 @@
 #ifndef CONFIGMGR_CONFIGNODEIMPL_HXX_
 #include "treeimpl.hxx"
 #endif
-#ifndef CONFIGMGR_UPDATEACCESSOR_HXX
-#include "updateaccessor.hxx"
-#endif
 #ifndef CONFIGMGR_MISC_OPTIONS_HXX_
 #include "options.hxx"
 #endif
@@ -118,7 +115,6 @@ DefaultProvider::DefaultProvider(rtl::Re
 
 /// tries to load a default instance of the specified node
 std::auto_ptr<ISubtree> DefaultProvider::getDefaultTree(
-            memory::UpdateAccessor& _aTreeAccessor,
             Tree const& _aTree, NodeRef const& _aNode
      ) const CFG_UNO_THROW_ALL()
 {
@@ -130,9 +126,7 @@ std::auto_ptr<ISubtree> DefaultProvider:
 //        clone the ISubtree (no interface for that) :-(
 
     if (m_aProxy.is() && aAttributes.existsInDefault()) 
-    {
-        aRet = m_aProxy->getDefaultTree(_aTreeAccessor,_aTree.getAbsolutePath(_aNode));
-    }
+        aRet = m_aProxy->getDefaultTree(_aTree.getAbsolutePath(_aNode));
 
     return aRet;
 }
@@ -143,9 +137,7 @@ static bool shouldFetchDefaultData(TreeR
 {
     bool bShouldFetch = false;
 
-    data::Accessor aTempAccess( getRootSegment(_aTreeRef) );
-    
-    Tree aTempTree(aTempAccess, _aTreeRef);
+    Tree aTempTree(_aTreeRef);
     
     node::Attributes aAttributes = aTempTree.getAttributes(aTempTree.getRootNode());
 
Index: configmgr/source/treemgr/configgroup.cxx
===================================================================
RCS file: /cvs/util/configmgr/source/treemgr/configgroup.cxx,v
retrieving revision 1.12
retrieving revision 1.12.24.3
diff -u -p -u -p -r1.12 -r1.12.24.3
--- configmgr/source/treemgr/configgroup.cxx	16 Sep 2006 15:27:53 -0000	1.12
+++ configmgr/source/treemgr/configgroup.cxx	16 Jan 2007 12:18:25 -0000	1.12.24.3
@@ -378,9 +378,7 @@ GroupDefaulter::GroupDefaulter(Tree cons
 //-----------------------------------------------------------------------------
 bool GroupDefaulter::isDataAvailable(TreeRef const& _aParentTree, NodeRef const& _aGroupNode)
 { 
-    data::Accessor aTempAccess( getRootSegment(_aParentTree) );
-    
-    Tree aTempTree(aTempAccess, _aParentTree);
+    Tree aTempTree(_aParentTree);
     
     return aTempTree.areValueDefaultsAvailable(_aGroupNode);
 }
Index: configmgr/source/treemgr/configpath.cxx
===================================================================
RCS file: /cvs/util/configmgr/source/treemgr/configpath.cxx,v
retrieving revision 1.13
retrieving revision 1.13.24.1
diff -u -p -u -p -r1.13 -r1.13.24.1
--- configmgr/source/treemgr/configpath.cxx	16 Sep 2006 15:28:07 -0000	1.13
+++ configmgr/source/treemgr/configpath.cxx	11 Jan 2007 10:35:37 -0000	1.13.24.1
@@ -33,6 +33,8 @@
  *
  ************************************************************************/
 
+#define dprint(a,b,c)
+
 // MARKER(update_precomp.py): autogen include statement, do not remove
 #include "precompiled_configmgr.hxx"
 
@@ -853,6 +855,9 @@ namespace 
 	Path::Rep implParsePath(OUString const& _aPathString, PathType eType) SAL_THROW((InvalidName))
 	{
 		Path::Rep aResult;
+
+        dprint (stderr, "implParsePath '%s' ",
+                 rtl::OUStringToOString(_aPathString, RTL_TEXTENCODING_UTF8).getStr());
 		
         StrPos pBegin = _aPathString.getStr();
         StrPos pEnd   = pBegin + _aPathString.getLength();
@@ -905,14 +910,20 @@ namespace 
                     throw InvalidName(_aPathString, "is not a valid path. Invalid type tag for predicate");
             }
             if (pQuoteStart != pEnd)
-                aElementName += implNormalizePredicate(pQuoteStart,pEnd);
+            {
+                dprint (stderr, "add 'normalize predicate'", "");
+                OUString aPred = implNormalizePredicate(pQuoteStart,pEnd);
+                aElementName += aPred;
+                dprint (stderr, " [result pred '%s']",
+                         rtl::OUStringToOString(aPred, RTL_TEXTENCODING_UTF8).getStr());
+            }
 
             aResult.prepend( Path::Component(aElementName, Path::PackageOnly()) );
 
             pEnd = pNameStart;
             if (pNameStart != pBegin) --pEnd;
         }
-
+        dprint (stderr, "\n", "");
 		return aResult;
 	}
 //-----------------------------------------------------------------------------
@@ -928,11 +939,17 @@ namespace 
         else if (!isWildcardType(_sBaseName) && !isSimpleName(_sBaseName))
             throw InvalidName(_sBaseName, "The base-name (type) part of a composite node name must be a simple word");
 
+        dprint (stderr, "implMakeNormalizePred '%s' ",
+                rtl::OUStringToOString(_sPredicate, RTL_TEXTENCODING_UTF8).getStr());
+
         StrPos pPredStart = _sPredicate.getStr();
         StrPos pPredEnd   = pPredStart + _sPredicate.getLength();
 
         if (pPredStart != pPredEnd)
             sComposite += implMakeNormalizedPredicate(pPredStart, pPredEnd, NULL);
+
+        dprint (stderr, " [result pred '%s']\n",
+                rtl::OUStringToOString(sComposite, RTL_TEXTENCODING_UTF8).getStr());
 
         return Name( sComposite, Path::PackageOnly() );
     }
Index: configmgr/source/treemgr/configset.cxx
===================================================================
RCS file: /cvs/util/configmgr/source/treemgr/configset.cxx,v
retrieving revision 1.29
retrieving revision 1.29.24.5
diff -u -p -u -p -r1.29 -r1.29.24.5
--- configmgr/source/treemgr/configset.cxx	16 Sep 2006 15:28:21 -0000	1.29
+++ configmgr/source/treemgr/configset.cxx	7 Feb 2007 12:00:33 -0000	1.29.24.5
@@ -66,9 +66,6 @@
 #ifndef CONFIGMGR_SETNODEBEHAVIOR_HXX_
 #include "setnodeimpl.hxx"
 #endif
-#ifndef CONFIGMGR_UPDATEACCESSOR_HXX
-#include "updateaccessor.hxx"
-#endif
 
 #ifndef _VOS_REFERNCE_HXX_
 #include <vos/refernce.hxx>
@@ -120,9 +117,9 @@ bool ElementRef::isValid() const
 
 //-----------------------------------------------------------------------------
 
-ElementTree ElementRef::getElementTree(data::Accessor const& _accessor) const
+ElementTree ElementRef::getElementTree() const
 {
-   return ElementTree(_accessor, m_aTreeHolder);
+   return ElementTree(m_aTreeHolder);
 }
 //-----------------------------------------------------------------------------
 
@@ -162,42 +159,31 @@ ElementRef ElementRef::extract(TreeRef c
 	ElementTreeImpl* pImpl = pTree ? pTree->asElementTree() : 0;
 	return ElementRef(pImpl);
 }
-//-----------------------------------------------------------------------------
 
-osl::Mutex& ElementRef::getTreeLock() const
-{
-    OSL_ENSURE(isValid(),"ERROR: Trying to get NULL lock for tree");
-
-	return m_aTreeHolder->getRootLock();
-}
 //-----------------------------------------------------------------------------
 // class ElementTree
 //-----------------------------------------------------------------------------
 
 ElementTree::ElementTree()
 : m_aTreeHolder()
-, m_accessor(NULL)
 {
 }
 //-----------------------------------------------------------------------------
 
-ElementTree::ElementTree(data::Accessor const& _accessor, ElementTreeImpl* pTree)
+ElementTree::ElementTree(ElementTreeImpl* pTree)
 : m_aTreeHolder(pTree)
-, m_accessor(_accessor)
 {
 }
 //-----------------------------------------------------------------------------
 
-ElementTree::ElementTree(data::Accessor const& _accessor, ElementTreeHolder const& pTree)
+ElementTree::ElementTree(ElementTreeHolder const& pTree)
 : m_aTreeHolder(pTree)
-, m_accessor(_accessor)
 {
 }
 //-----------------------------------------------------------------------------
 
 ElementTree::ElementTree(ElementTree const& aOther)
 : m_aTreeHolder(aOther.m_aTreeHolder)
-, m_accessor(aOther.m_accessor)
 {
 }
 //-----------------------------------------------------------------------------
@@ -205,7 +191,6 @@ ElementTree::ElementTree(ElementTree con
 ElementTree& ElementTree::operator=(ElementTree const& aOther)
 {
 	m_aTreeHolder = aOther.m_aTreeHolder;
-    m_accessor = aOther.m_accessor;
 	return *this;
 }
 //-----------------------------------------------------------------------------
@@ -258,13 +243,13 @@ ElementTreeImpl& ElementTree::operator*(
 
 Tree ElementTree::getTree() const
 {
-	return Tree(m_accessor,m_aTreeHolder.get());
+	return Tree(m_aTreeHolder.get());
 }
 //-----------------------------------------------------------------------------
 
 ElementTree ElementTree::extract(Tree const& aTree)
 {
-    return ElementRef::extract(aTree.getRef()).getElementTree(aTree.getDataAccessor());
+    return ElementRef::extract(aTree.getRef()).getElementTree();
 }
 //-----------------------------------------------------------------------------
 
@@ -324,9 +309,8 @@ OUString TemplateInfo::getTemplatePathSt
 // class SetElementInfo
 //-----------------------------------------------------------------------------
 
-SetElementInfo::SetElementInfo(data::Accessor const& _aSetAccessor, TemplateHolder const& aTemplate)
+SetElementInfo::SetElementInfo(TemplateHolder const& aTemplate)
 : m_aTemplateInfo(aTemplate)
-, m_aSetAccessor(_aSetAccessor)
 {
 }
 //-----------------------------------------------------------------------------
@@ -363,9 +347,8 @@ TemplateHolder SetElementInfo::extractEl
 // class SetElementFactory
 //-----------------------------------------------------------------------------
 
-SetElementFactory::SetElementFactory(data::Accessor const& _aDataAccessor, TemplateProvider const& aProvider)
+SetElementFactory::SetElementFactory(TemplateProvider const& aProvider)
 : m_aProvider(aProvider)
-, m_aDataAccessor(_aDataAccessor)
 {
 	OSL_ENSURE(aProvider.m_aImpl.is(), "WARNING: Template Instance Factory created without template provider - cannot instantiate elements");
 }
@@ -373,7 +356,6 @@ SetElementFactory::SetElementFactory(dat
 
 SetElementFactory::SetElementFactory(SetElementFactory const& aOther)
 : m_aProvider(aOther.m_aProvider)
-, m_aDataAccessor(aOther.m_aDataAccessor)
 {
 }
 //-----------------------------------------------------------------------------
@@ -381,7 +363,6 @@ SetElementFactory::SetElementFactory(Set
 SetElementFactory& SetElementFactory::operator=(SetElementFactory const& aOther)
 {
 	m_aProvider = aOther.m_aProvider;
-    m_aDataAccessor = aOther.m_aDataAccessor;
 	return *this;
 }
 //-----------------------------------------------------------------------------
@@ -400,7 +381,7 @@ ElementTree SetElementFactory::instantia
 
 	if (!aTemplate.is()) return ElementTree::emptyElement();
 
-    data::TreeSegment aInstanceTree( m_aProvider.m_aImpl->instantiate(this->getDataAccessor(), aTemplate) );
+    data::TreeSegment aInstanceTree( m_aProvider.m_aImpl->instantiate(aTemplate) );
 	OSL_ENSURE(aInstanceTree.is(), "ERROR: Cannot create Element Instance: Provider could not instantiate template");
 
     
@@ -408,7 +389,7 @@ ElementTree SetElementFactory::instantia
     //set removable state 
 	aInstanceTree.markRemovable();
 	
-	ElementTree aRet( this->getDataAccessor(), new ElementTreeImpl( aInstanceTree, aTemplate, m_aProvider ) );
+	ElementTree aRet( new ElementTreeImpl( aInstanceTree, aTemplate, m_aProvider ) );
 
 	return aRet;
 }
@@ -421,7 +402,7 @@ ElementTree SetElementFactory::instantia
 
     if (!_aElementData.is()) return ElementTree::emptyElement();
 
-	ElementTree aRet( this->getDataAccessor(), new ElementTreeImpl( _aElementData, aDummyTemplate, m_aProvider ) );
+	ElementTree aRet( new ElementTreeImpl( _aElementData, aDummyTemplate, m_aProvider ) );
 	// ElementTreeImpl* pNewTree = new ElementTreeImpl( NodeType::getDeferredChangeFactory(),*aTree, c_TreeDepthAll, aDummyTemplate, m_aProvider );
 	// pNewTree->takeNodeFrom(aTree);
 
@@ -601,7 +582,7 @@ void SetDefaulter::implValidateSet()
 }
 //-----------------------------------------------------------------------------
 
-static void doValidateElement(ElementRef const& aElement, bool bReqRemovable,Tree const& aTree)
+static void doValidateElement(ElementRef const& aElement, bool bReqRemovable)
 {
 	if (!aElement.isValid())
 		throw Exception("INTERNAL ERROR: Set Update: Unexpected NULL element");
@@ -612,7 +593,7 @@ static void doValidateElement(ElementRef
 
 	if ( bReqRemovable)
 	{
-		Tree aElementTree = aElement.getElementTree(aTree.getDataAccessor()).getTree();
+		Tree aElementTree = aElement.getElementTree().getTree();
 	
 		if(!aElementTree.getAttributes(aElementTree.getRootNode()).isRemovable())
 			throw ConstraintViolation( "New Set Update: Existing element cannot be removed (or replaced) !" );
@@ -623,7 +604,7 @@ static void doValidateElement(ElementRef
 /// validates that the given element is valid in this context and returns its name
 Path::Component TreeSetUpdater::implValidateElement(ElementRef const& aElement, bool bReqRemovable)
 {
-	doValidateElement(aElement,bReqRemovable,m_aParentTree);
+	doValidateElement(aElement,bReqRemovable);
 
 #if 0 // maybe reeanable for OSL_DEBUG_LEVEL>1 ?
 	ElementTreeImpl* pElement = TreeImplHelper::elementImpl(aTree)->isTemplateInstance();
@@ -639,10 +620,10 @@ Path::Component TreeSetUpdater::implVali
 /// validates that the given element is valid and can be replaced in this context and returns its name
 Path::Component ValueSetUpdater::implValidateElement(ElementRef const& aElement, bool mReqRemovable)
 {
-	doValidateElement(aElement,mReqRemovable,m_aParentTree);
+	doValidateElement(aElement,mReqRemovable);
 
 #if OSL_DEBUG_LEVEL > 0
-    UnoType aNodeType = ElementHelper::getUnoType(aElement.getElementTree(m_aParentTree.getDataAccessor()));
+    UnoType aNodeType = ElementHelper::getUnoType(aElement.getElementTree());
 
 	OSL_ENSURE(aNodeType.getTypeClass() != uno::TypeClass_VOID, "INTERNAL ERROR: Set Element without associated type found");
 	OSL_ENSURE(aNodeType.getTypeClass() != uno::TypeClass_INTERFACE,"INTERNAL ERROR: Set Element with complex type found");
@@ -819,7 +800,7 @@ NodeChange ValueSetUpdater::validateRepl
 
 	UnoAny aValidValue = implValidateValue(aElementNode, aNewValue);
    
-    ElementNodeRef aElementTree = aElement.getElementTree(m_aParentTree.getDataAccessor()).getTree();
+    ElementNodeRef aElementTree = aElement.getElementTree().getTree();
 	
 	ElementTreeHolder aNewElement;
 	if(aElementTree.getAttributes(aElementTree.getRootNode()).isRemovable())
@@ -867,8 +848,7 @@ NodeChange ValueSetUpdater::validateRemo
 
 NodeChange SetDefaulter::validateSetToDefaultState()
 {
-    memory::UpdateAccessor _aTargetSpace(NULL); // to do: get from right place
-    std::auto_ptr< ISubtree > aDefault = m_aDefaultProvider.getDefaultTree(_aTargetSpace,m_aParentTree,m_aSetNode);
+    std::auto_ptr< ISubtree > aDefault = m_aDefaultProvider.getDefaultTree(m_aParentTree,m_aSetNode);
 
 	// now build the specific change
 	std::auto_ptr<SetChangeImpl> pChange;
@@ -877,7 +857,7 @@ NodeChange SetDefaulter::validateSetToDe
     {
         TemplateProvider aProvider = SetElementFactory::findTemplateProvider(m_aParentTree,m_aSetNode);
 
-        configmgr::configuration::SetElementFactory aTmp(m_aParentTree.getDataAccessor(), aProvider);
+        configmgr::configuration::SetElementFactory aTmp(aProvider);
         pChange.reset( new SetResetImpl(aTmp, aDefault) );
 	    pChange->setTarget(m_aParentTree.getView().makeNode(m_aSetNode));
     }
@@ -887,7 +867,7 @@ NodeChange SetDefaulter::validateSetToDe
 
 ValueSetUpdater::ElementNodeRef ValueSetUpdater::extractElementNode (ElementRef const& aElement)
 {
-    return aElement.getElementTree(m_aParentTree.getDataAccessor()).getTree();
+    return aElement.getElementTree().getTree();
 }
 //-----------------------------------------------------------------------------
 
Index: configmgr/source/treemgr/defaultproviderproxy.cxx
===================================================================
RCS file: /cvs/util/configmgr/source/treemgr/defaultproviderproxy.cxx,v
retrieving revision 1.8
retrieving revision 1.8.24.2
diff -u -p -u -p -r1.8 -r1.8.24.2
--- configmgr/source/treemgr/defaultproviderproxy.cxx	16 Sep 2006 15:28:34 -0000	1.8
+++ configmgr/source/treemgr/defaultproviderproxy.cxx	16 Jan 2007 12:18:25 -0000	1.8.24.2
@@ -50,9 +50,6 @@
 #ifndef CONFIGMGR_MISC_OPTIONS_HXX_
 #include "options.hxx"
 #endif
-#ifndef CONFIGMGR_UPDATEACCESSOR_HXX
-#include "updateaccessor.hxx"
-#endif
 
 namespace configmgr
 {
@@ -82,7 +79,6 @@ DefaultProviderProxy::~DefaultProviderPr
 
 /// tries to load a default instance of the specified node (which must be within the request range owned)
 std::auto_ptr<ISubtree> DefaultProviderProxy::getDefaultTree(
-                            memory::UpdateAccessor& /*_aDestinationSpace*/,
                             AbsolutePath const& _aLocation
                        ) const CFG_UNO_THROW_ALL()
 {
@@ -104,9 +100,8 @@ bool DefaultProviderProxy::fetchDefaultD
     OSL_PRECOND(m_pDefaultTreeManager, "No tree to fetch defaults into");
     if (!m_pDefaultTreeManager) return false;
 
-    memory::UpdateAccessor anAccessToken(m_pDefaultTreeManager->getDataSegment(m_aBaseLocation,m_aOptions));
-
-    return !! m_pDefaultTreeManager->fetchDefaultData(anAccessToken,m_aBaseLocation,m_aOptions);
+//    m_pDefaultTreeManager->getDataSegment(m_aBaseLocation,m_aOptions);
+    return !! m_pDefaultTreeManager->fetchDefaultData(m_aBaseLocation,m_aOptions);
 }
 //-----------------------------------------------------------------------------
 	}
Index: configmgr/source/treemgr/defaultproviderproxy.hxx
===================================================================
RCS file: /cvs/util/configmgr/source/treemgr/defaultproviderproxy.hxx,v
retrieving revision 1.7
retrieving revision 1.7.84.2
diff -u -p -u -p -r1.7 -r1.7.84.2
--- configmgr/source/treemgr/defaultproviderproxy.hxx	8 Sep 2005 04:28:18 -0000	1.7
+++ configmgr/source/treemgr/defaultproviderproxy.hxx	11 Jan 2007 20:16:05 -0000	1.7.84.2
@@ -45,11 +45,6 @@
 #ifndef CONFIGMGR_MISC_REQUESTOPTIONS_HXX_
 #include "requestoptions.hxx"
 #endif
-
-#ifndef _SALHELPER_SIMPLEREFERENCEOBJECT_HXX_
-#include <salhelper/simplereferenceobject.hxx>
-#endif
-
 #ifndef _RTL_REF_HXX_
 #include <rtl/ref.hxx>
 #endif
@@ -67,18 +62,13 @@ namespace configmgr
     class IDefaultableTreeManager;
 	class OOptions;
 //-----------------------------------------------------------------------------
-    namespace memory
-    {
-        class UpdateAccessor;
-    }
-//-----------------------------------------------------------------------------
 	namespace configuration
 	{
 //-----------------------------------------------------------------------------
 
 		/// provides access to the defaults for a given request
         class DefaultProviderProxy 
-        : public salhelper::SimpleReferenceObject
+        : public configmgr::SimpleReferenceObject
 		{
             // the data defining a request
             AbsolutePath            m_aBaseLocation;
@@ -99,7 +89,7 @@ namespace configmgr
 			~DefaultProviderProxy();
 
 		/// tries to load a default instance of the specified node (which must be within the request range owned)
-            std::auto_ptr<ISubtree> getDefaultTree(memory::UpdateAccessor& _aDestinationSpace, AbsolutePath const& _aLocation) const CFG_UNO_THROW_ALL();
+            std::auto_ptr<ISubtree> getDefaultTree(AbsolutePath const& _aLocation) const CFG_UNO_THROW_ALL();
 
             /// tries to load default data into the owned tree - call only outside of any locks
             bool fetchDefaultData() CFG_UNO_THROW_ALL();
Index: configmgr/source/treemgr/deferredview.cxx
===================================================================
RCS file: /cvs/util/configmgr/source/treemgr/deferredview.cxx,v
retrieving revision 1.4
retrieving revision 1.4.24.2
diff -u -p -u -p -r1.4 -r1.4.24.2
--- configmgr/source/treemgr/deferredview.cxx	16 Sep 2006 15:28:47 -0000	1.4
+++ configmgr/source/treemgr/deferredview.cxx	16 Jan 2007 12:18:25 -0000	1.4.24.2
@@ -136,13 +136,13 @@ void DeferredViewStrategy::implCollectCh
     {
 	    if (_aNode.isSetNode())
 	    {
-            deferredSetNode(_aNode)->collectElementChanges( _aNode.accessor(), _rChanges);
+            deferredSetNode(_aNode)->collectElementChanges( _rChanges);
 	    }
 	    else if (_aNode.isGroupNode())
 	    {
             GroupNode aGroup(_aNode);
 
-            deferredGroupNode(aGroup)->collectValueChanges( aGroup.accessor(), _rChanges, _aNode.tree().get_impl(), _aNode.get_offset());
+            deferredGroupNode(aGroup)->collectValueChanges( _rChanges, _aNode.tree().get_impl(), _aNode.get_offset());
 
 		    for( Node aChild = aGroup.getFirstChild(); 
                  aChild.is(); 
@@ -225,7 +225,7 @@ node::Attributes DeferredViewStrategy::d
 //-----------------------------------------------------------------------------
 configuration::ValueMemberNode DeferredViewStrategy::doGetValueMember(GroupNode const& _aNode, Name const& _aName, bool _bForUpdate) const
 {
-    return deferredGroupNode(_aNode)->makeValueMember(_aNode.accessor(),_aName,_bForUpdate);
+    return deferredGroupNode(_aNode)->makeValueMember(_aName,_bForUpdate);
 }
 
 //-----------------------------------------------------------------------------
@@ -236,7 +236,6 @@ void DeferredViewStrategy::doInsertEleme
 
     //implMakeElement(aNewEntry)
     SetNodeElement aNewElement = implMakeElement(_aNode, _aNewEntry );
- //   _aNewEntry.tree()->rebuild(this, _aNode.accessor());
 
 	deferredSetNode(_aNode)->insertNewElement(aName, aNewElement);
 }
@@ -258,9 +257,9 @@ NodeFactory& DeferredViewStrategy::doGet
 //-----------------------------------------------------------------------------
 //-----------------------------------------------------------------------------
 
-ViewStrategyRef createDeferredChangeStrategy(memory::Segment const * _pSegment)
+ViewStrategyRef createDeferredChangeStrategy()
 {
-    return new DeferredViewStrategy(_pSegment);
+    return new DeferredViewStrategy();
 }
 
 //-----------------------------------------------------------------------------
@@ -274,11 +273,11 @@ std::auto_ptr<SubtreeChange> DeferredVie
 
     if (_aNode.isSetNode())
 	{
-		aRet = deferredSetNode(_aNode)->preCommitChanges(_aNode.accessor(),_rRemovedElements);
+		aRet = deferredSetNode(_aNode)->preCommitChanges(_rRemovedElements);
 	}
 	else if (_aNode.isGroupNode())
 	{
-		std::auto_ptr<SubtreeChange> aGroupChange(deferredGroupNode(_aNode)->preCommitValueChanges(_aNode.accessor()));
+		std::auto_ptr<SubtreeChange> aGroupChange(deferredGroupNode(_aNode)->preCommitValueChanges());
 
 		OSL_ASSERT(aGroupChange.get());
 		if (aGroupChange.get())
@@ -301,13 +300,13 @@ void DeferredViewStrategy::implFinishCom
 	{
 		OSL_ENSURE(rSubtreeChange.isSetNodeChange(),"ERROR: Change type GROUP does not match set");
 
-		deferredSetNode(_aNode)->finishCommit(_aNode.accessor(),rSubtreeChange);
+		deferredSetNode(_aNode)->finishCommit(rSubtreeChange);
 	}
 	else if (_aNode.isGroupNode())
 	{
 		OSL_ENSURE(!rSubtreeChange.isSetNodeChange(),"ERROR: Change type SET does not match group");
 
-		deferredGroupNode(_aNode)->finishCommit(_aNode.accessor(),rSubtreeChange);
+		deferredGroupNode(_aNode)->finishCommit(rSubtreeChange);
 		implFinishSubCommitted( GroupNode(_aNode), rSubtreeChange );
 	}
     else
@@ -326,13 +325,13 @@ void DeferredViewStrategy::implRevertCom
 	{
 		OSL_ENSURE(rSubtreeChange.isSetNodeChange(),"ERROR: Change type GROUP does not match set");
 
-		deferredSetNode(_aNode)->revertCommit(_aNode.accessor(),rSubtreeChange);
+		deferredSetNode(_aNode)->revertCommit(rSubtreeChange);
 	}
 	else if (_aNode.isGroupNode())
 	{
 		OSL_ENSURE(!rSubtreeChange.isSetNodeChange(),"ERROR: Change type SET does not match group");
 
-		deferredGroupNode(_aNode)->revertCommit(_aNode.accessor(),rSubtreeChange);
+		deferredGroupNode(_aNode)->revertCommit(rSubtreeChange);
 		implRevertSubCommitted( GroupNode(_aNode), rSubtreeChange );
 	}
     else
@@ -351,13 +350,13 @@ void DeferredViewStrategy::implFailedCom
 	{
 		OSL_ENSURE(rSubtreeChange.isSetNodeChange(),"ERROR: Change type GROUP does not match set");
 
-		deferredSetNode(_aNode)->failedCommit(_aNode.accessor(),rSubtreeChange);
+		deferredSetNode(_aNode)->failedCommit(rSubtreeChange);
 	}
 	else if (_aNode.isGroupNode())
 	{
 		OSL_ENSURE(!rSubtreeChange.isSetNodeChange(),"ERROR: Change type SET does not match group");
 
-		deferredGroupNode(_aNode)->failedCommit(_aNode.accessor(),rSubtreeChange);
+		deferredGroupNode(_aNode)->failedCommit(rSubtreeChange);
 		implFailedSubCommitted( GroupNode(_aNode), rSubtreeChange );
 	}
     else
Index: configmgr/source/treemgr/deferredview.hxx
===================================================================
RCS file: /cvs/util/configmgr/source/treemgr/deferredview.hxx,v
retrieving revision 1.3
retrieving revision 1.3.84.1
diff -u -p -u -p -r1.3 -r1.3.84.1
--- configmgr/source/treemgr/deferredview.hxx	8 Sep 2005 04:28:45 -0000	1.3
+++ configmgr/source/treemgr/deferredview.hxx	16 Jan 2007 12:18:25 -0000	1.3.84.1
@@ -51,12 +51,9 @@ namespace configmgr
 
 		class DeferredViewStrategy : public ViewStrategy
 		{
-            memory::Segment const * m_pSegment;
 		public:
 			explicit 
-            DeferredViewStrategy(memory::Segment const * _pSegment)
-            : m_pSegment(_pSegment)
-			{}
+            DeferredViewStrategy() {} 
 
         // ViewStrategy implementation
 		private:
@@ -87,9 +84,6 @@ namespace configmgr
             // set element access
             virtual void doInsertElement(SetNode const& _aNode, Name const& aName, configuration::SetEntry const& aNewEntry);
 			virtual void doRemoveElement(SetNode const& _aNode, Name const& aName);
-
-            virtual void doReleaseDataSegment() { m_pSegment = NULL; }
-            virtual memory::Segment const * doGetDataSegment() const { return m_pSegment; }
 
             virtual NodeFactory& doGetNodeFactory();
         private:
Index: configmgr/source/treemgr/directview.cxx
===================================================================
RCS file: /cvs/util/configmgr/source/treemgr/directview.cxx,v
retrieving revision 1.5
retrieving revision 1.5.24.1
diff -u -p -u -p -r1.5 -r1.5.24.1
--- configmgr/source/treemgr/directview.cxx	16 Sep 2006 15:29:01 -0000	1.5
+++ configmgr/source/treemgr/directview.cxx	16 Jan 2007 12:18:26 -0000	1.5.24.1
@@ -61,7 +61,9 @@ void DirectViewStrategy::implMarkNondefa
 
     OSL_ASSERT(aSetAccess.isValid());
 
-    sharable::SetNode* pNode = this->getDataForUpdate(aSetAccess);
+    sharable::SetNode* pNode = NULL;
+    if (m_aTreeSegment.is())
+        pNode = aSetAccess;
 
     OSL_ASSERT(pNode);
 
Index: configmgr/source/treemgr/directview.hxx
===================================================================
RCS file: /cvs/util/configmgr/source/treemgr/directview.hxx,v
retrieving revision 1.3
retrieving revision 1.3.84.1
diff -u -p -u -p -r1.3 -r1.3.84.1
--- configmgr/source/treemgr/directview.hxx	8 Sep 2005 04:29:14 -0000	1.3
+++ configmgr/source/treemgr/directview.hxx	16 Jan 2007 12:18:26 -0000	1.3.84.1
@@ -66,11 +66,6 @@ namespace configmgr
 			virtual bool doHasChanges(Node const& _aNode) const;
 			virtual void doMarkChanged(Node const& _aNode);
 
-            // direct data access
-            virtual void doReleaseDataSegment() { m_aTreeSegment.clear(); }
-            virtual memory::Segment const * doGetDataSegment()    const { return m_aTreeSegment.getSegment(); }
-            virtual memory::Segment * doGetDataSegmentForUpdate()       { return m_aTreeSegment.getSegment(); }
-
             // common attributes 
             virtual node::Attributes doAdjustAttributes(node::Attributes const& _aAttributes) const;
 
Index: configmgr/source/treemgr/groupnodeimpl.hxx
===================================================================
RCS file: /cvs/util/configmgr/source/treemgr/groupnodeimpl.hxx,v
retrieving revision 1.6
retrieving revision 1.6.84.3
diff -u -p -u -p -r1.6 -r1.6.84.3
--- configmgr/source/treemgr/groupnodeimpl.hxx	8 Sep 2005 04:29:29 -0000	1.6
+++ configmgr/source/treemgr/groupnodeimpl.hxx	12 Jan 2007 14:50:46 -0000	1.6.84.3
@@ -88,16 +88,15 @@ namespace configmgr
 
 		class GroupNodeImpl : public NodeImpl
 		{
+            mutable sharable::Node *m_pCache;
 		public:
-            explicit GroupNodeImpl(data::GroupNodeAddress const& _aNodeRef);
+            explicit GroupNodeImpl(data::GroupNodeAddress _pNodeRef);
 
-            typedef data::GroupNodeAccess DataAccess;
+            data::GroupNodeAccess getDataAccess() const;
 
-            DataAccess getDataAccess(data::Accessor const& _aAccessor) const;
+            bool areValueDefaultsAvailable() const;
 
-            bool areValueDefaultsAvailable(data::Accessor const& _aAccessor) const;
-
-            data::ValueNodeAccess getOriginalValueNode(data::Accessor const& _aAccessor, Name const& aName) const;
+            data::ValueNodeAccess getOriginalValueNode(Name const& aName) const;
 
             ValueMemberNode makeValueMember(data::ValueNodeAccess const& _aValueNode);
 		};
Index: configmgr/source/treemgr/nodechange.cxx
===================================================================
RCS file: /cvs/util/configmgr/source/treemgr/nodechange.cxx,v
retrieving revision 1.11
retrieving revision 1.11.24.1
diff -u -p -u -p -r1.11 -r1.11.24.1
--- configmgr/source/treemgr/nodechange.cxx	16 Sep 2006 15:29:14 -0000	1.11
+++ configmgr/source/treemgr/nodechange.cxx	11 Jan 2007 10:35:38 -0000	1.11.24.1
@@ -126,7 +126,7 @@ sal_uInt32 NodeChange::getChangeInfos(No
            
         for (NodeChangeImpl::ChangeCount ix = 0; ix < nChanges; ++ix)
         {
-            NodeChangeInformation aSingleInfo(m_pImpl->getDataAccessor());
+	    NodeChangeInformation aSingleInfo;
             aSingleInfo.change.type = NodeChangeData::eNoChange;
 
 		    m_pImpl->fillChangeInfo(aSingleInfo,ix);
@@ -151,7 +151,7 @@ bool NodeChange::getChangeLocation(NodeC
 
 Tree NodeChange::getBaseTree() const
 {
-	return Tree(m_pImpl->getDataAccessor(), m_pImpl->getTargetTree().get());
+	return Tree(m_pImpl->getTargetTree().get());
 }
 //-----------------------------------------------------------------------------
 
@@ -174,9 +174,9 @@ NodeRef NodeChange::getBaseNode() const
 Tree NodeChange::getAffectedTree() const
 {
 	if (this->maybeChange())
-		return Tree(m_pImpl->getDataAccessor(), m_pImpl->getTargetTree().get());
+		return Tree(m_pImpl->getTargetTree().get());
 	else
-		return Tree(m_pImpl->getDataAccessor(), 0);
+		return Tree(NULL);
 }
 //-----------------------------------------------------------------------------
 
Index: configmgr/source/treemgr/nodechangeimpl.cxx
===================================================================
RCS file: /cvs/util/configmgr/source/treemgr/nodechangeimpl.cxx,v
retrieving revision 1.20
retrieving revision 1.20.24.2
diff -u -p -u -p -r1.20 -r1.20.24.2
--- configmgr/source/treemgr/nodechangeimpl.cxx	16 Sep 2006 15:29:27 -0000	1.20
+++ configmgr/source/treemgr/nodechangeimpl.cxx	12 Jan 2007 14:50:46 -0000	1.20.24.2
@@ -80,8 +80,7 @@ enum { eTestedChange = 0x01, eAppliedCha
 //-----------------------------------------------------------------------------
 
 NodeChangeImpl::NodeChangeImpl(bool bNoCheck)
-: m_aDataAccessor( data::Accessor(NULL) )
-, m_aAffectedTree()
+: m_aAffectedTree()
 , m_nAffectedNode(0)
 , m_nState(0)
 {
@@ -93,7 +92,7 @@ view::ViewTreeAccess NodeChangeImpl::get
 {
 	OSL_ENSURE( m_aAffectedTree.is(), "ERROR: Configuration Change: Target Tree Access has not been set up" );
 
-	return Tree(m_aDataAccessor,m_aAffectedTree.get()).getView();
+	return Tree(m_aAffectedTree.get()).getView();
 }
 //-----------------------------------------------------------------------------
 
@@ -119,10 +118,10 @@ NodeOffset NodeChangeImpl::getTargetNode
 
 void NodeChangeImpl::setTarget(view::Node _aAffectedNode)
 {
-    this->setTarget(_aAffectedNode.accessor(), _aAffectedNode.tree().get_impl(), _aAffectedNode.get_offset());
+    this->setTarget(_aAffectedNode.tree().get_impl(), _aAffectedNode.get_offset());
 
 }
-void NodeChangeImpl::setTarget(data::Accessor const& _aAccessor, TreeHolder const& _aAffectedTree, NodeOffset _nAffectedNode)
+void NodeChangeImpl::setTarget(TreeHolder const& _aAffectedTree, NodeOffset _nAffectedNode)
 {
 	OSL_ENSURE(m_nState == 0 || (!m_aAffectedTree.is() && m_nState == eNoCheck), "WARNING: Configuration: Retargeting change that already was tested or applied");
 
@@ -132,7 +131,6 @@ void NodeChangeImpl::setTarget(data::Acc
 
 	if (m_nState != eNoCheck) m_nState = 0; // previous checks are invalidated
 
-    m_aDataAccessor = _aAccessor;
 	m_aAffectedTree = _aAffectedTree;
 	m_nAffectedNode = _nAffectedNode;
 }
@@ -292,11 +290,11 @@ void ValueChangeImpl::setTarget(view::Gr
 }
 //-----------------------------------------------------------------------------
 
-void ValueChangeImpl::setTarget(data::Accessor const& _aAccessor, TreeHolder const& aAffectedTree, NodeOffset nParentNode, Name const& sNodeName)
+void ValueChangeImpl::setTarget(TreeHolder const& aAffectedTree, NodeOffset nParentNode, Name const& sNodeName)
 {
     OSL_ENSURE(!sNodeName.isEmpty(), "ValueChangeTarget is being set without a name");
 
-    NodeChangeImpl::setTarget(_aAccessor,aAffectedTree,nParentNode);
+    NodeChangeImpl::setTarget(aAffectedTree,nParentNode);
     m_aName = sNodeName;
 }
 //-----------------------------------------------------------------------------
@@ -607,7 +605,7 @@ void SetResetImpl::doApply( view::Node c
 
         if (it->m_aAddedElement.is())
 		{
-			SetEntry aNewEntry( rTarget.accessor(), it->m_aAddedElement.get() );
+			SetEntry aNewEntry( it->m_aAddedElement.get() );
 			accessor.insertElement(aTargetSet, aElementName, aNewEntry);
 		}
 
@@ -682,7 +680,7 @@ void SetInsertImpl::doApplyToElement( vi
 {
 	if (m_aNewTree.is()) 
 	{
-		SetEntry aNewEntry( _aNode.accessor(), m_aNewTree.get() );
+		SetEntry aNewEntry( m_aNewTree.get() );
 		getTargetView().insertElement( _aNode, aName, aNewEntry);
 	}
 } 
@@ -753,7 +751,7 @@ void SetReplaceImpl::doApplyToElement( v
 		OSL_ENSURE(m_aNewTree.is(), "ERROR: Configuration: Replacing a node with nothing"); 
 		if (m_aNewTree.is()) 
 		{
-			SetEntry aNewEntry( _aNode.accessor(), m_aNewTree.get() );
+			SetEntry aNewEntry( m_aNewTree.get() );
 			aTargetView.insertElement( _aNode, aName, aNewEntry);
 		}
 	}
Index: configmgr/source/treemgr/nodechangeimpl.hxx
===================================================================
RCS file: /cvs/util/configmgr/source/treemgr/nodechangeimpl.hxx,v
retrieving revision 1.12
retrieving revision 1.12.42.3
diff -u -p -u -p -r1.12 -r1.12.42.3
--- configmgr/source/treemgr/nodechangeimpl.hxx	19 Jun 2006 23:32:49 -0000	1.12
+++ configmgr/source/treemgr/nodechangeimpl.hxx	12 Jan 2007 14:50:46 -0000	1.12.42.3
@@ -50,8 +50,8 @@
 #ifndef _RTL_REF_HXX_
 #include <rtl/ref.hxx>
 #endif
-#ifndef _SALHELPER_SIMPLEREFERENCEOBJECT_HXX_
-#include <salhelper/simplereferenceobject.hxx>
+#ifndef CONFIGMGR_UTILITY_HXX_
+#include "utility.hxx"
 #endif
 
 #ifndef INCLUDED_VECTOR
@@ -115,7 +115,7 @@ namespace configmgr
 
 		/// represents a node position in some tree
 		class NodeChangeImpl 
-		: public salhelper::SimpleReferenceObject
+		: public configmgr::SimpleReferenceObject
 		{
 		public:
 			explicit
@@ -129,10 +129,9 @@ namespace configmgr
 			/// the node that is affected by the change
 			NodeOffset getTargetNode() const;
 
-            data::Accessor const& getDataAccessor() const { return m_aDataAccessor; }
         protected:
 			/// setup the 'target' node that is to be affected or changed
-            void setTarget(data::Accessor const& _aAccessor, TreeHolder const& _aAffectedTree, NodeOffset _nAffectedNode);
+            void setTarget(TreeHolder const& _aAffectedTree, NodeOffset _nAffectedNode);
             void setTarget(view::Node _aAffectedNode);
 
             view::ViewTreeAccess getTargetView();
@@ -186,7 +185,6 @@ namespace configmgr
 
 		private:
             typedef sal_uInt16 State;
-            data::Accessor m_aDataAccessor;
 			TreeHolder m_aAffectedTree;
 			NodeOffset m_nAffectedNode;
             State      m_nState;
@@ -212,7 +210,7 @@ namespace configmgr
 		public:
 			/// setup the 'target' node that is to be affected or changed
             void setTarget(view::GroupNode const& _aParentNode, Name const& sNodeName);
-            void setTarget(data::Accessor const& _aAccessor, TreeHolder const& aAffectedTree, NodeOffset nParentNode, Name const& sNodeName);
+            void setTarget(TreeHolder const& aAffectedTree, NodeOffset nParentNode, Name const& sNodeName);
 
 		public:
 			/// get the name of the value
Index: configmgr/source/treemgr/nodechangeinfo.cxx
===================================================================
RCS file: /cvs/util/configmgr/source/treemgr/nodechangeinfo.cxx,v
retrieving revision 1.9
retrieving revision 1.9.24.2
diff -u -p -u -p -r1.9 -r1.9.24.2
--- configmgr/source/treemgr/nodechangeinfo.cxx	16 Sep 2006 15:29:49 -0000	1.9
+++ configmgr/source/treemgr/nodechangeinfo.cxx	12 Jan 2007 14:50:47 -0000	1.9.24.2
@@ -86,15 +86,15 @@ bool NodeChangeData::isDataChange() cons
 }
 //-----------------------------------------------------------------------------
 		
-Tree NodeChangeData::getNewElementTree(data::Accessor const& aAccessor) const
+Tree NodeChangeData::getNewElementTree() const
 {
-	return Tree( aAccessor, element.newValue.get() );
+	return Tree( element.newValue.get() );
 }
 //-----------------------------------------------------------------------------
 
-Tree NodeChangeData::getOldElementTree(data::Accessor const& aAccessor) const
+Tree NodeChangeData::getOldElementTree() const
 {
-	return Tree( aAccessor, element.oldValue.get() );
+	return Tree( element.oldValue.get() );
 }
 //-----------------------------------------------------------------------------
 
@@ -156,22 +156,20 @@ NodeChangeLocation::NodeChangeLocation()
 {
 }
 //-----------------------------------------------------------------------------
-bool NodeChangeLocation::isValidLocation(data::Accessor const& aAccessor) const
+bool NodeChangeLocation::isValidLocation() const
 {
-	// TODO: Validate that base,target and accessor relate correctly (?)
 	return	 m_base.isValidNode() && 
 			(m_affected.isEmpty() 
 				?	! m_bSubNodeChanging
 				:	( m_affected.isValidNode() && 
 					  (! m_bSubNodeChanging || 
                          (!m_path.isEmpty() && 
-                            SubNodeID(m_affected,m_path.getLocalName().getName()).isValidNode(aAccessor)
+                            SubNodeID(m_affected,m_path.getLocalName().getName()).isValidNode()
                     ) )  ) );
 }
 //-----------------------------------------------------------------------------
 bool NodeChangeLocation::isValidData() const
 {
-	// TODO: Validate that base,target and accessor relate correctly (?)
 	return	 m_base.isValidNode() && 
 			(m_affected.isEmpty() 
 				?	! m_bSubNodeChanging
@@ -210,10 +208,10 @@ void NodeChangeLocation::setChangingSubn
 }
 //-----------------------------------------------------------------------------
 
-Tree NodeChangeLocation::getBaseTree(data::Accessor const& aAccessor) const
+Tree NodeChangeLocation::getBaseTree() const
 {
 	OSL_ENSURE(m_base.isValidNode(), "Invalid base location set in NodeChangeLocation");
-	return Tree( aAccessor, TreeImplHelper::tree(m_base) );
+	return Tree( TreeImplHelper::tree(m_base) );
 }
 //-----------------------------------------------------------------------------
 
@@ -231,9 +229,9 @@ TreeRef NodeChangeLocation::getAffectedT
 }
 //-----------------------------------------------------------------------------
 
-Tree NodeChangeLocation::getAffectedTree(data::Accessor const& aAccessor) const
+Tree NodeChangeLocation::getAffectedTree() const
 {
-	return Tree( aAccessor, getAffectedTreeRef() );
+	return Tree( getAffectedTreeRef() );
 }
 //-----------------------------------------------------------------------------
 
Index: configmgr/source/treemgr/nodefactory.cxx
===================================================================
RCS file: /cvs/util/configmgr/source/treemgr/nodefactory.cxx,v
retrieving revision 1.7
retrieving revision 1.7.24.1
diff -u -p -u -p -r1.7 -r1.7.24.1
--- configmgr/source/treemgr/nodefactory.cxx	16 Sep 2006 15:30:03 -0000	1.7
+++ configmgr/source/treemgr/nodefactory.cxx	8 Jan 2007 20:49:03 -0000	1.7.24.1
@@ -69,7 +69,7 @@ namespace view 
 namespace 
 {
 //---------------------------------------------------------------------
-    using configuration::NodeImplHolder;
+    using configuration::NodeImpl;
     using configuration::Template;
     using data::ValueNodeAccess;
     using data::GroupNodeAccess;
@@ -89,27 +89,27 @@ namespace 
 //---------------------------------------------------------------------
 	struct BasicNodeFactory : NodeFactory
 	{
-		NodeImplHolder makeValueNode(ValueNodeAccess const& _aNodeAccess);
-		NodeImplHolder makeGroupNode(GroupNodeAccess const& _aNodeAccess);
-		NodeImplHolder makeSetNode  (SetNodeAccess const& _aNodeAccess, Template* pTemplate);
+		rtl::Reference<NodeImpl> makeValueNode(ValueNodeAccess const& _aNodeAccess);
+		rtl::Reference<NodeImpl> makeGroupNode(GroupNodeAccess const& _aNodeAccess);
+		rtl::Reference<NodeImpl> makeSetNode  (SetNodeAccess const& _aNodeAccess, Template* pTemplate);
 	};
 	//-------------------------------------------------------------------------
 
-	NodeImplHolder BasicNodeFactory::makeValueNode(ValueNodeAccess const& _aNodeAccess)
+	rtl::Reference<NodeImpl> BasicNodeFactory::makeValueNode(ValueNodeAccess const& _aNodeAccess)
 	{
-        return new configuration::ValueElementNodeImpl(_aNodeAccess.address());
+	    return new configuration::ValueElementNodeImpl(_aNodeAccess);
 	}
 	//-------------------------------------------------------------------------
 
-	NodeImplHolder BasicNodeFactory::makeGroupNode(GroupNodeAccess const& _aNodeAccess)
+	rtl::Reference<NodeImpl> BasicNodeFactory::makeGroupNode(GroupNodeAccess const& _aNodeAccess)
 	{
-		return new configuration::GroupNodeImpl(_aNodeAccess.address());
+	    return new configuration::GroupNodeImpl(_aNodeAccess);
 	}
 	//-------------------------------------------------------------------------
 
-	NodeImplHolder BasicNodeFactory::makeSetNode  (SetNodeAccess const& _aNodeAccess, Template* pTemplate)
+	rtl::Reference<NodeImpl> BasicNodeFactory::makeSetNode  (SetNodeAccess const& _aNodeAccess, Template* pTemplate)
 	{
-		return new configuration::SetNodeImpl(_aNodeAccess.address(),pTemplate);
+	    return new configuration::SetNodeImpl(_aNodeAccess,pTemplate);
 	}
 	//-------------------------------------------------------------------------
 
@@ -117,30 +117,30 @@ namespace 
 /*
 	struct DirectNodeFactory : NodeFactory
 	{
-		NodeImplHolder makeValueNode(ValueNodeAccess const& _aNodeAccess);
-		NodeImplHolder makeGroupNode(GroupNodeAccess const& _aNodeAccess);
-		NodeImplHolder makeSetNode  (SetNodeAccess const& _aNodeAccess, Template* pTemplate);
+		rtl::Reference<NodeImpl> makeValueNode(ValueNodeAccess const& _aNodeAccess);
+		rtl::Reference<NodeImpl> makeGroupNode(GroupNodeAccess const& _aNodeAccess);
+		rtl::Reference<NodeImpl> makeSetNode  (SetNodeAccess const& _aNodeAccess, Template* pTemplate);
 	};
 	//-------------------------------------------------------------------------
 
-	NodeImplHolder DirectNodeFactory::makeValueNode(ValueNodeAccess const& _aNodeAccess)
+	rtl::Reference<NodeImpl> DirectNodeFactory::makeValueNode(ValueNodeAccess const& _aNodeAccess)
 	{
-		return new DirectValueElementNodeImpl(_aNodeAccess.address());
+		return new DirectValueElementNodeImpl(_aNodeAccess);
 	}
 	//-------------------------------------------------------------------------
 
-	NodeImplHolder DirectNodeFactory::makeGroupNode(GroupNodeAccess const& _aNodeAccess)
+	rtl::Reference<NodeImpl> DirectNodeFactory::makeGroupNode(GroupNodeAccess const& _aNodeAccess)
 	{
-		return new DirectGroupNodeImpl(_aNodeAccess.address());
+		return new DirectGroupNodeImpl(_aNodeAccess);
 	}
 	//-------------------------------------------------------------------------
 
-	NodeImplHolder DirectNodeFactory::makeSetNode  (SetNodeAccess const& _aNodeAccess, Template* pTemplate)
+	rtl::Reference<NodeImpl> DirectNodeFactory::makeSetNode  (SetNodeAccess const& _aNodeAccess, Template* pTemplate)
 	{
 		if (isTreeSet(_aNodeAccess,pTemplate))
-			return new DirectTreeSetNodeImpl(_aNodeAccess.address(),pTemplate);
+			return new DirectTreeSetNodeImpl(_aNodeAccess,pTemplate);
 		else
-			return new DirectValueSetNodeImpl(_aNodeAccess.address(),pTemplate);
+			return new DirectValueSetNodeImpl(_aNodeAccess,pTemplate);
 	}
 	//-------------------------------------------------------------------------
 */
@@ -148,28 +148,28 @@ namespace 
 
 	struct DeferredNodeFactory : NodeFactory
 	{
-		NodeImplHolder makeValueNode(ValueNodeAccess const& _aNodeAccess);
-		NodeImplHolder makeGroupNode(GroupNodeAccess const& _aNodeAccess);
-		NodeImplHolder makeSetNode  (SetNodeAccess const& _aNodeAccess, Template* pTemplate);
+	    rtl::Reference<NodeImpl> makeValueNode(ValueNodeAccess const& _aNodeAccess);
+	    rtl::Reference<NodeImpl> makeGroupNode(GroupNodeAccess const& _aNodeAccess);
+	    rtl::Reference<NodeImpl> makeSetNode  (SetNodeAccess const& _aNodeAccess, Template* pTemplate);
 	};
 	//-------------------------------------------------------------------------
 
-	NodeImplHolder DeferredNodeFactory::makeValueNode(ValueNodeAccess const& _aNodeAccess)
+	rtl::Reference<NodeImpl> DeferredNodeFactory::makeValueNode(ValueNodeAccess const& _aNodeAccess)
 	{
     //    OSL_ENSURE(false, "Wrong factory for value elements - should be immutable (=read-only)");
-        return new configuration::ValueElementNodeImpl(_aNodeAccess.address());
+	    return new configuration::ValueElementNodeImpl(_aNodeAccess);
 	}
 	//-------------------------------------------------------------------------
 
-	NodeImplHolder DeferredNodeFactory::makeGroupNode(GroupNodeAccess const& _aNodeAccess)
+	rtl::Reference<NodeImpl> DeferredNodeFactory::makeGroupNode(GroupNodeAccess const& _aNodeAccess)
 	{
-		return new configuration::DeferredGroupNodeImpl(_aNodeAccess.address());
+	    return new configuration::DeferredGroupNodeImpl(_aNodeAccess);
 	}
 	//-------------------------------------------------------------------------
 
-	NodeImplHolder DeferredNodeFactory::makeSetNode  (SetNodeAccess const& _aNodeAccess, Template* pTemplate)
+	rtl::Reference<NodeImpl> DeferredNodeFactory::makeSetNode  (SetNodeAccess const& _aNodeAccess, Template* pTemplate)
 	{
-		return new configuration::DeferredSetNodeImpl(_aNodeAccess.address(),pTemplate);
+	    return new configuration::DeferredSetNodeImpl(_aNodeAccess,pTemplate);
 	}
 	//-------------------------------------------------------------------------
 
Index: configmgr/source/treemgr/nodefactory.hxx
===================================================================
RCS file: /cvs/util/configmgr/source/treemgr/nodefactory.hxx,v
retrieving revision 1.3
retrieving revision 1.3.84.1
diff -u -p -u -p -r1.3 -r1.3.84.1
--- configmgr/source/treemgr/nodefactory.hxx	8 Sep 2005 04:31:18 -0000	1.3
+++ configmgr/source/treemgr/nodefactory.hxx	8 Jan 2007 20:49:03 -0000	1.3.84.1
@@ -55,7 +55,6 @@ namespace configmgr
 	{
 		class NodeImpl;
 		class Template;
-
     }
 //-----------------------------------------------------------------------------
 	namespace view
@@ -69,7 +68,6 @@ namespace configmgr
 
 		struct NodeFactory
 		{
-            
             virtual NodeImplRef makeValueNode(data::ValueNodeAccess const& _aNodeAccess) = 0;
 			virtual NodeImplRef makeGroupNode(data::GroupNodeAccess const& _aNodeAccess) = 0;
 			virtual NodeImplRef makeSetNode(data::SetNodeAccess const& _aNodeAccess, configuration::Template* pTemplate) = 0;
Index: configmgr/source/treemgr/nodeimpl.cxx
===================================================================
RCS file: /cvs/util/configmgr/source/treemgr/nodeimpl.cxx,v
retrieving revision 1.24
retrieving revision 1.24.24.3
diff -u -p -u -p -r1.24 -r1.24.24.3
--- configmgr/source/treemgr/nodeimpl.cxx	16 Sep 2006 15:30:17 -0000	1.24
+++ configmgr/source/treemgr/nodeimpl.cxx	12 Jan 2007 14:50:47 -0000	1.24.24.3
@@ -83,19 +83,6 @@ namespace configmgr
 	namespace configuration
 	{
 
-
-//-----------------------------------------------------------------------------
-// class NodeImpl
-//-----------------------------------------------------------------------------
-
-/// provide access to the data of the underlying node
-data::NodeAccessRef NodeImpl::getOriginalNodeAccessRef(data::Accessor const * _pAccessor) const
-{
-    return data::NodeAccessRef(_pAccessor,m_aNodeRef_);
-}
-//-----------------------------------------------------------------------------
-
-
 // Specific types of nodes
 //-----------------------------------------------------------------------------
 
@@ -103,11 +90,11 @@ data::NodeAccessRef NodeImpl::getOrigina
 // class GroupNodeImpl
 //-----------------------------------------------------------------------------
 
-data::GroupNodeAccess GroupNodeImpl::getDataAccess(data::Accessor const& _aAccessor) const
+data::GroupNodeAccess GroupNodeImpl::getDataAccess() const
 {
     using namespace data;
 
-    NodeAccessRef aNodeAccess = getOriginalNodeAccessRef(&_aAccessor);
+    NodeAccess aNodeAccess = getOriginalNodeAccess();
     OSL_ASSERT(GroupNodeAccess::isInstance(aNodeAccess));
 
     GroupNodeAccess aGroupAccess(aNodeAccess);
@@ -117,15 +104,16 @@ data::GroupNodeAccess GroupNodeImpl::get
 }
 //-----------------------------------------------------------------------------
 
-GroupNodeImpl::GroupNodeImpl(data::GroupNodeAddress const& _aNodeRef)
-: NodeImpl(_aNodeRef)
+GroupNodeImpl::GroupNodeImpl(data::GroupNodeAddress _pNodeRef)
+    : NodeImpl(reinterpret_cast<data::NodeAddress>(_pNodeRef))
+    , m_pCache( NULL )
 {
 }
 //-----------------------------------------------------------------------------
 
-bool GroupNodeImpl::areValueDefaultsAvailable(data::Accessor const& _aAccessor) const
+bool GroupNodeImpl::areValueDefaultsAvailable() const
 {
-    data::GroupNodeAccess aGroupAccess = getDataAccess(_aAccessor);
+    data::GroupNodeAccess aGroupAccess = getDataAccess();
 
     return aGroupAccess.data().hasDefaultsAvailable();
 }
@@ -137,13 +125,41 @@ ValueMemberNode GroupNodeImpl::makeValue
 }
 //-----------------------------------------------------------------------------
 
-data::ValueNodeAccess GroupNodeImpl::getOriginalValueNode(data::Accessor const& _aAccessor, Name const& _aName) const
+data::ValueNodeAccess GroupNodeImpl::getOriginalValueNode(Name const& _aName) const
 {
     OSL_ENSURE( !_aName.isEmpty(), "Cannot get nameless child value");
 
     using namespace data;
 
-    NodeAccessRef aChild = this->getDataAccess(_aAccessor).getChildNode(_aName);
+    data::GroupNodeAccess aAccess = this->getDataAccess();
+    const rtl::OUString &rName = _aName.toString();
+
+/*
+    fprintf (stderr, "GroupNodeImpl::GetOriginalValueNode %p '%s' ", this,
+             rtl::OUStringToOString(rName, RTL_TEXTENCODING_UTF8).getStr());
+    fprintf (stderr, "cache '%s'\n",
+             m_pCache ? rtl::OUStringToOString(m_pCache->getName(),
+                                               RTL_TEXTENCODING_UTF8).getStr()
+             : "<null>");
+*/
+
+    if (m_pCache)
+    {
+        if (m_pCache->isNamed(rName))
+            return ValueNodeAccess( (ValueNodeAddress) m_pCache );
+
+        sharable::GroupNode & aNode = aAccess.data();
+        m_pCache = aNode.getNextChild(m_pCache);
+
+        if (m_pCache && m_pCache->isNamed(rName))
+            return ValueNodeAccess( (ValueNodeAddress) m_pCache );
+        m_pCache = NULL;
+    }
+
+    NodeAccess aChild = aAccess.getChildNode(_aName);
+    m_pCache = aChild;
+
+    // FIXME: how should we flush this cache ?
 
     return ValueNodeAccess(aChild);
 }
@@ -152,11 +168,11 @@ data::ValueNodeAccess GroupNodeImpl::get
 // class ValueElementNodeImpl
 //-----------------------------------------------------------------------------
 
-data::ValueNodeAccess ValueElementNodeImpl::getDataAccess(data::Accessor const& _aAccessor) const				
+data::ValueNodeAccess ValueElementNodeImpl::getDataAccess() const
 { 
     using namespace data;
 
-    NodeAccessRef aNodeAccess = getOriginalNodeAccessRef(&_aAccessor);
+    NodeAccess aNodeAccess = getOriginalNodeAccess();
     OSL_ASSERT(ValueNodeAccess::isInstance(aNodeAccess));
 
     ValueNodeAccess aValueAccess(aNodeAccess);
@@ -167,20 +183,20 @@ data::ValueNodeAccess ValueElementNodeIm
 //-----------------------------------------------------------------------------
 
 ValueElementNodeImpl::ValueElementNodeImpl(data::ValueNodeAddress const& _aNodeRef)
-: NodeImpl(_aNodeRef)
+    : NodeImpl(reinterpret_cast<data::NodeAddress>(_aNodeRef))
 {
 }
 //-----------------------------------------------------------------------------
 
-UnoAny	ValueElementNodeImpl::getValue(data::Accessor const& _aAccessor) const
+UnoAny	ValueElementNodeImpl::getValue() const
 {
-	return getDataAccess(_aAccessor).getValue();
+	return getDataAccess().getValue();
 }
 //-----------------------------------------------------------------------------
 
-UnoType	ValueElementNodeImpl::getValueType(data::Accessor const& _aAccessor) const
+UnoType	ValueElementNodeImpl::getValueType() const
 {
-	return getDataAccess(_aAccessor).getValueType();
+	return getDataAccess().getValueType();
 }
 //-----------------------------------------------------------------------------
 
@@ -210,10 +226,10 @@ namespace 
 	public:
         typedef typename NodeType::DataAccess DataNodeType;
 
-        NodeCast(NodeImpl& rOriginalNode, data::Accessor const& _aAccessor)
+        NodeCast(NodeImpl& rOriginalNode)
 		: m_pNode(0)
 		{
-			if (this->visitNode(rOriginalNode.getOriginalNodeAccessRef(&_aAccessor)) == DONE)
+			if (this->visitNode(rOriginalNode.getOriginalNodeAccess()) == DONE)
                 m_pNode = static_cast<NodeType*>(&rOriginalNode);
 		}
 
Index: configmgr/source/treemgr/nodeimpl.hxx
===================================================================
RCS file: /cvs/util/configmgr/source/treemgr/nodeimpl.hxx,v
retrieving revision 1.14
retrieving revision 1.14.84.4
diff -u -p -u -p -r1.14 -r1.14.84.4
--- configmgr/source/treemgr/nodeimpl.hxx	8 Sep 2005 04:31:49 -0000	1.14
+++ configmgr/source/treemgr/nodeimpl.hxx	7 Feb 2007 12:00:34 -0000	1.14.84.4
@@ -39,66 +39,63 @@
 #ifndef CONFIGMGR_CONFIGURATION_ATTRIBUTES_HXX_
 #include "attributes.hxx"
 #endif
-#ifndef CONFIGMGR_NODEADDRESS_HXX
-#include "nodeaddress.hxx"
+#ifndef INCLUDED_SHARABLE_NODE_HXX
+#include "node.hxx"
 #endif
-
-#ifndef _SALHELPER_SIMPLEREFERENCEOBJECT_HXX_
-#include <salhelper/simplereferenceobject.hxx>
+#ifndef CONFIGMGR_UTILITY_HXX_
+#include "utility.hxx"
 #endif
 #ifndef _RTL_REF_HXX_
 #include <rtl/ref.hxx>
 #endif
 
+#include "nodeaccess.hxx"
+
 namespace configmgr
 {
 //-----------------------------------------------------------------------------
-    namespace memory { class Accessor; }
-    namespace data { class NodeAccessRef; }
+    namespace data { class NodeAccess; }
     namespace view { class ViewStrategy; }
 //-----------------------------------------------------------------------------
-	namespace configuration
-	{
-//-----------------------------------------------------------------------------
-		typedef unsigned int NodeOffset;
-
-		class TreeImpl;
+    namespace configuration
+    {
+	//-----------------------------------------------------------------------------
+	typedef unsigned int NodeOffset;
+
+	class TreeImpl;
+
+	class Name;
+
+	class NodeChange;
+	class NodeChanges;
+	class NodeChangesInformation;
 
-		class Name;
-
-		class NodeChange;
-		class NodeChanges;
-		class NodeChangesInformation;
 //-----------------------------------------------------------------------------
-
 // Specific types of nodes
 //-----------------------------------------------------------------------------
 
-        class NodeImpl;
-		typedef rtl::Reference<NodeImpl> NodeImplHolder;
+    class NodeImpl;
+//	typedef rtl::Reference<NodeImpl> NodeImplHolder;
+	struct INodeHandler;
 
-		struct INodeHandler;
-
-		// Almost an interface, but derives from concrete OReference
-		class NodeImpl : public salhelper::SimpleReferenceObject
-		{
-            friend class view::ViewStrategy;
-            data::NodeAddress m_aNodeRef_;
-		public:
-            NodeImpl(data::NodeAddress const & _aNodeRef)
-            : m_aNodeRef_(_aNodeRef)
-            {}
-
-		public:
-//			void directCommitChanges(memory::Accessor const& _aAccessor) { doCommitChanges(_aAccessor); }
-
-            /// provide access to the address of the underlying node
-            data::NodeAddress getOriginalNodeAddress() const
-            { return m_aNodeRef_; }
-
-            /// provide access to the data of the underlying node
-            data::NodeAccessRef getOriginalNodeAccessRef(memory::Accessor const * _pAccessor) const;
-		};
+	// Almost an interface, but derives from concrete OReference
+	class NodeImpl : public configmgr::SimpleReferenceObject
+	{
+	    friend class view::ViewStrategy;
+            data::NodeAddress m_pNodeRef;
+	public:
+            NodeImpl(data::NodeAddress _pNodeRef)
+		: m_pNodeRef(_pNodeRef) {}
+
+	public:
+        /// provide access to the address of the underlying node
+        data::NodeAddress getOriginalNodeAddress() const
+            { return m_pNodeRef; }
+
+        /// provide access to the data of the underlying node
+        data::NodeAccess getOriginalNodeAccess() const
+	    { return data::NodeAccess( m_pNodeRef ); }
+	};
 
 //-----------------------------------------------------------------------------
 		class ValueElementNodeImpl;
Index: configmgr/source/treemgr/nodeimplobj.cxx
===================================================================
RCS file: /cvs/util/configmgr/source/treemgr/nodeimplobj.cxx,v
retrieving revision 1.24
retrieving revision 1.24.24.4
diff -u -p -u -p -r1.24 -r1.24.24.4
--- configmgr/source/treemgr/nodeimplobj.cxx	16 Sep 2006 15:30:31 -0000	1.24
+++ configmgr/source/treemgr/nodeimplobj.cxx	16 Jan 2007 12:18:26 -0000	1.24.24.4
@@ -97,7 +97,7 @@ DeferredGroupNodeImpl::~DeferredGroupNod
 }
 //-----------------------------------------------------------------------------
 
-ValueMemberNode DeferredGroupNodeImpl::makeValueMember(data::Accessor const& _aAccessor, Name const& _aName, bool _bForUpdate)
+ValueMemberNode DeferredGroupNodeImpl::makeValueMember(Name const& _aName, bool _bForUpdate)
 {
     MemberChanges::iterator it = m_aChanges.find(_aName);
     
@@ -107,7 +107,7 @@ ValueMemberNode DeferredGroupNodeImpl::m
             OSL_ENSURE(_aName.isEmpty(), "ERROR: Found empty change reference");
 
         else if (_bForUpdate || it->second->isChange()) // found one
-            return ValueMemberNode(_aAccessor, it->second);
+            return ValueMemberNode(it->second);
 
         else // leftover non-change
             m_aChanges.erase(it);
@@ -115,7 +115,7 @@ ValueMemberNode DeferredGroupNodeImpl::m
         // if not found continue with default
     }
     
-    data::ValueNodeAccess aOriginal = getOriginalValueNode(_aAccessor,_aName);
+    data::ValueNodeAccess aOriginal = getOriginalValueNode(_aName);
 
     if (_bForUpdate) // create a new change 
     {
@@ -124,7 +124,7 @@ ValueMemberNode DeferredGroupNodeImpl::m
             MemberChange aNewChange(new ValueMemberNode::DeferredImpl(aOriginal)); 
             m_aChanges[_aName] = aNewChange; 
              
-            return ValueMemberNode(_aAccessor, aNewChange);
+            return ValueMemberNode(aNewChange);
        }
     }
 
@@ -151,16 +151,16 @@ bool DeferredGroupNodeImpl::hasChanges()
 }
 //-----------------------------------------------------------------------------
 
-void DeferredGroupNodeImpl::collectValueChanges(data::Accessor const& _aAccessor, NodeChanges& rChanges, TreeImpl* pParentTree, NodeOffset nNode) const
+void DeferredGroupNodeImpl::collectValueChanges(NodeChanges& rChanges, TreeImpl* pParentTree, NodeOffset nNode) const
 {
     for (MemberChanges::const_iterator it = m_aChanges.begin(); it != m_aChanges.end(); ++it)
     {
         if (it->second.is())
         {
             OSL_ASSERT(!it->first.isEmpty());
-            if (ValueChangeImpl* pValueChange = it->second->collectChange(_aAccessor))
+            if (ValueChangeImpl* pValueChange = it->second->collectChange())
             {
-		        pValueChange->setTarget(_aAccessor,pParentTree,nNode,it->first);
+		        pValueChange->setTarget(pParentTree,nNode,it->first);
 
 		        rChanges.add( NodeChange(pValueChange) );
             }
@@ -201,34 +201,16 @@ DeferredGroupNodeImpl::MemberChange Defe
 }
 
 //-----------------------------------------------------------------------------
-/*
-void DeferredGroupNodeImpl::doCommitChanges(data::Accessor const& _aAccessor)
-{
-    for (ValueChanges::iterator pos = m_aChanges.begin(); pos != m_aChanges.end(); )
-    {
-        ValueChanges::iterator it = pos++; // this is used to allow erasing below
-        if (it->second.is())
-        {
-            it->second->commitDirect(_aAccessor); 
-            m_aChanges.erase(it); // this goes here to ensure exception safety
-        }
-        else
-            OSL_ASSERT(it->first.isEmpty());
-    }
-    m_aChanges.clear();
-}
-*/
-//-----------------------------------------------------------------------------
 
-std::auto_ptr<SubtreeChange> DeferredGroupNodeImpl::preCommitValueChanges(data::Accessor const& _aAccessor)
+std::auto_ptr<SubtreeChange> DeferredGroupNodeImpl::preCommitValueChanges()
 {	
 	std::auto_ptr<SubtreeChange> aRet;
 	
     if (!m_aChanges.empty())
     {
-        data::NodeAccessRef aOriginalData = this->getOriginalNodeAccessRef(&_aAccessor);
+        data::NodeAccess aOriginalData = this->getOriginalNodeAccess();
 		aRet.reset( new SubtreeChange(  aOriginalData.getName().toString(), 
-                                        aOriginalData.getAttributes() ) );
+						aOriginalData->getAttributes() ) );
 
         for (MemberChanges::iterator pos = m_aChanges.begin(); pos != m_aChanges.end(); )
         {
@@ -240,7 +222,7 @@ std::auto_ptr<SubtreeChange> DeferredGro
             }
             else if (it->second->isChange())
             {
-                std::auto_ptr<ValueChange> aValueChange = it->second->preCommitChange(_aAccessor); 
+                std::auto_ptr<ValueChange> aValueChange = it->second->preCommitChange(); 
                 if (aValueChange.get())
                 {
                     std::auto_ptr<Change> aBaseChange(aValueChange.release()); 
@@ -259,7 +241,7 @@ std::auto_ptr<SubtreeChange> DeferredGro
 }
 //-----------------------------------------------------------------------------
 
-void DeferredGroupNodeImpl::finishCommit(data::Accessor const& _aAccessor, SubtreeChange& rChanges)
+void DeferredGroupNodeImpl::finishCommit(SubtreeChange& rChanges)
 {
 	OSL_ENSURE(!rChanges.isSetNodeChange(),"ERROR: Change type SET does not match group");
 
@@ -283,7 +265,7 @@ void DeferredGroupNodeImpl::finishCommit
 
             if (aStoredChange.is())
             {
-                aStoredChange->finishCommit(rValueChange,_aAccessor);
+                aStoredChange->finishCommit(rValueChange);
                 OSL_ENSURE(!aStoredChange->isChange(),"ValueChange is not moot after finishCommit");
             }
             
@@ -301,7 +283,7 @@ void DeferredGroupNodeImpl::finishCommit
 }
 //-----------------------------------------------------------------------------
 
-void DeferredGroupNodeImpl::revertCommit(data::Accessor const& _aAccessor, SubtreeChange& rChanges)
+void DeferredGroupNodeImpl::revertCommit(SubtreeChange& rChanges)
 {
 	OSL_ENSURE(!rChanges.isSetNodeChange(),"ERROR: Change type SET does not match group");
 
@@ -325,7 +307,7 @@ void DeferredGroupNodeImpl::revertCommit
 
             if (aStoredChange.is())
             {
-                aStoredChange->revertCommit(rValueChange,_aAccessor);
+                aStoredChange->revertCommit(rValueChange);
                 OSL_ENSURE(!aStoredChange->isChange(),"ValueChange is not moot after reverting - will be discarded nevertheless");
             }
             m_aChanges.erase( itStoredChange ); // remove change if it is moot
@@ -336,7 +318,7 @@ void DeferredGroupNodeImpl::revertCommit
 }
 //-----------------------------------------------------------------------------
 
-void DeferredGroupNodeImpl::failedCommit(data::Accessor const& _aAccessor, SubtreeChange& rChanges)
+void DeferredGroupNodeImpl::failedCommit(SubtreeChange& rChanges)
 {
 	OSL_ENSURE(!rChanges.isSetNodeChange(),"ERROR: Change type SET does not match group");
 
@@ -359,7 +341,7 @@ void DeferredGroupNodeImpl::failedCommit
             OSL_ENSURE( aStoredChange.is(), "Cannot recover from failed change: found empty change object for Member value change");
 
             if (aStoredChange.is())
-                 aStoredChange->failedCommit(rValueChange,_aAccessor);
+                 aStoredChange->failedCommit(rValueChange);
            {
                 if (!aStoredChange->isChange())
                     m_aChanges.erase( itStoredChange ); // remove change if it is moot
@@ -416,7 +398,7 @@ bool DeferredSetNodeImpl::doIsEmpty() co
 	
 
 	// look for elements in the base set that are not 'deleted' (the changes are all deletions here)
-	{for(NativeIterator it = SetNodeImpl::beginElementSet(), stop = SetNodeImpl::endElementSet();
+	{for(ElementSet::PairIterator it = SetNodeImpl::beginElementSet(), stop = SetNodeImpl::endElementSet();
 		it != stop;
 		++it)
 	{
@@ -437,18 +419,18 @@ ElementTreeImpl* DeferredSetNodeImpl::do
 }
 //-----------------------------------------------------------------------------
 
-SetNodeVisitor::Result DeferredSetNodeImpl::doDispatchToElements(data::Accessor const& _aAccessor, SetNodeVisitor& aVisitor)
+SetNodeVisitor::Result DeferredSetNodeImpl::doDispatchToElements(SetNodeVisitor& aVisitor)
 {
 	SetNodeVisitor::Result eRet = SetNodeVisitor::CONTINUE;
 	// look for elements in the base set that are not hidden by changes
-	{for(NativeIterator it = SetNodeImpl::beginElementSet(), stop = SetNodeImpl::endElementSet();
+	{for(ElementSet::PairIterator it = SetNodeImpl::beginElementSet(), stop = SetNodeImpl::endElementSet();
 		it != stop && eRet != SetNodeVisitor::DONE;
 		++it)
 	{
 		if (m_aChangedData.getElement(it->first) == 0) 
 		{
 			OSL_ASSERT(it->second.isValid());
-			eRet = aVisitor.visit(SetEntry(_aAccessor,it->second.get()));
+			eRet = aVisitor.visit(SetEntry(it->second.get()));
 		}
 	}}
 
@@ -459,7 +441,7 @@ SetNodeVisitor::Result DeferredSetNodeIm
 	{
 		if (it->isValid())
 		{
-			eRet = aVisitor.visit(SetEntry(_aAccessor,it->get()));
+			eRet = aVisitor.visit(SetEntry(it->get()));
 		}
 	}}
 	return eRet;
@@ -472,10 +454,10 @@ bool DeferredSetNodeImpl::hasChanges() c
 }
 //-----------------------------------------------------------------------------
 
-void DeferredSetNodeImpl::collectElementChanges(data::Accessor const& _aAccessor, NodeChanges& rChanges) const
+void DeferredSetNodeImpl::collectElementChanges(NodeChanges& rChanges) const
 {
 	// collect added and deleted nodes
-	{for(NativeIterator it = m_aChangedData.beginNative(), stop = m_aChangedData.endNative();
+	{for(ElementSet::PairIterator it = m_aChangedData.beginNative(), stop = m_aChangedData.endNative();
 		it != stop;
 		++it)
 	{
@@ -485,18 +467,18 @@ void DeferredSetNodeImpl::collectElement
 		{
 			if (pOriginal)
 			{
-				rChanges.add(NodeChange(implCreateReplace(_aAccessor, it->first,it->second,*pOriginal)));
+				rChanges.add(NodeChange(implCreateReplace(it->first,it->second,*pOriginal)));
 			}
 			else
 			{
-				rChanges.add(NodeChange(implCreateInsert(_aAccessor, it->first,it->second)));
+				rChanges.add(NodeChange(implCreateInsert(it->first,it->second)));
 			}
 		}
 		else
 		{
 			if (pOriginal)
 			{
-				rChanges.add(NodeChange(implCreateRemove(_aAccessor, it->first,*pOriginal)));
+				rChanges.add(NodeChange(implCreateRemove(it->first,*pOriginal)));
 			}
 
 			//else nothing to do
@@ -505,14 +487,14 @@ void DeferredSetNodeImpl::collectElement
 
 	// collect preexisting nodes
     // if (!containsValues()) // value elements ar immutable !
-	{for(NativeIterator it = SetNodeImpl::beginElementSet(), stop = SetNodeImpl::endElementSet();
+	{for(ElementSet::PairIterator it = SetNodeImpl::beginElementSet(), stop = SetNodeImpl::endElementSet();
 		it != stop;
 		++it)
 	{
 		if (m_aChangedData.getElement(it->first) == 0) 
 		{
 			OSL_ASSERT(it->second.isValid());
-            view::ViewTreeAccess aElementView(_aAccessor, *it->second);
+			view::ViewTreeAccess aElementView(*it->second);
 
 			if (aElementView.hasChanges())
 				aElementView.collectChanges(rChanges);
@@ -531,7 +513,7 @@ void DeferredSetNodeImpl::markChanged()
 void DeferredSetNodeImpl::doTransferElements(ElementSet& rReplacement)
 {
 	// transfer preexisting nodes (unless replaced/deleted)
-	{for(NativeIterator it = SetNodeImpl::beginElementSet(), stop = SetNodeImpl::endElementSet();
+	{for(ElementSet::PairIterator it = SetNodeImpl::beginElementSet(), stop = SetNodeImpl::endElementSet();
 		it != stop;
 		++it)
 	{
@@ -545,8 +527,8 @@ void DeferredSetNodeImpl::doTransferElem
 
 	// commit added and deleted nodes
 	{
-		NativeIterator it = m_aChangedData.beginNative();
-		NativeIterator const stop = m_aChangedData.endNative();
+		ElementSet::PairIterator it = m_aChangedData.beginNative();
+		ElementSet::PairIterator const stop = m_aChangedData.endNative();
 
 		while(it != stop)
 		{
@@ -562,59 +544,60 @@ void DeferredSetNodeImpl::doTransferElem
 }
 //-----------------------------------------------------------------------------
 
-void DeferredSetNodeImpl::rebuildElement(data::Accessor const& _aAccessor, Name const& _aName, Element const& _aElement)
+void DeferredSetNodeImpl::rebuildElement(Name const& _aName, Element const& _aElement)
 {
     TreeImpl* pContext = this->getParentTree();
     OSL_ENSURE(pContext, "Context tree must be set before rebuilding");
 
     rtl::Reference<view::ViewStrategy> xContextBehavior = pContext->getViewBehavior();
     
-    data::TreeAccessor aElementAccessor = this->getDataAccess(_aAccessor).getElementTree(_aName);
-    OSL_ENSURE(aElementAccessor.isValid(), "Element Tree not found in data");
+    data::TreeAccessor aElementAccessor = this->getDataAccess().getElementTree(_aName);
+    OSL_ENSURE(aElementAccessor != NULL, "Element Tree not found in data");
 
     OSL_ENSURE(_aElement.isValid(), "Element not found in view");
-    data::Accessor aOldAccessor( _aElement->getViewBehavior()->getDataSegment() ); 
-    _aElement->rebuild(xContextBehavior,aElementAccessor,aOldAccessor);
+    _aElement->rebuild(xContextBehavior,aElementAccessor);
 }
 
 //-----------------------------------------------------------------------------
-std::auto_ptr<SubtreeChange> DeferredSetNodeImpl::preCommitChanges(data::Accessor const& _aAccessor, ElementList& _rRemovedElements)
+std::auto_ptr<SubtreeChange> DeferredSetNodeImpl::preCommitChanges(ElementList& _rRemovedElements)
 {	
-    data::NodeAccessRef aOriginalData = this->getOriginalNodeAccessRef(&_aAccessor);
-	// now first get the name of this node
-	Name sSetName = aOriginalData.getName();
-
-	// and make a SubtreeChange
-	std::auto_ptr<SubtreeChange> pSetChange( new SubtreeChange(sSetName.toString(), 															   
-															   getElementTemplate()->getName().toString(),
-															   getElementTemplate()->getModule().toString(),
-															   aOriginalData.getAttributes() ) );			
-
-	// commit preexisting nodes
-	{for(NativeIterator it = SetNodeImpl::beginElementSet(), stop = SetNodeImpl::endElementSet();
-		it != stop;
-		++it)
-	{
-		if (m_aChangedData.getElement(it->first) == 0) 
-		{
-			OSL_ASSERT(it->second.isValid());
-            OSL_ENSURE( !m_bDefault || it->second.inDefault, "m_bDefault is inconsistent");
-
-            view::ViewTreeAccess aElementView(_aAccessor,*it->second);
-            std::auto_ptr<SubtreeChange> pNewChange = aElementView.preCommitChanges(_rRemovedElements);
-			if (pNewChange.get() != 0)
-            {
-                //OSL_ENSURE( !containsValues(), "Unexpected change generated by value set element");
-			    std::auto_ptr<Change> pNewChangeBase( pNewChange.release() );
-				pSetChange->addChange(pNewChangeBase);
-            }
+    data::NodeAccess aOriginalData = this->getOriginalNodeAccess();
+    // now first get the name of this node
+    Name sSetName = aOriginalData.getName();
+
+    // and make a SubtreeChange
+    std::auto_ptr<SubtreeChange> pSetChange( new SubtreeChange(sSetName.toString(), 															   
+							       getElementTemplate()->getName().toString(),
+							       getElementTemplate()->getModule().toString(),
+							       aOriginalData->getAttributes() ) );			
+    
+    // commit preexisting nodes
+    {
+	for(ElementSet::PairIterator it = SetNodeImpl::beginElementSet(), stop = SetNodeImpl::endElementSet();
+	    it != stop;
+	    ++it)
+	{
+	    if (m_aChangedData.getElement(it->first) == 0) 
+	    {
+		OSL_ASSERT(it->second.isValid());
+		OSL_ENSURE( !m_bDefault || it->second.inDefault, "m_bDefault is inconsistent");
+
+		view::ViewTreeAccess aElementView(*it->second);
+		std::auto_ptr<SubtreeChange> pNewChange = aElementView.preCommitChanges(_rRemovedElements);
+		if (pNewChange.get() != 0)
+		{
+		    //OSL_ENSURE( !containsValues(), "Unexpected change generated by value set element");
+		  std::auto_ptr<Change> pNewChangeBase( pNewChange.release() );
+		  pSetChange->addChange(pNewChangeBase);
 		}
-	}}
+	    }
+	}
+    }
 
 	// commit added and deleted nodes
 	{
-		NativeIterator it = m_aChangedData.beginNative();
-		NativeIterator const stop = m_aChangedData.endNative();
+		ElementSet::PairIterator it = m_aChangedData.beginNative();
+		ElementSet::PairIterator const stop = m_aChangedData.endNative();
 
 		while(it != stop)
 		{
@@ -666,7 +649,7 @@ std::auto_ptr<SubtreeChange> DeferredSet
 }
 //-----------------------------------------------------------------------------
 
-void DeferredSetNodeImpl::finishCommit(data::Accessor const& _aAccessor, SubtreeChange& rChanges)
+void DeferredSetNodeImpl::finishCommit(SubtreeChange& rChanges)
 {
 	OSL_ENSURE(rChanges.isSetNodeChange(),"ERROR: Change type GROUP does not match set");
 	OSL_ENSURE(	rChanges.getElementTemplateName() ==  getElementTemplate()->getName().toString(),
@@ -713,7 +696,7 @@ void DeferredSetNodeImpl::finishCommit(d
 				else
 					SetNodeImpl::insertElement(aElementName,*pNewElement);
 
-                this->rebuildElement(_aAccessor,aElementName,*pNewElement);
+                this->rebuildElement(aElementName,*pNewElement);
 			}
 			else
 			{
@@ -732,7 +715,7 @@ void DeferredSetNodeImpl::finishCommit(d
 			{
 				OSL_ENSURE(aRemovedTree.is(), "Cannot take over the removed node");
 			
-				aOriginal->takeTreeAndRebuild(aRemovedTree, _aAccessor);
+				aOriginal->takeTreeAndRebuild(aRemovedTree);
 			}
 			m_aChangedData.removeElement(aElementName);
 		}
@@ -746,7 +729,7 @@ void DeferredSetNodeImpl::finishCommit(d
             if (!it->ISA(SubtreeChange)) throw Exception("Unexpected set element change");
 
 			if (pOriginal && pOriginal->isValid())
-                view::ViewTreeAccess(_aAccessor,**pOriginal).finishCommit(static_cast<SubtreeChange&>(*it));
+                view::ViewTreeAccess(**pOriginal).finishCommit(static_cast<SubtreeChange&>(*it));
 		}
 	}
 	m_bChanged = false;
@@ -755,7 +738,7 @@ void DeferredSetNodeImpl::finishCommit(d
 }
 //-----------------------------------------------------------------------------
 
-void DeferredSetNodeImpl::revertCommit(data::Accessor const& _aAccessor, SubtreeChange& rChanges)
+void DeferredSetNodeImpl::revertCommit(SubtreeChange& rChanges)
 {
 	OSL_ENSURE(rChanges.isSetNodeChange(),"ERROR: Change type GROUP does not match set");
 	OSL_ENSURE(	rChanges.getElementTemplateName() ==  getElementTemplate()->getName().toString(),
@@ -812,7 +795,7 @@ void DeferredSetNodeImpl::revertCommit(d
 			if (pOriginal && pRemovedTree.is())
 			{
 				OSL_ASSERT(pOriginal->isValid());
-				(*pOriginal)->takeTreeAndRebuild(pRemovedTree,_aAccessor);
+				(*pOriginal)->takeTreeAndRebuild(pRemovedTree);
                 OSL_DEBUG_ONLY(pRemovedTree.clear());
 			}
 			OSL_ENSURE(!pRemovedTree.is(), "Could not revert removed node: Nowhere to put ownership");
@@ -827,13 +810,13 @@ void DeferredSetNodeImpl::revertCommit(d
             if (!it->ISA(SubtreeChange)) throw Exception("Unexpected set element change");
 
 			if (pOriginal && pOriginal->isValid())
-                view::ViewTreeAccess(_aAccessor,**pOriginal).revertCommit(static_cast<SubtreeChange&>(*it));
+                view::ViewTreeAccess(**pOriginal).revertCommit(static_cast<SubtreeChange&>(*it));
 		}
 	}
 }
 //-----------------------------------------------------------------------------
 
-void DeferredSetNodeImpl::failedCommit(data::Accessor const& _aAccessor, SubtreeChange& rChanges)
+void DeferredSetNodeImpl::failedCommit(SubtreeChange& rChanges)
 {
 	OSL_ENSURE(rChanges.isSetNodeChange(),"ERROR: Change type GROUP does not match set");
 	OSL_ENSURE(	rChanges.getElementTemplateName() ==  getElementTemplate()->getName().toString(),
@@ -876,8 +859,8 @@ void DeferredSetNodeImpl::failedCommit(d
 
 				if (rAddNode.wasInserted())
 				{ // it has been integrated into the master tree
-                    OSL_ENSURE(getDataAccess(_aAccessor).getElementTree(aElementName).address() == rAddNode.getInsertedTree(),
-                                "Internal Error: Inserted tree address does not match actual data");
+				    OSL_ENSURE(getDataAccess().getElementTree(aElementName) == rAddNode.getInsertedTree(),
+					       "Internal Error: Inserted tree address does not match actual data");
 
 					// so add it
 					if (aOriginal.isValid())
@@ -886,7 +869,7 @@ void DeferredSetNodeImpl::failedCommit(d
 					else
 						SetNodeImpl::insertElement(aElementName,*pNewElement);
 
-                    this->rebuildElement(_aAccessor,aElementName,*pNewElement);
+                    this->rebuildElement(aElementName,*pNewElement);
 				}
 				else // Change not done; need to restore new node (element will be released into the wild then)
 				{
@@ -907,7 +890,7 @@ void DeferredSetNodeImpl::failedCommit(d
 				aRemovedTree = rRemoveNode.getRemovedTree();
 
 				OSL_ASSERT(aOriginal.isValid());
-				if (aRemovedTree.is() && !getDataAccess(_aAccessor).hasElement(aElementName))
+				if (aRemovedTree.is() && !getDataAccess().hasElement(aElementName))
 				{
 					// really removed - then remove the originel
 					if (aOriginal.isValid())
@@ -918,7 +901,7 @@ void DeferredSetNodeImpl::failedCommit(d
 			// handle a added or deleted node
 			if (aOriginal.isValid() && aRemovedTree.is())
 			{
-				aOriginal->takeTreeAndRebuild(aRemovedTree,_aAccessor);
+			  aOriginal->takeTreeAndRebuild(aRemovedTree);
                 //aOriginal->getAccess().makeDirect();
                 OSL_DEBUG_ONLY(aRemovedTree.clear());
 			}
@@ -936,7 +919,7 @@ void DeferredSetNodeImpl::failedCommit(d
             if (!it->ISA(SubtreeChange)) throw Exception("Unexpected set element change");
 
 			if (pOriginal && pOriginal->isValid())
-                view::ViewTreeAccess(_aAccessor,**pOriginal).recoverFailedCommit(static_cast<SubtreeChange&>(*it));
+                view::ViewTreeAccess(**pOriginal).recoverFailedCommit(static_cast<SubtreeChange&>(*it));
 		}
 	}
 	m_bChanged = false;
@@ -1007,7 +990,7 @@ void DeferredSetNodeImpl::removeOldEleme
 }
 //-----------------------------------------------------------------------------
 
-SetElementChangeImpl* DeferredSetNodeImpl::doAdjustChangedElement(data::Accessor const & _aAccessor, NodeChangesInformation& rLocalChanges, Name const& aName, Change const& aChange)
+SetElementChangeImpl* DeferredSetNodeImpl::doAdjustChangedElement(NodeChangesInformation& rLocalChanges, Name const& aName, Change const& aChange)
 {
 	if (Element* pLocalElement = m_aChangedData.getElement(aName))
 	{
@@ -1021,7 +1004,7 @@ SetElementChangeImpl* DeferredSetNodeImp
                 SubtreeChange const& aSubtreeChange = static_cast<SubtreeChange const&>(aChange);
 
 			    // recurse to element tree - but do not notify those changes (?)
-                view::Tree aElementTree(_aAccessor, **pElement);
+                view::Tree aElementTree(**pElement);
 
                 NodeChangesInformation aIgnoredChanges;
                 view::getViewBehavior(aElementTree)->adjustToChanges(aIgnoredChanges,view::getRootNode(aElementTree),aSubtreeChange);
@@ -1045,7 +1028,7 @@ SetElementChangeImpl* DeferredSetNodeImp
 			Element aLocalElement = *pLocalElement;
 
 			// also signal something happened
-			return implCreateReplace(_aAccessor,aName,aLocalElement,aLocalElement);
+			return implCreateReplace(aName,aLocalElement,aLocalElement);
 		}
 		else
 		{ 
@@ -1055,12 +1038,12 @@ SetElementChangeImpl* DeferredSetNodeImp
 	}
 	else
 	{
-		return SetNodeImpl::doAdjustChangedElement(_aAccessor, rLocalChanges,aName,aChange);
+		return SetNodeImpl::doAdjustChangedElement( rLocalChanges,aName,aChange);
 	}
 }
 //-----------------------------------------------------------------------------
 
-SetElementChangeImpl* DeferredSetNodeImpl::doAdjustToAddedElement(data::Accessor const& _aAccessor, Name const& aName, AddNode const& aAddNodeChange, Element const& aNewElement)
+SetElementChangeImpl* DeferredSetNodeImpl::doAdjustToAddedElement(Name const& aName, AddNode const& aAddNodeChange, Element const& aNewElement)
 {
     m_bDefault = false;
 	if (Element* pLocalElement = m_aChangedData.getElement(aName))
@@ -1084,22 +1067,22 @@ SetElementChangeImpl* DeferredSetNodeImp
 			Element aLocalElement = *pLocalElement;
 
 			// just signal something happened
-			return implCreateReplace(_aAccessor,aName,aLocalElement,aLocalElement);
+			return implCreateReplace(aName,aLocalElement,aLocalElement);
 		}
 		else // had been removed locally
 		{
 			// signal what happened
-			return implCreateInsert(_aAccessor,aName,aNewElement);
+			return implCreateInsert(aName,aNewElement);
 		}
 	}
 	else
 	{
-        return SetNodeImpl::implAdjustToAddedElement(_aAccessor,aName,aNewElement,aAddNodeChange.isReplacing());
+        return SetNodeImpl::implAdjustToAddedElement(aName,aNewElement,aAddNodeChange.isReplacing());
 	}
 }
 //-----------------------------------------------------------------------------
 
-SetElementChangeImpl* DeferredSetNodeImpl::doAdjustToRemovedElement(data::Accessor const& _aAccessor, Name const& aName, RemoveNode const& /*aRemoveNodeChange*/)
+SetElementChangeImpl* DeferredSetNodeImpl::doAdjustToRemovedElement(Name const& aName, RemoveNode const& /*aRemoveNodeChange*/)
 {
     m_bDefault = false;
 	if (Element* pLocalElement = m_aChangedData.getElement(aName))
@@ -1115,7 +1098,7 @@ SetElementChangeImpl* DeferredSetNodeImp
 			Element aLocalElement = *pLocalElement;
 
 			// signal something happened 
-			return implCreateReplace(_aAccessor,aName,aLocalElement,aLocalElement);
+			return implCreateReplace(aName,aLocalElement,aLocalElement);
 		}
 		else // already was removed locally
 		{
@@ -1124,19 +1107,19 @@ SetElementChangeImpl* DeferredSetNodeImp
 	}
 	else
 	{
-		return SetNodeImpl::implAdjustToRemovedElement(_aAccessor,aName);
+		return SetNodeImpl::implAdjustToRemovedElement(aName);
 	}
 }
 //-----------------------------------------------------------------------------
 
-void DeferredSetNodeImpl::doDifferenceToDefaultState(data::Accessor const& _aAccessor, SubtreeChange& _rChangeToDefault, ISubtree& _rDefaultTree)
+void DeferredSetNodeImpl::doDifferenceToDefaultState(SubtreeChange& _rChangeToDefault, ISubtree& _rDefaultTree)
 {
     if (!m_bDefault)
     {
-        implDifferenceToDefaultState(_aAccessor,_rChangeToDefault,_rDefaultTree);
+        implDifferenceToDefaultState(_rChangeToDefault,_rDefaultTree);
 
-		NativeIterator it = m_aChangedData.beginNative();
-		NativeIterator const stop = m_aChangedData.endNative();
+		ElementSet::PairIterator it = m_aChangedData.beginNative();
+		ElementSet::PairIterator const stop = m_aChangedData.endNative();
 
 		while(it != stop)
 		{
Index: configmgr/source/treemgr/nodeimplobj.hxx
===================================================================
RCS file: /cvs/util/configmgr/source/treemgr/nodeimplobj.hxx,v
retrieving revision 1.14
retrieving revision 1.14.42.4
diff -u -p -u -p -r1.14 -r1.14.42.4
--- configmgr/source/treemgr/nodeimplobj.hxx	19 Jun 2006 23:33:36 -0000	1.14
+++ configmgr/source/treemgr/nodeimplobj.hxx	12 Jan 2007 14:50:47 -0000	1.14.42.4
@@ -36,6 +36,9 @@
 #ifndef CONFIGMGR_NODEIMPLOBJECTS_HXX_
 #define CONFIGMGR_NODEIMPLOBJECTS_HXX_
 
+#ifndef INCLUDED_SHARABLE_NODE_HXX
+#include "node.hxx"
+#endif
 #ifndef CONFIGMGR_CONFIGNODEBEHAVIOR_HXX_
 #include "nodeimpl.hxx"
 #endif
@@ -48,12 +51,9 @@
 #ifndef CONFIGMGR_VALUENODEBEHAVIOR_HXX_
 #include "valuenodeimpl.hxx"
 #endif
-#ifndef CONFIGMGR_NODEADDRESS_HXX
-#include "nodeaddress.hxx"
-#endif
 
-#ifndef _SALHELPER_SIMPLEREFERENCEOBJECT_HXX_
-#include <salhelper/simplereferenceobject.hxx>
+#ifndef CONFIGMGR_UTILITY_HXX_
+#include "utility.hxx"
 #endif
 
 #ifndef INCLUDED_MEMORY
@@ -63,8 +63,8 @@
 
 namespace configmgr
 {
-	namespace configuration
-	{
+    namespace configuration
+    {
 //-----------------------------------------------------------------------------
 
 // Specific types of nodes for direct or read only access
@@ -73,26 +73,26 @@ namespace configmgr
 // Value Nodes
 //-----------------------------------------------------------------------------
 
-        class ValueMemberNode::DeferredImpl : public salhelper::SimpleReferenceObject
-		{
+        class ValueMemberNode::DeferredImpl : public configmgr::SimpleReferenceObject
+        {
             data::ValueNodeAddress m_aValueRef;
 
             UnoAny      m_aNewValue;
             bool	    m_bToDefault;
             bool	    m_bChange;
 		public:
-			explicit DeferredImpl(data::ValueNodeAccess const& _aValueNode) ;
+            explicit DeferredImpl(data::ValueNodeAccess const& _aValueNode);
 
 			/// does this wrap a change
             bool isChange() const   { return m_bChange; }
 
 			/// retrieve the underlying (original) node location
             data::ValueNodeAddress getOriginalNodeAddress() const
-            { return m_aValueRef; }
+                { return m_aValueRef; }
 
 			/// retrieve the underlying (original) node
-            data::ValueNodeAccess getOriginalNode(data::Accessor const& _aAccessor) const
-            { return data::ValueNodeAccess(_aAccessor,m_aValueRef); }
+            data::ValueNodeAccess getOriginalNode() const
+		{ return data::ValueNodeAccess(m_aValueRef); }
 
 			/// Does this node change to default
             bool isToDefault()		const { return m_bToDefault; }
@@ -108,14 +108,12 @@ namespace configmgr
 			
         public:
             // commit protocol
-			std::auto_ptr<ValueChange> preCommitChange(data::Accessor const& _aAccessor);
-			void finishCommit(ValueChange& rChange, data::Accessor const& _aAccessor);
-			void revertCommit(ValueChange& rChange, data::Accessor const& _aAccessor);
-			void failedCommit(ValueChange& rChange, data::Accessor const& _aAccessor);
-
-			// void commitDirect(data::Accessor const& _aAccessor);
+			std::auto_ptr<ValueChange> preCommitChange();
+			void finishCommit(ValueChange& rChange);
+			void revertCommit(ValueChange& rChange);
+			void failedCommit(ValueChange& rChange);
 
-            ValueChangeImpl* collectChange(data::Accessor const& _aAccessor);
+            ValueChangeImpl* collectChange();
             ValueChangeImpl* adjustToChange(ValueChange const& rExternalChange);
 
             // notification protocol
@@ -141,12 +139,12 @@ namespace configmgr
 
 		public:
 		// commit protocol
-			std::auto_ptr<SubtreeChange> preCommitValueChanges(data::Accessor const& _aAccessor);
-			void finishCommit(data::Accessor const& _aAccessor, SubtreeChange& rChange);
-			void revertCommit(data::Accessor const& _aAccessor, SubtreeChange& rChange);
-			void failedCommit(data::Accessor const& _aAccessor, SubtreeChange& rChange);
+			std::auto_ptr<SubtreeChange> preCommitValueChanges();
+			void finishCommit(SubtreeChange& rChange);
+			void revertCommit(SubtreeChange& rChange);
+			void failedCommit(SubtreeChange& rChange);
 
-			void collectValueChanges(data::Accessor const& _aAccessor, NodeChanges& rChanges, TreeImpl* pParent, NodeOffset nNode) const;
+			void collectValueChanges(NodeChanges& rChanges, TreeImpl* pParent, NodeOffset nNode) const;
 			
 		public:
 		// data access
@@ -157,7 +155,7 @@ namespace configmgr
             MemberChange findValueChange(Name const& aName);
 
             using GroupNodeImpl::makeValueMember;
-            ValueMemberNode makeValueMember(data::Accessor const& _aAccessor, Name const& _aName, bool _bForUpdate);
+            ValueMemberNode makeValueMember(Name const& _aName, bool _bForUpdate);
 
 		private:
             typedef std::map< Name, MemberChange > MemberChanges;
@@ -178,13 +176,13 @@ namespace configmgr
 		public:
 			bool hasChanges() const;
 			void markChanged();
-			void collectElementChanges(data::Accessor const& _aAccessor, NodeChanges& rChanges) const;
+			void collectElementChanges(NodeChanges& rChanges) const;
 
 		public:
-			std::auto_ptr<SubtreeChange> preCommitChanges(data::Accessor const& _aAccessor, ElementList& _rRemovedElements);
-			void failedCommit(data::Accessor const& _aAccessor, SubtreeChange& rChanges);
-			void finishCommit(data::Accessor const& _aAccessor, SubtreeChange& rChanges);
-			void revertCommit(data::Accessor const& _aAccessor, SubtreeChange& rChanges);
+			std::auto_ptr<SubtreeChange> preCommitChanges(ElementList& _rRemovedElements);
+			void failedCommit(SubtreeChange& rChanges);
+			void finishCommit(SubtreeChange& rChanges);
+			void revertCommit(SubtreeChange& rChanges);
 
 			void insertNewElement(Name const& aName, Element const& aNewElement);
 			void removeOldElement(Name const& aName);
@@ -193,20 +191,20 @@ namespace configmgr
 		// NodeImpl implementation
 			virtual bool		           doIsEmpty() const;
 			virtual ElementTreeImpl*	   doFindElement(Name const& aName) ;
-			virtual SetNodeVisitor::Result doDispatchToElements(data::Accessor const& _aAccessor, SetNodeVisitor& aVisitor);
+			virtual SetNodeVisitor::Result doDispatchToElements(SetNodeVisitor& aVisitor);
 
-            virtual void doDifferenceToDefaultState(data::Accessor const& _aAccessor, SubtreeChange& _rChangeToDefault, ISubtree& _rDefaultTree);
+            virtual void doDifferenceToDefaultState(SubtreeChange& _rChangeToDefault, ISubtree& _rDefaultTree);
 
-            virtual SetElementChangeImpl* doAdjustToAddedElement(data::Accessor const& _aAccessor, Name const& aName, AddNode const& aAddNodeChange, Element const & aNewElement);
-			virtual SetElementChangeImpl* doAdjustToRemovedElement(data::Accessor const& _aAccessor, Name const& aName, RemoveNode const& aRemoveNodeChange);
+            virtual SetElementChangeImpl* doAdjustToAddedElement(Name const& aName, AddNode const& aAddNodeChange, Element const & aNewElement);
+			virtual SetElementChangeImpl* doAdjustToRemovedElement(Name const& aName, RemoveNode const& aRemoveNodeChange);
 
-            virtual SetElementChangeImpl* doAdjustChangedElement(data::Accessor const& _aAccessor, NodeChangesInformation& rLocalChanges, Name const& aName, Change const& aChange);
+            virtual SetElementChangeImpl* doAdjustChangedElement(NodeChangesInformation& rLocalChanges, Name const& aName, Change const& aChange);
 
             virtual void doTransferElements(ElementSet& rReplacement);
 
 		// Implementation
 		private:
-			void rebuildElement(data::Accessor const& _aAccessor, Name const& aName, Element const& _aElement);
+			void rebuildElement(Name const& aName, Element const& _aElement);
 
 		private:
 			ElementSet m_aChangedData;
Index: configmgr/source/treemgr/noderef.cxx
===================================================================
RCS file: /cvs/util/configmgr/source/treemgr/noderef.cxx,v
retrieving revision 1.30
retrieving revision 1.30.24.5
diff -u -p -u -p -r1.30 -r1.30.24.5
--- configmgr/source/treemgr/noderef.cxx	16 Sep 2006 15:30:50 -0000	1.30
+++ configmgr/source/treemgr/noderef.cxx	16 Jan 2007 12:18:26 -0000	1.30.24.5
@@ -84,7 +84,7 @@ namespace configmgr
 view::ViewTreeAccess Tree::getView() const
 { 
     OSL_ENSURE(!isEmpty(),"Accessing view for tree: Tree must not be nil");
-    return view::ViewTreeAccess(this->getDataAccessor(),*m_ref);
+    return view::ViewTreeAccess(*m_ref);
 }
 //-----------------------------------------------------------------------------
 // class TreeImplHelper (declared in treeimpl.hxx)
@@ -214,7 +214,7 @@ namespace 
 
 		if (TreeImpl* pTree = anEntry.tree())
 		{
-            Tree aTree( anEntry.accessor(), pTree );
+            Tree aTree( pTree );
             NodeRef aTreeRoot = aTree.getRootNode(); 
 
 		    OSL_ASSERT( Result(NodeVisitor::DONE) == SetNodeVisitor::DONE );
@@ -304,7 +304,7 @@ namespace 
 
 		if (TreeImpl* pTree = anEntry.tree())
 		{
-            Tree aTree( anEntry.accessor(), pTree );
+            Tree aTree( pTree );
 
             node::Attributes aElementAttributes = aTree.getAttributes(aTree.getRootNode());
 
@@ -801,19 +801,16 @@ NodeOffset TreeRef::getContainedInnerNod
 // class Tree
 //-----------------------------------------------------------------------------
 
-Tree::Tree(data::Accessor const& _accessor, TreeImpl* pImpl)
-: m_accessor(_accessor)
-, m_ref(pImpl) 
+Tree::Tree(TreeImpl* pImpl)
+: m_ref(pImpl) 
 {
 }
-//-----------------------------------------------------------------------------
 
-// just DTRT
-Tree::Tree(data::Accessor const& _accessor, TreeRef const& _ref)
-: m_accessor(_accessor)
-, m_ref(_ref) 
+Tree::Tree(TreeRef const& _ref)
+: m_ref(_ref) 
 {
 }
+
 //-----------------------------------------------------------------------------
 
 void TreeRef::disposeData()
@@ -1085,8 +1082,8 @@ NodeRef Tree::getParent(AnyNodeRef const
 
 UnoAny Tree::getNodeValue(ValueRef const& aNode) const
 {
-	OSL_PRECOND( aNode.isValid(), "ERROR: Configuration: Value operation requires a valid Value Ref");
-	if (!aNode.isValid()) return UnoAny();
+    OSL_PRECOND( aNode.isValid(), "ERROR: Configuration: Value operation requires a valid Value Ref");
+    if (!aNode.isValid()) return UnoAny();
 
     OSL_PRECOND( isValidNode(aNode), "ERROR: Configuration: Value Ref does not point to valid value");
 
@@ -1269,7 +1266,7 @@ TreeRef TreeRef::getContextTree() const
 
 Tree Tree::getContextTree() const
 {
-	return Tree(m_accessor, m_ref.getContextTree());
+	return Tree(m_ref.getContextTree());
 }
 //-----------------------------------------------------------------------------
 
@@ -1412,19 +1409,6 @@ NodeVisitor::Result Tree::dispatchToChil
 
 	return aRet;
 }
-//-----------------------------------------------------------------------------
-
-void Tree::rebind(data::Accessor const& _aAccessor)
-{
-    m_accessor = _aAccessor;
-}
-//-----------------------------------------------------------------------------
-
-void Tree::unbind()
-{
-    m_accessor.clear();
-}
-//-----------------------------------------------------------------------------
 
 //-----------------------------------------------------------------------------
 // hashing any pointer
@@ -1566,13 +1550,13 @@ bool SubNodeID::isEmpty() const
 }
 //-----------------------------------------------------------------------------
 
-bool SubNodeID::isValidNode(data::Accessor const& _accessor) const
+bool SubNodeID::isValidNode() const
 {
 	if (!m_aParentID.isValidNode()) return false;
 
 	OSL_ENSURE(!m_sNodeName.isEmpty(),"Invalid subnode ID: Missing Name");
 
-    Tree aCheck( _accessor, TreeImplHelper::tree(m_aParentID) );
+    Tree aCheck( TreeImplHelper::tree(m_aParentID) );
     return aCheck.hasChild( TreeImplHelper::makeNode(m_aParentID),m_sNodeName );
 }
 //-----------------------------------------------------------------------------
@@ -1735,7 +1719,7 @@ bool findInnerChildOrAvailableElement(Tr
         ElementRef aElement = aTree.getAvailableElement(aNode,aName);
         if (aElement.isValid())
         {
-		    aTree = aElement.getElementTree(aTree.getDataAccessor()).getTree();
+		    aTree = aElement.getElementTree().getTree();
 		    aNode = aTree.getRootNode();
 	        return true;	
         }
@@ -1767,7 +1751,7 @@ AnyNodeRef getChildOrElement(Tree& aTree
         ElementRef aElement = aTree.getElement(aParentNode,aName);
         if (aElement.isValid())
         {
-		    aTree = aElement.getElementTree(aTree.getDataAccessor()).getTree();
+		    aTree = aElement.getElementTree().getTree();
             return AnyNodeRef(aTree.getRootNode());
         }
     }
@@ -1811,7 +1795,7 @@ bool findElement(Tree& aTree, NodeRef& a
 
     if (!aElement.isValid()) return false;
 
-    Tree aFoundTree = aElement.getElementTree(aTree.getDataAccessor()).getTree();
+    Tree aFoundTree = aElement.getElementTree().getTree();
 
     OSL_ENSURE(matches(aFoundTree.getRootName(),aName), "Element found, but type prefix does not match - failing");
     if ( !matches(aFoundTree.getRootName(),aName) ) return false;
@@ -1945,13 +1929,13 @@ void getAllContainedNodes(Tree const& aT
 }
 //-----------------------------------------------------------------------------
 
-void getAllChildrenHelper(data::Accessor const& _aAccessor, NodeID const& aNode, SubNodeIDList& aList)
+void getAllChildrenHelper(NodeID const& aNode, SubNodeIDList& aList)
 {
 	aList.clear();
 
 	if (TreeImpl* pTreeImpl = TreeImplHelper::tree(aNode))
 	{
-        view::ViewTreeAccess aView(_aAccessor, *pTreeImpl);
+        view::ViewTreeAccess aView(*pTreeImpl);
 
 		if (NodeOffset const nParent = TreeImplHelper::offset(aNode))
 		{
@@ -2084,25 +2068,6 @@ UnoAny getSimpleElementValue(Tree const&
     view::ViewTreeAccess aView = aTree.getView();
 
     return aView.getValue(aView.toValueNode(aNode));
-}
-
-//-----------------------------------------------------------------------------
-
-osl::Mutex& getRootLock(TreeRef const& aTree)
-{
-	TreeImpl* pImpl = TreeImplHelper::impl(aTree);
-	OSL_PRECOND( pImpl, "ERROR: Configuration: Tree locking requires a non-NULL Tree");
-
-	return pImpl->getRootLock();
-}
-//-----------------------------------------------------------------------------
-
-memory::Segment const * getRootSegment(TreeRef const& aTree)
-{
-	TreeImpl* pImpl = TreeImplHelper::impl(aTree);
-	OSL_PRECOND( pImpl, "ERROR: Configuration: Tree locking requires a non-NULL Tree");
-
-    return pImpl ? pImpl->getRootSegment() : NULL;
 }
 
 //-----------------------------------------------------------------------------
Index: configmgr/source/treemgr/readonlyview.cxx
===================================================================
RCS file: /cvs/util/configmgr/source/treemgr/readonlyview.cxx,v
retrieving revision 1.5
retrieving revision 1.5.24.1
diff -u -p -u -p -r1.5 -r1.5.24.1
--- configmgr/source/treemgr/readonlyview.cxx	16 Sep 2006 15:31:04 -0000	1.5
+++ configmgr/source/treemgr/readonlyview.cxx	16 Jan 2007 12:18:26 -0000	1.5.24.1
@@ -107,9 +107,9 @@ NodeFactory& ReadOnlyViewStrategy::doGet
 //-----------------------------------------------------------------------------
 //-----------------------------------------------------------------------------
 
-ViewStrategyRef createReadOnlyStrategy(memory::Segment const * _pSegment)
+ViewStrategyRef createReadOnlyStrategy()
 {
-    return new ReadOnlyViewStrategy(_pSegment);
+    return new ReadOnlyViewStrategy();
 }
 
 //-----------------------------------------------------------------------------
Index: configmgr/source/treemgr/readonlyview.hxx
===================================================================
RCS file: /cvs/util/configmgr/source/treemgr/readonlyview.hxx,v
retrieving revision 1.3
retrieving revision 1.3.84.1
diff -u -p -u -p -r1.3 -r1.3.84.1
--- configmgr/source/treemgr/readonlyview.hxx	8 Sep 2005 04:33:00 -0000	1.3
+++ configmgr/source/treemgr/readonlyview.hxx	16 Jan 2007 12:18:26 -0000	1.3.84.1
@@ -51,12 +51,9 @@ namespace configmgr
 
 		class ReadOnlyViewStrategy : public ViewStrategy
 		{
-            memory::Segment const * m_pSegment;
 		public:
 			explicit 
-            ReadOnlyViewStrategy(memory::Segment const * _pSegment)
-            : m_pSegment(_pSegment)
-			{}
+            ReadOnlyViewStrategy() {}
 
 		protected:
             // change handling -required
@@ -72,9 +69,6 @@ namespace configmgr
             // set element access
             virtual void doInsertElement(SetNode const& _aNode, Name const& aName, SetNodeEntry const& aNewEntry);
 			virtual void doRemoveElement(SetNode const& _aNode, Name const& aName);
-
-            virtual void doReleaseDataSegment() { m_pSegment = NULL; }
-            virtual memory::Segment const * doGetDataSegment() const { return m_pSegment; }
 
             virtual NodeFactory& doGetNodeFactory();
         private:
Index: configmgr/source/treemgr/roottree.cxx
===================================================================
RCS file: /cvs/util/configmgr/source/treemgr/roottree.cxx,v
retrieving revision 1.18
retrieving revision 1.18.24.3
diff -u -p -u -p -r1.18 -r1.18.24.3
--- configmgr/source/treemgr/roottree.cxx	16 Sep 2006 15:31:20 -0000	1.18
+++ configmgr/source/treemgr/roottree.cxx	16 Jan 2007 12:18:27 -0000	1.18.24.3
@@ -72,30 +72,26 @@ namespace configmgr
 //-----------------------------------------------------------------------------
 
 RootTree createReadOnlyTree(	AbsolutePath const& aRootPath, 
-                                memory::Segment const* _pDataSegment, 
                                 data::NodeAccess const& _aCacheNode, 
                                 TreeDepth nDepth,
-								TemplateProvider const& aTemplateProvider)
+				TemplateProvider const& aTemplateProvider)
 {
-	return RootTree( _aCacheNode.accessor(),
-                     new RootTreeImpl(	view::createReadOnlyStrategy(_pDataSegment),
-										aRootPath, _aCacheNode, nDepth,
-										aTemplateProvider
-									)); 
+	return RootTree( new RootTreeImpl(view::createReadOnlyStrategy(),
+					  aRootPath, _aCacheNode, nDepth,
+					  aTemplateProvider
+					  )); 
 }
 //-----------------------------------------------------------------------------
 
 RootTree createUpdatableTree(	AbsolutePath const& aRootPath, 
-                                memory::Segment const* _pDataSegment, 
                                 data::NodeAccess const& _aCacheNode, 
-								TreeDepth nDepth,
-								TemplateProvider const& aTemplateProvider)
+                                TreeDepth nDepth,
+                                TemplateProvider const& aTemplateProvider)
 {
-	return RootTree( _aCacheNode.accessor(),
-                     new RootTreeImpl(	view::createDeferredChangeStrategy(_pDataSegment),
-										aRootPath, _aCacheNode, nDepth,
-										aTemplateProvider
-									)); 
+	return RootTree(new RootTreeImpl(view::createDeferredChangeStrategy(),
+					  aRootPath, _aCacheNode, nDepth,
+					  aTemplateProvider
+					  )); 
 }
 
 //-----------------------------------------------------------------------------
@@ -148,7 +144,7 @@ void CommitHelper::reset()
 }
 
 //-----------------------------------------------------------------------------
-bool CommitHelper::prepareCommit(data::Accessor const& _aAccessor, TreeChangeList& rChangeList)
+bool CommitHelper::prepareCommit(TreeChangeList& rChangeList)
 {
 	OSL_ENSURE(m_pTree,"ERROR: CommitHelper: Cannot commit without a tree");
 	if (m_pTree == NULL) 
@@ -158,7 +154,7 @@ bool CommitHelper::prepareCommit(data::A
     m_pData.reset( new Data() );
 
 	// get and check the changes
-    std::auto_ptr<SubtreeChange> pTreeChange(view::ViewTreeAccess(_aAccessor,*m_pTree).preCommitChanges(m_pData->m_aRemovedElements));
+    std::auto_ptr<SubtreeChange> pTreeChange(view::ViewTreeAccess(*m_pTree).preCommitChanges(m_pData->m_aRemovedElements));
 	if (pTreeChange.get() == NULL) 
 		return false;
 
@@ -173,7 +169,7 @@ bool CommitHelper::prepareCommit(data::A
 }
 //-----------------------------------------------------------------------------
 
-void CommitHelper::finishCommit(data::Accessor const& _aAccessor, TreeChangeList& rChangeList)
+void CommitHelper::finishCommit(TreeChangeList& rChangeList)
 {
 	OSL_ENSURE(m_pTree,"INTERNAL ERROR: Nothing to finish without a tree");
 
@@ -184,11 +180,11 @@ void CommitHelper::finishCommit(data::Ac
 	if ( !matches(rChangeList.getRootNodePath(), aPath) ) 
 		throw configuration::Exception("INTERNAL ERROR: FinishCommit cannot handle rebased changes trees");
 
-	view::ViewTreeAccess(_aAccessor,*m_pTree).finishCommit(rChangeList.root);
+	view::ViewTreeAccess(*m_pTree).finishCommit(rChangeList.root);
 }
 //-----------------------------------------------------------------------------
 
-void CommitHelper::revertCommit(data::Accessor const& _aAccessor, TreeChangeList& rChangeList)
+void CommitHelper::revertCommit(TreeChangeList& rChangeList)
 {
 	OSL_ENSURE(m_pTree,"INTERNAL ERROR: Nothing to finish without a tree");
 
@@ -198,11 +194,11 @@ void CommitHelper::revertCommit(data::Ac
 	if ( !matches(rChangeList.getRootNodePath(), aPath) ) 
 		throw configuration::Exception("INTERNAL ERROR: FinishCommit cannot handle rebased changes trees");
 
-    view::ViewTreeAccess(_aAccessor,*m_pTree).revertCommit(rChangeList.root);
+    view::ViewTreeAccess(*m_pTree).revertCommit(rChangeList.root);
 }
 //-----------------------------------------------------------------------------
 
-void CommitHelper::failedCommit(data::Accessor const& _aAccessor, TreeChangeList& rChangeList)
+void CommitHelper::failedCommit(TreeChangeList& rChangeList)
 {
 	OSL_ENSURE(m_pTree,"INTERNAL ERROR: Nothing to finish without a tree");
 
@@ -212,7 +208,7 @@ void CommitHelper::failedCommit(data::Ac
 	if ( !matches(rChangeList.getRootNodePath(), aPath) ) 
 		throw configuration::Exception("INTERNAL ERROR: FinishCommit cannot handle rebased changes trees");
 
-	view::ViewTreeAccess(_aAccessor,*m_pTree).recoverFailedCommit(rChangeList.root);
+	view::ViewTreeAccess(*m_pTree).recoverFailedCommit(rChangeList.root);
 }
 //-----------------------------------------------------------------------------
 
Index: configmgr/source/treemgr/setnodeimpl.cxx
===================================================================
RCS file: /cvs/util/configmgr/source/treemgr/setnodeimpl.cxx,v
retrieving revision 1.24
retrieving revision 1.24.24.5
diff -u -p -u -p -r1.24 -r1.24.24.5
--- configmgr/source/treemgr/setnodeimpl.cxx	16 Sep 2006 15:31:34 -0000	1.24
+++ configmgr/source/treemgr/setnodeimpl.cxx	7 Feb 2007 12:00:34 -0000	1.24.24.5
@@ -159,7 +159,7 @@ namespace
        private:
 		Result handle(TreeAccessor const& _aElement);
 
-		Result handle(NodeAccessRef const& _aNonValue);
+		Result handle(NodeAccess const& _aNonValue);
 		Result handle(ValueNodeAccess const& _aValue);
 
 		void add(TreeAccessor const& _aNode);
@@ -222,7 +222,7 @@ namespace
         return CONTINUE;
 	}
     //-------------------------------------------------------------------------
-	CollectElementTrees::Result CollectElementTrees::handle(NodeAccessRef const& _aNonValue)
+	CollectElementTrees::Result CollectElementTrees::handle(NodeAccess const& _aNonValue)
 	{	
             { (void)_aNonValue; }               
         OSL_ENSURE(!ValueNodeAccess::isInstance(_aNonValue),"Unexpected: Value-node dispatched to wrong handler");
@@ -249,13 +249,13 @@ namespace
     }
     //-------------------------------------------------------------------------
     void CollectElementTrees::add(TreeAccessor const& _aTree)
-	{
-        node::Attributes const aAttributes = _aTree.getAttributes();
+    {
+        node::Attributes const aAttributes = _aTree->getAttributes();
 
-		bool bReadonly  = aAttributes.isReadonly();
-		bool bInDefault = !aAttributes.isReplacedForUser();
+	bool bReadonly  = aAttributes.isReadonly();
+	bool bInDefault = !aAttributes.isReplacedForUser();
 
-        view::ViewStrategyRef xStrategy = !bReadonly ? m_xStrategy : view::createReadOnlyStrategy(m_pParentTree ? m_pParentTree->getDataSegment() : NULL);
+        view::ViewStrategyRef xStrategy = !bReadonly ? m_xStrategy : view::createReadOnlyStrategy();
 
 		ElementTreeImpl * pNewTree;
 		if (m_pParentTree)
@@ -278,7 +278,7 @@ bool ElementSet::hasElement(Name const& 
 }
 //-------------------------------------------------------------------------
 
-ElementSet::Element* ElementSet::getElement(Name const& aName)
+ElementTreeData* ElementSet::getElement(Name const& aName)
 {
 	Data::iterator it = m_aData.find(aName);
 	if (it != m_aData.end())
@@ -289,7 +289,7 @@ ElementSet::Element* ElementSet::getElem
 //-------------------------------------------------------------------------
 
 
-ElementSet::Element const* ElementSet::getElement(Name const& aName) const
+ElementTreeData const* ElementSet::getElement(Name const& aName) const
 {
 	Data::const_iterator it = m_aData.find(aName);
 	if (it != m_aData.end())
@@ -299,7 +299,7 @@ ElementSet::Element const* ElementSet::g
 }
 //-------------------------------------------------------------------------
 
-ElementSet::Element ElementSet::findElement(Name const& aName)
+ElementTreeData ElementSet::findElement(Name const& aName)
 {
 	Element aRet;
 
@@ -320,7 +320,7 @@ void ElementSet::insertElement(Name cons
 }
 //-------------------------------------------------------------------------
 
-ElementSet::Element ElementSet::replaceElement(Name const& aName, Element const& aNewEntry)
+ElementTreeData ElementSet::replaceElement(Name const& aName, Element const& aNewEntry)
 {
 	OSL_ENSURE(m_aData.find(aName) != m_aData.end(),"INTERNAL ERROR: Replaced set Element is not present");
 
@@ -333,7 +333,7 @@ ElementSet::Element ElementSet::replaceE
 }
 //-------------------------------------------------------------------------
 
-ElementSet::Element ElementSet::removeElement(Name const& aName)
+ElementTreeData ElementSet::removeElement(Name const& aName)
 {
 	Data::iterator it = m_aData.find(aName);
 	OSL_ENSURE(it != m_aData.end(),"INTERNAL ERROR: Removed set Element is not present");
@@ -352,8 +352,8 @@ ElementSet::Element ElementSet::removeEl
 // class SetEntry
 //-----------------------------------------------------------------------------
 
-SetEntry::SetEntry(data::Accessor const& _aAccessor, ElementTreeImpl* pTree_)
-: m_aAccessor(_aAccessor), m_pTree(pTree_)
+SetEntry::SetEntry(ElementTreeImpl* pTree_)
+: m_pTree(pTree_)
 {
 	OSL_ENSURE(pTree_ == 0 || pTree_->isValidNode(pTree_->root_()),
 				"INTERNAL ERROR: Invalid empty tree used for SetEntry ");
@@ -364,7 +364,7 @@ SetEntry::SetEntry(data::Accessor const&
 view::ViewTreeAccess SetEntry::getTreeView() const
 {
     OSL_ENSURE(isValid(), "Cannot get View Access for NULL SetEntry");
-    return view::ViewTreeAccess(m_aAccessor,*m_pTree);
+    return view::ViewTreeAccess(*m_pTree);
 }
 
 //-----------------------------------------------------------------------------
@@ -374,8 +374,8 @@ view::ViewTreeAccess SetEntry::getTreeVi
 // class SetNodeImpl
 //-------------------------------------------------------------------------
 
-SetNodeImpl::SetNodeImpl(data::SetNodeAddress const& _aNodeRef,Template* pTemplate) 
-: NodeImpl(_aNodeRef)
+SetNodeImpl::SetNodeImpl(data::SetNodeAddress _pNodeRef,Template* pTemplate) 
+: NodeImpl(reinterpret_cast<NodeAddress>(_pNodeRef))
 ,m_aTemplate(pTemplate)
 ,m_aTemplateProvider()
 ,m_pParentTree(0)
@@ -391,7 +391,7 @@ SetNodeImpl::~SetNodeImpl() 
 }
 //-----------------------------------------------------------------------------
 
-void SetNodeImpl::rebuildFrom(SetNodeImpl& rOldData,data::SetNodeAccess const& _aNewNode,data::SetNodeAccess const& _aOldNode)
+void SetNodeImpl::rebuildFrom(SetNodeImpl& rOldData,data::SetNodeAccess const& _aNewNode)
 { 
     m_aTemplate         = rOldData.m_aTemplate;
     m_aTemplateProvider = rOldData.m_aTemplateProvider;
@@ -402,7 +402,7 @@ void SetNodeImpl::rebuildFrom(SetNodeImp
     if (rOldData.implHasLoadedElements())
     {
         rOldData.doTransferElements(m_aDataSet);
-        implRebuildElements(_aNewNode,_aOldNode);
+        implRebuildElements(_aNewNode);
         OSL_ASSERT(this->implHasLoadedElements());
     }
     else
@@ -422,36 +422,36 @@ void SetNodeImpl::doTransferElements(Ele
 }
 //-----------------------------------------------------------------------------
 
-void SetNodeImpl::implRebuildElements(data::SetNodeAccess const& _aNewNode,data::SetNodeAccess const& _aOldNode)
+void SetNodeImpl::implRebuildElements(data::SetNodeAccess const& _aNewNode)
 {
     OSL_ENSURE(m_pParentTree,"Cannot rebuild set without context tree");
     rtl::Reference<view::ViewStrategy> xNewStrategy = m_pParentTree->getViewBehavior();
 
-	for(ElementSet::Iterator it = m_aDataSet.begin(), stop = m_aDataSet.end();
-		it != stop;
-		++it)
-	{
-		OSL_ASSERT(it->isValid());
+    for(ElementSet::Iterator it = m_aDataSet.begin(), stop = m_aDataSet.end();
+	it != stop;
+	++it)
+    {
+	OSL_ASSERT(it->isValid());
         if (!it->isValid()) continue;
 
         Element aElement = *it;
         Name aName = aElement->getSimpleRootName();
 
         data::TreeAccessor const& aNewElementAccess = _aNewNode.getElementTree(aName);
-        data::TreeAccessor const& aOldElementAccess = aElement->getOriginalTreeAccess(_aOldNode.accessor());
-		OSL_ASSERT(aNewElementAccess.isValid());
-		OSL_ASSERT(aOldElementAccess.isValid());
+        data::TreeAccessor const& aOldElementAccess = aElement->getOriginalTreeAccess();
+	OSL_ASSERT(aNewElementAccess != NULL);
+	OSL_ASSERT(aOldElementAccess != NULL);
 
-        aElement->rebuild(xNewStrategy,aNewElementAccess,aOldElementAccess.accessor());
-	}
+	aElement->rebuild(xNewStrategy,aNewElementAccess);
+    }
 }
 //-----------------------------------------------------------------------------
 
-data::SetNodeAccess SetNodeImpl::getDataAccess(data::Accessor const& _aAccessor) const				
+data::SetNodeAccess SetNodeImpl::getDataAccess() const
 { 
     using namespace data;
 
-    NodeAccessRef aNodeAccess = getOriginalNodeAccessRef(&_aAccessor);
+    NodeAccess aNodeAccess = getOriginalNodeAccess();
     OSL_ASSERT(SetNodeAccess::isInstance(aNodeAccess));
 
     SetNodeAccess aSetAccess(aNodeAccess);
@@ -496,20 +496,20 @@ ElementTreeImpl* SetNodeImpl::doFindElem
     return m_aDataSet.findElement(aName).get(); 
 }
 //-------------------------------------------------------------------------
-void SetNodeImpl::doDifferenceToDefaultState(data::Accessor const& _aAccessor, SubtreeChange& _rChangeToDefault, ISubtree& _rDefaultTree)
+void SetNodeImpl::doDifferenceToDefaultState(SubtreeChange& _rChangeToDefault, ISubtree& _rDefaultTree)
 {
     OSL_ENSURE(implHasLoadedElements(),"Should not query difference to default state for set that is not loaded");
-    implDifferenceToDefaultState(_aAccessor,_rChangeToDefault,_rDefaultTree);
+    implDifferenceToDefaultState(_rChangeToDefault,_rDefaultTree);
 }
 //-----------------------------------------------------------------------------
 
-SetElementChangeImpl* SetNodeImpl::doAdjustToAddedElement(data::Accessor const& _aAccessor, Name const& aName, AddNode const& aAddNodeChange, Element const & aNewElement)
+SetElementChangeImpl* SetNodeImpl::doAdjustToAddedElement(Name const& aName, AddNode const& aAddNodeChange, Element const & aNewElement)
 {
-    return implAdjustToAddedElement(_aAccessor,aName,aNewElement,aAddNodeChange.isReplacing());
+    return implAdjustToAddedElement(aName,aNewElement,aAddNodeChange.isReplacing());
 }
 //-------------------------------------------------------------------------
 
-SetElementChangeImpl* SetNodeImpl::implAdjustToAddedElement(data::Accessor const& _aAccessor, Name const& aName, Element const & aNewElement, bool _bReplacing)
+SetElementChangeImpl* SetNodeImpl::implAdjustToAddedElement(Name const& aName, Element const & aNewElement, bool _bReplacing)
 {
     { (void)_bReplacing; }
 	OSL_ENSURE( validatedName(aNewElement) == aName, "Unexpected Name on new element" );
@@ -520,32 +520,32 @@ SetElementChangeImpl* SetNodeImpl::implA
 
 		Element aOldElement = this->replaceElement(aName,aNewElement);
 
-		return implCreateReplace(_aAccessor, aName,aNewElement,aOldElement);
+		return implCreateReplace(aName,aNewElement,aOldElement);
 	}
 	else
 	{
 		OSL_ENSURE( !_bReplacing, "Replaced Element doesn't exist - simply adding" );
 		this->insertElement(aName,aNewElement);
 
-		return implCreateInsert(_aAccessor, aName,aNewElement);
+		return implCreateInsert(aName,aNewElement);
 	}
 }
 //-------------------------------------------------------------------------
 
-SetElementChangeImpl* SetNodeImpl::doAdjustToRemovedElement(data::Accessor const& _aAccessor, Name const& aName, RemoveNode const& /*aRemoveNodeChange*/)
+SetElementChangeImpl* SetNodeImpl::doAdjustToRemovedElement(Name const& aName, RemoveNode const& /*aRemoveNodeChange*/)
 {
-    return implAdjustToRemovedElement(_aAccessor,aName);
+    return implAdjustToRemovedElement(aName);
 }
 //-------------------------------------------------------------------------
 
-SetElementChangeImpl* SetNodeImpl::implAdjustToRemovedElement(data::Accessor const& _aAccessor, Name const& aName)
+SetElementChangeImpl* SetNodeImpl::implAdjustToRemovedElement(Name const& aName)
 {
 	if (Element* pOriginal = getStoredElement(aName))
 	{
 		Element aOldElement = *pOriginal;
 		this->removeElement(aName);
 
-		return implCreateRemove(_aAccessor, aName,aOldElement);
+		return implCreateRemove(aName,aOldElement);
 	}
 	else
 	{
@@ -555,32 +555,32 @@ SetElementChangeImpl* SetNodeImpl::implA
 }
 //-------------------------------------------------------------------------
 
-SetElementChangeImpl* SetNodeImpl::implCreateInsert(data::Accessor const& _aAccessor, Name const& aName, Element const& aNewElement) const
+SetElementChangeImpl* SetNodeImpl::implCreateInsert(Name const& aName, Element const& aNewElement) const
 {
     Path::Component aFullName = Path::makeCompositeName(aName, this->getElementTemplate()->getName());
 
 	SetElementChangeImpl* pRet = new SetInsertImpl(aFullName, aNewElement.tree, true);
-	pRet->setTarget( _aAccessor, getParentTree(), getContextOffset() );
+	pRet->setTarget( getParentTree(), getContextOffset() );
 	return pRet;
 }
 //-------------------------------------------------------------------------
 
-SetElementChangeImpl* SetNodeImpl::implCreateReplace(data::Accessor const& _aAccessor, Name const& aName, Element const& aNewElement, Element const& aOldElement) const
+SetElementChangeImpl* SetNodeImpl::implCreateReplace(Name const& aName, Element const& aNewElement, Element const& aOldElement) const
 {
     Path::Component aFullName = Path::makeCompositeName(aName, this->getElementTemplate()->getName());
 
 	SetElementChangeImpl* pRet = new SetReplaceImpl(aFullName, aNewElement.tree, aOldElement.tree);
-	pRet->setTarget( _aAccessor, getParentTree(), getContextOffset() );
+	pRet->setTarget( getParentTree(), getContextOffset() );
 	return pRet;
 }
 //-------------------------------------------------------------------------
 
-SetElementChangeImpl* SetNodeImpl::implCreateRemove(data::Accessor const& _aAccessor, Name const& aName, Element const& aOldElement) const
+SetElementChangeImpl* SetNodeImpl::implCreateRemove(Name const& aName, Element const& aOldElement) const
 {
     Path::Component aFullName = Path::makeCompositeName(aName, this->getElementTemplate()->getName());
 
 	SetElementChangeImpl* pRet = new SetRemoveImpl(aFullName, aOldElement.tree);
-	pRet->setTarget( _aAccessor, getParentTree(), getContextOffset() );
+	pRet->setTarget( getParentTree(), getContextOffset() );
 	return pRet;
 }
 //-------------------------------------------------------------------------
@@ -624,32 +624,14 @@ Element	SetNodeImpl::removeElement(Name 
     return aOldElement;
 }
 //-------------------------------------------------------------------------
-/*
-void	SetNodeImpl::implMakeIndirect(bool bIndirect)
-{ 
-	for(ElementSet::Iterator it = m_aDataSet.begin(), stop = m_aDataSet.end();
-		it != stop; 
-		++it)
-	{
-        view::ViewTreeAccess accessor = (*it)->getAccess();
-        if (bIndirect)
-            accessor.makeIndirect();
-
-        else
-            accessor.makeDirect();
-
-	}
-}
-//-------------------------------------------------------------------------
-*/
-SetNodeVisitor::Result	SetNodeImpl::doDispatchToElements(data::Accessor const& _aAccessor, SetNodeVisitor& aVisitor)
+SetNodeVisitor::Result	SetNodeImpl::doDispatchToElements(SetNodeVisitor& aVisitor)
 {
 	SetNodeVisitor::Result eRet = SetNodeVisitor::CONTINUE;
 	for(ElementSet::Iterator it = m_aDataSet.begin(), stop = m_aDataSet.end();
 		it != stop && eRet != SetNodeVisitor::DONE; 
 		++it)
 	{
-		eRet = aVisitor.visit( SetEntry(_aAccessor, it->get()) ); 
+		eRet = aVisitor.visit( SetEntry(it->get()) ); 
 	}
 	return eRet;
 }
@@ -722,7 +704,7 @@ Element SetNodeImpl::entryToElement(SetE
 //-------------------------------------------------------------------------
 
 
-SetElementChangeImpl* SetNodeImpl::doAdjustChangedElement(data::Accessor const & _aAccessor, NodeChangesInformation& rLocalChanges, Name const& aName, Change const& _aElementChange)
+SetElementChangeImpl* SetNodeImpl::doAdjustChangedElement(NodeChangesInformation& rLocalChanges, Name const& aName, Change const& _aElementChange)
 {
     SetElementChangeImpl* pThisChange  = NULL;
     
@@ -736,7 +718,7 @@ SetElementChangeImpl* SetNodeImpl::doAdj
 
             SubtreeChange const& aSubtreeChange = static_cast<SubtreeChange const&>(_aElementChange);
 		    // recurse to element tree
-            view::Tree aElementTree(_aAccessor,**pElement);
+            view::Tree aElementTree(**pElement);
 
             view::getViewBehavior(aElementTree)->adjustToChanges(rLocalChanges, view::getRootNode(aElementTree), aSubtreeChange);
         }
@@ -761,7 +743,7 @@ SetElementChangeImpl* SetNodeImpl::doAdj
             OSL_ASSERT(aOldBaseTree.is()); // the tree took ownership
             OSL_ASSERT(aOldElement->isFree()); // the tree is free-floating
 
-		    pThisChange = implCreateReplace(_aAccessor,aName,*pElement,Element(aOldElement,bWasDefault));
+		    pThisChange = implCreateReplace(aName,*pElement,Element(aOldElement,bWasDefault));
 	    }
 	    else
             OSL_ENSURE( false, "Unexpected kind of change to set element" );
@@ -803,27 +785,26 @@ void SetNodeImpl::initElements(TemplateP
 }
 //-----------------------------------------------------------------------------
 
-bool SetNodeImpl::implLoadElements(data::Accessor const& _aAccessor) 
+bool SetNodeImpl::implLoadElements() 
 {
-	if (m_aInit > 0)
-	{
-		OSL_ENSURE(!getElementTemplate().is() || getElementTemplate()->isInstanceTypeKnown(),"ERROR: Need a type-validated template to fill a set");
-		OSL_ENSURE(getTemplateProvider().isValid() || getElementTemplate()->isInstanceValue(), "ERROR: Need a template provider to fill a non-primitive set");
+    if (m_aInit > 0)
+    {
+	OSL_ENSURE(!getElementTemplate().is() || getElementTemplate()->isInstanceTypeKnown(),"ERROR: Need a type-validated template to fill a set");
+	OSL_ENSURE(getTemplateProvider().isValid() || getElementTemplate()->isInstanceValue(), "ERROR: Need a template provider to fill a non-primitive set");
 
         TreeDepth nDepth = m_aInit;
-		implInitElements(this->getDataAccess(_aAccessor),nDepth);
-		m_aInit = 0;
-
-	}
-	OSL_ASSERT(implHasLoadedElements());
+	implInitElements(this->getDataAccess(),nDepth);
+	m_aInit = 0;
+    }
+    OSL_ASSERT(implHasLoadedElements());
 
-	return m_aInit == 0;
+    return m_aInit == 0;
 }
 //-----------------------------------------------------------------------------
 
-void SetNodeImpl::implEnsureElementsLoaded(data::Accessor const& _aAccessor) 
+void SetNodeImpl::implEnsureElementsLoaded() 
 {
-	if (!implLoadElements(_aAccessor))
+	if (!implLoadElements())
 		throw ConstraintViolation("Trying to access set elements beyond the loaded nestng level");
 }
 //-----------------------------------------------------------------------------
@@ -842,7 +823,7 @@ void SetNodeImpl::implInitElements( data
 	for(Iter it = aCollector.collection.begin(), stop = aCollector.collection.end();
 		it != stop; ++it)
 	{
-		implInitElement(implValidateElement(_aNode.accessor(),*it));
+	    implInitElement(implValidateElement(*it));
 	}
 }
 //-------------------------------------------------------------------------
@@ -864,29 +845,29 @@ void SetNodeImpl::implInitElement(Elemen
 }
 //-------------------------------------------------------------------------
 
-Element SetNodeImpl::makeAdditionalElement(data::Accessor const& _aAccessor, rtl::Reference<view::ViewStrategy> const& _xStrategy, AddNode const& aAddNodeChange, TreeDepth nDepth)
+Element SetNodeImpl::makeAdditionalElement(rtl::Reference<view::ViewStrategy> const& _xStrategy, AddNode const& aAddNodeChange, TreeDepth nDepth)
 {
 	OSL_ENSURE(aAddNodeChange.wasInserted(), "Cannot integrate element that is not in tree yet");
 
     data::TreeAddress aAddedTree = aAddNodeChange.getInsertedTree();
 	// need 'unsafe', because ownership would be gone when notifications are sent
-	if (aAddedTree.is())
+	if (aAddedTree != NULL)
 	{
 		// OSL_ENSURE( pNode->ISA(ISubtree), "Type mismatch when adjusting to update: value element found in tree set");
 
 		CollectElementTrees aCollector( _xStrategy, getParentTree(), getContextOffset(),
 									    nDepth, getElementTemplate(), getTemplateProvider() );
 
-        data::TreeAccessor aElementAccess( _aAccessor, aAddedTree);
+        data::TreeAccessor aElementAccess(aAddedTree);
 
-		return implValidateElement(_aAccessor, aCollector.create(aElementAccess));
+		return implValidateElement(aCollector.create(aElementAccess));
 	}
 
     return Element();
 }
 //-------------------------------------------------------------------------
 
-Element SetNodeImpl::implValidateElement(data::Accessor const& _aAccessor, Element const& aNewElement)
+Element SetNodeImpl::implValidateElement(Element const& aNewElement)
 {
 	TemplateHolder aTemplate = getElementTemplate();
 	OSL_ENSURE(aTemplate.is(),"INTERNAL ERROR: No template in set node");
@@ -908,12 +889,12 @@ Element SetNodeImpl::implValidateElement
 			    throw Exception("INTERNAL ERROR: Complex element tree in value set");
 		    }
 
-            view::Node aElementRoot = view::getRootNode( view::Tree(_aAccessor, *aNewElement) );
+            view::Node aElementRoot = view::getRootNode( view::Tree(*aNewElement) );
 
             OSL_ENSURE(aElementRoot.isValueNode(),"INTERNAL ERROR: Inserting complex type into value set node");
              
             view::ValueNode aValueNode(aElementRoot);
-            UnoType aValueType = aValueNode.get_impl()->getValueType(aValueNode.accessor());
+            UnoType aValueType = aValueNode.get_impl()->getValueType();
 
 		    OSL_ENSURE(	aValueType.getTypeClass() != uno::TypeClass_INTERFACE,
 					    "INTERNAL ERROR: Inserting complex type into value set node");
@@ -1025,9 +1006,9 @@ namespace
     //-------------------------------------------------------------------------
 
 // -----------------------------------------------------------------------------	
-	void DiffToDefault::handleActual(data::TreeAccessor const& _aElement)
+    void DiffToDefault::handleActual(data::TreeAccessor const& _aElement)
     {
-        bool bDefaultElement = _aElement.getRootNode().isDefault();
+        bool bDefaultElement = _aElement.getRootNode()->isDefault();
 
         OUString sName = _aElement.getName().toString();
 
@@ -1073,13 +1054,13 @@ namespace
 //-----------------------------------------------------------------------------
 }
 //-----------------------------------------------------------------------------
-void SetNodeImpl::implDifferenceToDefaultState(data::Accessor const& _aAccessor, SubtreeChange& _rChangeToDefault, ISubtree& _rDefaultTree) const
+void SetNodeImpl::implDifferenceToDefaultState(SubtreeChange& _rChangeToDefault, ISubtree& _rDefaultTree) const
 {
-    DiffToDefault(_rChangeToDefault,_rDefaultTree).diff( getDataAccess(_aAccessor) );
+    DiffToDefault(_rChangeToDefault,_rDefaultTree).diff( getDataAccess() );
 }
 //-----------------------------------------------------------------------------
-void SetNodeImpl::convertChanges(NodeChangesInformation& rLocalChanges, data::Accessor const& _accessor, SubtreeChange const& rExternalChange, 
-									 TreeDepth nDepth)
+void SetNodeImpl::convertChanges(NodeChangesInformation& rLocalChanges, SubtreeChange const& rExternalChange, 
+                                 TreeDepth nDepth)
 {
 	OSL_ASSERT(nDepth > 0);
 
@@ -1088,10 +1069,10 @@ void SetNodeImpl::convertChanges(NodeCha
 		NodeOffset nNode = getContextOffset();
 
 		OSL_ENSURE(pParentTree->isValidNode(nNode), "Invalid context node in Set");
-        OSL_ENSURE(view::Node(_accessor, *pParentTree, nNode).get_impl() == this, 
+        OSL_ENSURE(view::Node(*pParentTree, nNode).get_impl() == this, 
                     "Wrong context node in Set");
 
-		CollectChanges aCollector(rLocalChanges, _accessor, *pParentTree, nNode, getElementTemplate(), nDepth);
+		CollectChanges aCollector(rLocalChanges, *pParentTree, nNode, getElementTemplate(), nDepth);
 
 		aCollector.collectFromChildren(rExternalChange);
 	}
Index: configmgr/source/treemgr/setnodeimpl.hxx
===================================================================
RCS file: /cvs/util/configmgr/source/treemgr/setnodeimpl.hxx,v
retrieving revision 1.11
retrieving revision 1.11.84.4
diff -u -p -u -p -r1.11 -r1.11.84.4
--- configmgr/source/treemgr/setnodeimpl.hxx	8 Sep 2005 04:33:57 -0000	1.11
+++ configmgr/source/treemgr/setnodeimpl.hxx	7 Feb 2007 12:00:34 -0000	1.11.84.4
@@ -80,16 +80,14 @@ namespace configmgr
 	
 		struct SetEntry
 		{ 
-			SetEntry(data::Accessor const& _aAccessor,ElementTreeImpl* _pTree);
+			SetEntry(ElementTreeImpl* _pTree);
 
 			bool isValid()	const { return m_pTree != 0; }
 
-            data::Accessor const& accessor() const { return m_aAccessor; }
 			ElementTreeImpl* tree() const { return m_pTree; }; 
 
             view::ViewTreeAccess    getTreeView() const;
 		private:
-            data::Accessor   m_aAccessor;
 			ElementTreeImpl* m_pTree; 
 		};
 	//-------------------------------------------------------------------------
@@ -130,20 +128,19 @@ namespace configmgr
 		class ElementSet
 		{
 		public:
-			typedef ElementTreeData Element;
-			typedef std::map<Name, Element>	Data;
+			typedef std::map<Name, ElementTreeData>	Data;
 
 		// the following must be implemented by derived classes
 			bool isEmpty() const { return m_aData.empty(); }
 
 			bool hasElement(Name const& aName) const;
-			Element* getElement(Name const& aName);
-			Element const* getElement(Name const& aName) const;
-			Element findElement(Name const& aName);
-
-			void insertElement(Name const& aName, Element const& aNewEntry);
-			Element replaceElement(Name const& aName, Element const& aNewEntry);
-			Element removeElement(Name const& aName);
+			ElementTreeData* getElement(Name const& aName);
+			ElementTreeData const* getElement(Name const& aName) const;
+			ElementTreeData findElement(Name const& aName);
+
+			void insertElement(Name const& aName, ElementTreeData const& aNewEntry);
+			ElementTreeData replaceElement(Name const& aName, ElementTreeData const& aNewEntry);
+			ElementTreeData removeElement(Name const& aName);
 
 			void clearElements() {	m_aData.clear(); }
 
@@ -156,8 +153,8 @@ namespace configmgr
 			public:
 				ConstIterator(It const& it) : m_base(it) {}
 
-				Element const& operator* () const { return  m_base->second; }
-				Element const* operator->() const { return &m_base->second; }
+				ElementTreeData const& operator* () const { return  m_base->second; }
+				ElementTreeData const* operator->() const { return &m_base->second; }
 				
 				ConstIterator& operator++()		{ ++m_base; return *this; }
 				ConstIterator  operator++(int)	{ return ConstIterator(m_base++); }
@@ -181,8 +178,8 @@ namespace configmgr
 			public:
 				Iterator(It const& it) : m_base(it) {}
 
-				Element& operator* () const { return  m_base->second; }
-				Element* operator->() const { return &m_base->second; }
+				ElementTreeData& operator* () const { return  m_base->second; }
+				ElementTreeData* operator->() const { return &m_base->second; }
 				
 				Iterator& operator++()		{ ++m_base; return *this; }
 				Iterator  operator++(int)	{ return Iterator(m_base++); }
@@ -213,8 +210,8 @@ namespace configmgr
 	// Basic implementation of a set node
 	//-------------------------------------------------------------------------
 
-        class SetNodeImpl : public NodeImpl
-		{
+    class SetNodeImpl : public NodeImpl
+	{
             friend class view::ViewStrategy;
 			ElementSet          m_aDataSet;
 			TemplateHolder	    m_aTemplate;
@@ -226,12 +223,11 @@ namespace configmgr
 			InitHelper		m_aInit;
 
 		public:
-			typedef ElementSet::Element Element;
+			typedef ElementTreeData Element;
 
-			SetNodeImpl(data::SetNodeAddress const& _aNodeRef, Template* pTemplate);
+			SetNodeImpl(data::SetNodeAddress _pNodeRef, Template* pTemplate);
 
-            typedef data::SetNodeAccess	DataAccess; 
-            DataAccess getDataAccess(data::Accessor const& _aAccessor) const;
+            data::SetNodeAccess getDataAccess() const;
 
 			/// Get the template that describes elements of this set
 			TemplateHolder getElementTemplate() const { return m_aTemplate; }
@@ -239,13 +235,13 @@ namespace configmgr
 			/// Get a template provider that can create new elements for this set
 			TemplateProvider getTemplateProvider() const { return m_aTemplateProvider; }
 
-			void convertChanges(NodeChangesInformation& rLocalChanges, data::Accessor const& _accessor, SubtreeChange const& rExternalChange, TreeDepth nDepth);
+			void convertChanges(NodeChangesInformation& rLocalChanges, SubtreeChange const& rExternalChange, TreeDepth nDepth);
 
 			void	insertElement(Name const& aName, Element const& aNewElement); 
 			Element	replaceElement(Name const& aName, Element const& aNewElement);
 			Element	removeElement(Name const& aName);
 
-            void rebuildFrom(SetNodeImpl& rOldData,data::SetNodeAccess const& _aNewNode,data::SetNodeAccess const& _aOldNode);
+            void rebuildFrom(SetNodeImpl& rOldData,data::SetNodeAccess const& _aNewNode);
 
 		protected:
 			~SetNodeImpl();
@@ -254,12 +250,12 @@ namespace configmgr
 		// new overrideables
 			virtual bool                    doIsEmpty() const;
 			virtual ElementTreeImpl*	    doFindElement(Name const& aName) ;
-			virtual SetNodeVisitor::Result  doDispatchToElements(data::Accessor const& _aAccessor, SetNodeVisitor& aVisitor);
-            virtual void doDifferenceToDefaultState(data::Accessor const& _aAccessor, SubtreeChange& _rChangeToDefault, ISubtree& _rDefaultTree);
+			virtual SetNodeVisitor::Result  doDispatchToElements( SetNodeVisitor& aVisitor);
+            virtual void doDifferenceToDefaultState( SubtreeChange& _rChangeToDefault, ISubtree& _rDefaultTree);
 
-            virtual SetElementChangeImpl* doAdjustToAddedElement(data::Accessor const& _aAccessor, Name const& aName, AddNode const& aAddNodeChange, Element const & aNewElement);
-			virtual SetElementChangeImpl* doAdjustToRemovedElement(data::Accessor const& _aAccessor, Name const& aName, RemoveNode const& aRemoveNodeChange);
-			virtual SetElementChangeImpl* doAdjustChangedElement(data::Accessor const& _aAccessor, NodeChangesInformation& rLocalChanges, Name const& aName, Change const& aChange);
+            virtual SetElementChangeImpl* doAdjustToAddedElement( Name const& aName, AddNode const& aAddNodeChange, Element const & aNewElement);
+			virtual SetElementChangeImpl* doAdjustToRemovedElement( Name const& aName, RemoveNode const& aRemoveNodeChange);
+			virtual SetElementChangeImpl* doAdjustChangedElement( NodeChangesInformation& rLocalChanges, Name const& aName, Change const& aChange);
 
             virtual void doTransferElements(ElementSet& rReplacement);
 
@@ -268,7 +264,7 @@ namespace configmgr
 			TreeImpl*	getParentTree() const;
 			NodeOffset	getContextOffset() const;
 
-            Element makeElement(data::Accessor const& _aAccessor, SetEntry const & _anEntry);
+            Element makeElement( SetEntry const & _anEntry);
             static Element entryToElement(SetEntry const& _anEntry);
             view::ViewTreeAccess getElementView();
 
@@ -279,25 +275,25 @@ namespace configmgr
         protected:
 			/// does this set contain any elements (loads elements if needed)
 			bool implHasLoadedElements() const;
-            bool implLoadElements(data::Accessor const& _aAccessor);
-			void implEnsureElementsLoaded(data::Accessor const& _aAccessor);
+            bool implLoadElements();
+			void implEnsureElementsLoaded();
 			void implInitElements(data::SetNodeAccess const& _aNode, TreeDepth nDepth);
 			void implInitElement(Element const& aNewElement); 
  
-            void implRebuildElements(data::SetNodeAccess const& _aNewNode,data::SetNodeAccess const& _aOldNode);
+            void implRebuildElements(data::SetNodeAccess const& _aNewNode);
         protected:
-			SetElementChangeImpl* implCreateInsert    (data::Accessor const& _aAccessor, Name const& aName, Element const& aNewElement) const;
-			SetElementChangeImpl* implCreateReplace   (data::Accessor const& _aAccessor, Name const& aName, Element const& aNewElement, Element const& aOldElement) const;
-			SetElementChangeImpl* implCreateRemove    (data::Accessor const& _aAccessor, Name const& aName, Element const& aOldElement) const;
+			SetElementChangeImpl* implCreateInsert    ( Name const& aName, Element const& aNewElement) const;
+			SetElementChangeImpl* implCreateReplace   ( Name const& aName, Element const& aNewElement, Element const& aOldElement) const;
+			SetElementChangeImpl* implCreateRemove    ( Name const& aName, Element const& aOldElement) const;
 
-			SetElementChangeImpl* implAdjustToAddedElement(data::Accessor const& _aAccessor, Name const& aName, Element const& aNewElement, bool _bReplacing);
-			SetElementChangeImpl* implAdjustToRemovedElement(data::Accessor const& _aAccessor, Name const& aName);
+			SetElementChangeImpl* implAdjustToAddedElement( Name const& aName, Element const& aNewElement, bool _bReplacing);
+			SetElementChangeImpl* implAdjustToRemovedElement( Name const& aName);
             
-            Element makeAdditionalElement(data::Accessor const& _aAccessor, rtl::Reference<view::ViewStrategy> const& _xStrategy, AddNode const& aAddNodeChange, TreeDepth nDepth);
+            Element makeAdditionalElement( rtl::Reference<view::ViewStrategy> const& _xStrategy, AddNode const& aAddNodeChange, TreeDepth nDepth);
 
-			Element implValidateElement(data::Accessor const& _aAccessor, Element const& aNewElement);
+			Element implValidateElement(Element const& aNewElement);
 
-            void implDifferenceToDefaultState(data::Accessor const& _aAccessor, SubtreeChange& _rChangeToDefault, ISubtree& _rDefaultTree) const;
+            void implDifferenceToDefaultState( SubtreeChange& _rChangeToDefault, ISubtree& _rDefaultTree) const;
         protected:
 			bool hasStoredElement(Name const& aName) const
 			{ return m_aDataSet.hasElement(aName); }
@@ -306,10 +302,9 @@ namespace configmgr
 			Element const* getStoredElement(Name const& aName) const
 			{ return m_aDataSet.getElement(aName); }
 
-			typedef ElementSet::PairIterator NativeIterator;
-			NativeIterator beginElementSet() const
+			ElementSet::PairIterator beginElementSet() const
 			{ return m_aDataSet.beginNative(); }
-			NativeIterator endElementSet() const 
+			ElementSet::PairIterator endElementSet() const 
 			{ return m_aDataSet.endNative(); }
 
 			void attach(Element const& aNewElement, Name const& aName);
Index: configmgr/source/treemgr/templateimpl.cxx
===================================================================
RCS file: /cvs/util/configmgr/source/treemgr/templateimpl.cxx,v
retrieving revision 1.21
retrieving revision 1.21.24.2
diff -u -p -u -p -r1.21 -r1.21.24.2
--- configmgr/source/treemgr/templateimpl.cxx	16 Sep 2006 15:32:00 -0000	1.21
+++ configmgr/source/treemgr/templateimpl.cxx	12 Jan 2007 14:50:48 -0000	1.21.24.2
@@ -222,12 +222,12 @@ TemplateProvider_Impl::TemplateProvider_
 }
 //-----------------------------------------------------------------------------
 
-data::TreeSegment TemplateProvider_Impl::instantiate(data::Accessor const& _aSourceAccessor, TemplateHolder const& aTemplate)
+data::TreeSegment TemplateProvider_Impl::instantiate(TemplateHolder const& aTemplate)
 {
 	data::TreeSegment pRet;
 	if (aTemplate.is())
 	{
-        data::TreeAccessor aTemplateData = m_xProvider->requestTemplate(_aSourceAccessor, aTemplate->getName(), aTemplate->getModule());
+        data::TreeAccessor aTemplateData = m_xProvider->requestTemplate(aTemplate->getName(), aTemplate->getModule());
 	
 	    pRet = cloneExpandedForLocale(aTemplateData, m_aOptions.getLocale());
 	}
@@ -261,12 +261,12 @@ namespace
 
 	private: // NodeAction implementation
 		Result handle(ValueNodeAccess const& _aValueNode);
-		Result handle(NodeAccessRef const& _aNonValueNode);
+		Result handle(NodeAccess const& _aNonValueNode);
 	};
 //-----------------------------------------------------------------------------
 	static UnoType detectNodeType(TreeAccessor const& _aElement)
 	{
-		if (!_aElement.isValid())
+		if (_aElement == NULL)
 			throw configuration::Exception("Could not load required template to detect set elements");
 
 		TypeDetector aDetector;
@@ -343,7 +343,7 @@ TemplateHolder TemplateProvider_Impl::ma
 			OSL_ASSERT(_aNames.aName == _aSet.getElementTemplateName());
 			OSL_ASSERT(_aNames.aModule == _aSet.getElementTemplateModule());
 
-			data::TreeAccessor aTemplateData = m_xProvider->requestTemplate(_aSet.accessor(), _aNames.aName, _aNames.aModule);
+			data::TreeAccessor aTemplateData = m_xProvider->requestTemplate(_aNames.aName, _aNames.aModule);
 
 			aType = detectNodeType(aTemplateData); // throws if necessary
 		}
@@ -417,7 +417,7 @@ namespace
         return CONTINUE; // always continue to detect errors in data
 	}
 //-----------------------------------------------------------------------------
-	TypeDetector::Result TypeDetector::handle(NodeAccessRef const& _aNonValueNode)
+	TypeDetector::Result TypeDetector::handle(NodeAccess const& _aNonValueNode)
 	{
             { (void)_aNonValueNode; }                
         OSL_ENSURE(!ValueNodeAccess::isInstance(_aNonValueNode),"Value node dipatched to wrong handler");
Index: configmgr/source/treemgr/templateimpl.hxx
===================================================================
RCS file: /cvs/util/configmgr/source/treemgr/templateimpl.hxx,v
retrieving revision 1.14
retrieving revision 1.14.84.2
diff -u -p -u -p -r1.14 -r1.14.84.2
--- configmgr/source/treemgr/templateimpl.hxx	8 Sep 2005 04:34:41 -0000	1.14
+++ configmgr/source/treemgr/templateimpl.hxx	12 Jan 2007 14:50:48 -0000	1.14.84.2
@@ -52,8 +52,8 @@
 #ifndef _RTL_REF_HXX_
 #include <rtl/ref.hxx>
 #endif
-#ifndef _SALHELPER_SIMPLEREFERENCEOBJECT_HXX_
-#include <salhelper/simplereferenceobject.hxx>
+#ifndef CONFIGMGR_UTILITY_HXX_
+#include "utility.hxx"
 #endif
 
 #ifndef INCLUDED_MAP
@@ -193,7 +193,7 @@ namespace configmgr
 		// class SpecialTemplateProvider_Impl
 		//---------------------------------------------------------------------
 
-		struct SpecialTemplateProvider_Impl : salhelper::SimpleReferenceObject
+		struct SpecialTemplateProvider_Impl : configmgr::SimpleReferenceObject
 		{
 			SpecialTemplateProvider_Impl();
 			
@@ -207,13 +207,13 @@ namespace configmgr
 		// class TemplateProvider_Impl
 		//---------------------------------------------------------------------
 
-		struct TemplateProvider_Impl : salhelper::SimpleReferenceObject
+		struct TemplateProvider_Impl : configmgr::SimpleReferenceObject
 		{
             typedef TemplateProvider::TemplateManagerRef TemplateManagerRef;
 
 			TemplateProvider_Impl(TemplateManagerRef const & xProvider, RequestOptions const& aOptions);
 			
-            data::TreeSegment instantiate(memory::Accessor const& _aSourceAccessor, TemplateHolder const& aTemplate);
+            data::TreeSegment instantiate(TemplateHolder const& aTemplate);
 	
 			TemplateHolder makeElementTemplateWithType(TemplateName const& _aNames, data::SetNodeAccess const& _aSet);
 		private:
Index: configmgr/source/treemgr/treeimpl.cxx
===================================================================
RCS file: /cvs/util/configmgr/source/treemgr/treeimpl.cxx,v
retrieving revision 1.30
retrieving revision 1.30.24.7
diff -u -p -u -p -r1.30 -r1.30.24.7
--- configmgr/source/treemgr/treeimpl.cxx	16 Sep 2006 15:32:13 -0000	1.30
+++ configmgr/source/treemgr/treeimpl.cxx	7 Feb 2007 12:00:34 -0000	1.30.24.7
@@ -88,12 +88,6 @@
 #ifndef CONFIGMGR_CONFIGNODEFACTORY_HXX_
 #include "nodefactory.hxx"
 #endif
-#ifndef CONFIGMGR_SEGMENT_HXX
-#include "segment.hxx"
-#endif
-#ifndef CONFIGMGR_UPDATEACCESSOR_HXX
-#include "updateaccessor.hxx"
-#endif
 
 #ifndef _OSL_DIAGNOSE_H_
 #include <osl/diagnose.h>
@@ -195,7 +189,7 @@ VisitorStatus TreeImplBuilder::handle(da
 
 void TreeImplBuilder::addValueElement(data::ValueNodeAccess const& _aValue)
 {
-	NodeImplHolder aValueNode( m_rFactory.makeValueNode(_aValue) );
+	rtl::Reference<NodeImpl> aValueNode( m_rFactory.makeValueNode(_aValue) );
 	OSL_ENSURE( aValueNode.is(), "could not make value node wrapper" );
 
 	OSL_ENSURE( m_nParent == 0, "Adding value element that is not root of its fragment" );
@@ -216,7 +210,7 @@ void TreeImplBuilder::addValueMember(dat
 
 void TreeImplBuilder::addGroup(data::GroupNodeAccess const& _aTree)
 {
-	NodeImplHolder aGroupNode( m_rFactory.makeGroupNode(_aTree) );
+	rtl::Reference<NodeImpl> aGroupNode( m_rFactory.makeGroupNode(_aTree) );
 	OSL_ENSURE( aGroupNode.is(), "could not make group node wrapper" );
 
 	// TODO:!isValid() => maybe substitute a SimpleValueNodeImpl if possible
@@ -258,7 +252,7 @@ void TreeImplBuilder::addSet(data::SetNo
 	OSL_ASSERT(aTemplate.is());
 	OSL_ENSURE(aTemplate->isInstanceTypeKnown(),"ERROR: Cannor create set instance without knowing the instance type");
 
-	NodeImplHolder aSetNode( m_rFactory.makeSetNode(_aSet,aTemplate.get()) );
+	rtl::Reference<NodeImpl> aSetNode( m_rFactory.makeSetNode(_aSet,aTemplate.get()) );
 	OSL_ENSURE( aSetNode.is(), "could not make set node wrapper" );
 
 	// TODO:!isValid() => maybe substitute a SimpleValueNodeImpl if possible
@@ -278,41 +272,36 @@ void TreeImplBuilder::addSet(data::SetNo
 // class NodeData
 //-----------------------------------------------------------------------------
 
-NodeData::NodeData(NodeImplHolder const& aSpecificNode, Name const& aName, NodeOffset nParent)
+NodeData::NodeData(rtl::Reference<NodeImpl> const& aSpecificNode, Name const& aName, NodeOffset nParent)
 : m_pSpecificNode(aSpecificNode)
 , m_aName_(aName)
 , m_nParent(nParent)
 {
 }
-//-----------------------------------------------------------------------------
 
-data::NodeAccessRef NodeData::getOriginalNodeAccessRef(data::Accessor const * _pAccessor) const
-{
-    return data::NodeAccessRef(_pAccessor, m_pSpecificNode->getOriginalNodeAddress());
-}
 //-----------------------------------------------------------------------------
 
-void NodeData::rebuild(rtl::Reference<view::ViewStrategy> const & _xNewStrategy, data::NodeAccessRef const & _aNewData, data::Accessor const& _aOldAccessor)
+void NodeData::rebuild(rtl::Reference<view::ViewStrategy> const & _xNewStrategy, data::NodeAccess const & _aNewData)
 {
     using namespace data;
 
-    NodeImplHolder aNewImpl;
-    if (this->isSetNode(_aOldAccessor))
+    rtl::Reference<NodeImpl> aNewImpl;
+    if (this->isSetNode())
     {
         SetNodeAccess aNewSet(_aNewData);
         aNewImpl = _xNewStrategy->getNodeFactory().makeSetNode(aNewSet,NULL);
 
-        SetNodeImpl & rOldSetData = this->setImpl(_aOldAccessor);
+        SetNodeImpl & rOldSetData = this->setImpl();
         SetNodeImpl & rNewSetData = static_cast<SetNodeImpl &>(*aNewImpl);
 
-        SetNodeAccess aOldSet = rOldSetData.getDataAccess(_aOldAccessor);
+        SetNodeAccess aOldSet = rOldSetData.getDataAccess();
 
-        rNewSetData.rebuildFrom(rOldSetData,aNewSet,aOldSet);
+        rNewSetData.rebuildFrom(rOldSetData,aNewSet);
     }
-    else if (this->isGroupNode(_aOldAccessor))
+    else if (this->isGroupNode())
         aNewImpl = _xNewStrategy->getNodeFactory().makeGroupNode(GroupNodeAccess(_aNewData));
 
-    else if (this->isValueElementNode(_aOldAccessor))
+    else if (this->isValueElementNode())
         aNewImpl = _xNewStrategy->getNodeFactory().makeValueNode(ValueNodeAccess(_aNewData));
 
     m_pSpecificNode = aNewImpl;
@@ -320,54 +309,54 @@ void NodeData::rebuild(rtl::Reference<vi
 
 //-----------------------------------------------------------------------------
 
-bool NodeData::isSetNode(data::Accessor const& _aAccessor) const
+bool NodeData::isSetNode() const
 {
-    return data::SetNodeAccess::isInstance(getOriginalNodeAccessRef(&_aAccessor));
+    return data::SetNodeAccess::isInstance(getOriginalNodeAccess());
 }
 //-----------------------------------------------------------------------------
 
-bool NodeData::isValueElementNode(data::Accessor const& _aAccessor)	const
+bool NodeData::isValueElementNode()	const
 {
-    return data::ValueNodeAccess::isInstance(getOriginalNodeAccessRef(&_aAccessor));
+    return data::ValueNodeAccess::isInstance(getOriginalNodeAccess());
 }
 //-----------------------------------------------------------------------------
 
-bool NodeData::isGroupNode(data::Accessor const& _aAccessor) const
+bool NodeData::isGroupNode() const
 {
-    return data::GroupNodeAccess::isInstance(getOriginalNodeAccessRef(&_aAccessor));
+    return data::GroupNodeAccess::isInstance(getOriginalNodeAccess());
 }
 //-----------------------------------------------------------------------------
 
-SetNodeImpl&   NodeData::implGetSetImpl(data::Accessor const& _aAccessor)   const
+SetNodeImpl&   NodeData::implGetSetImpl()   const
 {
 	OSL_ASSERT(m_pSpecificNode != 0);
-	OSL_ASSERT(isSetNode(_aAccessor));
+	OSL_ASSERT(isSetNode());
 
-    if (!isSetNode(_aAccessor))
+    if (!isSetNode())
 			throw Exception( "INTERNAL ERROR: Node is not a set node. Cast failing." );
 
     return static_cast<SetNodeImpl&>(*m_pSpecificNode);
 }
 //---------------------------------------------------------------------
 
-GroupNodeImpl& NodeData::implGetGroupImpl(data::Accessor const& _aAccessor) const
+GroupNodeImpl& NodeData::implGetGroupImpl() const
 {
 	OSL_ASSERT(m_pSpecificNode != 0);
-	OSL_ASSERT(isGroupNode(_aAccessor));
+	OSL_ASSERT(isGroupNode());
 
-    if (!isGroupNode(_aAccessor))
+    if (!isGroupNode())
 			throw Exception( "INTERNAL ERROR: Node is not a group node. Cast failing." );
 
     return static_cast<GroupNodeImpl&>(*m_pSpecificNode);
 }
 //---------------------------------------------------------------------
 
-ValueElementNodeImpl& NodeData::implGetValueImpl(data::Accessor const& _aAccessor) const
+ValueElementNodeImpl& NodeData::implGetValueImpl() const
 {
 	OSL_ASSERT(m_pSpecificNode != 0);
-	OSL_ASSERT(isValueElementNode(_aAccessor));
+	OSL_ASSERT(isValueElementNode());
 
-    if (!isValueElementNode(_aAccessor))
+    if (!isValueElementNode())
 			throw Exception( "INTERNAL ERROR: Node is not a value node. Cast failing." );
 
     return static_cast<ValueElementNodeImpl&>(*m_pSpecificNode);
@@ -406,40 +395,21 @@ TreeImpl::~TreeImpl()
 
 void TreeImpl::disposeData()
 {
-	m_aNodes.clear();
-    if (m_xStrategy.is()) m_xStrategy->releaseDataSegment();
-}
-//-----------------------------------------------------------------------------
-
-data::Accessor TreeImpl::getDataAccessor(data::Accessor const& _aExternalAccessor) const
-{
-    if (memory::Segment const* pDataSegment = getDataSegment())
-        return data::Accessor(pDataSegment);
-
-    else
-        return _aExternalAccessor;
-}
-//-----------------------------------------------------------------------------
-
-data::TreeAccessor ElementTreeImpl::getOriginalTreeAccess(data::Accessor const& _aAccessor) const
-{
-    data::Accessor const& aRealAccessor = this->getDataAccessor(_aAccessor);
-//    data::NodeAccess aRoot = nodeData(root_())->getOriginalNodeAccess(aRealAccessor);
-	return data::TreeAccessor(aRealAccessor, m_aDataAddress/*aRoot.getDataPtr()*/);
+    m_aNodes.clear();
 }
 
 //-----------------------------------------------------------------------------
-void TreeImpl::rebuild(rtl::Reference<view::ViewStrategy> const & _xNewStrategy, data::NodeAccessRef const & _aNewData, data::Accessor const& _aOldAccessor)
+void TreeImpl::rebuild(rtl::Reference<view::ViewStrategy> const & _xNewStrategy, data::NodeAccess const & _aNewData)
 {
     m_xStrategy = _xNewStrategy;
-    this->implRebuild( this->root_(), _aNewData, _aOldAccessor);
+    this->implRebuild( this->root_(), _aNewData);
 }
 
 //-----------------------------------------------------------------------------
-void TreeImpl::implRebuild(NodeOffset nNode, data::NodeAccessRef const & _aNewData, data::Accessor const& _aOldAccessor)
+void TreeImpl::implRebuild(NodeOffset nNode, data::NodeAccess const & _aNewData)
 {
     NodeData * pNode = nodeData(nNode);
-    if (pNode->isGroupNode(_aOldAccessor))
+    if (pNode->isGroupNode())
     {
         // first rebuild the children
         data::GroupNodeAccess aNewGroupAccess(_aNewData);
@@ -447,13 +417,13 @@ void TreeImpl::implRebuild(NodeOffset nN
 
         for (NodeOffset nChild = firstChild_(nNode); isValidNode(nChild); nChild = findNextChild_(nNode,nChild))
         {
-            data::NodeAccessRef aChildAccess = aNewGroupAccess.getChildNode(implGetOriginalName(nChild));
+            data::NodeAccess aChildAccess = aNewGroupAccess.getChildNode(implGetOriginalName(nChild));
             OSL_ASSERT(aChildAccess.isValid());
-            implRebuild(nChild,aChildAccess,_aOldAccessor);
+            implRebuild(nChild,aChildAccess);
         }
     }
 
-    pNode->rebuild(m_xStrategy,_aNewData,_aOldAccessor);
+    pNode->rebuild(m_xStrategy,_aNewData);
 }
 
 //-----------------------------------------------------------------------------
@@ -495,7 +465,7 @@ AbsolutePath TreeImpl::getRootPath() con
 	return AbsolutePath(aPath);
 }
 //-----------------------------------------------------------------------------
-void TreeImpl::build(rtl::Reference<view::ViewStrategy> const& _xStrategy, data::NodeAccessRef const& _aRootNode, TreeDepth nDepth, TemplateProvider const& aTemplateProvider)
+void TreeImpl::build(rtl::Reference<view::ViewStrategy> const& _xStrategy, data::NodeAccess const& _aRootNode, TreeDepth nDepth, TemplateProvider const& aTemplateProvider)
 {
 	OSL_ASSERT(m_aNodes.empty());
 	m_nDepth = nDepth;
@@ -568,6 +538,15 @@ Path::Component ElementTreeImpl::doGetRo
 
 //-----------------------------------------------------------------------------
 
+Name ElementTreeImpl::getSimpleRootName() const
+{
+    // TreeImpl::getSimpleRootName tends to parse &
+    // then split the same name, burning CPU L&R
+    return Name( m_aElementName );
+}
+
+//-----------------------------------------------------------------------------
+
 Path::Component RootTreeImpl::doGetRootName() const
 {
     return m_aRootPath.getLocalName();
@@ -587,6 +566,7 @@ Name TreeImpl::getSimpleRootName() const
 {
 	return doGetRootName().getName();
 }
+
 //-----------------------------------------------------------------------------
 
 Path::Component TreeImpl::getExtendedRootName() const
@@ -666,31 +646,6 @@ NodeOffset TreeImpl::findChild_(NodeOffs
 }
 
 //-----------------------------------------------------------------------------
-// locking
-//-----------------------------------------------------------------------------
-osl::Mutex& TreeImpl::getRootLock() const
-{
-	if ( m_pParentTree )
-		return m_pParentTree->getRootLock();
-	else
-		return m_aOwnLock;
-}
-//-----------------------------------------------------------------------------
-memory::Segment const * TreeImpl::getRootSegment() const
-{
-	if ( m_pParentTree )
-		return m_pParentTree->getRootSegment();
-	else
-        return this->getDataSegment();
-}
-//-----------------------------------------------------------------------------
-memory::Segment const * TreeImpl::getDataSegment() const
-{
-    return m_xStrategy->getDataSegment();
-}
-//-----------------------------------------------------------------------------
-
-//-----------------------------------------------------------------------------
 // dynamic-casting
 //-----------------------------------------------------------------------------
 
@@ -780,7 +735,7 @@ ElementTreeImpl::ElementTreeImpl(	rtl::R
 : TreeImpl()
 , m_aInstanceInfo(aTemplateInfo)
 , m_aElementName(_aCacheTree.getName())
-, m_aDataAddress(_aCacheTree.address())
+, m_aDataAddress(_aCacheTree)
 , m_aOwnData()
 {
 	TreeImpl::build( _xStrategy, _aCacheTree.getRootNode(), nDepth, aTemplateProvider );
@@ -795,7 +750,7 @@ ElementTreeImpl::ElementTreeImpl(	rtl::R
 : TreeImpl( rParentTree, nParentNode )
 , m_aInstanceInfo(aTemplateInfo)
 , m_aElementName(_aCacheTree.getName())
-, m_aDataAddress(_aCacheTree.address())
+, m_aDataAddress(_aCacheTree)
 , m_aOwnData()
 {
 	TreeImpl::build( _xStrategy, _aCacheTree.getRootNode(), nDepth, aTemplateProvider );
@@ -811,14 +766,12 @@ ElementTreeImpl::ElementTreeImpl(	data::
 , m_aDataAddress(pNewTree.getBaseAddress())
 , m_aOwnData(pNewTree)
 {
-	if (!pNewTree.is())
-	{
-		throw Exception("ERROR: Provider can't create Element Instance From Template");
-	}
+    if (!pNewTree.is())
+	throw Exception("ERROR: Provider can't create Element Instance From Template");
 
-    data::NodeAccess aNewNodeWrapper( m_aOwnData.getAccessor(), m_aOwnData.getSegmentRootNode() );
+    data::NodeAccess aNewNodeWrapper( m_aOwnData.getSegmentRootNode() );
 
-	TreeImpl::build( view::createDirectAccessStrategy(m_aOwnData), aNewNodeWrapper, c_TreeDepthAll, aTemplateProvider );
+    TreeImpl::build( view::createDirectAccessStrategy(m_aOwnData), aNewNodeWrapper, c_TreeDepthAll, aTemplateProvider );
 }
 //-----------------------------------------------------------------------------
 
@@ -827,9 +780,10 @@ ElementTreeImpl::~ElementTreeImpl()
 }
 //-----------------------------------------------------------------------------
 
-memory::Segment * ElementTreeImpl::getUpdatableSegment(TreeImpl& _rTree)
+bool ElementTreeImpl::isUpdatableSegment(TreeImpl& _rTree)
 {
     TreeImpl * pTree = &_rTree;
+
     while (ElementTreeImpl * pElement = pTree->asElementTree())
     {
         if (pElement->m_aOwnData.is())
@@ -837,10 +791,7 @@ memory::Segment * ElementTreeImpl::getUp
             OSL_ENSURE( pElement->getContextTree()==NULL ||
                         pElement->getContextTree()->getViewBehavior() != pElement->getViewBehavior(),
                         "ElementTree with parent in same fragment should not own its data");
-
-            memory::Segment * pSegment = pElement->m_aOwnData.getSegment();
-            OSL_ASSERT(_rTree.getDataSegment() == pSegment);
-            return pSegment;
+            return true;
         }
 
         pTree = pElement->getContextTree();
@@ -848,15 +799,13 @@ memory::Segment * ElementTreeImpl::getUp
         if (!pTree)
         {
             OSL_ENSURE( false, "ElementTree without own data should have a parent");
-
-            return NULL;
+            return false;
         }
 
     }
     OSL_ENSURE( false, "Tree is not part of free-floating segment - cannot support direct update");
 
-    return NULL;
-
+    return false;
 }
 //-----------------------------------------------------------------------------
 
@@ -882,26 +831,15 @@ Path::Component ElementTreeImpl::makeExt
 
 // ownership handling
 //-----------------------------------------------------------------------------
-void ElementTreeImpl::rebuild(rtl::Reference<view::ViewStrategy> const & _aStrategy, data::TreeAccessor const & _aNewTree, data::Accessor const& _aOldAccessor)
+void ElementTreeImpl::rebuild(rtl::Reference<view::ViewStrategy> const & _aStrategy, data::TreeAccessor const & _aNewTree)
 {
-    TreeImpl::rebuild(_aStrategy,_aNewTree.getRootNode(),_aOldAccessor);
-    m_aDataAddress = _aNewTree.address();
+    TreeImpl::rebuild(_aStrategy,_aNewTree.getRootNode());
+    m_aDataAddress = _aNewTree;
     m_aElementName = _aNewTree.getName();
 }
 
 //-----------------------------------------------------------------------------
-#if 0
-void ElementTreeImpl::rebuild(rtl::Reference<view::ViewStrategy> const & _xStrategy, data::TreeAccessor const & _aNewTree)
-{
-    data::Accessor aOldAccessor( getViewBehavior()->getDataSegment() );
-    this->rebuild(_xStrategy,_aNewTree,aOldAccessor);
-}
-#endif
-//-----------------------------------------------------------------------------
 /// transfer ownership to the given set
-
-// -----------------------------------------------------------------------------
-// -----------------------------------------------------------------------------
 // -----------------------------------------------------------------------------
 void ElementTreeImpl::attachTo(data::SetNodeAccess const & aOwningSet, Name const& aElementName)
 {
@@ -915,20 +853,18 @@ void ElementTreeImpl::attachTo(data::Set
         TreeImpl* pOwningTree = this->getContextTree();
         OSL_ENSURE(pOwningTree, "Element Tree Context must be set before attaching data");
 
-        if (memory::Segment * pTargetSpace = getUpdatableSegment(*pOwningTree))
+        if (isUpdatableSegment(*pOwningTree))
         {
-            memory::UpdateAccessor aTargetAccessor(pTargetSpace);
-
             // copy over to the new segment
-            data::TreeAddress aNewElement = m_aOwnData.getTreeAccess().copyTree(aTargetAccessor);
+            data::TreeAddress aNewElement = m_aOwnData.getTreeAccess().copyTree();
 
-            data::SetNodeAccess::addElement(aTargetAccessor,aOwningSet.address(),  aNewElement);
+            data::SetNodeAccess::addElement(aOwningSet,  aNewElement);
 
-            data::TreeAccessor aNewAccessor(aTargetAccessor.downgrade(),aNewElement);
+            data::TreeAccessor aNewAccessor(aNewElement);
 
             rtl::Reference<view::ViewStrategy> xNewBehavior = pOwningTree->getViewBehavior();
 
-            this->rebuild(xNewBehavior,aNewAccessor,m_aOwnData.getAccessor());
+            this->rebuild(xNewBehavior,aNewAccessor);
         }
         else
             OSL_ENSURE( false, "Cannot attach directly to new tree - no update access available");
@@ -950,26 +886,21 @@ void ElementTreeImpl::detachFrom(data::S
         rtl::Reference< view::ViewStrategy > xOldStrategy = this->getViewBehavior();
         OSL_ENSURE(xOldStrategy.is(), "Element Tree Context must still have the old strategy when detaching data");
 
-        if (memory::Segment * pTargetSpace = xOldStrategy->getDataSegmentForUpdate())
         {
             using namespace data;
 
             // make a new segment with a copy of the data
-            TreeSegment aNewSegment = TreeSegment::createNew( this->getOriginalTreeAccess(aOwningSet.accessor()) );
+            TreeSegment aNewSegment = TreeSegment::createNew( this->getOriginalTreeAccess() );
 
             OSL_ENSURE(aNewSegment.is(),"ERROR: Could not create detached copy of elment data");
 
-            this->takeTreeAndRebuild( aNewSegment, aOwningSet.accessor() );
+            this->takeTreeAndRebuild( aNewSegment );
 
-            memory::UpdateAccessor aTargetAccessor(pTargetSpace);
+            TreeAddress aOldElement = data::SetNodeAccess::removeElement(aOwningSet, aElementName );
+	    OSL_ENSURE(aOldElement != NULL,"ERROR: Detached node not found in the given subtree");
 
-            TreeAddress aOldElement = data::SetNodeAccess::removeElement(aTargetAccessor,aOwningSet.address(), aElementName );
-		    OSL_ENSURE(aOldElement.is(),"ERROR: Detached node not found in the given subtree");
-
-            TreeAccessor::freeTree(aTargetAccessor,aOldElement);
+            TreeAccessor::freeTree(aOldElement);
         }
-        else
-            OSL_ENSURE( false, "Cannot detach directly from old tree - no update access available");
 
         OSL_ENSURE(m_aOwnData.is(),"ERROR: Could not create own data segment for detached node");
 	}
@@ -993,17 +924,16 @@ void ElementTreeImpl::takeTreeBack(data:
 //-----------------------------------------------------------------------------
 
 /// transfer ownership from the given owner
-void ElementTreeImpl::takeTreeAndRebuild(data::TreeSegment const & _aDataSegment, data::Accessor const & _aOldAccessor)
+void ElementTreeImpl::takeTreeAndRebuild(data::TreeSegment const & _aDataSegment)
 {
-	OSL_ENSURE(!m_aOwnData.is(),"ERROR: Cannot take over a node - already owning");
-	OSL_ENSURE(_aDataSegment.is(),"ERROR: Cannot take over NULL tree segment");
-	if (!m_aOwnData.is())
-	{
-        this->rebuild(view::createDirectAccessStrategy(_aDataSegment), _aDataSegment.getTreeAccess(),_aOldAccessor);
-
-		m_aOwnData = _aDataSegment;
+    OSL_ENSURE(!m_aOwnData.is(),"ERROR: Cannot take over a node - already owning");
+    OSL_ENSURE(_aDataSegment.is(),"ERROR: Cannot take over NULL tree segment");
+    if (!m_aOwnData.is())
+    {
+        this->rebuild(view::createDirectAccessStrategy(_aDataSegment), _aDataSegment.getTreeAccess());
+        m_aOwnData = _aDataSegment;
         OSL_ENSURE(m_aOwnData.is(),"ERROR: Could not take over data segment");
-	}
+    }
 }
 //-----------------------------------------------------------------------------
 
Index: configmgr/source/treemgr/treeimpl.hxx
===================================================================
RCS file: /cvs/util/configmgr/source/treemgr/treeimpl.hxx,v
retrieving revision 1.24
retrieving revision 1.24.42.5
diff -u -p -u -p -r1.24 -r1.24.42.5
--- configmgr/source/treemgr/treeimpl.hxx	19 Jun 2006 23:34:48 -0000	1.24
+++ configmgr/source/treemgr/treeimpl.hxx	16 Jan 2007 12:18:27 -0000	1.24.42.5
@@ -52,8 +52,8 @@
 #include "treeaccessor.hxx"
 #endif
 
-#ifndef _SALHELPER_SIMPLEREFERENCEOBJECT_HXX_
-#include <salhelper/simplereferenceobject.hxx>
+#ifndef CONFIGMGR_UTILITY_HXX_
+#include "utility.hxx"
 #endif
 #ifndef _RTL_REF_HXX_
 #include <rtl/ref.hxx>
@@ -152,13 +152,13 @@ namespace configmgr
 		*/
 		class NodeData
 		{
-			NodeImplHolder		m_pSpecificNode;
-			Name          		m_aName_; // cached for better performance
-			NodeOffset			m_nParent;
+			rtl::Reference<NodeImpl> m_pSpecificNode;
+			Name          		     m_aName_; // cached for better performance
+			NodeOffset			     m_nParent;
         public:
-			NodeData(NodeImplHolder const& aSpecificNodeImpl, Name const& aName, NodeOffset nParent);
+			NodeData(rtl::Reference<NodeImpl> const& aSpecificNodeImpl, Name const& aName, NodeOffset nParent);
 
-            void rebuild(rtl::Reference<view::ViewStrategy> const& _xNewStrategy, data::NodeAccessRef const & _aNewData, data::Accessor const & _aOldAccessor);
+            void rebuild(rtl::Reference<view::ViewStrategy> const& _xNewStrategy, data::NodeAccess const & _aNewData);
 		// COMMON: information
 			Name			    getName()       const { return m_aName_; }
 			NodeOffset			getParent()     const { return m_nParent; }
@@ -170,29 +170,30 @@ namespace configmgr
             NodeImpl const &    nodeImpl() const    { return implGetNodeImpl(); }
 
 		// SET: access to child elements
-			bool				isSetNode(data::Accessor const& _aAccessor)		const;
-			SetNodeImpl&		setImpl(data::Accessor const& _aAccessor)			  { return implGetSetImpl(_aAccessor); }
-			SetNodeImpl const&	setImpl(data::Accessor const& _aAccessor)		const { return implGetSetImpl(_aAccessor); }
+			bool				isSetNode()		const;
+			SetNodeImpl&		setImpl()			  { return implGetSetImpl(); }
+			SetNodeImpl const&	setImpl()		const { return implGetSetImpl(); }
 
 		// VALUES: access to data
-			bool				        isValueElementNode(data::Accessor const& _aAccessor)	const;
-			ValueElementNodeImpl&		valueElementImpl(data::Accessor const& _aAccessor)			  { return implGetValueImpl(_aAccessor); }
-			ValueElementNodeImpl const& valueElementImpl(data::Accessor const& _aAccessor)		const { return implGetValueImpl(_aAccessor); }
+			bool				        isValueElementNode()	const;
+			ValueElementNodeImpl&		valueElementImpl()			  { return implGetValueImpl(); }
+			ValueElementNodeImpl const& valueElementImpl()		const { return implGetValueImpl(); }
 
 		// GROUP: access to children 
-			bool				isGroupNode(data::Accessor const& _aAccessor)	const;
-			GroupNodeImpl&		groupImpl(data::Accessor const& _aAccessor)			  { return implGetGroupImpl(_aAccessor); }
-			GroupNodeImpl const&groupImpl(data::Accessor const& _aAccessor)		const { return implGetGroupImpl(_aAccessor); }
+			bool				isGroupNode()	const;
+			GroupNodeImpl&		groupImpl()			  { return implGetGroupImpl(); }
+			GroupNodeImpl const&groupImpl()		const { return implGetGroupImpl(); }
 
         // access helper
 		public:
-            data::NodeAccessRef getOriginalNodeAccessRef(data::Accessor const * _pAccessor) const;		
+            data::NodeAccess getOriginalNodeAccess() const
+                { return data::NodeAccess(m_pSpecificNode->getOriginalNodeAddress()); }
         
 		private:
 			NodeImpl&       implGetNodeImpl() const; 
-			SetNodeImpl&    implGetSetImpl(data::Accessor const& _aAccessor)   const; 
-			GroupNodeImpl&  implGetGroupImpl(data::Accessor const& _aAccessor) const ;
-			ValueElementNodeImpl& implGetValueImpl(data::Accessor const& _aAccessor) const ;
+			SetNodeImpl&    implGetSetImpl()   const; 
+			GroupNodeImpl&  implGetGroupImpl() const ;
+			ValueElementNodeImpl& implGetValueImpl() const ;
 		};
 //-----------------------------------------------------------------------------
 		class RootTreeImpl; // for 'dynamic-casting'
@@ -208,7 +209,7 @@ namespace configmgr
 			<p>	Also provides for navigation to the context this tree is located in
 			</p>
 		*/
-		class TreeImpl : public salhelper::SimpleReferenceObject
+		class TreeImpl : public configmgr::SimpleReferenceObject
 		{
             friend class view::ViewStrategy;
             friend class TreeSetNodeImpl;
@@ -227,13 +228,11 @@ namespace configmgr
 			TreeImpl(TreeImpl& rParentTree, NodeOffset nParentNode);
 
 			/// fills this TreeImpl starting from _aRootNode, using the given factory and the tree's template provider
-            void build(rtl::Reference<view::ViewStrategy> const& _xStrategy, data::NodeAccessRef const& _aRootNode, TreeDepth nDepth, TemplateProvider const& aTemplateProvider);
+            void build(rtl::Reference<view::ViewStrategy> const& _xStrategy, data::NodeAccess const& _aRootNode, TreeDepth nDepth, TemplateProvider const& aTemplateProvider);
 
-            void rebuild(rtl::Reference<view::ViewStrategy> const& _xNewStrategy, data::NodeAccessRef const & _aNewData, data::Accessor const & _aOldAccessor);
+            void rebuild(rtl::Reference<view::ViewStrategy> const& _xNewStrategy, data::NodeAccess const & _aNewData);
 
 		public:
-            data::Accessor      getDataAccessor(data::Accessor const& _aExternalAccessor) const;		
-
 			/// destroys a TreeImpl
 			virtual ~TreeImpl();
 
@@ -270,7 +269,7 @@ namespace configmgr
 
 			/** gets the simple <type>Name</type> of the root node (i.e. of the tree as a whole)
 			*/
-            Name            getSimpleRootName() const;
+            virtual Name            getSimpleRootName() const;
 
 			/** gets the full name of the root node 
 			*/
@@ -289,7 +288,7 @@ namespace configmgr
 			void	prependLocalPathTo(NodeOffset nNode, Path::Rep& rNames);
 
             // check whether defaults are available
-			bool	hasDefaults(NodeOffset _nNode, data::Accessor const& _aAccessor) const;
+			bool	hasDefaults(NodeOffset _nNode) const;
         public:
 			/// gets the <type>NodeOffset</type> of the root node in this tree
 			NodeOffset		root_() const { return m_nRoot; }
@@ -362,11 +361,6 @@ namespace configmgr
 			ElementTreeImpl		* asElementTree();
 			ElementTreeImpl const* asElementTree() const;
 
-		// synchronization and memory managers
-            osl::Mutex& getRootLock() const;
-            memory::Segment const * getRootSegment() const;
-            memory::Segment const * getDataSegment() const;
-
         // Behavior
             rtl::Reference< view::ViewStrategy > getViewBehavior() const;
 		protected:
@@ -376,7 +370,7 @@ namespace configmgr
 
 			void implCommitDirectFrom(NodeOffset nNode);
 */
-            void implRebuild(NodeOffset nNode, data::NodeAccessRef const & _aNewData, data::Accessor const & _aOldAccessor);
+            void implRebuild(NodeOffset nNode, data::NodeAccess const & _aNewData);
 
 		protected:
 			/// set a new parent context for this tree
@@ -397,9 +391,6 @@ namespace configmgr
             /// prepend the absolute path to the root of this tree (no context use)
 			virtual void doFinishRootPath(Path::Rep& rPath) const = 0;
 
-            osl::Mutex& doGetRootLock() const;
-            mutable osl::Mutex m_aOwnLock;
-
             rtl::Reference<view::ViewStrategy> m_xStrategy;
 			NodeList	m_aNodes;
 			TreeImpl*	m_pParentTree;
@@ -407,7 +398,6 @@ namespace configmgr
 			TreeDepth	m_nDepth;
 
 			enum { m_nRoot = 1 }; /// base of <type>NodeOffset</type>s used in this class
-			//NodeOffset	const m_nRoot; /// base of <type>NodeOffset</type>s used in this class
 
             /// prepend the absolute path to the root of this tree (using context if present)
 			void implPrependRootPath(Path::Rep& rPath) const;
@@ -447,13 +437,13 @@ namespace configmgr
 
         // rebuilding
             using TreeImpl::rebuild;
-            void rebuild(rtl::Reference<view::ViewStrategy> const& _xNewStrategy, data::TreeAccessor const & _aNewData, 
-                            data::Accessor const & _aOldAccessor);
+            void rebuild(rtl::Reference<view::ViewStrategy> const& _xNewStrategy, data::TreeAccessor const & _aNewData);
 
         // data access
-            data::TreeAccessor  getOriginalTreeAccess(data::Accessor const& _aAccessor) const;
+            data::TreeAccessor  getOriginalTreeAccess() const { return data::TreeAccessor(m_aDataAddress); }
 
         // Tree information
+            virtual Name            getSimpleRootName() const;
 			/// checks whether this is an instance of a known template
 			bool isTemplateInstance() const	{ return !!m_aInstanceInfo.is(); } 
 			/// checks whether this is an instance of the given template
@@ -473,7 +463,7 @@ namespace configmgr
 			void detachFrom(data::SetNodeAccess const & _aUpdatableSetNode, Name const& aElementName);
 
 			/// take ownership of the given tree (which must not already be the one in use)
-            void takeTreeAndRebuild(data::TreeSegment const& _aElementData, data::Accessor const & _aOldDataAccessor);
+            void takeTreeAndRebuild(data::TreeSegment const& _aElementData);
 			/// take ownership of the given tree (which must already be the one in use)
 			void takeTreeBack(data::TreeSegment const& _aElementData);
 
@@ -491,7 +481,7 @@ namespace configmgr
 			void detachTree();
 
 		private:
-            static memory::Segment * getUpdatableSegment(TreeImpl& _rTree);
+            static bool isUpdatableSegment(TreeImpl& _rTree);
 
 			virtual RootTreeImpl const* doCastToRootTree() const;
 			virtual ElementTreeImpl const* doCastToElementTree() const;
Index: configmgr/source/treemgr/valuemembernode.cxx
===================================================================
RCS file: /cvs/util/configmgr/source/treemgr/valuemembernode.cxx,v
retrieving revision 1.9
retrieving revision 1.9.24.4
diff -u -p -u -p -r1.9 -r1.9.24.4
--- configmgr/source/treemgr/valuemembernode.cxx	16 Sep 2006 15:32:27 -0000	1.9
+++ configmgr/source/treemgr/valuemembernode.cxx	16 Jan 2007 12:18:27 -0000	1.9.24.4
@@ -51,9 +51,6 @@
 #ifndef _CONFIGMGR_TREE_VALUENODE_HXX
 #include "valuenode.hxx"
 #endif
-#ifndef CONFIGMGR_UPDATEACCESSOR_HXX
-#include "updateaccessor.hxx"
-#endif
 
 #ifndef _OSL_DIAGNOSE_H_
 #include <osl/diagnose.h>
@@ -75,37 +72,17 @@ namespace 
 //-----------------------------------------------------------------------------
 
 inline
-void setOriginalValue(memory::UpdateAccessor& _aAccessor, data::ValueNodeAddress const& rOriginalAddress, UnoAny const& aNewValue)
+void setOriginalValue(data::ValueNodeAddress const& rOriginalAddress, UnoAny const& aNewValue)
 {
-    data::ValueNodeAccess::setValue(_aAccessor,rOriginalAddress,aNewValue);
+    data::ValueNodeAccess::setValue(rOriginalAddress,aNewValue);
 }
 //-----------------------------------------------------------------------------
 
 inline
-void setOriginalToDefault(memory::UpdateAccessor& _aAccessor, data::ValueNodeAddress const& rOriginalAddress)
+void setOriginalToDefault(data::ValueNodeAddress const& rOriginalAddress)
 {
-    data::ValueNodeAccess::setToDefault(_aAccessor,rOriginalAddress);
-}
-//-----------------------------------------------------------------------------
-/*
-void ValueMemberNode::DeferredImpl::commitDirect(data::Accessor const& _aAccessor)
-{
-    data::ValueNodeAccess aOriginalNode = getOriginalNode(_aAccessor);
-
-    if (isChange())
-    {
-	    if (m_bToDefault)
-		    setOriginalToDefault(directValueAccess(aOriginalNode));
-
-	    else 
-            setOriginalValue(directValueAccess(aOriginalNode),m_aNewValue);
-    }
-
-    OSL_ENSURE( m_aNewValue == aOriginalNode.getValue(), "Direct Commit: Inconsistent committed value");
-	m_bChange = false;
+    data::ValueNodeAccess::setToDefault(rOriginalAddress);
 }
-*/
-//-----------------------------------------------------------------------------
 } // anonymous namespace
 
 
@@ -114,19 +91,19 @@ void ValueMemberNode::DeferredImpl::comm
 //-----------------------------------------------------------------------------
 
 ValueMemberNode::ValueMemberNode(data::ValueNodeAccess const& _aNodeAccess)
-: m_aNodeRef(_aNodeAccess)
-, m_xDeferredOperation() 
+    : m_aNodeRef(_aNodeAccess)
+    , m_xDeferredOperation() 
 {}
 //-----------------------------------------------------------------------------
-ValueMemberNode::ValueMemberNode(data::Accessor const& _aAccessor, DeferredImplRef const& _xDeferred) // must be valid
-: m_aNodeRef( _xDeferred->getOriginalNode(_aAccessor) )
-, m_xDeferredOperation(_xDeferred) 
+ValueMemberNode::ValueMemberNode(DeferredImplRef const& _xDeferred) // must be valid
+    : m_aNodeRef( _xDeferred->getOriginalNode() )
+    , m_xDeferredOperation(_xDeferred) 
 {}
 //-----------------------------------------------------------------------------
 
 ValueMemberNode::ValueMemberNode(ValueMemberNode const& rOriginal)
-: m_aNodeRef(rOriginal.m_aNodeRef)
-, m_xDeferredOperation(rOriginal.m_xDeferredOperation) 
+    : m_aNodeRef(rOriginal.m_aNodeRef)
+    , m_xDeferredOperation(rOriginal.m_xDeferredOperation) 
 {}
 //-----------------------------------------------------------------------------
 ValueMemberNode& ValueMemberNode::operator=(ValueMemberNode const& rOriginal)
@@ -144,7 +121,7 @@ ValueMemberNode::~ValueMemberNode()
 bool ValueMemberNode::isValid() const
 {
     OSL_ASSERT( !m_xDeferredOperation.is() || 
-                 m_xDeferredOperation->getOriginalNodeAddress() == m_aNodeRef.address() );
+                 m_aNodeRef == m_xDeferredOperation->getOriginalNodeAddress());
     
     return m_aNodeRef.isValid();
 }
@@ -216,12 +193,8 @@ void ValueMemberUpdate::setValue(UnoAny 
 {
     if (m_aMemberNode.m_xDeferredOperation.is())
         m_aMemberNode.m_xDeferredOperation->setValue(aNewValue, m_aMemberNode.m_aNodeRef);
-
-    else if (memory::Segment * pUpdatableSegment = m_pStrategy->getDataSegmentForUpdate())
-    {
-        memory::UpdateAccessor aUpdater(pUpdatableSegment);
-        setOriginalValue( aUpdater, m_aMemberNode.m_aNodeRef.address(), aNewValue );
-    }
+    else
+        setOriginalValue(m_aMemberNode.m_aNodeRef, aNewValue );
 }
 //-----------------------------------------------------------------------------
 
@@ -229,12 +202,8 @@ void ValueMemberUpdate::setDefault() 
 {
     if (m_aMemberNode.m_xDeferredOperation.is())
         m_aMemberNode.m_xDeferredOperation->setValueToDefault(m_aMemberNode.m_aNodeRef);
-
-    else if (memory::Segment * pUpdatableSegment = m_pStrategy->getDataSegmentForUpdate())
-    {
-        memory::UpdateAccessor aUpdater(pUpdatableSegment);
-        setOriginalToDefault( aUpdater, m_aMemberNode.m_aNodeRef.address() );
-    }
+    else
+        setOriginalToDefault( m_aMemberNode.m_aNodeRef );
 }
 
 //-----------------------------------------------------------------------------
@@ -242,7 +211,7 @@ void ValueMemberUpdate::setDefault() 
 //-----------------------------------------------------------------------------
 
 ValueMemberNode::DeferredImpl::DeferredImpl(data::ValueNodeAccess const& _aValueNode)
-: m_aValueRef(_aValueNode.address())
+: m_aValueRef(_aValueNode)
 , m_aNewValue(_aValueNode.getValue())
 , m_bToDefault(false)
 , m_bChange(false)
@@ -251,7 +220,7 @@ ValueMemberNode::DeferredImpl::DeferredI
 
 void ValueMemberNode::DeferredImpl::setValue(UnoAny const& aNewValue, data::ValueNodeAccess const& _aOriginalNode)
 {
-    OSL_ENSURE(_aOriginalNode.address() == m_aValueRef, "Incorrect original node passed");
+    OSL_ENSURE(_aOriginalNode == m_aValueRef, "Incorrect original node passed");
     
     m_aNewValue = aNewValue;
     m_bToDefault = false;
@@ -262,7 +231,7 @@ void ValueMemberNode::DeferredImpl::setV
 
 void ValueMemberNode::DeferredImpl::setValueToDefault(data::ValueNodeAccess const& _aOriginalNode)
 {
-    OSL_ENSURE(_aOriginalNode.address() == m_aValueRef, "Incorrect original node passed");
+    OSL_ENSURE(_aOriginalNode == m_aValueRef, "Incorrect original node passed");
     
     m_aNewValue = _aOriginalNode.getDefaultValue();
     m_bToDefault = true;
@@ -271,11 +240,11 @@ void ValueMemberNode::DeferredImpl::setV
 }
 //-----------------------------------------------------------------------------
 
-std::auto_ptr<ValueChange> ValueMemberNode::DeferredImpl::preCommitChange(data::Accessor const& _aAccessor)
+std::auto_ptr<ValueChange> ValueMemberNode::DeferredImpl::preCommitChange()
 {
     OSL_ENSURE(isChange(), "Trying to commit a non-change");
 
-    data::ValueNodeAccess aOriginalNode = getOriginalNode(_aAccessor);
+    data::ValueNodeAccess aOriginalNode = getOriginalNode();
 
 	// first find the mode of the change
 	ValueChange::Mode eMode; 
@@ -301,12 +270,12 @@ std::auto_ptr<ValueChange> ValueMemberNo
 }
 //-----------------------------------------------------------------------------
 
-void ValueMemberNode::DeferredImpl::finishCommit(ValueChange& rChange, data::Accessor const& _aAccessor)
+void ValueMemberNode::DeferredImpl::finishCommit(ValueChange& rChange)
 {
     { (void)rChange; }
 	OSL_ENSURE(rChange.getNewValue() == this->getNewValue(),"Committed change does not match the intended value");
 
-    data::ValueNodeAccess aOriginalNode = getOriginalNode(_aAccessor);
+    data::ValueNodeAccess aOriginalNode = getOriginalNode();
 
     m_aNewValue = aOriginalNode.getValue();
     m_bToDefault = false;
@@ -316,19 +285,18 @@ void ValueMemberNode::DeferredImpl::fini
 }
 //-----------------------------------------------------------------------------
 
-void ValueMemberNode::DeferredImpl::revertCommit(ValueChange& rChange, data::Accessor const& )
+void ValueMemberNode::DeferredImpl::revertCommit(ValueChange& rChange)
 {
     { (void)rChange; }
-    //data::ValueNodeAccess aOriginalNode = getOriginalNode(_aAccessor):
 
 	OSL_ENSURE(rChange.getNewValue() == this->getNewValue(),"Reverted change does not match the intended value");
 	OSL_ENSURE(isChange(), "ValueMemeberNode::DeferredImpl: No Changes to revert");
 }
 //-----------------------------------------------------------------------------
 
-void ValueMemberNode::DeferredImpl::failedCommit(ValueChange& , data::Accessor const& _aAccessor)
+void ValueMemberNode::DeferredImpl::failedCommit(ValueChange&)
 {
-    data::ValueNodeAccess aOriginalNode = getOriginalNode(_aAccessor);
+    data::ValueNodeAccess aOriginalNode = getOriginalNode();
 
 	// discard the change
     m_aNewValue = aOriginalNode.getValue();
@@ -337,9 +305,9 @@ void ValueMemberNode::DeferredImpl::fail
     m_bChange= false;
 }
 //-----------------------------------------------------------------------------
-ValueChangeImpl* ValueMemberNode::DeferredImpl::collectChange(data::Accessor const& _aAccessor)
+ValueChangeImpl* ValueMemberNode::DeferredImpl::collectChange()
 {
-    data::ValueNodeAccess aOriginalNode = getOriginalNode(_aAccessor);
+    data::ValueNodeAccess aOriginalNode = getOriginalNode();
 
     UnoAny aOldValue = aOriginalNode.getValue();
     if (!m_bChange)
Index: configmgr/source/treemgr/valuemembernode.hxx
===================================================================
RCS file: /cvs/util/configmgr/source/treemgr/valuemembernode.hxx,v
retrieving revision 1.5
retrieving revision 1.5.84.2
diff -u -p -u -p -r1.5 -r1.5.84.2
--- configmgr/source/treemgr/valuemembernode.hxx	8 Sep 2005 04:35:43 -0000	1.5
+++ configmgr/source/treemgr/valuemembernode.hxx	12 Jan 2007 14:50:49 -0000	1.5.84.2
@@ -68,7 +68,7 @@ namespace configmgr
             /// create a ValueMemberNode for a given node
 			explicit ValueMemberNode(data::ValueNodeAccess const& _aNodeAccess);
             /// create a deferred ValueMemberNode (xOriginal must not be empty)
-            ValueMemberNode(data::Accessor const& _aAccessor, DeferredImplRef const& _xDeferred);
+            ValueMemberNode(DeferredImplRef const& _xDeferred);
 		public:
 			ValueMemberNode(ValueMemberNode const& rOriginal);
 			ValueMemberNode& operator=(ValueMemberNode const& rOriginal);
Index: configmgr/source/treemgr/valuenodeimpl.hxx
===================================================================
RCS file: /cvs/util/configmgr/source/treemgr/valuenodeimpl.hxx,v
retrieving revision 1.3
retrieving revision 1.3.84.3
diff -u -p -u -p -r1.3 -r1.3.84.3
--- configmgr/source/treemgr/valuenodeimpl.hxx	8 Sep 2005 04:35:58 -0000	1.3
+++ configmgr/source/treemgr/valuenodeimpl.hxx	12 Jan 2007 14:50:49 -0000	1.3.84.3
@@ -42,10 +42,7 @@
 
 namespace configmgr
 {
-//-----------------------------------------------------------------------------
-
-	class ValueChange;
-//-----------------------------------------------------------------------------
+    class ValueChange;
 
     namespace data 
     { 
@@ -54,17 +51,11 @@ namespace configmgr
     }
 //-----------------------------------------------------------------------------
 
-	namespace configuration
-	{
-//-----------------------------------------------------------------------------
-		typedef com::sun::star::uno::Any UnoAny;
-		typedef com::sun::star::uno::Type UnoType;
-
-		class ValueChangeImpl;
-
-		class Name;
+    namespace configuration
+    {
+	typedef com::sun::star::uno::Any UnoAny;
+	typedef com::sun::star::uno::Type UnoType;
 //-----------------------------------------------------------------------------
-
 // Another types of node
 //-----------------------------------------------------------------------------
 
@@ -72,29 +63,27 @@ namespace configmgr
             <p> This is an immutable value (changes are done by adding/replacing/removing set elements)
             </p>
         */
-		class ValueElementNodeImpl : public NodeImpl
-		{
-		public:
+	class ValueElementNodeImpl : public NodeImpl
+	{
+	public:
             explicit ValueElementNodeImpl(data::ValueNodeAddress const& _aNodeRef) ;
 
-		// the following delegate directly to the original node
-		public:
-			/// Does this node assume its default value
-			/// retrieve the current value of this node
-			UnoAny	getValue(data::Accessor const& _aAccessor) const;
-
-			/// get the type of this value
-			UnoType	getValueType(data::Accessor const& _aAccessor)	const;
-
-            typedef data::ValueNodeAccess DataAccess;
-            DataAccess getDataAccess(data::Accessor const& _aAccessor) const;
-		};
+	// the following delegate directly to the original node
+	public:
+	    /// Does this node assume its default value
+	    /// retrieve the current value of this node
+	    UnoAny	getValue() const;
+
+	    /// get the type of this value
+	    UnoType	getValueType()	const;
+
+	    typedef data::ValueNodeAccess DataAccess;
+            DataAccess getDataAccess() const;
+	};
 
-//-----------------------------------------------------------------------------
-		// domain-specific 'dynamic_cast' replacement
-		ValueElementNodeImpl&	AsValueNode(NodeImpl& rNode);
-//-----------------------------------------------------------------------------
-	}
+	// domain-specific 'dynamic_cast' replacement
+	ValueElementNodeImpl&	AsValueNode(NodeImpl& rNode);
+    }
 }
 
 #endif // CONFIGMGR_VALUENODEBEHAVIOR_HXX_
Index: configmgr/source/treemgr/viewaccess.hxx
===================================================================
RCS file: /cvs/util/configmgr/source/treemgr/viewaccess.hxx,v
retrieving revision 1.4
retrieving revision 1.4.84.3
diff -u -p -u -p -r1.4 -r1.4.84.3
--- configmgr/source/treemgr/viewaccess.hxx	8 Sep 2005 04:36:30 -0000	1.4
+++ configmgr/source/treemgr/viewaccess.hxx	12 Jan 2007 14:50:49 -0000	1.4.84.3
@@ -57,17 +57,14 @@ namespace configmgr
 	{
 //-----------------------------------------------------------------------------
 
-        class ViewTreeAccess 
-		{
+    class ViewTreeAccess 
+	{
             rtl::Reference< ViewStrategy >  m_xStrategy;
             Tree                            m_aTree;
 
-        private:
-            data::Accessor accessor() const { return m_aTree.accessor(); }
-
 		public:
             explicit ViewTreeAccess(Tree const & _aTree);
-            ViewTreeAccess(data::Accessor const & _aAccessor, configuration::TreeImpl& _rTree);
+            explicit ViewTreeAccess(configuration::TreeImpl& _rTree);
 
             rtl::Reference< view::ViewStrategy > getViewBehavior() { return m_xStrategy; }
 		public:
@@ -168,13 +165,13 @@ namespace configmgr
 
         // value (element) node specific operations
         public:
-			/// Does this node assume its default value
-			/// retrieve the current value of this node
-			UnoAny	getValue(ValueNode const& _aNode) const
+	    /// Does this node assume its default value
+	    /// retrieve the current value of this node
+	    UnoAny getValue(ValueNode const& _aNode) const
             { return m_xStrategy->getValue(_aNode); }
 
-			/// get the type of this value
-			UnoType	getValueType(ValueNode const& _aNode)	const
+	    /// get the type of this value
+	    UnoType getValueType(ValueNode const& _aNode)	const
             { return m_xStrategy->getValueType(_aNode); }
 
 
@@ -255,9 +252,9 @@ namespace configmgr
 
 //-----------------------------------------------------------------------------
         inline 
-        ViewTreeAccess::ViewTreeAccess(data::Accessor const & _aAccessor, configuration::TreeImpl& _rTree)
-        : m_xStrategy(_rTree.getViewBehavior())
-        , m_aTree(_aAccessor,_rTree)
+        ViewTreeAccess::ViewTreeAccess(configuration::TreeImpl& _rTree)
+            : m_xStrategy(_rTree.getViewBehavior())
+            , m_aTree(_rTree)
         {
         }
 
Index: configmgr/source/treemgr/viewfactory.hxx
===================================================================
RCS file: /cvs/util/configmgr/source/treemgr/viewfactory.hxx,v
retrieving revision 1.2
retrieving revision 1.2.84.2
diff -u -p -u -p -r1.2 -r1.2.84.2
--- configmgr/source/treemgr/viewfactory.hxx	8 Sep 2005 04:36:44 -0000	1.2
+++ configmgr/source/treemgr/viewfactory.hxx	7 Feb 2007 12:14:55 -0000	1.2.84.2
@@ -39,7 +39,6 @@
 namespace configmgr
 {
 //-----------------------------------------------------------------------------
-    namespace memory { class Segment; }
     namespace data { class TreeSegment; }
 
 	namespace view 
@@ -49,9 +48,9 @@ namespace configmgr
 	    typedef rtl::Reference<ViewStrategy> ViewStrategyRef;
 
 		/// provides a factory for read-only node implementations
-		ViewStrategyRef createReadOnlyStrategy(memory::Segment const * _pSegment);
+		ViewStrategyRef createReadOnlyStrategy();
 		/// provides a factory for nodes that cache changes temporarily
-		ViewStrategyRef createDeferredChangeStrategy(memory::Segment const * _pSegment);
+		ViewStrategyRef createDeferredChangeStrategy();
 		/// provides a factory for immediately commiting node implementations
         ViewStrategyRef createDirectAccessStrategy(data::TreeSegment const & _aTreeSegment);
 	//---------------------------------------------------------------------
Index: configmgr/source/treemgr/viewnode.cxx
===================================================================
RCS file: /cvs/util/configmgr/source/treemgr/viewnode.cxx,v
retrieving revision 1.4
retrieving revision 1.4.24.1
diff -u -p -u -p -r1.4 -r1.4.24.1
--- configmgr/source/treemgr/viewnode.cxx	16 Sep 2006 15:32:54 -0000	1.4
+++ configmgr/source/treemgr/viewnode.cxx	11 Jan 2007 10:35:41 -0000	1.4.24.1
@@ -121,33 +121,27 @@ namespace configmgr
         }
 
 //-----------------------------------------------------------------------------
-/*        data::TreeAccessor Tree::getAccess() const   // has a TreeAccessor
+        data::NodeAccess Node::getAccessRef() const
         { 
-            return get_impl()->getOriginalTreeAccess(m_accessor);                 
-        }
-*/
-//-----------------------------------------------------------------------------
-        data::NodeAccessRef Node::getAccessRef() const
-        { 
-            return get_impl()->getOriginalNodeAccessRef(&accessor());                 
+            return get_impl()->getOriginalNodeAccess();                 
         }
 
 //-----------------------------------------------------------------------------
         data::ValueNodeAccess ValueNode::getAccess() const
         { 
-            return get_impl()->getDataAccess(accessor());                 
+            return get_impl()->getDataAccess();
         }
 
 //-----------------------------------------------------------------------------
         data::GroupNodeAccess GroupNode::getAccess() const
         { 
-            return get_impl()->getDataAccess(accessor());                 
+            return get_impl()->getDataAccess();
         }
 
 //-----------------------------------------------------------------------------
         data::SetNodeAccess SetNode::getAccess() const
         { 
-            return get_impl()->getDataAccess(accessor());                 
+            return get_impl()->getDataAccess();
         }
 
 //-----------------------------------------------------------------------------
Index: configmgr/source/treemgr/viewnode.hxx
===================================================================
RCS file: /cvs/util/configmgr/source/treemgr/viewnode.hxx,v
retrieving revision 1.3
retrieving revision 1.3.84.3
diff -u -p -u -p -r1.3 -r1.3.84.3
--- configmgr/source/treemgr/viewnode.hxx	8 Sep 2005 04:37:13 -0000	1.3
+++ configmgr/source/treemgr/viewnode.hxx	12 Jan 2007 14:50:49 -0000	1.3.84.3
@@ -40,6 +40,9 @@
 #include "treeimpl.hxx"
 #endif
 
+#include "valuenodeaccess.hxx"
+#include "groupnodeaccess.hxx"
+
 namespace configmgr
 {
 //-----------------------------------------------------------------------------
@@ -58,8 +61,8 @@ namespace configmgr
         {
             typedef configuration::TreeImpl TreeData;
         
-            Tree(data::Accessor const& _accessor, TreeData& _ref) 
-            : m_accessor(_ref.getDataAccessor(_accessor)), m_addr(&_ref) 
+            Tree(TreeData& _ref) 
+            : m_addr(&_ref) 
             {}
 
         // low-level access
@@ -68,13 +71,7 @@ namespace configmgr
             TreeData* get_impl() const
             { return m_addr; }
 
-            data::Accessor const& accessor() const   // has a Accessor
-            { return m_accessor; }
-
-        //    data::TreeAccessor getAccess() const;   // has a TreeAccessor
-
         private:
-            data::Accessor m_accessor;   // has a TreeAccessor
             TreeData *  m_addr;  // has a TreeAddress or NodeAddress
         };
     //-------------------------------------------------------------------------
@@ -88,8 +85,8 @@ namespace configmgr
             : m_tree(_tree), m_addr(_addr) 
             {}
 
-            Node(data::Accessor const& _accessor, Tree::TreeData& _ref, NodeOffset _offs) 
-                : m_tree(_accessor,_ref), m_addr( _ref.nodeData(_offs)) 
+            Node(Tree::TreeData& _ref, NodeOffset _offs) 
+                : m_tree(_ref), m_addr( _ref.nodeData(_offs)) 
             {}
 
             bool is() const { return m_addr != 0; }
@@ -97,9 +94,9 @@ namespace configmgr
             Node getParent() const;
             Node getNextSibling() const;
 
-            bool isSetNode()    const { return is() && data().isSetNode(this->accessor()); }
-            bool isGroupNode()  const { return is() && data().isGroupNode(this->accessor()); }
-            bool isValueNode()  const { return is() && data().isValueElementNode(this->accessor()); }
+            bool isSetNode()    const { return is() && data().isSetNode(); }
+            bool isGroupNode()  const { return is() && data().isGroupNode(); }
+            bool isValueNode()  const { return is() && data().isValueElementNode(); }
 
         // low-level access
 //            NodeAddress operator->() const { return &data().nodeImpl(); }
@@ -115,10 +112,7 @@ namespace configmgr
             Tree tree() const   // has a Tree
             { return m_tree; }
 
-            data::Accessor const& accessor() const   // has a Accessor
-            { return m_tree.accessor(); }
-
-            data::NodeAccessRef getAccessRef() const;   // has a NodeAccess
+            data::NodeAccess getAccessRef() const;   // has a NodeAccess
 
         private:
             Tree        m_tree;   // has a Tree + Accessor
@@ -138,10 +132,10 @@ namespace configmgr
             bool is() const { return m_node.isValueNode(); }
 
         // low-level access
- //           NodeType* operator->() const { return &m_node.data().valueElementImpl(accessor()); }
+ //           NodeType* operator->() const { return &m_node.data().valueElementImpl(); }
 
             NodeType* get_impl() const
-            { return is() ? &m_node.data().valueElementImpl(accessor()) : NULL; }
+            { return is() ? &m_node.data().valueElementImpl() : NULL; }
 
             Node node() const   // has a Node
             { return m_node; }
@@ -149,9 +143,6 @@ namespace configmgr
             Tree tree() const   // has a Tree
             { return m_node.tree(); }
 
-            data::Accessor const& accessor() const   // has a TreeAccessor
-            { return m_node.accessor(); }
-
             data::ValueNodeAccess getAccess() const;   // has a NodeAccess
         };
     //-------------------------------------------------------------------------
@@ -171,10 +162,10 @@ namespace configmgr
             Node getFirstChild() const;
             Node getNextChild(Node const& _aAfterNode) const;
 
-//            NodeType* operator->() const { return &m_node.data().groupImpl(accessor()); }
+//            NodeType* operator->() const { return &m_node.data().groupImpl(); }
 
             NodeType* get_impl() const
-            { return is() ? &m_node.data().groupImpl(accessor()) : NULL; }
+            { return is() ? &m_node.data().groupImpl() : NULL; }
 
             Node node() const   // has a Node
             { return m_node; }
@@ -182,9 +173,6 @@ namespace configmgr
             Tree tree() const   // has a Tree
             { return m_node.tree(); }
 
-            data::Accessor const& accessor() const   // has a TreeAccessor
-            { return m_node.accessor(); }
-
             data::GroupNodeAccess getAccess() const;   // has a NodeAccess
         };
     //-------------------------------------------------------------------------
@@ -202,19 +190,16 @@ namespace configmgr
 
             bool is() const { return m_node.isSetNode(); }
 
-   //         NodeType* operator->() const  { return &m_node.data().setImpl(accessor()); }
+   //         NodeType* operator->() const  { return &m_node.data().setImpl(); }
             
             NodeType* get_impl() const
-            { return is() ? &m_node.data().setImpl(accessor()) : 0; }
+            { return is() ? &m_node.data().setImpl() : 0; }
 
             Node node() const   // has a Node
             { return m_node; }
 
             Tree tree() const   // has a Tree
             { return m_node.tree(); }
-
-            data::Accessor const& accessor() const   // has a TreeAccessor
-            { return m_node.accessor(); }
 
             data::SetNodeAccess getAccess() const;   // has a NodeAccess
         };
Index: configmgr/source/treemgr/viewstrategy.cxx
===================================================================
RCS file: /cvs/util/configmgr/source/treemgr/viewstrategy.cxx,v
retrieving revision 1.10
retrieving revision 1.10.24.4
diff -u -p -u -p -r1.10 -r1.10.24.4
--- configmgr/source/treemgr/viewstrategy.cxx	16 Sep 2006 15:33:07 -0000	1.10
+++ configmgr/source/treemgr/viewstrategy.cxx	16 Jan 2007 12:18:28 -0000	1.10.24.4
@@ -60,9 +60,6 @@
 #ifndef CONFIGMGR_SETNODEACCESS_HXX
 #include "setnodeaccess.hxx"
 #endif
-#ifndef CONFIGMGR_UPDATEACCESSOR_HXX
-#include "updateaccessor.hxx"
-#endif
 
 #ifndef CONFIGMGR_CONFIGCHANGE_HXX_
 #include "nodechange.hxx"
@@ -84,15 +81,13 @@ namespace configmgr
         using configuration::ElementList;
         using configuration::GroupMemberVisitor;
         using configuration::SetNodeVisitor;
-//-----------------------------------------------------------------------------
-// virtual void doInitElements( data::SetNodeAccess const& _aNode, TreeDepth nDepth);
 	
         static
         inline
         data::ValueNodeAccess getMemberValueAccess( GroupNode const & _aGroupNode, Name const & _aName )
         {
             configuration::GroupNodeImpl* pGroupData = _aGroupNode.get_impl();
-            return pGroupData->getOriginalValueNode(_aGroupNode.accessor(),_aName);
+            return pGroupData->getOriginalValueNode(_aName);
         }
 
 //-----------------------------------------------------------------------------
@@ -142,78 +137,13 @@ namespace configmgr
 		        {
 			        OSL_ASSERT(pContext->isValidNode(nContext));
 
-                    view::Node aContextNode(aNode.accessor(),*pContext,nContext);
+                    view::Node aContextNode(*pContext,nContext);
 			        pContext->getViewBehavior()->markChanged(aContextNode);
 		        }
 	        }
         }
 
 //-----------------------------------------------------------------------------
-        data::NodeAddress::DataType * ViewStrategy::getDataForUpdate(data::NodeAccessRef const & _aNode)
-        {
-            typedef data::NodeAddress::DataType DataType;
-            DataType * pResult = implAccessForUpdate(_aNode);
-            OSL_ASSERT(!pResult || _aNode.getDataPtr() == pResult);
-            return pResult;
-        }
-
-        data::SetNodeAddress::DataType * ViewStrategy::getDataForUpdate(data::SetNodeAccess const & _aNode)
-        {
-            typedef data::SetNodeAddress::DataType DataType;
-
-            sharable::Node * pNode = implAccessForUpdate(_aNode);
-            DataType * pResult = pNode ? pNode->setData() : 0;
-
-            OSL_ASSERT(!pResult || &_aNode.data() == pResult);
-            return pResult;
-        }
-
-        data::GroupNodeAddress::DataType * ViewStrategy::getDataForUpdate(data::GroupNodeAccess const & _aNode)
-        {
-            typedef data::GroupNodeAddress::DataType DataType;
-
-            sharable::Node * pNode = implAccessForUpdate(_aNode);
-            DataType * pResult = pNode ? pNode->groupData() : 0;
-
-            OSL_ASSERT(!pResult || &_aNode.data() == pResult);
-            return pResult;
-        }
-
-        data::ValueNodeAddress::DataType * ViewStrategy::getDataForUpdate(data::ValueNodeAccess const & _aNode)
-        {
-            typedef data::ValueNodeAddress::DataType DataType;
-
-            sharable::Node * pNode = implAccessForUpdate(_aNode);
-            DataType * pResult = pNode ? pNode->valueData() : 0;
-
-            OSL_ASSERT(!pResult || &_aNode.data() == pResult);
-            return pResult;
-        }
-
-//-----------------------------------------------------------------------------
-        data::NodeAddress::DataType * ViewStrategy::implAccessForUpdate(data::NodeAccessRef const & _aNode)
-        {
-            if (memory::Segment * pUpdatableSegment = doGetDataSegmentForUpdate())
-            {
-                void * p = memory::UpdateAccessor(pUpdatableSegment).validate(_aNode.rawAddress());
-             
-                OSL_ASSERT(const_cast<const void *>(p) == _aNode.getDataPtr());
-
-                return static_cast<data::NodeAddress::DataType*>(p);
-            }
-
-            else
-                return NULL;
-        }
-
-//-----------------------------------------------------------------------------
-        memory::Segment * ViewStrategy::doGetDataSegmentForUpdate()
-        { 
-            return NULL; 
-        }
-
-
-//-----------------------------------------------------------------------------
         std::auto_ptr<SubtreeChange> ViewStrategy::preCommitChanges(Tree const& _aTree, ElementList& _rRemovedElements)
         { 
             checkInstance(_aTree);
@@ -329,21 +259,21 @@ namespace configmgr
 	        {
 		        AddNode const& aAddNode = static_cast<AddNode const&>(rElementChange);
                 
-                SetNodeElement aNewElement = pSetData->makeAdditionalElement(_aSetNode.accessor(),this,aAddNode,nDepth);
+                SetNodeElement aNewElement = pSetData->makeAdditionalElement(this,aAddNode,nDepth);
 
-		        pThisChange = pSetData->doAdjustToAddedElement(_aSetNode.accessor(), aName, aAddNode,aNewElement);
+		        pThisChange = pSetData->doAdjustToAddedElement(aName, aAddNode,aNewElement);
 	        }
 	        else if (rElementChange.ISA(RemoveNode))
 	        {
 		        RemoveNode const& aRemoveNode = static_cast<RemoveNode const&>(rElementChange);
 
-		        pThisChange = pSetData->doAdjustToRemovedElement(_aSetNode.accessor(), aName, aRemoveNode);
+		        pThisChange = pSetData->doAdjustToRemovedElement(aName, aRemoveNode);
 	        }
 	        else
             {
                 if (nDepth > 0 || (NULL != pSetData->doFindElement(aName)) )// found even beyond nDepth ?
 	            {
-		            pThisChange = pSetData->doAdjustChangedElement(_aSetNode.accessor(),rLocalChanges,aName, rElementChange);
+		            pThisChange = pSetData->doAdjustChangedElement(rLocalChanges,aName, rElementChange);
 	            }
             }
 
@@ -374,7 +304,7 @@ namespace configmgr
 		        {
 			        OSL_ENSURE( !hasChanges(_aSetNode.node()),"Cannot have changes to consider when no elements are loaded");
 
-			        pSetData->convertChanges( rLocalChanges, _aSetNode.accessor(), rExternalChanges, nDepth);
+			        pSetData->convertChanges( rLocalChanges, rExternalChanges, nDepth);
 		        }
 	        }
         }
@@ -485,13 +415,13 @@ namespace configmgr
 		UnoAny	ViewStrategy::getValue(ValueNode const& _aNode) const
         { 
             checkInstance(_aNode.tree());
-            return _aNode.get_impl()->getValue(_aNode.accessor()); 
+            return _aNode.get_impl()->getValue(); 
         }
 
-		UnoType	ViewStrategy::getValueType(ValueNode const& _aNode)	const
+        UnoType ViewStrategy::getValueType(ValueNode const& _aNode)	const
         { 
             checkInstance(_aNode.tree());
-            return _aNode.get_impl()->getValueType(_aNode.accessor()); 
+            return _aNode.get_impl()->getValueType(); 
         }
 
 //-----------------------------------------------------------------------------
@@ -525,9 +455,9 @@ namespace configmgr
             }
 
 		    virtual Result handle(data::ValueNodeAccess const& _aValue);
-		    virtual Result handle(data::NodeAccessRef const& _aNonValue);
+		    virtual Result handle(data::NodeAccess const& _aNonValue);
         
-            bool test_value(data::NodeAccessRef const & _aNode) const;
+            bool test_value(data::NodeAccess const & _aNode) const;
 
             ViewStrategy&       m_rStrategy;     
             GroupNode           m_aGroup;
@@ -539,7 +469,7 @@ namespace configmgr
                 using NodeVisitor::handle;
         };
     
-        bool GroupMemberDispatch::test_value(data::NodeAccessRef const& _aNode) const
+        bool GroupMemberDispatch::test_value(data::NodeAccess const& _aNode) const
         {
             Name aName = _aNode.getName();
         
@@ -555,7 +485,7 @@ namespace configmgr
             return mapResult( m_rVisitor.visit( m_rStrategy.getValue(m_aGroup,aValueName) ) );
         }
 
-	    GroupMemberDispatch::Result GroupMemberDispatch::handle(data::NodeAccessRef const& _aNonValue)
+	    GroupMemberDispatch::Result GroupMemberDispatch::handle(data::NodeAccess const& _aNonValue)
             {
                 { (void)_aNonValue; }
             OSL_ENSURE( !test_value(_aNonValue), "ERROR: Group MemberDispatch:Found a ValueMember for a subtree child.");
@@ -583,7 +513,7 @@ namespace configmgr
         {
             checkInstance(_aNode.tree());
             configuration::GroupNodeImpl* pGroupNode=_aNode.get_impl();
-            data::GroupNodeAccess aGroupNodeAccess = pGroupNode->getDataAccess( _aNode.accessor() );
+            data::GroupNodeAccess aGroupNodeAccess = pGroupNode->getDataAccess();
             return aGroupNodeAccess.hasChildren();
         }
         
@@ -592,7 +522,7 @@ namespace configmgr
         { 
             checkInstance(_aNode.tree());
 
-            return  _aNode.get_impl()->areValueDefaultsAvailable( _aNode.accessor() );
+            return  _aNode.get_impl()->areValueDefaultsAvailable();
         }
 
         configuration::ValueMemberNode ViewStrategy::getValue(GroupNode const& _aNode, Name const& _aName) const
@@ -622,7 +552,7 @@ namespace configmgr
         ViewStrategy::SetNodeElement ViewStrategy::implMakeElement(SetNode const& _aNode, SetNodeEntry const& anEntry) const
         {
             configuration::SetNodeImpl * pNodeData = _aNode.get_impl();
-            return pNodeData->implValidateElement(anEntry.accessor(), pNodeData->entryToElement(anEntry));
+            return pNodeData->implValidateElement(pNodeData->entryToElement(anEntry));
         }
 //-----------------------------------------------------------------------------
 		SetEntry ViewStrategy::implFindElement(SetNode const& _aNode, Name const& aName) const
@@ -632,13 +562,13 @@ namespace configmgr
             OSL_ENSURE(pNodeData->implHasLoadedElements(),"Cannot find elements in set that is not loaded");
             configuration::ElementTreeImpl * pElement = pNodeData->doFindElement(aName); 
 
-            return SetEntry(_aNode.accessor(), pElement);
+            return SetEntry(pElement);
         }
 
 		SetEntry ViewStrategy::findElement(SetNode const& _aNode, Name const& aName) const
         { 
             checkInstance(_aNode.tree());
-	        _aNode.get_impl()->implEnsureElementsLoaded(_aNode.accessor());
+	        _aNode.get_impl()->implEnsureElementsLoaded();
 	        return implFindElement(_aNode,aName);
         }
 
@@ -648,7 +578,7 @@ namespace configmgr
 	        if (_aNode.get_impl()->implHasLoadedElements())
 		        return implFindElement(_aNode,aName);
 	        else
-		        return SetEntry(_aNode.accessor(),0);
+		        return SetEntry(0);
         }
 
         static 
@@ -681,10 +611,10 @@ namespace configmgr
                 if (this->hasChanges(_aNode.node()))
                 {
                     OSL_ENSURE(pNodeData->implHasLoadedElements(),"Unexpected: Found set with changes but elements are not loaded");
-                    pNodeData->doDifferenceToDefaultState(_aNode.accessor(),*aResult,_rDefaultTree);
+                    pNodeData->doDifferenceToDefaultState(*aResult,_rDefaultTree);
                 }
                 else                        
-                    pNodeData->implDifferenceToDefaultState(_aNode.accessor(),*aResult,_rDefaultTree);
+                    pNodeData->implDifferenceToDefaultState(*aResult,_rDefaultTree);
             }
             return aResult;
         }
@@ -702,49 +632,7 @@ namespace configmgr
         }
 
 //-----------------------------------------------------------------------------
-/*       //  virtual rtl::Reference<ViewStrategy> doCloneIndirect(); // fails* /
-        rtl::Reference<ViewStrategy> ViewStrategy::makeIndirect(Tree const& _aTree)
-        {
-            _aTree->makeIndirect(true);
-            return this;
-        }
-
-		void ViewStrategy::doCommitChanges(Node const& _aNode)
-        {
-            // nothing to do
-        }
-
-        // TODO: move this to deferred impl
-        void ViewStrategy::implCommitDirectIn(data::TreeAccessor const& _aPlaceHolder, Node const& _aNode)
-        {
-	        if (this->hasChanges(_aNode) )
-	        {
-                this->doCommitChanges(_aNode);
-
-                GroupNode aGroup(_aNode);
-
-                for (Node aChild = aGroup.getFirstChild(); aChild.is(); aChild = aGroup.getNextChild(aChild) )
-		        {
-			        implCommitDirectIn(_aPlaceHolder, aChild);
-		        }
-	        }
-        }
-
-        void ViewStrategy::commitDirectly(data::TreeAccessor const& _aPlaceHolder, Tree const& _aTree)
-        {
-            implCommitDirectIn( _aPlaceHolder, getRootNode(_aTree) );
-        }
-
-        //  virtual rtl::Reference<ViewStrategy> doCloneDirect();   // returns 'this'
-        rtl::Reference<ViewStrategy> ViewStrategy::makeDirect  (Tree const& _aTree)
-        {
-            commitDirectly(_aTree.accessor(), _aTree);
-            _aTree->makeIndirect(false);
-            return this;
-        }
-*/
-//-----------------------------------------------------------------------------
-        data::NodeAccessRef ViewStrategy::getNodeAccessRef(Node const& _aNode) const
+        data::NodeAccess ViewStrategy::getNodeAccess(Node const& _aNode) const
         { 
             checkInstance(_aNode.tree());
             return _aNode.getAccessRef(); 
@@ -759,18 +647,18 @@ namespace configmgr
         node::Attributes ViewStrategy::getNodeAttributes(Node const& _aNode) const
         { 
             checkInstance(_aNode.tree());
-            return _aNode.getAccessRef().getAttributes(); 
+            return _aNode.getAccessRef()->getAttributes(); 
         }
 
 //-----------------------------------------------------------------------------
-		SetNodeVisitor::Result ViewStrategy::dispatchToElements(SetNode const& _aNode, SetNodeVisitor& _aVisitor)
+        SetNodeVisitor::Result ViewStrategy::dispatchToElements(SetNode const& _aNode, SetNodeVisitor& _aVisitor)
         { 
             checkInstance(_aNode.tree());
 
             configuration::SetNodeImpl * pNodeData = _aNode.get_impl();
 
-	        if (pNodeData->implLoadElements(_aNode.accessor()))
-		        return pNodeData->doDispatchToElements(_aNode.accessor(), _aVisitor); 
+	        if (pNodeData->implLoadElements())
+		        return pNodeData->doDispatchToElements(_aVisitor); 
 
 	        else
 		        return SetNodeVisitor::CONTINUE;
@@ -782,7 +670,7 @@ namespace configmgr
 
             configuration::SetNodeImpl * pNodeData = _aNode.get_impl();
 
-	        return !pNodeData->implLoadElements(_aNode.accessor()) || pNodeData->doIsEmpty(); 
+	        return !pNodeData->implLoadElements() || pNodeData->doIsEmpty(); 
         }
 //-----------------------------------------------------------------------------
 
@@ -790,7 +678,7 @@ namespace configmgr
         { 
 	        // cannot insert, if we cannot check for collisions
             checkInstance(_aNode.tree());
-	        _aNode.get_impl()->implEnsureElementsLoaded(_aNode.accessor());
+	        _aNode.get_impl()->implEnsureElementsLoaded();
 	        doInsertElement(_aNode,_aName,_aNewEntry); 
         }
 
@@ -798,7 +686,7 @@ namespace configmgr
         { 
 	        // cannot remove, if we cannot check for existance
             checkInstance(_aNode.tree());
-	        _aNode.get_impl()->implEnsureElementsLoaded(_aNode.accessor());
+	        _aNode.get_impl()->implEnsureElementsLoaded();
 	        doRemoveElement(_aNode,_aName); 
         }
 
Index: configmgr/source/treemgr/viewstrategy.hxx
===================================================================
RCS file: /cvs/util/configmgr/source/treemgr/viewstrategy.hxx,v
retrieving revision 1.6
retrieving revision 1.6.84.5
diff -u -p -u -p -r1.6 -r1.6.84.5
--- configmgr/source/treemgr/viewstrategy.hxx	8 Sep 2005 04:37:43 -0000	1.6
+++ configmgr/source/treemgr/viewstrategy.hxx	7 Feb 2007 12:14:55 -0000	1.6.84.5
@@ -46,10 +46,10 @@
 #ifndef CONFIGMGR_SETNODEBEHAVIOR_HXX_
 #include "setnodeimpl.hxx"
 #endif
-
-#ifndef _SALHELPER_SIMPLEREFERENCEOBJECT_HXX_
-#include <salhelper/simplereferenceobject.hxx>
+#ifndef CONFIGMGR_UTILITY_HXX_
+#include "utility.hxx"
 #endif
+
 #ifndef _RTL_REF_HXX_
 #include <rtl/ref.hxx>
 #endif
@@ -57,8 +57,6 @@
 namespace configmgr
 {
 //-----------------------------------------------------------------------------
-    namespace memory { class Segment; }
-//-----------------------------------------------------------------------------
     namespace configuration
     {
         class SetElementChangeImpl;
@@ -77,7 +75,7 @@ namespace configmgr
         typedef com::sun::star::uno::Any    UnoAny;
         typedef com::sun::star::uno::Type   UnoType;
 //-----------------------------------------------------------------------------
-		class ViewStrategy : public salhelper::SimpleReferenceObject
+		class ViewStrategy : public configmgr::SimpleReferenceObject
 		{
         // node attributes
 		public:
@@ -195,22 +193,10 @@ namespace configmgr
         public:
             NodeFactory& getNodeFactory();
 
-        // direct update access to data
-        public:
-            void releaseDataSegment();
-
-            memory::Segment const * getDataSegment() const;
-            memory::Segment  * getDataSegmentForUpdate();
-
-            data::NodeAddress   ::DataType * getDataForUpdate(data::NodeAccessRef const & _aNode);
-            data::SetNodeAddress::DataType * getDataForUpdate(data::SetNodeAccess const & _aNode);
-            data::GroupNodeAddress::DataType * getDataForUpdate(data::GroupNodeAccess const & _aNode);
-            data::ValueNodeAddress::DataType * getDataForUpdate(data::ValueNodeAccess const & _aNode);
-
         // access to node innards
         protected:
             /// provide access to the data of the underlying node
-            data::NodeAccessRef getNodeAccessRef(Node const& _aNode) const;
+            data::NodeAccess getNodeAccess(Node const& _aNode) const;
 
             /// provide access to the address of the underlying node
             data::NodeAddress getNodeAddress(Node const& _aNode) const;
@@ -247,13 +233,6 @@ namespace configmgr
 
         // virtual interface - these functions all have default implementations without support for pending changes
 		protected:
-            virtual void doReleaseDataSegment() = 0;
-
-            // special support for direct changes to underlying data - default is no support
-            virtual data::NodeAddress::DataType * implAccessForUpdate(data::NodeAccessRef const & _aDataAccess);
-            virtual memory::Segment const * doGetDataSegment() const = 0;
-            virtual memory::Segment       * doGetDataSegmentForUpdate();
-
             // change handling
 			virtual void doCollectChanges(Node const& _aNode, NodeChanges& rChanges) const;
 
@@ -275,12 +254,7 @@ namespace configmgr
             // set element access
             virtual void doInsertElement(SetNode const& _aNode, Name const& aName, SetNodeEntry const& aNewEntry) = 0;
 			virtual void doRemoveElement(SetNode const& _aNode, Name const& aName) = 0;
-
-            // strategy change support
-/*			virtual void doCommitChanges(Node const& _aNode);
-            virtual rtl::Reference<ViewStrategy> doCloneDirect() = 0;   
-            virtual rtl::Reference<ViewStrategy> doCloneIndirect() = 0; 
-*/		};
+		};
 
 //-----------------------------------------------------------------------------
         inline Name ViewStrategy::getName(Node const& _aNode)	const	
@@ -294,15 +268,6 @@ namespace configmgr
 
 	    inline NodeFactory& ViewStrategy::getNodeFactory()	
         { return doGetNodeFactory(); }
-
-        inline void ViewStrategy::releaseDataSegment()
-        { doReleaseDataSegment(); }
-
-        inline memory::Segment const * ViewStrategy::getDataSegment()	const
-        { return doGetDataSegment(); }
-
-        inline memory::Segment       * ViewStrategy::getDataSegmentForUpdate()
-        { return doGetDataSegmentForUpdate(); }
 
 //-----------------------------------------------------------------------------
 	}
Index: configmgr/util/makefile.mk
===================================================================
RCS file: /cvs/util/configmgr/util/makefile.mk,v
retrieving revision 1.21
retrieving revision 1.19.84.2
diff -u -p -u -p -r1.21 -r1.19.84.2
--- configmgr/util/makefile.mk	31 Jan 2007 08:43:09 -0000	1.21
+++ configmgr/util/makefile.mk	7 Feb 2007 11:45:28 -0000	1.19.84.2
@@ -46,7 +46,6 @@ DLLPRE = 
 # --- Library -----------------------------------
 
 SHL1TARGET=	$(CFGMGR_TARGET)$(CFGMGR_MAJOR).uno
-
 SHL1VERSIONMAP= $(TARGET).map
 
 SHL1OBJS=$(SLOFILES)
Index: configmgr/workben/makefile.mk
===================================================================
RCS file: /cvs/util/configmgr/workben/Attic/makefile.mk,v
retrieving revision 1.4
retrieving revision 1.4.58.2
diff -u -p -u -p -r1.4 -r1.4.58.2
--- configmgr/workben/makefile.mk	8 Mar 2006 14:02:03 -0000	1.4
+++ configmgr/workben/makefile.mk	11 Jan 2007 10:35:42 -0000	1.4.58.2
@@ -0,0 +1,99 @@ USE_LDUMP2=TRUE
+#*************************************************************************
+#
+#   OpenOffice.org - a multi-platform office productivity suite
+#
+#   $RCSfile: makefile.mk,v $
+#
+#   $Revision: 1.4 $
+#
+#   last change: $Author: rt $ $Date: 2006/03/08 14:02:03 $
+#
+#   The Contents of this file are made available subject to
+#   the terms of GNU Lesser General Public License Version 2.1.
+#
+#
+#     GNU Lesser General Public License Version 2.1
+#     =============================================
+#     Copyright 2005 by Sun Microsystems, Inc.
+#     901 San Antonio Road, Palo Alto, CA 94303, USA
+#
+#     This library is free software; you can redistribute it and/or
+#     modify it under the terms of the GNU Lesser General Public
+#     License version 2.1, as published by the Free Software Foundation.
+#
+#     This library is distributed in the hope that it will be useful,
+#     but WITHOUT ANY WARRANTY; without even the implied warranty of
+#     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+#     Lesser General Public License for more details.
+#
+#     You should have received a copy of the GNU Lesser General Public
+#     License along with this library; if not, write to the Free Software
+#     Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+#     MA  02111-1307  USA
+#
+#*************************************************************************
+
+PRJ=..
+
+PRJINC=..$/source
+
+PRJNAME=configmgr
+TARGETTYPE=CUI
+TARGET=cm
+LIBTARGET=NO
+ENABLE_EXCEPTIONS=TRUE
+
+USE_LDUMP2=TRUE
+
+# --- Settings ---
+
+.INCLUDE : settings.mk
+
+# --- Files ---
+
+#
+# CFGDEMO
+#
+APP1TARGET=	cfgdemo
+APP1OBJS= $(OBJ)$/testapp.obj 
+
+APP1STDLIBS=\
+	$(SALLIB) \
+	$(VOSLIB) \
+	$(STDLIBCPP) \
+	$(CPPULIB) \
+	$(CPPUHELPERLIB) \
+	$(COMPHELPERLIB) \
+	$(UNOTOOLSLIB) \
+	$(TOOLSLIB) \
+	$(UUILIB) \
+	$(SVTOOLLIB) \
+	$(SVLIB)
+
+.IF "$(GUI)"=="WNT"
+APP1STDLIBS+=$(LIBCIMT)
+.ENDIF
+
+
+# APP1DEF=	$(MISC)\$(APP1TARGET).def
+
+## important for create a Lib
+## SHL1TARGET=	$(TARGET)
+## 
+## SHL1STDLIBS= \
+## 		  $(CPPULIB)		\
+## 		  $(CPPUHELPERLIB)	\
+## 		  $(VOSLIB)		\
+## 		  $(SALLIB)
+## 
+## SHL1DEPN=
+## SHL1IMPLIB=	i$(TARGET)
+## SHL1LIBS=	$(SLB)$/$(TARGET).lib
+## SHL1DEF=	$(MISC)$/$(SHL1TARGET).def
+## 
+## DEF1NAME=	$(SHL1TARGET)
+## DEF1EXPORTFILE=	exports.dxp
+
+# --- Targets ---
+
+.INCLUDE : target.mk
Index: configmgr/workben/testapp.cxx
===================================================================
RCS file: configmgr/workben/testapp.cxx
diff -N configmgr/workben/testapp.cxx
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ configmgr/workben/testapp.cxx	16 Jan 2007 12:57:13 -0000	1.1.2.4
@@ -0,0 +1,274 @@
+#include <stdio.h>
+#include <memory>
+#include <vector>
+
+#include <iostream>
+
+#ifndef _SV_SVAPP_HXX //autogen
+#include <vcl/svapp.hxx>
+#endif
+
+#ifndef _CPPUHELPER_SERVICEFACTORY_HXX_
+#include <cppuhelper/servicefactory.hxx>
+#endif
+#include <cppuhelper/implbase1.hxx>
+#include <cppuhelper/bootstrap.hxx>
+
+#ifndef _COMPHELPER_PROCESSFACTORY_HXX_
+#include <comphelper/processfactory.hxx>
+#endif
+
+#ifndef _COM_SUN_STAR_UNO_REFERENCE_H_
+#include <com/sun/star/uno/Reference.h>
+#endif
+
+#ifndef _COM_SUN_STAR_LANG_XMULTISERVICEFACTORY_HPP_
+#include <com/sun/star/lang/XMultiServiceFactory.hpp>
+#endif
+
+#ifndef _COM_SUN_STAR_BEANS_PROPERTYVALUE_HPP_
+#include <com/sun/star/beans/PropertyValue.hpp>
+#endif
+
+#ifndef _COM_SUN_STAR_BEANS_XPROPERTYSET_HPP_
+#include <com/sun/star/beans/XPropertySet.hpp>
+#endif
+
+#include <com/sun/star/beans/XMultiPropertySet.hpp>
+
+#ifndef _COM_SUN_STAR_CONTAINER_XNAMEACCESS_HPP_
+#include <com/sun/star/container/XNameAccess.hpp>
+#endif
+
+#ifndef _COM_SUN_STAR_CONTAINER_XNAMECONTAINER_HPP_
+#include <com/sun/star/container/XNameContainer.hpp>
+#endif
+
+#ifndef _COM_SUN_STAR_CONTAINER_XCONTAINER_HPP_
+#include <com/sun/star/container/XContainer.hpp>
+#endif
+#include <com/sun/star/container/XContainerListener.hpp>
+
+#ifndef _UTL_CONFIGMGR_HXX_
+#include <unotools/configmgr.hxx>
+#endif
+
+#ifndef _STREAM_HXX //autogen wg. SvStream
+#include <tools/stream.hxx>
+#endif
+
+#include <rtl/ustring.hxx>
+
+#ifndef _UTL_STREAM_WRAPPER_HXX_
+#include <unotools/streamwrap.hxx>
+#endif
+
+#include <tools/urlobj.hxx>
+#include <osl/diagnose.h>
+#include <cppuhelper/implbase1.hxx>
+
+// #include <icmp_oustring.hxx>
+
+#ifndef _COM_SUN_STAR_UNO_ANY_H_
+#include <com/sun/star/uno/Any.h>
+#endif
+#ifndef _COM_SUN_STAR_UNO_SEQUENCE_H_
+#include <com/sun/star/uno/Sequence.h>
+#endif
+
+// using namespace vos;
+using namespace rtl;
+using namespace com::sun::star::uno;
+using namespace com::sun::star::lang;
+using namespace com::sun::star::beans;
+using namespace com::sun::star::container;
+using namespace std;
+
+#define ASCII(x) OUString::createFromAscii(x)
+
+class DumpEvents : public ::cppu::WeakImplHelper1<XContainerListener>
+{
+public:
+		DumpEvents() {}
+		virtual ~DumpEvents() {}
+
+        virtual void SAL_CALL elementInserted( const ContainerEvent& aEvent ) throw(RuntimeException)
+		{
+			fprintf (stderr, "elementInserted\n");
+		}
+        virtual void SAL_CALL elementRemoved ( const ContainerEvent& aEvent ) throw(RuntimeException)
+		{
+			fprintf (stderr, "elementRemoved\n");
+		}
+        virtual void SAL_CALL elementReplaced( const ContainerEvent& aEvent ) throw(RuntimeException)
+		{
+			fprintf (stderr, "elementReplaced\n");
+		}
+        // lang.XEventListener
+        virtual void SAL_CALL disposing( const EventObject& aEvent ) throw(RuntimeException)
+		{
+//			fprintf (stderr, "listener: disposing\n");
+		}
+};
+
+static void
+doTest(	Reference< XMultiServiceFactory > xFac, Reference< XContainerListener > xDumpEvents )
+{
+	bool bSlow = xDumpEvents.is();
+
+	// uicommanddescription code:
+	static const char CONFIGURATION_ROOT_ACCESS[]           = "/org.openoffice.Office.UI.";
+	static const char CONFIGURATION_POP_ELEMENT_ACCESS[]    = "/UserInterface/Commands";
+static const char CONFIGURATION_PROPERTY_LABEL[]        = "Label";
+static const char CONFIGURATION_PROPERTY_CONTEXT_LABEL[] = "ContextLabel";
+static const char PROPSET_LABEL[]                       = "Label";
+static const char PROPSET_NAME[]                        = "Name";
+static const char PROPSET_POPUP[]                       = "Popup";
+static const char PROPSET_PROPERTIES[]                  = "Properties";
+
+	rtl::OUString m_aConfigPopupAccess( RTL_CONSTASCII_USTRINGPARAM( CONFIGURATION_ROOT_ACCESS ) );
+	Reference< XMultiServiceFactory > m_xConfigProviderPopups;
+	Reference< XNameAccess > m_xConfigAccessPopups;
+    rtl::OUString m_aPropUILabel( RTL_CONSTASCII_USTRINGPARAM( CONFIGURATION_PROPERTY_LABEL ));
+	rtl::OUString m_aPropUIContextLabel( RTL_CONSTASCII_USTRINGPARAM( CONFIGURATION_PROPERTY_CONTEXT_LABEL ));
+    rtl::OUString m_aPropLabel( RTL_CONSTASCII_USTRINGPARAM( PROPSET_LABEL ));
+    rtl::OUString m_aPropName( RTL_CONSTASCII_USTRINGPARAM( PROPSET_NAME ));
+    rtl::OUString m_aPropPopup( RTL_CONSTASCII_USTRINGPARAM( PROPSET_POPUP ));
+    rtl::OUString m_aPropProperties( RTL_CONSTASCII_USTRINGPARAM( PROPSET_PROPERTIES ));
+
+	m_aConfigPopupAccess += ASCII("GenericCommands");
+    m_aConfigPopupAccess += rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( CONFIGURATION_POP_ELEMENT_ACCESS ));
+    m_xConfigProviderPopups = Reference< XMultiServiceFactory >( xFac->createInstance(
+																 rtl::OUString( RTL_CONSTASCII_USTRINGPARAM(
+																			"com.sun.star.configuration.ConfigurationProvider" ))),
+																 UNO_QUERY );
+
+
+    PropertyValue aPropValue;
+    Sequence< Any > aArgs( 1 );
+	aPropValue.Name  = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "nodepath" ));
+	aPropValue.Value = makeAny( m_aConfigPopupAccess );
+	aArgs[0] <<= aPropValue;
+	m_xConfigAccessPopups = Reference< XNameAccess >( m_xConfigProviderPopups->createInstanceWithArguments(
+															  rtl::OUString( RTL_CONSTASCII_USTRINGPARAM(
+																	 "com.sun.star.configuration.ConfigurationAccess" )),
+															  aArgs ),
+													  UNO_QUERY );
+#if 0
+    if ( m_xConfigAccessPopups.is() && xDumpEvents.is() )
+	{
+       // Add as container listener
+       Reference< XContainer > xContainer( m_xConfigAccessPopups, UNO_QUERY );
+       if ( xContainer.is() )
+           xContainer->addContainerListener( xDumpEvents );
+	   else 
+		   fprintf (stderr, "no listening\n");
+	}
+#endif
+
+    sal_Int32               i( 0 );
+    Any                     a;
+    std::vector< OUString > aImageCommandVector;
+    std::vector< OUString > aImageRotateVector;
+    std::vector< OUString > aImageMirrorVector;
+    Sequence< OUString >    aNameSeq;
+
+    if ( m_xConfigAccessPopups.is() )
+    {
+        aNameSeq = m_xConfigAccessPopups->getElementNames();
+        fprintf (stderr, "Element names: %d\n", (int)aNameSeq.getLength());
+        for ( i = 0; i < aNameSeq.getLength(); i++ )
+        {
+            try
+            {
+				if (1) // bSlow) 
+				{
+					Reference< XNameAccess > xNameAccess;
+					// This is the slow bit ! ...
+					// Creating the @#$@#$ing XNameAccess object [ 650 times ]
+					// which we then use to 'getByName' etc.
+					a = m_xConfigAccessPopups->getByName( aNameSeq[i] );
+					if ( a >>= xNameAccess )
+					{
+						a = xNameAccess->getByName( m_aPropUILabel );
+						a = xNameAccess->getByName( m_aPropUIContextLabel );
+						a = xNameAccess->getByName( m_aPropProperties );
+					}
+				}
+				else
+				{
+						// getAsProperty !?
+					Reference< XMultiPropertySet > xMPS;
+					Sequence< OUString > aPropNames(3);
+					aPropNames[0] = m_aPropUILabel;
+					aPropNames[1] = m_aPropUIContextLabel;
+					aPropNames[2] = m_aPropProperties;
+					a = m_xConfigAccessPopups->getByName( aNameSeq[i] );
+					if ( a >>= xMPS )
+					{
+						Sequence<Any> aVals;
+						aVals = xMPS->getPropertyValues (aPropNames);
+					}
+					else
+						fprintf (stderr, "not an MPS\n");
+				}
+			}
+            catch ( com::sun::star::lang::WrappedTargetException& )
+            {
+            }
+            catch ( com::sun::star::container::NoSuchElementException& )
+            {
+            }
+        }
+    }
+}
+
+static void
+doTestRun( Reference< XMultiServiceFactory > xMSF, Reference< XContainerListener > xDumpEvents, int niter )
+{
+   TimeValue start, end;
+
+   // prime before time ...
+   if (niter > 5)
+       doTest (xMSF, xDumpEvents);
+
+   osl_getSystemTime( &start );
+
+   for (int i = 0; i < niter; i++)
+	   doTest (xMSF, xDumpEvents);
+   
+   osl_getSystemTime( &end );
+
+   static sal_Int64 usecs = 0;
+   const int oneMillion = 1000000000;
+   usecs += oneMillion * (end.Seconds - start.Seconds);
+   usecs += end.Nanosec - start.Nanosec;
+   usecs /= niter;
+   fprintf (stderr, "(per iteration) %d.%0.6d\n", (int) (usecs / oneMillion),
+            (int)(usecs % oneMillion));
+}
+
+int main( int argc, char **argv )
+{
+	Reference<XComponentContext> xComponentContext = ::cppu::defaultBootstrap_InitialComponentContext();
+	Reference<XMultiServiceFactory> xMSF(xComponentContext->getServiceManager(), UNO_QUERY);
+	if( !xMSF.is() )
+		fprintf( stderr, "Failed to bootstrap\n" );
+	::comphelper::setProcessServiceFactory( xMSF );
+
+	Reference< XMultiServiceFactory > xStayLoaded;
+	xStayLoaded = Reference< XMultiServiceFactory >(
+			xMSF->createInstance( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM(
+				 "com.sun.star.configuration.ConfigurationProvider" ))),
+			UNO_QUERY );
+
+	Reference< XContainerListener > xDumpEvents;
+
+	doTestRun (xMSF, xDumpEvents, 1);
+
+//	xDumpEvents = new DumpEvents();
+
+//	doTestRun (xMSF, xDumpEvents, 10);
+
+	return 0;
+}
