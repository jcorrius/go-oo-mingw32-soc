diff -u -r  basegfx/inc/basegfx/polygon/b2dpolygontools.hxx  basegfx/inc/basegfx/polygon/b2dpolygontools.hxx
---  basegfx/inc/basegfx/polygon/b2dpolygontools.hxx	2005-01-13 23:29:51.000000000 +0530
+++  basegfx/inc/basegfx/polygon/b2dpolygontools.hxx	2005-02-28 13:46:02.405083583 +0530
@@ -271,6 +271,18 @@
          */
         B2DPolygon createPolygonFromEllipse( const B2DPoint& rCenter, double nRadiusX, double nRadiusY );
 
+        /** Predicate whether a given polygon is a rectangle.
+
+        	@param rPoly
+            Polygon to check
+
+            @return true, if the polygon describes a rectangle
+            (contains exactly four points, is closed, and the points
+            are either cw or ccw enumerations of a rectangle's
+            vertices).
+         */
+        bool isRectangle( const B2DPolygon& rPoly );
+
 	} // end of namespace tools
 } // end of namespace basegfx
 
diff -u -r  basegfx/inc/basegfx/tools/canvastools.hxx  basegfx/inc/basegfx/tools/canvastools.hxx
---  basegfx/inc/basegfx/tools/canvastools.hxx	2004-11-27 00:06:22.000000000 +0530
+++  basegfx/inc/basegfx/tools/canvastools.hxx	2005-02-28 13:46:02.390085440 +0530
@@ -70,7 +70,7 @@
 #endif
 
 
-namespace drafts { namespace com { namespace sun { namespace star { namespace geometry 
+namespace com { namespace sun { namespace star { namespace geometry
 {
     struct AffineMatrix2D;
     struct RealPoint2D;
@@ -80,15 +80,15 @@
     struct IntegerSize2D;
     struct IntegerRectangle2D;
     struct RealBezierSegment2D;
-} } } } }
+} } } }
 
-namespace drafts { namespace com { namespace sun { namespace star { namespace rendering 
+namespace com { namespace sun { namespace star { namespace rendering
 {
     class  XGraphicDevice;
     class  XPolyPolygon2D;
-} } } } }
+} } } }
 
-namespace com { namespace sun { namespace star { namespace awt 
+namespace com { namespace sun { namespace star { namespace awt
 {
     struct Point;
     struct Size;
@@ -112,65 +112,65 @@
         // Polygon conversions
         // ===================================================================
 
-        ::com::sun::star::uno::Reference< ::drafts::com::sun::star::rendering::XPolyPolygon2D > 
-    		xPolyPolygonFromB2DPolygon( const ::com::sun::star::uno::Reference< 
-                                        	::drafts::com::sun::star::rendering::XGraphicDevice >& 	xGraphicDevice,
+        ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XPolyPolygon2D >
+    		xPolyPolygonFromB2DPolygon( const ::com::sun::star::uno::Reference<
+                                        	::com::sun::star::rendering::XGraphicDevice >& 	xGraphicDevice,
                                         const ::basegfx::B2DPolygon&								rPoly	 );
 
-        ::com::sun::star::uno::Reference< ::drafts::com::sun::star::rendering::XPolyPolygon2D > 
-    		xPolyPolygonFromB2DPolyPolygon( const ::com::sun::star::uno::Reference< 
-                                         		::drafts::com::sun::star::rendering::XGraphicDevice >& 	xGraphicDevice,
+        ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XPolyPolygon2D >
+    		xPolyPolygonFromB2DPolyPolygon( const ::com::sun::star::uno::Reference<
+                                         		::com::sun::star::rendering::XGraphicDevice >& 	xGraphicDevice,
                                             const ::basegfx::B2DPolyPolygon&							rPolyPoly	 );
 
 
-        ::basegfx::B2DPolygon polygonFromPoint2DSequence( 
-            const ::com::sun::star::uno::Sequence< 
-            	::drafts::com::sun::star::geometry::RealPoint2D >& rPoints );
-
-        ::basegfx::B2DPolyPolygon polyPolygonFromPoint2DSequenceSequence( 
-            const ::com::sun::star::uno::Sequence< 
-            	::com::sun::star::uno::Sequence< ::drafts::com::sun::star::geometry::RealPoint2D > >& rPoints );
-
-        ::basegfx::B2DPolygon polygonFromBezier2DSequence( 
-            const ::com::sun::star::uno::Sequence< 
-            	::drafts::com::sun::star::geometry::RealBezierSegment2D >& rPoints );
-
-        ::basegfx::B2DPolyPolygon polyPolygonFromBezier2DSequenceSequence( 
-            const ::com::sun::star::uno::Sequence< 
-            	::com::sun::star::uno::Sequence< ::drafts::com::sun::star::geometry::RealBezierSegment2D > >& rPoints );
+        ::basegfx::B2DPolygon polygonFromPoint2DSequence(
+            const ::com::sun::star::uno::Sequence<
+            	::com::sun::star::geometry::RealPoint2D >& rPoints );
+
+        ::basegfx::B2DPolyPolygon polyPolygonFromPoint2DSequenceSequence(
+            const ::com::sun::star::uno::Sequence<
+            	::com::sun::star::uno::Sequence< ::com::sun::star::geometry::RealPoint2D > >& rPoints );
+
+        ::basegfx::B2DPolygon polygonFromBezier2DSequence(
+            const ::com::sun::star::uno::Sequence<
+            	::com::sun::star::geometry::RealBezierSegment2D >& rPoints );
+
+        ::basegfx::B2DPolyPolygon polyPolygonFromBezier2DSequenceSequence(
+            const ::com::sun::star::uno::Sequence<
+            	::com::sun::star::uno::Sequence< ::com::sun::star::geometry::RealBezierSegment2D > >& rPoints );
 
 
         // Matrix conversions
         // ===================================================================
 
-        ::drafts::com::sun::star::geometry::AffineMatrix2D& 
-        	affineMatrixFromHomMatrix( ::drafts::com::sun::star::geometry::AffineMatrix2D&			matrix,
+        ::com::sun::star::geometry::AffineMatrix2D&
+        	affineMatrixFromHomMatrix( ::com::sun::star::geometry::AffineMatrix2D&			matrix,
                                        const ::basegfx::B2DHomMatrix&								transform);
 
-        ::basegfx::B2DHomMatrix& 
+        ::basegfx::B2DHomMatrix&
         	homMatrixFromAffineMatrix( ::basegfx::B2DHomMatrix&										transform,
-                                       const ::drafts::com::sun::star::geometry::AffineMatrix2D&	matrix );
+                                       const ::com::sun::star::geometry::AffineMatrix2D&	matrix );
 
 
         // Geometry conversions
         // ===================================================================
 
-        ::drafts::com::sun::star::geometry::RealSize2D  		size2DFromB2DSize( const ::basegfx::B2DVector& );
-        ::drafts::com::sun::star::geometry::RealPoint2D 		point2DFromB2DPoint( const ::basegfx::B2DPoint& );
-        ::drafts::com::sun::star::geometry::RealRectangle2D 	rectangle2DFromB2DRectangle( const ::basegfx::B2DRange& );
-
-        ::basegfx::B2DVector  	b2DSizeFromRealSize2D( const ::drafts::com::sun::star::geometry::RealSize2D& );
-        ::basegfx::B2DPoint		b2DPointFromRealPoint2D( const ::drafts::com::sun::star::geometry::RealPoint2D& );
-        ::basegfx::B2DRange		b2DRectangleFromRealRectangle2D( const ::drafts::com::sun::star::geometry::RealRectangle2D& );
-
-        ::drafts::com::sun::star::geometry::IntegerSize2D  		integerSize2DFromB2ISize( const ::basegfx::B2IVector& );
-        ::drafts::com::sun::star::geometry::IntegerPoint2D  	integerPoint2DFromB2IPoint( const ::basegfx::B2IPoint& );
-        ::drafts::com::sun::star::geometry::IntegerRectangle2D	integerRectangle2DFromB2IRectangle( const ::basegfx::B2IRange& );
-
-        ::basegfx::B2IVector  	b2ISizeFromIntegerSize2D( const ::drafts::com::sun::star::geometry::IntegerSize2D& );
-        ::basegfx::B2IPoint		b2IPointFromIntegerPoint2D( const ::drafts::com::sun::star::geometry::IntegerPoint2D& );
-        ::basegfx::B2IRange		b2IRectangleFromIntegerRectangle2D( const ::drafts::com::sun::star::geometry::IntegerRectangle2D& );
-        
+        ::com::sun::star::geometry::RealSize2D  		size2DFromB2DSize( const ::basegfx::B2DVector& );
+        ::com::sun::star::geometry::RealPoint2D 		point2DFromB2DPoint( const ::basegfx::B2DPoint& );
+        ::com::sun::star::geometry::RealRectangle2D 	rectangle2DFromB2DRectangle( const ::basegfx::B2DRange& );
+
+        ::basegfx::B2DVector  	b2DSizeFromRealSize2D( const ::com::sun::star::geometry::RealSize2D& );
+        ::basegfx::B2DPoint		b2DPointFromRealPoint2D( const ::com::sun::star::geometry::RealPoint2D& );
+        ::basegfx::B2DRange		b2DRectangleFromRealRectangle2D( const ::com::sun::star::geometry::RealRectangle2D& );
+
+        ::com::sun::star::geometry::IntegerSize2D  		integerSize2DFromB2ISize( const ::basegfx::B2IVector& );
+        ::com::sun::star::geometry::IntegerPoint2D  	integerPoint2DFromB2IPoint( const ::basegfx::B2IPoint& );
+        ::com::sun::star::geometry::IntegerRectangle2D	integerRectangle2DFromB2IRectangle( const ::basegfx::B2IRange& );
+
+        ::basegfx::B2IVector  	b2ISizeFromIntegerSize2D( const ::com::sun::star::geometry::IntegerSize2D& );
+        ::basegfx::B2IPoint		b2IPointFromIntegerPoint2D( const ::com::sun::star::geometry::IntegerPoint2D& );
+        ::basegfx::B2IRange		b2IRectangleFromIntegerRectangle2D( const ::com::sun::star::geometry::IntegerRectangle2D& );
+
         ::com::sun::star::awt::Size  		awtSizeFromB2ISize( const ::basegfx::B2IVector& );
         ::com::sun::star::awt::Point  		awtPointFromB2IPoint( const ::basegfx::B2IPoint& );
         ::com::sun::star::awt::Rectangle	awtRectangleFromB2IRectangle( const ::basegfx::B2IRange& );
diff -u -r  basegfx/inc/basegfx/vector/b2dvector.hxx  basegfx/inc/basegfx/vector/b2dvector.hxx
---  basegfx/inc/basegfx/vector/b2dvector.hxx	2004-11-03 14:06:55.000000000 +0530
+++  basegfx/inc/basegfx/vector/b2dvector.hxx	2005-02-28 13:46:02.399084326 +0530
@@ -66,39 +66,19 @@
 #include <basegfx/tuple/b2dtuple.hxx>
 #endif
 
+#ifndef _BGFX_VECTOR_B2IVECTOR_HXX
+#include <basegfx/vector/b2ivector.hxx>
+#endif
+
+#ifndef _BGFX_VECTOR_B2ENUMS_HXX
+#include <basegfx/vector/b2enums.hxx>
+#endif
+
 namespace basegfx
 {
 	// predeclaration
 	class B2DHomMatrix;
 
-	/**	Descriptor for the mathematical orientations of two 2D Vectors
-	*/
-	enum B2VectorOrientation
-	{
-		/// mathematically positive oriented
-		ORIENTATION_POSITIVE = 0,
-	    
-		/// mathematically negative oriented
-		ORIENTATION_NEGATIVE,
-	    
-		/// mathematically neutral, thus parallel
-		ORIENTATION_NEUTRAL
-	};
-
-	/**	Descriptor for the mathematical continuity of two 2D Vectors
-	*/
-	enum B2VectorContinuity
-	{
-		/// none
-		CONTINUITY_NONE = 0,
-	    
-		/// mathematically negative oriented
-		CONTINUITY_C1,
-	    
-		/// mathematically neutral, thus parallel
-		CONTINUITY_C2
-	};
-
 	/** Base Point class with two double values
 
 		This class derives all operators and common handling for
@@ -141,6 +121,15 @@
 		:	B2DTuple(rVec)
 		{}
 
+		/**	Create a copy of a 2D Vector
+
+			@param rVec
+			The 2D Vector which will be copied.
+		*/
+		B2DVector(const ::basegfx::B2IVector& rVec) 
+		:	B2DTuple(rVec)
+		{}
+
 		/** constructor with tuple to allow copy-constructing
 			from B2DTuple-based classes
 		*/

diff -u -r  basegfx/inc/basegfx/vector/b2ivector.hxx  basegfx/inc/basegfx/vector/b2ivector.hxx
---  basegfx/inc/basegfx/vector/b2ivector.hxx	2004-02-16 22:33:09.000000000 +0530
+++  basegfx/inc/basegfx/vector/b2ivector.hxx	2005-02-28 13:46:02.398084450 +0530
@@ -65,9 +65,8 @@
 #ifndef _BGFX_TUPLE_B2ITUPLE_HXX
 #include <basegfx/tuple/b2ituple.hxx>
 #endif
-
-#ifndef _BGFX_VECTOR_B2DVECTOR_HXX
-#include <basegfx/vector/b2dvector.hxx>
+#ifndef _BGFX_VECTOR_B2ENUMS_HXX
+#include <basegfx/vector/b2enums.hxx>
 #endif
 
 namespace basegfx
diff -u -r  basegfx/prj/d.lst  basegfx/prj/d.lst
---  basegfx/prj/d.lst	2005-01-13 23:30:15.000000000 +0530
+++  basegfx/prj/d.lst	2005-02-28 13:46:02.409083088 +0530
@@ -38,6 +38,7 @@
 
 mkdir: %_DEST%\inc%_EXT%\basegfx\vector
 ..\inc\basegfx\vector\b2dvector.hxx %_DEST%\inc%_EXT%\basegfx\vector\b2dvector.hxx
+..\inc\basegfx\vector\b2enums.hxx %_DEST%\inc%_EXT%\basegfx\vector\b2enums.hxx
 ..\inc\basegfx\vector\b2dsize.hxx %_DEST%\inc%_EXT%\basegfx\vector\b2dsize.hxx
 ..\inc\basegfx\vector\b3dvector.hxx %_DEST%\inc%_EXT%\basegfx\vector\b3dvector.hxx
 ..\inc\basegfx\vector\b3dsize.hxx %_DEST%\inc%_EXT%\basegfx\vector\b3dsize.hxx
diff -u -r  basegfx/source/polygon/b2dpolygontools.cxx  basegfx/source/polygon/b2dpolygontools.cxx
---  basegfx/source/polygon/b2dpolygontools.cxx	2005-01-13 23:30:30.000000000 +0530
+++  basegfx/source/polygon/b2dpolygontools.cxx	2005-02-28 13:46:02.461076653 +0530
@@ -1468,6 +1468,59 @@
             return aRet;
         }
 
+        bool isRectangle( const B2DPolygon& rPoly )
+        {
+            if( rPoly.count() != 4 ||
+                !rPoly.isClosed() )
+            {
+                return false;
+            }
+
+            const ::basegfx::B2DPoint& rPoint0( rPoly.getB2DPoint(0) );
+            const ::basegfx::B2DPoint& rPoint1( rPoly.getB2DPoint(1) );
+
+            bool bEdgeVertical( rPoint0.getX() == rPoint1.getX() );
+            bool bEdgeHorizontal( rPoint0.getY() == rPoint1.getY() );
+
+            if( !bEdgeVertical && !bEdgeHorizontal )
+                return false; // oblique vertex - for sure no rect 
+
+            bool bNullVertex( bEdgeVertical && bEdgeHorizontal );
+
+            for( sal_Int32 i=1; i<5; ++i )
+            {
+                const ::basegfx::B2DPoint& rPoint0( rPoly.getB2DPoint( i%4) );
+                const ::basegfx::B2DPoint& rPoint1( rPoly.getB2DPoint( (i+1)%4 ) );
+
+                const bool bCurrEdgeVertical( rPoint0.getX() == rPoint1.getX() );
+                const bool bCurrEdgeHorizontal( rPoint0.getY() == rPoint1.getY() );
+                
+                if( !bCurrEdgeVertical && !bCurrEdgeHorizontal )
+                    return false; // oblique vertex - for sure no rect
+
+                const bool bCurrNullVertex( bCurrEdgeVertical && bCurrEdgeHorizontal );
+
+                // direction change from last vertex?
+                if( !bNullVertex && !bCurrNullVertex &&
+                    (bEdgeVertical==bCurrEdgeVertical ||
+                     bEdgeHorizontal==bCurrEdgeHorizontal) )
+                {
+                    // nope, for sure no rect
+                    return false;
+                }
+
+                // might still be a rect - note that this code will
+                // accept all configurations of collinear points as
+                // rectangles, because they are representable as an
+                // axis-aligned rect.
+                bEdgeVertical	= bCurrEdgeVertical;
+                bEdgeHorizontal = bCurrEdgeHorizontal;
+                bNullVertex		= bCurrNullVertex;
+            }
+
+            return true;
+        }
+
 	} // end of namespace tools
 } // end of namespace basegfx
 
diff -u -r  basegfx/source/polygon/b2dpolypolygonrasterconverter.cxx  basegfx/source/polygon/b2dpolypolygonrasterconverter.cxx
---  basegfx/source/polygon/b2dpolypolygonrasterconverter.cxx	2004-11-27 00:09:11.000000000 +0530
+++  basegfx/source/polygon/b2dpolypolygonrasterconverter.cxx	2005-02-28 13:46:02.463076405 +0530
@@ -72,9 +72,249 @@
 
 #include <algorithm>
 
-
 namespace basegfx
 {
+	class radixSort {
+
+		//! public interface
+		public:
+
+			//! default constructor
+			radixSort( void );
+
+			//! destructor
+			~radixSort( void );
+
+			bool sort( const float *pInput, sal_uInt32 nNumElements, sal_uInt32 dwStride );
+
+			inline sal_uInt32 *indices( void ) const { return m_indices1; }
+
+		//! private attributes
+		private:
+
+			// current size of index list
+			sal_uInt32 m_current_size;
+							
+			// last known size of index list
+			sal_uInt32 m_previous_size;
+
+			// index lists
+			sal_uInt32 *m_indices1;
+			sal_uInt32 *m_indices2;
+
+			sal_uInt32 m_counter[256*4];
+			sal_uInt32 m_offset[256];
+
+		//! private methods
+		private:
+
+			bool resize( sal_uInt32 nNumElements );
+			void reset_indices( void );
+			bool prepareCounters( const float *pInput, sal_uInt32 nNumElements, sal_uInt32 dwStride );
+	};
+
+	inline radixSort::radixSort( void ) {
+		
+		m_indices1 = NULL;
+		m_indices2 = NULL;
+		m_current_size = 0;
+		m_previous_size = 0;
+
+		reset_indices();
+	}
+
+	inline radixSort::~radixSort( void ) {
+
+		delete [] m_indices2;
+		delete [] m_indices1;
+	}
+
+	bool radixSort::resize( sal_uInt32 nNumElements ) {
+		
+		if(nNumElements==m_previous_size)
+			return true;
+
+		if(nNumElements > m_current_size) {
+
+			// release index lists
+			if(m_indices2)
+				delete [] m_indices2;
+			if(m_indices1)
+				delete [] m_indices1;
+
+			// allocate new index lists
+			m_indices1 = new sal_uInt32[nNumElements];
+			m_indices2 = new sal_uInt32[nNumElements];
+
+			// check for out of memory situation
+			if(!((sal_uInt32)m_indices1|(sal_uInt32)m_indices2)) {
+				delete [] m_indices1;
+				delete [] m_indices2;
+				m_indices1 = NULL;
+				m_indices2 = NULL;
+				m_current_size = 0;
+				return false;
+			}
+
+			m_current_size = nNumElements;
+		}
+		
+		m_previous_size = nNumElements;
+
+		// initialize indices
+		reset_indices();
+
+		return true;
+	}
+
+	inline void radixSort::reset_indices( void ) {
+
+		for(sal_uInt32 i=0;i<m_current_size;i++)
+			m_indices1[i] = i;
+	}
+
+	bool radixSort::prepareCounters( const float *pInput, sal_uInt32 nNumElements, sal_uInt32 dwStride ) {
+
+		// clear counters
+		sal_uInt32 *ptr = m_counter;
+		for(int i=0; i<64; ++i) {
+			*ptr++ = NULL;
+			*ptr++ = NULL;
+			*ptr++ = NULL;
+			*ptr++ = NULL;
+			*ptr++ = NULL;
+			*ptr++ = NULL;
+			*ptr++ = NULL;
+			*ptr++ = NULL;
+			*ptr++ = NULL;
+			*ptr++ = NULL;
+			*ptr++ = NULL;
+			*ptr++ = NULL;
+			*ptr++ = NULL;
+			*ptr++ = NULL;
+			*ptr++ = NULL;
+			*ptr++ = NULL;
+		}
+
+		// prepare pointers to relevant memory addresses
+		sal_uInt8 *p = (sal_uInt8*)pInput;
+		sal_uInt8 *pe = p+(nNumElements*dwStride);
+		sal_uInt32 *h0= &m_counter[0];
+		sal_uInt32 *h1= &m_counter[256];
+		sal_uInt32 *h2= &m_counter[512];
+		sal_uInt32 *h3= &m_counter[768];
+
+		sal_uInt32 *Indices = m_indices1;
+		float previous_value = *(float *)(((sal_uInt8 *)pInput)+(m_indices1[0]*dwStride));
+		bool bSorted = true;
+		while(p!=pe) {
+			float value = *(float *)(((sal_uInt8 *)pInput)+((*Indices++)*dwStride));
+			if(value<previous_value)	{
+				bSorted = false;
+				break;
+			}
+			previous_value = value;
+			h0[*p++]++;
+			h1[*p++]++;
+			h2[*p++]++;
+			h3[*p++]++;
+			p += dwStride-4;
+		}
+		if(bSorted)
+			return true;
+		while(p!=pe) {
+			h0[*p++]++;
+			h1[*p++]++;
+			h2[*p++]++;
+			h3[*p++]++;
+			p += dwStride-4;
+		}
+		return false;
+	}
+
+	bool radixSort::sort( const float *pInput, sal_uInt32 nNumElements, sal_uInt32 dwStride ) {
+
+		if(!(pInput))
+			return false;
+		if(!(nNumElements))
+			return false;
+		if(!(resize(nNumElements)))
+			return false;
+
+		// prepare radix counters, return if already sorted
+		if(prepareCounters(pInput,nNumElements,dwStride))
+			return true;
+
+		// count number of negative values
+		sal_uInt32 num_negatives = 0;
+		sal_uInt32 *h3= &m_counter[768];
+		for(sal_uInt32 i=128;i<256;i++)
+			num_negatives += h3[i];
+
+		// perform passes, one for each byte
+		for(sal_uInt32 j=0;j<4;j++) {
+
+			// ignore this pass if all values have the same byte
+			bool bRun = true;
+			sal_uInt32 *current_counter = &m_counter[j<<8];
+			sal_uInt8 unique_value = *(((sal_uInt8*)pInput)+j);
+			if(current_counter[unique_value]==nNumElements)
+				bRun=false;
+
+			// does the incoming byte contain the sign bit?
+			sal_uInt32 i;
+			if(j!=3) {
+				if(bRun) {
+					m_offset[0] = 0;
+					for(i=1;i<256;i++)
+						m_offset[i] = m_offset[i-1] + current_counter[i-1];
+					sal_uInt8 *InputBytes = (sal_uInt8 *)pInput;
+					sal_uInt32 *Indices = m_indices1;
+					sal_uInt32 *IndicesEnd = &m_indices1[nNumElements];
+					InputBytes += j;
+					while(Indices!=IndicesEnd) {
+						sal_uInt32 id = *Indices++;
+						m_indices2[m_offset[InputBytes[id*dwStride]]++] = id;
+					}
+					sal_uInt32 *Tmp	= m_indices1;
+					m_indices1 = m_indices2;
+					m_indices2 = Tmp;
+				}
+			}
+			else {
+				if(bRun) {
+					m_offset[0] = num_negatives;
+					for(i=1;i<128;i++)
+						m_offset[i] = m_offset[i-1] + current_counter[i-1];
+					m_offset[255] = 0;
+					for(i=0;i<127;i++)
+						m_offset[254-i] = m_offset[255-i] + current_counter[255-i];
+					for(i=128;i<256;i++)
+						m_offset[i] += current_counter[i];
+					for(i=0;i<nNumElements;i++) {
+						sal_uInt32 Radix = (*(sal_uInt32 *)(((sal_uInt8 *)pInput)+(m_indices1[i]*dwStride)))>>24;
+						if(Radix<128) m_indices2[m_offset[Radix]++] = m_indices1[i];
+						else m_indices2[--m_offset[Radix]] = m_indices1[i];
+					}
+					sal_uInt32 *Tmp	= m_indices1;
+					m_indices1 = m_indices2;
+					m_indices2 = Tmp;
+				}
+				else {
+					if(unique_value>=128) {
+						for(i=0;i<nNumElements;i++)
+							m_indices2[i] = m_indices1[nNumElements-i-1];
+						sal_uInt32 *Tmp	= m_indices1;
+						m_indices1 = m_indices2;
+						m_indices2 = Tmp;
+					}
+				}
+			}
+		}
+
+		return true;
+	}
+
 	//************************************************************
 	// Internal vertex storage of B2DPolyPolygonRasterConverter
 	//************************************************************
@@ -103,9 +343,10 @@
     {
         class ImplLineNode
         {
+		public:
             sal_Int32	mnYCounter;
-            double		mfXPos;
-            double		mfXDelta;
+            float		mfXPos;
+            float		mfXDelta;
             bool		mbDownwards;
         
         public:
@@ -114,27 +355,30 @@
             */
             ImplLineNode(const B2DPoint& rP1, const B2DPoint& rP2, bool bDown) :
                 mnYCounter( fround(rP2.getY()) - fround(rP1.getY()) ),
-                mfXPos( rP1.getX() ),
-                mfXDelta( (rP2.getX() - rP1.getX()) / mnYCounter ),
+                mfXPos( (float)(rP1.getX()) ),
+                mfXDelta((float) ((rP2.getX() - rP1.getX()) / mnYCounter) ),
                 mbDownwards( bDown )
             {
             }
 
             /// get current x position
-            const double& getXPos() const 
+            const float& getXPos() const 
             { 
                 return mfXPos; 
             }
         
             /// returns true, if line ends on this Y value
-            void nextLine()
+            float nextLine()
             {
                 if(mnYCounter>=0)
                 {
                     // go one step in Y
                     mfXPos += mfXDelta;
                     --mnYCounter;
+					return mfXDelta;
                 }
+
+				return 0.0f;
             }
 
             bool isEnded()
@@ -306,6 +550,193 @@
         // it crosses or touches the current scanline.
         VectorOfLineNodes	aActiveVertices;
 
+#if 1
+
+		// mickey's optimized version...
+		radixSort rs;
+		sal_uInt32 nb,nb_previous;
+		sal_uInt32 nb_sort;
+		bool bSort = false;
+		nb_previous = 0;
+		nb_sort = 0;
+
+        // process each scanline
+        for( sal_Int32 y(0); y <= nScanlines; ++y )
+        {
+            // add vertices which start at current scanline into
+            // active vertex vector
+            ::std::for_each( maScanlines[y].begin(),
+                             maScanlines[y].end(),
+                             LineNodeGenerator( aActiveVertices ) );
+			nb = aActiveVertices.size();
+			if(nb != nb_previous) {
+				nb_previous = nb;
+				bSort = true;
+			}
+
+            // sort with increasing X
+			if(bSort) {
+				bSort = false;
+				float *pInput = &((*aActiveVertices.begin()).mfXPos);
+				rs.sort(pInput,nb,sizeof(ImplLineNode));
+				++nb_sort;
+#if 0
+				sal_uInt32 *sorted = rs.indices();
+				OSL_TRACE("%d\n",nb);
+				float last = aActiveVertices[sorted[0]].getXPos();
+				for(int n=0; n<nb; ++n) {
+					float current = aActiveVertices[sorted[n]].getXPos();
+					if(last > current) {
+						OSL_TRACE("error\n");
+					}
+					OSL_TRACE("%f\n",current);
+					last = current;
+				}
+				OSL_TRACE("-------\n",nb);
+#endif
+			}
+
+            const ::std::size_t nLen( nb );
+            if( !nLen )
+            {
+                // empty scanline - call derived with an 'off' span
+                // for the full width
+                span( maPolyPolyRectangle.getMinX(),
+                      maPolyPolyRectangle.getMaxX(),
+                      nMinY + y,
+                      false );
+            }
+            else
+            {
+                const sal_Int32 nCurrY( nMinY + y );
+                
+                // scanline not empty - forward all scans to derived,
+                // according to selected fill rule
+
+                // TODO(P1): Maybe allow these 'off' span calls to be
+                // switched off (or all 'on' span calls, depending on
+                // use case scenario)
+
+				// sorting didn't change the order of the elements
+				// in memory but prepared a list of indices in sorted order.
+				// thus we now process the nodes with an additional indirection.
+				sal_uInt32 *sorted = rs.indices();
+
+                // call derived with 'off' span for everything left of first active span
+                if( aActiveVertices[sorted[0]].getXPos() > maPolyPolyRectangle.getMinX() )
+                {
+                    span( maPolyPolyRectangle.getMinX(),
+                          aActiveVertices[sorted[0]].getXPos(),
+                          nCurrY,
+                          false );
+                }
+
+                switch( eFillRule )
+                {
+                    default:
+                        OSL_ENSURE(false,
+                                   "B2DPolyPolygonRasterConverter::rasterConvert(): Unexpected fill rule");
+                        return;
+
+                    case FillRule_EVEN_ODD:
+                        // process each span in current scanline, with
+                        // even-odd fill rule
+                        for( ::std::size_t i(0), nLen(aActiveVertices.size());
+                             i+1 < nLen;
+                             ++i )
+                        {
+							sal_uInt32 nIndex = sorted[i];
+							sal_uInt32 nNextIndex = sorted[i+1];
+                            span( aActiveVertices[nIndex].getXPos(),
+                                  aActiveVertices[nNextIndex].getXPos(),
+                                  nCurrY,
+                                  i % 2 == 0 );
+
+                            float delta = aActiveVertices[nIndex].nextLine();
+							if(delta > 0.0f) {
+								if(aActiveVertices[nIndex].getXPos() > aActiveVertices[nNextIndex].getXPos())
+									bSort = true;
+							}
+							else if(delta < 0.0f) {
+								if(i) {
+									sal_uInt32 nPrevIndex = sorted[i-1];
+									if(aActiveVertices[nIndex].getXPos() < aActiveVertices[nPrevIndex].getXPos())
+										bSort = true;
+								}
+							}
+                        }
+                        break;
+
+                    case FillRule_NONZERO_WINDING_NUMBER:
+                        // process each span in current scanline, with
+                        // non-zero winding numbe fill rule
+                        sal_Int32 nWindingNumber(0);
+                        for( ::std::size_t i(0), nLen(aActiveVertices.size());
+                             i+1 < nLen;
+                             ++i )
+                        {
+							sal_uInt32 nIndex = sorted[i];
+							sal_uInt32 nNextIndex = sorted[i+1];
+                            nWindingNumber += -1 + 2*aActiveVertices[nIndex].isDownwards();
+
+                            span( aActiveVertices[nIndex].getXPos(),
+                                  aActiveVertices[nNextIndex].getXPos(),
+                                  nCurrY,
+                                  nWindingNumber != 0 );
+
+                            float delta = aActiveVertices[nIndex].nextLine();
+							if(delta > 0.0f) {
+								if(aActiveVertices[nIndex].getXPos() > aActiveVertices[nNextIndex].getXPos())
+									bSort = true;
+							}
+							else if(delta < 0.0f) {
+								if(i) {
+									sal_uInt32 nPrevIndex = sorted[i-1];
+									if(aActiveVertices[nIndex].getXPos() < aActiveVertices[nPrevIndex].getXPos())
+										bSort = true;
+								}
+							}
+                        }
+                        break;
+                }
+
+                // call derived with 'off' span for everything right of last active span
+                if( aActiveVertices[sorted[nb-1]].getXPos() < maPolyPolyRectangle.getMaxX() )
+                {
+                    span( aActiveVertices[sorted[nb-1]].getXPos()+1.0,
+                          maPolyPolyRectangle.getMaxX(),
+                          nCurrY,
+                          false );
+                }
+
+                // also call nextLine on very last line node
+				sal_uInt32 nIndex = sorted[nb-1];
+                float delta = aActiveVertices[nIndex].nextLine();                
+				if(delta < 0.0f) {
+					if(nb) {
+						sal_uInt32 nPrevIndex = sorted[nb-2];
+						if(aActiveVertices[nIndex].getXPos() < aActiveVertices[nPrevIndex].getXPos())
+							bSort = true;
+					}
+				}
+            }
+
+            // remove line nodes which have ended on the current scanline
+            aActiveVertices.erase( ::std::remove_if( aActiveVertices.begin(),
+                                                     aActiveVertices.end(),
+                                                     ::boost::mem_fn( &ImplLineNode::isEnded ) ),
+                                   aActiveVertices.end() );
+			nb = aActiveVertices.size();
+			if(nb != nb_previous) {
+				nb_previous = nb;
+				bSort = true;
+			}
+        }
+		
+		//printf("%d %d",nb_sort,nScanlines);
+
+#else
+
         // process each scanline
         for( sal_Int32 y(0); y <= nScanlines; ++y )
         {
@@ -427,7 +858,7 @@
                          aActiveVertices.end(),
                          LineNodeComparator() );
         }
-    }
-
+#endif
+	}
 }
 // eof
diff -u -r  basegfx/source/tools/canvastools.cxx  basegfx/source/tools/canvastools.cxx
---  basegfx/source/tools/canvastools.cxx	2004-11-27 00:10:59.000000000 +0530
+++  basegfx/source/tools/canvastools.cxx	2005-02-28 13:46:02.441079128 +0530
@@ -59,35 +59,35 @@
  *
  ************************************************************************/
 
-#ifndef _DRAFTS_COM_SUN_STAR_GEOMETRY_REALSIZE2D_HPP__
-#include <drafts/com/sun/star/geometry/RealSize2D.hpp>
+#ifndef _COM_SUN_STAR_GEOMETRY_REALSIZE2D_HPP__
+#include <com/sun/star/geometry/RealSize2D.hpp>
 #endif
-#ifndef _DRAFTS_COM_SUN_STAR_GEOMETRY_REALPOINT2D_HPP__
-#include <drafts/com/sun/star/geometry/RealPoint2D.hpp>
+#ifndef _COM_SUN_STAR_GEOMETRY_REALPOINT2D_HPP__
+#include <com/sun/star/geometry/RealPoint2D.hpp>
 #endif
-#ifndef _DRAFTS_COM_SUN_STAR_GEOMETRY_REALRECTANGLE2D_HPP__
-#include <drafts/com/sun/star/geometry/RealRectangle2D.hpp>
+#ifndef _COM_SUN_STAR_GEOMETRY_REALRECTANGLE2D_HPP__
+#include <com/sun/star/geometry/RealRectangle2D.hpp>
 #endif
-#ifndef _DRAFTS_COM_SUN_STAR_GEOMETRY_REALBEZIERSEGMENT2D_HPP__
-#include <drafts/com/sun/star/geometry/RealBezierSegment2D.hpp>
+#ifndef _COM_SUN_STAR_GEOMETRY_REALBEZIERSEGMENT2D_HPP__
+#include <com/sun/star/geometry/RealBezierSegment2D.hpp>
 #endif
-#ifndef _DRAFTS_COM_SUN_STAR_GEOMETRY_AFFINEMATRIX2D_HPP_
-#include <drafts/com/sun/star/geometry/AffineMatrix2D.hpp>
+#ifndef _COM_SUN_STAR_GEOMETRY_AFFINEMATRIX2D_HPP_
+#include <com/sun/star/geometry/AffineMatrix2D.hpp>
 #endif
-#ifndef _DRAFTS_COM_SUN_STAR_GEOMETRY_INTEGERSIZE2D_HPP__
-#include <drafts/com/sun/star/geometry/IntegerSize2D.hpp>
+#ifndef _COM_SUN_STAR_GEOMETRY_INTEGERSIZE2D_HPP__
+#include <com/sun/star/geometry/IntegerSize2D.hpp>
 #endif
-#ifndef _DRAFTS_COM_SUN_STAR_GEOMETRY_INTEGERPOINT2D_HPP__
-#include <drafts/com/sun/star/geometry/IntegerPoint2D.hpp>
+#ifndef _COM_SUN_STAR_GEOMETRY_INTEGERPOINT2D_HPP__
+#include <com/sun/star/geometry/IntegerPoint2D.hpp>
 #endif
-#ifndef _DRAFTS_COM_SUN_STAR_GEOMETRY_INTEGERRECTANGLE2D_HPP__
-#include <drafts/com/sun/star/geometry/IntegerRectangle2D.hpp>
+#ifndef _COM_SUN_STAR_GEOMETRY_INTEGERRECTANGLE2D_HPP__
+#include <com/sun/star/geometry/IntegerRectangle2D.hpp>
 #endif
-#ifndef _DRAFTS_COM_SUN_STAR_RENDERING_XPOLYPOLYGON2D_HPP__
-#include <drafts/com/sun/star/rendering/XPolyPolygon2D.hpp>
+#ifndef _COM_SUN_STAR_RENDERING_XPOLYPOLYGON2D_HPP__
+#include <com/sun/star/rendering/XPolyPolygon2D.hpp>
 #endif
-#ifndef _DRAFTS_COM_SUN_STAR_RENDERING_XGRAPHICDEVICE_HPP__
-#include <drafts/com/sun/star/rendering/XGraphicDevice.hpp>
+#ifndef _COM_SUN_STAR_RENDERING_XGRAPHICDEVICE_HPP__
+#include <com/sun/star/rendering/XGraphicDevice.hpp>
 #endif
 
 #ifndef _COM_SUN_STAR_AWT_SIZE_HPP__
@@ -115,7 +115,6 @@
 #include <limits>
 
 
-using namespace ::drafts::com::sun::star;
 using namespace ::com::sun::star;
 
 namespace basegfx
@@ -376,53 +375,53 @@
 
         geometry::RealSize2D size2DFromB2DSize( const ::basegfx::B2DVector& rVec )
         {
-            return geometry::RealSize2D( rVec.getX(), 
+            return geometry::RealSize2D( rVec.getX(),
                                          rVec.getY() );
         }
 
         geometry::RealPoint2D point2DFromB2DPoint( const ::basegfx::B2DPoint& rPoint )
         {
-            return geometry::RealPoint2D( rPoint.getX(), 
+            return geometry::RealPoint2D( rPoint.getX(),
                                           rPoint.getY() );
         }
 
         geometry::RealRectangle2D rectangle2DFromB2DRectangle( const ::basegfx::B2DRange& rRect )
         {
-            return geometry::RealRectangle2D( rRect.getMinX(), 
-                                              rRect.getMinY(), 
-                                              rRect.getMaxX(), 
+            return geometry::RealRectangle2D( rRect.getMinX(),
+                                              rRect.getMinY(),
+                                              rRect.getMaxX(),
                                               rRect.getMaxY() );
         }
 
         ::basegfx::B2DVector b2DSizeFromRealSize2D( const geometry::RealSize2D& rSize )
         {
-            return ::basegfx::B2DVector( rSize.Width, 
+            return ::basegfx::B2DVector( rSize.Width,
                                          rSize.Height );
         }
 
         ::basegfx::B2DPoint b2DPointFromRealPoint2D( const geometry::RealPoint2D& rPoint )
         {
-            return ::basegfx::B2DPoint( rPoint.X, 
+            return ::basegfx::B2DPoint( rPoint.X,
                                         rPoint.Y );
         }
 
         ::basegfx::B2DRange b2DRectangleFromRealRectangle2D( const geometry::RealRectangle2D& rRect )
         {
-            return ::basegfx::B2DRange( rRect.X1, 
+            return ::basegfx::B2DRange( rRect.X1,
                                         rRect.Y1,
-                                        rRect.X2, 
+                                        rRect.X2,
                                         rRect.Y2 );
         }
 
         geometry::IntegerSize2D integerSize2DFromB2ISize( const ::basegfx::B2IVector& rSize )
         {
-            return geometry::IntegerSize2D( rSize.getX(), 
+            return geometry::IntegerSize2D( rSize.getX(),
                                             rSize.getY() );
         }
 
         geometry::IntegerPoint2D integerPoint2DFromB2IPoint( const ::basegfx::B2IPoint& rPoint )
         {
-            return geometry::IntegerPoint2D( rPoint.getX(), 
+            return geometry::IntegerPoint2D( rPoint.getX(),
                                              rPoint.getY() );
         }
 
@@ -434,19 +433,19 @@
 
         ::basegfx::B2IVector b2ISizeFromIntegerSize2D( const geometry::IntegerSize2D& rSize )
         {
-            return ::basegfx::B2IVector( rSize.Width, 
-                                         rSize.Height ); 
+            return ::basegfx::B2IVector( rSize.Width,
+                                         rSize.Height );
         }
 
         ::basegfx::B2IPoint b2IPointFromIntegerPoint2D( const geometry::IntegerPoint2D& rPoint )
         {
-            return ::basegfx::B2IPoint( rPoint.X, 
+            return ::basegfx::B2IPoint( rPoint.X,
                                         rPoint.Y );
         }
 
         ::basegfx::B2IRange b2IRectangleFromIntegerRectangle2D( const geometry::IntegerRectangle2D& rRectangle )
         {
-            return ::basegfx::B2IRange( rRectangle.X1, rRectangle.Y1, 
+            return ::basegfx::B2IRange( rRectangle.X1, rRectangle.Y1,
                                         rRectangle.X2, rRectangle.Y2 );
         }
 
diff -u -r  basegfx/source/vector/b2ivector.cxx  basegfx/source/vector/b2ivector.cxx
---  basegfx/source/vector/b2ivector.cxx	2004-05-12 13:43:45.000000000 +0530
+++  basegfx/source/vector/b2ivector.cxx	2005-02-28 13:46:02.455077395 +0530
@@ -70,6 +70,9 @@
 #ifndef _BGFX_NUMERIC_FTOOLS_HXX
 #include <basegfx/numeric/ftools.hxx>
 #endif
+#ifndef _BGFX_VECTOR_B2DVECTOR_HXX
+#include <basegfx/vector/b2dvector.hxx>
+#endif
 
 namespace basegfx
 {

diff -u -r  canvas/inc/canvas/bitmapcanvasbase.hxx  canvas/inc/canvas/bitmapcanvasbase.hxx
---  canvas/inc/canvas/bitmapcanvasbase.hxx	2004-11-26 22:31:54.000000000 +0530
+++  canvas/inc/canvas/bitmapcanvasbase.hxx	2005-02-28 13:41:07.259691043 +0530
@@ -62,8 +62,8 @@
 #ifndef INCLUDED_CANVAS_BITMAPCANVASBASE_HXX
 #define INCLUDED_CANVAS_BITMAPCANVASBASE_HXX
 
-#ifndef _DRAFTS_COM_SUN_STAR_RENDERING_XINTEGERBITMAP_HPP_
-#include <drafts/com/sun/star/rendering/XIntegerBitmap.hpp>
+#ifndef _COM_SUN_STAR_RENDERING_XINTEGERBITMAP_HPP_
+#include <com/sun/star/rendering/XIntegerBitmap.hpp>
 #endif
 
 #ifndef INCLUDED_CANVAS_CANVASBASE_HXX
@@ -111,13 +111,13 @@
         }
 
         // XBitmapCanvas
-        virtual void SAL_CALL copyRect( const ::com::sun::star::uno::Reference< ::drafts::com::sun::star::rendering::XBitmapCanvas >& 	sourceCanvas, 
-                                        const ::drafts::com::sun::star::geometry::RealRectangle2D& 										sourceRect, 
-                                        const ::drafts::com::sun::star::rendering::ViewState& 											sourceViewState, 
-                                        const ::drafts::com::sun::star::rendering::RenderState& 										sourceRenderState, 
-                                        const ::drafts::com::sun::star::geometry::RealRectangle2D& 										destRect, 
-                                        const ::drafts::com::sun::star::rendering::ViewState& 											destViewState, 
-                                        const ::drafts::com::sun::star::rendering::RenderState& 										destRenderState ) throw (::com::sun::star::lang::IllegalArgumentException, ::com::sun::star::uno::RuntimeException)
+        virtual void SAL_CALL copyRect( const ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XBitmapCanvas >& 	sourceCanvas, 
+                                        const ::com::sun::star::geometry::RealRectangle2D& 										sourceRect, 
+                                        const ::com::sun::star::rendering::ViewState& 											sourceViewState, 
+                                        const ::com::sun::star::rendering::RenderState& 										sourceRenderState, 
+                                        const ::com::sun::star::geometry::RealRectangle2D& 										destRect, 
+                                        const ::com::sun::star::rendering::ViewState& 											destViewState, 
+                                        const ::com::sun::star::rendering::RenderState& 										destRenderState ) throw (::com::sun::star::lang::IllegalArgumentException, ::com::sun::star::uno::RuntimeException)
         {
             typename BaseType::MutexType aGuard( BaseType::m_aMutex );
             
@@ -133,19 +133,19 @@
         }
 
         // XBitmap
-        virtual ::drafts::com::sun::star::geometry::IntegerSize2D SAL_CALL getSize(  ) throw (::com::sun::star::uno::RuntimeException)
+        virtual ::com::sun::star::geometry::IntegerSize2D SAL_CALL getSize(  ) throw (::com::sun::star::uno::RuntimeException)
         {
             typename BaseType::MutexType aGuard( BaseType::m_aMutex );
 
             return BaseType::maCanvasHelper.getSize();            
         }
 
-        virtual ::com::sun::star::uno::Reference< ::drafts::com::sun::star::rendering::XBitmapCanvas > SAL_CALL queryBitmapCanvas(  ) throw (::com::sun::star::uno::RuntimeException)
+        virtual ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XBitmapCanvas > SAL_CALL queryBitmapCanvas(  ) throw (::com::sun::star::uno::RuntimeException)
         {
             return this;            
         }
 
-        virtual ::com::sun::star::uno::Reference< ::drafts::com::sun::star::rendering::XBitmap > SAL_CALL getScaledBitmap( const ::drafts::com::sun::star::geometry::RealSize2D& newSize, sal_Bool beFast ) throw (::com::sun::star::uno::RuntimeException)
+        virtual ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XBitmap > SAL_CALL getScaledBitmap( const ::com::sun::star::geometry::RealSize2D& newSize, sal_Bool beFast ) throw (::com::sun::star::uno::RuntimeException)
         {
             typename BaseType::MutexType aGuard( BaseType::m_aMutex );
 
@@ -153,14 +153,14 @@
         }
 
         // XIntegerBitmap
-        virtual ::com::sun::star::uno::Sequence< sal_Int8 > SAL_CALL getData( const ::drafts::com::sun::star::geometry::IntegerRectangle2D& rect ) throw (::com::sun::star::lang::IndexOutOfBoundsException, ::drafts::com::sun::star::rendering::VolatileContentDestroyedException, ::com::sun::star::uno::RuntimeException)
+        virtual ::com::sun::star::uno::Sequence< sal_Int8 > SAL_CALL getData( const ::com::sun::star::geometry::IntegerRectangle2D& rect ) throw (::com::sun::star::lang::IndexOutOfBoundsException, ::com::sun::star::rendering::VolatileContentDestroyedException, ::com::sun::star::uno::RuntimeException)
         {
             typename BaseType::MutexType aGuard( BaseType::m_aMutex );
 
             return BaseType::maCanvasHelper.getData( rect );
         }
 
-        virtual void SAL_CALL setData( const ::com::sun::star::uno::Sequence< sal_Int8 >& data, const ::drafts::com::sun::star::rendering::IntegerBitmapLayout& bitmapLayout, const ::drafts::com::sun::star::geometry::IntegerRectangle2D& rect ) throw (::com::sun::star::lang::IllegalArgumentException, ::com::sun::star::lang::IndexOutOfBoundsException, ::com::sun::star::uno::RuntimeException)
+        virtual void SAL_CALL setData( const ::com::sun::star::uno::Sequence< sal_Int8 >& data, const ::com::sun::star::rendering::IntegerBitmapLayout& bitmapLayout, const ::com::sun::star::geometry::IntegerRectangle2D& rect ) throw (::com::sun::star::lang::IllegalArgumentException, ::com::sun::star::lang::IndexOutOfBoundsException, ::com::sun::star::uno::RuntimeException)
         {
             typename BaseType::MutexType aGuard( BaseType::m_aMutex );
 
@@ -169,7 +169,7 @@
             BaseType::maCanvasHelper.setData( data, rect );
         }
 
-        virtual void SAL_CALL setPixel( const ::com::sun::star::uno::Sequence< sal_Int8 >& color, const ::drafts::com::sun::star::rendering::IntegerBitmapLayout& bitmapLayout, const ::drafts::com::sun::star::geometry::IntegerPoint2D& pos ) throw (::com::sun::star::lang::IllegalArgumentException, ::com::sun::star::lang::IndexOutOfBoundsException, ::com::sun::star::uno::RuntimeException)
+        virtual void SAL_CALL setPixel( const ::com::sun::star::uno::Sequence< sal_Int8 >& color, const ::com::sun::star::rendering::IntegerBitmapLayout& bitmapLayout, const ::com::sun::star::geometry::IntegerPoint2D& pos ) throw (::com::sun::star::lang::IllegalArgumentException, ::com::sun::star::lang::IndexOutOfBoundsException, ::com::sun::star::uno::RuntimeException)
         {
             typename BaseType::MutexType aGuard( BaseType::m_aMutex );
 
@@ -178,21 +178,21 @@
             BaseType::maCanvasHelper.setPixel( color, pos );
         }
 
-        virtual ::com::sun::star::uno::Sequence< sal_Int8 > SAL_CALL getPixel( const ::drafts::com::sun::star::geometry::IntegerPoint2D& pos ) throw (::com::sun::star::lang::IndexOutOfBoundsException, ::drafts::com::sun::star::rendering::VolatileContentDestroyedException, ::com::sun::star::uno::RuntimeException)
+        virtual ::com::sun::star::uno::Sequence< sal_Int8 > SAL_CALL getPixel( const ::com::sun::star::geometry::IntegerPoint2D& pos ) throw (::com::sun::star::lang::IndexOutOfBoundsException, ::com::sun::star::rendering::VolatileContentDestroyedException, ::com::sun::star::uno::RuntimeException)
         {
             typename BaseType::MutexType aGuard( BaseType::m_aMutex );
 
             return BaseType::maCanvasHelper.getPixel( pos );
         }
 
-        virtual ::com::sun::star::uno::Reference< ::drafts::com::sun::star::rendering::XBitmapPalette > SAL_CALL getPalette(  ) throw (::com::sun::star::uno::RuntimeException)
+        virtual ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XBitmapPalette > SAL_CALL getPalette(  ) throw (::com::sun::star::uno::RuntimeException)
         {
             typename BaseType::MutexType aGuard( BaseType::m_aMutex );
 
             return BaseType::maCanvasHelper.getPalette();
         }
 
-        virtual ::drafts::com::sun::star::rendering::IntegerBitmapLayout SAL_CALL getMemoryLayout(  ) throw (::com::sun::star::uno::RuntimeException)
+        virtual ::com::sun::star::rendering::IntegerBitmapLayout SAL_CALL getMemoryLayout(  ) throw (::com::sun::star::uno::RuntimeException)
         {
             typename BaseType::MutexType aGuard( BaseType::m_aMutex );
 
diff -u -r  canvas/inc/canvas/canvasbase.hxx  canvas/inc/canvas/canvasbase.hxx
---  canvas/inc/canvas/canvasbase.hxx	2004-11-26 22:32:05.000000000 +0530
+++  canvas/inc/canvas/canvasbase.hxx	2005-02-28 13:41:07.256691393 +0530
@@ -62,11 +62,11 @@
 #ifndef INCLUDED_CANVAS_CANVASBASE_HXX
 #define INCLUDED_CANVAS_CANVASBASE_HXX
 
-#ifndef _DRAFTS_COM_SUN_STAR_RENDERING_XCANVAS_HPP_
-#include <drafts/com/sun/star/lang/XCanvas.hpp>
+#ifndef _COM_SUN_STAR_RENDERING_XCANVAS_HPP_
+#include <com/sun/star/rendering/XCanvas.hpp>
 #endif
 
-#ifndef _OSL_MUTEX_HXX_ 
+#ifndef _OSL_MUTEX_HXX_
 #include <osl/mutex.hxx>
 #endif
 #ifndef _COMPHELPER_BROADCASTHELPER_HXX_
@@ -134,9 +134,9 @@
         }
 
         // XCanvas
-        virtual void SAL_CALL drawPoint( const ::drafts::com::sun::star::geometry::RealPoint2D& 	aPoint, 
-                                         const ::drafts::com::sun::star::rendering::ViewState& 		viewState, 
-                                         const ::drafts::com::sun::star::rendering::RenderState& 	renderState ) throw (::com::sun::star::lang::IllegalArgumentException, ::com::sun::star::uno::RuntimeException)
+        virtual void SAL_CALL drawPoint( const ::com::sun::star::geometry::RealPoint2D& 	aPoint,
+                                         const ::com::sun::star::rendering::ViewState& 		viewState,
+                                         const ::com::sun::star::rendering::RenderState& 	renderState ) throw (::com::sun::star::lang::IllegalArgumentException, ::com::sun::star::uno::RuntimeException)
         {
             MutexType aGuard( m_aMutex );
 
@@ -145,215 +145,215 @@
             maCanvasHelper.drawPoint( aPoint, viewState, renderState );
         }
 
-        virtual void SAL_CALL drawLine( const ::drafts::com::sun::star::geometry::RealPoint2D& 	aStartPoint, 
-                                        const ::drafts::com::sun::star::geometry::RealPoint2D& 	aEndPoint, 
-                                        const ::drafts::com::sun::star::rendering::ViewState& 	viewState, 
-                                        const ::drafts::com::sun::star::rendering::RenderState& renderState	) throw (::com::sun::star::lang::IllegalArgumentException, ::com::sun::star::uno::RuntimeException)
+        virtual void SAL_CALL drawLine( const ::com::sun::star::geometry::RealPoint2D& 	aStartPoint,
+                                        const ::com::sun::star::geometry::RealPoint2D& 	aEndPoint,
+                                        const ::com::sun::star::rendering::ViewState& 	viewState,
+                                        const ::com::sun::star::rendering::RenderState& renderState	) throw (::com::sun::star::lang::IllegalArgumentException, ::com::sun::star::uno::RuntimeException)
         {
             MutexType aGuard( m_aMutex );
-            
+
             mbSurfaceDirty = true;
 
             maCanvasHelper.drawLine(aStartPoint, aEndPoint, viewState, renderState);
         }
 
-        virtual void SAL_CALL drawBezier( const ::drafts::com::sun::star::geometry::RealBezierSegment2D& 	aBezierSegment, 
-                                          const ::drafts::com::sun::star::geometry::RealPoint2D& 			aEndPoint,
-                                          const ::drafts::com::sun::star::rendering::ViewState& 			viewState, 
-                                          const ::drafts::com::sun::star::rendering::RenderState& 			renderState ) throw (::com::sun::star::lang::IllegalArgumentException, ::com::sun::star::uno::RuntimeException)
+        virtual void SAL_CALL drawBezier( const ::com::sun::star::geometry::RealBezierSegment2D& 	aBezierSegment,
+                                          const ::com::sun::star::geometry::RealPoint2D& 			aEndPoint,
+                                          const ::com::sun::star::rendering::ViewState& 			viewState,
+                                          const ::com::sun::star::rendering::RenderState& 			renderState ) throw (::com::sun::star::lang::IllegalArgumentException, ::com::sun::star::uno::RuntimeException)
         {
             MutexType aGuard( m_aMutex );
-            
+
             mbSurfaceDirty = true;
 
             maCanvasHelper.drawBezier(aBezierSegment, aEndPoint, viewState, renderState);
         }
 
-        virtual ::com::sun::star::uno::Reference< ::drafts::com::sun::star::rendering::XCachedPrimitive > SAL_CALL 	
-        	drawPolyPolygon( const ::com::sun::star::uno::Reference< ::drafts::com::sun::star::rendering::XPolyPolygon2D >& xPolyPolygon, 
-                             const ::drafts::com::sun::star::rendering::ViewState& 											viewState, 
-                             const ::drafts::com::sun::star::rendering::RenderState& 										renderState ) throw (::com::sun::star::lang::IllegalArgumentException, ::com::sun::star::uno::RuntimeException)
+        virtual ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XCachedPrimitive > SAL_CALL
+        	drawPolyPolygon( const ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XPolyPolygon2D >& xPolyPolygon,
+                             const ::com::sun::star::rendering::ViewState& 											viewState,
+                             const ::com::sun::star::rendering::RenderState& 										renderState ) throw (::com::sun::star::lang::IllegalArgumentException, ::com::sun::star::uno::RuntimeException)
         {
             MutexType aGuard( m_aMutex );
-            
+
             mbSurfaceDirty = true;
 
             return maCanvasHelper.drawPolyPolygon(xPolyPolygon, viewState, renderState);
         }
 
-        virtual ::com::sun::star::uno::Reference< ::drafts::com::sun::star::rendering::XCachedPrimitive > SAL_CALL 	
-        	strokePolyPolygon( const ::com::sun::star::uno::Reference< ::drafts::com::sun::star::rendering::XPolyPolygon2D >& 	xPolyPolygon, 
-                               const ::drafts::com::sun::star::rendering::ViewState& 											viewState, 
-                               const ::drafts::com::sun::star::rendering::RenderState& 											renderState, 
-                               const ::drafts::com::sun::star::rendering::StrokeAttributes& 									strokeAttributes ) throw (::com::sun::star::lang::IllegalArgumentException, ::com::sun::star::uno::RuntimeException)
+        virtual ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XCachedPrimitive > SAL_CALL
+        	strokePolyPolygon( const ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XPolyPolygon2D >& 	xPolyPolygon,
+                               const ::com::sun::star::rendering::ViewState& 											viewState,
+                               const ::com::sun::star::rendering::RenderState& 											renderState,
+                               const ::com::sun::star::rendering::StrokeAttributes& 									strokeAttributes ) throw (::com::sun::star::lang::IllegalArgumentException, ::com::sun::star::uno::RuntimeException)
         {
             MutexType aGuard( m_aMutex );
-            
+
             mbSurfaceDirty = true;
 
             return maCanvasHelper.strokePolyPolygon(xPolyPolygon, viewState, renderState, strokeAttributes);
         }
 
-        virtual ::com::sun::star::uno::Reference< ::drafts::com::sun::star::rendering::XCachedPrimitive > SAL_CALL 	
-        	strokeTexturedPolyPolygon( const ::com::sun::star::uno::Reference< ::drafts::com::sun::star::rendering::XPolyPolygon2D >& 	xPolyPolygon, 
-                                       const ::drafts::com::sun::star::rendering::ViewState& 											viewState, 
-                                       const ::drafts::com::sun::star::rendering::RenderState& 											renderState, 
-                                       const ::com::sun::star::uno::Sequence< ::drafts::com::sun::star::rendering::Texture >& 			textures, 
-                                       const ::drafts::com::sun::star::rendering::StrokeAttributes& 									strokeAttributes ) throw (::com::sun::star::lang::IllegalArgumentException, ::com::sun::star::uno::RuntimeException)
+        virtual ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XCachedPrimitive > SAL_CALL
+        	strokeTexturedPolyPolygon( const ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XPolyPolygon2D >& 	xPolyPolygon,
+                                       const ::com::sun::star::rendering::ViewState& 											viewState,
+                                       const ::com::sun::star::rendering::RenderState& 											renderState,
+                                       const ::com::sun::star::uno::Sequence< ::com::sun::star::rendering::Texture >& 			textures,
+                                       const ::com::sun::star::rendering::StrokeAttributes& 									strokeAttributes ) throw (::com::sun::star::lang::IllegalArgumentException, ::com::sun::star::uno::RuntimeException)
         {
             MutexType aGuard( m_aMutex );
-            
+
             mbSurfaceDirty = true;
 
             return maCanvasHelper.strokeTexturedPolyPolygon(xPolyPolygon, viewState, renderState, textures, strokeAttributes);
         }
 
-        virtual ::com::sun::star::uno::Reference< ::drafts::com::sun::star::rendering::XCachedPrimitive > SAL_CALL 	
-        	strokeTextureMappedPolyPolygon( const ::com::sun::star::uno::Reference< ::drafts::com::sun::star::rendering::XPolyPolygon2D >& 	xPolyPolygon, 
-                                            const ::drafts::com::sun::star::rendering::ViewState& 											viewState, 
-                                            const ::drafts::com::sun::star::rendering::RenderState& 										renderState, 
-                                            const ::com::sun::star::uno::Sequence< ::drafts::com::sun::star::rendering::Texture >& 			textures, 
-                                            const ::com::sun::star::uno::Reference< ::drafts::com::sun::star::geometry::XMapping2D >& 		xMapping, 
-                                            const ::drafts::com::sun::star::rendering::StrokeAttributes& 									strokeAttributes ) throw (::com::sun::star::lang::IllegalArgumentException, ::com::sun::star::uno::RuntimeException)
+        virtual ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XCachedPrimitive > SAL_CALL
+        	strokeTextureMappedPolyPolygon( const ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XPolyPolygon2D >& 	xPolyPolygon,
+                                            const ::com::sun::star::rendering::ViewState& 											viewState,
+                                            const ::com::sun::star::rendering::RenderState& 										renderState,
+                                            const ::com::sun::star::uno::Sequence< ::com::sun::star::rendering::Texture >& 			textures,
+                                            const ::com::sun::star::uno::Reference< ::com::sun::star::geometry::XMapping2D >& 		xMapping,
+                                            const ::com::sun::star::rendering::StrokeAttributes& 									strokeAttributes ) throw (::com::sun::star::lang::IllegalArgumentException, ::com::sun::star::uno::RuntimeException)
         {
             MutexType aGuard( m_aMutex );
-            
+
             mbSurfaceDirty = true;
 
             return maCanvasHelper.strokeTextureMappedPolyPolygon(xPolyPolygon, viewState, renderState, textures, xMapping, strokeAttributes);
         }
 
-        virtual ::com::sun::star::uno::Reference< ::drafts::com::sun::star::rendering::XPolyPolygon2D >   SAL_CALL 	
-        	queryStrokeShapes( const ::com::sun::star::uno::Reference< ::drafts::com::sun::star::rendering::XPolyPolygon2D >& 	xPolyPolygon, 
-                               const ::drafts::com::sun::star::rendering::ViewState& 											viewState, 
-                               const ::drafts::com::sun::star::rendering::RenderState& 											renderState, 
-                               const ::drafts::com::sun::star::rendering::StrokeAttributes& 									strokeAttributes ) throw (::com::sun::star::lang::IllegalArgumentException, ::com::sun::star::uno::RuntimeException)
+        virtual ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XPolyPolygon2D >   SAL_CALL
+        	queryStrokeShapes( const ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XPolyPolygon2D >& 	xPolyPolygon,
+                               const ::com::sun::star::rendering::ViewState& 											viewState,
+                               const ::com::sun::star::rendering::RenderState& 											renderState,
+                               const ::com::sun::star::rendering::StrokeAttributes& 									strokeAttributes ) throw (::com::sun::star::lang::IllegalArgumentException, ::com::sun::star::uno::RuntimeException)
         {
             MutexType aGuard( m_aMutex );
-            
+
             mbSurfaceDirty = true;
 
             return maCanvasHelper.queryStrokeShapes(xPolyPolygon, viewState, renderState, strokeAttributes);
         }
 
-        virtual ::com::sun::star::uno::Reference< ::drafts::com::sun::star::rendering::XCachedPrimitive > SAL_CALL 	
-        	fillPolyPolygon( const ::com::sun::star::uno::Reference< ::drafts::com::sun::star::rendering::XPolyPolygon2D >& xPolyPolygon, 
-                             const ::drafts::com::sun::star::rendering::ViewState& 											viewState, 
-                             const ::drafts::com::sun::star::rendering::RenderState& 										renderState ) throw (::com::sun::star::lang::IllegalArgumentException, ::com::sun::star::uno::RuntimeException)
+        virtual ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XCachedPrimitive > SAL_CALL
+        	fillPolyPolygon( const ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XPolyPolygon2D >& xPolyPolygon,
+                             const ::com::sun::star::rendering::ViewState& 											viewState,
+                             const ::com::sun::star::rendering::RenderState& 										renderState ) throw (::com::sun::star::lang::IllegalArgumentException, ::com::sun::star::uno::RuntimeException)
         {
             MutexType aGuard( m_aMutex );
-            
+
             mbSurfaceDirty = true;
 
             return maCanvasHelper.fillPolyPolygon(xPolyPolygon, viewState, renderState );
         }
 
-        virtual ::com::sun::star::uno::Reference< ::drafts::com::sun::star::rendering::XCachedPrimitive > SAL_CALL 	
-        	fillTexturedPolyPolygon( const ::com::sun::star::uno::Reference< ::drafts::com::sun::star::rendering::XPolyPolygon2D >& xPolyPolygon, 
-                                     const ::drafts::com::sun::star::rendering::ViewState& 											viewState, 
-                                     const ::drafts::com::sun::star::rendering::RenderState& 										renderState, 
-                                     const ::com::sun::star::uno::Sequence< ::drafts::com::sun::star::rendering::Texture >& 		textures ) throw (::com::sun::star::lang::IllegalArgumentException, ::com::sun::star::uno::RuntimeException)
+        virtual ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XCachedPrimitive > SAL_CALL
+        	fillTexturedPolyPolygon( const ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XPolyPolygon2D >& xPolyPolygon,
+                                     const ::com::sun::star::rendering::ViewState& 											viewState,
+                                     const ::com::sun::star::rendering::RenderState& 										renderState,
+                                     const ::com::sun::star::uno::Sequence< ::com::sun::star::rendering::Texture >& 		textures ) throw (::com::sun::star::lang::IllegalArgumentException, ::com::sun::star::uno::RuntimeException)
         {
             MutexType aGuard( m_aMutex );
-            
+
             mbSurfaceDirty = true;
 
             return maCanvasHelper.fillTexturedPolyPolygon(xPolyPolygon, viewState, renderState, textures);
         }
 
-        virtual ::com::sun::star::uno::Reference< ::drafts::com::sun::star::rendering::XCachedPrimitive > SAL_CALL 	
-        	fillTextureMappedPolyPolygon( const ::com::sun::star::uno::Reference< ::drafts::com::sun::star::rendering::XPolyPolygon2D >& 	xPolyPolygon, 
-                                          const ::drafts::com::sun::star::rendering::ViewState& 											viewState, 
-                                          const ::drafts::com::sun::star::rendering::RenderState& 											renderState, 
-                                          const ::com::sun::star::uno::Sequence< ::drafts::com::sun::star::rendering::Texture >& 			textures, 
-                                          const ::com::sun::star::uno::Reference< ::drafts::com::sun::star::geometry::XMapping2D >& 		xMapping ) throw (::com::sun::star::lang::IllegalArgumentException, ::com::sun::star::uno::RuntimeException)
+        virtual ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XCachedPrimitive > SAL_CALL
+        	fillTextureMappedPolyPolygon( const ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XPolyPolygon2D >& 	xPolyPolygon,
+                                          const ::com::sun::star::rendering::ViewState& 											viewState,
+                                          const ::com::sun::star::rendering::RenderState& 											renderState,
+                                          const ::com::sun::star::uno::Sequence< ::com::sun::star::rendering::Texture >& 			textures,
+                                          const ::com::sun::star::uno::Reference< ::com::sun::star::geometry::XMapping2D >& 		xMapping ) throw (::com::sun::star::lang::IllegalArgumentException, ::com::sun::star::uno::RuntimeException)
         {
             MutexType aGuard( m_aMutex );
-            
+
             mbSurfaceDirty = true;
 
             return maCanvasHelper.fillTextureMappedPolyPolygon(xPolyPolygon, viewState, renderState, textures, xMapping);
         }
 
 
-        virtual ::com::sun::star::uno::Reference< ::drafts::com::sun::star::rendering::XCanvasFont > SAL_CALL 
-        	createFont( const ::drafts::com::sun::star::rendering::FontRequest& 							fontRequest, 
-                        const ::com::sun::star::uno::Sequence< ::com::sun::star::beans::PropertyValue >& 	extraFontProperties, 
-                        const ::drafts::com::sun::star::geometry::Matrix2D& 								fontMatrix ) throw (::com::sun::star::lang::IllegalArgumentException, ::com::sun::star::uno::RuntimeException)
+        virtual ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XCanvasFont > SAL_CALL
+        	createFont( const ::com::sun::star::rendering::FontRequest& 							fontRequest,
+                        const ::com::sun::star::uno::Sequence< ::com::sun::star::beans::PropertyValue >& 	extraFontProperties,
+                        const ::com::sun::star::geometry::Matrix2D& 								fontMatrix ) throw (::com::sun::star::lang::IllegalArgumentException, ::com::sun::star::uno::RuntimeException)
         {
             MutexType aGuard( m_aMutex );
-            
+
             return maCanvasHelper.createFont( fontRequest, extraFontProperties, fontMatrix );
         }
 
 
-        virtual ::com::sun::star::uno::Sequence< ::drafts::com::sun::star::rendering::FontInfo > SAL_CALL 
-        	queryAvailableFonts( const ::drafts::com::sun::star::rendering::FontInfo& 								aFilter, 
+        virtual ::com::sun::star::uno::Sequence< ::com::sun::star::rendering::FontInfo > SAL_CALL
+        	queryAvailableFonts( const ::com::sun::star::rendering::FontInfo& 								aFilter,
                                  const ::com::sun::star::uno::Sequence< ::com::sun::star::beans::PropertyValue >& 	aFontProperties ) throw (::com::sun::star::lang::IllegalArgumentException, ::com::sun::star::uno::RuntimeException)
         {
             MutexType aGuard( m_aMutex );
-            
+
             return maCanvasHelper.queryAvailableFonts( aFilter, aFontProperties );
         }
 
 
-        virtual ::com::sun::star::uno::Reference< ::drafts::com::sun::star::rendering::XCachedPrimitive > SAL_CALL 
-        	drawText( const ::drafts::com::sun::star::rendering::StringContext& 									text, 
-                      const ::com::sun::star::uno::Reference< ::drafts::com::sun::star::rendering::XCanvasFont >& 	xFont, 
-                      const ::drafts::com::sun::star::rendering::ViewState& 										viewState, 
-                      const ::drafts::com::sun::star::rendering::RenderState& 										renderState, 
+        virtual ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XCachedPrimitive > SAL_CALL
+        	drawText( const ::com::sun::star::rendering::StringContext& 									text,
+                      const ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XCanvasFont >& 	xFont,
+                      const ::com::sun::star::rendering::ViewState& 										viewState,
+                      const ::com::sun::star::rendering::RenderState& 										renderState,
                       sal_Int8 																						textDirection ) throw (::com::sun::star::lang::IllegalArgumentException, ::com::sun::star::uno::RuntimeException)
         {
             MutexType aGuard( m_aMutex );
-            
+
             mbSurfaceDirty = true;
 
             return maCanvasHelper.drawText(text, xFont, viewState, renderState, textDirection);
         }
 
 
-        virtual ::com::sun::star::uno::Reference< ::drafts::com::sun::star::rendering::XCachedPrimitive > SAL_CALL 
-        	drawTextLayout( const ::com::sun::star::uno::Reference< ::drafts::com::sun::star::rendering::XTextLayout >& layoutetText, 
-                            const ::drafts::com::sun::star::rendering::ViewState& 										viewState, 
-                            const ::drafts::com::sun::star::rendering::RenderState& 									renderState ) throw (::com::sun::star::lang::IllegalArgumentException, ::com::sun::star::uno::RuntimeException)
+        virtual ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XCachedPrimitive > SAL_CALL
+        	drawTextLayout( const ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XTextLayout >& layoutetText,
+                            const ::com::sun::star::rendering::ViewState& 										viewState,
+                            const ::com::sun::star::rendering::RenderState& 									renderState ) throw (::com::sun::star::lang::IllegalArgumentException, ::com::sun::star::uno::RuntimeException)
         {
             MutexType aGuard( m_aMutex );
-            
+
             mbSurfaceDirty = true;
 
             return maCanvasHelper.drawTextLayout( layoutetText, viewState, renderState );
         }
 
 
-        virtual ::com::sun::star::uno::Reference< ::drafts::com::sun::star::rendering::XCachedPrimitive > SAL_CALL 	
-        	drawBitmap( const ::com::sun::star::uno::Reference< ::drafts::com::sun::star::rendering::XBitmap >& xBitmap, 
-                        const ::drafts::com::sun::star::rendering::ViewState& 									viewState, 
-                        const ::drafts::com::sun::star::rendering::RenderState& 								renderState ) throw (::com::sun::star::lang::IllegalArgumentException, ::com::sun::star::uno::RuntimeException)
+        virtual ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XCachedPrimitive > SAL_CALL
+        	drawBitmap( const ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XBitmap >& xBitmap,
+                        const ::com::sun::star::rendering::ViewState& 									viewState,
+                        const ::com::sun::star::rendering::RenderState& 								renderState ) throw (::com::sun::star::lang::IllegalArgumentException, ::com::sun::star::uno::RuntimeException)
         {
             MutexType aGuard( m_aMutex );
-            
+
             mbSurfaceDirty = true;
 
             return maCanvasHelper.drawBitmap(xBitmap, viewState, renderState);
         }
 
-        virtual ::com::sun::star::uno::Reference< ::drafts::com::sun::star::rendering::XCachedPrimitive > SAL_CALL 	
-        	drawBitmapModulated( const ::com::sun::star::uno::Reference< ::drafts::com::sun::star::rendering::XBitmap >& 	xBitmap, 
-                                 const ::drafts::com::sun::star::rendering::ViewState& 										viewState, 
-                                 const ::drafts::com::sun::star::rendering::RenderState& 									renderState ) throw (::com::sun::star::lang::IllegalArgumentException, ::com::sun::star::uno::RuntimeException)
+        virtual ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XCachedPrimitive > SAL_CALL
+        	drawBitmapModulated( const ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XBitmap >& 	xBitmap,
+                                 const ::com::sun::star::rendering::ViewState& 										viewState,
+                                 const ::com::sun::star::rendering::RenderState& 									renderState ) throw (::com::sun::star::lang::IllegalArgumentException, ::com::sun::star::uno::RuntimeException)
         {
             MutexType aGuard( m_aMutex );
-            
+
             mbSurfaceDirty = true;
 
             return maCanvasHelper.drawBitmapModulated(xBitmap, viewState, renderState);
         }
 
-        virtual ::com::sun::star::uno::Reference< ::drafts::com::sun::star::rendering::XGraphicDevice >   SAL_CALL 	
+        virtual ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XGraphicDevice >   SAL_CALL
         	getDevice() throw (::com::sun::star::uno::RuntimeException)
         {
             MutexType aGuard( m_aMutex );
-            
+
             return maCanvasHelper.getDevice();
         }
 
diff -u -r  canvas/inc/canvas/canvastools.hxx  canvas/inc/canvas/canvastools.hxx
---  canvas/inc/canvas/canvastools.hxx	2005-01-21 21:55:44.000000000 +0530
+++  canvas/inc/canvas/canvastools.hxx	2005-02-28 13:41:07.224695132 +0530
@@ -88,19 +88,19 @@
     class B2DRange;
 }
 
-namespace drafts { namespace com { namespace sun { namespace star { namespace geometry 
+namespace com { namespace sun { namespace star { namespace geometry 
 {
     struct RealSize2D;
     struct AffineMatrix2D;
     struct Matrix2D;
-} } } } }
+} } } }
 
-namespace drafts { namespace com { namespace sun { namespace star { namespace rendering 
+namespace com { namespace sun { namespace star { namespace rendering 
 {
     struct RenderState;
     struct ViewState;
     class  XCanvas;
-} } } } }
+} } } }
 
 
 namespace canvas
@@ -128,77 +128,77 @@
 
         /** Create a RealSize2D with both coordinate values set to +infinity
          */
-        ::drafts::com::sun::star::geometry::RealSize2D createInfiniteSize2D();
+        ::com::sun::star::geometry::RealSize2D createInfiniteSize2D();
 
 
         // View- and RenderState utilities
         // ===================================================================
 
-        ::drafts::com::sun::star::rendering::RenderState& 
-        	initRenderState( ::drafts::com::sun::star::rendering::RenderState&						renderState );
+        ::com::sun::star::rendering::RenderState& 
+        	initRenderState( ::com::sun::star::rendering::RenderState&						renderState );
 
-        ::drafts::com::sun::star::rendering::ViewState& 
-        	initViewState( ::drafts::com::sun::star::rendering::ViewState&							viewState );
+        ::com::sun::star::rendering::ViewState& 
+        	initViewState( ::com::sun::star::rendering::ViewState&							viewState );
 
         ::basegfx::B2DHomMatrix& 
 	        getViewStateTransform( ::basegfx::B2DHomMatrix&											transform,
-                                   const ::drafts::com::sun::star::rendering::ViewState&			viewState );
+                                   const ::com::sun::star::rendering::ViewState&			viewState );
         
-        ::drafts::com::sun::star::rendering::ViewState&
-        	setViewStateTransform( ::drafts::com::sun::star::rendering::ViewState& 					viewState,
+        ::com::sun::star::rendering::ViewState&
+        	setViewStateTransform( ::com::sun::star::rendering::ViewState& 					viewState,
                                    const ::basegfx::B2DHomMatrix&									transform );
         
         ::basegfx::B2DHomMatrix& 
         	getRenderStateTransform( ::basegfx::B2DHomMatrix&										transform,
-                                     const ::drafts::com::sun::star::rendering::RenderState&		renderState );
+                                     const ::com::sun::star::rendering::RenderState&		renderState );
         
-        ::drafts::com::sun::star::rendering::RenderState& 
-        	setRenderStateTransform( ::drafts::com::sun::star::rendering::RenderState& 				renderState,
+        ::com::sun::star::rendering::RenderState& 
+        	setRenderStateTransform( ::com::sun::star::rendering::RenderState& 				renderState,
                                      const ::basegfx::B2DHomMatrix&									transform );
         
-        ::drafts::com::sun::star::rendering::ViewState& 
-        	appendToViewState( ::drafts::com::sun::star::rendering::ViewState&						viewState,
+        ::com::sun::star::rendering::ViewState& 
+        	appendToViewState( ::com::sun::star::rendering::ViewState&						viewState,
                                const ::basegfx::B2DHomMatrix&										transform );
         
-        ::drafts::com::sun::star::rendering::RenderState& 
-        	appendToRenderState( ::drafts::com::sun::star::rendering::RenderState&					renderState,
+        ::com::sun::star::rendering::RenderState& 
+        	appendToRenderState( ::com::sun::star::rendering::RenderState&					renderState,
                                  const ::basegfx::B2DHomMatrix&										transform );
         
-        ::drafts::com::sun::star::rendering::ViewState& 
-        	prependToViewState( ::drafts::com::sun::star::rendering::ViewState&						viewState,
+        ::com::sun::star::rendering::ViewState& 
+        	prependToViewState( ::com::sun::star::rendering::ViewState&						viewState,
                                 const ::basegfx::B2DHomMatrix&										transform );
         
-        ::drafts::com::sun::star::rendering::RenderState& 
-        	prependToRenderState( ::drafts::com::sun::star::rendering::RenderState&					renderState,
+        ::com::sun::star::rendering::RenderState& 
+        	prependToRenderState( ::com::sun::star::rendering::RenderState&					renderState,
                                   const ::basegfx::B2DHomMatrix&									transform );
 
         ::basegfx::B2DHomMatrix& 
         	mergeViewAndRenderTransform( ::basegfx::B2DHomMatrix&									transform,
-                                         const ::drafts::com::sun::star::rendering::ViewState&		viewState,
-                                         const ::drafts::com::sun::star::rendering::RenderState&	renderState );
+                                         const ::com::sun::star::rendering::ViewState&		viewState,
+                                         const ::com::sun::star::rendering::RenderState&	renderState );
 
-        ::drafts::com::sun::star::rendering::ViewState& 
-	        mergeViewAndRenderState( ::drafts::com::sun::star::rendering::ViewState&				resultViewState,
-                                     const ::drafts::com::sun::star::rendering::ViewState&			viewState,
-                                     const ::drafts::com::sun::star::rendering::RenderState&		renderState,
+        ::com::sun::star::rendering::ViewState& 
+	        mergeViewAndRenderState( ::com::sun::star::rendering::ViewState&				resultViewState,
+                                     const ::com::sun::star::rendering::ViewState&			viewState,
+                                     const ::com::sun::star::rendering::RenderState&		renderState,
                                      const ::com::sun::star::uno::Reference< 
-                                     	::drafts::com::sun::star::rendering::XCanvas > 				xCanvas );
+                                     	::com::sun::star::rendering::XCanvas > 				xCanvas );
 
-        bool operator==( const ::drafts::com::sun::star::rendering::RenderState&					rLHS,
-                         const ::drafts::com::sun::star::rendering::RenderState& 					rRHS );
+        bool operator==( const ::com::sun::star::rendering::RenderState&					rLHS,
+                         const ::com::sun::star::rendering::RenderState& 					rRHS );
 
-        bool operator==( const ::drafts::com::sun::star::rendering::ViewState&						rLHS,
-                         const ::drafts::com::sun::star::rendering::ViewState& 						rRHS );
+        bool operator==( const ::com::sun::star::rendering::ViewState&						rLHS,
+                         const ::com::sun::star::rendering::ViewState& 						rRHS );
 
 
         // Matrix utilities
         // ===================================================================
 
-        ::drafts::com::sun::star::geometry::AffineMatrix2D& 
-        	setIdentityAffineMatrix2D( ::drafts::com::sun::star::geometry::AffineMatrix2D&	matrix );
+        ::com::sun::star::geometry::AffineMatrix2D& 
+        	setIdentityAffineMatrix2D( ::com::sun::star::geometry::AffineMatrix2D&	matrix );
 
-        ::drafts::com::sun::star::geometry::Matrix2D& 
-        	setIdentityMatrix2D( ::drafts::com::sun::star::geometry::Matrix2D&			    matrix );
+        ::com::sun::star::geometry::Matrix2D& 
+        	setIdentityMatrix2D( ::com::sun::star::geometry::Matrix2D&			    matrix );
 
 
         // Special utilities
@@ -220,6 +220,8 @@
             Transformation to apply to the input rectangle
 
             @see calcRectToRectTransform()
+
+            @return a reference to the resulting rectangle
          */
         ::basegfx::B2DRange& calcTransformedRectBounds( ::basegfx::B2DRange&			o_Rect,
                                                         const ::basegfx::B2DRange&		i_Rect,
@@ -367,7 +369,7 @@
             @return A reference to the resulting sequence of parameters
 		*/
 		::com::sun::star::uno::Sequence< ::com::sun::star::uno::Any >& getDeviceInfo( 
-			const ::com::sun::star::uno::Reference< ::drafts::com::sun::star::rendering::XCanvas >& i_rxCanvas,
+			const ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XCanvas >& i_rxCanvas,
 			::com::sun::star::uno::Sequence< ::com::sun::star::uno::Any >& o_rxParams );
     }
 }
diff -u -r  canvas/inc/canvas/elapsedtime.hxx  canvas/inc/canvas/elapsedtime.hxx
---  canvas/inc/canvas/elapsedtime.hxx	2004-11-26 22:32:42.000000000 +0530
+++  canvas/inc/canvas/elapsedtime.hxx	2005-02-28 13:41:07.258691160 +0530
@@ -66,11 +66,17 @@
 #include <sal/types.h>
 #endif
 
+#include "boost/shared_ptr.hpp"
+
 namespace canvas
 {
     namespace tools
     {
-        /** Calculate elapsed time
+        /** Calculate elapsed time.
+
+        	This class provides several time-measurement and
+        	-management functions. In its simplest use-case, it
+        	measures the time from its creation.
          */
         class ElapsedTime
         {
@@ -84,6 +90,22 @@
              */
             ElapsedTime();
 
+            /** Creates a new ElapsedTime object based on another
+                timer.
+
+				The moment of construction starts the time
+				measurement. That means, a subsequent getElapsedTime()
+				call will return the time difference between object
+				creation and getElapsedTime() call. All time values
+				are not taken from the system's time base, but from
+				the provided timer.
+             */
+            ElapsedTime( ::boost::shared_ptr<ElapsedTime> const & pTimeBase );
+
+            /** Gets this timer's base timer.
+             */
+            ::boost::shared_ptr<ElapsedTime> const & getTimeBase() const;
+            
             /** Reset the time
 
 				The instance of the reset() call starts the time
@@ -97,15 +119,97 @@
 
             	This method returns the elapsed time in seconds
             	between either the construction of this object, or the
-            	last reset() call, if any.
+            	last reset() call, if any (but see the time modulation
+            	methods below, for means to modify the otherwise
+            	continuous flow of time).
 
                 @return the elapsed time in seconds.
              */            
             double getElapsedTime() const;
+            
+            /** Pauses the running timer.
+
+            	This method stops the time, as returned by this
+            	object, until continueTimer() is called. During this
+            	period, getElapsedTime() will always return the same
+            	time value (i.e. the instant when pauseTimer() was
+            	called).
+             */
+            void pauseTimer();
+            
+            /** Continues the paused timer.  
+
+            	This method re-enables the time flow, that is, time
+            	starts running again for clients calling
+            	getElapsedTime(). The (subtle) difference to the
+            	holdTimer/releaseTimer() methods below is, that there
+            	is no perceived time 'jump' between the pauseTimer()
+            	call and the continueTimer() call, i.e. the time
+            	starts over with the same value it has stopped on
+            	pauseTimer().
+             */
+            void continueTimer();
+                        
+            /** Adjusts the timer, hold and pause times.
+
+            	This method modifies the time as returned by this
+            	object by the specified amount. This affects the time
+            	as returned by getElapsedTime(), regardless of the
+            	mode (e.g. paused, or on hold).
+
+                @param fOffset 
+                This value will be added to the current time, i.e. the
+                next call to getElapsedTime() (when performed
+                immediately) will be adjusted by fOffset.
+
+                @param bLimitToLastQueriedTime 
+                Limits the given offset to the time that has been
+                taken via getElapsedTime()
+            */
+            void adjustTimer( double fOffset,
+                              bool bLimitToLastQueriedTime = true );
+            
+            /** Holds the current time.
+
+            	This call makes the timer hold the current time
+            	(e.g. getElapsedTime() will return the time when
+            	holdTimer() was called), while the underlying time is
+            	running on. When releaseTimer() is called, the time
+            	will 'jump' to the then-current, underlying time. This
+            	is equivalent to pressing the "interim time" button on
+            	a stop watch, which shows this stopped time, while the
+            	clock keeps running internally.
+            */
+            void holdTimer();
+            
+            /** Releases a held timer.
 
+				After this call, the timer again returns the running
+				time on getElapsedTime().
+             */
+            void releaseTimer();
+            
         private:
-            sal_uInt64 	mnStartTime;	// implementation-dependent start time representation
-            double		mfTimeFactor;	// correction factor to get the time in seconds from mnStartTime
+            static double getSystemTime();
+            double getCurrentTime() const;
+            double getElapsedTimeImpl() const; // does not set m_fLastQueriedTime
+
+            const ::boost::shared_ptr<ElapsedTime>	m_pTimeBase;
+            
+            /// To validate adjustTimer() calls with bLimitToLastQueriedTime=true
+            mutable double 							m_fLastQueriedTime;
+
+            /// Start time, from which the difference to the time base is returned
+            double 									m_fStartTime;
+
+            /// Instant, when last pause or hold started, relative to m_fStartTime 
+            double 									m_fFrozenTime;
+
+            /// True, when in pause mode
+            bool									m_bInPauseMode;
+
+            /// True, when in hold mode
+            bool									m_bInHoldMode;
         };
 
     }
diff -u -r  canvas/inc/canvas/linepolypolygonbase.hxx  canvas/inc/canvas/linepolypolygonbase.hxx
---  canvas/inc/canvas/linepolypolygonbase.hxx	2004-11-26 22:32:52.000000000 +0530
+++  canvas/inc/canvas/linepolypolygonbase.hxx	2005-02-28 13:41:07.200697936 +0530
@@ -75,8 +75,8 @@
 #include <comphelper/broadcasthelper.hxx>
 #endif
 
-#ifndef _DRAFTS_COM_SUN_STAR_RENDERING_XLINEPOLYPOLYGON2D_HPP_
-#include <drafts/com/sun/star/rendering/XLinePolyPolygon2D.hpp>
+#ifndef _COM_SUN_STAR_RENDERING_XLINEPOLYPOLYGON2D_HPP_
+#include <com/sun/star/rendering/XLinePolyPolygon2D.hpp>
 #endif
 
 #ifndef _BGFX_POLYGON_B2DPOLYPOLYGON_HXX
@@ -88,7 +88,7 @@
     namespace tools
     {
 		typedef ::cppu::WeakComponentImplHelper2< 
-			::drafts::com::sun::star::rendering::XLinePolyPolygon2D,
+			::com::sun::star::rendering::XLinePolyPolygon2D,
             ::com::sun::star::lang::XServiceInfo > LinePolyPolygon_Base;
 
 		class LinePolyPolygonBase : public ::comphelper::OBaseMutex, public LinePolyPolygon_Base
@@ -97,19 +97,19 @@
 			explicit LinePolyPolygonBase( const ::basegfx::B2DPolyPolygon& );
 
 			// XPolyPolygon2D
-			virtual void SAL_CALL addPolyPolygon( const ::drafts::com::sun::star::geometry::RealPoint2D& position, const ::com::sun::star::uno::Reference< ::drafts::com::sun::star::rendering::XPolyPolygon2D >& polyPolygon ) throw (::com::sun::star::uno::RuntimeException);
+			virtual void SAL_CALL addPolyPolygon( const ::com::sun::star::geometry::RealPoint2D& position, const ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XPolyPolygon2D >& polyPolygon ) throw (::com::sun::star::uno::RuntimeException);
 			virtual sal_Int32 SAL_CALL getNumberOfPolygons(  ) throw (::com::sun::star::uno::RuntimeException);
 			virtual sal_Int32 SAL_CALL getNumberOfPolygonPoints( sal_Int32 polygon ) throw (::com::sun::star::uno::RuntimeException);
-			virtual ::drafts::com::sun::star::rendering::FillRule SAL_CALL getFillRule(  ) throw (::com::sun::star::uno::RuntimeException);
-			virtual void SAL_CALL setFillRule( ::drafts::com::sun::star::rendering::FillRule fillRule ) throw (::com::sun::star::uno::RuntimeException);
+			virtual ::com::sun::star::rendering::FillRule SAL_CALL getFillRule(  ) throw (::com::sun::star::uno::RuntimeException);
+			virtual void SAL_CALL setFillRule( ::com::sun::star::rendering::FillRule fillRule ) throw (::com::sun::star::uno::RuntimeException);
 			virtual sal_Bool SAL_CALL isClosed( sal_Int32 index ) throw (::com::sun::star::uno::RuntimeException);
 			virtual void SAL_CALL setClosed( sal_Int32 index, sal_Bool closedState ) throw (::com::sun::star::uno::RuntimeException);
 
 			// XLinePolyPolygon2D
-			virtual ::com::sun::star::uno::Sequence< ::com::sun::star::uno::Sequence< ::drafts::com::sun::star::geometry::RealPoint2D > > SAL_CALL getPoints( sal_Int32 nPolygonIndex, sal_Int32 nNumberOfPolygons, sal_Int32 nPointIndex, sal_Int32 nNumberOfPoints ) throw (::com::sun::star::uno::RuntimeException);
-			virtual void SAL_CALL setPoints( const ::com::sun::star::uno::Sequence< ::com::sun::star::uno::Sequence< ::drafts::com::sun::star::geometry::RealPoint2D > >& points, sal_Int32 nPolygonIndex, sal_Int32 nPointIndex ) throw (::com::sun::star::uno::RuntimeException);
-			virtual ::drafts::com::sun::star::geometry::RealPoint2D SAL_CALL getPoint( sal_Int32 nPolygonIndex, sal_Int32 nPointIndex ) throw (::com::sun::star::uno::RuntimeException);
-			virtual void SAL_CALL setPoint( const ::drafts::com::sun::star::geometry::RealPoint2D& point, sal_Int32 nPolygonIndex, sal_Int32 nPointIndex ) throw (::com::sun::star::uno::RuntimeException);
+			virtual ::com::sun::star::uno::Sequence< ::com::sun::star::uno::Sequence< ::com::sun::star::geometry::RealPoint2D > > SAL_CALL getPoints( sal_Int32 nPolygonIndex, sal_Int32 nNumberOfPolygons, sal_Int32 nPointIndex, sal_Int32 nNumberOfPoints ) throw (::com::sun::star::uno::RuntimeException);
+			virtual void SAL_CALL setPoints( const ::com::sun::star::uno::Sequence< ::com::sun::star::uno::Sequence< ::com::sun::star::geometry::RealPoint2D > >& points, sal_Int32 nPolygonIndex, sal_Int32 nPointIndex ) throw (::com::sun::star::uno::RuntimeException);
+			virtual ::com::sun::star::geometry::RealPoint2D SAL_CALL getPoint( sal_Int32 nPolygonIndex, sal_Int32 nPointIndex ) throw (::com::sun::star::uno::RuntimeException);
+			virtual void SAL_CALL setPoint( const ::com::sun::star::geometry::RealPoint2D& point, sal_Int32 nPolygonIndex, sal_Int32 nPointIndex ) throw (::com::sun::star::uno::RuntimeException);
 
 	        ::basegfx::B2DPolyPolygon getPolyPolygon() const;
 

diff -u -r  canvas/prj/d.lst  canvas/prj/d.lst
---  canvas/prj/d.lst	2004-11-26 22:33:55.000000000 +0530
+++  canvas/prj/d.lst	2005-02-28 13:41:07.339681696 +0530
@@ -13,6 +13,7 @@
 ..\inc\canvas\linepolypolygonbase.hxx %_DEST%\inc%_EXT%\canvas\linepolypolygonbase.hxx
 ..\inc\canvas\redrawmanagement.hxx %_DEST%\inc%_EXT%\canvas\redrawmanagement.hxx
 ..\inc\canvas\canvastools.hxx %_DEST%\inc%_EXT%\canvas\canvastools.hxx
+..\inc\canvas\prioritybooster.hxx %_DEST%\inc%_EXT%\canvas\prioritybooster.hxx
 ..\inc\canvas\debug.hxx %_DEST%\inc%_EXT%\canvas\debug.hxx
 ..\inc\canvas\elapsedtime.hxx %_DEST%\inc%_EXT%\canvas\elapsedtime.hxx
 ..\inc\canvas\vclwrapper.hxx %_DEST%\inc%_EXT%\canvas\vclwrapper.hxx
diff -u -r  canvas/source/factory/cf_service.cxx  canvas/source/factory/cf_service.cxx
---  canvas/source/factory/cf_service.cxx	2004-11-26 22:34:16.000000000 +0530
+++  canvas/source/factory/cf_service.cxx	2005-02-28 13:41:08.360562408 +0530
@@ -82,12 +82,12 @@
 
 OUString SAL_CALL getImplName()
 {
-    return OUSTR("drafts.com.sun.star.comp.rendering.CanvasFactory");
+    return OUSTR("com.sun.star.comp.rendering.CanvasFactory");
 }
 
 Sequence<OUString> SAL_CALL getSuppServices()
 {
-    OUString name = OUSTR("drafts.com.sun.star.rendering.CanvasFactory");
+    OUString name = OUSTR("com.sun.star.rendering.CanvasFactory");
     return Sequence<OUString>(&name, 1);
 }
 
@@ -102,7 +102,7 @@
     Sequence<OUString> m_services;
     OUString m_serviceName;
     Reference<lang::XSingleComponentFactory> m_xFactory;
-    
+
     Reference<XInterface> use(
         Reference<lang::XSingleComponentFactory> const & xFactory,
         Sequence<Any> const & args,
@@ -110,18 +110,18 @@
     Reference<XInterface> lookupAndUse(
         OUString const & serviceName, Sequence<Any> const & args,
         Reference<XComponentContext> const & xContext );
-    
+
 public:
     virtual ~CanvasFactory();
     CanvasFactory( Reference<XComponentContext> const & xContext );
-    
+
     // XServiceInfo
     virtual OUString SAL_CALL getImplementationName() throw (RuntimeException);
     virtual sal_Bool SAL_CALL supportsService( OUString const & serviceName )
         throw (RuntimeException);
     virtual Sequence<OUString> SAL_CALL getSupportedServiceNames()
         throw (RuntimeException);
-    
+
     // XMultiComponentFactory
     virtual Sequence<OUString> SAL_CALL getAvailableServiceNames()
         throw (RuntimeException);
@@ -173,17 +173,17 @@
     catch (Exception & exc) {
         (void) exc;
     }
-    
+
     // append the usual preferred ones:
     sal_Int32 pos = m_services.getLength();
 #if defined WNT
     m_services.realloc( pos + 3 );
-    m_services[ pos++ ] = OUSTR("drafts.com.sun.star.rendering.DXCanvas");
+    m_services[ pos++ ] = OUSTR("com.sun.star.rendering.DXCanvas");
 #else
     m_services.realloc( pos + 2 );
 #endif
-    m_services[ pos++ ] = OUSTR("drafts.com.sun.star.rendering.JavaCanvas");
-    m_services[ pos   ] = OUSTR("drafts.com.sun.star.rendering.VCLCanvas");
+    m_services[ pos++ ] = OUSTR("com.sun.star.rendering.JavaCanvas");
+    m_services[ pos   ] = OUSTR("com.sun.star.rendering.VCLCanvas");
 }
 
 CanvasFactory::~CanvasFactory()
@@ -267,7 +267,7 @@
                 return xCanvas;
         }
     }
-    
+
     Reference<container::XContentEnumerationAccess> xEnumAccess(
         // use service manager of factory:
         m_xContext->getServiceManager(), UNO_QUERY_THROW );
@@ -291,7 +291,7 @@
             }
         }
     }
-    
+
     return Reference<XInterface>();
 }
 
@@ -307,7 +307,7 @@
         if (xCanvas.is())
             return xCanvas;
     }
-    
+
     {
         // try to reuse previously installed factory:
         ::osl::ClearableMutexGuard guard(m_mutex);
@@ -319,7 +319,7 @@
                 return xCanvas;
         }
     }
-    
+
     // try configured ones:
     OUString const * pservices = m_services.getConstArray();
     sal_Int32 pos = 0, len = m_services.getLength();
@@ -329,7 +329,7 @@
         if (xCanvas.is())
             return xCanvas;
     }
-    
+
     OSL_ENSURE( 0, "### no canvas available!?" );
     return Reference<XInterface>();
 }
diff -u -r  canvas/source/java/BackBuffer.java  canvas/source/java/BackBuffer.java
---  canvas/source/java/BackBuffer.java	2004-03-18 16:08:28.000000000 +0530
+++  canvas/source/java/BackBuffer.java	2005-02-28 13:41:08.005603884 +0530
@@ -67,7 +67,7 @@
 import com.sun.star.awt.*;
 
 // Canvas
-import drafts.com.sun.star.rendering.*;
+import com.sun.star.rendering.*;
 
 // Java AWT
 import java.awt.*;
diff -u -r  canvas/source/java/BezierPolyPolygon.java  canvas/source/java/BezierPolyPolygon.java
---  canvas/source/java/BezierPolyPolygon.java	2004-03-18 16:08:28.000000000 +0530
+++  canvas/source/java/BezierPolyPolygon.java	2005-02-28 13:41:08.069596407 +0530
@@ -58,15 +58,15 @@
 // UNO
 import com.sun.star.uno.UnoRuntime;
 import com.sun.star.uno.XComponentContext;
-import com.sun.star.uno.AnyConverter; 
+import com.sun.star.uno.AnyConverter;
 import com.sun.star.lib.uno.helper.WeakBase;
 
 // OOo AWT
 import com.sun.star.awt.*;
 
 // Canvas
-import drafts.com.sun.star.rendering.*;
-import drafts.com.sun.star.geometry.*;
+import com.sun.star.rendering.*;
+import com.sun.star.geometry.*;
 
 // system-dependent stuff
 import sun.awt.*;
@@ -74,8 +74,8 @@
 
 public class BezierPolyPolygon
     extends com.sun.star.lib.uno.helper.ComponentBase
-    implements com.sun.star.lang.XServiceInfo, 
-			   drafts.com.sun.star.rendering.XBezierPolyPolygon2D
+    implements com.sun.star.lang.XServiceInfo,
+			   com.sun.star.rendering.XBezierPolyPolygon2D
 {
     private java.awt.geom.GeneralPath path;
 
@@ -144,7 +144,7 @@
     // XBezierPolyPolygon implementation
     // =================================
     //
-    public RealBezierSegment2D[][] getPoints( int nPolygonIndex, int nNumberOfPolygons, int nPointIndex, int nNumberOfPoints ) 
+    public RealBezierSegment2D[][] getPoints( int nPolygonIndex, int nNumberOfPolygons, int nPointIndex, int nNumberOfPoints )
     {
         return null;
     }
@@ -166,7 +166,7 @@
     {
         CanvasUtils.printLog( "LinePolyPolygon.setPoint: not yet implemented!" );
     }
-    
+
     //----------------------------------------------------------------------------------
 
     //
@@ -175,18 +175,18 @@
     //
 
     private static final String s_implName = "XBezierPolyPolygon2D.java.impl";
-    private static final String s_serviceName = "drafts.com.sun.star.rendering.BezierPolyPolygon2D";
-    
+    private static final String s_serviceName = "com.sun.star.rendering.BezierPolyPolygon2D";
+
     public String getImplementationName()
     {
         return s_implName;
     }
-    
+
     public String [] getSupportedServiceNames()
     {
         return new String [] { s_serviceName };
     }
-    
+
     public boolean supportsService( String serviceName )
     {
         return serviceName.equals( s_serviceName );
diff -u -r  canvas/source/java/BitmapCanvas.java  canvas/source/java/BitmapCanvas.java
---  canvas/source/java/BitmapCanvas.java	2004-03-18 16:08:28.000000000 +0530
+++  canvas/source/java/BitmapCanvas.java	2005-02-28 13:41:08.174584139 +0530
@@ -67,8 +67,8 @@
 import com.sun.star.awt.*;
 
 // Canvas
-import drafts.com.sun.star.rendering.*;
-import drafts.com.sun.star.geometry.*;
+import com.sun.star.rendering.*;
+import com.sun.star.geometry.*;
 
 // Java AWT
 import java.awt.*;
@@ -81,7 +81,7 @@
 
 public class BitmapCanvas
     extends CanvasBase
-    implements drafts.com.sun.star.rendering.XBitmapCanvas,
+    implements com.sun.star.rendering.XBitmapCanvas,
                com.sun.star.lang.XServiceInfo
 {
     private Graphics2D	graphics;
@@ -105,13 +105,13 @@
     // ==================
     //
 
-    public synchronized void copyRect( drafts.com.sun.star.rendering.XBitmapCanvas	sourceCanvas,
-                                       drafts.com.sun.star.geometry.RealRectangle2D sourceRect, 
-                                       drafts.com.sun.star.rendering.ViewState 		sourceViewState, 
-                                       drafts.com.sun.star.rendering.RenderState 	sourceRenderState,
-                                       drafts.com.sun.star.geometry.RealRectangle2D	destRect, 
-                                       drafts.com.sun.star.rendering.ViewState 		destViewState, 
-                                       drafts.com.sun.star.rendering.RenderState 	destRenderState )
+    public synchronized void copyRect( com.sun.star.rendering.XBitmapCanvas	sourceCanvas,
+                                       com.sun.star.geometry.RealRectangle2D sourceRect, 
+                                       com.sun.star.rendering.ViewState 		sourceViewState, 
+                                       com.sun.star.rendering.RenderState 	sourceRenderState,
+                                       com.sun.star.geometry.RealRectangle2D	destRect, 
+                                       com.sun.star.rendering.ViewState 		destViewState, 
+                                       com.sun.star.rendering.RenderState 	destRenderState )
     {
         // TODO: create temp image when transform is non-trivial
 
@@ -145,7 +145,7 @@
     //----------------------------------------------------------------------------------
 
     private static final String s_implName = "XBitmapCanvas.java.impl";
-    private static final String s_serviceName = "drafts.com.sun.star.rendering.BitmapCanvas";
+    private static final String s_serviceName = "com.sun.star.rendering.BitmapCanvas";
     
     //----------------------------------------------------------------------------------
 
diff -u -r  canvas/source/java/CanvasBase.java  canvas/source/java/CanvasBase.java
---  canvas/source/java/CanvasBase.java	2004-11-26 22:34:53.000000000 +0530
+++  canvas/source/java/CanvasBase.java	2005-02-28 13:41:07.997604819 +0530
@@ -67,8 +67,8 @@
 import com.sun.star.awt.*;
 
 // Canvas
-import drafts.com.sun.star.rendering.*;
-import drafts.com.sun.star.geometry.*;
+import com.sun.star.rendering.*;
+import com.sun.star.geometry.*;
 
 // Java AWT
 import java.awt.*;
@@ -80,7 +80,7 @@
 
 public abstract class CanvasBase
     extends com.sun.star.lib.uno.helper.ComponentBase
-    implements drafts.com.sun.star.rendering.XCanvas
+    implements com.sun.star.rendering.XCanvas
 {
     // to be overridden
     public abstract Graphics2D getGraphics();
@@ -230,23 +230,23 @@
                                                                          ViewState 									viewState,
                                                                          RenderState 								renderState,
                                                                          Texture[] 									textures, 
-                                                                         drafts.com.sun.star.geometry.XMapping2D 	xMapping,
+                                                                         com.sun.star.geometry.XMapping2D 	xMapping,
                                                                          StrokeAttributes 							strokeAttributes ) throws com.sun.star.lang.IllegalArgumentException, VolatileContentDestroyedException
     {
         return null;
     }
 
-	public synchronized XPolyPolygon2D queryStrokeShapes( drafts.com.sun.star.rendering.XPolyPolygon2D   xPolyPolygon, 
-                                                          drafts.com.sun.star.rendering.ViewState        viewState,
-                                                          drafts.com.sun.star.rendering.RenderState      renderState, 
-                                                          drafts.com.sun.star.rendering.StrokeAttributes strokeAttributes ) throws com.sun.star.lang.IllegalArgumentException
+	public synchronized XPolyPolygon2D queryStrokeShapes( com.sun.star.rendering.XPolyPolygon2D   xPolyPolygon, 
+                                                          com.sun.star.rendering.ViewState        viewState,
+                                                          com.sun.star.rendering.RenderState      renderState, 
+                                                          com.sun.star.rendering.StrokeAttributes strokeAttributes ) throws com.sun.star.lang.IllegalArgumentException
     {
         return null;
     }
 
-	public synchronized XCachedPrimitive fillPolyPolygon( drafts.com.sun.star.rendering.XPolyPolygon2D xPolyPolygon,
-                                                          drafts.com.sun.star.rendering.ViewState      viewState,
-                                                          drafts.com.sun.star.rendering.RenderState    renderState ) throws com.sun.star.lang.IllegalArgumentException
+	public synchronized XCachedPrimitive fillPolyPolygon( com.sun.star.rendering.XPolyPolygon2D xPolyPolygon,
+                                                          com.sun.star.rendering.ViewState      viewState,
+                                                          com.sun.star.rendering.RenderState    renderState ) throws com.sun.star.lang.IllegalArgumentException
     {
         CanvasUtils.printLog( "CanvasBase.fillPolyPolygon() called" );
 
@@ -264,10 +264,10 @@
         return null;
     }
 
-	public synchronized XCachedPrimitive fillTexturedPolyPolygon( drafts.com.sun.star.rendering.XPolyPolygon2D    xPolyPolygon, 
-                                                                  drafts.com.sun.star.rendering.ViewState         viewState,
-                                                                  drafts.com.sun.star.rendering.RenderState       renderState, 
-                                                                  drafts.com.sun.star.rendering.Texture []        textures ) throws com.sun.star.lang.IllegalArgumentException
+	public synchronized XCachedPrimitive fillTexturedPolyPolygon( com.sun.star.rendering.XPolyPolygon2D    xPolyPolygon, 
+                                                                  com.sun.star.rendering.ViewState         viewState,
+                                                                  com.sun.star.rendering.RenderState       renderState, 
+                                                                  com.sun.star.rendering.Texture []        textures ) throws com.sun.star.lang.IllegalArgumentException
     {
         return null;
     }
@@ -276,12 +276,12 @@
                                                                        ViewState 								viewState, 
                                                                        RenderState 								renderState, 
                                                                        Texture[] 								textures, 
-                                                                       drafts.com.sun.star.geometry.XMapping2D 	xMapping ) throws com.sun.star.lang.IllegalArgumentException, VolatileContentDestroyedException
+                                                                       com.sun.star.geometry.XMapping2D 	xMapping ) throws com.sun.star.lang.IllegalArgumentException, VolatileContentDestroyedException
     {
         return null;
     }
 
-    public synchronized XCanvasFont createFont( FontRequest fontRequest, com.sun.star.beans.PropertyValue[] extraFontProperties, drafts.com.sun.star.geometry.Matrix2D fontMatrix ) throws com.sun.star.lang.IllegalArgumentException
+    public synchronized XCanvasFont createFont( FontRequest fontRequest, com.sun.star.beans.PropertyValue[] extraFontProperties, com.sun.star.geometry.Matrix2D fontMatrix ) throws com.sun.star.lang.IllegalArgumentException
     {
         // TODO: support extra arguments
         return new CanvasFont( fontRequest, this );
@@ -338,9 +338,9 @@
         return null;
     }
 
-	public synchronized XCachedPrimitive drawBitmap( drafts.com.sun.star.rendering.XBitmap   	xBitmap, 
-                                                     drafts.com.sun.star.rendering.ViewState 	viewState, 
-                                                     drafts.com.sun.star.rendering.RenderState 	renderState ) throws com.sun.star.lang.IllegalArgumentException
+	public synchronized XCachedPrimitive drawBitmap( com.sun.star.rendering.XBitmap   	xBitmap, 
+                                                     com.sun.star.rendering.ViewState 	viewState, 
+                                                     com.sun.star.rendering.RenderState 	renderState ) throws com.sun.star.lang.IllegalArgumentException
     {
         CanvasUtils.printLog( "CanvasBase.drawBitmap() called" );
 
@@ -359,9 +359,9 @@
         return null;
     }
 
-	public synchronized XCachedPrimitive drawBitmapModulated( drafts.com.sun.star.rendering.XBitmap   	xBitmap, 
-                                                              drafts.com.sun.star.rendering.ViewState 	viewState, 
-                                                              drafts.com.sun.star.rendering.RenderState renderState ) throws com.sun.star.lang.IllegalArgumentException
+	public synchronized XCachedPrimitive drawBitmapModulated( com.sun.star.rendering.XBitmap   	xBitmap, 
+                                                              com.sun.star.rendering.ViewState 	viewState, 
+                                                              com.sun.star.rendering.RenderState renderState ) throws com.sun.star.lang.IllegalArgumentException
     {
         CanvasUtils.printLog( "CanvasBase.drawBitmapModulated() called" );
 
diff -u -r  canvas/source/java/CanvasBitmap.java  canvas/source/java/CanvasBitmap.java
---  canvas/source/java/CanvasBitmap.java	2004-11-26 22:35:05.000000000 +0530
+++  canvas/source/java/CanvasBitmap.java	2005-02-28 13:41:08.067596640 +0530
@@ -65,14 +65,14 @@
 import com.sun.star.awt.*;
 
 // Canvas
-import drafts.com.sun.star.rendering.*;
-import drafts.com.sun.star.geometry.*;
+import com.sun.star.rendering.*;
+import com.sun.star.geometry.*;
 
 public class CanvasBitmap
     extends CanvasBase
     implements com.sun.star.lang.XServiceInfo, 
-			   drafts.com.sun.star.rendering.XBitmapCanvas,
-			   drafts.com.sun.star.rendering.XIntegerBitmap
+			   com.sun.star.rendering.XBitmapCanvas,
+			   com.sun.star.rendering.XIntegerBitmap
 {
     private java.awt.image.BufferedImage 	bitmap;
     private java.awt.Graphics2D				graphics;
@@ -138,7 +138,7 @@
 
     //----------------------------------------------------------------------------------
 
-    public synchronized drafts.com.sun.star.rendering.XBitmap getScaledBitmap( RealSize2D newSize, boolean beFast ) throws com.sun.star.lang.IllegalArgumentException, VolatileContentDestroyedException
+    public synchronized com.sun.star.rendering.XBitmap getScaledBitmap( RealSize2D newSize, boolean beFast ) throws com.sun.star.lang.IllegalArgumentException, VolatileContentDestroyedException
     {
         return new CanvasBitmap( newSize, beFast, this );
     }
@@ -150,13 +150,13 @@
     // ==================
     //
 
-    public synchronized void copyRect( drafts.com.sun.star.rendering.XBitmapCanvas	sourceCanvas,
-                                       drafts.com.sun.star.geometry.RealRectangle2D sourceRect, 
-                                       drafts.com.sun.star.rendering.ViewState 		sourceViewState, 
-                                       drafts.com.sun.star.rendering.RenderState 	sourceRenderState,
-                                       drafts.com.sun.star.geometry.RealRectangle2D	destRect, 
-                                       drafts.com.sun.star.rendering.ViewState 		destViewState, 
-                                       drafts.com.sun.star.rendering.RenderState 	destRenderState )
+    public synchronized void copyRect( com.sun.star.rendering.XBitmapCanvas	sourceCanvas,
+                                       com.sun.star.geometry.RealRectangle2D sourceRect, 
+                                       com.sun.star.rendering.ViewState 		sourceViewState, 
+                                       com.sun.star.rendering.RenderState 	sourceRenderState,
+                                       com.sun.star.geometry.RealRectangle2D	destRect, 
+                                       com.sun.star.rendering.ViewState 		destViewState, 
+                                       com.sun.star.rendering.RenderState 	destRenderState )
     {
         CanvasUtils.printLog( "JavaCanvas.copyRect() called" );
 
@@ -205,7 +205,7 @@
 
     //----------------------------------------------------------------------------------
 
-    public synchronized void setData( byte[] data, IntegerBitmapLayout bitmapLayout, drafts.com.sun.star.geometry.IntegerRectangle2D rect )
+    public synchronized void setData( byte[] data, IntegerBitmapLayout bitmapLayout, com.sun.star.geometry.IntegerRectangle2D rect )
     {
         int [] pixelData = CanvasUtils.byte2int( data );
         bitmap.setRGB( rect.X1, rect.Y1, rect.X2 - rect.X1, rect.Y2 - rect.Y1, pixelData, 0, bitmap.getWidth() );
@@ -213,7 +213,7 @@
 
     //----------------------------------------------------------------------------------
 
-    public synchronized void setPixel( byte[] color, IntegerBitmapLayout bitmapLayout, drafts.com.sun.star.geometry.IntegerPoint2D pos )
+    public synchronized void setPixel( byte[] color, IntegerBitmapLayout bitmapLayout, com.sun.star.geometry.IntegerPoint2D pos )
     {
         if( color.length != 4 )
             CanvasUtils.printLog( "CanvasBitmap.setPixel: Wrong color format" );
@@ -271,7 +271,7 @@
     //
 
     private static final String s_implName = "XIntegerBitmap.java.impl";
-    private static final String s_serviceName = "drafts.com.sun.star.rendering.IntegerBitmap";
+    private static final String s_serviceName = "com.sun.star.rendering.IntegerBitmap";
     
     public String getImplementationName()
     {
diff -u -r  canvas/source/java/CanvasClonedSprite.java  canvas/source/java/CanvasClonedSprite.java
---  canvas/source/java/CanvasClonedSprite.java	2004-11-26 22:35:18.000000000 +0530
+++  canvas/source/java/CanvasClonedSprite.java	2005-02-28 13:41:07.964608674 +0530
@@ -67,8 +67,8 @@
 import com.sun.star.awt.*;
 
 // Canvas
-import drafts.com.sun.star.rendering.*;
-import drafts.com.sun.star.geometry.*;
+import com.sun.star.rendering.*;
+import com.sun.star.geometry.*;
 
 // Java AWT
 import java.awt.*;
@@ -80,7 +80,7 @@
 
 public class CanvasClonedSprite
     extends com.sun.star.lib.uno.helper.ComponentBase
-    implements drafts.com.sun.star.rendering.XSprite,
+    implements com.sun.star.rendering.XSprite,
 		        com.sun.star.lang.XServiceInfo,
 				SpriteBase
 {
@@ -206,7 +206,7 @@
     //----------------------------------------------------------------------------------
 
     private static final String s_implName = "XSprite.java.impl";
-    private static final String s_serviceName = "drafts.com.sun.star.rendering.Sprite";
+    private static final String s_serviceName = "com.sun.star.rendering.Sprite";
     
     //----------------------------------------------------------------------------------
 
diff -u -r  canvas/source/java/CanvasCustomSprite.java  canvas/source/java/CanvasCustomSprite.java
---  canvas/source/java/CanvasCustomSprite.java	2004-11-26 22:35:30.000000000 +0530
+++  canvas/source/java/CanvasCustomSprite.java	2005-02-28 13:41:08.046599094 +0530
@@ -67,8 +67,8 @@
 import com.sun.star.awt.*;
 
 // Canvas
-import drafts.com.sun.star.rendering.*;
-import drafts.com.sun.star.geometry.*;
+import com.sun.star.rendering.*;
+import com.sun.star.geometry.*;
 
 // Java AWT
 import java.awt.*;
@@ -80,7 +80,7 @@
 
 public class CanvasCustomSprite
     extends com.sun.star.lib.uno.helper.ComponentBase
-    implements drafts.com.sun.star.rendering.XCustomSprite,
+    implements com.sun.star.rendering.XCustomSprite,
 		        com.sun.star.lang.XServiceInfo,
 				SpriteBase
 {
@@ -214,7 +214,7 @@
         // repaint ourselves
     }
 
-    public synchronized drafts.com.sun.star.rendering.XCanvas getContentCanvas()
+    public synchronized com.sun.star.rendering.XCanvas getContentCanvas()
     {
         CanvasUtils.printLog( "CanvasCustomSprite.getContentCanvas() called" );
 
@@ -224,7 +224,7 @@
     //----------------------------------------------------------------------------------
 
     private static final String s_implName = "XCustomSprite.java.impl";
-    private static final String s_serviceName = "drafts.com.sun.star.rendering.CustomSprite";
+    private static final String s_serviceName = "com.sun.star.rendering.CustomSprite";
     
     //----------------------------------------------------------------------------------
 
diff -u -r  canvas/source/java/CanvasFont.java  canvas/source/java/CanvasFont.java
---  canvas/source/java/CanvasFont.java	2004-11-26 22:35:43.000000000 +0530
+++  canvas/source/java/CanvasFont.java	2005-02-28 13:41:08.006603767 +0530
@@ -65,8 +65,8 @@
 import com.sun.star.awt.*;
 
 // Canvas
-import drafts.com.sun.star.rendering.*;
-import drafts.com.sun.star.geometry.*;
+import com.sun.star.rendering.*;
+import com.sun.star.geometry.*;
 
 // system-dependent stuff
 import sun.awt.*;
@@ -75,15 +75,15 @@
 public class CanvasFont
     extends com.sun.star.lib.uno.helper.ComponentBase
     implements com.sun.star.lang.XServiceInfo, 
-			   drafts.com.sun.star.rendering.XCanvasFont
+			   com.sun.star.rendering.XCanvasFont
 {
     private CanvasBase 									associatedCanvas;
-    private drafts.com.sun.star.rendering.FontRequest	fontRequest;
+    private com.sun.star.rendering.FontRequest	fontRequest;
     private java.awt.Font								font;
 
     //----------------------------------------------------------------------------------
 
-    public CanvasFont( drafts.com.sun.star.rendering.FontRequest 	_fontRequest,
+    public CanvasFont( com.sun.star.rendering.FontRequest 	_fontRequest,
                        CanvasBase 									_canvas )
     {
         associatedCanvas = _canvas;
@@ -141,7 +141,7 @@
     //
 
     private static final String s_implName = "CanvasFont.java.impl";
-    private static final String s_serviceName = "drafts.com.sun.star.rendering.XCanvasFont";
+    private static final String s_serviceName = "com.sun.star.rendering.XCanvasFont";
     
     public String getImplementationName()
     {
diff -u -r  canvas/source/java/CanvasGraphicDevice.java  canvas/source/java/CanvasGraphicDevice.java
---  canvas/source/java/CanvasGraphicDevice.java	2004-11-26 22:35:57.000000000 +0530
+++  canvas/source/java/CanvasGraphicDevice.java	2005-02-28 13:41:08.057597809 +0530
@@ -66,8 +66,8 @@
 import com.sun.star.awt.*;
 
 // Canvas
-import drafts.com.sun.star.rendering.*;
-import drafts.com.sun.star.geometry.*;
+import com.sun.star.rendering.*;
+import com.sun.star.geometry.*;
 
 // Java AWT
 import java.awt.*;
@@ -84,7 +84,7 @@
     extends com.sun.star.lib.uno.helper.ComponentBase
     implements com.sun.star.lang.XServiceInfo, 
     		   com.sun.star.beans.XPropertySet,
-			   drafts.com.sun.star.rendering.XGraphicDevice
+			   com.sun.star.rendering.XGraphicDevice
 {
     private java.awt.Graphics2D				graphics;
     private java.awt.GraphicsConfiguration  graphicsConfig;
@@ -116,19 +116,19 @@
         return null;
     }
 
-    public synchronized drafts.com.sun.star.geometry.RealSize2D getPhysicalResolution()
+    public synchronized com.sun.star.geometry.RealSize2D getPhysicalResolution()
     {
         CanvasUtils.printLog( "CanvasGraphicDevice.getPhysicalResolution!" );
         // TODO: getDefaultTransform + getNormalizingTransform
-        return new drafts.com.sun.star.geometry.RealSize2D(100,100);
+        return new com.sun.star.geometry.RealSize2D(100,100);
     }
 
-    public synchronized drafts.com.sun.star.geometry.RealSize2D getSize()
+    public synchronized com.sun.star.geometry.RealSize2D getSize()
     {
         CanvasUtils.printLog( "CanvasGraphicDevice.getSize!" );
         java.awt.Rectangle bounds = graphicsConfig.getBounds();
 
-        return new drafts.com.sun.star.geometry.RealSize2D(bounds.width, bounds.height);
+        return new com.sun.star.geometry.RealSize2D(bounds.width, bounds.height);
     }
 
     public synchronized XLinePolyPolygon2D createCompatibleLinePolyPolygon( RealPoint2D[][] points )
@@ -143,7 +143,7 @@
         return new BezierPolyPolygon( points );
     }
 
-    public synchronized drafts.com.sun.star.rendering.XBitmap createCompatibleBitmap( IntegerSize2D size )
+    public synchronized com.sun.star.rendering.XBitmap createCompatibleBitmap( IntegerSize2D size )
     {
         CanvasUtils.printLog( "createCompatibleBitmap called with size (" + size.Width + ", " + size.Height + ")" );
         return new CanvasBitmap( graphicsConfig.createCompatibleImage( size.Width, 
@@ -151,14 +151,14 @@
                                                                        Transparency.OPAQUE ) );
     }
 
-    public synchronized drafts.com.sun.star.rendering.XVolatileBitmap createVolatileBitmap( IntegerSize2D size )
+    public synchronized com.sun.star.rendering.XVolatileBitmap createVolatileBitmap( IntegerSize2D size )
     {
         CanvasUtils.printLog( "createVolatileBitmap called with size (" + size.Width + ", " + size.Height + ")" );
         //return new CanvasBitmap( graphicsConfig.createCompatibleVolatileImage( size.Width, size.Height ) );
         return null;
     }
 
-    public synchronized drafts.com.sun.star.rendering.XBitmap createCompatibleAlphaBitmap( IntegerSize2D size )
+    public synchronized com.sun.star.rendering.XBitmap createCompatibleAlphaBitmap( IntegerSize2D size )
     {
         CanvasUtils.printLog( "createCompatibleBitmap called with size (" + size.Width + ", " + size.Height + ")" );
         return new CanvasBitmap( graphicsConfig.createCompatibleImage( size.Width, 
@@ -166,14 +166,14 @@
                                                                         Transparency.TRANSLUCENT ) );
     }
 
-    public synchronized drafts.com.sun.star.rendering.XVolatileBitmap createVolatileAlphaBitmap( IntegerSize2D size )
+    public synchronized com.sun.star.rendering.XVolatileBitmap createVolatileAlphaBitmap( IntegerSize2D size )
     {
         CanvasUtils.printLog( "createVolatileBitmap called with size (" + size.Width + ", " + size.Height + ")" );
         //return new CanvasBitmap( graphicsConfig.createCompatibleVolatileImage( size.Width, size.Height ) );
         return null;
     }
 
-    public synchronized drafts.com.sun.star.rendering.XParametricPolyPolygon2DFactory getParametricPolyPolygonFactory()
+    public synchronized com.sun.star.rendering.XParametricPolyPolygon2DFactory getParametricPolyPolygonFactory()
     {
         // TODO
         return null;
@@ -250,7 +250,7 @@
     //
 
     private static final String s_implName = "XGraphicsDevice.java.impl";
-    private static final String s_serviceName = "drafts.com.sun.star.rendering.GraphicsDevice";
+    private static final String s_serviceName = "com.sun.star.rendering.GraphicsDevice";
     
     public String getImplementationName()
     {
diff -u -r  canvas/source/java/CanvasSprite.java  canvas/source/java/CanvasSprite.java
---  canvas/source/java/CanvasSprite.java	2004-11-26 22:36:11.000000000 +0530
+++  canvas/source/java/CanvasSprite.java	2005-02-28 13:41:08.069596407 +0530
@@ -67,8 +67,8 @@
 import com.sun.star.awt.*;
 
 // Canvas
-import drafts.com.sun.star.rendering.*;
-import drafts.com.sun.star.geometry.*;
+import com.sun.star.rendering.*;
+import com.sun.star.geometry.*;
 
 // Java AWT
 import java.awt.*;
@@ -80,7 +80,7 @@
 
 public class CanvasSprite
     extends com.sun.star.lib.uno.helper.ComponentBase
-    implements drafts.com.sun.star.rendering.XAnimatedSprite,
+    implements com.sun.star.rendering.XAnimatedSprite,
 				com.sun.star.lang.XServiceInfo,
 				SpriteBase
 {
@@ -216,9 +216,9 @@
         }
     }
 
-    public synchronized void move( drafts.com.sun.star.geometry.RealPoint2D 	_aNewPos, 
-                                   drafts.com.sun.star.rendering.ViewState 		_viewState, 
-                                   drafts.com.sun.star.rendering.RenderState 	_renderState )
+    public synchronized void move( com.sun.star.geometry.RealPoint2D 	_aNewPos, 
+                                   com.sun.star.rendering.ViewState 		_viewState, 
+                                   com.sun.star.rendering.RenderState 	_renderState )
     {
         // transform given point with concatenated transformation
         AffineTransform transform = CanvasUtils.ViewConcatRenderTransform( _viewState, _renderState );
@@ -310,7 +310,7 @@
     private void setupSpriteBuffering( AffineTransform _viewTransform )
     {
         // determine bounds of view-transformed animation output rectangle
-        drafts.com.sun.star.geometry.RealSize2D animSize = getAnimationAttributes().UntransformedSize;
+        com.sun.star.geometry.RealSize2D animSize = getAnimationAttributes().UntransformedSize;
 
         java.awt.geom.Rectangle2D.Double aTransformedBounds =             
             CanvasUtils.calcTransformedRectBounds( new java.awt.geom.Rectangle2D.Double(0.0,0.0,
@@ -328,7 +328,7 @@
     //----------------------------------------------------------------------------------
 
     private static final String s_implName = "XSprite.java.impl";
-    private static final String s_serviceName = "drafts.com.sun.star.rendering.Sprite";
+    private static final String s_serviceName = "com.sun.star.rendering.Sprite";
     
     //----------------------------------------------------------------------------------
 
diff -u -r  canvas/source/java/CanvasTest_perftest.java  canvas/source/java/CanvasTest_perftest.java
---  canvas/source/java/CanvasTest_perftest.java	2004-03-18 16:08:31.000000000 +0530
+++  canvas/source/java/CanvasTest_perftest.java	2005-02-28 13:41:07.972607740 +0530
@@ -67,7 +67,7 @@
 import com.sun.star.awt.*;
 
 // Canvas
-import drafts.com.sun.star.rendering.*;
+import com.sun.star.rendering.*;
 
 // Java AWT
 import java.awt.*;
@@ -81,7 +81,7 @@
 public class CanvasTest
     extends CanvasBase
     implements com.sun.star.awt.XWindow,
-			   drafts.com.sun.star.rendering.XSpriteCanvas,
+			   com.sun.star.rendering.XSpriteCanvas,
                com.sun.star.lang.XServiceInfo, 
                com.sun.star.lang.XInitialization
 {
@@ -439,13 +439,13 @@
     // ==================
     //
 
-    public synchronized void copyRect( drafts.com.sun.star.rendering.XBitmapCanvas	sourceCanvas,
-                                       drafts.com.sun.star.rendering.Rectangle2D 	sourceRect, 
-                                       drafts.com.sun.star.rendering.ViewState 		sourceViewState, 
-                                       drafts.com.sun.star.rendering.RenderState 	sourceRenderState,
-                                       drafts.com.sun.star.rendering.Rectangle2D 	destRect, 
-                                       drafts.com.sun.star.rendering.ViewState 		destViewState, 
-                                       drafts.com.sun.star.rendering.RenderState 	destRenderState )
+    public synchronized void copyRect( com.sun.star.rendering.XBitmapCanvas	sourceCanvas,
+                                       com.sun.star.rendering.Rectangle2D 	sourceRect, 
+                                       com.sun.star.rendering.ViewState 		sourceViewState, 
+                                       com.sun.star.rendering.RenderState 	sourceRenderState,
+                                       com.sun.star.rendering.Rectangle2D 	destRect, 
+                                       com.sun.star.rendering.ViewState 		destViewState, 
+                                       com.sun.star.rendering.RenderState 	destRenderState )
     {
         CanvasUtils.printLog( "CanvasTest.copyRect() called" );
 
@@ -490,14 +490,14 @@
     // ==================
     //
 
-    public synchronized drafts.com.sun.star.rendering.XAnimatedSprite createSpriteFromAnimation( XAnimation animation )
+    public synchronized com.sun.star.rendering.XAnimatedSprite createSpriteFromAnimation( XAnimation animation )
     {
         CanvasUtils.printLog( "CanvasTest.createSpriteFromAnimation called" );
 
         return new CanvasSprite( animation, this, (Graphics2D)dummyFrame.frame.getGraphics() );
     }
 
-    public synchronized XAnimatedSprite createSpriteFromBitmaps( drafts.com.sun.star.rendering.XBitmap[] animationBitmaps, 
+    public synchronized XAnimatedSprite createSpriteFromBitmaps( com.sun.star.rendering.XBitmap[] animationBitmaps, 
                                                                  short interpolationMode )
     {
         return null;
@@ -665,7 +665,7 @@
     //----------------------------------------------------------------------------------
 
     private static final String s_implName = "XCanvas.java.impl";
-    private static final String s_serviceName = "drafts.com.sun.star.rendering.Canvas";
+    private static final String s_serviceName = "com.sun.star.rendering.Canvas";
     
     //----------------------------------------------------------------------------------
 
diff -u -r  canvas/source/java/CanvasUtils.java  canvas/source/java/CanvasUtils.java
---  canvas/source/java/CanvasUtils.java	2004-03-18 16:08:31.000000000 +0530
+++  canvas/source/java/CanvasUtils.java	2005-02-28 13:41:08.035600379 +0530
@@ -67,8 +67,8 @@
 import com.sun.star.awt.*;
 
 // Canvas
-import drafts.com.sun.star.rendering.*;
-import drafts.com.sun.star.geometry.*;
+import com.sun.star.rendering.*;
+import com.sun.star.geometry.*;
 
 // Java AWT
 import java.awt.*;
@@ -184,11 +184,11 @@
         return path;
     }
 
-    public static java.awt.geom.GeneralPath makeGenPathFromBezierPoly( drafts.com.sun.star.rendering.XBezierPolyPolygon2D poly )
+    public static java.awt.geom.GeneralPath makeGenPathFromBezierPoly( com.sun.star.rendering.XBezierPolyPolygon2D poly )
     {
         try
         {
-            drafts.com.sun.star.geometry.RealBezierSegment2D [][] points = poly.getPoints(0,-1,0,-1);
+            com.sun.star.geometry.RealBezierSegment2D [][] points = poly.getPoints(0,-1,0,-1);
 
             return makeGenPathFromBezierPoints( points );
         }
@@ -222,11 +222,11 @@
         return path;
     }
 
-    public static java.awt.geom.GeneralPath makeGenPathFromLinePoly( drafts.com.sun.star.rendering.XLinePolyPolygon2D poly )
+    public static java.awt.geom.GeneralPath makeGenPathFromLinePoly( com.sun.star.rendering.XLinePolyPolygon2D poly )
     {
         try
         {
-            drafts.com.sun.star.geometry.RealPoint2D [][] points = poly.getPoints(0,-1,0,-1);
+            com.sun.star.geometry.RealPoint2D [][] points = poly.getPoints(0,-1,0,-1);
 
             return makeGenPathFromLinePoints( points );
         }
@@ -237,7 +237,7 @@
         return new java.awt.geom.GeneralPath();
     }
 
-    public static java.awt.geom.GeneralPath makeGeneralPath( drafts.com.sun.star.rendering.XPolyPolygon2D poly )
+    public static java.awt.geom.GeneralPath makeGeneralPath( com.sun.star.rendering.XPolyPolygon2D poly )
     {
         if( poly instanceof BezierPolyPolygon )
         {
@@ -275,7 +275,7 @@
         return new GeneralPath();
     }
 
-    public static java.awt.image.BufferedImage getBufferedImage( drafts.com.sun.star.rendering.XBitmap bitmap )
+    public static java.awt.image.BufferedImage getBufferedImage( com.sun.star.rendering.XBitmap bitmap )
     {
         if( bitmap instanceof CanvasBitmap )
         {
@@ -332,62 +332,62 @@
         int rule = java.awt.AlphaComposite.SRC_OVER;
         switch( compositeOp )
         {
-            case drafts.com.sun.star.rendering.CompositeOperation.CLEAR:
+            case com.sun.star.rendering.CompositeOperation.CLEAR:
                 CanvasUtils.printLog( "javaRuleFromCompositeOp: clear selected" );
                 rule = java.awt.AlphaComposite.CLEAR;
                 break;
 
-            case drafts.com.sun.star.rendering.CompositeOperation.SOURCE:
+            case com.sun.star.rendering.CompositeOperation.SOURCE:
                 CanvasUtils.printLog( "javaRuleFromCompositeOp: src selected" );
                 rule = java.awt.AlphaComposite.SRC;
                 break;
 
-            case drafts.com.sun.star.rendering.CompositeOperation.DESTINATION:
+            case com.sun.star.rendering.CompositeOperation.DESTINATION:
                 CanvasUtils.printLog( "javaRuleFromCompositeOp: dst selected" );
                 rule = java.awt.AlphaComposite.DST;
                 break;
 
-            case drafts.com.sun.star.rendering.CompositeOperation.OVER:
+            case com.sun.star.rendering.CompositeOperation.OVER:
                 CanvasUtils.printLog( "javaRuleFromCompositeOp: over selected" );
                 rule = java.awt.AlphaComposite.SRC_OVER;
                 break;
 
-            case drafts.com.sun.star.rendering.CompositeOperation.UNDER:
+            case com.sun.star.rendering.CompositeOperation.UNDER:
                 CanvasUtils.printLog( "javaRuleFromCompositeOp: under selected" );
                 rule = java.awt.AlphaComposite.DST_OVER;
                 break;
 
-            case drafts.com.sun.star.rendering.CompositeOperation.INSIDE:
+            case com.sun.star.rendering.CompositeOperation.INSIDE:
                 CanvasUtils.printLog( "javaRuleFromCompositeOp: inside selected" );
                 rule = java.awt.AlphaComposite.CLEAR;
                 break;
 
-            case drafts.com.sun.star.rendering.CompositeOperation.INSIDE_REVERSE:
+            case com.sun.star.rendering.CompositeOperation.INSIDE_REVERSE:
                 CanvasUtils.printLog( "javaRuleFromCompositeOp: inReverse selected" );
                 rule = java.awt.AlphaComposite.CLEAR;
                 break;
 
-            case drafts.com.sun.star.rendering.CompositeOperation.OUTSIDE:
+            case com.sun.star.rendering.CompositeOperation.OUTSIDE:
                 CanvasUtils.printLog( "javaRuleFromCompositeOp: outside selected" );
                 rule = java.awt.AlphaComposite.CLEAR;
                 break;
 
-            case drafts.com.sun.star.rendering.CompositeOperation.OUTSIDE_REVERSE:
+            case com.sun.star.rendering.CompositeOperation.OUTSIDE_REVERSE:
                 CanvasUtils.printLog( "javaRuleFromCompositeOp: outReverse selected" );
                 rule = java.awt.AlphaComposite.CLEAR;
                 break;
 
-            case drafts.com.sun.star.rendering.CompositeOperation.XOR:
+            case com.sun.star.rendering.CompositeOperation.XOR:
                 CanvasUtils.printLog( "javaRuleFromCompositeOp: xor selected" );
                 rule = java.awt.AlphaComposite.CLEAR;
                 break;
 
-            case drafts.com.sun.star.rendering.CompositeOperation.ADD:
+            case com.sun.star.rendering.CompositeOperation.ADD:
                 CanvasUtils.printLog( "javaRuleFromCompositeOp: add selected" );
                 rule = java.awt.AlphaComposite.CLEAR;
                 break;
 
-            case drafts.com.sun.star.rendering.CompositeOperation.SATURATE:
+            case com.sun.star.rendering.CompositeOperation.SATURATE:
                 CanvasUtils.printLog( "javaRuleFromCompositeOp: saturate selected" );
                 rule = java.awt.AlphaComposite.CLEAR;
                 break;
@@ -548,7 +548,7 @@
     public static void setupGraphicsFont( java.awt.Graphics2D 							graphics,
                                           ViewState 									viewState, 
                                           RenderState									renderState,
-                                          drafts.com.sun.star.rendering.XCanvasFont	 	xFont			)
+                                          com.sun.star.rendering.XCanvasFont	 	xFont			)
     {
         if( xFont instanceof CanvasFont )
         {
diff -u -r  canvas/source/java/JavaCanvas.java  canvas/source/java/JavaCanvas.java
---  canvas/source/java/JavaCanvas.java	2004-11-26 22:36:24.000000000 +0530
+++  canvas/source/java/JavaCanvas.java	2005-02-28 13:41:08.021602015 +0530
@@ -67,8 +67,8 @@
 import com.sun.star.awt.*;
 
 // Canvas
-import drafts.com.sun.star.rendering.*;
-import drafts.com.sun.star.geometry.*;
+import com.sun.star.rendering.*;
+import com.sun.star.geometry.*;
 
 // Java AWT
 import java.awt.*;
@@ -82,8 +82,8 @@
 public class JavaCanvas
     extends CanvasBase
     implements com.sun.star.awt.XWindow,
-			   drafts.com.sun.star.rendering.XSpriteCanvas,
-			   drafts.com.sun.star.rendering.XIntegerBitmap,
+			   com.sun.star.rendering.XSpriteCanvas,
+			   com.sun.star.rendering.XIntegerBitmap,
                com.sun.star.lang.XServiceInfo, 
                com.sun.star.lang.XInitialization
 {
@@ -370,13 +370,13 @@
     // ==================
     //
 
-    public synchronized void copyRect( drafts.com.sun.star.rendering.XBitmapCanvas	sourceCanvas,
-                                       drafts.com.sun.star.geometry.RealRectangle2D sourceRect, 
-                                       drafts.com.sun.star.rendering.ViewState 		sourceViewState, 
-                                       drafts.com.sun.star.rendering.RenderState 	sourceRenderState,
-                                       drafts.com.sun.star.geometry.RealRectangle2D	destRect, 
-                                       drafts.com.sun.star.rendering.ViewState 		destViewState, 
-                                       drafts.com.sun.star.rendering.RenderState 	destRenderState )
+    public synchronized void copyRect( com.sun.star.rendering.XBitmapCanvas	sourceCanvas,
+                                       com.sun.star.geometry.RealRectangle2D sourceRect, 
+                                       com.sun.star.rendering.ViewState 		sourceViewState, 
+                                       com.sun.star.rendering.RenderState 	sourceRenderState,
+                                       com.sun.star.geometry.RealRectangle2D	destRect, 
+                                       com.sun.star.rendering.ViewState 		destViewState, 
+                                       com.sun.star.rendering.RenderState 	destRenderState )
     {
         CanvasUtils.printLog( "JavaCanvas.copyRect() called" );
 
@@ -421,14 +421,14 @@
     // ==================
     //
 
-    public synchronized drafts.com.sun.star.rendering.XAnimatedSprite createSpriteFromAnimation( XAnimation animation )
+    public synchronized com.sun.star.rendering.XAnimatedSprite createSpriteFromAnimation( XAnimation animation )
     {
         CanvasUtils.printLog( "JavaCanvas.createSpriteFromAnimation called" );
 
         return new CanvasSprite( animation, this, (Graphics2D)dummyFrame.frame.getGraphics() );
     }
 
-    public synchronized XAnimatedSprite createSpriteFromBitmaps( drafts.com.sun.star.rendering.XBitmap[] animationBitmaps, 
+    public synchronized XAnimatedSprite createSpriteFromBitmaps( com.sun.star.rendering.XBitmap[] animationBitmaps, 
                                                                  byte interpolationMode )
     {
         return null;
@@ -473,7 +473,7 @@
 
     //----------------------------------------------------------------------------------
 
-    public synchronized drafts.com.sun.star.rendering.XBitmap getScaledBitmap( RealSize2D newSize, boolean beFast ) throws com.sun.star.lang.IllegalArgumentException, VolatileContentDestroyedException
+    public synchronized com.sun.star.rendering.XBitmap getScaledBitmap( RealSize2D newSize, boolean beFast ) throws com.sun.star.lang.IllegalArgumentException, VolatileContentDestroyedException
     {
         // TODO
         return null;
@@ -494,14 +494,14 @@
 
     //----------------------------------------------------------------------------------
 
-    public synchronized void setData( byte[] data, IntegerBitmapLayout bitmapLayout, drafts.com.sun.star.geometry.IntegerRectangle2D rect )
+    public synchronized void setData( byte[] data, IntegerBitmapLayout bitmapLayout, com.sun.star.geometry.IntegerRectangle2D rect )
     {
         // TODO
     }
 
     //----------------------------------------------------------------------------------
 
-    public synchronized void setPixel( byte[] color, IntegerBitmapLayout bitmapLayout, drafts.com.sun.star.geometry.IntegerPoint2D pos )
+    public synchronized void setPixel( byte[] color, IntegerBitmapLayout bitmapLayout, com.sun.star.geometry.IntegerPoint2D pos )
     {
         // TODO
     }
@@ -669,7 +669,7 @@
     //----------------------------------------------------------------------------------
 
     private static final String s_implName = "XCanvas.java.impl";
-    private static final String s_serviceName = "drafts.com.sun.star.rendering.JavaCanvas";
+    private static final String s_serviceName = "com.sun.star.rendering.JavaCanvas";
     
     //----------------------------------------------------------------------------------
 
diff -u -r  canvas/source/java/LinePolyPolygon.java  canvas/source/java/LinePolyPolygon.java
---  canvas/source/java/LinePolyPolygon.java	2004-03-18 16:08:31.000000000 +0530
+++  canvas/source/java/LinePolyPolygon.java	2005-02-28 13:41:08.068596524 +0530
@@ -65,8 +65,8 @@
 import com.sun.star.awt.*;
 
 // Canvas
-import drafts.com.sun.star.rendering.*;
-import drafts.com.sun.star.geometry.*;
+import com.sun.star.rendering.*;
+import com.sun.star.geometry.*;
 
 // system-dependent stuff
 import sun.awt.*;
@@ -75,7 +75,7 @@
 public class LinePolyPolygon
     extends com.sun.star.lib.uno.helper.ComponentBase
     implements com.sun.star.lang.XServiceInfo, 
-			   drafts.com.sun.star.rendering.XLinePolyPolygon2D
+			   com.sun.star.rendering.XLinePolyPolygon2D
 {
     private java.awt.geom.GeneralPath path;
 
@@ -216,7 +216,7 @@
     //
 
     private static final String s_implName = "XLinePolyPolygon2D.java.impl";
-    private static final String s_serviceName = "drafts.com.sun.star.rendering.LinePolyPolygon2D";
+    private static final String s_serviceName = "com.sun.star.rendering.LinePolyPolygon2D";
     
     public String getImplementationName()
     {
diff -u -r  canvas/source/java/SpriteBase.java  canvas/source/java/SpriteBase.java
---  canvas/source/java/SpriteBase.java	2004-03-18 16:08:32.000000000 +0530
+++  canvas/source/java/SpriteBase.java	2005-02-28 13:41:08.067596640 +0530
@@ -67,7 +67,7 @@
 import com.sun.star.awt.*;
 
 // Canvas
-import drafts.com.sun.star.rendering.*;
+import com.sun.star.rendering.*;
 
 // Java AWT
 import java.awt.*;
diff -u -r  canvas/source/java/SpriteRep.java  canvas/source/java/SpriteRep.java
---  canvas/source/java/SpriteRep.java	2004-11-26 22:36:40.000000000 +0530
+++  canvas/source/java/SpriteRep.java	2005-02-28 13:41:08.047598977 +0530
@@ -67,7 +67,7 @@
 import com.sun.star.awt.*;
 
 // Canvas
-import drafts.com.sun.star.rendering.*;
+import com.sun.star.rendering.*;
 
 // Java AWT
 import java.awt.*;
@@ -194,7 +194,7 @@
         buffer 	 	   = original.buffer;
     }
 
-    public synchronized drafts.com.sun.star.rendering.XCanvas getContentCanvas()
+    public synchronized com.sun.star.rendering.XCanvas getContentCanvas()
     {
         CanvasUtils.printLog( "SpriteRep.getContentCanvas() called" );
 
diff -u -r  canvas/source/java/SpriteRunner.java  canvas/source/java/SpriteRunner.java
---  canvas/source/java/SpriteRunner.java	2004-11-26 22:36:54.000000000 +0530
+++  canvas/source/java/SpriteRunner.java	2005-02-28 13:41:07.987605987 +0530
@@ -67,7 +67,7 @@
 import com.sun.star.awt.*;
 
 // Canvas
-import drafts.com.sun.star.rendering.*;
+import com.sun.star.rendering.*;
 
 // Java AWT
 import java.awt.*;
diff -u -r  canvas/source/java/TextLayout.java  canvas/source/java/TextLayout.java
---  canvas/source/java/TextLayout.java	2004-11-26 22:37:05.000000000 +0530
+++  canvas/source/java/TextLayout.java	2005-02-28 13:41:08.046599094 +0530
@@ -65,8 +65,8 @@
 import com.sun.star.awt.*;
 
 // Canvas
-import drafts.com.sun.star.rendering.*;
-import drafts.com.sun.star.geometry.*;
+import com.sun.star.rendering.*;
+import com.sun.star.geometry.*;
 
 // system-dependent stuff
 import sun.awt.*;
@@ -75,7 +75,7 @@
 public class TextLayout
     extends com.sun.star.lib.uno.helper.ComponentBase
     implements com.sun.star.lang.XServiceInfo, 
-			   drafts.com.sun.star.rendering.XTextLayout
+			   com.sun.star.rendering.XTextLayout
 {
     private double[]            advancements;
     private StringContext       text;
@@ -108,13 +108,13 @@
         return null;
     }
 
-    public drafts.com.sun.star.geometry.RealRectangle2D[] queryInkMeasures(  )
+    public com.sun.star.geometry.RealRectangle2D[] queryInkMeasures(  )
     {
         // TODO
         return null;
     }
 
-    public drafts.com.sun.star.geometry.RealRectangle2D[] queryMeasures(  )
+    public com.sun.star.geometry.RealRectangle2D[] queryMeasures(  )
     {
         // TODO
         return null;
@@ -134,7 +134,7 @@
         advancements = aAdvancements;
     }
 
-    public drafts.com.sun.star.geometry.RealRectangle2D queryTextBounds(  )
+    public com.sun.star.geometry.RealRectangle2D queryTextBounds(  )
     {
         // TODO
         return null;
@@ -152,7 +152,7 @@
         return 0;
     }
 
-    public TextHit getTextHit( /*IN*/drafts.com.sun.star.geometry.RealPoint2D aHitPoint )
+    public TextHit getTextHit( /*IN*/com.sun.star.geometry.RealPoint2D aHitPoint )
     {
         // TODO
         return null;
@@ -230,7 +230,7 @@
     //
 
     private static final String s_implName = "CanvasFont.java.impl";
-    private static final String s_serviceName = "drafts.com.sun.star.rendering.XCanvasFont";
+    private static final String s_serviceName = "com.sun.star.rendering.XCanvasFont";
     
     public String getImplementationName()
     {
diff -u -r  canvas/source/tools/canvastools.cxx  canvas/source/tools/canvastools.cxx
---  canvas/source/tools/canvastools.cxx	2005-01-21 21:56:02.000000000 +0530
+++  canvas/source/tools/canvastools.cxx	2005-02-28 13:41:08.298569652 +0530
@@ -59,23 +59,23 @@
  *
  ************************************************************************/
 
-#ifndef _DRAFTS_COM_SUN_STAR_GEOMETRY_AFFINEMATRIX2D_HPP_
-#include <drafts/com/sun/star/geometry/AffineMatrix2D.hpp>
+#ifndef _COM_SUN_STAR_GEOMETRY_AFFINEMATRIX2D_HPP_
+#include <com/sun/star/geometry/AffineMatrix2D.hpp>
 #endif
-#ifndef _DRAFTS_COM_SUN_STAR_GEOMETRY_MATRIX2D_HPP_
-#include <drafts/com/sun/star/geometry/Matrix2D.hpp>
+#ifndef _COM_SUN_STAR_GEOMETRY_MATRIX2D_HPP_
+#include <com/sun/star/geometry/Matrix2D.hpp>
 #endif
-#ifndef _DRAFTS_COM_SUN_STAR_RENDERING_RENDERSTATE_HPP__
-#include <drafts/com/sun/star/rendering/RenderState.hpp>
+#ifndef _COM_SUN_STAR_RENDERING_RENDERSTATE_HPP__
+#include <com/sun/star/rendering/RenderState.hpp>
 #endif
-#ifndef _DRAFTS_COM_SUN_STAR_RENDERING_VIEWSTATE_HPP__
-#include <drafts/com/sun/star/rendering/ViewState.hpp>
+#ifndef _COM_SUN_STAR_RENDERING_VIEWSTATE_HPP__
+#include <com/sun/star/rendering/ViewState.hpp>
 #endif
-#ifndef _DRAFTS_COM_SUN_STAR_RENDERING_XCANVAS_HPP__
-#include <drafts/com/sun/star/rendering/XCanvas.hpp>
+#ifndef _COM_SUN_STAR_RENDERING_XCANVAS_HPP__
+#include <com/sun/star/rendering/XCanvas.hpp>
 #endif
-#ifndef _DRAFTS_COM_SUN_STAR_RENDERING_COMPOSITEOPERATION_HPP__
-#include <drafts/com/sun/star/rendering/CompositeOperation.hpp>
+#ifndef _COM_SUN_STAR_RENDERING_COMPOSITEOPERATION_HPP__
+#include <com/sun/star/rendering/CompositeOperation.hpp>
 #endif
 #ifndef _COM_SUN_STAR_BEANS_XPROPERTYSET_HPP_
 #include <com/sun/star/beans/XPropertySet.hpp>
@@ -111,7 +111,6 @@
 #include <cstdio>
 
 
-using namespace ::drafts::com::sun::star;
 using namespace ::com::sun::star;
 
 namespace canvas
@@ -338,52 +337,34 @@
                                                         const ::basegfx::B2DRange&		inRect,
                                                         const ::basegfx::B2DHomMatrix& 	transformation )
         {
-            double left, top, bottom, right;
+            outRect.reset();
 
             // transform all four extremal points of the rectangle,
             // take bounding rect of those.
-            ::basegfx::B2DPoint aPoint;
-
+            
             // transform left-top point
-            aPoint.setX( inRect.getMinX() );
-            aPoint.setY( inRect.getMinY() );
-
-            aPoint *= transformation;
-            left = right = aPoint.getX();
-            top = bottom = aPoint.getY();
+            outRect.expand( transformation * inRect.getMinimum() );
 
             // transform bottom-right point
-            aPoint.setX( inRect.getMaxX() );
-            aPoint.setY( inRect.getMaxY() );
+            outRect.expand( transformation * inRect.getMaximum() );
 
-            aPoint *= transformation;
-            left   = ::std::min(left, aPoint.getX());
-            top    = ::std::min(top, aPoint.getY());
-            right  = ::std::max(right, aPoint.getX());
-            bottom = ::std::max(bottom, aPoint.getY());
+            ::basegfx::B2DPoint aPoint;
 
             // transform top-right point
             aPoint.setX( inRect.getMaxX() );
             aPoint.setY( inRect.getMinY() );
 
             aPoint *= transformation;
-            left   = ::std::min(left, aPoint.getX());
-            top    = ::std::min(top, aPoint.getY());
-            right  = ::std::max(right, aPoint.getX());
-            bottom = ::std::max(bottom, aPoint.getY());
+            outRect.expand( aPoint );
 
             // transform bottom-left point
             aPoint.setX( inRect.getMinX() );
             aPoint.setY( inRect.getMaxY() );
 
             aPoint *= transformation;
-            left   = ::std::min(left, aPoint.getX());
-            top    = ::std::min(top, aPoint.getY());
-            right  = ::std::max(right, aPoint.getX());
-            bottom = ::std::max(bottom, aPoint.getY());
+            outRect.expand( aPoint );
 
             // over and out.
-            outRect = ::basegfx::B2DRectangle( left, top, right, bottom );
             return outRect;
         }
         
diff -u -r  canvas/source/tools/elapsedtime.cxx  canvas/source/tools/elapsedtime.cxx
---  canvas/source/tools/elapsedtime.cxx	2004-11-26 22:37:54.000000000 +0530
+++  canvas/source/tools/elapsedtime.cxx	2005-02-28 13:41:08.299569535 +0530
@@ -59,11 +59,9 @@
  *
  ************************************************************************/
 
-#ifndef _OSL_TIME_H_
-#include <osl/time.h>
-#endif
-
-#include <canvas/elapsedtime.hxx>
+#include "osl/time.h"
+#include "osl/diagnose.h"
+#include "canvas/elapsedtime.hxx"
 
 #if defined(WIN) || defined(WNT)
 
@@ -76,109 +74,185 @@
 #include <mmsystem.h>
 #endif
 
+#include <algorithm>
+#include <limits>
+
+namespace canvas {
+namespace tools {
+
 
-namespace canvas
+#if defined(WIN) || defined(WNT)
+// TODO(Q2): is 0 okay for the failure case here?
+double ElapsedTime::getSystemTime()
 {
-    namespace tools
+    // TEMP!!!
+    // Awaiting corresponding functionality in OSL
+    //
+    
+    // is there a performance counter available?
+    static bool bTimeSetupDone( false );
+    static bool bPerfTimerAvailable( false );
+    static LONGLONG nPerfCountFreq;
+
+    // TODO(F1): This _might_ cause problems, as it prevents correct
+    // time handling for very long lifetimes of this class's
+    // surrounding component in memory. When the difference between
+    // current sys time and nInitialCount exceeds IEEE double's
+    // mantissa, time will start to run jerky.
+    static LONGLONG nInitialCount;
+    
+    if( !bTimeSetupDone )
     {
-        namespace
+        if( QueryPerformanceFrequency(
+                reinterpret_cast<LARGE_INTEGER *>(&nPerfCountFreq) ) )
         {
-#if defined(WIN) || defined(WNT)
-            static double fTimeFactor;
-#endif
+            // read initial time:
+            QueryPerformanceCounter(
+                reinterpret_cast<LARGE_INTEGER *>(&nInitialCount) );
+            bPerfTimerAvailable = true;
+        }
+        bTimeSetupDone = true;
+    }
+    
+    if( bPerfTimerAvailable )
+    {
+        LONGLONG nCurrCount;
+        QueryPerformanceCounter(
+            reinterpret_cast<LARGE_INTEGER *>(&nCurrCount) );
+        nCurrCount -= nInitialCount;
+        return (double)nCurrCount / nPerfCountFreq;
+    }
+    else
+    {
+        LONGLONG nCurrTime = timeGetTime();
+        return (double)nCurrTime / 1000.0;
+    }
+}
 
-            double getTimeFactor()
-            {
-#if defined(WIN) || defined(WNT)
-                // value is hardware-dependent
-                return fTimeFactor;
-#else
-                // value is in nanoseconds
-                return 10e-10;
-#endif
-            }
+#else // ! WNT
 
-            sal_uInt64 getCurrentTime()
-            {
-#if defined(WIN) || defined(WNT)
-                sal_uInt64 bRet( 0 );
+// TODO(Q2): is 0 okay for the failure case here?
+double ElapsedTime::getSystemTime()
+{
+    TimeValue aTimeVal;   
+    if( osl_getSystemTime( &aTimeVal ) )
+        return ((aTimeVal.Nanosec * 10e-10) + aTimeVal.Seconds);
+    else
+        return 0.0;
+}
 
-                // TEMP!!!
-                // Awaiting corresponding functionality in OSL
-                //
-
-                // is there a performance counter available?
-                static bool bTimeSetupDone( false );
-                static bool bPerfTimerAvailable;
-
-                if( !bTimeSetupDone )
-                {
-                    LONGLONG nPerfCount;
-                    if( QueryPerformanceFrequency((LARGE_INTEGER *) &nPerfCount) )
-                    {
-                        // yes, timer choice flag
-                        bPerfTimerAvailable = true;
-
-                        // set scaling factor
-                        fTimeFactor = 1.0/nPerfCount;
-                    }
-                    else 
-                    {
-                        // no performance counter, read in using timeGetTime
-                        bPerfTimerAvailable = false;
-
-                        // set timer scaling factor
-                        fTimeFactor = 0.001; 
-                    }
-
-                    bTimeSetupDone = true;
-                }
-
-                if( bPerfTimerAvailable )
-                {
-                    LONGLONG nCurrTime;
-
-                    // read initial time
-                    QueryPerformanceCounter((LARGE_INTEGER *) &nCurrTime);
-
-                    bRet = nCurrTime;
-                }
-                else
-                {
-                    bRet = timeGetTime();
-                }
-#else
-                TimeValue aTimeVal;
-                sal_uInt64 bRet( 0 );
-
-                if( osl_getSystemTime( &aTimeVal ) )
-                {
-                    // combine to seconds + fraction of second
-                    bRet = ((sal_uInt64)aTimeVal.Seconds) * (sal_uInt64)1000000000 + (sal_uInt64)aTimeVal.Nanosec;
-                }
 #endif
 
-                return bRet; // TODO(Q2): is 0 okay for the failure case here?
-            }
-        }
+ElapsedTime::ElapsedTime()
+    : m_pTimeBase(),
+      m_fLastQueriedTime( 0.0 ),
+      m_fStartTime( getSystemTime() ),
+      m_fFrozenTime( 0.0 ),
+      m_bInPauseMode( false ),
+      m_bInHoldMode( false )
+{
+}
 
-        ElapsedTime::ElapsedTime() :
-            mnStartTime( getCurrentTime() ),
-            mfTimeFactor( getTimeFactor() )
-        {
-        }
+ElapsedTime::ElapsedTime(
+    boost::shared_ptr<ElapsedTime> const & pTimeBase )
+    : m_pTimeBase( pTimeBase ),
+      m_fLastQueriedTime( 0.0 ),
+      m_fStartTime( getCurrentTime() ),
+      m_fFrozenTime( 0.0 ),
+      m_bInPauseMode( false ),
+      m_bInHoldMode( false )
+{
+}
 
-        void ElapsedTime::reset()
-        {
-            mnStartTime = getCurrentTime();
-        }
+boost::shared_ptr<ElapsedTime> const & ElapsedTime::getTimeBase() const
+{
+    return m_pTimeBase;
+}
 
-        double ElapsedTime::getElapsedTime() const
-        {
-            sal_uInt64 nCurrTime( getCurrentTime() );
+void ElapsedTime::reset()
+{
+    m_fLastQueriedTime = 0.0;
+    m_fStartTime = getCurrentTime();
+    m_fFrozenTime = 0.0;
+    m_bInPauseMode = false;
+    m_bInHoldMode = false;
+}
 
-            return mfTimeFactor * (nCurrTime - mnStartTime);
+void ElapsedTime::adjustTimer( double fOffset, bool bLimitToLastQueriedTime )
+{
+#if 0
+    if (bLimitToLastQueriedTime) {
+        const double fCurrentTime = getElapsedTimeImpl();
+        if (m_fLastQueriedTime > (fCurrentTime + fOffset)) {
+            // TODO(Q3): Once the dust has settled, reduce to
+            // OSL_TRACE here!
+            OSL_ENSURE( false, "### adjustTimer(): clamping!" );
+            fOffset = (m_fLastQueriedTime - fCurrentTime);
         }
-        
     }
+#endif
+    // to make getElapsedTime() become _larger_, have to reduce
+    // m_fStartTime.
+    m_fStartTime -= fOffset;
+
+    // also adjust frozen time, this method must _always_ affect the
+    // value returned by getElapsedTime()!
+    if (m_bInHoldMode || m_bInPauseMode)
+        m_fFrozenTime += fOffset;
+}
+
+double ElapsedTime::getCurrentTime() const
+{
+    return m_pTimeBase.get() == 0
+        ? getSystemTime() : m_pTimeBase->getElapsedTimeImpl();
+}
+
+double ElapsedTime::getElapsedTime() const
+{
+    m_fLastQueriedTime = getElapsedTimeImpl();
+    return m_fLastQueriedTime;
+}
+
+double ElapsedTime::getElapsedTimeImpl() const
+{
+    if (m_bInHoldMode || m_bInPauseMode)
+        return m_fFrozenTime;
+    
+    return getCurrentTime() - m_fStartTime;
 }
+
+void ElapsedTime::pauseTimer()
+{
+    m_fFrozenTime = getElapsedTimeImpl();
+    m_bInPauseMode = true;
+}
+
+void ElapsedTime::continueTimer()
+{
+    m_bInPauseMode = false;
+
+    // stop pausing, time runs again. Note that
+    // getElapsedTimeImpl() honors hold mode, i.e. a
+    // continueTimer() in hold mode will preserve the latter
+    const double fPauseDuration( getElapsedTimeImpl() - m_fFrozenTime );
+
+    // adjust start time, such that subsequent getElapsedTime() calls
+    // will virtually start from m_fFrozenTime.
+    m_fStartTime += fPauseDuration;
+}
+
+void ElapsedTime::holdTimer()
+{
+    // when called during hold mode (e.g. more than once per time
+    // object), the original hold time will be maintained.
+    m_fFrozenTime = getElapsedTimeImpl();
+    m_bInHoldMode = true;
+}
+
+void ElapsedTime::releaseTimer()
+{
+    m_bInHoldMode = false;
+}
+
+} // namespace tools
+} // namespace canvas
diff -u -r  canvas/source/tools/linepolypolygonbase.cxx  canvas/source/tools/linepolypolygonbase.cxx
---  canvas/source/tools/linepolypolygonbase.cxx	2004-11-26 22:38:07.000000000 +0530
+++  canvas/source/tools/linepolypolygonbase.cxx	2005-02-28 13:41:08.297569768 +0530
@@ -59,24 +59,24 @@
  *
  ************************************************************************/
 
-#ifndef _DRAFTS_COM_SUN_STAR_GEOMETRY_AFFINEMATRIX2D_HPP_
-#include <drafts/com/sun/star/geometry/AffineMatrix2D.hpp>
+#ifndef _COM_SUN_STAR_GEOMETRY_AFFINEMATRIX2D_HPP_
+#include <com/sun/star/geometry/AffineMatrix2D.hpp>
 #endif
-#ifndef _DRAFTS_COM_SUN_STAR_GEOMETRY_MATRIX2D_HPP_
-#include <drafts/com/sun/star/geometry/Matrix2D.hpp>
+#ifndef _COM_SUN_STAR_GEOMETRY_MATRIX2D_HPP_
+#include <com/sun/star/geometry/Matrix2D.hpp>
 #endif
 
-#ifndef _DRAFTS_COM_SUN_STAR_RENDERING_RENDERSTATE_HPP__
-#include <drafts/com/sun/star/rendering/RenderState.hpp>
+#ifndef _COM_SUN_STAR_RENDERING_RENDERSTATE_HPP__
+#include <com/sun/star/rendering/RenderState.hpp>
 #endif
-#ifndef _DRAFTS_COM_SUN_STAR_RENDERING_VIEWSTATE_HPP__
-#include <drafts/com/sun/star/rendering/ViewState.hpp>
+#ifndef _COM_SUN_STAR_RENDERING_VIEWSTATE_HPP__
+#include <com/sun/star/rendering/ViewState.hpp>
 #endif
-#ifndef _DRAFTS_COM_SUN_STAR_RENDERING_XCANVAS_HPP__
-#include <drafts/com/sun/star/rendering/XCanvas.hpp>
+#ifndef _COM_SUN_STAR_RENDERING_XCANVAS_HPP__
+#include <com/sun/star/rendering/XCanvas.hpp>
 #endif
-#ifndef _DRAFTS_COM_SUN_STAR_RENDERING_COMPOSITEOPERATION_HPP__
-#include <drafts/com/sun/star/rendering/CompositeOperation.hpp>
+#ifndef _COM_SUN_STAR_RENDERING_COMPOSITEOPERATION_HPP__
+#include <com/sun/star/rendering/CompositeOperation.hpp>
 #endif
 
 #ifndef _BGFX_MATRIX_B2DHOMMATRIX_HXX
@@ -101,7 +101,6 @@
 #include <canvas/linepolypolygonbase.hxx>
 
 
-using namespace ::drafts::com::sun::star;
 using namespace ::com::sun::star;
 
 namespace canvas
diff -u -r  canvas/source/tools/makefile.mk  canvas/source/tools/makefile.mk
---  canvas/source/tools/makefile.mk	2004-11-26 22:38:21.000000000 +0530
+++  canvas/source/tools/makefile.mk	2005-02-28 13:41:08.299569535 +0530
@@ -79,7 +79,8 @@
 SLOFILES =	\
 	$(SLO)$/canvastools.obj \
 	$(SLO)$/linepolypolygonbase.obj \
-	$(SLO)$/elapsedtime.obj 
+	$(SLO)$/elapsedtime.obj \
+	$(SLO)$/prioritybooster.obj 
 
 SHL1TARGET= 	$(TARGET)$(UPD)$(DLLPOSTFIX)
 SHL1IMPLIB= 	i$(TARGET)

diff -u -r  canvas/source/vcl/bitmapbackbuffer.cxx  canvas/source/vcl/bitmapbackbuffer.cxx
---  canvas/source/vcl/bitmapbackbuffer.cxx	2004-11-26 22:39:00.000000000 +0530
+++  canvas/source/vcl/bitmapbackbuffer.cxx	2005-02-28 13:41:07.521660432 +0530
@@ -86,14 +86,15 @@
         maBitmap( rBitmap ),
         mpVDev( NULL ),
         mrRefDevice( rRefDevice ),
-        mbBitmapContentIsCurrent( true )
+        mbBitmapContentIsCurrent( false ),
+        mbVDevContentIsCurrent( false )
     {
     }
         
     BitmapBackBuffer::~BitmapBackBuffer()
     {
         // make sure solar mutex is held on deletion (other methods
-        // are supposed to already hold the solar mutex)
+        // are supposed to be called with already locked solar mutex)
         ::vos::OGuard aGuard( Application::GetSolarMutex() );
         
         if( mpVDev )
@@ -130,7 +131,10 @@
 
     BitmapEx& BitmapBackBuffer::getBitmapReference()
     {
-        if( !mbBitmapContentIsCurrent && mpVDev )
+        OSL_ENSURE( !mbBitmapContentIsCurrent || !mbVDevContentIsCurrent,
+                    "BitmapBackBuffer::getBitmapReference(): Both bitmap and VDev are valid?!" );
+
+        if( mbVDevContentIsCurrent && mpVDev )
         {
             // VDev content is more current than bitmap - copy contents before!
             mpVDev->EnableMapMode( FALSE );
@@ -142,6 +146,7 @@
         // client queries bitmap, and will possibly alter content -
         // next time, VDev needs to be updated
         mbBitmapContentIsCurrent = true;
+        mbVDevContentIsCurrent 	 = false;
 
         return *maBitmap;
     }
@@ -165,16 +170,21 @@
 
     void BitmapBackBuffer::updateVDev() const
     {
+        OSL_ENSURE( !mbBitmapContentIsCurrent || !mbVDevContentIsCurrent,
+                    "BitmapBackBuffer::updateVDev(): Both bitmap and VDev are valid?!" );
+
         if( mpVDev && mbBitmapContentIsCurrent )
         {
             // fill with bitmap content
             mpVDev->EnableMapMode( FALSE );
             const Point aEmptyPoint;
             mpVDev->DrawBitmapEx( aEmptyPoint, *maBitmap );
-
-            // canvas queried the VDev, and will possibly paint into it
-            mbBitmapContentIsCurrent = false;
         }
+
+        // canvas queried the VDev, and will possibly paint into
+        // it. Next time, bitmap must be updated
+        mbBitmapContentIsCurrent = false;
+        mbVDevContentIsCurrent 	 = true;
     }
 
 }
diff -u -r  canvas/source/vcl/bitmapbackbuffer.hxx  canvas/source/vcl/bitmapbackbuffer.hxx
---  canvas/source/vcl/bitmapbackbuffer.hxx	2004-11-26 22:39:12.000000000 +0530
+++  canvas/source/vcl/bitmapbackbuffer.hxx	2005-02-28 13:41:07.521660432 +0530
@@ -111,11 +111,21 @@
         const OutputDevice& 					mrRefDevice;
 
         /** When true, the bitmap contains the last valid
-            content. When false, and mpVDev is non-NULL, the VDev
-            contains the last valid content (which must be copied back
-            to the bitmap, when getBitmapReference() is called).
+            content. When false, and mbVDevContentIsCurrent is true,
+            the VDev contains the last valid content (which must be
+            copied back to the bitmap, when getBitmapReference() is
+            called). When both are false, this object is just
+            initialized.
          */
         mutable bool							mbBitmapContentIsCurrent; 
+
+        /** When true, and mpVDev is non-NULL, the VDev contains the
+            last valid content. When false, and
+            mbBitmapContentIsCurrent is true, the bitmap contains the
+            last valid content. When both are false, this object is
+            just initialized.
+         */
+        mutable bool							mbVDevContentIsCurrent;
     };
 
     typedef ::boost::shared_ptr< BitmapBackBuffer > BitmapBackBufferSharedPtr;
diff -u -r  canvas/source/vcl/canvasbitmap.cxx  canvas/source/vcl/canvasbitmap.cxx
---  canvas/source/vcl/canvasbitmap.cxx	2004-11-26 22:40:25.000000000 +0530
+++  canvas/source/vcl/canvasbitmap.cxx	2005-02-28 13:41:07.594651903 +0530
@@ -70,7 +70,6 @@
 #endif
 
 using namespace ::com::sun::star;
-using namespace ::drafts::com::sun::star;
 
 
 namespace vclcanvas
@@ -159,7 +158,7 @@
         CanvasBitmap_Base::disposing();
     }
 
-#define SERVICE_NAME "drafts.com.sun.star.rendering.CanvasBitmap"
+#define SERVICE_NAME "com.sun.star.rendering.CanvasBitmap"
 
     ::rtl::OUString SAL_CALL CanvasBitmap::getImplementationName(  ) throw (uno::RuntimeException)
     {
diff -u -r  canvas/source/vcl/canvasbitmaphelper.cxx  canvas/source/vcl/canvasbitmaphelper.cxx
---  canvas/source/vcl/canvasbitmaphelper.cxx	2004-11-26 22:40:50.000000000 +0530
+++  canvas/source/vcl/canvasbitmaphelper.cxx	2005-02-28 13:41:07.522660315 +0530
@@ -103,7 +103,6 @@
 
 
 using namespace ::com::sun::star;
-using namespace ::drafts::com::sun::star;
 
 namespace vclcanvas
 {
diff -u -r  canvas/source/vcl/canvasbitmaphelper.hxx  canvas/source/vcl/canvasbitmaphelper.hxx
---  canvas/source/vcl/canvasbitmaphelper.hxx	2004-11-26 22:41:01.000000000 +0530
+++  canvas/source/vcl/canvasbitmaphelper.hxx	2005-02-28 13:41:07.523660198 +0530
@@ -104,29 +104,29 @@
 
         void disposing();
 
-        ::drafts::com::sun::star::geometry::IntegerSize2D SAL_CALL getSize();
+        ::com::sun::star::geometry::IntegerSize2D SAL_CALL getSize();
 
-        ::com::sun::star::uno::Reference< ::drafts::com::sun::star::rendering::XBitmapCanvas > SAL_CALL queryBitmapCanvas();
+        ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XBitmapCanvas > SAL_CALL queryBitmapCanvas();
 
-        ::com::sun::star::uno::Reference< ::drafts::com::sun::star::rendering::XBitmap > SAL_CALL 
-        	getScaledBitmap( const ::drafts::com::sun::star::geometry::RealSize2D& 	newSize, 
+        ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XBitmap > SAL_CALL 
+        	getScaledBitmap( const ::com::sun::star::geometry::RealSize2D& 	newSize, 
                              sal_Bool 												beFast );
 
         ::com::sun::star::uno::Sequence< sal_Int8 > SAL_CALL 
-	        getData( const ::drafts::com::sun::star::geometry::IntegerRectangle2D& rect );
+	        getData( const ::com::sun::star::geometry::IntegerRectangle2D& rect );
 
         void SAL_CALL setData( const ::com::sun::star::uno::Sequence< sal_Int8 >& 				data, 
-                               const ::drafts::com::sun::star::geometry::IntegerRectangle2D& 	rect );
+                               const ::com::sun::star::geometry::IntegerRectangle2D& 	rect );
 
         void SAL_CALL setPixel( const ::com::sun::star::uno::Sequence< sal_Int8 >& 			color, 
-                                const ::drafts::com::sun::star::geometry::IntegerPoint2D& 	pos );
+                                const ::com::sun::star::geometry::IntegerPoint2D& 	pos );
 
         ::com::sun::star::uno::Sequence< sal_Int8 > SAL_CALL 
-	        getPixel( const ::drafts::com::sun::star::geometry::IntegerPoint2D& pos );
+	        getPixel( const ::com::sun::star::geometry::IntegerPoint2D& pos );
 
-        ::com::sun::star::uno::Reference< ::drafts::com::sun::star::rendering::XBitmapPalette > SAL_CALL getPalette();
+        ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XBitmapPalette > SAL_CALL getPalette();
 
-        ::drafts::com::sun::star::rendering::IntegerBitmapLayout SAL_CALL getMemoryLayout();
+        ::com::sun::star::rendering::IntegerBitmapLayout SAL_CALL getMemoryLayout();
 
         /// @internal
         BitmapEx getBitmap() const;
diff -u -r  canvas/source/vcl/canvasbitmap.hxx  canvas/source/vcl/canvasbitmap.hxx
---  canvas/source/vcl/canvasbitmap.hxx	2004-11-26 22:40:39.000000000 +0530
+++  canvas/source/vcl/canvasbitmap.hxx	2005-02-28 13:41:07.595651786 +0530
@@ -69,11 +69,11 @@
 #ifndef _COM_SUN_STAR_LANG_XSERVICEINFO_HPP_
 #include <com/sun/star/lang/XServiceInfo.hpp>
 #endif
-#ifndef _DRAFTS_COM_SUN_STAR_RENDERING_XBITMAPCANVAS_HPP_
-#include <drafts/com/sun/star/rendering/XBitmapCanvas.hpp>
+#ifndef _COM_SUN_STAR_RENDERING_XBITMAPCANVAS_HPP_
+#include <com/sun/star/rendering/XBitmapCanvas.hpp>
 #endif
-#ifndef _DRAFTS_COM_SUN_STAR_RENDERING_XINTEGERBITMAP_HPP_
-#include <drafts/com/sun/star/rendering/XIntegerBitmap.hpp>
+#ifndef _COM_SUN_STAR_RENDERING_XINTEGERBITMAP_HPP_
+#include <com/sun/star/rendering/XIntegerBitmap.hpp>
 #endif
 
 #ifndef _SV_VIRDEV_HXX
@@ -97,8 +97,8 @@
 
 namespace vclcanvas
 {
-    typedef ::cppu::WeakComponentImplHelper3< ::drafts::com::sun::star::rendering::XBitmapCanvas,
-			                         		  ::drafts::com::sun::star::rendering::XIntegerBitmap,
+    typedef ::cppu::WeakComponentImplHelper3< ::com::sun::star::rendering::XBitmapCanvas,
+			                         		  ::com::sun::star::rendering::XIntegerBitmap,
                          			 		  ::com::sun::star::lang::XServiceInfo >  								CanvasBitmapBase_Base;
     typedef ::canvas::internal::BitmapCanvasBase< CanvasBitmapBase_Base, CanvasBitmapHelper, tools::LocalGuard > 	CanvasBitmap_Base;
 
diff -u -r  canvas/source/vcl/canvascustomsprite.cxx  canvas/source/vcl/canvascustomsprite.cxx
---  canvas/source/vcl/canvascustomsprite.cxx	2005-01-21 21:56:18.000000000 +0530
+++  canvas/source/vcl/canvascustomsprite.cxx	2005-02-28 13:41:07.484664755 +0530
@@ -91,6 +91,12 @@
 #ifndef _BGFX_TOOLS_CANVASTOOLS_HXX
 #include <basegfx/tools/canvastools.hxx>
 #endif
+#ifndef _BGFX_POLYGON_B2DPOLYGON_HXX
+#include <basegfx/polygon/b2dpolygon.hxx>
+#endif
+#ifndef _BGFX_POLYGON_B2DPOLYGONTOOLS_HXX
+#include <basegfx/polygon/b2dpolygontools.hxx>
+#endif
 #ifndef _BGFX_NUMERIC_FTOOLS_HXX
 #include <basegfx/numeric/ftools.hxx>
 #endif
@@ -101,7 +107,6 @@
 
 
 using namespace ::com::sun::star;
-using namespace ::drafts::com::sun::star;
 
 
 namespace vclcanvas
@@ -118,14 +123,12 @@
         maSize( ::vcl::unotools::sizeFromRealSize2D( rSpriteSize ) ),
         mxClipPoly(),
         mfAlpha(0.0),
-        mbActive(false)
+        mbActive(false),
+        mbIsContentFullyOpaque( false )
     {
         ENSURE_AND_THROW( rDevice.get() && rSpriteCanvas.get(),
                           "CanvasBitmap::CanvasBitmap(): Invalid device or sprite canvas" );
 
-        // to prevent truncations due to round-offs
-        maSize.Width() += 1; maSize.Height() += 1;
-
         // setup graphic device
         maCanvasHelper.setGraphicDevice( rDevice );
         
@@ -178,6 +181,54 @@
         CanvasCustomSprite_Base::disposing();
     }
 
+    uno::Reference< rendering::XCachedPrimitive > SAL_CALL CanvasCustomSprite::drawBitmap( const uno::Reference< rendering::XBitmap >&	xBitmap, 
+                                                                                           const rendering::ViewState& 					viewState, 
+                                                                                           const rendering::RenderState& 				renderState ) throw (lang::IllegalArgumentException, uno::RuntimeException)
+    {
+        tools::LocalGuard aGuard;
+
+        const ::BitmapEx& rBmpEx( tools::bitmapExFromXBitmap(xBitmap) );
+
+        // check whether bitmap is non-alpha, and whether its
+        // transformed size covers the whole sprite.
+        if( !rBmpEx.IsTransparent() )
+        {
+            // TODO(Q2): Factor out to canvastools or similar
+
+            ::basegfx::B2DHomMatrix aTransform;
+            ::canvas::tools::mergeViewAndRenderTransform(aTransform,
+                                                         viewState, 
+                                                         renderState);
+            
+            const geometry::IntegerSize2D& rSize( xBitmap->getSize() );
+
+            ::basegfx::B2DPolygon aPoly( 
+                ::basegfx::tools::createPolygonFromRect(
+                    ::basegfx::B2DRectangle( 0.0,0.0,
+                                             rSize.Width+1,
+                                             rSize.Height+1 ) ) );
+            aPoly.transform( aTransform );
+
+            if( ::basegfx::tools::isInside( 
+                    aPoly,
+                    ::basegfx::tools::createPolygonFromRect(
+                        ::basegfx::B2DRectangle( 0.0,0.0,
+                                                 maSize.Width(),
+                                                 maSize.Height() ) ),
+                    true ) )
+            {
+                // bitmap will fully cover the sprite, set flag
+                // appropriately
+                mbIsContentFullyOpaque = true;
+            }
+        }
+            
+        // delegate to base
+        return CanvasCustomSprite_Base::drawBitmap( xBitmap,
+                                                    viewState,
+                                                    renderState );
+    }
+
     void SAL_CALL CanvasCustomSprite::setAlpha( double alpha ) throw (lang::IllegalArgumentException, uno::RuntimeException)
     {
         tools::LocalGuard aGuard;
@@ -340,10 +391,13 @@
         // surface content has changed (we cleared it, at least)
         mbSurfaceDirty = true;
 
+        // just cleared content to fully transparent
+        mbIsContentFullyOpaque = false;
+
         return this;
     }
 
-#define SERVICE_NAME "drafts.com.sun.star.rendering.CanvasCustomSprite"
+#define SERVICE_NAME "com.sun.star.rendering.CanvasCustomSprite"
 
     ::rtl::OUString SAL_CALL CanvasCustomSprite::getImplementationName() throw( uno::RuntimeException )
     {
@@ -406,7 +460,7 @@
                 
                     aPolyPoly.Translate( rOutputPos );
                 
-                    const Region aClipRegion( aPolyPoly );
+                    const Region aClipRegion( Region::GetRegionFromPolyPolygon( aPolyPoly ) );
                 
                     rTargetSurface.SetClipRegion( aClipRegion );
                 }
@@ -420,23 +474,37 @@
                 mbSurfaceDirty = false;
                 
                 Bitmap aBmp( mpBackBuffer->getOutDev().GetBitmap( aEmptyPoint, maSize ) );
-                Bitmap aMask( mpBackBufferMask->getOutDev().GetBitmap( aEmptyPoint, maSize ) );
 
-                if( aMask.GetBitCount() != 1 )
+                if( mbIsContentFullyOpaque )
                 {
-                    OSL_ENSURE(false,
-                               "CanvasCustomSprite::redraw(): Mask bitmap is not monochrome (performance!)");
-                    aMask.MakeMono(255);
+                    // optimized case: content canvas is fully opaque
+                    // maContent = BitmapEx( aBmp.CreateDisplayBitmap( &rTargetSurface ) );
+                    maContent = BitmapEx( aBmp );
                 }
+                else
+                {
+                    Bitmap aMask( mpBackBufferMask->getOutDev().GetBitmap( aEmptyPoint, maSize ) );
 
-                maContent = BitmapEx( aBmp.CreateDisplayBitmap( &rTargetSurface ), 
-                                      aMask.CreateDisplayBitmap( &rTargetSurface ) );
+                    if( aMask.GetBitCount() != 1 )
+                    {
+                        OSL_ENSURE(false,
+                                   "CanvasCustomSprite::redraw(): Mask bitmap is not monochrome (performance!)");
+                        aMask.MakeMono(255);
+                    }
+
+                    // maContent = BitmapEx( aBmp.CreateDisplayBitmap( &rTargetSurface ), 
+                    //                       aMask.CreateDisplayBitmap( &rTargetSurface ) );
+                    maContent = BitmapEx( aBmp, aMask );
+                }
             }
 
             if( ::rtl::math::approxEqual(mfAlpha, 1.0) )
             {
-                // fully opaque -> copy to output
-                rTargetSurface.DrawBitmapEx( rOutputPos, *maContent );
+                // no alpha modulation -> just copy to output
+                if( maContent->IsTransparent() )
+                    rTargetSurface.DrawBitmapEx( rOutputPos, *maContent );
+                else
+                    rTargetSurface.DrawBitmap( rOutputPos, maContent->GetBitmap() );
             }
             else
             {
@@ -448,7 +516,8 @@
                 AlphaMask aAlpha( maSize, &nColor );
             
                 // mask out fully transparent areas
-                aAlpha.Replace( maContent->GetMask(), 255 );
+                if( maContent->IsTransparent() )
+                    aAlpha.Replace( maContent->GetMask(), 255 );
 
                 // alpha-blend to output                    
                 rTargetSurface.DrawBitmapEx( rOutputPos, 
diff -u -r  canvas/source/vcl/canvascustomsprite.hxx  canvas/source/vcl/canvascustomsprite.hxx
---  canvas/source/vcl/canvascustomsprite.hxx	2004-11-26 22:41:26.000000000 +0530
+++  canvas/source/vcl/canvascustomsprite.hxx	2005-02-28 13:41:07.485664638 +0530
@@ -73,11 +73,11 @@
 #ifndef _COM_SUN_STAR_LANG_XSERVICEINFO_HPP_
 #include <com/sun/star/lang/XServiceInfo.hpp>
 #endif
-#ifndef _DRAFTS_COM_SUN_STAR_RENDERING_XCUSTOMSPRITE_HPP_
-#include <drafts/com/sun/star/rendering/XCustomSprite.hpp>
+#ifndef _COM_SUN_STAR_RENDERING_XCUSTOMSPRITE_HPP_
+#include <com/sun/star/rendering/XCustomSprite.hpp>
 #endif
-#ifndef _DRAFTS_COM_SUN_STAR_RENDERING_XPOLYPOLYGON2D_HPP_
-#include <drafts/com/sun/star/rendering/XPolyPolygon2D.hpp>
+#ifndef _COM_SUN_STAR_RENDERING_XPOLYPOLYGON2D_HPP_
+#include <com/sun/star/rendering/XPolyPolygon2D.hpp>
 #endif
 
 #ifndef _BGFX_POINT_B2DPOINT_HXX
@@ -102,8 +102,8 @@
 
 namespace vclcanvas
 {
-    typedef ::cppu::WeakComponentImplHelper3< ::drafts::com::sun::star::rendering::XCustomSprite,
-									 		  ::drafts::com::sun::star::rendering::XBitmapCanvas,
+    typedef ::cppu::WeakComponentImplHelper3< ::com::sun::star::rendering::XCustomSprite,
+									 		  ::com::sun::star::rendering::XBitmapCanvas,
                          			 		  ::com::sun::star::lang::XServiceInfo >  								CanvasCustomSpriteBase_Base;
     typedef ::canvas::internal::BitmapCanvasBase< CanvasCustomSpriteBase_Base, CanvasHelper, tools::LocalGuard > 	CanvasCustomSprite_Base;
 
@@ -113,7 +113,7 @@
                                public CanvasCustomSprite_Base
     {
     public:
-        CanvasCustomSprite( const ::drafts::com::sun::star::geometry::RealSize2D& 	rSpriteSize,
+        CanvasCustomSprite( const ::com::sun::star::geometry::RealSize2D& 	rSpriteSize,
                             const WindowGraphicDevice::ImplRef&						rDevice,
                             const SpriteCanvas::ImplRef&							rSpriteCanvas );
 
@@ -131,17 +131,23 @@
 
         virtual void SAL_CALL disposing();
 
+        // XCanvas: selectively override base's method here, for opacity tracking
+        virtual ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XCachedPrimitive > SAL_CALL 	
+        	drawBitmap( const ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XBitmap >& xBitmap, 
+                        const ::com::sun::star::rendering::ViewState& 									viewState, 
+                        const ::com::sun::star::rendering::RenderState& 								renderState ) throw (::com::sun::star::lang::IllegalArgumentException, ::com::sun::star::uno::RuntimeException);
+
         // XSprite
         virtual void SAL_CALL setAlpha( double alpha ) throw (::com::sun::star::lang::IllegalArgumentException, ::com::sun::star::uno::RuntimeException);
-        virtual void SAL_CALL move( const ::drafts::com::sun::star::geometry::RealPoint2D& aNewPos, const ::drafts::com::sun::star::rendering::ViewState& viewState, const ::drafts::com::sun::star::rendering::RenderState& renderState ) throw (::com::sun::star::lang::IllegalArgumentException, ::com::sun::star::uno::RuntimeException);
-        virtual void SAL_CALL transform( const ::drafts::com::sun::star::geometry::AffineMatrix2D& aTransformation ) throw (::com::sun::star::lang::IllegalArgumentException, ::com::sun::star::uno::RuntimeException);
-        virtual void SAL_CALL clip( const ::com::sun::star::uno::Reference< ::drafts::com::sun::star::rendering::XPolyPolygon2D >& aClip ) throw (::com::sun::star::uno::RuntimeException);
+        virtual void SAL_CALL move( const ::com::sun::star::geometry::RealPoint2D& aNewPos, const ::com::sun::star::rendering::ViewState& viewState, const ::com::sun::star::rendering::RenderState& renderState ) throw (::com::sun::star::lang::IllegalArgumentException, ::com::sun::star::uno::RuntimeException);
+        virtual void SAL_CALL transform( const ::com::sun::star::geometry::AffineMatrix2D& aTransformation ) throw (::com::sun::star::lang::IllegalArgumentException, ::com::sun::star::uno::RuntimeException);
+        virtual void SAL_CALL clip( const ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XPolyPolygon2D >& aClip ) throw (::com::sun::star::uno::RuntimeException);
         virtual void SAL_CALL setPriority( double nPriority ) throw (::com::sun::star::uno::RuntimeException);
         virtual void SAL_CALL show(  ) throw (::com::sun::star::uno::RuntimeException);
         virtual void SAL_CALL hide(  ) throw (::com::sun::star::uno::RuntimeException);
 
         // XCustomSprite
-        virtual ::com::sun::star::uno::Reference< ::drafts::com::sun::star::rendering::XCanvas > SAL_CALL 
+        virtual ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XCanvas > SAL_CALL 
         	getContentCanvas(  ) throw (::com::sun::star::uno::RuntimeException);
 
         // XServiceInfo
@@ -175,9 +181,18 @@
         ::basegfx::B2DPoint											maPosition;
         Size														maSize;
         ::com::sun::star::uno::Reference< 
-              ::drafts::com::sun::star::rendering::XPolyPolygon2D >	mxClipPoly;
+              ::com::sun::star::rendering::XPolyPolygon2D >	mxClipPoly;
         double														mfAlpha;
         bool														mbActive;
+
+        /** OutDev render speedup.
+
+        	When true, this flag denotes that the current
+        	mpBackBufferMask content is fully opaque, thus, that blits
+        	to the screen can use a plain Bitmap instead of the
+        	BitmapEx.
+         */
+        mutable bool												mbIsContentFullyOpaque;
     };
 }
 
diff -u -r  canvas/source/vcl/canvasfont.cxx  canvas/source/vcl/canvasfont.cxx
---  canvas/source/vcl/canvasfont.cxx	2004-11-26 22:41:39.000000000 +0530
+++  canvas/source/vcl/canvasfont.cxx	2005-02-28 13:41:07.592652137 +0530
@@ -77,7 +77,6 @@
 #include "textlayout.hxx"
 
 using namespace ::com::sun::star;
-using namespace ::drafts::com::sun::star;
 
 
 namespace vclcanvas
@@ -174,7 +173,7 @@
         return uno::Sequence< beans::PropertyValue >();
     }
 
-#define SERVICE_NAME "drafts.com.sun.star.rendering.CanvasFont"
+#define SERVICE_NAME "com.sun.star.rendering.CanvasFont"
 
     ::rtl::OUString SAL_CALL CanvasFont::getImplementationName() throw( uno::RuntimeException )
     {
diff -u -r  canvas/source/vcl/canvasfont.hxx  canvas/source/vcl/canvasfont.hxx
---  canvas/source/vcl/canvasfont.hxx	2004-11-26 22:41:53.000000000 +0530
+++  canvas/source/vcl/canvasfont.hxx	2005-02-28 13:41:07.592652137 +0530
@@ -77,8 +77,8 @@
 #include <com/sun/star/lang/XServiceInfo.hpp>
 #endif
 
-#ifndef _DRAFTS_COM_SUN_STAR_RENDERING_XCANVASFONT_HPP_
-#include <drafts/com/sun/star/rendering/XCanvasFont.hpp>
+#ifndef _COM_SUN_STAR_RENDERING_XCANVASFONT_HPP_
+#include <com/sun/star/rendering/XCanvasFont.hpp>
 #endif
 
 #ifndef _SV_FONT_HXX
@@ -97,7 +97,7 @@
 
 namespace vclcanvas
 {
-    typedef ::cppu::WeakComponentImplHelper2< ::drafts::com::sun::star::rendering::XCanvasFont,
+    typedef ::cppu::WeakComponentImplHelper2< ::com::sun::star::rendering::XCanvasFont,
                          					  ::com::sun::star::lang::XServiceInfo > CanvasFont_Base;
 
     class CanvasFont : public ::comphelper::OBaseMutex, public CanvasFont_Base
@@ -105,20 +105,20 @@
     public:
         typedef ::comphelper::ImplementationReference<
             CanvasFont,
-            ::drafts::com::sun::star::rendering::XCanvasFont > ImplRef;
+            ::com::sun::star::rendering::XCanvasFont > ImplRef;
 
-        CanvasFont( const ::drafts::com::sun::star::rendering::FontRequest& 								fontRequest,
+        CanvasFont( const ::com::sun::star::rendering::FontRequest& 								fontRequest,
                     const ::com::sun::star::uno::Sequence< ::com::sun::star::beans::PropertyValue >& 		extraFontProperties, 
-                    const ::drafts::com::sun::star::geometry::Matrix2D&										rFontMatrix,
+                    const ::com::sun::star::geometry::Matrix2D&										rFontMatrix,
                     const OutDevProviderSharedPtr&															rDevice );
 
         /// Dispose all internal references
         virtual void SAL_CALL disposing();
 
         // XCanvasFont
-        virtual ::com::sun::star::uno::Reference< ::drafts::com::sun::star::rendering::XTextLayout > SAL_CALL createTextLayout( const ::drafts::com::sun::star::rendering::StringContext& aText, sal_Int8 nDirection, sal_Int64 nRandomSeed ) throw (::com::sun::star::uno::RuntimeException);
-        virtual ::drafts::com::sun::star::rendering::FontRequest SAL_CALL getFontRequest(  ) throw (::com::sun::star::uno::RuntimeException);
-        virtual ::drafts::com::sun::star::rendering::FontMetrics SAL_CALL getFontMetrics(  ) throw (::com::sun::star::uno::RuntimeException);
+        virtual ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XTextLayout > SAL_CALL createTextLayout( const ::com::sun::star::rendering::StringContext& aText, sal_Int8 nDirection, sal_Int64 nRandomSeed ) throw (::com::sun::star::uno::RuntimeException);
+        virtual ::com::sun::star::rendering::FontRequest SAL_CALL getFontRequest(  ) throw (::com::sun::star::uno::RuntimeException);
+        virtual ::com::sun::star::rendering::FontMetrics SAL_CALL getFontMetrics(  ) throw (::com::sun::star::uno::RuntimeException);
         virtual ::com::sun::star::uno::Sequence< double > SAL_CALL getAvailableSizes(  ) throw (::com::sun::star::uno::RuntimeException);
         virtual ::com::sun::star::uno::Sequence< ::com::sun::star::beans::PropertyValue > SAL_CALL getExtraFontProperties(  ) throw (::com::sun::star::uno::RuntimeException);
 
@@ -138,7 +138,7 @@
         CanvasFont& operator=( const CanvasFont& );
 
         ::canvas::vcltools::VCLObject<Font>					maFont;
-        ::drafts::com::sun::star::rendering::FontRequest	maFontRequest;
+        ::com::sun::star::rendering::FontRequest	maFontRequest;
         OutDevProviderSharedPtr								mpRefDevice;
     };
 
diff -u -r  canvas/source/vcl/canvashelper.cxx  canvas/source/vcl/canvashelper.cxx
---  canvas/source/vcl/canvashelper.cxx	2004-11-26 22:42:04.000000000 +0530
+++  canvas/source/vcl/canvashelper.cxx	2005-02-28 13:41:07.585652955 +0530
@@ -65,6 +65,10 @@
 #include <rtl/math.hxx>
 #endif 
 
+#ifndef _COM_SUN_STAR_RENDERING_TEXTDIRECTION_HPP__
+#include <com/sun/star/rendering/TextDirection.hpp>
+#endif
+
 #ifndef _TL_POLY_HXX
 #include <tools/poly.hxx>
 #endif
@@ -84,6 +88,9 @@
 #ifndef _BGFX_MATRIX_B2DHOMMATRIX_HXX
 #include <basegfx/matrix/b2dhommatrix.hxx>
 #endif
+#ifndef _BGFX_RANGE_B2DRECTANGLE_HXX
+#include <basegfx/range/b2drectangle.hxx>
+#endif
 #ifndef _BGFX_POINT_B2DPOINT_HXX
 #include <basegfx/point/b2dpoint.hxx>
 #endif
@@ -110,7 +117,6 @@
 
 
 using namespace ::com::sun::star;
-using namespace ::drafts::com::sun::star;
 
 
 namespace vclcanvas
@@ -302,7 +308,7 @@
 
             if( mp2ndOutDev.get() )
             {
-                if( nTransparency )
+                if( !nTransparency )
                     mp2ndOutDev->getOutDev().DrawPolyPolygon( aPolyPoly );
                 else
                     mp2ndOutDev->getOutDev().DrawTransparent( aPolyPoly, nTransPercent );
@@ -327,7 +333,7 @@
         {
             tools::OutDevStateKeeper aStateKeeper( mpProtectedOutDev );
 
-            const int nTransparency( setupOutDevState( viewState, renderState, FILL_COLOR ) );
+            const int nTransparency( setupOutDevState( viewState, renderState, IGNORE_COLOR ) );
             const PolyPolygon aPolyPoly( tools::mapPolyPolygon( tools::polyPolygonFromXPolyPolygon2D(xPolyPolygon),
                                                                 viewState, renderState ) );
 
@@ -410,17 +416,42 @@
             if( !setupTextOutput( aOutpos, viewState, renderState, xFont ) )
                 return uno::Reference< rendering::XCachedPrimitive >(NULL); // no output necessary
 
+            // change text direction and layout mode
+            ULONG nLayoutMode(0);
+            switch( textDirection )
+            {
+                case rendering::TextDirection::WEAK_LEFT_TO_RIGHT:
+                    nLayoutMode |= TEXT_LAYOUT_BIDI_LTR;
+                    // FALLTHROUGH intended
+                case rendering::TextDirection::STRONG_LEFT_TO_RIGHT:
+                    nLayoutMode |= TEXT_LAYOUT_BIDI_LTR | TEXT_LAYOUT_BIDI_STRONG;
+                    nLayoutMode |= TEXT_LAYOUT_TEXTORIGIN_LEFT;
+                    break;
+
+                case rendering::TextDirection::WEAK_RIGHT_TO_LEFT:
+                    nLayoutMode |= TEXT_LAYOUT_BIDI_RTL;
+                    // FALLTHROUGH intended
+                case rendering::TextDirection::STRONG_RIGHT_TO_LEFT:
+                    nLayoutMode |= TEXT_LAYOUT_BIDI_RTL | TEXT_LAYOUT_BIDI_STRONG;
+                    nLayoutMode |= TEXT_LAYOUT_TEXTORIGIN_RIGHT;
+                    break;
+            }
+
             // TODO(F2): alpha
+            mpOutDev->getOutDev().SetLayoutMode( nLayoutMode );
             mpOutDev->getOutDev().DrawText( aOutpos,
                                             text.Text,
                                             ::canvas::tools::numeric_cast<USHORT>(text.StartPosition),
                                             ::canvas::tools::numeric_cast<USHORT>(text.Length) );
 
             if( mp2ndOutDev.get() )
+            {
+                mp2ndOutDev->getOutDev().SetLayoutMode( nLayoutMode );
                 mp2ndOutDev->getOutDev().DrawText( aOutpos,
                                                    text.Text,
                                                    ::canvas::tools::numeric_cast<USHORT>(text.StartPosition),
                                                    ::canvas::tools::numeric_cast<USHORT>(text.Length) );
+            }
         }
 
         return uno::Reference< rendering::XCachedPrimitive >(NULL);
@@ -494,9 +525,26 @@
                 (!::basegfx::fTools::equalZero( aMatrix.get(0,1) ) ||
                  !::basegfx::fTools::equalZero( aMatrix.get(1,0) )) )
             {
+                const BitmapEx& rBmpEx( tools::bitmapExFromXBitmap(xBitmap) );
+
+                // modify output position, to account for the fact
+                // that transformBitmap() always normalizes its output
+                // bitmap into the smallest enclosing box.
+                const Size				aBmpSize( rBmpEx.GetSizePixel() );
+                ::basegfx::B2DRectangle	aDestRect;            
+                ::canvas::tools::calcTransformedRectBounds( aDestRect, 
+                                                            ::basegfx::B2DRectangle(0,
+                                                                                    0,
+                                                                                    aBmpSize.Width(),
+                                                                                    aBmpSize.Height()),
+                                                            aMatrix );
+
+                aOutputPos.setX( aDestRect.getMinX() );
+                aOutputPos.setY( aDestRect.getMinY() );
+
                 // complex transformation, use generic affine bitmap
                 // transformation
-                aBmpEx = tools::transformBitmap( tools::bitmapExFromXBitmap(xBitmap),
+                aBmpEx = tools::transformBitmap( rBmpEx,
                                                  viewState, renderState );
             }
             else if( !aMatrix.isIdentity() &&
@@ -918,7 +966,7 @@
                     ::basegfx::unotools::homMatrixFromAffineMatrix( aMatrix, 
                                                                     viewState.AffineTransform ) );
                 
-                aClipRegion = Region( ::PolyPolygon( aClipPoly ) );
+                aClipRegion = Region::GetRegionFromPolyPolygon( ::PolyPolygon( aClipPoly ) );
             }
         }
 
@@ -937,12 +985,12 @@
             if( aClipPoly.count() )
             {
                 // setup non-empty clipping
-                Region aRegion = Region( ::PolyPolygon( aClipPoly ) );
+                Region aRegion = Region::GetRegionFromPolyPolygon( ::PolyPolygon( aClipPoly ) );
 
                 if( aClipRegion.IsEmpty() )
                     aClipRegion = aRegion;
                 else
-                    aClipRegion.Intersect( Region( ::PolyPolygon( aClipPoly ) ) );
+                    aClipRegion.Intersect( aRegion );
             }
             else
             {
@@ -1001,13 +1049,15 @@
                     break;
 
                 case FILL_COLOR:
+                    // #i42440# Make VCL canvas comply to XCanvas polygon fill
+                    // semantics (no exclusion of rightmost/bottommost pixel).
                     rOutDev.SetFillColor( aColor );
-                    rOutDev.SetLineColor();
+                    rOutDev.SetLineColor( aColor );
 
                     if( p2ndOutDev )
                     {
                         p2ndOutDev->SetFillColor( aColor );
-                        p2ndOutDev->SetLineColor();
+                        p2ndOutDev->SetLineColor( aColor );
                     }
                     break;
 
diff -u -r  canvas/source/vcl/canvashelper.hxx  canvas/source/vcl/canvashelper.hxx
---  canvas/source/vcl/canvashelper.hxx	2004-11-26 22:42:14.000000000 +0530
+++  canvas/source/vcl/canvashelper.hxx	2005-02-28 13:41:07.586652838 +0530
@@ -62,11 +62,11 @@
 #ifndef _VCLCANVAS_CANVASHELPER_HXX_
 #define _VCLCANVAS_CANVASHELPER_HXX_
 
-#ifndef _DRAFTS_COM_SUN_STAR_RENDERING_XCANVAS_HPP_
-#include <drafts/com/sun/star/rendering/XCanvas.hpp>
+#ifndef _COM_SUN_STAR_RENDERING_XCANVAS_HPP_
+#include <com/sun/star/rendering/XCanvas.hpp>
 #endif
-#ifndef _DRAFTS_COM_SUN_STAR_RENDERING_XINTEGERBITMAP_HPP_
-#include <drafts/com/sun/star/rendering/XIntegerBitmap.hpp>
+#ifndef _COM_SUN_STAR_RENDERING_XINTEGERBITMAP_HPP_
+#include <com/sun/star/rendering/XIntegerBitmap.hpp>
 #endif
 
 #ifndef _SV_OUTDEV_HXX
@@ -114,126 +114,126 @@
 
         // XCanvas (only providing, not implementing the
         // interface. Also note subtle method parameter differences)
-        void SAL_CALL drawPoint( const ::drafts::com::sun::star::geometry::RealPoint2D& 	aPoint, 
-                                 const ::drafts::com::sun::star::rendering::ViewState& 		viewState, 
-                                 const ::drafts::com::sun::star::rendering::RenderState& 	renderState );
-        void SAL_CALL drawLine( const ::drafts::com::sun::star::geometry::RealPoint2D& 	aStartPoint, 
-                                const ::drafts::com::sun::star::geometry::RealPoint2D& 	aEndPoint, 
-                                const ::drafts::com::sun::star::rendering::ViewState& 	viewState, 
-                                const ::drafts::com::sun::star::rendering::RenderState& renderState	);
-        void SAL_CALL drawBezier( const ::drafts::com::sun::star::geometry::RealBezierSegment2D&	aBezierSegment, 
-                                  const ::drafts::com::sun::star::geometry::RealPoint2D& 			aEndPoint,
-                                  const ::drafts::com::sun::star::rendering::ViewState& 			viewState, 
-                                  const ::drafts::com::sun::star::rendering::RenderState& 			renderState );
-        ::com::sun::star::uno::Reference< ::drafts::com::sun::star::rendering::XCachedPrimitive > SAL_CALL 	
-        	drawPolyPolygon( const ::com::sun::star::uno::Reference< ::drafts::com::sun::star::rendering::XPolyPolygon2D >& xPolyPolygon, 
-                             const ::drafts::com::sun::star::rendering::ViewState& 											viewState, 
-                             const ::drafts::com::sun::star::rendering::RenderState& 										renderState );
-        ::com::sun::star::uno::Reference< ::drafts::com::sun::star::rendering::XCachedPrimitive > SAL_CALL 	
-        	strokePolyPolygon( const ::com::sun::star::uno::Reference< ::drafts::com::sun::star::rendering::XPolyPolygon2D >& 	xPolyPolygon, 
-                               const ::drafts::com::sun::star::rendering::ViewState& 											viewState, 
-                               const ::drafts::com::sun::star::rendering::RenderState& 											renderState, 
-                               const ::drafts::com::sun::star::rendering::StrokeAttributes& 									strokeAttributes );
-        ::com::sun::star::uno::Reference< ::drafts::com::sun::star::rendering::XCachedPrimitive > SAL_CALL 	
-        	strokeTexturedPolyPolygon( const ::com::sun::star::uno::Reference< ::drafts::com::sun::star::rendering::XPolyPolygon2D >& 	xPolyPolygon, 
-                                       const ::drafts::com::sun::star::rendering::ViewState& 											viewState, 
-                                       const ::drafts::com::sun::star::rendering::RenderState& 											renderState, 
-                                       const ::com::sun::star::uno::Sequence< ::drafts::com::sun::star::rendering::Texture >& 			textures, 
-                                       const ::drafts::com::sun::star::rendering::StrokeAttributes& 									strokeAttributes );
-        ::com::sun::star::uno::Reference< ::drafts::com::sun::star::rendering::XCachedPrimitive > SAL_CALL 	
-        	strokeTextureMappedPolyPolygon( const ::com::sun::star::uno::Reference< ::drafts::com::sun::star::rendering::XPolyPolygon2D >& 	xPolyPolygon, 
-                                            const ::drafts::com::sun::star::rendering::ViewState& 											viewState, 
-                                            const ::drafts::com::sun::star::rendering::RenderState& 										renderState, 
-                                            const ::com::sun::star::uno::Sequence< ::drafts::com::sun::star::rendering::Texture >& 			textures, 
-                                            const ::com::sun::star::uno::Reference< ::drafts::com::sun::star::geometry::XMapping2D >& 		xMapping, 
-                                            const ::drafts::com::sun::star::rendering::StrokeAttributes& 									strokeAttributes );
-        ::com::sun::star::uno::Reference< ::drafts::com::sun::star::rendering::XPolyPolygon2D >   SAL_CALL 	
-        	queryStrokeShapes( const ::com::sun::star::uno::Reference< ::drafts::com::sun::star::rendering::XPolyPolygon2D >& 	xPolyPolygon, 
-                               const ::drafts::com::sun::star::rendering::ViewState& 											viewState, 
-                               const ::drafts::com::sun::star::rendering::RenderState& 											renderState, 
-                               const ::drafts::com::sun::star::rendering::StrokeAttributes& 									strokeAttributes );
-        ::com::sun::star::uno::Reference< ::drafts::com::sun::star::rendering::XCachedPrimitive > SAL_CALL 	
-        	fillPolyPolygon( const ::com::sun::star::uno::Reference< ::drafts::com::sun::star::rendering::XPolyPolygon2D >& xPolyPolygon, 
-                             const ::drafts::com::sun::star::rendering::ViewState& 											viewState, 
-                             const ::drafts::com::sun::star::rendering::RenderState& 										renderState );
-        ::com::sun::star::uno::Reference< ::drafts::com::sun::star::rendering::XCachedPrimitive > SAL_CALL 	
-        	fillTexturedPolyPolygon( const ::com::sun::star::uno::Reference< ::drafts::com::sun::star::rendering::XPolyPolygon2D >& xPolyPolygon, 
-                                     const ::drafts::com::sun::star::rendering::ViewState& 											viewState, 
-                                     const ::drafts::com::sun::star::rendering::RenderState& 										renderState, 
-                                     const ::com::sun::star::uno::Sequence< ::drafts::com::sun::star::rendering::Texture >& 		textures );
-        ::com::sun::star::uno::Reference< ::drafts::com::sun::star::rendering::XCachedPrimitive > SAL_CALL 	
-        	fillTextureMappedPolyPolygon( const ::com::sun::star::uno::Reference< ::drafts::com::sun::star::rendering::XPolyPolygon2D >& 	xPolyPolygon, 
-                                          const ::drafts::com::sun::star::rendering::ViewState& 											viewState, 
-                                          const ::drafts::com::sun::star::rendering::RenderState& 											renderState, 
-                                          const ::com::sun::star::uno::Sequence< ::drafts::com::sun::star::rendering::Texture >& 			textures, 
-                                          const ::com::sun::star::uno::Reference< ::drafts::com::sun::star::geometry::XMapping2D >& 		xMapping );
+        void SAL_CALL drawPoint( const ::com::sun::star::geometry::RealPoint2D& 	aPoint, 
+                                 const ::com::sun::star::rendering::ViewState& 		viewState, 
+                                 const ::com::sun::star::rendering::RenderState& 	renderState );
+        void SAL_CALL drawLine( const ::com::sun::star::geometry::RealPoint2D& 	aStartPoint, 
+                                const ::com::sun::star::geometry::RealPoint2D& 	aEndPoint, 
+                                const ::com::sun::star::rendering::ViewState& 	viewState, 
+                                const ::com::sun::star::rendering::RenderState& renderState	);
+        void SAL_CALL drawBezier( const ::com::sun::star::geometry::RealBezierSegment2D&	aBezierSegment, 
+                                  const ::com::sun::star::geometry::RealPoint2D& 			aEndPoint,
+                                  const ::com::sun::star::rendering::ViewState& 			viewState, 
+                                  const ::com::sun::star::rendering::RenderState& 			renderState );
+        ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XCachedPrimitive > SAL_CALL 	
+        	drawPolyPolygon( const ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XPolyPolygon2D >& xPolyPolygon, 
+                             const ::com::sun::star::rendering::ViewState& 											viewState, 
+                             const ::com::sun::star::rendering::RenderState& 										renderState );
+        ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XCachedPrimitive > SAL_CALL 	
+        	strokePolyPolygon( const ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XPolyPolygon2D >& 	xPolyPolygon, 
+                               const ::com::sun::star::rendering::ViewState& 											viewState, 
+                               const ::com::sun::star::rendering::RenderState& 											renderState, 
+                               const ::com::sun::star::rendering::StrokeAttributes& 									strokeAttributes );
+        ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XCachedPrimitive > SAL_CALL 	
+        	strokeTexturedPolyPolygon( const ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XPolyPolygon2D >& 	xPolyPolygon, 
+                                       const ::com::sun::star::rendering::ViewState& 											viewState, 
+                                       const ::com::sun::star::rendering::RenderState& 											renderState, 
+                                       const ::com::sun::star::uno::Sequence< ::com::sun::star::rendering::Texture >& 			textures, 
+                                       const ::com::sun::star::rendering::StrokeAttributes& 									strokeAttributes );
+        ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XCachedPrimitive > SAL_CALL 	
+        	strokeTextureMappedPolyPolygon( const ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XPolyPolygon2D >& 	xPolyPolygon, 
+                                            const ::com::sun::star::rendering::ViewState& 											viewState, 
+                                            const ::com::sun::star::rendering::RenderState& 										renderState, 
+                                            const ::com::sun::star::uno::Sequence< ::com::sun::star::rendering::Texture >& 			textures, 
+                                            const ::com::sun::star::uno::Reference< ::com::sun::star::geometry::XMapping2D >& 		xMapping, 
+                                            const ::com::sun::star::rendering::StrokeAttributes& 									strokeAttributes );
+        ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XPolyPolygon2D >   SAL_CALL 	
+        	queryStrokeShapes( const ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XPolyPolygon2D >& 	xPolyPolygon, 
+                               const ::com::sun::star::rendering::ViewState& 											viewState, 
+                               const ::com::sun::star::rendering::RenderState& 											renderState, 
+                               const ::com::sun::star::rendering::StrokeAttributes& 									strokeAttributes );
+        ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XCachedPrimitive > SAL_CALL 	
+        	fillPolyPolygon( const ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XPolyPolygon2D >& xPolyPolygon, 
+                             const ::com::sun::star::rendering::ViewState& 											viewState, 
+                             const ::com::sun::star::rendering::RenderState& 										renderState );
+        ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XCachedPrimitive > SAL_CALL 	
+        	fillTexturedPolyPolygon( const ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XPolyPolygon2D >& xPolyPolygon, 
+                                     const ::com::sun::star::rendering::ViewState& 											viewState, 
+                                     const ::com::sun::star::rendering::RenderState& 										renderState, 
+                                     const ::com::sun::star::uno::Sequence< ::com::sun::star::rendering::Texture >& 		textures );
+        ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XCachedPrimitive > SAL_CALL 	
+        	fillTextureMappedPolyPolygon( const ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XPolyPolygon2D >& 	xPolyPolygon, 
+                                          const ::com::sun::star::rendering::ViewState& 											viewState, 
+                                          const ::com::sun::star::rendering::RenderState& 											renderState, 
+                                          const ::com::sun::star::uno::Sequence< ::com::sun::star::rendering::Texture >& 			textures, 
+                                          const ::com::sun::star::uno::Reference< ::com::sun::star::geometry::XMapping2D >& 		xMapping );
 
-        ::com::sun::star::uno::Reference< ::drafts::com::sun::star::rendering::XCanvasFont > SAL_CALL
-        	createFont( const ::drafts::com::sun::star::rendering::FontRequest& 								fontRequest, 
+        ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XCanvasFont > SAL_CALL
+        	createFont( const ::com::sun::star::rendering::FontRequest& 								fontRequest, 
                         const ::com::sun::star::uno::Sequence< ::com::sun::star::beans::PropertyValue >& 		extraFontProperties, 
-                        const ::drafts::com::sun::star::geometry::Matrix2D& 									fontMatrix );
+                        const ::com::sun::star::geometry::Matrix2D& 									fontMatrix );
 
-        ::com::sun::star::uno::Sequence< ::drafts::com::sun::star::rendering::FontInfo > SAL_CALL 
-        	queryAvailableFonts( const ::drafts::com::sun::star::rendering::FontInfo& 								aFilter, 
+        ::com::sun::star::uno::Sequence< ::com::sun::star::rendering::FontInfo > SAL_CALL 
+        	queryAvailableFonts( const ::com::sun::star::rendering::FontInfo& 								aFilter, 
                                  const ::com::sun::star::uno::Sequence< ::com::sun::star::beans::PropertyValue >& 	aFontProperties );
 
-        ::com::sun::star::uno::Reference< ::drafts::com::sun::star::rendering::XCachedPrimitive > SAL_CALL 
-        	drawText( const ::drafts::com::sun::star::rendering::StringContext& 									text, 
-                      const ::com::sun::star::uno::Reference< ::drafts::com::sun::star::rendering::XCanvasFont >& 	xFont, 
-                      const ::drafts::com::sun::star::rendering::ViewState& 										viewState, 
-                      const ::drafts::com::sun::star::rendering::RenderState& 										renderState, 
+        ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XCachedPrimitive > SAL_CALL 
+        	drawText( const ::com::sun::star::rendering::StringContext& 									text, 
+                      const ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XCanvasFont >& 	xFont, 
+                      const ::com::sun::star::rendering::ViewState& 										viewState, 
+                      const ::com::sun::star::rendering::RenderState& 										renderState, 
                       sal_Int8 																						textDirection );
 
-        ::com::sun::star::uno::Reference< ::drafts::com::sun::star::rendering::XCachedPrimitive > SAL_CALL 
-        	drawTextLayout( const ::com::sun::star::uno::Reference< ::drafts::com::sun::star::rendering::XTextLayout >& layoutetText, 
-                            const ::drafts::com::sun::star::rendering::ViewState& 										viewState, 
-                            const ::drafts::com::sun::star::rendering::RenderState& 									renderState );
-
-        ::com::sun::star::uno::Reference< ::drafts::com::sun::star::rendering::XCachedPrimitive > SAL_CALL 	
-        	drawBitmap( const ::com::sun::star::uno::Reference< ::drafts::com::sun::star::rendering::XBitmap >& xBitmap, 
-                        const ::drafts::com::sun::star::rendering::ViewState& 									viewState, 
-                        const ::drafts::com::sun::star::rendering::RenderState& 								renderState );
-        ::com::sun::star::uno::Reference< ::drafts::com::sun::star::rendering::XCachedPrimitive > SAL_CALL 	
-        	drawBitmapModulated( const ::com::sun::star::uno::Reference< ::drafts::com::sun::star::rendering::XBitmap >&	xBitmap, 
-                                 const ::drafts::com::sun::star::rendering::ViewState& 										viewState, 
-                                 const ::drafts::com::sun::star::rendering::RenderState& 									renderState );
-        ::com::sun::star::uno::Reference< ::drafts::com::sun::star::rendering::XGraphicDevice > SAL_CALL 
+        ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XCachedPrimitive > SAL_CALL 
+        	drawTextLayout( const ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XTextLayout >& layoutetText, 
+                            const ::com::sun::star::rendering::ViewState& 										viewState, 
+                            const ::com::sun::star::rendering::RenderState& 									renderState );
+
+        ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XCachedPrimitive > SAL_CALL 	
+        	drawBitmap( const ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XBitmap >& xBitmap, 
+                        const ::com::sun::star::rendering::ViewState& 									viewState, 
+                        const ::com::sun::star::rendering::RenderState& 								renderState );
+        ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XCachedPrimitive > SAL_CALL 	
+        	drawBitmapModulated( const ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XBitmap >&	xBitmap, 
+                                 const ::com::sun::star::rendering::ViewState& 										viewState, 
+                                 const ::com::sun::star::rendering::RenderState& 									renderState );
+        ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XGraphicDevice > SAL_CALL 
         	getDevice();
 
         // BitmapCanvasHelper functionality
         // ================================
 
-        void SAL_CALL copyRect( const ::com::sun::star::uno::Reference< ::drafts::com::sun::star::rendering::XBitmapCanvas >& 	sourceCanvas, 
-                                const ::drafts::com::sun::star::geometry::RealRectangle2D& 										sourceRect, 
-                                const ::drafts::com::sun::star::rendering::ViewState& 											sourceViewState, 
-                                const ::drafts::com::sun::star::rendering::RenderState& 										sourceRenderState, 
-                                const ::drafts::com::sun::star::geometry::RealRectangle2D& 										destRect, 
-                                const ::drafts::com::sun::star::rendering::ViewState& 											destViewState, 
-                                const ::drafts::com::sun::star::rendering::RenderState& 										destRenderState );
+        void SAL_CALL copyRect( const ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XBitmapCanvas >& 	sourceCanvas, 
+                                const ::com::sun::star::geometry::RealRectangle2D& 										sourceRect, 
+                                const ::com::sun::star::rendering::ViewState& 											sourceViewState, 
+                                const ::com::sun::star::rendering::RenderState& 										sourceRenderState, 
+                                const ::com::sun::star::geometry::RealRectangle2D& 										destRect, 
+                                const ::com::sun::star::rendering::ViewState& 											destViewState, 
+                                const ::com::sun::star::rendering::RenderState& 										destRenderState );
             
-        ::drafts::com::sun::star::geometry::IntegerSize2D SAL_CALL getSize();
+        ::com::sun::star::geometry::IntegerSize2D SAL_CALL getSize();
 
-        ::com::sun::star::uno::Reference< ::drafts::com::sun::star::rendering::XBitmapCanvas > SAL_CALL queryBitmapCanvas();
+        ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XBitmapCanvas > SAL_CALL queryBitmapCanvas();
 
-        ::com::sun::star::uno::Reference< ::drafts::com::sun::star::rendering::XBitmap > SAL_CALL 
-        	getScaledBitmap( const ::drafts::com::sun::star::geometry::RealSize2D& 	newSize, 
+        ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XBitmap > SAL_CALL 
+        	getScaledBitmap( const ::com::sun::star::geometry::RealSize2D& 	newSize, 
                              sal_Bool 												beFast );
 
         ::com::sun::star::uno::Sequence< sal_Int8 > SAL_CALL 
-	        getData( const ::drafts::com::sun::star::geometry::IntegerRectangle2D& rect );
+	        getData( const ::com::sun::star::geometry::IntegerRectangle2D& rect );
 
         void SAL_CALL setData( const ::com::sun::star::uno::Sequence< sal_Int8 >& 				data, 
-                               const ::drafts::com::sun::star::geometry::IntegerRectangle2D& 	rect );
+                               const ::com::sun::star::geometry::IntegerRectangle2D& 	rect );
 
         void SAL_CALL setPixel( const ::com::sun::star::uno::Sequence< sal_Int8 >& 			color, 
-                                const ::drafts::com::sun::star::geometry::IntegerPoint2D& 	pos );
+                                const ::com::sun::star::geometry::IntegerPoint2D& 	pos );
 
         ::com::sun::star::uno::Sequence< sal_Int8 > SAL_CALL 
-	        getPixel( const ::drafts::com::sun::star::geometry::IntegerPoint2D& pos );
+	        getPixel( const ::com::sun::star::geometry::IntegerPoint2D& pos );
 
-        ::com::sun::star::uno::Reference< ::drafts::com::sun::star::rendering::XBitmapPalette > SAL_CALL getPalette();
+        ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XBitmapPalette > SAL_CALL getPalette();
 
-        ::drafts::com::sun::star::rendering::IntegerBitmapLayout SAL_CALL getMemoryLayout();
+        ::com::sun::star::rendering::IntegerBitmapLayout SAL_CALL getMemoryLayout();
 
 
         // Flush drawing queue to screen (only works for Window outdev)
@@ -245,8 +245,8 @@
         };
         
         // returns transparency of color
-        int setupOutDevState( const ::drafts::com::sun::star::rendering::ViewState& 	viewState, 
-                              const ::drafts::com::sun::star::rendering::RenderState& 	renderState,
+        int setupOutDevState( const ::com::sun::star::rendering::ViewState& 	viewState, 
+                              const ::com::sun::star::rendering::RenderState& 	renderState,
                               ColorType													eColorType );
     protected:
         /// Phyical output device
@@ -264,9 +264,9 @@
         CanvasHelper& operator=( const CanvasHelper& );
         
         bool setupTextOutput( ::Point&																						o_rOutPos,
-                              const ::drafts::com::sun::star::rendering::ViewState& 										viewState, 
-                              const ::drafts::com::sun::star::rendering::RenderState& 										renderState, 
-                              const ::com::sun::star::uno::Reference< ::drafts::com::sun::star::rendering::XCanvasFont >&	xFont );
+                              const ::com::sun::star::rendering::ViewState& 										viewState, 
+                              const ::com::sun::star::rendering::RenderState& 										renderState, 
+                              const ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XCanvasFont >&	xFont );
 
     };
 }
diff -u -r  canvas/source/vcl/impltools.cxx  canvas/source/vcl/impltools.cxx
---  canvas/source/vcl/impltools.cxx	2004-11-26 22:43:05.000000000 +0530
+++  canvas/source/vcl/impltools.cxx	2005-02-28 13:41:07.587652721 +0530
@@ -70,33 +70,36 @@
 #include <rtl/logfile.hxx>
 #endif
 
-#ifndef _DRAFTS_COM_SUN_STAR_GEOMETRY_REALSIZE2D_HPP__
-#include <drafts/com/sun/star/geometry/RealSize2D.hpp>
+#ifndef _COM_SUN_STAR_GEOMETRY_REALSIZE2D_HPP__
+#include <com/sun/star/geometry/RealSize2D.hpp>
 #endif
-#ifndef _DRAFTS_COM_SUN_STAR_GEOMETRY_REALPOINT2D_HPP__
-#include <drafts/com/sun/star/geometry/RealPoint2D.hpp>
+#ifndef _COM_SUN_STAR_GEOMETRY_REALPOINT2D_HPP__
+#include <com/sun/star/geometry/RealPoint2D.hpp>
 #endif
-#ifndef _DRAFTS_COM_SUN_STAR_GEOMETRY_REALRECTANGLE2D_HPP__
-#include <drafts/com/sun/star/geometry/RealRectangle2D.hpp>
+#ifndef _COM_SUN_STAR_GEOMETRY_REALRECTANGLE2D_HPP__
+#include <com/sun/star/geometry/RealRectangle2D.hpp>
 #endif
 
-#ifndef _DRAFTS_COM_SUN_STAR_RENDERING_RENDERSTATE_HPP__
-#include <drafts/com/sun/star/rendering/RenderState.hpp>
+#ifndef _COM_SUN_STAR_RENDERING_RENDERSTATE_HPP__
+#include <com/sun/star/rendering/RenderState.hpp>
 #endif
-#ifndef _DRAFTS_COM_SUN_STAR_RENDERING_XCANVAS_HPP__
-#include <drafts/com/sun/star/rendering/XCanvas.hpp>
+#ifndef _COM_SUN_STAR_RENDERING_XCANVAS_HPP__
+#include <com/sun/star/rendering/XCanvas.hpp>
 #endif
-#ifndef _DRAFTS_COM_SUN_STAR_RENDERING_XBITMAP_HPP__
-#include <drafts/com/sun/star/rendering/XBitmap.hpp>
+#ifndef _COM_SUN_STAR_RENDERING_XBITMAP_HPP__
+#include <com/sun/star/rendering/XBitmap.hpp>
 #endif
-#ifndef _DRAFTS_COM_SUN_STAR_RENDERING_XPOLYPOLYGON2D_HPP__
-#include <drafts/com/sun/star/rendering/XPolyPolygon2D.hpp>
+#ifndef _COM_SUN_STAR_RENDERING_XPOLYPOLYGON2D_HPP__
+#include <com/sun/star/rendering/XPolyPolygon2D.hpp>
 #endif
-#ifndef _DRAFTS_COM_SUN_STAR_GEOMETRY_REALBEZIERSEGMENT2D_HPP__
-#include <drafts/com/sun/star/geometry/RealBezierSegment2D.hpp>
+#ifndef _COM_SUN_STAR_GEOMETRY_REALBEZIERSEGMENT2D_HPP__
+#include <com/sun/star/geometry/RealBezierSegment2D.hpp>
 #endif
-#ifndef _DRAFTS_COM_SUN_STAR_RENDERING_XINTEGERBITMAP_HPP__
-#include <drafts/com/sun/star/rendering/XIntegerBitmap.hpp>
+#ifndef _COM_SUN_STAR_RENDERING_XINTEGERBITMAP_HPP__
+#include <com/sun/star/rendering/XIntegerBitmap.hpp>
+#endif
+#ifndef _COM_SUN_STAR_LANG_XUNOTUNNEL_HPP_
+#include <com/sun/star/lang/XUnoTunnel.hpp>
 #endif
 
 #ifndef _SV_SALBTYPE_HXX
@@ -146,7 +149,6 @@
 
 
 using namespace ::com::sun::star;
-using namespace ::drafts::com::sun::star;
 
 namespace vclcanvas
 {
@@ -188,6 +190,13 @@
             }
             else
             {
+                uno::Reference< lang::XUnoTunnel > xTunnel( xBitmap, uno::UNO_QUERY );
+                if( xTunnel.is() )
+                {
+                    sal_Int64 nPtr = xTunnel->getSomething( vcl::unotools::getTunnelIdentifier( vcl::unotools::Id_BitmapEx ) );
+                    if( nPtr )
+                        return BitmapEx( *(BitmapEx*)nPtr );
+                }
                 // TODO(F1): extract pixel from XBitmap interface
                 ENSURE_AND_THROW( false, 
                                   "bitmapExFromXBitmap(): could not extract bitmap" );
@@ -296,14 +305,13 @@
             ::canvas::tools::mergeViewAndRenderTransform(aTransform,
                                                          rViewState,
                                                          rRenderState);
-            aTransform.set(0,2,0.0);
-            aTransform.set(1,2,0.0);
 
             const Size 					aBmpSize( rBitmap.GetSizePixel() );
             ::basegfx::B2DRectangle		aDestRect;
             
             bool bCopyBack( false );
-            
+
+            // calc effective transformation for bitmap
             ::canvas::tools::calcTransformedRectBounds( aDestRect, 
                                                         ::basegfx::B2DRectangle(0,
                                                                                 0,
@@ -311,6 +319,15 @@
                                                                                 aBmpSize.Height()),
                                                         aTransform );
 
+            // re-center bitmap, such that it's left, top border is
+            // aligned with (0,0). The method takes the given
+            // rectangle, and calculates a transformation that maps
+            // this rectangle unscaled to the origin.
+            ::basegfx::B2DHomMatrix aLocalTransform;
+            ::canvas::tools::calcRectToOriginTransform( aLocalTransform,
+                                                        aDestRect,
+                                                        aTransform );
+
             const bool bModulateColors( eModulationMode == MODULATE_WITH_DEVICECOLOR &&
                                         rRenderState.DeviceColor.getLength() > 2 );
             const double nRedModulation( bModulateColors ? rRenderState.DeviceColor[0] : 1.0 );
@@ -350,6 +367,9 @@
             const Size aDestBmpSize( ::basegfx::fround( aDestRect.getMaxX() ), 
                                      ::basegfx::fround( aDestRect.getMaxY() ) );
 
+            if( aDestBmpSize.Width() == 0 || aDestBmpSize.Height() == 0 )
+                return BitmapEx();
+
             Bitmap aDstBitmap( aDestBmpSize, aSrcBitmap.GetBitCount(), &pReadAccess->GetPalette() );
             Bitmap aDstAlpha( AlphaMask( aDestBmpSize ).GetBitmap() );
 
diff -u -r  canvas/source/vcl/impltools.hxx  canvas/source/vcl/impltools.hxx
---  canvas/source/vcl/impltools.hxx	2004-11-26 22:43:19.000000000 +0530
+++  canvas/source/vcl/impltools.hxx	2005-02-28 13:41:07.587652721 +0530
@@ -128,21 +128,21 @@
     struct HomogenMatrix3;
 } } } }
 
-namespace drafts { namespace com { namespace sun { namespace star { namespace geometry 
+namespace com { namespace sun { namespace star { namespace geometry 
 {
     struct RealPoint2D;
     struct RealSize2D;
     struct RealRectangle2D;
-} } } } }
+} } } }
 
-namespace drafts { namespace com { namespace sun { namespace star { namespace rendering 
+namespace com { namespace sun { namespace star { namespace rendering 
 {
     struct RenderState;
     struct ViewState;
     class  XCanvas;
     class  XBitmap;
     class  XPolyPolygon2D;
-} } } } }
+} } } }
 
 
 namespace vclcanvas
@@ -151,11 +151,11 @@
     {
         ::basegfx::B2DPolyPolygon
         polyPolygonFromXPolyPolygon2D( const ::com::sun::star::uno::Reference< 
-                                       ::drafts::com::sun::star::rendering::XPolyPolygon2D >& );
+                                       ::com::sun::star::rendering::XPolyPolygon2D >& );
 
         ::BitmapEx
         bitmapExFromXBitmap( const ::com::sun::star::uno::Reference< 
-                             ::drafts::com::sun::star::rendering::XBitmap >& );
+                             ::com::sun::star::rendering::XBitmap >& );
 
         /** Setup VCL font and output position
 
@@ -163,8 +163,8 @@
          */
         bool setupFontTransform( ::Point&													o_rPoint,
                                  ::Font& 													io_rVCLFont, 
-                                 const ::drafts::com::sun::star::rendering::ViewState& 		viewState,
-                                 const ::drafts::com::sun::star::rendering::RenderState& 	renderState,
+                                 const ::com::sun::star::rendering::ViewState& 		viewState,
+                                 const ::com::sun::star::rendering::RenderState& 	renderState,
                                  ::OutputDevice&											rOutDev );
                                  
 
@@ -229,13 +229,13 @@
             const bool		mbMappingWasEnabled;
         };
 
-        ::Point mapRealPoint2D( const ::drafts::com::sun::star::geometry::RealPoint2D& 	rPoint,
-                                const ::drafts::com::sun::star::rendering::ViewState& 	rViewState,
-                                const ::drafts::com::sun::star::rendering::RenderState&	rRenderState );
+        ::Point mapRealPoint2D( const ::com::sun::star::geometry::RealPoint2D& 	rPoint,
+                                const ::com::sun::star::rendering::ViewState& 	rViewState,
+                                const ::com::sun::star::rendering::RenderState&	rRenderState );
 
         ::PolyPolygon mapPolyPolygon( const ::basegfx::B2DPolyPolygon& 							rPoly,
-                                      const ::drafts::com::sun::star::rendering::ViewState& 	rViewState,
-                                      const ::drafts::com::sun::star::rendering::RenderState&	rRenderState );
+                                      const ::com::sun::star::rendering::ViewState& 	rViewState,
+                                      const ::com::sun::star::rendering::RenderState&	rRenderState );
 
         enum ModulationMode
         {
@@ -244,8 +244,8 @@
         };
 
         ::BitmapEx transformBitmap( const BitmapEx& 										rBitmap,
-                                    const ::drafts::com::sun::star::rendering::ViewState& 	rViewState,
-                                    const ::drafts::com::sun::star::rendering::RenderState&	rRenderState,
+                                    const ::com::sun::star::rendering::ViewState& 	rViewState,
+                                    const ::com::sun::star::rendering::RenderState&	rRenderState,
                                     ModulationMode											eModulationMode=MODULATE_NONE );
 
 	}
diff -u -r  canvas/source/vcl/linepolypolygon.cxx  canvas/source/vcl/linepolypolygon.cxx
---  canvas/source/vcl/linepolypolygon.cxx	2004-11-26 22:43:32.000000000 +0530
+++  canvas/source/vcl/linepolypolygon.cxx	2005-02-28 13:41:07.588652604 +0530
@@ -77,7 +77,6 @@
 
 
 using namespace ::com::sun::star;
-using namespace ::drafts::com::sun::star;
 
 namespace vclcanvas
 {
@@ -96,7 +95,7 @@
         return ::rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( LINEPOLYPOLYGON_IMPLEMENTATION_NAME ) );
     }
 
-#define SERVICE_NAME "drafts.com.sun.star.rendering.LinePolyPolygon"
+#define SERVICE_NAME "com.sun.star.rendering.LinePolyPolygon"
 
     sal_Bool SAL_CALL LinePolyPolygon::supportsService( const ::rtl::OUString& ServiceName ) throw (uno::RuntimeException)
     {
diff -u -r  canvas/source/vcl/linepolypolygon.hxx  canvas/source/vcl/linepolypolygon.hxx
---  canvas/source/vcl/linepolypolygon.hxx	2004-11-26 22:43:45.000000000 +0530
+++  canvas/source/vcl/linepolypolygon.hxx	2005-02-28 13:41:07.588652604 +0530
@@ -77,8 +77,8 @@
 #include <com/sun/star/lang/XServiceInfo.hpp>
 #endif
 
-#ifndef _DRAFTS_COM_SUN_STAR_RENDERING_XLINEPOLYPOLYGON2D_HPP_
-#include <drafts/com/sun/star/rendering/XLinePolyPolygon2D.hpp>
+#ifndef _COM_SUN_STAR_RENDERING_XLINEPOLYPOLYGON2D_HPP_
+#include <com/sun/star/rendering/XLinePolyPolygon2D.hpp>
 #endif
 
 #ifndef _BGFX_POLYGON_B2DPOLYPOLYGON_HXX
diff -u -r  canvas/source/vcl/parametricpolypolygon.cxx  canvas/source/vcl/parametricpolypolygon.cxx
---  canvas/source/vcl/parametricpolypolygon.cxx	2005-01-13 23:28:40.000000000 +0530
+++  canvas/source/vcl/parametricpolypolygon.cxx	2005-02-28 13:41:07.591652254 +0530
@@ -103,7 +103,6 @@
 
 
 using namespace ::com::sun::star;
-using namespace ::drafts::com::sun::star;
 
 namespace vclcanvas
 {
@@ -200,7 +199,7 @@
         return uno::Sequence< double >();
     }
 
-#define SERVICE_NAME "drafts.com.sun.star.rendering.ParametricPolyPolygon"
+#define SERVICE_NAME "com.sun.star.rendering.ParametricPolyPolygon"
 
     ::rtl::OUString SAL_CALL ParametricPolyPolygon::getImplementationName(  ) throw (uno::RuntimeException)
     {
diff -u -r  canvas/source/vcl/parametricpolypolygon.hxx  canvas/source/vcl/parametricpolypolygon.hxx
---  canvas/source/vcl/parametricpolypolygon.hxx	2005-01-13 23:28:55.000000000 +0530
+++  canvas/source/vcl/parametricpolypolygon.hxx	2005-02-28 13:41:07.591652254 +0530
@@ -65,11 +65,11 @@
 #ifndef _COM_SUN_STAR_LANG_XSERVICEINFO_HPP_
 #include <com/sun/star/lang/XServiceInfo.hpp>
 #endif
-#ifndef _DRAFTS_COM_SUN_STAR_RENDERING_XGRAPHICDEVICE_HPP_
-#include <drafts/com/sun/star/rendering/XGraphicDevice.hpp>
+#ifndef _COM_SUN_STAR_RENDERING_XGRAPHICDEVICE_HPP_
+#include <com/sun/star/rendering/XGraphicDevice.hpp>
 #endif
-#ifndef _DRAFTS_COM_SUN_STAR_RENDERING_XPARAMETRICPOLYPOLYGON2DFACTORY_HPP_
-#include <drafts/com/sun/star/rendering/XParametricPolyPolygon2DFactory.hpp>
+#ifndef _COM_SUN_STAR_RENDERING_XPARAMETRICPOLYPOLYGON2DFACTORY_HPP_
+#include <com/sun/star/rendering/XParametricPolyPolygon2DFactory.hpp>
 #endif
 
 #ifndef _CPPUHELPER_COMPBASE2_HXX_
@@ -104,7 +104,7 @@
 
 namespace vclcanvas
 {
-    typedef ::cppu::WeakComponentImplHelper2< ::drafts::com::sun::star::rendering::XParametricPolyPolygon2D,
+    typedef ::cppu::WeakComponentImplHelper2< ::com::sun::star::rendering::XParametricPolyPolygon2D,
             		   			  		      ::com::sun::star::lang::XServiceInfo > ParametricPolyPolygon_Base;
 
     class ParametricPolyPolygon : public ::comphelper::OBaseMutex, public ParametricPolyPolygon_Base
@@ -114,29 +114,29 @@
         static ParametricPolyPolygon* createLinearHorizontalGradient( const ::com::sun::star::uno::Sequence< double >& 			leftColor, 
                                                                       const ::com::sun::star::uno::Sequence< double >& 			rightColor,
                                                                       const ::com::sun::star::uno::Reference< 
-                                                                      	::drafts::com::sun::star::rendering::XGraphicDevice >&  xDevice );
+                                                                      	::com::sun::star::rendering::XGraphicDevice >&  xDevice );
         static ParametricPolyPolygon* createAxialHorizontalGradient( const ::com::sun::star::uno::Sequence< double >& 			middleColor, 
                                                                      const ::com::sun::star::uno::Sequence< double >& 			endColor,
                                                                      const ::com::sun::star::uno::Reference< 
-                                                                      	::drafts::com::sun::star::rendering::XGraphicDevice >&  xDevice );
+                                                                      	::com::sun::star::rendering::XGraphicDevice >&  xDevice );
         static ParametricPolyPolygon* createEllipticalGradient( const ::com::sun::star::uno::Sequence< double >& 				centerColor, 
                                                                 const ::com::sun::star::uno::Sequence< double >& 				endColor,
-                                                                const ::drafts::com::sun::star::geometry::RealRectangle2D&		boundRect,
+                                                                const ::com::sun::star::geometry::RealRectangle2D&		boundRect,
                                                                 const ::com::sun::star::uno::Reference< 
-	                                                             	 ::drafts::com::sun::star::rendering::XGraphicDevice >& 	xDevice );
+	                                                             	 ::com::sun::star::rendering::XGraphicDevice >& 	xDevice );
         static ParametricPolyPolygon* createRectangularGradient( const ::com::sun::star::uno::Sequence< double >& 			centerColor, 
                                                                  const ::com::sun::star::uno::Sequence< double >& 			endColor,
-                                                                 const ::drafts::com::sun::star::geometry::RealRectangle2D&	boundRect,
+                                                                 const ::com::sun::star::geometry::RealRectangle2D&	boundRect,
                                                                  const ::com::sun::star::uno::Reference< 
-	                                                             	 ::drafts::com::sun::star::rendering::XGraphicDevice >& xDevice );
+	                                                             	 ::com::sun::star::rendering::XGraphicDevice >& xDevice );
 
         /// Dispose all internal references
         virtual void SAL_CALL disposing();
 
         // XParametricPolyPolygon2D
-        virtual ::com::sun::star::uno::Reference< ::drafts::com::sun::star::rendering::XPolyPolygon2D > SAL_CALL getOutline( double t ) throw (::com::sun::star::lang::IllegalArgumentException, ::com::sun::star::uno::RuntimeException);
+        virtual ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XPolyPolygon2D > SAL_CALL getOutline( double t ) throw (::com::sun::star::lang::IllegalArgumentException, ::com::sun::star::uno::RuntimeException);
         virtual ::com::sun::star::uno::Sequence< double > SAL_CALL getColor( double t ) throw (::com::sun::star::lang::IllegalArgumentException, ::com::sun::star::uno::RuntimeException);
-        virtual ::com::sun::star::uno::Sequence< double > SAL_CALL getPointColor( const ::drafts::com::sun::star::geometry::RealPoint2D& point ) throw (::com::sun::star::lang::IllegalArgumentException, ::com::sun::star::uno::RuntimeException);
+        virtual ::com::sun::star::uno::Sequence< double > SAL_CALL getPointColor( const ::com::sun::star::geometry::RealPoint2D& point ) throw (::com::sun::star::lang::IllegalArgumentException, ::com::sun::star::uno::RuntimeException);
 
         // XServiceInfo
         virtual ::rtl::OUString SAL_CALL getImplementationName(  ) throw (::com::sun::star::uno::RuntimeException);
@@ -146,9 +146,9 @@
         bool fill( OutputDevice&											rOutDev,
                    OutputDevice*											p2ndOutDev,
                    const PolyPolygon& 										rPoly,
-                   const ::drafts::com::sun::star::rendering::ViewState& 	viewState, 
-                   const ::drafts::com::sun::star::rendering::RenderState&	renderState,
-                   const ::drafts::com::sun::star::rendering::Texture&	    texture,
+                   const ::com::sun::star::rendering::ViewState& 	viewState, 
+                   const ::com::sun::star::rendering::RenderState&	renderState,
+                   const ::com::sun::star::rendering::Texture&	    texture,
                    int 														nTransparency ) const;
 
     protected:
diff -u -r  canvas/source/vcl/spritecanvas.cxx  canvas/source/vcl/spritecanvas.cxx
---  canvas/source/vcl/spritecanvas.cxx	2004-12-02 18:11:49.000000000 +0530
+++  canvas/source/vcl/spritecanvas.cxx	2005-02-28 13:41:07.593652020 +0530
@@ -117,11 +117,10 @@
 #include "windowgraphicdevice.hxx"
 
 using namespace ::com::sun::star;
-using namespace ::drafts::com::sun::star;
 
 
 #define IMPLEMENTATION_NAME "VCLCanvas::SpriteCanvas"
-#define SERVICE_NAME "drafts.com.sun.star.rendering.VCLCanvas"
+#define SERVICE_NAME "com.sun.star.rendering.VCLCanvas"
 
 namespace
 {
diff -u -r  canvas/source/vcl/spritecanvas.hxx  canvas/source/vcl/spritecanvas.hxx
---  canvas/source/vcl/spritecanvas.hxx	2004-12-02 18:11:49.000000000 +0530
+++  canvas/source/vcl/spritecanvas.hxx	2005-02-28 13:41:07.594651903 +0530
@@ -79,11 +79,11 @@
 #ifndef _COM_SUN_STAR_AWT_XWINDOW_HPP_
 #include <com/sun/star/awt/XWindow.hpp>
 #endif
-#ifndef _DRAFTS_COM_SUN_STAR_RENDERING_XSPRITECANVAS_HPP_
-#include <drafts/com/sun/star/rendering/XSpriteCanvas.hpp>
+#ifndef _COM_SUN_STAR_RENDERING_XSPRITECANVAS_HPP_
+#include <com/sun/star/rendering/XSpriteCanvas.hpp>
 #endif
-#ifndef _DRAFTS_COM_SUN_STAR_RENDERING_XINTEGERBITMAP_HPP_
-#include <drafts/com/sun/star/rendering/XIntegerBitmap.hpp>
+#ifndef _COM_SUN_STAR_RENDERING_XINTEGERBITMAP_HPP_
+#include <com/sun/star/rendering/XIntegerBitmap.hpp>
 #endif
 
 #ifndef _CPPUHELPER_COMPBASE6_HXX_
@@ -117,8 +117,8 @@
 
 namespace vclcanvas
 {
-    typedef ::cppu::WeakComponentImplHelper6< ::drafts::com::sun::star::rendering::XSpriteCanvas,
-			                         		  ::drafts::com::sun::star::rendering::XIntegerBitmap,
+    typedef ::cppu::WeakComponentImplHelper6< ::com::sun::star::rendering::XSpriteCanvas,
+			                         		  ::com::sun::star::rendering::XIntegerBitmap,
 											  ::com::sun::star::awt::XWindow,
                                      		  ::com::sun::star::lang::XInitialization,
                                      		  ::com::sun::star::lang::XServiceInfo,
@@ -137,11 +137,11 @@
         virtual void SAL_CALL disposing();
 
         // XSpriteCanvas
-        virtual ::com::sun::star::uno::Reference< ::drafts::com::sun::star::rendering::XAnimatedSprite > SAL_CALL createSpriteFromAnimation( const ::com::sun::star::uno::Reference< ::drafts::com::sun::star::rendering::XAnimation >& animation ) throw (::com::sun::star::lang::IllegalArgumentException, ::com::sun::star::uno::RuntimeException);
-        virtual ::com::sun::star::uno::Reference< ::drafts::com::sun::star::rendering::XAnimatedSprite > SAL_CALL createSpriteFromBitmaps( const ::com::sun::star::uno::Sequence< ::com::sun::star::uno::Reference< ::drafts::com::sun::star::rendering::XBitmap > >& animationBitmaps, 
-                                                                                                                                           sal_Int8                                                                                                                   interpolationMode ) throw (::com::sun::star::lang::IllegalArgumentException, ::drafts::com::sun::star::rendering::VolatileContentDestroyedException, ::com::sun::star::uno::RuntimeException);
-        virtual ::com::sun::star::uno::Reference< ::drafts::com::sun::star::rendering::XCustomSprite > SAL_CALL createCustomSprite( const ::drafts::com::sun::star::geometry::RealSize2D& spriteSize ) throw (::com::sun::star::lang::IllegalArgumentException, ::com::sun::star::uno::RuntimeException);
-        virtual ::com::sun::star::uno::Reference< ::drafts::com::sun::star::rendering::XSprite > SAL_CALL createClonedSprite( const ::com::sun::star::uno::Reference< ::drafts::com::sun::star::rendering::XSprite >& original ) throw (::com::sun::star::lang::IllegalArgumentException, ::com::sun::star::uno::RuntimeException);
+        virtual ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XAnimatedSprite > SAL_CALL createSpriteFromAnimation( const ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XAnimation >& animation ) throw (::com::sun::star::lang::IllegalArgumentException, ::com::sun::star::uno::RuntimeException);
+        virtual ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XAnimatedSprite > SAL_CALL createSpriteFromBitmaps( const ::com::sun::star::uno::Sequence< ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XBitmap > >& animationBitmaps, 
+                                                                                                                                           sal_Int8                                                                                                                   interpolationMode ) throw (::com::sun::star::lang::IllegalArgumentException, ::com::sun::star::rendering::VolatileContentDestroyedException, ::com::sun::star::uno::RuntimeException);
+        virtual ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XCustomSprite > SAL_CALL createCustomSprite( const ::com::sun::star::geometry::RealSize2D& spriteSize ) throw (::com::sun::star::lang::IllegalArgumentException, ::com::sun::star::uno::RuntimeException);
+        virtual ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XSprite > SAL_CALL createClonedSprite( const ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XSprite >& original ) throw (::com::sun::star::lang::IllegalArgumentException, ::com::sun::star::uno::RuntimeException);
         virtual sal_Bool SAL_CALL updateScreen( sal_Bool bUpdateAll ) throw (::com::sun::star::uno::RuntimeException);
 
         // XComponent (comes implicitely with XWindow)
diff -u -r  canvas/source/vcl/sprite.hxx  canvas/source/vcl/sprite.hxx
---  canvas/source/vcl/sprite.hxx	2004-11-26 22:45:14.000000000 +0530
+++  canvas/source/vcl/sprite.hxx	2005-02-28 13:41:07.523660198 +0530
@@ -66,8 +66,8 @@
 #include <rtl/ref.hxx>
 #endif
 
-#ifndef _DRAFTS_COM_SUN_STAR_RENDERING_XCANVAS_HPP_
-#include <drafts/com/sun/star/rendering/XCanvas.hpp>
+#ifndef _COM_SUN_STAR_RENDERING_XCANVAS_HPP_
+#include <com/sun/star/rendering/XCanvas.hpp>
 #endif
 
 #ifndef _BGFX_POINT_B2DPOINT_HXX
diff -u -r  canvas/source/vcl/textlayout.cxx  canvas/source/vcl/textlayout.cxx
---  canvas/source/vcl/textlayout.cxx	2004-11-26 22:46:04.000000000 +0530
+++  canvas/source/vcl/textlayout.cxx	2005-02-28 13:41:07.525659965 +0530
@@ -66,8 +66,8 @@
 #include <boost/scoped_array.hpp>
 #endif
 
-#ifndef _DRAFTS_COM_SUN_STAR_RENDERING_TEXTDIRECTION_HPP_
-#include <drafts/com/sun/star/rendering/TextDirection.hpp>
+#ifndef _COM_SUN_STAR_RENDERING_TEXTDIRECTION_HPP_
+#include <com/sun/star/rendering/TextDirection.hpp>
 #endif
 #ifndef _BGFX_MATRIX_B2DHOMMATRIX_HXX
 #include <basegfx/matrix/b2dhommatrix.hxx>
@@ -82,7 +82,6 @@
 
 
 using namespace ::com::sun::star;
-using namespace ::drafts::com::sun::star;
 
 namespace vclcanvas
 {
@@ -237,12 +236,17 @@
                 break;
         }
 
-        rOutDev.SetLayoutMode( nLayoutMode );
+        // set calculated layout mode. Origin is always the left edge,
+        // as required at the API spec
+        rOutDev.SetLayoutMode( nLayoutMode | TEXT_LAYOUT_TEXTORIGIN_LEFT );
 
         // TODO(P2): cache that
         ::boost::scoped_array< long > aOffsets(new long[maLogicalAdvancements.getLength()]);
         setupTextOffsets( aOffsets.get(), maLogicalAdvancements, viewState, renderState );
 
+        // TODO(F3): ensure correct length and termination for DX
+        // array (last entry _must_ contain the overall width)
+
         rOutDev.DrawTextArray( rOutpos,
                                maText.Text,
                                aOffsets.get(),
@@ -306,7 +310,7 @@
     }
 
 
-#define SERVICE_NAME "drafts.com.sun.star.rendering.TextLayout"
+#define SERVICE_NAME "com.sun.star.rendering.TextLayout"
 
     ::rtl::OUString SAL_CALL TextLayout::getImplementationName() throw( uno::RuntimeException )
     {
diff -u -r  canvas/source/vcl/textlayout.hxx  canvas/source/vcl/textlayout.hxx
---  canvas/source/vcl/textlayout.hxx	2004-11-26 22:46:16.000000000 +0530
+++  canvas/source/vcl/textlayout.hxx	2005-02-28 13:41:07.525659965 +0530
@@ -72,8 +72,8 @@
 #ifndef _COM_SUN_STAR_LANG_XSERVICEINFO_HPP_
 #include <com/sun/star/lang/XServiceInfo.hpp>
 #endif
-#ifndef _DRAFTS_COM_SUN_STAR_RENDERING_XTEXTLAYOUT_HPP_
-#include <drafts/com/sun/star/rendering/XTextLayout.hpp>
+#ifndef _COM_SUN_STAR_RENDERING_XTEXTLAYOUT_HPP_
+#include <com/sun/star/rendering/XTextLayout.hpp>
 #endif
 
 #include <canvas/vclwrapper.hxx>
@@ -88,13 +88,13 @@
 
 namespace vclcanvas
 {
-    typedef ::cppu::WeakComponentImplHelper2< ::drafts::com::sun::star::rendering::XTextLayout,
+    typedef ::cppu::WeakComponentImplHelper2< ::com::sun::star::rendering::XTextLayout,
                          					  ::com::sun::star::lang::XServiceInfo > TextLayout_Base;
 
     class TextLayout : public ::comphelper::OBaseMutex, public TextLayout_Base
     {
     public:
-        TextLayout( const ::drafts::com::sun::star::rendering::StringContext& 	aText, 
+        TextLayout( const ::com::sun::star::rendering::StringContext& 	aText, 
                     sal_Int8                                                  	nDirection, 
                     sal_Int64                                                 	nRandomSeed,
                     const CanvasFont::ImplRef&                                	rFont,
@@ -104,23 +104,23 @@
         virtual void SAL_CALL disposing();
 
         // XTextLayout
-        virtual ::com::sun::star::uno::Sequence< ::com::sun::star::uno::Reference< ::drafts::com::sun::star::rendering::XPolyPolygon2D > > SAL_CALL queryTextShapes(  ) throw (::com::sun::star::uno::RuntimeException);
-        virtual ::com::sun::star::uno::Sequence< ::drafts::com::sun::star::geometry::RealRectangle2D > SAL_CALL queryInkMeasures(  ) throw (::com::sun::star::uno::RuntimeException);
-        virtual ::com::sun::star::uno::Sequence< ::drafts::com::sun::star::geometry::RealRectangle2D > SAL_CALL queryMeasures(  ) throw (::com::sun::star::uno::RuntimeException);
+        virtual ::com::sun::star::uno::Sequence< ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XPolyPolygon2D > > SAL_CALL queryTextShapes(  ) throw (::com::sun::star::uno::RuntimeException);
+        virtual ::com::sun::star::uno::Sequence< ::com::sun::star::geometry::RealRectangle2D > SAL_CALL queryInkMeasures(  ) throw (::com::sun::star::uno::RuntimeException);
+        virtual ::com::sun::star::uno::Sequence< ::com::sun::star::geometry::RealRectangle2D > SAL_CALL queryMeasures(  ) throw (::com::sun::star::uno::RuntimeException);
         virtual ::com::sun::star::uno::Sequence< double > SAL_CALL queryLogicalAdvancements(  ) throw (::com::sun::star::uno::RuntimeException);
         virtual void SAL_CALL applyLogicalAdvancements( const ::com::sun::star::uno::Sequence< double >& aAdvancements ) throw (::com::sun::star::lang::IllegalArgumentException, ::com::sun::star::uno::RuntimeException);
-        virtual ::drafts::com::sun::star::geometry::RealRectangle2D SAL_CALL queryTextBounds(  ) throw (::com::sun::star::uno::RuntimeException);
+        virtual ::com::sun::star::geometry::RealRectangle2D SAL_CALL queryTextBounds(  ) throw (::com::sun::star::uno::RuntimeException);
         virtual double SAL_CALL justify( double nSize ) throw (::com::sun::star::lang::IllegalArgumentException, ::com::sun::star::uno::RuntimeException);
-        virtual double SAL_CALL combinedJustify( const ::com::sun::star::uno::Sequence< ::com::sun::star::uno::Reference< ::drafts::com::sun::star::rendering::XTextLayout > >& aNextLayouts, double nSize ) throw (::com::sun::star::lang::IllegalArgumentException, ::com::sun::star::uno::RuntimeException);
-        virtual ::drafts::com::sun::star::rendering::TextHit SAL_CALL getTextHit( const ::drafts::com::sun::star::geometry::RealPoint2D& aHitPoint ) throw (::com::sun::star::uno::RuntimeException);
-        virtual ::drafts::com::sun::star::rendering::Caret SAL_CALL getCaret( sal_Int32 nInsertionIndex, sal_Bool bExcludeLigatures ) throw (::com::sun::star::lang::IndexOutOfBoundsException, ::com::sun::star::uno::RuntimeException);
+        virtual double SAL_CALL combinedJustify( const ::com::sun::star::uno::Sequence< ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XTextLayout > >& aNextLayouts, double nSize ) throw (::com::sun::star::lang::IllegalArgumentException, ::com::sun::star::uno::RuntimeException);
+        virtual ::com::sun::star::rendering::TextHit SAL_CALL getTextHit( const ::com::sun::star::geometry::RealPoint2D& aHitPoint ) throw (::com::sun::star::uno::RuntimeException);
+        virtual ::com::sun::star::rendering::Caret SAL_CALL getCaret( sal_Int32 nInsertionIndex, sal_Bool bExcludeLigatures ) throw (::com::sun::star::lang::IndexOutOfBoundsException, ::com::sun::star::uno::RuntimeException);
         virtual sal_Int32 SAL_CALL getNextInsertionIndex( sal_Int32 nStartIndex, sal_Int32 nCaretAdvancement, sal_Bool bExcludeLigatures ) throw (::com::sun::star::lang::IndexOutOfBoundsException, ::com::sun::star::uno::RuntimeException);
-        virtual ::com::sun::star::uno::Reference< ::drafts::com::sun::star::rendering::XPolyPolygon2D > SAL_CALL queryVisualHighlighting( sal_Int32 nStartIndex, sal_Int32 nEndIndex ) throw (::com::sun::star::lang::IndexOutOfBoundsException, ::com::sun::star::uno::RuntimeException);
-        virtual ::com::sun::star::uno::Reference< ::drafts::com::sun::star::rendering::XPolyPolygon2D > SAL_CALL queryLogicalHighlighting( sal_Int32 nStartIndex, sal_Int32 nEndIndex ) throw (::com::sun::star::lang::IndexOutOfBoundsException, ::com::sun::star::uno::RuntimeException);
+        virtual ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XPolyPolygon2D > SAL_CALL queryVisualHighlighting( sal_Int32 nStartIndex, sal_Int32 nEndIndex ) throw (::com::sun::star::lang::IndexOutOfBoundsException, ::com::sun::star::uno::RuntimeException);
+        virtual ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XPolyPolygon2D > SAL_CALL queryLogicalHighlighting( sal_Int32 nStartIndex, sal_Int32 nEndIndex ) throw (::com::sun::star::lang::IndexOutOfBoundsException, ::com::sun::star::uno::RuntimeException);
         virtual double SAL_CALL getBaselineOffset(  ) throw (::com::sun::star::uno::RuntimeException);
         virtual sal_Int8 SAL_CALL getMainTextDirection(  ) throw (::com::sun::star::uno::RuntimeException);
-        virtual ::com::sun::star::uno::Reference< ::drafts::com::sun::star::rendering::XCanvasFont > SAL_CALL getFont(  ) throw (::com::sun::star::uno::RuntimeException);
-        virtual ::drafts::com::sun::star::rendering::StringContext SAL_CALL getText(  ) throw (::com::sun::star::uno::RuntimeException);
+        virtual ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XCanvasFont > SAL_CALL getFont(  ) throw (::com::sun::star::uno::RuntimeException);
+        virtual ::com::sun::star::rendering::StringContext SAL_CALL getText(  ) throw (::com::sun::star::uno::RuntimeException);
         
         // XServiceInfo
         virtual ::rtl::OUString SAL_CALL getImplementationName() throw( ::com::sun::star::uno::RuntimeException );
@@ -129,8 +129,8 @@
 
         bool draw( OutputDevice&                                           rOutDev, 
                    const Point&                                            rOutpos, 
-                   const ::drafts::com::sun::star::rendering::ViewState&   viewState, 
-                   const ::drafts::com::sun::star::rendering::RenderState& renderState ) const;
+                   const ::com::sun::star::rendering::ViewState&   viewState, 
+                   const ::com::sun::star::rendering::RenderState& renderState ) const;
 
     protected:
         ~TextLayout(); // we're a ref-counted UNO class. _We_ destroy ourselves.
@@ -142,10 +142,10 @@
 
         void setupTextOffsets( long*													outputOffsets,
                                const ::com::sun::star::uno::Sequence< double >& 		inputOffsets,
-                               const ::drafts::com::sun::star::rendering::ViewState& 	viewState, 
-                               const ::drafts::com::sun::star::rendering::RenderState& 	renderState		) const;
+                               const ::com::sun::star::rendering::ViewState& 	viewState, 
+                               const ::com::sun::star::rendering::RenderState& 	renderState		) const;
 
-        ::drafts::com::sun::star::rendering::StringContext maText;
+        ::com::sun::star::rendering::StringContext maText;
         ::com::sun::star::uno::Sequence< double >          maLogicalAdvancements;
         CanvasFont::ImplRef                                mpFont;
         OutDevProviderSharedPtr		                   	   mpRefDevice;
diff -u -r  canvas/source/vcl/windowgraphicdevice.cxx  canvas/source/vcl/windowgraphicdevice.cxx
---  canvas/source/vcl/windowgraphicdevice.cxx	2005-01-21 21:56:40.000000000 +0530
+++  canvas/source/vcl/windowgraphicdevice.cxx	2005-02-28 13:41:07.519660666 +0530
@@ -80,12 +80,11 @@
 #include <basegfx/tools/canvastools.hxx>
 #endif
 
-#ifndef _DRAFTS_COM_SUN_STAR_RENDERING_XLINEPOLYPOLYGON2D_HPP_
-#include <drafts/com/sun/star/rendering/XLinePolyPolygon2D.hpp>
+#ifndef _COM_SUN_STAR_RENDERING_XLINEPOLYPOLYGON2D_HPP_
+#include <com/sun/star/rendering/XLinePolyPolygon2D.hpp>
 #endif
 
 using namespace ::com::sun::star;
-using namespace ::drafts::com::sun::star;
 
 
 namespace vclcanvas
@@ -372,7 +371,7 @@
     }
 
 #define IMPLEMENTATION_NAME "VCLCanvas::WindowGraphicDevice"
-#define SERVICE_NAME "drafts.com.sun.star.rendering.GraphicDevice"
+#define SERVICE_NAME "com.sun.star.rendering.GraphicDevice"
 
     ::rtl::OUString SAL_CALL WindowGraphicDevice::getImplementationName(  ) throw (uno::RuntimeException)
     {
diff -u -r  canvas/source/vcl/windowgraphicdevice.hxx  canvas/source/vcl/windowgraphicdevice.hxx
---  canvas/source/vcl/windowgraphicdevice.hxx	2005-01-13 23:29:22.000000000 +0530
+++  canvas/source/vcl/windowgraphicdevice.hxx	2005-02-28 13:41:07.520660549 +0530
@@ -68,14 +68,14 @@
 #ifndef _COM_SUN_STAR_BEANS_XPROPERTYSET_HPP_
 #include <com/sun/star/beans/XPropertySet.hpp>
 #endif
-#ifndef _DRAFTS_COM_SUN_STAR_RENDERING_XGRAPHICDEVICE_HPP_
-#include <drafts/com/sun/star/rendering/XGraphicDevice.hpp>
+#ifndef _COM_SUN_STAR_RENDERING_XGRAPHICDEVICE_HPP_
+#include <com/sun/star/rendering/XGraphicDevice.hpp>
 #endif
-#ifndef _DRAFTS_COM_SUN_STAR_RENDERING_XPARAMETRICPOLYPOLYGON2DFACTORY_HPP_
-#include <drafts/com/sun/star/rendering/XParametricPolyPolygon2DFactory.hpp>
+#ifndef _COM_SUN_STAR_RENDERING_XPARAMETRICPOLYPOLYGON2DFACTORY_HPP_
+#include <com/sun/star/rendering/XParametricPolyPolygon2DFactory.hpp>
 #endif
-#ifndef _DRAFTS_COM_SUN_STAR_RENDERING_XCANVAS_HPP_
-#include <drafts/com/sun/star/rendering/XCanvas.hpp>
+#ifndef _COM_SUN_STAR_RENDERING_XCANVAS_HPP_
+#include <com/sun/star/rendering/XCanvas.hpp>
 #endif
 
 #ifndef _CPPUHELPER_COMPBASE4_HXX_
@@ -101,8 +101,8 @@
 
 namespace vclcanvas
 {
-    typedef ::cppu::WeakComponentImplHelper4< ::drafts::com::sun::star::rendering::XGraphicDevice,
-                                              ::drafts::com::sun::star::rendering::XParametricPolyPolygon2DFactory,
+    typedef ::cppu::WeakComponentImplHelper4< ::com::sun::star::rendering::XGraphicDevice,
+                                              ::com::sun::star::rendering::XParametricPolyPolygon2DFactory,
                                               ::com::sun::star::beans::XPropertySet,
             		   			  		      ::com::sun::star::lang::XServiceInfo > WindowGraphicDevice_Base;
 
@@ -111,7 +111,7 @@
     public:
 
 		typedef ::comphelper::ImplementationReference< WindowGraphicDevice, 
-                                                       ::drafts::com::sun::star::rendering::XGraphicDevice > ImplRef;
+                                                       ::com::sun::star::rendering::XGraphicDevice > ImplRef;
  
         /** Create an XWindowGraphicDevice for given VCL window
          */
@@ -121,29 +121,29 @@
         virtual void SAL_CALL disposing();
 
         // XWindowGraphicDevice
-        virtual ::com::sun::star::uno::Reference< ::drafts::com::sun::star::rendering::XBufferController > SAL_CALL getBufferController(  ) throw (::com::sun::star::uno::RuntimeException);
-        virtual ::com::sun::star::uno::Reference< ::drafts::com::sun::star::rendering::XColorSpace > SAL_CALL getDeviceColorSpace(  ) throw (::com::sun::star::uno::RuntimeException);
-        virtual ::drafts::com::sun::star::geometry::RealSize2D SAL_CALL getPhysicalResolution(  ) throw (::com::sun::star::uno::RuntimeException);
-        virtual ::drafts::com::sun::star::geometry::RealSize2D SAL_CALL getSize(  ) throw (::com::sun::star::uno::RuntimeException);
-        virtual ::com::sun::star::uno::Reference< ::drafts::com::sun::star::rendering::XLinePolyPolygon2D > SAL_CALL createCompatibleLinePolyPolygon( const ::com::sun::star::uno::Sequence< ::com::sun::star::uno::Sequence< ::drafts::com::sun::star::geometry::RealPoint2D > >& points ) throw (::com::sun::star::uno::RuntimeException);
-        virtual ::com::sun::star::uno::Reference< ::drafts::com::sun::star::rendering::XBezierPolyPolygon2D > SAL_CALL createCompatibleBezierPolyPolygon( const ::com::sun::star::uno::Sequence< ::com::sun::star::uno::Sequence< ::drafts::com::sun::star::geometry::RealBezierSegment2D > >& points ) throw (::com::sun::star::uno::RuntimeException);
-        virtual ::com::sun::star::uno::Reference< ::drafts::com::sun::star::rendering::XBitmap > SAL_CALL createCompatibleBitmap( const ::drafts::com::sun::star::geometry::IntegerSize2D& size ) throw (::com::sun::star::lang::IllegalArgumentException, ::com::sun::star::uno::RuntimeException);
-        virtual ::com::sun::star::uno::Reference< ::drafts::com::sun::star::rendering::XVolatileBitmap > SAL_CALL createVolatileBitmap( const ::drafts::com::sun::star::geometry::IntegerSize2D& size ) throw (::com::sun::star::lang::IllegalArgumentException, ::com::sun::star::uno::RuntimeException);
-        virtual ::com::sun::star::uno::Reference< ::drafts::com::sun::star::rendering::XBitmap > SAL_CALL createCompatibleAlphaBitmap( const ::drafts::com::sun::star::geometry::IntegerSize2D& size ) throw (::com::sun::star::lang::IllegalArgumentException, ::com::sun::star::uno::RuntimeException);
-        virtual ::com::sun::star::uno::Reference< ::drafts::com::sun::star::rendering::XVolatileBitmap > SAL_CALL createVolatileAlphaBitmap( const ::drafts::com::sun::star::geometry::IntegerSize2D& size ) throw (::com::sun::star::lang::IllegalArgumentException, ::com::sun::star::uno::RuntimeException);
-        virtual ::com::sun::star::uno::Reference< ::drafts::com::sun::star::rendering::XParametricPolyPolygon2DFactory > SAL_CALL getParametricPolyPolygonFactory(  ) throw (::com::sun::star::uno::RuntimeException);
+        virtual ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XBufferController > SAL_CALL getBufferController(  ) throw (::com::sun::star::uno::RuntimeException);
+        virtual ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XColorSpace > SAL_CALL getDeviceColorSpace(  ) throw (::com::sun::star::uno::RuntimeException);
+        virtual ::com::sun::star::geometry::RealSize2D SAL_CALL getPhysicalResolution(  ) throw (::com::sun::star::uno::RuntimeException);
+        virtual ::com::sun::star::geometry::RealSize2D SAL_CALL getSize(  ) throw (::com::sun::star::uno::RuntimeException);
+        virtual ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XLinePolyPolygon2D > SAL_CALL createCompatibleLinePolyPolygon( const ::com::sun::star::uno::Sequence< ::com::sun::star::uno::Sequence< ::com::sun::star::geometry::RealPoint2D > >& points ) throw (::com::sun::star::uno::RuntimeException);
+        virtual ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XBezierPolyPolygon2D > SAL_CALL createCompatibleBezierPolyPolygon( const ::com::sun::star::uno::Sequence< ::com::sun::star::uno::Sequence< ::com::sun::star::geometry::RealBezierSegment2D > >& points ) throw (::com::sun::star::uno::RuntimeException);
+        virtual ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XBitmap > SAL_CALL createCompatibleBitmap( const ::com::sun::star::geometry::IntegerSize2D& size ) throw (::com::sun::star::lang::IllegalArgumentException, ::com::sun::star::uno::RuntimeException);
+        virtual ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XVolatileBitmap > SAL_CALL createVolatileBitmap( const ::com::sun::star::geometry::IntegerSize2D& size ) throw (::com::sun::star::lang::IllegalArgumentException, ::com::sun::star::uno::RuntimeException);
+        virtual ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XBitmap > SAL_CALL createCompatibleAlphaBitmap( const ::com::sun::star::geometry::IntegerSize2D& size ) throw (::com::sun::star::lang::IllegalArgumentException, ::com::sun::star::uno::RuntimeException);
+        virtual ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XVolatileBitmap > SAL_CALL createVolatileAlphaBitmap( const ::com::sun::star::geometry::IntegerSize2D& size ) throw (::com::sun::star::lang::IllegalArgumentException, ::com::sun::star::uno::RuntimeException);
+        virtual ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XParametricPolyPolygon2DFactory > SAL_CALL getParametricPolyPolygonFactory(  ) throw (::com::sun::star::uno::RuntimeException);
         virtual sal_Bool SAL_CALL hasFullScreenMode(  ) throw (::com::sun::star::uno::RuntimeException);
         virtual sal_Bool SAL_CALL enterFullScreenMode( sal_Bool bEnter ) throw (::com::sun::star::uno::RuntimeException);
 
         // XParametricPolyPolygon2DFactory
-        virtual ::com::sun::star::uno::Reference< ::drafts::com::sun::star::rendering::XParametricPolyPolygon2D > SAL_CALL createLinearHorizontalGradient( const ::com::sun::star::uno::Sequence< double >& leftColor, const ::com::sun::star::uno::Sequence< double >& rightColor ) throw (::com::sun::star::lang::IllegalArgumentException, ::com::sun::star::uno::RuntimeException);
-        virtual ::com::sun::star::uno::Reference< ::drafts::com::sun::star::rendering::XParametricPolyPolygon2D > SAL_CALL createAxialHorizontalGradient( const ::com::sun::star::uno::Sequence< double >& middleColor, const ::com::sun::star::uno::Sequence< double >& endColor ) throw (::com::sun::star::lang::IllegalArgumentException, ::com::sun::star::uno::RuntimeException);
-        virtual ::com::sun::star::uno::Reference< ::drafts::com::sun::star::rendering::XParametricPolyPolygon2D > SAL_CALL createEllipticalGradient( const ::com::sun::star::uno::Sequence< double >& centerColor, const ::com::sun::star::uno::Sequence< double >& endColor, const ::drafts::com::sun::star::geometry::RealRectangle2D& boundRect ) throw (::com::sun::star::lang::IllegalArgumentException, ::com::sun::star::uno::RuntimeException);
-        virtual ::com::sun::star::uno::Reference< ::drafts::com::sun::star::rendering::XParametricPolyPolygon2D > SAL_CALL createRectangularGradient( const ::com::sun::star::uno::Sequence< double >& centerColor, const ::com::sun::star::uno::Sequence< double >& endColor, const ::drafts::com::sun::star::geometry::RealRectangle2D& boundRect ) throw (::com::sun::star::lang::IllegalArgumentException, ::com::sun::star::uno::RuntimeException);
-        virtual ::com::sun::star::uno::Reference< ::drafts::com::sun::star::rendering::XParametricPolyPolygon2D > SAL_CALL createVerticalLinesHatch( const ::com::sun::star::uno::Sequence< double >& leftColor, const ::com::sun::star::uno::Sequence< double >& rightColor ) throw (::com::sun::star::lang::IllegalArgumentException, ::com::sun::star::uno::RuntimeException);
-        virtual ::com::sun::star::uno::Reference< ::drafts::com::sun::star::rendering::XParametricPolyPolygon2D > SAL_CALL createOrthogonalLinesHatch( const ::com::sun::star::uno::Sequence< double >& leftTopColor, const ::com::sun::star::uno::Sequence< double >& rightBottomColor ) throw (::com::sun::star::lang::IllegalArgumentException, ::com::sun::star::uno::RuntimeException);
-        virtual ::com::sun::star::uno::Reference< ::drafts::com::sun::star::rendering::XParametricPolyPolygon2D > SAL_CALL createThreeCrossingLinesHatch( const ::com::sun::star::uno::Sequence< double >& startColor, const ::com::sun::star::uno::Sequence< double >& endColor ) throw (::com::sun::star::lang::IllegalArgumentException, ::com::sun::star::uno::RuntimeException);
-        virtual ::com::sun::star::uno::Reference< ::drafts::com::sun::star::rendering::XParametricPolyPolygon2D > SAL_CALL createFourCrossingLinesHatch( const ::com::sun::star::uno::Sequence< double >& startColor, const ::com::sun::star::uno::Sequence< double >& endColor ) throw (::com::sun::star::lang::IllegalArgumentException, ::com::sun::star::uno::RuntimeException);
+        virtual ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XParametricPolyPolygon2D > SAL_CALL createLinearHorizontalGradient( const ::com::sun::star::uno::Sequence< double >& leftColor, const ::com::sun::star::uno::Sequence< double >& rightColor ) throw (::com::sun::star::lang::IllegalArgumentException, ::com::sun::star::uno::RuntimeException);
+        virtual ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XParametricPolyPolygon2D > SAL_CALL createAxialHorizontalGradient( const ::com::sun::star::uno::Sequence< double >& middleColor, const ::com::sun::star::uno::Sequence< double >& endColor ) throw (::com::sun::star::lang::IllegalArgumentException, ::com::sun::star::uno::RuntimeException);
+        virtual ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XParametricPolyPolygon2D > SAL_CALL createEllipticalGradient( const ::com::sun::star::uno::Sequence< double >& centerColor, const ::com::sun::star::uno::Sequence< double >& endColor, const ::com::sun::star::geometry::RealRectangle2D& boundRect ) throw (::com::sun::star::lang::IllegalArgumentException, ::com::sun::star::uno::RuntimeException);
+        virtual ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XParametricPolyPolygon2D > SAL_CALL createRectangularGradient( const ::com::sun::star::uno::Sequence< double >& centerColor, const ::com::sun::star::uno::Sequence< double >& endColor, const ::com::sun::star::geometry::RealRectangle2D& boundRect ) throw (::com::sun::star::lang::IllegalArgumentException, ::com::sun::star::uno::RuntimeException);
+        virtual ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XParametricPolyPolygon2D > SAL_CALL createVerticalLinesHatch( const ::com::sun::star::uno::Sequence< double >& leftColor, const ::com::sun::star::uno::Sequence< double >& rightColor ) throw (::com::sun::star::lang::IllegalArgumentException, ::com::sun::star::uno::RuntimeException);
+        virtual ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XParametricPolyPolygon2D > SAL_CALL createOrthogonalLinesHatch( const ::com::sun::star::uno::Sequence< double >& leftTopColor, const ::com::sun::star::uno::Sequence< double >& rightBottomColor ) throw (::com::sun::star::lang::IllegalArgumentException, ::com::sun::star::uno::RuntimeException);
+        virtual ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XParametricPolyPolygon2D > SAL_CALL createThreeCrossingLinesHatch( const ::com::sun::star::uno::Sequence< double >& startColor, const ::com::sun::star::uno::Sequence< double >& endColor ) throw (::com::sun::star::lang::IllegalArgumentException, ::com::sun::star::uno::RuntimeException);
+        virtual ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XParametricPolyPolygon2D > SAL_CALL createFourCrossingLinesHatch( const ::com::sun::star::uno::Sequence< double >& startColor, const ::com::sun::star::uno::Sequence< double >& endColor ) throw (::com::sun::star::lang::IllegalArgumentException, ::com::sun::star::uno::RuntimeException);
 
         // XPropertySet
         virtual ::com::sun::star::uno::Reference< ::com::sun::star::beans::XPropertySetInfo > SAL_CALL getPropertySetInfo(  ) throw (::com::sun::star::uno::RuntimeException);
diff -u -r  canvas/source/win/dx_canvasbitmap.cxx  canvas/source/win/dx_canvasbitmap.cxx
---  canvas/source/win/dx_canvasbitmap.cxx	2004-11-26 22:47:45.000000000 +0530
+++  canvas/source/win/dx_canvasbitmap.cxx	2005-02-28 13:41:07.816625966 +0530
@@ -66,7 +66,6 @@
 
 
 using namespace ::com::sun::star;
-using namespace ::drafts::com::sun::star;
 
 namespace dxcanvas
 {
@@ -97,7 +96,7 @@
         return mpBitmap;
     }
 
-#define SERVICE_NAME "drafts.com.sun.star.rendering.CanvasBitmap"
+#define SERVICE_NAME "com.sun.star.rendering.CanvasBitmap"
 
     ::rtl::OUString SAL_CALL CanvasBitmap::getImplementationName(  ) throw (uno::RuntimeException)
     {
diff -u -r  canvas/source/win/dx_canvasbitmap.hxx  canvas/source/win/dx_canvasbitmap.hxx
---  canvas/source/win/dx_canvasbitmap.hxx	2004-11-26 22:47:59.000000000 +0530
+++  canvas/source/win/dx_canvasbitmap.hxx	2005-02-28 13:41:07.817625849 +0530
@@ -72,11 +72,11 @@
 #include <com/sun/star/lang/XServiceInfo.hpp>
 #endif
 
-#ifndef _DRAFTS_COM_SUN_STAR_RENDERING_XBITMAPCANVAS_HPP_
-#include <drafts/com/sun/star/rendering/XBitmapCanvas.hpp>
+#ifndef _COM_SUN_STAR_RENDERING_XBITMAPCANVAS_HPP_
+#include <com/sun/star/rendering/XBitmapCanvas.hpp>
 #endif
-#ifndef _DRAFTS_COM_SUN_STAR_RENDERING_XINTEGERBITMAP_HPP_
-#include <drafts/com/sun/star/rendering/XIntegerBitmap.hpp>
+#ifndef _COM_SUN_STAR_RENDERING_XINTEGERBITMAP_HPP_
+#include <com/sun/star/rendering/XIntegerBitmap.hpp>
 #endif
 
 #ifndef _BGFX_VECTOR_B2ISIZE_HXX
@@ -100,8 +100,8 @@
 
 namespace dxcanvas
 {
-    typedef ::cppu::WeakComponentImplHelper3< ::drafts::com::sun::star::rendering::XBitmapCanvas,
-											  ::drafts::com::sun::star::rendering::XIntegerBitmap,
+    typedef ::cppu::WeakComponentImplHelper3< ::com::sun::star::rendering::XBitmapCanvas,
+											  ::com::sun::star::rendering::XIntegerBitmap,
                          					  ::com::sun::star::lang::XServiceInfo >  	CanvasBitmapBase_Base;
     typedef ::canvas::internal::BitmapCanvasBase< CanvasBitmapBase_Base, CanvasHelper > CanvasBitmap_Base;
 
diff -u -r  canvas/source/win/dx_canvascustomsprite.cxx  canvas/source/win/dx_canvascustomsprite.cxx
---  canvas/source/win/dx_canvascustomsprite.cxx	2004-11-26 22:48:12.000000000 +0530
+++  canvas/source/win/dx_canvascustomsprite.cxx	2005-02-28 13:41:07.791628887 +0530
@@ -100,7 +100,6 @@
 
 
 using namespace ::com::sun::star;
-using namespace ::drafts::com::sun::star;
 
 namespace dxcanvas
 {
@@ -328,7 +327,7 @@
         return this;
     }
 
-#define SERVICE_NAME "drafts.com.sun.star.rendering.CanvasCustomSprite"
+#define SERVICE_NAME "com.sun.star.rendering.CanvasCustomSprite"
 
     ::rtl::OUString SAL_CALL CanvasCustomSprite::getImplementationName() throw( uno::RuntimeException )
     {
diff -u -r  canvas/source/win/dx_canvascustomsprite.hxx  canvas/source/win/dx_canvascustomsprite.hxx
---  canvas/source/win/dx_canvascustomsprite.hxx	2004-11-26 22:48:24.000000000 +0530
+++  canvas/source/win/dx_canvascustomsprite.hxx	2005-02-28 13:41:07.792628770 +0530
@@ -77,8 +77,8 @@
 #include <com/sun/star/lang/XServiceInfo.hpp>
 #endif
 
-#ifndef _DRAFTS_COM_SUN_STAR_RENDERING_XCUSTOMSPRITE_HPP_
-#include <drafts/com/sun/star/rendering/XCustomSprite.hpp>
+#ifndef _COM_SUN_STAR_RENDERING_XCUSTOMSPRITE_HPP_
+#include <com/sun/star/rendering/XCustomSprite.hpp>
 #endif
 
 #ifndef _BGFX_POINT_B2DPOINT_HXX
@@ -98,9 +98,9 @@
 
 namespace dxcanvas
 {
-    typedef ::cppu::WeakComponentImplHelper4< ::drafts::com::sun::star::rendering::XCustomSprite,
-									 		  ::drafts::com::sun::star::rendering::XBitmapCanvas,
-											  ::drafts::com::sun::star::rendering::XIntegerBitmap,
+    typedef ::cppu::WeakComponentImplHelper4< ::com::sun::star::rendering::XCustomSprite,
+									 		  ::com::sun::star::rendering::XBitmapCanvas,
+											  ::com::sun::star::rendering::XIntegerBitmap,
                          			 		  ::com::sun::star::lang::XServiceInfo >  			CanvasCustomSpriteBase_Base;
     typedef ::canvas::internal::BitmapCanvasBase< CanvasCustomSpriteBase_Base, CanvasHelper > 	CanvasCustomSprite_Base;
 
@@ -124,7 +124,7 @@
             @param rDevice
             Target DX device
          */
-        CanvasCustomSprite( const ::drafts::com::sun::star::geometry::RealSize2D& 	rSpriteSize,
+        CanvasCustomSprite( const ::com::sun::star::geometry::RealSize2D& 	rSpriteSize,
                             const WindowGraphicDevice::ImplRef&						rRefDevice,
                             const SpriteCanvas::ImplRef&							rSpriteCanvas,
                             const DeviceSharedPtr&									rDevice );
@@ -146,15 +146,15 @@
 
         // XSprite
         virtual void SAL_CALL setAlpha( double alpha ) throw (::com::sun::star::lang::IllegalArgumentException, ::com::sun::star::uno::RuntimeException);
-        virtual void SAL_CALL move( const ::drafts::com::sun::star::geometry::RealPoint2D& aNewPos, const ::drafts::com::sun::star::rendering::ViewState& viewState, const ::drafts::com::sun::star::rendering::RenderState& renderState ) throw (::com::sun::star::lang::IllegalArgumentException, ::com::sun::star::uno::RuntimeException);
-        virtual void SAL_CALL transform( const ::drafts::com::sun::star::geometry::AffineMatrix2D& aTransformation ) throw (::com::sun::star::lang::IllegalArgumentException, ::com::sun::star::uno::RuntimeException);
-        virtual void SAL_CALL clip( const ::com::sun::star::uno::Reference< ::drafts::com::sun::star::rendering::XPolyPolygon2D >& aClip ) throw (::com::sun::star::uno::RuntimeException);
+        virtual void SAL_CALL move( const ::com::sun::star::geometry::RealPoint2D& aNewPos, const ::com::sun::star::rendering::ViewState& viewState, const ::com::sun::star::rendering::RenderState& renderState ) throw (::com::sun::star::lang::IllegalArgumentException, ::com::sun::star::uno::RuntimeException);
+        virtual void SAL_CALL transform( const ::com::sun::star::geometry::AffineMatrix2D& aTransformation ) throw (::com::sun::star::lang::IllegalArgumentException, ::com::sun::star::uno::RuntimeException);
+        virtual void SAL_CALL clip( const ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XPolyPolygon2D >& aClip ) throw (::com::sun::star::uno::RuntimeException);
         virtual void SAL_CALL setPriority( double nPriority ) throw (::com::sun::star::uno::RuntimeException);
         virtual void SAL_CALL show(  ) throw (::com::sun::star::uno::RuntimeException);
         virtual void SAL_CALL hide(  ) throw (::com::sun::star::uno::RuntimeException);
 
         // XCustomSprite
-        virtual ::com::sun::star::uno::Reference< ::drafts::com::sun::star::rendering::XCanvas > SAL_CALL 
+        virtual ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XCanvas > SAL_CALL 
         	getContentCanvas(  ) throw (::com::sun::star::uno::RuntimeException);
 
         // XServiceInfo
@@ -194,7 +194,7 @@
         // sprite state
         ::basegfx::B2DPoint											maPosition;
         ::com::sun::star::uno::Reference< 
-              ::drafts::com::sun::star::rendering::XPolyPolygon2D >	mxClipPoly;
+              ::com::sun::star::rendering::XPolyPolygon2D >	mxClipPoly;
         double														mfAlpha;
         bool														mbActive;
 
diff -u -r  canvas/source/win/dx_canvasfont.cxx  canvas/source/win/dx_canvasfont.cxx
---  canvas/source/win/dx_canvasfont.cxx	2004-11-26 22:48:38.000000000 +0530
+++  canvas/source/win/dx_canvasfont.cxx	2005-02-28 13:41:07.807627017 +0530
@@ -63,15 +63,14 @@
 #include <dx_textlayout.hxx>
 #include <dx_spritecanvas.hxx>
 
-#ifndef _DRAFTS_COM_SUN_STAR_RENDERING_XSPRITECANVAS_HPP_
-#include <drafts/com/sun/star/rendering/XSpriteCanvas.hpp>
+#ifndef _COM_SUN_STAR_RENDERING_XSPRITECANVAS_HPP_
+#include <com/sun/star/rendering/XSpriteCanvas.hpp>
 #endif
-#ifndef _DRAFTS_COM_SUN_STAR_RENDERING_PANOSEWEIGHT_HPP_
-#include <drafts/com/sun/star/rendering/PanoseWeight.hpp>
+#ifndef _COM_SUN_STAR_RENDERING_PANOSEWEIGHT_HPP_
+#include <com/sun/star/rendering/PanoseWeight.hpp>
 #endif
 
 using namespace ::com::sun::star;
-using namespace ::drafts::com::sun::star;
 
 namespace dxcanvas
 {
@@ -159,7 +158,7 @@
         return rendering::FontMetrics();
     }
 
-#define SERVICE_NAME "drafts.com.sun.star.rendering.CanvasFont"
+#define SERVICE_NAME "com.sun.star.rendering.CanvasFont"
 
     ::rtl::OUString SAL_CALL CanvasFont::getImplementationName() throw( uno::RuntimeException )
     {
@@ -200,7 +199,7 @@
         return mpFont;
     }
 
-	const ::drafts::com::sun::star::geometry::Matrix2D& CanvasFont::getFontMatrix() const
+	const ::com::sun::star::geometry::Matrix2D& CanvasFont::getFontMatrix() const
 	{
 		return maFontMatrix;
 	}
diff -u -r  canvas/source/win/dx_canvasfont.hxx  canvas/source/win/dx_canvasfont.hxx
---  canvas/source/win/dx_canvasfont.hxx	2004-11-26 22:48:50.000000000 +0530
+++  canvas/source/win/dx_canvasfont.hxx	2005-02-28 13:41:07.808626901 +0530
@@ -76,11 +76,11 @@
 #ifndef _COM_SUN_STAR_LANG_XSERVICEINFO_HPP_
 #include <com/sun/star/lang/XServiceInfo.hpp>
 #endif
-#ifndef _DRAFTS_COM_SUN_STAR_RENDERING_XCANVAS_HPP_
-#include <drafts/com/sun/star/rendering/XCanvas.hpp>
+#ifndef _COM_SUN_STAR_RENDERING_XCANVAS_HPP_
+#include <com/sun/star/rendering/XCanvas.hpp>
 #endif
-#ifndef _DRAFTS_COM_SUN_STAR_RENDERING_XCANVASFONT_HPP_
-#include <drafts/com/sun/star/rendering/XCanvasFont.hpp>
+#ifndef _COM_SUN_STAR_RENDERING_XCANVASFONT_HPP_
+#include <com/sun/star/rendering/XCanvasFont.hpp>
 #endif
 
 #ifndef _RTL_REF_HXX_
@@ -106,7 +106,7 @@
     typedef ::boost::shared_ptr< Gdiplus::Font > 		FontSharedPtr;
     typedef ::boost::shared_ptr< Gdiplus::FontFamily > 	FontFamilySharedPtr;
 
-    typedef ::cppu::WeakComponentImplHelper2< ::drafts::com::sun::star::rendering::XCanvasFont,
+    typedef ::cppu::WeakComponentImplHelper2< ::com::sun::star::rendering::XCanvasFont,
                          					  ::com::sun::star::lang::XServiceInfo > CanvasFont_Base;
 
     class CanvasFont : public ::comphelper::OBaseMutex, public CanvasFont_Base
@@ -114,19 +114,19 @@
     public:
         typedef ::comphelper::ImplementationReference< 
             CanvasFont, 
-            ::drafts::com::sun::star::rendering::XCanvasFont > ImplRef;
+            ::com::sun::star::rendering::XCanvasFont > ImplRef;
 
-        CanvasFont( const ::drafts::com::sun::star::rendering::FontRequest& 							fontRequest,
+        CanvasFont( const ::com::sun::star::rendering::FontRequest& 							fontRequest,
                     const ::com::sun::star::uno::Sequence< ::com::sun::star::beans::PropertyValue >& 	extraFontProperties, 
-                    const ::drafts::com::sun::star::geometry::Matrix2D& 								fontMatrix );
+                    const ::com::sun::star::geometry::Matrix2D& 								fontMatrix );
 
         /// Dispose all internal references
         virtual void SAL_CALL disposing();
 
         // XCanvasFont
-        virtual ::com::sun::star::uno::Reference< ::drafts::com::sun::star::rendering::XTextLayout > SAL_CALL createTextLayout( const ::drafts::com::sun::star::rendering::StringContext& aText, sal_Int8 nDirection, sal_Int64 nRandomSeed ) throw (::com::sun::star::uno::RuntimeException);
-        virtual ::drafts::com::sun::star::rendering::FontRequest SAL_CALL getFontRequest(  ) throw (::com::sun::star::uno::RuntimeException);
-        virtual ::drafts::com::sun::star::rendering::FontMetrics SAL_CALL getFontMetrics(  ) throw (::com::sun::star::uno::RuntimeException);
+        virtual ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XTextLayout > SAL_CALL createTextLayout( const ::com::sun::star::rendering::StringContext& aText, sal_Int8 nDirection, sal_Int64 nRandomSeed ) throw (::com::sun::star::uno::RuntimeException);
+        virtual ::com::sun::star::rendering::FontRequest SAL_CALL getFontRequest(  ) throw (::com::sun::star::uno::RuntimeException);
+        virtual ::com::sun::star::rendering::FontMetrics SAL_CALL getFontMetrics(  ) throw (::com::sun::star::uno::RuntimeException);
         virtual ::com::sun::star::uno::Sequence< double > SAL_CALL getAvailableSizes(  ) throw (::com::sun::star::uno::RuntimeException);
         virtual ::com::sun::star::uno::Sequence< ::com::sun::star::beans::PropertyValue > SAL_CALL getExtraFontProperties(  ) throw (::com::sun::star::uno::RuntimeException);
 
@@ -138,7 +138,7 @@
         double				getCellAscent() const;
         double				getEmHeight() const;
         FontSharedPtr 		getFont() const;
-		const ::drafts::com::sun::star::geometry::Matrix2D& getFontMatrix() const;
+		const ::com::sun::star::geometry::Matrix2D& getFontMatrix() const;
 
     protected:
         ~CanvasFont(); // we're a ref-counted UNO class. _We_ destroy ourselves.
@@ -151,8 +151,8 @@
         GDIPlusUserSharedPtr								mpGdiPlusUser;
         FontFamilySharedPtr									mpFontFamily;
         FontSharedPtr										mpFont;
-        ::drafts::com::sun::star::rendering::FontRequest	maFontRequest;
-		::drafts::com::sun::star::geometry::Matrix2D		maFontMatrix;
+        ::com::sun::star::rendering::FontRequest	maFontRequest;
+		::com::sun::star::geometry::Matrix2D		maFontMatrix;
     };
 
 }
diff -u -r  canvas/source/win/dx_canvashelper.cxx  canvas/source/win/dx_canvashelper.cxx
---  canvas/source/win/dx_canvashelper.cxx	2004-11-26 22:49:00.000000000 +0530
+++  canvas/source/win/dx_canvashelper.cxx	2005-02-28 13:41:07.811626550 +0530
@@ -65,8 +65,8 @@
 #include <rtl/logfile.hxx>
 #endif
 
-#ifndef _DRAFTS_COM_SUN_STAR_RENDERING_COMPOSITEOPERATION_HPP_
-#include <drafts/com/sun/star/rendering/CompositeOperation.hpp>
+#ifndef _COM_SUN_STAR_RENDERING_COMPOSITEOPERATION_HPP_
+#include <com/sun/star/rendering/CompositeOperation.hpp>
 #endif
 
 #ifndef BOOST_SCOPED_ARRAY_HPP_INCLUDED
@@ -96,7 +96,6 @@
 
 
 using namespace ::com::sun::star;
-using namespace ::drafts::com::sun::star;
 
 namespace dxcanvas
 {
diff -u -r  canvas/source/win/dx_canvashelper.hxx  canvas/source/win/dx_canvashelper.hxx
---  canvas/source/win/dx_canvashelper.hxx	2004-11-26 22:49:12.000000000 +0530
+++  canvas/source/win/dx_canvashelper.hxx	2005-02-28 13:41:07.811626550 +0530
@@ -66,11 +66,11 @@
 #include <com/sun/star/uno/Reference.hxx>
 #endif
 
-#ifndef _DRAFTS_COM_SUN_STAR_RENDERING_XCANVAS_HPP_
-#include <drafts/com/sun/star/rendering/XCanvas.hpp>
+#ifndef _COM_SUN_STAR_RENDERING_XCANVAS_HPP_
+#include <com/sun/star/rendering/XCanvas.hpp>
 #endif
-#ifndef _DRAFTS_COM_SUN_STAR_RENDERING_XINTEGERBITMAP_HPP_
-#include <drafts/com/sun/star/rendering/XIntegerBitmap.hpp>
+#ifndef _COM_SUN_STAR_RENDERING_XINTEGERBITMAP_HPP_
+#include <com/sun/star/rendering/XIntegerBitmap.hpp>
 #endif
 
 #ifndef _BGFX_VECTOR_B2ISIZE_HXX
@@ -153,124 +153,124 @@
 
         // XCanvas (only providing, not implementing the
         // interface. Also note subtle method parameter differences)
-        void SAL_CALL drawPoint( const ::drafts::com::sun::star::geometry::RealPoint2D& 	aPoint, 
-                                 const ::drafts::com::sun::star::rendering::ViewState& 		viewState, 
-                                 const ::drafts::com::sun::star::rendering::RenderState& 	renderState );
-        void SAL_CALL drawLine( const ::drafts::com::sun::star::geometry::RealPoint2D& 	aStartPoint, 
-                                const ::drafts::com::sun::star::geometry::RealPoint2D& 	aEndPoint, 
-                                const ::drafts::com::sun::star::rendering::ViewState& 	viewState, 
-                                const ::drafts::com::sun::star::rendering::RenderState& renderState	);
-        void SAL_CALL drawBezier( const ::drafts::com::sun::star::geometry::RealBezierSegment2D&	aBezierSegment, 
-                                  const ::drafts::com::sun::star::geometry::RealPoint2D& 			aEndPoint,
-                                  const ::drafts::com::sun::star::rendering::ViewState& 			viewState, 
-                                  const ::drafts::com::sun::star::rendering::RenderState& 			renderState );
-        ::com::sun::star::uno::Reference< ::drafts::com::sun::star::rendering::XCachedPrimitive > SAL_CALL 	
-        	drawPolyPolygon( const ::com::sun::star::uno::Reference< ::drafts::com::sun::star::rendering::XPolyPolygon2D >& xPolyPolygon, 
-                             const ::drafts::com::sun::star::rendering::ViewState& 											viewState, 
-                             const ::drafts::com::sun::star::rendering::RenderState& 										renderState );
-        ::com::sun::star::uno::Reference< ::drafts::com::sun::star::rendering::XCachedPrimitive > SAL_CALL 	
-        	strokePolyPolygon( const ::com::sun::star::uno::Reference< ::drafts::com::sun::star::rendering::XPolyPolygon2D >& 	xPolyPolygon, 
-                               const ::drafts::com::sun::star::rendering::ViewState& 											viewState, 
-                               const ::drafts::com::sun::star::rendering::RenderState& 											renderState, 
-                               const ::drafts::com::sun::star::rendering::StrokeAttributes& 									strokeAttributes );
-        ::com::sun::star::uno::Reference< ::drafts::com::sun::star::rendering::XCachedPrimitive > SAL_CALL 	
-        	strokeTexturedPolyPolygon( const ::com::sun::star::uno::Reference< ::drafts::com::sun::star::rendering::XPolyPolygon2D >& 	xPolyPolygon, 
-                                       const ::drafts::com::sun::star::rendering::ViewState& 											viewState, 
-                                       const ::drafts::com::sun::star::rendering::RenderState& 											renderState, 
-                                       const ::com::sun::star::uno::Sequence< ::drafts::com::sun::star::rendering::Texture >& 			textures, 
-                                       const ::drafts::com::sun::star::rendering::StrokeAttributes& 									strokeAttributes );
-        ::com::sun::star::uno::Reference< ::drafts::com::sun::star::rendering::XCachedPrimitive > SAL_CALL 	
-        	strokeTextureMappedPolyPolygon( const ::com::sun::star::uno::Reference< ::drafts::com::sun::star::rendering::XPolyPolygon2D >& 	xPolyPolygon, 
-                                            const ::drafts::com::sun::star::rendering::ViewState& 											viewState, 
-                                            const ::drafts::com::sun::star::rendering::RenderState& 										renderState, 
-                                            const ::com::sun::star::uno::Sequence< ::drafts::com::sun::star::rendering::Texture >& 			textures, 
-                                            const ::com::sun::star::uno::Reference< ::drafts::com::sun::star::geometry::XMapping2D >& 		xMapping, 
-                                            const ::drafts::com::sun::star::rendering::StrokeAttributes& 									strokeAttributes );
-        ::com::sun::star::uno::Reference< ::drafts::com::sun::star::rendering::XPolyPolygon2D >   SAL_CALL 	
-        	queryStrokeShapes( const ::com::sun::star::uno::Reference< ::drafts::com::sun::star::rendering::XPolyPolygon2D >& 	xPolyPolygon, 
-                               const ::drafts::com::sun::star::rendering::ViewState& 											viewState, 
-                               const ::drafts::com::sun::star::rendering::RenderState& 											renderState, 
-                               const ::drafts::com::sun::star::rendering::StrokeAttributes& 									strokeAttributes );
-        ::com::sun::star::uno::Reference< ::drafts::com::sun::star::rendering::XCachedPrimitive > SAL_CALL 	
-        	fillPolyPolygon( const ::com::sun::star::uno::Reference< ::drafts::com::sun::star::rendering::XPolyPolygon2D >& xPolyPolygon, 
-                             const ::drafts::com::sun::star::rendering::ViewState& 											viewState, 
-                             const ::drafts::com::sun::star::rendering::RenderState& 										renderState );
-        ::com::sun::star::uno::Reference< ::drafts::com::sun::star::rendering::XCachedPrimitive > SAL_CALL 	
-        	fillTexturedPolyPolygon( const ::com::sun::star::uno::Reference< ::drafts::com::sun::star::rendering::XPolyPolygon2D >& xPolyPolygon, 
-                                     const ::drafts::com::sun::star::rendering::ViewState& 											viewState, 
-                                     const ::drafts::com::sun::star::rendering::RenderState& 										renderState, 
-                                     const ::com::sun::star::uno::Sequence< ::drafts::com::sun::star::rendering::Texture >& 		textures );
-        ::com::sun::star::uno::Reference< ::drafts::com::sun::star::rendering::XCachedPrimitive > SAL_CALL 	
-        	fillTextureMappedPolyPolygon( const ::com::sun::star::uno::Reference< ::drafts::com::sun::star::rendering::XPolyPolygon2D >& 	xPolyPolygon, 
-                                          const ::drafts::com::sun::star::rendering::ViewState& 											viewState, 
-                                          const ::drafts::com::sun::star::rendering::RenderState& 											renderState, 
-                                          const ::com::sun::star::uno::Sequence< ::drafts::com::sun::star::rendering::Texture >& 			textures, 
-                                          const ::com::sun::star::uno::Reference< ::drafts::com::sun::star::geometry::XMapping2D >& 		xMapping );
+        void SAL_CALL drawPoint( const ::com::sun::star::geometry::RealPoint2D& 	aPoint, 
+                                 const ::com::sun::star::rendering::ViewState& 		viewState, 
+                                 const ::com::sun::star::rendering::RenderState& 	renderState );
+        void SAL_CALL drawLine( const ::com::sun::star::geometry::RealPoint2D& 	aStartPoint, 
+                                const ::com::sun::star::geometry::RealPoint2D& 	aEndPoint, 
+                                const ::com::sun::star::rendering::ViewState& 	viewState, 
+                                const ::com::sun::star::rendering::RenderState& renderState	);
+        void SAL_CALL drawBezier( const ::com::sun::star::geometry::RealBezierSegment2D&	aBezierSegment, 
+                                  const ::com::sun::star::geometry::RealPoint2D& 			aEndPoint,
+                                  const ::com::sun::star::rendering::ViewState& 			viewState, 
+                                  const ::com::sun::star::rendering::RenderState& 			renderState );
+        ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XCachedPrimitive > SAL_CALL 	
+        	drawPolyPolygon( const ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XPolyPolygon2D >& xPolyPolygon, 
+                             const ::com::sun::star::rendering::ViewState& 											viewState, 
+                             const ::com::sun::star::rendering::RenderState& 										renderState );
+        ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XCachedPrimitive > SAL_CALL 	
+        	strokePolyPolygon( const ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XPolyPolygon2D >& 	xPolyPolygon, 
+                               const ::com::sun::star::rendering::ViewState& 											viewState, 
+                               const ::com::sun::star::rendering::RenderState& 											renderState, 
+                               const ::com::sun::star::rendering::StrokeAttributes& 									strokeAttributes );
+        ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XCachedPrimitive > SAL_CALL 	
+        	strokeTexturedPolyPolygon( const ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XPolyPolygon2D >& 	xPolyPolygon, 
+                                       const ::com::sun::star::rendering::ViewState& 											viewState, 
+                                       const ::com::sun::star::rendering::RenderState& 											renderState, 
+                                       const ::com::sun::star::uno::Sequence< ::com::sun::star::rendering::Texture >& 			textures, 
+                                       const ::com::sun::star::rendering::StrokeAttributes& 									strokeAttributes );
+        ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XCachedPrimitive > SAL_CALL 	
+        	strokeTextureMappedPolyPolygon( const ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XPolyPolygon2D >& 	xPolyPolygon, 
+                                            const ::com::sun::star::rendering::ViewState& 											viewState, 
+                                            const ::com::sun::star::rendering::RenderState& 										renderState, 
+                                            const ::com::sun::star::uno::Sequence< ::com::sun::star::rendering::Texture >& 			textures, 
+                                            const ::com::sun::star::uno::Reference< ::com::sun::star::geometry::XMapping2D >& 		xMapping, 
+                                            const ::com::sun::star::rendering::StrokeAttributes& 									strokeAttributes );
+        ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XPolyPolygon2D >   SAL_CALL 	
+        	queryStrokeShapes( const ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XPolyPolygon2D >& 	xPolyPolygon, 
+                               const ::com::sun::star::rendering::ViewState& 											viewState, 
+                               const ::com::sun::star::rendering::RenderState& 											renderState, 
+                               const ::com::sun::star::rendering::StrokeAttributes& 									strokeAttributes );
+        ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XCachedPrimitive > SAL_CALL 	
+        	fillPolyPolygon( const ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XPolyPolygon2D >& xPolyPolygon, 
+                             const ::com::sun::star::rendering::ViewState& 											viewState, 
+                             const ::com::sun::star::rendering::RenderState& 										renderState );
+        ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XCachedPrimitive > SAL_CALL 	
+        	fillTexturedPolyPolygon( const ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XPolyPolygon2D >& xPolyPolygon, 
+                                     const ::com::sun::star::rendering::ViewState& 											viewState, 
+                                     const ::com::sun::star::rendering::RenderState& 										renderState, 
+                                     const ::com::sun::star::uno::Sequence< ::com::sun::star::rendering::Texture >& 		textures );
+        ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XCachedPrimitive > SAL_CALL 	
+        	fillTextureMappedPolyPolygon( const ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XPolyPolygon2D >& 	xPolyPolygon, 
+                                          const ::com::sun::star::rendering::ViewState& 											viewState, 
+                                          const ::com::sun::star::rendering::RenderState& 											renderState, 
+                                          const ::com::sun::star::uno::Sequence< ::com::sun::star::rendering::Texture >& 			textures, 
+                                          const ::com::sun::star::uno::Reference< ::com::sun::star::geometry::XMapping2D >& 		xMapping );
 
-        ::com::sun::star::uno::Reference< ::drafts::com::sun::star::rendering::XCanvasFont > SAL_CALL
-        	createFont( const ::drafts::com::sun::star::rendering::FontRequest& 								fontRequest, 
+        ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XCanvasFont > SAL_CALL
+        	createFont( const ::com::sun::star::rendering::FontRequest& 								fontRequest, 
                         const ::com::sun::star::uno::Sequence< ::com::sun::star::beans::PropertyValue >& 		extraFontProperties, 
-                        const ::drafts::com::sun::star::geometry::Matrix2D& 									fontMatrix );
+                        const ::com::sun::star::geometry::Matrix2D& 									fontMatrix );
 
-        ::com::sun::star::uno::Sequence< ::drafts::com::sun::star::rendering::FontInfo > SAL_CALL 
-        	queryAvailableFonts( const ::drafts::com::sun::star::rendering::FontInfo& 								aFilter, 
+        ::com::sun::star::uno::Sequence< ::com::sun::star::rendering::FontInfo > SAL_CALL 
+        	queryAvailableFonts( const ::com::sun::star::rendering::FontInfo& 								aFilter, 
                                  const ::com::sun::star::uno::Sequence< ::com::sun::star::beans::PropertyValue >& 	aFontProperties );
 
-        ::com::sun::star::uno::Reference< ::drafts::com::sun::star::rendering::XCachedPrimitive > SAL_CALL 
-        	drawText( const ::drafts::com::sun::star::rendering::StringContext& 									text, 
-                      const ::com::sun::star::uno::Reference< ::drafts::com::sun::star::rendering::XCanvasFont >& 	xFont, 
-                      const ::drafts::com::sun::star::rendering::ViewState& 										viewState, 
-                      const ::drafts::com::sun::star::rendering::RenderState& 										renderState, 
+        ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XCachedPrimitive > SAL_CALL 
+        	drawText( const ::com::sun::star::rendering::StringContext& 									text, 
+                      const ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XCanvasFont >& 	xFont, 
+                      const ::com::sun::star::rendering::ViewState& 										viewState, 
+                      const ::com::sun::star::rendering::RenderState& 										renderState, 
                       sal_Int8 																						textDirection );
 
-        ::com::sun::star::uno::Reference< ::drafts::com::sun::star::rendering::XCachedPrimitive > SAL_CALL 
-        	drawTextLayout( const ::com::sun::star::uno::Reference< ::drafts::com::sun::star::rendering::XTextLayout >& layoutetText, 
-                            const ::drafts::com::sun::star::rendering::ViewState& 										viewState, 
-                            const ::drafts::com::sun::star::rendering::RenderState& 									renderState );
-
-        ::com::sun::star::uno::Reference< ::drafts::com::sun::star::rendering::XCachedPrimitive > SAL_CALL 	
-        	drawBitmap( const ::com::sun::star::uno::Reference< ::drafts::com::sun::star::rendering::XBitmap >& xBitmap, 
-                        const ::drafts::com::sun::star::rendering::ViewState& 									viewState, 
-                        const ::drafts::com::sun::star::rendering::RenderState& 								renderState );
-        ::com::sun::star::uno::Reference< ::drafts::com::sun::star::rendering::XCachedPrimitive > SAL_CALL 	
-        	drawBitmapModulated( const ::com::sun::star::uno::Reference< ::drafts::com::sun::star::rendering::XBitmap >&	xBitmap, 
-                                 const ::drafts::com::sun::star::rendering::ViewState& 										viewState, 
-                                 const ::drafts::com::sun::star::rendering::RenderState& 									renderState );
-        ::com::sun::star::uno::Reference< ::drafts::com::sun::star::rendering::XGraphicDevice > SAL_CALL 
+        ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XCachedPrimitive > SAL_CALL 
+        	drawTextLayout( const ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XTextLayout >& layoutetText, 
+                            const ::com::sun::star::rendering::ViewState& 										viewState, 
+                            const ::com::sun::star::rendering::RenderState& 									renderState );
+
+        ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XCachedPrimitive > SAL_CALL 	
+        	drawBitmap( const ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XBitmap >& xBitmap, 
+                        const ::com::sun::star::rendering::ViewState& 									viewState, 
+                        const ::com::sun::star::rendering::RenderState& 								renderState );
+        ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XCachedPrimitive > SAL_CALL 	
+        	drawBitmapModulated( const ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XBitmap >&	xBitmap, 
+                                 const ::com::sun::star::rendering::ViewState& 										viewState, 
+                                 const ::com::sun::star::rendering::RenderState& 									renderState );
+        ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XGraphicDevice > SAL_CALL 
         	getDevice();
 
         // BitmapCanvasHelper functionality
         // ================================
 
-        void SAL_CALL copyRect( const ::com::sun::star::uno::Reference< ::drafts::com::sun::star::rendering::XBitmapCanvas >& 	sourceCanvas, 
-                                const ::drafts::com::sun::star::geometry::RealRectangle2D& 										sourceRect, 
-                                const ::drafts::com::sun::star::rendering::ViewState& 											sourceViewState, 
-                                const ::drafts::com::sun::star::rendering::RenderState& 										sourceRenderState, 
-                                const ::drafts::com::sun::star::geometry::RealRectangle2D& 										destRect, 
-                                const ::drafts::com::sun::star::rendering::ViewState& 											destViewState, 
-                                const ::drafts::com::sun::star::rendering::RenderState& 										destRenderState );
+        void SAL_CALL copyRect( const ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XBitmapCanvas >& 	sourceCanvas, 
+                                const ::com::sun::star::geometry::RealRectangle2D& 										sourceRect, 
+                                const ::com::sun::star::rendering::ViewState& 											sourceViewState, 
+                                const ::com::sun::star::rendering::RenderState& 										sourceRenderState, 
+                                const ::com::sun::star::geometry::RealRectangle2D& 										destRect, 
+                                const ::com::sun::star::rendering::ViewState& 											destViewState, 
+                                const ::com::sun::star::rendering::RenderState& 										destRenderState );
             
-        ::drafts::com::sun::star::geometry::IntegerSize2D SAL_CALL getSize();
+        ::com::sun::star::geometry::IntegerSize2D SAL_CALL getSize();
 
-        ::com::sun::star::uno::Reference< ::drafts::com::sun::star::rendering::XBitmap > SAL_CALL 
-        	getScaledBitmap( const ::drafts::com::sun::star::geometry::RealSize2D& 	newSize, 
+        ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XBitmap > SAL_CALL 
+        	getScaledBitmap( const ::com::sun::star::geometry::RealSize2D& 	newSize, 
                              sal_Bool 												beFast );
 
         ::com::sun::star::uno::Sequence< sal_Int8 > SAL_CALL 
-	        getData( const ::drafts::com::sun::star::geometry::IntegerRectangle2D& rect );
+	        getData( const ::com::sun::star::geometry::IntegerRectangle2D& rect );
 
         void SAL_CALL setData( const ::com::sun::star::uno::Sequence< sal_Int8 >& 				data, 
-                               const ::drafts::com::sun::star::geometry::IntegerRectangle2D& 	rect );
+                               const ::com::sun::star::geometry::IntegerRectangle2D& 	rect );
 
         void SAL_CALL setPixel( const ::com::sun::star::uno::Sequence< sal_Int8 >& 			color, 
-                                const ::drafts::com::sun::star::geometry::IntegerPoint2D& 	pos );
+                                const ::com::sun::star::geometry::IntegerPoint2D& 	pos );
 
         ::com::sun::star::uno::Sequence< sal_Int8 > SAL_CALL 
-	        getPixel( const ::drafts::com::sun::star::geometry::IntegerPoint2D& pos );
+	        getPixel( const ::com::sun::star::geometry::IntegerPoint2D& pos );
 
-        ::com::sun::star::uno::Reference< ::drafts::com::sun::star::rendering::XBitmapPalette > SAL_CALL getPalette();
+        ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XBitmapPalette > SAL_CALL getPalette();
 
-        ::drafts::com::sun::star::rendering::IntegerBitmapLayout SAL_CALL getMemoryLayout();
+        ::com::sun::star::rendering::IntegerBitmapLayout SAL_CALL getMemoryLayout();
         
         // Flush drawing queue to screen
         void					flush() const;
@@ -289,8 +289,8 @@
         
         // returns transparency of color
         void setupGraphicsState( SurfaceGraphicsSharedPtr&									rGraphics,
-                                 const ::drafts::com::sun::star::rendering::ViewState& 		viewState, 
-                                 const ::drafts::com::sun::star::rendering::RenderState& 	renderState );
+                                 const ::com::sun::star::rendering::ViewState& 		viewState, 
+                                 const ::com::sun::star::rendering::RenderState& 	renderState );
         
         Gdiplus::CompositingMode 	calcCompositingMode( sal_Int8 nMode );
 
diff -u -r  canvas/source/win/dx_impltools.cxx  canvas/source/win/dx_impltools.cxx
---  canvas/source/win/dx_impltools.cxx	2004-11-26 22:51:31.000000000 +0530
+++  canvas/source/win/dx_impltools.cxx	2005-02-28 13:41:07.796628303 +0530
@@ -62,16 +62,16 @@
 #include <canvas/debug.hxx>
 #include <canvas/verbosetrace.hxx>
 
-#ifndef _DRAFTS_COM_SUN_STAR_GEOMETRY_REALPOINT2D_HPP_
-#include <drafts/com/sun/star/geometry/RealPoint2D.hpp>
+#ifndef _COM_SUN_STAR_GEOMETRY_REALPOINT2D_HPP_
+#include <com/sun/star/geometry/RealPoint2D.hpp>
 #endif
 
 #ifndef _COM_SUN_STAR_LANG_XSERVICEINFO_HPP_
 #include <com/sun/star/lang/XServiceInfo.hpp>
 #endif
 
-#ifndef _DRAFTS_COM_SUN_STAR_GEOMETRY_INTEGERRECTANGLE2D_HPP__
-#include <drafts/com/sun/star/geometry/IntegerRectangle2D.hpp>
+#ifndef _COM_SUN_STAR_GEOMETRY_INTEGERRECTANGLE2D_HPP__
+#include <com/sun/star/geometry/IntegerRectangle2D.hpp>
 #endif
 
 #ifndef _BGFX_MATRIX_B2DHOMMATRIX_HXX
@@ -99,7 +99,6 @@
 
 
 using namespace ::com::sun::star;
-using namespace ::drafts::com::sun::star;
 
 
 namespace dxcanvas
@@ -170,14 +169,14 @@
         {
             // TODO(P2): Check whether this gets inlined. If not, make functor
             // out of it
-            inline Gdiplus::PointF implGdiPlusPointFromRealPoint2D( const ::drafts::com::sun::star::geometry::RealPoint2D& rPoint )
+            inline Gdiplus::PointF implGdiPlusPointFromRealPoint2D( const ::com::sun::star::geometry::RealPoint2D& rPoint )
             {
                 return Gdiplus::PointF( static_cast<Gdiplus::REAL>(rPoint.X), 
                                         static_cast<Gdiplus::REAL>(rPoint.Y) );
             }
         }
 
-        Gdiplus::PointF gdiPlusPointFromRealPoint2D( const ::drafts::com::sun::star::geometry::RealPoint2D& rPoint )
+        Gdiplus::PointF gdiPlusPointFromRealPoint2D( const ::com::sun::star::geometry::RealPoint2D& rPoint )
         {
             return implGdiPlusPointFromRealPoint2D( rPoint );
         }
diff -u -r  canvas/source/win/dx_impltools.hxx  canvas/source/win/dx_impltools.hxx
---  canvas/source/win/dx_impltools.hxx	2004-11-26 22:51:46.000000000 +0530
+++  canvas/source/win/dx_impltools.hxx	2005-02-28 13:41:07.797628186 +0530
@@ -84,20 +84,20 @@
 	class B2DPolyPolygon;
 };
 
-namespace drafts { namespace com { namespace sun { namespace star { namespace geometry
+namespace com { namespace sun { namespace star { namespace geometry
 {
     struct IntegerRectangle2D;
     struct RealPoint2D;
-} } } } }
+} } } }
 
-namespace drafts { namespace com { namespace sun { namespace star { namespace rendering 
+namespace com { namespace sun { namespace star { namespace rendering 
 {
     class  XCanvas;
     class  XGraphicDevice;
     class  XBitmap;
     class  XPolyPolygon2D;
     class  XCanvasFont;
-} } } } }
+} } } }
 
 
 namespace dxcanvas
@@ -106,41 +106,41 @@
     {
         ::basegfx::B2DPolyPolygon
         polyPolygonFromXPolyPolygon2D( const ::com::sun::star::uno::Reference< 
-                                       ::drafts::com::sun::star::rendering::XPolyPolygon2D >& );
+                                       ::com::sun::star::rendering::XPolyPolygon2D >& );
 
         void setupGraphics( Gdiplus::Graphics& rGraphics );
 
         void gdiPlusMatrixFromB2DHomMatrix( Gdiplus::Matrix& 				rGdiplusMatrix, 
                                             const ::basegfx::B2DHomMatrix&	rMatrix );
         void gdiPlusMatrixFromAffineMatrix2D( Gdiplus::Matrix& 											rGdiplusMatrix, 
-                                              const ::drafts::com::sun::star::geometry::AffineMatrix2D& rMatrix );
+                                              const ::com::sun::star::geometry::AffineMatrix2D& rMatrix );
 
-        Gdiplus::PointF gdiPlusPointFromRealPoint2D( const ::drafts::com::sun::star::geometry::RealPoint2D& );
-        Gdiplus::Rect 	gdiPlusRectFromIntegerRectangle2D( const ::drafts::com::sun::star::geometry::IntegerRectangle2D& );
+        Gdiplus::PointF gdiPlusPointFromRealPoint2D( const ::com::sun::star::geometry::RealPoint2D& );
+        Gdiplus::Rect 	gdiPlusRectFromIntegerRectangle2D( const ::com::sun::star::geometry::IntegerRectangle2D& );
         RECT 			gdiRectFromB2IRect( const ::basegfx::B2IRange& );
 
         ::com::sun::star::uno::Sequence< double > argbToDoubleSequence( 
-            const ::com::sun::star::uno::Reference< ::drafts::com::sun::star::rendering::XGraphicDevice >& 	xDevice,
+            const ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XGraphicDevice >& 	xDevice,
             const Gdiplus::ARGB&																			rColor		 );
         ::com::sun::star::uno::Sequence< sal_Int8 > argbToIntSequence( 
-            const ::com::sun::star::uno::Reference< ::drafts::com::sun::star::rendering::XGraphicDevice >& 	xDevice,
+            const ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XGraphicDevice >& 	xDevice,
             const Gdiplus::ARGB&																			rColor		 );
-        Gdiplus::ARGB sequenceToArgb( const ::com::sun::star::uno::Reference< ::drafts::com::sun::star::rendering::XGraphicDevice >& xDevice,
+        Gdiplus::ARGB sequenceToArgb( const ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XGraphicDevice >& xDevice,
                                       const ::com::sun::star::uno::Sequence< sal_Int8 >&											 rColor	 );
-        Gdiplus::ARGB sequenceToArgb( const ::com::sun::star::uno::Reference< ::drafts::com::sun::star::rendering::XGraphicDevice >& xDevice,
+        Gdiplus::ARGB sequenceToArgb( const ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XGraphicDevice >& xDevice,
                                       const ::com::sun::star::uno::Sequence< double >&												 rColor	 );
 
         GraphicsPathSharedPtr graphicsPathFromRealPoint2DSequence( const ::com::sun::star::uno::Sequence< 
-                                                                 ::com::sun::star::uno::Sequence< ::drafts::com::sun::star::geometry::RealPoint2D > >& );
+                                                                 ::com::sun::star::uno::Sequence< ::com::sun::star::geometry::RealPoint2D > >& );
 
         GraphicsPathSharedPtr graphicsPathFromXPolyPolygon2D( const ::com::sun::star::uno::Reference< 
-                                                              ::drafts::com::sun::star::rendering::XPolyPolygon2D >& );
+                                                              ::com::sun::star::rendering::XPolyPolygon2D >& );
 
         BitmapSharedPtr bitmapFromXBitmap( const ::com::sun::star::uno::Reference< 
-                                           ::drafts::com::sun::star::rendering::XBitmap >& );
+                                           ::com::sun::star::rendering::XBitmap >& );
 
         CanvasFont::ImplRef	canvasFontFromXFont( const ::com::sun::star::uno::Reference< 
-                                                 	::drafts::com::sun::star::rendering::XCanvasFont >& xFont );
+                                                 	::com::sun::star::rendering::XCanvasFont >& xFont );
 
         void setModulateImageAttributes( Gdiplus::ImageAttributes& o_rAttr,
                                          double					   nRedModulation,
diff -u -r  canvas/source/win/dx_linepolypolygon.cxx  canvas/source/win/dx_linepolypolygon.cxx
---  canvas/source/win/dx_linepolypolygon.cxx	2004-11-26 22:51:59.000000000 +0530
+++  canvas/source/win/dx_linepolypolygon.cxx	2005-02-28 13:41:07.809626784 +0530
@@ -68,7 +68,6 @@
 #endif
 
 using namespace ::com::sun::star;
-using namespace ::drafts::com::sun::star;
 
 namespace dxcanvas
 {
@@ -141,7 +140,7 @@
         return ::rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( LINEPOLYPOLYGON_IMPLEMENTATION_NAME ) );
     }
 
-#define SERVICE_NAME "drafts.com.sun.star.rendering.LinePolyPolygon"
+#define SERVICE_NAME "com.sun.star.rendering.LinePolyPolygon"
 
     sal_Bool SAL_CALL LinePolyPolygon::supportsService( const ::rtl::OUString& ServiceName ) throw (uno::RuntimeException)
     {
diff -u -r  canvas/source/win/dx_linepolypolygon.hxx  canvas/source/win/dx_linepolypolygon.hxx
---  canvas/source/win/dx_linepolypolygon.hxx	2004-11-26 22:52:12.000000000 +0530
+++  canvas/source/win/dx_linepolypolygon.hxx	2005-02-28 13:41:07.809626784 +0530
@@ -74,8 +74,8 @@
 #include <com/sun/star/lang/XServiceInfo.hpp>
 #endif
 
-#ifndef _DRAFTS_COM_SUN_STAR_RENDERING_XLINEPOLYPOLYGON2D_HPP_
-#include <drafts/com/sun/star/rendering/XLinePolyPolygon2D.hpp>
+#ifndef _COM_SUN_STAR_RENDERING_XLINEPOLYPOLYGON2D_HPP_
+#include <com/sun/star/rendering/XLinePolyPolygon2D.hpp>
 #endif
 
 #ifndef _CANVAS_CANVASTOOLS_HXX
@@ -94,16 +94,16 @@
     class LinePolyPolygon : public ::canvas::tools::LinePolyPolygonBase
     {
     public:
-        explicit LinePolyPolygon( const ::com::sun::star::uno::Sequence< ::com::sun::star::uno::Sequence< ::drafts::com::sun::star::geometry::RealPoint2D > >& points );
+        explicit LinePolyPolygon( const ::com::sun::star::uno::Sequence< ::com::sun::star::uno::Sequence< ::com::sun::star::geometry::RealPoint2D > >& points );
 
         // XPolyPolygon2D
-        virtual void SAL_CALL addPolyPolygon( const ::drafts::com::sun::star::geometry::RealPoint2D& position, const ::com::sun::star::uno::Reference< ::drafts::com::sun::star::rendering::XPolyPolygon2D >& polyPolygon ) throw (::com::sun::star::uno::RuntimeException);
-        virtual void SAL_CALL setFillRule( ::drafts::com::sun::star::rendering::FillRule fillRule ) throw (::com::sun::star::uno::RuntimeException);
+        virtual void SAL_CALL addPolyPolygon( const ::com::sun::star::geometry::RealPoint2D& position, const ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XPolyPolygon2D >& polyPolygon ) throw (::com::sun::star::uno::RuntimeException);
+        virtual void SAL_CALL setFillRule( ::com::sun::star::rendering::FillRule fillRule ) throw (::com::sun::star::uno::RuntimeException);
         virtual void SAL_CALL setClosed( sal_Int32 index, sal_Bool closedState ) throw (::com::sun::star::uno::RuntimeException);
 
         // XLinePolyPolygon2D
-        virtual void SAL_CALL setPoints( const ::com::sun::star::uno::Sequence< ::com::sun::star::uno::Sequence< ::drafts::com::sun::star::geometry::RealPoint2D > >& points, sal_Int32 nPolygonIndex, sal_Int32 nPointIndex ) throw (::com::sun::star::uno::RuntimeException);
-        virtual void SAL_CALL setPoint( const ::drafts::com::sun::star::geometry::RealPoint2D& point, sal_Int32 nPolygonIndex, sal_Int32 nPointIndex ) throw (::com::sun::star::uno::RuntimeException);
+        virtual void SAL_CALL setPoints( const ::com::sun::star::uno::Sequence< ::com::sun::star::uno::Sequence< ::com::sun::star::geometry::RealPoint2D > >& points, sal_Int32 nPolygonIndex, sal_Int32 nPointIndex ) throw (::com::sun::star::uno::RuntimeException);
+        virtual void SAL_CALL setPoint( const ::com::sun::star::geometry::RealPoint2D& point, sal_Int32 nPolygonIndex, sal_Int32 nPointIndex ) throw (::com::sun::star::uno::RuntimeException);
 
         // XServiceInfo
         virtual ::rtl::OUString SAL_CALL getImplementationName(  ) throw (::com::sun::star::uno::RuntimeException);
diff -u -r  canvas/source/win/dx_parametricpolypolygon.cxx  canvas/source/win/dx_parametricpolypolygon.cxx
---  canvas/source/win/dx_parametricpolypolygon.cxx	2004-11-26 22:52:23.000000000 +0530
+++  canvas/source/win/dx_parametricpolypolygon.cxx	2005-02-28 13:41:07.772631107 +0530
@@ -64,13 +64,12 @@
 #include "dx_parametricpolypolygon.hxx"
 #include <dx_impltools.hxx>
 
-#ifndef _DRAFTS_COM_SUN_STAR_RENDERING_TEXTURINGMODE_HPP_
-#include <drafts/com/sun/star/rendering/TexturingMode.hpp>
+#ifndef _COM_SUN_STAR_RENDERING_TEXTURINGMODE_HPP_
+#include <com/sun/star/rendering/TexturingMode.hpp>
 #endif
 
 
 using namespace ::com::sun::star;
-using namespace ::drafts::com::sun::star;
 
 namespace dxcanvas
 {
@@ -290,7 +289,7 @@
         return uno::Sequence< double >();
     }
 
-#define SERVICE_NAME "drafts.com.sun.star.rendering.ParametricPolyPolygon"
+#define SERVICE_NAME "com.sun.star.rendering.ParametricPolyPolygon"
 
     ::rtl::OUString SAL_CALL ParametricPolyPolygon::getImplementationName(  ) throw (uno::RuntimeException)
     {
diff -u -r  canvas/source/win/dx_parametricpolypolygon.hxx  canvas/source/win/dx_parametricpolypolygon.hxx
---  canvas/source/win/dx_parametricpolypolygon.hxx	2004-11-26 22:52:34.000000000 +0530
+++  canvas/source/win/dx_parametricpolypolygon.hxx	2005-02-28 13:41:07.773630990 +0530
@@ -72,11 +72,11 @@
 #ifndef _COM_SUN_STAR_LANG_XSERVICEINFO_HPP_
 #include <com/sun/star/lang/XServiceInfo.hpp>
 #endif
-#ifndef _DRAFTS_COM_SUN_STAR_RENDERING_XGRAPHICDEVICE_HPP_
-#include <drafts/com/sun/star/rendering/XGraphicDevice.hpp>
+#ifndef _COM_SUN_STAR_RENDERING_XGRAPHICDEVICE_HPP_
+#include <com/sun/star/rendering/XGraphicDevice.hpp>
 #endif
-#ifndef _DRAFTS_COM_SUN_STAR_RENDERING_XPARAMETRICPOLYPOLYGON2D_HPP_
-#include <drafts/com/sun/star/rendering/XParametricPolyPolygon2D.hpp>
+#ifndef _COM_SUN_STAR_RENDERING_XPARAMETRICPOLYPOLYGON2D_HPP_
+#include <com/sun/star/rendering/XParametricPolyPolygon2D.hpp>
 #endif
 
 #include "dx_winstuff.hxx"
@@ -89,7 +89,7 @@
 
 namespace dxcanvas
 {
-    typedef ::cppu::WeakComponentImplHelper2< ::drafts::com::sun::star::rendering::XParametricPolyPolygon2D,
+    typedef ::cppu::WeakComponentImplHelper2< ::com::sun::star::rendering::XParametricPolyPolygon2D,
             		   			  		      ::com::sun::star::lang::XServiceInfo > ParametricPolyPolygon_Base;
 
     class ParametricPolyPolygon : public ::comphelper::OBaseMutex, public ParametricPolyPolygon_Base
@@ -99,28 +99,28 @@
         static ParametricPolyPolygon* createLinearHorizontalGradient( const ::com::sun::star::uno::Sequence< double >& 			leftColor, 
                                                                       const ::com::sun::star::uno::Sequence< double >& 			rightColor,
                                                                       const ::com::sun::star::uno::Reference< 
-                                                                      	::drafts::com::sun::star::rendering::XGraphicDevice >&  xDevice );
+                                                                      	::com::sun::star::rendering::XGraphicDevice >&  xDevice );
         static ParametricPolyPolygon* createAxialHorizontalGradient( const ::com::sun::star::uno::Sequence< double >& 			middleColor, 
                                                                      const ::com::sun::star::uno::Sequence< double >& 			endColor,
                                                                      const ::com::sun::star::uno::Reference< 
-                                                                      	::drafts::com::sun::star::rendering::XGraphicDevice >&  xDevice );
+                                                                      	::com::sun::star::rendering::XGraphicDevice >&  xDevice );
         static ParametricPolyPolygon* createCircularGradient( const ::com::sun::star::uno::Sequence< double >& 			centerColor, 
                                                               const ::com::sun::star::uno::Sequence< double >& 			endColor,
                                                               const ::com::sun::star::uno::Reference< 
-                                                             	 ::drafts::com::sun::star::rendering::XGraphicDevice >& xDevice );
+                                                             	 ::com::sun::star::rendering::XGraphicDevice >& xDevice );
         static ParametricPolyPolygon* createRectangularGradient( const ::com::sun::star::uno::Sequence< double >& 			centerColor, 
                                                                  const ::com::sun::star::uno::Sequence< double >& 			endColor,
-                                                                 const ::drafts::com::sun::star::geometry::RealRectangle2D&	boundRect,
+                                                                 const ::com::sun::star::geometry::RealRectangle2D&	boundRect,
                                                                  const ::com::sun::star::uno::Reference< 
-	                                                             	 ::drafts::com::sun::star::rendering::XGraphicDevice >& xDevice );
+	                                                             	 ::com::sun::star::rendering::XGraphicDevice >& xDevice );
 
         /// Dispose all internal references
         virtual void SAL_CALL disposing();
 
         // XParametricPolyPolygon2D
-        virtual ::com::sun::star::uno::Reference< ::drafts::com::sun::star::rendering::XPolyPolygon2D > SAL_CALL getOutline( double t ) throw (::com::sun::star::lang::IllegalArgumentException, ::com::sun::star::uno::RuntimeException);
+        virtual ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XPolyPolygon2D > SAL_CALL getOutline( double t ) throw (::com::sun::star::lang::IllegalArgumentException, ::com::sun::star::uno::RuntimeException);
         virtual ::com::sun::star::uno::Sequence< double > SAL_CALL getColor( double t ) throw (::com::sun::star::lang::IllegalArgumentException, ::com::sun::star::uno::RuntimeException);
-        virtual ::com::sun::star::uno::Sequence< double > SAL_CALL getPointColor( const ::drafts::com::sun::star::geometry::RealPoint2D& point ) throw (::com::sun::star::lang::IllegalArgumentException, ::com::sun::star::uno::RuntimeException);
+        virtual ::com::sun::star::uno::Sequence< double > SAL_CALL getPointColor( const ::com::sun::star::geometry::RealPoint2D& point ) throw (::com::sun::star::lang::IllegalArgumentException, ::com::sun::star::uno::RuntimeException);
 
         // XServiceInfo
         virtual ::rtl::OUString SAL_CALL getImplementationName(  ) throw (::com::sun::star::uno::RuntimeException);
@@ -129,9 +129,9 @@
 
         bool fill( SurfaceGraphicsSharedPtr&								rGraphics,
                    const GraphicsPathSharedPtr& 							rPath,
-                   const ::drafts::com::sun::star::rendering::ViewState& 	viewState, 
-                   const ::drafts::com::sun::star::rendering::RenderState&	renderState,
-                   const ::drafts::com::sun::star::rendering::Texture&	    texture ) const;
+                   const ::com::sun::star::rendering::ViewState& 	viewState, 
+                   const ::com::sun::star::rendering::RenderState&	renderState,
+                   const ::com::sun::star::rendering::Texture&	    texture ) const;
 
     protected:
         ~ParametricPolyPolygon(); // we're a ref-counted UNO class. _We_ destroy ourselves.
@@ -164,11 +164,11 @@
 
         template< typename BrushType > void applyTextureParams( BrushType*											pBrush,
                                                                 const Gdiplus::Matrix&	 							rMatrix,
-                                                                const ::drafts::com::sun::star::rendering::Texture& rTexture ) const;
+                                                                const ::com::sun::star::rendering::Texture& rTexture ) const;
 
         void applyTextureParameters( const VectorOfBrushes::const_iterator&					rIter,
                                      const Gdiplus::Matrix&	 								rMatrix,
-                                     const ::drafts::com::sun::star::rendering::Texture& 	rTexture ) const;
+                                     const ::com::sun::star::rendering::Texture& 	rTexture ) const;
 
 
         VectorOfBrushes	maBrushes;
diff -u -r  canvas/source/win/dx_spritecanvas.cxx  canvas/source/win/dx_spritecanvas.cxx
---  canvas/source/win/dx_spritecanvas.cxx	2004-11-26 22:53:44.000000000 +0530
+++  canvas/source/win/dx_spritecanvas.cxx	2005-02-28 13:41:07.815626083 +0530
@@ -123,11 +123,10 @@
 #include <dx_gdisurface.hxx>
 
 using namespace ::com::sun::star;
-using namespace ::drafts::com::sun::star;
 
 
 #define IMPLEMENTATION_NAME "DXCanvas::SpriteCanvas"
-#define SERVICE_NAME "drafts.com.sun.star.rendering.DXCanvas"
+#define SERVICE_NAME "com.sun.star.rendering.DXCanvas"
 
 namespace
 {
diff -u -r  canvas/source/win/dx_spritecanvas.hxx  canvas/source/win/dx_spritecanvas.hxx
---  canvas/source/win/dx_spritecanvas.hxx	2004-11-26 22:54:00.000000000 +0530
+++  canvas/source/win/dx_spritecanvas.hxx	2005-02-28 13:41:07.816625966 +0530
@@ -83,11 +83,11 @@
 #ifndef _COM_SUN_STAR_AWT_XWINDOW_HPP_
 #include <com/sun/star/awt/XWindow.hpp>
 #endif
-#ifndef _DRAFTS_COM_SUN_STAR_RENDERING_XINTEGERBITMAP_HPP_
-#include <drafts/com/sun/star/rendering/XIntegerBitmap.hpp>
+#ifndef _COM_SUN_STAR_RENDERING_XINTEGERBITMAP_HPP_
+#include <com/sun/star/rendering/XIntegerBitmap.hpp>
 #endif
-#ifndef _DRAFTS_COM_SUN_STAR_RENDERING_XSPRITECANVAS_HPP_
-#include <drafts/com/sun/star/rendering/XSpriteCanvas.hpp>
+#ifndef _COM_SUN_STAR_RENDERING_XSPRITECANVAS_HPP_
+#include <com/sun/star/rendering/XSpriteCanvas.hpp>
 #endif
 
 #include <list>
@@ -111,8 +111,8 @@
 
 namespace dxcanvas
 {
-    typedef ::cppu::WeakComponentImplHelper6< ::drafts::com::sun::star::rendering::XSpriteCanvas,
-											  ::drafts::com::sun::star::rendering::XIntegerBitmap,
+    typedef ::cppu::WeakComponentImplHelper6< ::com::sun::star::rendering::XSpriteCanvas,
+											  ::com::sun::star::rendering::XIntegerBitmap,
 											  ::com::sun::star::awt::XWindow,
                         					   ::com::sun::star::lang::XInitialization,
                         					   ::com::sun::star::lang::XServiceInfo,
@@ -131,11 +131,11 @@
         virtual void SAL_CALL disposing();
 
         // XSpriteCanvas
-        virtual ::com::sun::star::uno::Reference< ::drafts::com::sun::star::rendering::XAnimatedSprite > SAL_CALL createSpriteFromAnimation( const ::com::sun::star::uno::Reference< ::drafts::com::sun::star::rendering::XAnimation >& animation ) throw (::com::sun::star::uno::RuntimeException);
-        virtual ::com::sun::star::uno::Reference< ::drafts::com::sun::star::rendering::XAnimatedSprite > SAL_CALL createSpriteFromBitmaps( const ::com::sun::star::uno::Sequence< ::com::sun::star::uno::Reference< ::drafts::com::sun::star::rendering::XBitmap > >& animationBitmaps, 
-                                                                                                                                           sal_Int8 interpolationMode ) throw (::com::sun::star::lang::IllegalArgumentException, ::drafts::com::sun::star::rendering::VolatileContentDestroyedException, ::com::sun::star::uno::RuntimeException);
-        virtual ::com::sun::star::uno::Reference< ::drafts::com::sun::star::rendering::XCustomSprite > SAL_CALL createCustomSprite( const ::drafts::com::sun::star::geometry::RealSize2D& spriteSize ) throw (::com::sun::star::uno::RuntimeException);
-        virtual ::com::sun::star::uno::Reference< ::drafts::com::sun::star::rendering::XSprite > SAL_CALL createClonedSprite( const ::com::sun::star::uno::Reference< ::drafts::com::sun::star::rendering::XSprite >& original ) throw (::com::sun::star::uno::RuntimeException);
+        virtual ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XAnimatedSprite > SAL_CALL createSpriteFromAnimation( const ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XAnimation >& animation ) throw (::com::sun::star::uno::RuntimeException);
+        virtual ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XAnimatedSprite > SAL_CALL createSpriteFromBitmaps( const ::com::sun::star::uno::Sequence< ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XBitmap > >& animationBitmaps, 
+                                                                                                                                           sal_Int8 interpolationMode ) throw (::com::sun::star::lang::IllegalArgumentException, ::com::sun::star::rendering::VolatileContentDestroyedException, ::com::sun::star::uno::RuntimeException);
+        virtual ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XCustomSprite > SAL_CALL createCustomSprite( const ::com::sun::star::geometry::RealSize2D& spriteSize ) throw (::com::sun::star::uno::RuntimeException);
+        virtual ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XSprite > SAL_CALL createClonedSprite( const ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XSprite >& original ) throw (::com::sun::star::uno::RuntimeException);
         virtual sal_Bool SAL_CALL updateScreen( sal_Bool bUpdateAll ) throw (::com::sun::star::uno::RuntimeException);
 
         // XComponent (comes implicitely with XWindow)
diff -u -r  canvas/source/win/dx_sprite.hxx  canvas/source/win/dx_sprite.hxx
---  canvas/source/win/dx_sprite.hxx	2004-11-26 22:53:27.000000000 +0530
+++  canvas/source/win/dx_sprite.hxx	2005-02-28 13:41:07.799627952 +0530
@@ -66,8 +66,8 @@
 #include <rtl/ref.hxx>
 #endif
 
-#ifndef _DRAFTS_COM_SUN_STAR_RENDERING_XCANVAS_HPP_
-#include <drafts/com/sun/star/rendering/XCanvas.hpp>
+#ifndef _COM_SUN_STAR_RENDERING_XCANVAS_HPP_
+#include <com/sun/star/rendering/XCanvas.hpp>
 #endif
 
 #ifndef _BGFX_POINT_B2DPOINT_HXX
diff -u -r  canvas/source/win/dx_textlayout.cxx  canvas/source/win/dx_textlayout.cxx
---  canvas/source/win/dx_textlayout.cxx	2004-11-26 22:55:36.000000000 +0530
+++  canvas/source/win/dx_textlayout.cxx	2005-02-28 13:41:07.775630756 +0530
@@ -77,7 +77,6 @@
 #endif
 
 using namespace ::com::sun::star;
-using namespace ::drafts::com::sun::star;
 
 namespace dxcanvas
 {
@@ -283,7 +282,7 @@
     }
 
 
-#define SERVICE_NAME "drafts.com.sun.star.rendering.TextLayout"
+#define SERVICE_NAME "com.sun.star.rendering.TextLayout"
 
     ::rtl::OUString SAL_CALL TextLayout::getImplementationName() throw( uno::RuntimeException )
     {
diff -u -r  canvas/source/win/dx_textlayout_drawhelper.cxx  canvas/source/win/dx_textlayout_drawhelper.cxx
---  canvas/source/win/dx_textlayout_drawhelper.cxx	2004-11-26 22:55:57.000000000 +0530
+++  canvas/source/win/dx_textlayout_drawhelper.cxx	2005-02-28 13:41:07.819625615 +0530
@@ -71,8 +71,8 @@
 #include <tools/color.hxx>
 #endif
 
-#ifndef _DRAFTS_COM_SUN_STAR_RENDERING_FONTREQUEST_HPP_
-#include <drafts/com/sun/star/rendering/FontRequest.hpp>
+#ifndef _COM_SUN_STAR_RENDERING_FONTREQUEST_HPP_
+#include <com/sun/star/rendering/FontRequest.hpp>
 #endif
 
 #ifndef _COMPHELPER_SEQUENCE_HXX_
@@ -106,7 +106,6 @@
 
 
 using namespace ::com::sun::star;
-using namespace ::drafts::com::sun::star;
 
 //////////////////////////////////////////////////////////////////////////////
 
@@ -147,7 +146,7 @@
 		const ::basegfx::B2ISize& rOutputOffset,
 		const rendering::StringContext& rText,
 		const uno::Sequence< double >& rLogicalAdvancements,
-		const uno::Reference< ::drafts::com::sun::star::rendering::XCanvasFont >& rCanvasFont,
+		const uno::Reference< ::com::sun::star::rendering::XCanvasFont >& rCanvasFont,
 		const geometry::Matrix2D& rFontMatrix)
 	{
 		if(mpVirtualDevice && rText.Length)
@@ -164,7 +163,7 @@
 			mpVirtualDevice->SetTextColor(aColor);
 
 			// create the font
-			const ::drafts::com::sun::star::rendering::FontRequest& rFontRequest = rCanvasFont->getFontRequest();
+			const ::com::sun::star::rendering::FontRequest& rFontRequest = rCanvasFont->getFontRequest();
 			Font aFont(
 				rFontRequest.FontDescription.FamilyName,
 				rFontRequest.FontDescription.StyleName,
diff -u -r  canvas/source/win/dx_textlayout_drawhelper.hxx  canvas/source/win/dx_textlayout_drawhelper.hxx
---  canvas/source/win/dx_textlayout_drawhelper.hxx	2004-11-26 22:56:09.000000000 +0530
+++  canvas/source/win/dx_textlayout_drawhelper.hxx	2005-02-28 13:41:07.820625499 +0530
@@ -66,24 +66,24 @@
 #include <com/sun/star/uno/Sequence.hxx>
 #endif
 
-#ifndef _DRAFTS_COM_SUN_STAR_RENDERING_STRINGCONTEXT_HPP__
-#include <drafts/com/sun/star/rendering/StringContext.hpp>
+#ifndef _COM_SUN_STAR_RENDERING_STRINGCONTEXT_HPP__
+#include <com/sun/star/rendering/StringContext.hpp>
 #endif
 
-#ifndef _DRAFTS_COM_SUN_STAR_RENDERING_XCANVASFONT_HPP__
-#include <drafts/com/sun/star/rendering/XCanvasFont.hpp>
+#ifndef _COM_SUN_STAR_RENDERING_XCANVASFONT_HPP__
+#include <com/sun/star/rendering/XCanvasFont.hpp>
 #endif
 
-#ifndef _DRAFTS_COM_SUN_STAR_GEOMETRY_MATRIX2D_HPP__
-#include <drafts/com/sun/star/geometry/Matrix2D.hpp>
+#ifndef _COM_SUN_STAR_GEOMETRY_MATRIX2D_HPP__
+#include <com/sun/star/geometry/Matrix2D.hpp>
 #endif
 
 #ifndef _BGFX_MATRIX_B2DHOMMATRIX_HXX
 #include <basegfx/matrix/b2dhommatrix.hxx>
 #endif
 
-#ifndef _DRAFTS_COM_SUN_STAR_RENDERING_XGRAPHICDEVICE_HPP__
-#include <drafts/com/sun/star/rendering/XGraphicDevice.hpp>
+#ifndef _COM_SUN_STAR_RENDERING_XGRAPHICDEVICE_HPP__
+#include <com/sun/star/rendering/XGraphicDevice.hpp>
 #endif
 
 #ifndef _BGFX_VECTOR_B2ISIZE_HXX
@@ -98,24 +98,24 @@
 	class TextLayoutDrawHelper
 	{
 		HDC										maHDC;
-		::com::sun::star::uno::Reference< ::drafts::com::sun::star::rendering::XGraphicDevice > mxGraphicDevice;
+		::com::sun::star::uno::Reference< ::com::sun::star::rendering::XGraphicDevice > mxGraphicDevice;
 		VirtualDevice*							mpVirtualDevice;
 
 	public:
 		TextLayoutDrawHelper(
 			HDC aHDC,
-			const ::com::sun::star::uno::Reference< ::drafts::com::sun::star::rendering::XGraphicDevice >& xGraphicDevice);
+			const ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XGraphicDevice >& xGraphicDevice);
 		~TextLayoutDrawHelper();
 
 		// draw text
 		void drawText(
-			const ::drafts::com::sun::star::rendering::ViewState& rViewState, 
-			const ::drafts::com::sun::star::rendering::RenderState& rRenderState,
+			const ::com::sun::star::rendering::ViewState& rViewState, 
+			const ::com::sun::star::rendering::RenderState& rRenderState,
 			const ::basegfx::B2ISize& rOutputOffset,
-			const ::drafts::com::sun::star::rendering::StringContext& rText,
+			const ::com::sun::star::rendering::StringContext& rText,
 			const ::com::sun::star::uno::Sequence< double >& rLogicalAdvancements,
-			const ::com::sun::star::uno::Reference< ::drafts::com::sun::star::rendering::XCanvasFont >& rCanvasFont,
-			const ::drafts::com::sun::star::geometry::Matrix2D& rFontMatrix);
+			const ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XCanvasFont >& rCanvasFont,
+			const ::com::sun::star::geometry::Matrix2D& rFontMatrix);
 	};
 }
 
diff -u -r  canvas/source/win/dx_textlayout.hxx  canvas/source/win/dx_textlayout.hxx
---  canvas/source/win/dx_textlayout.hxx	2004-11-26 22:55:46.000000000 +0530
+++  canvas/source/win/dx_textlayout.hxx	2005-02-28 13:41:07.776630639 +0530
@@ -73,8 +73,8 @@
 #include <com/sun/star/lang/XServiceInfo.hpp>
 #endif
 
-#ifndef _DRAFTS_COM_SUN_STAR_RENDERING_XTEXTLAYOUT_HPP_
-#include <drafts/com/sun/star/rendering/XTextLayout.hpp>
+#ifndef _COM_SUN_STAR_RENDERING_XTEXTLAYOUT_HPP_
+#include <com/sun/star/rendering/XTextLayout.hpp>
 #endif
 
 #ifndef _BGFX_VECTOR_B2ISIZE_HXX
@@ -93,13 +93,13 @@
 
 namespace dxcanvas
 {
-    typedef ::cppu::WeakComponentImplHelper2< ::drafts::com::sun::star::rendering::XTextLayout,
+    typedef ::cppu::WeakComponentImplHelper2< ::com::sun::star::rendering::XTextLayout,
                          					  ::com::sun::star::lang::XServiceInfo > TextLayout_Base;
 
     class TextLayout : public ::comphelper::OBaseMutex, public TextLayout_Base
     {
     public:
-        TextLayout( const ::drafts::com::sun::star::rendering::StringContext& aText, 
+        TextLayout( const ::com::sun::star::rendering::StringContext& aText, 
                     sal_Int8                                                  nDirection, 
                     sal_Int64                                                 nRandomSeed,
                     const CanvasFont::ImplRef&                                rFont );
@@ -108,23 +108,23 @@
         virtual void SAL_CALL disposing();
 
         // XTextLayout
-        virtual ::com::sun::star::uno::Sequence< ::com::sun::star::uno::Reference< ::drafts::com::sun::star::rendering::XPolyPolygon2D > > SAL_CALL queryTextShapes(  ) throw (::com::sun::star::uno::RuntimeException);
-        virtual ::com::sun::star::uno::Sequence< ::drafts::com::sun::star::geometry::RealRectangle2D > SAL_CALL queryInkMeasures(  ) throw (::com::sun::star::uno::RuntimeException);
-        virtual ::com::sun::star::uno::Sequence< ::drafts::com::sun::star::geometry::RealRectangle2D > SAL_CALL queryMeasures(  ) throw (::com::sun::star::uno::RuntimeException);
+        virtual ::com::sun::star::uno::Sequence< ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XPolyPolygon2D > > SAL_CALL queryTextShapes(  ) throw (::com::sun::star::uno::RuntimeException);
+        virtual ::com::sun::star::uno::Sequence< ::com::sun::star::geometry::RealRectangle2D > SAL_CALL queryInkMeasures(  ) throw (::com::sun::star::uno::RuntimeException);
+        virtual ::com::sun::star::uno::Sequence< ::com::sun::star::geometry::RealRectangle2D > SAL_CALL queryMeasures(  ) throw (::com::sun::star::uno::RuntimeException);
         virtual ::com::sun::star::uno::Sequence< double > SAL_CALL queryLogicalAdvancements(  ) throw (::com::sun::star::uno::RuntimeException);
         virtual void SAL_CALL applyLogicalAdvancements( const ::com::sun::star::uno::Sequence< double >& aAdvancements ) throw (::com::sun::star::lang::IllegalArgumentException, ::com::sun::star::uno::RuntimeException);
-        virtual ::drafts::com::sun::star::geometry::RealRectangle2D SAL_CALL queryTextBounds(  ) throw (::com::sun::star::uno::RuntimeException);
+        virtual ::com::sun::star::geometry::RealRectangle2D SAL_CALL queryTextBounds(  ) throw (::com::sun::star::uno::RuntimeException);
         virtual double SAL_CALL justify( double nSize ) throw (::com::sun::star::lang::IllegalArgumentException, ::com::sun::star::uno::RuntimeException);
-        virtual double SAL_CALL combinedJustify( const ::com::sun::star::uno::Sequence< ::com::sun::star::uno::Reference< ::drafts::com::sun::star::rendering::XTextLayout > >& aNextLayouts, double nSize ) throw (::com::sun::star::lang::IllegalArgumentException, ::com::sun::star::uno::RuntimeException);
-        virtual ::drafts::com::sun::star::rendering::TextHit SAL_CALL getTextHit( const ::drafts::com::sun::star::geometry::RealPoint2D& aHitPoint ) throw (::com::sun::star::uno::RuntimeException);
-        virtual ::drafts::com::sun::star::rendering::Caret SAL_CALL getCaret( sal_Int32 nInsertionIndex, sal_Bool bExcludeLigatures ) throw (::com::sun::star::lang::IndexOutOfBoundsException, ::com::sun::star::uno::RuntimeException);
+        virtual double SAL_CALL combinedJustify( const ::com::sun::star::uno::Sequence< ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XTextLayout > >& aNextLayouts, double nSize ) throw (::com::sun::star::lang::IllegalArgumentException, ::com::sun::star::uno::RuntimeException);
+        virtual ::com::sun::star::rendering::TextHit SAL_CALL getTextHit( const ::com::sun::star::geometry::RealPoint2D& aHitPoint ) throw (::com::sun::star::uno::RuntimeException);
+        virtual ::com::sun::star::rendering::Caret SAL_CALL getCaret( sal_Int32 nInsertionIndex, sal_Bool bExcludeLigatures ) throw (::com::sun::star::lang::IndexOutOfBoundsException, ::com::sun::star::uno::RuntimeException);
         virtual sal_Int32 SAL_CALL getNextInsertionIndex( sal_Int32 nStartIndex, sal_Int32 nCaretAdvancement, sal_Bool bExcludeLigatures ) throw (::com::sun::star::lang::IndexOutOfBoundsException, ::com::sun::star::uno::RuntimeException);
-        virtual ::com::sun::star::uno::Reference< ::drafts::com::sun::star::rendering::XPolyPolygon2D > SAL_CALL queryVisualHighlighting( sal_Int32 nStartIndex, sal_Int32 nEndIndex ) throw (::com::sun::star::lang::IndexOutOfBoundsException, ::com::sun::star::uno::RuntimeException);
-        virtual ::com::sun::star::uno::Reference< ::drafts::com::sun::star::rendering::XPolyPolygon2D > SAL_CALL queryLogicalHighlighting( sal_Int32 nStartIndex, sal_Int32 nEndIndex ) throw (::com::sun::star::lang::IndexOutOfBoundsException, ::com::sun::star::uno::RuntimeException);
+        virtual ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XPolyPolygon2D > SAL_CALL queryVisualHighlighting( sal_Int32 nStartIndex, sal_Int32 nEndIndex ) throw (::com::sun::star::lang::IndexOutOfBoundsException, ::com::sun::star::uno::RuntimeException);
+        virtual ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XPolyPolygon2D > SAL_CALL queryLogicalHighlighting( sal_Int32 nStartIndex, sal_Int32 nEndIndex ) throw (::com::sun::star::lang::IndexOutOfBoundsException, ::com::sun::star::uno::RuntimeException);
         virtual double SAL_CALL getBaselineOffset(  ) throw (::com::sun::star::uno::RuntimeException);
         virtual sal_Int8 SAL_CALL getMainTextDirection(  ) throw (::com::sun::star::uno::RuntimeException);
-        virtual ::com::sun::star::uno::Reference< ::drafts::com::sun::star::rendering::XCanvasFont > SAL_CALL getFont(  ) throw (::com::sun::star::uno::RuntimeException);
-        virtual ::drafts::com::sun::star::rendering::StringContext SAL_CALL getText(  ) throw (::com::sun::star::uno::RuntimeException);
+        virtual ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XCanvasFont > SAL_CALL getFont(  ) throw (::com::sun::star::uno::RuntimeException);
+        virtual ::com::sun::star::rendering::StringContext SAL_CALL getText(  ) throw (::com::sun::star::uno::RuntimeException);
         
         // XServiceInfo
         virtual ::rtl::OUString SAL_CALL getImplementationName() throw( ::com::sun::star::uno::RuntimeException );
@@ -133,10 +133,10 @@
 
         bool draw( SurfaceGraphicsSharedPtr&								rGraphics, 
                    const Gdiplus::SolidBrush&								rBrush,
-				   const ::drafts::com::sun::star::rendering::ViewState&	rViewState, 
-				   const ::drafts::com::sun::star::rendering::RenderState&	rRenderState,
+				   const ::com::sun::star::rendering::ViewState&	rViewState, 
+				   const ::com::sun::star::rendering::RenderState&	rRenderState,
 				   const ::basegfx::B2ISize&								rOutputOffset,
-				   const ::com::sun::star::uno::Reference< ::drafts::com::sun::star::rendering::XGraphicDevice >& xGraphicDevice) const;
+				   const ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XGraphicDevice >& xGraphicDevice) const;
 
     protected:
         ~TextLayout(); // we're a ref-counted UNO class. _We_ destroy ourselves.
@@ -148,7 +148,7 @@
 
         // NOTE: no need for GDIPlusUserSharedPtr, mpFont implicitely has one already
 
-        ::drafts::com::sun::star::rendering::StringContext maText;
+        ::com::sun::star::rendering::StringContext maText;
         ::com::sun::star::uno::Sequence< double >          maLogicalAdvancements;
         CanvasFont::ImplRef                                mpFont;
         sal_Int8                                           mnTextDirection;
diff -u -r  canvas/source/win/dx_windowgraphicdevice.cxx  canvas/source/win/dx_windowgraphicdevice.cxx
---  canvas/source/win/dx_windowgraphicdevice.cxx	2004-11-26 22:56:47.000000000 +0530
+++  canvas/source/win/dx_windowgraphicdevice.cxx	2005-02-28 13:41:07.806627134 +0530
@@ -59,8 +59,8 @@
  *
  ************************************************************************/
 
-#ifndef _DRAFTS_COM_SUN_STAR_RENDERING_XLINEPOLYPOLYGON2D_HPP_
-#include <drafts/com/sun/star/rendering/XLinePolyPolygon2D.hpp>
+#ifndef _COM_SUN_STAR_RENDERING_XLINEPOLYPOLYGON2D_HPP_
+#include <com/sun/star/rendering/XLinePolyPolygon2D.hpp>
 #endif
 
 #ifndef _BGFX_TOOLS_CANVASTOOLS_HXX
@@ -77,7 +77,6 @@
 
 
 using namespace ::com::sun::star;
-using namespace ::drafts::com::sun::star;
 
 namespace dxcanvas
 {
@@ -345,7 +344,7 @@
     }
 	
 #define IMPLEMENTATION_NAME "DXCanvas::WindowGraphicDevice"
-#define SERVICE_NAME "drafts.com.sun.star.rendering.WindowGraphicDevice"
+#define SERVICE_NAME "com.sun.star.rendering.WindowGraphicDevice"
 
     ::rtl::OUString SAL_CALL WindowGraphicDevice::getImplementationName(  ) throw (::com::sun::star::uno::RuntimeException)
     {
diff -u -r  canvas/source/win/dx_windowgraphicdevice.hxx  canvas/source/win/dx_windowgraphicdevice.hxx
---  canvas/source/win/dx_windowgraphicdevice.hxx	2004-11-26 22:56:58.000000000 +0530
+++  canvas/source/win/dx_windowgraphicdevice.hxx	2005-02-28 13:41:07.807627017 +0530
@@ -76,11 +76,11 @@
 #ifndef _COM_SUN_STAR_LANG_XSERVICEINFO_HPP_
 #include <com/sun/star/lang/XServiceInfo.hpp>
 #endif
-#ifndef _DRAFTS_COM_SUN_STAR_RENDERING_XGRAPHICDEVICE_HPP_
-#include <drafts/com/sun/star/rendering/XGraphicDevice.hpp>
+#ifndef _COM_SUN_STAR_RENDERING_XGRAPHICDEVICE_HPP_
+#include <com/sun/star/rendering/XGraphicDevice.hpp>
 #endif
-#ifndef _DRAFTS_COM_SUN_STAR_RENDERING_XPARAMETRICPOLYPOLYGON2DFACTORY_HPP_
-#include <drafts/com/sun/star/rendering/XParametricPolyPolygon2DFactory.hpp>
+#ifndef _COM_SUN_STAR_RENDERING_XPARAMETRICPOLYPOLYGON2DFACTORY_HPP_
+#include <com/sun/star/rendering/XParametricPolyPolygon2DFactory.hpp>
 #endif
 
 #ifndef _BGFX_VECTOR_B2ISIZE_HXX
@@ -94,7 +94,7 @@
 	namespace tools 
 	{ 
 		::com::sun::star::uno::Sequence< ::com::sun::star::uno::Any >& getDXDeviceInfo( 
-		    ::com::sun::star::uno::Reference< drafts::com::sun::star::rendering::XGraphicDevice > xDevice, 
+		    ::com::sun::star::uno::Reference< com::sun::star::rendering::XGraphicDevice > xDevice, 
 		    ::com::sun::star::uno::Sequence< ::com::sun::star::uno::Any >& o_rxParams );
 	}
 }
@@ -103,8 +103,8 @@
 
 namespace dxcanvas
 {
-    typedef ::cppu::WeakComponentImplHelper3< ::drafts::com::sun::star::rendering::XGraphicDevice,
-                                              ::drafts::com::sun::star::rendering::XParametricPolyPolygon2DFactory,
+    typedef ::cppu::WeakComponentImplHelper3< ::com::sun::star::rendering::XGraphicDevice,
+                                              ::com::sun::star::rendering::XParametricPolyPolygon2DFactory,
             		   			  		      ::com::sun::star::lang::XServiceInfo > WindowGraphicDevice_Base;
 
     class WindowGraphicDevice : public ::comphelper::OBaseMutex, public WindowGraphicDevice_Base
@@ -112,11 +112,11 @@
     public:
 
 		friend 	::com::sun::star::uno::Sequence< ::com::sun::star::uno::Any >& ::canvas::tools::getDXDeviceInfo( 
-		    ::com::sun::star::uno::Reference< drafts::com::sun::star::rendering::XGraphicDevice > xDevice, 
+		    ::com::sun::star::uno::Reference< com::sun::star::rendering::XGraphicDevice > xDevice, 
 		    ::com::sun::star::uno::Sequence< ::com::sun::star::uno::Any >& o_rxParams );
 	        
 		typedef ::comphelper::ImplementationReference< WindowGraphicDevice, 
-                                                       ::drafts::com::sun::star::rendering::XGraphicDevice > ImplRef;
+                                                       ::com::sun::star::rendering::XGraphicDevice > ImplRef;
 
         /** Create WindowGraphicDevice in window mode
          */
@@ -131,29 +131,29 @@
         virtual void SAL_CALL disposing();
 
         // XGraphicDevice
-        virtual ::com::sun::star::uno::Reference< ::drafts::com::sun::star::rendering::XBufferController > SAL_CALL getBufferController(  ) throw (::com::sun::star::uno::RuntimeException);
-        virtual ::com::sun::star::uno::Reference< ::drafts::com::sun::star::rendering::XColorSpace > SAL_CALL getDeviceColorSpace(  ) throw (::com::sun::star::uno::RuntimeException);
-        virtual ::drafts::com::sun::star::geometry::RealSize2D SAL_CALL getPhysicalResolution(  ) throw (::com::sun::star::uno::RuntimeException);
-        virtual ::drafts::com::sun::star::geometry::RealSize2D SAL_CALL getSize(  ) throw (::com::sun::star::uno::RuntimeException);
-        virtual ::com::sun::star::uno::Reference< ::drafts::com::sun::star::rendering::XLinePolyPolygon2D > SAL_CALL createCompatibleLinePolyPolygon( const ::com::sun::star::uno::Sequence< ::com::sun::star::uno::Sequence< ::drafts::com::sun::star::geometry::RealPoint2D > >& points ) throw (::com::sun::star::uno::RuntimeException);
-        virtual ::com::sun::star::uno::Reference< ::drafts::com::sun::star::rendering::XBezierPolyPolygon2D > SAL_CALL createCompatibleBezierPolyPolygon( const ::com::sun::star::uno::Sequence< ::com::sun::star::uno::Sequence< ::drafts::com::sun::star::geometry::RealBezierSegment2D > >& points ) throw (::com::sun::star::uno::RuntimeException);
-        virtual ::com::sun::star::uno::Reference< ::drafts::com::sun::star::rendering::XBitmap > SAL_CALL createCompatibleBitmap( const ::drafts::com::sun::star::geometry::IntegerSize2D& size ) throw (::com::sun::star::lang::IllegalArgumentException, ::com::sun::star::uno::RuntimeException);
-        virtual ::com::sun::star::uno::Reference< ::drafts::com::sun::star::rendering::XVolatileBitmap > SAL_CALL createVolatileBitmap( const ::drafts::com::sun::star::geometry::IntegerSize2D& size ) throw (::com::sun::star::lang::IllegalArgumentException, ::com::sun::star::uno::RuntimeException);
-        virtual ::com::sun::star::uno::Reference< ::drafts::com::sun::star::rendering::XBitmap > SAL_CALL createCompatibleAlphaBitmap( const ::drafts::com::sun::star::geometry::IntegerSize2D& size ) throw (::com::sun::star::lang::IllegalArgumentException, ::com::sun::star::uno::RuntimeException);
-        virtual ::com::sun::star::uno::Reference< ::drafts::com::sun::star::rendering::XVolatileBitmap > SAL_CALL createVolatileAlphaBitmap( const ::drafts::com::sun::star::geometry::IntegerSize2D& size ) throw (::com::sun::star::lang::IllegalArgumentException, ::com::sun::star::uno::RuntimeException);
-        virtual ::com::sun::star::uno::Reference< ::drafts::com::sun::star::rendering::XParametricPolyPolygon2DFactory > SAL_CALL getParametricPolyPolygonFactory(  ) throw (::com::sun::star::uno::RuntimeException);
+        virtual ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XBufferController > SAL_CALL getBufferController(  ) throw (::com::sun::star::uno::RuntimeException);
+        virtual ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XColorSpace > SAL_CALL getDeviceColorSpace(  ) throw (::com::sun::star::uno::RuntimeException);
+        virtual ::com::sun::star::geometry::RealSize2D SAL_CALL getPhysicalResolution(  ) throw (::com::sun::star::uno::RuntimeException);
+        virtual ::com::sun::star::geometry::RealSize2D SAL_CALL getSize(  ) throw (::com::sun::star::uno::RuntimeException);
+        virtual ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XLinePolyPolygon2D > SAL_CALL createCompatibleLinePolyPolygon( const ::com::sun::star::uno::Sequence< ::com::sun::star::uno::Sequence< ::com::sun::star::geometry::RealPoint2D > >& points ) throw (::com::sun::star::uno::RuntimeException);
+        virtual ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XBezierPolyPolygon2D > SAL_CALL createCompatibleBezierPolyPolygon( const ::com::sun::star::uno::Sequence< ::com::sun::star::uno::Sequence< ::com::sun::star::geometry::RealBezierSegment2D > >& points ) throw (::com::sun::star::uno::RuntimeException);
+        virtual ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XBitmap > SAL_CALL createCompatibleBitmap( const ::com::sun::star::geometry::IntegerSize2D& size ) throw (::com::sun::star::lang::IllegalArgumentException, ::com::sun::star::uno::RuntimeException);
+        virtual ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XVolatileBitmap > SAL_CALL createVolatileBitmap( const ::com::sun::star::geometry::IntegerSize2D& size ) throw (::com::sun::star::lang::IllegalArgumentException, ::com::sun::star::uno::RuntimeException);
+        virtual ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XBitmap > SAL_CALL createCompatibleAlphaBitmap( const ::com::sun::star::geometry::IntegerSize2D& size ) throw (::com::sun::star::lang::IllegalArgumentException, ::com::sun::star::uno::RuntimeException);
+        virtual ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XVolatileBitmap > SAL_CALL createVolatileAlphaBitmap( const ::com::sun::star::geometry::IntegerSize2D& size ) throw (::com::sun::star::lang::IllegalArgumentException, ::com::sun::star::uno::RuntimeException);
+        virtual ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XParametricPolyPolygon2DFactory > SAL_CALL getParametricPolyPolygonFactory(  ) throw (::com::sun::star::uno::RuntimeException);
         virtual sal_Bool SAL_CALL hasFullScreenMode(  ) throw (::com::sun::star::uno::RuntimeException);
         virtual sal_Bool SAL_CALL enterFullScreenMode( sal_Bool bEnter ) throw (::com::sun::star::uno::RuntimeException);
 
         // XParametricPolyPolygon2DFactory
-        virtual ::com::sun::star::uno::Reference< ::drafts::com::sun::star::rendering::XParametricPolyPolygon2D > SAL_CALL createLinearHorizontalGradient( const ::com::sun::star::uno::Sequence< double >& leftColor, const ::com::sun::star::uno::Sequence< double >& rightColor ) throw (::com::sun::star::lang::IllegalArgumentException, ::com::sun::star::uno::RuntimeException);
-        virtual ::com::sun::star::uno::Reference< ::drafts::com::sun::star::rendering::XParametricPolyPolygon2D > SAL_CALL createAxialHorizontalGradient( const ::com::sun::star::uno::Sequence< double >& middleColor, const ::com::sun::star::uno::Sequence< double >& endColor ) throw (::com::sun::star::lang::IllegalArgumentException, ::com::sun::star::uno::RuntimeException);
-        virtual ::com::sun::star::uno::Reference< ::drafts::com::sun::star::rendering::XParametricPolyPolygon2D > SAL_CALL createCircularGradient( const ::com::sun::star::uno::Sequence< double >& centerColor, const ::com::sun::star::uno::Sequence< double >& endColor ) throw (::com::sun::star::lang::IllegalArgumentException, ::com::sun::star::uno::RuntimeException);
-        virtual ::com::sun::star::uno::Reference< ::drafts::com::sun::star::rendering::XParametricPolyPolygon2D > SAL_CALL createRectangularGradient( const ::com::sun::star::uno::Sequence< double >& centerColor, const ::com::sun::star::uno::Sequence< double >& endColor, const ::drafts::com::sun::star::geometry::RealRectangle2D& boundRect ) throw (::com::sun::star::lang::IllegalArgumentException, ::com::sun::star::uno::RuntimeException);
-        virtual ::com::sun::star::uno::Reference< ::drafts::com::sun::star::rendering::XParametricPolyPolygon2D > SAL_CALL createVerticalLinesHatch( const ::com::sun::star::uno::Sequence< double >& leftColor, const ::com::sun::star::uno::Sequence< double >& rightColor ) throw (::com::sun::star::lang::IllegalArgumentException, ::com::sun::star::uno::RuntimeException);
-        virtual ::com::sun::star::uno::Reference< ::drafts::com::sun::star::rendering::XParametricPolyPolygon2D > SAL_CALL createOrthogonalLinesHatch( const ::com::sun::star::uno::Sequence< double >& leftTopColor, const ::com::sun::star::uno::Sequence< double >& rightBottomColor ) throw (::com::sun::star::lang::IllegalArgumentException, ::com::sun::star::uno::RuntimeException);
-        virtual ::com::sun::star::uno::Reference< ::drafts::com::sun::star::rendering::XParametricPolyPolygon2D > SAL_CALL createThreeCrossingLinesHatch( const ::com::sun::star::uno::Sequence< double >& startColor, const ::com::sun::star::uno::Sequence< double >& endColor ) throw (::com::sun::star::lang::IllegalArgumentException, ::com::sun::star::uno::RuntimeException);
-        virtual ::com::sun::star::uno::Reference< ::drafts::com::sun::star::rendering::XParametricPolyPolygon2D > SAL_CALL createFourCrossingLinesHatch( const ::com::sun::star::uno::Sequence< double >& startColor, const ::com::sun::star::uno::Sequence< double >& endColor ) throw (::com::sun::star::lang::IllegalArgumentException, ::com::sun::star::uno::RuntimeException);
+        virtual ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XParametricPolyPolygon2D > SAL_CALL createLinearHorizontalGradient( const ::com::sun::star::uno::Sequence< double >& leftColor, const ::com::sun::star::uno::Sequence< double >& rightColor ) throw (::com::sun::star::lang::IllegalArgumentException, ::com::sun::star::uno::RuntimeException);
+        virtual ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XParametricPolyPolygon2D > SAL_CALL createAxialHorizontalGradient( const ::com::sun::star::uno::Sequence< double >& middleColor, const ::com::sun::star::uno::Sequence< double >& endColor ) throw (::com::sun::star::lang::IllegalArgumentException, ::com::sun::star::uno::RuntimeException);
+        virtual ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XParametricPolyPolygon2D > SAL_CALL createCircularGradient( const ::com::sun::star::uno::Sequence< double >& centerColor, const ::com::sun::star::uno::Sequence< double >& endColor ) throw (::com::sun::star::lang::IllegalArgumentException, ::com::sun::star::uno::RuntimeException);
+        virtual ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XParametricPolyPolygon2D > SAL_CALL createRectangularGradient( const ::com::sun::star::uno::Sequence< double >& centerColor, const ::com::sun::star::uno::Sequence< double >& endColor, const ::com::sun::star::geometry::RealRectangle2D& boundRect ) throw (::com::sun::star::lang::IllegalArgumentException, ::com::sun::star::uno::RuntimeException);
+        virtual ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XParametricPolyPolygon2D > SAL_CALL createVerticalLinesHatch( const ::com::sun::star::uno::Sequence< double >& leftColor, const ::com::sun::star::uno::Sequence< double >& rightColor ) throw (::com::sun::star::lang::IllegalArgumentException, ::com::sun::star::uno::RuntimeException);
+        virtual ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XParametricPolyPolygon2D > SAL_CALL createOrthogonalLinesHatch( const ::com::sun::star::uno::Sequence< double >& leftTopColor, const ::com::sun::star::uno::Sequence< double >& rightBottomColor ) throw (::com::sun::star::lang::IllegalArgumentException, ::com::sun::star::uno::RuntimeException);
+        virtual ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XParametricPolyPolygon2D > SAL_CALL createThreeCrossingLinesHatch( const ::com::sun::star::uno::Sequence< double >& startColor, const ::com::sun::star::uno::Sequence< double >& endColor ) throw (::com::sun::star::lang::IllegalArgumentException, ::com::sun::star::uno::RuntimeException);
+        virtual ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XParametricPolyPolygon2D > SAL_CALL createFourCrossingLinesHatch( const ::com::sun::star::uno::Sequence< double >& startColor, const ::com::sun::star::uno::Sequence< double >& endColor ) throw (::com::sun::star::lang::IllegalArgumentException, ::com::sun::star::uno::RuntimeException);
 
         // XServiceInfo
         virtual ::rtl::OUString SAL_CALL getImplementationName(  ) throw (::com::sun::star::uno::RuntimeException);
diff -u -r  comphelper/inc/comphelper/anytostring.hxx  comphelper/inc/comphelper/anytostring.hxx
---  comphelper/inc/comphelper/anytostring.hxx	2004-04-13 18:19:03.000000000 +0530
+++  comphelper/inc/comphelper/anytostring.hxx	2005-02-28 13:41:05.038950534 +0530
@@ -59,8 +59,8 @@
  *
  ************************************************************************/
 
-#if ! defined INCLUDED_ANYTOSTRING_HXX
-#define INCLUDED_ANYTOSTRING_HXX
+#if ! defined(INCLUDED_COMPHELPER_ANYTOSTRING_HXX)
+#define INCLUDED_COMPHELPER_ANYTOSTRING_HXX
 
 #include "rtl/ustring.hxx"
 #include "com/sun/star/uno/Any.hxx"
diff -u -r  comphelper/source/misc/makefile.mk  comphelper/source/misc/makefile.mk
---  comphelper/source/misc/makefile.mk	2004-11-17 19:10:09.000000000 +0530
+++  comphelper/source/misc/makefile.mk	2005-02-28 13:41:05.758866412 +0530
@@ -99,7 +99,8 @@
 			$(SLO)$/anytostring.obj		\
 			$(SLO)$/mediadescriptor.obj \
 			$(SLO)$/locale.obj \
-			$(SLO)$/configurationhelper.obj
+			$(SLO)$/configurationhelper.obj \
+			$(SLO)$/scopeguard.obj
 
 # --- Targets ----------------------------------
 
diff -u -r  cppcanvas/inc/cppcanvas/bitmap.hxx  cppcanvas/inc/cppcanvas/bitmap.hxx
---  cppcanvas/inc/cppcanvas/bitmap.hxx	2004-11-27 02:20:24.000000000 +0530
+++  cppcanvas/inc/cppcanvas/bitmap.hxx	2005-02-28 13:41:04.140055570 +0530
@@ -77,10 +77,10 @@
 #include <cppcanvas/bitmapcanvas.hxx>
 #endif
 
-namespace drafts { namespace com { namespace sun { namespace star { namespace rendering 
+namespace com { namespace sun { namespace star { namespace rendering 
 {
     class  XBitmap;
-} } } } }
+} } } }
 
 
 /* Definition of Bitmap interface */
@@ -114,7 +114,7 @@
         virtual BitmapCanvasSharedPtr		getBitmapCanvas() const = 0;
 
         virtual ::com::sun::star::uno::Reference< 
-            ::drafts::com::sun::star::rendering::XBitmap > 	getUNOBitmap() const = 0;
+            ::com::sun::star::rendering::XBitmap > 	getUNOBitmap() const = 0;
     };
 
     typedef ::boost::shared_ptr< ::cppcanvas::Bitmap > BitmapSharedPtr;
diff -u -r  cppcanvas/inc/cppcanvas/canvas.hxx  cppcanvas/inc/cppcanvas/canvas.hxx
---  cppcanvas/inc/cppcanvas/canvas.hxx	2004-11-27 02:20:53.000000000 +0530
+++  cppcanvas/inc/cppcanvas/canvas.hxx	2005-02-28 13:41:04.160053233 +0530
@@ -88,11 +88,11 @@
     class B2DPolyPolygon;
 }
 
-namespace drafts { namespace com { namespace sun { namespace star { namespace rendering 
+namespace com { namespace sun { namespace star { namespace rendering 
 {
     class  XCanvas;
     struct ViewState;
-} } } } }
+} } } }
 
 
 /* Definition of BitmapCanvas */
@@ -123,7 +123,7 @@
             	actual primitive bounding box, when the canvas
             	performs anti-aliasing.
              */
-            ANTIALIASING_EXTRA_SIZE=2 
+            ANTIALIASING_EXTRA_SIZE=3
     	};
 
         virtual ~Canvas() {}
@@ -143,8 +143,8 @@
         // this should be considered private. if RTTI gets enabled
         // someday, remove that to a separate interface
         virtual ::com::sun::star::uno::Reference< 
-            ::drafts::com::sun::star::rendering::XCanvas > 			getUNOCanvas() const = 0;
-        virtual ::drafts::com::sun::star::rendering::ViewState	 	getViewState() const = 0;
+            ::com::sun::star::rendering::XCanvas > 			getUNOCanvas() const = 0;
+        virtual ::com::sun::star::rendering::ViewState	 	getViewState() const = 0;
     };
 
 }
diff -u -r  cppcanvas/inc/cppcanvas/font.hxx  cppcanvas/inc/cppcanvas/font.hxx
---  cppcanvas/inc/cppcanvas/font.hxx	2004-09-08 22:27:42.000000000 +0530
+++  cppcanvas/inc/cppcanvas/font.hxx	2005-02-28 13:41:04.140055570 +0530
@@ -75,10 +75,10 @@
     class OUString;
 }
 
-namespace drafts { namespace com { namespace sun { namespace star { namespace rendering 
+namespace com { namespace sun { namespace star { namespace rendering 
 {
     class  XCanvasFont;
-} } } } }
+} } } }
 
 /* Definition of Font class */
 
@@ -94,7 +94,7 @@
         virtual double 			getCellSize() const = 0;
 
         virtual ::com::sun::star::uno::Reference< 
-            ::drafts::com::sun::star::rendering::XCanvasFont > getUNOFont() const = 0;
+            ::com::sun::star::rendering::XCanvasFont > getUNOFont() const = 0;
     };
 
     typedef ::boost::shared_ptr< ::cppcanvas::Font > FontSharedPtr;
diff -u -r  cppcanvas/inc/cppcanvas/polypolygon.hxx  cppcanvas/inc/cppcanvas/polypolygon.hxx
---  cppcanvas/inc/cppcanvas/polypolygon.hxx	2004-09-08 22:27:56.000000000 +0530
+++  cppcanvas/inc/cppcanvas/polypolygon.hxx	2005-02-28 13:41:04.149054518 +0530
@@ -80,10 +80,10 @@
     class B2DPolyPolygon;
 }
 
-namespace drafts { namespace com { namespace sun { namespace star { namespace rendering 
+namespace com { namespace sun { namespace star { namespace rendering 
 {
     class  XPolyPolygon2D;
-} } } } }
+} } } }
 
 
 /* Definition of PolyPolygon interface */
@@ -125,7 +125,7 @@
         virtual double 						getStrokeWidth() const = 0;
 
         virtual ::com::sun::star::uno::Reference< 
-            ::drafts::com::sun::star::rendering::XPolyPolygon2D > getUNOPolyPolygon() const = 0;
+            ::com::sun::star::rendering::XPolyPolygon2D > getUNOPolyPolygon() const = 0;
     };
 
     typedef ::boost::shared_ptr< ::cppcanvas::PolyPolygon > PolyPolygonSharedPtr;
diff -u -r  cppcanvas/inc/cppcanvas/spritecanvas.hxx  cppcanvas/inc/cppcanvas/spritecanvas.hxx
---  cppcanvas/inc/cppcanvas/spritecanvas.hxx	2004-11-27 02:22:28.000000000 +0530
+++  cppcanvas/inc/cppcanvas/spritecanvas.hxx	2005-02-28 13:41:04.166052532 +0530
@@ -88,10 +88,10 @@
 #include <cppcanvas/customsprite.hxx>
 #endif
 
-namespace drafts { namespace com { namespace sun { namespace star { namespace rendering 
+namespace com { namespace sun { namespace star { namespace rendering 
 {
     class  XSpriteCanvas;
-} } } } }
+} } } }
 
 
 /* Definition of SpriteCanvas */
@@ -122,7 +122,7 @@
         }
 
         virtual ::com::sun::star::uno::Reference< 
-            ::drafts::com::sun::star::rendering::XSpriteCanvas > 	getUNOSpriteCanvas() const = 0;
+            ::com::sun::star::rendering::XSpriteCanvas > 	getUNOSpriteCanvas() const = 0;
     };
 
 }
diff -u -r  cppcanvas/inc/cppcanvas/sprite.hxx  cppcanvas/inc/cppcanvas/sprite.hxx
---  cppcanvas/inc/cppcanvas/sprite.hxx	2004-11-27 02:22:15.000000000 +0530
+++  cppcanvas/inc/cppcanvas/sprite.hxx	2005-02-28 13:41:04.137055920 +0530
@@ -77,10 +77,10 @@
     class B2DPoint;
 }
 
-namespace drafts { namespace com { namespace sun { namespace star { namespace rendering 
+namespace com { namespace sun { namespace star { namespace rendering 
 {
     class  XSprite;
-} } } } }
+} } } }
 
 
 /* Definition of Sprite class */
@@ -133,7 +133,7 @@
         virtual void hide() = 0;
 
         virtual ::com::sun::star::uno::Reference< 
-            ::drafts::com::sun::star::rendering::XSprite > getUNOSprite() const = 0;
+            ::com::sun::star::rendering::XSprite > getUNOSprite() const = 0;
     };
 
     typedef ::boost::shared_ptr< ::cppcanvas::Sprite > SpriteSharedPtr;
diff -u -r  cppcanvas/inc/cppcanvas/vclfactory.hxx  cppcanvas/inc/cppcanvas/vclfactory.hxx
---  cppcanvas/inc/cppcanvas/vclfactory.hxx	2004-11-27 02:22:49.000000000 +0530
+++  cppcanvas/inc/cppcanvas/vclfactory.hxx	2005-02-28 13:41:04.160053233 +0530
@@ -102,11 +102,11 @@
 {
     class OUString;
 }
-namespace drafts { namespace com { namespace sun { namespace star { namespace rendering 
+namespace com { namespace sun { namespace star { namespace rendering 
 {
     class  XBitmapCanvas;
     class  XSpriteCanvas;
-} } } } }
+} } } }
 
 /* Definition of VCLFactory class */
 
@@ -127,11 +127,11 @@
 
         BitmapCanvasSharedPtr 	createCanvas( const ::Window& rVCLWindow );
         BitmapCanvasSharedPtr 	createCanvas( const ::com::sun::star::uno::Reference< 
-                                              			::drafts::com::sun::star::rendering::XBitmapCanvas >& xCanvas );
+                                              			::com::sun::star::rendering::XBitmapCanvas >& xCanvas );
 
         SpriteCanvasSharedPtr 	createSpriteCanvas( const ::Window& rVCLWindow ) const;
         SpriteCanvasSharedPtr 	createSpriteCanvas( const ::com::sun::star::uno::Reference< 
-                                              				 ::drafts::com::sun::star::rendering::XSpriteCanvas >& xCanvas ) const;
+                                              				 ::com::sun::star::rendering::XSpriteCanvas >& xCanvas ) const;
         SpriteCanvasSharedPtr 	createFullscreenSpriteCanvas( const ::Window& rVCLWindow, const Size& rFullscreenSize ) const;
 
         /** Create a polygon from a tools::Polygon
diff -u -r  cppcanvas/source/inc/canvasgraphichelper.hxx  cppcanvas/source/inc/canvasgraphichelper.hxx
---  cppcanvas/source/inc/canvasgraphichelper.hxx	2004-03-18 16:11:02.000000000 +0530
+++  cppcanvas/source/inc/canvasgraphichelper.hxx	2005-02-28 13:41:04.501013392 +0530
@@ -62,8 +62,8 @@
 #ifndef _CPPCANVAS_CANVASGRAPHICHELPER_HXX
 #define _CPPCANVAS_CANVASGRAPHICHELPER_HXX
 
-#ifndef _DRAFTS_COM_SUN_STAR_RENDERING_RENDERSTATE_HPP__
-#include <drafts/com/sun/star/rendering/RenderState.hpp>
+#ifndef _COM_SUN_STAR_RENDERING_RENDERSTATE_HPP__
+#include <com/sun/star/rendering/RenderState.hpp>
 #endif
 #ifndef _BGFX_POLYGON_B2DPOLYPOLYGON_HXX
 #include <basegfx/polygon/b2dpolypolygon.hxx>
@@ -71,10 +71,10 @@
 
 #include <cppcanvas/canvasgraphic.hxx>
 
-namespace drafts { namespace com { namespace sun { namespace star { namespace rendering 
+namespace com { namespace sun { namespace star { namespace rendering 
 {
     class  XGraphicDevice;
-} } } } }
+} } } }
 
 
 /* Definition of CanvasGraphicHelper class */
@@ -104,14 +104,14 @@
             // for our clients
             // ===============
             CanvasSharedPtr																			getCanvas() const;
-            ::com::sun::star::uno::Reference< ::drafts::com::sun::star::rendering::XGraphicDevice >	getGraphicDevice() const;
+            ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XGraphicDevice >	getGraphicDevice() const;
 
-            mutable ::drafts::com::sun::star::rendering::RenderState 								maRenderState; // for reasons of speed...
+            mutable ::com::sun::star::rendering::RenderState 								maRenderState; // for reasons of speed...
 
         private:
             PolyPolygonSharedPtr																	mpClipPolyPolygon;
             CanvasSharedPtr 																		mpCanvas;
-            ::com::sun::star::uno::Reference< ::drafts::com::sun::star::rendering::XGraphicDevice > mxGraphicDevice;
+            ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XGraphicDevice > mxGraphicDevice;
         };
 
     }
diff -u -r  cppcanvas/source/inc/implrenderer.hxx  cppcanvas/source/inc/implrenderer.hxx
---  cppcanvas/source/inc/implrenderer.hxx	2005-01-28 20:59:56.000000000 +0530
+++  cppcanvas/source/inc/implrenderer.hxx	2005-02-28 13:41:04.492014443 +0530
@@ -145,7 +145,7 @@
                                  bool					bIntersect );
 
             ::com::sun::star::uno::Reference< 
-                ::drafts::com::sun::star::rendering::XCanvasFont > createFont( ::basegfx::B2DHomMatrix& 	o_rFontMatrix,
+                ::com::sun::star::rendering::XCanvasFont > createFont( ::basegfx::B2DHomMatrix& 	o_rFontMatrix,
                                                                                const ::Font& 				rFont,
                                                                                const CanvasSharedPtr&		rCanvas,
                                                                                const ::VirtualDevice&		rVDev,
diff -u -r  cppcanvas/source/inc/tools.hxx  cppcanvas/source/inc/tools.hxx
---  cppcanvas/source/inc/tools.hxx	2004-03-18 16:11:03.000000000 +0530
+++  cppcanvas/source/inc/tools.hxx	2005-02-28 13:41:04.471016897 +0530
@@ -73,10 +73,10 @@
 #include <cppcanvas/color.hxx>
 #endif
 
-namespace drafts { namespace com { namespace sun { namespace star { namespace rendering 
+namespace com { namespace sun { namespace star { namespace rendering 
 {
     class  XGraphicDevice;
-} } } } }
+} } } }
 
 
 namespace cppcanvas
@@ -85,11 +85,11 @@
     {
         ::com::sun::star::uno::Sequence< double > 
         	intSRGBAToDoubleSequence( const ::com::sun::star::uno::Reference< 
-                                      		::drafts::com::sun::star::rendering::XGraphicDevice >&, 
+                                      		::com::sun::star::rendering::XGraphicDevice >&, 
                                       Color::IntSRGBA );
 
         Color::IntSRGBA doubleSequenceToIntSRGBA( const ::com::sun::star::uno::Reference< 
-                                                  		::drafts::com::sun::star::rendering::XGraphicDevice >& 	rDevice, 
+                                                  		::com::sun::star::rendering::XGraphicDevice >& 	rDevice, 
                                                   const ::com::sun::star::uno::Sequence< double >&				rColor 	);
     }
 }
diff -u -r  cppcanvas/source/mtfrenderer/bitmapaction.cxx  cppcanvas/source/mtfrenderer/bitmapaction.cxx
---  cppcanvas/source/mtfrenderer/bitmapaction.cxx	2004-11-27 02:24:03.000000000 +0530
+++  cppcanvas/source/mtfrenderer/bitmapaction.cxx	2005-02-28 13:41:04.685991777 +0530
@@ -65,8 +65,8 @@
 #ifndef _RTL_LOGFILE_HXX_
 #include <rtl/logfile.hxx>
 #endif
-#ifndef _DRAFTS_COM_SUN_STAR_RENDERING_XBITMAP_HPP__
-#include <drafts/com/sun/star/rendering/XBitmap.hpp>
+#ifndef _COM_SUN_STAR_RENDERING_XBITMAP_HPP__
+#include <com/sun/star/rendering/XBitmap.hpp>
 #endif
 
 #ifndef _SV_BITMAPEX_HXX
@@ -94,7 +94,6 @@
 
 
 using namespace ::com::sun::star;
-using namespace ::drafts::com::sun::star;
 
 namespace cppcanvas 
 { 
diff -u -r  cppcanvas/source/mtfrenderer/bitmapaction.hxx  cppcanvas/source/mtfrenderer/bitmapaction.hxx
---  cppcanvas/source/mtfrenderer/bitmapaction.hxx	2004-11-27 02:24:18.000000000 +0530
+++  cppcanvas/source/mtfrenderer/bitmapaction.hxx	2005-02-28 13:41:04.686991660 +0530
@@ -66,8 +66,8 @@
 #include <com/sun/star/uno/Reference.hxx>
 #endif
 
-#ifndef _DRAFTS_COM_SUN_STAR_RENDERING_RENDERSTATE_HPP__
-#include <drafts/com/sun/star/rendering/RenderState.hpp>
+#ifndef _COM_SUN_STAR_RENDERING_RENDERSTATE_HPP__
+#include <com/sun/star/rendering/RenderState.hpp>
 #endif
 
 #include <cppcanvas/canvas.hxx>
@@ -78,10 +78,10 @@
 class BitmapEx;
 class Color;
 
-namespace drafts { namespace com { namespace sun { namespace star { namespace rendering 
+namespace com { namespace sun { namespace star { namespace rendering 
 {
     class 	XBitmap;
-} } } } }
+} } } }
 
 /* Definition of internal::BitmapAction class */
 
@@ -127,9 +127,9 @@
             BitmapAction& operator = ( const BitmapAction& );
 
             ::com::sun::star::uno::Reference<
-                ::drafts::com::sun::star::rendering::XBitmap > 	mxBitmap;
+                ::com::sun::star::rendering::XBitmap > 	mxBitmap;
             CanvasSharedPtr										mpCanvas;
-            ::drafts::com::sun::star::rendering::RenderState	maState;
+            ::com::sun::star::rendering::RenderState	maState;
         };
     } 
 }
diff -u -r  cppcanvas/source/mtfrenderer/implrenderer.cxx  cppcanvas/source/mtfrenderer/implrenderer.cxx
---  cppcanvas/source/mtfrenderer/implrenderer.cxx	2005-02-08 17:01:24.000000000 +0530
+++  cppcanvas/source/mtfrenderer/implrenderer.cxx	2005-02-28 13:41:04.697990375 +0530
@@ -82,14 +82,14 @@
 
 #include <cppcanvas/canvas.hxx>
 
-#ifndef _DRAFTS_COM_SUN_STAR_RENDERING_XGRAPHICDEVICE_HPP_
-#include <drafts/com/sun/star/rendering/XGraphicDevice.hpp>
+#ifndef _COM_SUN_STAR_RENDERING_XGRAPHICDEVICE_HPP_
+#include <com/sun/star/rendering/XGraphicDevice.hpp>
 #endif
-#ifndef _DRAFTS_COM_SUN_STAR_RENDERING_TEXTURINGMODE_HPP_
-#include <drafts/com/sun/star/rendering/TexturingMode.hpp>
+#ifndef _COM_SUN_STAR_RENDERING_TEXTURINGMODE_HPP_
+#include <com/sun/star/rendering/TexturingMode.hpp>
 #endif
-#ifndef _DRAFTS_COM_SUN_STAR_RENDERING_XPARAMETRICPOLYPOLYGON2DFACTORY_HPP_
-#include <drafts/com/sun/star/rendering/XParametricPolyPolygon2DFactory.hpp>
+#ifndef _COM_SUN_STAR_RENDERING_XPARAMETRICPOLYPOLYGON2DFACTORY_HPP_
+#include <com/sun/star/rendering/XParametricPolyPolygon2DFactory.hpp>
 #endif
 
 #ifndef _VCL_CANVASTOOLS_HXX
@@ -135,29 +135,29 @@
 #include <com/sun/star/uno/Sequence.hxx>
 #endif
 
-#ifndef _DRAFTS_COM_SUN_STAR_GEOMETRY_REALPOINT2D_HPP__
-#include <drafts/com/sun/star/geometry/RealPoint2D.hpp>
+#ifndef _COM_SUN_STAR_GEOMETRY_REALPOINT2D_HPP__
+#include <com/sun/star/geometry/RealPoint2D.hpp>
 #endif
-#ifndef _DRAFTS_COM_SUN_STAR_RENDERING_VIEWSTATE_HPP__
-#include <drafts/com/sun/star/rendering/ViewState.hpp>
+#ifndef _COM_SUN_STAR_RENDERING_VIEWSTATE_HPP__
+#include <com/sun/star/rendering/ViewState.hpp>
 #endif
-#ifndef _DRAFTS_COM_SUN_STAR_RENDERING_RENDERSTATE_HPP__
-#include <drafts/com/sun/star/rendering/RenderState.hpp>
+#ifndef _COM_SUN_STAR_RENDERING_RENDERSTATE_HPP__
+#include <com/sun/star/rendering/RenderState.hpp>
 #endif
-#ifndef _DRAFTS_COM_SUN_STAR_RENDERING_XCANVASFONT_HPP__
-#include <drafts/com/sun/star/rendering/XCanvasFont.hpp>
+#ifndef _COM_SUN_STAR_RENDERING_XCANVASFONT_HPP__
+#include <com/sun/star/rendering/XCanvasFont.hpp>
 #endif
-#ifndef _DRAFTS_COM_SUN_STAR_RENDERING_XPOLYPOLYGON2D_HPP__
-#include <drafts/com/sun/star/rendering/XPolyPolygon2D.hpp>
+#ifndef _COM_SUN_STAR_RENDERING_XPOLYPOLYGON2D_HPP__
+#include <com/sun/star/rendering/XPolyPolygon2D.hpp>
 #endif
-#ifndef _DRAFTS_COM_SUN_STAR_RENDERING_XCANVAS_HPP__
-#include <drafts/com/sun/star/rendering/XCanvas.hpp>
+#ifndef _COM_SUN_STAR_RENDERING_XCANVAS_HPP__
+#include <com/sun/star/rendering/XCanvas.hpp>
 #endif
-#ifndef _DRAFTS_COM_SUN_STAR_RENDERING_PATHCAPTYPE_HPP__
-#include <drafts/com/sun/star/rendering/PathCapType.hpp>
+#ifndef _COM_SUN_STAR_RENDERING_PATHCAPTYPE_HPP__
+#include <com/sun/star/rendering/PathCapType.hpp>
 #endif
-#ifndef _DRAFTS_COM_SUN_STAR_RENDERING_PATHJOINTYPE_HPP__
-#include <drafts/com/sun/star/rendering/PathJoinType.hpp>
+#ifndef _COM_SUN_STAR_RENDERING_PATHJOINTYPE_HPP__
+#include <com/sun/star/rendering/PathJoinType.hpp>
 #endif
 
 #ifndef _BGFX_MATRIX_B2DHOMMATRIX_HXX
@@ -190,7 +190,6 @@
 #include <outdevstate.hxx>
 
 
-using namespace ::drafts::com::sun::star;
 using namespace ::com::sun::star;
 
 
@@ -876,12 +875,10 @@
             ENSURE_AND_THROW( nIndex >= 0 && nLength <= rString.Len() + nIndex,
                               "ImplRenderer::createTextWithEffectsAction(): Invalid text index" );
 
-            ::cppcanvas::internal::OutDevState& rState = getState( rStates );
-
             // TODO(F2): implement all text effects
-            if( rState.textAlignment );             // TODO(F2): NYI
+            if( getState( rStates ).textAlignment );             // TODO(F2): NYI
 
-            if( rState.isTextEffectShadowSet )
+            if( getState( rStates ).isTextEffectShadowSet )
             {
                 // calculate relief offset (similar to outdev3.cxx)
                 // TODO(F3): better match with outdev3.cxx
@@ -893,7 +890,7 @@
 
                 // determine shadow color (from outdev3.cxx)
                 ::Color aTextColor = ::vcl::unotools::sequenceToColor(
-                    rCanvas->getUNOCanvas()->getDevice(), rState.textColor );
+                    rCanvas->getUNOCanvas()->getDevice(), getState( rStates ).textColor );
                 bool bIsDark = (aTextColor.GetColor() == COL_BLACK)
                     || (aTextColor.GetLuminance() < 8);
                 ::Color aShadowColor( bIsDark ? COL_LIGHTGRAY : COL_BLACK );
@@ -902,14 +899,14 @@
                 // draw shadow text and restore original rState
                 // TODO(P2): just restore textColor instead of push/pop
                 pushState( rStates, PUSH_ALL );
-                // ::com::sun::star::uno::Sequence< double > origTextColor = rState.textColor;
+                // ::com::sun::star::uno::Sequence< double > origTextColor = getState( rStates ).textColor;
                 getState( rStates ).textColor = ::vcl::unotools::colorToDoubleSequence(
                     rCanvas->getUNOCanvas()->getDevice(), aShadowColor );
                 createTextWithLinesAction(
                     aShadowPoint, rString, nIndex, nLength,
                     pCharWidths, rVDev, rCanvas, rStates, rParms, nCurrActionIndex );
                 popState( rStates );
-                // rState.textColor = origTextColor;
+                // getState( rStates ).textColor = origTextColor;
             }
 
             // draw the normal text
@@ -917,7 +914,7 @@
                 rStartPoint, rString, nIndex, nLength,
                 pCharWidths, rVDev, rCanvas, rStates, rParms, nCurrActionIndex );
 
-            if( rState.textReliefStyle )
+            if( getState( rStates ).textReliefStyle )
             {
                 // calculate relief offset (similar to outdev3.cxx)
                 long nReliefOffset = rVDev.PixelToLogic( Size( 1, 1 ) ).Height();
@@ -925,14 +922,14 @@
                 if( nReliefOffset < 1 )
                     nReliefOffset = 1;
 
-                if( rState.textReliefStyle == RELIEF_ENGRAVED )
+                if( getState( rStates ).textReliefStyle == RELIEF_ENGRAVED )
                     nReliefOffset = -nReliefOffset;
                 Point aReliefPoint( nReliefOffset, nReliefOffset );
                 aReliefPoint += rStartPoint;
 
                 // determine relief color (from outdev3.cxx)
                 ::Color aTextColor = ::vcl::unotools::sequenceToColor(
-                    rCanvas->getUNOCanvas()->getDevice(), rState.textColor );
+                    rCanvas->getUNOCanvas()->getDevice(), getState( rStates ).textColor );
                 ::Color aReliefColor( COL_LIGHTGRAY );
                 if( aTextColor.GetColor() == COL_BLACK )
                     aReliefColor = ::Color( COL_WHITE );
@@ -943,14 +940,14 @@
                 // draw relief text and restore original rState
                 // TODO(P2): just restore textColor instead of push/pop
                 pushState( rStates, PUSH_ALL );
-                // ::com::sun::star::uno::Sequence< double > origTextColor = rState.textColor;
+                // ::com::sun::star::uno::Sequence< double > origTextColor = getState( rStates ).textColor;
                 getState( rStates ).textColor = ::vcl::unotools::colorToDoubleSequence(
                     rCanvas->getUNOCanvas()->getDevice(), aReliefColor );
                 createTextWithLinesAction(
                     aReliefPoint, rString, nIndex, nLength,
                     pCharWidths, rVDev, rCanvas, rStates, rParms, nCurrActionIndex );
                 popState( rStates );
-                // rState.textColor = origTextColor;
+                // getState( rStates ).textColor = origTextColor;
             }
 		}
 
@@ -1058,6 +1055,9 @@
             	int						nCurrActionIndex )
         {
             pushState( rStates, PUSH_ALL );
+
+            // #i42812# Don't hold references into vector, when
+            // modifying it at the same time.
             ::cppcanvas::internal::OutDevState& rState = getState( rStates );
 
             // initialize the color of the text lines
diff -u -r  cppcanvas/source/mtfrenderer/lineaction.cxx  cppcanvas/source/mtfrenderer/lineaction.cxx
---  cppcanvas/source/mtfrenderer/lineaction.cxx	2004-11-27 02:24:46.000000000 +0530
+++  cppcanvas/source/mtfrenderer/lineaction.cxx	2005-02-28 13:41:04.698990258 +0530
@@ -65,8 +65,8 @@
 #ifndef _RTL_LOGFILE_HXX_
 #include <rtl/logfile.hxx>
 #endif
-#ifndef _DRAFTS_COM_SUN_STAR_RENDERING_XCANVAS_HPP_
-#include <drafts/com/sun/star/rendering/XCanvas.hpp>
+#ifndef _COM_SUN_STAR_RENDERING_XCANVAS_HPP_
+#include <com/sun/star/rendering/XCanvas.hpp>
 #endif
 
 #ifndef _SV_GEN_HXX
@@ -89,7 +89,6 @@
 
 
 using namespace ::com::sun::star;
-using namespace ::drafts::com::sun::star;
 
 namespace cppcanvas 
 { 
diff -u -r  cppcanvas/source/mtfrenderer/lineaction.hxx  cppcanvas/source/mtfrenderer/lineaction.hxx
---  cppcanvas/source/mtfrenderer/lineaction.hxx	2004-11-27 02:25:01.000000000 +0530
+++  cppcanvas/source/mtfrenderer/lineaction.hxx	2005-02-28 13:41:04.698990258 +0530
@@ -62,8 +62,8 @@
 #ifndef _CPPCANVAS_LINEACTION_HXX
 #define _CPPCANVAS_LINEACTION_HXX
 
-#ifndef _DRAFTS_COM_SUN_STAR_RENDERING_RENDERSTATE_HPP__
-#include <drafts/com/sun/star/rendering/RenderState.hpp>
+#ifndef _COM_SUN_STAR_RENDERING_RENDERSTATE_HPP__
+#include <com/sun/star/rendering/RenderState.hpp>
 #endif
 
 #ifndef _SV_GEN_HXX
@@ -103,7 +103,7 @@
             Point												maStartPoint;
             Point												maEndPoint;
             CanvasSharedPtr										mpCanvas;
-            ::drafts::com::sun::star::rendering::RenderState	maState;
+            ::com::sun::star::rendering::RenderState	maState;
         };
     } 
 }
diff -u -r  cppcanvas/source/mtfrenderer/mtftools.cxx  cppcanvas/source/mtfrenderer/mtftools.cxx
---  cppcanvas/source/mtfrenderer/mtftools.cxx	2004-11-27 02:25:29.000000000 +0530
+++  cppcanvas/source/mtfrenderer/mtftools.cxx	2005-02-28 13:41:04.712988622 +0530
@@ -62,8 +62,8 @@
 #include <mtftools.hxx>
 #include <outdevstate.hxx>
 
-#ifndef _DRAFTS_COM_SUN_STAR_RENDERING_RENDERSTATE_HPP__
-#include <drafts/com/sun/star/rendering/RenderState.hpp>
+#ifndef _COM_SUN_STAR_RENDERING_RENDERSTATE_HPP__
+#include <com/sun/star/rendering/RenderState.hpp>
 #endif
 
 #ifndef _CANVAS_CANVASTOOLS_HXX
@@ -71,7 +71,6 @@
 #endif
 
 
-using namespace ::drafts::com::sun::star;
 using namespace ::com::sun::star;
 
 namespace cppcanvas
@@ -79,7 +78,7 @@
 
     namespace tools
     {
-        void initRenderState( ::drafts::com::sun::star::rendering::RenderState&	renderState,
+        void initRenderState( ::com::sun::star::rendering::RenderState&	renderState,
                               const struct ::cppcanvas::internal::OutDevState&	outdevState )
         {
             ::canvas::tools::initRenderState( renderState );
diff -u -r  cppcanvas/source/mtfrenderer/mtftools.hxx  cppcanvas/source/mtfrenderer/mtftools.hxx
---  cppcanvas/source/mtfrenderer/mtftools.hxx	2004-03-18 16:11:05.000000000 +0530
+++  cppcanvas/source/mtfrenderer/mtftools.hxx	2005-02-28 13:41:04.712988622 +0530
@@ -66,10 +66,10 @@
 #	include <sal/types.h>
 #endif
 
-namespace drafts { namespace com { namespace sun { namespace star { namespace rendering 
+namespace com { namespace sun { namespace star { namespace rendering 
 {
     struct RenderState;
-} } } } }
+} } } }
 
 
 namespace cppcanvas
@@ -81,7 +81,7 @@
 
     namespace tools
     {
-        void initRenderState( ::drafts::com::sun::star::rendering::RenderState&	renderState,
+        void initRenderState( ::com::sun::star::rendering::RenderState&	renderState,
                               const ::cppcanvas::internal::OutDevState&			outdevState );
     }
 }
diff -u -r  cppcanvas/source/mtfrenderer/outdevstate.hxx  cppcanvas/source/mtfrenderer/outdevstate.hxx
---  cppcanvas/source/mtfrenderer/outdevstate.hxx	2005-01-28 21:00:25.000000000 +0530
+++  cppcanvas/source/mtfrenderer/outdevstate.hxx	2005-02-28 13:41:04.630998203 +0530
@@ -69,20 +69,20 @@
 #include <com/sun/star/uno/Sequence.hxx>
 #endif
 
-#ifndef _DRAFTS_COM_SUN_STAR_RENDERING_STRINGCONTEXT_HPP__
-#include <drafts/com/sun/star/rendering/StringContext.hpp>
+#ifndef _COM_SUN_STAR_RENDERING_STRINGCONTEXT_HPP__
+#include <com/sun/star/rendering/StringContext.hpp>
 #endif
-#ifndef _DRAFTS_COM_SUN_STAR_RENDERING_RENDERSTATE_HPP__
-#include <drafts/com/sun/star/rendering/RenderState.hpp>
+#ifndef _COM_SUN_STAR_RENDERING_RENDERSTATE_HPP__
+#include <com/sun/star/rendering/RenderState.hpp>
 #endif
-#ifndef _DRAFTS_COM_SUN_STAR_RENDERING_XPOLYPOLYGON2D_HPP__
-#include <drafts/com/sun/star/rendering/XPolyPolygon2D.hpp>
+#ifndef _COM_SUN_STAR_RENDERING_XPOLYPOLYGON2D_HPP__
+#include <com/sun/star/rendering/XPolyPolygon2D.hpp>
 #endif
-#ifndef _DRAFTS_COM_SUN_STAR_RENDERING_XCANVASFONT_HPP__
-#include <drafts/com/sun/star/rendering/XCanvasFont.hpp>
+#ifndef _COM_SUN_STAR_RENDERING_XCANVASFONT_HPP__
+#include <com/sun/star/rendering/XCanvasFont.hpp>
 #endif
-#ifndef _DRAFTS_COM_SUN_STAR_RENDERING_TEXTDIRECTION_HPP__
-#include <drafts/com/sun/star/rendering/TextDirection.hpp>
+#ifndef _COM_SUN_STAR_RENDERING_TEXTDIRECTION_HPP__
+#include <com/sun/star/rendering/TextDirection.hpp>
 #endif
 
 #ifndef _BGFX_MATRIX_B2DHOMMATRIX_HXX
@@ -126,7 +126,7 @@
 
                 textEmphasisMarkStyle(EMPHASISMARK_NONE),
                 pushFlags(PUSH_ALL),
-                textDirection(::drafts::com::sun::star::rendering::TextDirection::WEAK_LEFT_TO_RIGHT),
+                textDirection(::com::sun::star::rendering::TextDirection::WEAK_LEFT_TO_RIGHT),
                 textAlignment(0), // TODO(Q2): Synchronize with implrenderer 
                 				  // and possibly new rendering::TextAlignment
                 textReliefStyle(RELIEF_NONE),
@@ -148,7 +148,7 @@
 
             ::basegfx::B2DPolyPolygon																clip;
             ::Rectangle																				clipRect;
-            ::com::sun::star::uno::Reference< ::drafts::com::sun::star::rendering::XPolyPolygon2D > xClipPoly;
+            ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XPolyPolygon2D > 		xClipPoly;
 
             ::com::sun::star::uno::Sequence< double >												lineColor;
             ::com::sun::star::uno::Sequence< double >												fillColor;
@@ -161,7 +161,7 @@
             	@attention Beware, this member can be NULL, and
             	nevertheless text output is generated.
              */
-            ::com::sun::star::uno::Reference< ::drafts::com::sun::star::rendering::XCanvasFont > 	xFont;
+            ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XCanvasFont > 	xFont;
             ::basegfx::B2DHomMatrix																	transform;
             ::basegfx::B2DHomMatrix																	fontTransform;
 
diff -u -r  cppcanvas/source/mtfrenderer/pointaction.cxx  cppcanvas/source/mtfrenderer/pointaction.cxx
---  cppcanvas/source/mtfrenderer/pointaction.cxx	2004-11-27 02:26:08.000000000 +0530
+++  cppcanvas/source/mtfrenderer/pointaction.cxx	2005-02-28 13:41:04.733986169 +0530
@@ -66,8 +66,8 @@
 #ifndef _RTL_LOGFILE_HXX_
 #include <rtl/logfile.hxx>
 #endif
-#ifndef _DRAFTS_COM_SUN_STAR_RENDERING_XCANVAS_HPP_
-#include <drafts/com/sun/star/rendering/XCanvas.hpp>
+#ifndef _COM_SUN_STAR_RENDERING_XCANVAS_HPP_
+#include <com/sun/star/rendering/XCanvas.hpp>
 #endif
 
 #ifndef _SV_GEN_HXX
@@ -88,7 +88,6 @@
 
 
 using namespace ::com::sun::star;
-using namespace ::drafts::com::sun::star;
 
 namespace cppcanvas 
 { 
diff -u -r  cppcanvas/source/mtfrenderer/pointaction.hxx  cppcanvas/source/mtfrenderer/pointaction.hxx
---  cppcanvas/source/mtfrenderer/pointaction.hxx	2004-11-27 02:26:22.000000000 +0530
+++  cppcanvas/source/mtfrenderer/pointaction.hxx	2005-02-28 13:41:04.733986169 +0530
@@ -62,8 +62,8 @@
 #ifndef _CPPCANVAS_POINTACTION_HXX
 #define _CPPCANVAS_POINTACTION_HXX
 
-#ifndef _DRAFTS_COM_SUN_STAR_RENDERING_RENDERSTATE_HPP__
-#include <drafts/com/sun/star/rendering/RenderState.hpp>
+#ifndef _COM_SUN_STAR_RENDERING_RENDERSTATE_HPP__
+#include <com/sun/star/rendering/RenderState.hpp>
 #endif
 
 #ifndef _SV_GEN_HXX
@@ -104,7 +104,7 @@
 
             ::Point												maPoint;
             CanvasSharedPtr										mpCanvas;
-            ::drafts::com::sun::star::rendering::RenderState	maState;
+            ::com::sun::star::rendering::RenderState	maState;
         };
     } 
 }
diff -u -r  cppcanvas/source/mtfrenderer/polypolyaction.cxx  cppcanvas/source/mtfrenderer/polypolyaction.cxx
---  cppcanvas/source/mtfrenderer/polypolyaction.cxx	2004-11-27 02:26:36.000000000 +0530
+++  cppcanvas/source/mtfrenderer/polypolyaction.cxx	2005-02-28 13:41:04.731986403 +0530
@@ -66,11 +66,11 @@
 #include <rtl/logfile.hxx>
 #endif
 
-#ifndef _DRAFTS_COM_SUN_STAR_RENDERING_XCANVAS_HPP_
-#include <drafts/com/sun/star/rendering/XCanvas.hpp>
+#ifndef _COM_SUN_STAR_RENDERING_XCANVAS_HPP_
+#include <com/sun/star/rendering/XCanvas.hpp>
 #endif
-#ifndef _DRAFTS_COM_SUN_STAR_RENDERING_TEXTURINGMODE_HPP_
-#include <drafts/com/sun/star/rendering/TexturingMode.hpp>
+#ifndef _COM_SUN_STAR_RENDERING_TEXTURINGMODE_HPP_
+#include <com/sun/star/rendering/TexturingMode.hpp>
 #endif
 
 #ifndef _SV_GEN_HXX
@@ -91,7 +91,6 @@
 
 
 using namespace ::com::sun::star;
-using namespace ::drafts::com::sun::star;
 
 namespace cppcanvas 
 { 
diff -u -r  cppcanvas/source/mtfrenderer/polypolyaction.hxx  cppcanvas/source/mtfrenderer/polypolyaction.hxx
---  cppcanvas/source/mtfrenderer/polypolyaction.hxx	2004-11-27 02:26:50.000000000 +0530
+++  cppcanvas/source/mtfrenderer/polypolyaction.hxx	2005-02-28 13:41:04.732986286 +0530
@@ -66,15 +66,15 @@
 #include <com/sun/star/uno/Reference.hxx>
 #endif
 
-#ifndef _DRAFTS_COM_SUN_STAR_RENDERING_RENDERSTATE_HPP__
-#include <drafts/com/sun/star/rendering/RenderState.hpp>
+#ifndef _COM_SUN_STAR_RENDERING_RENDERSTATE_HPP__
+#include <com/sun/star/rendering/RenderState.hpp>
 #endif
 
-#ifndef _DRAFTS_COM_SUN_STAR_RENDERING_XPOLYPOLYGON2D_HPP__
-#include <drafts/com/sun/star/rendering/XPolyPolygon2D.hpp>
+#ifndef _COM_SUN_STAR_RENDERING_XPOLYPOLYGON2D_HPP__
+#include <com/sun/star/rendering/XPolyPolygon2D.hpp>
 #endif
-#ifndef _DRAFTS_COM_SUN_STAR_RENDERING_TEXTURE_HPP_
-#include <drafts/com/sun/star/rendering/Texture.hpp>
+#ifndef _COM_SUN_STAR_RENDERING_TEXTURE_HPP_
+#include <com/sun/star/rendering/Texture.hpp>
 #endif
 
 #include <action.hxx>
@@ -106,7 +106,7 @@
             PolyPolyAction( const ::PolyPolygon&,  
                             const CanvasSharedPtr&, 
                             const OutDevState&,
-                            const ::drafts::com::sun::star::rendering::Texture& ); 
+                            const ::com::sun::star::rendering::Texture& ); 
             PolyPolyAction( const ::PolyPolygon&,  
                             const CanvasSharedPtr&, 
                             const OutDevState&,
@@ -126,11 +126,11 @@
             PolyPolyAction& operator = ( const PolyPolyAction& );
 
             ::com::sun::star::uno::Reference<
-                ::drafts::com::sun::star::rendering::XPolyPolygon2D > 	mxPolyPoly;
+                ::com::sun::star::rendering::XPolyPolygon2D > 	mxPolyPoly;
             CanvasSharedPtr												mpCanvas;
-            ::drafts::com::sun::star::rendering::RenderState			maState;
+            ::com::sun::star::rendering::RenderState			maState;
 
-            ::drafts::com::sun::star::rendering::Texture				maTexture;
+            ::com::sun::star::rendering::Texture				maTexture;
             
             ::com::sun::star::uno::Sequence< double >					maFillColor;
             ::com::sun::star::uno::Sequence< double >					maStrokeColor;
diff -u -r  cppcanvas/source/mtfrenderer/textaction.cxx  cppcanvas/source/mtfrenderer/textaction.cxx
---  cppcanvas/source/mtfrenderer/textaction.cxx	2005-01-28 21:00:41.000000000 +0530
+++  cppcanvas/source/mtfrenderer/textaction.cxx	2005-02-28 13:41:04.713988506 +0530
@@ -66,8 +66,8 @@
 #include <rtl/logfile.hxx>
 #endif
 
-#ifndef _DRAFTS_COM_SUN_STAR_RENDERING_XCANVAS_HPP_
-#include <drafts/com/sun/star/rendering/XCanvas.hpp>
+#ifndef _COM_SUN_STAR_RENDERING_XCANVAS_HPP_
+#include <com/sun/star/rendering/XCanvas.hpp>
 #endif
 
 #ifndef _BGFX_MATRIX_B2DHOMMATRIX_HXX
@@ -100,7 +100,6 @@
 #include <mtftools.hxx>
 
 
-using namespace ::drafts::com::sun::star;
 using namespace ::com::sun::star;
 
 namespace cppcanvas
diff -u -r  cppcanvas/source/mtfrenderer/textaction.hxx  cppcanvas/source/mtfrenderer/textaction.hxx
---  cppcanvas/source/mtfrenderer/textaction.hxx	2005-01-28 21:00:58.000000000 +0530
+++  cppcanvas/source/mtfrenderer/textaction.hxx	2005-02-28 13:41:04.731986403 +0530
@@ -66,16 +66,16 @@
 #include <com/sun/star/uno/Sequence.hxx>
 #endif
 
-#ifndef _DRAFTS_COM_SUN_STAR_RENDERING_RENDERSTATE_HPP__
-#include <drafts/com/sun/star/rendering/RenderState.hpp>
+#ifndef _COM_SUN_STAR_RENDERING_RENDERSTATE_HPP__
+#include <com/sun/star/rendering/RenderState.hpp>
 #endif
 
-#ifndef _DRAFTS_COM_SUN_STAR_RENDERING_STRINGCONTEXT_HPP__
-#include <drafts/com/sun/star/rendering/StringContext.hpp>
+#ifndef _COM_SUN_STAR_RENDERING_STRINGCONTEXT_HPP__
+#include <com/sun/star/rendering/StringContext.hpp>
 #endif
 
-#ifndef _DRAFTS_COM_SUN_STAR_RENDERING_TEXTDIRECTION_HPP_
-#include <drafts/com/sun/star/rendering/TextDirection.hpp>
+#ifndef _COM_SUN_STAR_RENDERING_TEXTDIRECTION_HPP_
+#include <com/sun/star/rendering/TextDirection.hpp>
 #endif
 
 #ifndef _COMPHELPER_OPTIONALVALUE_HXX
@@ -90,11 +90,11 @@
 
 class Point;
 
-namespace drafts { namespace com { namespace sun { namespace star { namespace rendering 
+namespace com { namespace sun { namespace star { namespace rendering 
 {
     class  XCanvasFont;
     class  XTextLayout;
-} } } } }
+} } } }
 
 /* Definition of internal::LineAction class */
 
@@ -142,13 +142,13 @@
             // for the translation.
 
             ::com::sun::star::uno::Reference<
-                ::drafts::com::sun::star::rendering::XCanvasFont > 	mxFont;
+                ::com::sun::star::rendering::XCanvasFont > 	mxFont;
             ::com::sun::star::uno::Reference<
-                ::drafts::com::sun::star::rendering::XTextLayout > 	mxTextLayout;
-            ::drafts::com::sun::star::rendering::StringContext		maStringContext;
+                ::com::sun::star::rendering::XTextLayout > 	mxTextLayout;
+            ::com::sun::star::rendering::StringContext		maStringContext;
             ::com::sun::star::uno::Sequence< double > 				maOffsets;
             CanvasSharedPtr											mpCanvas;
-            ::drafts::com::sun::star::rendering::RenderState		maState;
+            ::com::sun::star::rendering::RenderState		maState;
             sal_Int8												maTextDirection;
         };
     } 
diff -u -r  cppcanvas/source/mtfrenderer/transparencygroupaction.cxx  cppcanvas/source/mtfrenderer/transparencygroupaction.cxx
---  cppcanvas/source/mtfrenderer/transparencygroupaction.cxx	2004-11-27 02:27:31.000000000 +0530
+++  cppcanvas/source/mtfrenderer/transparencygroupaction.cxx	2005-02-28 13:41:04.678992595 +0530
@@ -72,8 +72,8 @@
 #include <rtl/logfile.hxx>
 #endif
 
-#ifndef _DRAFTS_COM_SUN_STAR_RENDERING_XBITMAP_HPP__
-#include <drafts/com/sun/star/rendering/XBitmap.hpp>
+#ifndef _COM_SUN_STAR_RENDERING_XBITMAP_HPP__
+#include <com/sun/star/rendering/XBitmap.hpp>
 #endif
 
 #ifndef INCLUDED_RTL_MATH_HXX
@@ -127,7 +127,6 @@
 
 
 using namespace ::com::sun::star;
-using namespace ::drafts::com::sun::star;
 
 namespace cppcanvas 
 { 
diff -u -r  cppcanvas/source/mtfrenderer/transparencygroupaction.hxx  cppcanvas/source/mtfrenderer/transparencygroupaction.hxx
---  cppcanvas/source/mtfrenderer/transparencygroupaction.hxx	2004-11-27 02:27:42.000000000 +0530
+++  cppcanvas/source/mtfrenderer/transparencygroupaction.hxx	2005-02-28 13:41:04.678992595 +0530
@@ -66,8 +66,8 @@
 #include <com/sun/star/uno/Reference.hxx>
 #endif
 
-#ifndef _DRAFTS_COM_SUN_STAR_RENDERING_RENDERSTATE_HPP__
-#include <drafts/com/sun/star/rendering/RenderState.hpp>
+#ifndef _COM_SUN_STAR_RENDERING_RENDERSTATE_HPP__
+#include <com/sun/star/rendering/RenderState.hpp>
 #endif
 
 #include <cppcanvas/canvas.hxx>
@@ -81,10 +81,10 @@
 class GDIMetaFile;
 class Gradient;
 
-namespace drafts { namespace com { namespace sun { namespace star { namespace rendering 
+namespace com { namespace sun { namespace star { namespace rendering 
 {
     class 	XBitmap;
-} } } } }
+} } } }
 
 /* Definition of internal::BitmapAction class */
 
@@ -186,12 +186,12 @@
             const ::Size 										maDstSize;
 
             mutable ::com::sun::star::uno::Reference<
-                ::drafts::com::sun::star::rendering::XBitmap > 	mxBufferBitmap; // contains last rendered version
+                ::com::sun::star::rendering::XBitmap > 	mxBufferBitmap; // contains last rendered version
             mutable ::basegfx::B2DHomMatrix						maLastTransformation; // contains active 
             																		  // transformation for
             																		  // mxBufferBitmap content 
             CanvasSharedPtr										mpCanvas;            
-            ::drafts::com::sun::star::rendering::RenderState	maState;
+            ::com::sun::star::rendering::RenderState	maState;
             const double										mnAlpha;
         };
     } 
diff -u -r  cppcanvas/source/tools/canvasgraphichelper.cxx  cppcanvas/source/tools/canvasgraphichelper.cxx
---  cppcanvas/source/tools/canvasgraphichelper.cxx	2004-11-27 02:27:57.000000000 +0530
+++  cppcanvas/source/tools/canvasgraphichelper.cxx	2005-02-28 13:41:04.562006265 +0530
@@ -61,11 +61,11 @@
 
 #include <canvasgraphichelper.hxx>
 
-#ifndef _DRAFTS_COM_SUN_STAR_RENDERING_XGRAPHICDEVICE_HPP_
-#include <drafts/com/sun/star/rendering/XGraphicDevice.hpp>
+#ifndef _COM_SUN_STAR_RENDERING_XGRAPHICDEVICE_HPP_
+#include <com/sun/star/rendering/XGraphicDevice.hpp>
 #endif
-#ifndef _DRAFTS_COM_SUN_STAR_RENDERING_XPOLYPOLYGON2D_HPP_
-#include <drafts/com/sun/star/rendering/XPolyPolygon2D.hpp>
+#ifndef _COM_SUN_STAR_RENDERING_XPOLYPOLYGON2D_HPP_
+#include <com/sun/star/rendering/XPolyPolygon2D.hpp>
 #endif
 
 #ifndef _CANVAS_CANVASTOOLS_HXX
@@ -83,7 +83,6 @@
 
 
 using namespace ::com::sun::star;
-using namespace ::drafts::com::sun::star;
 
 /* Implementation of CanvasGraphicHelper class */
 
diff -u -r  cppcanvas/source/tools/tools.cxx  cppcanvas/source/tools/tools.cxx
---  cppcanvas/source/tools/tools.cxx	2004-11-27 02:28:21.000000000 +0530
+++  cppcanvas/source/tools/tools.cxx	2005-02-28 13:41:04.521011055 +0530
@@ -63,7 +63,6 @@
 
 
 using namespace ::com::sun::star;
-using namespace ::drafts::com::sun::star;
 
 namespace cppcanvas
 {
diff -u -r  cppcanvas/source/wrapper/basegfxfactory.cxx  cppcanvas/source/wrapper/basegfxfactory.cxx
---  cppcanvas/source/wrapper/basegfxfactory.cxx	2004-11-27 02:28:35.000000000 +0530
+++  cppcanvas/source/wrapper/basegfxfactory.cxx	2005-02-28 13:41:04.797978691 +0530
@@ -69,8 +69,8 @@
 #include <osl/diagnose.h>
 #endif
 
-#ifndef _DRAFTS_COM_SUN_STAR_RENDERING_INTERPOLATIONMODE_HPP_
-#include <drafts/com/sun/star/rendering/InterpolationMode.hpp>
+#ifndef _COM_SUN_STAR_RENDERING_INTERPOLATIONMODE_HPP_
+#include <com/sun/star/rendering/InterpolationMode.hpp>
 #endif
 
 #ifndef _BGFX_POLYGON_B2DPOLYGON_HXX
@@ -90,7 +90,7 @@
 #include <impltext.hxx>
 
 
-using namespace ::drafts::com::sun::star;
+using namespace ::com::sun::star;
 using namespace ::com::sun::star;
 
 namespace cppcanvas
diff -u -r  cppcanvas/source/wrapper/implbitmapcanvas.cxx  cppcanvas/source/wrapper/implbitmapcanvas.cxx
---  cppcanvas/source/wrapper/implbitmapcanvas.cxx	2004-11-27 02:29:16.000000000 +0530
+++  cppcanvas/source/wrapper/implbitmapcanvas.cxx	2005-02-28 13:41:04.798978575 +0530
@@ -59,11 +59,11 @@
  *
  ************************************************************************/
 
-#ifndef _DRAFTS_COM_SUN_STAR_RENDERING_XCANVAS_HPP__
-#include <drafts/com/sun/star/rendering/XCanvas.hpp>
+#ifndef _COM_SUN_STAR_RENDERING_XCANVAS_HPP__
+#include <com/sun/star/rendering/XCanvas.hpp>
 #endif
-#ifndef _DRAFTS_COM_SUN_STAR_RENDERING_XBITMAPCANVAS_HPP__
-#include <drafts/com/sun/star/rendering/XBitmapCanvas.hpp>
+#ifndef _COM_SUN_STAR_RENDERING_XBITMAPCANVAS_HPP__
+#include <com/sun/star/rendering/XBitmapCanvas.hpp>
 #endif
 
 #ifndef _BGFX_MATRIX_B2DHOMMATRIX_HXX
@@ -76,7 +76,7 @@
 #include <implbitmapcanvas.hxx>
 
 
-using namespace ::drafts::com::sun::star;
+using namespace ::com::sun::star;
 using namespace ::com::sun::star;
 
 namespace cppcanvas
diff -u -r  cppcanvas/source/wrapper/implbitmapcanvas.hxx  cppcanvas/source/wrapper/implbitmapcanvas.hxx
---  cppcanvas/source/wrapper/implbitmapcanvas.hxx	2004-11-27 02:29:31.000000000 +0530
+++  cppcanvas/source/wrapper/implbitmapcanvas.hxx	2005-02-28 13:41:04.798978575 +0530
@@ -62,11 +62,11 @@
 #ifndef _CPPCANVAS_IMPLBITMAPCANVAS_HXX
 #define _CPPCANVAS_IMPLBITMAPCANVAS_HXX
 
-#ifndef _DRAFTS_COM_SUN_STAR_RENDERING_XBITMAPCANVAS_HPP__
-#include <drafts/com/sun/star/rendering/XBitmapCanvas.hpp>
+#ifndef _COM_SUN_STAR_RENDERING_XBITMAPCANVAS_HPP__
+#include <com/sun/star/rendering/XBitmapCanvas.hpp>
 #endif
-#ifndef _DRAFTS_COM_SUN_STAR_RENDERING_XBITMAP_HPP__
-#include <drafts/com/sun/star/rendering/XBitmap.hpp>
+#ifndef _COM_SUN_STAR_RENDERING_XBITMAP_HPP__
+#include <com/sun/star/rendering/XBitmap.hpp>
 #endif
 
 #ifndef BOOST_SHARED_PTR_HPP_INCLUDED
@@ -93,7 +93,7 @@
         {
         public:
             ImplBitmapCanvas( const ::com::sun::star::uno::Reference< 
-                              	::drafts::com::sun::star::rendering::XBitmapCanvas >& rCanvas );
+                              	::com::sun::star::rendering::XBitmapCanvas >& rCanvas );
             virtual ~ImplBitmapCanvas();
 
             virtual ::basegfx::B2ISize 		getSize() const;
@@ -107,8 +107,8 @@
             // default: disabled assignment
             ImplBitmapCanvas& operator=( const ImplBitmapCanvas& );
 
-            const ::com::sun::star::uno::Reference< ::drafts::com::sun::star::rendering::XBitmapCanvas > 	mxBitmapCanvas;
-            const ::com::sun::star::uno::Reference< ::drafts::com::sun::star::rendering::XBitmap > 			mxBitmap;
+            const ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XBitmapCanvas > 	mxBitmapCanvas;
+            const ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XBitmap > 			mxBitmap;
         };
     }
 }
diff -u -r  cppcanvas/source/wrapper/implbitmap.cxx  cppcanvas/source/wrapper/implbitmap.cxx
---  cppcanvas/source/wrapper/implbitmap.cxx	2004-11-27 02:28:48.000000000 +0530
+++  cppcanvas/source/wrapper/implbitmap.cxx	2005-02-28 13:41:04.799978458 +0530
@@ -67,7 +67,7 @@
 #endif
 
 
-using namespace ::drafts::com::sun::star;
+using namespace ::com::sun::star;
 using namespace ::com::sun::star;
 
 namespace cppcanvas
@@ -80,11 +80,16 @@
                                 const uno::Reference< rendering::XBitmap >& rBitmap ) :
             CanvasGraphicHelper( rParentCanvas ),
             mxBitmap( rBitmap ),
-            mpBitmapCanvas( 
-                new ImplBitmapCanvas( uno::Reference< rendering::XBitmapCanvas >(rBitmap,
-                                                                                 uno::UNO_QUERY) ) )
+            mpBitmapCanvas()
         {
             OSL_ENSURE( mxBitmap.is(), "ImplBitmap::ImplBitmap: no valid bitmap" );
+
+            uno::Reference< rendering::XBitmapCanvas > xBitmapCanvas( rBitmap,
+                                                                      uno::UNO_QUERY );
+            if( xBitmapCanvas.is() )
+                mpBitmapCanvas.reset( new ImplBitmapCanvas( 
+                                          uno::Reference< rendering::XBitmapCanvas >(rBitmap,
+                                                                                     uno::UNO_QUERY) ) );
         }
 
         ImplBitmap::~ImplBitmap()
diff -u -r  cppcanvas/source/wrapper/implbitmap.hxx  cppcanvas/source/wrapper/implbitmap.hxx
---  cppcanvas/source/wrapper/implbitmap.hxx	2004-11-27 02:29:02.000000000 +0530
+++  cppcanvas/source/wrapper/implbitmap.hxx	2005-02-28 13:41:04.799978458 +0530
@@ -65,11 +65,11 @@
 #ifndef _COM_SUN_STAR_UNO_REFERENCE_HXX_
 #include <com/sun/star/uno/Reference.hxx>
 #endif
-#ifndef _DRAFTS_COM_SUN_STAR_RENDERING_XBITMAP_HPP__
-#include <drafts/com/sun/star/rendering/XBitmap.hpp>
+#ifndef _COM_SUN_STAR_RENDERING_XBITMAP_HPP__
+#include <com/sun/star/rendering/XBitmap.hpp>
 #endif
-#ifndef _DRAFTS_COM_SUN_STAR_RENDERING_XGRAPHICDEVICE_HPP__
-#include <drafts/com/sun/star/rendering/XGraphicDevice.hpp>
+#ifndef _COM_SUN_STAR_RENDERING_XGRAPHICDEVICE_HPP__
+#include <com/sun/star/rendering/XGraphicDevice.hpp>
 #endif
 
 #include <cppcanvas/bitmap.hxx>
@@ -90,7 +90,7 @@
 
             ImplBitmap( const CanvasSharedPtr& rParentCanvas,
                         const ::com::sun::star::uno::Reference< 
-                        	::drafts::com::sun::star::rendering::XBitmap >& rBitmap );
+                        	::com::sun::star::rendering::XBitmap >& rBitmap );
 
             virtual ~ImplBitmap();
 
@@ -102,14 +102,14 @@
 
             // Bitmap implementation
             virtual ::com::sun::star::uno::Reference< 
-                ::drafts::com::sun::star::rendering::XBitmap > 	getUNOBitmap() const;
+                ::com::sun::star::rendering::XBitmap > 	getUNOBitmap() const;
 
         private:
             // default: disabled copy/assignment
             ImplBitmap(const ImplBitmap&);
             ImplBitmap& operator=( const ImplBitmap& );
 
-            const ::com::sun::star::uno::Reference< ::drafts::com::sun::star::rendering::XBitmap > 	mxBitmap;
+            const ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XBitmap > 	mxBitmap;
             BitmapCanvasSharedPtr																	mpBitmapCanvas;
  		};
     }
diff -u -r  cppcanvas/source/wrapper/implcanvas.cxx  cppcanvas/source/wrapper/implcanvas.cxx
---  cppcanvas/source/wrapper/implcanvas.cxx	2004-11-27 02:29:44.000000000 +0530
+++  cppcanvas/source/wrapper/implcanvas.cxx	2005-02-28 13:41:04.801978224 +0530
@@ -71,8 +71,8 @@
 #include <basegfx/polygon/b2dpolypolygon.hxx>
 #endif
 
-#ifndef _DRAFTS_COM_SUN_STAR_RENDERING_XCANVAS_HPP_
-#include <drafts/com/sun/star/rendering/XCanvas.hpp>
+#ifndef _COM_SUN_STAR_RENDERING_XCANVAS_HPP_
+#include <com/sun/star/rendering/XCanvas.hpp>
 #endif
 
 #include <canvas/canvastools.hxx>
@@ -82,7 +82,7 @@
 #include <implcolor.hxx>
 
 
-using namespace ::drafts::com::sun::star;
+using namespace ::com::sun::star;
 using namespace ::com::sun::star;
 
 namespace cppcanvas
diff -u -r  cppcanvas/source/wrapper/implcanvas.hxx  cppcanvas/source/wrapper/implcanvas.hxx
---  cppcanvas/source/wrapper/implcanvas.hxx	2004-11-27 02:29:59.000000000 +0530
+++  cppcanvas/source/wrapper/implcanvas.hxx	2005-02-28 13:41:04.801978224 +0530
@@ -66,8 +66,8 @@
 #include <com/sun/star/uno/Reference.hxx>
 #endif
 
-#ifndef _DRAFTS_COM_SUN_STAR_RENDERING_VIEWSTATE_HPP__
-#include <drafts/com/sun/star/rendering/ViewState.hpp>
+#ifndef _COM_SUN_STAR_RENDERING_VIEWSTATE_HPP__
+#include <com/sun/star/rendering/ViewState.hpp>
 #endif
 
 #ifndef BOOST_SHARED_PTR_HPP_INCLUDED
@@ -87,10 +87,10 @@
     class B2DPolyPolygon;
 }
 
-namespace drafts { namespace com { namespace sun { namespace star { namespace rendering 
+namespace com { namespace sun { namespace star { namespace rendering 
 {
     class  XCanvas;
-} } } } }
+} } } }
 
 
 /* Definition of ImplCanvas */
@@ -105,7 +105,7 @@
         {
         public:
             ImplCanvas( const ::com::sun::star::uno::Reference< 
-                        	::drafts::com::sun::star::rendering::XCanvas >& rCanvas );
+                        	::com::sun::star::rendering::XCanvas >& rCanvas );
             virtual ~ImplCanvas();
 
             virtual void 						setTransformation( const ::basegfx::B2DHomMatrix& rMatrix );
@@ -121,9 +121,9 @@
             virtual CanvasSharedPtr				clone() const;
 
             virtual ::com::sun::star::uno::Reference< 
-                ::drafts::com::sun::star::rendering::XCanvas > 		getUNOCanvas() const;
+                ::com::sun::star::rendering::XCanvas > 		getUNOCanvas() const;
 
-            virtual ::drafts::com::sun::star::rendering::ViewState	getViewState() const;
+            virtual ::com::sun::star::rendering::ViewState	getViewState() const;
 
             // take compiler-provided default copy constructor
             //ImplCanvas(const ImplCanvas&);
@@ -132,9 +132,9 @@
             // default: disabled assignment
             ImplCanvas& operator=( const ImplCanvas& );
 
-            ::drafts::com::sun::star::rendering::ViewState											maViewState;
+            ::com::sun::star::rendering::ViewState											maViewState;
             PolyPolygonSharedPtr																	mpClipPolyPolygon;
-            const ::com::sun::star::uno::Reference< ::drafts::com::sun::star::rendering::XCanvas > 	mxCanvas;
+            const ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XCanvas > 	mxCanvas;
 		};
 
 	}
diff -u -r  cppcanvas/source/wrapper/implcolor.cxx  cppcanvas/source/wrapper/implcolor.cxx
---  cppcanvas/source/wrapper/implcolor.cxx	2004-11-27 02:30:13.000000000 +0530
+++  cppcanvas/source/wrapper/implcolor.cxx	2005-02-28 13:41:04.803977990 +0530
@@ -62,7 +62,7 @@
 #include <implcolor.hxx>
 #include <tools.hxx>
 
-using namespace ::drafts::com::sun::star;
+using namespace ::com::sun::star;
 using namespace ::com::sun::star;
 
 namespace cppcanvas
diff -u -r  cppcanvas/source/wrapper/implcolor.hxx  cppcanvas/source/wrapper/implcolor.hxx
---  cppcanvas/source/wrapper/implcolor.hxx	2004-09-08 22:29:51.000000000 +0530
+++  cppcanvas/source/wrapper/implcolor.hxx	2005-02-28 13:41:04.803977990 +0530
@@ -70,8 +70,8 @@
 #include <boost/shared_ptr.hpp>
 #endif
 
-#ifndef _DRAFTS_COM_SUN_STAR_RENDERING_XGRAPHICDEVICE_HPP__
-#include <drafts/com/sun/star/rendering/XGraphicDevice.hpp>
+#ifndef _COM_SUN_STAR_RENDERING_XGRAPHICDEVICE_HPP__
+#include <com/sun/star/rendering/XGraphicDevice.hpp>
 #endif
 
 #ifndef _CPPCANVAS_COLOR_HXX
@@ -89,14 +89,14 @@
         {
         public:
             ImplColor( const ::com::sun::star::uno::Reference< 
-                       		::drafts::com::sun::star::rendering::XGraphicDevice >& rDevice );
+                       		::com::sun::star::rendering::XGraphicDevice >& rDevice );
             virtual ~ImplColor();
 
             virtual IntSRGBA 									getIntSRGBA( ::com::sun::star::uno::Sequence< double >& rDeviceColor ) const;
             virtual ::com::sun::star::uno::Sequence< double > 	getDeviceColor( IntSRGBA aSRGBA ) const;
 
         private:
-            ::com::sun::star::uno::Reference< ::drafts::com::sun::star::rendering::XGraphicDevice >	mxDevice;
+            ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XGraphicDevice >	mxDevice;
         };
 
     }
diff -u -r  cppcanvas/source/wrapper/implcustomsprite.cxx  cppcanvas/source/wrapper/implcustomsprite.cxx
---  cppcanvas/source/wrapper/implcustomsprite.cxx	2004-11-27 02:30:36.000000000 +0530
+++  cppcanvas/source/wrapper/implcustomsprite.cxx	2005-02-28 13:41:04.802978107 +0530
@@ -63,7 +63,7 @@
 #include <implcanvas.hxx>
 
 using namespace ::com::sun::star;
-using namespace ::drafts::com::sun::star;
+using namespace ::com::sun::star;
 
 namespace cppcanvas
 {
diff -u -r  cppcanvas/source/wrapper/implcustomsprite.hxx  cppcanvas/source/wrapper/implcustomsprite.hxx
---  cppcanvas/source/wrapper/implcustomsprite.hxx	2004-11-27 02:30:55.000000000 +0530
+++  cppcanvas/source/wrapper/implcustomsprite.hxx	2005-02-28 13:41:04.802978107 +0530
@@ -90,9 +90,9 @@
         {
         public:
             ImplCustomSprite( const ::com::sun::star::uno::Reference< 
-                              		::drafts::com::sun::star::rendering::XSpriteCanvas >& 	rParentCanvas,
+                              		::com::sun::star::rendering::XSpriteCanvas >& 	rParentCanvas,
                               const ::com::sun::star::uno::Reference< 
-                              		::drafts::com::sun::star::rendering::XCustomSprite >& 	rSprite,
+                              		::com::sun::star::rendering::XCustomSprite >& 	rSprite,
                               const ImplSpriteCanvas::TransformationArbiterSharedPtr&		rTransformArbiter );
             virtual ~ImplCustomSprite();
 
@@ -104,7 +104,7 @@
             ImplCustomSprite& operator=( const ImplCustomSprite& );
 
             mutable CanvasSharedPtr																			mpLastCanvas;
-            const ::com::sun::star::uno::Reference< ::drafts::com::sun::star::rendering::XCustomSprite > 	mxCustomSprite;
+            const ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XCustomSprite > 	mxCustomSprite;
         };
     }
 }
diff -u -r  cppcanvas/source/wrapper/implfont.cxx  cppcanvas/source/wrapper/implfont.cxx
---  cppcanvas/source/wrapper/implfont.cxx	2004-11-27 02:31:11.000000000 +0530
+++  cppcanvas/source/wrapper/implfont.cxx	2005-02-28 13:41:04.805977757 +0530
@@ -63,7 +63,7 @@
 #include <canvas/canvastools.hxx>
 
 
-using namespace ::drafts::com::sun::star;
+using namespace ::com::sun::star;
 using namespace ::com::sun::star;
 
 /* Definition of Font class */
diff -u -r  cppcanvas/source/wrapper/implfont.hxx  cppcanvas/source/wrapper/implfont.hxx
---  cppcanvas/source/wrapper/implfont.hxx	2004-09-08 22:30:16.000000000 +0530
+++  cppcanvas/source/wrapper/implfont.hxx	2005-02-28 13:41:04.805977757 +0530
@@ -70,8 +70,8 @@
 #include <boost/shared_ptr.hpp>
 #endif
 
-#ifndef _DRAFTS_COM_SUN_STAR_RENDERING_XCANVAS_HPP__
-#include <drafts/com/sun/star/rendering/XCanvas.hpp>
+#ifndef _COM_SUN_STAR_RENDERING_XCANVAS_HPP__
+#include <com/sun/star/rendering/XCanvas.hpp>
 #endif
 
 #ifndef _CPPCANVAS_FONT_HXX
@@ -83,10 +83,10 @@
     class OUString;
 }
 
-namespace drafts { namespace com { namespace sun { namespace star { namespace rendering 
+namespace com { namespace sun { namespace star { namespace rendering 
 {
     class  XCanvasFont;
-} } } } }
+} } } }
 
 /* Definition of Font class */
 
@@ -100,7 +100,7 @@
         {
         public:
             ImplFont( const ::com::sun::star::uno::Reference< 
-                      	::drafts::com::sun::star::rendering::XCanvas >& rCanvas,
+                      	::com::sun::star::rendering::XCanvas >& rCanvas,
                       const ::rtl::OUString& rFontName, 
                       const double& rCellSize );
 
@@ -110,11 +110,11 @@
             virtual double 			getCellSize() const;
 
             virtual ::com::sun::star::uno::Reference< 
-                ::drafts::com::sun::star::rendering::XCanvasFont > getUNOFont() const;
+                ::com::sun::star::rendering::XCanvasFont > getUNOFont() const;
 
         private:
-            ::com::sun::star::uno::Reference< ::drafts::com::sun::star::rendering::XCanvas >		mxCanvas;
-            ::com::sun::star::uno::Reference< ::drafts::com::sun::star::rendering::XCanvasFont >	mxFont;
+            ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XCanvas >		mxCanvas;
+            ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XCanvasFont >	mxFont;
 		};
 	}
 }
diff -u -r  cppcanvas/source/wrapper/implpolypolygon.cxx  cppcanvas/source/wrapper/implpolypolygon.cxx
---  cppcanvas/source/wrapper/implpolypolygon.cxx	2004-11-27 02:31:35.000000000 +0530
+++  cppcanvas/source/wrapper/implpolypolygon.cxx	2005-02-28 13:41:04.807977523 +0530
@@ -63,11 +63,11 @@
 #include <rtl/math.hxx>
 #endif
 
-#ifndef _DRAFTS_COM_SUN_STAR_RENDERING_PATHJOINTYPE_HPP_
-#include <drafts/com/sun/star/rendering/PathJoinType.hpp>
+#ifndef _COM_SUN_STAR_RENDERING_PATHJOINTYPE_HPP_
+#include <com/sun/star/rendering/PathJoinType.hpp>
 #endif
-#ifndef _DRAFTS_COM_SUN_STAR_RENDERING_PATHCAPTYPE_HPP_
-#include <drafts/com/sun/star/rendering/PathCapType.hpp>
+#ifndef _COM_SUN_STAR_RENDERING_PATHCAPTYPE_HPP_
+#include <com/sun/star/rendering/PathCapType.hpp>
 #endif
 
 #ifndef _BGFX_MATRIX_B2DHOMMATRIX_HXX
@@ -81,7 +81,7 @@
 #include <tools.hxx>
 
 
-using namespace ::drafts::com::sun::star;
+using namespace ::com::sun::star;
 using namespace ::com::sun::star;
 
 
diff -u -r  cppcanvas/source/wrapper/implpolypolygon.hxx  cppcanvas/source/wrapper/implpolypolygon.hxx
---  cppcanvas/source/wrapper/implpolypolygon.hxx	2004-11-27 02:31:47.000000000 +0530
+++  cppcanvas/source/wrapper/implpolypolygon.hxx	2005-02-28 13:41:04.807977523 +0530
@@ -65,23 +65,23 @@
 #ifndef _COM_SUN_STAR_UNO_REFERENCE_HXX_
 #include <com/sun/star/uno/Reference.hxx>
 #endif
-#ifndef _DRAFTS_COM_SUN_STAR_RENDERING_XPOLYPOLYGON2D_HPP__
-#include <drafts/com/sun/star/rendering/XPolyPolygon2D.hpp>
+#ifndef _COM_SUN_STAR_RENDERING_XPOLYPOLYGON2D_HPP__
+#include <com/sun/star/rendering/XPolyPolygon2D.hpp>
 #endif
-#ifndef _DRAFTS_COM_SUN_STAR_RENDERING_XGRAPHICDEVICE_HPP__
-#include <drafts/com/sun/star/rendering/XGraphicDevice.hpp>
+#ifndef _COM_SUN_STAR_RENDERING_XGRAPHICDEVICE_HPP__
+#include <com/sun/star/rendering/XGraphicDevice.hpp>
 #endif
-#ifndef _DRAFTS_COM_SUN_STAR_RENDERING_STROKEATTRIBUTES_HPP__
-#include <drafts/com/sun/star/rendering/StrokeAttributes.hpp>
+#ifndef _COM_SUN_STAR_RENDERING_STROKEATTRIBUTES_HPP__
+#include <com/sun/star/rendering/StrokeAttributes.hpp>
 #endif
 
 #include <cppcanvas/polypolygon.hxx>
 #include <canvasgraphichelper.hxx>
 
-namespace drafts { namespace com { namespace sun { namespace star { namespace rendering 
+namespace com { namespace sun { namespace star { namespace rendering 
 {
     struct RealPoint2D;
-} } } } }
+} } } }
 
 
 namespace cppcanvas
@@ -94,7 +94,7 @@
         public:
             ImplPolyPolygon( const CanvasSharedPtr& rParentCanvas,
                              const ::com::sun::star::uno::Reference< 
-                             	::drafts::com::sun::star::rendering::XPolyPolygon2D >& rPolyPoly );
+                             	::com::sun::star::rendering::XPolyPolygon2D >& rPolyPoly );
 
             virtual ~ImplPolyPolygon();
 
@@ -112,16 +112,16 @@
             virtual bool 			draw() const;
 
             virtual ::com::sun::star::uno::Reference< 
-                ::drafts::com::sun::star::rendering::XPolyPolygon2D > getUNOPolyPolygon() const;
+                ::com::sun::star::rendering::XPolyPolygon2D > getUNOPolyPolygon() const;
 
         private:
             // default: disabled copy/assignment
             ImplPolyPolygon(const ImplPolyPolygon&);
             ImplPolyPolygon& operator= ( const ImplPolyPolygon& );
         
-            const ::com::sun::star::uno::Reference< ::drafts::com::sun::star::rendering::XPolyPolygon2D > 	mxPolyPoly;
+            const ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XPolyPolygon2D > 	mxPolyPoly;
 
-            ::drafts::com::sun::star::rendering::StrokeAttributes											maStrokeAttributes;
+            ::com::sun::star::rendering::StrokeAttributes											maStrokeAttributes;
 
             ::com::sun::star::uno::Sequence< double > 														maFillColor;
             ::com::sun::star::uno::Sequence< double > 														maStrokeColor;
diff -u -r  cppcanvas/source/wrapper/implspritecanvas.cxx  cppcanvas/source/wrapper/implspritecanvas.cxx
---  cppcanvas/source/wrapper/implspritecanvas.cxx	2004-11-27 02:32:29.000000000 +0530
+++  cppcanvas/source/wrapper/implspritecanvas.cxx	2005-02-28 13:41:04.800978341 +0530
@@ -66,15 +66,15 @@
 #include <basegfx/tools/canvastools.hxx>
 #endif
 
-#ifndef _DRAFTS_COM_SUN_STAR_RENDERING_INTERPOLATIONMODE_HPP_
-#include <drafts/com/sun/star/rendering/InterpolationMode.hpp>
+#ifndef _COM_SUN_STAR_RENDERING_INTERPOLATIONMODE_HPP_
+#include <com/sun/star/rendering/InterpolationMode.hpp>
 #endif
 
 #include <implspritecanvas.hxx>
 #include <implcustomsprite.hxx>
 
 
-using namespace ::drafts::com::sun::star;
+using namespace ::com::sun::star;
 using namespace ::com::sun::star;
 
 namespace cppcanvas
diff -u -r  cppcanvas/source/wrapper/implspritecanvas.hxx  cppcanvas/source/wrapper/implspritecanvas.hxx
---  cppcanvas/source/wrapper/implspritecanvas.hxx	2004-11-27 02:32:43.000000000 +0530
+++  cppcanvas/source/wrapper/implspritecanvas.hxx	2005-02-28 13:41:04.800978341 +0530
@@ -62,8 +62,8 @@
 #ifndef _CPPCANVAS_IMPLSPRITECANVAS_HXX
 #define _CPPCANVAS_IMPLSPRITECANVAS_HXX
 
-#ifndef _DRAFTS_COM_SUN_STAR_RENDERING_XSPRITECANVAS_HPP__
-#include <drafts/com/sun/star/rendering/XSpriteCanvas.hpp>
+#ifndef _COM_SUN_STAR_RENDERING_XSPRITECANVAS_HPP__
+#include <com/sun/star/rendering/XSpriteCanvas.hpp>
 #endif
 
 #ifndef _BGFX_VECTOR_B2DSIZE_HXX
@@ -93,7 +93,7 @@
         {
         public:
             ImplSpriteCanvas( const ::com::sun::star::uno::Reference< 
-                              	::drafts::com::sun::star::rendering::XSpriteCanvas >& rCanvas );
+                              	::com::sun::star::rendering::XSpriteCanvas >& rCanvas );
             ImplSpriteCanvas(const ImplSpriteCanvas&);
 
             virtual ~ImplSpriteCanvas();
@@ -108,13 +108,13 @@
             SpriteSharedPtr					createSpriteFromBitmaps( 
                 const ::com::sun::star::uno::Sequence< 
                 	::com::sun::star::uno::Reference< 
-                		::drafts::com::sun::star::rendering::XBitmap > >& 	animationBitmaps, 
+                		::com::sun::star::rendering::XBitmap > >& 	animationBitmaps, 
                 sal_Int8 													interpolationMode );
 
             virtual CanvasSharedPtr			clone() const;
 
             virtual ::com::sun::star::uno::Reference< 
-                ::drafts::com::sun::star::rendering::XSpriteCanvas > 	getUNOSpriteCanvas() const;
+                ::com::sun::star::rendering::XSpriteCanvas > 	getUNOSpriteCanvas() const;
 
             /** This class passes the view transformation
                 to child sprites
@@ -142,7 +142,7 @@
             // default: disabled assignment
             ImplSpriteCanvas& operator=( const ImplSpriteCanvas& );
 
-            const ::com::sun::star::uno::Reference< ::drafts::com::sun::star::rendering::XSpriteCanvas > 	mxSpriteCanvas;
+            const ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XSpriteCanvas > 	mxSpriteCanvas;
             TransformationArbiterSharedPtr																	mpTransformArbiter;
         };
     }
diff -u -r  cppcanvas/source/wrapper/implsprite.cxx  cppcanvas/source/wrapper/implsprite.cxx
---  cppcanvas/source/wrapper/implsprite.cxx	2004-11-27 02:32:02.000000000 +0530
+++  cppcanvas/source/wrapper/implsprite.cxx	2005-02-28 13:41:04.796978808 +0530
@@ -59,11 +59,11 @@
  *
  ************************************************************************/
 
-#ifndef _DRAFTS_COM_SUN_STAR_RENDERING_XSPRITE_HPP_
-#include <drafts/com/sun/star/rendering/XSprite.hpp>
+#ifndef _COM_SUN_STAR_RENDERING_XSPRITE_HPP_
+#include <com/sun/star/rendering/XSprite.hpp>
 #endif
-#ifndef _DRAFTS_COM_SUN_STAR_RENDERING_XANIMATEDSPRITE_HPP_
-#include <drafts/com/sun/star/rendering/XAnimatedSprite.hpp>
+#ifndef _COM_SUN_STAR_RENDERING_XANIMATEDSPRITE_HPP_
+#include <com/sun/star/rendering/XAnimatedSprite.hpp>
 #endif
 
 #ifndef _BGFX_TOOLS_CANVASTOOLS_HXX
@@ -80,7 +80,7 @@
 #include <implsprite.hxx>
 
 
-using namespace ::drafts::com::sun::star;
+using namespace ::com::sun::star;
 using namespace ::com::sun::star;
 
 namespace cppcanvas
diff -u -r  cppcanvas/source/wrapper/implsprite.hxx  cppcanvas/source/wrapper/implsprite.hxx
---  cppcanvas/source/wrapper/implsprite.hxx	2004-11-27 02:32:15.000000000 +0530
+++  cppcanvas/source/wrapper/implsprite.hxx	2005-02-28 13:41:04.796978808 +0530
@@ -65,11 +65,11 @@
 #ifndef _COM_SUN_STAR_UNO_REFERENCE_HXX_
 #include <com/sun/star/uno/Reference.hxx>
 #endif
-#ifndef _DRAFTS_COM_SUN_STAR_RENDERING_XSPRITECANVAS_HPP_
-#include <drafts/com/sun/star/rendering/XSpriteCanvas.hpp>
+#ifndef _COM_SUN_STAR_RENDERING_XSPRITECANVAS_HPP_
+#include <com/sun/star/rendering/XSpriteCanvas.hpp>
 #endif
-#ifndef _DRAFTS_COM_SUN_STAR_RENDERING_XSPRITE_HPP_
-#include <drafts/com/sun/star/rendering/XSprites.hpp>
+#ifndef _COM_SUN_STAR_RENDERING_XSPRITE_HPP_
+#include <com.sun.star.rendering.XSprites.hpp>
 #endif
 
 #ifndef BOOST_SHARED_PTR_HPP_INCLUDED
@@ -91,14 +91,14 @@
         {
         public:
             ImplSprite( const ::com::sun::star::uno::Reference< 
-                              	::drafts::com::sun::star::rendering::XSpriteCanvas >& 	rParentCanvas,
+                              	::com::sun::star::rendering::XSpriteCanvas >& 	rParentCanvas,
                         const ::com::sun::star::uno::Reference< 
-                              	::drafts::com::sun::star::rendering::XSprite >& 		rSprite,
+                              	::com::sun::star::rendering::XSprite >& 		rSprite,
                         const ImplSpriteCanvas::TransformationArbiterSharedPtr&			rTransformArbiter );
             ImplSprite( const ::com::sun::star::uno::Reference< 
-                              	::drafts::com::sun::star::rendering::XSpriteCanvas >& 	rParentCanvas,
+                              	::com::sun::star::rendering::XSpriteCanvas >& 	rParentCanvas,
                         const ::com::sun::star::uno::Reference< 
-                              	::drafts::com::sun::star::rendering::XAnimatedSprite >& rSprite,
+                              	::com::sun::star::rendering::XAnimatedSprite >& rSprite,
                         const ImplSpriteCanvas::TransformationArbiterSharedPtr&			rTransformArbiter );
             virtual ~ImplSprite();
 
@@ -113,10 +113,10 @@
             virtual void hide();
 
             virtual ::com::sun::star::uno::Reference< 
-                ::drafts::com::sun::star::rendering::XSprite > 	getUNOSprite() const;
+                ::com::sun::star::rendering::XSprite > 	getUNOSprite() const;
 
             ::com::sun::star::uno::Reference< 
-				::drafts::com::sun::star::rendering::XGraphicDevice >
+				::com::sun::star::rendering::XGraphicDevice >
 													            getGraphicDevice() const;
 
         private:
@@ -124,9 +124,9 @@
             ImplSprite(const ImplSprite&);
             ImplSprite& operator=( const ImplSprite& );
 
-            ::com::sun::star::uno::Reference< ::drafts::com::sun::star::rendering::XGraphicDevice > 		mxGraphicDevice;
-            const ::com::sun::star::uno::Reference< ::drafts::com::sun::star::rendering::XSprite > 			mxSprite;
-            const ::com::sun::star::uno::Reference< ::drafts::com::sun::star::rendering::XAnimatedSprite > 	mxAnimatedSprite;
+            ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XGraphicDevice > 		mxGraphicDevice;
+            const ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XSprite > 			mxSprite;
+            const ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XAnimatedSprite > 	mxAnimatedSprite;
             ImplSpriteCanvas::TransformationArbiterSharedPtr												mpTransformArbiter;
 		};
 	}
diff -u -r  cppcanvas/source/wrapper/impltext.cxx  cppcanvas/source/wrapper/impltext.cxx
---  cppcanvas/source/wrapper/impltext.cxx	2004-11-27 02:32:57.000000000 +0530
+++  cppcanvas/source/wrapper/impltext.cxx	2005-02-28 13:41:04.807977523 +0530
@@ -62,14 +62,14 @@
 #include <impltext.hxx>
 #include <canvas/canvastools.hxx>
 
-#ifndef _DRAFTS_COM_SUN_STAR_RENDERING_TEXTDIRECTION_HPP__
-#include <drafts/com/sun/star/rendering/TextDirection.hpp>
+#ifndef _COM_SUN_STAR_RENDERING_TEXTDIRECTION_HPP__
+#include <com/sun/star/rendering/TextDirection.hpp>
 #endif
-#ifndef _DRAFTS_COM_SUN_STAR_RENDERING_XCANVAS_HPP__
-#include <drafts/com/sun/star/rendering/XCanvas.hpp>
+#ifndef _COM_SUN_STAR_RENDERING_XCANVAS_HPP__
+#include <com/sun/star/rendering/XCanvas.hpp>
 #endif
-#ifndef _DRAFTS_COM_SUN_STAR_RENDERING_STRINGCONTEXT_HPP__
-#include <drafts/com/sun/star/rendering/StringContext.hpp>
+#ifndef _COM_SUN_STAR_RENDERING_STRINGCONTEXT_HPP__
+#include <com/sun/star/rendering/StringContext.hpp>
 #endif
 
 #ifndef _RTL_USTRING_HXX_
@@ -81,7 +81,7 @@
 #endif
 
 
-using namespace ::drafts::com::sun::star;
+using namespace ::com::sun::star;
 using namespace ::com::sun::star;
 
 namespace cppcanvas
diff -u -r  cppcanvas/source/wrapper/impltext.hxx  cppcanvas/source/wrapper/impltext.hxx
---  cppcanvas/source/wrapper/impltext.hxx	2004-11-27 02:33:10.000000000 +0530
+++  cppcanvas/source/wrapper/impltext.hxx	2005-02-28 13:41:04.808977406 +0530
@@ -62,17 +62,17 @@
 #ifndef _CANVAS_IMPLTEXT_HXX
 #define _CANVAS_IMPLTEXT_HXX
 
-#ifndef _DRAFTS_COM_SUN_STAR_RENDERING_RENDERSTATE_HPP__
-#include <drafts/com/sun/star/rendering/RenderState.hpp>
+#ifndef _COM_SUN_STAR_RENDERING_RENDERSTATE_HPP__
+#include <com/sun/star/rendering/RenderState.hpp>
 #endif
-#ifndef _DRAFTS_COM_SUN_STAR_RENDERING_STRINGCONTEXT_HPP__
-#include <drafts/com/sun/star/rendering/StringContext.hpp>
+#ifndef _COM_SUN_STAR_RENDERING_STRINGCONTEXT_HPP__
+#include <com/sun/star/rendering/StringContext.hpp>
 #endif
-#ifndef _DRAFTS_COM_SUN_STAR_RENDERING_XCANVAS_HPP__
-#include <drafts/com/sun/star/rendering/XCanvas.hpp>
+#ifndef _COM_SUN_STAR_RENDERING_XCANVAS_HPP__
+#include <com/sun/star/rendering/XCanvas.hpp>
 #endif
-#ifndef _DRAFTS_COM_SUN_STAR_RENDERING_XCANVASFONT_HPP__
-#include <drafts/com/sun/star/rendering/XCanvasFont.hpp>
+#ifndef _COM_SUN_STAR_RENDERING_XCANVASFONT_HPP__
+#include <com/sun/star/rendering/XCanvasFont.hpp>
 #endif
 
 #include <cppcanvas/text.hxx>
diff -u -r  cppcanvas/source/wrapper/vclfactory.cxx  cppcanvas/source/wrapper/vclfactory.cxx
---  cppcanvas/source/wrapper/vclfactory.cxx	2004-11-27 02:33:34.000000000 +0530
+++  cppcanvas/source/wrapper/vclfactory.cxx	2005-02-28 13:41:04.804977874 +0530
@@ -69,8 +69,8 @@
 #include <osl/diagnose.h>
 #endif
 
-#ifndef _DRAFTS_COM_SUN_STAR_RENDERING_INTERPOLATIONMODE_HPP_
-#include <drafts/com/sun/star/rendering/InterpolationMode.hpp>
+#ifndef _COM_SUN_STAR_RENDERING_INTERPOLATIONMODE_HPP_
+#include <com/sun/star/rendering/InterpolationMode.hpp>
 #endif
 
 #ifndef _SV_WINDOW_HXX
@@ -94,7 +94,7 @@
 #include <implsprite.hxx>
 
 
-using namespace ::drafts::com::sun::star;
+using namespace ::com::sun::star;
 using namespace ::com::sun::star;
 
 namespace cppcanvas
diff -u -r  offapi/com/sun/star/drawing/makefile.mk  offapi/com/sun/star/drawing/makefile.mk
---  offapi/com/sun/star/drawing/makefile.mk	2004-05-19 16:10:02.000000000 +0530
+++  offapi/com/sun/star/drawing/makefile.mk	2005-02-28 13:41:26.382456637 +0530
@@ -226,7 +226,26 @@
 	XShapeGrouper.idl\
 	XShapeMirror.idl\
 	XShapes.idl\
-	XUniversalShapeDescriptor.idl
+	XUniversalShapeDescriptor.idl\
+\
+    XCustomShapeHandle.idl                          \
+    XCustomShapeEngine.idl                          \
+    CustomShapeEngine.idl                           \
+    CustomShape.idl                                 \
+    EnhancedCustomShapeTextPathMode.idl             \
+    EnhancedCustomShapeGluePointType.idl            \
+    EnhancedCustomShapeParameterType.idl            \
+    EnhancedCustomShapeParameter.idl                \
+    EnhancedCustomShapeSegmentCommand.idl           \
+    EnhancedCustomShapeSegment.idl                  \
+    EnhancedCustomShapeParameterPair.idl            \
+    EnhancedCustomShapeTextFrame.idl                \
+    EnhancedCustomShapeAdjustmentValue.idl          \
+    EnhancedCustomShapeGeometry.idl                 \
+    EnhancedCustomShapeExtrusion.idl                \
+    EnhancedCustomShapePath.idl                     \
+    EnhancedCustomShapeTextPath.idl                 \
+    EnhancedCustomShapeHandle.idl
 
 # ------------------------------------------------------------------
 
diff -u -r  offapi/com/sun/star/xml/dom/events/XMutationEvent.idl  offapi/com/sun/star/xml/dom/events/XMutationEvent.idl
---  offapi/com/sun/star/xml/dom/events/XMutationEvent.idl	2004-03-08 19:38:38.000000000 +0530
+++  offapi/com/sun/star/xml/dom/events/XMutationEvent.idl	2005-02-28 13:41:11.850154657 +0530
@@ -91,4 +91,4 @@
 };
 }; }; }; }; }; };
 
-#endif
\ No newline at end of file
+#endif
diff -u -r  offapi/prj/build.lst  offapi/prj/build.lst
---  offapi/prj/build.lst	2005-01-18 20:46:25.000000000 +0530
+++  offapi/prj/build.lst	2005-02-28 13:41:30.184012458 +0530
@@ -83,9 +83,9 @@
 oa	offapi\com\sun\star\xml\crypto     	    nmake	-	all	oa_crypto oa_wrapper oa_security NULL
 oa	offapi\com\sun\star\xml\csax     	    nmake	-	all	oa_csax oa_sax NULL
 oa	offapi\com\sun\star\xml\wrapper		    nmake	-	all	oa_wrapper oa_sax NULL
-oa	offapi\drafts\com\sun\star\geometry		nmake	-	all	oa_geometry NULL
-oa	offapi\drafts\com\sun\star\rendering	nmake	-	all oa_rendering oa_geometry NULL
-oa	offapi\drafts\com\sun\star\drawing		nmake	-	all	oa_draftdraw NULL
+oa	offapi\com\sun\star\geometry		    nmake	-	all	oa_geometry NULL
+oa	offapi\com\sun\star\rendering	        nmake	-	all oa_rendering oa_geometry NULL
+oa	offapi\com\sun\star\drawing		        nmake	-	all	oa_draftdraw NULL
 oa	offapi\drafts\com\sun\star\form         nmake	-	all	oa_drafts_form NULL
 oa  offapi\drafts\com\sun\star\ui           nmake   -   all oa_drafts_ui NULL
 oa  offapi\drafts\com\sun\star\frame        nmake   -   all oa_drafts_frame NULL
diff -u -r  offapi/prj/d.lst  offapi/prj/d.lst
---  offapi/prj/d.lst	2005-01-27 21:03:43.000000000 +0530
+++  offapi/prj/d.lst	2005-02-28 13:41:30.172013860 +0530
@@ -3,12 +3,9 @@
 mkdir: %COMMON_DEST%\idl%_EXT%\drafts\com\sun
 mkdir: %COMMON_DEST%\idl%_EXT%\drafts\com\sun\star
 mkdir: %COMMON_DEST%\idl%_EXT%\drafts\com\sun\star\sync
-mkdir: %COMMON_DEST%\idl%_EXT%\drafts\com\sun\star\geometry
-mkdir: %COMMON_DEST%\idl%_EXT%\drafts\com\sun\star\rendering
 mkdir: %COMMON_DEST%\idl%_EXT%\drafts\com\sun\star\frame
 mkdir: %COMMON_DEST%\idl%_EXT%\drafts\com\sun\star\frame\status
 mkdir: %COMMON_DEST%\idl%_EXT%\drafts\com\sun\star\formula
-mkdir: %COMMON_DEST%\idl%_EXT%\drafts\com\sun\star\drawing
 mkdir: %COMMON_DEST%\idl%_EXT%\drafts\com\sun\star\sheet
 mkdir: %COMMON_DEST%\idl%_EXT%\drafts\com\sun\star\table
 mkdir: %COMMON_DEST%\idl%_EXT%\drafts\com\sun\star\i18n
@@ -32,7 +29,9 @@
 mkdir: %COMMON_DEST%\idl%_EXT%\com\sun\star\datatransfer\dnd
 mkdir: %COMMON_DEST%\idl%_EXT%\com\sun\star\datatransfer\clipboard
 mkdir: %COMMON_DEST%\idl%_EXT%\com\sun\star\document
+mkdir: %COMMON_DEST%\idl%_EXT%\com\sun\star\geometry
 mkdir: %COMMON_DEST%\idl%_EXT%\com\sun\star\drawing
+mkdir: %COMMON_DEST%\idl%_EXT%\com\sun\star\rendering
 mkdir: %COMMON_DEST%\idl%_EXT%\com\sun\star\embed
 mkdir: %COMMON_DEST%\idl%_EXT%\com\sun\star\form
 mkdir: %COMMON_DEST%\idl%_EXT%\com\sun\star\form\component
@@ -124,7 +123,9 @@
 ..\com\sun\star\datatransfer\clipboard\*.idl %COMMON_DEST%\idl%_EXT%\com\sun\star\datatransfer\clipboard
 ..\com\sun\star\datatransfer\dnd\*.idl %COMMON_DEST%\idl%_EXT%\com\sun\star\datatransfer\dnd
 ..\com\sun\star\document\*.idl %COMMON_DEST%\idl%_EXT%\com\sun\star\document
+..\com\sun\star\geometry\*.idl %COMMON_DEST%\idl%_EXT%\com\sun\star\geometry
 ..\com\sun\star\drawing\*.idl %COMMON_DEST%\idl%_EXT%\com\sun\star\drawing
+..\com\sun\star\rendering\*.idl %COMMON_DEST%\idl%_EXT%\com\sun\star\rendering
 ..\com\sun\star\embed\*.idl %COMMON_DEST%\idl%_EXT%\com\sun\star\embed
 ..\com\sun\star\form\*.idl %COMMON_DEST%\idl%_EXT%\com\sun\star\form
 ..\com\sun\star\form\component\*.idl %COMMON_DEST%\idl%_EXT%\com\sun\star\form\component
@@ -184,8 +185,6 @@
 ..\com\sun\star\ui\*.idl %COMMON_DEST%\idl%_EXT%\com\sun\star\ui
 ..\com\sun\star\ui\dialogs\*.idl %COMMON_DEST%\idl%_EXT%\com\sun\star\ui\dialogs
 
-..\drafts\com\sun\star\geometry\*.idl %COMMON_DEST%\idl%_EXT%\drafts\com\sun\star\geometry
-..\drafts\com\sun\star\rendering\*.idl %COMMON_DEST%\idl%_EXT%\drafts\com\sun\star\rendering
 ..\drafts\com\sun\star\frame\*.idl %COMMON_DEST%\idl%_EXT%\drafts\com\sun\star\frame
 ..\drafts\com\sun\star\frame\status\*.idl %COMMON_DEST%\idl%_EXT%\drafts\com\sun\star\frame\status
 ..\drafts\com\sun\star\ui\*.idl %COMMON_DEST%\idl%_EXT%\drafts\com\sun\star\ui
diff -u -r  offapi/util/makefile.mk  offapi/util/makefile.mk
---  offapi/util/makefile.mk	2004-11-26 23:34:53.000000000 +0530
+++  offapi/util/makefile.mk	2005-02-28 13:41:30.216008719 +0530
@@ -98,6 +98,8 @@
 	$(UCR)$/cssddnd.db \
 	$(UCR)$/cssdocument.db \
 	$(UCR)$/cssdrawing.db \
+    $(UCR)$/cssgeometry.db \
+    $(UCR)$/cssrendering.db \
 	$(UCR)$/cssembed.db \
 	$(UCR)$/cssfcontrol.db \
 	$(UCR)$/cssform.db \
@@ -164,9 +166,6 @@
 	$(UCR)$/dcssform.db \
 	$(UCR)$/dcssui.db \
 	$(UCR)$/dcssfstatus.db \
-	$(UCR)$/dcssgeometry.db \
-	$(UCR)$/dcssrendering.db \
-	$(UCR)$/dcssdrawing.db \
 	$(UCR)$/xsec-security.db \
 	$(UCR)$/xsec-crypto.db \
 	$(UCR)$/xsec-csax.db \
diff -u -r  offuh/prj/d.lst  offuh/prj/d.lst
---  offuh/prj/d.lst	2004-11-29 18:11:43.000000000 +0530
+++  offuh/prj/d.lst	2005-02-28 13:41:03.746101603 +0530
@@ -23,6 +23,8 @@
 mkdir: %_DEST%\inc%_EXT%\com\sun\star\daemons
 mkdir: %_DEST%\inc%_EXT%\com\sun\star\document
 mkdir: %_DEST%\inc%_EXT%\com\sun\star\drawing
+mkdir: %_DEST%\inc%_EXT%\com\sun\star\geometry
+mkdir: %_DEST%\inc%_EXT%\com\sun\star\rendering
 mkdir: %_DEST%\inc%_EXT%\com\sun\star\embed
 mkdir: %_DEST%\inc%_EXT%\com\sun\star\form
 mkdir: %_DEST%\inc%_EXT%\com\sun\star\xforms
@@ -99,10 +101,7 @@
 mkdir: %_DEST%\inc%_EXT%\drafts\com\sun\star\frame
 mkdir: %_DEST%\inc%_EXT%\drafts\com\sun\star\frame\status
 mkdir: %_DEST%\inc%_EXT%\drafts\com\sun\star\i18n
-mkdir: %_DEST%\inc%_EXT%\drafts\com\sun\star\drawing
 mkdir: %_DEST%\inc%_EXT%\drafts\com\sun\star\ui
-mkdir: %_DEST%\inc%_EXT%\drafts\com\sun\star\geometry
-mkdir: %_DEST%\inc%_EXT%\drafts\com\sun\star\rendering
 mkdir: %_DEST%\inc%_EXT%\drafts\com\sun\star\form
 mkdir: %_DEST%\inc%_EXT%\drafts\com\sun\star\script
 mkdir: %_DEST%\inc%_EXT%\com\sun\star\script\browse
@@ -158,6 +157,10 @@
 ..\%__SRC%\inc\com\sun\star\document\*.hpp %_DEST%\inc%_EXT%\com\sun\star\document\*.hpp
 ..\%__SRC%\inc\com\sun\star\drawing\*.hdl %_DEST%\inc%_EXT%\com\sun\star\drawing\*.hdl
 ..\%__SRC%\inc\com\sun\star\drawing\*.hpp %_DEST%\inc%_EXT%\com\sun\star\drawing\*.hpp
+..\%__SRC%\inc\com\sun\star\geometry\*.hdl %_DEST%\inc%_EXT%\com\sun\star\geometry\*.hdl
+..\%__SRC%\inc\com\sun\star\geometry\*.hpp %_DEST%\inc%_EXT%\com\sun\star\geometry\*.hpp
+..\%__SRC%\inc\com\sun\star\rendering\*.hdl %_DEST%\inc%_EXT%\com\sun\star\rendering\*.hdl
+..\%__SRC%\inc\com\sun\star\rendering\*.hpp %_DEST%\inc%_EXT%\com\sun\star\rendering\*.hpp
 ..\%__SRC%\inc\com\sun\star\embed\*.hdl %_DEST%\inc%_EXT%\com\sun\star\embed\*.hdl
 ..\%__SRC%\inc\com\sun\star\embed\*.hpp %_DEST%\inc%_EXT%\com\sun\star\embed\*.hpp
 ..\%__SRC%\inc\com\sun\star\form\*.hdl %_DEST%\inc%_EXT%\com\sun\star\form\*.hdl
@@ -302,15 +305,6 @@
 ..\%__SRC%\inc\drafts\com\sun\star\i18n\*.hpp %_DEST%\inc%_EXT%\drafts\com\sun\star\i18n\*.hpp
 ..\%__SRC%\inc\drafts\com\sun\star\i18n\*.hdl %_DEST%\inc%_EXT%\drafts\com\sun\star\i18n\*.hdl
 
-..\%__SRC%\inc\drafts\com\sun\star\geometry\*.hpp %_DEST%\inc%_EXT%\drafts\com\sun\star\geometry\*.hpp
-..\%__SRC%\inc\drafts\com\sun\star\geometry\*.hdl %_DEST%\inc%_EXT%\drafts\com\sun\star\geometry\*.hdl
-
-..\%__SRC%\inc\drafts\com\sun\star\drawing\*.hpp %_DEST%\inc%_EXT%\drafts\com\sun\star\drawing\*.hpp
-..\%__SRC%\inc\drafts\com\sun\star\drawing\*.hdl %_DEST%\inc%_EXT%\drafts\com\sun\star\drawing\*.hdl
-
-..\%__SRC%\inc\drafts\com\sun\star\rendering\*.hpp %_DEST%\inc%_EXT%\drafts\com\sun\star\rendering\*.hpp
-..\%__SRC%\inc\drafts\com\sun\star\rendering\*.hdl %_DEST%\inc%_EXT%\drafts\com\sun\star\rendering\*.hdl
-
 ..\%__SRC%\inc\com\sun\star\script\browse\*.hpp %_DEST%\inc%_EXT%\com\sun\star\script\browse\*.hpp
 ..\%__SRC%\inc\com\sun\star\script\browse\*.hdl %_DEST%\inc%_EXT%\com\sun\star\script\browse\*.hdl
 ..\%__SRC%\inc\com\sun\star\script\provider\*.hpp %_DEST%\inc%_EXT%\com\sun\star\script\provider\*.hpp
diff -u -r  sd/source/ui/animations/STLPropertySet.cxx  sd/source/ui/animations/STLPropertySet.cxx
---  sd/source/ui/animations/STLPropertySet.cxx	2004-11-27 01:26:03.000000000 +0530
+++  sd/source/ui/animations/STLPropertySet.cxx	2005-02-28 13:40:25.199606012 +0530
@@ -158,4 +158,4 @@
 	return( rIter != maPropertyMap.end() );
 }
 
-}
\ No newline at end of file
+}
diff -u -r  sd/source/ui/inc/CustomAnimation.hxx  sd/source/ui/inc/CustomAnimation.hxx
---  sd/source/ui/inc/CustomAnimation.hxx	2004-11-27 01:41:35.000000000 +0530
+++  sd/source/ui/inc/CustomAnimation.hxx	2005-02-28 13:40:22.784888204 +0530
@@ -74,4 +74,4 @@
 	extern ::Window* createCustomAnimationPane( ::Window* pParent, const ::com::sun::star::uno::Reference< ::com::sun::star::frame::XModel >& xModel );
 }
 
-#endif // _SD_CUSTOMANIMATION_HXX_
\ No newline at end of file
+#endif // _SD_CUSTOMANIMATION_HXX_
diff -u -r  sd/source/ui/slideshow/slideshowimpl.cxx  sd/source/ui/slideshow/slideshowimpl.cxx
---  sd/source/ui/slideshow/slideshowimpl.cxx	2005-01-28 21:23:08.000000000 +0530
+++  sd/source/ui/slideshow/slideshowimpl.cxx	2005-02-28 13:40:26.285479114 +0530
@@ -141,6 +141,8 @@
 #include "cppuhelper/exc_hlp.hxx"
 #include "rtl/ref.hxx"
 
+#include "canvas/elapsedtime.hxx"
+#include "canvas/prioritybooster.hxx"
 
 // TODO(Q3): This breaks encapsulation. Either export
 // these strings from avmedia, or provide an XManager
@@ -173,7 +175,7 @@
 using ::comphelper::ImplementationReference;
 
 using namespace ::com::sun::star;
-using namespace ::drafts::com::sun::star;
+using namespace ::com::sun::star;
 using namespace ::com::sun::star::presentation;
 using namespace ::com::sun::star::drawing;
 
@@ -368,6 +371,7 @@
 	msOnClick( RTL_CONSTASCII_USTRINGPARAM("OnClick") ),
 	msBookmark( RTL_CONSTASCII_USTRINGPARAM("Bookmark") ),
 	msVerb( RTL_CONSTASCII_USTRINGPARAM("Verb") ),
+	mnEntryCounter(0),
 	mnLastPageNumber(-1),
 	mbIsPaused(false),
 	mbInputFreeze(false)
@@ -1251,6 +1255,7 @@
 {
 	if( bPause != mbIsPaused )
 	{
+        mbIsPaused = bPause;
 		if( mxShow.is() )
 		{
 			bool bRet = mxShow->pause(bPause);
@@ -1532,8 +1537,6 @@
 		const bool bUpdate = xShow->update(fUpdate);
 		if (bUpdate)
 		{
-            if (fUpdate == 0.0) // ASAP case
-                fUpdate = 0.033; // lowest time resolution: 30 updates per sec
             maUpdateTimer.SetTimeout( static_cast<ULONG>(fUpdate * 1000.0) );
             maUpdateTimer.Start();
 		}
@@ -1564,23 +1567,33 @@
 {
 	// doing some nMagic
     const rtl::Reference<SlideshowImpl> this_(this);
-    
+
+	// prevent recursive calls
+	if(mnEntryCounter)
+		return 0;
+	mnEntryCounter++;
+
 	try
 	{
-		const sal_uInt32 nLoopTime = osl_getGlobalTimer();
+        // TODO(Q3): Evaluate under various systems and setups,
+        // whether this is really necessary. Under WinXP and Matrox
+        // G550, the frame rates were much more steadier with this
+        // tweak, although.
+
+// currently no solution, because this kills sound (at least on Windows)
+//         // Boost our prio, as long as we're in the render loop
+//         ::canvas::tools::PriorityBooster aBooster(2);
+
 		double fUpdate = update();
-		
-		while (mxShow.is() &&
-               (fUpdate >= 0.0) && (fUpdate <= 0.05) &&
-               ((osl_getGlobalTimer() - nLoopTime) < 500))
-		{
+		while(mxShow.is() && fUpdate <= 0.0) {
+			sal_uInt32 nCurrentTime = osl_getGlobalTimer();
 			Application::Reschedule();
             fUpdate = update();
 		}
 	}
 	catch( Exception& e )
 	{
-		e;
+		static_cast<void>(e);
 		DBG_ERROR(
             (OString("sd::SlideshowImpl::updateHdl(), "
                      "exception caught: ") +
@@ -1588,6 +1601,8 @@
                  comphelper::anyToString( cppu::getCaughtException() ),
                  RTL_TEXTENCODING_UTF8 )).getStr() );
 	}
+
+	--mnEntryCounter;
     
 	return 0;
 }
diff -u -r  sd/source/ui/slideshow/slideshowimpl.hxx  sd/source/ui/slideshow/slideshowimpl.hxx
---  sd/source/ui/slideshow/slideshowimpl.hxx	2005-01-28 21:11:31.000000000 +0530
+++  sd/source/ui/slideshow/slideshowimpl.hxx	2005-02-28 13:40:26.287478880 +0530
@@ -399,6 +399,9 @@
 
 	PresentationSettings maPresSettings;
 
+	/// used in updateHdl to prevent recursive calls
+	sal_Int32		mnEntryCounter;
+
 	sal_Int32		mnLastPageNumber;
 	WrappedShapeEventImplMap	maShapeEventMap;
 
diff -u -r  sd/source/ui/slideshow/slideshowviewimpl.cxx  sd/source/ui/slideshow/slideshowviewimpl.cxx
---  sd/source/ui/slideshow/slideshowviewimpl.cxx	2005-01-28 21:11:43.000000000 +0530
+++  sd/source/ui/slideshow/slideshowviewimpl.cxx	2005-02-28 13:40:26.290478529 +0530
@@ -86,7 +86,7 @@
 
 using namespace ::rtl;
 using namespace ::com::sun::star;
-using namespace ::drafts::com::sun::star;
+using namespace ::com::sun::star;
 
 namespace sd
 {
diff -u -r  sd/source/ui/slideshow/slideshowviewimpl.hxx  sd/source/ui/slideshow/slideshowviewimpl.hxx
---  sd/source/ui/slideshow/slideshowviewimpl.hxx	2004-12-09 21:41:45.000000000 +0530
+++  sd/source/ui/slideshow/slideshowviewimpl.hxx	2005-02-28 13:40:26.290478529 +0530
@@ -119,7 +119,7 @@
 #include <com/sun/star/animations/XAnimationNodeSupplier.hpp>
 #endif
 #ifndef _COM_SUN_STAR_RENDERING_XSPRITECANVAS_HPP_
-#include <drafts/com/sun/star/rendering/XSpriteCanvas.hpp>
+#include <com/sun/star/rendering/XSpriteCanvas.hpp>
 #endif
 
 #ifndef _COMPHELPER_IMPLEMENTATIONREFERENCE_HXX
@@ -370,9 +370,9 @@
     virtual void SAL_CALL paint( const ::com::sun::star::awt::PaintEvent& e ) throw (::com::sun::star::uno::RuntimeException);
 
     // XSlideShowView methods
-	virtual ::com::sun::star::uno::Reference< ::drafts::com::sun::star::rendering::XSpriteCanvas > SAL_CALL getCanvas(  ) throw (::com::sun::star::uno::RuntimeException);
+	virtual ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XSpriteCanvas > SAL_CALL getCanvas(  ) throw (::com::sun::star::uno::RuntimeException);
 	virtual void SAL_CALL clear(  ) throw (::com::sun::star::uno::RuntimeException);
-	virtual ::drafts::com::sun::star::geometry::AffineMatrix2D SAL_CALL getTransformation(  ) throw (::com::sun::star::uno::RuntimeException);
+	virtual ::com::sun::star::geometry::AffineMatrix2D SAL_CALL getTransformation(  ) throw (::com::sun::star::uno::RuntimeException);
     virtual void SAL_CALL addTransformationChangedListener( const ::com::sun::star::uno::Reference< ::com::sun::star::util::XModifyListener >& xListener ) throw (::com::sun::star::uno::RuntimeException);
     virtual void SAL_CALL removeTransformationChangedListener( const ::com::sun::star::uno::Reference< ::com::sun::star::util::XModifyListener >& xListener ) throw (::com::sun::star::uno::RuntimeException);
     virtual void SAL_CALL addPaintListener( const ::com::sun::star::uno::Reference< ::com::sun::star::awt::XPaintListener >& xListener ) throw (::com::sun::star::uno::RuntimeException);
diff -u -r  sd/util/makefile.mk  sd/util/makefile.mk
---  sd/util/makefile.mk	2005-01-18 20:49:14.000000000 +0530
+++  sd/util/makefile.mk	2005-02-28 13:40:21.520036020 +0530
@@ -111,6 +111,7 @@
 	$(VCLLIB) \
 	$(SVLLIB) \
 	$(SOTLIB) \
+    $(CANVASTOOLSLIB) \
 	$(UNOTOOLSLIB) \
 	$(TOOLSLIB) \
 	$(COMPHELPERLIB) \
diff -u -r  slideshow/source/api/com/sun/star/presentation/XShapeEventListener.idl  slideshow/source/api/com/sun/star/presentation/XShapeEventListener.idl
---  slideshow/source/api/com/sun/star/presentation/XShapeEventListener.idl	2004-11-27 00:14:20.000000000 +0530
+++  slideshow/source/api/com/sun/star/presentation/XShapeEventListener.idl	2005-02-28 13:41:43.917407868 +0530
@@ -58,8 +58,8 @@
  *
  *
  ************************************************************************/
-#ifndef __drafts_com_sun_star_presentation_XShapeEventListener_idl__
-#define __drafts_com_sun_star_presentation_XShapeEventListener_idl__
+#ifndef __com_sun_star_presentation_XShapeEventListener_idl__
+#define __com_sun_star_presentation_XShapeEventListener_idl__
 
 #ifndef __com_sun_star_lang_XEventListener_idl__ 
 #include <com/sun/star/lang/XEventListener.idl> 
diff -u -r  slideshow/source/api/com/sun/star/presentation/XSlideShow.idl  slideshow/source/api/com/sun/star/presentation/XSlideShow.idl
---  slideshow/source/api/com/sun/star/presentation/XSlideShow.idl	2004-11-27 00:14:32.000000000 +0530
+++  slideshow/source/api/com/sun/star/presentation/XSlideShow.idl	2005-02-28 13:41:43.916407985 +0530
@@ -58,8 +58,8 @@
  *
  *
  ************************************************************************/
-#ifndef __drafts_com_sun_star_presentation_XSlideShow_idl__
-#define __drafts_com_sun_star_presentation_XSlideShow_idl__
+#ifndef __com_sun_star_presentation_XSlideShow_idl__
+#define __com_sun_star_presentation_XSlideShow_idl__
 
 #ifndef __com_sun_star_uno_XInterface_idl__ 
 #include <com/sun/star/uno/XInterface.idl> 
@@ -67,11 +67,11 @@
 #ifndef __com_sun_star_beans_PropertyValue_idl__ 
 #include <com/sun/star/beans/PropertyValue.idl> 
 #endif 
-#ifndef __drafts_com_sun_star_geometry_RealRectangle2D_idl__ 
-#include <drafts/com/sun/star/geometry/RealRectangle2D.idl> 
+#ifndef __com_sun_star_geometry_RealRectangle2D_idl__ 
+#include <com/sun/star/geometry/RealRectangle2D.idl> 
 #endif 
-#ifndef __drafts_com_sun_star_rendering_XSpriteCanvas_idl__ 
-#include <drafts/com/sun/star/rendering/XSpriteCanvas.idl> 
+#ifndef __com_sun_star_rendering_XSpriteCanvas_idl__ 
+#include <com/sun/star/rendering/XSpriteCanvas.idl> 
 #endif 
 #ifndef __com_sun_star_animations_XAnimationNode_idl__ 
 #include <com/sun/star/animations/XAnimationNode.idl> 
diff -u -r  slideshow/source/api/com/sun/star/presentation/XSlideShowListener.idl  slideshow/source/api/com/sun/star/presentation/XSlideShowListener.idl
---  slideshow/source/api/com/sun/star/presentation/XSlideShowListener.idl	2004-11-27 00:14:43.000000000 +0530
+++  slideshow/source/api/com/sun/star/presentation/XSlideShowListener.idl	2005-02-28 13:41:43.917407868 +0530
@@ -58,8 +58,8 @@
  *
  *
  ************************************************************************/
-#ifndef __drafts_com_sun_star_presentation_XSlideShowListener_idl__
-#define __drafts_com_sun_star_presentation_XSlideShowListener_idl__
+#ifndef __com_sun_star_presentation_XSlideShowListener_idl__
+#define __com_sun_star_presentation_XSlideShowListener_idl__
 
 #ifndef __com_sun_star_lang_XEventListener_idl__ 
 #include <com/sun/star/lang/XEventListener.idl> 
diff -u -r  slideshow/source/api/com/sun/star/presentation/XSlideShowView.idl  slideshow/source/api/com/sun/star/presentation/XSlideShowView.idl
---  slideshow/source/api/com/sun/star/presentation/XSlideShowView.idl	2004-11-27 00:14:55.000000000 +0530
+++  slideshow/source/api/com/sun/star/presentation/XSlideShowView.idl	2005-02-28 13:41:43.944404714 +0530
@@ -58,17 +58,17 @@
  *
  *
  ************************************************************************/
-#ifndef __drafts_com_sun_star_presentation_XSlideShowView_idl__
-#define __drafts_com_sun_star_presentation_XSlideShowView_idl__
+#ifndef __com_sun_star_presentation_XSlideShowView_idl__
+#define __com_sun_star_presentation_XSlideShowView_idl__
 
 #ifndef __com_sun_star_uno_XInterface_idl__ 
 #include <com/sun/star/uno/XInterface.idl> 
 #endif 
-#ifndef __drafts_com_sun_star_rendering_XSpriteCanvas_idl__ 
-#include <drafts/com/sun/star/rendering/XSpriteCanvas.idl> 
+#ifndef __com_sun_star_rendering_XSpriteCanvas_idl__ 
+#include <com/sun/star/rendering/XSpriteCanvas.idl> 
 #endif 
-#ifndef __drafts_com_sun_star_geometry_RealRectangle2D_idl__ 
-#include <drafts/com/sun/star/geometry/RealRectangle2D.idl> 
+#ifndef __com_sun_star_geometry_RealRectangle2D_idl__ 
+#include <com/sun/star/geometry/RealRectangle2D.idl> 
 #endif 
 #ifndef __com_sun_star_util_XModifyListener_idl__ 
 #include <com/sun/star/util/XModifyListener.idl> 
@@ -103,7 +103,7 @@
         @return XSpriteCanvas to display on. Must be valid, and the
         same object, as long as this view is added to any slide show.
      */
-    ::drafts::com::sun::star::rendering::XSpriteCanvas getCanvas();
+    ::com::sun::star::rendering::XSpriteCanvas getCanvas();
 
     /** This method clears the whole view area.
 
@@ -127,7 +127,7 @@
         ratio of the scaling should match that of the slides
         (otherwise, the slides will be scaled anisotrophically).
      */
-    ::drafts::com::sun::star::geometry::AffineMatrix2D getTransformation();
+    ::com::sun::star::geometry::AffineMatrix2D getTransformation();
 
     /** Add a listener to get notified when the transformation matrix changes.<p>
 
diff -u -r  slideshow/source/engine/activities/activitiesfactory.cxx  slideshow/source/engine/activities/activitiesfactory.cxx
---  slideshow/source/engine/activities/activitiesfactory.cxx	2005-01-21 22:27:47.000000000 +0530
+++  slideshow/source/engine/activities/activitiesfactory.cxx	2005-02-28 13:41:44.830301209 +0530
@@ -93,7 +93,7 @@
 #include <continuouskeytimeactivitybase.hxx>
 
 
-using namespace ::drafts::com::sun::star;
+using namespace ::com::sun::star;
 using namespace ::com::sun::star;
 
 
@@ -218,13 +218,13 @@
                                       "FromToByActivity::FromToByActivity(): From and one of To or By, or To or By alone must be valid" );
                 }
 
-                virtual void start()
+                virtual void startAnimation()                    
                 {
-                    BaseType::start();
+                    BaseType::startAnimation();
 
                     // start animation
-                    mpAnim->start( BaseType::mpShape,
-                                   BaseType::mpAttributeLayer );
+                    mpAnim->start( BaseType::getShape(),
+                                   BaseType::getShapeAttributeLayer() );
 
                     // setup start and end value. Determine animation
                     // start value only when animation actually
@@ -280,12 +280,10 @@
                     }
                 }
 
-                virtual void end()
+                virtual void endAnimation()
                 {
                     // end animation
                     mpAnim->end();
-
-                    BaseType::end();
                 }
 
                 /// perform override for ContinuousActivityBase
@@ -314,7 +312,7 @@
                                                maStartValue), 
                                               maEndValue, 
                                               nFrame, 
-                                              BaseType::maDiscreteTimes.size() ) ) ) );
+                                              BaseType::getNumberOfKeyTimes() ) ) ) );
                 }
 
             private:
@@ -487,21 +485,19 @@
                                       "ValuesActivity::ValuesActivity(): Empty value vector" );
                 }
 
-                virtual void start()
+                virtual void startAnimation()
                 {
-                    BaseType::start();
+                    BaseType::startAnimation();
 
                     // start animation
-                    mpAnim->start( BaseType::mpShape,
-                                   BaseType::mpAttributeLayer );
+                    mpAnim->start( BaseType::getShape(),
+                                   BaseType::getShapeAttributeLayer() );
                 }
 
-                virtual void end()
+                virtual void endAnimation()
                 {
                     // end animation
                     mpAnim->end();
-
-                    BaseType::end();
                 }
 
                 /// perform override for ContinuousKeyTimeActivityBase base
@@ -618,6 +614,7 @@
 
                 ActivityParameters aActivityParms( rParms.mpEndEvent,
                                                    rParms.mrEventQueue,
+                                                   rParms.mrActivitiesQueue,
                                                    rParms.mnMinDuration,
                                                    rParms.maRepeats,
                                                    rParms.mnAcceleration,
@@ -685,8 +682,10 @@
                             // since DiscreteActivityBase suspends itself
                             // between the frames, create a WakeupEvent for it.
                             aActivityParms.mpWakeupEvent.reset( 
-                                new WakeupEvent( rParms.mrActivitiesQueue ) );
-                    
+                                new WakeupEvent(
+                                    rParms.mrEventQueue.getTimer(),
+                                    rParms.mrActivitiesQueue ) );
+                            
                             AnimationActivitySharedPtr pActivity(
                                 createValueListActivity< DiscreteActivityBase >( 
                                     xNode->getValues(),
@@ -749,7 +748,9 @@
                             // since DiscreteActivityBase suspends itself
                             // between the frames, create a WakeupEvent for it.
                             aActivityParms.mpWakeupEvent.reset( 
-                                new WakeupEvent( rParms.mrActivitiesQueue ) );
+                                new WakeupEvent(
+                                    rParms.mrEventQueue.getTimer(),
+                                    rParms.mrActivitiesQueue ) );
                     
                             AnimationActivitySharedPtr pActivity(
                                 createFromToByActivity< DiscreteActivityBase >( 
@@ -817,21 +818,19 @@
                                       "SimpleActivity::SimpleActivity(): Invalid animation object" );
                 }
 
-                virtual void start()
+                virtual void startAnimation()
                 {
-                    ContinuousActivityBase::start();
+                    ContinuousActivityBase::startAnimation();
 
                     // start animation
-                    mpAnim->start( mpShape,
-                                   mpAttributeLayer );
+                    mpAnim->start( getShape(),
+                                   getShapeAttributeLayer() );
                 }
 
-                virtual void end()
+                virtual void endAnimation()
                 {
                     // end animation
                     mpAnim->end();
-
-                    ContinuousActivityBase::end();
                 }
 
                 /// perform override for ContinuousActivityBase
@@ -926,6 +925,7 @@
         {
             ActivityParameters aActivityParms( rParms.mpEndEvent,
                                                rParms.mrEventQueue,
+                                               rParms.mrActivitiesQueue,
                                                rParms.mnMinDuration,
                                                rParms.maRepeats,
                                                rParms.mnAcceleration,
diff -u -r  slideshow/source/engine/activities/activitybase.cxx  slideshow/source/engine/activities/activitybase.cxx
---  slideshow/source/engine/activities/activitybase.cxx	2005-01-21 22:27:59.000000000 +0530
+++  slideshow/source/engine/activities/activitybase.cxx	2005-02-28 13:41:44.828301443 +0530
@@ -102,21 +102,28 @@
             mbIsActive = false;
         }
 
-        bool ActivityBase::perform()
+        double ActivityBase::calcTimeLag() const
         {
-            // still active?
-            if( !isActive() )
-                return false; // no, early exit.
-
-            if( mbFirstPerformCall )
+            // TODO(Q1): implement different init process!            
+            if (isActive() && mbFirstPerformCall)
             {
                 mbFirstPerformCall = false;
-
+                
                 // notify derived classes that we're 
                 // starting now
-                start();
+                const_cast<ActivityBase *>(this)->startAnimation();
             }
-
+            return 0.0;
+        }
+    
+        bool ActivityBase::perform()
+        {
+            // still active?
+            if( !isActive() )
+                return false; // no, early exit.
+            
+            OSL_ASSERT( ! mbFirstPerformCall );
+            
             return true;
         }
 
@@ -153,18 +160,6 @@
             return true;
         }
 
-        void ActivityBase::end()
-        {
-            mbIsActive = false;
-
-            // Activity is ending, queue event, then
-            if( mpEndEvent.get() )
-                mrEventQueue.addEvent( mpEndEvent );
-
-            // release references
-            mpEndEvent.reset();
-        }
-
         void ActivityBase::setTargets( const AnimatableShapeSharedPtr& 		rShape,
                                        const ShapeAttributeLayerSharedPtr& 	rAttrLayer )
         {
@@ -177,6 +172,19 @@
             mpAttributeLayer = rAttrLayer;
         }
 
+        void ActivityBase::endActivity()
+        {
+            // this is a regular activity end
+            mbIsActive = false;
+
+            // Activity is ending, queue event, then
+            if( mpEndEvent.get() )
+                mrEventQueue.addEvent( mpEndEvent );
+
+            // release references
+            mpEndEvent.reset();
+        }
+
         double ActivityBase::calcAcceleratedTime( double nT ) const
         {
             // Handle acceleration/deceleration
diff -u -r  slideshow/source/engine/activities/activitybase.hxx  slideshow/source/engine/activities/activitybase.hxx
---  slideshow/source/engine/activities/activitybase.hxx	2005-01-21 22:28:13.000000000 +0530
+++  slideshow/source/engine/activities/activitybase.hxx	2005-02-28 13:41:44.828301443 +0530
@@ -83,14 +83,6 @@
         public:
             ActivityBase( const ActivityParameters& rParms );
 
-            /** Hook for derived classes
-
-	            This method will be called from the first
-                perform() invocation, to signal the start of the
-                activity.
-            */
-            virtual void start() = 0;
-
             /// From Disposable interface
             virtual void dispose();
 
@@ -100,16 +92,44 @@
                 and then perform their work.
             */
             virtual bool perform();
+            virtual double calcTimeLag() const;
 
             virtual bool isActive() const;
             virtual bool needsScreenUpdate() const;
-            virtual void end();
+            // virtual void dequeued() = 0; must be overridden by derived classes
 
             // From AnimationActivity interface
             virtual void setTargets( const AnimatableShapeSharedPtr& 		rShape,
                                      const ShapeAttributeLayerSharedPtr& 	rAttrLayer );
 
         protected:
+            /** Hook for derived classes
+
+	            This method will be called from the first
+                perform() invocation, to signal the start of the
+                activity.
+            */
+            virtual void startAnimation() = 0;
+
+            /** Hook for derived classes
+
+	            This method will be called after the last perform()
+	            invocation, and after the potential changes of that
+	            perform() call are committed to screen. That is, in
+	            endAnimation(), the animation objects (sprites,
+	            animation) can safely be destroyed, without causing
+	            visible artifacts on screen.
+            */
+            virtual void endAnimation() = 0;
+
+            /** End this activity, in a regular way.
+
+            	This method is for derived classes needing to signal a
+            	regular activity end (i.e. because the regular
+            	duration is over)
+             */
+            void endActivity();
+
             /** Modify fractional time.
                       
 	            This method modifies the fractional time (total
@@ -119,9 +139,14 @@
             */
             double calcAcceleratedTime( double nT ) const;
 
-            // TODO(Q2): Wrap direct member access with protected
-            // accessor methods
-
+            EventQueue& 					getEventQueue() const { return mrEventQueue; }
+            AnimatableShapeSharedPtr		getShape() const { return mpShape; }
+            ShapeAttributeLayerSharedPtr	getShapeAttributeLayer() const { return mpAttributeLayer; }
+            bool							isRepeatCountValid() const { return maRepeats.isValid(); }
+            double							getRepeatCount() const { return maRepeats.getValue(); }
+            bool							isAutoReverse() const { return mbAutoReverse; }
+            
+        private:
             EventSharedPtr								mpEndEvent;
             EventQueue& 								mrEventQueue;
             AnimatableShapeSharedPtr					mpShape;			// only to pass on to animation
@@ -133,7 +158,7 @@
 
             const bool									mbAutoReverse;
 
-            bool										mbFirstPerformCall; // true, if perform() has not yet been called
+            mutable bool								mbFirstPerformCall; // true, if perform() has not yet been called
             bool										mbIsActive;
         };
     }
diff -u -r  slideshow/source/engine/activities/activityparameters.hxx  slideshow/source/engine/activities/activityparameters.hxx
---  slideshow/source/engine/activities/activityparameters.hxx	2005-01-21 22:28:24.000000000 +0530
+++  slideshow/source/engine/activities/activityparameters.hxx	2005-02-28 13:41:44.826301677 +0530
@@ -122,6 +122,7 @@
              */
             ActivityParameters( const EventSharedPtr&						rEndEvent,
                                 EventQueue& 								rEventQueue,
+                                ActivitiesQueue& 							rActivitiesQueue,
                                 double										nMinDuration,
                                 const ::comphelper::OptionalValue<double>&	rRepeats,
                                 double										nAccelerationFraction,
@@ -131,6 +132,7 @@
                 mrEndEvent( rEndEvent ),
                 mpWakeupEvent(),
                 mrEventQueue( rEventQueue ),
+                mrActivitiesQueue( rActivitiesQueue ),
                 mpFormula(),
                 maDiscreteTimes(),
                 mnMinDuration( nMinDuration ),
@@ -150,6 +152,9 @@
             /// EventQueue to add events to
             EventQueue& 								mrEventQueue;
 
+            /// ActivitiesQueue to add events to
+            ActivitiesQueue& 							mrActivitiesQueue;
+
             /// Optional formula
             ExpressionNodeSharedPtr						mpFormula;
 
diff -u -r  slideshow/source/engine/activities/continuouskeytimeactivitybase.hxx  slideshow/source/engine/activities/continuouskeytimeactivitybase.hxx
---  slideshow/source/engine/activities/continuouskeytimeactivitybase.hxx	2005-01-21 22:29:17.000000000 +0530
+++  slideshow/source/engine/activities/continuouskeytimeactivitybase.hxx	2005-02-28 13:41:44.823302027 +0530
@@ -105,7 +105,7 @@
             virtual void simplePerform( double 		nSimpleTime, 
                                         sal_uInt32 	nRepeatCount ) const;
 
-        protected:
+        private:
             const ::std::vector< double >	maKeyTimes;
 
             /// last active index in maKeyTimes (to avoid frequent searching)
diff -u -r  slideshow/source/engine/activities/discreteactivitybase.cxx  slideshow/source/engine/activities/discreteactivitybase.cxx
---  slideshow/source/engine/activities/discreteactivitybase.cxx	2005-01-21 22:29:29.000000000 +0530
+++  slideshow/source/engine/activities/discreteactivitybase.cxx	2005-02-28 13:41:44.832300976 +0530
@@ -105,7 +105,7 @@
 #endif
         }
 
-        void DiscreteActivityBase::start()
+        void DiscreteActivityBase::startAnimation()
         {
             // start timer on wakeup event
             mpWakeupEvent->start();
@@ -114,7 +114,7 @@
         sal_uInt32 DiscreteActivityBase::calcFrameIndex( sal_uInt32 	nCurrCalls,
                                                          ::std::size_t 	nVectorSize ) const
         {
-            if( mbAutoReverse )
+            if( isAutoReverse() )
             {
                 // every full repeat run consists of one
                 // forward and one backward traversal.
@@ -136,7 +136,7 @@
         sal_uInt32 DiscreteActivityBase::calcRepeatCount( sal_uInt32 	nCurrCalls,
                                                           ::std::size_t	nVectorSize ) const
         {
-            if( mbAutoReverse )
+            if( isAutoReverse() )
                 return nCurrCalls / (2*nVectorSize); // we've got 2 cycles per repeat
             else
                 return nCurrCalls / nVectorSize;
@@ -169,14 +169,14 @@
             // if auto-reverse is specified, halve the
             // effective repeat count, since we pass every
             // repeat run twice: once forward, once backward.
-            if( mbAutoReverse )
+            if( isAutoReverse() )
                 nCurrRepeat /= 2.0;
 
             // schedule next frame, if either repeat is indefinite 
             // (repeat forever), or we've not yet reached the requested
             // repeat count
-            if( !maRepeats.isValid() ||
-                nCurrRepeat < maRepeats.getValue() )
+            if( !isRepeatCountValid() ||
+                nCurrRepeat < getRepeatCount() )
             {
                 // add wake-up event to queue (modulo 
                 // vector size, to cope with repeats).
@@ -206,12 +206,16 @@
                                     mnCurrPerformCalls, 
                                     nVectorSize ) ] ) ) );
 
-                mrEventQueue.addEvent( mpWakeupEvent );
+                getEventQueue().addEvent( mpWakeupEvent );
             }
             else
             {
-                // done
-                end();
+                // release event reference (relation to wakeup event
+                // is circular!)
+                mpWakeupEvent.reset();
+
+                // done with this activity
+                endActivity();
             }
 
             return false; // remove from queue, will be added back by the wakeup event.
@@ -229,12 +233,15 @@
             ActivityBase::dispose();
         }
 
-        void DiscreteActivityBase::end()
+        void DiscreteActivityBase::dequeued()
         {
-            // release references
-            mpWakeupEvent.reset();
-            
-            ActivityBase::end();
+            // ignored here, if we're still active. Discrete
+            // activities are dequeued after every perform() call,
+            // thus, the call is only significant when isActive() ==
+            // false.
+            if( !isActive() )
+                endAnimation();
         }
+
     }
 }
diff -u -r  slideshow/source/engine/activities/discreteactivitybase.hxx  slideshow/source/engine/activities/discreteactivitybase.hxx
---  slideshow/source/engine/activities/discreteactivitybase.hxx	2005-01-21 22:29:43.000000000 +0530
+++  slideshow/source/engine/activities/discreteactivitybase.hxx	2005-02-28 13:41:44.833300859 +0530
@@ -99,16 +99,20 @@
             virtual void dispose();
 
             virtual bool perform();
-            virtual void start();
-            virtual void end();
+            virtual void dequeued();
 
         protected:
+            virtual void startAnimation();
+
             sal_uInt32 calcFrameIndex( sal_uInt32 		nCurrCalls,
                                        ::std::size_t 	nVectorSize ) const;
 
             sal_uInt32 calcRepeatCount( sal_uInt32 		nCurrCalls,
                                         ::std::size_t 	nVectorSize ) const;
 
+            ::std::size_t getNumberOfKeyTimes() const { return maDiscreteTimes.size(); }
+
+        private:
             WakeupEventSharedPtr			mpWakeupEvent;
             const ::std::vector< double >	maDiscreteTimes;
             const double					mnSimpleDuration;
diff -u -r  slideshow/source/engine/activities/simplecontinuousactivitybase.cxx  slideshow/source/engine/activities/simplecontinuousactivitybase.cxx
---  slideshow/source/engine/activities/simplecontinuousactivitybase.cxx	2005-01-21 22:30:27.000000000 +0530
+++  slideshow/source/engine/activities/simplecontinuousactivitybase.cxx	2005-02-28 13:41:44.825301793 +0530
@@ -70,37 +70,35 @@
 {
     namespace internal
     {
-        SimpleContinuousActivityBase::SimpleContinuousActivityBase( const ActivityParameters& rParms ) :
+        SimpleContinuousActivityBase::SimpleContinuousActivityBase(
+            const ActivityParameters& rParms ) :
             ActivityBase( rParms ),
-            maTimer(),
+            maTimer( rParms.mrActivitiesQueue.getTimer() ),
             mnMinSimpleDuration( rParms.mnMinDuration ),
             mnMinNumberOfFrames( rParms.mnMinNumberOfFrames ),
             mnCurrPerformCalls( 0 )
         {
         }
 
-        void SimpleContinuousActivityBase::start()
+        void SimpleContinuousActivityBase::startAnimation()
         {
             // init timer. We measure animation time only when we're 
             // actually started.
             maTimer.reset();
         }
-        
-        bool SimpleContinuousActivityBase::perform()
-        {
-            // call base class, for start() calls and end handling
-            if( !ActivityBase::perform() )
-                return false; // done, we're ended
 
+        double SimpleContinuousActivityBase::calcTimeLag() const
+        {
+            ActivityBase::calcTimeLag();
+            if (! isActive())
+                return 0.0;
+            
             // retrieve locally elapsed time
             const double nCurrElapsedTime( maTimer.getElapsedTime() );
 
             // log time
-            VERBOSE_TRACE( "SimpleContinuousActivityBase::perform(): next step is based on time: %f", nCurrElapsedTime );
-
-
-            // calc relative animation position
-            // ================================
+            VERBOSE_TRACE( "SimpleContinuousActivityBase::calcTimeLag(): "
+                           "next step is based on time: %f", nCurrElapsedTime );
 
             // go to great length to ensure a proper animation
             // run. Since we don't know how often we will be called
@@ -110,10 +108,12 @@
             // times. 
 
             // fraction of time elapsed
-            const double nFractionElapsedTime( nCurrElapsedTime / mnMinSimpleDuration );
+            const double nFractionElapsedTime(
+                nCurrElapsedTime / mnMinSimpleDuration );
 
             // fraction of minimum calls performed
-            const double nFractionRequiredCalls( (double)mnCurrPerformCalls / mnMinNumberOfFrames );
+            const double nFractionRequiredCalls(
+                (double)mnCurrPerformCalls / mnMinNumberOfFrames );
 
             // okay, so now, the decision is easy:
             //
@@ -129,18 +129,37 @@
             // down, and take the required minimal number of steps,
             // sufficiently equally distributed across the animation
             // time line.
-            double nT;
             if( nFractionElapsedTime < nFractionRequiredCalls )
             {
-                VERBOSE_TRACE( "SimpleContinuousActivityBase::perform(): t=%f is based on time", nFractionElapsedTime );
-                nT = nFractionElapsedTime;
+                VERBOSE_TRACE( "SimpleContinuousActivityBase::calcTimeLag(): "
+                               "t=%f is based on time", nFractionElapsedTime );
+                return 0.0;
             }
             else
             {
-                VERBOSE_TRACE( "SimpleContinuousActivityBase::perform(): t=%f is based on number of calls", nFractionRequiredCalls );
-                nT = nFractionRequiredCalls;
+                VERBOSE_TRACE( "SimpleContinuousActivityBase::perform(): "
+                               "t=%f is based on number of calls",
+                               nFractionRequiredCalls );
+                
+                // lag global time, so all other animations lag, too:
+                return ((nFractionElapsedTime - nFractionRequiredCalls)
+                        * mnMinSimpleDuration);
             }
+        }
+    
+        bool SimpleContinuousActivityBase::perform()
+        {
+            // call base class, for start() calls and end handling
+            if( !ActivityBase::perform() )
+                return false; // done, we're ended
+            
 
+            // get relative animation position
+            // ===============================
+            
+            const double nCurrElapsedTime( maTimer.getElapsedTime() );
+            double nT( nCurrElapsedTime / mnMinSimpleDuration );
+            
 
             // one of the stop criteria reached?
             // =================================
@@ -149,16 +168,17 @@
             // matched.
             bool bActivityEnding( false );
 
-            if( maRepeats.isValid() )
+            if( isRepeatCountValid() )
             {
                 // Finite duration
                 // ===============
 
                 // When we've autoreverse on, the repeat count
                 // doubles
-                const double nEffectiveRepeat( mbAutoReverse ?
-                                               2.0*maRepeats.getValue() :
-                                               maRepeats.getValue() );
+                const double nRepeatCount( getRepeatCount() );
+                const double nEffectiveRepeat( isAutoReverse() ?
+                                               2.0*nRepeatCount :
+                                               nRepeatCount );
 
                 // time (or frame count) elapsed?
                 if( nEffectiveRepeat <= nT )
@@ -178,7 +198,7 @@
             // ========================
 
             // TODO(Q3): Refactor this mess
-            if( mbAutoReverse )
+            if( isAutoReverse() )
             {
                 // divert active duration into repeat and
                 // fractional part.
@@ -211,8 +231,8 @@
             double nRelativeSimpleTime( modf(nT, &nRepeats) );
 
             // clamp repeats to max permissible value (maRepeats.getValue() - 1.0)
-            if( maRepeats.isValid() &&
-                nRepeats >= maRepeats.getValue() )
+            if( isRepeatCountValid() &&
+                nRepeats >= getRepeatCount() )
             {
                 // Note that this code here only gets
                 // triggered if maRepeats.getValue() is an
@@ -239,7 +259,7 @@
                 // nRelativeSimpleTime=1.0. For auto-reversed
                 // animations, nRelativeSimpleTime must become
                 // 0.0
-                nRelativeSimpleTime = mbAutoReverse ? 0.0 : 1.0;
+                nRelativeSimpleTime = isAutoReverse() ? 0.0 : 1.0;
                 nRepeats -= 1.0;
             }
 
@@ -252,17 +272,27 @@
                            static_cast<sal_uInt32>( nRepeats ) );
 
 
-            // delayed end() call from end condition check below.
-            // Issued after the simplePerform() call above, to give
-            // animations the chance to correctly reach the animation
-            // end value.
+            // delayed endActivity() call from end condition check
+            // below. Issued after the simplePerform() call above, to
+            // give animations the chance to correctly reach the
+            // animation end value, without spurious bail-outs because
+            // of isActive() returning false.
             if( bActivityEnding )
-                end();
+                endActivity();
 
             // one more frame successfully performed
             ++mnCurrPerformCalls;
 
             return isActive();
         }
+
+        void SimpleContinuousActivityBase::dequeued()
+        {
+            ENSURE_AND_THROW( !isActive(),
+                              "SimpleContinuousActivityBase::dequeued(): Dequeued, but still active?!" );
+
+            endAnimation();
+        }
+
     }
 }
diff -u -r  slideshow/source/engine/activities/simplecontinuousactivitybase.hxx  slideshow/source/engine/activities/simplecontinuousactivitybase.hxx
---  slideshow/source/engine/activities/simplecontinuousactivitybase.hxx	2005-01-21 22:30:43.000000000 +0530
+++  slideshow/source/engine/activities/simplecontinuousactivitybase.hxx	2005-02-28 13:41:44.826301677 +0530
@@ -81,6 +81,12 @@
         public:
             SimpleContinuousActivityBase( const ActivityParameters& rParms );
 
+            virtual double calcTimeLag() const;
+            
+            virtual bool perform();
+            virtual void dequeued();
+
+        protected:
             /** Hook for derived classes
 
 	            This method will be called from perform().
@@ -96,11 +102,9 @@
             */
             virtual void simplePerform( double nSimpleTime, sal_uInt32 nRepeatCount ) const = 0;
             
-            virtual void start();
+            virtual void startAnimation();
 
-            virtual bool perform();
-
-        protected:
+        private:
             /// Time elapsed since activity started
             ::canvas::tools::ElapsedTime	maTimer;
 
diff -u -r  slideshow/source/engine/activitiesqueue.cxx  slideshow/source/engine/activitiesqueue.cxx
---  slideshow/source/engine/activitiesqueue.cxx	2004-11-27 00:15:21.000000000 +0530
+++  slideshow/source/engine/activitiesqueue.cxx	2005-02-28 13:41:44.896293499 +0530
@@ -61,6 +61,7 @@
 
 // must be first
 #include <canvas/debug.hxx>
+#include "comphelper/scopeguard.hxx"
 
 #ifndef _CANVAS_VERBOSETRACE_HXX
 #include <canvas/verbosetrace.hxx>
@@ -80,25 +81,28 @@
 #include <activitiesqueue.hxx>
 
 
-using namespace ::drafts::com::sun::star;
+using namespace ::com::sun::star;
 using namespace ::com::sun::star;
 
 namespace presentation
 {
     namespace internal
     {
-        ActivitiesQueue::ActivitiesQueue( const UnoViewContainer& rViews ) :
-            mpLayerManager(),
-            maCurrentActivitiesWaiting(),
-            maCurrentActivitiesReinsert(),
-            mrViews( rViews ),
-            mbCurrentRoundNeedsScreenUpdate( false )
+        ActivitiesQueue::ActivitiesQueue(
+            boost::shared_ptr< ::canvas::tools::ElapsedTime > const & pPresTimer,
+            const UnoViewContainer& rViews )
+            : mpTimer( pPresTimer ),
+              mpLayerManager(),
+              maCurrentActivitiesWaiting(),
+              maCurrentActivitiesReinsert(),
+              mrViews( rViews ),
+              mbCurrentRoundNeedsScreenUpdate( false )
         {
         }
 
         ActivitiesQueue::~ActivitiesQueue()
         {
-            // dispose all queues
+            // dispose all queue entries
             ::std::for_each( maCurrentActivitiesWaiting.begin(),
                              maCurrentActivitiesWaiting.end(),
                              ::boost::mem_fn(&Disposable::dispose) );
@@ -124,11 +128,25 @@
         {
             VERBOSE_TRACE( "ActivitiesQueue: outer loop heartbeat" );
 
-            bool bPerformScreenUpdate( false );
-
-            // was:
-            // if( !maCurrentActivitiesWaiting.empty() )
-            // for low-prio activities
+            // accumulate time lag for all activities, and lag time
+            // base if necessary:
+            ActivityQueue::const_iterator iPos(
+                maCurrentActivitiesWaiting.begin() );
+            const ActivityQueue::const_iterator iEnd(
+                maCurrentActivitiesWaiting.end() );
+            double fLag = 0.0;
+            for ( ; iPos != iEnd; ++iPos )
+                fLag = std::max<double>( fLag, (*iPos)->calcTimeLag() );
+            if (fLag > 0.0) {
+                mpTimer->adjustTimer( -fLag );
+            }
+            
+            // This list collects all activities which did not request
+            // a reinsertion. After the screen update has been
+            // performed, those are notified via dequeued(). This
+            // facilitates cleanup actions taking place _after_ the
+            // current frame has been displayed.
+            ActivityQueue aDequeuedActivities;
 
             // process list of activities
             while( !maCurrentActivitiesWaiting.empty() )
@@ -182,10 +200,16 @@
 
                 if( bReinsert )
                     maCurrentActivitiesReinsert.push_back( pActivity );
+                else
+                    aDequeuedActivities.push_back( pActivity );
 
                 VERBOSE_TRACE( "ActivitiesQueue: inner loop heartbeat" );
             }
 
+            // when true, the code below has determined that a screen
+            // update is necessary.
+            bool bPerformScreenUpdate( false );
+
             // waiting activities exhausted? Then update screen, and
             // reinsert
             if( maCurrentActivitiesWaiting.empty() )
@@ -238,6 +262,12 @@
 
                 VERBOSE_TRACE( "ActivitiesQueue: update done" );
             }
+
+            // notify all dequeued activities, but only _after_ the
+            // screen update.
+            ::std::for_each( aDequeuedActivities.begin(),
+                             aDequeuedActivities.end(),
+                             ::boost::mem_fn( &Activity::dequeued ) );
         }
 
         bool ActivitiesQueue::isEmpty()
@@ -252,11 +282,8 @@
 
         void ActivitiesQueue::clear()
         {
-            ActivityQueue aTmp0;
-            maCurrentActivitiesWaiting.swap( aTmp0 );
-
-            ActivityQueue aTmp1;
-            maCurrentActivitiesReinsert.swap( aTmp1 );
+            maCurrentActivitiesWaiting.clear();
+            maCurrentActivitiesReinsert.clear();
 
             mbCurrentRoundNeedsScreenUpdate = false;
         }
diff -u -r  slideshow/source/engine/animatedsprite.cxx  slideshow/source/engine/animatedsprite.cxx
---  slideshow/source/engine/animatedsprite.cxx	2005-01-21 22:24:58.000000000 +0530
+++  slideshow/source/engine/animatedsprite.cxx	2005-02-28 13:41:45.778190462 +0530
@@ -85,7 +85,7 @@
 #endif
 
 
-using namespace ::drafts::com::sun::star;
+using namespace ::com::sun::star;
 using namespace ::com::sun::star;
 
 namespace presentation
diff -u -r  slideshow/source/engine/animationfactory.cxx  slideshow/source/engine/animationfactory.cxx
---  slideshow/source/engine/animationfactory.cxx	2004-11-27 00:17:20.000000000 +0530
+++  slideshow/source/engine/animationfactory.cxx	2005-02-28 13:41:44.895293616 +0530
@@ -105,7 +105,7 @@
 #include <functional>
 
 
-using namespace ::drafts::com::sun::star;
+using namespace ::com::sun::star;
 using namespace ::com::sun::star;
 
 
diff -u -r  slideshow/source/engine/animationnodes/animationaudionode.cxx  slideshow/source/engine/animationnodes/animationaudionode.cxx
---  slideshow/source/engine/animationnodes/animationaudionode.cxx	2005-01-21 22:31:24.000000000 +0530
+++  slideshow/source/engine/animationnodes/animationaudionode.cxx	2005-02-28 13:41:45.596211724 +0530
@@ -94,8 +94,10 @@
                     
             try
             {
-                mpPlayer.reset( new SoundPlayer( aSoundURL,
-                                                 getContext().mxComponentContext ) );
+                mpPlayer = SoundPlayer::create(
+                    getContext().mrEventMultiplexer,
+                    aSoundURL,
+                    getContext().mxComponentContext );
             }
             catch( lang::NoSupportException& ) 
             {
@@ -108,7 +110,11 @@
 
         void AnimationAudioNode::dispose()
         {
-            mpPlayer.reset();
+            if (mpPlayer.get() != 0) {
+                mpPlayer->stopPlayback();
+                mpPlayer->dispose();
+                mpPlayer.reset();
+            }
 
             mxAudioNode.clear();
 
diff -u -r  slideshow/source/engine/animationnodes/animationbasenode.cxx  slideshow/source/engine/animationnodes/animationbasenode.cxx
---  slideshow/source/engine/animationnodes/animationbasenode.cxx	2005-01-21 22:31:51.000000000 +0530
+++  slideshow/source/engine/animationnodes/animationbasenode.cxx	2005-02-28 13:41:45.544217798 +0530
@@ -229,10 +229,14 @@
                     // NOTE: For shapes with ParagraphTarget, we ignore
                     // the SubItem property. We implicitely assume that it
                     // is set to ONLY_TEXT.
-                    OSL_ENSURE( mxAnimateNode->getSubItem() == ::com::sun::star::presentation::ShapeAnimationSubType::ONLY_TEXT,
-                                "AnimationBaseNode::AnimationBaseNode(): ParagraphTarget given, but subitem!=AS_TEXT? "
-                                "Make up your mind, I'll ignore the subitem." );
-                        
+                    OSL_ENSURE(
+                        mxAnimateNode->getSubItem() ==
+                        ::com::sun::star::presentation::ShapeAnimationSubType::ONLY_TEXT ||
+                        mxAnimateNode->getSubItem() ==
+                        ::com::sun::star::presentation::ShapeAnimationSubType::AS_WHOLE,
+                        "AnimationBaseNode::AnimationBaseNode(): ParagraphTarget given, but subitem not AS_TEXT or AS_WHOLE? "
+                        "Make up your mind, I'll ignore the subitem." );
+                    
                     // okay, found a ParagraphTarget with a valid XShape. Does the shape
                     // provide the given paragraph?
                     const DocTreeNode& rTreeNode( DocTreeNode::createFromShape( 
@@ -414,8 +418,8 @@
 
             if( mpActivity.get() && mpActivity->isActive() )
             {
-                // end activity, if still running
-                mpActivity->end();
+                // kill activity, if still running
+                mpActivity->dispose();
             }
 
             // destroy activity, we need to re-generate it
diff -u -r  slideshow/source/engine/animationnodes/animationnodefactory.cxx  slideshow/source/engine/animationnodes/animationnodefactory.cxx
---  slideshow/source/engine/animationnodes/animationnodefactory.cxx	2005-01-28 21:19:44.000000000 +0530
+++  slideshow/source/engine/animationnodes/animationnodefactory.cxx	2005-02-28 13:41:45.621208803 +0530
diff -u -r  slideshow/source/engine/animationnodes/basenode.hxx  slideshow/source/engine/animationnodes/basenode.hxx
---  slideshow/source/engine/animationnodes/basenode.hxx	2005-01-21 22:35:38.000000000 +0530
+++  slideshow/source/engine/animationnodes/basenode.hxx	2005-02-28 13:41:45.623208569 +0530
@@ -76,11 +76,11 @@
 
         /** Context for every node.
 
-        Besides the global AnimationNodeFactory::Context data,
-        this struct also contains the current DocTree subset
-        for this node. If start and end index of the
-        DocTreeNode are equal, the node should use the
-        complete shape.
+	        Besides the global AnimationNodeFactory::Context data,
+            this struct also contains the current DocTree subset
+            for this node. If start and end index of the
+            DocTreeNode are equal, the node should use the
+            complete shape.
         */
         struct NodeContext
         {
diff -u -r  slideshow/source/engine/animationnodes/setactivity.hxx  slideshow/source/engine/animationnodes/setactivity.hxx
---  slideshow/source/engine/animationnodes/setactivity.hxx	2005-01-21 22:38:14.000000000 +0530
+++  slideshow/source/engine/animationnodes/setactivity.hxx	2005-02-28 13:41:45.565215345 +0530
@@ -107,6 +107,11 @@
                 mpAttributeLayer.reset();
             }
 
+            virtual double calcTimeLag() const
+            {
+                return 0.0;
+            }
+            
             virtual bool perform()
             {
                 if( !mpAnimation.get() || !mpAttributeLayer.get() || !mpShape.get() )
@@ -130,7 +135,7 @@
                 return true;
             }
 
-            virtual void end()
+            virtual void dequeued()
             {
             }
                 
diff -u -r  slideshow/source/engine/backgroundshape.cxx  slideshow/source/engine/backgroundshape.cxx
---  slideshow/source/engine/backgroundshape.cxx	2004-11-27 00:18:29.000000000 +0530
+++  slideshow/source/engine/backgroundshape.cxx	2005-02-28 13:41:44.504339293 +0530
@@ -102,7 +102,7 @@
 #include <slideshowexceptions.hxx>
 #include <gdimtftools.hxx>
 
-using namespace ::drafts::com::sun::star;
+using namespace ::com::sun::star;
 using namespace ::com::sun::star;
 
 
diff -u -r  slideshow/source/engine/drawshape.cxx  slideshow/source/engine/drawshape.cxx
---  slideshow/source/engine/drawshape.cxx	2004-11-27 00:21:05.000000000 +0530
+++  slideshow/source/engine/drawshape.cxx	2005-02-28 13:41:44.934289060 +0530
@@ -116,7 +116,7 @@
 #include <lerp.hxx>
 #include <gdimtftools.hxx>
 
-using namespace ::drafts::com::sun::star;
+using namespace ::com::sun::star;
 using namespace ::com::sun::star;
 
 
@@ -1065,7 +1065,9 @@
                               ::std::back_insert_iterator< ::std::vector<double> >( aTimeout ),
                               ::boost::mem_fn( &MtfAnimationFrame::getDuration ) );
 
-            WakeupEventSharedPtr pWakeupEvent( new WakeupEvent(rContext.mrActivitiesQueue) );
+            WakeupEventSharedPtr pWakeupEvent(
+                new WakeupEvent( rContext.mrEventQueue.getTimer(),
+                                 rContext.mrActivitiesQueue ) );
 
             mpIntrinsicAnimationActivity.reset( 
                 new IntrinsicAnimationActivity(rContext,
@@ -1083,7 +1085,7 @@
             if( !mpIntrinsicAnimationActivity.get() )
                 return false;
 
-            mpIntrinsicAnimationActivity->end();
+            mpIntrinsicAnimationActivity->dispose();
             mpIntrinsicAnimationActivity.reset();
 
             return true;
diff -u -r  slideshow/source/engine/eventmultiplexer.cxx  slideshow/source/engine/eventmultiplexer.cxx
---  slideshow/source/engine/eventmultiplexer.cxx	2004-11-27 00:22:49.000000000 +0530
+++  slideshow/source/engine/eventmultiplexer.cxx	2005-02-28 13:41:44.834300742 +0530
@@ -90,7 +90,7 @@
 #include <algorithm>
 
 
-using namespace ::drafts::com::sun::star;
+using namespace ::com::sun::star;
 using namespace ::com::sun::star;
 
 /* Implementation of EventMultiplexer class */
@@ -171,10 +171,10 @@
             if( !bEmptyContainer )
             {
                 // precond: rHandlerContainer.size() is now at least 2,
-                // which is ensures by the rHandlerContainer.empty()
+                // which is ensured by the rHandlerContainer.empty()
                 // check above.
 
-                // element was insert, but now we have to keep the
+                // element was inserted, but now we have to keep the
                 // entries sorted
                 ::std::inplace_merge( rHandlerContainer.begin(),
                                       rHandlerContainer.end()-1,
@@ -195,19 +195,26 @@
 
             if( !maNextEffectHandlers.empty() )
             {
-                // still handlers left, schedule next timeout event
+                // still handlers left, schedule next timeout
+                // event. Will also set mbIsTickEventOn back to true
                 scheduleTick();
             }
         }
 
         void EventMultiplexer::Listener::scheduleTick()
         {
+            EventSharedPtr pEvent( makeDelay( ::boost::bind( &EventMultiplexer::Listener::tick,
+                                                             ::boost::ref( *this ) ),
+                                              mnTimeout ) );
+
+            // store weak reference to generated event, to notice when
+            // the event queue gets cleansed (we then have to
+            // regenerate the tick event!)
+            mpTickEvent = pEvent;
+
             // enabled auto mode: simply schedule a timeout event,
             // which will eventually call our tick() method
-            mrEventQueue.addEvent( 
-                makeDelay( ::boost::bind( &EventMultiplexer::Listener::tick,
-                                          ::boost::ref( *this ) ),
-                           mnTimeout ) );
+            mrEventQueue.addEvent( pEvent );
         }
                 
         void EventMultiplexer::Listener::handleTicks()
@@ -215,6 +222,11 @@
             if( !mbIsAutoMode )
                 return; // nothing to do, don't need no ticks
 
+            EventSharedPtr pTickEvent( mpTickEvent.lock() );
+            if( pTickEvent )
+                return; // nothing to do, there's already a tick
+                        // pending
+
             // schedule initial tick (which reschedules itself 
             // after that, all by itself)
             scheduleTick();
@@ -471,6 +483,7 @@
             maMouseDoubleClickHandlers(),
             maMouseMoveHandlers(),
             mnTimeout( 0.0 ),
+            mpTickEvent(),
             mnMouseCursor( awt::SystemPointer::ARROW ),
             mnVolatileMouseCursor( -1 ),
             mnLastVolatileMouseCursor( mnMouseCursor ),
@@ -639,6 +652,9 @@
         {
             addHandler( maNextEffectHandlers,
                         rHandler );
+
+            // Enable tick events, if not done already
+            handleTicks();
         }
         
         void EventMultiplexer::Listener::removeNextEffectHandler( const EventHandlerSharedPtr& rHandler )
diff -u -r  slideshow/source/engine/eventqueue.cxx  slideshow/source/engine/eventqueue.cxx
---  slideshow/source/engine/eventqueue.cxx	2004-11-27 00:23:02.000000000 +0530
+++  slideshow/source/engine/eventqueue.cxx	2005-02-28 13:41:44.505339177 +0530
@@ -96,9 +96,10 @@
         }
 
 
-        EventQueue::EventQueue() :
-            maEvents(),
-            maElapsedTime()
+        EventQueue::EventQueue(
+            boost::shared_ptr<canvas::tools::ElapsedTime> const & pPresTimer )
+            : maEvents(),
+              mpTimer( pPresTimer )
         {
         }
 
@@ -122,7 +123,7 @@
             // prepare entry
             EventEntry entry;
 
-            const double nCurrTime( maElapsedTime.getElapsedTime() );
+            const double nCurrTime( mpTimer->getElapsedTime() );
             entry.pEvent = rEvent;
             entry.nTime  = rEvent->getActivationTime( nCurrTime );
 
@@ -138,14 +139,14 @@
             return true;
         }
 
-        void EventQueue::process( double* pTimeoutForNextCall )
-        {            
+        double EventQueue::process()
+        {
             VERBOSE_TRACE( "EventQueue: heartbeat" );
 
             // perform topmost, ready-to-execute event
             // =======================================
 
-            const double nCurrTime( maElapsedTime.getElapsedTime() );
+            const double nCurrTime( mpTimer->getElapsedTime() );
 
             // process ready/elapsed events. Note that the 'perceived'
             // current time remains constant for this loop, thus we're
@@ -197,23 +198,10 @@
                 }
             }
 
-            // setup optional timeout value
-            if( pTimeoutForNextCall )
-            {
-                if( maEvents.empty() )
-                {
-                    // no further events available, 
-                    *pTimeoutForNextCall = ::std::numeric_limits<double>::max();
-                }
-                else
-                {
-                    // ensure nothing negative is returned. Fetch
-                    // fresh current time, event processing above
-                    // might have taken significant time
-                    *pTimeoutForNextCall = ::std::max(0.0, 
-                                                      maEvents.top().nTime - maElapsedTime.getElapsedTime());
-                }
-            }
+            // return time for next entry (if any)
+            return maEvents.empty() ? 
+                ::std::numeric_limits<double>::max() :
+                maEvents.top().nTime;
         }
         
         bool EventQueue::isEmpty()
diff -u -r  slideshow/source/engine/gdimtftools.cxx  slideshow/source/engine/gdimtftools.cxx
---  slideshow/source/engine/gdimtftools.cxx	2004-11-27 00:23:50.000000000 +0530
+++  slideshow/source/engine/gdimtftools.cxx	2005-02-28 13:41:44.608327144 +0530
@@ -69,17 +69,40 @@
 #ifndef _COM_SUN_STAR_DOCUMENT_XFILTER_HPP_
 #include <com/sun/star/document/XFilter.hpp>
 #endif
+#ifndef _COM_SUN_STAR_GRAPHIC_XGRAPHIC_HPP_ 
+#include <com/sun/star/graphic/XGraphic.hpp>
+#endif
+#ifndef _COM_SUN_STAR_GRAPHIC_XGRAPHICRENDERER_HPP_ 
+#include <com/sun/star/graphic/XGraphicRenderer.hpp>
+#endif
 
 #ifndef _COM_SUN_STAR_DRAWING_XSHAPE_HPP_
 #include <com/sun/star/drawing/XShape.hpp>
 #endif
 
+#ifndef _COMPHELPER_BROADCASTHELPER_HXX_
+#include <comphelper/broadcasthelper.hxx>
+#endif
+#ifndef _CPPUHELPER_COMPBASE1_HXX_
+#include <cppuhelper/compbase1.hxx>
+#endif
+
+#ifndef _COMPHELPER_UNO3_HXX_
+#include <comphelper/uno3.hxx>
+#endif
+#ifndef _CPPUHELPER_IMPLBASE1_HXX_
+#include <cppuhelper/implbase1.hxx>
+#endif
+
 #ifndef _STREAM_HXX
 #include <tools/stream.hxx>
 #endif
 #ifndef _SV_SVAPP_HXX
 #include <vcl/svapp.hxx>
 #endif
+#ifndef _SV_METAACT_HXX
+#include <vcl/metaact.hxx>
+#endif
 #ifndef _SV_VIRDEV_HXX
 #include <vcl/virdev.hxx>
 #endif
@@ -116,6 +139,12 @@
     {
         namespace
         {
+            // TODO(E2): Detect the case when svx/drawing layer is not
+            // in-process, or even not on the same machine, and
+            // fallback to metafile streaming!
+
+#if 0
+            // Conservative way: stream mtf in and out
             bool getMetaFile( const uno::Reference< lang::XComponent >& 	xSource, 
                               const uno::Reference< drawing::XDrawPage >&	xContainingPage,
                               GDIMetaFile& 									rMtf,
@@ -174,6 +203,138 @@
             
                 return aStream.GetError() == 0;
             }
+#else
+
+            typedef ::cppu::WeakComponentImplHelper1< graphic::XGraphicRenderer > DummyRenderer_Base;
+
+            class DummyRenderer : 
+                public DummyRenderer_Base,
+                public ::comphelper::OBaseMutex
+            {
+            public:
+                DummyRenderer() : 
+                    DummyRenderer_Base( m_aMutex ),
+                    mxGraphic()
+                {
+                }
+
+                //---  XGraphicRenderer  -----------------------------------
+                virtual void SAL_CALL render( const uno::Reference< graphic::XGraphic >& rGraphic ) throw (uno::RuntimeException)
+                {
+                    ::osl::MutexGuard aGuard( m_aMutex );
+                    mxGraphic = rGraphic;
+                }
+
+                GDIMetaFile getMtf() const
+                {
+                    ::osl::MutexGuard aGuard( m_aMutex );
+                    
+                    Graphic aGraphic( mxGraphic );
+
+                    if( aGraphic.GetType() == GRAPHIC_BITMAP )
+                    {
+                        // wrap bitmap into GDIMetafile
+                        GDIMetaFile 	aMtf;
+                        ::Point			aEmptyPoint;
+
+                        ::BitmapEx		aBmpEx( aGraphic.GetBitmapEx() );
+
+                        aMtf.AddAction( new MetaBmpExAction( aEmptyPoint,
+                                                             aBmpEx ) );
+                        aMtf.SetPrefSize( aBmpEx.GetPrefSize() );
+                        aMtf.SetPrefMapMode( aBmpEx.GetPrefMapMode() );
+
+                        return aMtf;
+                    }
+                    else
+                    {
+                        return aGraphic.GetGDIMetaFile();
+                    }
+                }
+
+            private:
+                // ref-counted UNO object, _we_ destroy ourselves
+                virtual ~DummyRenderer();
+
+                uno::Reference< graphic::XGraphic >	mxGraphic;
+            };
+
+            // outline, to have vtable generated here
+            DummyRenderer::~DummyRenderer()
+            {
+            }
+
+            // Quick'n'dirty way: tunnel Graphic (only works for
+            // in-process slideshow, of course)
+            bool getMetaFile( const uno::Reference< lang::XComponent >& 	xSource, 
+                              const uno::Reference< drawing::XDrawPage >&	xContainingPage,
+                              GDIMetaFile& 									rMtf,
+                              bool											bVerboseComments,
+                              bool 											bBackgroundOnly )
+            {
+                // create dummy XGraphicRenderer, which receives the
+                // generated XGraphic from the GraphicExporter
+
+                // TODO(P3): Move creation of DummyRenderer out of the
+                // loop! Either by making it static, or transforming
+                // the whole thing here into a class.
+                DummyRenderer*						 		pRenderer( new DummyRenderer() );
+                uno::Reference< graphic::XGraphicRenderer > xRenderer( pRenderer );
+
+                // -> stuff that into UnoGraphicExporter.
+                uno::Reference< lang::XMultiServiceFactory > xFactory( ::comphelper::getProcessServiceFactory() );
+                if( !xFactory.is() )
+                    return false;
+
+                // creating the graphic exporter
+                uno::Reference< document::XExporter > xExporter( xFactory->createInstance( 
+                                                                     rtl::OUString::createFromAscii("com.sun.star.drawing.GraphicExportFilter")), 
+                                                                 uno::UNO_QUERY);
+                uno::Reference< document::XFilter > xFilter( xExporter, uno::UNO_QUERY );
+
+                if( !xExporter.is() || !xFilter.is() )
+                    return false;
+
+                uno::Sequence< beans::PropertyValue > aProps(3);
+                aProps[0].Name = rtl::OUString::createFromAscii("FilterName");
+                aProps[0].Value <<= rtl::OUString::createFromAscii("SVM");
+
+                aProps[1].Name = rtl::OUString::createFromAscii("GraphicRenderer");
+                aProps[1].Value <<= xRenderer;
+
+                uno::Sequence< beans::PropertyValue > aFilterData(4);
+                aFilterData[0].Name = rtl::OUString::createFromAscii("VerboseComments");
+                aFilterData[0].Value <<= bVerboseComments;
+
+                aFilterData[1].Name = rtl::OUString::createFromAscii("ExportOnlyBackground");
+                aFilterData[1].Value <<= bBackgroundOnly;
+
+                aFilterData[2].Name = rtl::OUString::createFromAscii("Version");
+                const sal_Int32 nVersion = SOFFICE_FILEFORMAT_50; 
+                aFilterData[2].Value <<= nVersion; 
+
+                aFilterData[3].Name = rtl::OUString::createFromAscii("CurrentPage");
+                aFilterData[3].Value <<= uno::Reference< uno::XInterface >( xContainingPage,
+                                                                            uno::UNO_QUERY_THROW );
+
+                aProps[2].Name = rtl::OUString::createFromAscii("FilterData");
+                aProps[2].Value <<= aFilterData;
+
+                xExporter->setSourceDocument( xSource );
+                if( !xFilter->filter( aProps ) )
+                    return false;
+
+                rMtf = pRenderer->getMtf();
+
+                // pRenderer is automatically destroyed when xRenderer
+                // goes out of scope
+
+                // TODO(E3): Error handling. Exporter might have
+                // generated nothing, a bitmap, threw an exception,
+                // whatever.
+                return true;
+            }
+#endif
         }
 
         bool getMetaFile( const uno::Reference< drawing::XShape >& 		xShape, 
diff -u -r  slideshow/source/engine/intrinsicanimationactivity.cxx  slideshow/source/engine/intrinsicanimationactivity.cxx
---  slideshow/source/engine/intrinsicanimationactivity.cxx	2004-11-27 00:24:01.000000000 +0530
+++  slideshow/source/engine/intrinsicanimationactivity.cxx	2005-02-28 13:41:44.699316513 +0530
@@ -101,6 +101,11 @@
             mnCurrIndex = 0;
         }
 
+        double IntrinsicAnimationActivity::calcTimeLag() const
+        {
+            return 0.0;
+        }
+    
         bool IntrinsicAnimationActivity::perform()
         {
             if( !isActive() )
@@ -137,9 +142,9 @@
             return isActive();
         }
 
-        void IntrinsicAnimationActivity::end()
+        void IntrinsicAnimationActivity::dequeued()
         {
-            dispose();
+            // not used here
         }
 
     }
diff -u -r  slideshow/source/engine/layermanager.cxx  slideshow/source/engine/layermanager.cxx
---  slideshow/source/engine/layermanager.cxx	2004-11-27 00:24:25.000000000 +0530
+++  slideshow/source/engine/layermanager.cxx	2005-02-28 13:41:45.818185789 +0530
@@ -73,7 +73,7 @@
 #include <boost/mem_fn.hpp>
 #endif
 
-using namespace ::drafts::com::sun::star;
+using namespace ::com::sun::star;
 using namespace ::com::sun::star;
 
 
diff -u -r  slideshow/source/engine/mediashape.cxx  slideshow/source/engine/mediashape.cxx
---  slideshow/source/engine/mediashape.cxx	2004-11-27 00:24:48.000000000 +0530
+++  slideshow/source/engine/mediashape.cxx	2005-02-28 13:41:45.500222939 +0530
@@ -92,7 +92,7 @@
 #include <slideshowexceptions.hxx>
 #include <tools.hxx>
 
-using namespace ::drafts::com::sun::star;
+using namespace ::com::sun::star;
 using namespace ::com::sun::star;
 
 
diff -u -r  slideshow/source/engine/presentation.cxx  slideshow/source/engine/presentation.cxx
---  slideshow/source/engine/presentation.cxx	2005-01-21 22:25:44.000000000 +0530
+++  slideshow/source/engine/presentation.cxx	2005-02-28 13:41:44.932289293 +0530
@@ -144,21 +144,6 @@
 #include <basegfx/tools/canvastools.hxx>
 #endif
 
-#ifndef _SV_SVAPP_HXX 
-#include <vcl/svapp.hxx>
-#endif
-
-#ifndef BOOST_BIND_HPP_INCLUDED
-#include <boost/bind.hpp>
-#endif
-
-#include <map>
-#include <memory>
-#include <vector>
-#include <list>
-#include <iterator>
-#include <algorithm>
-
 #include <unoviewcontainer.hxx>
 #include <shapeimporter.hxx>
 #include <transitionfactory.hxx>
@@ -174,8 +159,19 @@
 #include <slidebitmap.hxx>
 #include <rehearsetimingsactivity.hxx>
 #include <waitsymbol.hxx>
+#include "comphelper/scopeguard.hxx"
+
+#include "boost/utility.hpp"
+#include <boost/bind.hpp>
+#include <map>
+#include <memory>
+#include <vector>
+#include <list>
+#include <iterator>
+#include <algorithm>
+
 
-using namespace ::drafts::com::sun::star;
+using namespace ::com::sun::star;
 using namespace ::com::sun::star;
 
 // -----------------------------------------------------------------------------
@@ -192,15 +188,16 @@
 
             struct SlideEvent : public lang::EventObject
             {
-                sal_Int32	nOldSlideIndex;
-                sal_Int32	nNewSlideIndex;
-                bool		bShowEnded;
+                sal_Int32   nOldSlideIndex;
+                sal_Int32   nNewSlideIndex;
+                bool        bShowEnded;
             };
 
             typedef ::comphelper::OListenerContainerBase< ::com::sun::star::presentation::XSlideShowListener,
-				                                          SlideEvent >   ShowListeners_Base;
+                                                          SlideEvent >   ShowListeners_Base;
 
-            class ShowListeners : public ShowListeners_Base
+            class ShowListeners : public ShowListeners_Base,
+                                  private boost::noncopyable
             {
             public:
                 ShowListeners( ::osl::Mutex& rMutex ) :
@@ -210,7 +207,7 @@
 
             protected:
                 virtual bool implNotify( const uno::Reference< ::com::sun::star::presentation::XSlideShowListener >& rListener,
-                                         const SlideEvent& 															 rEvent ) throw( uno::Exception )
+                                         const SlideEvent&                                                           rEvent ) throw( uno::Exception )
                 {
                     if( rEvent.bShowEnded )
                         rListener->showEnded();
@@ -221,7 +218,7 @@
                     return true; // continue calling listeners
                 }
             };
-            typedef ::std::auto_ptr< ShowListeners >	ShowListenersPtr; 
+            typedef ::std::auto_ptr< ShowListeners >    ShowListenersPtr; 
         }
 
 
@@ -229,15 +226,15 @@
         // Presentation_Impl declaration
         // ============================================================
 
-        class Presentation_Impl
+        class Presentation_Impl : private boost::noncopyable
         {
         public:
             Presentation_Impl( const uno::Reference< uno::XComponentContext >& xContext );
             
-			void dispose();
+            void dispose();
 
             // ==========================================================
-			// implementations of Presentation class methods
+            // implementations of Presentation class methods
             // ==========================================================
 
             bool nextEffect();
@@ -246,19 +243,19 @@
 
             bool nextSlide();
 
-			bool startShapeActivity( const uno::Reference< drawing::XShape >& xShape );
+            bool startShapeActivity( const uno::Reference< drawing::XShape >& xShape );
 
-			bool stopShapeActivity( const uno::Reference< drawing::XShape >& xShape );
+            bool stopShapeActivity( const uno::Reference< drawing::XShape >& xShape );
 
-			bool pause( bool bPauseShow );
+            bool pause( bool bPauseShow );
 
             bool displaySlide( sal_Int32 nSlideIndex );
 
             sal_Int32 getCurrentSlideIndex();
 
-            bool prefetch( const uno::Sequence< uno::Reference< drawing::XDrawPage > >& 		aSlideSequence, 
+            bool prefetch( const uno::Sequence< uno::Reference< drawing::XDrawPage > >&         aSlideSequence, 
                            const uno::Sequence< uno::Reference< animations::XAnimationNode > >& aRootNodeSequence, 
-                           const uno::Sequence< beans::PropertyValue >& 						aShowProperties );
+                           const uno::Sequence< beans::PropertyValue >&                         aShowProperties );
 
             bool setProperty( const beans::PropertyValue& aShowProperty );
 
@@ -270,19 +267,19 @@
 
             void removeSlideShowListener( const uno::Reference< ::com::sun::star::presentation::XSlideShowListener >& xListener );
 
-            void addShapeEventListener( const uno::Reference< ::com::sun::star::presentation::XShapeEventListener >& 	xListener, 
-                                        const uno::Reference< drawing::XShape >& 										xShape );
+            void addShapeEventListener( const uno::Reference< ::com::sun::star::presentation::XShapeEventListener >&    xListener, 
+                                        const uno::Reference< drawing::XShape >&                                        xShape );
 
             void removeShapeEventListener( const uno::Reference< ::com::sun::star::presentation::XShapeEventListener >& xListener, 
-                                           const uno::Reference< drawing::XShape >& 									xShape );
+                                           const uno::Reference< drawing::XShape >&                                     xShape );
 
-            void setShapeCursor( const uno::Reference< drawing::XShape >& 	xShape, 
-                                 sal_Int16 									nPointerShape );
+            void setShapeCursor( const uno::Reference< drawing::XShape >&   xShape, 
+                                 sal_Int16                                  nPointerShape );
 
             bool update( double* pNextTimeout );
 
             // ==========================================================
-			// Public methods, which are called from local helper classes
+            // Public methods, which are called from local helper classes
             // ==========================================================
 
             /** Notify that the transition phase of the current slide
@@ -328,27 +325,23 @@
 
             /** Notify that the view has changed.
 
-            	Currently, this method call denotes a change in view
-            	size and/or scaling.
+                Currently, this method call denotes a change in view
+                size and/or scaling.
              */
             void notifyViewChange();
 
             // ==========================================================
-			// Public types
+            // Public types
             // ==========================================================
 
             typedef ::std::map< uno::Reference< drawing::XShape >,
                                 ::std::vector< 
-                					uno::Reference< 
-						                ::com::sun::star::presentation::XShapeEventListener > > >	ShapeEventListenerMap;
+                                    uno::Reference< 
+                                        ::com::sun::star::presentation::XShapeEventListener > > >   ShapeEventListenerMap;
             typedef ::std::map< uno::Reference< drawing::XShape >,
-                                sal_Int16 >															ShapeCursorMap;
+                                sal_Int16 >                                                         ShapeCursorMap;
 
         private:
-            // default: disabled copy/assignment
-            Presentation_Impl(const Presentation_Impl&);
-            Presentation_Impl& operator=( const Presentation_Impl& );            
-
             /// Get current slide (empty shared_ptr if none)
             const SlideSharedPtr& getCurrentSlide() const;
 
@@ -357,38 +350,31 @@
 
             /** Show next slide, register end event
 
-            	This method is called from nextSlide() etc., and from
-            	SlideAnimationsEndEvent. It also registers an end
-            	event at the Slide to trigger the next slide.
-            	Furthermore, it broadcasts the slide change event to
-            	any XSlide
+                This method is called from nextSlide() etc., and from
+                SlideAnimationsEndEvent. It also registers an end
+                event at the Slide to trigger the next slide.
+                Furthermore, it broadcasts the slide change event to
+                any XSlide
              */
             bool showNext( sal_Int32 nPage );
 
             /// Display/hide wait symbol on all views
-            void setWaitState( bool bOn );
-            /// Display/hide pen cursor on all views
-            void setPenCursor( bool bOn );
+            void setWaitState( const bool bOn );
             /// sets mouse cursor related to flags.
             void updateMouseCursor();
 
             /** Prepare a slide transition
                 
-            	This method registers all necessary events and
-            	activities for a slide transition.
+                This method registers all necessary events and
+                activities for a slide transition.
 
                 @return the slide change activity, or NULL for no
                 transition effect
              */
-            ActivitySharedPtr createSlideTransition( const uno::Reference< drawing::XDrawPage >&	xDrawPage,
-                                                     const SlideSharedPtr& 							rLeavingSlide,
-                                                     const SlideSharedPtr& 							rEnteringSlide,
-                                                     const EventSharedPtr& 							rTransitionEndEvent,
-                                                     const ::basegfx::B2DSize& 						rEnteringSlideSize );
-
-            /** Retrieve size of given slide
-             */
-            ::basegfx::B2DSize getSlideSize( sal_Int32 nPage ) const;
+            ActivitySharedPtr createSlideTransition( const uno::Reference< drawing::XDrawPage >&    xDrawPage,
+                                                     const SlideSharedPtr&                          rLeavingSlide,
+                                                     const SlideSharedPtr&                          rEnteringSlide,
+                                                     const EventSharedPtr&                          rTransitionEndEvent );
 
             /** Create a new slide.
              */
@@ -412,8 +398,8 @@
             {
                 SlideBufferEntry() : mpSlide(), mnSlideIndex(0) {} // for proper init
 
-                SlideSharedPtr	mpSlide;
-                int				mnSlideIndex;
+                SlideSharedPtr  mpSlide;
+                int             mnSlideIndex;
             };
             
             // holds current, previous and next slide:
@@ -433,50 +419,51 @@
                 return func;
             }
 
-            typedef ::std::vector< uno::Reference< drawing::XDrawPage > > 			VectorOfDrawPages;
-            typedef ::std::vector< uno::Reference< animations::XAnimationNode > > 	VectorOfRootNodes;
+            typedef ::std::vector< uno::Reference< drawing::XDrawPage > >           VectorOfDrawPages;
+            typedef ::std::vector< uno::Reference< animations::XAnimationNode > >   VectorOfRootNodes;
 
-            VectorOfDrawPages 						maDrawPages;
-            VectorOfRootNodes						maAnimationRootNodes;
+            VectorOfDrawPages                       maDrawPages;
+            VectorOfRootNodes                       maAnimationRootNodes;
 
-            UnoViewContainer						maViewContainer;
+            UnoViewContainer                        maViewContainer;
 
-			// Mutex for mpListeners (superfluous, but the class
-			// demands it)
-			::osl::Mutex							maMutex;
-			ShowListenersPtr						mpListeners;
+            // Mutex for mpListeners (superfluous, but the class
+            // demands it)
+            ::osl::Mutex                            maMutex;
+            ShowListenersPtr                        mpListeners;
 
             /// map of vectors, containing all registered listeners for a shape
-            ShapeEventListenerMap					maShapeEventListeners;
+            ShapeEventListenerMap                   maShapeEventListeners;
             /// map of sal_Int16 values, specifying the mouse cursor for every shape
-            ShapeCursorMap							maShapeCursors;
+            ShapeCursorMap                          maShapeCursors;
 
             ::comphelper::OptionalValue< RGBColor > maUserPaintColor;
 
-			EventQueue								maEventQueue;
-            ActivitiesQueue							maActivitiesQueue;
-            EventMultiplexer						maEventMultiplexer;
-            UserEventQueue							maUserEventQueue;
+            boost::shared_ptr<canvas::tools::ElapsedTime> mpPresTimer;
+            EventQueue                              maEventQueue;
+            ActivitiesQueue                         maActivitiesQueue;
+            EventMultiplexer                        maEventMultiplexer;
+            UserEventQueue                          maUserEventQueue;
             
-            ::comphelper::OptionalValue< double > 	maAutomaticAdvancementTimeout;
+            ::comphelper::OptionalValue< double >   maAutomaticAdvancementTimeout;
             boost::shared_ptr<RehearseTimingsActivity> mrehearseTimingsActivity;
             boost::shared_ptr<WaitSymbol>           mwaitSymbol;
             
-            uno::Reference<uno::XComponentContext>	mxComponentContext;
+            uno::Reference<uno::XComponentContext>  mxComponentContext;
 
             bool                                    mbWaitState;
-            bool                                    mbPenCursor;
-            bool									mbImageAnimationsAllowed;
-			bool									mbNoSlideTransitions;
-            bool 									mbMouseVisible;
-            bool									mbForceManualAdvance;
-			bool									mbShowPaused;
+            bool                                    mbImageAnimationsAllowed;
+            bool                                    mbNoSlideTransitions;
+            bool                                    mbMouseVisible;
+            bool                                    mbForceManualAdvance;
+            bool                                    mbShowPaused;
         };
 
 
         namespace
         {
-            class SlideViewLayer : public ViewLayer
+            class SlideViewLayer : public ViewLayer,
+                                   private boost::noncopyable
             {
             public:
                 SlideViewLayer( const ::cppcanvas::SpriteCanvasSharedPtr& rCanvas ) :
@@ -506,20 +493,21 @@
                 }
 
             private:
-                ::cppcanvas::SpriteCanvasSharedPtr	mpCanvas;
+                ::cppcanvas::SpriteCanvasSharedPtr  mpCanvas;
             };
 
-            class SlideView : public UnoView
+            class SlideView : public UnoView,
+                              private boost::noncopyable
             {
             public:
                 /** Create View implementation.
 
-		        	@param xView
+                    @param xView
                     View to render to.
                 */
                 SlideView( const uno::Reference< ::com::sun::star::presentation::XSlideShowView >& xView,
-                           EventQueue&															   rEventQueue,
-                           Presentation_Impl&												   	   rPresentation );
+                           EventQueue&                                                             rEventQueue,
+                           Presentation_Impl&                                                      rPresentation );
                 ~SlideView();
 
                 virtual ViewLayerSharedPtr createViewLayer() const;
@@ -542,28 +530,29 @@
 
                 /** Listener class, implementing all functionality
 
-                	Because we have to mix shared_ptr and
-                	uno::Reference at the SlideView class (shared_ptr
-                	for the View interface, uno::Reference semantics
-                	for the listeners), we have to use that proverbial
-                	extra level of indirection here. The SlideView
-                	delegates all methods to this Listener object,
-                	itself holding only an ::rtl::Reference to
-                	it. When the SlideShow is deleted, it disposes the
-                	Listener, and releasing its reference.
+                    Because we have to mix shared_ptr and
+                    uno::Reference at the SlideView class (shared_ptr
+                    for the View interface, uno::Reference semantics
+                    for the listeners), we have to use that proverbial
+                    extra level of indirection here. The SlideView
+                    delegates all methods to this Listener object,
+                    itself holding only an ::rtl::Reference to
+                    it. When the SlideShow is deleted, it disposes the
+                    Listener, and releasing its reference.
                  */
                 class Listener : public ::comphelper::OBaseMutex,
-                                 public SlideViewListener_Base
+                                 public SlideViewListener_Base,
+                                 private boost::noncopyable
                 {
                 public:
                     /** Create Listener implementation.
 
-		        		@param xView
-	                    View to render to.
+                        @param xView
+                        View to render to.
                     */
                     Listener( const uno::Reference< ::com::sun::star::presentation::XSlideShowView >& xView,
-                              EventQueue&															  rEventQueue,
-                              Presentation_Impl&												  	  rPresentation ) :
+                              EventQueue&                                                             rEventQueue,
+                              Presentation_Impl&                                                      rPresentation ) :
                         SlideViewListener_Base( m_aMutex ),
                         mxView( xView ),
                         mpCanvas(),
@@ -805,7 +794,7 @@
                     }
 
                 protected:
-                    ~Listener() {} // ref-counted UNO object, we self-destruct
+                    virtual ~Listener() {} // ref-counted UNO object, we self-destruct
 
                 private:
                     void updateCanvas()
@@ -850,30 +839,30 @@
                             mpCanvas->setClip( pPolyPoly );
                     }
 
-                    uno::Reference< ::com::sun::star::presentation::XSlideShowView >	mxView;
-                    ::cppcanvas::SpriteCanvasSharedPtr									mpCanvas;
+                    uno::Reference< ::com::sun::star::presentation::XSlideShowView >    mxView;
+                    ::cppcanvas::SpriteCanvasSharedPtr                                  mpCanvas;
 
-                    EventQueue&															mrEventQueue;
-                    Presentation_Impl&													mrPresentation;
+                    EventQueue&                                                         mrEventQueue;
+                    Presentation_Impl&                                                  mrPresentation;
 
-                    const ::basegfx::B2DPolygon											maUnitRectPoly;
-                    ::basegfx::B2DPolyPolygon											maClip;
+                    const ::basegfx::B2DPolygon                                         maUnitRectPoly;
+                    ::basegfx::B2DPolyPolygon                                           maClip;
 
-                    ::basegfx::B2DHomMatrix												maViewTransform;
-                    ::basegfx::B2DSize													maUserSize;
+                    ::basegfx::B2DHomMatrix                                             maViewTransform;
+                    ::basegfx::B2DSize                                                  maUserSize;
 
-                    mutable bool														mbContentValid;
+                    mutable bool                                                        mbContentValid;
                 };
 
                 typedef ::rtl::Reference< Listener > ListenerRef;
                 
                 // Ref-counted Listener
-                ListenerRef			mpListener;
+                ListenerRef         mpListener;
             };
 
             SlideView::SlideView( const uno::Reference< ::com::sun::star::presentation::XSlideShowView >&  xView,
-                                  EventQueue&															   rEventQueue,
-                                  Presentation_Impl&												   	   rPresentation ) :
+                                  EventQueue&                                                              rEventQueue,
+                                  Presentation_Impl&                                                       rPresentation ) :
                 mpListener( new Listener( xView, rEventQueue, rPresentation ) )
             {
                 ENSURE_AND_THROW( mpListener.is(),
@@ -953,16 +942,17 @@
 
             /** Event handler for slide end events.
 
-            	This handler is registered for slide animation end
-            	events at the global EventMultiplexer, and internally
-            	queues an event that in turn calls
-            	Presentation_Impl::notifySlideAnimationsEnded()
+                This handler is registered for slide animation end
+                events at the global EventMultiplexer, and internally
+                queues an event that in turn calls
+                Presentation_Impl::notifySlideAnimationsEnded()
              */
-            class SlideAnimationsEndHandler : public EventHandler
+            class SlideAnimationsEndHandler : public EventHandler,
+                                              private boost::noncopyable
             {
             public:
                 SlideAnimationsEndHandler( Presentation_Impl& rPresentation,
-                                           EventQueue&   	  rEventQueue ) :
+                                           EventQueue&        rEventQueue ) :
                     mrPresentation( rPresentation ),
                     mrEventQueue( rEventQueue )
                 {
@@ -989,9 +979,9 @@
 
             private:
                 Presentation_Impl&  mrPresentation;
-                EventQueue&   	  	mrEventQueue;
+                EventQueue&         mrEventQueue;
             };
-		}
+        }
 
 
         //
@@ -1003,35 +993,35 @@
             maDrawPages(),
             maAnimationRootNodes(),
             maViewContainer(),
-			maMutex(),
-			mpListeners( new ShowListeners( maMutex ) ),
+            maMutex(),
+            mpListeners( new ShowListeners( maMutex ) ),
             maShapeEventListeners(),
             maShapeCursors(),
             maUserPaintColor(),
-            maEventQueue(),
-            maActivitiesQueue( maViewContainer ),
+            mpPresTimer( new canvas::tools::ElapsedTime ),
+            maEventQueue( mpPresTimer ),
+            maActivitiesQueue( mpPresTimer, maViewContainer ),
             maEventMultiplexer( maEventQueue ),
             maUserEventQueue( maEventMultiplexer,
                               maEventQueue ),
             maAutomaticAdvancementTimeout(),
             mxComponentContext( xContext ),
             mbWaitState(false),
-            mbPenCursor(false),
             mbImageAnimationsAllowed( true ),
-			mbNoSlideTransitions( false ),
+            mbNoSlideTransitions( false ),
             mbMouseVisible( true ),
             mbForceManualAdvance( false ),
             mrehearseTimingsActivity(),
             mwaitSymbol(),
-			mbShowPaused( false )
+            mbShowPaused( false )
         {
             maEventMultiplexer.addSlideAnimationsEndHandler( 
                 EventHandlerSharedPtr( new SlideAnimationsEndHandler( *this,
                                                                       maEventQueue ) ) );
         }
 
-		void Presentation_Impl::dispose()
-		{
+        void Presentation_Impl::dispose()
+        {
             mxComponentContext.clear();
 
             if (mwaitSymbol.get() != 0) {
@@ -1040,39 +1030,38 @@
             }
             
             if (mrehearseTimingsActivity.get() != 0) {
-                mrehearseTimingsActivity->end();
+                mrehearseTimingsActivity->dispose();
                 mrehearseTimingsActivity.reset();
             }
             
-			maUserEventQueue.clear();
+            maUserEventQueue.clear();
             maEventMultiplexer.clear();
-			maActivitiesQueue.clear();
-			maEventQueue.clear();
+            maActivitiesQueue.clear();
+            maEventQueue.clear();
 
             maShapeCursors.clear();
-			mpListeners.reset();
+            mpListeners.reset();
 
-			maViewContainer.clear();
-			maAnimationRootNodes.clear();
-			maDrawPages.clear();
+            maViewContainer.clear();
+            maAnimationRootNodes.clear();
+            maDrawPages.clear();
             
-            for_each_buffered_slide(
-                boost::mem_fn<void, SlideSharedPtr>( &SlideSharedPtr::reset ) );
-		}
+            for( std::size_t pos = 0; pos < SLIDE_BUFFER_SIZE; ++pos )
+                maSlideBuffer[pos].mpSlide.reset();
+        }
 
         ActivitySharedPtr Presentation_Impl::createSlideTransition( const uno::Reference< drawing::XDrawPage >& xDrawPage,
-                                                                    const SlideSharedPtr& 						rLeavingSlide,
-                                                                    const SlideSharedPtr& 						rEnteringSlide,
-                                                                    const EventSharedPtr& 						rTransitionEndEvent,
-                                                                    const ::basegfx::B2DSize& 					rEnteringSlideSize )
+                                                                    const SlideSharedPtr&                       rLeavingSlide,
+                                                                    const SlideSharedPtr&                       rEnteringSlide,
+                                                                    const EventSharedPtr&                       rTransitionEndEvent )
         {
             ENSURE_AND_THROW( !maViewContainer.empty(),
                               "Presentation_Impl::createSlideTransition(): No views" );
 
-			// return empty transition, if slide transitions
-			// are disabled.
-			if( mbNoSlideTransitions )
-				return ActivitySharedPtr();
+            // return empty transition, if slide transitions
+            // are disabled.
+            if( mbNoSlideTransitions )
+                return ActivitySharedPtr();
 
             // retrieve slide change parameters from XDrawPage
             uno::Reference< beans::XPropertySet > xPropSet( xDrawPage,
@@ -1153,8 +1142,9 @@
             {
                 try
                 {
-                    pSoundPlayer.reset( new SoundPlayer(aSoundURL,
-                                                        mxComponentContext) );
+                    pSoundPlayer = SoundPlayer::create( maEventMultiplexer,
+                                                        aSoundURL,
+                                                        mxComponentContext);
                 }
                 catch( lang::NoSupportException& ) 
                 {
@@ -1168,8 +1158,6 @@
             SlideChangeAnimationSharedPtr pTransition( 
                 TransitionFactory::createSlideTransition( rLeavingSlide,
                                                           rEnteringSlide,
-                                                          maViewContainer,
-                                                          rEnteringSlideSize,
                                                           nTransitionType,
                                                           nTransitionSubType,
                                                           bTransitionDirection,
@@ -1223,24 +1211,6 @@
                     true ) );
         }
 
-        ::basegfx::B2DSize Presentation_Impl::getSlideSize( sal_Int32 nPage ) const
-        {
-            ENSURE_AND_THROW( 0 <= nPage && static_cast<int>(maDrawPages.size()) > nPage,
-                              "Presentation_Impl::getSlideSize(): Index out of range" );
-
-            const uno::Reference< drawing::XDrawPage >& xDrawPage( maDrawPages[ nPage ] );            
-            uno::Reference< beans::XPropertySet > xPropSet( xDrawPage, 
-                                                            uno::UNO_QUERY_THROW );
-
-            sal_Int32 nDocWidth;
-            sal_Int32 nDocHeight;
-            xPropSet->getPropertyValue( ::rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Width") ) ) >>= nDocWidth;
-            xPropSet->getPropertyValue( ::rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Height") ) ) >>= nDocHeight;
-
-            return ::basegfx::B2DSize( nDocWidth,
-                                       nDocHeight );
-        }
-
         namespace
         {
             class ShapeListenerRegisterer
@@ -1262,7 +1232,7 @@
                 }
 
             private:
-                SlideSharedPtr&	mrSlide;
+                SlideSharedPtr& mrSlide;
             };
         }
 
@@ -1271,14 +1241,14 @@
             ENSURE_AND_THROW( 0 <= nPage && static_cast<int>(maDrawPages.size()) > nPage,
                               "Presentation_Impl::createSlide(): Index out of range" );
 
-			ENSURE_AND_THROW( 0 <= nPage && static_cast<int>(maAnimationRootNodes.size()) > nPage,
+            ENSURE_AND_THROW( 0 <= nPage && static_cast<int>(maAnimationRootNodes.size()) > nPage,
                               "Presentation_Impl::createSlide(): Index out of range" );
 
             const uno::Reference< drawing::XDrawPage >& xDrawPage( maDrawPages[ nPage ] );
 
-			const uno::Reference< animations::XAnimationNode >& xRootNode( maAnimationRootNodes[nPage] );
+            const uno::Reference< animations::XAnimationNode >& xRootNode( maAnimationRootNodes[nPage] );
 
-			if( !xDrawPage.is() )
+            if( !xDrawPage.is() )
                 return SlideSharedPtr(); 
 
             SlideSharedPtr pSlide( new Slide( xDrawPage, xRootNode,
@@ -1433,12 +1403,6 @@
             return maSlideBuffer[PREVIOUS_SLIDE].mpSlide;
         }
 
-        void Presentation_Impl::setPenCursor( const bool bOn )
-        {
-            mbPenCursor = bOn;
-            updateMouseCursor();
-        }
-    
         void Presentation_Impl::setWaitState( const bool bOn )
         {
             mbWaitState = bOn;
@@ -1468,8 +1432,8 @@
             if( maViewContainer.empty() )
                 return false;
 
-			if( !mpListeners.get() )
-				return false; // we're disposed
+            if( !mpListeners.get() )
+                return false; // we're disposed
 
             // check range:
             // ============
@@ -1492,18 +1456,25 @@
             bool bRet( false );
 
             // this here might take some time
-            setWaitState(true);
             {
+                const comphelper::ScopeGuard guard_(
+                    boost::bind( &Presentation_Impl::setWaitState,
+                                 this, false ) );
+                setWaitState(true);
+                
                 if( prefetchSlide( nPage ) )
                 {
-                    ::basegfx::B2DSize aSlideSize( getSlideSize( nPage ) );
-
+                    const basegfx::B2ISize slideSize_(
+                        getCurrentSlide()->getSlideSize() );
+                    const basegfx::B2DSize slideSize( slideSize_.getX(),
+                                                      slideSize_.getY() );
+                    
                     // push new transformation to all views
-                    ::std::for_each( maViewContainer.begin(),
-                                     maViewContainer.end(),
-                                     ::boost::bind(&View::setViewSize,
-                                                   _1,
-                                                   ::boost::cref( aSlideSize ) ) );
+                    ::std::for_each(
+                        maViewContainer.begin(),
+                        maViewContainer.end(),
+                        ::boost::bind(&View::setViewSize,
+                                      _1, ::boost::cref( slideSize ) ) );
                     
                     // explicitly notify view change here,
                     // because transformation might have changed:
@@ -1514,20 +1485,21 @@
                     if (mwaitSymbol.get() != 0)
                         mwaitSymbol->notifyViewChange();
                     
-                    EventSharedPtr pTransitionEndEvent(                                        
-                        makeEvent( ::boost::bind( &Presentation_Impl::notifySlideTransitionEnded,
-                                                  ::boost::ref( *this ) ) ) );
-
-
+                    EventSharedPtr pTransitionEndEvent(
+                        makeEvent(
+                            boost::bind(
+                                &Presentation_Impl::notifySlideTransitionEnded,
+                                this ) ) );
+                    
                     // create slide transition, and add proper end event 
-                    // (which then starts the slide effects via CURRENT_SLIDE.show())
+                    // (which then starts the slide effects
+                    // via CURRENT_SLIDE.show())
                     ActivitySharedPtr pSlideChangeActivity( 
                         createSlideTransition( maDrawPages[ nPage ],
                                                getPreviousSlide(),
                                                getCurrentSlide(),
-                                               pTransitionEndEvent,
-                                               aSlideSize ) );
-
+                                               pTransitionEndEvent ) );
+                    
                     if( pSlideChangeActivity.get() )
                     {
                         // factory generated a slide transition - activate it!
@@ -1539,12 +1511,11 @@
                         // effect start event right away.
                         maEventQueue.addEvent( pTransitionEndEvent );
                     }
-
+                    
                     bRet = true;
                 }
-            }
-            setWaitState(false);
-
+            } // finally
+            
             return bRet;
         }
 
@@ -1583,29 +1554,36 @@
 
         bool Presentation_Impl::nextEffect()
         {
-			if( !mbShowPaused )
-				return maEventMultiplexer.notifyNextEffect();
-			else
-				return true;
-        }
-
-		bool Presentation_Impl::startShapeActivity( const uno::Reference< drawing::XShape >& xShape )
-		{
-			// TODO(F3): NYI
-			return false;
-		}
-
-		bool Presentation_Impl::stopShapeActivity( const uno::Reference< drawing::XShape >& xShape )
-		{
-			// TODO(F3): NYI
-			return false;
-		}
-
-		bool Presentation_Impl::pause( bool bPauseShow )
-		{
-			mbShowPaused = bPauseShow;
-			return true;
-		}
+            if( !mbShowPaused )
+                return maEventMultiplexer.notifyNextEffect();
+            else
+                return true;
+        }
+
+        bool Presentation_Impl::startShapeActivity( const uno::Reference< drawing::XShape >& xShape )
+        {
+            // TODO(F3): NYI
+            return false;
+        }
+
+        bool Presentation_Impl::stopShapeActivity( const uno::Reference< drawing::XShape >& xShape )
+        {
+            // TODO(F3): NYI
+            return false;
+        }
+
+        bool Presentation_Impl::pause( bool bPauseShow )
+        {
+            if (bPauseShow)
+                mpPresTimer->pauseTimer();
+            else
+                mpPresTimer->continueTimer();
+
+            maEventMultiplexer.notifyPauseMode(bPauseShow);
+            
+            mbShowPaused = bPauseShow;
+            return true;
+        }
 
         bool Presentation_Impl::previousSlide()
         {
@@ -1642,9 +1620,9 @@
             return maSlideBuffer[CURRENT_SLIDE].mnSlideIndex;
         }
 
-        bool Presentation_Impl::prefetch( const uno::Sequence< uno::Reference< drawing::XDrawPage > >& 			aSlideSequence, 
-                                          const uno::Sequence< uno::Reference< animations::XAnimationNode > >& 	aRootNodeSequence, 
-                                          const uno::Sequence< beans::PropertyValue >& 							aShowProperties )
+        bool Presentation_Impl::prefetch( const uno::Sequence< uno::Reference< drawing::XDrawPage > >&          aSlideSequence, 
+                                          const uno::Sequence< uno::Reference< animations::XAnimationNode > >&  aRootNodeSequence, 
+                                          const uno::Sequence< beans::PropertyValue >&                          aShowProperties )
         {
             stopShow();
             
@@ -1664,9 +1642,9 @@
             // process properties
             // ------------------
 
-			// clear set-only properties (the property can only
-			// be _set_ via the API, not cleared)
-			mbNoSlideTransitions = false;
+            // clear set-only properties (the property can only
+            // be _set_ via the API, not cleared)
+            mbNoSlideTransitions = false;
 
             for( sal_Int32 i=0, nLen=aShowProperties.getLength(); i<nLen; ++i )
             {
@@ -1723,12 +1701,13 @@
             // initialize view content
             // =======================
 
-            const sal_Int32 nCurrSlide( getCurrentSlideIndex() );
-            if( nCurrSlide != -1 )
+            if (getCurrentSlide().get() != 0)
             {
                 // set view transformation
-                ::basegfx::B2DSize aSlideSize( getSlideSize( nCurrSlide ) );
-                pView->setViewSize( aSlideSize );
+                const basegfx::B2ISize slideSize =
+                    getCurrentSlide()->getSlideSize();
+                pView->setViewSize( basegfx::B2DSize( slideSize.getX(),
+                                                      slideSize.getY() ) );
             }
 
             // clear view area (since its newly added, 
@@ -1875,7 +1854,7 @@
                 }
                 else if (mrehearseTimingsActivity.get() != 0) {
                     // removes timer from all views:
-                    mrehearseTimingsActivity->end();
+                    mrehearseTimingsActivity->dispose();
                     mrehearseTimingsActivity.reset();
                 }
                 
@@ -1904,18 +1883,18 @@
 
         void Presentation_Impl::addSlideShowListener( const uno::Reference< ::com::sun::star::presentation::XSlideShowListener >& xListener )
         {
-			if( mpListeners.get() )
-				mpListeners->addListener( xListener );
+            if( mpListeners.get() )
+                mpListeners->addListener( xListener );
         }
 
         void Presentation_Impl::removeSlideShowListener( const uno::Reference< ::com::sun::star::presentation::XSlideShowListener >& xListener )
         {
-			if( mpListeners.get() )
-				mpListeners->removeListener( xListener );
+            if( mpListeners.get() )
+                mpListeners->removeListener( xListener );
         }
 
         void Presentation_Impl::addShapeEventListener( const uno::Reference< ::com::sun::star::presentation::XShapeEventListener >& xListener, 
-                                                       const uno::Reference< drawing::XShape >& 									xShape )
+                                                       const uno::Reference< drawing::XShape >&                                     xShape )
         {
             ShapeEventListenerMap::iterator aIter;
             if( (aIter=maShapeEventListeners.find( xShape )) == maShapeEventListeners.end() )
@@ -1940,14 +1919,14 @@
                     _1, boost::cref(xListener), boost::cref(xShape) ) );
         }
 
-        void Presentation_Impl::removeShapeEventListener( const uno::Reference< ::com::sun::star::presentation::XShapeEventListener >& 	xListener, 
-                                                          const uno::Reference< drawing::XShape >& 										xShape )
+        void Presentation_Impl::removeShapeEventListener( const uno::Reference< ::com::sun::star::presentation::XShapeEventListener >&  xListener, 
+                                                          const uno::Reference< drawing::XShape >&                                      xShape )
         {
             ShapeEventListenerMap::iterator aIter;
             if( (aIter=maShapeEventListeners.find( xShape )) != maShapeEventListeners.end() )
             {
                 // entry for this shape found -> remove listener from the list
-                ShapeEventListenerMap::value_type::second_type::iterator 	   aListener( aIter->second.end() );
+                ShapeEventListenerMap::value_type::second_type::iterator       aListener( aIter->second.end() );
                 const ShapeEventListenerMap::value_type::second_type::iterator aEnd( aIter->second.end() );
                 if( (aListener=::std::remove( aIter->second.begin(), 
                                           aEnd, 
@@ -1965,8 +1944,8 @@
                     _1, boost::cref(xListener), boost::cref(xShape) ) );
         }
 
-        void Presentation_Impl::setShapeCursor( const uno::Reference< drawing::XShape >& 	xShape, 
-                                                sal_Int16 									nPointerShape )
+        void Presentation_Impl::setShapeCursor( const uno::Reference< drawing::XShape >&    xShape, 
+                                                sal_Int16                                   nPointerShape )
         {            
             ShapeCursorMap::iterator aIter;
             if( (aIter=maShapeCursors.find( xShape )) == maShapeCursors.end() )
@@ -1996,44 +1975,72 @@
 
         bool Presentation_Impl::update( double* pTimeoutForNextCall )
         {
-			if( mbShowPaused )
-			{
-				// TODO(F2): This clearly does not perform
-				// the expected, since the animation times keep
-				// running. Must somehow 'stop' a global clock 
-				// here. If at all possible, combine that with 
-				// the problem of SMIL parent nodes timing affecting
-				// their children.
-				if( pTimeoutForNextCall )
-					*pTimeoutForNextCall = 0.1;
-			}
-			else
-			{
-				// process queues:
-	            maEventQueue.process(pTimeoutForNextCall);
-		        maActivitiesQueue.process();
-                
-                if (maActivitiesQueue.isEmpty())
+            if( mbShowPaused )
+            {
+                if( pTimeoutForNextCall )
+                    *pTimeoutForNextCall = 0.1; // come back soon
+            }
+            else
+            {
+                double nNextEventTime(0.1);
+
+                // hold timer, while processing the queues (ensures
+                // same time for all activities and events)
+                {
+                    const comphelper::ScopeGuard guard(
+                        boost::bind( &canvas::tools::ElapsedTime::releaseTimer,
+                                     mpPresTimer ) );
+                    mpPresTimer->holdTimer();            
+                    
+                    // process queues:
+                    nNextEventTime = maEventQueue.process();
+                    maActivitiesQueue.process();
+                }
+                // Time held until here
+
+
+                // calc pTimeoutForNextCall value
+                // ==============================
+
+                if( pTimeoutForNextCall )
                 {
-                    if (maUserEventQueue.isEmpty())
+                    if (maActivitiesQueue.isEmpty())
                     {
-                        if (maEventQueue.isEmpty()) {
+                        const bool bNoUserEvents( maUserEventQueue.isEmpty() );
+                        const bool bNoTimerEvents( maEventQueue.isEmpty() );
+
+                        if (bNoTimerEvents && bNoUserEvents)
+                        {
                             // all queues empty, can safely exit:
                             return false;
                         }
+
+                        // [user] events left: set sleep time either to
+                        // 0.1 minimum, if user events are pending, or to
+                        // the difference from current time (nota bene:
+                        // time no longer held here!) to the next event in
+                        // the event queue.
+                        
+                        // ensure positive value
+                        *pTimeoutForNextCall = 
+                            ::std::max( 0.0,  
+                                        nNextEventTime - mpPresTimer->getElapsedTime() );
+
+                        // if we have user events pending, come back at
+                        // least every 0.1 seconds.
+                        if (!bNoUserEvents)
+                        {
+                            *pTimeoutForNextCall = 
+                                ::std::min<double>( *pTimeoutForNextCall,
+                                                    0.1 );
+                        }
                     }
-                    // [user] events left:
-                    else if (pTimeoutForNextCall != 0) {
-                        *pTimeoutForNextCall = std::min<double>(
-                            *pTimeoutForNextCall,
-                            0.1 /* next check for user event posted to
-                                   event queue */ );
+                    else
+                    {
+                        // activities left: requires immediate updates
+                        *pTimeoutForNextCall = 0.0; // come back ASAP
                     }
                 }
-                else if (pTimeoutForNextCall != 0) {
-                    // activies left: require immediate updates
-                    *pTimeoutForNextCall = 0.0; // ASAP
-                }
             }
             
             return true; // keep on calling me
@@ -2113,20 +2120,24 @@
             // prepare the initial slide bitmap (speeds up slide
             // change setup time a lot). Show the wait cursor, this
             // indeed might take some seconds.
-            setWaitState(true);
-
-            prefetchNextSlides();
-            if( !maViewContainer.empty() &&
-                maSlideBuffer[NEXT_SLIDE].mpSlide.get() )
             {
-                // ignore return value, this is just to populate
-                // Slide's internal bitmap buffer, such that the time
-                // needed to generate the slide bitmap is not spent
-                // when the slide change is requested.
-                maSlideBuffer[NEXT_SLIDE].mpSlide->getCurrentSlideBitmap( *maViewContainer.begin() );
-            }
-
-            setWaitState(false);
+                const comphelper::ScopeGuard guard_(
+                    boost::bind( &Presentation_Impl::setWaitState, this,
+                                 false ) );
+                setWaitState(true);
+                
+                prefetchNextSlides();
+                if( !maViewContainer.empty() &&
+                    maSlideBuffer[NEXT_SLIDE].mpSlide.get() )
+                {
+                    // ignore return value, this is just to populate
+                    // Slide's internal bitmap buffer, such that the time
+                    // needed to generate the slide bitmap is not spent
+                    // when the slide change is requested.
+                    maSlideBuffer[NEXT_SLIDE].mpSlide->getCurrentSlideBitmap(
+                        *maViewContainer.begin() );
+                }
+            } // finally
         }
 
         void Presentation_Impl::notifySlideEnded()
@@ -2167,38 +2178,38 @@
             if( getCurrentSlideIndex()+1 < static_cast<sal_Int32>(maDrawPages.size()) )
             {
                 nextSlide(); // MUST call that: results in
-                		 	 // maUserEventQueue.clear(). See
-                		 	 // nextSlide inline comments. What's
-                		 	 // more, stopShow()'s currSlide->end()
-                		 	 // call is now also required,
-                		 	 // notifySlideEnded() relies on that
-                		 	 // unconditionally. Otherwise, genuine
-                		 	 // shape // animations (drawing layer and
-                		 	 // GIF) will not be stopped.
+                             // maUserEventQueue.clear(). See
+                             // nextSlide inline comments. What's
+                             // more, stopShow()'s currSlide->end()
+                             // call is now also required,
+                             // notifySlideEnded() relies on that
+                             // unconditionally. Otherwise, genuine
+                             // shape // animations (drawing layer and
+                             // GIF) will not be stopped.
             }
             else
             {
                 stopShow();  // MUST call that: results in
-                		 	 // maUserEventQueue.clear(). What's more,
-                		 	 // stopShow()'s currSlide->end() call is
-                		 	 // now also required, notifySlideEnded()
-                		 	 // relies on that
-                		 	 // unconditionally. Otherwise, genuine
-                		 	 // shape animations (drawing layer and
-                		 	 // GIF) will not be stopped.
+                             // maUserEventQueue.clear(). What's more,
+                             // stopShow()'s currSlide->end() call is
+                             // now also required, notifySlideEnded()
+                             // relies on that
+                             // unconditionally. Otherwise, genuine
+                             // shape animations (drawing layer and
+                             // GIF) will not be stopped.
 
                 // we've reached the last slide: broadcast a show
                 // ended event
-				SlideEvent aEvent;
-				aEvent.bShowEnded = true;
+                SlideEvent aEvent;
+                aEvent.bShowEnded = true;
 
                 // TODO(T2): Attention, this is not thread safe. We're 
                 // calling out listeners with locked mutex!
-				mpListeners->notify( aEvent );
+                mpListeners->notify( aEvent );
 
                 // force default cursor here:
                 maEventMultiplexer.setMouseCursor( awt::SystemPointer::ARROW );
-			}
+            }
         }
 
         void Presentation_Impl::notifyViewChange()
@@ -2231,13 +2242,13 @@
     {
     }
 
-	void Presentation::dispose()
-	{
+    void Presentation::dispose()
+    {
         ENSURE_AND_THROW( mpImpl.get(),
                           "Presentation: pImpl is NULL" );
 
         mpImpl->dispose();
-	}
+    }
 
     bool Presentation::nextEffect()
     {
@@ -2247,29 +2258,29 @@
         return mpImpl->nextEffect();
     }
 
-	bool Presentation::startShapeActivity( const uno::Reference< drawing::XShape >& xShape )
-	{
+    bool Presentation::startShapeActivity( const uno::Reference< drawing::XShape >& xShape )
+    {
         ENSURE_AND_THROW( mpImpl.get(),
                           "Presentation: pImpl is NULL" );
-		
-		return mpImpl->startShapeActivity( xShape );
-	}
+        
+        return mpImpl->startShapeActivity( xShape );
+    }
 
-	bool Presentation::stopShapeActivity( const uno::Reference< drawing::XShape >& xShape )
-	{
+    bool Presentation::stopShapeActivity( const uno::Reference< drawing::XShape >& xShape )
+    {
         ENSURE_AND_THROW( mpImpl.get(),
                           "Presentation: pImpl is NULL" );
-		
-		return mpImpl->stopShapeActivity( xShape );
-	}
+        
+        return mpImpl->stopShapeActivity( xShape );
+    }
 
-	bool Presentation::pause( bool bPauseShow )
-	{
+    bool Presentation::pause( bool bPauseShow )
+    {
         ENSURE_AND_THROW( mpImpl.get(),
                           "Presentation: pImpl is NULL" );
-		
-		return mpImpl->pause( bPauseShow );
-	}
+        
+        return mpImpl->pause( bPauseShow );
+    }
 
     bool Presentation::previousSlide()
     {
@@ -2303,9 +2314,9 @@
         return mpImpl->getCurrentSlideIndex();
     }
 
-    bool Presentation::prefetch( const uno::Sequence< uno::Reference< drawing::XDrawPage > >& 			aSlideSequence, 
-                                 const uno::Sequence< uno::Reference< animations::XAnimationNode > >& 	aRootNodeSequence, 
-                                 const uno::Sequence< beans::PropertyValue >& 							aShowProperties )
+    bool Presentation::prefetch( const uno::Sequence< uno::Reference< drawing::XDrawPage > >&           aSlideSequence, 
+                                 const uno::Sequence< uno::Reference< animations::XAnimationNode > >&   aRootNodeSequence, 
+                                 const uno::Sequence< beans::PropertyValue >&                           aShowProperties )
     {
         ENSURE_AND_THROW( mpImpl.get(),
                           "Presentation: pImpl is NULL" );
@@ -2355,8 +2366,8 @@
         mpImpl->removeSlideShowListener( xListener );
     }
 
-    void Presentation::addShapeEventListener( const uno::Reference< ::com::sun::star::presentation::XShapeEventListener >& 	xListener,
-                                              const uno::Reference< drawing::XShape >& 										xShape )
+    void Presentation::addShapeEventListener( const uno::Reference< ::com::sun::star::presentation::XShapeEventListener >&  xListener,
+                                              const uno::Reference< drawing::XShape >&                                      xShape )
     {
         ENSURE_AND_THROW( mpImpl.get(),
                           "Presentation: pImpl is NULL" );
@@ -2365,8 +2376,8 @@
                                        xShape );
     }
 
-    void Presentation::removeShapeEventListener( const uno::Reference< ::com::sun::star::presentation::XShapeEventListener >& 	xListener, 
-                                                 const uno::Reference< drawing::XShape >& 										xShape )
+    void Presentation::removeShapeEventListener( const uno::Reference< ::com::sun::star::presentation::XShapeEventListener >&   xListener, 
+                                                 const uno::Reference< drawing::XShape >&                                       xShape )
     {
         ENSURE_AND_THROW( mpImpl.get(),
                           "Presentation: pImpl is NULL" );
@@ -2376,7 +2387,7 @@
     }
 
     void Presentation::setShapeCursor( const uno::Reference< drawing::XShape >& xShape, 
-                                       sal_Int16 								nPointerShape )
+                                       sal_Int16                                nPointerShape )
     {
         ENSURE_AND_THROW( mpImpl.get(),
                           "Presentation: pImpl is NULL" );
diff -u -r  slideshow/source/engine/rehearsetimingsactivity.cxx  slideshow/source/engine/rehearsetimingsactivity.cxx
---  slideshow/source/engine/rehearsetimingsactivity.cxx	2005-01-27 19:46:22.000000000 +0530
+++  slideshow/source/engine/rehearsetimingsactivity.cxx	2005-02-28 13:41:44.749310672 +0530
@@ -71,13 +71,13 @@
 #include "activitiesqueue.hxx"
 #include "mouseeventhandler.hxx"
 #include "rehearsetimingsactivity.hxx"
-#include "drafts/com/sun/star/rendering/XCanvas.hpp"
-#include "drafts/com/sun/star/rendering/XBitmap.hpp"
+#include <com/sun/star/rendering/XCanvas.hpp>
+#include <com/sun/star/rendering/XBitmap.hpp>
 #include "boost/bind.hpp"
 #include <algorithm>
 
 
-using namespace ::drafts::com::sun::star;
+using namespace ::com::sun::star;
 using namespace ::com::sun::star;
 using namespace ::com::sun::star::uno;
 
@@ -95,11 +95,12 @@
       m_rEventMultiplexer(rEventMultiplexer),
       m_rActivitiesQueue(rActivitiesQueue),
       m_this(),
-      m_elapsedTime(),
+      m_elapsedTime( rEventQueue.getTimer() ),
       m_views(),
       m_spriteRectangle(),
       m_font( Application::GetSettings().GetStyleSettings().GetInfoFont() ),
-      m_wakeUpEvent( new WakeupEvent(rActivitiesQueue) ),
+      m_wakeUpEvent( new WakeupEvent( rEventQueue.getTimer(),
+                                      rActivitiesQueue ) ),
       m_mouseHandler(),
       m_bActive(false),
       m_drawPressed(false)
@@ -110,7 +111,7 @@
     m_font.SetAlign( ALIGN_BASELINE );
 //     m_font.SetColor( COL_WHITE );
     m_font.SetColor( COL_BLACK );
-    
+
     // determine sprite size (in pixel):
 	VirtualDevice blackHole;
 	blackHole.EnableOutput(false);
@@ -145,13 +146,13 @@
     m_elapsedTime.reset();
     m_drawPressed = false;
     m_bActive = true;
-    
+
     // paint and show all sprites:
     paintAllSprites();
     for_each_sprite( boost::bind( &cppcanvas::Sprite::show, _1 ) );
-    
+
     m_rActivitiesQueue.addActivity( m_this );
-    
+
     m_mouseHandler->reset();
     m_rEventMultiplexer.addClickHandler(
         m_mouseHandler, 42 /* highest prio of all, > 3.0 */ );
@@ -192,6 +193,11 @@
 }
 
 // Activity:
+double RehearseTimingsActivity::calcTimeLag() const
+{
+    return 0.0;
+}
+
 bool RehearseTimingsActivity::perform()
 {
     if (! isActive())
@@ -199,13 +205,13 @@
     OSL_ENSURE( m_wakeUpEvent.get() != 0, "### no wake-up event!" );
     if (m_wakeUpEvent.get() == 0)
         return false;
-    
+
     m_wakeUpEvent->start();
     m_wakeUpEvent->setNextTimeout( 0.5 /* secs */ );
     m_rEventQueue.addEvent( m_wakeUpEvent );
-    
+
     paintAllSprites();
-    
+
     return false; // don't reinsert, WakeupEvent will perform
                   // that after the given timeout
 }
@@ -220,9 +226,9 @@
     return isActive();
 }
 
-void RehearseTimingsActivity::end()
+void RehearseTimingsActivity::dequeued()
 {
-    dispose();
+    // not used here
 }
 
 basegfx::B2DRectangle RehearseTimingsActivity::calcSpriteRectangle(
@@ -250,15 +256,17 @@
 
 void RehearseTimingsActivity::addView( UnoViewSharedPtr const & rView )
 {
+    const ViewsVecT::iterator iEnd( m_views.end() );
     if (std::find_if(
-            m_views.begin(), m_views.end(),
+            m_views.begin(), iEnd,
             boost::bind(
                 std::equal_to<UnoViewSharedPtr>(),
                 rView,
                 // select view:
-                boost::bind( std::select1st<ViewsVecT::value_type>(), _1 ) ) ))
+                boost::bind( std::select1st<ViewsVecT::value_type>(), _1 ) ) )!=
+        iEnd)
         return; // already added
-    
+
     cppcanvas::CustomSpriteSharedPtr sprite(
         rView->createSprite( basegfx::B2DSize(
                                  m_spriteSizePixel.getWidth(),
@@ -290,7 +298,7 @@
     if (! m_views.empty()) {
         // new sprite pos, transformation might have changed:
         m_spriteRectangle = calcSpriteRectangle( m_views.begin()->first );
-        
+
         // reposition all sprites:
         const basegfx::B2DPoint spritePos(
             m_spriteRectangle.getMinX(), m_spriteRectangle.getMinY() );
@@ -330,10 +338,10 @@
         buf.append( static_cast<sal_Unicode>('0') );
     buf.append( n );
     const rtl::OUString time = buf.makeStringAndClear();
-    
+
     cppcanvas::BaseGfxFactory & factory =
         cppcanvas::BaseGfxFactory::getInstance();
-    
+
 	// create the MetaFile:
 	GDIMetaFile metaFile;
 	VirtualDevice blackHole;
@@ -358,15 +366,15 @@
     blackHole.DrawText(
         Point( (m_spriteSizePixel.getWidth() - rect.getWidth()) / 2,
                m_nYOffset ), time );
-    
+
 	metaFile.Stop();
 	metaFile.WindStart();
-    
+
     cppcanvas::RendererSharedPtr renderer(
         cppcanvas::VCLFactory::getInstance().createRenderer(
             canvas, metaFile, cppcanvas::Renderer::Parameters() ) );
     const bool succ = renderer->draw();
-    OSL_ASSERT( succ ); succ;    
+    OSL_ASSERT( succ ); succ;
 }
 
 
diff -u -r  slideshow/source/engine/rehearsetimingsactivity.hxx  slideshow/source/engine/rehearsetimingsactivity.hxx
---  slideshow/source/engine/rehearsetimingsactivity.hxx	2005-01-21 22:26:13.000000000 +0530
+++  slideshow/source/engine/rehearsetimingsactivity.hxx	2005-02-28 13:41:44.749310672 +0530
@@ -116,10 +116,11 @@
     // Disposable:
     virtual void dispose();
     // Activity:
+    virtual double calcTimeLag() const;
     virtual bool perform();
     virtual bool isActive() const;
     virtual bool needsScreenUpdate() const;
-    virtual void end();
+    virtual void dequeued();
     
 private:
     RehearseTimingsActivity(
@@ -174,23 +175,12 @@
                   cppcanvas::CustomSpriteSharedPtr> > ViewsVecT;
     ViewsVecT m_views;
     
-    // interims solution only:
-    template <typename PairT>
-    static typename PairT::second_type const & mySelect2nd( PairT const & p ) {
-        return p.second;
-    }
     template <typename FuncT>
     FuncT for_each_sprite( FuncT func ) const {
-        std::for_each(
-            m_views.begin(), m_views.end(),
-            boost::bind( func,
-                         // select sprite:
-                         boost::bind(
-                             // due to bind problems:
-                             &RehearseTimingsActivity::mySelect2nd<
-                             ViewsVecT::value_type>,
-//                              std::select2nd<ViewsVecT::value_type>(),
-                             _1 ) ) );
+        ViewsVecT::const_iterator iPos( m_views.begin() );
+        const ViewsVecT::const_iterator iEnd( m_views.end() );
+        for ( ; iPos != iEnd; ++iPos )
+            func( iPos->second );
         return func;
     }
     
diff -u -r  slideshow/source/engine/shapeeventbroadcaster.cxx  slideshow/source/engine/shapeeventbroadcaster.cxx
---  slideshow/source/engine/shapeeventbroadcaster.cxx	2004-11-27 00:26:46.000000000 +0530
+++  slideshow/source/engine/shapeeventbroadcaster.cxx	2005-02-28 13:41:45.487224457 +0530
@@ -92,7 +92,7 @@
 
 
 using namespace ::com::sun::star;
-using namespace ::drafts::com::sun::star;
+using namespace ::com::sun::star;
 
 namespace presentation
 {
diff -u -r  slideshow/source/engine/shapeimporter.cxx  slideshow/source/engine/shapeimporter.cxx
---  slideshow/source/engine/shapeimporter.cxx	2004-11-27 00:26:59.000000000 +0530
+++  slideshow/source/engine/shapeimporter.cxx	2005-02-28 13:41:44.895293616 +0530
@@ -155,7 +155,7 @@
 #include <gdimtftools.hxx>
 
 
-using namespace ::drafts::com::sun::star;
+using namespace ::com::sun::star;
 using namespace ::com::sun::star;
 
 // -----------------------------------------------------------------------------
diff -u -r  slideshow/source/engine/slidebitmap.cxx  slideshow/source/engine/slidebitmap.cxx
---  slideshow/source/engine/slidebitmap.cxx	2004-11-27 00:29:01.000000000 +0530
+++  slideshow/source/engine/slidebitmap.cxx	2005-02-28 13:41:44.580330415 +0530
@@ -63,11 +63,11 @@
 #include <canvas/debug.hxx>
 #include <slidebitmap.hxx>
 
-#ifndef _DRAFTS_COM_SUN_STAR_RENDERING_XCANVAS_HPP_
-#include <drafts/com/sun/star/rendering/XCanvas.hpp>
+#ifndef _COM_SUN_STAR_RENDERING_XCANVAS_HPP_
+#include <com/sun/star/rendering/XCanvas.hpp>
 #endif
-#ifndef _DRAFTS_COM_SUN_STAR_RENDERING_XBITMAP_HPP_
-#include <drafts/com/sun/star/rendering/XBitmap.hpp>
+#ifndef _COM_SUN_STAR_RENDERING_XBITMAP_HPP_
+#include <com/sun/star/rendering/XBitmap.hpp>
 #endif
 
 #ifndef _BGFX_MATRIX_B2DHOMMATRIX_HXX
@@ -78,7 +78,7 @@
 #include <basegfx/tools/canvastools.hxx>
 
 
-using namespace ::drafts::com::sun::star;
+using namespace ::com::sun::star;
 using namespace ::com::sun::star;
 
 namespace presentation
diff -u -r  slideshow/source/engine/slide.cxx  slideshow/source/engine/slide.cxx
---  slideshow/source/engine/slide.cxx	2005-01-21 22:26:32.000000000 +0530
+++  slideshow/source/engine/slide.cxx	2005-02-28 13:41:45.502222705 +0530
@@ -111,6 +111,9 @@
 #ifndef _BGFX_POLYGON_B2DPOLYGON_HXX
 #include <basegfx/polygon/b2dpolygon.hxx>
 #endif
+#ifndef _BGFX_POLYGON_B2DPOLYGONTOOLS_HXX
+#include <basegfx/polygon/b2dpolygontools.hxx>
+#endif
 #ifndef _BGFX_NUMERIC_FTOOLS_HXX
 #include <basegfx/numeric/ftools.hxx>
 #endif
@@ -146,7 +149,7 @@
 #include <tools.hxx>
 
 
-using namespace ::drafts::com::sun::star;
+using namespace ::com::sun::star;
 using namespace ::com::sun::star;
 
 // -----------------------------------------------------------------------------
@@ -167,7 +170,7 @@
             mxDrawPage( xDrawPage ),
 			mxRootNode( xRootNode ),
             maContext( LayerManagerSharedPtr(
-                           new LayerManager( getPageRect() ) ),
+                           new LayerManager( getSlideRect() ) ),
                        rEventQueue, 
                        rEventMultiplexer,
                        rActivitiesQueue, 
@@ -566,12 +569,11 @@
                     pCanvas->setTransformation( ::basegfx::B2DHomMatrix() );
 
                     // fill the bounds rectangle in white
-                    ::basegfx::B2DPolygon aPoly;                
-                    aPoly.append( ::basegfx::B2DPoint() );
-                    aPoly.append( ::basegfx::B2DPoint(maSize.getX(), 0) );
-                    aPoly.append( ::basegfx::B2DPoint(maSize.getX(), maSize.getY()) );
-                    aPoly.append( ::basegfx::B2DPoint(0, maSize.getY()) );
-                    aPoly.setClosed(true);
+                    const ::basegfx::B2DPolygon aPoly(
+                        ::basegfx::tools::createPolygonFromRect(
+                            ::basegfx::B2DRectangle( 0.0, 0.0,
+                                                     maSize.getX(),
+                                                     maSize.getY() ) ) );
 
                     ::cppcanvas::PolyPolygonSharedPtr pPolyPoly( 
                         ::cppcanvas::BaseGfxFactory::getInstance().createPolyPolygon( pCanvas, aPoly ) );
@@ -690,7 +692,7 @@
             SlideBitmapSharedPtr& rBitmap( 
                 maSlideBitmaps.at( nViewIndex ).at( meAnimationState ) );
 
-			const ::basegfx::B2ISize& rSlideSize( getSlideSize( rView ) );
+			const ::basegfx::B2ISize& rSlideSize( getSlideSizePixel( rView ) );
 
 			// is the bitmap valid (actually existent, and of correct
 			// size)?
@@ -698,7 +700,7 @@
 				rBitmap->getSize() != rSlideSize )
             {
                 // no bitmap there yet, or wrong size - create one
-                rBitmap = createCurrentSlideBitmap(rView);
+                rBitmap = createCurrentSlideBitmap(rView, rSlideSize);
             }
 
             return rBitmap;
@@ -733,26 +735,29 @@
         //--------------------------------------------------------------------------------------------------------------
 
 
-        ::basegfx::B2ISize Slide::getSlideSize( const UnoViewSharedPtr& rView )
+        ::basegfx::B2ISize Slide::getSlideSizePixel(
+            const UnoViewSharedPtr& rView ) const
         {
-            ::basegfx::B2ISize aPageSize;
-            if( !getPageSize( aPageSize ) )
-                ENSURE_AND_THROW(false,"Slide::getSlideSize(): Cannot fetch page size");
+            const ::basegfx::B2ISize slideSize( getSlideSize() );
 
             ::cppcanvas::CanvasSharedPtr pCanvas( rView->getCanvas() );
 
             // determine transformed page bounds
             const ::basegfx::B2DRectangle aRect( 0,0,
-                                                 aPageSize.getX(),
-                                                 aPageSize.getY() );
+                                                 slideSize.getX(),
+                                                 slideSize.getY() );
             ::basegfx::B2DRectangle aTmpRect;
             ::canvas::tools::calcTransformedRectBounds( aTmpRect, aRect, pCanvas->getTransformation() );
 
-            return ::basegfx::B2ISize( ::basegfx::fround( aTmpRect.getRange().getX() ),
-									   ::basegfx::fround( aTmpRect.getRange().getY() ) );
+            // #i42440# Returned slide size is one pixel too small, as
+            // rendering happens one pixel to the right and below the
+            // actual bound rect.
+            return ::basegfx::B2ISize( ::basegfx::fround( aTmpRect.getRange().getX() ) + 1,
+									   ::basegfx::fround( aTmpRect.getRange().getY() ) + 1 );
 		}
 
-        SlideBitmapSharedPtr Slide::createCurrentSlideBitmap( const UnoViewSharedPtr& rView )
+        SlideBitmapSharedPtr Slide::createCurrentSlideBitmap(
+            const UnoViewSharedPtr& rView, const ::basegfx::B2ISize& rBmpSize )
         {
             ENSURE_AND_THROW( rView.get() && rView->getCanvas().get(), 
                               "Slide::createCurrentSlideBitmap(): Invalid view" );
@@ -761,8 +766,6 @@
             ENSURE_AND_THROW( mbShowLoaded, 
                               "Slide::createCurrentSlideBitmap(): No show loaded" );
 
-            const ::basegfx::B2ISize& rBmpSize( getSlideSize( rView ) );
-
             ::cppcanvas::CanvasSharedPtr pCanvas( rView->getCanvas() );
 
             // create a bitmap of appropriate size
@@ -910,33 +913,25 @@
             mpPaintOverlay.reset();
         }
 
-        bool Slide::getPageSize( ::basegfx::B2ISize& o_rPageSize ) const
+        basegfx::B2ISize Slide::getSlideSize() const
         {
-            uno::Reference< beans::XPropertySet > xPropSet( mxDrawPage, 
-                                                            uno::UNO_QUERY );
-            if( !xPropSet.is() )
-                return false;
-
-            sal_Int32 nDocWidth;
-            sal_Int32 nDocHeight;
+            uno::Reference< beans::XPropertySet > xPropSet(
+                mxDrawPage, uno::UNO_QUERY_THROW );
+            
+            sal_Int32 nDocWidth = 0;
+            sal_Int32 nDocHeight = 0;
             xPropSet->getPropertyValue( ::rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Width") ) ) >>= nDocWidth;
             xPropSet->getPropertyValue( ::rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Height") ) ) >>= nDocHeight;
 
-            o_rPageSize.setX( nDocWidth );
-            o_rPageSize.setY( nDocHeight );
-
-            return true;
+            return basegfx::B2ISize( nDocWidth, nDocHeight );
         }
 
-        ::basegfx::B2DRectangle Slide::getPageRect() const
+        ::basegfx::B2DRectangle Slide::getSlideRect() const
         {
-            ::basegfx::B2ISize aPageSize;
-            if( !getPageSize( aPageSize ) )
-                ENSURE_AND_THROW(false,"Slide::getPageRect(): Cannot fetch page size");
-            
+            const basegfx::B2ISize slideSize( getSlideSize() );
             return ::basegfx::B2DRectangle(0.0,0.0,
-                                           aPageSize.getX(),
-                                           aPageSize.getY());
+                                           slideSize.getX(),
+                                           slideSize.getY());
         }
 
         namespace
diff -u -r  slideshow/source/engine/soundplayer.cxx  slideshow/source/engine/soundplayer.cxx
---  slideshow/source/engine/soundplayer.cxx	2004-11-27 00:30:02.000000000 +0530
+++  slideshow/source/engine/soundplayer.cxx	2005-02-28 13:41:44.699316513 +0530
@@ -95,10 +95,50 @@
     namespace internal
     {
         // TODO(Q3): Move the whole SoundPlayer class to avmedia.
+    
+        boost::shared_ptr<SoundPlayer> SoundPlayer::create(
+            EventMultiplexer & rEventMultiplexer,
+            const ::rtl::OUString& rSoundURL,
+            const uno::Reference< uno::XComponentContext>&	rComponentContext )
+        {
+            boost::shared_ptr<SoundPlayer> pPlayer(
+                new SoundPlayer( rEventMultiplexer,
+                                 rSoundURL,
+                                 rComponentContext ) );
+            rEventMultiplexer.addPauseHandler( pPlayer );
+            pPlayer->mThis = pPlayer;
+            return pPlayer;
+        }
 
-        SoundPlayer::SoundPlayer( const ::rtl::OUString& 							rSoundURL,
-                                  const uno::Reference< uno::XComponentContext>&	rComponentContext ) :
-            mxPlayer()
+        bool SoundPlayer::handlePause( bool bPauseShow )
+        {
+            return bPauseShow ? stopPlayback() : startPlayback();
+        }
+    
+        void SoundPlayer::dispose()
+        {
+            if (mThis.get() != 0) {
+                mrEventMultiplexer.removePauseHandler( mThis );
+                mThis.reset();
+            }
+            
+			if (mxPlayer.is()) {
+				mxPlayer->stop();
+				uno::Reference<lang::XComponent> xComponent(
+                    mxPlayer, uno::UNO_QUERY );
+				if (xComponent.is())
+					xComponent->dispose();
+                mxPlayer.clear();
+			}
+        }
+    
+        SoundPlayer::SoundPlayer(
+            EventMultiplexer & rEventMultiplexer,
+            const ::rtl::OUString& rSoundURL,
+            const uno::Reference< uno::XComponentContext>&	rComponentContext )
+            : mrEventMultiplexer(rEventMultiplexer),
+              mThis(),
+              mxPlayer()
         {
             ENSURE_AND_THROW( rComponentContext.is(),
                               "SoundPlayer::SoundPlayer(): Invalid component context" );
@@ -121,21 +161,16 @@
             }
             catch( uno::Exception& ) 
             {
-                throw lang::NoSupportException();
+                throw lang::NoSupportException(
+                    rtl::OUString( RTL_CONSTASCII_USTRINGPARAM(
+                                       "No sound support for ") ) + rSoundURL,
+                    uno::Reference<uno::XInterface>() );
             }
         }
 
         SoundPlayer::~SoundPlayer()
         {
-			if( mxPlayer.is() )
-			{
-				mxPlayer->stop();
-
-				uno::Reference< lang::XComponent > xComponent( mxPlayer, uno::UNO_QUERY );
-		
-				if( xComponent.is() )
-					xComponent->dispose();
-			}
+            dispose();
         }
 
         double SoundPlayer::getDuration() const
diff -u -r  slideshow/source/engine/transitions/clippingfunctor.cxx  slideshow/source/engine/transitions/clippingfunctor.cxx
---  slideshow/source/engine/transitions/clippingfunctor.cxx	2004-11-27 00:33:27.000000000 +0530
+++  slideshow/source/engine/transitions/clippingfunctor.cxx	2005-02-28 13:41:45.370238125 +0530
@@ -195,6 +195,10 @@
             ::basegfx::B2DPolyPolygon aClipPoly = (*mpParametricPoly)( 
                 mbForwardParameterSweep ? nValue : 1.0 - nValue );
 
+            // TODO(Q4): workaround here, better be fixed in cppcanvas
+            if (aClipPoly.count() == 0)
+                aClipPoly.append( basegfx::B2DPolygon() );
+
             if (mbFlip)
                 aClipPoly.flip();
     
@@ -217,12 +221,10 @@
                 ::std::swap( aClipPoly, aTmp );
                 aClipPoly.append( aTmp );
         
-                // TODO(P1): If former aClipPoly is
-                // _strictly_ inside maBackgroundRect,
-                // no need to remove intersections
-                // (but this optimization strictly
-                // speaking belongs into
-                // removeIntersections...)
+                // TODO(P1): If former aClipPoly is _strictly_ inside
+                // maBackgroundRect, no need to remove intersections
+                // (but this optimization strictly speaking belongs
+                // into removeIntersections...)
                 aClipPoly = ::basegfx::tools::removeAllIntersections(aClipPoly);
                 aClipPoly = ::basegfx::tools::removeNeutralPolygons(aClipPoly, sal_True);
 
diff -u -r  slideshow/source/engine/transitions/combtransition.cxx  slideshow/source/engine/transitions/combtransition.cxx
---  slideshow/source/engine/transitions/combtransition.cxx	2005-01-21 22:38:29.000000000 +0530
+++  slideshow/source/engine/transitions/combtransition.cxx	2005-02-28 13:41:45.372237892 +0530
@@ -59,207 +59,163 @@
  *
  ************************************************************************/
 
-#include <canvas/debug.hxx>
-#include <combtransition.hxx>
-
-#include <basegfx/polygon/b2dpolygontools.hxx>
-#include <basegfx/polygon/b2dpolypolygontools.hxx>
+#include "combtransition.hxx"
+#include "canvas/debug.hxx"
+#include "basegfx/polygon/b2dpolygontools.hxx"
+#include "basegfx/polygon/b2dpolypolygontools.hxx"
+
+namespace presentation {
+namespace internal {
+
+namespace {
+
+basegfx::B2DPolyPolygon createClipPolygon(
+    const ::basegfx::B2DVector& rDirection,
+    const ::basegfx::B2DSize& rSlideSize,
+    int nNumStrips, int nOffset )
+{
+    // create clip polygon in standard orientation (will later
+    // be rotated to match direction vector)
+    ::basegfx::B2DPolyPolygon aClipPoly;
+    
+    // create nNumStrips/2 vertical strips
+    for( int i=nOffset; i<nNumStrips; i+=2 )
+    {
+        aClipPoly.append( 
+            ::basegfx::tools::createPolygonFromRect( 
+                ::basegfx::B2DRectangle( (double)i/nNumStrips, 0.0,
+                                         (double)(i+1)/nNumStrips, 1.0) ) );
+        
+    }
+    
+    // rotate polygons, such that the strips are parallel to
+    // the given direction vector
+    const ::basegfx::B2DVector aUpVec(0.0, 1.0);
+    ::basegfx::B2DHomMatrix    aMatrix;
+    
+    aMatrix.translate( -0.5, -0.5 );
+    aMatrix.rotate( aUpVec.angle( rDirection ) );
+    aMatrix.translate( 0.5, 0.5 );
+    
+    // blow up clip polygon to slide size
+    aMatrix.scale( rSlideSize.getX(),
+                   rSlideSize.getY() );
+    
+    aClipPoly.transform( aMatrix );
+    
+    return aClipPoly;
+}
 
+}
 
-namespace presentation 
+CombTransition::CombTransition(
+    boost::optional<SlideSharedPtr> const & leavingSlide,
+    const SlideSharedPtr& pEnteringSlide,
+    const SoundPlayerSharedPtr& pSoundPlayer,
+    const ::basegfx::B2DVector& rPushDirection,
+    sal_Int32                   nNumStripes )
+    : SlideChangeBase( leavingSlide, pEnteringSlide, pSoundPlayer,
+                       false /* no leaving sprite */,
+                       false /* no entering sprite */ ),
+      maPushDirectionUnit( rPushDirection ),
+      mnNumStripes( nNumStripes )
 {
-    namespace internal 
-    {
-        namespace
-        {
-            ::basegfx::B2DPolyPolygon createClipPolygon( const ::basegfx::B2DVector& rDirection,
-                                                         const ::basegfx::B2DSize&	 rSlideSize,
-                                                         int						 nNumStrips,
-                                                         int						 nOffset )
-            {
-                // create clip polygon in standard orientation (will later
-                // be rotated to match direction vector)
-                ::basegfx::B2DPolyPolygon aClipPoly;
-
-                // create nNumStrips/2 vertical strips
-                for( int i=nOffset; i<nNumStrips; i+=2 )
-                {
-                    aClipPoly.append( 
-                        ::basegfx::tools::createPolygonFromRect( 
-                            ::basegfx::B2DRectangle( (double)i/nNumStrips, 0.0,
-                                                     (double)(i+1)/nNumStrips, 1.0) ) );
-
-                }
-
-                // rotate polygons, such that the strips are parallel to
-                // the given direction vector
-                const ::basegfx::B2DVector aUpVec(0.0, 1.0);
-                ::basegfx::B2DHomMatrix    aMatrix;
-
-                aMatrix.translate( -0.5, -0.5 );
-                aMatrix.rotate( aUpVec.angle( rDirection ) );
-                aMatrix.translate( 0.5, 0.5 );
-            
-                // blow up clip polygon to slide size
-                aMatrix.scale( rSlideSize.getX(),
-                               rSlideSize.getY() );
-
-                aClipPoly.transform( aMatrix );
-
-                return aClipPoly;
-            }
-        }
-
-        CombTransition::CombTransition( const SlideBitmapSharedPtr& rLeavingBitmap,
-                                        const SlideBitmapSharedPtr& rEnteringBitmap,
-                                        const ::basegfx::B2DVector& rPushDirection,
-                                        sal_Int32					nNumStripes,
-                                        const SoundPlayerSharedPtr&	rSoundPlayer ) :
-            maViews(),
-            mpLeavingBitmap( rLeavingBitmap ),
-            mpEnteringBitmap( rEnteringBitmap ),
-            maBitmapSize( getBitmapSize() ),
-            maClipPolygon1( createClipPolygon( rPushDirection,
-                                               maBitmapSize,
-                                               nNumStripes,
-                                               0 ) ),
-            maClipPolygon2( createClipPolygon( rPushDirection,
-                                               maBitmapSize,
-                                               nNumStripes,
-                                               1 ) ),
-            maPushDirection( maBitmapSize * 
-                             rPushDirection ),
-            mpSoundPlayer( rSoundPlayer )
-        {
-            ENSURE_AND_THROW(
-                rEnteringBitmap.get(),
-                "CombTransition::CombTransition(): Invalid entering bitmap" );
-        }
-    
-        ::basegfx::B2DSize CombTransition::getBitmapSize() const
-        {
-            return ::basegfx::B2DSize( 
-                ::basegfx::B2DTuple( mpEnteringBitmap->getSize() ) );
-        }
-
-        void CombTransition::start( const AnimatableShapeSharedPtr&,
-                                    const ShapeAttributeLayerSharedPtr& )
-        {
-            // TODO(F1): Maybe we've got to create separate bitmaps
-            // for every view, should the canvas not allow for
-            // cross-canvas bitmap rendering
-            if( mpSoundPlayer.get() )
-                mpSoundPlayer->startPlayback();
-        }
-
-        void CombTransition::end()
-        {
-            if( mpSoundPlayer.get() )
-                mpSoundPlayer->stopPlayback();
-
-            // drop all references
-            mpLeavingBitmap.reset();
-            mpEnteringBitmap.reset();
-
-            maViews.clear();
-        }
-
-        bool CombTransition::operator()( double t )
-        {
-            if( !mpEnteringBitmap.get() )
-            {
-                return false;
-            }
-
-            for( ::std::size_t i=0, nEntries=maViews.size(); i<nEntries; ++i )
-            {
-                // calc bitmap offsets. The enter/leaving bitmaps are only
-                // as large as the actual slides. For scaled-down
-                // presentations, we have to move the left, top edge of
-                // those bitmaps to the actual position, governed by the
-                // given view transform. The aBitmapPosPixel local
-                // variable is already in device coordinate space
-                // (i.e. pixel).
-
-                ::cppcanvas::CanvasSharedPtr pCanvas( maViews[i]->getCanvas() );
-
-                ENSURE_AND_THROW( pCanvas.get(),
-                                  "CombTransition::operator(): Invalid canvas" );
-
-                // TODO(F2): Properly respect clip here. Might have to be transformed, too.
-                const ::basegfx::B2DHomMatrix 	aViewTransform( pCanvas->getTransformation() );
-                const ::basegfx::B2DPoint 		aPageOrigin( aViewTransform * ::basegfx::B2DPoint() );
-                
-                // change transformation on cloned canvas to be in
-                // device pixel
-                pCanvas = pCanvas->clone();
-                pCanvas->setTransformation( ::basegfx::B2DHomMatrix() );
-
-                // TODO(Q2): Use basegfx bitmaps here
-                // TODO(F1): SlideBitmap is not fully portable between different canvases!
-
-                if( mpLeavingBitmap.get() )
-                {
-                    // render odd strips
-                    mpLeavingBitmap->move( aPageOrigin + t*maPushDirection );
-                    mpLeavingBitmap->clip( maClipPolygon1 );
-                    mpLeavingBitmap->draw( pCanvas );
-
-                    // render even strips
-                    mpLeavingBitmap->move( aPageOrigin - t*maPushDirection );
-                    mpLeavingBitmap->clip( maClipPolygon2 );
-                    mpLeavingBitmap->draw( pCanvas );
-                }
-
-                // TODO(Q2): Use basegfx bitmaps here
-                // TODO(F1): SlideBitmap is not fully portable between different canvases!
-            
-                // render odd strips
-                mpEnteringBitmap->move( aPageOrigin + (t-1.0)*maPushDirection );
-                mpEnteringBitmap->clip( maClipPolygon1 );
-                mpEnteringBitmap->draw( pCanvas );
-
-                // render even strips
-                mpEnteringBitmap->move( aPageOrigin + (1.0-t)*maPushDirection );
-                mpEnteringBitmap->clip( maClipPolygon2 );
-                mpEnteringBitmap->draw( pCanvas );
-            }
-
-            return true;
-        }
-
-        double CombTransition::getUnderlyingValue() const
-        {
-            return 0.0;     // though this should be used in concert with 
-				            // ActivitiesFactory::createSimpleActivity, better
-            	            // explicitely name our start value.
-	                        // Permissible range for operator() above is [0,1]
-        }
-
-        void CombTransition::addView( const ViewSharedPtr& rView )
-        {
-            // TODO(Q2): Try to use UnoViewContainer here.
-            maViews.push_back( rView );
-        }
-
-        bool CombTransition::removeView( const ViewSharedPtr& rView )
-        {
-            // remove locally
-            const ViewVector::iterator aEnd( maViews.end() );
-            ViewVector::iterator aIter;
-            if( (aIter=::std::remove( maViews.begin(), 
-                                      aEnd, 
-                                      rView)) == aEnd )
-            {
-                // view seemingly was not added, failed
-                return false;
-            }
+}
 
-            // actually erase from container
-            maViews.erase( aIter, aEnd );
+void CombTransition::renderComb(
+    double t, UnoViewSharedPtr const & pView ) const
+{
+    const cppcanvas::CanvasSharedPtr pCanvas_ = pView->getCanvas();
+    
+    // calc bitmap offsets. The enter/leaving bitmaps are only
+    // as large as the actual slides. For scaled-down
+    // presentations, we have to move the left, top edge of
+    // those bitmaps to the actual position, governed by the
+    // given view transform. The aBitmapPosPixel local
+    // variable is already in device coordinate space
+    // (i.e. pixel).
+    
+    ENSURE_AND_THROW( pCanvas_.get(),
+                      "CombTransition::renderComb(): Invalid canvas" );
+    
+    // TODO(F2): Properly respect clip here. Might have to be transformed, too.
+    const basegfx::B2DHomMatrix viewTransform( pCanvas_->getTransformation() );
+    const basegfx::B2DPoint pageOrigin( viewTransform * basegfx::B2DPoint() );
+    
+    // change transformation on cloned canvas to be in
+    // device pixel
+    cppcanvas::CanvasSharedPtr pCanvas( pCanvas_->clone() );
+    basegfx::B2DHomMatrix transform;
+    basegfx::B2DPoint p;
+    
+    // TODO(Q2): Use basegfx bitmaps here
+    // TODO(F1): SlideBitmap is not fully portable between different canvases!
 
-            return true;
-        }
+    const basegfx::B2DSize enteringSizePixel( 
+        getEnteringSizePixel(pView) );
 
+    const basegfx::B2DVector aPushDirection = basegfx::B2DVector(
+        enteringSizePixel * maPushDirectionUnit );
+    const basegfx::B2DPolyPolygon aClipPolygon1 = basegfx::B2DPolyPolygon(
+        createClipPolygon( maPushDirectionUnit,
+                           enteringSizePixel,
+                           mnNumStripes, 0 ) );
+    const basegfx::B2DPolyPolygon aClipPolygon2 = basegfx::B2DPolyPolygon(
+        createClipPolygon( maPushDirectionUnit,
+                           enteringSizePixel,
+                           mnNumStripes, 1 ) );
+    
+    SlideBitmapSharedPtr const & pLeavingBitmap = getLeavingBitmap();
+    if (pLeavingBitmap.get() != 0) {
+        // render odd strips:
+        pLeavingBitmap->clip( aClipPolygon1 );
+        // don't modify bitmap object (no move!):
+        p = basegfx::B2DPoint( pageOrigin + (t * aPushDirection) );
+        transform.translate( p.getX(), p.getY() );
+        pCanvas->setTransformation( transform );
+        pLeavingBitmap->draw( pCanvas );
+        
+        // render even strips:
+        pLeavingBitmap->clip( aClipPolygon2 );
+        // don't modify bitmap object (no move!):
+        transform.identity();
+        p = basegfx::B2DPoint( pageOrigin - (t * aPushDirection) );
+        transform.translate( p.getX(), p.getY() );
+        pCanvas->setTransformation( transform );
+        pLeavingBitmap->draw( pCanvas );
     }
+    
+    // TODO(Q2): Use basegfx bitmaps here
+    // TODO(F1): SlideBitmap is not fully portable between different canvases!
+    
+    // render odd strips:
+    SlideBitmapSharedPtr const & pEnteringBitmap = getEnteringBitmap();
+    pEnteringBitmap->clip( aClipPolygon1 );
+    // don't modify bitmap object (no move!):
+    transform.identity();
+    p = basegfx::B2DPoint( pageOrigin + ((t - 1.0) * aPushDirection) );
+    transform.translate( p.getX(), p.getY() );
+    pCanvas->setTransformation( transform );
+    pEnteringBitmap->draw( pCanvas );
+    
+    // render even strips:
+    pEnteringBitmap->clip( aClipPolygon2 );
+    // don't modify bitmap object (no move!):
+    transform.identity();
+    p = basegfx::B2DPoint( pageOrigin + ((1.0 - t) * aPushDirection) );
+    transform.translate( p.getX(), p.getY() );
+    pCanvas->setTransformation( transform );
+    pEnteringBitmap->draw( pCanvas );
 }
+
+bool CombTransition::operator()( double t )
+{
+    SlideBitmapSharedPtr const & pSlideBitmap = getEnteringBitmap();
+    if (pSlideBitmap.get() == 0)
+        return false;
+    for_each_view( boost::bind( &CombTransition::renderComb, this, t, _1 ) );
+    return true;
+}
+
+} // namespace internal
+} // namespace presentation
diff -u -r  slideshow/source/engine/transitions/combtransition.hxx  slideshow/source/engine/transitions/combtransition.hxx
---  slideshow/source/engine/transitions/combtransition.hxx	2004-11-27 00:34:22.000000000 +0530
+++  slideshow/source/engine/transitions/combtransition.hxx	2005-02-28 13:41:45.372237892 +0530
@@ -62,88 +62,42 @@
 #ifndef _SLIDESHOW_COMBTRANSITION_HXX
 #define _SLIDESHOW_COMBTRANSITION_HXX
 
-#ifndef _RTL_USTRING_HXX_
-#include <rtl/ustring.hxx>
-#endif 
-#ifndef _BGFX_POLYGON_B2DPOLYPOLYGON_HXX
-#include <basegfx/polygon/b2dpolypolygon.hxx>
-#endif
-
-#ifndef BOOST_SHARED_PTR_HPP_INCLUDED
-#include <boost/shared_ptr.hpp>
-#endif
-
-#include <slidechangeanimation.hxx>
-#include <slidebitmap.hxx>
-#include <soundplayer.hxx>
+#include "basegfx/polygon/b2dpolypolygon.hxx"
+#include "slidechangebase.hxx"
 
+namespace presentation {
+namespace internal {
 
-namespace presentation
+/** Comb transition class.
+    
+    This class provides a SlideChangeAnimation, showing a
+    comb-like effect (stripes of alternating push effects).
+*/
+class CombTransition : public SlideChangeBase
 {
-    namespace internal
-    {
-        /** Comb transition class.
-
-	    	This class provides a SlideChangeAnimation, showing a
-	    	comb-like effect (stripes of alternating push effects).
-        */
-        class CombTransition : public SlideChangeAnimation
-        {
-        public:
-            /** Create the comb transition effect.
-
-            	@param rLeavingBitmap
-                Bitmap of slide which leaves
-
-                @param rEnteringBitmap
-                Bitmap of slide which enters
-
-                @param nNumStripes
-                Number of comb-like stripes to show in this effect
-
-                @param rSoundPlayer
-                Sound to play, while transition is running. Use NULL
-                for no sound.
-             */
-            CombTransition( const SlideBitmapSharedPtr& rLeavingBitmap,
-                            const SlideBitmapSharedPtr& rEnteringBitmap,
-                            const ::basegfx::B2DVector& rPushDirection,
-                            sal_Int32					nNumStripes,
-                            const SoundPlayerSharedPtr&	rSoundPlayer );
+public:
+    /** Create the comb transition effect.
         
-            // NumberAnimation
-            virtual bool operator()( double x );
-            virtual double getUnderlyingValue() const;
-
-            // Animation
-            virtual void start( const AnimatableShapeSharedPtr&,
-                                const ShapeAttributeLayerSharedPtr& );
-            virtual void end();
-
-            // SlideChangeAnimation
-            virtual void addView( const ViewSharedPtr& rView );
-            virtual bool removeView( const ViewSharedPtr& rView );
-
-        private:
-            /** Query the size of the bitmaps in device pixel
-             */
-            ::basegfx::B2DSize getBitmapSize() const;
-
-            ViewVector						maViews;
-
-            SlideBitmapSharedPtr			mpLeavingBitmap;
-            SlideBitmapSharedPtr			mpEnteringBitmap;
-            
-            const ::basegfx::B2DSize		maBitmapSize;
-
-            const ::basegfx::B2DPolyPolygon	maClipPolygon1;
-            const ::basegfx::B2DPolyPolygon	maClipPolygon2;
-
-            const ::basegfx::B2DVector 		maPushDirection;
-
-            SoundPlayerSharedPtr			mpSoundPlayer;
-        };
-    }
-}
+        @param nNumStripes
+        Number of comb-like stripes to show in this effect
+    */
+    CombTransition( ::boost::optional<SlideSharedPtr> const & leavingSlide,
+                    const SlideSharedPtr& pEnteringSlide,
+                    const SoundPlayerSharedPtr& pSoundPlayer,
+                    const ::basegfx::B2DVector& rPushDirection,
+                    sal_Int32                   nNumStripes );
+    
+    // NumberAnimation
+    virtual bool operator()( double x );
+    
+private:
+    const ::basegfx::B2DVector maPushDirectionUnit;
+    sal_Int32                  mnNumStripes;
+    
+    void renderComb( double t, UnoViewSharedPtr const & pView ) const;
+};
+
+} // namespace internal
+} // namespace presentation
 
 #endif /* _SLIDESHOW_COMBTRANSITION_HXX */
diff -u -r  slideshow/source/engine/transitions/makefile.mk  slideshow/source/engine/transitions/makefile.mk
---  slideshow/source/engine/transitions/makefile.mk	2004-11-27 00:36:49.000000000 +0530
+++  slideshow/source/engine/transitions/makefile.mk	2005-02-28 13:41:45.481225158 +0530
@@ -84,8 +84,8 @@
 SLOFILES = \
         $(SLO)$/barwipepolypolygon.obj \
         $(SLO)$/boxwipe.obj \
-		$(SLO)$/clippingfunctor.obj \
-		$(SLO)$/combtransition.obj \
+        $(SLO)$/clippingfunctor.obj \
+        $(SLO)$/combtransition.obj \
         $(SLO)$/fourboxwipe.obj \
         $(SLO)$/barndoorwipe.obj \
         $(SLO)$/iriswipe.obj \
@@ -107,8 +107,8 @@
         $(SLO)$/shapetransitionfactory.obj \
         $(SLO)$/slidetransitionfactory.obj \
         $(SLO)$/transitionfactorytab.obj \
-        $(SLO)$/transitiontools.obj
-
+        $(SLO)$/transitiontools.obj \
+        $(SLO)$/slidechangebase.obj
 
 # ==========================================================================
 
diff -u -r  slideshow/source/engine/transitions/parametricpolypolygonfactory.cxx  slideshow/source/engine/transitions/parametricpolypolygonfactory.cxx
---  slideshow/source/engine/transitions/parametricpolypolygonfactory.cxx	2004-11-27 00:37:11.000000000 +0530
+++  slideshow/source/engine/transitions/parametricpolypolygonfactory.cxx	2005-02-28 13:41:45.086271303 +0530
@@ -134,14 +134,16 @@
                     new CheckerBoardWipe );
             case RANDOMBARWIPE:
                 return ParametricPolyPolygonSharedPtr(
-                    new RandomWipe( 100, true /* bars */ ) );
+                    new RandomWipe( 128, true /* bars */ ) );
             case DISSOLVE:
                 return ParametricPolyPolygonSharedPtr(
-                    new RandomWipe( 100, false /* dissolve */ ) );
+                    new RandomWipe( 16 * 16, // for now until dxcanvas is faster
+//                                     64 * 64 /* elements */,
+                                    false /* dissolve */ ) );
             case WATERFALLWIPE:
                 return ParametricPolyPolygonSharedPtr(
                     new WaterfallWipe(
-                        100,
+                        128,
                         // flipOnYAxis:
                         nSubType == VERTICALRIGHT ||
                         nSubType == HORIZONTALLEFT ) );
@@ -178,7 +180,8 @@
             case SNAKEWIPE:
                 return ParametricPolyPolygonSharedPtr(
                     new SnakeWipe(
-                        100,
+                        // elements:
+                        64 * 64,
                         // diagonal:
                         nSubType == TOPLEFTDIAGONAL ||
                         nSubType == TOPRIGHTDIAGONAL ||
@@ -192,7 +195,8 @@
             case PARALLELSNAKESWIPE:
                 return ParametricPolyPolygonSharedPtr(
                     new ParallelSnakesWipe(
-                        100,
+                        // elements:
+                        64 * 64,
                         // diagonal:
                         nSubType == DIAGONALBOTTOMLEFTOPPOSITE ||
                         nSubType == DIAGONALTOPLEFTOPPOSITE,
@@ -212,7 +216,7 @@
                 return ParametricPolyPolygonSharedPtr(
                     new SpiralWipe(
                         // elements:
-                        100,
+                        64 * 64,
                         // flipOnYAxis:
                         nSubType == TOPLEFTCOUNTERCLOCKWISE ||
                         nSubType == TOPRIGHTCOUNTERCLOCKWISE ||
@@ -222,7 +226,7 @@
                 return ParametricPolyPolygonSharedPtr(
                     new BoxSnakesWipe(
                         // elements:
-                        100,
+                        64 * 64,
                         // fourBox:
                         nSubType == FOURBOXVERTICAL ||
                         nSubType == FOURBOXHORIZONTAL ) );
diff -u -r  slideshow/source/engine/transitions/randomwipe.cxx  slideshow/source/engine/transitions/randomwipe.cxx
---  slideshow/source/engine/transitions/randomwipe.cxx	2004-11-27 00:37:54.000000000 +0530
+++  slideshow/source/engine/transitions/randomwipe.cxx	2005-02-28 13:41:45.485224691 +0530
@@ -63,7 +63,7 @@
 #include "randomwipe.hxx"
 #include "basegfx/matrix/b2dhommatrix.hxx"
 #include "basegfx/numeric/ftools.hxx"
-#include <stdlib.h>
+#include "tools.hxx"
 
 
 namespace presentation {
@@ -100,9 +100,9 @@
     // mix up:
     for ( sal_Int32 i = (nElements / 2); i--; )
     {
-        sal_Int32 pos1 = (rand() * nElements / RAND_MAX);
-        sal_Int32 pos2 = (rand() * nElements / RAND_MAX);
-        ::basegfx::B2DPoint point( m_positions[ pos1 ] );
+        const sal_Int32 pos1 = getRandomOrdinal(nElements);
+        const sal_Int32 pos2 = getRandomOrdinal(nElements);
+        const ::basegfx::B2DPoint point( m_positions[ pos1 ] );
         m_positions[ pos1 ] = m_positions[ pos2 ];
         m_positions[ pos2 ] = point;
     }
diff -u -r  slideshow/source/engine/transitions/slidetransitionfactory.cxx  slideshow/source/engine/transitions/slidetransitionfactory.cxx
---  slideshow/source/engine/transitions/slidetransitionfactory.cxx	2005-01-21 22:38:43.000000000 +0530
+++  slideshow/source/engine/transitions/slidetransitionfactory.cxx	2005-02-28 13:41:45.481225158 +0530
@@ -59,7 +59,8 @@
  *
  ************************************************************************/
 
-#include <basegfx/numeric/ftools.hxx>
+#include "slidechangebase.hxx"
+
 #include <basegfx/matrix/b2dhommatrix.hxx>
 #include <basegfx/polygon/b2dpolygontools.hxx>
 #include <basegfx/polygon/b2dpolypolygontools.hxx>
@@ -70,7 +71,6 @@
 #include <com/sun/star/animations/TransitionType.hpp>
 #include <com/sun/star/animations/TransitionSubType.hpp>
 
-#include <unoview.hxx>
 #include <transitionfactory.hxx>
 #include <transitiontools.hxx>
 #include <parametricpolypolygonfactory.hxx>
@@ -78,15 +78,7 @@
 #include <clippingfunctor.hxx>
 #include <combtransition.hxx>
 
-#ifndef BOOST_BIND_HPP_INCLUDED
-#include <boost/bind.hpp>
-#endif
-
-
-using namespace ::com::sun::star;
-
-namespace presentation {
-namespace internal {
+#include "comphelper/optional.hxx"
 
 
 /***************************************************
@@ -95,974 +87,537 @@
  ***                                             ***
  ***************************************************/
 
-namespace
-{
-    // helper methods
-    // =============================================
+using namespace com::sun::star;
 
-    void fillPage( const ::cppcanvas::CanvasSharedPtr& rDestinationCanvas,
-                   const ::basegfx::B2DSize&		   rPageSizePixel,
-                   const RGBColor&					   rFillColor )
-    {
-        // need to render without any transformation (we
-        // assume rPageSizePixel to represent device units)
-        ::cppcanvas::CanvasSharedPtr pDevicePixelCanvas( rDestinationCanvas->clone() );
-        pDevicePixelCanvas->setTransformation( ::basegfx::B2DHomMatrix() );
-
-        // TODO(F2): Properly respect clip here. Might have to be transformed, too.
-        const ::basegfx::B2DHomMatrix 	aViewTransform( rDestinationCanvas->getTransformation() );
-        const ::basegfx::B2DPoint 		aOutputPosPixel( aViewTransform * ::basegfx::B2DPoint() );
-
-        const ::basegfx::B2DPolygon aPoly( ::basegfx::tools::createPolygonFromRect(
-                                               ::basegfx::B2DRectangle(aOutputPosPixel.getX(),
-                                                                       aOutputPosPixel.getY(),
-                                                                       aOutputPosPixel.getX() + rPageSizePixel.getX(),
-                                                                       aOutputPosPixel.getY() + rPageSizePixel.getY() ) ) );
-
-        ::cppcanvas::PolyPolygonSharedPtr pPolyPoly( 
-            ::cppcanvas::BaseGfxFactory::getInstance().createPolyPolygon( pDevicePixelCanvas, 
-                                                                          aPoly ) );
+namespace presentation {
+namespace internal {
 
-        if( pPolyPoly.get() )
-        {
-            pPolyPoly->setRGBAFillColor( rFillColor.getIntegerColor() );
-            pPolyPoly->draw();
-        }
-    }
+namespace {
 
-    /** Base class for all slide change effects.
+// helper methods
+// =============================================
 
-    	This class provides the basic sprite and view handling
-    	functionality. Derived classes should normally only need to
-    	implement the perform() method.
-     */
-    class SlideChangeBase : public SlideChangeAnimation
-    {
-    public:
-        /** Create a new SlideChanger, for the given leaving and
-            entering slide bitmaps
-
-            @param rLeavingBitmap
-            Bitmap that contains the slide image of the leaving
-            slide. Can be NULL.
-            
-            @param rEnteringBitmap
-            Bitmap that contains the slide image of the entering slide
-            
-            @param rSoundPlayer
-            Sound to play, while transition is running. Use NULL
-            for no sound.
-        */
-        SlideChangeBase( const SlideBitmapSharedPtr& rLeavingBitmap,
-                         const SlideBitmapSharedPtr& rEnteringBitmap,
-                         const SoundPlayerSharedPtr& rSoundPlayer );
-        
-        // NumberAnimation
-        virtual bool operator()( double x );
-        virtual double getUnderlyingValue() const;
-
-        // Animation
-        virtual void start( const AnimatableShapeSharedPtr&,
-                            const ShapeAttributeLayerSharedPtr& );
-        virtual void end();
-
-        // SlideChangeAnimation
-        virtual void addView( const ViewSharedPtr& rView );
-        virtual bool removeView( const ViewSharedPtr& rView );
-
-    protected:
-        /** Query the size of the bitmaps in device pixel
-         */
-        ::basegfx::B2DSize getBitmapSize() const;
-        
-    private:
-        /** Called on derived classes to implement actual slide change.
-
-        	This method is called with the sprite of the slide coming 'in'
-
-        	@param rSprite
-            Current sprite to operate on. This is the sprite of the
-            'entering' slide
-
-            @param x
-            Current parameter value
-         */
-        virtual void performIn( const ::cppcanvas::CustomSpriteSharedPtr&	rSprite,
-                                const ::cppcanvas::CanvasSharedPtr&			rDestinationCanvas,
-                                double 										t ) = 0;
-
-        /** Called on derived classes to implement actual slide change.
-
-        	This method is called with the sprite of the slide moving 'out'
-
-        	@param rSprite
-            Current sprite to operate on. This is the sprite of the
-            'leaving' slide
-
-            @param x
-            Current parameter value
-         */
-        virtual void performOut( const ::cppcanvas::CustomSpriteSharedPtr&	rSprite,
-                                 const ::cppcanvas::CanvasSharedPtr&		rDestinationCanvas,
-                                 double 									t ) = 0;
-        
-        ViewVector												maViews;
-        SlideBitmapSharedPtr									mpLeavingBitmap;
-        SlideBitmapSharedPtr									mpEnteringBitmap;
-
-        SoundPlayerSharedPtr									mpSoundPlayer;
-
-        typedef ::std::vector< ::cppcanvas::CustomSpriteSharedPtr >	SpriteVector;	
-        SpriteVector											maOutSprites;
-        SpriteVector											maInSprites;
-        bool							   						mbSpritesVisible;
-    };
-
-    SlideChangeBase::SlideChangeBase( const SlideBitmapSharedPtr& rLeavingBitmap,
-                                      const SlideBitmapSharedPtr& rEnteringBitmap,
-                                      const SoundPlayerSharedPtr& rSoundPlayer ) :
-        maViews(),
-        mpLeavingBitmap( rLeavingBitmap ),
-        mpEnteringBitmap( rEnteringBitmap ),
-        mpSoundPlayer( rSoundPlayer ),
-        maOutSprites(),
-        maInSprites(),
-        mbSpritesVisible(false)
-    {
-        ENSURE_AND_THROW(
-            rEnteringBitmap.get(),
-            "SlideChangeBase::SlideChangeBase(): Invalid entering bitmap" );
-    }
+void fillPage( const ::cppcanvas::CanvasSharedPtr& rDestinationCanvas,
+               const ::basegfx::B2DSize&           rPageSizePixel,
+               const RGBColor&                     rFillColor )
+{
+    // need to render without any transformation (we
+    // assume rPageSizePixel to represent device units)
+    const ::cppcanvas::CanvasSharedPtr pDevicePixelCanvas(
+        rDestinationCanvas->clone() );
+    pDevicePixelCanvas->setTransformation( ::basegfx::B2DHomMatrix() );
+    
+    // TODO(F2): Properly respect clip here.
+    // Might have to be transformed, too.
+    const ::basegfx::B2DHomMatrix aViewTransform(
+        rDestinationCanvas->getTransformation() );
+    const ::basegfx::B2DPoint aOutputPosPixel(
+        aViewTransform * ::basegfx::B2DPoint() );
     
-    ::basegfx::B2DSize SlideChangeBase::getBitmapSize() const
+    const ::basegfx::B2DPolygon aPoly(
+        ::basegfx::tools::createPolygonFromRect(
+            ::basegfx::B2DRectangle(
+                aOutputPosPixel.getX(),
+                aOutputPosPixel.getY(),
+                aOutputPosPixel.getX() + rPageSizePixel.getX(),
+                aOutputPosPixel.getY() + rPageSizePixel.getY() ) ) );
+    
+    ::cppcanvas::PolyPolygonSharedPtr pPolyPoly( 
+        ::cppcanvas::BaseGfxFactory::getInstance().createPolyPolygon(
+            pDevicePixelCanvas, aPoly ) );
+    
+    if( pPolyPoly.get() )
     {
-        return ::basegfx::B2DSize( 
-            ::basegfx::B2DTuple( mpEnteringBitmap->getSize() ) );
+        pPolyPoly->setRGBAFillColor( rFillColor.getIntegerColor() );
+        pPolyPoly->draw();
     }
+}
 
-    void SlideChangeBase::start( const AnimatableShapeSharedPtr&,
-                                 const ShapeAttributeLayerSharedPtr& )
-    {
-        if( maInSprites.empty() )
-        {
-            // TODO(P2): change to bitmapsprite once that's working
 
-            // create leaving slide sprites
-            // ============================
+class ClippedSlideChange : public SlideChangeBase
+{
+public:
+    /** Create a new SlideChanger, for the given leaving and
+        entering slide bitmaps, which applies the given clip
+        polygon.
+    */
+    ClippedSlideChange(
+        const SlideSharedPtr&                   pEnteringSlide,
+        const ParametricPolyPolygonSharedPtr&   rPolygon,
+        const TransitionInfo&                   rTransitionInfo,
+        bool                                    bDirectionForward,
+        const SoundPlayerSharedPtr&             pSoundPlayer ) :
+        SlideChangeBase(
+            // leaving bitmap is empty, we're leveraging the fact that the
+            // old slide is still displayed in the background:
+            boost::optional<SlideSharedPtr>(),
+            pEnteringSlide,
+            pSoundPlayer ),
+        maClippingFunctor( rPolygon,
+                           rTransitionInfo,
+                           bDirectionForward,
+                           true )
+        {}
+    
+    virtual void performIn(
+        const ::cppcanvas::CustomSpriteSharedPtr&   rSprite,
+        UnoViewSharedPtr const &                    pView,
+        const ::cppcanvas::CanvasSharedPtr&         rDestinationCanvas,
+        double                                      t );
+    
+    virtual void performOut(
+        const ::cppcanvas::CustomSpriteSharedPtr&  rSprite,
+        UnoViewSharedPtr const &                   pView,
+        const ::cppcanvas::CanvasSharedPtr&        rDestinationCanvas,
+        double                                     t );
+    
+private:
+    ClippingFunctor             maClippingFunctor;
+};
+
+void ClippedSlideChange::performIn(
+    const ::cppcanvas::CustomSpriteSharedPtr&   rSprite,
+    UnoViewSharedPtr const &                    pView,
+    const ::cppcanvas::CanvasSharedPtr&         rDestinationCanvas,
+    double                                      t )
+{
+    rSprite->setClip( maClippingFunctor( t, getEnteringSize() ) );
+}
 
-            if( mpLeavingBitmap.get() )
-            {
-                // create a sprite for every entry in mrViews
-                ::std::transform( maViews.begin(),
-                                  maViews.end(),
-                                  ::std::back_insert_iterator<SpriteVector>(maOutSprites),
-                                  ::boost::bind( &ViewLayer::createSprite,
-                                                 _1,
-                                                 ::basegfx::B2DSize( 
-                                                     ::basegfx::B2DTuple(
-                                                         mpLeavingBitmap->getSize() ) ) ) );
-
-                // set sprite alpha to 1.0 for every sprite
-                ::std::for_each( maOutSprites.begin(),
-                                 maOutSprites.end(),
-                                 ::boost::bind( &::cppcanvas::Sprite::setAlpha,
-                                                _1,
-                                                1.0) );   // default is 0.0, which seems to be 
-            											  // a bad idea when viewing content...
-            }
+void ClippedSlideChange::performOut(
+    const ::cppcanvas::CustomSpriteSharedPtr&  rSprite,
+    UnoViewSharedPtr const &                   pView,
+    const ::cppcanvas::CanvasSharedPtr&        rDestinationCanvas,
+    double                                     t )
+{
+    // not needed here
+}
 
-            // create entering slide sprites
-            // =============================
 
-            // create a sprite for every entry in mrViews
-            ::std::transform( maViews.begin(),
-                              maViews.end(),
-                              ::std::back_insert_iterator<SpriteVector>(maInSprites),
-                              ::boost::bind( &ViewLayer::createSprite,
-                                             _1,
-                                             getBitmapSize() ) );
-
-            // set sprite alpha to 1.0 for every sprite
-            ::std::for_each( maInSprites.begin(),
-                             maInSprites.end(),
-                             ::boost::bind( &::cppcanvas::Sprite::setAlpha,
-                                            _1,
-                                            1.0) );   // default is 0.0, which seems to be 
-            										  // a bad idea when viewing content...
-
-            // start accompanying sound effect, if any
-            if( mpSoundPlayer.get() )
-                mpSoundPlayer->startPlayback();
-        }
-    }
+class FadingSlideChange : public SlideChangeBase
+{
+public:
+    /** Create a new SlideChanger, for the given leaving and
+        entering slides, which applies a fade effect.
+    */
+    FadingSlideChange(
+        boost::optional<SlideSharedPtr> const &          leavingSlide,
+        const SlideSharedPtr&                            pEnteringSlide,
+        const ::comphelper::OptionalValue< RGBColor >&   rFadeColor,
+        const SoundPlayerSharedPtr&                      pSoundPlayer )
+        : SlideChangeBase( leavingSlide,
+                           pEnteringSlide,
+                           pSoundPlayer ),
+          maFadeColor( rFadeColor ),
+          mbFirstTurn( true )
+        {}
+    
+    virtual void performIn(
+        const ::cppcanvas::CustomSpriteSharedPtr&   rSprite,
+        UnoViewSharedPtr const &                    pView,
+        const ::cppcanvas::CanvasSharedPtr&         rDestinationCanvas,
+        double                                      t );
+    
+    virtual void performOut(
+        const ::cppcanvas::CustomSpriteSharedPtr&  rSprite,
+        UnoViewSharedPtr const &                   pView,
+        const ::cppcanvas::CanvasSharedPtr&        rDestinationCanvas,
+        double                                     t );
+    
+private:
+    const ::comphelper::OptionalValue< RGBColor >   maFadeColor;
+    bool                                            mbFirstTurn;
+};
+
+void FadingSlideChange::performIn(
+    const ::cppcanvas::CustomSpriteSharedPtr&   rSprite,
+    UnoViewSharedPtr const &                    pView,
+    const ::cppcanvas::CanvasSharedPtr&         rDestinationCanvas,
+    double                                      t )
+{
+    ENSURE_AND_THROW(
+        rSprite.get(),
+        "FadingSlideChange::performIn(): Invalid sprite" );
+    
+    if( maFadeColor.isValid() )
+        // After half of the active time, fade in new slide
+        rSprite->setAlpha( t > 0.5 ? 2.0*(t-0.5) : 0.0 );
+    else
+        // Fade in new slide over full active time
+        rSprite->setAlpha( t );
+}
 
-    void SlideChangeBase::end()
+void FadingSlideChange::performOut(
+    const ::cppcanvas::CustomSpriteSharedPtr&  rSprite,
+    UnoViewSharedPtr const &                   pView,
+    const ::cppcanvas::CanvasSharedPtr&        rDestinationCanvas,
+    double                                     t )
+{
+    ENSURE_AND_THROW(
+        rSprite.get(),
+        "FadingSlideChange::performOut(): Invalid sprite" );
+    ENSURE_AND_THROW(
+        rDestinationCanvas.get(),
+        "FadingSlideChange::performOut(): Invalid dest canvas" );
+    
+    // only needed for color fades
+    if( maFadeColor.isValid() )
     {
-        // end accompanying sound effect, if any
-        if( mpSoundPlayer.get() )
-            mpSoundPlayer->stopPlayback();
-
-        if (mpEnteringBitmap.get() != 0)
+        if( mbFirstTurn )
         {
-            // draw fully entered bitmap:
-            ViewVector::const_iterator iPos( maViews.begin() );
-            const ViewVector::const_iterator iEnd( maViews.end() );
-            for ( ; iPos != iEnd; ++iPos )
-            {
-                const cppcanvas::CanvasSharedPtr pCanvas(
-                    (*iPos)->getCanvas() );
-                // need to render without any transformation (we
-                // assume device units):
-                const basegfx::B2DHomMatrix viewTransform(
-                    pCanvas->getTransformation() );
-                const basegfx::B2DPoint posPixel(
-                    viewTransform * basegfx::B2DPoint() );
-                const cppcanvas::CanvasSharedPtr pDevicePixelCanvas(
-                    pCanvas->clone() );
-                basegfx::B2DHomMatrix transform;
-                transform.translate( posPixel.getX(), posPixel.getY() );
-                pDevicePixelCanvas->setTransformation( transform );
-                mpEnteringBitmap->draw( pDevicePixelCanvas );
-            }
-            // TODO: Slide::show() initial Sliderendering may be obsolete now
+            mbFirstTurn = false;
+            
+            // clear page to given fade color. 'Leaving' slide is
+            // painted atop of that, but slowly fading out.
+            fillPage( rDestinationCanvas,
+                      getEnteringSizePixel( pView ),
+                      maFadeColor.getValue() );
         }
         
-        mbSpritesVisible = false;
-
-        // drop all references
-        mpLeavingBitmap.reset();
-        mpEnteringBitmap.reset();
-        maOutSprites.clear();
-        maInSprites.clear();
-
-        maViews.clear();
+        // Until half of the active time, fade out old
+        // slide. After half of the active time, old slide
+        // will be invisible.
+        rSprite->setAlpha( t > 0.5 ? 0.0 : 2.0*t );
     }
+}
 
-    bool SlideChangeBase::operator()( double nValue )
-    {
-        if( maInSprites.empty() ||
-            mpEnteringBitmap.get() == NULL )
-        {
-            return false;
-        }
-
-        ENSURE_AND_RETURN( maViews.size() == maInSprites.size(),
-                           "SlideChangeBase::operator(): Mismatching sprite/view numbers" );
-
-        bool bSpritesVisible( mbSpritesVisible );
-
-        for( ::std::size_t i=0, nEntries=maInSprites.size(); i<nEntries; ++i )
-        {
-            // calc sprite offsets. The enter/leaving bitmaps are only
-            // as large as the actual slides. For scaled-down
-            // presentations, we have to move the left, top edge of
-            // those bitmaps to the actual position, governed by the
-            // given view transform. The aSpritePosPixel local
-            // variable is already in device coordinate space
-            // (i.e. pixel).
-
-            ::cppcanvas::CanvasSharedPtr 		pCanvas( maViews[i]->getCanvas() );
-            ::cppcanvas::CustomSpriteSharedPtr 	pInSprite( maInSprites[i] );
-            ::cppcanvas::CustomSpriteSharedPtr 	pOutSprite;
-
-            if( !maOutSprites.empty() )
-                pOutSprite = maOutSprites[i];
-
-            // TODO(F2): Properly respect clip here. Might have to be transformed, too.
-            const ::basegfx::B2DHomMatrix 	aViewTransform( pCanvas->getTransformation() );
-            const ::basegfx::B2DPoint 		aSpritePosPixel( aViewTransform * ::basegfx::B2DPoint() );
-            
-            // move sprite to final output position, in 
-            // device coordinates
-            if( pOutSprite.get() )
-                pOutSprite->movePixel( aSpritePosPixel );
-            pInSprite->movePixel( aSpritePosPixel );
-
-            if( !mbSpritesVisible )
-            {
-                if( pOutSprite.get() )
-                {
-                    // only render once: clipping is done
-                    // exclusively with the sprite
-                    const ::cppcanvas::CanvasSharedPtr pOutContentCanvas( pOutSprite->getContentCanvas() );
-                        
-                    if( pOutContentCanvas.get() )
-                    {
-                        // TODO(Q2): Use basegfx bitmaps here
-                        // TODO(F1): SlideBitmap is not fully portable between different canvases!
-
-                        // render the content
-                        mpLeavingBitmap->draw( pOutContentCanvas );
-                    }
-                }
-
-                // only render once: clipping is done
-                // exclusively with the sprite
-                const ::cppcanvas::CanvasSharedPtr pInContentCanvas( pInSprite->getContentCanvas() );
-                        
-                if( pInContentCanvas.get() )
-                {
-                    // TODO(Q2): Use basegfx bitmaps here
-                    // TODO(F1): SlideBitmap is not fully portable between different canvases!
-
-                    // render the content
-                    mpEnteringBitmap->draw( pInContentCanvas );
-                }
-            }
-
-            // first, call perform method for 'leaving' slide, if it
-            // was specified. After that, call perform on 'entering'
-            // slide mandatorily.
-            if( pOutSprite.get() )
-                performOut( pOutSprite, pCanvas, nValue );
-
-            performIn( pInSprite, pCanvas, nValue );
-
-            // finishing deeds for first run.
-            if( !mbSpritesVisible )
-            {
-                // enable sprites
-                if( pOutSprite.get() )
-                    pOutSprite->show();
-                pInSprite->show();
-                bSpritesVisible = true;
-            }
-        } // for_each( sprite )
-
-        mbSpritesVisible = bSpritesVisible;
-
-        return true;
+class MovingSlideChange : public SlideChangeBase
+{
+    /// Direction vector for leaving slide,
+    const ::basegfx::B2DVector  maLeavingDirection;
+    
+    /// Direction vector for entering slide,
+    const ::basegfx::B2DVector  maEnteringDirection;
+    
+    bool                        mbFirstPerformCall;
+    
+public:
+    /** Create a new SlideChanger, for the given entering slide
+        bitmaps, which performes a moving slide change effect
+        
+        @param rLeavingDirection
+        Direction vector. The move is performed along this
+        direction vector, starting at a position where the leaving
+        slide is fully visible, and ending at a position where the
+        leaving slide is just not visible. The vector must have
+        unit length.
+        
+        @param rEnteringDirection
+        Direction vector. The move is performed along this
+        direction vector, starting at a position where the
+        entering slide is just not visible, and ending at the
+        final slide position. The vector must have unit length.
+    */
+    MovingSlideChange(
+        boost::optional<SlideSharedPtr> const & leavingSlide,
+        const SlideSharedPtr& pEnteringSlide,
+        const SoundPlayerSharedPtr& pSoundPlayer,
+        const ::basegfx::B2DVector& rLeavingDirection,
+        const ::basegfx::B2DVector& rEnteringDirection )
+        : SlideChangeBase(
+            leavingSlide, pEnteringSlide, pSoundPlayer,
+            // Optimization: when leaving bitmap is given,
+            // but it does not move, don't create sprites for it,
+            // we simply paint it once at startup:
+            !rLeavingDirection.equalZero() /* bCreateLeavingSprites */,
+            !rEnteringDirection.equalZero() /* bCreateEnteringSprites */ ),
+          // TODO(F1): calc correct length of direction
+          // vector. Directions not strictly horizontal or vertical
+          // must travel a longer distance.
+          maLeavingDirection( rLeavingDirection ),
+          // TODO(F1): calc correct length of direction
+          // vector. Directions not strictly horizontal or vertical
+          // must travel a longer distance.
+          maEnteringDirection( rEnteringDirection ),
+          mbFirstPerformCall( true )
+        {}
+    
+    virtual void performIn(
+        const ::cppcanvas::CustomSpriteSharedPtr&   rSprite,
+        UnoViewSharedPtr const &                    pView,
+        const ::cppcanvas::CanvasSharedPtr&         rDestinationCanvas,
+        double                                      t );
+    
+    virtual void performOut(
+        const ::cppcanvas::CustomSpriteSharedPtr&  rSprite,
+        UnoViewSharedPtr const &                   pView,
+        const ::cppcanvas::CanvasSharedPtr&        rDestinationCanvas,
+        double                                     t );
+};
+
+void MovingSlideChange::performIn(
+    const ::cppcanvas::CustomSpriteSharedPtr&   rSprite,
+    UnoViewSharedPtr const &                    pView,
+    const ::cppcanvas::CanvasSharedPtr&         rDestinationCanvas,
+    double                                      t )
+{
+    // intro sprite moves:
+    
+    ENSURE_AND_THROW(
+        rSprite.get(),
+        "MovingSlideChange::performIn(): Invalid sprite" );
+    ENSURE_AND_THROW(
+        rDestinationCanvas.get(),
+        "MovingSlideChange::performIn(): Invalid dest canvas" );
+    
+    if (mbFirstPerformCall && maLeavingDirection.equalZero()) {
+        mbFirstPerformCall = false;
+        renderBitmap( getLeavingBitmap(), rDestinationCanvas );
     }
+    
+    // TODO(F1): This does not account for non-translational
+    // transformations! If the canvas is rotated, we still
+    // move the sprite unrotated (which might or might not
+    // produce the intended effect).
+    const basegfx::B2DHomMatrix aViewTransform(
+        rDestinationCanvas->getTransformation() );
+    const basegfx::B2DPoint aPageOrigin(
+        aViewTransform * basegfx::B2DPoint() );
+    
+    // move sprite
+    rSprite->movePixel(
+        aPageOrigin +
+        ((t - 1.0) * 
+         ::basegfx::B2DSize( getEnteringSizePixel(pView) ) * 
+         maEnteringDirection) );
+}
 
-    double SlideChangeBase::getUnderlyingValue() const
-    {
-        return 0.0;     // though this should be used in concert with 
-					    // ActivitiesFactory::createSimpleActivity, better
-    					// explicitely name our start value.
-					    // Permissible range for operator() above is [0,1]
+void MovingSlideChange::performOut(
+    const ::cppcanvas::CustomSpriteSharedPtr&  rSprite,
+    UnoViewSharedPtr const &                   pView,
+    const ::cppcanvas::CanvasSharedPtr&        rDestinationCanvas,
+    double                                     t )
+{
+    // outro sprite moves:
+    
+    ENSURE_AND_THROW(
+        rSprite.get(),
+        "MovingSlideChange::performOut(): Invalid sprite" );
+    ENSURE_AND_THROW(
+        rDestinationCanvas.get(),
+        "MovingSlideChange::performOut(): Invalid dest canvas" );
+    
+    if (mbFirstPerformCall && maEnteringDirection.equalZero()) {
+        mbFirstPerformCall = false;
+        renderBitmap( getEnteringBitmap(), rDestinationCanvas );
     }
+    
+    // TODO(F1): This does not account for non-translational
+    // transformations! If the canvas is rotated, we still
+    // move the sprite unrotated (which might or might not
+    // produce the intended effect).
+    const basegfx::B2DHomMatrix aViewTransform(
+        rDestinationCanvas->getTransformation() );
+    const basegfx::B2DPoint aPageOrigin(
+        aViewTransform * basegfx::B2DPoint() );
+    
+    // move sprite
+    rSprite->movePixel(
+        aPageOrigin + (t * 
+                       ::basegfx::B2DSize( getEnteringSizePixel(pView) ) * 
+                       maLeavingDirection) );
+}
 
-    void SlideChangeBase::addView( const ViewSharedPtr& rView )
-    {
-        // TODO(Q2): Try to use UnoViewContainer here, and only create
-        // new sprites here (when new views are added during animation
-        // playback).
-        maViews.push_back( rView );
-    }
 
-    bool SlideChangeBase::removeView( const ViewSharedPtr& rView )
+SlideChangeAnimationSharedPtr createPushWipeTransition(
+    boost::optional<SlideSharedPtr> const &         leavingSlide_,
+    const SlideSharedPtr&                           pEnteringSlide,
+    sal_Int16                                       nTransitionType,
+    sal_Int16                                       nTransitionSubType,
+    bool                                            bTransitionDirection,
+    const SoundPlayerSharedPtr&                     pSoundPlayer )
+{
+    boost::optional<SlideSharedPtr> leavingSlide; // no bitmap
+    if (leavingSlide_ && (*leavingSlide_).get() != 0)
     {
-        // remove locally
-        const ViewVector::iterator aEnd( maViews.end() );
-        ViewVector::iterator aIter;
-        if( (aIter=::std::remove( maViews.begin(), 
-                                  aEnd, 
-                                  rView)) == aEnd )
-        {
-            // view seemingly was not added, failed
-            return false;
-        }
-
-        // actually erase from container
-        maViews.erase( aIter, aEnd );
-
-        return true;
+        // opt: only page, if we've an
+        // actual slide to move out here. We
+        // _don't_ need a fake black background
+        // bitmap, neither for push nor for comb
+        // wipes.
+        leavingSlide = leavingSlide_;
     }
-
-
-    class ClippedSlideChange : public SlideChangeBase
-    {
-    public:
-        /** Create a new SlideChanger, for the given leaving and
-            entering slide bitmaps, which applies the given clip
-            polygon.
-
-            @param rEnteringBitmap
-            Bitmap that contains the slide image of the entering slide
-
-            @param rSlideSize
-            Slide side in user coordinate space
-        */
-        ClippedSlideChange( const SlideBitmapSharedPtr& 			rEnteringBitmap,
-                            const ParametricPolyPolygonSharedPtr&   rPolygon,
-                            const TransitionInfo&                   rTransitionInfo,
-                            const ::basegfx::B2DSize&				rSlideSize,
-                            bool                                    bDirectionForward,
-                            const SoundPlayerSharedPtr& 			rSoundPlayer ) :
-            SlideChangeBase( SlideBitmapSharedPtr(), // leaving bitmap
-                                                     // is empty,
-                                                     // we're
-                                                     // leveraging the
-                                                     // fact that the
-                                                     // old slide is
-                                                     // still
-                                                     // displayed in
-                                                     // the background.
-                             rEnteringBitmap,
-                             rSoundPlayer ),
-            maClippingFunctor( rPolygon,
-                               rTransitionInfo,
-                               bDirectionForward,
-                               true ),
-            maSlideSize( rSlideSize )
-        {
-        }
-
-        virtual void performIn( const ::cppcanvas::CustomSpriteSharedPtr& 	rSprite,
-                                const ::cppcanvas::CanvasSharedPtr&			rDestinationCanvas,
-                                double 										t )
-        {
-            rSprite->setClip( 
-                maClippingFunctor( t,
-                                   maSlideSize ) );
-        }
+    
+    // setup direction vector
+    bool bComb( false );
+    ::basegfx::B2DVector aDirection;
+    switch( nTransitionSubType )
+    {
+    default:
+        OSL_ENSURE(
+            false, 
+            "createPushWipeTransition(): Unexpected transition "
+            "subtype for animations::TransitionType::PUSHWIPE "
+            "transitions" );
+        return SlideChangeAnimationSharedPtr();
         
-        virtual void performOut( const ::cppcanvas::CustomSpriteSharedPtr&	rSprite,
-                                 const ::cppcanvas::CanvasSharedPtr&		rDestinationCanvas,
-                                 double 									t )
-        {
-            // not needed here
-        }
-
-    private:
-        ClippingFunctor				maClippingFunctor;
-        const ::basegfx::B2DSize	maSlideSize;
-    };
-
-
-    class FadingSlideChange : public SlideChangeBase
-    {
-    public:
-        /** Create a new SlideChanger, for the given leaving and
-            entering slide bitmaps, which applies a fade effect.
-
-            @param rEnteringBitmap
-            Bitmap that contains the slide image of the entering slide
-        */
-        FadingSlideChange( const SlideBitmapSharedPtr& 						rLeavingBitmap,
-                           const SlideBitmapSharedPtr& 						rEnteringBitmap,
-                           const ::comphelper::OptionalValue< RGBColor >&	rFadeColor,
-                           const SoundPlayerSharedPtr& 						rSoundPlayer ) :
-            SlideChangeBase( rLeavingBitmap,
-                             rEnteringBitmap,
-                             rSoundPlayer ),
-            maFadeColor( rFadeColor ),
-            mbFirstTurn( true )
-        {
-        }
-
-        virtual void performIn( const ::cppcanvas::CustomSpriteSharedPtr& 	rSprite,
-                                const ::cppcanvas::CanvasSharedPtr&			rDestinationCanvas,
-                                double 										t )
-        {
-            ENSURE_AND_THROW( rSprite.get(),
-                              "FadingSlideChange::performIn(): Invalid sprite" );
-
-            if( maFadeColor.isValid() )
-                // After half of the active time, fade in new slide
-                rSprite->setAlpha( t > 0.5 ? 2.0*(t-0.5) : 0.0 );
-            else
-                // Fade in new slide over full active time
-                rSprite->setAlpha( t );
-        }
+    case animations::TransitionSubType::FROMTOP:
+        aDirection = ::basegfx::B2DVector( 0.0, 1.0 );
+        break;
         
-        virtual void performOut( const ::cppcanvas::CustomSpriteSharedPtr&	rSprite,
-                                 const ::cppcanvas::CanvasSharedPtr&		rDestinationCanvas,
-                                 double 									t )
-        {
-            ENSURE_AND_THROW( rSprite.get(),
-                              "FadingSlideChange::performOut(): Invalid sprite" );
-            ENSURE_AND_THROW( rDestinationCanvas.get(),
-                              "FadingSlideChange::performOut(): Invalid dest canvas" );
-
-            // only needed for color fades
-            if( maFadeColor.isValid() )
-            {
-                if( mbFirstTurn )
-                {
-                    mbFirstTurn = false;
-
-                    // clear page to given fade color. 'Leaving' slide is
-                    // painted atop of that, but slowly fading out.
-                    fillPage( rDestinationCanvas,
-                              getBitmapSize(),
-                              maFadeColor.getValue() );
-                }
-                
-                // Until half of the active time, fade out old
-                // slide. After half of the active time, old slide
-                // will be invisible.
-                rSprite->setAlpha( t > 0.5 ? 0.0 : 2.0*t );
-            }
-        }
+    case animations::TransitionSubType::FROMBOTTOM:
+        aDirection = ::basegfx::B2DVector( 0.0, -1.0 );
+        break;
         
-    private:
-        const ::comphelper::OptionalValue< RGBColor >	maFadeColor;
-        bool											mbFirstTurn;
-    };
-
-    /** To avoid ternary operator in initializer below (Solaris
-     * compiler problems)
-     */
-    SlideBitmapSharedPtr selectLeavingBitmap( bool 							bDontUseBitmap,
-                                              const SlideBitmapSharedPtr& 	rBitmap )
-    {
-        if( bDontUseBitmap ) 
-            return SlideBitmapSharedPtr();
-        else
-            return rBitmap;
-    }
-
-
-    class MovingSlideChange : public SlideChangeBase
-    {
-    public:
-        /** Create a new SlideChanger, for the given entering slide
-            bitmaps, which performes a moving slide change effect
-
-            @param rLeavingBitmap
-            Bitmap that contains the slide image of the leaving slide
-
-            @param rEnteringBitmap
-            Bitmap that contains the slide image of the entering slide
-
-            @param rLeavingDirection
-            Direction vector. The move is performed along this
-            direction vector, starting at a position where the leaving
-            slide is fully visible, and ending at a position where the
-            leaving slide is just not visible. The vector must have
-            unit length.
-
-            @param rEnteringDirection
-            Direction vector. The move is performed along this
-            direction vector, starting at a position where the
-            entering slide is just not visible, and ending at the
-            final slide position. The vector must have unit length.
-        */
-        MovingSlideChange( const SlideBitmapSharedPtr& rLeavingBitmap,
-                           const SlideBitmapSharedPtr& rEnteringBitmap,
-                           const ::basegfx::B2DVector& rLeavingDirection,
-                           const ::basegfx::B2DVector& rEnteringDirection,
-                           bool						   bDirectionForward,
-                           const SoundPlayerSharedPtr& rSoundPlayer ) :
-            // Optimization: when leaving bitmap is given, but it does
-            // not move, don't pass on to SlideChangeBase: we simply
-            // paint it once at startup.
-            SlideChangeBase( 
-                selectLeavingBitmap( 
-                    rLeavingDirection.equalZero(),
-                    rLeavingBitmap ),
-                rEnteringBitmap,
-                rSoundPlayer ),
-            maBitmapSize( getBitmapSize() ),
-            mpLeavingBitmap( rLeavingBitmap ),
-            // TODO(F1): calc correct length of direction
-            // vector. Directions not strictly horizontal or vertical
-            // must travel a longer distance.
-            maLeavingDirection( maBitmapSize * 
-                                rLeavingDirection ),
-            // TODO(F1): calc correct length of direction
-            // vector. Directions not strictly horizontal or vertical
-            // must travel a longer distance.
-            maEnteringDirection( maBitmapSize *
-                                 rEnteringDirection ),
-            mbDirectionForward( bDirectionForward ),
-            mbFirstPerformCall( true )
-        {
-        }
-
-        void renderLeavingBitmap( const ::cppcanvas::CanvasSharedPtr& rDestinationCanvas )
-        {
-            if( mbFirstPerformCall )
-            {
-                mbFirstPerformCall = false;
-
-                if( maLeavingDirection.equalZero() &&
-                    mpLeavingBitmap.get() )
-                {
-                    // leaving bitmap given, which is static (and
-                    // therefore not passed to SlideChangeBase): paint
-                    // once on first performIn callstartup
-                    const ::basegfx::B2DHomMatrix 	aViewTransform( rDestinationCanvas->getTransformation() );
-                    const ::basegfx::B2DPoint 		aOutPosPixel( aViewTransform * ::basegfx::B2DPoint() );
-
-                    // setup a canvas with device coordinate space,
-                    // the slide bitmap already has the correct
-                    // dimension.
-                    ::cppcanvas::CanvasSharedPtr pDevicePixelCanvas( rDestinationCanvas->clone() );
-                    pDevicePixelCanvas->setTransformation( ::basegfx::B2DHomMatrix() );
-
-                    // render at given output position
-                    mpLeavingBitmap->move( aOutPosPixel );
-                    mpLeavingBitmap->draw( pDevicePixelCanvas );
-                }
-            }
-
-        }
+    case animations::TransitionSubType::FROMLEFT:
+        aDirection = ::basegfx::B2DVector( 1.0, 0.0 );
+        break;
         
-        virtual void performIn( const ::cppcanvas::CustomSpriteSharedPtr& 	rSprite,
-                                const ::cppcanvas::CanvasSharedPtr&			rDestinationCanvas,
-                                double 										t )
-        {
-            ENSURE_AND_THROW( rSprite.get(),
-                              "MovingSlideChange::performIn(): Invalid sprite" );
-            ENSURE_AND_THROW( rDestinationCanvas.get(),
-                              "MovingSlideChange::performIn(): Invalid dest canvas" );
-
-            renderLeavingBitmap( rDestinationCanvas );
-
-            // TODO(F1): This does not account for non-translational
-            // transformations! If the canvas is rotated, we still
-            // move the sprite unrotated (which might or might not
-            // produce the intended effect).
-            const ::basegfx::B2DHomMatrix 	aViewTransform( rDestinationCanvas->getTransformation() );
-            const ::basegfx::B2DPoint 		aPageOrigin( aViewTransform * ::basegfx::B2DPoint() );
-
-            t = mbDirectionForward ? t : 1.0 - t;
-
-            // move sprite
-            rSprite->movePixel( aPageOrigin + (t-1.0)*maEnteringDirection );
-        }
-
-        virtual void performOut( const ::cppcanvas::CustomSpriteSharedPtr&	rSprite,
-                                 const ::cppcanvas::CanvasSharedPtr&		rDestinationCanvas,
-                                 double 									t )
-        {
-            ENSURE_AND_THROW( rSprite.get(),
-                              "MovingSlideChange::performOut(): Invalid sprite" );
-            ENSURE_AND_THROW( rDestinationCanvas.get(),
-                              "MovingSlideChange::performOut(): Invalid dest canvas" );
-
-            renderLeavingBitmap( rDestinationCanvas );
-
-            // TODO(F1): This does not account for non-translational
-            // transformations! If the canvas is rotated, we still
-            // move the sprite unrotated (which might or might not
-            // produce the intended effect).
-            const ::basegfx::B2DHomMatrix 	aViewTransform( rDestinationCanvas->getTransformation() );
-            const ::basegfx::B2DPoint 		aPageOrigin( aViewTransform * ::basegfx::B2DPoint() );
-            
-            t = mbDirectionForward ? t : 1.0 - t;
-
-            // move sprite
-            rSprite->movePixel( aPageOrigin + t*maLeavingDirection );
-        }
-
-    private:
-        const ::basegfx::B2DSize	maBitmapSize;
-
-        /// Local copy, in case it's not passed on to base class
-        SlideBitmapSharedPtr		mpLeavingBitmap;
-
-        /// Direction vector for leaving slide, already scaled up to full slide size
-        const ::basegfx::B2DVector 	maLeavingDirection;
-
-        /// Direction vector for entering slide, already scaled up to full slide size
-        const ::basegfx::B2DVector 	maEnteringDirection;
-
-        /// When false, t parameter sweep is inverted
-        const bool 					mbDirectionForward;
-
-        bool						mbFirstPerformCall;
-    };
-
-    ::cppcanvas::CanvasSharedPtr getCanvasFromView( const UnoViewContainer& rViews )
-    {
-        ENSURE_AND_THROW( !rViews.empty(),
-                          "getCanvasFromView(): Empty view container!" );
-
-        // TODO(F2): Generalize to multiple, multi-device views
-        return (*rViews.begin())->getCanvas();
+    case animations::TransitionSubType::FROMRIGHT:
+        aDirection = ::basegfx::B2DVector( -1.0, 0.0 );
+        break;
+        
+    case animations::TransitionSubType::FROMBOTTOMRIGHT:
+        aDirection = ::basegfx::B2DVector( -1.0, -1.0 );
+        break;
+        
+    case animations::TransitionSubType::FROMBOTTOMLEFT:
+        aDirection = ::basegfx::B2DVector( 1.0, -1.0 );
+        break;
+        
+    case animations::TransitionSubType::FROMTOPRIGHT:
+        aDirection = ::basegfx::B2DVector( -1.0, 1.0 );
+        break;
+        
+    case animations::TransitionSubType::FROMTOPLEFT:
+        aDirection = ::basegfx::B2DVector( 1.0, 1.0 );
+        break;
+        
+    case animations::TransitionSubType::COMBHORIZONTAL:
+        aDirection = ::basegfx::B2DVector( 1.0, 0.0 );
+        bComb = true;
+        break;
+        
+    case animations::TransitionSubType::COMBVERTICAL:
+        aDirection = ::basegfx::B2DVector( 0.0, 1.0 );
+        bComb = true;
+        break;
     }
-
-    /** Retrieve bitmap for given slide.
-
-		If the slide ptr is invalid, a black bitmap is created.
-     */
-    SlideBitmapSharedPtr retrieveSlideBitmap( const SlideSharedPtr& 	rSlide,
-                                              const UnoViewContainer&	rViews,
-                                              const ::basegfx::B2DSize	rSlideSize )
+    
+    if( bComb )
     {
-        if( rSlide.get() )
-        {
-            // TODO(F2): Generalize to multiple, multi-device views
-            return rSlide->getCurrentSlideBitmap( *rViews.begin() );
-        }
-        else
-        {
-            ::cppcanvas::CanvasSharedPtr pCanvas( getCanvasFromView( rViews ) );
-
-            // convert slide size to device coordinate system (i.e. pixel)
-            const ::basegfx::B2DHomMatrix aViewTransform( pCanvas->getTransformation() );
-            const ::basegfx::B2DSize aFloatBmpSize( aViewTransform * rSlideSize );
-
-            // create a fully black bitmap (black is the default
-            // background, used when no slides are present)
-            const ::basegfx::B2ISize aBmpSize( 
-                ::basegfx::fround( aFloatBmpSize.getX() ),
-                ::basegfx::fround( aFloatBmpSize.getY() ) );
-
-            // create a bitmap of appropriate size
-            ::cppcanvas::BitmapSharedPtr pBitmap( 
-                ::cppcanvas::BaseGfxFactory::getInstance().createBitmap( 
-                    pCanvas, 
-                    aBmpSize ) );
-
-            ENSURE_AND_THROW( pBitmap.get(),
-                              "retrieveLeavingBitmap(): Cannot create page bitmap" );
-
-            ::cppcanvas::BitmapCanvasSharedPtr pBitmapCanvas( pBitmap->getBitmapCanvas() );
-
-            ENSURE_AND_THROW( pBitmapCanvas.get(),
-                              "retrieveLeavingBitmap(): Cannot create page bitmap canvas" );
-
-            // set transformation to identitiy (->device pixel)
-            pBitmapCanvas->setTransformation( ::basegfx::B2DHomMatrix() );
-            
-            // fill the bounds rectangle in white
-            ::basegfx::B2DPolygon aPoly;                
-            aPoly.append( ::basegfx::B2DPoint() );
-            aPoly.append( ::basegfx::B2DPoint(rSlideSize.getX(), 0) );
-            aPoly.append( ::basegfx::B2DPoint(rSlideSize.getX(), rSlideSize.getY()) );
-            aPoly.append( ::basegfx::B2DPoint(0, rSlideSize.getY()) );
-            aPoly.setClosed(true);
-            
-            ::cppcanvas::PolyPolygonSharedPtr pPolyPoly( 
-                ::cppcanvas::BaseGfxFactory::getInstance().createPolyPolygon( pBitmapCanvas, 
-                                                                              aPoly ) );
-            
-            if( pPolyPoly.get() )
-            {
-                pPolyPoly->setRGBAFillColor( 0x00000000U );
-                pPolyPoly->draw();
-            }
-
-            return SlideBitmapSharedPtr( new SlideBitmap( pBitmap ) );
-        }
+        return SlideChangeAnimationSharedPtr(
+            new CombTransition( leavingSlide,
+                                pEnteringSlide,
+                                pSoundPlayer,
+                                aDirection, 
+                                24 /* comb with 12 stripes */ ) );
+    }
+    else
+    {
+        return SlideChangeAnimationSharedPtr( 
+            new MovingSlideChange( leavingSlide,
+                                   pEnteringSlide,
+                                   pSoundPlayer,
+                                   aDirection, 
+                                   aDirection ) );
     }
+}
 
-    SlideChangeAnimationSharedPtr createPushWipeTransition(
-        const SlideSharedPtr& 							rLeavingSlide,
-        const SlideSharedPtr& 							rEnteringSlide,
-        const UnoViewContainer&							rViews,
-        const ::basegfx::B2DSize&						rSlideSize,
-        sal_Int16               						nTransitionType,
-        sal_Int16               						nTransitionSubType,
-        bool											bTransitionDirection,
-        const SoundPlayerSharedPtr& 					rSoundPlayer )
-    {
-        SlideBitmapSharedPtr pLeavingBitmap;
+SlideChangeAnimationSharedPtr createSlideWipeTransition(
+    boost::optional<SlideSharedPtr> const &         leavingSlide,
+    const SlideSharedPtr&                           pEnteringSlide,
+    sal_Int16                                       nTransitionType,
+    sal_Int16                                       nTransitionSubType,
+    bool                                            bTransitionDirection,
+    const SoundPlayerSharedPtr&                     pSoundPlayer )
+{
+    // setup 'in' direction vector
+    ::basegfx::B2DVector aInDirection;
+    switch( nTransitionSubType )
+    {
+    default:
+        OSL_ENSURE(
+            false, 
+            "createSlideWipeTransition(): Unexpected transition "
+            "subtype for animations::TransitionType::SLIDEWIPE "
+            "transitions" );
+        return SlideChangeAnimationSharedPtr();
         
-        SlideBitmapSharedPtr pEnteringBitmap(
-            retrieveSlideBitmap( rEnteringSlide,
-                                 rViews,
-                                 rSlideSize ) );
-
-        if( rLeavingSlide.get() )
-        {
-            // only get leaving bitmap, if we've an
-            // actual slide to move out here. We
-            // _don't_ need a fake black background
-            // bitmap, neither for push nor for comb
-            // wipes.
-            pLeavingBitmap = retrieveSlideBitmap( rLeavingSlide,
-                                                  rViews,
-                                                  rSlideSize );
-        }
-
-        // setup direction vector
-        bool bComb( false );
-        ::basegfx::B2DVector aDirection;
-        switch( nTransitionSubType )
-        {
-            default:
-                OSL_ENSURE( false, 
-                            "createPushWipeTransition(): Unexpected transition "
-                            "subtype for animations::TransitionType::PUSHWIPE transitions" );
-                return SlideChangeAnimationSharedPtr();
-
-            case animations::TransitionSubType::FROMTOP:
-                aDirection = ::basegfx::B2DVector( 0.0, 1.0 );
-                break;
-
-            case animations::TransitionSubType::FROMBOTTOM:
-                aDirection = ::basegfx::B2DVector( 0.0, -1.0 );
-                break;
-
-            case animations::TransitionSubType::FROMLEFT:
-                aDirection = ::basegfx::B2DVector( 1.0, 0.0 );
-                break;
-
-            case animations::TransitionSubType::FROMRIGHT:
-                aDirection = ::basegfx::B2DVector( -1.0, 0.0 );
-                break;
-
-            case animations::TransitionSubType::FROMBOTTOMRIGHT:
-                aDirection = ::basegfx::B2DVector( -1.0, -1.0 );
-                break;
-
-            case animations::TransitionSubType::FROMBOTTOMLEFT:
-                aDirection = ::basegfx::B2DVector( 1.0, -1.0 );
-                break;
-
-            case animations::TransitionSubType::FROMTOPRIGHT:
-                aDirection = ::basegfx::B2DVector( -1.0, 1.0 );
-                break;
-
-            case animations::TransitionSubType::FROMTOPLEFT:
-                aDirection = ::basegfx::B2DVector( 1.0, 1.0 );
-                break;
-
-            case animations::TransitionSubType::COMBHORIZONTAL:
-                aDirection = ::basegfx::B2DVector( 1.0, 0.0 );
-                bComb = true;
-                break;
-
-            case animations::TransitionSubType::COMBVERTICAL:
-                aDirection = ::basegfx::B2DVector( 0.0, 1.0 );
-                bComb = true;
-                break;
-        }
-
-        if( bComb )
-        {
-            return SlideChangeAnimationSharedPtr( 
-                new CombTransition( pLeavingBitmap,
-                                    pEnteringBitmap,
-                                    aDirection, 
-                                    24,
-                                    rSoundPlayer ) ); // comb with 12 stripes
-        }
-        else
-        {
-            return SlideChangeAnimationSharedPtr( 
-                new MovingSlideChange( pLeavingBitmap,
-                                       pEnteringBitmap,
-                                       aDirection, 
-                                       aDirection,
-                                       true,
-                                       rSoundPlayer ) );
-        }
+    case animations::TransitionSubType::FROMTOP:
+        aInDirection = ::basegfx::B2DVector( 0.0, 1.0 );
+        break;
+        
+    case animations::TransitionSubType::FROMRIGHT:
+        aInDirection = ::basegfx::B2DVector( -1.0, 0.0 );
+        break;
+        
+    case animations::TransitionSubType::FROMLEFT:
+        aInDirection = ::basegfx::B2DVector( 1.0, 0.0 );
+        break;
+        
+    case animations::TransitionSubType::FROMBOTTOM:
+        aInDirection = ::basegfx::B2DVector( 0.0, -1.0 );
+        break;
+        
+    case animations::TransitionSubType::FROMBOTTOMRIGHT:
+        aInDirection = ::basegfx::B2DVector( -1.0, -1.0 );
+        break;
+        
+    case animations::TransitionSubType::FROMBOTTOMLEFT:
+        aInDirection = ::basegfx::B2DVector( 1.0, -1.0 );
+        break;
+        
+    case animations::TransitionSubType::FROMTOPRIGHT:
+        aInDirection = ::basegfx::B2DVector( -1.0, 1.0 );
+        break;
+        
+    case animations::TransitionSubType::FROMTOPLEFT:
+        aInDirection = ::basegfx::B2DVector( 1.0, 1.0 );
+        break;
     }
-
-    SlideChangeAnimationSharedPtr createSlideWipeTransition(
-        const SlideSharedPtr& 							rLeavingSlide,
-        const SlideSharedPtr& 							rEnteringSlide,
-        const UnoViewContainer&							rViews,
-        const ::basegfx::B2DSize&						rSlideSize,
-        sal_Int16               						nTransitionType,
-        sal_Int16               						nTransitionSubType,
-        bool											bTransitionDirection,
-        const SoundPlayerSharedPtr& 					rSoundPlayer )
+    
+    if( bTransitionDirection )
     {
-        // setup 'in' direction vector
-        ::basegfx::B2DVector aInDirection;
-        switch( nTransitionSubType )
-        {
-            default:
-                OSL_ENSURE( false, 
-                            "createSlideWipeTransition(): Unexpected transition "
-                            "subtype for animations::TransitionType::SLIDEWIPE transitions" );
-                return SlideChangeAnimationSharedPtr();
-
-            case animations::TransitionSubType::FROMTOP:
-                aInDirection = ::basegfx::B2DVector( 0.0, 1.0 );
-                break;
-
-            case animations::TransitionSubType::FROMRIGHT:
-                aInDirection = ::basegfx::B2DVector( -1.0, 0.0 );
-                break;
-
-            case animations::TransitionSubType::FROMLEFT:
-                aInDirection = ::basegfx::B2DVector( 1.0, 0.0 );
-                break;
-
-            case animations::TransitionSubType::FROMBOTTOM:
-                aInDirection = ::basegfx::B2DVector( 0.0, -1.0 );
-                break;
-
-            case animations::TransitionSubType::FROMBOTTOMRIGHT:
-                aInDirection = ::basegfx::B2DVector( -1.0, -1.0 );
-                break;
-
-            case animations::TransitionSubType::FROMBOTTOMLEFT:
-                aInDirection = ::basegfx::B2DVector( 1.0, -1.0 );
-                break;
-
-            case animations::TransitionSubType::FROMTOPRIGHT:
-                aInDirection = ::basegfx::B2DVector( -1.0, 1.0 );
-                break;
-
-            case animations::TransitionSubType::FROMTOPLEFT:
-                aInDirection = ::basegfx::B2DVector( 1.0, 1.0 );
-                break;
-        }
-
-        if( bTransitionDirection )
-        {
-            // normal, 'forward' slide wipe effect. Since the old
-            // content is still on screen (and does not move), we can
-            // pass the 'leaving' bitmap empty.
-            // =======================================================
-
-            return SlideChangeAnimationSharedPtr( 
-                new MovingSlideChange( SlideBitmapSharedPtr(),
-                                       retrieveSlideBitmap( rEnteringSlide,
-                                                            rViews,
-                                                            rSlideSize ),
-                                       ::basegfx::B2DVector(),
-                                       aInDirection,
-                                       true,
-                                       rSoundPlayer ) );
-        }
-        else
-        {
-            // 'reversed' slide wipe effect. Reverse for slide wipes
-            // means, that the new slide is in the back, statically,
-            // and the old one is moving off in the foreground. Since
-            // the old content is moving, we need a bitmap for it in
-            // any case.
-            // =======================================================
-
-            return SlideChangeAnimationSharedPtr( 
-                new MovingSlideChange( retrieveSlideBitmap( rEnteringSlide,
-                                                            rViews,
-                                                            rSlideSize ),
-                                       retrieveSlideBitmap( rLeavingSlide,
-                                                            rViews,
-                                                            rSlideSize ),
-                                       ::basegfx::B2DVector(),
-                                       // flip direction, to match
-                                       // 'reverse mode' for parameter sweep
-                                       -1.0*aInDirection,
-                                       false,
-                                       rSoundPlayer ) );
-        }
+        // normal, 'forward' slide wipe effect. Since the old
+        // content is still on screen (and does not move), we omit
+        // the 'leaving' slide.
+        // =======================================================
+        
+        return SlideChangeAnimationSharedPtr( 
+            new MovingSlideChange(
+                boost::optional<SlideSharedPtr>() /* no slide */,
+                pEnteringSlide,
+                pSoundPlayer,
+                basegfx::B2DVector(),
+                aInDirection ) );
+    }
+    else
+    {
+        // 'reversed' slide wipe effect. Reverse for slide wipes
+        // means, that the new slide is in the back, statically,
+        // and the old one is moving off in the foreground.
+        // =======================================================
+        
+        return SlideChangeAnimationSharedPtr( 
+            new MovingSlideChange(
+                leavingSlide,
+                pEnteringSlide,
+                pSoundPlayer,
+                aInDirection,
+                basegfx::B2DVector() ) );
     }
+}
 
 } // anon namespace
 
 
 SlideChangeAnimationSharedPtr TransitionFactory::createSlideTransition(
-    const SlideSharedPtr& 							rLeavingSlide,
-    const SlideSharedPtr& 							rEnteringSlide,
-    const UnoViewContainer&							rViews,
-    const ::basegfx::B2DSize&						rSlideSize,
-    sal_Int16               						nTransitionType,
-    sal_Int16               						nTransitionSubType,
-    bool											bTransitionDirection,
-    const ::comphelper::OptionalValue< RGBColor >&	rTransitionFadeColor,
-    const SoundPlayerSharedPtr& 					rSoundPlayer			)
+    const SlideSharedPtr&                           pLeavingSlide,
+    const SlideSharedPtr&                           pEnteringSlide,
+    sal_Int16                                       nTransitionType,
+    sal_Int16                                       nTransitionSubType,
+    bool                                            bTransitionDirection,
+    const ::comphelper::OptionalValue< RGBColor >&  rTransitionFadeColor,
+    const SoundPlayerSharedPtr&                     pSoundPlayer            )
 {
     ENSURE_AND_THROW(
-        rEnteringSlide.get(),
+        pEnteringSlide.get(),
         "TransitionFactory::createSlideTransition(): Invalid entering slide" );
     
     const TransitionInfo* pTransitionInfo( 
         getTransitionInfo( nTransitionType, nTransitionSubType ) );
 
-    ::cppcanvas::CanvasSharedPtr pCanvas( getCanvasFromView(rViews) );
-
     if( pTransitionInfo != NULL )
     {
         switch( pTransitionInfo->meTransitionClass )
@@ -1070,8 +625,8 @@
             default:
             case TransitionInfo::TRANSITION_INVALID:
                 OSL_TRACE(
-                    "TransitionFactory::createSlideTransition(): Invalid type/subtype (%d/%d) "
-                    "combination encountered.",
+                    "TransitionFactory::createSlideTransition(): "
+                    "Invalid type/subtype (%d/%d) combination encountered.",
                     nTransitionType,
                     nTransitionSubType );
                 return SlideChangeAnimationSharedPtr();
@@ -1083,20 +638,14 @@
                 ParametricPolyPolygonSharedPtr pPoly( 
                     ParametricPolyPolygonFactory::createClipPolyPolygon( 
                         nTransitionType, nTransitionSubType ) );
-                
-                SlideBitmapSharedPtr pEnteringBitmap( 
-                    retrieveSlideBitmap( rEnteringSlide,
-                                         rViews,
-                                         rSlideSize ) );
 
                 // create a clip transition from that
-                return SlideChangeAnimationSharedPtr( 
-                    new ClippedSlideChange( pEnteringBitmap,
+                return SlideChangeAnimationSharedPtr(
+                    new ClippedSlideChange( pEnteringSlide,
                                             pPoly,
                                             *pTransitionInfo,
-                                            rSlideSize,
                                             bTransitionDirection,
-                                            rSoundPlayer ) );
+                                            pSoundPlayer ) );
             }
             break;
             
@@ -1105,9 +654,11 @@
                 switch( nTransitionType )
                 {
                     default:
-                        OSL_ENSURE( false, 
-                                    "TransitionFactory::createSlideTransition(): Unexpected transition "
-                                    "type for TRANSITION_SPECIAL transitions" );
+                        OSL_ENSURE(
+                            false, 
+                            "TransitionFactory::createSlideTransition(): "
+                            "Unexpected transition type for "
+                            "TRANSITION_SPECIAL transitions" );
                         return SlideChangeAnimationSharedPtr();
 
                     case animations::TransitionType::RANDOM:
@@ -1115,74 +666,69 @@
                         // select randomly one of the effects from the
                         // TransitionFactoryTable
 
-                        const TransitionInfo* pRandomTransitionInfo( getRandomTransitionInfo() );
+                        const TransitionInfo* pRandomTransitionInfo(
+                            getRandomTransitionInfo() );
                         
-                        ENSURE_AND_THROW( pRandomTransitionInfo != NULL,
-                                          "TransitionFactory::createSlideTransition(): Got invalid random transition info" );
-
-                        ENSURE_AND_THROW( pRandomTransitionInfo->mnTransitionType != animations::TransitionType::RANDOM,
-                                          "TransitionFactory::createSlideTransition(): Got random again for random input!" );
+                        ENSURE_AND_THROW(
+                            pRandomTransitionInfo != NULL,
+                            "TransitionFactory::createSlideTransition(): "
+                            "Got invalid random transition info" );
+
+                        ENSURE_AND_THROW(
+                            pRandomTransitionInfo->mnTransitionType !=
+                            animations::TransitionType::RANDOM,
+                            "TransitionFactory::createSlideTransition(): "
+                            "Got random again for random input!" );
 
                         // and recurse
-                        return createSlideTransition( rLeavingSlide,
-                                                      rEnteringSlide,
-                                                      rViews,
-                                                      rSlideSize,
-                                                      pRandomTransitionInfo->mnTransitionType,
-                                                      pRandomTransitionInfo->mnTransitionSubType,
-                                                      bTransitionDirection,
-                                                      rTransitionFadeColor,
-                                                      rSoundPlayer );
+                        return createSlideTransition(
+                            pLeavingSlide,
+                            pEnteringSlide,
+                            pRandomTransitionInfo->mnTransitionType,
+                            pRandomTransitionInfo->mnTransitionSubType,
+                            bTransitionDirection,
+                            rTransitionFadeColor,
+                            pSoundPlayer );
                     }
 
                     case animations::TransitionType::PUSHWIPE:
                     {
-                        return createPushWipeTransition( rLeavingSlide,
-                                                         rEnteringSlide,
-                                                         rViews,
-                                                         rSlideSize,
-                                                         nTransitionType,
-                                                         nTransitionSubType,
-                                                         bTransitionDirection,
-                                                         rSoundPlayer );
+                        return createPushWipeTransition(
+                            comphelper::make_optional(pLeavingSlide),
+                            pEnteringSlide,
+                            nTransitionType,
+                            nTransitionSubType,
+                            bTransitionDirection,
+                            pSoundPlayer );
                     }
 
                     case animations::TransitionType::SLIDEWIPE:
                     {
-                        return createSlideWipeTransition( rLeavingSlide,
-                                                          rEnteringSlide,
-                                                          rViews,
-                                                          rSlideSize,
-                                                          nTransitionType,
-                                                          nTransitionSubType,
-                                                          bTransitionDirection,
-                                                          rSoundPlayer );
+                        return createSlideWipeTransition(
+                            comphelper::make_optional(pLeavingSlide),
+                            pEnteringSlide,
+                            nTransitionType,
+                            nTransitionSubType,
+                            bTransitionDirection,
+                            pSoundPlayer );
                     }
 
                     case animations::TransitionType::FADE:
                     {
-                        SlideBitmapSharedPtr pLeavingBitmap;
-                        
-                        SlideBitmapSharedPtr pEnteringBitmap( 
-                            retrieveSlideBitmap( rEnteringSlide,
-                                                 rViews,
-                                                 rSlideSize ) );
-
-                        if( rLeavingSlide.get() &&
-                            rTransitionFadeColor.isValid() )
-                        {
-                            // only generate second bitmap, if fade
+                        // black page:
+                        boost::optional<SlideSharedPtr> leavingSlide;
+                        if (pLeavingSlide.get() != 0 &&
+                            rTransitionFadeColor.isValid()) {
+                            // only generate, if fade
                             // effect really needs it.
-                            pLeavingBitmap = retrieveSlideBitmap( rLeavingSlide,
-                                                                  rViews,
-                                                                  rSlideSize );
+                            leavingSlide.reset( pLeavingSlide );
                         }
-
+                        
                         return SlideChangeAnimationSharedPtr( 
-                            new FadingSlideChange( pLeavingBitmap,
-                                                   pEnteringBitmap,
+                            new FadingSlideChange( leavingSlide,
+                                                   pEnteringSlide,
                                                    rTransitionFadeColor,
-                                                   rSoundPlayer ) );
+                                                   pSoundPlayer ) );
                     }
                 }
             }
@@ -1193,17 +739,17 @@
     // No animation generated, maybe no table entry for given 
     // transition?
     OSL_TRACE(
-        "TransitionFactory::createSlideTransition(): Unknown type/subtype (%d/%d) "
-        "combination encountered",
+        "TransitionFactory::createSlideTransition(): "
+        "Unknown type/subtype (%d/%d) combination encountered",
         nTransitionType,
         nTransitionSubType );
     OSL_ENSURE(
         false,
-        "TransitionFactory::createSlideTransition(): Unknown type/subtype "
-        "combination encountered" );
-        
+        "TransitionFactory::createSlideTransition(): "
+        "Unknown type/subtype combination encountered" );
+    
     return SlideChangeAnimationSharedPtr();
 }
 
-}
-}
+} // namespace internal
+} // namespace presentation
diff -u -r  slideshow/source/engine/transitions/transitionfactorytab.cxx  slideshow/source/engine/transitions/transitionfactorytab.cxx
---  slideshow/source/engine/transitions/transitionfactorytab.cxx	2004-11-27 00:39:45.000000000 +0530
+++  slideshow/source/engine/transitions/transitionfactorytab.cxx	2005-02-28 13:41:45.303245953 +0530
@@ -59,16 +59,15 @@
  *
  ************************************************************************/
 
-#include <cstdlib>
-
 #include "basegfx/numeric/ftools.hxx"
 #include "transitionfactory.hxx"
 #include <com/sun/star/animations/TransitionType.hpp>
 #include <com/sun/star/animations/TransitionSubType.hpp>
 #include <algorithm>
 
+#include "tools.hxx"
 
-using namespace ::drafts::com::sun::star;
+using namespace ::com::sun::star;
 using namespace ::com::sun::star;
 
 namespace presentation {
@@ -863,7 +862,7 @@
         0.0, // no rotation
         1.0, // no scaling
         1.0, // no scaling
-        TransitionInfo::REVERSEMETHOD_ROTATE_180,
+        TransitionInfo::REVERSEMETHOD_FLIP_X,
         true, // 'out' by parameter sweep inversion
         false // scale isotrophically to target size
     },
@@ -1451,7 +1450,7 @@
         0.0, // no rotation
         1.0, // no scaling
         1.0, // no scaling
-        TransitionInfo::REVERSEMETHOD_IGNORE,
+        TransitionInfo::REVERSEMETHOD_SUBTRACT_AND_INVERT,
         true, // 'out' by parameter sweep inversion
         false // scale isotrophically to target size
     },
@@ -1463,7 +1462,7 @@
         90.0, // rotation
         1.0, // no scaling
         1.0, // no scaling
-        TransitionInfo::REVERSEMETHOD_IGNORE,
+        TransitionInfo::REVERSEMETHOD_SUBTRACT_AND_INVERT,
         true, // 'out' by parameter sweep inversion
         false // scale isotrophically to target size
     },
@@ -1475,7 +1474,7 @@
         180.0, // rotation
         1.0, // no scaling
         1.0, // no scaling
-        TransitionInfo::REVERSEMETHOD_IGNORE,
+        TransitionInfo::REVERSEMETHOD_SUBTRACT_AND_INVERT,
         true, // 'out' by parameter sweep inversion
         false // scale isotrophically to target size
     },
@@ -1487,7 +1486,7 @@
         270.0, // rotation
         1.0, // no scaling
         1.0, // no scaling
-        TransitionInfo::REVERSEMETHOD_IGNORE,
+        TransitionInfo::REVERSEMETHOD_SUBTRACT_AND_INVERT,
         true, // 'out' by parameter sweep inversion
         false // scale isotrophically to target size
     },
@@ -1499,7 +1498,7 @@
         90.0, // rotation
         1.0, // no scaling
         1.0, // no scaling
-        TransitionInfo::REVERSEMETHOD_IGNORE,
+        TransitionInfo::REVERSEMETHOD_SUBTRACT_AND_INVERT,
         true, // 'out' by parameter sweep inversion
         false // scale isotrophically to target size
     },
@@ -1511,7 +1510,7 @@
         180.0, // rotation
         1.0, // no scaling
         1.0, // no scaling
-        TransitionInfo::REVERSEMETHOD_IGNORE,
+        TransitionInfo::REVERSEMETHOD_SUBTRACT_AND_INVERT,
         true, // 'out' by parameter sweep inversion
         false // scale isotrophically to target size
     },
@@ -1523,7 +1522,7 @@
         270.0, // rotation
         1.0, // no scaling
         1.0, // no scaling
-        TransitionInfo::REVERSEMETHOD_IGNORE,
+        TransitionInfo::REVERSEMETHOD_SUBTRACT_AND_INVERT,
         true, // 'out' by parameter sweep inversion
         false // scale isotrophically to target size
     },
@@ -1535,7 +1534,7 @@
         0.0, // no rotation
         1.0, // no scaling
         1.0, // no scaling
-        TransitionInfo::REVERSEMETHOD_IGNORE,
+        TransitionInfo::REVERSEMETHOD_SUBTRACT_AND_INVERT,
         true, // 'out' by parameter sweep inversion
         false // scale isotrophically to target size
     },
@@ -2156,10 +2155,9 @@
 
 const TransitionInfo* TransitionFactory::getRandomTransitionInfo()
 {
-    static const ::std::size_t lcl_randomTableSize(
-        sizeof(lcl_transitionInfo)/sizeof(TransitionInfo) - 2);
-    
-    return lcl_transitionInfo + lcl_randomTableSize * rand() / RAND_MAX;
+    return lcl_transitionInfo + getRandomOrdinal(
+        sizeof(lcl_transitionInfo) / sizeof(TransitionInfo)
+        - 1 /* exclude random transition at end of table */ );
 }
 
 } // namespace internal
diff -u -r  slideshow/source/engine/unoviewcontainer.cxx  slideshow/source/engine/unoviewcontainer.cxx
---  slideshow/source/engine/unoviewcontainer.cxx	2004-11-27 00:30:38.000000000 +0530
+++  slideshow/source/engine/unoviewcontainer.cxx	2005-02-28 13:41:45.499223055 +0530
@@ -69,7 +69,7 @@
 #include <algorithm>
 
 
-using namespace ::drafts::com::sun::star;
+using namespace ::com::sun::star;
 using namespace ::com::sun::star;
 
 // -----------------------------------------------------------------------------
diff -u -r  slideshow/source/engine/userpaintoverlay.cxx  slideshow/source/engine/userpaintoverlay.cxx
---  slideshow/source/engine/userpaintoverlay.cxx	2004-11-27 00:31:00.000000000 +0530
+++  slideshow/source/engine/userpaintoverlay.cxx	2005-02-28 13:41:45.501222822 +0530
@@ -85,7 +85,7 @@
 
 
 using namespace ::com::sun::star;
-using namespace ::drafts::com::sun::star;
+using namespace ::com::sun::star;
 
 namespace presentation
 {
diff -u -r  slideshow/source/engine/viewbackgroundshape.cxx  slideshow/source/engine/viewbackgroundshape.cxx
---  slideshow/source/engine/viewbackgroundshape.cxx	2004-11-27 00:31:12.000000000 +0530
+++  slideshow/source/engine/viewbackgroundshape.cxx	2005-02-28 13:41:44.552333686 +0530
@@ -105,7 +105,7 @@
 #include <cppcanvas/bitmap.hxx>
 #endif
 
-using namespace ::drafts::com::sun::star;
+using namespace ::com::sun::star;
 using namespace ::com::sun::star;
 
 
diff -u -r  slideshow/source/engine/viewmediashape.cxx  slideshow/source/engine/viewmediashape.cxx
---  slideshow/source/engine/viewmediashape.cxx	2005-01-21 22:26:48.000000000 +0530
+++  slideshow/source/engine/viewmediashape.cxx	2005-02-28 13:41:44.835300625 +0530
@@ -126,8 +126,8 @@
 #ifndef _COM_SUN_STAR_AWT_XWINDOW_HPP_
 #include <com/sun/star/awt/XWindow.hpp>
 #endif
-#ifndef _DRAFTS_COM_SUN_STAR_RENDERING_XCANVAS_HPP_
-#include <drafts/com/sun/star/rendering/XCanvas.hpp>
+#ifndef _COM_SUN_STAR_RENDERING_XCANVAS_HPP_
+#include <com/sun/star/rendering/XCanvas.hpp>
 #endif
 #ifndef _COM_SUN_STAR_LANG_XCOMPONENT_HDL_
 #include <com/sun/star/lang/XComponent.hdl>
@@ -140,7 +140,7 @@
 #endif
 
 using namespace ::com::sun::star;
-using namespace ::drafts::com::sun::star;
+using namespace ::com::sun::star;
 
 namespace presentation
 {
@@ -244,14 +244,12 @@
 			if( !mpMediaWindow.get() )
 			{
                 // fill the shape background with black
-                ::basegfx::B2DPolygon aPoly;
-                
-                aPoly.append( ::basegfx::B2DPoint( aAdjustedBounds.getMinX(), aAdjustedBounds.getMinY() ) );
-                aPoly.append( ::basegfx::B2DPoint( aAdjustedBounds.getMaxX(), aAdjustedBounds.getMinY() ) );
-                aPoly.append( ::basegfx::B2DPoint( aAdjustedBounds.getMaxX(), aAdjustedBounds.getMaxY() ) );
-                aPoly.append( ::basegfx::B2DPoint( aAdjustedBounds.getMinX(), aAdjustedBounds.getMaxY() ) );
+                const ::basegfx::B2DPolygon aPoly(
+                    ::basegfx::tools::createPolygonFromRect(
+                        aAdjustedBounds ) );
                 
-                ::cppcanvas::PolyPolygonSharedPtr pPolyPoly( ::cppcanvas::BaseGfxFactory::getInstance().createPolyPolygon( pCanvas, aPoly ) );
+                ::cppcanvas::PolyPolygonSharedPtr pPolyPoly( 
+                    ::cppcanvas::BaseGfxFactory::getInstance().createPolyPolygon( pCanvas, aPoly ) );
                     
                 if( pPolyPoly.get() )
                 {
diff -u -r  slideshow/source/engine/viewshape.cxx  slideshow/source/engine/viewshape.cxx
---  slideshow/source/engine/viewshape.cxx	2004-11-27 00:31:36.000000000 +0530
+++  slideshow/source/engine/viewshape.cxx	2005-02-28 13:41:44.838300275 +0530
@@ -65,7 +65,7 @@
 #ifndef  _USE_MATH_DEFINES
 #define  _USE_MATH_DEFINES  // needed by Visual C++ for math constants
 #endif
-#include <math.h>           // M_PI definition 
+#include <math.h>           // M_PI definition
 
 #include <viewshape.hxx>
 #include <tools.hxx>
@@ -77,8 +77,8 @@
 #include <rtl/math.hxx>
 #endif
 
-#ifndef _DRAFTS_COM_SUN_STAR_RENDERING_PANOSELETTERFORM_HPP_
-#include <drafts/com/sun/star/rendering/PanoseLetterForm.hpp>
+#ifndef _COM_SUN_STAR_RENDERING_PANOSELETTERFORM_HPP_
+#include <com/sun/star/rendering/PanoseLetterForm.hpp>
 #endif
 #ifndef _COM_SUN_STAR_AWT_FONTSLANT_HPP_
 #include <com/sun/star/awt/FontSlant.hpp>
@@ -107,7 +107,7 @@
 #include <cppcanvas/basegfxfactory.hxx>
 #endif
 
-using namespace ::drafts::com::sun::star;
+using namespace ::com::sun::star;
 using namespace ::com::sun::star;
 
 
@@ -115,10 +115,10 @@
 {
     namespace internal
     {
-        
-        // TODO(F2): Provide sensible setup for mtf-related attributes (fill mode, 
+
+        // TODO(F2): Provide sensible setup for mtf-related attributes (fill mode,
         // char rotation etc.). Do that via mtf argument at this object
-        
+
         bool ViewShape::prefetch( const ::cppcanvas::CanvasSharedPtr&	rDestinationCanvas,
                                   const GDIMetaFileSharedPtr&			rMtf,
                                   const ShapeAttributeLayerSharedPtr&	rAttr ) const
@@ -153,7 +153,7 @@
                         // convert RGBColor to RGBA32 integer. Note
                         // that getIntegerColor() also truncates
                         // out-of-range values appropriately
-                        aParms.maFillColor = 
+                        aParms.maFillColor =
                             rAttr->getFillColor().getIntegerColor();
                     }
                     if( rAttr->isLineColorValid() )
@@ -161,7 +161,7 @@
                         // convert RGBColor to RGBA32 integer. Note
                         // that getIntegerColor() also truncates
                         // out-of-range values appropriately
-                        aParms.maLineColor = 
+                        aParms.maLineColor =
                             rAttr->getLineColor().getIntegerColor();
                     }
                     if( rAttr->isCharColorValid() )
@@ -169,12 +169,12 @@
                         // convert RGBColor to RGBA32 integer. Note
                         // that getIntegerColor() also truncates
                         // out-of-range values appropriately
-                        aParms.maTextColor = 
+                        aParms.maTextColor =
                             rAttr->getCharColor().getIntegerColor();
                     }
                     if( rAttr->isFontFamilyValid() )
                     {
-                        aParms.maFontName = 
+                        aParms.maFontName =
                             rAttr->getFontFamily();
                     }
                     if( rAttr->isCharScaleValid() )
@@ -193,28 +193,28 @@
                     }
                     if( rAttr->isCharWeightValid() )
                     {
-                        aParms.maFontWeight = 
+                        aParms.maFontWeight =
                             static_cast< sal_Int8 >(
-                                ::basegfx::fround( 
+                                ::basegfx::fround(
                                     ::std::max( 0.0,
-                                                ::std::min( 11.0, 
+                                                ::std::min( 11.0,
                                                             rAttr->getCharWeight() / 20.0 ) ) ) );
                     }
                     if( rAttr->isCharPostureValid() )
                     {
-                        aParms.maFontLetterForm = 
+                        aParms.maFontLetterForm =
                             rAttr->getCharPosture() == awt::FontSlant_NONE ?
                             rendering::PanoseLetterForm::ANYTHING :
                             rendering::PanoseLetterForm::OBLIQUE_CONTACT;
                     }
                     if( rAttr->isUnderlineModeValid() )
                     {
-                        aParms.maFontUnderline = 
+                        aParms.maFontUnderline =
                             rAttr->getUnderlineMode();
                     }
                 }
 
-                mpRenderer = ::cppcanvas::VCLFactory::getInstance().createRenderer( rDestinationCanvas, 
+                mpRenderer = ::cppcanvas::VCLFactory::getInstance().createRenderer( rDestinationCanvas,
                                                                                     *rMtf.get(),
                                                                                     aParms );
 
@@ -244,8 +244,8 @@
             if( rClip.count() )
             {
                 // setup clip
-                mpRenderer->setClip( 
-                    ::cppcanvas::BaseGfxFactory::getInstance().createPolyPolygon( 
+                mpRenderer->setClip(
+                    ::cppcanvas::BaseGfxFactory::getInstance().createPolyPolygon(
                         rDestinationCanvas,
                         rClip ) );
             }
@@ -280,7 +280,7 @@
         }
 
         bool ViewShape::renderSprite( const GDIMetaFileSharedPtr&				rMtf,
-                                      const ::basegfx::B2DRectangle&			rOrigBounds, 
+                                      const ::basegfx::B2DRectangle&			rOrigBounds,
                                       const ::basegfx::B2DRectangle&			rBounds,
                                       int										nUpdateFlags,
                                       const ShapeAttributeLayerSharedPtr&		pAttr,
@@ -289,7 +289,7 @@
         {
             RTL_LOGFILE_CONTEXT( aLog, "::presentation::internal::ViewShape::renderSprite()" );
 
-            // TODO(P1): For multiple views, it might pay off to reorg Shape and ViewShape, 
+            // TODO(P1): For multiple views, it might pay off to reorg Shape and ViewShape,
             // in that all the common setup steps here are refactored to Shape (would then
             // have to be performed only _once_ per Shape paint).
 
@@ -317,33 +317,33 @@
             }
             if( mbForceUpdate || (nUpdateFlags & ALPHA) )
             {
-                mpSprite->setAlpha( (pAttr.get() && pAttr->isAlphaValid()) ? 
+                mpSprite->setAlpha( (pAttr.get() && pAttr->isAlphaValid()) ?
                                     // clamp alpha to valid range
-                                    ::std::max( 0.0, 
-                                                ::std::min( 1.0, pAttr->getAlpha() ) ): 
+                                    ::std::max( 0.0,
+                                                ::std::min( 1.0, pAttr->getAlpha() ) ):
                                     1.0 );
             }
             if( mbForceUpdate || (nUpdateFlags & CLIP) )
             {
-                if( pAttr.get() && pAttr->isClipValid() ) 
+                if( pAttr.get() && pAttr->isClipValid() )
                     mpSprite->clip( pAttr->getClip() );
                 else
                     mpSprite->clip( ::basegfx::B2DPolyPolygon() );
             }
             if( mbForceUpdate || (nUpdateFlags & TRANSFORMATION) )
-            {                
+            {
                 // TODO(P2): implement sprite transformation by
                 // XSprite::setTransformation()
                 bRedrawRequired = true;
             }
             if( mbForceUpdate || (nUpdateFlags & CONTENT) )
-            {                
+            {
                 bRedrawRequired = true;
 
-                // TODO(P1): maybe provide some appearance change methods at 
+                // TODO(P1): maybe provide some appearance change methods at
                 // the Renderer interface
 
-                // clear the last canvas; forces the renderer to be regenerated 
+                // clear the last canvas; forces the renderer to be regenerated
                 // below, for the different attributes to take effect
                 mpLastCanvas.reset();
             }
@@ -364,12 +364,14 @@
 
                 const ::basegfx::B2DSize aSize( rBounds.getRange() );
 
-                // calc size of transformed unit rectangle
-                const ::basegfx::B2DSize aTransformedSize( 
+                // calc size of transformed unit rectangle in device
+                // coordinate space, add border to capture antialiased
+                // shape content.
+                const ::basegfx::B2DSize aTransformedSize(
                     getShapeUpdateArea( rBounds,
                                         aTransform,
                                         pAttr ).getRange() );
-                
+
                 // subtract from regular bounds to determine the extra
                 // size needed. Ignore transformed size that is smaller
                 // than the original shape.
@@ -379,19 +381,26 @@
                     ::std::max( 0.0,
                                 aTransformedSize.getY() - aSize.getY() ) );
 
+                // TODO(Q3): Better encapsulate this calculation in
+                // the Canvas, or at least cppcanvas. There are
+                // several assumptions made here, that might not hold
+                // universally. First of all, even the VCL canvas
+                // renders one pixel more to the right and the
+                // bottom. Second, the extra pixel might as well
+                // extend to the top and the left.
+
                 // resize the sprite (scale might have changed), add
-                // additionalSize to make room for rotation/shear
-                const ::basegfx::B2DSize& rSpriteSize( 
-                    mpViewLayer->getCanvas()->getTransformation() * 
-                    ::basegfx::B2DSize( aSize + 
-                                        aAdditionalSize ) );
+                // additionalSize to make room for
+                // rotation/shear.
+                mpSprite->resize(
+                    calcSpriteSizePixel(
+                        ::basegfx::B2DSize( aSize +
+                                            aAdditionalSize ) ) );
 
-                mpSprite->resize( rSpriteSize );
-                
                 if( !aAdditionalSize.equalZero() )
                 {
-                    // translation is solely performed via Sprite::move(). 
-                    // Because of that, if we enlarged the sprite size, the 
+                    // translation is solely performed via Sprite::move().
+                    // Because of that, if we enlarged the sprite size, the
                     // content will move the corresponding amount to the right
                     // and bottom. Correct that.
                     mpSprite->move( rBounds.getMinimum() - 0.5*aAdditionalSize );
@@ -403,8 +412,8 @@
             }
 
             return draw( mpSprite->getContentCanvas(),
-                         rMtf, 
-                         pAttr, 
+                         rMtf,
+                         pAttr,
                          aTransform,
                          ::basegfx::B2DPolyPolygon(), // clipping is done via Sprite::clip()
                          rSubsets );
@@ -412,7 +421,7 @@
 
         bool ViewShape::render( const ::cppcanvas::CanvasSharedPtr&			rDestinationCanvas,
                                 const GDIMetaFileSharedPtr&					rMtf,
-                                const ::basegfx::B2DRectangle&				rOrigBounds, 
+                                const ::basegfx::B2DRectangle&				rOrigBounds,
                                 const ::basegfx::B2DRectangle&				rBounds,
                                 int											nUpdateFlags,
                                 const ShapeAttributeLayerSharedPtr&			pAttr,
@@ -421,7 +430,7 @@
         {
             RTL_LOGFILE_CONTEXT( aLog, "::presentation::internal::ViewShape::render()" );
 
-            // TODO(P1): For multiple views, it might pay off to reorg Shape and ViewShape, 
+            // TODO(P1): For multiple views, it might pay off to reorg Shape and ViewShape,
             // in that all the common setup steps here are refactored to Shape (would then
             // have to be performed only _once_ per Shape paint).
 
@@ -433,16 +442,16 @@
                 return true;
             }
 
-            // since we have no sprite here, _any_ update request 
+            // since we have no sprite here, _any_ update request
             // translates into a required redraw.
             bool bRedrawRequired( mbForceUpdate || nUpdateFlags != 0 );
 
             if( (nUpdateFlags & CONTENT) )
-            {                
-                // TODO(P1): maybe provide some appearance change methods at 
+            {
+                // TODO(P1): maybe provide some appearance change methods at
                 // the Renderer interface
-                
-                // clear the last canvas; forces the renderer to be regenerated 
+
+                // clear the last canvas; forces the renderer to be regenerated
                 // below, for the different attributes to take effect
                 mpLastCanvas.reset();
             }
@@ -452,8 +461,8 @@
             if( !bRedrawRequired )
                 return true;
 
-            VERBOSE_TRACE( "ViewShape::render(): rendering shape %X at position (%f,%f)", 
-                           this, 
+            VERBOSE_TRACE( "ViewShape::render(): rendering shape %X at position (%f,%f)",
+                           this,
                            rBounds.getMinX(),
                            rBounds.getMinY() );
 
@@ -468,7 +477,7 @@
                 // setup clip poly
                 if( pAttr->isClipValid() )
                     aClip = pAttr->getClip();
-                                
+
                 if( pAttr->isAlphaValid() )
                 {
                     const double nAlpha( pAttr->getAlpha() );
@@ -477,9 +486,9 @@
                         !::rtl::math::approxEqual(nAlpha, 1.0) )
                     {
                         // get shape transformation _without_ page output position
-                        const ::basegfx::B2DHomMatrix aTransform( getShapeTransformation( rOrigBounds, 
-                                                                                          rBounds, 
-                                                                                          pAttr, 
+                        const ::basegfx::B2DHomMatrix aTransform( getShapeTransformation( rOrigBounds,
+                                                                                          rBounds,
+                                                                                          pAttr,
                                                                                           false ) );
 
                         // render with global alpha - have to prepare
@@ -488,14 +497,14 @@
                         // -------------------------------------------
 
                         // determine output rect in device pixel
-                        const ::basegfx::B2DHomMatrix aCanvasTransform( 
+                        const ::basegfx::B2DHomMatrix aCanvasTransform(
                             rDestinationCanvas->getTransformation() );
                         ::basegfx::B2DRectangle aTmpRect;
-                        ::canvas::tools::calcTransformedRectBounds( aTmpRect, 
-                                                                    rBounds, 
+                        ::canvas::tools::calcTransformedRectBounds( aTmpRect,
+                                                                    rBounds,
                                                                     aCanvasTransform );
 
-                        const ::basegfx::B2ISize aBmpSize( 
+                        const ::basegfx::B2ISize aBmpSize(
                             ::basegfx::fround( aTmpRect.getWidth() ),
                             ::basegfx::fround( aTmpRect.getHeight() ) );
 
@@ -503,9 +512,9 @@
                             mpLastBitmapCanvas->getSize() != aBmpSize )
                         {
                             // create a bitmap of appropriate size
-                            mpLastBitmap = 
-                                ::cppcanvas::BaseGfxFactory::getInstance().createAlphaBitmap( 
-                                    rDestinationCanvas, 
+                            mpLastBitmap =
+                                ::cppcanvas::BaseGfxFactory::getInstance().createAlphaBitmap(
+                                    rDestinationCanvas,
                                     aBmpSize );
 
                             ENSURE_AND_THROW(mpLastBitmap.get(),
@@ -524,20 +533,20 @@
                             ::basegfx::B2DHomMatrix aLinearTransform( aCanvasTransform );
                             aLinearTransform.set( 0, 2, 0.0 );
                             aLinearTransform.set( 1, 2, 0.0 );
-            
+
                             // apply linear part of canvas view
                             // transformation to bitmap canvas
                             mpLastBitmapCanvas->setTransformation( aLinearTransform );
                         }
-                            
+
                         // TODO(P1): If no update flags, or only
                         // alpha_update is set, we can save us the
                         // rendering into the bitmap
 
                         // render into this bitmap
                         if( !draw( mpLastBitmapCanvas,
-                                   rMtf, 
-                                   pAttr, 
+                                   rMtf,
+                                   pAttr,
                                    aTransform,
                                    aClip,
                                    rSubsets ) )
@@ -573,19 +582,30 @@
 
             // retrieve shape transformation, _with_ shape translation
             // to actual page position.
-            const ::basegfx::B2DHomMatrix aTransform( getShapeTransformation( rOrigBounds, 
-                                                                              rBounds, 
-                                                                              pAttr, 
+            const ::basegfx::B2DHomMatrix aTransform( getShapeTransformation( rOrigBounds,
+                                                                              rBounds,
+                                                                              pAttr,
                                                                               true) );
 
             return draw( rDestinationCanvas,
-                         rMtf, 
-                         pAttr, 
+                         rMtf,
+                         pAttr,
                          aTransform,
                          aClip,
                          rSubsets );
         }
 
+        ::basegfx::B2DSize ViewShape::calcSpriteSizePixel( const ::basegfx::B2DSize& rUserSize ) const
+        {
+            // Convert from user to device coordinate system. Also,
+            // add a small border around the shape, to account for
+            // antialiased rendering touching pixel outside the actual
+            // shape bound rect
+            return mpViewLayer->getCanvas()->getTransformation() * rUserSize
+                + ::basegfx::B2DSize( ::cppcanvas::Canvas::ANTIALIASING_EXTRA_SIZE,
+                                      ::cppcanvas::Canvas::ANTIALIASING_EXTRA_SIZE );
+        }
+
         ViewShape::ViewShape( const ViewLayerSharedPtr& rViewLayer ) :
             mpViewLayer( rViewLayer ),
             mpRenderer(),
@@ -620,8 +640,8 @@
             return ::basegfx::B2DRectangle(0.0, 0.0, 1.0, 1.0);
 
 //             if( rSubset.isEmpty() ||
-//                 !prefetch( mpViewLayer->getCanvas(), 
-//                            rMtf, 
+//                 !prefetch( mpViewLayer->getCanvas(),
+//                            rMtf,
 //                            pAttr ) )
 //             {
 //                 // either subset contains the whole shape. Or we
@@ -630,7 +650,7 @@
 //                 return ::basegfx::B2DRectangle(0.0, 0.0, 1.0, 1.0);
 //             }
 
-//             ENSURE_AND_THROW( mpRenderer.get(), 
+//             ENSURE_AND_THROW( mpRenderer.get(),
 //                               "ViewShape::getActualBounds(): Invalid renderer" );
 
 //             // retrieve bounds for subset of whole metafile
@@ -639,30 +659,30 @@
 //             {
 //                 ::basegfx::B2DRange aTotalBounds;
 
-//                 // get part before subset range 
+//                 // get part before subset range
 //                 if( rSubset.getStartIndex() > 0 )
-//                     aTotalBounds = mpRenderer->getSubsetArea( 0, 
+//                     aTotalBounds = mpRenderer->getSubsetArea( 0,
 //                                                               rSubset.getStartIndex() );
 
 //                 // get part behind subset range
 //                 if( rSubset.getEndIndex() < nNumDocTreeItems )
-//                     aTotalBounds.expand( mpRenderer->getSubsetArea( rSubset.getEndIndex(), 
+//                     aTotalBounds.expand( mpRenderer->getSubsetArea( rSubset.getEndIndex(),
 //                                                                     nNumDocTreeItems ) );
-                    
+
 //                 return aTotalBounds;
 //             }
 //             else
 //             {
-//                 return mpRenderer->getSubsetArea( rSubset.getStartIndex(), 
+//                 return mpRenderer->getSubsetArea( rSubset.getStartIndex(),
 //                                                   rSubset.getEndIndex() );
 //             }
         }
 
         ::basegfx::B2DSize ViewShape::getAntialiasingBorder() const
         {
-            const ::basegfx::B2DHomMatrix& rViewTransform( 
-                mpViewLayer->getCanvas()->getTransformation() ); 
-            
+            const ::basegfx::B2DHomMatrix& rViewTransform(
+                mpViewLayer->getCanvas()->getTransformation() );
+
             // TODO(F1): As a quick shortcut (did not want to invert
             // whole matrix here), taking only scale components of
             // view transformation matrix. This will be wrong when
@@ -705,29 +725,29 @@
             // try to create sprite, when animated
             if( isBackgroundDetached() && !mpSprite.get() )
             {
-                const ::basegfx::B2DSize& rSpriteSize( 
-                    mpViewLayer->getCanvas()->getTransformation() * ::basegfx::B2DSize( rArgs.mrBounds.getRange() ) );
-
-                mpSprite.reset( new AnimatedSprite( mpViewLayer, rSpriteSize ) );
+                mpSprite.reset(
+                    new AnimatedSprite( mpViewLayer,
+                                        calcSpriteSizePixel(
+                                            rArgs.mrBounds.getRange() ) ) );
             }
 
             // Shall we render to a sprite, or to a plain canvas?
             if( mpSprite.get() != NULL )
-                return renderSprite( rMtf, 
-                                     rArgs.mrOrigBounds, 
-                                     rArgs.mrBounds, 
-                                     nUpdateFlags, 
-                                     rArgs.mrAttr, 
-                                     rArgs.mrSubsets, 
+                return renderSprite( rMtf,
+                                     rArgs.mrOrigBounds,
+                                     rArgs.mrBounds,
+                                     nUpdateFlags,
+                                     rArgs.mrAttr,
+                                     rArgs.mrSubsets,
                                      bIsVisible );
             else
-                return render( mpViewLayer->getCanvas(), 
-                               rMtf, 
-                               rArgs.mrOrigBounds, 
-                               rArgs.mrBounds, 
-                               nUpdateFlags, 
-                               rArgs.mrAttr, 
-                               rArgs.mrSubsets, 
+                return render( mpViewLayer->getCanvas(),
+                               rMtf,
+                               rArgs.mrOrigBounds,
+                               rArgs.mrBounds,
+                               nUpdateFlags,
+                               rArgs.mrAttr,
+                               rArgs.mrSubsets,
                                bIsVisible );
         }
 
diff -u -r  slideshow/source/engine/waitsymbol.cxx  slideshow/source/engine/waitsymbol.cxx
---  slideshow/source/engine/waitsymbol.cxx	2005-01-21 22:27:10.000000000 +0530
+++  slideshow/source/engine/waitsymbol.cxx	2005-02-28 13:41:44.939288476 +0530
@@ -66,7 +66,7 @@
 #include <algorithm>
 
 
-using namespace ::drafts::com::sun::star;
+using namespace ::com::sun::star;
 using namespace ::com::sun::star;
 using namespace ::com::sun::star::uno;
 
@@ -119,13 +119,15 @@
     
 void WaitSymbol::addView( UnoViewSharedPtr const & rView )
 {
+    const ViewsVecT::iterator iEnd( m_views.end() );
     if (std::find_if(
-            m_views.begin(), m_views.end(),
+            m_views.begin(), iEnd,
             boost::bind(
                 std::equal_to<UnoViewSharedPtr>(),
                 rView,
                 // select view:
-                boost::bind( std::select1st<ViewsVecT::value_type>(), _1 ) ) ))
+                boost::bind( std::select1st<ViewsVecT::value_type>(), _1 ) ) )!=
+        iEnd)
         return; // already added
     
     const geometry::IntegerSize2D spriteSize( m_xBitmap->getSize() );
diff -u -r  slideshow/source/engine/waitsymbol.hxx  slideshow/source/engine/waitsymbol.hxx
---  slideshow/source/engine/waitsymbol.hxx	2005-01-21 22:27:23.000000000 +0530
+++  slideshow/source/engine/waitsymbol.hxx	2005-02-28 13:41:44.939288476 +0530
@@ -65,7 +65,7 @@
 #include "cppcanvas/customsprite.hxx"
 #include "disposable.hxx"
 #include "unoview.hxx"
-#include "drafts/com/sun/star/rendering/XBitmap.hpp"
+#include <com/sun/star/rendering/XBitmap.hpp>
 #include <vector>
 #include "boost/shared_ptr.hpp"
 #include "boost/bind.hpp"
@@ -80,38 +80,38 @@
 public:
     WaitSymbol(
         com::sun::star::uno::Reference<
-        drafts::com::sun::star::rendering::XBitmap> const & xBitmap );
-    
+        com::sun::star::rendering::XBitmap> const & xBitmap );
+
     /** Shows the wait symbol.
      */
     void show() { setVisible(true); }
-    
+
     /** Hides the wait symbol.
      */
     void hide() { setVisible(false); }
-    
+
     /** Adds a view for display.
      */
     void addView( UnoViewSharedPtr const & rView );
-    
+
     void removeView( UnoViewSharedPtr const & rView );
-    
+
     void notifyViewChange();
-    
+
     // Disposable:
     virtual void dispose();
-    
+
 private:
     com::sun::star::uno::Reference<
-        drafts::com::sun::star::rendering::XBitmap> m_xBitmap;
-    
+        com::sun::star::rendering::XBitmap> m_xBitmap;
+
     basegfx::B2DPoint calcSpritePos( UnoViewSharedPtr const & rView ) const;
-    
+
     typedef std::vector<
         std::pair<UnoViewSharedPtr,
                   cppcanvas::CustomSpriteSharedPtr> > ViewsVecT;
     ViewsVecT m_views;
-    
+
     // interims solution only:
     template <typename PairT>
     static typename PairT::second_type const & mySelect2nd( PairT const & p ) {
@@ -131,7 +131,7 @@
                              _1 ) ) );
         return func;
     }
-    
+
     bool m_bVisible;
     void setVisible( const bool bVisible );
 };
diff -u -r  slideshow/source/engine/wakeupevent.cxx  slideshow/source/engine/wakeupevent.cxx
---  slideshow/source/engine/wakeupevent.cxx	2004-11-27 00:31:48.000000000 +0530
+++  slideshow/source/engine/wakeupevent.cxx	2005-02-28 13:41:44.750310555 +0530
@@ -70,8 +70,10 @@
 {
     namespace internal
     {
-        WakeupEvent::WakeupEvent( ActivitiesQueue& rActivityQueue ) :
-            maTimer(),
+        WakeupEvent::WakeupEvent(
+            boost::shared_ptr<canvas::tools::ElapsedTime> const & pTimeBase,
+            ActivitiesQueue& rActivityQueue ) :
+            maTimer(pTimeBase),
             mnNextTime(0.0),
             mpActivity(),
             mrActivityQueue( rActivityQueue )
diff -u -r  slideshow/source/inc/activitiesqueue.hxx  slideshow/source/inc/activitiesqueue.hxx
---  slideshow/source/inc/activitiesqueue.hxx	2004-11-27 00:41:35.000000000 +0530
+++  slideshow/source/inc/activitiesqueue.hxx	2005-02-28 13:41:44.327359971 +0530
@@ -69,6 +69,9 @@
 #include <layermanager.hxx>
 #include <unoviewcontainer.hxx>
 
+#include "canvas/elapsedtime.hxx"
+#include "boost/utility.hpp" // for boost::noncopyable
+
 
 /* Definition of ActivitiesQueue class */
 
@@ -81,7 +84,7 @@
             activity objects to this class, which are called in a
             round-robin fashion.
         */
-        class ActivitiesQueue
+        class ActivitiesQueue : private ::boost::noncopyable
         {
         public:
             /** Create an ActivitiesQueue.
@@ -91,8 +94,11 @@
                 with updateScreen(), when a full round of activities
                 has been performed.
              */
-            ActivitiesQueue( const UnoViewContainer& rViews );
-
+            ActivitiesQueue(
+                ::boost::shared_ptr< ::canvas::tools::ElapsedTime >
+                const & pPresTimer,
+                const UnoViewContainer& rViews );
+            
             ~ActivitiesQueue();
 
             /** Add the given activity to the queue.
@@ -127,11 +133,14 @@
              */
             void clear();
 
+            /** Gets the queue's timer object.
+             */
+            ::boost::shared_ptr< ::canvas::tools::ElapsedTime > const &
+            getTimer() const { return mpTimer; }
+            
         private:
-            // default: disabled copy/assignment
-            ActivitiesQueue(const ActivitiesQueue&);
-            ActivitiesQueue& operator=( const ActivitiesQueue& );
-
+            ::boost::shared_ptr< ::canvas::tools::ElapsedTime > mpTimer;
+            
             typedef ::std::list< ActivitySharedPtr > 		ActivityQueue;
 
             LayerManagerSharedPtr	mpLayerManager; // for screen updates
diff -u -r  slideshow/source/inc/activity.hxx  slideshow/source/inc/activity.hxx
---  slideshow/source/inc/activity.hxx	2004-11-27 00:41:46.000000000 +0530
+++  slideshow/source/inc/activity.hxx	2005-02-28 13:41:44.342358219 +0530
@@ -91,6 +91,17 @@
             */
             virtual bool perform() = 0;
 
+            /** Calculates whether the activity lags time.
+
+            	If this method returns a time lag greater than 0.0,
+            	the ActivitiesQueue will adjust the global slideshow
+            	time, by subtracting the given amount of lag.
+                
+                @return time lag or 0.0. Value must be greater or
+                equal than zero.
+            */
+            virtual double calcTimeLag() const = 0;
+            
             /** Query whether this activity is still continuing
 
 	            @return true, if this activity still
@@ -114,13 +125,15 @@
              */
             virtual bool needsScreenUpdate() const = 0;
 
-            /** End the activity prematurely
+            /** Notifies the Activity that it has now left the
+                ActivitiesQueue
 
-            	This method ends the activity prematurely, i.e. before
-            	time or number of iterations is reached. The next time
-            	perform() or isActive() are called, false is returned.
+                Use this method to react on the queue removal
+                event. For animated shapes, this is e.g. used to
+                switch back to the non-sprite presentation mode of the
+                shape.
              */
-            virtual void end() = 0;
+            virtual void dequeued() = 0;
         };
 
         typedef ::boost::shared_ptr< Activity > ActivitySharedPtr;
diff -u -r  slideshow/source/inc/event.hxx  slideshow/source/inc/event.hxx
---  slideshow/source/inc/event.hxx	2004-11-27 00:45:36.000000000 +0530
+++  slideshow/source/inc/event.hxx	2005-02-28 13:41:44.273366279 +0530
@@ -62,10 +62,7 @@
 #ifndef _SLIDESHOW_EVENT_HXX
 #define _SLIDESHOW_EVENT_HXX
 
-#ifndef BOOST_SHARED_PTR_HPP_INCLUDED
 #include <boost/shared_ptr.hpp>
-#endif
-
 #include <vector>
 
 #include <disposable.hxx>
diff -u -r  slideshow/source/inc/eventmultiplexer.hxx  slideshow/source/inc/eventmultiplexer.hxx
---  slideshow/source/inc/eventmultiplexer.hxx	2004-11-27 00:45:59.000000000 +0530
+++  slideshow/source/inc/eventmultiplexer.hxx	2005-02-28 13:41:44.276365929 +0530
@@ -94,6 +94,7 @@
 #include <eventqueue.hxx>
 #include <unoview.hxx>
 
+#include <boost/weak_ptr.hpp>
 #include <vector>
 
 
@@ -641,28 +642,36 @@
 
                 void implSetMouseCursor( sal_Int16 ) const;
 
-                EventQueue&				mrEventQueue;
-                UnoViewVector			maViews;
+                EventQueue&					mrEventQueue;
+                UnoViewVector				maViews;
 
-                ImplEventHandlers		maNextEffectHandlers;
-                ImplEventHandlers		maSlideStartHandlers;
-                ImplEventHandlers		maSlideEndHandlers;
-                ImplAnimationHandlers	maAnimationStartHandlers;
-                ImplAnimationHandlers	maAnimationEndHandlers;
-                ImplEventHandlers	 	maSlideAnimationsEndHandlers;
-                ImplAnimationHandlers	maAudioStoppedHandlers;
-                ImplPauseHandlers		maPauseHandlers;
-                ImplMouseHandlers		maMouseClickHandlers;
-                ImplMouseHandlers		maMouseDoubleClickHandlers;
-                ImplMouseHandlers		maMouseMoveHandlers;
-
-                double					mnTimeout;
-
-                sal_Int16				mnMouseCursor;
-                sal_Int16				mnVolatileMouseCursor;
-                sal_Int16				mnLastVolatileMouseCursor;
+                ImplEventHandlers			maNextEffectHandlers;
+                ImplEventHandlers			maSlideStartHandlers;
+                ImplEventHandlers			maSlideEndHandlers;
+                ImplAnimationHandlers		maAnimationStartHandlers;
+                ImplAnimationHandlers		maAnimationEndHandlers;
+                ImplEventHandlers	 		maSlideAnimationsEndHandlers;
+                ImplAnimationHandlers		maAudioStoppedHandlers;
+                ImplPauseHandlers			maPauseHandlers;
+                ImplMouseHandlers			maMouseClickHandlers;
+                ImplMouseHandlers			maMouseDoubleClickHandlers;
+                ImplMouseHandlers			maMouseMoveHandlers;
+
+                double						mnTimeout;
+
+                /** Holds ptr to optional tick event weakly
+
+                	When event queue is cleansed, the next
+                	setAutomaticMode(true) call is then able to
+                	regenerate the event.
+                 */
+                ::boost::weak_ptr< Event >	mpTickEvent; 
+
+                sal_Int16					mnMouseCursor;
+                sal_Int16					mnVolatileMouseCursor;
+                sal_Int16					mnLastVolatileMouseCursor;
                 
-                bool					mbIsAutoMode;
+                bool						mbIsAutoMode;
             };
 
 
diff -u -r  slideshow/source/inc/eventqueue.hxx  slideshow/source/inc/eventqueue.hxx
---  slideshow/source/inc/eventqueue.hxx	2004-11-27 00:46:11.000000000 +0530
+++  slideshow/source/inc/eventqueue.hxx	2005-02-28 13:41:44.097386840 +0530
@@ -67,9 +67,10 @@
 #endif
 
 #include <queue>
-
 #include <event.hxx>
 
+#include "boost/utility.hpp" // for boost::noncopyable
+
 
 /* Definition of ActivitiesQueue class */
 
@@ -80,10 +81,12 @@
 		/** This class handles events in a presentation. Events are
             time instants where e.g. effects start.
          */
-        class EventQueue
+        class EventQueue : private ::boost::noncopyable
         {
         public:
-            EventQueue();
+            EventQueue(
+                ::boost::shared_ptr< ::canvas::tools::ElapsedTime >
+                const & pPresTimer );
 
             ~EventQueue();
 
@@ -98,12 +101,15 @@
             	possible on the queue (typically, this means one event
             	get processed). 
 
-                @param pTimeoutForNextCall
-                Timeout in seconds, until the next event is ready. The
-                interval can be used by the caller to perform other
-                tasks. This is permitted to be NULL.
+                @return Timeout in seconds, until the next event is
+                ready. The time returned here is relative to the pres
+                timer (i.e. the timer specified at the EventQueue
+                constructor). When the queue is empty (i.e. isEmpty()
+                returns true), the returned value is the highest
+                representable double value
+                (::std::numeric_limits<double>::max()).
              */
-            void process( double* pTimeoutForNextCall );
+            double process();
 
 			/** Query state of the queue
 
@@ -115,11 +121,12 @@
              */
             void clear();
 
+            /** Gets the queue's timer object.
+             */
+            ::boost::shared_ptr< ::canvas::tools::ElapsedTime > const &
+            getTimer() const { return mpTimer; }
+            
         private:
-            // default: disabled copy/assignment
-            EventQueue(const EventQueue&);
-            EventQueue& operator=( const EventQueue& );
-
             struct EventEntry
             {
                 EventSharedPtr	pEvent;
@@ -131,10 +138,11 @@
             typedef ::std::priority_queue< EventEntry > ImplQueueType;
 
             ImplQueueType					maEvents;
+
             // perform timing of events via relative time
             // measurements. The world time starts, when the
             // EventQueue object is created
-            ::canvas::tools::ElapsedTime	maElapsedTime;
+            ::boost::shared_ptr< ::canvas::tools::ElapsedTime > mpTimer;
         };
 
     }
diff -u -r  slideshow/source/inc/intrinsicanimationactivity.hxx  slideshow/source/inc/intrinsicanimationactivity.hxx
---  slideshow/source/inc/intrinsicanimationactivity.hxx	2004-11-27 00:47:29.000000000 +0530
+++  slideshow/source/inc/intrinsicanimationactivity.hxx	2005-02-28 13:41:44.254368499 +0530
@@ -107,10 +107,11 @@
                                         const ::std::vector<double>&	rTimeouts );
 
             virtual void dispose();
+            virtual double calcTimeLag() const;
             virtual bool perform();
             virtual bool isActive() const;
             virtual bool needsScreenUpdate() const;
-            virtual void end();
+            virtual void dequeued();
 
         private:
             SlideShowContext 		maContext;
diff -u -r  slideshow/source/inc/slidebitmap.hxx  slideshow/source/inc/slidebitmap.hxx
---  slideshow/source/inc/slidebitmap.hxx	2004-11-27 00:50:53.000000000 +0530
+++  slideshow/source/inc/slidebitmap.hxx	2005-02-28 13:41:44.184376677 +0530
@@ -83,10 +83,10 @@
 #include <boost/shared_ptr.hpp>
 #endif
 
-namespace drafts { namespace com { namespace sun { namespace star { namespace rendering 
+namespace com { namespace sun { namespace star { namespace rendering
 {
     class XBitmap;
-} } } } }
+} } } }
 
 
 /* Definition of SlideBitmap class */
@@ -104,7 +104,7 @@
         	without data loss, across different canvases). And since
         	we don't want to revert to a VCL Bitmap here, have to wait
         	until basegfx bitmap tooling is ready.
-            
+
             TODO(F2): Add support for Canvas-independent bitmaps
             here. Then, Slide::getInitialSlideBitmap and
             Slide::getFinalSlideBitmap must also be adapted (they no
@@ -129,8 +129,8 @@
             ::basegfx::B2DPolyPolygon								maClipPoly;
 
             // TODO(Q2): Remove UNO bitmap as the transport medium
-            ::com::sun::star::uno::Reference< 
-                ::drafts::com::sun::star::rendering::XBitmap >		mxBitmap;
+            ::com::sun::star::uno::Reference<
+                ::com::sun::star::rendering::XBitmap >		mxBitmap;
         };
 
         typedef ::boost::shared_ptr< ::presentation::internal::SlideBitmap > SlideBitmapSharedPtr;
diff -u -r  slideshow/source/inc/slidechangeanimation.hxx  slideshow/source/inc/slidechangeanimation.hxx
---  slideshow/source/inc/slidechangeanimation.hxx	2004-11-27 00:51:03.000000000 +0530
+++  slideshow/source/inc/slidechangeanimation.hxx	2005-02-28 13:41:44.345357868 +0530
@@ -62,7 +62,7 @@
 #ifndef _SLIDESHOW_SLIDECHANGEANIMATION_HXX
 #define _SLIDESHOW_SLIDECHANGEANIMATION_HXX
 
-#include <view.hxx>
+#include <unoview.hxx>
 #include <numberanimation.hxx>
 
 
@@ -85,14 +85,14 @@
 
             	The slide change will be made visible on the new view
              */
-            virtual void addView( const ViewSharedPtr& rView ) = 0;
+            virtual void addView( const UnoViewSharedPtr& rView ) = 0;
 
             /** Revoke a view
                 
             	The slide change will cease to be display on the given
             	view.
              */
-            virtual bool removeView( const ViewSharedPtr& rView ) = 0;
+            virtual bool removeView( const UnoViewSharedPtr& rView ) = 0;
         };
 
         typedef ::boost::shared_ptr< SlideChangeAnimation > SlideChangeAnimationSharedPtr;
diff -u -r  slideshow/source/inc/slide.hxx  slideshow/source/inc/slide.hxx
---  slideshow/source/inc/slide.hxx	2005-01-21 22:39:04.000000000 +0530
+++  slideshow/source/inc/slide.hxx	2005-02-28 13:41:44.366355415 +0530
@@ -287,6 +287,13 @@
              */
             void setUserPaintColor( const ::comphelper::OptionalValue< RGBColor >& rColor );
 
+            /// Query the XDrawPage's size
+            basegfx::B2ISize getSlideSize() const;
+            
+		    /// Get size of the slide in device coordinates for given view
+            ::basegfx::B2ISize getSlideSizePixel(
+                UnoViewSharedPtr const & pView ) const;
+
         private:
             // default: disabled copy/assignment
             Slide(const Slide&);
@@ -299,23 +306,19 @@
             bool applyInitialShapeAttributes( const ::com::sun::star::uno::Reference< 
 			                                	  ::com::sun::star::animations::XAnimationNode >& xRootAnimationNode );
 
-		    /// Get size of the slide in device coordinates for given view
-	        ::basegfx::B2ISize getSlideSize( const UnoViewSharedPtr& rView );
-            
             /// Renders current slide content to bitmap
-            SlideBitmapSharedPtr createCurrentSlideBitmap( const UnoViewSharedPtr& rView );
-
+            SlideBitmapSharedPtr createCurrentSlideBitmap(
+                const UnoViewSharedPtr& rView,
+                ::basegfx::B2ISize const & rSlideSize );
+            
             /// Prefetch all shapes (not the animations)
             bool prefetchShapes();
 
             /// Prefetch show, but don't call applyInitialShapeAttributes()
             bool implPrefetchShow();
 
-            /// Query the XDrawPage's size
-            bool getPageSize				( ::basegfx::B2ISize& o_rPageSize ) const;
-
-            /// Query the rectangle covered by the page
-            ::basegfx::B2DRectangle getPageRect() const;
+            /// Query the rectangle covered by the slide
+            ::basegfx::B2DRectangle getSlideRect() const;
 
             /// Start GIF and other intrinsic shape animations
             void endIntrinsicAnimations();
diff -u -r  slideshow/source/inc/soundplayer.hxx  slideshow/source/inc/soundplayer.hxx
---  slideshow/source/inc/soundplayer.hxx	2004-11-27 00:51:49.000000000 +0530
+++  slideshow/source/inc/soundplayer.hxx	2005-02-28 13:41:44.260367798 +0530
@@ -66,9 +66,6 @@
 #include <rtl/ustring.hxx>
 #endif 
 
-#ifndef _COM_SUN_STAR_UNO_REFERENCE_HXX_
-#include <com/sun/star/uno/Reference.hxx>
-#endif
 #ifndef _COM_SUN_STAR_UNO_XCOMPONENTCONTEXT_HXX_
 #include <com/sun/star/uno/XComponentContext.hpp>
 #endif
@@ -83,6 +80,9 @@
 #include <boost/shared_ptr.hpp>
 #endif
 
+#include "pauseeventhandler.hxx"
+#include "eventmultiplexer.hxx"
+
 
 /* Definition of SoundPlayer class */
 
@@ -90,9 +90,12 @@
 {
     namespace internal
     {
-        /** Little class that plays a sound from a URL
+        /** Little class that plays a sound from a URL.
+            TODO:
+            Must be explicitly disposed (as long as enable_shared_ptr_from_this
+            isn't available)!
          */
-        class SoundPlayer
+        class SoundPlayer : public PauseEventHandler
         {
         public:
             /** Create a sound player object.
@@ -108,11 +111,13 @@
                 the sound file is invalid, or not supported by the
                 player service.
              */
-            SoundPlayer( const ::rtl::OUString& 							rSoundURL,
-                         const ::com::sun::star::uno::Reference< 
-                         		::com::sun::star::uno::XComponentContext>&	rComponentContext );
+            static ::boost::shared_ptr<SoundPlayer> create(
+                EventMultiplexer & rEventMultiplexer,
+                const ::rtl::OUString& rSoundURL,
+                const ::com::sun::star::uno::Reference< 
+                ::com::sun::star::uno::XComponentContext>& rComponentContext );
 
-            ~SoundPlayer();
+            virtual ~SoundPlayer();
 
             /** Query duration of sound playback.
 
@@ -126,7 +131,22 @@
             bool startPlayback();
             bool stopPlayback();
 
+            // PauseEventHandler:
+            virtual bool handlePause( bool bPauseShow );
+            // Disposable:
+            virtual void dispose();
+            
         private:
+            SoundPlayer(
+                EventMultiplexer & rEventMultiplexer,
+                const ::rtl::OUString& rSoundURL,
+                const ::com::sun::star::uno::Reference< 
+                ::com::sun::star::uno::XComponentContext>& rComponentContext );
+
+            EventMultiplexer & mrEventMultiplexer;
+            // TODO(Q3): obsolete when boost::enable_shared_ptr_from_this
+            //           is available
+            ::boost::shared_ptr<SoundPlayer> mThis;
             ::com::sun::star::uno::Reference< ::com::sun::star::media::XPlayer > mxPlayer;
         };        
 
diff -u -r  slideshow/source/inc/tools.hxx  slideshow/source/inc/tools.hxx
---  slideshow/source/inc/tools.hxx	2004-11-27 00:52:22.000000000 +0530
+++  slideshow/source/inc/tools.hxx	2005-02-28 13:41:44.211373522 +0530
@@ -102,6 +102,9 @@
 #include <hslcolor.hxx>
 #include <layermanager.hxx>
 
+#include "boost/optional.hpp"
+#include <cstdlib>
+
 
 namespace com { namespace sun { namespace star { namespace beans 
 {
@@ -334,7 +337,26 @@
         /** Convert a plain UNO API 32 bit int to RGBColor
          */
         RGBColor unoColor2RGBColor( sal_Int32 );
-        
+
+    
+        /// Gets a random ordinal [0,n)
+        inline ::std::size_t getRandomOrdinal( const ::std::size_t n )
+        {
+            return static_cast< ::std::size_t >(
+                double(n) * rand() / (RAND_MAX + 1.0) );
+        }
+    
+        /// To work around ternary operator in initializer lists
+        /// (Solaris compiler problems)
+        template <typename T>
+        inline T const & ternary_op(
+            const bool cond, T const & arg1, T const & arg2 )
+        {
+            if (cond)
+                return arg1;
+            else
+                return arg2;
+        }
 	}
 }
 
diff -u -r  slideshow/source/inc/transitionfactory.hxx  slideshow/source/inc/transitionfactory.hxx
---  slideshow/source/inc/transitionfactory.hxx	2004-11-27 00:52:33.000000000 +0530
+++  slideshow/source/inc/transitionfactory.hxx	2005-02-28 13:41:44.367355298 +0530
@@ -69,7 +69,6 @@
 #include <comphelper/optionalvalue.hxx>
 #endif
 
-#include <unoviewcontainer.hxx>
 #include <animatableshape.hxx>
 #include <rgbcolor.hxx>
 #include <slide.hxx>
@@ -130,9 +129,6 @@
                 @param rLeavingBitmap
                 Bitmap of the slide which 'leaves' the screen.
 
-                @param rSlideSize
-                Size of the entering slide in user coordinate space
-
                 @param nTransitionType
                 Type of the transition (see XTransitionFilter)
 
@@ -151,8 +147,6 @@
             static SlideChangeAnimationSharedPtr createSlideTransition(
                 const SlideSharedPtr& 							rLeavingSlide,
                 const SlideSharedPtr& 							rEnteringSlide,
-                const UnoViewContainer&							rViews,
-                const ::basegfx::B2DSize&						rSlideSize,
                 sal_Int16               						nTransitionType,
                 sal_Int16               						nTransitionSubType,
                 bool											bTransitionDirection,
diff -u -r  slideshow/source/inc/viewbackgroundshape.hxx  slideshow/source/inc/viewbackgroundshape.hxx
---  slideshow/source/inc/viewbackgroundshape.hxx	2004-11-27 00:53:49.000000000 +0530
+++  slideshow/source/inc/viewbackgroundshape.hxx	2005-02-28 13:41:44.122383920 +0530
@@ -65,8 +65,8 @@
 #ifndef _COM_SUN_STAR_UNO_REFERENCE_HXX_
 #include <com/sun/star/uno/Reference.hxx>
 #endif
-#ifndef _DRAFTS_COM_SUN_STAR_RENDERING_XBITMAP_HPP_
-#include <drafts/com/sun/star/rendering/XBitmap.hpp>
+#ifndef _COM_SUN_STAR_RENDERING_XBITMAP_HPP_
+#include <com/sun/star/rendering/XBitmap.hpp>
 #endif
 
 #ifndef _BGFX_RANGE_B2DRECTANGLE_HXX
@@ -133,7 +133,7 @@
 
             /// Generated content bitmap, already with correct output size
             mutable ::com::sun::star::uno::Reference< 
-                ::drafts::com::sun::star::rendering::XBitmap >	mxBitmap;
+                ::com::sun::star::rendering::XBitmap >	mxBitmap;
 
             /// The last metafile a render object was generated for
             mutable GDIMetaFileSharedPtr						mpLastMtf;
diff -u -r  slideshow/source/inc/viewshape.hxx  slideshow/source/inc/viewshape.hxx
---  slideshow/source/inc/viewshape.hxx	2004-11-27 00:54:21.000000000 +0530
+++  slideshow/source/inc/viewshape.hxx	2005-02-28 13:41:44.291364177 +0530
@@ -294,6 +294,16 @@
                          const DocTreeNode::VectorOfDocTreeNodes&	rSubsets,
                          bool 										bIsVisible ) const;
 
+            /** Calc sprite size in pixel
+
+            	Converts user coordinate system to device pixel, and
+            	adds antialiasing border.
+
+            	@param rUserSize
+                Size of the sprite in user coordinate system (doc coordinates)
+             */
+            ::basegfx::B2DSize calcSpriteSizePixel( const ::basegfx::B2DSize& rUserSize ) const;
+
             /** The view layer this object is part of. 
 
                 Needed for sprite creation
diff -u -r  slideshow/source/inc/wakeupevent.hxx  slideshow/source/inc/wakeupevent.hxx
---  slideshow/source/inc/wakeupevent.hxx	2004-11-27 00:54:32.000000000 +0530
+++  slideshow/source/inc/wakeupevent.hxx	2005-02-28 13:41:44.266367097 +0530
@@ -87,7 +87,10 @@
         class WakeupEvent : public Event
         {
         public:
-            WakeupEvent( ActivitiesQueue& rActivityQueue );
+            WakeupEvent(
+                ::boost::shared_ptr< ::canvas::tools::ElapsedTime >
+                const & pTimeBase,
+                ActivitiesQueue& rActivityQueue );
 
             virtual void dispose();
             virtual bool fire();
diff -u -r  svx/inc/outliner.hxx  svx/inc/outliner.hxx
---  svx/inc/outliner.hxx	2005-01-21 20:34:09.000000000 +0530
+++  svx/inc/outliner.hxx	2005-02-28 13:40:35.084450855 +0530
@@ -963,6 +963,20 @@
     	This method decorates recorded metafiles with XTEXT_EOx
     	comments, to transport the logical text structure like
     	paragraph, line, sentence, word and cell breaks.
+
+        Specifically, comment actions named XTEXT_EOC contain the
+        index of the last glyph of a character, XTEXT_EOW contain the
+        index of the last glyph of a word, and XTEXT_EOS the last
+        index of a sentence, respectively. The named three comment
+        actions appear after a text rendering action
+        (e.g. META_TEXT_ACTION), and the index values reference
+        character indices in this last text render action (this is
+        because text render actions cannot be split up in a
+        output-preserving way).
+
+        XTEXT_EOL and XTEXT_EOP appear after the end of a line or a
+        paragraph, respectively, and don't carry a glyph index (as
+        they cannot appear inbetween a META_TEXT_ACTION).
      */
     void			EnableVerboseTextComments( BOOL bEnable = TRUE );
     BOOL			IsVerboseTextComments() const;
diff -u -r  svx/inc/svdoashp.hxx  svx/inc/svdoashp.hxx
---  svx/inc/svdoashp.hxx	2005-01-21 20:56:02.000000000 +0530
+++  svx/inc/svdoashp.hxx	2005-02-28 13:40:29.738075636 +0530
@@ -69,8 +69,8 @@
 #include "svdotext.hxx"
 #endif
 #include <com/sun/star/uno/Reference.h>
-#ifndef _DRAFTS_COM_SUN_STAR_DRAWING_XCUSTOMSHAPEENGINE_HPP_
-#include <drafts/com/sun/star/drawing/XCustomShapeEngine.hpp>
+#ifndef _COM_SUN_STAR_DRAWING_XCUSTOMSHAPEENGINE_HPP_
+#include <com/sun/star/drawing/XCustomShapeEngine.hpp>
 #endif
 
 #ifndef INCLUDED_SVXDLLAPI_H
@@ -125,9 +125,9 @@
 	// #i37011# render geometry shadow
 	SdrObject*											mpLastShadowGeometry;
 
-	SVX_DLLPRIVATE com::sun::star::uno::Reference< drafts::com::sun::star::drawing::XCustomShapeEngine > GetCustomShapeEngine( const SdrObjCustomShape* pCustomShape ) const;
+	SVX_DLLPRIVATE com::sun::star::uno::Reference< com::sun::star::drawing::XCustomShapeEngine > GetCustomShapeEngine( const SdrObjCustomShape* pCustomShape ) const;
 	SVX_DLLPRIVATE const sal_Bool GetLineGeometry( XPolyPolygon& rLineGeometry, const SdrObjCustomShape* pCustomShape, const sal_Bool bBezierAllowed ) const;
-	SVX_DLLPRIVATE com::sun::star::uno::Sequence< com::sun::star::uno::Reference< drafts::com::sun::star::drawing::XCustomShapeHandle > >
+	SVX_DLLPRIVATE com::sun::star::uno::Sequence< com::sun::star::uno::Reference< com::sun::star::drawing::XCustomShapeHandle > >
 		SdrObjCustomShape::GetInteraction( const SdrObjCustomShape* pCustomShape ) const;
 
 	// #i37011# centralize throw-away of render geometry
diff -u -r  svx/source/customshapes/EnhancedCustomShape2d.cxx  svx/source/customshapes/EnhancedCustomShape2d.cxx
---  svx/source/customshapes/EnhancedCustomShape2d.cxx	2005-01-27 21:46:16.000000000 +0530
+++  svx/source/customshapes/EnhancedCustomShape2d.cxx	2005-02-28 13:40:42.056636096 +0530
@@ -130,11 +130,11 @@
 #ifndef _COM_SUN_STAR_AWT_SIZE_HPP_
 #include <com/sun/star/awt/Size.hpp>
 #endif
-#ifndef _DRAFTS_COM_SUN_STAR_DRAWING_ENHANCEDCUSTOMSHAPEPARAMETERTYPE_HPP_
-#include <drafts/com/sun/star/drawing/EnhancedCustomShapeParameterType.hpp>
+#ifndef _COM_SUN_STAR_DRAWING_ENHANCEDCUSTOMSHAPEPARAMETERTYPE_HPP_
+#include <com/sun/star/drawing/EnhancedCustomShapeParameterType.hpp>
 #endif
-#ifndef __drafts_com_sun_star_drawing_EnhancedCustomShapeSegmentCommand_hpp__
-#include <drafts/com/sun/star/drawing/EnhancedCustomShapeSegmentCommand.hpp>
+#ifndef __COM_SUN_STAR_DRAWING_ENHANCEDCUSTOMSHAPESEGMENTCOMMAND_HPP__
+#include <com/sun/star/drawing/EnhancedCustomShapeSegmentCommand.hpp>
 #endif
 #ifndef BOOST_SHARED_PTR_HPP_INCLUDED
 #include <boost/shared_ptr.hpp>
@@ -167,8 +167,8 @@
 //#endif
 
 using namespace ::com::sun::star::uno;
-using namespace ::drafts::com::sun::star::drawing;
-using namespace ::drafts::com::sun::star::drawing::EnhancedCustomShapeSegmentCommand;
+using namespace ::com::sun::star::drawing;
+using namespace ::com::sun::star::drawing::EnhancedCustomShapeSegmentCommand;
 
 void EnhancedCustomShape2d::SetEnhancedCustomShapeParameter( EnhancedCustomShapeParameter& rParameter, const sal_Int32 nValue )
 {
@@ -549,7 +549,7 @@
 	sal_uInt32 i, nProperties = rHandleProperties.getLength();
 	if ( nProperties )
 	{
-		rDestinationHandle.nFlags = 0;	
+		rDestinationHandle.nFlags = 0;
 		for ( i = 0; i < nProperties; i++ )
 		{
 			const com::sun::star::beans::PropertyValue& rPropVal = rHandleProperties[ i ];
@@ -607,7 +607,7 @@
 /* seems not to be used.
 			else if ( rPropVal.Name.equals( sMap ) )
 			{
-				drafts::com::sun::star::drawing::EnhancedCustomShapeParameterPair aMap;
+				com::sun::star::drawing::EnhancedCustomShapeParameterPair aMap;
 				if ( rPropVal.Value >>= aMap )
 				{
 					if ( GetValueForEnhancedCustomShapeHandleParameter( nXMap, aMap.First ) )
@@ -657,7 +657,7 @@
 {
 	const sal_Int32* pDefData = NULL;
 	const mso_CustomShape* pDefCustomShape = GetCustomShapeContent( eSpType );
-	if ( pDefCustomShape )	
+	if ( pDefCustomShape )
 		pDefData = pDefCustomShape->pDefData;
 
 	//////////////////////
@@ -708,7 +708,7 @@
 	}
 
 	const rtl::OUString	sPath( RTL_CONSTASCII_USTRINGPARAM ( "Path" ) );
-	
+
 	//////////////////////
 	// Path/Coordinates //
 	//////////////////////
@@ -977,11 +977,11 @@
 			n = 0;
 			com::sun::star::beans::PropertyValues& rPropValues = seqHandles[ i ];
 			rPropValues.realloc( nPropertiesNeeded );
-			
+
 			// POSITION
 			{
 				const rtl::OUString	sPosition( RTL_CONSTASCII_USTRINGPARAM ( "Position" ) );
-				::drafts::com::sun::star::drawing::EnhancedCustomShapeParameterPair aPosition;
+				::com::sun::star::drawing::EnhancedCustomShapeParameterPair aPosition;
 				SetEnhancedCustomShapeHandleParameter( aPosition.First, pData->nPositionX, sal_True, sal_True );
 				SetEnhancedCustomShapeHandleParameter( aPosition.Second, pData->nPositionY, sal_True, sal_False );
 				rPropValues[ n ].Name = sPosition;
@@ -1011,7 +1011,7 @@
 			if ( nFlags & MSDFF_HANDLE_FLAGS_POLAR )
 			{
 				const rtl::OUString	sPolar( RTL_CONSTASCII_USTRINGPARAM ( "Polar" ) );
-				::drafts::com::sun::star::drawing::EnhancedCustomShapeParameterPair aCenter;
+				::com::sun::star::drawing::EnhancedCustomShapeParameterPair aCenter;
 				SetEnhancedCustomShapeHandleParameter( aCenter.First,  pData->nCenterX,
 					( nFlags & MSDFF_HANDLE_FLAGS_CENTER_X_IS_SPECIAL ) != 0, sal_True  );
 				SetEnhancedCustomShapeHandleParameter( aCenter.Second, pData->nCenterY,
@@ -1023,7 +1023,7 @@
 					if ( pData->nRangeXMin != 0x80000000 )
 					{
 						const rtl::OUString	sRadiusRangeMinimum( RTL_CONSTASCII_USTRINGPARAM ( "RadiusRangeMinimum" ) );
-						::drafts::com::sun::star::drawing::EnhancedCustomShapeParameter aRadiusRangeMinimum;
+						::com::sun::star::drawing::EnhancedCustomShapeParameter aRadiusRangeMinimum;
 						SetEnhancedCustomShapeHandleParameter( aRadiusRangeMinimum, pData->nRangeXMin,
 							( nFlags & MSDFF_HANDLE_FLAGS_RANGE_X_MIN_IS_SPECIAL ) != 0, sal_True  );
 						rPropValues[ n ].Name = sRadiusRangeMinimum;
@@ -1032,7 +1032,7 @@
 					if ( pData->nRangeXMax != 0x7fffffff )
 					{
 						const rtl::OUString	sRadiusRangeMaximum( RTL_CONSTASCII_USTRINGPARAM ( "RadiusRangeMaximum" ) );
-						::drafts::com::sun::star::drawing::EnhancedCustomShapeParameter aRadiusRangeMaximum;
+						::com::sun::star::drawing::EnhancedCustomShapeParameter aRadiusRangeMaximum;
 						SetEnhancedCustomShapeHandleParameter( aRadiusRangeMaximum, pData->nRangeXMax,
 							( nFlags & MSDFF_HANDLE_FLAGS_RANGE_X_MAX_IS_SPECIAL ) != 0, sal_False );
 						rPropValues[ n ].Name = sRadiusRangeMaximum;
@@ -1045,7 +1045,7 @@
 				if ( pData->nRangeXMin != 0x80000000 )
 				{
 					const rtl::OUString	sRangeXMinimum( RTL_CONSTASCII_USTRINGPARAM ( "RangeXMinimum" ) );
-					::drafts::com::sun::star::drawing::EnhancedCustomShapeParameter aRangeXMinimum;
+					::com::sun::star::drawing::EnhancedCustomShapeParameter aRangeXMinimum;
 					SetEnhancedCustomShapeHandleParameter( aRangeXMinimum, pData->nRangeXMin,
 						( nFlags & MSDFF_HANDLE_FLAGS_RANGE_X_MIN_IS_SPECIAL ) != 0, sal_True  );
 					rPropValues[ n ].Name = sRangeXMinimum;
@@ -1054,7 +1054,7 @@
 				if ( pData->nRangeXMax != 0x7fffffff )
 				{
 					const rtl::OUString	sRangeXMaximum( RTL_CONSTASCII_USTRINGPARAM ( "RangeXMaximum" ) );
-					::drafts::com::sun::star::drawing::EnhancedCustomShapeParameter aRangeXMaximum;
+					::com::sun::star::drawing::EnhancedCustomShapeParameter aRangeXMaximum;
 					SetEnhancedCustomShapeHandleParameter( aRangeXMaximum, pData->nRangeXMax,
 						( nFlags & MSDFF_HANDLE_FLAGS_RANGE_X_MAX_IS_SPECIAL ) != 0, sal_False );
 					rPropValues[ n ].Name = sRangeXMaximum;
@@ -1063,7 +1063,7 @@
 				if ( pData->nRangeYMin != 0x80000000 )
 				{
 					const rtl::OUString	sRangeYMinimum( RTL_CONSTASCII_USTRINGPARAM ( "RangeYMinimum" ) );
-					::drafts::com::sun::star::drawing::EnhancedCustomShapeParameter aRangeYMinimum;
+					::com::sun::star::drawing::EnhancedCustomShapeParameter aRangeYMinimum;
 					SetEnhancedCustomShapeHandleParameter( aRangeYMinimum, pData->nRangeYMin,
 						( nFlags & MSDFF_HANDLE_FLAGS_RANGE_Y_MIN_IS_SPECIAL ) != 0, sal_True );
 					rPropValues[ n ].Name = sRangeYMinimum;
@@ -1072,7 +1072,7 @@
 				if ( pData->nRangeYMax != 0x7fffffff )
 				{
 					const rtl::OUString	sRangeYMaximum( RTL_CONSTASCII_USTRINGPARAM ( "RangeYMaximum" ) );
-					::drafts::com::sun::star::drawing::EnhancedCustomShapeParameter aRangeYMaximum;
+					::com::sun::star::drawing::EnhancedCustomShapeParameter aRangeYMaximum;
 					SetEnhancedCustomShapeHandleParameter( aRangeYMaximum, pData->nRangeYMax,
 						( nFlags & MSDFF_HANDLE_FLAGS_RANGE_Y_MAX_IS_SPECIAL ) != 0, sal_False );
 					rPropValues[ n ].Name = sRangeYMaximum;
@@ -1345,7 +1345,7 @@
 	return bRetValue;
 }
 
-Point EnhancedCustomShape2d::GetPoint( const drafts::com::sun::star::drawing::EnhancedCustomShapeParameterPair& rPair,
+Point EnhancedCustomShape2d::GetPoint( const com::sun::star::drawing::EnhancedCustomShapeParameterPair& rPair,
 										const sal_Bool bScale, const sal_Bool bReplaceGeoSize ) const
 {
 	Point		aRetValue;
@@ -1452,7 +1452,7 @@
 		{
 			rRetValue  = 0.0;
 			bRetValue = sal_True;
-		}	
+		}
 		break;
 		case EnhancedCustomShapeParameterType::RIGHT :
 		{
@@ -1560,8 +1560,8 @@
 				{
 					if ( aLogicRect.GetHeight() > aLogicRect.GetWidth() )
 					{
-						drafts::com::sun::star::drawing::EnhancedCustomShapeParameter aFirst = aHandle.aPosition.First;
-						drafts::com::sun::star::drawing::EnhancedCustomShapeParameter aSecond = aHandle.aPosition.Second;
+						com::sun::star::drawing::EnhancedCustomShapeParameter aFirst = aHandle.aPosition.First;
+						com::sun::star::drawing::EnhancedCustomShapeParameter aSecond = aHandle.aPosition.Second;
 						aHandle.aPosition.First = aSecond;
 						aHandle.aPosition.Second = aFirst;
 					}
@@ -1719,12 +1719,12 @@
 	aLineStart.SetValue(((XLineStartItem&)pObj->GetMergedItem( XATTR_LINEEND )).GetValue());
 	XLineStartWidthItem  aLineStartWidth(((XLineStartWidthItem&)pObj->GetMergedItem( XATTR_LINEENDWIDTH )).GetValue());
 	XLineStartCenterItem aLineStartCenter(((XLineStartCenterItem&)pObj->GetMergedItem( XATTR_LINEENDCENTER )).GetValue());
-	
+
 	XLineEndItem		 aLineEnd;
 	aLineEnd.SetValue(((XLineEndItem&)pObj->GetMergedItem( XATTR_LINESTART )).GetValue());
 	XLineEndWidthItem    aLineEndWidth(((XLineEndWidthItem&)pObj->GetMergedItem( XATTR_LINESTARTWIDTH )).GetValue());
 	XLineEndCenterItem   aLineEndCenter(((XLineEndCenterItem&)pObj->GetMergedItem( XATTR_LINESTARTCENTER )).GetValue());
-	
+
 	pObj->SetMergedItem( aLineStart );
 	pObj->SetMergedItem( aLineStartWidth );
 	pObj->SetMergedItem( aLineStartCenter );
@@ -1787,7 +1787,7 @@
 	sal_Int32 nSegInfoSize = seqSegments.getLength();
 	if ( !nSegInfoSize )
 	{
-		sal_Int32 nPtNum;	
+		sal_Int32 nPtNum;
 		aPoly = XPolygon( (sal_uInt16)( nCoordSize + 1 ) );
 		const EnhancedCustomShapeParameterPair* pTmp = seqCoordinates.getArray();
 		for ( nPtNum = 0; nPtNum < nCoordSize; nPtNum++ )
@@ -1873,11 +1873,11 @@
 							double fStartAngle, fEndAngle;
 							GetParameter( fStartAngle, seqCoordinates[ rSrcPt + 2 ].First,  sal_False, sal_False );
 							GetParameter( fEndAngle  , seqCoordinates[ rSrcPt + 2 ].Second, sal_False, sal_False );
-							
+
 							if ( ((sal_Int32)fStartAngle % 360) != ((sal_Int32)fEndAngle % 360) )
 							{
-								if ( (sal_Int32)fStartAngle & 0x7fff0000 )	// SJ: if the angle was imported from our escher import, then the 
-									fStartAngle /= 65536.0;					// value is shifted by 16. TODO: already change the fixed float to a 
+								if ( (sal_Int32)fStartAngle & 0x7fff0000 )	// SJ: if the angle was imported from our escher import, then the
+									fStartAngle /= 65536.0;					// value is shifted by 16. TODO: already change the fixed float to a
 								if ( (sal_Int32)fEndAngle & 0x7fff0000 )	// double in the import filter
 								{
 									fEndAngle /= 65536.0;
@@ -1898,8 +1898,8 @@
 								AppendArc( aRect, Point( (sal_Int32)fx1, (sal_Int32)fy1 ), Point( (sal_Int32)fx2, (sal_Int32)fy2 ), sal_False, aPoly );
 							}
 							else
-							{	/* SJ: TODO: this block should be replaced sometimes, because the current point 
-								   is not set correct, it also does not use the correct moveto 
+							{	/* SJ: TODO: this block should be replaced sometimes, because the current point
+								   is not set correct, it also does not use the correct moveto
 								   point if ANGLEELLIPSETO was used, but the method AppendArc
 								   is at the moment not able to draw full circles (if startangle is 0
 								   and endangle 360 nothing is painted :-( */
diff -u -r  svx/source/customshapes/EnhancedCustomShape2d.hxx  svx/source/customshapes/EnhancedCustomShape2d.hxx
---  svx/source/customshapes/EnhancedCustomShape2d.hxx	2004-11-26 19:56:32.000000000 +0530
+++  svx/source/customshapes/EnhancedCustomShape2d.hxx	2005-02-28 13:40:42.080633292 +0530
@@ -83,20 +83,20 @@
 #ifndef _SFXITEMSET_HXX
 #include <svtools/itemset.hxx>
 #endif
-#ifndef __drafts_com_sun_star_drawing_EnhancedCustomShapeParameterPair_hpp__
-#include <drafts/com/sun/star/drawing/EnhancedCustomShapeParameterPair.hpp>
+#ifndef __com_sun_star_drawing_EnhancedCustomShapeParameterPair_hpp__
+#include <com/sun/star/drawing/EnhancedCustomShapeParameterPair.hpp>
 #endif
-#ifndef _DRAFTS_COM_SUN_STAR_DRAWING_ENHANCEDCUSTOMSHAPESEGMENT_HPP_
-#include <drafts/com/sun/star/drawing/EnhancedCustomShapeSegment.hpp>
+#ifndef _COM_SUN_STAR_DRAWING_ENHANCEDCUSTOMSHAPESEGMENT_HPP_
+#include <com/sun/star/drawing/EnhancedCustomShapeSegment.hpp>
 #endif
-#ifndef _DRAFTS_COM_SUN_STAR_DRAWING_ENHANCEDCUSTOMSHAPEPARAMETER_HPP_
-#include <drafts/com/sun/star/drawing/EnhancedCustomShapeParameter.hpp>
+#ifndef _COM_SUN_STAR_DRAWING_ENHANCEDCUSTOMSHAPEPARAMETER_HPP_
+#include <com/sun/star/drawing/EnhancedCustomShapeParameter.hpp>
 #endif
-#ifndef __drafts_com_sun_star_drawing_EnhancedCustomShapeTextFrame_hpp__
-#include <drafts/com/sun/star/drawing/EnhancedCustomShapeTextFrame.hpp>
+#ifndef __COM_SUN_STAR_DRAWING_ENHANCEDCUSTOMSHAPETEXTFRAME_HPP__
+#include <com/sun/star/drawing/EnhancedCustomShapeTextFrame.hpp>
 #endif
-#ifndef _DRAFTS_COM_SUN_STAR_DRAWING_ENHANCEDCUSTOMSHAPEADJUSTMENTVALUE_HPP_
-#include <drafts/com/sun/star/drawing/EnhancedCustomShapeAdjustmentValue.hpp>
+#ifndef _COM_SUN_STAR_DRAWING_ENHANCEDCUSTOMSHAPEADJUSTMENTVALUE_HPP_
+#include <com/sun/star/drawing/EnhancedCustomShapeAdjustmentValue.hpp>
 #endif
 #ifndef BOOST_SHARED_PTR_HPP_INCLUDED
 #include <boost/shared_ptr.hpp>
@@ -158,11 +158,11 @@
 		std::vector< ::boost::shared_ptr< ExpressionNode > >													vNodesSharedPtr;
 
 
-		com::sun::star::uno::Sequence< drafts::com::sun::star::drawing::EnhancedCustomShapeSegment >			seqSegments;
-		com::sun::star::uno::Sequence< drafts::com::sun::star::drawing::EnhancedCustomShapeParameterPair>		seqCoordinates;
-		com::sun::star::uno::Sequence< drafts::com::sun::star::drawing::EnhancedCustomShapeTextFrame >			seqTextFrames;
-		com::sun::star::uno::Sequence< drafts::com::sun::star::drawing::EnhancedCustomShapeParameterPair>		seqGluePoints;
-		com::sun::star::uno::Sequence< drafts::com::sun::star::drawing::EnhancedCustomShapeAdjustmentValue >	seqAdjustmentValues;
+		com::sun::star::uno::Sequence< com::sun::star::drawing::EnhancedCustomShapeSegment >			seqSegments;
+		com::sun::star::uno::Sequence< com::sun::star::drawing::EnhancedCustomShapeParameterPair>		seqCoordinates;
+		com::sun::star::uno::Sequence< com::sun::star::drawing::EnhancedCustomShapeTextFrame >			seqTextFrames;
+		com::sun::star::uno::Sequence< com::sun::star::drawing::EnhancedCustomShapeParameterPair>		seqGluePoints;
+		com::sun::star::uno::Sequence< com::sun::star::drawing::EnhancedCustomShapeAdjustmentValue >	seqAdjustmentValues;
 		com::sun::star::uno::Sequence< com::sun::star::beans::PropertyValues >									seqHandles;
 
 		sal_Bool					bTextFlow		: 1;
@@ -175,9 +175,9 @@
 
 		sal_Bool					SetAdjustValueAsDouble( const double& rValue, const sal_Int32 nIndex );
 		Color						GetColorData( const Color& rFillColor, sal_uInt32 nIndex );
-		sal_Bool					GetParameter( double& rParameterReturnValue,  const drafts::com::sun::star::drawing::EnhancedCustomShapeParameter&,
+		sal_Bool					GetParameter( double& rParameterReturnValue,  const com::sun::star::drawing::EnhancedCustomShapeParameter&,
 													const sal_Bool bReplaceGeoWidth, const sal_Bool bReplaceGeoHeight ) const;
-		Point						GetPoint( const drafts::com::sun::star::drawing::EnhancedCustomShapeParameterPair&,
+		Point						GetPoint( const com::sun::star::drawing::EnhancedCustomShapeParameterPair&,
 													const sal_Bool bScale = sal_True, const sal_Bool bReplaceGeoSize = sal_False ) const;
 
 		static void					SwapStartAndEndArrow( SdrObject* pObj );
@@ -197,15 +197,15 @@
 			sal_Bool	bMirroredY;
 			sal_Bool	bSwitched;
 
-			drafts::com::sun::star::drawing::EnhancedCustomShapeParameterPair aPosition;
-			drafts::com::sun::star::drawing::EnhancedCustomShapeParameterPair	aPolar;
+			com::sun::star::drawing::EnhancedCustomShapeParameterPair aPosition;
+			com::sun::star::drawing::EnhancedCustomShapeParameterPair	aPolar;
 
-			drafts::com::sun::star::drawing::EnhancedCustomShapeParameter		aRadiusRangeMinimum;
-			drafts::com::sun::star::drawing::EnhancedCustomShapeParameter		aRadiusRangeMaximum;
-			drafts::com::sun::star::drawing::EnhancedCustomShapeParameter		aXRangeMinimum;
-			drafts::com::sun::star::drawing::EnhancedCustomShapeParameter		aXRangeMaximum;
-			drafts::com::sun::star::drawing::EnhancedCustomShapeParameter		aYRangeMinimum;
-			drafts::com::sun::star::drawing::EnhancedCustomShapeParameter		aYRangeMaximum;
+			com::sun::star::drawing::EnhancedCustomShapeParameter		aRadiusRangeMinimum;
+			com::sun::star::drawing::EnhancedCustomShapeParameter		aRadiusRangeMaximum;
+			com::sun::star::drawing::EnhancedCustomShapeParameter		aXRangeMinimum;
+			com::sun::star::drawing::EnhancedCustomShapeParameter		aXRangeMaximum;
+			com::sun::star::drawing::EnhancedCustomShapeParameter		aYRangeMinimum;
+			com::sun::star::drawing::EnhancedCustomShapeParameter		aYRangeMaximum;
 		};
 
 		sal_Bool					IsFlipVert() { return bFlipV; };
@@ -240,7 +240,7 @@
 			ENUM_FUNC_LOGHEIGHT
 		};
 		double						GetEnumFunc( const EnumFunc eVal ) const;
- 
+
 		double						GetAdjustValueAsDouble( const sal_Int32 nIndex ) const;
 		double						GetEquationValueAsDouble( const sal_Int32 nIndex ) const;
 		sal_Int32					GetAdjustValueAsInteger( const sal_Int32 nIndex, const sal_Int32 nDefault = 0 ) const;
@@ -249,11 +249,11 @@
 
 		static void					AppendEnhancedCustomShapeEquationParameter( rtl::OUString& rParameter, const sal_Int16 nPara, const sal_Bool bIsSpecialValue );
 
-		static void					SetEnhancedCustomShapeEquationParameter( drafts::com::sun::star::drawing::EnhancedCustomShapeParameter&
+		static void					SetEnhancedCustomShapeEquationParameter( com::sun::star::drawing::EnhancedCustomShapeParameter&
 										rParameter, const sal_Int16 nPara, const sal_Bool bIsSpecialValue );
-		static void					SetEnhancedCustomShapeParameter( drafts::com::sun::star::drawing::EnhancedCustomShapeParameter&
+		static void					SetEnhancedCustomShapeParameter( com::sun::star::drawing::EnhancedCustomShapeParameter&
 										rParameter, const sal_Int32 nValue );
-		static void					SetEnhancedCustomShapeHandleParameter( drafts::com::sun::star::drawing::EnhancedCustomShapeParameter&
+		static void					SetEnhancedCustomShapeHandleParameter( com::sun::star::drawing::EnhancedCustomShapeParameter&
 										rParameter, const sal_Int32 nPara, const sal_Bool bIsSpecialValue, sal_Bool bHorz );
 		static sal_Bool				ConvertSequenceToEnhancedCustomShape2dHandle( const com::sun::star::beans::PropertyValues& rHandleProperties,
 										EnhancedCustomShape2d::Handle& rDestinationHandle );
diff -u -r  svx/source/customshapes/EnhancedCustomShape3d.cxx  svx/source/customshapes/EnhancedCustomShape3d.cxx
---  svx/source/customshapes/EnhancedCustomShape3d.cxx	2004-11-03 16:03:47.000000000 +0530
+++  svx/source/customshapes/EnhancedCustomShape3d.cxx	2005-02-28 13:40:42.150625113 +0530
@@ -153,7 +153,7 @@
 #include <svx/sdr/properties/properties.hxx>
 #endif
 #ifndef _DRAFTS_COM_SUN_STAR_DRAWING_ENHANCEDCUSTOMSHAPEPARAMETERPARIR_HPP_
-#include <drafts/com/sun/star/drawing/EnhancedCustomShapeParameterPair.hpp>
+#include <com/sun/star/drawing/EnhancedCustomShapeParameterPair.hpp>
 #endif
 
 #define ITEMVALUE(ItemSet,Id,Cast)  ((const Cast&)(ItemSet).Get(Id)).GetValue()
@@ -164,7 +164,7 @@
 
 void GetOrigin( SdrCustomShapeGeometryItem& rItem, double& rOriginX, double& rOriginY )
 {
-	::drafts::com::sun::star::drawing::EnhancedCustomShapeParameterPair aOriginParaPair;
+	::com::sun::star::drawing::EnhancedCustomShapeParameterPair aOriginParaPair;
  	const rtl::OUString	sOrigin( RTL_CONSTASCII_USTRINGPARAM ( "Origin" ) );
 	Any* pAny = rItem.GetPropertyValueByName( sExtrusion, sOrigin );
 	if ( ! ( pAny && ( *pAny >>= aOriginParaPair ) && ( aOriginParaPair.First.Value >>= rOriginX ) && ( aOriginParaPair.Second.Value >>= rOriginY ) ) )
@@ -175,7 +175,7 @@
 }
 void GetRotateAngle( SdrCustomShapeGeometryItem& rItem, double& rAngleX, double& rAngleY )
 {
-	::drafts::com::sun::star::drawing::EnhancedCustomShapeParameterPair aRotateAngleParaPair;
+	::com::sun::star::drawing::EnhancedCustomShapeParameterPair aRotateAngleParaPair;
  	const rtl::OUString	sRotateAngle( RTL_CONSTASCII_USTRINGPARAM ( "RotateAngle" ) );
 	Any* pAny = rItem.GetPropertyValueByName( sExtrusion, sRotateAngle );
 	if ( ! ( pAny && ( *pAny >>= aRotateAngleParaPair ) && ( aRotateAngleParaPair.First.Value >>= rAngleX ) && ( aRotateAngleParaPair.Second.Value >>= rAngleY ) ) )
@@ -188,7 +188,7 @@
 }
 void GetSkew( SdrCustomShapeGeometryItem& rItem, double& rSkewAmount, double& rSkewAngle )
 {
-	::drafts::com::sun::star::drawing::EnhancedCustomShapeParameterPair aSkewParaPair;
+	::com::sun::star::drawing::EnhancedCustomShapeParameterPair aSkewParaPair;
  	const rtl::OUString	sSkew( RTL_CONSTASCII_USTRINGPARAM ( "Skew" ) );
 	Any* pAny = rItem.GetPropertyValueByName( sExtrusion, sSkew );
 	if ( ! ( pAny && ( *pAny >>= aSkewParaPair ) && ( aSkewParaPair.First.Value >>= rSkewAmount ) && ( aSkewParaPair.Second.Value >>= rSkewAngle ) ) )
@@ -200,7 +200,7 @@
 }
 void GetExtrusionDepth( SdrCustomShapeGeometryItem& rItem, const double* pMap, double& rBackwardDepth, double& rForwardDepth )
 {
-	::drafts::com::sun::star::drawing::EnhancedCustomShapeParameterPair aDepthParaPair;
+	::com::sun::star::drawing::EnhancedCustomShapeParameterPair aDepthParaPair;
 	double fDepth, fFraction;
 	const rtl::OUString	sDepth( RTL_CONSTASCII_USTRINGPARAM ( "Depth" ) );
 	Any* pAny = rItem.GetPropertyValueByName( sExtrusion, sDepth );
diff -u -r  svx/source/customshapes/EnhancedCustomShapeEngine.cxx  svx/source/customshapes/EnhancedCustomShapeEngine.cxx
---  svx/source/customshapes/EnhancedCustomShapeEngine.cxx	2004-11-03 16:04:02.000000000 +0530
+++  svx/source/customshapes/EnhancedCustomShapeEngine.cxx	2005-02-28 13:40:42.291608638 +0530
@@ -115,17 +115,17 @@
 {
 	return B2UCONST( "com.sun.star.drawing.EnhancedCustomShapeEngine" );
 }
-sal_Bool SAL_CALL EnhancedCustomShapeEngine_supportsService( const rtl::OUString& ServiceName ) 
+sal_Bool SAL_CALL EnhancedCustomShapeEngine_supportsService( const rtl::OUString& ServiceName )
 	throw( NMSP_UNO::RuntimeException )
 {
-    return ServiceName.equalsAsciiL( RTL_CONSTASCII_STRINGPARAM( "drafts.com.sun.star.drawing.CustomShapeEngine" ) );
+    return ServiceName.equalsAsciiL( RTL_CONSTASCII_STRINGPARAM( "com.sun.star.drawing.CustomShapeEngine" ) );
 }
-SEQ( rtl::OUString ) SAL_CALL EnhancedCustomShapeEngine_getSupportedServiceNames() 
+SEQ( rtl::OUString ) SAL_CALL EnhancedCustomShapeEngine_getSupportedServiceNames()
 	throw( NMSP_UNO::RuntimeException )
 {
 	SEQ( rtl::OUString ) aRet(1);
     rtl::OUString* pArray = aRet.getArray();
-    pArray[0] = B2UCONST( "drafts.com.sun.star.drawing.CustomShapeEngine" );
+    pArray[0] = B2UCONST( "com.sun.star.drawing.CustomShapeEngine" );
     return aRet;
 }
 
@@ -172,17 +172,17 @@
 
 // XServiceInfo ---------------------------------------------------------------
 
-rtl::OUString SAL_CALL EnhancedCustomShapeEngine::getImplementationName() 
+rtl::OUString SAL_CALL EnhancedCustomShapeEngine::getImplementationName()
 	throw( NMSP_UNO::RuntimeException )
 {
 	return EnhancedCustomShapeEngine_getImplementationName();
 }
-sal_Bool SAL_CALL EnhancedCustomShapeEngine::supportsService( const rtl::OUString& rServiceName ) 
+sal_Bool SAL_CALL EnhancedCustomShapeEngine::supportsService( const rtl::OUString& rServiceName )
 	throw( NMSP_UNO::RuntimeException )
 {
     return EnhancedCustomShapeEngine_supportsService( rServiceName );
 }
-SEQ( rtl::OUString ) SAL_CALL EnhancedCustomShapeEngine::getSupportedServiceNames() 
+SEQ( rtl::OUString ) SAL_CALL EnhancedCustomShapeEngine::getSupportedServiceNames()
 	throw ( NMSP_UNO::RuntimeException )
 {
     return EnhancedCustomShapeEngine_getSupportedServiceNames();
@@ -203,7 +203,7 @@
 		sal_Bool bTextPathOn = sal_False;
 		const rtl::OUString	sTextPath( RTL_CONSTASCII_USTRINGPARAM ( "TextPath" ) );
 		com::sun::star::uno::Any* pAny = rGeometryItem.GetPropertyValueByName( sTextPath, sTextPath );
-		if ( pAny ) 
+		if ( pAny )
 			*pAny >>= bTextPathOn;
 
 		EnhancedCustomShape2d aCustomShape2d( pSdrObjCustomShape );
@@ -338,9 +338,9 @@
 	return aPolyPolygonBezierCoords;
 }
 
-SEQ( REF( drafts::com::sun::star::drawing::XCustomShapeHandle ) ) SAL_CALL EnhancedCustomShapeEngine::getInteraction()
+SEQ( REF( com::sun::star::drawing::XCustomShapeHandle ) ) SAL_CALL EnhancedCustomShapeEngine::getInteraction()
 	throw ( NMSP_UNO::RuntimeException )
-{	
+{
 	sal_uInt32 i, nHdlCount = 0;
 	SdrObject* pSdrObjCustomShape = GetSdrObjectFromXShape( mxShape );
 	if ( pSdrObjCustomShape )
@@ -348,7 +348,7 @@
 		EnhancedCustomShape2d aCustomShape2d( pSdrObjCustomShape );
 		nHdlCount = aCustomShape2d.GetHdlCount();
 	}
-	SEQ( REF( drafts::com::sun::star::drawing::XCustomShapeHandle ) ) aSeq( nHdlCount );
+	SEQ( REF( com::sun::star::drawing::XCustomShapeHandle ) ) aSeq( nHdlCount );
 	for ( i = 0; i < nHdlCount; i++ )
 		aSeq[ i ] = new EnhancedCustomShapeHandle( mxShape, i );
 	return aSeq;
diff -u -r  svx/source/customshapes/EnhancedCustomShapeEngine.hxx  svx/source/customshapes/EnhancedCustomShapeEngine.hxx
---  svx/source/customshapes/EnhancedCustomShapeEngine.hxx	2004-04-02 19:33:45.000000000 +0530
+++  svx/source/customshapes/EnhancedCustomShapeEngine.hxx	2005-02-28 13:40:42.298607820 +0530
@@ -101,8 +101,8 @@
 #ifndef _COM_SUN_STAR_LANG_XSERVICEINFO_HPP_
 #include <com/sun/star/lang/XServiceInfo.hpp>
 #endif
-#ifndef _DRAFTS_COM_SUN_STAR_DRAWING_XCUSTOMSHAPEENGINE_HPP_
-#include <drafts/com/sun/star/drawing/XCustomShapeEngine.hpp>
+#ifndef _COM_SUN_STAR_DRAWING_XCUSTOMSHAPEENGINE_HPP_
+#include <com/sun/star/drawing/XCustomShapeEngine.hpp>
 #endif
 
 // -----------------------------------------------------------------------------
@@ -129,7 +129,7 @@
 < 
 	com::sun::star::lang::XInitialization,
 	com::sun::star::lang::XServiceInfo,
-	drafts::com::sun::star::drawing::XCustomShapeEngine
+	com::sun::star::drawing::XCustomShapeEngine
 >
 {
 	REF( NMSP_LANG::XMultiServiceFactory )		mxFact;
@@ -162,7 +162,7 @@
 		throw ( NMSP_UNO::RuntimeException );
 	virtual com::sun::star::drawing::PolyPolygonBezierCoords SAL_CALL getLineGeometry()
 		throw ( NMSP_UNO::RuntimeException );
-	virtual SEQ( REF( drafts::com::sun::star::drawing::XCustomShapeHandle ) ) SAL_CALL getInteraction()
+	virtual SEQ( REF( com::sun::star::drawing::XCustomShapeHandle ) ) SAL_CALL getInteraction()
 		throw ( NMSP_UNO::RuntimeException );
 };
 
diff -u -r  svx/source/customshapes/EnhancedCustomShapeFunctionParser.cxx  svx/source/customshapes/EnhancedCustomShapeFunctionParser.cxx
---  svx/source/customshapes/EnhancedCustomShapeFunctionParser.cxx	2005-01-07 14:53:03.000000000 +0530
+++  svx/source/customshapes/EnhancedCustomShapeFunctionParser.cxx	2005-02-28 13:40:42.252613195 +0530
@@ -87,7 +87,7 @@
 #include <algorithm>
 #include <stack>
 using namespace com::sun::star;
-using namespace drafts::com::sun::star::drawing;
+using namespace ::com::sun::star::drawing;
 
 void FillEquationParameter( const EnhancedCustomShapeParameter& rSource, const sal_Int32 nDestPara, EnhancedCustomShapeEquation& rDest )
 {
@@ -103,7 +103,7 @@
 
 	switch( rSource.Type )
 	{
-		case drafts::com::sun::star::drawing::EnhancedCustomShapeParameterType::EQUATION :
+		case com::sun::star::drawing::EnhancedCustomShapeParameterType::EQUATION :
 		{
 			if ( nValue & 0x40000000 )
 			{
@@ -113,13 +113,13 @@
 			nValue |= 0x400;
 		}
 		break;
-		case drafts::com::sun::star::drawing::EnhancedCustomShapeParameterType::ADJUSTMENT : nValue += DFF_Prop_adjustValue; break;
-		case drafts::com::sun::star::drawing::EnhancedCustomShapeParameterType::BOTTOM : nValue = DFF_Prop_geoBottom; break;
-		case drafts::com::sun::star::drawing::EnhancedCustomShapeParameterType::RIGHT : nValue = DFF_Prop_geoRight; break;
-		case drafts::com::sun::star::drawing::EnhancedCustomShapeParameterType::TOP : nValue = DFF_Prop_geoTop;	break;
-		case drafts::com::sun::star::drawing::EnhancedCustomShapeParameterType::LEFT : nValue = DFF_Prop_geoLeft; break;
+		case com::sun::star::drawing::EnhancedCustomShapeParameterType::ADJUSTMENT : nValue += DFF_Prop_adjustValue; break;
+		case com::sun::star::drawing::EnhancedCustomShapeParameterType::BOTTOM : nValue = DFF_Prop_geoBottom; break;
+		case com::sun::star::drawing::EnhancedCustomShapeParameterType::RIGHT : nValue = DFF_Prop_geoRight; break;
+		case com::sun::star::drawing::EnhancedCustomShapeParameterType::TOP : nValue = DFF_Prop_geoTop;	break;
+		case com::sun::star::drawing::EnhancedCustomShapeParameterType::LEFT : nValue = DFF_Prop_geoLeft; break;
 	}
-	if ( rSource.Type != drafts::com::sun::star::drawing::EnhancedCustomShapeParameterType::NORMAL )
+	if ( rSource.Type != com::sun::star::drawing::EnhancedCustomShapeParameterType::NORMAL )
 		rDest.nOperation |= ( 0x2000 << nDestPara );
 	rDest.nPara[ nDestPara ] = nValue;
 }
diff -u -r  svx/source/customshapes/EnhancedCustomShapeFunctionParser.hxx  svx/source/customshapes/EnhancedCustomShapeFunctionParser.hxx
---  svx/source/customshapes/EnhancedCustomShapeFunctionParser.hxx	2005-01-07 14:53:17.000000000 +0530
+++  svx/source/customshapes/EnhancedCustomShapeFunctionParser.hxx	2005-02-28 13:40:42.253613078 +0530
@@ -71,11 +71,11 @@
 #ifndef _ENHANCEDCUSTOMSHAPEFUNCTIONPARSER_HXX
 #include "EnhancedCustomShapeFunctionParser.hxx"
 #endif
-#ifndef _DRAFTS_COM_SUN_STAR_DRAWING_ENHANCEDCUSTOMSHAPEPARAMETER_HPP_
-#include <drafts/com/sun/star/drawing/EnhancedCustomShapeParameter.hpp>
+#ifndef _COM_SUN_STAR_DRAWING_ENHANCEDCUSTOMSHAPEPARAMETER_HPP_
+#include <com/sun/star/drawing/EnhancedCustomShapeParameter.hpp>
 #endif
-#ifndef _DRAFTS_COM_SUN_STAR_DRAWING_ENHANCEDCUSTOMSHAPEPARAMETERTYPE_HPP_
-#include <drafts/com/sun/star/drawing/EnhancedCustomShapeParameterType.hpp>
+#ifndef _COM_SUN_STAR_DRAWING_ENHANCEDCUSTOMSHAPEPARAMETERTYPE_HPP_
+#include <com/sun/star/drawing/EnhancedCustomShapeParameterType.hpp>
 #endif
 #include <vector>
 
@@ -137,7 +137,7 @@
     class OUString;
 }
 
-void FillEquationParameter( const drafts::com::sun::star::drawing::EnhancedCustomShapeParameter&, const sal_Int32, EnhancedCustomShapeEquation& );
+void FillEquationParameter( const com::sun::star::drawing::EnhancedCustomShapeParameter&, const sal_Int32, EnhancedCustomShapeEquation& );
 
 class ExpressionNode
 {
@@ -166,7 +166,7 @@
 
 	/** Operator to retrieve the ms version of expression
 	*/
-	virtual drafts::com::sun::star::drawing::EnhancedCustomShapeParameter fillNode(
+	virtual com::sun::star::drawing::EnhancedCustomShapeParameter fillNode(
 		std::vector< EnhancedCustomShapeEquation >& rEquations, ExpressionNode* pOptionalArg, sal_uInt32 nFlags ) = 0;
 };
 typedef ::boost::shared_ptr< ExpressionNode > ExpressionNodeSharedPtr;
diff -u -r  svx/source/customshapes/EnhancedCustomShapeGeometry.cxx  svx/source/customshapes/EnhancedCustomShapeGeometry.cxx
---  svx/source/customshapes/EnhancedCustomShapeGeometry.cxx	2005-01-27 21:46:38.000000000 +0530
+++  svx/source/customshapes/EnhancedCustomShapeGeometry.cxx	2005-02-28 13:40:42.290608755 +0530
@@ -61,8 +61,8 @@
 #ifndef _ENHANCEDCUSTOMSHAPEGEOMETRY_HXX
 #include "EnhancedCustomShapeGeometry.hxx"
 #endif
-#ifndef _DRAFTS_COM_SUN_STAR_DRAWING_ENHANCEDCUSTOMSHAPEGLUEPOINTTYPE_HPP_
-#include <drafts/com/sun/star/drawing/EnhancedCustomShapeGluePointType.hpp>
+#ifndef _COM_SUN_STAR_DRAWING_ENHANCEDCUSTOMSHAPEGLUEPOINTTYPE_HPP_
+#include <com/sun/star/drawing/EnhancedCustomShapeGluePointType.hpp>
 #endif
 
 /*
@@ -5519,10 +5519,10 @@
 }
 const sal_Int16 GetCustomShapeConnectionTypeDefault( MSO_SPT eSpType )
 {
-	sal_Int16 nGluePointType = drafts::com::sun::star::drawing::EnhancedCustomShapeGluePointType::SEGMENTS;
+	sal_Int16 nGluePointType = com::sun::star::drawing::EnhancedCustomShapeGluePointType::SEGMENTS;
 	const mso_CustomShape* pDefCustomShape = GetCustomShapeContent( eSpType );
 	if ( pDefCustomShape && pDefCustomShape->nGluePoints )
-		nGluePointType = drafts::com::sun::star::drawing::EnhancedCustomShapeGluePointType::CUSTOM;
+		nGluePointType = com::sun::star::drawing::EnhancedCustomShapeGluePointType::CUSTOM;
 	else
 	{
 		switch( eSpType )
@@ -5533,7 +5533,7 @@
 			case mso_sptFlowChartProcess :
 			case mso_sptTextPlainText :
 			case mso_sptTextBox :
-				nGluePointType = drafts::com::sun::star::drawing::EnhancedCustomShapeGluePointType::RECT;
+				nGluePointType = com::sun::star::drawing::EnhancedCustomShapeGluePointType::RECT;
 		}
 	}
 	return nGluePointType;
diff -u -r  svx/source/customshapes/EnhancedCustomShapeHandle.hxx  svx/source/customshapes/EnhancedCustomShapeHandle.hxx
---  svx/source/customshapes/EnhancedCustomShapeHandle.hxx	2004-04-02 19:35:01.000000000 +0530
+++  svx/source/customshapes/EnhancedCustomShapeHandle.hxx	2005-02-28 13:40:42.268611325 +0530
@@ -76,8 +76,8 @@
 #ifndef _COM_SUN_STAR_DRAWING_XSHAPE_HPP_
 #include <com/sun/star/drawing/XShape.hpp>
 #endif
-#ifndef _DRAFTS_COM_SUN_STAR_DRAWING_XCUSTOMSHAPEHANDLE_HPP_
-#include <drafts/com/sun/star/drawing/XCustomShapeHandle.hpp>
+#ifndef _COM_SUN_STAR_DRAWING_XCUSTOMSHAPEHANDLE_HPP_
+#include <com/sun/star/drawing/XCustomShapeHandle.hpp>
 #endif
 #ifndef _COM_SUN_STAR_AWT_POINT_HPP_
 #include <com/sun/star/awt/Point.hpp>
@@ -88,7 +88,7 @@
 
 class EnhancedCustomShapeHandle : public cppu::WeakImplHelper2
 < 
-	drafts::com::sun::star::drawing::XCustomShapeHandle,
+	com::sun::star::drawing::XCustomShapeHandle,
 	com::sun::star::lang::XInitialization
 >
 {
diff -u -r  svx/source/customshapes/makefile.mk  svx/source/customshapes/makefile.mk
---  svx/source/customshapes/makefile.mk	2005-01-21 22:16:11.000000000 +0530
+++  svx/source/customshapes/makefile.mk	2005-02-28 13:40:42.299607703 +0530
@@ -98,8 +98,8 @@
 			com.sun.star.util.XTextSearch							\
 			com.sun.star.util.SearchResult							\
 			com.sun.star.xml.sax.XDocumentHandler					\
-			drafts.com.sun.star.drawing.XCustomShapeEngine			\
-			drafts.com.sun.star.drawing.XCustomShapeHandle
+			com.sun.star.drawing.XCustomShapeEngine			        \
+			com.sun.star.drawing.XCustomShapeHandle
 
 
 # --- Files -------------------------------------
diff -u -r  svx/source/dialog/cuicharmap.hxx  svx/source/dialog/cuicharmap.hxx
---  svx/source/dialog/cuicharmap.hxx	2004-05-10 22:20:37.000000000 +0530
+++  svx/source/dialog/cuicharmap.hxx	2005-02-28 13:40:45.419243153 +0530
@@ -124,4 +124,4 @@
 };
 
 #endif
- 
\ No newline at end of file
+ 
diff -u -r  svx/source/editeng/impedit3.cxx  svx/source/editeng/impedit3.cxx
---  svx/source/editeng/impedit3.cxx	2004-11-26 23:42:55.000000000 +0530
+++  svx/source/editeng/impedit3.cxx	2005-02-28 13:40:41.801665891 +0530
diff -u -r  svx/source/editeng/impedit.hxx  svx/source/editeng/impedit.hxx
---  svx/source/editeng/impedit.hxx	2005-01-11 18:29:27.000000000 +0530
+++  svx/source/editeng/impedit.hxx	2005-02-28 13:40:41.788667410 +0530
@@ -744,10 +744,11 @@
 
     /** Decorate metafile output with verbose text comments
 
-		This method is used to call SvxFont::QuickDrawText
-		character-by-character wise, adding informational metafile
-		comments after logical text units like characters, words and
-		sentences. This is necessary for slideshow text effects.
+		This method is used to wrap SvxFont::QuickDrawText, to
+		determine character-by-character wise, which logical text
+		units like characters, words and sentences are contained in
+		the output string at hand. This is necessary for slideshow
+		text effects.
      */
     void 				ImplDrawWithComments( SvxFont& 								rFont,
                                               const ::com::sun::star::lang::Locale& rLocale,
diff -u -r  svx/source/form/fmshell.cxx  svx/source/form/fmshell.cxx
---  svx/source/form/fmshell.cxx	2005-01-28 22:02:33.000000000 +0530
+++  svx/source/form/fmshell.cxx	2005-02-28 13:40:40.000000000 +0530
@@ -356,7 +356,7 @@
 using namespace ::com::sun::star::sdbcx;
 using namespace ::com::sun::star::beans;
 using namespace ::com::sun::star::form;
-using namespace ::drafts::com::sun::star::frame;
+using namespace ::com::sun::star::frame;
 using namespace ::svxform;
 
 //========================================================================
diff -u -r  svx/source/items/ofaitem.cxx  svx/source/items/ofaitem.cxx
---  svx/source/items/ofaitem.cxx	2004-07-06 18:47:04.000000000 +0530
+++  svx/source/items/ofaitem.cxx	2005-02-28 13:40:40.000000000 +0530
@@ -119,4 +119,4 @@
 
     return sal_False;
 }
-*/
\ No newline at end of file
+*/
diff -u -r  svx/source/msfilter/escherex.cxx  svx/source/msfilter/escherex.cxx
---  svx/source/msfilter/escherex.cxx	2005-01-07 14:53:47.000000000 +0530
+++  svx/source/msfilter/escherex.cxx	2005-02-28 13:40:51.655514413 +0530
@@ -178,25 +178,25 @@
 #include <com/sun/star/drawing/TextHorizontalAdjust.hpp>
 #endif
 #ifndef _DRAFTS_COM_SUN_STAR_DRAWING_ENHANCEDCUSTOMSHAPEPARAMETERPARIR_HPP_
-#include <drafts/com/sun/star/drawing/EnhancedCustomShapeParameterPair.hpp>
+#include <com/sun/star/drawing/EnhancedCustomShapeParameterPair.hpp>
 #endif
-#ifndef _DRAFTS_COM_SUN_STAR_DRAWING_ENHANCEDCUSTOMSHAPESEGMENT_HPP_
-#include <drafts/com/sun/star/drawing/EnhancedCustomShapeSegment.hpp>
+#ifndef _COM_SUN_STAR_DRAWING_ENHANCEDCUSTOMSHAPESEGMENT_HPP_
+#include <com/sun/star/drawing/EnhancedCustomShapeSegment.hpp>
 #endif
-#ifndef _DRAFTS_COM_SUN_STAR_DRAWING_ENHANCEDCUSTOMSHAPEPARAMETERTYPE_HPP_
-#include <drafts/com/sun/star/drawing/EnhancedCustomShapeParameterType.hpp>
+#ifndef _COM_SUN_STAR_DRAWING_ENHANCEDCUSTOMSHAPEPARAMETERTYPE_HPP_
+#include <com/sun/star/drawing/EnhancedCustomShapeParameterType.hpp>
 #endif
 #ifndef _DRAFTS_COM_SUN_STAR_DRAWING_ENHANCEDCUSTOMSHAPESEGMENTCOMMAND_hpp_
-#include <drafts/com/sun/star/drawing/EnhancedCustomShapeSegmentCommand.hpp>
+#include <com/sun/star/drawing/EnhancedCustomShapeSegmentCommand.hpp>
 #endif
-#ifndef _DRAFTS_COM_SUN_STAR_DRAWING_ENHANCEDCUSTOMSHAPETEXTFRAME_HPP_
-#include <drafts/com/sun/star/drawing/EnhancedCustomShapeTextFrame.hpp>
+#ifndef _COM_SUN_STAR_DRAWING_ENHANCEDCUSTOMSHAPETEXTFRAME_HPP_
+#include <com/sun/star/drawing/EnhancedCustomShapeTextFrame.hpp>
 #endif
-#ifndef _DRAFTS_COM_SUN_STAR_DRAWING_ENHANCEDCUSTOMSHAPEADJUSTMENTVALUE_HPP_
-#include <drafts/com/sun/star/drawing/EnhancedCustomShapeAdjustmentValue.hpp>
+#ifndef _COM_SUN_STAR_DRAWING_ENHANCEDCUSTOMSHAPEADJUSTMENTVALUE_HPP_
+#include <com/sun/star/drawing/EnhancedCustomShapeAdjustmentValue.hpp>
 #endif
-#ifndef _DRAFTS_COM_SUN_STAR_DRAWING_ENHANCEDCUSTOMSHAPETEXTPATHMODE_HPP_
-#include <drafts/com/sun/star/drawing/EnhancedCustomShapeTextPathMode.hpp>
+#ifndef _COM_SUN_STAR_DRAWING_ENHANCEDCUSTOMSHAPETEXTPATHMODE_HPP_
+#include <com/sun/star/drawing/EnhancedCustomShapeTextPathMode.hpp>
 #endif
 #ifndef _COM_SUN_STAR_DRAWING_PROJECTIONMODE_HPP_
 #include <com/sun/star/drawing/ProjectionMode.hpp>
@@ -1895,7 +1895,7 @@
 
 // ---------------------------------------------------------------------------------------------
 
-sal_Int32 GetValueForEnhancedCustomShapeParameter( const drafts::com::sun::star::drawing::EnhancedCustomShapeParameter& rParameter, const std::vector< sal_Int32 >& rEquationOrder )
+sal_Int32 GetValueForEnhancedCustomShapeParameter( const com::sun::star::drawing::EnhancedCustomShapeParameter& rParameter, const std::vector< sal_Int32 >& rEquationOrder )
 {
 	sal_Int32 nValue = 0;
 	if ( rParameter.Value.getValueTypeClass() == uno::TypeClass_DOUBLE )
@@ -1909,30 +1909,30 @@
 
 	switch( rParameter.Type )
 	{
-		case drafts::com::sun::star::drawing::EnhancedCustomShapeParameterType::EQUATION :
+		case com::sun::star::drawing::EnhancedCustomShapeParameterType::EQUATION :
 		{
 			nValue = (sal_uInt16)rEquationOrder[ nValue ];
 			nValue |= (sal_uInt32)0x80000000;
 		}
 		break;
-		case drafts::com::sun::star::drawing::EnhancedCustomShapeParameterType::NORMAL :
+		case com::sun::star::drawing::EnhancedCustomShapeParameterType::NORMAL :
 		{
 			
 		}
 		break;
 /* not sure if it is allowed to set following values
 (but they are not yet used)
-		case drafts::com::sun::star::drawing::EnhancedCustomShapeParameterType::ADJUSTMENT :
-		case drafts::com::sun::star::drawing::EnhancedCustomShapeParameterType::BOTTOM :
-		case drafts::com::sun::star::drawing::EnhancedCustomShapeParameterType::RIGHT :
-		case drafts::com::sun::star::drawing::EnhancedCustomShapeParameterType::TOP :
-		case drafts::com::sun::star::drawing::EnhancedCustomShapeParameterType::LEFT :
+		case com::sun::star::drawing::EnhancedCustomShapeParameterType::ADJUSTMENT :
+		case com::sun::star::drawing::EnhancedCustomShapeParameterType::BOTTOM :
+		case com::sun::star::drawing::EnhancedCustomShapeParameterType::RIGHT :
+		case com::sun::star::drawing::EnhancedCustomShapeParameterType::TOP :
+		case com::sun::star::drawing::EnhancedCustomShapeParameterType::LEFT :
 */
 	}
 	return nValue;
 }
 
-sal_Bool GetValueForEnhancedCustomShapeHandleParameter( sal_Int32& nRetValue, const drafts::com::sun::star::drawing::EnhancedCustomShapeParameter& rParameter )
+sal_Bool GetValueForEnhancedCustomShapeHandleParameter( sal_Int32& nRetValue, const com::sun::star::drawing::EnhancedCustomShapeParameter& rParameter )
 {
 	sal_Bool bSpecial = sal_False;
 	nRetValue = 0;
@@ -1947,33 +1947,33 @@
 
 	switch( rParameter.Type )
 	{
-		case drafts::com::sun::star::drawing::EnhancedCustomShapeParameterType::EQUATION :
+		case com::sun::star::drawing::EnhancedCustomShapeParameterType::EQUATION :
 		{
 			nRetValue += 3;
 			bSpecial = sal_True;
 		}
 		break;
-		case drafts::com::sun::star::drawing::EnhancedCustomShapeParameterType::ADJUSTMENT :
+		case com::sun::star::drawing::EnhancedCustomShapeParameterType::ADJUSTMENT :
 		{
 			nRetValue += 0x100;
 			bSpecial = sal_True;
 		}
 		break;
-		case drafts::com::sun::star::drawing::EnhancedCustomShapeParameterType::TOP :
-		case drafts::com::sun::star::drawing::EnhancedCustomShapeParameterType::LEFT :
+		case com::sun::star::drawing::EnhancedCustomShapeParameterType::TOP :
+		case com::sun::star::drawing::EnhancedCustomShapeParameterType::LEFT :
 		{
 			nRetValue = 0;
 			bSpecial = sal_True;
 		}
 		break;
-		case drafts::com::sun::star::drawing::EnhancedCustomShapeParameterType::RIGHT :
-		case drafts::com::sun::star::drawing::EnhancedCustomShapeParameterType::BOTTOM :
+		case com::sun::star::drawing::EnhancedCustomShapeParameterType::RIGHT :
+		case com::sun::star::drawing::EnhancedCustomShapeParameterType::BOTTOM :
 		{
 			nRetValue = 1;
 			bSpecial = sal_True;
 		}
 		break;
-		case drafts::com::sun::star::drawing::EnhancedCustomShapeParameterType::NORMAL :
+		case com::sun::star::drawing::EnhancedCustomShapeParameterType::NORMAL :
 		{
 			
 		}
@@ -2005,8 +2005,8 @@
 				{
 					::boost::shared_ptr< ExpressionNode > aExpressNode(
 						EnhancedCustomShapeFunctionParser::parseFunction( sEquationSource[ i ], aCustoShape2d ) );
-					drafts::com::sun::star::drawing::EnhancedCustomShapeParameter aPara( aExpressNode->fillNode( rEquations, NULL, 0 ) );
-					if ( aPara.Type != drafts::com::sun::star::drawing::EnhancedCustomShapeParameterType::EQUATION )
+					com::sun::star::drawing::EnhancedCustomShapeParameter aPara( aExpressNode->fillNode( rEquations, NULL, 0 ) );
+					if ( aPara.Type != com::sun::star::drawing::EnhancedCustomShapeParameterType::EQUATION )
 					{
 						EnhancedCustomShapeEquation	aEquation;
 						aEquation.nOperation = 0;
@@ -2187,7 +2187,7 @@
 							{
 								double fDepth;
 								double fFraction;
-								drafts::com::sun::star::drawing::EnhancedCustomShapeParameterPair aDepthParaPair;
+								com::sun::star::drawing::EnhancedCustomShapeParameterPair aDepthParaPair;
 								if ( ( rProp.Value >>= aDepthParaPair ) && ( aDepthParaPair.First.Value >>= fDepth ) && ( aDepthParaPair.Second.Value >>= fFraction ) )
 								{
 									double fForeDepth = fDepth * fFraction;
@@ -2323,7 +2323,7 @@
 							{
 								double fExtrusionAngleX;
 								double fExtrusionAngleY;
-								drafts::com::sun::star::drawing::EnhancedCustomShapeParameterPair aRotateAnglePair;
+								com::sun::star::drawing::EnhancedCustomShapeParameterPair aRotateAnglePair;
 								if ( ( rProp.Value >>= aRotateAnglePair ) && ( aRotateAnglePair.First.Value >>= fExtrusionAngleX ) && ( aRotateAnglePair.Second.Value >>= fExtrusionAngleY ) )
 								{
 									fExtrusionAngleX *= 65536;
@@ -2353,7 +2353,7 @@
 							{
 								double fSkewAmount;
 								double fSkewAngle;
-								drafts::com::sun::star::drawing::EnhancedCustomShapeParameterPair aSkewParaPair;
+								com::sun::star::drawing::EnhancedCustomShapeParameterPair aSkewParaPair;
 								if ( ( rProp.Value >>= aSkewParaPair ) && ( aSkewParaPair.First.Value >>= fSkewAmount ) && ( aSkewParaPair.Second.Value >>= fSkewAngle ) )
 								{
 									AddOpt( DFF_Prop_c3DSkewAmount, (sal_Int32)fSkewAmount );
@@ -2395,7 +2395,7 @@
 							{
 								double fExtrusionOriginX;
 								double fExtrusionOriginY;
-								drafts::com::sun::star::drawing::EnhancedCustomShapeParameterPair aOriginPair;
+								com::sun::star::drawing::EnhancedCustomShapeParameterPair aOriginPair;
 								if ( ( rProp.Value >>= aOriginPair ) && ( aOriginPair.First.Value >>= fExtrusionOriginX ) && ( aOriginPair.Second.Value >>= fExtrusionOriginY ) )
 								{
 									AddOpt( DFF_Prop_c3DOriginX, (sal_Int32)( fExtrusionOriginX * 65536 ) );
@@ -2530,7 +2530,7 @@
 							{
 								if ( !bIsDefaultObject )
 								{
-									com::sun::star::uno::Sequence< drafts::com::sun::star::drawing::EnhancedCustomShapeParameterPair > aCoordinates;
+									com::sun::star::uno::Sequence< com::sun::star::drawing::EnhancedCustomShapeParameterPair > aCoordinates;
 									if ( rProp.Value >>= aCoordinates )
 									{
 										// creating the vertices
@@ -2566,7 +2566,7 @@
 							{
 								if ( !bIsDefaultObject )
 								{
-									com::sun::star::uno::Sequence< drafts::com::sun::star::drawing::EnhancedCustomShapeParameterPair> aGluePoints;
+									com::sun::star::uno::Sequence< com::sun::star::drawing::EnhancedCustomShapeParameterPair> aGluePoints;
 									if ( rProp.Value >>= aGluePoints )
 									{
 										// creating the vertices
@@ -2608,7 +2608,7 @@
 							{
 								if ( !bIsDefaultObject )
 								{		
-									com::sun::star::uno::Sequence< drafts::com::sun::star::drawing::EnhancedCustomShapeSegment > aSegments;
+									com::sun::star::uno::Sequence< com::sun::star::drawing::EnhancedCustomShapeSegment > aSegments;
 									if ( rProp.Value >>= aSegments )
 									{
 										// creating seginfo
@@ -2626,80 +2626,80 @@
 												sal_uInt16 nVal = (sal_uInt16)aSegments[ j ].Count;
 												switch( aSegments[ j ].Command )
 												{
-													case drafts::com::sun::star::drawing::EnhancedCustomShapeSegmentCommand::UNKNOWN :
-													case drafts::com::sun::star::drawing::EnhancedCustomShapeSegmentCommand::LINETO : break;												
-													case drafts::com::sun::star::drawing::EnhancedCustomShapeSegmentCommand::MOVETO :
+													case com::sun::star::drawing::EnhancedCustomShapeSegmentCommand::UNKNOWN :
+													case com::sun::star::drawing::EnhancedCustomShapeSegmentCommand::LINETO : break;												
+													case com::sun::star::drawing::EnhancedCustomShapeSegmentCommand::MOVETO :
 													{
 														nVal = 0x4000;
 													}
 													break;
-													case drafts::com::sun::star::drawing::EnhancedCustomShapeSegmentCommand::CURVETO :
+													case com::sun::star::drawing::EnhancedCustomShapeSegmentCommand::CURVETO :
 													{
 														nVal |= 0x2000;
 													}
 													break;
-													case drafts::com::sun::star::drawing::EnhancedCustomShapeSegmentCommand::CLOSESUBPATH :
+													case com::sun::star::drawing::EnhancedCustomShapeSegmentCommand::CLOSESUBPATH :
 													{
 														nVal = 0x6001;
 													}
 													break;
-													case drafts::com::sun::star::drawing::EnhancedCustomShapeSegmentCommand::ENDSUBPATH :
+													case com::sun::star::drawing::EnhancedCustomShapeSegmentCommand::ENDSUBPATH :
 													{
 														nVal = 0x8000;
 													}
 													break;
-													case drafts::com::sun::star::drawing::EnhancedCustomShapeSegmentCommand::NOFILL :
+													case com::sun::star::drawing::EnhancedCustomShapeSegmentCommand::NOFILL :
 													{
 														nVal = 0xaa00;
 													}
 													break;
-													case drafts::com::sun::star::drawing::EnhancedCustomShapeSegmentCommand::NOSTROKE :
+													case com::sun::star::drawing::EnhancedCustomShapeSegmentCommand::NOSTROKE :
 													{
 														nVal = 0xab00;
 													}
 													break;
-													case drafts::com::sun::star::drawing::EnhancedCustomShapeSegmentCommand::ANGLEELLIPSETO :
+													case com::sun::star::drawing::EnhancedCustomShapeSegmentCommand::ANGLEELLIPSETO :
 													{
 														nVal *= 3;
 														nVal |= 0xa100;
 													}
 													break;
-													case drafts::com::sun::star::drawing::EnhancedCustomShapeSegmentCommand::ANGLEELLIPSE :
+													case com::sun::star::drawing::EnhancedCustomShapeSegmentCommand::ANGLEELLIPSE :
 													{
 														nVal *= 3;
 														nVal |= 0xa200;
 													}
 													break;
-													case drafts::com::sun::star::drawing::EnhancedCustomShapeSegmentCommand::ARCTO :
+													case com::sun::star::drawing::EnhancedCustomShapeSegmentCommand::ARCTO :
 													{
 														nVal <<= 2;
 														nVal |= 0xa300;
 													}
 													break;
-													case drafts::com::sun::star::drawing::EnhancedCustomShapeSegmentCommand::ARC :
+													case com::sun::star::drawing::EnhancedCustomShapeSegmentCommand::ARC :
 													{
 														nVal <<= 2;
 														nVal |= 0xa400;
 													}
 													break;
-													case drafts::com::sun::star::drawing::EnhancedCustomShapeSegmentCommand::CLOCKWISEARCTO :
+													case com::sun::star::drawing::EnhancedCustomShapeSegmentCommand::CLOCKWISEARCTO :
 													{
 														nVal <<= 2;
 														nVal |= 0xa500;
 													}
 													break;
-													case drafts::com::sun::star::drawing::EnhancedCustomShapeSegmentCommand::CLOCKWISEARC :
+													case com::sun::star::drawing::EnhancedCustomShapeSegmentCommand::CLOCKWISEARC :
 													{
 														nVal <<= 2;
 														nVal |= 0xa600;
 													}
 													break;
-													case drafts::com::sun::star::drawing::EnhancedCustomShapeSegmentCommand::ELLIPTICALQUADRANTX :
+													case com::sun::star::drawing::EnhancedCustomShapeSegmentCommand::ELLIPTICALQUADRANTX :
 													{
 														nVal |= 0xa700;
 													}
 													break;
-													case drafts::com::sun::star::drawing::EnhancedCustomShapeSegmentCommand::ELLIPTICALQUADRANTY :
+													case com::sun::star::drawing::EnhancedCustomShapeSegmentCommand::ELLIPTICALQUADRANTY :
 													{
 														nVal |= 0xa800;
 													}
@@ -2741,7 +2741,7 @@
 							{
 								if ( !bIsDefaultObject )
 								{
-									com::sun::star::uno::Sequence< drafts::com::sun::star::drawing::EnhancedCustomShapeTextFrame > aPathTextFrames;
+									com::sun::star::uno::Sequence< com::sun::star::drawing::EnhancedCustomShapeTextFrame > aPathTextFrames;
 									if ( rProp.Value >>= aPathTextFrames )
 									{
 										if ( (sal_uInt16)aPathTextFrames.getLength() )
@@ -2821,14 +2821,14 @@
 							}
 							else if ( rProp.Name.equals( sTextPathMode ) )
 							{
-								drafts::com::sun::star::drawing::EnhancedCustomShapeTextPathMode eTextPathMode;
+								com::sun::star::drawing::EnhancedCustomShapeTextPathMode eTextPathMode;
 								if ( rProp.Value >>= eTextPathMode )
 								{
 									nTextPathFlags |= 0x05000000;
 									nTextPathFlags &=~0x500;	// TextPathMode_NORMAL
-									if ( eTextPathMode == drafts::com::sun::star::drawing::EnhancedCustomShapeTextPathMode_PATH )
+									if ( eTextPathMode == com::sun::star::drawing::EnhancedCustomShapeTextPathMode_PATH )
 										nTextPathFlags |= 0x100;
-									else if ( eTextPathMode == drafts::com::sun::star::drawing::EnhancedCustomShapeTextPathMode_SHAPE )
+									else if ( eTextPathMode == com::sun::star::drawing::EnhancedCustomShapeTextPathMode_SHAPE )
 										nTextPathFlags |= 0x500;
 								}
 							}
@@ -2957,7 +2957,7 @@
 
 										if ( rPropVal.Name.equals( sPosition ) )
 										{
-											drafts::com::sun::star::drawing::EnhancedCustomShapeParameterPair aPosition;
+											com::sun::star::drawing::EnhancedCustomShapeParameterPair aPosition;
 											if ( rPropVal.Value >>= aPosition )
 											{
 												GetValueForEnhancedCustomShapeHandleParameter( nXPosition, aPosition.First );
@@ -2993,7 +2993,7 @@
 										}
 										else if ( rPropVal.Name.equals( sPolar ) )
 										{
-											drafts::com::sun::star::drawing::EnhancedCustomShapeParameterPair aPolar;
+											com::sun::star::drawing::EnhancedCustomShapeParameterPair aPolar;
 											if ( rPropVal.Value >>= aPolar )
 											{
 												if ( GetValueForEnhancedCustomShapeHandleParameter( nXMap, aPolar.First ) )
@@ -3006,7 +3006,7 @@
 	/* seems not to be used.
 										else if ( rPropVal.Name.equals( sMap ) )
 										{
-											drafts::com::sun::star::drawing::EnhancedCustomShapeParameterPair aMap;
+											com::sun::star::drawing::EnhancedCustomShapeParameterPair aMap;
 											if ( rPropVal.Value >>= aMap )
 											{
 												if ( GetValueForEnhancedCustomShapeHandleParameter( nXMap, aMap.First ) )
@@ -3022,7 +3022,7 @@
 											nYRangeMin = (sal_Int32)0xff4c0000;	// the range of angles seems to be a not
 											nYRangeMax = (sal_Int32)0x00b40000;	// used feature, so we are defaulting this
 
-											drafts::com::sun::star::drawing::EnhancedCustomShapeParameter aRadiusRangeMinimum;
+											com::sun::star::drawing::EnhancedCustomShapeParameter aRadiusRangeMinimum;
 											if ( rPropVal.Value >>= aRadiusRangeMinimum )
 											{
 												if ( GetValueForEnhancedCustomShapeHandleParameter( nXRangeMin, aRadiusRangeMinimum ) )
@@ -3035,7 +3035,7 @@
 											nYRangeMin = (sal_Int32)0xff4c0000;	// the range of angles seems to be a not
 											nYRangeMax = (sal_Int32)0x00b40000;	// used feature, so we are defaulting this
 
-											drafts::com::sun::star::drawing::EnhancedCustomShapeParameter aRadiusRangeMaximum;
+											com::sun::star::drawing::EnhancedCustomShapeParameter aRadiusRangeMaximum;
 											if ( rPropVal.Value >>= aRadiusRangeMaximum )
 											{
 												if ( GetValueForEnhancedCustomShapeHandleParameter( nXRangeMax, aRadiusRangeMaximum ) )
@@ -3045,7 +3045,7 @@
 										}
 										else if ( rPropVal.Name.equals( sRangeXMinimum ) )
 										{
-											drafts::com::sun::star::drawing::EnhancedCustomShapeParameter aXRangeMinimum;
+											com::sun::star::drawing::EnhancedCustomShapeParameter aXRangeMinimum;
 											if ( rPropVal.Value >>= aXRangeMinimum )
 											{
 												if ( GetValueForEnhancedCustomShapeHandleParameter( nXRangeMin, aXRangeMinimum ) )
@@ -3055,7 +3055,7 @@
 										}
 										else if ( rPropVal.Name.equals( sRangeXMaximum ) )
 										{
-											drafts::com::sun::star::drawing::EnhancedCustomShapeParameter aXRangeMaximum;
+											com::sun::star::drawing::EnhancedCustomShapeParameter aXRangeMaximum;
 											if ( rPropVal.Value >>= aXRangeMaximum )
 											{
 												if ( GetValueForEnhancedCustomShapeHandleParameter( nXRangeMax, aXRangeMaximum ) )
@@ -3065,7 +3065,7 @@
 										}
 										else if ( rPropVal.Name.equals( sRangeYMinimum ) )
 										{
-											drafts::com::sun::star::drawing::EnhancedCustomShapeParameter aYRangeMinimum;
+											com::sun::star::drawing::EnhancedCustomShapeParameter aYRangeMinimum;
 											if ( rPropVal.Value >>= aYRangeMinimum )
 											{
 												if ( GetValueForEnhancedCustomShapeHandleParameter( nYRangeMin, aYRangeMinimum ) )
@@ -3075,7 +3075,7 @@
 										}
 										else if ( rPropVal.Name.equals( sRangeYMaximum ) )
 										{
-											drafts::com::sun::star::drawing::EnhancedCustomShapeParameter aYRangeMaximum;
+											com::sun::star::drawing::EnhancedCustomShapeParameter aYRangeMaximum;
 											if ( rPropVal.Value >>= aYRangeMaximum )
 											{
 												if ( GetValueForEnhancedCustomShapeHandleParameter( nYRangeMax, aYRangeMaximum ) )
@@ -3118,7 +3118,7 @@
 			}
 			if ( pAdjustmentValuesProp )
 			{
-				uno::Sequence< drafts::com::sun::star::drawing::EnhancedCustomShapeAdjustmentValue > aAdjustmentSeq;
+				uno::Sequence< com::sun::star::drawing::EnhancedCustomShapeAdjustmentValue > aAdjustmentSeq;
 				if ( pAdjustmentValuesProp->Value >>= aAdjustmentSeq )
 				{
 					if ( bPredefinedHandlesUsed )
@@ -3141,7 +3141,7 @@
 					sal_Int32 i, nValue, nAdjustmentValues = aAdjustmentSeq.getLength();
 					for ( i = 0; i < nAdjustmentValues; i++ )
 					{
-						const drafts::com::sun::star::drawing::EnhancedCustomShapeAdjustmentValue & rProp = aAdjustmentSeq[ i ];
+						const com::sun::star::drawing::EnhancedCustomShapeAdjustmentValue & rProp = aAdjustmentSeq[ i ];
 						if ( rProp.State == beans::PropertyState_DIRECT_VALUE )
 						{
 							sal_Bool bUseFixedFloat = ( nAdjustmentsWhichNeedsToBeConverted & ( 1 << i ) ) != 0;
diff -u -r  svx/source/msfilter/msdffimp.cxx  svx/source/msfilter/msdffimp.cxx
---  svx/source/msfilter/msdffimp.cxx	2005-01-31 14:44:27.000000000 +0530
+++  svx/source/msfilter/msdffimp.cxx	2005-02-28 13:40:51.592521774 +0530
@@ -379,29 +379,29 @@
 #ifndef _ENHANCEDCUSTOMSHAPEGEOMETRY_HXX
 #include "../customshapes/EnhancedCustomShapeGeometry.hxx"
 #endif
-#ifndef _DRAFTS_COM_SUN_STAR_DRAWING_ENHANCEDCUSTOMSHAPEPARAMETERPAIR_HPP_
-#include <drafts/com/sun/star/drawing/EnhancedCustomShapeParameterPair.hpp>
+#ifndef _COM_SUN_STAR_DRAWING_ENHANCEDCUSTOMSHAPEPARAMETERPAIR_HPP_
+#include <com/sun/star/drawing/EnhancedCustomShapeParameterPair.hpp>
 #endif
-#ifndef _DRAFTS_COM_SUN_STAR_DRAWING_ENHANCEDCUSTOMSHAPEPARAMETERTYPE_HPP_
-#include <drafts/com/sun/star/drawing/EnhancedCustomShapeParameterType.hpp>
+#ifndef _COM_SUN_STAR_DRAWING_ENHANCEDCUSTOMSHAPEPARAMETERTYPE_HPP_
+#include <com/sun/star/drawing/EnhancedCustomShapeParameterType.hpp>
 #endif
-#ifndef _DRAFTS_COM_SUN_STAR_DRAWING_ENHANCEDCUSTOMSHAPESEGMENT_HPP_
-#include <drafts/com/sun/star/drawing/EnhancedCustomShapeSegment.hpp>
+#ifndef _COM_SUN_STAR_DRAWING_ENHANCEDCUSTOMSHAPESEGMENT_HPP_
+#include <com/sun/star/drawing/EnhancedCustomShapeSegment.hpp>
 #endif
-#ifndef _DRAFTS_COM_SUN_STAR_DRAWING_ENHANCEDCUSTOMSHAPEGLUEPOINTTYPE_HPP_
-#include <drafts/com/sun/star/drawing/EnhancedCustomShapeGluePointType.hpp>
+#ifndef _COM_SUN_STAR_DRAWING_ENHANCEDCUSTOMSHAPEGLUEPOINTTYPE_HPP_
+#include <com/sun/star/drawing/EnhancedCustomShapeGluePointType.hpp>
 #endif
-#ifndef _DRAFTS_COM_SUN_STAR_DRAWING_ENHANCEDCUSTOMSHAPESEGMENTCOMMAND_HPP_
-#include <drafts/com/sun/star/drawing/EnhancedCustomShapeSegmentCommand.hpp>
+#ifndef _COM_SUN_STAR_DRAWING_ENHANCEDCUSTOMSHAPESEGMENTCOMMAND_HPP_
+#include <com/sun/star/drawing/EnhancedCustomShapeSegmentCommand.hpp>
 #endif
-#ifndef _DRAFTS_COM_SUN_STAR_DRAWING_ENHANCEDCUSTOMSHAPETEXTFRAME_HPP_
-#include <drafts/com/sun/star/drawing/EnhancedCustomShapeTextFrame.hpp>
+#ifndef _COM_SUN_STAR_DRAWING_ENHANCEDCUSTOMSHAPETEXTFRAME_HPP_
+#include <com/sun/star/drawing/EnhancedCustomShapeTextFrame.hpp>
 #endif
-#ifndef _DRAFTS_COM_SUN_STAR_DRAWING_ENHANCEDCUSTOMSHAPEADJUSTMENTVALUE_HPP_
-#include <drafts/com/sun/star/drawing/EnhancedCustomShapeAdjustmentValue.hpp>
+#ifndef _COM_SUN_STAR_DRAWING_ENHANCEDCUSTOMSHAPEADJUSTMENTVALUE_HPP_
+#include <com/sun/star/drawing/EnhancedCustomShapeAdjustmentValue.hpp>
 #endif
-#ifndef _DRAFTS_COM_SUN_STAR_DRAWING_ENHANCEDCUSTOMSHAPETEXTPATHMODE_HPP_
-#include <drafts/com/sun/star/drawing/EnhancedCustomShapeTextPathMode.hpp>
+#ifndef _COM_SUN_STAR_DRAWING_ENHANCEDCUSTOMSHAPETEXTPATHMODE_HPP_
+#include <com/sun/star/drawing/EnhancedCustomShapeTextPathMode.hpp>
 #endif
 #ifndef __com_sun_star_beans_PropertyValues_hpp__
 #include <com/sun/star/beans/PropertyValues.hpp>
@@ -414,7 +414,7 @@
 #endif
 
 using namespace ::com::sun::star    ;
-using namespace ::drafts::com::sun::star::drawing;
+using namespace ::com::sun::star::drawing;
 using namespace uno		            ;
 using namespace beans		        ;
 using namespace drawing	            ;
@@ -1390,7 +1390,7 @@
 									const rtl::OUString	sCoordinates( RTL_CONSTASCII_USTRINGPARAM ( "Coordinates" ) );
 
 									sal_uInt32 i, nPt = nC;
-									com::sun::star::uno::Sequence< drafts::com::sun::star::drawing::EnhancedCustomShapeSegment > aSegments;
+									com::sun::star::uno::Sequence< com::sun::star::drawing::EnhancedCustomShapeSegment > aSegments;
 									pAny = aGeometryItem.GetPropertyValueByName( sPath, sSegments );
 									if ( pAny )
 									{
@@ -1450,17 +1450,17 @@
 									pAny = aGeometryItem.GetPropertyValueByName( sPath, sCoordinates );
 									if ( pAny )
 									{
-										com::sun::star::uno::Sequence< drafts::com::sun::star::drawing::EnhancedCustomShapeParameterPair > aCoordinates;
+										com::sun::star::uno::Sequence< com::sun::star::drawing::EnhancedCustomShapeParameterPair > aCoordinates;
 										*pAny >>= aCoordinates;
 										if ( nPt < (sal_uInt32)aCoordinates.getLength() )
 										{
 											nId = 4;
-											drafts::com::sun::star::drawing::EnhancedCustomShapeParameterPair& rPara = aCoordinates[ nPt ];
+											com::sun::star::drawing::EnhancedCustomShapeParameterPair& rPara = aCoordinates[ nPt ];
 											sal_Int32 nX, nY;
 											if ( ( rPara.First.Value >>= nX ) && ( rPara.Second.Value >>= nY ) )
 											{
 												const rtl::OUString	sGluePoints( RTL_CONSTASCII_USTRINGPARAM ( "GluePoints" ) );
-												com::sun::star::uno::Sequence< drafts::com::sun::star::drawing::EnhancedCustomShapeParameterPair > aGluePoints;
+												com::sun::star::uno::Sequence< com::sun::star::drawing::EnhancedCustomShapeParameterPair > aGluePoints;
 												pAny = aGeometryItem.GetPropertyValueByName( sPath, sGluePoints );
 												if ( pAny )
 													*pAny >>= aGluePoints;
@@ -2776,7 +2776,7 @@
 		// Path/Coordinates
 		if ( IsProperty( DFF_Prop_pVertices ) )
 		{
-			com::sun::star::uno::Sequence< drafts::com::sun::star::drawing::EnhancedCustomShapeParameterPair > aCoordinates;
+			com::sun::star::uno::Sequence< com::sun::star::drawing::EnhancedCustomShapeParameterPair > aCoordinates;
 
 			sal_uInt16 i;
 			sal_uInt16 nNumElemVert = 0;
@@ -2817,7 +2817,7 @@
 		// Path/Segments
 		if ( IsProperty( DFF_Prop_pSegmentInfo ) )
 		{
-			com::sun::star::uno::Sequence< drafts::com::sun::star::drawing::EnhancedCustomShapeSegment > aSegments;
+			com::sun::star::uno::Sequence< com::sun::star::drawing::EnhancedCustomShapeSegment > aSegments;
 
 			sal_uInt16 i, nTmp;
 			sal_uInt16 nNumElemSeg = 0;
@@ -2954,7 +2954,7 @@
 			if ( nElemSize == 16 )
 			{
 				sal_Int32 nLeft, nTop, nRight, nBottom;
-				com::sun::star::uno::Sequence< drafts::com::sun::star::drawing::EnhancedCustomShapeTextFrame > aTextFrames( nNumElem );
+				com::sun::star::uno::Sequence< com::sun::star::drawing::EnhancedCustomShapeTextFrame > aTextFrames( nNumElem );
 				for ( i = 0; i < nNumElem; i++ )
 				{
 					rIn >> nLeft
@@ -2976,7 +2976,7 @@
 		//Path/GluePoints
 		if ( IsProperty( DFF_Prop_connectorPoints ) )
 		{
-			com::sun::star::uno::Sequence< drafts::com::sun::star::drawing::EnhancedCustomShapeParameterPair > aGluePoints;
+			com::sun::star::uno::Sequence< com::sun::star::drawing::EnhancedCustomShapeParameterPair > aGluePoints;
 
 			sal_uInt16 i;
 			sal_uInt16 nNumElemVert = 0;
@@ -3098,7 +3098,7 @@
 	sal_Int32 nAdjustmentValues = ( i - DFF_Prop_adjustValue ) + 1;
 	if ( nAdjustmentValues )
 	{
-		uno::Sequence< drafts::com::sun::star::drawing::EnhancedCustomShapeAdjustmentValue > aAdjustmentSeq( nAdjustmentValues );
+		uno::Sequence< com::sun::star::drawing::EnhancedCustomShapeAdjustmentValue > aAdjustmentSeq( nAdjustmentValues );
 		while( --nAdjustmentValues >= 0 )
 		{
 			sal_Int32 nValue = 0;
diff -u -r  svx/source/svdraw/svdoashp.cxx  svx/source/svdraw/svdoashp.cxx
---  svx/source/svdraw/svdoashp.cxx	2005-01-28 22:39:06.000000000 +0530
+++  svx/source/svdraw/svdoashp.cxx	2005-02-28 13:40:49.574757558 +0530
@@ -92,8 +92,8 @@
 #ifndef _COM_SUN_STAR_DRAWING_XSHAPE_HPP_
 #include <com/sun/star/drawing/XShape.hpp>
 #endif
-#ifndef _DRAFTS_COM_SUN_STAR_DRAWING_XCUSTOMSHAPEENGINE_HPP_
-#include <drafts/com/sun/star/drawing/XCustomShapeEngine.hpp>
+#ifndef _COM_SUN_STAR_DRAWING_XCUSTOMSHAPEENGINE_HPP_
+#include <com/sun/star/drawing/XCustomShapeEngine.hpp>
 #endif
 #ifndef _COM_SUN_STAR_DRAWING_POLYPOLYGONBEZIERCOORDS_HPP_
 #include <com/sun/star/drawing/PolyPolygonBezierCoords.hpp>
@@ -153,23 +153,23 @@
 #ifndef _ENHANCEDCUSTOMSHAPE2D_HXX
 #include "../customshapes/EnhancedCustomShape2d.hxx"
 #endif
-#ifndef _com_sun_star_beans_PropertyValues_hpp__
+#ifndef _COM_SUN_STAR_BEANS_PROPERTYVALUES_HPP__
 #include <com/sun/star/beans/PropertyValues.hpp>
 #endif
-#ifndef _DRAFTS_COM_SUN_STAR_DRAWING_ENHANCEDCUSTOMSHAPEADJUSTMENTVALUE_HPP_
-#include <drafts/com/sun/star/drawing/EnhancedCustomShapeAdjustmentValue.hpp>
+#ifndef _COM_SUN_STAR_DRAWING_ENHANCEDCUSTOMSHAPEADJUSTMENTVALUE_HPP_
+#include <com/sun/star/drawing/EnhancedCustomShapeAdjustmentValue.hpp>
 #endif
-#ifndef __drafts_com_sun_star_drawing_EnhancedCustomShapeParameterPair_hpp__
-#include <drafts/com/sun/star/drawing/EnhancedCustomShapeParameterPair.hpp>
+#ifndef __COM_SUN_STAR_DRAWING_ENHANCEDCUSTOMSHAPEPARAMETERPAIR_HPP__
+#include <com/sun/star/drawing/EnhancedCustomShapeParameterPair.hpp>
 #endif
-#ifndef __drafts_com_sun_star_drawing_EnhancedCustomShapeTextFrame_hpp__
-#include <drafts/com/sun/star/drawing/EnhancedCustomShapeTextFrame.hpp>
+#ifndef __COM_SUN_STAR_DRAWING_ENHANCEDCUSTOMSHAPETEXTFRAME_HPP__
+#include <com/sun/star/drawing/EnhancedCustomShapeTextFrame.hpp>
 #endif
-#ifndef _DRAFTS_COM_SUN_STAR_DRAWING_ENHANCEDCUSTOMSHAPESEGMENT_HPP_
-#include <drafts/com/sun/star/drawing/EnhancedCustomShapeSegment.hpp>
+#ifndef _COM_SUN_STAR_DRAWING_ENHANCEDCUSTOMSHAPESEGMENT_HPP_
+#include <com/sun/star/drawing/EnhancedCustomShapeSegment.hpp>
 #endif
-#ifndef __drafts_com_sun_star_drawing_EnhancedCustomShapeSegmentCommand_hpp__
-#include <drafts/com/sun/star/drawing/EnhancedCustomShapeSegmentCommand.hpp>
+#ifndef __COM_SUN_STAR_DRAWING_ENHANCEDCUSTOMSHAPESEGMENTCOMMAND_HPP__
+#include <com/sun/star/drawing/EnhancedCustomShapeSegmentCommand.hpp>
 #endif
 #ifndef _SVX_WRITINGMODEITEM_HXX
 #include <writingmodeitem.hxx>
@@ -259,7 +259,7 @@
 using namespace ::com::sun::star::util;
 using namespace ::com::sun::star::beans;
 using namespace ::com::sun::star::drawing;
-using namespace ::drafts::com::sun::star::drawing;
+using namespace ::com::sun::star::drawing;
 
 ////////////////////////////////////////////////////////////////////////////////////////////////////
 // #i37011# create a clone with all attributes changed to shadow attributes
@@ -433,7 +433,7 @@
 						aDestBitmap.ReleaseAccess(pWriteAccess);
 						aFillBitmap.SetBitmap(aDestBitmap);
 					}
-					
+
 					aSourceBitmap.ReleaseAccess(pReadAccess);
 				}
 			}
@@ -650,9 +650,9 @@
 	}
 	return bRet;
 }
-Sequence< Reference< drafts::com::sun::star::drawing::XCustomShapeHandle > > SdrObjCustomShape::GetInteraction( const SdrObjCustomShape* pCustomShape ) const
+Sequence< Reference< com::sun::star::drawing::XCustomShapeHandle > > SdrObjCustomShape::GetInteraction( const SdrObjCustomShape* pCustomShape ) const
 {
-	Sequence< Reference< drafts::com::sun::star::drawing::XCustomShapeHandle > > xInteraction;
+	Sequence< Reference< com::sun::star::drawing::XCustomShapeHandle > > xInteraction;
 	Reference< XCustomShapeEngine > xCustomShapeEngine( GetCustomShapeEngine( pCustomShape ) );
 	if ( xCustomShapeEngine.is() )
 		xInteraction = xCustomShapeEngine->getInteraction();
@@ -705,10 +705,10 @@
 
 	const sal_Int32* pDefData = NULL;
 	const mso_CustomShape* pDefCustomShape = GetCustomShapeContent( eSpType );
-	if ( pDefCustomShape )	
+	if ( pDefCustomShape )
 		pDefData = pDefCustomShape->pDefData;
 
-	com::sun::star::uno::Sequence< drafts::com::sun::star::drawing::EnhancedCustomShapeAdjustmentValue >	seqAdjustmentValues;
+	com::sun::star::uno::Sequence< com::sun::star::drawing::EnhancedCustomShapeAdjustmentValue >	seqAdjustmentValues;
 
 	//////////////////////
 	// AdjustmentValues //
@@ -742,7 +742,7 @@
 	aPropVal.Name = sAdjustmentValues;
 	aPropVal.Value <<= seqAdjustmentValues;
 	aGeometryItem.SetPropertyValue( aPropVal );
-	
+
 	///////////////
 	// Coordsize //
 	///////////////
@@ -772,7 +772,7 @@
 	pAny = ((SdrCustomShapeGeometryItem&)aGeometryItem).GetPropertyValueByName( sPath, sCoordinates );
 	if ( !pAny && pDefCustomShape && pDefCustomShape->nVertices && pDefCustomShape->pVertices )
 	{
-		com::sun::star::uno::Sequence< drafts::com::sun::star::drawing::EnhancedCustomShapeParameterPair> seqCoordinates;
+		com::sun::star::uno::Sequence< com::sun::star::drawing::EnhancedCustomShapeParameterPair> seqCoordinates;
 
 		sal_Int32 i, nCount = pDefCustomShape->nVertices;
 		seqCoordinates.realloc( nCount );
@@ -793,7 +793,7 @@
 	pAny = ((SdrCustomShapeGeometryItem&)aGeometryItem).GetPropertyValueByName( sPath, sGluePoints );
 	if ( !pAny && pDefCustomShape && pDefCustomShape->nGluePoints && pDefCustomShape->pGluePoints )
 	{
-		com::sun::star::uno::Sequence< drafts::com::sun::star::drawing::EnhancedCustomShapeParameterPair> seqGluePoints;
+		com::sun::star::uno::Sequence< com::sun::star::drawing::EnhancedCustomShapeParameterPair> seqGluePoints;
 		sal_Int32 i, nCount = pDefCustomShape->nGluePoints;
 		seqGluePoints.realloc( nCount );
 		for ( i = 0; i < nCount; i++ )
@@ -813,7 +813,7 @@
 	pAny = ((SdrCustomShapeGeometryItem&)aGeometryItem).GetPropertyValueByName( sPath, sSegments );
 	if ( !pAny && pDefCustomShape && pDefCustomShape->nElements && pDefCustomShape->pElements )
 	{
-		com::sun::star::uno::Sequence< drafts::com::sun::star::drawing::EnhancedCustomShapeSegment > seqSegments;
+		com::sun::star::uno::Sequence< com::sun::star::drawing::EnhancedCustomShapeSegment > seqSegments;
 
 		sal_Int32 i, nCount = pDefCustomShape->nElements;
 		seqSegments.realloc( nCount );
@@ -942,7 +942,7 @@
 	{
 		sal_Int32 nXRef = pDefCustomShape->nXRef;
 		if ( ( nXRef != (sal_Int32)0x80000000 ) )
-		{	
+		{
 			aPropVal.Name = sStretchX;
 			aPropVal.Value <<= nXRef;
 			aGeometryItem.SetPropertyValue( sPath, aPropVal );
@@ -958,7 +958,7 @@
 	{
 		sal_Int32 nYRef = pDefCustomShape->nYRef;
 		if ( ( nYRef != (sal_Int32)0x80000000 ) )
-		{	
+		{
 			aPropVal.Name = sStretchY;
 			aPropVal.Value <<= nYRef;
 			aGeometryItem.SetPropertyValue( sPath, aPropVal );
@@ -972,7 +972,7 @@
 	pAny = ((SdrCustomShapeGeometryItem&)aGeometryItem).GetPropertyValueByName( sPath, sTextFrames );
 	if ( !pAny && pDefCustomShape && pDefCustomShape->nTextRect && pDefCustomShape->pTextRect )
 	{
-		com::sun::star::uno::Sequence< drafts::com::sun::star::drawing::EnhancedCustomShapeTextFrame > seqTextFrames;
+		com::sun::star::uno::Sequence< com::sun::star::drawing::EnhancedCustomShapeTextFrame > seqTextFrames;
 
 		sal_Int32 i, nCount = pDefCustomShape->nTextRect;
 		seqTextFrames.realloc( nCount );
@@ -1056,11 +1056,11 @@
 			n = 0;
 			com::sun::star::beans::PropertyValues& rPropValues = seqHandles[ i ];
 			rPropValues.realloc( nPropertiesNeeded );
-			
+
 			// POSITION
 			{
 				const rtl::OUString	sPosition( RTL_CONSTASCII_USTRINGPARAM ( "Position" ) );
-				::drafts::com::sun::star::drawing::EnhancedCustomShapeParameterPair aPosition;
+				::com::sun::star::drawing::EnhancedCustomShapeParameterPair aPosition;
 				EnhancedCustomShape2d::SetEnhancedCustomShapeHandleParameter( aPosition.First, pData->nPositionX, sal_True, sal_True );
 				EnhancedCustomShape2d::SetEnhancedCustomShapeHandleParameter( aPosition.Second, pData->nPositionY, sal_True, sal_False );
 				rPropValues[ n ].Name = sPosition;
@@ -1090,7 +1090,7 @@
 			if ( nFlags & MSDFF_HANDLE_FLAGS_POLAR )
 			{
 				const rtl::OUString	sPolar( RTL_CONSTASCII_USTRINGPARAM ( "Polar" ) );
-				::drafts::com::sun::star::drawing::EnhancedCustomShapeParameterPair aCenter;
+				::com::sun::star::drawing::EnhancedCustomShapeParameterPair aCenter;
 				EnhancedCustomShape2d::SetEnhancedCustomShapeHandleParameter( aCenter.First,  pData->nCenterX,
 					( nFlags & MSDFF_HANDLE_FLAGS_CENTER_X_IS_SPECIAL ) != 0, sal_True  );
 				EnhancedCustomShape2d::SetEnhancedCustomShapeHandleParameter( aCenter.Second, pData->nCenterY,
@@ -1102,7 +1102,7 @@
 					if ( pData->nRangeXMin != 0x80000000 )
 					{
 						const rtl::OUString	sRadiusRangeMinimum( RTL_CONSTASCII_USTRINGPARAM ( "RadiusRangeMinimum" ) );
-						::drafts::com::sun::star::drawing::EnhancedCustomShapeParameter aRadiusRangeMinimum;
+						::com::sun::star::drawing::EnhancedCustomShapeParameter aRadiusRangeMinimum;
 						EnhancedCustomShape2d::SetEnhancedCustomShapeHandleParameter( aRadiusRangeMinimum, pData->nRangeXMin,
 							( nFlags & MSDFF_HANDLE_FLAGS_RANGE_X_MIN_IS_SPECIAL ) != 0, sal_True  );
 						rPropValues[ n ].Name = sRadiusRangeMinimum;
@@ -1111,7 +1111,7 @@
 					if ( pData->nRangeXMax != 0x7fffffff )
 					{
 						const rtl::OUString	sRadiusRangeMaximum( RTL_CONSTASCII_USTRINGPARAM ( "RadiusRangeMaximum" ) );
-						::drafts::com::sun::star::drawing::EnhancedCustomShapeParameter aRadiusRangeMaximum;
+						::com::sun::star::drawing::EnhancedCustomShapeParameter aRadiusRangeMaximum;
 						EnhancedCustomShape2d::SetEnhancedCustomShapeHandleParameter( aRadiusRangeMaximum, pData->nRangeXMax,
 							( nFlags & MSDFF_HANDLE_FLAGS_RANGE_X_MAX_IS_SPECIAL ) != 0, sal_False );
 						rPropValues[ n ].Name = sRadiusRangeMaximum;
@@ -1124,7 +1124,7 @@
 				if ( pData->nRangeXMin != 0x80000000 )
 				{
 					const rtl::OUString	sRangeXMinimum( RTL_CONSTASCII_USTRINGPARAM ( "RangeXMinimum" ) );
-					::drafts::com::sun::star::drawing::EnhancedCustomShapeParameter aRangeXMinimum;
+					::com::sun::star::drawing::EnhancedCustomShapeParameter aRangeXMinimum;
 					EnhancedCustomShape2d::SetEnhancedCustomShapeHandleParameter( aRangeXMinimum, pData->nRangeXMin,
 						( nFlags & MSDFF_HANDLE_FLAGS_RANGE_X_MIN_IS_SPECIAL ) != 0, sal_True  );
 					rPropValues[ n ].Name = sRangeXMinimum;
@@ -1133,7 +1133,7 @@
 				if ( pData->nRangeXMax != 0x7fffffff )
 				{
 					const rtl::OUString	sRangeXMaximum( RTL_CONSTASCII_USTRINGPARAM ( "RangeXMaximum" ) );
-					::drafts::com::sun::star::drawing::EnhancedCustomShapeParameter aRangeXMaximum;
+					::com::sun::star::drawing::EnhancedCustomShapeParameter aRangeXMaximum;
 					EnhancedCustomShape2d::SetEnhancedCustomShapeHandleParameter( aRangeXMaximum, pData->nRangeXMax,
 						( nFlags & MSDFF_HANDLE_FLAGS_RANGE_X_MAX_IS_SPECIAL ) != 0, sal_False );
 					rPropValues[ n ].Name = sRangeXMaximum;
@@ -1142,7 +1142,7 @@
 				if ( pData->nRangeYMin != 0x80000000 )
 				{
 					const rtl::OUString	sRangeYMinimum( RTL_CONSTASCII_USTRINGPARAM ( "RangeYMinimum" ) );
-					::drafts::com::sun::star::drawing::EnhancedCustomShapeParameter aRangeYMinimum;
+					::com::sun::star::drawing::EnhancedCustomShapeParameter aRangeYMinimum;
 					EnhancedCustomShape2d::SetEnhancedCustomShapeHandleParameter( aRangeYMinimum, pData->nRangeYMin,
 						( nFlags & MSDFF_HANDLE_FLAGS_RANGE_Y_MIN_IS_SPECIAL ) != 0, sal_True );
 					rPropValues[ n ].Name = sRangeYMinimum;
@@ -1151,7 +1151,7 @@
 				if ( pData->nRangeYMax != 0x7fffffff )
 				{
 					const rtl::OUString	sRangeYMaximum( RTL_CONSTASCII_USTRINGPARAM ( "RangeYMaximum" ) );
-					::drafts::com::sun::star::drawing::EnhancedCustomShapeParameter aRangeYMaximum;
+					::com::sun::star::drawing::EnhancedCustomShapeParameter aRangeYMaximum;
 					EnhancedCustomShape2d::SetEnhancedCustomShapeHandleParameter( aRangeYMaximum, pData->nRangeYMax,
 						( nFlags & MSDFF_HANDLE_FLAGS_RANGE_Y_MAX_IS_SPECIAL ) != 0, sal_False );
 					rPropValues[ n ].Name = sRangeYMaximum;
@@ -1205,7 +1205,7 @@
 			pAny = ((SdrCustomShapeGeometryItem&)aGeometryItem).GetPropertyValueByName( sPath, sCoordinates );
 			if ( pAny && pDefCustomShape && pDefCustomShape->nVertices && pDefCustomShape->pVertices )
 			{
-				com::sun::star::uno::Sequence< drafts::com::sun::star::drawing::EnhancedCustomShapeParameterPair> seqCoordinates1, seqCoordinates2;
+				com::sun::star::uno::Sequence< com::sun::star::drawing::EnhancedCustomShapeParameterPair> seqCoordinates1, seqCoordinates2;
 				if ( *pAny >>= seqCoordinates1 )
 				{
 					sal_Int32 i, nCount = pDefCustomShape->nVertices;
@@ -1230,7 +1230,7 @@
 			pAny = ((SdrCustomShapeGeometryItem&)aGeometryItem).GetPropertyValueByName( sPath, sGluePoints );
 			if ( pAny && pDefCustomShape && pDefCustomShape->nGluePoints && pDefCustomShape->pGluePoints )
 			{
-				com::sun::star::uno::Sequence< drafts::com::sun::star::drawing::EnhancedCustomShapeParameterPair> seqGluePoints1, seqGluePoints2;
+				com::sun::star::uno::Sequence< com::sun::star::drawing::EnhancedCustomShapeParameterPair> seqGluePoints1, seqGluePoints2;
 				if ( *pAny >>= seqGluePoints1 )
 				{
 					sal_Int32 i, nCount = pDefCustomShape->nGluePoints;
@@ -1258,7 +1258,7 @@
 			pAny = ((SdrCustomShapeGeometryItem&)aGeometryItem).GetPropertyValueByName( sPath, sSegments );
 			if ( pAny )
 			{
-				com::sun::star::uno::Sequence< drafts::com::sun::star::drawing::EnhancedCustomShapeSegment > seqSegments1, seqSegments2;
+				com::sun::star::uno::Sequence< com::sun::star::drawing::EnhancedCustomShapeSegment > seqSegments1, seqSegments2;
 				if ( *pAny >>= seqSegments1 )
 				{
 					if ( pDefCustomShape && pDefCustomShape->nElements && pDefCustomShape->pElements )
@@ -1468,7 +1468,7 @@
 			pAny = ((SdrCustomShapeGeometryItem&)aGeometryItem).GetPropertyValueByName( sPath, sTextFrames );
 			if ( pAny && pDefCustomShape && pDefCustomShape->nTextRect && pDefCustomShape->pTextRect )
 			{
-				com::sun::star::uno::Sequence< drafts::com::sun::star::drawing::EnhancedCustomShapeTextFrame > seqTextFrames1, seqTextFrames2;
+				com::sun::star::uno::Sequence< com::sun::star::drawing::EnhancedCustomShapeTextFrame > seqTextFrames1, seqTextFrames2;
 				if ( *pAny >>= seqTextFrames1 )
 				{
 					sal_Int32 i, nCount = pDefCustomShape->nTextRect;
@@ -1538,11 +1538,11 @@
 						n = 0;
 						com::sun::star::beans::PropertyValues& rPropValues = seqHandles2[ i ];
 						rPropValues.realloc( nPropertiesNeeded );
-						
+
 						// POSITION
 						{
 							const rtl::OUString	sPosition( RTL_CONSTASCII_USTRINGPARAM ( "Position" ) );
-							::drafts::com::sun::star::drawing::EnhancedCustomShapeParameterPair aPosition;
+							::com::sun::star::drawing::EnhancedCustomShapeParameterPair aPosition;
 							EnhancedCustomShape2d::SetEnhancedCustomShapeHandleParameter( aPosition.First, pData->nPositionX, sal_True, sal_True );
 							EnhancedCustomShape2d::SetEnhancedCustomShapeHandleParameter( aPosition.Second, pData->nPositionY, sal_True, sal_False );
 							rPropValues[ n ].Name = sPosition;
@@ -1572,7 +1572,7 @@
 						if ( nFlags & MSDFF_HANDLE_FLAGS_POLAR )
 						{
 							const rtl::OUString	sPolar( RTL_CONSTASCII_USTRINGPARAM ( "Polar" ) );
-							::drafts::com::sun::star::drawing::EnhancedCustomShapeParameterPair aCenter;
+							::com::sun::star::drawing::EnhancedCustomShapeParameterPair aCenter;
 							EnhancedCustomShape2d::SetEnhancedCustomShapeHandleParameter( aCenter.First,  pData->nCenterX,
 								( nFlags & MSDFF_HANDLE_FLAGS_CENTER_X_IS_SPECIAL ) != 0, sal_True  );
 							EnhancedCustomShape2d::SetEnhancedCustomShapeHandleParameter( aCenter.Second, pData->nCenterY,
@@ -1584,7 +1584,7 @@
 								if ( pData->nRangeXMin != 0x80000000 )
 								{
 									const rtl::OUString	sRadiusRangeMinimum( RTL_CONSTASCII_USTRINGPARAM ( "RadiusRangeMinimum" ) );
-									::drafts::com::sun::star::drawing::EnhancedCustomShapeParameter aRadiusRangeMinimum;
+									::com::sun::star::drawing::EnhancedCustomShapeParameter aRadiusRangeMinimum;
 									EnhancedCustomShape2d::SetEnhancedCustomShapeHandleParameter( aRadiusRangeMinimum, pData->nRangeXMin,
 										( nFlags & MSDFF_HANDLE_FLAGS_RANGE_X_MIN_IS_SPECIAL ) != 0, sal_True  );
 									rPropValues[ n ].Name = sRadiusRangeMinimum;
@@ -1593,7 +1593,7 @@
 								if ( pData->nRangeXMax != 0x7fffffff )
 								{
 									const rtl::OUString	sRadiusRangeMaximum( RTL_CONSTASCII_USTRINGPARAM ( "RadiusRangeMaximum" ) );
-									::drafts::com::sun::star::drawing::EnhancedCustomShapeParameter aRadiusRangeMaximum;
+									::com::sun::star::drawing::EnhancedCustomShapeParameter aRadiusRangeMaximum;
 									EnhancedCustomShape2d::SetEnhancedCustomShapeHandleParameter( aRadiusRangeMaximum, pData->nRangeXMax,
 										( nFlags & MSDFF_HANDLE_FLAGS_RANGE_X_MAX_IS_SPECIAL ) != 0, sal_False );
 									rPropValues[ n ].Name = sRadiusRangeMaximum;
@@ -1606,7 +1606,7 @@
 							if ( pData->nRangeXMin != 0x80000000 )
 							{
 								const rtl::OUString	sRangeXMinimum( RTL_CONSTASCII_USTRINGPARAM ( "RangeXMinimum" ) );
-								::drafts::com::sun::star::drawing::EnhancedCustomShapeParameter aRangeXMinimum;
+								::com::sun::star::drawing::EnhancedCustomShapeParameter aRangeXMinimum;
 								EnhancedCustomShape2d::SetEnhancedCustomShapeHandleParameter( aRangeXMinimum, pData->nRangeXMin,
 									( nFlags & MSDFF_HANDLE_FLAGS_RANGE_X_MIN_IS_SPECIAL ) != 0, sal_True  );
 								rPropValues[ n ].Name = sRangeXMinimum;
@@ -1615,7 +1615,7 @@
 							if ( pData->nRangeXMax != 0x7fffffff )
 							{
 								const rtl::OUString	sRangeXMaximum( RTL_CONSTASCII_USTRINGPARAM ( "RangeXMaximum" ) );
-								::drafts::com::sun::star::drawing::EnhancedCustomShapeParameter aRangeXMaximum;
+								::com::sun::star::drawing::EnhancedCustomShapeParameter aRangeXMaximum;
 								EnhancedCustomShape2d::SetEnhancedCustomShapeHandleParameter( aRangeXMaximum, pData->nRangeXMax,
 									( nFlags & MSDFF_HANDLE_FLAGS_RANGE_X_MAX_IS_SPECIAL ) != 0, sal_False );
 								rPropValues[ n ].Name = sRangeXMaximum;
@@ -1624,7 +1624,7 @@
 							if ( pData->nRangeYMin != 0x80000000 )
 							{
 								const rtl::OUString	sRangeYMinimum( RTL_CONSTASCII_USTRINGPARAM ( "RangeYMinimum" ) );
-								::drafts::com::sun::star::drawing::EnhancedCustomShapeParameter aRangeYMinimum;
+								::com::sun::star::drawing::EnhancedCustomShapeParameter aRangeYMinimum;
 								EnhancedCustomShape2d::SetEnhancedCustomShapeHandleParameter( aRangeYMinimum, pData->nRangeYMin,
 									( nFlags & MSDFF_HANDLE_FLAGS_RANGE_Y_MIN_IS_SPECIAL ) != 0, sal_True );
 								rPropValues[ n ].Name = sRangeYMinimum;
@@ -1633,7 +1633,7 @@
 							if ( pData->nRangeYMax != 0x7fffffff )
 							{
 								const rtl::OUString	sRangeYMaximum( RTL_CONSTASCII_USTRINGPARAM ( "RangeYMaximum" ) );
-								::drafts::com::sun::star::drawing::EnhancedCustomShapeParameter aRangeYMaximum;
+								::com::sun::star::drawing::EnhancedCustomShapeParameter aRangeYMaximum;
 								EnhancedCustomShape2d::SetEnhancedCustomShapeHandleParameter( aRangeYMaximum, pData->nRangeYMax,
 									( nFlags & MSDFF_HANDLE_FLAGS_RANGE_Y_MAX_IS_SPECIAL ) != 0, sal_False );
 								rPropValues[ n ].Name = sRangeYMaximum;
@@ -2091,7 +2091,7 @@
 USHORT SdrObjCustomShape::GetHdlCount() const
 {
 	USHORT nBasicHdlCount = SdrTextObj::GetHdlCount();
-	Sequence< Reference< drafts::com::sun::star::drawing::XCustomShapeHandle > >
+	Sequence< Reference< com::sun::star::drawing::XCustomShapeHandle > >
 		sCustomShapeHandles = GetInteraction( this );
 	return (USHORT)( sCustomShapeHandles.getLength() + nBasicHdlCount );
 }
@@ -2105,12 +2105,12 @@
 		pH = SdrTextObj::GetHdl( nHdlNum );
 	else
 	{
-		Sequence< Reference< drafts::com::sun::star::drawing::XCustomShapeHandle > >
+		Sequence< Reference< com::sun::star::drawing::XCustomShapeHandle > >
 			sCustomShapeHandles = GetInteraction( this );
 		USHORT nCustomShapeHdlNum = nHdlNum - nBasicHdlCount;
 		if ( nCustomShapeHdlNum < sCustomShapeHandles.getLength() )
 		{
-			Reference< drafts::com::sun::star::drawing::XCustomShapeHandle > xHdl
+			Reference< com::sun::star::drawing::XCustomShapeHandle > xHdl
 				= sCustomShapeHandles[ nCustomShapeHdlNum ];
 			if ( xHdl.is() )
 			{
@@ -2158,12 +2158,12 @@
 	const SdrHdl* pHdl = rDrag.GetHdl();
 	if ( pHdl && ( pHdl->GetKind() == HDL_CUSTOMSHAPE1 ) )
 	{
-		Sequence< Reference< drafts::com::sun::star::drawing::XCustomShapeHandle > >
+		Sequence< Reference< com::sun::star::drawing::XCustomShapeHandle > >
 			sCustomShapeHandles = GetInteraction( (SdrObjCustomShape*)rDrag.GetUser() );
 		USHORT nCustomShapeHdlNum = pHdl->GetPointNum();
 		if ( nCustomShapeHdlNum < sCustomShapeHandles.getLength() )
 		{
-			Reference< drafts::com::sun::star::drawing::XCustomShapeHandle > xHdl
+			Reference< com::sun::star::drawing::XCustomShapeHandle > xHdl
 				= sCustomShapeHandles[ nCustomShapeHdlNum ];
 			if ( xHdl.is() )
 			{
@@ -2198,12 +2198,12 @@
 	//	SendRepaintBroadcast();
 
 		Point aPt( rDrag.GetNow() );
-		Sequence< Reference< drafts::com::sun::star::drawing::XCustomShapeHandle > >
+		Sequence< Reference< com::sun::star::drawing::XCustomShapeHandle > >
 			sCustomShapeHandles = GetInteraction( this );
 		USHORT nCustomShapeHdlNum = pHdl->GetPointNum();
 		if ( nCustomShapeHdlNum < sCustomShapeHandles.getLength() )
 		{
-			Reference< drafts::com::sun::star::drawing::XCustomShapeHandle > xHdl
+			Reference< com::sun::star::drawing::XCustomShapeHandle > xHdl
 				= sCustomShapeHandles[ nCustomShapeHdlNum ];
 			if ( xHdl.is() )
 			{
@@ -2927,7 +2927,7 @@
 	// #i37011#
 	SdrObject* pRetval = 0L;
 	SdrObject* pRenderedCustomShape = 0L;
-	
+
 	if ( !mXRenderedCustomShape.is() )
 	{
 		// force CustomShape
diff -u -r  svx/source/toolbars/extrusionbar.cxx  svx/source/toolbars/extrusionbar.cxx
---  svx/source/toolbars/extrusionbar.cxx	2005-02-04 19:51:52.000000000 +0530
+++  svx/source/toolbars/extrusionbar.cxx	2005-02-28 13:40:51.123576572 +0530
@@ -60,10 +60,10 @@
  ************************************************************************/
 
 #ifndef _DRAFTS_COM_SUN_STAR_DRAWING_ENHANCEDCUSTOMSHAPEPARAMETERPARIR_HPP_
-#include <drafts/com/sun/star/drawing/EnhancedCustomShapeParameterPair.hpp>
+#include <com/sun/star/drawing/EnhancedCustomShapeParameterPair.hpp>
 #endif
-#ifndef _DRAFTS_COM_SUN_STAR_DRAWING_ENHANCEDCUSTOMSHAPEPARAMETERTYPE_HPP_
-#include <drafts/com/sun/star/drawing/EnhancedCustomShapeParameterType.hpp>
+#ifndef _COM_SUN_STAR_DRAWING_ENHANCEDCUSTOMSHAPEPARAMETERTYPE_HPP_
+#include <com/sun/star/drawing/EnhancedCustomShapeParameterType.hpp>
 #endif
 #ifndef _COM_SUN_STAR_DRAWING_SHADEMODE_HPP_
 #include <com/sun/star/drawing/ShadeMode.hpp>
@@ -126,7 +126,7 @@
 using namespace ::com::sun::star::beans;
 using namespace ::com::sun::star::drawing;
 using namespace ::com::sun::star::uno;
-using namespace ::drafts::com::sun::star::drawing;
+using namespace ::com::sun::star::drawing;
 
 /*************************************************************************
 |*
diff -u -r  svx/source/toolbars/fontworkbar.cxx  svx/source/toolbars/fontworkbar.cxx
---  svx/source/toolbars/fontworkbar.cxx	2005-02-04 19:52:05.000000000 +0530
+++  svx/source/toolbars/fontworkbar.cxx	2005-02-28 13:40:51.071582647 +0530
@@ -92,8 +92,8 @@
 #ifndef _SVDOASHP_HXX
 #include <svdoashp.hxx>
 #endif
-#ifndef _DRAFTS_COM_SUN_STAR_DRAWING_ENHANCEDCUSTOMSHAPEADJUSTMENTVALUE_HPP_
-#include <drafts/com/sun/star/drawing/EnhancedCustomShapeAdjustmentValue.hpp>
+#ifndef _COM_SUN_STAR_DRAWING_ENHANCEDCUSTOMSHAPEADJUSTMENTVALUE_HPP_
+#include <com/sun/star/drawing/EnhancedCustomShapeAdjustmentValue.hpp>
 #endif
 #ifndef _SFX_BINDINGS_HXX
 #include <sfx2/bindings.hxx>
diff -u -r  svx/source/unodraw/UnoGraphicExporter.cxx  svx/source/unodraw/UnoGraphicExporter.cxx
---  svx/source/unodraw/UnoGraphicExporter.cxx	2004-11-26 23:45:04.000000000 +0530
+++  svx/source/unodraw/UnoGraphicExporter.cxx	2005-02-28 13:40:49.287791092 +0530
@@ -105,6 +105,13 @@
 #include <com/sun/star/drawing/XDrawPage.hpp>
 #endif
 
+#ifndef _COM_SUN_STAR_GRAPHIC_XGRAPHIC_HPP_ 
+#include <com/sun/star/graphic/XGraphic.hpp>
+#endif
+#ifndef _COM_SUN_STAR_GRAPHIC_XGRAPHICRENDERER_HPP_ 
+#include <com/sun/star/graphic/XGraphicRenderer.hpp>
+#endif
+
 #ifndef _COM_SUN_STAR_UTIL_URL_HPP_
 #include <com/sun/star/util/URL.hpp>
 #endif
@@ -578,7 +585,8 @@
 	OUString aFilterName, aMediaType;
 	URL aURL;
 
-	com::sun::star::uno::Reference< com::sun::star::io::XOutputStream > xOutputStream;
+	com::sun::star::uno::Reference< com::sun::star::io::XOutputStream > 		xOutputStream;
+    com::sun::star::uno::Reference< com::sun::star::graphic::XGraphicRenderer > xGraphicRenderer;
 	{
 		sal_Int32 nArgs = aDescriptor.getLength();
 		const PropertyValue* pValues = aDescriptor.getConstArray();
@@ -603,6 +611,10 @@
 			{
 				pValues->Value >>= xOutputStream;
 			}
+			else if( pValues->Name.equalsAsciiL( RTL_CONSTASCII_STRINGPARAM( "GraphicRenderer" ) ) )
+			{
+				pValues->Value >>= xGraphicRenderer;
+			}
 			else if( pValues->Name.equalsAsciiL( RTL_CONSTASCII_STRINGPARAM( "Width" ) ) )	// for compatibility reasons, deprecated
 			{
 				pValues->Value >>= nWidth;
@@ -996,7 +1008,12 @@
 		else
 		{
 			// now we have a graphic, so export it
-			if( xOutputStream.is() )
+            if( xGraphicRenderer.is() )
+            {
+                // render graphic directly into given renderer
+                xGraphicRenderer->render( aGraphic.GetXGraphic() );
+            }
+			else if( xOutputStream.is() )
 			{
                 // TODO: Either utilize optional XSeekable functionality for the 
                 // SvOutputStream, or adapt the graphic filter to not seek anymore.
diff -u -r  vcl/inc/bitmap.hxx  vcl/inc/bitmap.hxx
---  vcl/inc/bitmap.hxx	2005-01-13 22:56:04.000000000 +0530
+++  vcl/inc/bitmap.hxx	2005-02-28 13:40:52.928365675 +0530
@@ -277,6 +277,16 @@
 class	GDIMetaFile;
 class	AlphaMask;
 
+struct BitmapSystemData
+{
+    #if defined WNT
+    void* pDIB; // device independent byte buffer
+    void* pDDB; // if not NULL then this is actually an HBITMAP
+    #else
+    void* pDummy;
+    #endif
+};
+
 class VCL_DLLPUBLIC Bitmap
 {
 private:
@@ -371,6 +381,14 @@
     inline ULONG            GetColorCount() const;
     inline ULONG            GetSizeBytes() const;
 	BOOL					HasGreyPalette() const;
+    /** get system dependent bitmap data
+    
+        @param rData
+        The system dependent BitmapSystemData structure to be filled
+        
+        @return TRUE if the bitmap has a valid system object (e.g. not empty)
+    */
+    bool                    GetSystemData( BitmapSystemData& rData ) const;
 
 	ULONG					GetChecksum() const;
 
diff -u -r  vcl/inc/bmpacc.hxx  vcl/inc/bmpacc.hxx
---  vcl/inc/bmpacc.hxx	2005-01-13 22:56:33.000000000 +0530
+++  vcl/inc/bmpacc.hxx	2005-02-28 13:40:52.948363338 +0530
@@ -148,7 +148,7 @@
 public:
 	
 SAL_DLLPRIVATE  void            ImplZeroInitUnusedBits();
-
+SAL_DLLPRIVATE  BitmapBuffer*   ImplGetBitmapBuffer() const { return mpBuffer; }
 
                                 DECL_FORMAT( _1BIT_MSB_PAL )
                                 DECL_FORMAT( _1BIT_LSB_PAL )
diff -u -r  vcl/inc/canvastools.hxx  vcl/inc/canvastools.hxx
---  vcl/inc/canvastools.hxx	2005-01-13 22:57:27.000000000 +0530
+++  vcl/inc/canvastools.hxx	2005-02-28 13:40:52.936364740 +0530
@@ -94,7 +94,7 @@
     class B2DPolyPolygon;
 }
 
-namespace drafts { namespace com { namespace sun { namespace star { namespace geometry 
+namespace com { namespace sun { namespace star { namespace geometry 
 {
     struct RealPoint2D;
     struct RealSize2D;
@@ -103,15 +103,15 @@
     struct IntegerSize2D;
     struct IntegerRectangle2D;
     struct RealBezierSegment2D;
-} } } } }
+} } } }
 
-namespace drafts { namespace com { namespace sun { namespace star { namespace rendering 
+namespace com { namespace sun { namespace star { namespace rendering 
 {
     class  XGraphicDevice;
     class  XBitmap;
     class  XIntegerBitmap;
     class  XPolyPolygon2D;
-} } } } }
+} } } }
 
 
 namespace vcl
@@ -123,41 +123,41 @@
 
         /** Create an XPolyPolygon from VCL/Tools polygon
          */
-        ::com::sun::star::uno::Reference< ::drafts::com::sun::star::rendering::XPolyPolygon2D > 
+        ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XPolyPolygon2D > 
 	    	VCL_DLLPUBLIC xPolyPolygonFromPolygon( const ::com::sun::star::uno::Reference< 
-                                     	::drafts::com::sun::star::rendering::XGraphicDevice >& 	xGraphicDevice,
+                                     	::com::sun::star::rendering::XGraphicDevice >& 	xGraphicDevice,
                                      const ::Polygon&											inputPolygon );
         
         /** Create an XPolyPolygon from VCL/Tools polyPolygon
          */
-        ::com::sun::star::uno::Reference< ::drafts::com::sun::star::rendering::XPolyPolygon2D > 
+        ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XPolyPolygon2D > 
 	    	VCL_DLLPUBLIC xPolyPolygonFromPolyPolygon( const ::com::sun::star::uno::Reference< 
-                                         	::drafts::com::sun::star::rendering::XGraphicDevice >& 	xGraphicDevice,
+                                         	::com::sun::star::rendering::XGraphicDevice >& 	xGraphicDevice,
                                          const ::PolyPolygon&										inputPolyPolygon );
         
         /** Create an VCL/Tools polygon from a point sequence
          */
         ::Polygon VCL_DLLPUBLIC polygonFromPoint2DSequence( 
             const ::com::sun::star::uno::Sequence< 
-            	::drafts::com::sun::star::geometry::RealPoint2D >& rPoints );
+            	::com::sun::star::geometry::RealPoint2D >& rPoints );
 
         /** Create an VCL/Tools polyPolygon from a point sequence sequence
          */
         ::PolyPolygon VCL_DLLPUBLIC polyPolygonFromPoint2DSequenceSequence( 
             const ::com::sun::star::uno::Sequence< 
-            	::com::sun::star::uno::Sequence< ::drafts::com::sun::star::geometry::RealPoint2D > >& rPoints );
+            	::com::sun::star::uno::Sequence< ::com::sun::star::geometry::RealPoint2D > >& rPoints );
 
         /** Create an VCL/Tools polygon from a bezier segment sequence
          */
         ::Polygon VCL_DLLPUBLIC polygonFromBezier2DSequence( 
             const ::com::sun::star::uno::Sequence< 
-            	::drafts::com::sun::star::geometry::RealBezierSegment2D >& rPoints );
+            	::com::sun::star::geometry::RealBezierSegment2D >& rPoints );
 
         /** Create an VCL/Tools polyPolygon from a bezier segment sequence sequence
          */
         ::PolyPolygon VCL_DLLPUBLIC polyPolygonFromBezier2DSequenceSequence( 
             const ::com::sun::star::uno::Sequence< 
-            	::com::sun::star::uno::Sequence< ::drafts::com::sun::star::geometry::RealBezierSegment2D > >& rPoints );
+            	::com::sun::star::uno::Sequence< ::com::sun::star::geometry::RealBezierSegment2D > >& rPoints );
 
 
         // Bitmap conversions
@@ -165,24 +165,29 @@
 
         /** Create an XBitmap from VCL Bitmap
          */
-        ::com::sun::star::uno::Reference< ::drafts::com::sun::star::rendering::XBitmap > 
+        ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XBitmap > 
 	    	VCL_DLLPUBLIC xBitmapFromBitmap( const ::com::sun::star::uno::Reference< 
-                               		::drafts::com::sun::star::rendering::XGraphicDevice >& 	xGraphicDevice,
+                               		::com::sun::star::rendering::XGraphicDevice >& 	xGraphicDevice,
                                const ::Bitmap&												inputBitmap );
 
         /** Create an XBitmap from VCL BitmapEx
          */
-        ::com::sun::star::uno::Reference< ::drafts::com::sun::star::rendering::XBitmap > 
+        ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XBitmap > 
 	    	VCL_DLLPUBLIC xBitmapFromBitmapEx( const ::com::sun::star::uno::Reference< 
-                                 	::drafts::com::sun::star::rendering::XGraphicDevice >& 	xGraphicDevice,
+                                 	::com::sun::star::rendering::XGraphicDevice >& 	xGraphicDevice,
                                  const ::BitmapEx&											inputBitmap );
 
         /** Create a BitmapEx from an XBitmap
          */
         ::BitmapEx VCL_DLLPUBLIC bitmapExFromXBitmap( const ::com::sun::star::uno::Reference< 
-                                        	::drafts::com::sun::star::rendering::XGraphicDevice >& 	xGraphicDevice,
+                                        	::com::sun::star::rendering::XGraphicDevice >& 	xGraphicDevice,
                                         const ::com::sun::star::uno::Reference< 
-                                        	::drafts::com::sun::star::rendering::XIntegerBitmap >&	xInputBitmap );
+                                        	::com::sun::star::rendering::XIntegerBitmap >&	xInputBitmap );
+                                            
+        /** get a unique identifier for identification in XUnoTunnel interface
+         */
+         enum TunnelIdentifierType { Id_BitmapEx = 0 };
+         const com::sun::star::uno::Sequence< sal_Int8 > VCL_DLLPUBLIC getTunnelIdentifier( TunnelIdentifierType eType );
 
         // Color conversions (vcl/tools Color <-> x)
         // ===================================================================
@@ -191,14 +196,14 @@
          */
         ::com::sun::star::uno::Sequence< double > 
         	VCL_DLLPUBLIC colorToDoubleSequence( const ::com::sun::star::uno::Reference< 
-                                   ::drafts::com::sun::star::rendering::XGraphicDevice >& 	xGraphicDevice,
+                                   ::com::sun::star::rendering::XGraphicDevice >& 	xGraphicDevice,
                                    const Color&												rColor		 );
 
         /** Create a device-specific color sequence from VCL/Tools color
          */
         ::com::sun::star::uno::Sequence< sal_Int8 > 
         	VCL_DLLPUBLIC colorToIntSequence( const ::com::sun::star::uno::Reference< 
-                             	::drafts::com::sun::star::rendering::XGraphicDevice >& 	xGraphicDevice,
+                             	::com::sun::star::rendering::XGraphicDevice >& 	xGraphicDevice,
                                 const Color&											rColor		 );
 
         /** Convert from XGraphicDevice color space to VCL/Tools Color.
@@ -208,7 +213,7 @@
 			are taken as BGRA (for four elements) or BGR tuples (for
 			three elements)
          */
-        Color VCL_DLLPUBLIC sequenceToColor( const ::com::sun::star::uno::Reference< ::drafts::com::sun::star::rendering::XGraphicDevice >&,
+        Color VCL_DLLPUBLIC sequenceToColor( const ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XGraphicDevice >&,
                                const ::com::sun::star::uno::Sequence< double >&											 );
 
         /** Convert from XGraphicDevice color space to VCL/Tools Color.
@@ -218,7 +223,7 @@
 			are taken as BGRA (for four elements) or BGR tuples (for
 			three elements)
          */
-        Color VCL_DLLPUBLIC sequenceToColor( const ::com::sun::star::uno::Reference< ::drafts::com::sun::star::rendering::XGraphicDevice >&,
+        Color VCL_DLLPUBLIC sequenceToColor( const ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XGraphicDevice >&,
                                const ::com::sun::star::uno::Sequence< sal_Int8 >&										 );
  
 
@@ -226,22 +231,22 @@
         // ===================================================================
 
         // geometry::Real        
-        ::drafts::com::sun::star::geometry::RealSize2D  		VCL_DLLPUBLIC size2DFromSize( const Size& );
-        ::drafts::com::sun::star::geometry::RealPoint2D 		VCL_DLLPUBLIC point2DFromPoint( const Point& );
-        ::drafts::com::sun::star::geometry::RealRectangle2D 	VCL_DLLPUBLIC rectangle2DFromRectangle( const Rectangle& );
-
-        Size  													VCL_DLLPUBLIC sizeFromRealSize2D( const ::drafts::com::sun::star::geometry::RealSize2D& );
-        Point 													VCL_DLLPUBLIC pointFromRealPoint2D( const ::drafts::com::sun::star::geometry::RealPoint2D& );
-        Rectangle 												VCL_DLLPUBLIC rectangleFromRealRectangle2D( const ::drafts::com::sun::star::geometry::RealRectangle2D& );
+        ::com::sun::star::geometry::RealSize2D  		VCL_DLLPUBLIC size2DFromSize( const Size& );
+        ::com::sun::star::geometry::RealPoint2D 		VCL_DLLPUBLIC point2DFromPoint( const Point& );
+        ::com::sun::star::geometry::RealRectangle2D 	VCL_DLLPUBLIC rectangle2DFromRectangle( const Rectangle& );
+
+        Size  													VCL_DLLPUBLIC sizeFromRealSize2D( const ::com::sun::star::geometry::RealSize2D& );
+        Point 													VCL_DLLPUBLIC pointFromRealPoint2D( const ::com::sun::star::geometry::RealPoint2D& );
+        Rectangle 												VCL_DLLPUBLIC rectangleFromRealRectangle2D( const ::com::sun::star::geometry::RealRectangle2D& );
 
         // geometry::Integer        
-        ::drafts::com::sun::star::geometry::IntegerSize2D  		VCL_DLLPUBLIC integerSize2DFromSize( const Size& );
-        ::drafts::com::sun::star::geometry::IntegerPoint2D 		VCL_DLLPUBLIC integerPoint2DFromPoint( const Point& );
-        ::drafts::com::sun::star::geometry::IntegerRectangle2D 	VCL_DLLPUBLIC integerRectangle2DFromRectangle( const Rectangle& );
-
-        Size  													VCL_DLLPUBLIC sizeFromIntegerSize2D( const ::drafts::com::sun::star::geometry::IntegerSize2D& );
-        Point 													VCL_DLLPUBLIC pointFromIntegerPoint2D( const ::drafts::com::sun::star::geometry::IntegerPoint2D& );
-        Rectangle 												VCL_DLLPUBLIC rectangleFromIntegerRectangle2D( const ::drafts::com::sun::star::geometry::IntegerRectangle2D& );
+        ::com::sun::star::geometry::IntegerSize2D  		VCL_DLLPUBLIC integerSize2DFromSize( const Size& );
+        ::com::sun::star::geometry::IntegerPoint2D 		VCL_DLLPUBLIC integerPoint2DFromPoint( const Point& );
+        ::com::sun::star::geometry::IntegerRectangle2D 	VCL_DLLPUBLIC integerRectangle2DFromRectangle( const Rectangle& );
+
+        Size  													VCL_DLLPUBLIC sizeFromIntegerSize2D( const ::com::sun::star::geometry::IntegerSize2D& );
+        Point 													VCL_DLLPUBLIC pointFromIntegerPoint2D( const ::com::sun::star::geometry::IntegerPoint2D& );
+        Rectangle 												VCL_DLLPUBLIC rectangleFromIntegerRectangle2D( const ::com::sun::star::geometry::IntegerRectangle2D& );
 
         // basegfx::B2D        
         Size  						VCL_DLLPUBLIC sizeFromB2DSize( const ::basegfx::B2DVector& );
diff -u -r  vcl/inc/region.hxx  vcl/inc/region.hxx
---  vcl/inc/region.hxx	2005-01-13 23:14:51.000000000 +0530
+++  vcl/inc/region.hxx	2005-02-28 13:40:53.011355977 +0530
@@ -173,6 +173,17 @@
 
 	friend VCL_DLLPUBLIC SvStream& operator>>( SvStream& rIStm, Region& rRegion );
 	friend VCL_DLLPUBLIC SvStream& operator<<( SvStream& rOStm, const Region& rRegion );
+    
+    /* workaround: faster conversion for PolyPolygons
+     * if half of the Polygons contained in rPolyPoly are actually
+     * rectangles, then the returned Region will be constructed by
+     * XOr'ing the contained Polygons together; in the case of
+     * only Rectangles this can be up to eight times faster than
+     * Region( const PolyPolygon& ).
+     * Caution: this is only useful if the Region is known to be
+     * changed to rectangles; e.g. if being set as clip region
+     */
+    static Region GetRegionFromPolyPolygon( const PolyPolygon& rPolyPoly );
 };
 
 #endif	// _SV_REGION_HXX
diff -u -r  vcl/inc/salbmp.hxx  vcl/inc/salbmp.hxx
---  vcl/inc/salbmp.hxx	2005-01-13 23:15:06.000000000 +0530
+++  vcl/inc/salbmp.hxx	2005-02-28 13:40:52.985359015 +0530
@@ -73,6 +73,7 @@
 struct BitmapBuffer;
 class SalGraphics;
 class BitmapPalette;
+struct BitmapSystemData;
 
 class VCL_DLLPUBLIC SalBitmap
 {
@@ -94,6 +95,7 @@
 						
 	virtual BitmapBuffer*	AcquireBuffer( bool bReadOnly ) = 0;
 	virtual void			ReleaseBuffer( BitmapBuffer* pBuffer, bool bReadOnly ) = 0;
+    virtual bool            GetSystemData( BitmapSystemData& rData ) = 0;
 
 };
 
diff -u -r  vcl/inc/salbtype.hxx  vcl/inc/salbtype.hxx
---  vcl/inc/salbtype.hxx	2005-01-13 23:15:19.000000000 +0530
+++  vcl/inc/salbtype.hxx	2005-02-28 13:40:52.978359833 +0530
@@ -247,8 +247,8 @@
 	inline						~BitmapPalette();
 
 	inline BitmapPalette&		operator=( const BitmapPalette& rBitmapPalette );
-	inline BOOL 				operator==( const BitmapPalette& rBitmapPalette );
-	inline BOOL 				operator!=( const BitmapPalette& rBitmapPalette );
+	inline BOOL 				operator==( const BitmapPalette& rBitmapPalette ) const;
+	inline BOOL 				operator!=( const BitmapPalette& rBitmapPalette ) const;
 	inline BOOL 				operator!();
 
 	inline USHORT				GetEntryCount() const;
@@ -663,7 +663,7 @@
 
 // ------------------------------------------------------------------
 
-inline BOOL BitmapPalette::operator==( const BitmapPalette& rBitmapPalette )
+inline BOOL BitmapPalette::operator==( const BitmapPalette& rBitmapPalette ) const
 {
 	BOOL bRet = FALSE;
 
@@ -686,7 +686,7 @@
 
 // ------------------------------------------------------------------
 
-inline BOOL BitmapPalette::operator!=( const BitmapPalette& rBitmapPalette )
+inline BOOL BitmapPalette::operator!=( const BitmapPalette& rBitmapPalette ) const
 {
 	return !( *this == rBitmapPalette );
 }
diff -u -r  vcl/inc/window.h  vcl/inc/window.h
---  vcl/inc/window.h	2005-01-13 23:26:32.000000000 +0530
+++  vcl/inc/window.h	2005-02-28 13:40:52.968361001 +0530
@@ -115,13 +115,12 @@
     class XAccessible;
 }}}}
 
-namespace drafts {
 namespace com {
 namespace sun {
 namespace star {
 namespace rendering {
     class XCanvas;
-}}}}}
+}}}}
 
 namespace com {
 namespace sun {
@@ -282,7 +281,7 @@
     VclEventListeners   maChildEventListeners;
 
     // The canvas interface for this VCL window. Is persistent after the first GetCanvas() call
-    mutable ::com::sun::star::uno::Reference< ::drafts::com::sun::star::rendering::XCanvas > 	mxCanvas;
+    mutable ::com::sun::star::uno::Reference< ::com::sun::star::rendering::XCanvas > 	mxCanvas;
 
     // The (optional) XWindow interface to the Java EmbeddedFrame containing the canvas
     mutable ::com::sun::star::uno::Reference< ::com::sun::star::awt::XWindow > 					mxCanvasWindow;
diff -u -r  vcl/inc/window.hxx  vcl/inc/window.hxx
---  vcl/inc/window.hxx	2005-01-21 22:53:05.000000000 +0530
+++  vcl/inc/window.hxx	2005-02-28 13:40:53.009356211 +0530
@@ -157,13 +157,12 @@
     class XAccessible;
 }}}}
 
-namespace drafts {
 namespace com {
 namespace sun {
 namespace star {
 namespace rendering {
     class XCanvas;
-}}}}}
+}}}}
 
 namespace com {
 namespace sun {
@@ -1010,10 +1009,10 @@
 
     // new Canvas
     ::com::sun::star::uno::Reference< 
-		::drafts::com::sun::star::rendering::XCanvas > GetCanvas() const;
+		::com::sun::star::rendering::XCanvas > GetCanvas() const;
     // new Canvas
     ::com::sun::star::uno::Reference< 
-		::drafts::com::sun::star::rendering::XCanvas > GetFullscreenCanvas( const Size& rFullscreenSize ) const;
+		::com::sun::star::rendering::XCanvas > GetFullscreenCanvas( const Size& rFullscreenSize ) const;
 
     /*  records all DrawText operations within the passed rectangle;
      *  a synchronous paint is sent to achieve this
diff -u -r  vcl/prj/d.lst  vcl/prj/d.lst
---  vcl/prj/d.lst	2005-01-13 23:27:25.000000000 +0530
+++  vcl/prj/d.lst	2005-02-28 13:40:53.055350836 +0530
@@ -31,7 +31,6 @@
 hedabu: ..\inc\animate.hxx %_DEST%\inc%_EXT%\vcl\animate.hxx
 hedabu: ..\inc\apptypes.hxx %_DEST%\inc%_EXT%\vcl\apptypes.hxx
 hedabu: ..\inc\bitmap.hxx %_DEST%\inc%_EXT%\vcl\bitmap.hxx
-hedabu: ..\inc\bitmap.inl %_DEST%\inc%_EXT%\vcl\bitmap.inl
 hedabu: ..\inc\bitmapex.hxx %_DEST%\inc%_EXT%\vcl\bitmapex.hxx
 hedabu: ..\inc\bmpacc.hxx %_DEST%\inc%_EXT%\vcl\bmpacc.hxx
 hedabu: ..\inc\btndlg.hxx %_DEST%\inc%_EXT%\vcl\btndlg.hxx
diff -u -r  vcl/source/gdi/bitmap.cxx  vcl/source/gdi/bitmap.cxx
---  vcl/source/gdi/bitmap.cxx	2004-05-21 21:52:22.000000000 +0530
+++  vcl/source/gdi/bitmap.cxx	2005-02-28 13:40:58.581705067 +0530
@@ -80,6 +80,9 @@
 #ifndef _SV_IMPBMP_HXX
 #include <impbmp.hxx>
 #endif
+#ifndef _SV_SALBMP_HXX
+#include <salbmp.hxx>
+#endif
 #ifndef _SV_RC_H
 #include <tools/rc.h>
 #endif
@@ -1945,3 +1948,18 @@
 {
 	return ImplMakeMono( cThreshold );
 }
+
+// ------------------------------------------------------------------
+
+bool Bitmap::GetSystemData( BitmapSystemData& rData ) const
+{
+    bool bRet = false;
+    if( mpImpBmp )
+    {
+        SalBitmap* pSalBitmap = mpImpBmp->ImplGetSalBitmap();
+        if( pSalBitmap )
+            bRet = pSalBitmap->GetSystemData( rData );
+    }
+    
+    return bRet;
+}
diff -u -r  vcl/source/gdi/impbmp.cxx  vcl/source/gdi/impbmp.cxx
---  vcl/source/gdi/impbmp.cxx	2004-01-06 19:12:38.000000000 +0530
+++  vcl/source/gdi/impbmp.cxx	2005-02-28 13:40:58.605702263 +0530
@@ -164,4 +164,4 @@
 
 	if( !bReadOnly )
 		mnChecksum = 0;
-}
\ No newline at end of file
+}
diff -u -r  vcl/source/gdi/makefile.mk  vcl/source/gdi/makefile.mk
---  vcl/source/gdi/makefile.mk	2005-01-31 18:52:39.000000000 +0530
+++  vcl/source/gdi/makefile.mk	2005-02-28 13:40:58.718689060 +0530
@@ -94,6 +94,7 @@
 			$(SLO)$/bmpacc.obj		\
 			$(SLO)$/bmpacc2.obj 	\
 			$(SLO)$/bmpacc3.obj 	\
+			$(SLO)$/bmpfast.obj	\
 			$(SLO)$/color.obj		\
 			$(SLO)$/cvtsvm.obj		\
 			$(SLO)$/cvtgrf.obj		\
diff -u -r  vcl/source/gdi/outdev2.cxx  vcl/source/gdi/outdev2.cxx
---  vcl/source/gdi/outdev2.cxx	2005-01-31 14:47:56.000000000 +0530
+++  vcl/source/gdi/outdev2.cxx	2005-02-28 13:40:58.758684387 +0530
@@ -122,6 +122,9 @@
 #ifndef _SV_IMAGE_HXX
 #include <image.hxx>
 #endif
+#ifndef _SV_BMPFAST_HXX
+#include <bmpfast.hxx>
+#endif
 
 #define BAND_MAX_SIZE 512000
 
@@ -1636,10 +1639,10 @@
 								  const Point& rDestPt, const Size& rDestSize,
 								  const Point& rSrcPtPixel, const Size& rSrcSizePixel )
 {
-	Point		aPt;
+	const Point aNullPt;
 	Point		aOutPt( LogicToPixel( rDestPt ) );
-	Size		aOutSz( LogicToPixel( rDestSize ) );
-	Rectangle	aDstRect( aPt, GetOutputSizePixel() );
+	Size        aOutSz( LogicToPixel( rDestSize ) );
+	Rectangle	aDstRect( aNullPt, GetOutputSizePixel() );
 	const BOOL	bHMirr = aOutSz.Width() < 0, bVMirr = aOutSz.Height() < 0;
 
 	if( OUTDEV_WINDOW == meOutDevType )
@@ -1666,7 +1669,7 @@
 	{
         VirtualDevice* pOldVDev = mpAlphaVDev;
 
-		Rectangle aBmpRect( aPt, rBmp.GetSizePixel() );
+		Rectangle aBmpRect( aNullPt, rBmp.GetSizePixel() );
 
 		if( !aBmpRect.Intersection( Rectangle( rSrcPtPixel, rSrcSizePixel ) ).IsEmpty() )
 		{
@@ -1710,7 +1713,7 @@
 				if( bHMirr )
 					pMapX[ nX ] = nMirrOffX - pMapX[ nX ];
 			}
-
+            
 			// create vertical mapping table
 			if( bVMirr )
 				nMirrOffY = ( aBmpRect.Top() << 1 ) + nSrcHeight - 1;
@@ -1733,107 +1736,124 @@
             // #i38887# reading from screen may sometimes fail
             if( aBmp.ImplGetImpBitmap() )
             {
-			    if( GetBitCount() <= 8 )
-			    {
-				    Bitmap				aDither( aBmp.GetSizePixel(), 8 );
-				    BitmapColor 		aIndex( 0 );
-				    BitmapReadAccess*	pB = aBmp.AcquireReadAccess();
-				    BitmapWriteAccess*	pW = aDither.AcquireWriteAccess();
-
-				    if( pB && pP && pA && pW )
-				    {
-					    for( nY = 0, nOutY = nOffY; nY < nDstHeight; nY++, nOutY++ )
-					    {
-						    const long nMapY = pMapY[ nY ];
-						    const long nModY = ( nOutY & 0x0FL ) << 4L;
-
-						    for( nX = 0, nOutX = nOffX; nX < nDstWidth; nX++, nOutX++ )
-						    {
-							    const long	nMapX = pMapX[ nX ];
-							    const ULONG nD = nVCLDitherLut[ nModY | ( nOutX & 0x0FL ) ];
-
-							    aDstCol = pB->GetColor( nY, nX );
-							    aDstCol.Merge( pP->GetColor( nMapY, nMapX ), (BYTE) pA->GetPixel( nMapY, nMapX ) );
-							    aIndex.SetIndex( (BYTE) ( nVCLRLut[ ( nVCLLut[ aDstCol.GetRed() ] + nD ) >> 16UL ] +
-													    nVCLGLut[ ( nVCLLut[ aDstCol.GetGreen() ] + nD ) >> 16UL ] +
-													    nVCLBLut[ ( nVCLLut[ aDstCol.GetBlue() ] + nD ) >> 16UL ] ) );
-							    pW->SetPixel( nY, nX, aIndex );
-						    }
-					    }
-				    }
-
-				    aBmp.ReleaseAccess( pB );
-				    aDither.ReleaseAccess( pW );
-				    DrawBitmap( aDstRect.TopLeft(), aDither );
-			    }
-			    else
-			    {
-				    BitmapWriteAccess*	pB = aBmp.AcquireWriteAccess();
+                if( GetBitCount() <= 8 )
+                {
+                    Bitmap				aDither( aBmp.GetSizePixel(), 8 );
+                    BitmapColor 		aIndex( 0 );
+                    BitmapReadAccess*	pB = aBmp.AcquireReadAccess();
+                    BitmapWriteAccess*	pW = aDither.AcquireWriteAccess();
+
+                    if( pB && pP && pA && pW )
+                    {
+                        for( nY = 0, nOutY = nOffY; nY < nDstHeight; nY++, nOutY++ )
+                        {
+                            const long nMapY = pMapY[ nY ];
+                            const long nModY = ( nOutY & 0x0FL ) << 4L;
+
+                            for( nX = 0, nOutX = nOffX; nX < nDstWidth; nX++, nOutX++ )
+                            {
+                                const long	nMapX = pMapX[ nX ];
+                                const ULONG nD = nVCLDitherLut[ nModY | ( nOutX & 0x0FL ) ];
 
-				    if( pP && pA && pB )
-				    {
+                                aDstCol = pB->GetColor( nY, nX );
+                                aDstCol.Merge( pP->GetColor( nMapY, nMapX ), (BYTE) pA->GetPixel( nMapY, nMapX ) );
+                                aIndex.SetIndex( (BYTE) ( nVCLRLut[ ( nVCLLut[ aDstCol.GetRed() ] + nD ) >> 16UL ] +
+                                                          nVCLGLut[ ( nVCLLut[ aDstCol.GetGreen() ] + nD ) >> 16UL ] +
+                                                          nVCLBLut[ ( nVCLLut[ aDstCol.GetBlue() ] + nD ) >> 16UL ] ) );
+                                pW->SetPixel( nY, nX, aIndex );
+                            }
+                        }
+                    }
+
+                    aBmp.ReleaseAccess( pB );
+                    aDither.ReleaseAccess( pW );
+                    DrawBitmap( aDstRect.TopLeft(), aDither );
+                }
+                else
+                {
+                    BitmapWriteAccess*	pB = aBmp.AcquireWriteAccess();
+
+                    bool bFastBlend = false;
+                    if( pP && pA && pB )
+                    {
+                        SalTwoRect aTR;
+                        aTR.mnSrcX      = aBmpRect.Left();
+                        aTR.mnSrcY      = aBmpRect.Top();
+                        aTR.mnSrcWidth  = aBmpRect.GetWidth();
+                        aTR.mnSrcHeight = aBmpRect.GetHeight();
+                        aTR.mnDestX     = nOffX;
+                        aTR.mnDestY     = nOffY;
+                        aTR.mnDestWidth = aOutSz.Width();
+                        aTR.mnDestHeight= aOutSz.Height();
+
+                        if( !bHMirr || !bVMirr )
+                            bFastBlend = ImplFastBitmapBlending( *pB,*pP,*pA, aTR );
+                    }
+
+                    if( pP && pA && pB && !bFastBlend )
+                    {
                         switch( pP->GetScanlineFormat() )
                         {
                             case( BMP_FORMAT_8BIT_PAL ):
-                            {
-                                for( nY = 0; nY < nDstHeight; nY++ )
                                 {
-                                    const long	nMapY = pMapY[ nY ];
-                                    Scanline	pPScan = pP->GetScanline( nMapY );
-                                    Scanline	pAScan = pA->GetScanline( nMapY );
-
-                                    for( nX = 0; nX < nDstWidth; nX++ )
+                                    for( nY = 0; nY < nDstHeight; nY++ )
                                     {
-                                        const long nMapX = pMapX[ nX ];
-                                        aDstCol = pB->GetPixel( nY, nX );
-                                        pB->SetPixel( nY, nX, aDstCol.Merge( pP->GetPaletteColor( pPScan[ nMapX ] ),
-                                                                            pAScan[ nMapX ] ) );
+                                        const long	nMapY = pMapY[ nY ];
+                                        Scanline	pPScan = pP->GetScanline( nMapY );
+                                        Scanline	pAScan = pA->GetScanline( nMapY );
+
+                                        for( nX = 0; nX < nDstWidth; nX++ )
+                                        {
+                                            const long nMapX = pMapX[ nX ];
+                                            aDstCol = pB->GetPixel( nY, nX );
+                                            pB->SetPixel( nY, nX, aDstCol.Merge( pP->GetPaletteColor( pPScan[ nMapX ] ),
+                                                                                 pAScan[ nMapX ] ) );
+                                        }
                                     }
                                 }
-                            }
-                            break;
+                                break;
 
                             case( BMP_FORMAT_24BIT_TC_BGR ):
-                            {
-                                for( nY = 0; nY < nDstHeight; nY++ )
                                 {
-                                    const long	nMapY = pMapY[ nY ];
-                                    Scanline	pPScan = pP->GetScanline( nMapY );
-                                    Scanline	pAScan = pA->GetScanline( nMapY );
-
-                                    for( nX = 0; nX < nDstWidth; nX++ )
+                                    for( nY = 0; nY < nDstHeight; nY++ )
                                     {
-                                        const long	nMapX = pMapX[ nX ];
-                                        Scanline	pTmp = pPScan + nMapX * 3;
-
-                                        aDstCol = pB->GetPixel( nY, nX );
-                                        pB->SetPixel( nY, nX, aDstCol.Merge( pTmp[ 2 ], pTmp[ 1 ], pTmp[ 0 ],
-                                                                            pAScan[ nMapX ] ) );
+                                        const long	nMapY = pMapY[ nY ];
+                                        Scanline	pPScan = pP->GetScanline( nMapY );
+                                        Scanline	pAScan = pA->GetScanline( nMapY );
+
+                                        for( nX = 0; nX < nDstWidth; nX++ )
+                                        {
+                                            const long	nMapX = pMapX[ nX ];
+                                            Scanline	pTmp = pPScan + nMapX * 3;
+
+                                            aDstCol = pB->GetPixel( nY, nX );
+                                            pB->SetPixel( nY, nX, aDstCol.Merge( pTmp[ 2 ], pTmp[ 1 ], pTmp[ 0 ],
+                                                                                 pAScan[ nMapX ] ) );
+                                        }
                                     }
                                 }
-                            }
-                            break;
+                                break;
 
                             case( BMP_FORMAT_24BIT_TC_RGB ):
-                            {
-                                for( nY = 0; nY < nDstHeight; nY++ )
                                 {
-                                    const long	nMapY = pMapY[ nY ];
-                                    Scanline	pPScan = pP->GetScanline( nMapY );
-                                    Scanline	pAScan = pA->GetScanline( nMapY );
-
-                                    for( nX = 0; nX < nDstWidth; nX++ )
+                                    for( nY = 0; nY < nDstHeight; nY++ )
                                     {
-                                        const long	nMapX = pMapX[ nX ];
-                                        Scanline	pTmp = pPScan + nMapX * 3;
-
-                                        aDstCol = pB->GetPixel( nY, nX );
-                                        pB->SetPixel( nY, nX, aDstCol.Merge( pTmp[ 0 ], pTmp[ 1 ], pTmp[ 2 ],
-                                                                            pAScan[ nMapX ] ) );
+                                        const long	nMapY = pMapY[ nY ];
+                                        Scanline	pPScan = pP->GetScanline( nMapY );
+                                        Scanline	pAScan = pA->GetScanline( nMapY );
+
+                                        for( nX = 0; nX < nDstWidth; nX++ )
+                                        {
+                                            const long	nMapX = pMapX[ nX ];
+                                            Scanline    pTmp = pPScan + nMapX * 3;
+
+                                            aDstCol = pB->GetPixel( nY, nX );
+                                            pB->SetPixel( nY, nX, aDstCol.Merge( pTmp[ 0 ], pTmp[ 1 ], pTmp[ 2 ],
+                                                                                 pAScan[ nMapX ] ) );
+                                        }
                                     }
                                 }
-                            }
-                            break;
+                                break;
 
                             default:
                             {
@@ -1847,17 +1867,17 @@
                                         const long nMapX = pMapX[ nX ];
                                         aDstCol = pB->GetPixel( nY, nX );
                                         pB->SetPixel( nY, nX, aDstCol.Merge( pP->GetColor( nMapY, nMapX ),
-                                                                            pAScan[ nMapX ] ) );
+                                                                             pAScan[ nMapX ] ) );
                                     }
                                 }
                             }
                             break;
                         }
-				    }
+                    }
 
-				    aBmp.ReleaseAccess( pB );
-				    DrawBitmap( aDstRect.TopLeft(), aBmp );
-			    }
+                    aBmp.ReleaseAccess( pB );
+                    DrawBitmap( aDstRect.TopLeft(), aBmp );
+                }
             }
 
             // #110958# Enable alpha VDev again
diff -u -r  vcl/source/gdi/regband.cxx  vcl/source/gdi/regband.cxx
---  vcl/source/gdi/regband.cxx	2004-09-08 20:37:34.000000000 +0530
+++  vcl/source/gdi/regband.cxx	2005-02-28 13:40:58.608701913 +0530
@@ -624,56 +624,105 @@
 	ImplRegionBandSep* pNewSep;
 	ImplRegionBandSep* pPrevSep = 0;
 	ImplRegionBandSep* pSep = mpFirstSep;
-	while ( pSep  )
-	{
-		// new separation completely overlapping?
-		//	 -> move boundaries to left remainder
-		//	 -> reduce boundaries of new separation
-		if ( (nXLeft <= pSep->mnXLeft) && (nXRight >= pSep->mnXRight) )
-		{
-			pSep->mnXRight = pSep->mnXLeft;
-			pSep->mnXLeft = nXLeft;
-			nXLeft = pSep->mnXRight;
-		}
-
-		// new separation overlaping from left?
-		//	 -> move boundaries to left remainder
-		//	 -> set boundaries of new separation to right remainder
-		if ( (nXRight >= pSep->mnXLeft) && (nXLeft <= pSep->mnXLeft) )
-		{
-			pSep->mnXRight = pSep->mnXLeft;
-			pSep->mnXLeft = nXLeft;
-			nXLeft = pSep->mnXRight;
-		}
-
-		// new separation overlaping from right? -> reduce boundary
-		if ( (nXLeft <= pSep->mnXRight) && (nXRight > pSep->mnXRight) )
-			pSep->mnXRight = nXLeft;
-
-		// new separation within the actual one? -> reduce boundary
-		// and add new entry for reminder
-		if ( (nXLeft >= pSep->mnXLeft) && (nXRight <= pSep->mnXRight) )
-		{
-			pNewSep 			= new ImplRegionBandSep;
-			pNewSep->mnXLeft	= pSep->mnXLeft;
-			pNewSep->mnXRight	= nXLeft;
-
-			pSep->mnXLeft = nXRight;
-
-			// connections from the new separation
-			pNewSep->mpNextSep = pSep;
-
-			// connections to the new separation
-			if ( pSep == mpFirstSep )
-				mpFirstSep = pNewSep;
-			else
-				pPrevSep->mpNextSep = pNewSep;
-		}
-
-		pPrevSep = pSep;
-		pSep = pSep->mpNextSep;
-	}
 
+    while ( pSep  )
+    {
+        // new separation completely left ?
+        if( nXRight < pSep->mnXLeft )
+        {
+            pNewSep             = new ImplRegionBandSep;
+            pNewSep->mnXLeft    = nXLeft;
+            pNewSep->mnXRight   = nXRight;
+            pNewSep->mpNextSep  = pSep;
+            pNewSep->mbRemoved  = FALSE;
+            
+            // connections from the new separation
+            pNewSep->mpNextSep = pSep;
+            
+            // connections to the new separation
+            if ( pSep == mpFirstSep )
+                mpFirstSep = pNewSep;
+            else
+                pPrevSep->mpNextSep = pNewSep;
+            pPrevSep = NULL; // do not run accidentally into the "right" case when breaking the loop
+            break;
+        }
+        // separation equal to band ?
+        //  -> remove band
+        if( nXLeft == pSep->mnXLeft && nXRight == pSep->mnXRight )
+        {
+            pSep->mbRemoved = TRUE;
+            pPrevSep = NULL; // do not run accidentally into the "right" case when breaking the loop
+            break;
+        }
+        // new separation completely overlapping?
+        //	 -> move boundaries to left remainder
+        //	 -> reduce boundaries of new separation
+        if ( (nXLeft <= pSep->mnXLeft) && (nXRight > pSep->mnXRight) )
+        {
+            long nNewLeft = pSep->mnXRight;
+            pSep->mnXRight = pSep->mnXLeft;
+            pSep->mnXLeft = nXLeft;
+            nXLeft = nNewLeft;
+        }
+        
+        // new separation overlaping from left?
+        //	 -> move boundaries to left remainder
+        //	 -> set boundaries of new separation to right remainder
+        else if ( (nXRight >= pSep->mnXLeft) && (nXLeft <= pSep->mnXLeft) )
+        {
+            long nNewLeft = nXRight;
+            nXRight = pSep->mnXRight;
+            pSep->mnXRight = pSep->mnXLeft;
+            pSep->mnXLeft = nXLeft;
+            nXLeft = nNewLeft;
+        }
+        
+        // new separation overlaping from right? -> reduce boundary
+        else if ( (nXLeft <= pSep->mnXRight) && (nXRight >= pSep->mnXRight) )
+        {
+            long nNewLeft = pSep->mnXRight;
+            pSep->mnXRight = nXLeft;
+            nXLeft = nNewLeft;
+        }
+        
+        // new separation within the current one? -> reduce boundary
+        // and add new entry for remainder
+        else if ( (nXLeft >= pSep->mnXLeft) && (nXRight <= pSep->mnXRight) )
+        {
+            pNewSep 			= new ImplRegionBandSep;
+            pNewSep->mnXLeft	= pSep->mnXLeft;
+            pNewSep->mnXRight	= nXLeft;
+            pNewSep->mbRemoved  = FALSE;
+            
+            pSep->mnXLeft = nXRight;
+            
+            // connections from the new separation
+            pNewSep->mpNextSep = pSep;
+            
+            // connections to the new separation
+            if ( pSep == mpFirstSep )
+                mpFirstSep = pNewSep;
+            else
+                pPrevSep->mpNextSep = pNewSep;
+        }
+        
+        pPrevSep = pSep;
+        pSep = pSep->mpNextSep;
+    }
+    // new separation completely right ?
+    if( pPrevSep && nXLeft >= pPrevSep->mnXRight )
+    {
+        pNewSep             = new ImplRegionBandSep;
+        pNewSep->mnXLeft    = nXLeft;
+        pNewSep->mnXRight   = nXRight;
+        pNewSep->mpNextSep  = NULL;
+        pNewSep->mbRemoved  = FALSE;
+        
+        // connections from the new separation
+        pPrevSep->mpNextSep = pNewSep;
+    }
+    
 	OptimizeBand();
 }
 
diff -u -r  vcl/source/gdi/region.cxx  vcl/source/gdi/region.cxx
---  vcl/source/gdi/region.cxx	2004-09-08 20:37:47.000000000 +0530
+++  vcl/source/gdi/region.cxx	2005-02-28 13:40:58.755684737 +0530
@@ -1562,9 +1562,12 @@
 	if ( (rRegion.mpImplRegion == &aImplEmptyRegion) || (rRegion.mpImplRegion == &aImplNullRegion) )
 		return TRUE;
 
-	// no instance data? -> nothing to do
+	// no own instance data? -> XOr = copy
 	if ( (mpImplRegion == &aImplEmptyRegion) || (mpImplRegion == &aImplNullRegion) )
+    {
+        *this = rRegion;
 		return TRUE;
+    }
 
 	// no own instance data? -> make own copy!
 	if ( mpImplRegion->mnRefCount > 1 )
@@ -2469,3 +2472,84 @@
 	delete pData->mpRegion;
 	delete pData;
 }
+
+// -----------------------------------------------------------------------
+
+static inline bool ImplPolygonRectTest( const Polygon& rPoly, Rectangle* pRectOut = NULL )
+{
+    bool bIsRect = false;
+    const Point* pPoints = rPoly.GetConstPointAry();
+    USHORT nPoints = rPoly.GetSize();
+    if( nPoints == 4 || (nPoints == 5 && pPoints[0] == pPoints[4]) )
+    {
+        long nX1 = pPoints[0].X(), nX2 = pPoints[2].X(),
+        nY1 = pPoints[0].Y(), nY2 = pPoints[2].Y();
+        if( ( (pPoints[1].X() == nX1 && pPoints[3].X() == nX2) &&
+            (pPoints[1].Y() == nY2 && pPoints[3].Y() == nY1) )
+        ||
+        ( (pPoints[1].X() == nX2 && pPoints[3].X() == nX1) &&
+        (pPoints[1].Y() == nY1 && pPoints[3].Y() == nY2) ) )
+        {
+            bIsRect = true;
+            if( pRectOut )
+            {
+                long nSwap;
+                if( nX2 < nX1 )
+                {
+                    nSwap = nX2;
+                    nX2 = nX1;
+                    nX1 = nSwap;
+                }
+                if( nY2 < nY1 )
+                {
+                    nSwap = nY2;
+                    nY2 = nY1;
+                    nY1 = nSwap;
+                }
+                if( nX2 != nX1 )
+                    nX2--;
+                if( nY2 != nY1 )
+                    nY2--;
+                pRectOut->Left()    = nX1;
+                pRectOut->Right()   = nX2;
+                pRectOut->Top()     = nY1;
+                pRectOut->Bottom()  = nY2;
+            }
+        }
+    }
+    return bIsRect;
+}
+
+Region Region::GetRegionFromPolyPolygon( const PolyPolygon& rPolyPoly )
+{
+    //return Region( rPolyPoly );
+    
+    // check if it's worth extracting the XOr'ing the Rectangles
+    // empiricism shows that break even between XOr'ing rectangles separately
+    // and ImplPolyPolyRegionToBandRegion is at half rectangles/half polygons
+    int nPolygonRects = 0, nPolygonPolygons = 0;
+    int nPolygons = rPolyPoly.Count();
+    
+    for( int i = 0; i < nPolygons; i++ )
+    {
+        const Polygon& rPoly = rPolyPoly[i];
+        if( ImplPolygonRectTest( rPoly ) )
+            nPolygonRects++;
+        else
+            nPolygonPolygons++;
+    }
+    if( nPolygonPolygons > nPolygonRects )
+        return Region( rPolyPoly );
+    
+    Region aResult;
+    Rectangle aRect;
+    for( int i = 0; i < nPolygons; i++ )
+    {
+        const Polygon& rPoly = rPolyPoly[i];
+        if( ImplPolygonRectTest( rPoly, &aRect ) )
+            aResult.XOr( aRect );
+        else
+            aResult.XOr( Region(rPoly) );
+    }
+    return aResult;
+}
diff -u -r  vcl/source/gdi/salmisc.cxx  vcl/source/gdi/salmisc.cxx
---  vcl/source/gdi/salmisc.cxx	2004-07-23 15:34:42.000000000 +0530
+++  vcl/source/gdi/salmisc.cxx	2005-02-28 13:40:58.425723294 +0530
@@ -64,6 +64,7 @@
 #endif
 #include <bmpacc.hxx>
 #include <salbtype.hxx>
+#include <bmpfast.hxx>
 
 // -----------
 // - Defines -
@@ -317,6 +318,8 @@
 	delete[] pColToPalMap;
 }
 
+// -----------------------------------------------------------------------------
+
 // ---------------------
 // - StretchAndConvert -
 // ---------------------
@@ -327,16 +330,7 @@
     FncGetPixel		pFncGetPixel;
     FncSetPixel		pFncSetPixel;
 	BitmapBuffer*	pDstBuffer = new BitmapBuffer;
-	const ULONG		nDstScanlineFormat = BMP_SCANLINE_FORMAT( nDstBitmapFormat );
-	const long		nSrcX = rTwoRect.mnSrcX, nSrcY = rTwoRect.mnSrcY;
-	const long		nSrcDX = rTwoRect.mnSrcWidth, nSrcDY = rTwoRect.mnSrcHeight;
-	const long		nDstDX = rTwoRect.mnDestWidth, nDstDY = rTwoRect.mnDestHeight;
-	Scanline*		pSrcScan = new Scanline[ rSrcBuffer.mnHeight ];
-	Scanline*		pDstScan = new Scanline[ nDstDY ];
-	long*			pMapX = new long[ nDstDX ];
-	long*			pMapY = new long[ nDstDY ];
-	Scanline		pTmpScan;
-	long			i, nTmp, nOffset;
+    long            i;
 
 	// set function for getting pixels
 	switch( BMP_SCANLINE_FORMAT( rSrcBuffer.mnFormat ) )
@@ -368,6 +362,7 @@
 	}
 
 	// set function for setting pixels
+    const ULONG nDstScanlineFormat = BMP_SCANLINE_FORMAT( nDstBitmapFormat );
 	switch( nDstScanlineFormat )
 	{
 		IMPL_CASE_SET_FORMAT( _1BIT_MSB_PAL, 1 );
@@ -399,11 +394,10 @@
 
 	// fill destination buffer
 	pDstBuffer->mnFormat = nDstBitmapFormat;
-	pDstBuffer->mnWidth = nDstDX;
-	pDstBuffer->mnHeight = nDstDY;
-	pDstBuffer->mnScanlineSize = AlignedWidth4Bytes( pDstBuffer->mnBitCount * nDstDX );
-	pDstBuffer->mpBits = new BYTE[ pDstBuffer->mnScanlineSize * nDstDY ];
-	rtl_zeroMemory( pDstBuffer->mpBits, pDstBuffer->mnScanlineSize * nDstDY );
+	pDstBuffer->mnWidth = rTwoRect.mnDestWidth;
+	pDstBuffer->mnHeight = rTwoRect.mnDestHeight;
+	pDstBuffer->mnScanlineSize = AlignedWidth4Bytes( pDstBuffer->mnBitCount * pDstBuffer->mnWidth );
+	pDstBuffer->mpBits = new BYTE[ pDstBuffer->mnScanlineSize * pDstBuffer->mnHeight ];
 
 	// do we need a destination palette or color mask?
 	if( ( nDstScanlineFormat == BMP_FORMAT_1BIT_MSB_PAL ) ||
@@ -425,7 +419,21 @@
 		pDstBuffer->maColorMask = *pDstMask;
 	}
 
-	// horizontal mapping table
+    // short circuit the most important conversions
+    bool bFastConvert = ImplFastBitmapConversion( *pDstBuffer, rSrcBuffer, rTwoRect );
+    if( bFastConvert )
+        return pDstBuffer;
+    
+    const long      nSrcX = rTwoRect.mnSrcX, nSrcY = rTwoRect.mnSrcY;
+    const long      nSrcDX = rTwoRect.mnSrcWidth, nSrcDY = rTwoRect.mnSrcHeight;
+    const long      nDstDX = rTwoRect.mnDestWidth, nDstDY = rTwoRect.mnDestHeight;
+    Scanline*       pSrcScan = new Scanline[ rSrcBuffer.mnHeight ];
+    Scanline*       pDstScan = new Scanline[ nDstDY ];
+    long*           pMapX = new long[ nDstDX ];
+    long*           pMapY = new long[ nDstDY ];
+    long            nTmp, nOffset;
+
+    // horizontal mapping table
 	if( nDstDX != nSrcDX )
 	{
 		const double fFactorX = ( nDstDX > 1 ) ? (double) ( nSrcDX - 1 ) / ( nDstDX - 1 ) : 0.0;
@@ -454,6 +462,7 @@
 	}
 
 	// source scanline buffer
+    Scanline pTmpScan;
 	if( BMP_SCANLINE_ADJUSTMENT( rSrcBuffer.mnFormat ) == BMP_FORMAT_TOP_DOWN )
 		pTmpScan = rSrcBuffer.mpBits, nOffset = rSrcBuffer.mnScanlineSize;
 	else
diff -u -r  vcl/source/helper/canvastools.cxx  vcl/source/helper/canvastools.cxx
---  vcl/source/helper/canvastools.cxx	2004-11-27 02:13:34.000000000 +0530
+++  vcl/source/helper/canvastools.cxx	2005-02-28 13:40:59.309620009 +0530
@@ -63,45 +63,45 @@
 #include <rtl/logfile.hxx>
 #endif
 
-#ifndef _DRAFTS_COM_SUN_STAR_GEOMETRY_REALSIZE2D_HPP__
-#include <drafts/com/sun/star/geometry/RealSize2D.hpp>
+#ifndef _COM_SUN_STAR_GEOMETRY_REALSIZE2D_HPP__
+#include <com/sun/star/geometry/RealSize2D.hpp>
 #endif
-#ifndef _DRAFTS_COM_SUN_STAR_GEOMETRY_REALPOINT2D_HPP__
-#include <drafts/com/sun/star/geometry/RealPoint2D.hpp>
+#ifndef _COM_SUN_STAR_GEOMETRY_REALPOINT2D_HPP__
+#include <com/sun/star/geometry/RealPoint2D.hpp>
 #endif
-#ifndef _DRAFTS_COM_SUN_STAR_GEOMETRY_REALRECTANGLE2D_HPP__
-#include <drafts/com/sun/star/geometry/RealRectangle2D.hpp>
+#ifndef _COM_SUN_STAR_GEOMETRY_REALRECTANGLE2D_HPP__
+#include <com/sun/star/geometry/RealRectangle2D.hpp>
 #endif
-#ifndef _DRAFTS_COM_SUN_STAR_GEOMETRY_INTEGERSIZE2D_HPP__
-#include <drafts/com/sun/star/geometry/IntegerSize2D.hpp>
+#ifndef _COM_SUN_STAR_GEOMETRY_INTEGERSIZE2D_HPP__
+#include <com/sun/star/geometry/IntegerSize2D.hpp>
 #endif
-#ifndef _DRAFTS_COM_SUN_STAR_GEOMETRY_INTEGERPOINT2D_HPP__
-#include <drafts/com/sun/star/geometry/IntegerPoint2D.hpp>
+#ifndef _COM_SUN_STAR_GEOMETRY_INTEGERPOINT2D_HPP__
+#include <com/sun/star/geometry/IntegerPoint2D.hpp>
 #endif
-#ifndef _DRAFTS_COM_SUN_STAR_GEOMETRY_INTEGERRECTANGLE2D_HPP__
-#include <drafts/com/sun/star/geometry/IntegerRectangle2D.hpp>
+#ifndef _COM_SUN_STAR_GEOMETRY_INTEGERRECTANGLE2D_HPP__
+#include <com/sun/star/geometry/IntegerRectangle2D.hpp>
 #endif
 
-#ifndef _DRAFTS_COM_SUN_STAR_RENDERING_XGRAPHICDEVICE_HPP__
-#include <drafts/com/sun/star/rendering/XGraphicDevice.hpp>
+#ifndef _COM_SUN_STAR_RENDERING_XGRAPHICDEVICE_HPP__
+#include <com/sun/star/rendering/XGraphicDevice.hpp>
 #endif
-#ifndef _DRAFTS_COM_SUN_STAR_RENDERING_XBITMAP_HPP__
-#include <drafts/com/sun/star/rendering/XBitmap.hpp>
+#ifndef _COM_SUN_STAR_RENDERING_XBITMAP_HPP__
+#include <com/sun/star/rendering/XBitmap.hpp>
 #endif
-#ifndef _DRAFTS_COM_SUN_STAR_RENDERING_XPOLYPOLYGON2D_HPP__
-#include <drafts/com/sun/star/rendering/XPolyPolygon2D.hpp>
+#ifndef _COM_SUN_STAR_RENDERING_XPOLYPOLYGON2D_HPP__
+#include <com/sun/star/rendering/XPolyPolygon2D.hpp>
 #endif
-#ifndef _DRAFTS_COM_SUN_STAR_GEOMETRY_REALBEZIERSEGMENT2D_HPP__
-#include <drafts/com/sun/star/geometry/RealBezierSegment2D.hpp>
+#ifndef _COM_SUN_STAR_GEOMETRY_REALBEZIERSEGMENT2D_HPP__
+#include <com/sun/star/geometry/RealBezierSegment2D.hpp>
 #endif
-#ifndef _DRAFTS_COM_SUN_STAR_RENDERING_INTEGERBITMAPFORMAT_HPP__
-#include <drafts/com/sun/star/rendering/IntegerBitmapFormat.hpp>
+#ifndef _COM_SUN_STAR_RENDERING_INTEGERBITMAPFORMAT_HPP__
+#include <com/sun/star/rendering/IntegerBitmapFormat.hpp>
 #endif
-#ifndef _DRAFTS_COM_SUN_STAR_RENDERING_ENDIANNESS_HPP__
-#include <drafts/com/sun/star/rendering/Endianness.hpp>
+#ifndef _COM_SUN_STAR_RENDERING_ENDIANNESS_HPP__
+#include <com/sun/star/rendering/Endianness.hpp>
 #endif
-#ifndef _DRAFTS_COM_SUN_STAR_RENDERING_XINTEGERBITMAP_HPP__
-#include <drafts/com/sun/star/rendering/XIntegerBitmap.hpp>
+#ifndef _COM_SUN_STAR_RENDERING_XINTEGERBITMAP_HPP__
+#include <com/sun/star/rendering/XIntegerBitmap.hpp>
 #endif
 
 #ifndef _BGFX_MATRIX_B2DHOMMATRIX_HXX
@@ -127,15 +127,16 @@
 #endif
 
 #include <tools/poly.hxx>
+#include <rtl/uuid.h>
 
 #include <salbtype.hxx>
 #include <bmpacc.hxx>
 #include <bitmapex.hxx>
 
+#include <canvasbitmap.hxx>
 #include <canvastools.hxx>
 
 
-using namespace ::drafts::com::sun::star;
 using namespace ::com::sun::star;
 
 namespace vcl
@@ -165,18 +166,18 @@
                 uno::Sequence< geometry::RealBezierSegment2D > outputSequence( nCurrSize );
 
                 // fill sequence from polygon
-                i=0; 
+                i=0;
                 int nOutPos=0;
                 while( i<nCurrSize )
                 {
                     DBG_ASSERT( nCurrSize > nOutPos,
                                 "bezierSequenceFromPolygon(): output size calculated incorrectly");
-                    
+
                     if( i+2 < nCurrSize )
                     {
                         // we have at least two more point to process
                         // - control points allowed here
-                        
+
                         if( inputPolygon.GetFlags(i) != POLY_CONTROL &&
                             inputPolygon.GetFlags(i+1) == POLY_CONTROL &&
                             inputPolygon.GetFlags(i+2) == POLY_CONTROL )
@@ -195,9 +196,9 @@
                             // no bezier segment at all - add
                             // degenerated bezier point (i.e. straight line)
                             outputSequence[nOutPos++] = geometry::RealBezierSegment2D( inputPolygon[i].X(),
-                                                                                       inputPolygon[i].Y(), 
+                                                                                       inputPolygon[i].Y(),
                                                                                        inputPolygon[i].X(),
-                                                                                       inputPolygon[i].Y(), 
+                                                                                       inputPolygon[i].Y(),
                                                                                        inputPolygon[i].X(),
                                                                                        inputPolygon[i].Y() );
                             i += 1;
@@ -207,15 +208,15 @@
                     {
                         DBG_ASSERT( inputPolygon.GetFlags(i) != POLY_CONTROL,
                                     "bezierSequenceFromPolygon(): Invalid point sequence in Polygon");
-                        
+
                         // can't have any bezier segments here
                         // (not enough points left) - add
                         // degenerated bezier point (i.e. straight
                         // line)
                         outputSequence[nOutPos++] = geometry::RealBezierSegment2D( inputPolygon[i].X(),
-                                                                                   inputPolygon[i].Y(), 
+                                                                                   inputPolygon[i].Y(),
                                                                                    inputPolygon[i].X(),
-                                                                                   inputPolygon[i].Y(), 
+                                                                                   inputPolygon[i].Y(),
                                                                                    inputPolygon[i].X(),
                                                                                    inputPolygon[i].Y() );
                         i += 1;
@@ -226,9 +227,9 @@
                         // allowed any more
                         DBG_ASSERT( inputPolygon.GetFlags(i) != POLY_CONTROL,
                                     "bezierSequenceFromPolygon(): Invalid point sequence in Polygon");
-                        
+
                         outputSequence[nOutPos++] = geometry::RealBezierSegment2D( inputPolygon[i].X(),
-                                                                                   inputPolygon[i].Y(), 
+                                                                                   inputPolygon[i].Y(),
                                                                                    0.0, 0.0,
                                                                                    0.0, 0.0 );
                         i += 1;
@@ -273,8 +274,8 @@
             {
                 uno::Sequence< uno::Sequence< geometry::RealBezierSegment2D > > outputSequence( 1 );
                 outputSequence[0] = bezierSequenceFromPolygon( inputPolygon );
-                
-                return uno::Reference< rendering::XPolyPolygon2D >( 
+
+                return uno::Reference< rendering::XPolyPolygon2D >(
                     xGraphicDevice->createCompatibleBezierPolyPolygon( outputSequence ),
                     uno::UNO_QUERY );
             }
@@ -283,7 +284,7 @@
                 uno::Sequence< uno::Sequence< geometry::RealPoint2D > > outputSequence( 1 );
                 outputSequence[0] = pointSequenceFromPolygon( inputPolygon );
 
-                return uno::Reference< rendering::XPolyPolygon2D >( 
+                return uno::Reference< rendering::XPolyPolygon2D >(
                     xGraphicDevice->createCompatibleLinePolyPolygon( outputSequence ),
                     uno::UNO_QUERY );
             }
@@ -322,7 +323,7 @@
                     outputSequence[i] = bezierSequenceFromPolygon( inputPolyPolygon[i] );
                 }
 
-                return uno::Reference< rendering::XPolyPolygon2D >( 
+                return uno::Reference< rendering::XPolyPolygon2D >(
                     xGraphicDevice->createCompatibleBezierPolyPolygon( outputSequence ),
                     uno::UNO_QUERY );
             }
@@ -335,7 +336,7 @@
                     outputSequence[i] = pointSequenceFromPolygon( inputPolyPolygon[i] );
                 }
 
-                return uno::Reference< rendering::XPolyPolygon2D >( 
+                return uno::Reference< rendering::XPolyPolygon2D >(
                     xGraphicDevice->createCompatibleLinePolyPolygon( outputSequence ),
                     uno::UNO_QUERY );
             }
@@ -457,153 +458,7 @@
         {
             RTL_LOGFILE_CONTEXT( aLog, "::vcl::unotools::xBitmapFromBitmap()" );
 
-            if( !xGraphicDevice.is() )
-                return uno::Reference< rendering::XBitmap >();
-
-            const Size aPixelSize( inputBitmap.GetSizePixel() );
-
-            uno::Reference< rendering::XBitmap > 
-                xBitmap( xGraphicDevice->createCompatibleBitmap( 
-                             integerSize2DFromSize( aPixelSize ) ) );
-
-            uno::Reference< rendering::XIntegerBitmap >
-                xIntegerBitmap( xBitmap, 
-                                uno::UNO_QUERY );
-
-            ::Bitmap copyOfInputBitmap( inputBitmap );
-            ScopedBitmapReadAccess pAcc( copyOfInputBitmap.AcquireReadAccess(),
-                                         copyOfInputBitmap );
-
-            const int nPixel( aPixelSize.Width() * aPixelSize.Height() );
-            uno::Sequence< sal_Int8 > bmpData( nPixel*4 );
-
-            // TODO: can we handle this more generically? 
-            // arrayToSequence comes to mind, or other templatized
-            // algos.
-            // TODO: handle the other types here!
-            // TODO: handle bitmap layout, too!
-            if( pAcc.get() && 
-                xIntegerBitmap.is() )
-            {
-                BitmapColor	aCol;
-
-                // read from bitmap
-                // =======================
-
-                int x, y, i;
-                for( y=0, i=0; y<aPixelSize.Height(); ++y )
-                {
-                    switch( pAcc->GetScanlineFormat() )
-                    {
-                        case BMP_FORMAT_8BIT_PAL:
-                        {
-                            Scanline pScan = pAcc->GetScanline( y );
-
-                            for( x=0; x<aPixelSize.Width(); ++x )
-                            {
-                                aCol = pAcc->GetPaletteColor( pScan[x] );
-                        
-                                // store as RGBA
-                                // TODO: differentiate between alpha and non-alpha
-                                // bitmaps. Maybe we even need a 
-                                // createCompatibleAlphaBitmap on the XGraphicDevice
-                                bmpData[i++] = aCol.GetBlue();
-                                bmpData[i++] = aCol.GetGreen();
-                                bmpData[i++] = aCol.GetRed();
-                                bmpData[i++] = static_cast<sal_uInt8>(255);
-                            }
-                        }
-                        break;
-
-                        case BMP_FORMAT_24BIT_TC_BGR:
-                        {
-                            Scanline pScan = pAcc->GetScanline( y );
-
-                            for( x=0; x<aPixelSize.Width(); ++x )
-                            {
-                                Scanline pTmp = pScan + x * 3;
-
-                                // store as RGBA
-                                // TODO: differentiate between alpha and non-alpha
-                                // bitmaps. Maybe we even need a 
-                                // createCompatibleAlphaBitmap on the XGraphicDevice
-                                bmpData[i++] = pTmp[ 0 ];
-                                bmpData[i++] = pTmp[ 1 ];
-                                bmpData[i++] = pTmp[ 2 ];
-                                bmpData[i++] = static_cast<sal_uInt8>(255);
-                            }
-                        }
-                        break;
-
-                        case BMP_FORMAT_24BIT_TC_RGB:
-                        {
-                            Scanline pScan = pAcc->GetScanline( y );
-
-                            for( x=0; x<aPixelSize.Width(); ++x )
-                            {
-                                Scanline pTmp = pScan + x * 3;
-
-                                // store as RGBA
-                                // TODO: differentiate between alpha and non-alpha
-                                // bitmaps. Maybe we even need a 
-                                // createCompatibleAlphaBitmap on the XGraphicDevice
-                                bmpData[i++] = pTmp[ 2 ];
-                                bmpData[i++] = pTmp[ 1 ];
-                                bmpData[i++] = pTmp[ 0 ];
-                                bmpData[i++] = static_cast<sal_uInt8>(255);
-                            }
-                        }
-                        break;
-
-                        default:
-                        {
-                            for( x=0; x<aPixelSize.Width(); ++x )
-                            {
-                                // yes. x and y are swapped on Get/SetPixel
-                                aCol = pAcc->GetColor(y,x);                            
-                        
-                                // store as RGBA
-                                // TODO: differentiate between alpha and non-alpha
-                                // bitmaps. Maybe we even need a 
-                                // createCompatibleAlphaBitmap on the XGraphicDevice
-                                bmpData[i++] = aCol.GetBlue();
-                                bmpData[i++] = aCol.GetGreen();
-                                bmpData[i++] = aCol.GetRed();
-                                bmpData[i++] = static_cast<sal_uInt8>(255);
-                            }
-                        }
-                        break;
-                    }
-                }
-            }
-
-            // TODO(P2): Completely avoid alpha channel for plain
-            // bitmaps here!
-            uno::Sequence< sal_Int64 > aComponentMask(4);
-            aComponentMask[0] = 0x0000FF00;
-            aComponentMask[1] = 0x00FF0000;
-            aComponentMask[2] = 0xFF000000;
-            aComponentMask[3] = 0x000000FF;
-
-            rendering::IntegerBitmapLayout aMemLayout(
-                aPixelSize.Height(),
-                4*aPixelSize.Width(),
-                4*aPixelSize.Width(),
-                0,
-                4,
-                aComponentMask,
-                rendering::Endianness::LITTLE,
-                rendering::IntegerBitmapFormat::CHUNKY_32BIT,
-                sal_False );
-
-            xIntegerBitmap->setData( bmpData, 
-                                     aMemLayout,
-                                     geometry::IntegerRectangle2D(0,0,
-                                                                  aPixelSize.Width(),
-                                                                  aPixelSize.Height()) );
-
-            return uno::Reference< rendering::XBitmap >( xIntegerBitmap,
-                                                         uno::UNO_QUERY );
+            return new vcl::unotools::VclCanvasBitmap( BitmapEx( inputBitmap ) );
         }
 
         //---------------------------------------------------------------------------------------
@@ -613,277 +468,24 @@
         {
             RTL_LOGFILE_CONTEXT( aLog, "::vcl::unotools::xBitmapFromBitmapEx()" );
 
-            // if bitmapex is not transparent: revert to plain bitmap
-            // method
-            if( !inputBitmap.IsTransparent() )
-                return xBitmapFromBitmap( xGraphicDevice,
-                                          inputBitmap.GetBitmap() );
-
-            if( !xGraphicDevice.is() )
-                return uno::Reference< rendering::XBitmap >();
+            return new vcl::unotools::VclCanvasBitmap( inputBitmap );
+        }
 
-            const Size aPixelSize( inputBitmap.GetSizePixel() );
+        //---------------------------------------------------------------------------------------
 
-            uno::Reference< rendering::XBitmap > 
-                xBitmap( xGraphicDevice->createCompatibleAlphaBitmap( 
-                             integerSize2DFromSize( aPixelSize ) ) );
-
-            uno::Reference< rendering::XIntegerBitmap >
-                xIntegerBitmap( xBitmap, 
-                                uno::UNO_QUERY );
-
-            Bitmap aBitmap( inputBitmap.GetBitmap() );
-            ScopedBitmapReadAccess pAcc( aBitmap.AcquireReadAccess(),
-                                         aBitmap );
-
-            const int nPixel( aPixelSize.Width() * aPixelSize.Height() );
-            uno::Sequence< sal_Int8 > bmpData( nPixel*4 );
-
-            // TODO: can we handle this more generically? 
-            // arrayToSequence comes to mind, or other templatized
-            // algos.
-            // TODO: handle the other types here!
-            // TODO: handle bitmap layout, too!
-            if( pAcc.get() && 
-                xIntegerBitmap.is() )
+        const uno::Sequence< sal_Int8 > getTunnelIdentifier( TunnelIdentifierType eType )
+        {
+            static std::hash_map< int, uno::Sequence< sal_Int8 > > aIds;
+            std::hash_map< int, uno::Sequence< sal_Int8 > >::iterator it =
+                aIds.find( eType );
+            if( it == aIds.end() )
             {
-                BitmapColor	aCol;
-
-                if( inputBitmap.IsTransparent() )
-                {
-                    if( inputBitmap.IsAlpha() )
-                    {
-                        // read from alpha bitmap
-                        // ======================
-
-                        Bitmap aAlpha( inputBitmap.GetAlpha().GetBitmap() );
-                        ScopedBitmapReadAccess pAlphaAcc( aAlpha.AcquireReadAccess(),
-                                                          aAlpha );
-
-                        DBG_ASSERT( pAlphaAcc->GetScanlineFormat() == BMP_FORMAT_8BIT_PAL ||
-                                    pAlphaAcc->GetScanlineFormat() == BMP_FORMAT_8BIT_TC_MASK, 
-                                    "::vcl::unotools::xBitmapFromBitmapEx(): non-8bit alpha not supported!" );
-
-                        if( pAlphaAcc.get() )
-                        {
-                            int x, y, i;
-                            for( y=0, i=0; y<aPixelSize.Height(); ++y )
-                            {
-                                switch( pAcc->GetScanlineFormat() )
-                                {
-                                    case BMP_FORMAT_8BIT_PAL:
-                                    {
-                                        Scanline pScan  = pAcc->GetScanline( y );
-                                        Scanline pAScan = pAlphaAcc->GetScanline( y );
-
-                                        for( x=0; x<aPixelSize.Width(); ++x )
-                                        {
-                                            aCol = pAcc->GetPaletteColor( pScan[x] );
-
-                                            bmpData[i++] = aCol.GetBlue();
-                                            bmpData[i++] = aCol.GetGreen();
-                                            bmpData[i++] = aCol.GetRed();
-
-                                            // out notion of alpha is different from the rest of the world's
-                                            bmpData[i++] = 255 - (BYTE)pAScan[x];
-                                        }
-                                    }
-                                    break;
-
-                                    case BMP_FORMAT_24BIT_TC_BGR:
-                                    {
-                                        Scanline pScan  = pAcc->GetScanline( y );
-                                        Scanline pAScan = pAlphaAcc->GetScanline( y );
-
-                                        for( x=0; x<aPixelSize.Width(); ++x )
-                                        {
-                                            Scanline pTmp = pScan + x * 3;
-
-                                            // store as RGBA
-                                            bmpData[i++] = pTmp[ 0 ];
-                                            bmpData[i++] = pTmp[ 1 ];
-                                            bmpData[i++] = pTmp[ 2 ];
-
-                                            // out notion of alpha is different from the rest of the world's
-                                            bmpData[i++] = 255 - (BYTE)pAScan[x];
-                                        }
-                                    }
-                                    break;
-
-                                    case BMP_FORMAT_24BIT_TC_RGB:
-                                    {
-                                        Scanline pScan  = pAcc->GetScanline( y );
-                                        Scanline pAScan = pAlphaAcc->GetScanline( y );
-
-                                        for( x=0; x<aPixelSize.Width(); ++x )
-                                        {
-                                            Scanline pTmp = pScan + x * 3;
-
-                                            // store as RGBA
-                                            bmpData[i++] = pTmp[ 2 ];
-                                            bmpData[i++] = pTmp[ 1 ];
-                                            bmpData[i++] = pTmp[ 0 ];
-
-                                            // out notion of alpha is different from the rest of the world's
-                                            bmpData[i++] = 255 - (BYTE)pAScan[x];
-                                        }
-                                    }
-                                    break;
-
-                                    default:
-                                    {
-                                        for( x=0; x<aPixelSize.Width(); ++x )
-                                        {
-                                            // yes. x and y are swapped on Get/SetPixel
-                                            aCol = pAcc->GetColor(y,x);
-
-                                            bmpData[i++] = aCol.GetBlue();
-                                            bmpData[i++] = aCol.GetGreen();
-                                            bmpData[i++] = aCol.GetRed();
-
-                                            // out notion of alpha is different from the rest of the world's
-                                            bmpData[i++] = 255 - (BYTE)pAlphaAcc->GetPixel(y,x);
-                                        }
-                                    }
-                                    break;
-                                }
-                            }
-                        }
-                    }
-                    else
-                    {
-                        // read from masked bitmap
-                        // =======================
-
-                        Bitmap aMask( inputBitmap.GetMask() );
-                        ScopedBitmapReadAccess pMaskAcc( aMask.AcquireReadAccess(),
-                                                         aMask );
-
-                        if( pMaskAcc.get() )
-                        {
-                            DBG_ASSERT( pMaskAcc->GetScanlineFormat() == BMP_FORMAT_1BIT_MSB_PAL ||
-                                        pMaskAcc->GetScanlineFormat() == BMP_FORMAT_1BIT_LSB_PAL, 
-                                        "::vcl::unotools::xBitmapFromBitmapEx(): non-1bit masks not supported!" );
-
-                            const int nBitIncrement( 
-                                pMaskAcc->GetScanlineFormat() == BMP_FORMAT_1BIT_MSB_PAL ? -1 : 1 );
-                            const int nInitialBit( 
-                                pMaskAcc->GetScanlineFormat() == BMP_FORMAT_1BIT_MSB_PAL ? 7 : 0 );
-
-                            int x, y, i, nCurrBit, nMask;
-                            for( y=0, i=0; y<aPixelSize.Height(); ++y )
-                            {
-                                switch( pAcc->GetScanlineFormat() )
-                                {
-                                    case BMP_FORMAT_8BIT_PAL:
-                                    {
-                                        Scanline pScan  = pAcc->GetScanline( y );
-                                        Scanline pMScan = pMaskAcc->GetScanline( y );
-
-                                        for( x=0, nCurrBit=nInitialBit; x<aPixelSize.Width(); ++x )
-                                        {
-                                            aCol = pAcc->GetPaletteColor( pScan[x] );
-
-                                            bmpData[i++] = aCol.GetBlue();
-                                            bmpData[i++] = aCol.GetGreen();
-                                            bmpData[i++] = aCol.GetRed();
-
-                                            nMask = 1L << nCurrBit;
-                                            bmpData[i++] = (1 - (pMScan[ (x & ~7L) >> 3L ] & nMask) / nMask) * 255;
-                                            nCurrBit = ((nCurrBit + nBitIncrement) % 8L) & 7L;
-                                        }
-                                    }
-                                    break;
-
-                                    case BMP_FORMAT_24BIT_TC_BGR:
-                                    {
-                                        Scanline pScan  = pAcc->GetScanline( y );
-                                        Scanline pMScan = pMaskAcc->GetScanline( y );
-
-                                        for( x=0, nCurrBit=nInitialBit; x<aPixelSize.Width(); ++x )
-                                        {
-                                            Scanline pTmp = pScan + x * 3;
-
-                                            // store as RGBA
-                                            bmpData[i++] = pTmp[ 0 ];
-                                            bmpData[i++] = pTmp[ 1 ];
-                                            bmpData[i++] = pTmp[ 2 ];
-
-                                            nMask = 1L << nCurrBit;
-                                            bmpData[i++] = (1 - (pMScan[ (x & ~7L) >> 3L ] & nMask) / nMask) * 255;
-                                            nCurrBit = ((nCurrBit + nBitIncrement) % 8L) & 7L;
-                                        }
-                                    }
-                                    break;
-
-                                    case BMP_FORMAT_24BIT_TC_RGB:
-                                    {
-                                        Scanline pScan  = pAcc->GetScanline( y );
-                                        Scanline pMScan = pMaskAcc->GetScanline( y );
-
-                                        for( x=0, nCurrBit=nInitialBit; x<aPixelSize.Width(); ++x )
-                                        {
-                                            Scanline pTmp = pScan + x * 3;
-
-                                            // store as RGBA
-                                            bmpData[i++] = pTmp[ 2 ];
-                                            bmpData[i++] = pTmp[ 1 ];
-                                            bmpData[i++] = pTmp[ 0 ];
-
-                                            nMask = 1L << nCurrBit;
-                                            bmpData[i++] = (1 - (pMScan[ (x & ~7L) >> 3L ] & nMask) / nMask) * 255;
-                                            nCurrBit = ((nCurrBit + nBitIncrement) % 8L) & 7L;
-                                        }
-                                    }
-                                    break;
-
-                                    default:
-                                    {
-                                        for( x=0; x<aPixelSize.Width(); ++x )
-                                        {
-                                            // yes. x and y are swapped on Get/SetPixel
-                                            aCol = pAcc->GetColor(y,x);                            
-
-                                            // store as RGBA
-                                            bmpData[i++] = aCol.GetBlue();
-                                            bmpData[i++] = aCol.GetGreen();
-                                            bmpData[i++] = aCol.GetRed();
-                                            bmpData[i++] = ((BYTE)pMaskAcc->GetPixel(y,x)) ? 0 : 255;
-                                        }
-                                    }
-                                    break;
-                                }
-                            }
-                        }
-                    }
-                }
+                uno::Sequence< sal_Int8 > aNewId( 16 );
+                rtl_createUuid( (sal_uInt8*)aNewId.getArray(), NULL, sal_True );
+                aIds[ eType ] = aNewId;
+                it = aIds.find( eType );
             }
-
-            uno::Sequence< sal_Int64 > aComponentMask(4);
-            aComponentMask[0] = 0x0000FF00;
-            aComponentMask[1] = 0x00FF0000;
-            aComponentMask[2] = 0xFF000000;
-            aComponentMask[3] = 0x000000FF;
-
-            rendering::IntegerBitmapLayout aMemLayout(
-                aPixelSize.Height(),
-                4*aPixelSize.Width(),
-                4*aPixelSize.Width(),
-                0,
-                4,
-                aComponentMask,
-                rendering::Endianness::LITTLE,
-                rendering::IntegerBitmapFormat::CHUNKY_32BIT,
-                sal_False );
-
-            xIntegerBitmap->setData( bmpData, 
-                                     aMemLayout,
-                                     geometry::IntegerRectangle2D(0,0,
-                                                                  aPixelSize.Width(),
-                                                                  aPixelSize.Height()) );
-
-            return uno::Reference< rendering::XBitmap >( xIntegerBitmap, 
-                                                         uno::UNO_QUERY );
+            return it->second;
         }
 
         //---------------------------------------------------------------------------------------
@@ -896,8 +498,19 @@
             if( !xGraphicDevice.is() || !xInputBitmap.is() )
                 return ::BitmapEx();
 
+            uno::Reference< lang::XUnoTunnel > xTunnel( xInputBitmap, uno::UNO_QUERY );
+            if( xTunnel.is() )
+            {
+                const uno::Sequence< sal_Int8 >& rTest = getTunnelIdentifier( Id_BitmapEx );
+                sal_Int64 nPtr = xTunnel->getSomething( rTest );
+                if( nPtr != 0 )
+                {
+                    return BitmapEx( *(BitmapEx*)nPtr );
+                }
+            }
+
             const Size aPixelSize( sizeFromIntegerSize2D( xInputBitmap->getSize() ) );
-            const uno::Sequence< sal_Int8 > data( xInputBitmap->getData( 
+            const uno::Sequence< sal_Int8 > data( xInputBitmap->getData(
                                                       geometry::IntegerRectangle2D(0,0,aPixelSize.Width(),aPixelSize.Height()) ) );
 
             ::Bitmap aBitmap( aPixelSize, 24 ); // create 24bpp Bitmap
@@ -908,11 +521,11 @@
                                                       aBitmap );
                 ScopedBitmapWriteAccess pAlphaWriteAccess( aAlpha.AcquireWriteAccess(),
                                                            aAlpha );
-            
+
                 if( pWriteAccess.get() != NULL &&
                     pAlphaWriteAccess.get() != NULL )
                 {
-                    // for the time being, always read as BGRA 
+                    // for the time being, always read as BGRA
                     int nCurrPos(0);
                     for( int y=0; y<aPixelSize.Height(); ++y )
                     {
@@ -929,7 +542,7 @@
                 }
             }
 
-            return ::BitmapEx( aBitmap, 
+            return ::BitmapEx( aBitmap,
                                AlphaMask( aAlpha ) );
         }
 
@@ -1013,51 +626,51 @@
 
         geometry::RealSize2D size2DFromSize( const Size& rSize )
         {
-            return geometry::RealSize2D( rSize.Width(), 
-                                         rSize.Height() ); 
+            return geometry::RealSize2D( rSize.Width(),
+                                         rSize.Height() );
         }
 
         geometry::RealPoint2D point2DFromPoint( const Point& rPoint )
         {
-            return geometry::RealPoint2D( rPoint.X(), 
+            return geometry::RealPoint2D( rPoint.X(),
                                           rPoint.Y() );
         }
 
         geometry::RealRectangle2D rectangle2DFromRectangle( const Rectangle& rRect )
         {
-            return geometry::RealRectangle2D( rRect.Left(), rRect.Top(), 
+            return geometry::RealRectangle2D( rRect.Left(), rRect.Top(),
                                               rRect.Right(), rRect.Bottom() );
         }
 
         Size sizeFromRealSize2D( const geometry::RealSize2D& rSize )
         {
-            return Size( static_cast<long>(rSize.Width + .5), 
+            return Size( static_cast<long>(rSize.Width + .5),
                          static_cast<long>(rSize.Height + .5) );
         }
 
         Point pointFromRealPoint2D( const geometry::RealPoint2D& rPoint )
         {
-            return Point( static_cast<long>(rPoint.X + .5), 
+            return Point( static_cast<long>(rPoint.X + .5),
                           static_cast<long>(rPoint.Y + .5) );
         }
 
         Rectangle rectangleFromRealRectangle2D( const geometry::RealRectangle2D& rRect )
         {
-            return Rectangle( static_cast<long>(rRect.X1 + .5), 
-                              static_cast<long>(rRect.Y1 + .5), 
-                              static_cast<long>(rRect.X2 + .5), 
+            return Rectangle( static_cast<long>(rRect.X1 + .5),
+                              static_cast<long>(rRect.Y1 + .5),
+                              static_cast<long>(rRect.X2 + .5),
                               static_cast<long>(rRect.Y2 + .5) );
         }
 
         ::Size sizeFromB2DSize( const ::basegfx::B2DVector& rVec )
         {
-            return ::Size( FRound( rVec.getX() ), 
+            return ::Size( FRound( rVec.getX() ),
                            FRound( rVec.getY() ) );
         }
 
         ::Point pointFromB2DPoint( const ::basegfx::B2DPoint& rPoint )
         {
-            return ::Point( FRound( rPoint.getX() ), 
+            return ::Point( FRound( rPoint.getX() ),
                             FRound( rPoint.getY() ) );
         }
 
@@ -1071,13 +684,13 @@
 
         ::basegfx::B2DVector b2DSizeFromSize( const ::Size& rSize )
         {
-            return ::basegfx::B2DVector( rSize.Width(), 
+            return ::basegfx::B2DVector( rSize.Width(),
                                          rSize.Height() );
         }
 
         ::basegfx::B2DPoint b2DPointFromPoint( const ::Point& rPoint )
         {
-            return ::basegfx::B2DPoint( rPoint.X(), 
+            return ::basegfx::B2DPoint( rPoint.X(),
                                         rPoint.Y() );
         }
 
@@ -1091,13 +704,13 @@
 
         geometry::IntegerSize2D integerSize2DFromSize( const Size& rSize )
         {
-            return geometry::IntegerSize2D( rSize.Width(), 
+            return geometry::IntegerSize2D( rSize.Width(),
                                             rSize.Height() );
         }
 
         geometry::IntegerPoint2D integerPoint2DFromPoint( const Point& rPoint )
         {
-            return geometry::IntegerPoint2D( rPoint.X(), 
+            return geometry::IntegerPoint2D( rPoint.X(),
                                              rPoint.Y() );
         }
 
@@ -1108,20 +721,20 @@
         }
 
         Size sizeFromIntegerSize2D( const geometry::IntegerSize2D& rSize )
-        { 
-            return Size( rSize.Width, 
-                         rSize.Height ); 
+        {
+            return Size( rSize.Width,
+                         rSize.Height );
         }
 
         Point pointFromIntegerPoint2D( const geometry::IntegerPoint2D& rPoint )
         {
-            return Point( rPoint.X, 
+            return Point( rPoint.X,
                           rPoint.Y );
         }
 
         Rectangle rectangleFromIntegerRectangle2D( const geometry::IntegerRectangle2D& rRectangle )
         {
-            return Rectangle( rRectangle.X1, rRectangle.Y1, 
+            return Rectangle( rRectangle.X1, rRectangle.Y1,
                               rRectangle.X2, rRectangle.Y2 );
         }
 
diff -u -r  vcl/source/helper/makefile.mk  vcl/source/helper/makefile.mk
---  vcl/source/helper/makefile.mk	2005-01-13 23:31:49.000000000 +0530
+++  vcl/source/helper/makefile.mk	2005-02-28 13:40:59.313619542 +0530
@@ -78,6 +78,7 @@
 
 SLOFILES=\
 	$(SLO)$/evntpost.obj		\
+    $(SLO)$/canvasbitmap.obj    \
 	$(SLO)$/canvastools.obj		\
 	$(SLO)$/xconnection.obj		\
 	$(SLO)$/threadex.obj		\
diff -u -r  vcl/source/helper/smartid.cxx  vcl/source/helper/smartid.cxx
---  vcl/source/helper/smartid.cxx	2004-09-09 21:50:30.000000000 +0530
+++  vcl/source/helper/smartid.cxx	2005-02-28 13:40:59.291622112 +0530
@@ -295,4 +295,4 @@
         else
             return rRight.HasString() || !HasNumeric() && rRight.HasNumeric();
     }
-}
\ No newline at end of file
+}
diff -u -r  vcl/source/window/window.cxx  vcl/source/window/window.cxx
---  vcl/source/window/window.cxx	2005-02-23 17:41:42.000000000 +0530
+++  vcl/source/window/window.cxx	2005-02-28 13:41:00.536476649 +0530
@@ -161,10 +161,10 @@
 #endif
 #include <com/sun/star/awt/XWindowPeer.hpp>
 
-#ifndef _DRAFTS_COM_SUN_STAR_RENDERING_XCANVAS_HPP_
-#include <drafts/com/sun/star/rendering/XCanvas.hpp>
-#endif
 #ifndef _COM_SUN_STAR_RENDERING_XCANVAS_HPP_
+#include <com/sun/star/rendering/XCanvas.hpp>
+#endif
+#ifndef _COM_SUN_STAR_AWT_XWINDOW_HPP_
 #include <com/sun/star/awt/XWindow.hpp>
 #endif
 #ifndef _COMPHELPER_PROCESSFACTORY_HXX_
@@ -741,7 +741,7 @@
     mpWindowImpl->mbDrawSelectionBackground = FALSE;    // TRUE: draws transparent window background to indicate (toolbox) selection
     mpWindowImpl->mbIsCanvasCreated	= FALSE;		    // TRUE: a canvas has been requested, thus, mxCanvasWindow must be
                                                         // checked for every pos or size change. Since mxCanvasWindow is
-                                                        // a weak reference, checking for validity is somewhat expensive, 
+                                                        // a weak reference, checking for validity is somewhat expensive,
                                                         // and is now guarded by this cheap bool check.
 
     mbEnableRTL         = TRUE;         // TRUE: this outdev will be mirrored if RTL window layout (UI mirroring) is globally active
@@ -809,12 +809,12 @@
             nFrameStyle |= SAL_FRAME_STYLE_DEFAULT;
         // check for undecorated floating window
         if( // 1. floating windows that are not moveable/sizeable (only closeable allowed)
-            ( !(nFrameStyle & ~SAL_FRAME_STYLE_CLOSEABLE) && 
+            ( !(nFrameStyle & ~SAL_FRAME_STYLE_CLOSEABLE) &&
             ( mpWindowImpl->mbFloatWin || ((GetType() == WINDOW_BORDERWINDOW) && ((ImplBorderWindow*)this)->mbFloatWindow) || (nStyle & WB_SYSTEMFLOATWIN) ) ) ||
             // 2. borderwindows of floaters with ownerdraw decoration
             ( ((GetType() == WINDOW_BORDERWINDOW) && ((ImplBorderWindow*)this)->mbFloatWindow && (nStyle & WB_OWNERDRAWDECORATION) ) ) )
         {
-            nFrameStyle = SAL_FRAME_STYLE_FLOAT; 
+            nFrameStyle = SAL_FRAME_STYLE_FLOAT;
             if( nStyle & WB_OWNERDRAWDECORATION )
                 nFrameStyle |= (SAL_FRAME_STYLE_OWNERDRAWDECORATION | SAL_FRAME_STYLE_NOSHADOW);
         }
@@ -1207,7 +1209,7 @@
     DBG_ASSERT( pResMgr, "No res mgr for auto help id" );
     if( ! pResMgr )
         return 0;
-  
+
     nHID = pResMgr->GetAutoHelpId();
 
     return nHID;
@@ -2566,7 +2568,7 @@
         mpWindowImpl->maInvalidateRegion.Union( *pRegion );
 
     // Handle transparent windows correctly: invalidate must be done on the first opaque parent
-    if( ((IsPaintTransparent() && !(nFlags & INVALIDATE_NOTRANSPARENT)) || (nFlags & INVALIDATE_TRANSPARENT) ) 
+    if( ((IsPaintTransparent() && !(nFlags & INVALIDATE_NOTRANSPARENT)) || (nFlags & INVALIDATE_TRANSPARENT) )
             && ImplGetParent() )
     {
         /* The following optimization shows problems when resizing (native) tabcontrols (eg the Help viewer)
@@ -4242,7 +4244,7 @@
 
 // -----------------------------------------------------------------------
 
-Window::Window( WindowType nType ) 
+Window::Window( WindowType nType )
 {
     DBG_CTOR( Window, ImplDbgCheckWindow );
 
@@ -4284,7 +4286,7 @@
 
     // Dispose of the canvas implementation (which, currently, has an
     // own wrapper window as a child to this one.
-    Reference< ::drafts::com::sun::star::rendering::XCanvas >  xCanvas( mpWindowImpl->mxCanvas );
+    Reference< ::com::sun::star::rendering::XCanvas >  xCanvas( mpWindowImpl->mxCanvas );
     if( xCanvas.is() )
     {
         ::com::sun::star::uno::Reference < ::com::sun::star::lang::XComponent >
@@ -4895,7 +4897,7 @@
                 case STATE_CHANGE_VISIBLE:
                     xCanvasWindow->setVisible( mpWindowImpl->mbVisible );
                     break;
-                    
+
                 case STATE_CHANGE_ENABLE:
                     xCanvasWindow->setEnable( !mpWindowImpl->mbDisabled );
                     break;
@@ -5579,7 +5581,7 @@
 
     // transparency is not useful for frames as the background would have to be provided by a different frame
     if( bTransparent && mpWindowImpl->mbFrame )
-        return; 
+        return;
 
     if ( mpWindowImpl->mpBorderWindow )
         mpWindowImpl->mpBorderWindow->SetPaintTransparent( bTransparent );
@@ -9025,10 +9027,10 @@
     return ImplGetWinData()->mbEnableNativeWidget;
 }
 
-Reference< ::drafts::com::sun::star::rendering::XCanvas > Window::GetCanvas() const
+Reference< ::com::sun::star::rendering::XCanvas > Window::GetCanvas() const
 {
     // try to retrieve hard reference from weak member
-    Reference< ::drafts::com::sun::star::rendering::XCanvas >  xCanvas( mpWindowImpl->mxCanvas );
+    Reference< ::com::sun::star::rendering::XCanvas >  xCanvas( mpWindowImpl->mxCanvas );
 
     // canvas still valid? Then we're done.
     if( xCanvas.is() )
@@ -9088,7 +9090,7 @@
         Reference<lang::XMultiServiceFactory> xCanvasFactory(
             xFactory->createInstance(
                 OUString( RTL_CONSTASCII_USTRINGPARAM(
-                              "drafts.com.sun.star."
+                              "com.sun.star."
                               "rendering.CanvasFactory") ) ), UNO_QUERY );
         if (xCanvasFactory.is()) {
             xCanvas.set( xCanvasFactory->createInstanceWithArguments(
@@ -9096,7 +9098,7 @@
                          UNO_QUERY );
 
             mpWindowImpl->mxCanvas = xCanvas;
- 
+
             // now, try to retrieve an XWindow interface from the canvas
             // (this is an implementation detail of the Java interface,
             // which might vanish without notice).
@@ -9120,10 +9122,10 @@
     return xCanvas;
 }
 
-Reference< ::drafts::com::sun::star::rendering::XCanvas > Window::GetFullscreenCanvas( const Size& rFullscreenSize ) const
+Reference< ::com::sun::star::rendering::XCanvas > Window::GetFullscreenCanvas( const Size& rFullscreenSize ) const
 {
     // try to retrieve hard reference from weak member
-    Reference< ::drafts::com::sun::star::rendering::XCanvas >  xCanvas( mpWindowImpl->mxCanvas );
+    Reference< ::com::sun::star::rendering::XCanvas >  xCanvas( mpWindowImpl->mxCanvas );
 
     // canvas still valid? Then we're done.
     if( xCanvas.is() )
@@ -9185,7 +9187,7 @@
         Reference<lang::XMultiServiceFactory> xCanvasFactory(
             xFactory->createInstance(
                 OUString( RTL_CONSTASCII_USTRINGPARAM(
-                              "drafts.com.sun.star."
+                              "com.sun.star."
                               "rendering.CanvasFactory") ) ), UNO_QUERY );
         if (xCanvasFactory.is()) {
             xCanvas.set( xCanvasFactory->createInstanceWithArguments(
@@ -9193,7 +9195,7 @@
                          UNO_QUERY );
 
             mpWindowImpl->mxCanvas = xCanvas;
- 
+
             // now, try to retrieve an XWindow interface from the canvas
             // (this is an implementation detail of the Java interface,
             // which might vanish without notice).
@@ -9223,11 +9225,11 @@
     mpWindowImpl->mbReallyVisible = mpWindowImpl->mbVisible;
     BOOL bDevOutput = mbDevOutput;
     mbDevOutput = TRUE;
-    
+
     BOOL bOutput = IsOutputEnabled();
-    EnableOutput();    
-    
-    DBG_ASSERT( GetMapMode().GetMapUnit() == MAP_PIXEL, "MapMode must be PIXEL based" ); 
+    EnableOutput();
+
+    DBG_ASSERT( GetMapMode().GetMapUnit() == MAP_PIXEL, "MapMode must be PIXEL based" );
 
     // preserve graphicsstate
     Push();
@@ -9237,8 +9239,8 @@
     GDIMetaFile* pOldMtf = GetConnectMetaFile();
     pMtf->WindEnd();
     SetConnectMetaFile( pMtf );
-    
-    // put a push action to metafile 
+
+    // put a push action to metafile
     Push();
     // copy graphics state to metafile
     SetFont( GetFont() );
@@ -9282,7 +9284,7 @@
     Paint( aPaintRect );
     // put a pop action to metafile
     Pop();
-    
+
     SetConnectMetaFile( pOldMtf );
     EnableOutput( bOutput );
     mpWindowImpl->mbReallyVisible = bRVisible;
@@ -9362,17 +9364,17 @@
         ImplPaintToMetaFile( &aMF );
 
     mpWindowImpl->mbVisible = bVisible;
-    
+
     if( pRealParent )
         SetParent( pRealParent );
-    
+
     pDev->Push();
     pDev->SetMapMode();
 
     aMF.Move( aPos.X(), aPos.Y() );
     aMF.WindStart();
     aMF.Play( pDev );
-    
+
     pDev->Pop();
 }
 
diff -u -r  vcl/unx/dummy/dbmp.cxx  vcl/unx/dummy/dbmp.cxx
---  vcl/unx/dummy/dbmp.cxx	2004-02-20 14:22:40.000000000 +0530
+++  vcl/unx/dummy/dbmp.cxx	2005-02-28 13:40:53.000000000 +0530
@@ -224,3 +224,9 @@
 {
 }
 
+// -----------------------------------------------------------------------------
+
+bool DummyBitmap::GetSystemData( BitmapSystemData& rData )
+{
+    return false;
+}
diff -u -r  vcl/unx/dummy/dbmp.hxx  vcl/unx/dummy/dbmp.hxx
---  vcl/unx/dummy/dbmp.hxx	2004-02-20 14:22:50.000000000 +0530
+++  vcl/unx/dummy/dbmp.hxx	2005-02-28 13:40:53.000000000 +0530
@@ -104,6 +104,7 @@
 						
 	virtual BitmapBuffer*	AcquireBuffer( bool bReadOnly );
 	virtual void			ReleaseBuffer( BitmapBuffer* pBuffer, bool bReadOnly );
+    virtual bool            GetSystemData( BitmapSystemData& );
 };
 
 #endif // _SV_DBMP_HXX
diff -u -r  vcl/unx/inc/salbmp.h  vcl/unx/inc/salbmp.h
---  vcl/unx/inc/salbmp.h	2005-01-24 15:15:40.000000000 +0530
+++  vcl/unx/inc/salbmp.h	2005-02-28 13:40:53.000000000 +0530
@@ -163,6 +163,7 @@
 						
 	virtual BitmapBuffer*	AcquireBuffer( bool bReadOnly );
 	virtual void			ReleaseBuffer( BitmapBuffer* pBuffer, bool bReadOnly );
+    virtual bool            GetSystemData( BitmapSystemData& rData );
 };
 
 // --------------
diff -u -r  vcl/unx/source/gdi/salbmp.cxx  vcl/unx/source/gdi/salbmp.cxx
---  vcl/unx/source/gdi/salbmp.cxx	2004-06-22 23:12:38.000000000 +0530
+++  vcl/unx/source/gdi/salbmp.cxx	2005-02-28 13:40:53.000000000 +0530
@@ -193,7 +193,6 @@
 			}
 
 			pDIB->mpBits = new BYTE[ pDIB->mnScanlineSize * pDIB->mnHeight ];
-			rtl_zeroMemory( pDIB->mpBits, pDIB->mnScanlineSize * pDIB->mnHeight );
 		}
 	}
 	else
@@ -217,7 +216,7 @@
 		SalXLib*	pXLib = pSalDisp->GetXLib();
 		Display*	pXDisp = pSalDisp->GetDisplay();
 
-		// do not die on XError here
+        // do not die on XError here
 		// alternatively one could check the coordinates for being offscreen
 		// but this call can actually work on servers with backing store
 		// defaults even if the rectangle is offscreen
@@ -338,7 +337,9 @@
 				}
 			}
 
-			pDIB = StretchAndConvert( aSrcBuf, aTwoRect, nDstFormat, const_cast<BitmapPalette*>(pDstPal) );
+            nDstFormat = aSrcBuf.mnFormat;
+			pDIB = StretchAndConvert( aSrcBuf, aTwoRect, nDstFormat,
+                const_cast<BitmapPalette*>(pDstPal), &aSrcBuf.maColorMask );
 			XDestroyImage( pImage );
 		}
 	}
@@ -845,6 +846,13 @@
 	}
 }
 
+// -----------------------------------------------------------------------------
+
+bool X11SalBitmap::GetSystemData( BitmapSystemData& rData )
+{
+    return false;
+}
+
 // --------------
 // - ImplSalDDB -
 // --------------
diff -u -r  vcl/unx/source/gdi/salgdi3.cxx  vcl/unx/source/gdi/salgdi3.cxx
---  vcl/unx/source/gdi/salgdi3.cxx	2005-02-23 17:41:37.000000000 +0530
+++  vcl/unx/source/gdi/salgdi3.cxx	2005-02-28 13:40:53.000000000 +0530
@@ -1246,11 +1246,9 @@
 
 void X11SalGraphics::GetDevFontList( ImplDevFontList *pList )
 {
-#if defined( NASTY_SLOW_UGLY_X_FONTS )
     // announce X11 fonts
     XlfdStorage* pX11FontList = GetDisplay()->GetXlfdList();
     pX11FontList->AnnounceFonts( pList );
-#endif
 
     // prepare the GlyphCache using psprint's font infos
     aX11GlyphPeer.SetDisplay( GetXDisplay(),
diff -u -r  vcl/win/inc/salbmp.h  vcl/win/inc/salbmp.h
---  vcl/win/inc/salbmp.h	2003-11-18 20:18:14.000000000 +0530
+++  vcl/win/inc/salbmp.h	2005-02-28 13:40:55.000000000 +0530
@@ -127,6 +127,7 @@
 
 	virtual BitmapBuffer*		AcquireBuffer( bool bReadOnly );
 	virtual void                ReleaseBuffer( BitmapBuffer* pBuffer, bool bReadOnly );
+    virtual bool                GetSystemData( BitmapSystemData& rData );
 };
 
 #endif // _SV_SALBMP_HXX
diff -u -r  vcl/win/source/gdi/salbmp.cxx  vcl/win/source/gdi/salbmp.cxx
---  vcl/win/source/gdi/salbmp.cxx	2004-01-06 20:24:30.000000000 +0530
+++  vcl/win/source/gdi/salbmp.cxx	2005-02-28 13:40:56.000000000 +0530
@@ -78,6 +78,9 @@
 #ifndef _SV_SALBMP_H
 #include <salbmp.h>
 #endif
+#ifndef _SV_BITMAP_HXX
+#include <bitmap.hxx> // for BitmapSystemData
+#endif
 #include <string.h>
 
 // -----------
@@ -666,3 +669,15 @@
 		while( !bEndDecoding && ( pDIB <= pLast ) );
 	}
 }
+
+bool WinSalBitmap::GetSystemData( BitmapSystemData& rData )
+{
+    bool bRet = false;
+    if( mhDIB || mhDDB )
+    {
+        bRet = true;
+        rData.pDIB = mhDIB;
+        rData.pDDB = mhDDB;
+    }
+    return bRet;
+}
diff -u -r  vcl/win/source/gdi/salgdi3.cxx  vcl/win/source/gdi/salgdi3.cxx
---  vcl/win/source/gdi/salgdi3.cxx	2005-01-31 19:17:43.000000000 +0530
+++  vcl/win/source/gdi/salgdi3.cxx	2005-02-28 13:40:56.000000000 +0530
@@ -1012,6 +1012,11 @@
     HFONT hNewFont = 0;
     HFONT hOldFont;
 
+    HDC hdcScreen = 0;
+    if( mbVirDev )
+        // only required for virtual devices, see below for details
+        hdcScreen = GetDC(0);
+
     if( aSalShlData.mbWNT )
     {
         LOGFONTW aLogFont;
@@ -1030,6 +1035,13 @@
             lstrcpynW( aLogFont.lfFaceName, L"Courier New", 11 );
 
         hNewFont = CreateFontIndirectW( &aLogFont );
+        if( hdcScreen )
+        {
+            // select font into screen hdc first to get an antialiased font
+            // see knowledge base article 305290:
+            // "PRB: Fonts Not Drawn Antialiased on Device Context for DirectDraw Surface"
+            SelectFont( hdcScreen, SelectFont( hdcScreen , hNewFont ) );
+        }
         hOldFont = SelectFont( mhDC, hNewFont );
 
         TEXTMETRICW aTextMetricW;
@@ -1067,6 +1079,13 @@
             strncpy( aLogFont.lfFaceName, "Courier New", 11 );
 
         hNewFont = CreateFontIndirectA( &aLogFont );
+        if( hdcScreen )
+        {
+            // select font into screen hdc first to get an antialiased font
+            // see knowledge base article 305290:
+            // "PRB: Fonts Not Drawn Antialiased on Device Context for DirectDraw Surface"
+            SelectFont( hdcScreen, SelectFont( hdcScreen , hNewFont ) );
+        }
         hOldFont = SelectFont( mhDC, hNewFont );
 
         TEXTMETRICA aTextMetricA;
@@ -1085,6 +1104,9 @@
         }
     }
 
+    if( hdcScreen )
+        ReleaseDC( NULL, hdcScreen );
+
     if( !mhDefFont )
     {
         // keep default font
diff -u -r  xmloff/source/draw/shapeexport4.cxx  xmloff/source/draw/shapeexport4.cxx
---  xmloff/source/draw/shapeexport4.cxx	2004-11-26 19:40:00.000000000 +0530
+++  xmloff/source/draw/shapeexport4.cxx	2005-02-28 13:41:40.075856703 +0530
@@ -83,15 +83,15 @@
 #include <com/sun/star/drawing/Direction3D.hpp>
 #endif
 
-#ifndef _COM_SUN_STAR_DRAWING_POSITION3D_HPP_ 
+#ifndef _COM_SUN_STAR_DRAWING_POSITION3D_HPP_
 #include <com/sun/star/drawing/Position3D.hpp>
 #endif
 
-#ifndef _COM_SUN_STAR_DRAWING_CAMERAGEOMETRY_HPP_ 
+#ifndef _COM_SUN_STAR_DRAWING_CAMERAGEOMETRY_HPP_
 #include <com/sun/star/drawing/CameraGeometry.hpp>
 #endif
 
-#ifndef _COM_SUN_STAR_DRAWING_DOUBLESEQUENCE_HPP_ 
+#ifndef _COM_SUN_STAR_DRAWING_DOUBLESEQUENCE_HPP_
 #include <com/sun/star/drawing/DoubleSequence.hpp>
 #endif
 
@@ -107,15 +107,15 @@
 #include <tools/debug.hxx>
 #endif
 
-#ifndef _RTL_USTRBUF_HXX_ 
+#ifndef _RTL_USTRBUF_HXX_
 #include <rtl/ustrbuf.hxx>
 #endif
 
-#ifndef _XMLOFF_XMLEXP_HXX 
+#ifndef _XMLOFF_XMLEXP_HXX
 #include "xmlexp.hxx"
 #endif
 
-#ifndef _XMLOFF_XMLUCONV_HXX 
+#ifndef _XMLOFF_XMLUCONV_HXX
 #include "xmluconv.hxx"
 #endif
 
@@ -138,29 +138,29 @@
 #ifndef _COM_SUN_STAR_DRAWING_SHADEMODE_HPP_
 #include <com/sun/star/drawing/ShadeMode.hpp>
 #endif
-#ifndef _DRAFTS_COM_SUN_STAR_DRAWING_ENHANCEDCUSTOMSHAPEPARAMETERTYPE_HPP_
-#include <drafts/com/sun/star/drawing/EnhancedCustomShapeParameterType.hpp>
+#ifndef _COM_SUN_STAR_DRAWING_ENHANCEDCUSTOMSHAPEPARAMETERTYPE_HPP_
+#include <com/sun/star/drawing/EnhancedCustomShapeParameterType.hpp>
 #endif
-#ifndef _DRAFTS_COM_SUN_STAR_DRAWING_ENHANCEDCUSTOMSHAPEPARAMETERPARI_HPP_
-#include <drafts/com/sun/star/drawing/EnhancedCustomShapeParameterPair.hpp>
+#ifndef _COM_SUN_STAR_DRAWING_ENHANCEDCUSTOMSHAPEPARAMETERPARI_HPP_
+#include <com/sun/star/drawing/EnhancedCustomShapeParameterPair.hpp>
 #endif
-#ifndef _DRAFTS_COM_SUN_STAR_DRAWING_ENHANCEDCUSTOMSHAPEGLUEPOINTTYPE_HPP_
-#include <drafts/com/sun/star/drawing/EnhancedCustomShapeGluePointType.hpp>
+#ifndef _COM_SUN_STAR_DRAWING_ENHANCEDCUSTOMSHAPEGLUEPOINTTYPE_HPP_
+#include <com/sun/star/drawing/EnhancedCustomShapeGluePointType.hpp>
 #endif
-#ifndef _DRAFTS_COM_SUN_STAR_DRAWING_ENHANCEDCUSTOMSHAPETEXTFRAME_HPP_
-#include <drafts/com/sun/star/drawing/EnhancedCustomShapeTextFrame.hpp>
+#ifndef _COM_SUN_STAR_DRAWING_ENHANCEDCUSTOMSHAPETEXTFRAME_HPP_
+#include <com/sun/star/drawing/EnhancedCustomShapeTextFrame.hpp>
 #endif
 #ifndef _DRAFTS_COM_SUN_STAR_DRAWING_ENHANCEDCUSTOMSHAPESEGMENT_HPP_
-#include <drafts/com/sun/star/drawing/EnhancedCustomShapeSegment.hpp>
+#include <com/sun/star/drawing/EnhancedCustomShapeSegment.hpp>
 #endif
-#ifndef _DRAFTS_COM_SUN_STAR_DRAWING_ENHANCEDCUSTOMSHAPESEGMENTCOMMAND_HPP_
-#include <drafts/com/sun/star/drawing/EnhancedCustomShapeSegmentCommand.hpp>
+#ifndef _COM_SUN_STAR_DRAWING_ENHANCEDCUSTOMSHAPESEGMENTCOMMAND_HPP_
+#include <com/sun/star/drawing/EnhancedCustomShapeSegmentCommand.hpp>
 #endif
-#ifndef _DRAFTS_COM_SUN_STAR_DRAWING_ENHANCEDCUSTOMSHAPEADJUSTMENTVALUE_HPP_
-#include <drafts/com/sun/star/drawing/EnhancedCustomShapeAdjustmentValue.hpp>
+#ifndef _COM_SUN_STAR_DRAWING_ENHANCEDCUSTOMSHAPEADJUSTMENTVALUE_HPP_
+#include <com/sun/star/drawing/EnhancedCustomShapeAdjustmentValue.hpp>
 #endif
-#ifndef _DRAFTS_COM_SUN_STAR_DRAWING_ENHANCEDCUSTOMSHAPETEXTPATHMODE_HPP_
-#include <drafts/com/sun/star/drawing/EnhancedCustomShapeTextPathMode.hpp>
+#ifndef _COM_SUN_STAR_DRAWING_ENHANCEDCUSTOMSHAPETEXTPATHMODE_HPP_
+#include <com/sun/star/drawing/EnhancedCustomShapeTextPathMode.hpp>
 #endif
 #ifndef _COM_SUN_STAR_BEANS_PROPERTYVALUES_HPP_
 #include <com/sun/star/beans/PropertyValues.hpp>
@@ -178,7 +178,7 @@
 
 //////////////////////////////////////////////////////////////////////////////
 
-void ExportParameter( rtl::OUStringBuffer& rStrBuffer, const drafts::com::sun::star::drawing::EnhancedCustomShapeParameter& rParameter )
+void ExportParameter( rtl::OUStringBuffer& rStrBuffer, const com::sun::star::drawing::EnhancedCustomShapeParameter& rParameter )
 {
 	if ( rStrBuffer.getLength() )
 		rStrBuffer.append( (sal_Unicode)' ' );
@@ -195,7 +195,7 @@
 
 		switch( rParameter.Type )
 		{
-			case drafts::com::sun::star::drawing::EnhancedCustomShapeParameterType::EQUATION :
+			case com::sun::star::drawing::EnhancedCustomShapeParameterType::EQUATION :
 			{
 				rStrBuffer.append( (sal_Unicode)'?' );
 				rStrBuffer.append( (sal_Unicode)'f' );
@@ -203,36 +203,36 @@
 			}
 			break;
 
-			case drafts::com::sun::star::drawing::EnhancedCustomShapeParameterType::ADJUSTMENT :
+			case com::sun::star::drawing::EnhancedCustomShapeParameterType::ADJUSTMENT :
 			{
 				rStrBuffer.append( (sal_Unicode)'$' );
 				rStrBuffer.append( rtl::OUString::valueOf( nValue ) );
 			}
 			break;
-			
-			case drafts::com::sun::star::drawing::EnhancedCustomShapeParameterType::BOTTOM :
+
+			case com::sun::star::drawing::EnhancedCustomShapeParameterType::BOTTOM :
 				rStrBuffer.append( GetXMLToken( XML_BOTTOM ) ); break;
-			case drafts::com::sun::star::drawing::EnhancedCustomShapeParameterType::RIGHT :
+			case com::sun::star::drawing::EnhancedCustomShapeParameterType::RIGHT :
 				rStrBuffer.append( GetXMLToken( XML_RIGHT ) ); break;
-			case drafts::com::sun::star::drawing::EnhancedCustomShapeParameterType::TOP :
+			case com::sun::star::drawing::EnhancedCustomShapeParameterType::TOP :
 				rStrBuffer.append( GetXMLToken( XML_TOP ) ); break;
-			case drafts::com::sun::star::drawing::EnhancedCustomShapeParameterType::LEFT :
+			case com::sun::star::drawing::EnhancedCustomShapeParameterType::LEFT :
 				rStrBuffer.append( GetXMLToken( XML_LEFT ) ); break;
-			case drafts::com::sun::star::drawing::EnhancedCustomShapeParameterType::XSTRETCH :
+			case com::sun::star::drawing::EnhancedCustomShapeParameterType::XSTRETCH :
 				rStrBuffer.append( GetXMLToken( XML_XSTRETCH ) ); break;
-			case drafts::com::sun::star::drawing::EnhancedCustomShapeParameterType::YSTRETCH :
+			case com::sun::star::drawing::EnhancedCustomShapeParameterType::YSTRETCH :
 				rStrBuffer.append( GetXMLToken( XML_YSTRETCH ) ); break;
-			case drafts::com::sun::star::drawing::EnhancedCustomShapeParameterType::HASSTROKE :
+			case com::sun::star::drawing::EnhancedCustomShapeParameterType::HASSTROKE :
 				rStrBuffer.append( GetXMLToken( XML_HASSTROKE ) ); break;
-			case drafts::com::sun::star::drawing::EnhancedCustomShapeParameterType::HASFILL :
+			case com::sun::star::drawing::EnhancedCustomShapeParameterType::HASFILL :
 				rStrBuffer.append( GetXMLToken( XML_HASFILL ) ); break;
-			case drafts::com::sun::star::drawing::EnhancedCustomShapeParameterType::WIDTH :
+			case com::sun::star::drawing::EnhancedCustomShapeParameterType::WIDTH :
 				rStrBuffer.append( GetXMLToken( XML_WIDTH ) ); break;
-			case drafts::com::sun::star::drawing::EnhancedCustomShapeParameterType::HEIGHT :
+			case com::sun::star::drawing::EnhancedCustomShapeParameterType::HEIGHT :
 				rStrBuffer.append( GetXMLToken( XML_HEIGHT ) ); break;
-			case drafts::com::sun::star::drawing::EnhancedCustomShapeParameterType::LOGWIDTH :
+			case com::sun::star::drawing::EnhancedCustomShapeParameterType::LOGWIDTH :
 				rStrBuffer.append( GetXMLToken( XML_LOGWIDTH ) ); break;
-			case drafts::com::sun::star::drawing::EnhancedCustomShapeParameterType::LOGHEIGHT :
+			case com::sun::star::drawing::EnhancedCustomShapeParameterType::LOGHEIGHT :
 				rStrBuffer.append( GetXMLToken( XML_LOGHEIGHT ) ); break;
 			default :
 				rStrBuffer.append( rtl::OUString::valueOf( nValue ) );
@@ -286,7 +286,7 @@
 				{
 					case EAS_Position :
 					{
-						drafts::com::sun::star::drawing::EnhancedCustomShapeParameterPair aPosition;
+						com::sun::star::drawing::EnhancedCustomShapeParameterPair aPosition;
 						if ( rPropVal.Value >>= aPosition )
 						{
 							ExportParameter( aStrBuffer, aPosition.First );
@@ -322,7 +322,7 @@
 					break;
 					case EAS_Polar :
 					{
-						drafts::com::sun::star::drawing::EnhancedCustomShapeParameterPair aPolar;
+						com::sun::star::drawing::EnhancedCustomShapeParameterPair aPolar;
 						if ( rPropVal.Value >>= aPolar )
 						{
 							ExportParameter( aStrBuffer, aPolar.First );
@@ -334,7 +334,7 @@
 					break;
 					case EAS_RadiusRangeMinimum :
 					{
-						drafts::com::sun::star::drawing::EnhancedCustomShapeParameter aRadiusRangeMinimum;
+						com::sun::star::drawing::EnhancedCustomShapeParameter aRadiusRangeMinimum;
 						if ( rPropVal.Value >>= aRadiusRangeMinimum )
 						{
 							ExportParameter( aStrBuffer, aRadiusRangeMinimum );
@@ -345,7 +345,7 @@
 					break;
 					case EAS_RadiusRangeMaximum :
 					{
-						drafts::com::sun::star::drawing::EnhancedCustomShapeParameter aRadiusRangeMaximum;
+						com::sun::star::drawing::EnhancedCustomShapeParameter aRadiusRangeMaximum;
 						if ( rPropVal.Value >>= aRadiusRangeMaximum )
 						{
 							ExportParameter( aStrBuffer, aRadiusRangeMaximum );
@@ -356,7 +356,7 @@
 					break;
 					case EAS_RangeXMinimum :
 					{
-						drafts::com::sun::star::drawing::EnhancedCustomShapeParameter aXRangeMinimum;
+						com::sun::star::drawing::EnhancedCustomShapeParameter aXRangeMinimum;
 						if ( rPropVal.Value >>= aXRangeMinimum )
 						{
 							ExportParameter( aStrBuffer, aXRangeMinimum );
@@ -367,7 +367,7 @@
 					break;
 					case EAS_RangeXMaximum :
 					{
-						drafts::com::sun::star::drawing::EnhancedCustomShapeParameter aXRangeMaximum;
+						com::sun::star::drawing::EnhancedCustomShapeParameter aXRangeMaximum;
 						if ( rPropVal.Value >>= aXRangeMaximum )
 						{
 							ExportParameter( aStrBuffer, aXRangeMaximum );
@@ -378,7 +378,7 @@
 					break;
 					case EAS_RangeYMinimum :
 					{
-						drafts::com::sun::star::drawing::EnhancedCustomShapeParameter aYRangeMinimum;
+						com::sun::star::drawing::EnhancedCustomShapeParameter aYRangeMinimum;
 						if ( rPropVal.Value >>= aYRangeMinimum )
 						{
 							ExportParameter( aStrBuffer, aYRangeMinimum );
@@ -389,7 +389,7 @@
 					break;
 					case EAS_RangeYMaximum :
 					{
-						drafts::com::sun::star::drawing::EnhancedCustomShapeParameter aYRangeMaximum;
+						com::sun::star::drawing::EnhancedCustomShapeParameter aYRangeMaximum;
 						if ( rPropVal.Value >>= aYRangeMaximum )
 						{
 							ExportParameter( aStrBuffer, aYRangeMaximum );
@@ -410,8 +410,8 @@
 }
 
 void ImpExportEnhancedPath( SvXMLExport& rExport,
-	const uno::Sequence< drafts::com::sun::star::drawing::EnhancedCustomShapeParameterPair >& rCoordinates,
-		const uno::Sequence< drafts::com::sun::star::drawing::EnhancedCustomShapeSegment >& rSegments )
+	const uno::Sequence< com::sun::star::drawing::EnhancedCustomShapeParameterPair >& rCoordinates,
+		const uno::Sequence< com::sun::star::drawing::EnhancedCustomShapeSegment >& rSegments )
 {
 
 	rtl::OUString		aStr;
@@ -419,14 +419,14 @@
 
 	sal_Int32 i, j, k, l;
 
-	sal_Int32 nCoords = rCoordinates.getLength();	
+	sal_Int32 nCoords = rCoordinates.getLength();
 	sal_Int32 nSegments = rSegments.getLength();
 	sal_Bool bSimpleSegments = nSegments == 0;
 	if ( bSimpleSegments )
 		nSegments = 4;
 	for ( j = i = 0; j < nSegments; j++ )
 	{
-		drafts::com::sun::star::drawing::EnhancedCustomShapeSegment aSegment;
+		com::sun::star::drawing::EnhancedCustomShapeSegment aSegment;
 		if ( bSimpleSegments )
 		{
 			// if there are not enough segments we will default them
@@ -435,25 +435,25 @@
 				case 0 :
 				{
 					aSegment.Count = 1;
-					aSegment.Command = drafts::com::sun::star::drawing::EnhancedCustomShapeSegmentCommand::MOVETO;
+					aSegment.Command = com::sun::star::drawing::EnhancedCustomShapeSegmentCommand::MOVETO;
 				}
 				break;
 				case 1 :
 				{
 					aSegment.Count = (sal_Int16)Min( nCoords - 1, (sal_Int32)32767 );
-					aSegment.Command = drafts::com::sun::star::drawing::EnhancedCustomShapeSegmentCommand::LINETO;
+					aSegment.Command = com::sun::star::drawing::EnhancedCustomShapeSegmentCommand::LINETO;
 				}
 				break;
 				case 2 :
 				{
 					aSegment.Count = 1;
-					aSegment.Command = drafts::com::sun::star::drawing::EnhancedCustomShapeSegmentCommand::CLOSESUBPATH;
+					aSegment.Command = com::sun::star::drawing::EnhancedCustomShapeSegmentCommand::CLOSESUBPATH;
 				}
 				break;
 				case 3 :
 				{
 					aSegment.Count = 1;
-					aSegment.Command = drafts::com::sun::star::drawing::EnhancedCustomShapeSegmentCommand::ENDSUBPATH;
+					aSegment.Command = com::sun::star::drawing::EnhancedCustomShapeSegmentCommand::ENDSUBPATH;
 				}
 				break;
 			}
@@ -467,44 +467,44 @@
 		sal_Int32 nParameter = 0;
 		switch( aSegment.Command )
 		{
-			case drafts::com::sun::star::drawing::EnhancedCustomShapeSegmentCommand::CLOSESUBPATH :
+			case com::sun::star::drawing::EnhancedCustomShapeSegmentCommand::CLOSESUBPATH :
 				aStrBuffer.append( (sal_Unicode)'Z' ); break;
-			case drafts::com::sun::star::drawing::EnhancedCustomShapeSegmentCommand::ENDSUBPATH :
+			case com::sun::star::drawing::EnhancedCustomShapeSegmentCommand::ENDSUBPATH :
 				aStrBuffer.append( (sal_Unicode)'N' ); break;
-			case drafts::com::sun::star::drawing::EnhancedCustomShapeSegmentCommand::NOFILL :
+			case com::sun::star::drawing::EnhancedCustomShapeSegmentCommand::NOFILL :
 				aStrBuffer.append( (sal_Unicode)'F' ); break;
-			case drafts::com::sun::star::drawing::EnhancedCustomShapeSegmentCommand::NOSTROKE :
+			case com::sun::star::drawing::EnhancedCustomShapeSegmentCommand::NOSTROKE :
 				aStrBuffer.append( (sal_Unicode)'S' ); break;
 
-			case drafts::com::sun::star::drawing::EnhancedCustomShapeSegmentCommand::MOVETO :
+			case com::sun::star::drawing::EnhancedCustomShapeSegmentCommand::MOVETO :
 				aStrBuffer.append( (sal_Unicode)'M' ); nParameter = 1; break;
-			case drafts::com::sun::star::drawing::EnhancedCustomShapeSegmentCommand::LINETO :
+			case com::sun::star::drawing::EnhancedCustomShapeSegmentCommand::LINETO :
 				aStrBuffer.append( (sal_Unicode)'L' ); nParameter = 1; break;
-			case drafts::com::sun::star::drawing::EnhancedCustomShapeSegmentCommand::CURVETO :
+			case com::sun::star::drawing::EnhancedCustomShapeSegmentCommand::CURVETO :
 				aStrBuffer.append( (sal_Unicode)'C' ); nParameter = 3; break;
-			case drafts::com::sun::star::drawing::EnhancedCustomShapeSegmentCommand::ANGLEELLIPSETO :
+			case com::sun::star::drawing::EnhancedCustomShapeSegmentCommand::ANGLEELLIPSETO :
 				aStrBuffer.append( (sal_Unicode)'T' ); nParameter = 3; break;
-			case drafts::com::sun::star::drawing::EnhancedCustomShapeSegmentCommand::ANGLEELLIPSE :
+			case com::sun::star::drawing::EnhancedCustomShapeSegmentCommand::ANGLEELLIPSE :
 				aStrBuffer.append( (sal_Unicode)'U' ); nParameter = 3; break;
-			case drafts::com::sun::star::drawing::EnhancedCustomShapeSegmentCommand::ARCTO :
+			case com::sun::star::drawing::EnhancedCustomShapeSegmentCommand::ARCTO :
 				aStrBuffer.append( (sal_Unicode)'A' ); nParameter = 4; break;
-			case drafts::com::sun::star::drawing::EnhancedCustomShapeSegmentCommand::ARC :
+			case com::sun::star::drawing::EnhancedCustomShapeSegmentCommand::ARC :
 				aStrBuffer.append( (sal_Unicode)'B' ); nParameter = 4; break;
-			case drafts::com::sun::star::drawing::EnhancedCustomShapeSegmentCommand::CLOCKWISEARCTO :
+			case com::sun::star::drawing::EnhancedCustomShapeSegmentCommand::CLOCKWISEARCTO :
 				aStrBuffer.append( (sal_Unicode)'W' ); nParameter = 4; break;
-			case drafts::com::sun::star::drawing::EnhancedCustomShapeSegmentCommand::CLOCKWISEARC :
+			case com::sun::star::drawing::EnhancedCustomShapeSegmentCommand::CLOCKWISEARC :
 				aStrBuffer.append( (sal_Unicode)'V' ); nParameter = 4; break;
-			case drafts::com::sun::star::drawing::EnhancedCustomShapeSegmentCommand::ELLIPTICALQUADRANTX :
+			case com::sun::star::drawing::EnhancedCustomShapeSegmentCommand::ELLIPTICALQUADRANTX :
 				aStrBuffer.append( (sal_Unicode)'X' ); nParameter = 1; break;
-			case drafts::com::sun::star::drawing::EnhancedCustomShapeSegmentCommand::ELLIPTICALQUADRANTY :
+			case com::sun::star::drawing::EnhancedCustomShapeSegmentCommand::ELLIPTICALQUADRANTY :
 				aStrBuffer.append( (sal_Unicode)'Y' ); nParameter = 1; break;
-			case drafts::com::sun::star::drawing::EnhancedCustomShapeSegmentCommand::QUADRATICCURVETO :
+			case com::sun::star::drawing::EnhancedCustomShapeSegmentCommand::QUADRATICCURVETO :
 				aStrBuffer.append( (sal_Unicode)'Q' ); nParameter = 2; break;
 
 			default : // ups, seems to be something wrong
 			{
 				aSegment.Count = 1;
-				aSegment.Command = drafts::com::sun::star::drawing::EnhancedCustomShapeSegmentCommand::LINETO;
+				aSegment.Command = com::sun::star::drawing::EnhancedCustomShapeSegmentCommand::LINETO;
 			}
 			break;
 		}
@@ -520,7 +520,7 @@
 						ExportParameter( aStrBuffer, rCoordinates[ i++ ].Second );
 					}
 				}
-				else 
+				else
 				{
 					j = nSegments;	// error -> exiting
 					break;
@@ -541,10 +541,10 @@
 	uno::Sequence< beans::PropertyValues > aHandles;
 
 	sal_Bool bCoordinates = sal_False;
-	uno::Sequence< drafts::com::sun::star::drawing::EnhancedCustomShapeSegment > aSegments;
-	uno::Sequence< drafts::com::sun::star::drawing::EnhancedCustomShapeParameterPair > aCoordinates;
+	uno::Sequence< com::sun::star::drawing::EnhancedCustomShapeSegment > aSegments;
+	uno::Sequence< com::sun::star::drawing::EnhancedCustomShapeParameterPair > aCoordinates;
 
-	uno::Sequence< drafts::com::sun::star::drawing::EnhancedCustomShapeAdjustmentValue > aAdjustmentValues;
+	uno::Sequence< com::sun::star::drawing::EnhancedCustomShapeAdjustmentValue > aAdjustmentValues;
 
 	rtl::OUString		aStr;
 	rtl::OUStringBuffer aStrBuffer;
@@ -627,7 +627,7 @@
 									{
 										sal_Bool bExtrusionOn;
 										if ( rProp.Value >>= bExtrusionOn )
-											rExport.AddAttribute( XML_NAMESPACE_DRAW, XML_EXTRUSION, 
+											rExport.AddAttribute( XML_NAMESPACE_DRAW, XML_EXTRUSION,
 												bExtrusionOn ? GetXMLToken( XML_TRUE ) : GetXMLToken( XML_FALSE ) );
 									}
 									break;
@@ -645,7 +645,7 @@
 									break;
 									case EAS_Depth :
 									{
-										drafts::com::sun::star::drawing::EnhancedCustomShapeParameterPair aDepthParaPair;
+										com::sun::star::drawing::EnhancedCustomShapeParameterPair aDepthParaPair;
 										if ( rProp.Value >>= aDepthParaPair )
 										{
 											double fDepth;
@@ -682,7 +682,7 @@
 									{
 										sal_Bool bExtrusionLightFace;
 										if ( rProp.Value >>= bExtrusionLightFace )
-											rExport.AddAttribute( XML_NAMESPACE_DRAW, XML_EXTRUSION_LIGHT_FACE, 
+											rExport.AddAttribute( XML_NAMESPACE_DRAW, XML_EXTRUSION_LIGHT_FACE,
 												bExtrusionLightFace ? GetXMLToken( XML_TRUE ) : GetXMLToken( XML_FALSE ) );
 									}
 									break;
@@ -690,7 +690,7 @@
 									{
 										sal_Bool bExtrusionFirstLightHarsh;
 										if ( rProp.Value >>= bExtrusionFirstLightHarsh )
-											rExport.AddAttribute( XML_NAMESPACE_DRAW, XML_EXTRUSION_FIRST_LIGHT_HARSH, 
+											rExport.AddAttribute( XML_NAMESPACE_DRAW, XML_EXTRUSION_FIRST_LIGHT_HARSH,
 												bExtrusionFirstLightHarsh ? GetXMLToken( XML_TRUE ) : GetXMLToken( XML_FALSE ) );
 									}
 									break;
@@ -756,7 +756,7 @@
 									{
 										sal_Bool bExtrusionMetal;
 										if ( rProp.Value >>= bExtrusionMetal )
-											rExport.AddAttribute( XML_NAMESPACE_DRAW, XML_EXTRUSION_METAL, 
+											rExport.AddAttribute( XML_NAMESPACE_DRAW, XML_EXTRUSION_METAL,
 												bExtrusionMetal ? GetXMLToken( XML_TRUE ) : GetXMLToken( XML_FALSE ) );
 									}
 									break;
@@ -785,7 +785,7 @@
 									break;
 									case EAS_RotateAngle :
 									{
-										drafts::com::sun::star::drawing::EnhancedCustomShapeParameterPair aRotateAngleParaPair;
+										com::sun::star::drawing::EnhancedCustomShapeParameterPair aRotateAngleParaPair;
 										if ( rProp.Value >>= aRotateAngleParaPair )
 										{
 											ExportParameter( aStrBuffer, aRotateAngleParaPair.First );
@@ -822,7 +822,7 @@
 									break;
 									case EAS_Skew :
 									{
-										drafts::com::sun::star::drawing::EnhancedCustomShapeParameterPair aSkewParaPair;
+										com::sun::star::drawing::EnhancedCustomShapeParameterPair aSkewParaPair;
 										if ( rProp.Value >>= aSkewParaPair )
 										{
 											ExportParameter( aStrBuffer, aSkewParaPair.First );
@@ -865,7 +865,7 @@
 									break;
 									case EAS_Origin :
 									{
-										drafts::com::sun::star::drawing::EnhancedCustomShapeParameterPair aOriginParaPair;
+										com::sun::star::drawing::EnhancedCustomShapeParameterPair aOriginParaPair;
 										if ( rProp.Value >>= aOriginParaPair )
 										{
 											ExportParameter( aStrBuffer, aOriginParaPair.First );
@@ -880,7 +880,7 @@
 										sal_Bool bExtrusionColor;
 										if ( rProp.Value >>= bExtrusionColor )
 										{
-											rExport.AddAttribute( XML_NAMESPACE_DRAW, XML_EXTRUSION_COLOR, 
+											rExport.AddAttribute( XML_NAMESPACE_DRAW, XML_EXTRUSION_COLOR,
 												bExtrusionColor ? GetXMLToken( XML_TRUE ) : GetXMLToken( XML_FALSE ) );
 										}
 									}
@@ -905,20 +905,20 @@
 									{
 										sal_Bool bTextPathOn;
 										if ( rProp.Value >>= bTextPathOn )
-											rExport.AddAttribute( XML_NAMESPACE_DRAW, XML_TEXT_PATH, 
+											rExport.AddAttribute( XML_NAMESPACE_DRAW, XML_TEXT_PATH,
 												bTextPathOn ? GetXMLToken( XML_TRUE ) : GetXMLToken( XML_FALSE ) );
 									}
 									break;
 									case EAS_TextPathMode :
 									{
-										drafts::com::sun::star::drawing::EnhancedCustomShapeTextPathMode eTextPathMode;
+										com::sun::star::drawing::EnhancedCustomShapeTextPathMode eTextPathMode;
 										if ( rProp.Value >>= eTextPathMode )
 										{
 											switch ( eTextPathMode )
 											{
-												case drafts::com::sun::star::drawing::EnhancedCustomShapeTextPathMode_NORMAL: aStr = GetXMLToken( XML_NORMAL ); break;
-												case drafts::com::sun::star::drawing::EnhancedCustomShapeTextPathMode_PATH	: aStr = GetXMLToken( XML_PATH );   break;
-												case drafts::com::sun::star::drawing::EnhancedCustomShapeTextPathMode_SHAPE : aStr = GetXMLToken( XML_SHAPE );  break;
+												case com::sun::star::drawing::EnhancedCustomShapeTextPathMode_NORMAL: aStr = GetXMLToken( XML_NORMAL ); break;
+												case com::sun::star::drawing::EnhancedCustomShapeTextPathMode_PATH	: aStr = GetXMLToken( XML_PATH );   break;
+												case com::sun::star::drawing::EnhancedCustomShapeTextPathMode_SHAPE : aStr = GetXMLToken( XML_SHAPE );  break;
 											}
 											if ( aStr.getLength() )
 												rExport.AddAttribute( XML_NAMESPACE_DRAW, XML_TEXT_PATH_MODE, aStr );
@@ -961,7 +961,7 @@
 									{
 										sal_Bool bExtrusionAllowed;
 										if ( rProp.Value >>= bExtrusionAllowed )
-											rExport.AddAttribute( XML_NAMESPACE_DRAW, XML_EXTRUSION_ALLOWED, 
+											rExport.AddAttribute( XML_NAMESPACE_DRAW, XML_EXTRUSION_ALLOWED,
 												bExtrusionAllowed ? GetXMLToken( XML_TRUE ) : GetXMLToken( XML_FALSE ) );
 									}
 									break;
@@ -969,7 +969,7 @@
 									{
 										sal_Bool bConcentricGradientFillAllowed;
 										if ( rProp.Value >>= bConcentricGradientFillAllowed )
-											rExport.AddAttribute( XML_NAMESPACE_DRAW, XML_CONCENTRIC_GRADIENT_FILL_ALLOWED, 
+											rExport.AddAttribute( XML_NAMESPACE_DRAW, XML_CONCENTRIC_GRADIENT_FILL_ALLOWED,
 												bConcentricGradientFillAllowed ? GetXMLToken( XML_TRUE ) : GetXMLToken( XML_FALSE ) );
 									}
 									break;
@@ -983,7 +983,7 @@
 									break;
 									case EAS_GluePoints :
 									{
-										com::sun::star::uno::Sequence< drafts::com::sun::star::drawing::EnhancedCustomShapeParameterPair> aGluePoints;
+										com::sun::star::uno::Sequence< com::sun::star::drawing::EnhancedCustomShapeParameterPair> aGluePoints;
 										if ( rProp.Value >>= aGluePoints )
 										{
 											sal_Int32 j, nElements = aGluePoints.getLength();
@@ -1007,9 +1007,9 @@
 										{
 											switch ( nGluePointType )
 											{
-												case drafts::com::sun::star::drawing::EnhancedCustomShapeGluePointType::NONE     : aStr = GetXMLToken( XML_NONE );    break;
-												case drafts::com::sun::star::drawing::EnhancedCustomShapeGluePointType::SEGMENTS : aStr = GetXMLToken( XML_SEGMENTS ); break;
-												case drafts::com::sun::star::drawing::EnhancedCustomShapeGluePointType::RECT     : aStr = GetXMLToken( XML_RECTANGLE ); break;
+												case com::sun::star::drawing::EnhancedCustomShapeGluePointType::NONE     : aStr = GetXMLToken( XML_NONE );    break;
+												case com::sun::star::drawing::EnhancedCustomShapeGluePointType::SEGMENTS : aStr = GetXMLToken( XML_SEGMENTS ); break;
+												case com::sun::star::drawing::EnhancedCustomShapeGluePointType::RECT     : aStr = GetXMLToken( XML_RECTANGLE ); break;
 											}
 											if ( aStr.getLength() )
 												rExport.AddAttribute( XML_NAMESPACE_DRAW, XML_GLUE_POINT_TYPE, aStr );
@@ -1022,7 +1022,7 @@
 									}
 									break;
 									case EAS_Segments :
-									{								
+									{
 										rProp.Value >>= aSegments;
 									}
 									break;
@@ -1042,7 +1042,7 @@
 									break;
 									case EAS_TextFrames :
 									{
-										com::sun::star::uno::Sequence< drafts::com::sun::star::drawing::EnhancedCustomShapeTextFrame > aPathTextFrames;
+										com::sun::star::uno::Sequence< com::sun::star::drawing::EnhancedCustomShapeTextFrame > aPathTextFrames;
 										if ( rProp.Value >>= aPathTextFrames )
 										{
 											if ( (sal_uInt16)aPathTextFrames.getLength() )
@@ -1095,7 +1095,7 @@
 					if ( i )
 						aStrBuffer.append( (sal_Unicode)' ' );
 
-					const drafts::com::sun::star::drawing::EnhancedCustomShapeAdjustmentValue& rAdj = aAdjustmentValues[ i ];
+					const com::sun::star::drawing::EnhancedCustomShapeAdjustmentValue& rAdj = aAdjustmentValues[ i ];
 					if ( rAdj.State == beans::PropertyState_DIRECT_VALUE )
 					{
 						if ( rAdj.Value.getValueTypeClass() == uno::TypeClass_DOUBLE )
diff -u -r  xmloff/source/draw/ximpcustomshape.cxx  xmloff/source/draw/ximpcustomshape.cxx
---  xmloff/source/draw/ximpcustomshape.cxx	2004-11-26 19:40:19.000000000 +0530
+++  xmloff/source/draw/ximpcustomshape.cxx	2005-02-28 13:41:40.239837544 +0530
@@ -143,26 +143,26 @@
 #include <com/sun/star/drawing/Direction3D.hpp>
 #endif
 
-#ifndef _DRAFTS_COM_SUN_STAR_DRAWING_ENHANCEDCUSTOMSHAPEPARAMETERPAIR_HPP_
-#include <drafts/com/sun/star/drawing/EnhancedCustomShapeParameterPair.hpp>
+#ifndef _COM_SUN_STAR_DRAWING_ENHANCEDCUSTOMSHAPEPARAMETERPAIR_HPP_
+#include <com/sun/star/drawing/EnhancedCustomShapeParameterPair.hpp>
 #endif
-#ifndef _DRAFTS_COM_SUN_STAR_DRAWING_ENHANCEDCUSTOMSHAPEPARAMETERTYPE_HPP_
-#include <drafts/com/sun/star/drawing/EnhancedCustomShapeParameterType.hpp>
+#ifndef _COM_SUN_STAR_DRAWING_ENHANCEDCUSTOMSHAPEPARAMETERTYPE_HPP_
+#include <com/sun/star/drawing/EnhancedCustomShapeParameterType.hpp>
 #endif
-#ifndef _DRAFTS_COM_SUN_STAR_DRAWING_ENHANCEDCUSTOMSHAPETEXTFRAME_HPP_
-#include <drafts/com/sun/star/drawing/EnhancedCustomShapeTextFrame.hpp>
+#ifndef _COM_SUN_STAR_DRAWING_ENHANCEDCUSTOMSHAPETEXTFRAME_HPP_
+#include <com/sun/star/drawing/EnhancedCustomShapeTextFrame.hpp>
 #endif
-#ifndef _DRAFTS_COM_SUN_STAR_DRAWING_ENHANCEDCUSTOMSHAPEADJUSTMENTVALUE_HPP_
-#include <drafts/com/sun/star/drawing/EnhancedCustomShapeAdjustmentValue.hpp>
+#ifndef _COM_SUN_STAR_DRAWING_ENHANCEDCUSTOMSHAPEADJUSTMENTVALUE_HPP_
+#include <com/sun/star/drawing/EnhancedCustomShapeAdjustmentValue.hpp>
 #endif
-#ifndef _DRAFTS_COM_SUN_STAR_DRAWING_ENHANCEDCUSTOMSHAPESEGMENT_HPP_
-#include <drafts/com/sun/star/drawing/EnhancedCustomShapeSegment.hpp>
+#ifndef _COM_SUN_STAR_DRAWING_ENHANCEDCUSTOMSHAPESEGMENT_HPP_
+#include <com/sun/star/drawing/EnhancedCustomShapeSegment.hpp>
 #endif
-#ifndef _DRAFTS_COM_SUN_STAR_DRAWING_ENHANCEDCUSTOMSHAPESEGMENTCOMMAND_HPP_
-#include <drafts/com/sun/star/drawing/EnhancedCustomShapeSegmentCommand.hpp>
+#ifndef _COM_SUN_STAR_DRAWING_ENHANCEDCUSTOMSHAPESEGMENTCOMMAND_HPP_
+#include <com/sun/star/drawing/EnhancedCustomShapeSegmentCommand.hpp>
 #endif
-#ifndef _DRAFTS_COM_SUN_STAR_DRAWING_ENHANCEDCUSTOMSHAPETEXTPATHMODE_HPP_
-#include <drafts/com/sun/star/drawing/EnhancedCustomShapeTextPathMode.hpp>
+#ifndef _COM_SUN_STAR_DRAWING_ENHANCEDCUSTOMSHAPETEXTPATHMODE_HPP_
+#include <com/sun/star/drawing/EnhancedCustomShapeTextPathMode.hpp>
 #endif
 #ifndef _COM_SUN_STAR_DRAWING_PROJECTIONMODE_HPP_
 #include <com/sun/star/drawing/ProjectionMode.hpp>
@@ -324,7 +324,7 @@
 	return bValid;
 }
 
-sal_Bool GetNextParameter( drafts::com::sun::star::drawing::EnhancedCustomShapeParameter& rParameter, sal_Int32& nIndex, const rtl::OUString& rParaString )
+sal_Bool GetNextParameter( com::sun::star::drawing::EnhancedCustomShapeParameter& rParameter, sal_Int32& nIndex, const rtl::OUString& rParaString )
 {
 	if ( nIndex >= rParaString.getLength() )
 		return sal_False;
@@ -333,10 +333,10 @@
 	sal_Bool bNumberRequired = sal_True;
 	sal_Bool bMustBePositiveWholeNumbered = sal_False;
 
-	rParameter.Type = drafts::com::sun::star::drawing::EnhancedCustomShapeParameterType::NORMAL;
+	rParameter.Type = com::sun::star::drawing::EnhancedCustomShapeParameterType::NORMAL;
 	if ( rParaString[ nIndex ] == (sal_Unicode)'$' )
 	{
-		rParameter.Type = drafts::com::sun::star::drawing::EnhancedCustomShapeParameterType::ADJUSTMENT;
+		rParameter.Type = com::sun::star::drawing::EnhancedCustomShapeParameterType::ADJUSTMENT;
 		bMustBePositiveWholeNumbered = sal_True;
 		nIndex++;
 	}
@@ -348,7 +348,7 @@
 		bValid = GetEquationName( rParaString, nIndex, aEquationName );
 		if ( bValid )
 		{
-			rParameter.Type = drafts::com::sun::star::drawing::EnhancedCustomShapeParameterType::EQUATION;
+			rParameter.Type = com::sun::star::drawing::EnhancedCustomShapeParameterType::EQUATION;
 			rParameter.Value <<= aEquationName;
 			nIndex += aEquationName.getLength();
 		}
@@ -358,62 +358,62 @@
 		bNumberRequired = sal_False;
 		if ( rParaString.matchIgnoreAsciiCaseAsciiL( "left", 4, nIndex ) )
 		{
-			rParameter.Type = drafts::com::sun::star::drawing::EnhancedCustomShapeParameterType::LEFT;
+			rParameter.Type = com::sun::star::drawing::EnhancedCustomShapeParameterType::LEFT;
 			nIndex += 4;
 		}
 		else if ( rParaString.matchIgnoreAsciiCaseAsciiL( "top", 3, nIndex ) )
 		{
-			rParameter.Type = drafts::com::sun::star::drawing::EnhancedCustomShapeParameterType::TOP;
+			rParameter.Type = com::sun::star::drawing::EnhancedCustomShapeParameterType::TOP;
 			nIndex += 3;
 		}
 		else if ( rParaString.matchIgnoreAsciiCaseAsciiL( "right", 5, nIndex ) )
 		{
-			rParameter.Type = drafts::com::sun::star::drawing::EnhancedCustomShapeParameterType::RIGHT;
+			rParameter.Type = com::sun::star::drawing::EnhancedCustomShapeParameterType::RIGHT;
 			nIndex += 5;
 		}
 		else if ( rParaString.matchIgnoreAsciiCaseAsciiL( "bottom", 6, nIndex ) )
 		{
-			rParameter.Type = drafts::com::sun::star::drawing::EnhancedCustomShapeParameterType::BOTTOM;
+			rParameter.Type = com::sun::star::drawing::EnhancedCustomShapeParameterType::BOTTOM;
 			nIndex += 6;
 		}
 		else if ( rParaString.matchIgnoreAsciiCaseAsciiL( "xstretch", 8, nIndex ) )
 		{
-			rParameter.Type = drafts::com::sun::star::drawing::EnhancedCustomShapeParameterType::XSTRETCH;
+			rParameter.Type = com::sun::star::drawing::EnhancedCustomShapeParameterType::XSTRETCH;
 			nIndex += 8;
 		}
 		else if ( rParaString.matchIgnoreAsciiCaseAsciiL( "ystretch", 8, nIndex ) )
 		{
-			rParameter.Type = drafts::com::sun::star::drawing::EnhancedCustomShapeParameterType::YSTRETCH;
+			rParameter.Type = com::sun::star::drawing::EnhancedCustomShapeParameterType::YSTRETCH;
 			nIndex += 8;
 		}
 		else if ( rParaString.matchIgnoreAsciiCaseAsciiL( "hasstroke", 9, nIndex ) )
 		{
-			rParameter.Type = drafts::com::sun::star::drawing::EnhancedCustomShapeParameterType::HASSTROKE;
+			rParameter.Type = com::sun::star::drawing::EnhancedCustomShapeParameterType::HASSTROKE;
 			nIndex += 9;
 		}
 		else if ( rParaString.matchIgnoreAsciiCaseAsciiL( "hasfill", 7, nIndex ) )
 		{
-			rParameter.Type = drafts::com::sun::star::drawing::EnhancedCustomShapeParameterType::HASFILL;
+			rParameter.Type = com::sun::star::drawing::EnhancedCustomShapeParameterType::HASFILL;
 			nIndex += 7;
 		}
 		else if ( rParaString.matchIgnoreAsciiCaseAsciiL( "width", 5, nIndex ) )
 		{
-			rParameter.Type = drafts::com::sun::star::drawing::EnhancedCustomShapeParameterType::WIDTH;
+			rParameter.Type = com::sun::star::drawing::EnhancedCustomShapeParameterType::WIDTH;
 			nIndex += 5;
 		}
 		else if ( rParaString.matchIgnoreAsciiCaseAsciiL( "height", 6, nIndex ) )
 		{
-			rParameter.Type = drafts::com::sun::star::drawing::EnhancedCustomShapeParameterType::HEIGHT;
+			rParameter.Type = com::sun::star::drawing::EnhancedCustomShapeParameterType::HEIGHT;
 			nIndex += 6;
 		}
 		else if ( rParaString.matchIgnoreAsciiCaseAsciiL( "logwidth", 8, nIndex ) )
 		{
-			rParameter.Type = drafts::com::sun::star::drawing::EnhancedCustomShapeParameterType::LOGWIDTH;
+			rParameter.Type = com::sun::star::drawing::EnhancedCustomShapeParameterType::LOGWIDTH;
 			nIndex += 8;
 		}
 		else if ( rParaString.matchIgnoreAsciiCaseAsciiL( "logheight", 9, nIndex ) )
 		{
-			rParameter.Type = drafts::com::sun::star::drawing::EnhancedCustomShapeParameterType::LOGHEIGHT;
+			rParameter.Type = com::sun::star::drawing::EnhancedCustomShapeParameterType::LOGHEIGHT;
 			nIndex += 9;
 		}
 		else
@@ -458,7 +458,7 @@
 								bM = sal_True;
 							else if ( bE )
 								bEM = sal_True;
-							else 
+							else
 								bValid = sal_False;
 						}
 					}
@@ -580,7 +580,7 @@
 						const rtl::OUString& rValue, const EnhancedCustomShapeTokenEnum eDestProp )
 {
 	sal_Int32 nIndex = 0;
-	drafts::com::sun::star::drawing::EnhancedCustomShapeParameter aParameter;
+	com::sun::star::drawing::EnhancedCustomShapeParameter aParameter;
 	if ( GetNextParameter( aParameter, nIndex, rValue ) )
 	{
 		beans::PropertyValue aProp;
@@ -594,7 +594,7 @@
 						const rtl::OUString& rValue, const EnhancedCustomShapeTokenEnum eDestProp )
 {
 	sal_Int32 nIndex = 0;
-	drafts::com::sun::star::drawing::EnhancedCustomShapeParameterPair aParameterPair;
+	com::sun::star::drawing::EnhancedCustomShapeParameterPair aParameterPair;
 	if ( GetNextParameter( aParameterPair.First, nIndex, rValue )
 		&& GetNextParameter( aParameterPair.Second, nIndex, rValue ) )
 	{
@@ -608,8 +608,8 @@
 void GetEnhancedParameterPairSequence( std::vector< com::sun::star::beans::PropertyValue >& rDest,		// e.g. draw:glue-points
 						const rtl::OUString& rValue, const EnhancedCustomShapeTokenEnum eDestProp )
 {
-	std::vector< drafts::com::sun::star::drawing::EnhancedCustomShapeParameterPair > vParameter;
-	drafts::com::sun::star::drawing::EnhancedCustomShapeParameterPair aParameter;
+	std::vector< com::sun::star::drawing::EnhancedCustomShapeParameterPair > vParameter;
+	com::sun::star::drawing::EnhancedCustomShapeParameterPair aParameter;
 
 	sal_Int32 nIndex = 0;
 	while ( GetNextParameter( aParameter.First, nIndex, rValue )
@@ -619,10 +619,10 @@
 	}
 	if ( vParameter.size() )
 	{
-		uno::Sequence< drafts::com::sun::star::drawing::EnhancedCustomShapeParameterPair > aParameterSeq( vParameter.size() );
-		std::vector< drafts::com::sun::star::drawing::EnhancedCustomShapeParameterPair >::const_iterator aIter = vParameter.begin();
-		std::vector< drafts::com::sun::star::drawing::EnhancedCustomShapeParameterPair >::const_iterator aEnd = vParameter.end();
-		drafts::com::sun::star::drawing::EnhancedCustomShapeParameterPair* pValues = aParameterSeq.getArray();
+		uno::Sequence< com::sun::star::drawing::EnhancedCustomShapeParameterPair > aParameterSeq( vParameter.size() );
+		std::vector< com::sun::star::drawing::EnhancedCustomShapeParameterPair >::const_iterator aIter = vParameter.begin();
+		std::vector< com::sun::star::drawing::EnhancedCustomShapeParameterPair >::const_iterator aEnd = vParameter.end();
+		com::sun::star::drawing::EnhancedCustomShapeParameterPair* pValues = aParameterSeq.getArray();
 
 		while ( aIter != aEnd )
 			*pValues++ = *aIter++;
@@ -637,13 +637,13 @@
 void GetEnhancedRectangleSequence( std::vector< com::sun::star::beans::PropertyValue >& rDest,		// e.g. draw:text-areas
 						const rtl::OUString& rValue, const EnhancedCustomShapeTokenEnum eDestProp )
 {
-	std::vector< drafts::com::sun::star::drawing::EnhancedCustomShapeTextFrame > vTextFrame;
-	drafts::com::sun::star::drawing::EnhancedCustomShapeTextFrame aParameter;
+	std::vector< com::sun::star::drawing::EnhancedCustomShapeTextFrame > vTextFrame;
+	com::sun::star::drawing::EnhancedCustomShapeTextFrame aParameter;
 
 	sal_Int32 nIndex = 0;
 
 	while ( GetNextParameter( aParameter.TopLeft.First, nIndex, rValue )
-			&& GetNextParameter( aParameter.TopLeft.Second, nIndex, rValue ) 
+			&& GetNextParameter( aParameter.TopLeft.Second, nIndex, rValue )
 			&& GetNextParameter( aParameter.BottomRight.First, nIndex, rValue )
 			&& GetNextParameter( aParameter.BottomRight.Second, nIndex, rValue ) )
 	{
@@ -651,10 +651,10 @@
 	}
 	if ( vTextFrame.size() )
 	{
-		uno::Sequence< drafts::com::sun::star::drawing::EnhancedCustomShapeTextFrame > aTextFrameSeq( vTextFrame.size() );
-		std::vector< drafts::com::sun::star::drawing::EnhancedCustomShapeTextFrame >::const_iterator aIter = vTextFrame.begin();
-		std::vector< drafts::com::sun::star::drawing::EnhancedCustomShapeTextFrame >::const_iterator aEnd = vTextFrame.end();
-		drafts::com::sun::star::drawing::EnhancedCustomShapeTextFrame* pValues = aTextFrameSeq.getArray();
+		uno::Sequence< com::sun::star::drawing::EnhancedCustomShapeTextFrame > aTextFrameSeq( vTextFrame.size() );
+		std::vector< com::sun::star::drawing::EnhancedCustomShapeTextFrame >::const_iterator aIter = vTextFrame.begin();
+		std::vector< com::sun::star::drawing::EnhancedCustomShapeTextFrame >::const_iterator aEnd = vTextFrame.end();
+		com::sun::star::drawing::EnhancedCustomShapeTextFrame* pValues = aTextFrameSeq.getArray();
 
 		while ( aIter != aEnd )
 			*pValues++ = *aIter++;
@@ -669,129 +669,129 @@
 void GetEnhancedPath( std::vector< com::sun::star::beans::PropertyValue >& rDest,					// e.g. draw:enhanced-path
 						const rtl::OUString& rValue )
 {
-	std::vector< drafts::com::sun::star::drawing::EnhancedCustomShapeParameterPair >	vCoordinates;
-	std::vector< drafts::com::sun::star::drawing::EnhancedCustomShapeSegment >		vSegments;
+	std::vector< com::sun::star::drawing::EnhancedCustomShapeParameterPair >	vCoordinates;
+	std::vector< com::sun::star::drawing::EnhancedCustomShapeSegment >		vSegments;
 
 	sal_Int32 nIndex = 0;
 	sal_Int32 nParameterCount = 0;
 
 	sal_Int32 nParametersNeeded = 1;
-	sal_Int16 nLatestSegmentCommand = drafts::com::sun::star::drawing::EnhancedCustomShapeSegmentCommand::MOVETO;
+	sal_Int16 nLatestSegmentCommand = com::sun::star::drawing::EnhancedCustomShapeSegmentCommand::MOVETO;
 
 	sal_Bool bValid = sal_True;
-	
+
 	while( bValid && ( nIndex < rValue.getLength() ) )
 	{
 		switch( rValue[ nIndex ] )
 		{
 			case 'M' :
 			{
-				nLatestSegmentCommand = drafts::com::sun::star::drawing::EnhancedCustomShapeSegmentCommand::MOVETO;
+				nLatestSegmentCommand = com::sun::star::drawing::EnhancedCustomShapeSegmentCommand::MOVETO;
 				nParametersNeeded = 1;
 				nIndex++;
 			}
 			break;
 			case 'L' :
 			{
-				nLatestSegmentCommand = drafts::com::sun::star::drawing::EnhancedCustomShapeSegmentCommand::LINETO;
+				nLatestSegmentCommand = com::sun::star::drawing::EnhancedCustomShapeSegmentCommand::LINETO;
 				nParametersNeeded = 1;
 				nIndex++;
 			}
 			break;
 			case 'C' :
 			{
-				nLatestSegmentCommand = drafts::com::sun::star::drawing::EnhancedCustomShapeSegmentCommand::CURVETO;
+				nLatestSegmentCommand = com::sun::star::drawing::EnhancedCustomShapeSegmentCommand::CURVETO;
 				nParametersNeeded = 3;
 				nIndex++;
 			}
 			break;
 			case 'Z' :
 			{
-				nLatestSegmentCommand = drafts::com::sun::star::drawing::EnhancedCustomShapeSegmentCommand::CLOSESUBPATH;
+				nLatestSegmentCommand = com::sun::star::drawing::EnhancedCustomShapeSegmentCommand::CLOSESUBPATH;
 				nParametersNeeded = 0;
 				nIndex++;
 			}
 			break;
 			case 'N' :
 			{
-				nLatestSegmentCommand = drafts::com::sun::star::drawing::EnhancedCustomShapeSegmentCommand::ENDSUBPATH;
+				nLatestSegmentCommand = com::sun::star::drawing::EnhancedCustomShapeSegmentCommand::ENDSUBPATH;
 				nParametersNeeded = 0;
 				nIndex++;
 			}
 			break;
 			case 'F' :
 			{
-				nLatestSegmentCommand = drafts::com::sun::star::drawing::EnhancedCustomShapeSegmentCommand::NOFILL;
+				nLatestSegmentCommand = com::sun::star::drawing::EnhancedCustomShapeSegmentCommand::NOFILL;
 				nParametersNeeded = 0;
 				nIndex++;
 			}
 			break;
 			case 'S' :
 			{
-				nLatestSegmentCommand = drafts::com::sun::star::drawing::EnhancedCustomShapeSegmentCommand::NOSTROKE;
+				nLatestSegmentCommand = com::sun::star::drawing::EnhancedCustomShapeSegmentCommand::NOSTROKE;
 				nParametersNeeded = 0;
 				nIndex++;
 			}
 			break;
 			case 'T' :
 			{
-				nLatestSegmentCommand = drafts::com::sun::star::drawing::EnhancedCustomShapeSegmentCommand::ANGLEELLIPSETO;
+				nLatestSegmentCommand = com::sun::star::drawing::EnhancedCustomShapeSegmentCommand::ANGLEELLIPSETO;
 				nParametersNeeded = 3;
 				nIndex++;
 			}
 			break;
 			case 'U' :
 			{
-				nLatestSegmentCommand = drafts::com::sun::star::drawing::EnhancedCustomShapeSegmentCommand::ANGLEELLIPSE;
+				nLatestSegmentCommand = com::sun::star::drawing::EnhancedCustomShapeSegmentCommand::ANGLEELLIPSE;
 				nParametersNeeded = 3;
 				nIndex++;
 			}
 			break;
 			case 'A' :
 			{
-				nLatestSegmentCommand = drafts::com::sun::star::drawing::EnhancedCustomShapeSegmentCommand::ARCTO;
+				nLatestSegmentCommand = com::sun::star::drawing::EnhancedCustomShapeSegmentCommand::ARCTO;
 				nParametersNeeded = 4;
 				nIndex++;
 			}
 			break;
 			case 'B' :
 			{
-				nLatestSegmentCommand = drafts::com::sun::star::drawing::EnhancedCustomShapeSegmentCommand::ARC;
+				nLatestSegmentCommand = com::sun::star::drawing::EnhancedCustomShapeSegmentCommand::ARC;
 				nParametersNeeded = 4;
 				nIndex++;
 			}
 			break;
 			case 'W' :
 			{
-				nLatestSegmentCommand = drafts::com::sun::star::drawing::EnhancedCustomShapeSegmentCommand::CLOCKWISEARCTO;
+				nLatestSegmentCommand = com::sun::star::drawing::EnhancedCustomShapeSegmentCommand::CLOCKWISEARCTO;
 				nParametersNeeded = 4;
 				nIndex++;
 			}
 			break;
 			case 'V' :
 			{
-				nLatestSegmentCommand = drafts::com::sun::star::drawing::EnhancedCustomShapeSegmentCommand::CLOCKWISEARC;
+				nLatestSegmentCommand = com::sun::star::drawing::EnhancedCustomShapeSegmentCommand::CLOCKWISEARC;
 				nParametersNeeded = 4;
 				nIndex++;
 			}
 			break;
 			case 'X' :
 			{
-				nLatestSegmentCommand = drafts::com::sun::star::drawing::EnhancedCustomShapeSegmentCommand::ELLIPTICALQUADRANTX;
+				nLatestSegmentCommand = com::sun::star::drawing::EnhancedCustomShapeSegmentCommand::ELLIPTICALQUADRANTX;
 				nParametersNeeded = 1;
 				nIndex++;
 			}
 			break;
 			case 'Y' :
 			{
-				nLatestSegmentCommand = drafts::com::sun::star::drawing::EnhancedCustomShapeSegmentCommand::ELLIPTICALQUADRANTY;
+				nLatestSegmentCommand = com::sun::star::drawing::EnhancedCustomShapeSegmentCommand::ELLIPTICALQUADRANTY;
 				nParametersNeeded = 1;
 				nIndex++;
 			}
 			break;
 			case 'Q' :
 			{
-				nLatestSegmentCommand = drafts::com::sun::star::drawing::EnhancedCustomShapeSegmentCommand::QUADRATICCURVETO;
+				nLatestSegmentCommand = com::sun::star::drawing::EnhancedCustomShapeSegmentCommand::QUADRATICCURVETO;
 				nParametersNeeded = 2;
 				nIndex++;
 			}
@@ -816,8 +816,8 @@
 			case '9' :
 			case '.' :
 			{
-				drafts::com::sun::star::drawing::EnhancedCustomShapeParameterPair aPair;
-				if ( GetNextParameter( aPair.First, nIndex, rValue ) && 
+				com::sun::star::drawing::EnhancedCustomShapeParameterPair aPair;
+				if ( GetNextParameter( aPair.First, nIndex, rValue ) &&
 						GetNextParameter( aPair.Second, nIndex, rValue ) )
 				{
 					vCoordinates.push_back( aPair );
@@ -833,7 +833,7 @@
 		}
 		if ( !nParameterCount && !nParametersNeeded )
 		{
-			drafts::com::sun::star::drawing::EnhancedCustomShapeSegment aSegment;
+			com::sun::star::drawing::EnhancedCustomShapeSegment aSegment;
 			aSegment.Command = nLatestSegmentCommand;
 			aSegment.Count = 0;
 			vSegments.push_back( aSegment );
@@ -843,11 +843,11 @@
 		{
 			// check if the last command is identical,
 			// if so, we just need to increment the count
-			if ( vSegments.size() && ( vSegments[ vSegments.size() - 1 ].Command == nLatestSegmentCommand ) )	
+			if ( vSegments.size() && ( vSegments[ vSegments.size() - 1 ].Command == nLatestSegmentCommand ) )
 				vSegments[ vSegments.size() -1 ].Count++;
 			else
 			{
-				drafts::com::sun::star::drawing::EnhancedCustomShapeSegment aSegment;
+				com::sun::star::drawing::EnhancedCustomShapeSegment aSegment;
 				aSegment.Command = nLatestSegmentCommand;
 				aSegment.Count = 1;
 				vSegments.push_back( aSegment );
@@ -856,10 +856,10 @@
 		}
 	}
 	// adding the Coordinates property
-	uno::Sequence< drafts::com::sun::star::drawing::EnhancedCustomShapeParameterPair > seqCoordinates( vCoordinates.size() );
-	std::vector< drafts::com::sun::star::drawing::EnhancedCustomShapeParameterPair >::const_iterator aCoordinatesIter = vCoordinates.begin();
-	std::vector< drafts::com::sun::star::drawing::EnhancedCustomShapeParameterPair >::const_iterator aCoordinatesEnd = vCoordinates.end();
-	drafts::com::sun::star::drawing::EnhancedCustomShapeParameterPair* pCoordinateValues = seqCoordinates.getArray();
+	uno::Sequence< com::sun::star::drawing::EnhancedCustomShapeParameterPair > seqCoordinates( vCoordinates.size() );
+	std::vector< com::sun::star::drawing::EnhancedCustomShapeParameterPair >::const_iterator aCoordinatesIter = vCoordinates.begin();
+	std::vector< com::sun::star::drawing::EnhancedCustomShapeParameterPair >::const_iterator aCoordinatesEnd = vCoordinates.end();
+	com::sun::star::drawing::EnhancedCustomShapeParameterPair* pCoordinateValues = seqCoordinates.getArray();
 
 	while ( aCoordinatesIter != aCoordinatesEnd )
 		*pCoordinateValues++ = *aCoordinatesIter++;
@@ -871,10 +871,10 @@
 
 
 	// adding the Segments property
-	uno::Sequence< drafts::com::sun::star::drawing::EnhancedCustomShapeSegment > seqSegments( vSegments.size() );
-	std::vector< drafts::com::sun::star::drawing::EnhancedCustomShapeSegment >::const_iterator aSegmentsIter = vSegments.begin();
-	std::vector< drafts::com::sun::star::drawing::EnhancedCustomShapeSegment >::const_iterator aSegmentsEnd = vSegments.end();
-	drafts::com::sun::star::drawing::EnhancedCustomShapeSegment* pSegmentValues = seqSegments.getArray();
+	uno::Sequence< com::sun::star::drawing::EnhancedCustomShapeSegment > seqSegments( vSegments.size() );
+	std::vector< com::sun::star::drawing::EnhancedCustomShapeSegment >::const_iterator aSegmentsIter = vSegments.begin();
+	std::vector< com::sun::star::drawing::EnhancedCustomShapeSegment >::const_iterator aSegmentsEnd = vSegments.end();
+	com::sun::star::drawing::EnhancedCustomShapeSegment* pSegmentValues = seqSegments.getArray();
 
 	while ( aSegmentsIter != aSegmentsEnd )
 		*pSegmentValues++ = *aSegmentsIter++;
@@ -887,13 +887,13 @@
 void GetAdjustmentValues( std::vector< com::sun::star::beans::PropertyValue >& rDest,				// draw:adjustments
 						const rtl::OUString& rValue )
 {
-	std::vector< drafts::com::sun::star::drawing::EnhancedCustomShapeAdjustmentValue > vAdjustmentValue;
-	drafts::com::sun::star::drawing::EnhancedCustomShapeParameter aParameter;
+	std::vector< com::sun::star::drawing::EnhancedCustomShapeAdjustmentValue > vAdjustmentValue;
+	com::sun::star::drawing::EnhancedCustomShapeParameter aParameter;
 	sal_Int32 nIndex = 0;
 	while ( GetNextParameter( aParameter, nIndex, rValue ) )
 	{
-		drafts::com::sun::star::drawing::EnhancedCustomShapeAdjustmentValue aAdj;
-		if ( aParameter.Type == drafts::com::sun::star::drawing::EnhancedCustomShapeParameterType::NORMAL )
+		com::sun::star::drawing::EnhancedCustomShapeAdjustmentValue aAdj;
+		if ( aParameter.Type == com::sun::star::drawing::EnhancedCustomShapeParameterType::NORMAL )
 		{
 			aAdj.Value <<= aParameter.Value;
 			aAdj.State = beans::PropertyState_DIRECT_VALUE;
@@ -907,10 +907,10 @@
 	sal_Int32 nAdjustmentValues = vAdjustmentValue.size();
 	if ( nAdjustmentValues )
 	{
-		uno::Sequence< drafts::com::sun::star::drawing::EnhancedCustomShapeAdjustmentValue > aAdjustmentValues( nAdjustmentValues );
-		std::vector< drafts::com::sun::star::drawing::EnhancedCustomShapeAdjustmentValue >::const_iterator aIter = vAdjustmentValue.begin();
-		std::vector< drafts::com::sun::star::drawing::EnhancedCustomShapeAdjustmentValue >::const_iterator aEnd = vAdjustmentValue.end();
-		drafts::com::sun::star::drawing::EnhancedCustomShapeAdjustmentValue* pValues = aAdjustmentValues.getArray();
+		uno::Sequence< com::sun::star::drawing::EnhancedCustomShapeAdjustmentValue > aAdjustmentValues( nAdjustmentValues );
+		std::vector< com::sun::star::drawing::EnhancedCustomShapeAdjustmentValue >::const_iterator aIter = vAdjustmentValue.begin();
+		std::vector< com::sun::star::drawing::EnhancedCustomShapeAdjustmentValue >::const_iterator aEnd = vAdjustmentValue.end();
+		com::sun::star::drawing::EnhancedCustomShapeAdjustmentValue* pValues = aAdjustmentValues.getArray();
 
 		while ( aIter != aEnd )
 			*pValues++ = *aIter++;
@@ -976,9 +976,9 @@
 				case EAS_extrusion_depth :
 				{
 					sal_Int32 nIndex = 0;
-					drafts::com::sun::star::drawing::EnhancedCustomShapeParameterPair aParameterPair;
-					drafts::com::sun::star::drawing::EnhancedCustomShapeParameter& rDepth = aParameterPair.First;
-					drafts::com::sun::star::drawing::EnhancedCustomShapeParameter& rFraction = aParameterPair.Second;
+					com::sun::star::drawing::EnhancedCustomShapeParameterPair aParameterPair;
+					com::sun::star::drawing::EnhancedCustomShapeParameter& rDepth = aParameterPair.First;
+					com::sun::star::drawing::EnhancedCustomShapeParameter& rFraction = aParameterPair.Second;
 					if ( GetNextParameter( rDepth, nIndex, rValue ) )
 					{
 						// try to catch the unit for the depth
@@ -1136,11 +1136,11 @@
 				break;
 				case EAS_text_path_mode :
 				{
-					drafts::com::sun::star::drawing::EnhancedCustomShapeTextPathMode eTextPathMode( drafts::com::sun::star::drawing::EnhancedCustomShapeTextPathMode_NORMAL );
+					com::sun::star::drawing::EnhancedCustomShapeTextPathMode eTextPathMode( com::sun::star::drawing::EnhancedCustomShapeTextPathMode_NORMAL );
 					if( IsXMLToken( rValue, XML_PATH ) )
-						eTextPathMode = drafts::com::sun::star::drawing::EnhancedCustomShapeTextPathMode_PATH;
+						eTextPathMode = com::sun::star::drawing::EnhancedCustomShapeTextPathMode_PATH;
 					else if ( IsXMLToken( rValue, XML_SHAPE ) )
-						eTextPathMode = drafts::com::sun::star::drawing::EnhancedCustomShapeTextPathMode_SHAPE;
+						eTextPathMode = com::sun::star::drawing::EnhancedCustomShapeTextPathMode_SHAPE;
 
 					beans::PropertyValue aProp;
 					aProp.Name = EASGet( EAS_TextPathMode );
@@ -1229,9 +1229,9 @@
 
 /* if rPara.Type is from type EnhancedCustomShapeParameterType::EQUATION, the name of the equation
    will be converted from rtl::OUString to index */
-void CheckAndResolveEquationParameter( drafts::com::sun::star::drawing::EnhancedCustomShapeParameter& rPara, EquationHashMap* pH )
+void CheckAndResolveEquationParameter( com::sun::star::drawing::EnhancedCustomShapeParameter& rPara, EquationHashMap* pH )
 {
-	if ( rPara.Type == drafts::com::sun::star::drawing::EnhancedCustomShapeParameterType::EQUATION )
+	if ( rPara.Type == com::sun::star::drawing::EnhancedCustomShapeParameterType::EQUATION )
 	{
 		rtl::OUString aEquationName;
 		if ( rPara.Value >>= aEquationName )
@@ -1259,7 +1259,7 @@
 			(*pH)[ *aEquationNameIter ] = (sal_Int32)( aEquationNameIter - maEquationNames.begin() );
 			aEquationNameIter++;
 		}
-		
+
 		// resolve equation
 		std::vector< rtl::OUString >::iterator aEquationIter = maEquations.begin();
 		std::vector< rtl::OUString >::iterator aEquationEnd  = maEquations.end();
@@ -1302,8 +1302,8 @@
 				case EAS_Coordinates :
 				case EAS_GluePoints :
 				{
-					uno::Sequence< drafts::com::sun::star::drawing::EnhancedCustomShapeParameterPair >& rSeq =
-						*((uno::Sequence< drafts::com::sun::star::drawing::EnhancedCustomShapeParameterPair >*)
+					uno::Sequence< com::sun::star::drawing::EnhancedCustomShapeParameterPair >& rSeq =
+						*((uno::Sequence< com::sun::star::drawing::EnhancedCustomShapeParameterPair >*)
 							aPathIter->Value.getValue());
 					for ( i = 0; i < rSeq.getLength(); i++ )
 					{
@@ -1314,8 +1314,8 @@
 				break;
 				case EAS_TextFrames :
 				{
-					uno::Sequence< drafts::com::sun::star::drawing::EnhancedCustomShapeTextFrame >& rSeq =
-						*((uno::Sequence< drafts::com::sun::star::drawing::EnhancedCustomShapeTextFrame >*)
+					uno::Sequence< com::sun::star::drawing::EnhancedCustomShapeTextFrame >& rSeq =
+						*((uno::Sequence< com::sun::star::drawing::EnhancedCustomShapeTextFrame >*)
 							aPathIter->Value.getValue());
 					for ( i = 0; i < rSeq.getLength(); i++ )
 					{
@@ -1346,15 +1346,15 @@
 					case EAS_RadiusRangeMinimum :
 					case EAS_RadiusRangeMaximum :
 					{
-						CheckAndResolveEquationParameter( *((drafts::com::sun::star::drawing::EnhancedCustomShapeParameter*)
+						CheckAndResolveEquationParameter( *((com::sun::star::drawing::EnhancedCustomShapeParameter*)
 							pValues->Value.getValue()), pH );
 					}
 					break;
 					case EAS_Polar :
 					{
-						CheckAndResolveEquationParameter( (*((drafts::com::sun::star::drawing::EnhancedCustomShapeParameterPair*)
+						CheckAndResolveEquationParameter( (*((com::sun::star::drawing::EnhancedCustomShapeParameterPair*)
 							pValues->Value.getValue())).First, pH );
-						CheckAndResolveEquationParameter( (*((drafts::com::sun::star::drawing::EnhancedCustomShapeParameterPair*)
+						CheckAndResolveEquationParameter( (*((com::sun::star::drawing::EnhancedCustomShapeParameterPair*)
 							pValues->Value.getValue())).Second, pH );
 					}
 					break;
diff -u -r  xmloff/source/draw/ximpcustomshape.hxx  xmloff/source/draw/ximpcustomshape.hxx
---  xmloff/source/draw/ximpcustomshape.hxx	2004-11-26 19:40:35.000000000 +0530
+++  xmloff/source/draw/ximpcustomshape.hxx	2005-02-28 13:41:40.239837544 +0530
@@ -75,14 +75,14 @@
 #ifndef _COM_SUN_STAR_UNO_REFERENCE_H_
 #include <com/sun/star/uno/Reference.h>
 #endif
-#ifndef _COM_SUN_STAR_BEANS_PROPERTYVALUE_HPP_ 
+#ifndef _COM_SUN_STAR_BEANS_PROPERTYVALUE_HPP_
 #include <com/sun/star/beans/PropertyValue.hpp>
 #endif
-#ifndef __com_sun_star_beans_PropertyValues_hpp__ 
+#ifndef __com_sun_star_beans_PropertyValues_hpp__
 #include <com/sun/star/beans/PropertyValues.hpp>
 #endif
-#ifndef _DRAFTS_COM_SUN_STAR_DRAWING_ENHANCEDCUSTOMSHAPEPARAMETER_HPP_
-#include <drafts/com/sun/star/drawing/EnhancedCustomShapeParameter.hpp>
+#ifndef _COM_SUN_STAR_DRAWING_ENHANCEDCUSTOMSHAPEPARAMETER_HPP_
+#include <com/sun/star/drawing/EnhancedCustomShapeParameter.hpp>
 #endif
 
 namespace com { namespace sun { namespace star {
--- /dev/null	2004-08-25 23:04:59.000000000 +0530
+++ basegfx/inc/basegfx/vector/b2enums.hxx	2005-02-28 13:46:02.000000000 +0530
@@ -0,0 +1,101 @@
+/*************************************************************************
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
+ *
+ *  Copyright: 2000 by Sun Microsystems, Inc.
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+
+#ifndef _BGFX_VECTOR_B2ENUMS_HXX
+#define _BGFX_VECTOR_B2ENUMS_HXX
+
+#ifndef _SAL_TYPES_H_
+#include <sal/types.h>
+#endif
+
+namespace basegfx
+{
+	/**	Descriptor for the mathematical orientations of two 2D Vectors
+	*/
+	enum B2VectorOrientation
+	{
+		/// mathematically positive oriented
+		ORIENTATION_POSITIVE = 0,
+	    
+		/// mathematically negative oriented
+		ORIENTATION_NEGATIVE,
+	    
+		/// mathematically neutral, thus parallel
+		ORIENTATION_NEUTRAL
+	};
+
+	/**	Descriptor for the mathematical continuity of two 2D Vectors
+	*/
+	enum B2VectorContinuity
+	{
+		/// none
+		CONTINUITY_NONE = 0,
+	    
+		/// mathematically negative oriented
+		CONTINUITY_C1,
+	    
+		/// mathematically neutral, thus parallel
+		CONTINUITY_C2
+	};
+
+} // end of namespace basegfx
+
+#endif /* _BGFX_VECTOR_B2ENUMS_HXX */
--- /dev/null	2004-08-25 23:04:59.000000000 +0530
+++ canvas/inc/canvas/prioritybooster.hxx	2005-02-28 13:41:07.000000000 +0530
@@ -0,0 +1,101 @@
+/*************************************************************************
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
+ *
+ *  Copyright: 2000 by Sun Microsystems, Inc.
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+
+#ifndef _CANVAS_PRIORITYBOOSTER_HXX
+#define _CANVAS_PRIORITYBOOSTER_HXX
+
+#ifndef _SAL_TYPES_H_
+#include <sal/types.h>
+#endif
+
+#include <memory>
+
+
+namespace canvas
+{
+    namespace tools
+    {
+        struct PriorityBooster_Impl;
+
+        /** Simplistic RAII object, to temporarily boost execution
+            priority for the current scope.
+         */
+        class PriorityBooster
+        {
+        public:
+            /** Create booster, with given priority delta
+
+            	@param nDelta
+                Difference in execution priority. Positive values
+                increase prio, negative values decrease prio.
+             */
+            explicit PriorityBooster( sal_Int32 nDelta );
+            ~PriorityBooster();
+
+        private:
+            // also disables copy constructor and assignment operator
+            const ::std::auto_ptr< PriorityBooster_Impl > mpImpl;
+        };
+    }
+}
+
+#endif /* _CANVAS_PRIORITYBOOSTER_HXX */
+// eof
--- /dev/null	2004-08-25 23:04:59.000000000 +0530
+++ canvas/source/tools/prioritybooster.cxx	2005-02-28 13:41:08.000000000 +0530
@@ -0,0 +1,103 @@
+/*************************************************************************
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
+ *
+ *  Copyright: 2000 by Sun Microsystems, Inc.
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+
+
+#ifdef WNT            
+#include <windows.h>
+#endif
+
+#include "osl/diagnose.h"
+#include "canvas/prioritybooster.hxx"
+
+
+namespace canvas
+{
+    namespace tools
+    {
+        struct PriorityBooster_Impl
+        {
+            int mnOldPriority;
+        };
+
+        PriorityBooster::PriorityBooster( sal_Int32 nDelta ) : 
+            mpImpl( new PriorityBooster_Impl )
+        {
+#ifdef WNT            
+            HANDLE aCurrThread = GetCurrentThread();
+            mpImpl->mnOldPriority = GetThreadPriority( aCurrThread );
+
+            const bool bSuccess( 0 != SetThreadPriority( aCurrThread, mpImpl->mnOldPriority + nDelta ) );
+
+            OSL_ENSURE( bSuccess,
+                        "PriorityBooster::PriorityBooster(): Was not able to modify thread priority" );
+#endif            
+        }
+
+        PriorityBooster::~PriorityBooster()
+        {
+#ifdef WNT            
+            SetThreadPriority( GetCurrentThread(), 
+                               mpImpl->mnOldPriority );
+#endif
+        }
+	} // namespace tools
+
+} // namespace canvas
--- /dev/null	2004-08-25 23:04:59.000000000 +0530
+++ comphelper/inc/comphelper/optional.hxx	2005-02-28 13:41:05.000000000 +0530
@@ -0,0 +1,138 @@
+/*************************************************************************
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
+ *
+ *  Copyright: 2000 by Sun Microsystems, Inc.
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+
+#if ! defined(INCLUDED_COMPHELPER_OPTIONAL_HXX)
+#define INCLUDED_COMPHELPER_OPTIONAL_HXX
+
+#include "com/sun/star/beans/Optional.hpp"
+#include "boost/optional.hpp"
+#include "boost/type_traits.hpp"
+#include "boost/static_assert.hpp"
+
+//=== static (compile time) assertions for C++-UNO:
+// TODO: move to cppu?
+
+#if defined(__SUNPRO_CC)
+#define CPPU_STATIC_ASSERT_HAS_GETCPPUTYPE(THE_TYPE)
+#else
+#define CPPU_STATIC_ASSERT_HAS_GETCPPUTYPE(THE_TYPE) \
+do { \
+static_cast< ::com::sun::star::uno::Type const & (SAL_CALL *)( \
+THE_TYPE const * ) >(&getCppuType); \
+} while (0)
+#endif // defined(__SUNPRO_CC)
+
+#define CPPU_STATIC_ASSERT_IS_UNOTYPE(THE_TYPE) \
+CPPU_STATIC_ASSERT_HAS_GETCPPUTYPE(THE_TYPE); \
+BOOST_STATIC_ASSERT( (! ::boost::is_same<THE_TYPE, bool>::value) )
+
+namespace comphelper {
+
+//=== helpers and conversions for beans::Optional<T> from/to boost::optional<T>:
+
+/// Object generator for boost::optional<T>
+template <typename T>
+inline ::boost::optional<T> make_optional( T const & v )
+{
+    return ::boost::optional<T>(v);
+}
+
+/// specialization: Object generator for boost::optional< beans::Optional<T> >
+template <typename T>
+inline ::boost::optional<T> make_optional(
+    ::com::sun::star::beans::Optional<T> const & o )
+{
+    if (o.IsPresent)
+        return ::boost::optional<T>(o.Value);
+    else
+        return ::boost::optional<T>();
+}
+
+/// Object generator for beans::Optional<T>
+template <typename T>
+inline ::com::sun::star::beans::Optional<T> makeOptional( T const & v )
+{
+    CPPU_STATIC_ASSERT_IS_UNOTYPE(T);
+    return ::com::sun::star::beans::Optional<T>(true, v);
+}
+
+/// specialization: Object generator for beans::Optional< boost::optional<T> >
+template <typename T>
+inline ::com::sun::star::beans::Optional<T> makeOptional(
+    ::boost::optional<T> const & o )
+{
+    CPPU_STATIC_ASSERT_IS_UNOTYPE(T);
+    if (o)
+        return ::com::sun::star::beans::Optional<T>(true, *o);
+    else
+        return ::com::sun::star::beans::Optional<T>();
+}
+
+/// specialization: Object generator for beans::Optional<bool>
+inline ::com::sun::star::beans::Optional<sal_Bool> makeOptional( bool v )
+{
+    return ::com::sun::star::beans::Optional<sal_Bool>(true, v);
+}
+
+} // namespace comphelper
+
+#endif
+
--- /dev/null	2004-08-25 23:04:59.000000000 +0530
+++ comphelper/inc/comphelper/scopeguard.hxx	2005-02-28 13:41:05.000000000 +0530
@@ -0,0 +1,100 @@
+/*************************************************************************
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
+ *
+ *  Copyright: 2000 by Sun Microsystems, Inc.
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+
+#if ! defined(INCLUDED_COMPHELPER_SCOPEGUARD_HXX)
+#define INCLUDED_COMPHELPER_SCOPEGUARD_HXX
+
+#include "boost/function.hpp"
+#include "boost/noncopyable.hpp"
+
+namespace comphelper {
+
+/** ScopeGuard to ease writing exception-safe code.
+ */
+class ScopeGuard : private boost::noncopyable // noncopyable until we have
+                                              // good reasons...
+{
+public:
+    /** @param func function object to be executed in dtor
+        @param bIgnoreExceptions if true (default),
+                                 thrown exceptions in dtor will be
+                                 silently ignored (but OSL_ asserted)
+    */
+    template <typename FuncT>
+    explicit ScopeGuard( FuncT func, bool bIgnoreExceptions = true )
+        : m_func(func), m_bIgnoreExceptions(bIgnoreExceptions) {}
+    
+    ~ScopeGuard();
+    
+    /** Dismisses the scope guard, i.e. the function won't
+        be executed.
+    */
+    void dismiss();
+    
+private:
+    ::boost::function0<void> m_func;
+    const bool m_bIgnoreExceptions;
+};
+
+} // namespace comphelper
+
+#endif
+
--- /dev/null	2004-08-25 23:04:59.000000000 +0530
+++ comphelper/source/misc/scopeguard.cxx	2005-02-28 13:41:05.000000000 +0530
@@ -0,0 +1,101 @@
+/*************************************************************************
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
+ *
+ *  Copyright: 2000 by Sun Microsystems, Inc.
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+
+#include "comphelper/scopeguard.hxx"
+#include "osl/diagnose.h"
+#include "com/sun/star/uno/Exception.hpp"
+
+namespace comphelper {
+
+ScopeGuard::~ScopeGuard()
+{
+    if (m_func)
+    {
+        if (m_bIgnoreExceptions)
+        {
+            try {
+                m_func();
+            }
+            catch (com::sun::star::uno::Exception & exc) {
+                OSL_ENSURE(
+                    false, rtl::OUStringToOString(
+                        rtl::OUString( RTL_CONSTASCII_USTRINGPARAM(
+                                           "UNO exception occured: ") ) +
+                        exc.Message, RTL_TEXTENCODING_UTF8 ).getStr() );
+            }
+            catch (...) {
+                OSL_ENSURE( false, "unknown exception occured!" );
+            }
+        }
+        else
+        {
+            m_func();
+        }
+    }
+}
+
+void ScopeGuard::dismiss()
+{
+    m_func.clear();
+}
+
+} // namespace comphelper
+
--- /dev/null	2004-08-25 23:04:59.000000000 +0530
+++ offapi/com/sun/star/drawing/CustomShapeEngine.idl	2005-02-28 13:41:26.000000000 +0530
@@ -0,0 +1,98 @@
+/*************************************************************************
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
+ *
+ *  Copyright: 2000 by Sun Microsystems, Inc.
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+#ifndef __drafts_com_sun_star_drawing_CustomShapeEngine_idl__ 
+#define __com_sun_star_drawing_CustomShapeEngine_idl__ 
+ 
+#ifndef __com_sun_star_lang_XInitialization_idl__ 
+#include <com/sun/star/lang/XInitialization.idl> 
+#endif 
+ 
+#ifndef __com_sun_star_drawing_XCustomShapeEngine_idl__
+#include <com/sun/star/drawing/XCustomShapeEngine.idl>
+#endif
+
+//============================================================================= 
+ 
+module com {  module sun {  module star {  module drawing {  
+ 
+//============================================================================= 
+ 
+/** This service is for a CustomShape
+ */
+service CustomShapeEngine
+{ 
+	/** initializing the CustomShapeEngine
+
+	 */
+	interface ::com::sun::star::lang::XInitialization;
+
+	/** 
+
+	 */
+	interface com::sun::star::drawing::XCustomShapeEngine;
+}; 
+ 
+//============================================================================= 
+ 
+}; }; }; };  
+ 
+#endif 
+
--- /dev/null	2004-08-25 23:04:59.000000000 +0530
+++ offapi/com/sun/star/drawing/CustomShape.idl	2005-02-28 13:41:26.000000000 +0530
@@ -0,0 +1,150 @@
+/*************************************************************************
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
+ *
+ *  Copyright: 2000 by Sun Microsystems, Inc.
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+#ifndef __drafts_com_sun_star_drawing_CustomShape_idl__ 
+#define __com_sun_star_drawing_CustomShape_idl__ 
+ 
+#ifndef __com_sun_star_drawing_Shape_idl__ 
+#include <com/sun/star/drawing/Shape.idl> 
+#endif 
+ 
+#ifndef __com_sun_star_drawing_FillProperties_idl__ 
+#include <com/sun/star/drawing/FillProperties.idl> 
+#endif 
+
+#ifndef __com_sun_star_drawing_LineProperties_idl__ 
+#include <com/sun/star/drawing/LineProperties.idl> 
+#endif 
+ 
+#ifndef __com_sun_star_drawing_ShadowProperties_idl__ 
+#include <com/sun/star/drawing/ShadowProperties.idl> 
+#endif 
+
+#ifndef __com_sun_star_drawing_Text_idl__ 
+#include <com/sun/star/drawing/Text.idl> 
+#endif 
+
+#ifndef __com_sun_star_drawing_RotationDescriptor_idl__ 
+#include <com/sun/star/drawing/RotationDescriptor.idl> 
+#endif 
+ 
+#ifndef __com_sun_star_beans_PropertyValue_idl__
+#include <com/sun/star/beans/PropertyValue.idl>
+#endif
+
+//============================================================================= 
+ 
+module com {  module sun {  module star {  module drawing {  
+ 
+//============================================================================= 
+ 
+/** This service is for a CustomShape
+ */
+service CustomShape
+{ 
+	service com::sun::star::drawing::Shape; 
+
+	service com::sun::star::drawing::FillProperties; 
+
+	service com::sun::star::drawing::LineProperties; 
+
+	service com::sun::star::drawing::ShadowProperties; 
+
+	service com::sun::star::drawing::Text; 
+	
+	service com::sun::star::drawing::RotationDescriptor; 
+
+	//-------------------------------------------------------------------------
+	/** This property contains the CustomShapeEngine service name that has to
+	    be used for rendering.
+	*/
+	[property] string CustomShapeEngine;
+
+	//-------------------------------------------------------------------------
+	/** This property can be used to store data that the CustomShapeEngine may
+	    use for rendering
+	*/
+	[optional, property] string CustomShapeData;
+
+	//-------------------------------------------------------------------------
+	/** This property describes the geometry of the CustomShape. The CustomShapeEngine
+	    that is used should be able to get on with the content of this property.
+	    
+	    If the CustomShapeEngine property is "drafts.com.sun.star.drawing.EnhancedCustomShapeEngine",
+	    then this property is containing properties as they are specified in the service
+	    drafts.com.sun.star.drawing.EnhancedCustomShapeGeometry
+	*/
+	[optional, property] sequence<::com::sun::star::beans::PropertyValue> CustomShapeGeometry;
+
+	//-------------------------------------------------------------------------
+	/**	This property describes the URL to a replacement graphic that could
+		be displayed if the CustomShape engine is not available.
+	*/
+	[optional, property] string CustomShapeReplacementURL;
+
+	//-------------------------------------------------------------------------
+}; 
+ 
+//============================================================================= 
+ 
+}; }; }; };  
+ 
+#endif 
+
--- /dev/null	2004-08-25 23:04:59.000000000 +0530
+++ offapi/com/sun/star/drawing/EnhancedCustomShapeAdjustmentValue.idl	2005-02-28 13:41:25.000000000 +0530
@@ -0,0 +1,92 @@
+/*************************************************************************
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
+ *
+ *  Copyright: 2000 by Sun Microsystems, Inc.
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+#ifndef __com_sun_star_drawing_EnhancedCustomShapeAdjustmentValue_idl__
+#define __com_sun_star_drawing_EnhancedCustomShapeAdjustmentValue_idl__
+
+#ifndef __com_sun_star_beans_PropertyState_idl__
+#include <com/sun/star/beans/PropertyState.idl>
+#endif
+
+//============================================================================= 
+ 
+ module com {  module sun {  module star {  module drawing {
+ 
+//============================================================================= 
+ 
+/** specifies a single AdjustmentValue
+ */
+struct EnhancedCustomShapeAdjustmentValue
+{
+	/** the any can be of type long or double
+	*/
+	any		Value;
+
+	/**
+	*/
+	::com::sun::star::beans::PropertyState State;
+}; 
+ 
+//============================================================================= 
+ 
+}; }; }; };
+ 
+#endif 
+
--- /dev/null	2004-08-25 23:04:59.000000000 +0530
+++ offapi/com/sun/star/drawing/EnhancedCustomShapeExtrusion.idl	2005-02-28 13:41:26.000000000 +0530
@@ -0,0 +1,210 @@
+/*************************************************************************
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
+ *
+ *  Copyright: 2000 by Sun Microsystems, Inc.
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+#ifndef __drafts_com_sun_star_drawing_EnhancedCustomShapeExtrusion_idl__
+#define __com_sun_star_drawing_EnhancedCustomShapeExtrusion_idl__
+
+#ifndef __com_sun_star_awt_Size_idl__ 
+#include <com/sun/star/awt/Size.idl>
+#endif
+#ifndef __com_sun_star_awt_Point_idl__ 
+#include <com/sun/star/awt/Point.idl>
+#endif
+#ifndef __com_sun_star_beans_PropertyValue_idl__
+#include <com/sun/star/beans/PropertyValue.idl>
+#endif
+#ifndef __com_sun_star_drawing_Position3D_idl__ 
+#include <com/sun/star/drawing/Position3D.idl>
+#endif
+#ifndef __com_sun_star_drawing_Direction3D_idl__ 
+#include <com/sun/star/drawing/Direction3D.idl>
+#endif
+#ifndef __com_sun_star_drawing_ProjectionMode_idl__ 
+#include <com/sun/star/drawing/ProjectionMode.idl>
+#endif
+#ifndef __com_sun_star_drawing_ShadeMode_idl__ 
+#include <com/sun/star/drawing/ShadeMode.idl>
+#endif
+#ifndef __com_sun_star_drawing_EnhancedCustomShapeParameterPair_idl__
+#include <com/sun/star/drawing/EnhancedCustomShapeParameterPair.idl>
+#endif
+
+//=============================================================================
+
+module com { module sun { module star { module drawing { 
+
+//=============================================================================
+/**
+  This service may be represented by a ::com::sun::star::beans::PropertyValue [].
+*/
+
+service EnhancedCustomShapeExtrusion
+{
+	/** This property specifies if extrusion is displayed. The default for this property
+		is "false"
+	*/
+	[optional, property] boolean Extrusion;
+
+	/** This attribute specifies the brightness of a scene in percent.
+	*/
+	[optional, property] double Brightness;
+
+	/** The first value of EnhancedCustomShapeParameterPair specifies the depth of the
+		extrusion in 1/100 mm. The second value (0.0 to 1.0) specifies the fraction of
+		the extrusion that lies before the shape, a value of 0 is default.
+	*/
+	[optional, property] ::com::sun::star::drawing::EnhancedCustomShapeParameterPair Depth;
+
+	/** This attribute specifies the amount of diffusion reflected by the shape
+        in percent
+	*/
+	[optional, property] double Diffusion;
+
+	/** Specifies the number of line segments that should be used to display curved surfaces.
+		The higher the number the more line segments are used.
+	*/
+	[optional, property] long NumberOfLineSegments;
+
+	/** Specifies if the front face of the extrusion responds to lightning changes.
+	*/
+	[optional, property] boolean LightFace;
+
+	/** Specifies if the primary light is harsh.
+	*/
+	[optional, property] boolean FirstLightHarsh;
+
+	/** Specifies if the secondary light is harsh.
+	*/
+	[optional, property] boolean SecondLightHarsh;
+
+	/** Specifies the intensity for the first light in percent.
+	*/
+	[optional, property] double FirstLightLevel;
+
+	/** Specifies the intensity for the second light in percent.
+	*/
+	[optional, property] double SecondLightLevel;
+
+	/** Specifies the direction of the first light.
+	*/
+	[optional, property] ::com::sun::star::drawing::Direction3D FirstLightDirection;
+
+	/** Specifies the direction of the second light.
+	*/
+	[optional, property] ::com::sun::star::drawing::Direction3D SecondLightDirection;
+
+	/** Specifies if the surface of the extrusion object looks like metal.
+	*/
+	[optional, property] boolean Metal;
+
+	/** This property defines the shade mode.
+	*/
+	[optional, property] ::com::sun::star::drawing::ShadeMode ShadeMode;
+	
+	/**	This attributes specifies the rotation angle about the x-axis in grad. 
+	    The order of rotation is: z-axis, y-axis and then x-axis. The z-axis is 
+		specified by the draw:rotate-angle.
+	*/
+	[optional, property] ::com::sun::star::drawing::EnhancedCustomShapeParameterPair RotateAngle;
+
+	/** This attribute specifies the position of the rotate center 
+	    in terms of shape size fractions, if the property is omitted, then
+		the geometrical center of the shape is used (this is the default).
+	*/
+	[optional, property] ::com::sun::star::drawing::Direction3D RotationCenter;
+
+	/** The draw:extrusion-shininess specifies the shininess of a mirror in percent.
+	*/
+	[optional, property] double Shininess;
+
+	/** The first value of the draw:extrusion-skew attribute specifies the skew amount of
+		an extrusion in	percent. The second parameter specifies the skew-angle. Skew settings
+		are only applied if the attribute ProjectionMode is ProjectionMode_PARALLEL.
+	*/
+	[optional, property] ::com::sun::star::drawing::EnhancedCustomShapeParameterPair Skew;
+
+	/** This attribute specifies the specularity of an extrusion object in percent.
+	*/
+	[optional, property] double Specularity;
+
+	/** This property defines the projection mode.
+	*/
+	[optional, property] com::sun::star::drawing::ProjectionMode ProjectionMode;
+
+	/** This attribute specifies the viewpoint of the observer.
+	*/
+	[optional, property] ::com::sun::star::drawing::Position3D ViewPoint;
+
+	/** This attribute specifies the origin within the bounding box of the
+	    shape in terms of the shape size fractions.
+	*/
+	[optional, property] ::com::sun::star::drawing::EnhancedCustomShapeParameterPair Origin;
+
+	/** This attribute specifies if the "SecondFillColor" is used as extrusion color
+	*/
+	[optional, property] boolean ExtrusionColor;
+};
+
+//=============================================================================
+
+}; }; }; }; 
+
+#endif
+
--- /dev/null	2004-08-25 23:04:59.000000000 +0530
+++ offapi/com/sun/star/drawing/EnhancedCustomShapeGluePointType.idl	2005-02-28 13:41:25.000000000 +0530
@@ -0,0 +1,98 @@
+/*************************************************************************
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
+ *
+ *  Copyright: 2000 by Sun Microsystems, Inc.
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+#ifndef __com_sun_star_drawing_EnhancedCustomShapeGluePointType_idl__ 
+#define __com_sun_star_drawing_EnhancedCustomShapeGluePointType_idl__ 
+ 
+ 
+//============================================================================= 
+ 
+ module com {  module sun {  module star {  module drawing {  
+ 
+//============================================================================= 
+ 
+/** defines which gluepoints are being offered by the EnhancedCustomShape
+ */
+constants EnhancedCustomShapeGluePointType
+{ 
+	/** no gluepoints are offered 
+	 */
+	const short NONE = 0;
+ 
+	/** gluepoints are offered for each segment 
+	 */
+	const short SEGMENTS = 1;
+ 
+	/** only glue points of the GluePoints property from the 
+	    drafts::com::sun:star::drawing::EnhancedCustomShapePath are offered
+	 */
+	const short CUSTOM = 2;
+
+	/** standard top, left, right, bottom glue points are offered
+	 */
+	const short RECT = 3;
+ }; 
+ 
+//============================================================================= 
+ 
+}; }; }; };
+ 
+#endif 
+
--- /dev/null	2004-08-25 23:04:59.000000000 +0530
+++ offapi/com/sun/star/drawing/EnhancedCustomShapeHandle.idl	2005-02-28 13:41:26.000000000 +0530
@@ -0,0 +1,135 @@
+/*************************************************************************
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
+ *
+ *  Copyright: 2000 by Sun Microsystems, Inc.
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+#ifndef __drafts_com_sun_star_drawing_EnhancedCustomShapeHandle_idl__
+#define __com_sun_star_drawing_EnhancedCustomShapeHandle_idl__
+
+#ifndef __com_sun_star_drawing_EnhancedCustomShapeParameterPair_idl__
+#include <com/sun/star/drawing/EnhancedCustomShapeParameterPair.idl>
+#endif
+
+//============================================================================= 
+ 
+ module com {  module sun {  module star {  module drawing {  
+ 
+//============================================================================= 
+ 
+/**
+  This service may be represented by a ::com::sun::star::beans::PropertyValue [].
+*/
+
+service EnhancedCustomShapeHandle
+{
+	/** Specifies if the x position of the handle is mirrored.
+	*/
+	[optional, property] boolean MirroredX;
+
+	/** Specifies if the y position of the handle is mirrored.
+	*/
+	[optional, property] boolean MirroredY;
+
+	/** Specifies if the handle directions are swapped if the shape is taller than wide.
+	*/
+	[optional, property] boolean Switched;
+
+	/** If the property Polar is set, then the first value specifies the radius and the second
+	    parameter the angle of the handle. Otherwise, if the handle is not polar, the first parameter
+		specifies the horizontal handle position, the vertical handle position is described by the
+		second parameter.
+	*/
+	[optional, property] ::com::sun::star::drawing::EnhancedCustomShapeParameterPair Position;
+
+	/** If this attribute is set, the handle is a polar handle. The property specifies the center
+	    position of the handle. If this attribute is set, the attributes RangeX and RangeY are ignored,
+		instead the attribute RadiusRange is used.
+	*/
+	[optional, property] ::com::sun::star::drawing::EnhancedCustomShapeParameterPair Polar;
+
+	/** If the attribute RangeXMinimum is set, it specifies the horizontal minimum range of the handle.
+	*/
+	[optional, property] ::com::sun::star::drawing::EnhancedCustomShapeParameter RangeXMinimum;
+
+	/** If the attribute RangeXMaximum is set, it specifies the horizontal maximum range of the handle.
+	*/
+	[optional, property] ::com::sun::star::drawing::EnhancedCustomShapeParameter RangeXMaximum;
+
+	/** If the attribute RangeYMinimum is set, it specifies the vertical minimum range of the handle.
+	*/
+	[optional, property] ::com::sun::star::drawing::EnhancedCustomShapeParameter RangeYMinimum;
+
+	/** If the attribute RangeYMaximum is set, it specifies the vertical maximum range of the handle.
+	*/
+	[optional, property] ::com::sun::star::drawing::EnhancedCustomShapeParameter RangeYMaximum;
+	
+	/** If this attribute is set, it specifies the minimum radius range that can be used for a polar handle. 
+	*/
+	[optional, property] ::com::sun::star::drawing::EnhancedCustomShapeParameter RadiusRangeMinimum;
+
+	/** If this attribute is set, it specifies the maximum radius range that can be used for a polar handle. 
+	*/
+	[optional, property] ::com::sun::star::drawing::EnhancedCustomShapeParameter RadiusRangeMaximum;
+};
+ 
+//============================================================================= 
+ 
+}; }; }; };
+ 
+#endif 
+
--- /dev/null	2004-08-25 23:04:59.000000000 +0530
+++ offapi/com/sun/star/drawing/EnhancedCustomShapeParameter.idl	2005-02-28 13:41:25.000000000 +0530
@@ -0,0 +1,88 @@
+/*************************************************************************
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
+ *
+ *  Copyright: 2000 by Sun Microsystems, Inc.
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+#ifndef __com_sun_star_drawing_EnhancedCustomShapeParameter_idl__
+#define __com_sun_star_drawing_EnhancedCustomShapeParameter_idl__
+ 
+//============================================================================= 
+ 
+ module com {  module sun {  module star {  module drawing {
+ 
+//============================================================================= 
+ 
+/** specifies a single value which is used with EnhancedCustomShapes
+ */
+struct EnhancedCustomShapeParameter
+{
+	/** the any can be of type long or double
+	*/
+	any		Value;
+
+	/**
+	*/
+	short	Type;
+}; 
+ 
+//============================================================================= 
+ 
+}; }; }; };
+ 
+#endif 
+
--- /dev/null	2004-08-25 23:04:59.000000000 +0530
+++ offapi/com/sun/star/drawing/EnhancedCustomShapeParameterPair.idl	2005-02-28 13:41:26.000000000 +0530
@@ -0,0 +1,90 @@
+/*************************************************************************
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
+ *
+ *  Copyright: 2000 by Sun Microsystems, Inc.
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+#ifndef __com_sun_star_drawing_EnhancedCustomShapeParameterPair_idl__
+#define __com_sun_star_drawing_EnhancedCustomShapeParameterPair_idl__
+  
+#ifndef __com_sun_star_drawing_EnhancedCustomShapeParameter_idl__ 
+#include <com/sun/star/drawing/EnhancedCustomShapeParameter.idl>
+#endif
+ 
+//============================================================================= 
+ 
+ module com {  module sun {  module star {  module drawing {  
+ 
+//============================================================================= 
+ 
+/** specifies the coordinates used with EnhancedCustomShapes
+ */
+struct EnhancedCustomShapeParameterPair
+{
+	::com::sun::star::drawing::EnhancedCustomShapeParameter	First;
+ 
+	//-------------------------------------------------------------------------
+
+	::com::sun::star::drawing::EnhancedCustomShapeParameter	Second;
+};
+ 
+//============================================================================= 
+ 
+}; }; }; };
+ 
+#endif 
+
--- /dev/null	2004-08-25 23:04:59.000000000 +0530
+++ offapi/com/sun/star/drawing/EnhancedCustomShapeParameterType.idl	2005-02-28 13:41:26.000000000 +0530
@@ -0,0 +1,141 @@
+/*************************************************************************
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
+ *
+ *  Copyright: 2000 by Sun Microsystems, Inc.
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+#ifndef __com_sun_star_drawing_EnhancedCustomShapeParameterType_idl__
+#define __com_sun_star_drawing_EnhancedCustomShapeParameterType_idl__
+ 
+ 
+//============================================================================= 
+ 
+ module com {  module sun {  module star {  module drawing {  
+ 
+//============================================================================= 
+ 
+/** defines how a EnhancedCustomShapeParameter has to be interpreted
+ */
+constants EnhancedCustomShapeParameterType
+{ 
+	/** the value of the point component is normal, the Coordinate is taken as it is
+	 */
+	const short NORMAL = 0;
+ 
+	/** the value of the point component has to be interpreted as index to a Equation
+	 */
+	const short EQUATION = 1;
+ 
+	/** the value of the point component has to be interpreted as index into the list of AdjustmentValues
+	 */
+	const short ADJUSTMENT = 2;
+ 
+	/** the logical left border of the CustomShape is used
+	 */
+	const short LEFT = 3;
+
+	/** the logical top border of the CustomShape is used
+	 */
+	const short TOP = 4;
+
+	/** the logical right border of the CustomShape is used
+	 */
+	const short RIGHT = 5;
+
+	/** the logical bottom border of the CustomShape is used
+	 */
+	const short BOTTOM = 6;
+
+	/** the x value of the stretch point is used
+	 */
+	const short XSTRETCH = 7;
+
+	/** the y value of the stretch point is used
+	 */
+	const short YSTRETCH = 8;
+
+	/** If the shape has a line style, a value of 1 is used.
+	 */
+	const short HASSTROKE = 9;
+
+	/** If the shape has a fill style, a value of 1 is used.
+	 */
+	const short HASFILL = 10;
+
+	/** The width of the svg:viewBox is used.
+	 */
+	const short WIDTH = 11;
+
+	/** The height of the svg:viewBox is used.
+	 */
+	const short HEIGHT = 12;
+
+	/** The logical width of the shape is used.
+	 */
+	const short LOGWIDTH = 13;
+
+	/** The logical height of the shape is used.
+	 */
+	const short LOGHEIGHT = 14;
+}; 
+ 
+//============================================================================= 
+ 
+}; }; }; };
+ 
+#endif 
+
--- /dev/null	2004-08-25 23:04:59.000000000 +0530
+++ offapi/com/sun/star/drawing/EnhancedCustomShapePath.idl	2005-02-28 13:41:25.000000000 +0530
@@ -0,0 +1,153 @@
+/*************************************************************************
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
+ *
+ *  Copyright: 2000 by Sun Microsystems, Inc.
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+#ifndef __drafts_com_sun_star_drawing_EnhancedCustomShapePath_idl__
+#define __com_sun_star_drawing_EnhancedCustomShapePath_idl__
+
+#ifndef __com_sun_star_awt_Size_idl__ 
+#include <com/sun/star/awt/Size.idl>
+#endif
+#ifndef __com_sun_star_awt_Point_idl__ 
+#include <com/sun/star/awt/Point.idl>
+#endif
+#ifndef __com_sun_star_beans_PropertyValue_idl__
+#include <com/sun/star/beans/PropertyValue.idl>
+#endif
+#ifndef __com_sun_star_drawing_EnhancedCustomShapeParameterPair_idl__
+#include <com/sun/star/drawing/EnhancedCustomShapeParameterPair.idl>
+#endif
+#ifndef __com_sun_star_drawing_EnhancedCustomShapeSegment_idl__
+#include <com/sun/star/drawing/EnhancedCustomShapeSegment.idl>
+#endif
+#ifndef __com_sun_star_drawing_EnhancedCustomShapeTextFrame_idl__
+#include <com/sun/star/drawing/EnhancedCustomShapeTextFrame.idl>
+#endif
+
+
+//=============================================================================
+
+module com { module sun { module star { module drawing { 
+
+//=============================================================================
+/**
+  This service may be represented by a ::com::sun::star::beans::PropertyValue [].
+*/
+
+service EnhancedCustomShapePath
+{
+	/** This property is specifying the points that makes the geometry of the shape
+	*/
+	[optional, property] sequence<::com::sun::star::drawing::EnhancedCustomShapeParameterPair> Coordinates;
+
+	/** This property specifies the commands and the way the Coordinates have to be interpreted.
+	*/
+	[optional, property] sequence<::com::sun::star::drawing::EnhancedCustomShapeSegment> Segments;
+
+	/** This property specifies the horizontal StretchPoint that has to be used. No stretching is used if
+	    this property is omitted.
+	*/
+	[optional, property] long StretchX;
+
+	/** This property specifies the vertical StretchPoint that has to be used. No stretching is used if
+		this property is omitted.
+	*/
+	[optional, property] long StretchY;
+
+	/** This property specifies the text frames that can be used with the shape. In general
+	   the first text frame is used, except the shape is containing vertical text, then the object 
+	   tries to use the second text frame. The default text frame will be as big as the shape.
+	*/
+	[optional, property] sequence<::com::sun::star::drawing::EnhancedCustomShapeTextFrame> TextFrames;
+
+	/** This property specifies custom glue points
+	*/
+	[optional, property] sequence<::com::sun::star::drawing::EnhancedCustomShapeParameterPair> GluePoints;
+
+	/** This property specifies GluePoint leaving directions.
+	*/
+	[optional, property] sequence< double > GluePointLeavingDirections;
+
+	/** This property defines the GluePoint type. The values that can be used are
+		specified in ::com::sun::star::drawing::EnhancedCustomShapeGluePointType
+	*/
+	[optional, property] short GluePointType;
+
+	/** This property specifies if this shape supports the EnhancedCustomShapeExtrusion
+		properties. The default is true.
+	*/
+	[optional, property] boolean ExtrusionAllowed;
+
+	/** This property specifies if this shape supports concentric gradient fill. The default
+		is false.
+	*/
+	[optional, property] boolean ConcentricGradientFillAllowed;
+
+	/** This property specifies if this shape supports concentric gradient fill. The
+		default is false;
+	*/
+	[optional, property] boolean TextPathAllowed;
+};
+
+//=============================================================================
+
+}; }; }; }; 
+
+#endif
+
--- /dev/null	2004-08-25 23:04:59.000000000 +0530
+++ offapi/com/sun/star/drawing/EnhancedCustomShapeSegmentCommand.idl	2005-02-28 13:41:26.000000000 +0530
@@ -0,0 +1,149 @@
+/*************************************************************************
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
+ *
+ *  Copyright: 2000 by Sun Microsystems, Inc.
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+#ifndef __drafts_com_sun_star_drawing_EnhancedCustomShapeSegmentInformationCommand_idl__
+#define __com_sun_star_drawing_EnhancedCustomShapeSegmentInformationCommand_idl__
+ 
+ 
+//============================================================================= 
+ 
+ module com {  module sun {  module star {  module drawing {  
+ 
+//============================================================================= 
+ 
+/** 
+ */
+constants EnhancedCustomShapeSegmentCommand
+{ 
+	/**
+	 */
+	const short UNKNOWN = 0;
+
+	/**
+	 */
+	const short MOVETO = 1;
+ 
+	/**
+	 */
+	const short LINETO = 2;
+ 
+	/**
+	 */
+	const short CURVETO = 3;
+ 
+	/**
+	 */
+	const short CLOSESUBPATH = 4;
+
+	/**
+	 */
+	const short ENDSUBPATH = 5;
+
+	/**
+	 */
+	const short NOFILL = 6;
+
+	/**
+	 */
+	const short NOSTROKE = 7;
+
+	/**
+	 */
+	const short ANGLEELLIPSETO = 8;
+
+	/**
+	 */
+	const short ANGLEELLIPSE = 9;
+
+	/**
+	 */
+	const short ARCTO = 10;
+
+	/**
+	 */
+	const short ARC = 11;
+
+	/**
+	 */
+	const short CLOCKWISEARCTO = 12;
+
+	/**
+	 */
+	const short CLOCKWISEARC = 13;
+
+	/**
+	 */
+	const short ELLIPTICALQUADRANTX = 14;
+
+	/**
+	 */
+	const short ELLIPTICALQUADRANTY = 15;
+
+	/**
+	 */
+	const short QUADRATICCURVETO = 16;
+}; 
+ 
+//============================================================================= 
+ 
+}; }; }; };
+ 
+#endif 
+
--- /dev/null	2004-08-25 23:04:59.000000000 +0530
+++ offapi/com/sun/star/drawing/EnhancedCustomShapeSegment.idl	2005-02-28 13:41:26.000000000 +0530
@@ -0,0 +1,88 @@
+/*************************************************************************
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
+ *
+ *  Copyright: 2000 by Sun Microsystems, Inc.
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+#ifndef __com_sun_star_drawing_EnhancedCustomShapeSegment_idl__
+#define __com_sun_star_drawing_EnhancedCustomShapeSegment_idl__
+
+#ifndef __com_sun_star_drawing_EnhancedCustomShapeSegmentCommand_idl__
+#include <com/sun/star/drawing/EnhancedCustomShapeSegmentCommand.idl>
+#endif
+
+//============================================================================= 
+ 
+ module com {  module sun {  module star {  module drawing {  
+ 
+//============================================================================= 
+ 
+/** 
+ */
+struct EnhancedCustomShapeSegment
+{
+	short Command;
+
+	short Count;
+};
+ 
+//============================================================================= 
+ 
+}; }; }; };
+ 
+#endif 
+
--- /dev/null	2004-08-25 23:04:59.000000000 +0530
+++ offapi/com/sun/star/drawing/EnhancedCustomShapeTextFrame.idl	2005-02-28 13:41:26.000000000 +0530
@@ -0,0 +1,91 @@
+/*************************************************************************
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
+ *
+ *  Copyright: 2000 by Sun Microsystems, Inc.
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+#ifndef __com_sun_star_drawing_EnhancedCustomShapeTextFrame_idl__
+#define __com_sun_star_drawing_EnhancedCustomShapeTextFrame_idl__
+  
+#ifndef __com_sun_star_drawing_EnhancedCustomShapeParameterPair_idl__ 
+#include <com/sun/star/drawing/EnhancedCustomShapeParameterPair.idl>
+#endif
+ 
+//============================================================================= 
+ 
+ module com {  module sun {  module star {  module drawing {  
+ 
+//============================================================================= 
+ 
+/** specifies the coordinates used with EnhancedCustomShapes
+ */
+struct EnhancedCustomShapeTextFrame
+{
+	::com::sun::star::drawing::EnhancedCustomShapeParameterPair	TopLeft;
+ 
+	//-------------------------------------------------------------------------
+
+	::com::sun::star::drawing::EnhancedCustomShapeParameterPair	BottomRight;
+
+};
+ 
+//============================================================================= 
+ 
+}; }; }; };
+ 
+#endif 
+
--- /dev/null	2004-08-25 23:04:59.000000000 +0530
+++ offapi/com/sun/star/drawing/EnhancedCustomShapeTextPath.idl	2005-02-28 13:41:26.000000000 +0530
@@ -0,0 +1,97 @@
+/*************************************************************************
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
+ *
+ *  Copyright: 2000 by Sun Microsystems, Inc.
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+#ifndef __drafts_com_sun_star_drawing_EnhancedCustomShapeTextPath_idl__
+#define __com_sun_star_drawing_EnhancedCustomShapeTextPath_idl__
+
+#ifndef __com_sun_star_drawing_EnhancedCustomShapeTextPathMode_idl__
+#include <com/sun/star/drawing/EnhancedCustomShapeTextPathMode.idl>
+#endif
+
+//=============================================================================
+
+module com { module sun { module star { module drawing { 
+
+//=============================================================================
+/**
+  This service may be represented by a ::com::sun::star::beans::PropertyValue [].
+*/
+
+service EnhancedCustomShapeTextPath
+{
+	/** This property specifies if a text path is used. The default is false.
+	*/
+	[optional, property] boolean TextPath;
+
+	/** This property specifies how the text is drawn.
+	*/
+	[optional, property] ::com::sun::star::drawing::EnhancedCustomShapeTextPathMode TextPathMode;
+
+	/** This property specifies if the text is scaled using the shape path.
+	*/
+	[optional, property] boolean ScaleX;
+};
+
+//=============================================================================
+
+}; }; }; }; 
+
+#endif
+
--- /dev/null	2004-08-25 23:04:59.000000000 +0530
+++ offapi/com/sun/star/drawing/EnhancedCustomShapeTextPathMode.idl	2005-02-28 13:41:26.000000000 +0530
@@ -0,0 +1,91 @@
+/*************************************************************************
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
+ *
+ *  Copyright: 2000 by Sun Microsystems, Inc.
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+#ifndef __com_sun_star_drawing_EnhancedCustomShapeTextPathMode_idl__ 
+#define __com_sun_star_drawing_EnhancedCustomShapeTextPathMode_idl__ 
+ 
+ 
+//============================================================================= 
+ 
+module com {  module sun {  module star {  module drawing {  
+ 
+//============================================================================= 
+ 
+enum EnhancedCustomShapeTextPathMode
+{ 
+	/** the text is drawn along the path without scaling.
+	 */
+	NORMAL,
+ 
+	/** the text is fit to the path.
+	 */
+	PATH,
+ 
+	/** the text is fit to the bounding box of the shape.
+	 */
+	SHAPE
+}; 
+ 
+//============================================================================= 
+ 
+}; }; }; };  
+ 
+#endif 
+
--- /dev/null	2004-08-25 23:04:59.000000000 +0530
+++ offapi/com/sun/star/drawing/XCustomShapeEngine.idl	2005-02-28 13:41:26.000000000 +0530
@@ -0,0 +1,121 @@
+/*************************************************************************
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
+ *
+ *  Copyright: 2000 by Sun Microsystems, Inc.
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+#ifndef __com_sun_star_drawing_XCustomShapeEngine_idl__ 
+#define __com_sun_star_drawing_XCustomShapeEngine_idl__ 
+
+#ifndef __com_sun_star_awt_Rectangle_idl__ 
+#include <com/sun/star/awt/Rectangle.idl> 
+#endif 
+#ifndef __com_sun_star_drawing_PolyPolygonBezierCoords_idl__ 
+#include <com/sun/star/drawing/PolyPolygonBezierCoords.idl>
+#endif
+#ifndef __com_sun_star_uno_XInterface_idl__ 
+#include <com/sun/star/uno/XInterface.idl> 
+#endif 
+#ifndef __com_sun_star_drawing_XShape_idl__ 
+#include <com/sun/star/drawing/XShape.idl> 
+#endif 
+#ifndef __com_sun_star_drawing_XCustomShapeHandle_idl__ 
+#include <com/sun/star/drawing/XCustomShapeHandle.idl> 
+#endif 
+
+//============================================================================= 
+ 
+ module com {  module sun {  module star {  module drawing {  
+ 
+//============================================================================= 
+ 
+/** The XCustomShapeEngine
+ */
+interface XCustomShapeEngine: com::sun::star::uno::XInterface
+{ 
+	//------------------------------------------------------------------------- 
+	 
+	/** 
+		@returns
+			a the shape that is representing the CustomShape
+	 */
+	com::sun::star::drawing::XShape render(); 
+
+	/** 
+		@returns the text bound of the shape
+	*/
+	com::sun::star::awt::Rectangle getTextBounds();
+
+	/** 
+		@returns the line geometry of the object
+	*/
+	com::sun::star::drawing::PolyPolygonBezierCoords getLineGeometry();
+
+	/**
+		@returns
+			a collection of interaction handles
+	 */
+	sequence<com::sun::star::drawing::XCustomShapeHandle> getInteraction(); 
+
+ }; 
+ 
+//============================================================================= 
+ 
+}; }; }; };  
+ 
+#endif 
+
--- /dev/null	2004-08-25 23:04:59.000000000 +0530
+++ offapi/com/sun/star/drawing/XCustomShapeHandle.idl	2005-02-28 13:41:26.000000000 +0530
@@ -0,0 +1,102 @@
+/*************************************************************************
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
+ *
+ *  Copyright: 2000 by Sun Microsystems, Inc.
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+#ifndef __com_sun_star_drawing_XCustomShapeHandle_idl__ 
+#define __com_sun_star_drawing_XCustomShapeHandle_idl__ 
+
+#ifndef __com_sun_star_uno_XInterface_idl__ 
+#include <com/sun/star/uno/XInterface.idl> 
+#endif 
+
+#ifndef __com_sun_star_awt_Point_idl__ 
+#include <com/sun/star/awt/Point.idl> 
+#endif 
+ 
+//============================================================================= 
+ 
+ module com {  module sun {  module star {  module drawing {  
+ 
+//============================================================================= 
+ 
+/** The XCustomShapeHandle
+ */
+interface XCustomShapeHandle: com::sun::star::uno::XInterface
+{ 
+	//------------------------------------------------------------------------- 
+	 
+	/** is getting the actual handle position
+
+		@returns
+			a the actual handle position
+	 */
+	com::sun::star::awt::Point getPosition(); 
+
+	/** is setting a new positon for the handle
+	 */
+	void setControllerPosition( [in] com::sun::star::awt::Point aPoint ); 
+
+ }; 
+ 
+//============================================================================= 
+ 
+}; }; }; };  
+ 
+#endif 
+
--- /dev/null	2004-08-25 23:04:59.000000000 +0530
+++ offapi/com/sun/star/geometry/AffineMatrix2D.idl	2005-02-28 13:41:27.000000000 +0530
@@ -0,0 +1,127 @@
+/*************************************************************************
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
+ *
+ *  Copyright: 2000 by Sun Microsystems, Inc.
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+#ifndef __com_sun_star_geometry_AffineMatrix2D_idl__
+#define __com_sun_star_geometry_AffineMatrix2D_idl__
+
+module com {  module sun {  module star {  module geometry {
+
+/** This structure defines a 2 by 3 affine matrix.<p>
+
+    The matrix defined by this structure constitutes an affine mapping
+    of a point in 2D to another point in 2D. The last line of a
+    complete 3 by 3 matrix is omitted, since it is implicitely assumed
+    to be [0,0,1].<p>
+
+    An affine mapping, as performed by this matrix, can be written out
+    as follows, where <code>xs</code> and <code>ys</code> are the source, and 
+    <code>xd</code> and <code>yd</code> the corresponding result coordinates:
+
+    <code>
+    	xd = m00*xs + m01*ys + m02;
+    	yd = m10*xs + m11*ys + m12;
+    </code><p>
+
+    Thus, in common matrix language, with M being the
+    <type>AffineMatrix2D</type> and vs=[xs,ys]^T, vd=[xd,yd]^T two 2D
+    vectors, the affine transformation is written as
+    vd=M*vs. Concatenation of transformations amounts to
+    multiplication of matrices, i.e. a translation, given by T,
+    followed by a rotation, given by R, is expressed as vd=R*(T*vs) in
+    the above notation. Since matrix multiplication is associative,
+    this can be shortened to vd=(R*T)*vs=M'*vs. Therefore, a set of
+    consecutive transformations can be accumulated into a single
+    AffineMatrix2D, by multiplying the current transformation with the
+    additional transformation from the left.<p>
+
+    Due to this transformational approach, all geometry data types are
+    points in abstract integer or real coordinate spaces, without any
+    physical dimensions attached to them. This physical measurement
+    units are typically only added when using these data types to
+    render something onto a physical output device, like a screen or a
+    printer, Then, the total transformation matrix and the device
+    resolution determine the actual measurement unit.<p>
+
+    @since #110496#
+ */
+struct AffineMatrix2D
+{
+    /// The top, left matrix entry.
+    double m00;
+
+    /// The top, middle matrix entry.
+    double m01;
+
+    /// The top, right matrix entry.
+    double m02;
+
+    /// The bottom, left matrix entry.
+    double m10;
+
+    /// The bottom, middle matrix entry.
+    double m11;
+
+    /// The bottom, right matrix entry.
+    double m12;
+};
+
+}; }; }; };
+
+#endif
--- /dev/null	2004-08-25 23:04:59.000000000 +0530
+++ offapi/com/sun/star/geometry/EllipticalArc.idl	2005-02-28 13:41:27.000000000 +0530
@@ -0,0 +1,128 @@
+/*************************************************************************
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
+ *
+ *  Copyright: 2000 by Sun Microsystems, Inc.
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+#ifndef __com_sun_star_geometry_EllipticalArc_idl__
+#define __com_sun_star_geometry_EllipticalArc_idl__
+
+#ifndef __com_sun_star_geometry_RealPoint2D_idl__
+#include <com/sun/star/geometry/RealPoint2D.idl>
+#endif
+
+module com {  module sun {  module star {  module geometry {
+
+/** This structure specifies an arbitrary elliptical arc.<p>
+
+    This structure contains all parameters necessary to specify
+    arbitrary elliptical arcs. The parameters are modelled closely
+    after the <a href="www.w3c.org">SVG</a> specification.<p>
+
+    As with the parameters below, there are mostly four different
+    ellipses arcs (two different ellipses, on which four different
+    arcs connect start and end point) which satisfy the given set of
+    constrains. Thus, there are two flags indicating which one of those
+    ellipses should be taken.<p>
+
+    @since #110496#
+ */
+struct EllipticalArc
+{
+    /// Start point of the arc.
+	RealPoint2D StartPosition;
+
+	//-------------------------------------------------------------------------
+
+    /// End point of the arc.
+	RealPoint2D EndPosition;
+
+	//-------------------------------------------------------------------------
+
+    /// Main radius in x direction of the ellipse this arc is part of.
+	double 	RadiusX;
+
+	//-------------------------------------------------------------------------
+
+    /// Main radius in y direction of the ellipse this arc is part of.
+	double 	RadiusY;
+
+	//-------------------------------------------------------------------------
+
+    /** Rotation angle of the x axis of the ellipse relative to the x
+        axis of the reference coordinate system.
+     */
+	double 	XAxisRotation;
+
+	//-------------------------------------------------------------------------
+
+    /** If <TRUE>, and there's a choice, take the longer one of two arcs
+        connecting start and end point.
+     */
+	boolean	IsLargeArc;
+
+	//-------------------------------------------------------------------------
+
+    /** If <TRUE>, and there's a choice, take the arc that goes
+        clock-wise from start to end point.
+     */
+	boolean IsClockwiseSweep;
+};
+
+}; }; }; };
+
+#endif
--- /dev/null	2004-08-25 23:04:59.000000000 +0530
+++ offapi/com/sun/star/geometry/IntegerBezierSegment2D.idl	2005-02-28 13:41:27.000000000 +0530
@@ -0,0 +1,101 @@
+/*************************************************************************
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
+ *
+ *  Copyright: 2000 by Sun Microsystems, Inc.
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+#ifndef __com_sun_star_geometry_IntegerBezierSegment2D_idl__
+#define __com_sun_star_geometry_IntegerBezierSegment2D_idl__
+
+module com {  module sun {  module star {  module geometry {
+
+/** This structure contains the relevant data for a cubic Bezier
+    curve.<p>
+
+    The data is stored integer-valued. The last point of the segment
+    is taken from the first point of the following segment, and thus
+    not included herein. That is, when forming a polygon out of cubic
+    Bezier segments, each two consecutive IntegerBezierSegment2Ds
+    define the actual curve, with the very last segment providing only
+    the end point of the last curve, and the remaining members
+    ignored.<p>
+
+    @see drafts.com.sun.star.rendering.XBezierPolyPolygon2D
+    @since #110496#
+ */
+struct IntegerBezierSegment2D
+{
+    /// The x coordinate of the start point.
+    long Px;
+    /// The y coordinate of the start point.
+    long Py;
+
+    /// The x coordinate of the first control point.
+    long C1x;
+    /// The y coordinate of the first control point.
+    long C1y;
+
+    /// The x coordinate of the second control point.
+    long C2x;
+    /// The y coordinate of the second control point.
+    long C2y;
+
+};
+
+}; }; }; };
+
+#endif
--- /dev/null	2004-08-25 23:04:59.000000000 +0530
+++ offapi/com/sun/star/geometry/IntegerPoint2D.idl	2005-02-28 13:41:27.000000000 +0530
@@ -0,0 +1,86 @@
+/*************************************************************************
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
+ *
+ *  Copyright: 2000 by Sun Microsystems, Inc.
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+#ifndef __com_sun_star_geometry_IntegerPoint2D_idl__
+#define __com_sun_star_geometry_IntegerPoint2D_idl__
+
+module com {  module sun {  module star {  module geometry {
+
+/** This structure defines a two-dimensional point
+
+	This structure contains x and y integer-valued coordinates of a
+	two-dimensional point.
+
+    @since #110496#
+ */
+struct IntegerPoint2D
+{
+    /// The x coordinate of the point.
+    long X;
+
+	//-------------------------------------------------------------------------
+
+    /// The x coordinate of the point.
+    long Y;
+};
+
+}; }; }; };
+
+#endif
--- /dev/null	2004-08-25 23:04:59.000000000 +0530
+++ offapi/com/sun/star/geometry/IntegerRectangle2D.idl	2005-02-28 13:41:27.000000000 +0530
@@ -0,0 +1,113 @@
+/*************************************************************************
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
+ *
+ *  Copyright: 2000 by Sun Microsystems, Inc.
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+#ifndef __com_sun_star_geometry_IntegerRectangle2D_idl__
+#define __com_sun_star_geometry_IntegerRectangle2D_idl__
+
+module com {  module sun {  module star {  module geometry {
+
+/*  Removed, because XCanvas is private API until further notice.
+
+    The values are stored as integers. Please note that the
+    <type>drafts.com.sun.star.rendering.XCanvas</type> defines the
+    screen representation of rectangles in such a way that the lower
+    and the rightmost line of the rectangle are not drawn on
+    screen. Thus, if for two rectangles R1 and R2, R1.x2 equals R2.x1,
+    the screen representation of these rectangles will not overlap,
+    but being exactly adjacent. That also means, that an
+    IntegerRectangle2D with X1 equal X2 or Y1 equal Y2 can be
+    considered empty.<p>
+*/
+
+/** This structure contains the necessary information for a
+    two-dimensional rectangle.<p>
+
+    @since #110496#
+ */
+struct IntegerRectangle2D
+{
+    /// X coordinate of upper left corner. 
+    long X1;
+
+	//-------------------------------------------------------------------------
+
+    /// Y coordinate of upper left corner. 
+    long Y1;
+
+	//-------------------------------------------------------------------------
+
+    /** X coordinate of lower right corner.<p>
+
+    	Must be greater than X1 for non-empty rectangles.<p>
+    */
+    long X2;
+
+	//-------------------------------------------------------------------------
+
+    /** Y coordinate of lower right corner.<p>
+
+    	Must be greater than y1 for non-empty rectangles.<p>
+    */
+    long Y2;
+};
+
+}; }; }; };
+
+#endif
--- /dev/null	2004-08-25 23:04:59.000000000 +0530
+++ offapi/com/sun/star/geometry/IntegerSize2D.idl	2005-02-28 13:41:27.000000000 +0530
@@ -0,0 +1,85 @@
+/*************************************************************************
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
+ *
+ *  Copyright: 2000 by Sun Microsystems, Inc.
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+#ifndef __com_sun_star_geometry_IntegerSize2D_idl__
+#define __com_sun_star_geometry_IntegerSize2D_idl__
+
+module com {  module sun {  module star {  module geometry {
+
+/** This structure contains data representing a two-dimensional size.<p>
+
+	The data is stored integer-valued.<p>
+
+    @since #110496#
+ */
+struct IntegerSize2D
+{
+    /// Amount of space occupied in the x direction.
+    long Width;
+
+	//-------------------------------------------------------------------------
+
+    /// Amount of space occupied in the y direction.
+    long Height;
+};
+
+}; }; }; };
+
+#endif
--- /dev/null	2004-08-25 23:04:59.000000000 +0530
+++ offapi/com/sun/star/geometry/makefile.mk	2005-02-28 13:41:27.000000000 +0530
@@ -0,0 +1,92 @@
+#*************************************************************************
+#
+#   $RCSfile$
+#
+#   $Revision$
+#
+#   last change: $Author$ $Date$
+#
+#   The Contents of this file are made available subject to the terms of
+#   either of the following licenses
+#
+#          - GNU Lesser General Public License Version 2.1
+#          - Sun Industry Standards Source License Version 1.1
+#
+#   Sun Microsystems Inc., October, 2000
+#
+#   GNU Lesser General Public License Version 2.1
+#   =============================================
+#   Copyright 2000 by Sun Microsystems, Inc.
+#   901 San Antonio Road, Palo Alto, CA 94303, USA
+#
+#   This library is free software; you can redistribute it and/or
+#   modify it under the terms of the GNU Lesser General Public
+#   License version 2.1, as published by the Free Software Foundation.
+#
+#   This library is distributed in the hope that it will be useful,
+#   but WITHOUT ANY WARRANTY; without even the implied warranty of
+#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+#   Lesser General Public License for more details.
+#
+#   You should have received a copy of the GNU Lesser General Public
+#   License along with this library; if not, write to the Free Software
+#   Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+#   MA  02111-1307  USA
+#
+#
+#   Sun Industry Standards Source License Version 1.1
+#   =================================================
+#   The contents of this file are subject to the Sun Industry Standards
+#   Source License Version 1.1 (the "License"); You may not use this file
+#   except in compliance with the License. You may obtain a copy of the
+#   License at http://www.openoffice.org/license.html.
+#
+#   Software provided under this License is provided on an "AS IS" basis,
+#   WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+#   WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+#   MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+#   See the License for the specific provisions governing your rights and
+#   obligations concerning the Software.
+#
+#   The Initial Developer of the Original Code is: Sun Microsystems, Inc.
+#
+#   Copyright: 2000 by Sun Microsystems, Inc.
+#
+#   All Rights Reserved.
+#
+#   Contributor(s): _______________________________________
+#
+#
+#
+#*************************************************************************
+
+PRJ=..$/..$/..$/..
+
+PRJNAME=geometry
+
+TARGET=cssgeometry
+PACKAGE=com$/sun$/star$/geometry
+
+# --- Settings -----------------------------------------------------
+.INCLUDE :  $(PRJ)$/util$/makefile.pmk
+
+# ------------------------------------------------------------------------
+
+IDLFILES=\
+	AffineMatrix2D.idl			\
+	EllipticalArc.idl			\
+	Matrix2D.idl				\
+	XMapping2D.idl				\
+	IntegerBezierSegment2D.idl 	\
+	RealBezierSegment2D.idl 	\
+	RealPoint2D.idl				\
+	RealRectangle2D.idl			\
+	RealSize2D.idl				\
+	IntegerPoint2D.idl			\
+	IntegerRectangle2D.idl		\
+	IntegerSize2D.idl
+
+# ------------------------------------------------------------------
+
+.INCLUDE :  target.mk
+.INCLUDE :  $(PRJ)$/util$/target.pmk
--- /dev/null	2004-08-25 23:04:59.000000000 +0530
+++ offapi/com/sun/star/geometry/Matrix2D.idl	2005-02-28 13:41:27.000000000 +0530
@@ -0,0 +1,124 @@
+/*************************************************************************
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
+ *
+ *  Copyright: 2000 by Sun Microsystems, Inc.
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+#ifndef __com_sun_star_geometry_Matrix2D_idl__
+#define __com_sun_star_geometry_Matrix2D_idl__
+
+module com {  module sun {  module star {  module geometry {
+
+/** This structure defines a 2 by 2 matrix.<p>
+
+    This constitutes a linear mapping of a point in 2D to another
+    point in 2D.<p>
+
+    The matrix defined by this structure constitutes a linear
+    mapping of a point in 2D to another point in 2D. In contrast to
+    the <type>drafts.com.sun.star.geometry.AffineMatrix2D</type>, this
+    matrix does not include any translational components.<p>
+
+    A linear mapping, as performed by this matrix, can be written out
+    as follows, where <code>xs</code> and <code>ys</code> are the source, and 
+    <code>xd</code> and <code>yd</code> the corresponding result coordinates:
+
+    <code>
+    	xd = m00*xs + m01*ys;
+    	yd = m10*xs + m11*ys;
+    </code><p>
+
+    Thus, in common matrix language, with M being the
+    <type>Matrix2D</type> and vs=[xs,ys]^T, vd=[xd,yd]^T two 2D
+    vectors, the linear mapping is written as
+    vd=M*vs. Concatenation of transformations amounts to
+    multiplication of matrices, i.e. a scaling, given by S,
+    followed by a rotation, given by R, is expressed as vd=R*(S*vs) in
+    the above notation. Since matrix multiplication is associative,
+    this can be shortened to vd=(R*S)*vs=M'*vs. Therefore, a set of
+    consecutive transformations can be accumulated into a single
+    Matrix2D, by multiplying the current transformation with the
+    additional transformation from the left.<p>
+
+    Due to this transformational approach, all geometry data types are
+    points in abstract integer or real coordinate spaces, without any
+    physical dimensions attached to them. This physical measurement
+    units are typically only added when using these data types to
+    render something onto a physical output device, like a screen or a
+    printer. Then, the total transformation matrix and the device
+    resolution determine the actual measurement unit.<p>
+
+    @since #110496#
+ */
+struct Matrix2D
+{
+    /// The top, left matrix entry.
+    double m00;
+
+    /// The top, right matrix entry.
+    double m01;
+
+    /// The bottom, left matrix entry.
+    double m10;
+
+    /// The bottom, right matrix entry.
+    double m11;
+};
+
+}; }; }; };
+
+#endif
--- /dev/null	2004-08-25 23:04:59.000000000 +0530
+++ offapi/com/sun/star/geometry/RealBezierSegment2D.idl	2005-02-28 13:41:27.000000000 +0530
@@ -0,0 +1,101 @@
+/*************************************************************************
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
+ *
+ *  Copyright: 2000 by Sun Microsystems, Inc.
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+#ifndef __com_sun_star_geometry_RealBezierSegment2D_idl__
+#define __com_sun_star_geometry_RealBezierSegment2D_idl__
+
+module com {  module sun {  module star {  module geometry {
+
+/** This structure contains the relevant data for a cubic Bezier
+    curve.<p>
+
+    The data is stored real-valued. The last point of the segment is
+    taken from the first point of the following segment, and thus not
+    included herein. That is, when forming a polygon out of cubic
+    Bezier segments, each two consecutive IntegerBezierSegment2Ds
+    define the actual curve, with the very last segment providing only
+    the end point of the last curve, and the remaining members
+    ignored.<p>
+
+    @see drafts.com.sun.star.rendering.XBezierPolyPolygon2D
+    @since #110496#
+ */
+struct RealBezierSegment2D
+{
+    /// The x coordinate of the start point.
+    double Px;
+    /// The y coordinate of the start point.
+    double Py;
+
+    /// The x coordinate of the first control point.
+    double C1x;
+    /// The y coordinate of the first control point.
+    double C1y;
+
+    /// The x coordinate of the second control point.
+    double C2x;
+    /// The y coordinate of the second control point.
+    double C2y;
+
+};
+
+}; }; }; };
+
+#endif
--- /dev/null	2004-08-25 23:04:59.000000000 +0530
+++ offapi/com/sun/star/geometry/RealPoint2D.idl	2005-02-28 13:41:27.000000000 +0530
@@ -0,0 +1,86 @@
+/*************************************************************************
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
+ *
+ *  Copyright: 2000 by Sun Microsystems, Inc.
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+#ifndef __com_sun_star_geometry_RealPoint2D_idl__
+#define __com_sun_star_geometry_RealPoint2D_idl__
+
+module com {  module sun {  module star {  module geometry {
+
+/** This structure defines a two-dimensional point
+
+	This structure contains x and y real-valued coordinates of a
+	two-dimensional point.
+
+    @since #110496#
+ */
+struct RealPoint2D
+{
+    /// The x coordinate of the point.
+    double X;
+
+	//-------------------------------------------------------------------------
+
+    /// The x coordinate of the point.
+    double Y;
+};
+
+}; }; }; };
+
+#endif
--- /dev/null	2004-08-25 23:04:59.000000000 +0530
+++ offapi/com/sun/star/geometry/RealRectangle2D.idl	2005-02-28 13:41:27.000000000 +0530
@@ -0,0 +1,113 @@
+/*************************************************************************
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
+ *
+ *  Copyright: 2000 by Sun Microsystems, Inc.
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+#ifndef __com_sun_star_geometry_RealRectangle2D_idl__
+#define __com_sun_star_geometry_RealRectangle2D_idl__
+
+module com {  module sun {  module star {  module geometry {
+
+/*  Removed, because XCanvas is private API until further notice.
+
+    The values are stored as reals. Please note that the
+    <type>drafts.com.sun.star.rendering.XCanvas</type> defines the
+    screen representation of rectangles in such a way that the lower
+    and the rightmost line of the rectangle are not drawn on
+    screen. Thus, if for two rectangles R1 and R2, R1.x2 equals R2.x1,
+    the screen representation of these rectangles will not overlap,
+    but being exactly adjacent. That also means, that an
+    IntegerRectangle2D with X1 equal X2 or Y1 equal Y2 can be
+    considered empty.<p>
+*/
+
+/** This structure contains the necessary information for a
+    two-dimensional rectangle.<p>
+
+    @since #110496#
+ */
+struct RealRectangle2D
+{
+    /// X coordinate of upper left corner .
+    double X1;
+
+	//-------------------------------------------------------------------------
+
+    /// Y coordinate of upper left corner.
+    double Y1;
+
+	//-------------------------------------------------------------------------
+
+    /** X coordinate of lower right corner.<p>
+
+    	Must be greater than x1 for non-empty rectangles.<p>.
+    */
+    double X2;
+
+	//-------------------------------------------------------------------------
+
+    /** Y coordinate of lower right corner.<p>
+
+    	Must be greater than y1 for non-empty rectangles.<p>
+     */
+    double Y2;
+};
+
+}; }; }; };
+
+#endif
--- /dev/null	2004-08-25 23:04:59.000000000 +0530
+++ offapi/com/sun/star/geometry/RealSize2D.idl	2005-02-28 13:41:27.000000000 +0530
@@ -0,0 +1,85 @@
+/*************************************************************************
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
+ *
+ *  Copyright: 2000 by Sun Microsystems, Inc.
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+#ifndef __com_sun_star_geometry_RealSize2D_idl__
+#define __com_sun_star_geometry_RealSize2D_idl__
+
+module com {  module sun {  module star {  module geometry {
+
+/** This structure contains data representing a two-dimensional size.<p>
+
+	The data is stored real-valued.<p>
+
+    @since #110496#
+ */
+struct RealSize2D
+{
+    /// Amount of space occupied in the x direction.
+    double Width;
+
+	//-------------------------------------------------------------------------
+
+    /// Amount of space occupied in the y direction.
+    double Height;
+};
+
+}; }; }; };
+
+#endif
--- /dev/null	2004-08-25 23:04:59.000000000 +0530
+++ offapi/com/sun/star/geometry/XMapping2D.idl	2005-02-28 13:41:27.000000000 +0530
@@ -0,0 +1,106 @@
+/*************************************************************************
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
+ *
+ *  Copyright: 2000 by Sun Microsystems, Inc.
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+#ifndef __com_sun_star_geometry_XMapping2D_idl__
+#define __com_sun_star_geometry_XMapping2D_idl__
+
+#ifndef __com_sun_star_uno_XInterface_idl__ 
+#include <com/sun/star/uno/XInterface.idl> 
+#endif 
+#ifndef __com_sun_star_geometry_RealPoint2D_idl__
+#include <com/sun/star/geometry/RealPoint2D.idl>
+#endif
+
+module com {  module sun {  module star {  module geometry {
+
+/** Interface defining an arbitrary bijective mapping from R^2 to R^2.<p>
+
+	This interface provides methods to define an arbitrary bijective
+	mapping from R^2 to R^2, i.e. from the two-dimensional space of
+	real numbers onto itself, as is representable by the
+	<type>double</type> floating point type. The mapping must be
+	bijective, i.e. map a pair of real numbers to exactly one other
+	pair of real numbers an vice versa, to facilitate a working
+	inverse. Bijectiveness also implies completeness, i.e. for every
+	pair of real numbers there must be another pair that is mapped
+	upon them.<p>
+
+    @since #110496#
+ */
+interface XMapping2D : ::com::sun::star::uno::XInterface
+{
+	/** Forward 2D mapping function
+	 */
+	RealPoint2D 	map( [in] RealPoint2D aPoint );
+
+	//-------------------------------------------------------------------------
+
+	/** Inverse 2D mapping function.<p>
+
+    	The following invariant must hold:
+    	<code>map(mapInverse(p))=p</code>. This effectively rules out
+    	non-bijective mappings.<p>
+	 */
+	RealPoint2D 	mapInverse( [in] RealPoint2D aPoint );
+};
+
+}; }; }; };
+
+#endif
--- /dev/null	2004-08-25 23:04:59.000000000 +0530
+++ offapi/com/sun/star/rendering/AnimationAttributes.idl	2005-02-28 13:41:29.000000000 +0530
@@ -0,0 +1,105 @@
+/*************************************************************************
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
+ *
+ *  Copyright: 2000 by Sun Microsystems, Inc.
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+#ifndef __com_sun_star_rendering_AnimationAttributes_idl__
+#define __com_sun_star_rendering_AnimationAttributes_idl__
+
+#ifndef __com_sun_star_geometry_RealSize2D_idl__
+#include <com/sun/star/geometry/RealSize2D.idl>
+#endif
+
+module com { module sun { module star { module rendering {
+
+/** This structure contains attributes needed to run an animation.
+
+    @since #110496#
+ */
+struct AnimationAttributes
+{
+    /// Preferred duration of the animation sequence in seconds.
+    double 										Duration;
+    
+	//-------------------------------------------------------------------------
+
+    /** Repeat mode of the animation sequence.<p>
+	
+		This value determines how the [0,1] parameter space of the animation
+        should be sweeped through. Permissible values are given in
+        <type>AnimationRepeat</type>.<p>
+        
+        @see AnimationRepeat.
+     */
+    byte										RepeatMode;
+    
+	//-------------------------------------------------------------------------
+
+    /** Size of the untrasnformed animation sequence.<p>
+
+		This value specifies the size of the animation when rendered
+		with the identity view transform. This permits
+		e.g. <type>XSprite</type> implementations to cache rendered
+		animation content in finite-sized bitmaps.<p>
+     */
+    ::com::sun::star::geometry::RealSize2D	UntransformedSize;
+}; 
+
+}; }; }; };
+
+#endif
--- /dev/null	2004-08-25 23:04:59.000000000 +0530
+++ offapi/com/sun/star/rendering/AnimationRepeat.idl	2005-02-28 13:41:29.000000000 +0530
@@ -0,0 +1,118 @@
+/*************************************************************************
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
+ *
+ *  Copyright: 2000 by Sun Microsystems, Inc.
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+#ifndef __com_sun_star_rendering_AnimationRepeat_idl__
+#define __com_sun_star_rendering_AnimationRepeat_idl__
+
+module com { module sun { module star { module rendering {
+
+/** This are the possible repeat modes for animations.<p>
+
+	These constants determine how the [0,1] parameter range of the
+	animation is driven through, thus defining the possible repeat
+	modes.<p>
+
+    @since #110496#
+ */
+constants AnimationRepeat 
+{ 
+    /** The [0,1] parameter range is sweeped through exactly once.<p>
+
+    	The [0,1] parameter range is sweeped through exactly once,
+    	starting with 0 and ending with 1.<p>
+    */
+    const byte ONE_SHOT=0;
+
+	//-------------------------------------------------------------------------
+
+    /** The [0,1] parameter range is sweeped through exactly twice.<p>
+
+    	The [0,1] parameter range is sweeped through exactly twice,
+    	starting with 0, going to 1, and going back to 0. When
+    	plotting the value over time, this yields a triangle curve.<p>
+    */
+    const byte ONE_SHOT_PINGPONG=1;
+
+	//-------------------------------------------------------------------------
+
+    /** The [0,1] parameter range is sweeped through infinitely.<p>
+
+    	The [0,1] parameter range is sweeped through infinitely,
+    	starting with 0, going to 1, and going back to 0, and then
+    	starting again. When plotting the value over time, this yields
+    	a repeated triangle curve.<p>
+    */
+    const byte PINGPONG=2;
+
+	//-------------------------------------------------------------------------
+
+    /** The [0,1] parameter range is sweeped through infinitely.<p>
+
+    	The [0,1] parameter range is sweeped through infinitely,
+    	starting with 0, going to 1, and starting with 0 again. When
+    	plotting the value over time, this yields a repeated saw-tooth
+    	curve.<p>
+    */
+    const byte REPEAT=3;
+};
+
+}; }; }; };
+
+#endif
--- /dev/null	2004-08-25 23:04:59.000000000 +0530
+++ offapi/com/sun/star/rendering/CanvasFactory.idl	2005-02-28 13:41:29.000000000 +0530
@@ -0,0 +1,92 @@
+/*************************************************************************
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
+ *
+ *  Copyright: 2000 by Sun Microsystems, Inc.
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+
+#if ! defined INCLUDED_drafts_com_sun_star_rendering_CanvasFactory_idl
+#define INCLUDED_drafts_com_sun_star_rendering_CanvasFactory_idl
+
+#include <com/sun/star/lang/XMultiComponentFactory.idl>
+
+
+module com { module sun { module star { module rendering {
+
+/** The <type>CanvasFactory</type> is used to create the <type>Canvas</type>
+    objects, evaluating the user's configuration preferences from
+    
+    <code>/org.openoffice.VCL/Settings/Canvas/PreferredServices</code>.
+    
+    The latter specifies a string list of service names to use.
+
+    <p>
+    Instantiating this service, you can use its
+    <type scope="com::sun::star::lang">XMultiComponentFactory</type>
+    interface to create <type>Canvas</type> objects, passing an empty string
+    as service specifier (default).
+    If you want to manually override the configured service list, you can pass
+    a service name to try first.
+    </p>
+    
+    @since #110496#
+*/
+service CanvasFactory : com::sun::star::lang::XMultiComponentFactory;
+ 
+}; }; }; };
+
+#endif
--- /dev/null	2004-08-25 23:04:59.000000000 +0530
+++ offapi/com/sun/star/rendering/Caret.idl	2005-02-28 13:41:29.000000000 +0530
@@ -0,0 +1,104 @@
+/*************************************************************************
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
+ *
+ *  Copyright: 2000 by Sun Microsystems, Inc.
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+#ifndef __com_sun_star_rendering_Caret_idl__
+#define __com_sun_star_rendering_Caret_idl__
+
+module com { module sun { module star { module rendering {
+
+/** This structure contains the caret information.<p>
+
+	This structure is used from the <type>XTextLayout</type> interface
+	to transport information regarding a text caret.<p>
+
+    @since #110496#
+ */
+struct Caret 
+{
+    /** This contains the main caret index.<p>
+
+    	The main caret index corresponds to the insert position when
+    	inserting text in the layout's main text direction.
+     */
+    long 		MainCaretIndex;
+
+    /** This contains the secondary caret index.<p>
+
+    	The secondary caret index, when different from the main caret
+    	index, corresponds to the insert position when inserting text
+    	at a direction change opposite to the layout's main text
+    	direction.
+     */
+    long 		SecondaryCaretIndex;
+
+    /** The angle of the caret.<p>
+
+    	This member contains the rotation angle of the caret in
+    	degrees, with 0 denoting an unrotated caret (the unrotated
+    	caret orientation depends on the writing mode, horizontally or
+    	vertically). The rotation angle is positive for
+    	counter-clockwise rotations.<p>
+     */
+    double		CaretAngle;
+};
+
+}; }; }; };
+
+#endif
--- /dev/null	2004-08-25 23:04:59.000000000 +0530
+++ offapi/com/sun/star/rendering/ColorProfile.idl	2005-02-28 13:41:29.000000000 +0530
@@ -0,0 +1,76 @@
+/*************************************************************************
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
+ *
+ *  Copyright: 2000 by Sun Microsystems, Inc.
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+#ifndef __com_sun_star_rendering_ColorProfile_idl__
+#define __com_sun_star_rendering_ColorProfile_idl__
+
+module com { module sun { module star { module rendering {
+
+/* TODO: There's still a lot open here! */
+
+struct ColorProfile
+{
+    // TODO
+	byte dummy;
+};
+
+}; }; }; };
+
+#endif
--- /dev/null	2004-08-25 23:04:59.000000000 +0530
+++ offapi/com/sun/star/rendering/ColorSpaceType.idl	2005-02-28 13:41:29.000000000 +0530
@@ -0,0 +1,74 @@
+/*************************************************************************
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
+ *
+ *  Copyright: 2000 by Sun Microsystems, Inc.
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+#ifndef __com_sun_star_rendering_ColorSpaceType_idl__
+#define __com_sun_star_rendering_ColorSpaceType_idl__
+
+module com { module sun { module star { module rendering {
+
+struct ColorSpaceType
+{
+    // TODO
+	byte dummy;
+};
+
+}; }; }; };
+
+#endif
--- /dev/null	2004-08-25 23:04:59.000000000 +0530
+++ offapi/com/sun/star/rendering/CompositeOperation.idl	2005-02-28 13:41:29.000000000 +0530
@@ -0,0 +1,192 @@
+/*************************************************************************
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
+ *
+ *  Copyright: 2000 by Sun Microsystems, Inc.
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+#ifndef __com_sun_star_rendering_CompositeOperation_idl__
+#define __com_sun_star_rendering_CompositeOperation_idl__
+
+module com { module sun { module star { module rendering {
+
+/** These constants determine how the primitive color is combined with
+    the background.<p>
+
+	When performing this calculations, it is assumed that all color
+	values are premultiplied with the corresponding alpha values (if
+	no alpha is specified, 1.0 is assumed). Then, the following
+	general compositing operation is performed: 
+    <p>
+    C = Ca * Fa + Cb * Fb
+    <p>
+    where C is the result color, Ca and Cb are the input colors,
+    premultiplied with alpha, and Fa and Fb are described for the
+    different composite modes (wherein Aa and Ab denote source and
+    destination alpha, respectively).<p>
+
+    @since #110496#
+ */
+constants CompositeOperation
+{
+    /** Clear the destination.<p>
+
+    	Clear the destination area. The function values are: Fa = Fb =
+    	0.<p>
+     */
+	const byte CLEAR = 0;
+
+    /** Copy source as-is to the destination.<p>
+
+    	Copy source as-is to the destination. The function values are:
+    	Fa = 1, Fb = 0.<p>
+     */
+    const byte SOURCE = 1;
+	
+    /** Leave the destination as-is.<p>
+
+    	Leave the destination as-is. The function values are: Fa = 0,
+    	Fb = 1.<p>
+     */
+    const byte DESTINATION = 2;
+
+    /** Copy the source over the destination.<p>
+        
+	    Copy the source over the destination. The function values are:
+	    Fa = 1, Fb = 1-Aa.<p>
+     */
+    const byte OVER = 3;
+
+    /** Copy the source under the destination.<p>
+
+    	Copy the source under the destination. The function values
+    	are: Fa = 1-Ab, Fb = 1.<p>
+     */
+    const byte UNDER = 4;
+
+    /** Copy the source to the destination.<p>
+
+    	Copy the source to the destination, but limited to where the
+    	destination is. The function values are: Fa = Ab, Fb = 0.<p>
+     */
+    const byte INSIDE = 5;
+
+    /** Leave the destination as is.<p>
+
+    	Leave the destination as is, but only where the source
+    	was. The function values are: Fa = 0, Fb = Aa.<p>
+     */
+    const byte INSIDE_REVERSE = 6;
+
+    /** Copy the source to the destination<p>
+        
+    	Copy the source to the destination, but limited to where the
+    	destination is not. The function values are: Fa = 1-Ab, Fb =
+    	0.<p>
+     */
+    const byte OUTSIDE = 7;
+
+    /** Leave the destination as is.<p>
+
+    	Leave the destination as is, but only where the source has not
+    	been. The function values are: Fa = 0, Fb = 1-Aa.<p>
+     */
+    const byte OUTSIDE_REVERSE = 8;
+
+    /** Copy the source over the destination<p>
+        
+    	Copy the source over the destination, but only where the
+    	destination is. Keep the destination. The function values are:
+    	Fa = Ab, Fb = 1-Aa.<p>
+     */
+    const byte ATOP = 9;
+
+    /** Copy the destination over the source.<p>
+
+    	Copy the destination over the source, but only where the
+    	source is. Keep the source. The function values are: Fa =
+    	1-Ab, Fb = Aa.<p>
+     */
+    const byte ATOP_REVERSE = 10;
+
+    /** Combine source and destination by exclusive or.<p>
+
+    	Take only the parts where either source or destination, but
+    	not both visible. The function values are: Fa = 1-Ab, Fb =
+    	1-Aa.<p>
+     */
+    const byte XOR = 11;
+
+    /** Add source and destination values.<p>
+
+    	Simply add contributions of both source and destination. The
+    	resulting color values are limited to the permissible color
+    	range, and clipped to the maximal value, if exceeded. The
+    	function values are: Fa = 1, Fb = 1.<p>
+    */
+    const byte ADD = 12;
+
+    /** Saturate source and destination.<p>
+
+    	Saturate destination with source values. The function values
+    	are: Fa = min(1,(1-Ab)/Aa), Fb = 1<p>
+     */
+    const byte SATURATE = 13;
+};
+
+}; }; }; };
+
+#endif
--- /dev/null	2004-08-25 23:04:59.000000000 +0530
+++ offapi/com/sun/star/rendering/EmphasisMark.idl	2005-02-28 13:41:29.000000000 +0530
@@ -0,0 +1,121 @@
+/*************************************************************************
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
+ *
+ *  Copyright: 2000 by Sun Microsystems, Inc.
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+#ifndef __com_sun_star_rendering_EmphasisMark_idl__
+#define __com_sun_star_rendering_EmphasisMark_idl__
+
+module com { module sun { module star { module rendering {
+
+/** These constants control the automatic rendering of emphasis marks.<p>
+
+	These constants control the automatic rendering of emphasis marks
+	for a given font.<p>
+
+    @since #110496#
+ */
+constants EmphasisMark
+{
+    /// No automatic emphasis marks
+    const byte NONE = 0;
+
+	//-------------------------------------------------------------------------
+
+    /// Automatic emphasis marks as dots above the glyphs
+    const byte DOT_ABOVE = 1;
+
+	//-------------------------------------------------------------------------
+
+    /// Automatic emphasis marks as dots below the glyphs
+    const byte DOT_BELOW = 2;
+
+	//-------------------------------------------------------------------------
+
+    /// Automatic emphasis marks as circles (unfilled outlines) above the glyphs
+    const byte CIRCLE_ABOVE = 3;
+
+	//-------------------------------------------------------------------------
+
+    /// Automatic emphasis marks as circles (unfilled outlines) below the glyphs
+    const byte CIRCLE_BELOW = 4;
+
+	//-------------------------------------------------------------------------
+
+    /// Automatic emphasis marks as discs (filled circles) above the glyphs
+    const byte DISC_ABOVE = 5;
+
+	//-------------------------------------------------------------------------
+
+    /// Automatic emphasis marks as discs (filled circles) below the glyphs
+    const byte DISC_BELOW = 6;
+
+	//-------------------------------------------------------------------------
+
+    /// Automatic emphasis marks as accent marks above the glyphs
+    const byte ACCENT_ABOVE = 7;
+
+	//-------------------------------------------------------------------------
+
+    /// Automatic emphasis marks as accent marks below the glyphs
+    const byte ACCENT_BELOW = 8;
+};
+
+}; }; }; };
+
+#endif
--- /dev/null	2004-08-25 23:04:59.000000000 +0530
+++ offapi/com/sun/star/rendering/Endianness.idl	2005-02-28 13:41:29.000000000 +0530
@@ -0,0 +1,94 @@
+/*************************************************************************
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
+ *
+ *  Copyright: 2000 by Sun Microsystems, Inc.
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+#ifndef __com_sun_star_rendering_Endianness_idl__
+#define __com_sun_star_rendering_Endianness_idl__
+
+module com { module sun { module star { module rendering {
+
+/** These constans describe the endiannes of data structures.<p>
+
+	The endianness specifies the order in which the bytes of larger
+	types are laid out in memory.<p>
+
+    @since #110496#
+ */
+constants Endianness 
+{
+    /** Little endian.<p>
+
+    	The values are stored in little endian format, i.e. the bytes
+    	of the long word 0xAABBCCDD are layed out like 0xDD, 0xCC,
+    	0xBB, 0xAA in memory.<p>
+     */
+    const byte	LITTLE=0;
+
+    /** Big endian.<p>
+
+    	The values are stored in big endian format, i.e. the bytes
+    	of the long word 0xAABBCCDD are layed out like 0xAA, 0xBB,
+    	0xCC, 0xDD in memory.<p>
+     */
+    const byte BIG=1;
+};
+
+}; }; }; };
+
+#endif
--- /dev/null	2004-08-25 23:04:59.000000000 +0530
+++ offapi/com/sun/star/rendering/FillRule.idl	2005-02-28 13:41:29.000000000 +0530
@@ -0,0 +1,93 @@
+/*************************************************************************
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
+ *
+ *  Copyright: 2000 by Sun Microsystems, Inc.
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+#ifndef __com_sun_star_rendering_FillRule_idl__
+#define __com_sun_star_rendering_FillRule_idl__
+
+module com { module sun { module star { module rendering {
+
+/** Determines which algorithm to use when determining inside and
+    outside of filled poly-polygons.
+
+    @since #110496#
+ */
+enum FillRule
+{
+    /** Fill every area, which is within one or more of the
+        poly-polygons polygons.<p>
+
+        For example, a poly-polygon consisting of two concentric
+        circles is filled the same way as if only the outer circle
+        would exist.<p>
+     */
+	NON_ZERO,
+
+	//-------------------------------------------------------------------------
+
+    /** Fill every area, where, when travelling along a line, an
+        uneven number of intersections with polygon edges have
+        happened.<p>
+     */
+	EVEN_ODD
+};
+
+}; }; }; };
+
+#endif
--- /dev/null	2004-08-25 23:04:59.000000000 +0530
+++ offapi/com/sun/star/rendering/FloatingPointBitmapFormat.idl	2005-02-28 13:41:29.000000000 +0530
@@ -0,0 +1,132 @@
+/*************************************************************************
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
+ *
+ *  Copyright: 2000 by Sun Microsystems, Inc.
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+#ifndef __com_sun_star_rendering_FloatingPointBitmapFormat_idl__
+#define __com_sun_star_rendering_FloatingPointBitmapFormat_idl__
+
+module com { module sun { module star { module rendering {
+
+/** This structure describes format of a floating point bitmap.
+
+    @since #110496#
+ */
+constants FloatingPointBitmapFormat 
+{
+    /** Half-float format, with chunky layout.<p>
+
+    	The color components are stored in the half-float format,
+    	i.e. in a 16 bit value, with 5 bit exponent, 10 bit mantissa
+    	and a sign bit. The bits of each value are stored consecutive
+    	in memory.<p>
+     */
+    const byte	CHUNKY_HALFFLOAT=0;
+
+    /** Half-float format, with plane layout.<p>
+
+    	The color components are stored in the half-float format,
+    	i.e. in a 16 bit value, with 5 bit exponent, 10 bit mantissa
+    	and a sign bit. The bits of each value are stored each bit in
+    	a separate plane, i.e. a plane contains a single bit from
+    	every pixel's components.<p>
+     */
+    const byte	PLANES_HALFFLOAT=1;
+
+    /** IEEE float format, with chunky layout.<p>
+
+    	The color components are stored in the IEEE single-precision
+    	floating point format, i.e. in a 32 bit value, with 8 bit
+    	exponent, 23 bit mantissa and a sign bit. The bits of each
+    	value are stored consecutive in memory.<p>
+     */
+    const byte	CHUNKY_FLOAT=2;
+
+    /** IEEE float format, with plane layout.<p>
+
+    	The color components are stored in the IEEE single-precision
+    	floating point format, i.e. in a 32 bit value, with 8 bit
+    	exponent, 23 bit mantissa and a sign bit. The bits of each
+    	value are stored each bit in a separate plane, i.e. a plane
+    	contains a single bit from every pixel's components.<p>
+     */
+    const byte	PLANES_FLOAT=3;
+
+    /** IEEE double format, with chunky layout.<p>
+
+    	The color components are stored in the IEEE double-precision
+    	floating point format, i.e. in a 64 bit value, with 16 bit
+    	exponent, 47 bit mantissa and a sign bit. The bits of each
+    	value are stored consecutive in memory.<p>
+     */
+    const byte	CHUNKY_DOUBLE=4;
+
+    /** IEEE double format, with chunky layout.<p>
+
+    	The color components are stored in the IEEE double-precision
+    	floating point format, i.e. in a 64 bit value, with 16 bit
+    	exponent, 47 bit mantissa and a sign bit. The bits of each
+    	value are stored each bit in a separate plane, i.e. a plane
+    	contains a single bit from every pixel's components.<p>
+     */
+    const byte	PLANES_DOUBLE=5;
+};
+
+}; }; }; };
+
+#endif
--- /dev/null	2004-08-25 23:04:59.000000000 +0530
+++ offapi/com/sun/star/rendering/FloatingPointBitmapLayout.idl	2005-02-28 13:41:29.000000000 +0530
@@ -0,0 +1,114 @@
+/*************************************************************************
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
+ *
+ *  Copyright: 2000 by Sun Microsystems, Inc.
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+#ifndef __com_sun_star_rendering_FloatingPointBitmapLayout_idl__
+#define __com_sun_star_rendering_FloatingPointBitmapLayout_idl__
+
+#ifndef __com_sun_star_rendering_Endianness_idl__
+#include <com/sun/star/rendering/Endianness.idl>
+#endif
+#ifndef __com_sun_star_rendering_FloatingPointBitmapFormat_idl__
+#include <com/sun/star/rendering/FloatingPointBitmapFormat.idl>
+#endif
+
+module com { module sun { module star { module rendering {
+
+/** This structure describes the memory layout of a bitmap having
+    floating point color channels.<p>
+
+    This structure collects all necessary information to describe the
+    memory layout of a bitmap having floating point color channels<p>
+
+    @since #110496#
+ */
+struct FloatingPointBitmapLayout
+{
+    /// Number of scanlines for this bitmap.
+    long				ScanLines;
+
+    /// Number of data bytes per scanline.
+    long 				ScanLineBytes;
+
+    /// Byte offset between the start of two consecutive scanlines.
+    long				ScanLineStride;
+
+    /// Byte offset between the start of two consecutive planes.
+    long				PlaneStride;
+
+    /// Number of color components per pixel.
+    long			    NumComponents;
+
+    /** Endianness of the pixel values.
+
+    	This value must be one of the <type>Endianness</type> constants
+     */
+    byte			    Endianness;
+
+    /** Format type of this bitmap.<p>
+
+    	This value must be one of the
+    	<type>FloatingPointBitmapFormat</type> constants.<p>
+    */
+    byte				Format;
+};
+
+}; }; }; };
+
+#endif
--- /dev/null	2004-08-25 23:04:59.000000000 +0530
+++ offapi/com/sun/star/rendering/FontInfo.idl	2005-02-28 13:41:29.000000000 +0530
@@ -0,0 +1,160 @@
+/*************************************************************************
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
+ *
+ *  Copyright: 2000 by Sun Microsystems, Inc.
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+#ifndef __com_sun_star_rendering_FontInfo_idl__
+#define __com_sun_star_rendering_FontInfo_idl__
+
+#ifndef __com_sun_star_util_TriState_idl__ 
+#include <com/sun/star/util/TriState.idl>
+#endif
+
+#ifndef __com_sun_star_rendering_Panose_idl__
+#include <com/sun/star/rendering/Panose.idl>
+#endif
+
+
+module com { module sun { module star { module rendering {
+
+/** This structure provides information about a specific font.<p>
+
+    @since #110496#
+ */
+struct FontInfo
+{
+    /** The PANOSE font classification.<p>
+
+        TODO: Document semantics in Panose.idl
+     */
+    Panose								FontDescription;
+
+	//-------------------------------------------------------------------------
+
+    /** The name of the font family.<p>
+
+    	The family name is the one normally associated to a font, such
+    	as Times New Roman, Thorndale, Andale or Arial.<p>
+
+        Note: outlined fonts are now specified with 'outline' as part
+        of the family name.<p>
+     */
+    string								FamilyName;
+
+	//-------------------------------------------------------------------------
+
+    /** The name of the specific font style within its family.<p>
+
+    	For example, oblique, italic, or narrow.<p>
+     */
+    string								StyleName;
+
+	//-------------------------------------------------------------------------
+
+    /** This value specifies which unicode ranges are supported by
+     	this font.<p>
+
+    	This is to be interpreted as a split-up 128bit value, see <a
+    	href=http://partners.adobe.com/asn/tech/type/opentype/os2.jsp#ur>Adobe's
+    	OpenType specification</a> for the specific meaning of each
+    	bit. UnicodeRanges0 contains the least significant bits,
+    	UnicodeRanges3 the most significant ones.<p>
+
+        const int128       UNICODE_RANGE_BASIC_LATIN = 1;
+        const int128       UNICODE_RANGE_LATIN_SUPPLEMENT = 2;
+        const int128       UNICODE_RANGE_LATIN_EXTENDED_A = 4;
+        const int128       UNICODE_RANGE_LATIN_EXTENDED_B = 4;
+        ...
+        const int128       UNICODE_RANGE_MASK_LATIN = 1;
+        const int128       UNICODE_RANGE_MASK_CJK   = (31<<48) + (3<<55) +
+        (1<<59);
+        const int128       UNICODE_RANGE_MASK_CTL   = (1<<11) + (1<<13) +
+        (0x3FFF<<15) + (0x0FFF<<70);
+
+     */
+    long								UnicodeRanges0;
+    long								UnicodeRanges1;
+    long								UnicodeRanges2;
+    long								UnicodeRanges3;
+
+	//-------------------------------------------------------------------------
+
+    /** Specifies whether the font is a symbol font.<p>
+
+    	If yes, text written in this symbol font does not have a
+    	specified meaning.<p>
+     */
+    ::com::sun::star::util::TriState	IsSymbolFont;
+
+	//-------------------------------------------------------------------------
+
+    /** Set to true, if the font is usable for vertical text
+        output.<p>
+
+        Vertical fonts have subtle differences to horizontal ones,
+        e.g. rotated or differently shaped glyphs, or special rotated
+        versions of normally upright glyphs (e.g. brackets).<p>
+     */
+    ::com::sun::star::util::TriState	IsVertical;
+
+
+};
+
+}; }; }; };
+
+#endif
--- /dev/null	2004-08-25 23:04:59.000000000 +0530
+++ offapi/com/sun/star/rendering/FontMetrics.idl	2005-02-28 13:41:29.000000000 +0530
@@ -0,0 +1,135 @@
+/*************************************************************************
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
+ *
+ *  Copyright: 2000 by Sun Microsystems, Inc.
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+#ifndef __com_sun_star_rendering_FontMetrics_idl__
+#define __com_sun_star_rendering_FontMetrics_idl__
+
+module com { module sun { module star { module rendering {
+
+/** Metrics global to the font, i.e. not specific to single
+    glyphs. The font height is defined as
+    ascent+descent+internalLeading, and therefore not explicitely
+    included here.<p>
+
+    Please note that when querying FontMetrics from an XCanvasFont
+    interface, all values here are given in device coordinates, and
+    already tuned to the specific font size. That means, the
+    referenceCharWidth and/or ascent+descent+internalLeading will
+    approximately (rounded to integer device resolution, or exactly,
+    if fractional font rendering is enabled) match the
+    referenceAdvancement/cellSize members of the FontRequest for
+    which the XCanvasFont was queried.
+
+    @since #110496#
+ */
+struct FontMetrics
+{
+    /// Ascent (above the baseline) part of the font. 
+    double		Ascent;
+
+	//-------------------------------------------------------------------------
+
+    /// Descent (below the baseline) part of the font.
+    double		Descent; 
+
+	//-------------------------------------------------------------------------
+
+    /// Extra space above ascent
+    double		InternalLeading; 
+
+	//-------------------------------------------------------------------------
+
+    /** Extra space outside the font cells.<p>
+
+        It should not contain ink marks and is typically used
+        by the font designer to modify the line distance.<p>
+     */
+    double		ExternalLeading;
+
+	//-------------------------------------------------------------------------
+
+    /** This value specifies the reference character width of the
+        font.<p>
+
+        It's roughly equivalent to the average width of all
+        characters, and if one needs a font with double character
+        width, the referenceCharSize should be doubled.<p>
+     */
+    double 		ReferenceCharSize;
+
+	//-------------------------------------------------------------------------
+
+    /** Specifies the offset to be added to the baseline when drawing
+        underlined text.
+     */
+    double 		UnderlineOffset;
+
+	//-------------------------------------------------------------------------
+
+    /** Specifies the offset to be added to the baseline when striking
+        through the text.
+     */
+    double		StrikeThroughOffset;
+
+};
+
+}; }; }; };
+
+#endif
--- /dev/null	2004-08-25 23:04:59.000000000 +0530
+++ offapi/com/sun/star/rendering/FontRequest.idl	2005-02-28 13:41:29.000000000 +0530
@@ -0,0 +1,149 @@
+/*************************************************************************
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
+ *
+ *  Copyright: 2000 by Sun Microsystems, Inc.
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+#ifndef __com_sun_star_rendering_FontRequest_idl__
+#define __com_sun_star_rendering_FontRequest_idl__
+
+#ifndef __com_sun_star_rendering_FontInfo_idl__
+#include <com/sun/star/rendering/FontInfo.idl>
+#endif
+
+#ifndef __com_sun_star_lang_Locale_idl__
+#include <com/sun/star/lang/Locale.idl>
+#endif
+
+module com { module sun { module star { module rendering {
+
+/** This structure contains all information necessary to describe a
+    font to be queried from XCanvas.<p>
+    
+    Note: Outline fonts are to be requested as a special family, set
+    <member>FontInfo::FamilyName</member> appropriately. Emboss/relief
+    must be emulated by upper layers.<p>
+
+    Leave the <member>FontInfo::FamilyName</member> and
+    <member>FontInfo::StyleName</member> empty, if font selection
+    should only happen via the PANOSE description.
+
+    @since #110496#
+ */
+struct FontRequest
+{
+    /** The description of the font.<p>
+
+    	This member contains the description of the font as returned
+    	by the font listing methods.<p>
+     */
+    FontInfo						FontDescription;
+
+	//-------------------------------------------------------------------------
+
+    /** The size of the font in <em>device</em> coordinate space.<p>
+
+    	This value corresponds to the font height in Western scripts,
+    	but is independent of the writing direction (see
+    	<member>FontRequest::IsVertical</member> below). That
+    	means, the value specified here is always measured orthogonal
+    	to the text advancement (height for horizontal writing, and
+    	width for vertical writing).<p>
+
+        When this value is negative, its absolute value is taken as
+        the character size of the font. If this value is positive,
+        it's taken as the cell size of the font.<p>
+
+        This member and the referenceAdvancement member are mutually
+        exclusive, one of them has to be set to 0 (which means don't
+        care). For distorted fonts, the render transformation must be
+        used.<p>
+    */ 
+    double 							CellSize; 
+
+	//-------------------------------------------------------------------------
+
+    /** This value specifies the size of the font in the writing
+        direction (i.e. width for horizontal writing, and height for
+        vertical writing).<p>
+
+        It is equivalent to the referenceCharSize of the FontMetrics
+        structure.<p>
+
+        This member and the cellSize member are mutually exclusive,
+        one of them has to be set to 0 (which means don't care). For
+        distorted fonts, the font matrix must be used.<p>
+     */
+    double							ReferenceAdvancement;
+
+	//-------------------------------------------------------------------------
+    
+    /** The locale this font should be able to render.<p>
+
+    	This member supplements the
+    	<member>FontInfo::UnicodeRange0</member> entry with a specific
+    	locale; this is e.g. important when selecting between
+    	traditional and simplified chinese is necessary (since the
+    	letters have the same unicode ranges and character values).<p>
+     */
+    ::com::sun::star::lang::Locale	Locale;
+
+};
+
+}; }; }; };
+
+#endif
--- /dev/null	2004-08-25 23:04:59.000000000 +0530
+++ offapi/com/sun/star/rendering/IntegerBitmapFormat.idl	2005-02-28 13:41:29.000000000 +0530
@@ -0,0 +1,147 @@
+/*************************************************************************
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
+ *
+ *  Copyright: 2000 by Sun Microsystems, Inc.
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+#ifndef __com_sun_star_rendering_IntegerBitmapFormat_idl__
+#define __com_sun_star_rendering_IntegerBitmapFormat_idl__
+
+module com { module sun { module star { module rendering {
+
+/** This structure describes the format of an integer bitmap.
+
+    @since #110496#
+ */
+constants IntegerBitmapFormat 
+{
+    /** One bit format, with chunky layout.
+     */
+    const byte	CHUNKY_1BIT=0;
+
+    /** One bit format, with plane layout.
+     */
+    const byte	PLANES_1BIT=1;
+
+    /** Two bit format, with chunky layout.
+     */
+    const byte	CHUNKY_2BIT=2;
+
+    /** Two bit format, with plane layout.
+     */
+    const byte	PLANES_2BIT=3;
+
+    /** Four bit format, with chunky layout.
+     */
+    const byte	CHUNKY_4BIT=4;
+
+    /** Four bit format, with plane layout.
+     */
+    const byte	PLANES_4BIT=5;
+
+    /** Eight bit format, with chunky layout.
+     */
+    const byte	CHUNKY_8BIT=6;
+
+    /** Eight bit format, with plane layout.
+     */
+    const byte	PLANES_8BIT=7;
+
+    /** Sixteen bit format, with chunky layout.
+     */
+    const byte	CHUNKY_16BIT=8;
+
+    /** Sixteen bit format, with plane layout.
+     */
+    const byte	PLANES_16BIT=9;
+
+    /** Twentyfour bit format, with chunky layout.
+     */
+    const byte	CHUNKY_24BIT=10;
+
+    /** Twentyfour bit format, with plane layout.
+     */
+    const byte	PLANES_24BIT=11;
+
+    /** Thirtytwo bit format, with chunky layout.
+     */
+    const byte	CHUNKY_32BIT=12;
+
+    /** Thirtytwo bit format, with plane layout.
+     */
+    const byte	PLANES_32BIT=13;
+
+    /** Fourtyeight bit format, with chunky layout.
+     */
+    const byte	CHUNKY_48BIT=14;
+
+    /** Fourtyeight bit format, with plane layout.
+     */
+    const byte	PLANES_48BIT=15;
+
+    /** Sixtyfour bit format, with chunky layout.
+     */
+    const byte	CHUNKY_64BIT=16;
+
+    /** Sixtyfour bit format, with plane layout.
+     */
+    const byte	PLANES_64BIT=17;
+};
+
+}; }; }; };
+
+#endif
--- /dev/null	2004-08-25 23:04:59.000000000 +0530
+++ offapi/com/sun/star/rendering/IntegerBitmapLayout.idl	2005-02-28 13:41:29.000000000 +0530
@@ -0,0 +1,133 @@
+/*************************************************************************
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
+ *
+ *  Copyright: 2000 by Sun Microsystems, Inc.
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+#ifndef __com_sun_star_rendering_IntegerBitmapLayout_idl__
+#define __com_sun_star_rendering_IntegerBitmapLayout_idl__
+
+#ifndef __com_sun_star_rendering_Endianness_idl__
+#include <com/sun/star/rendering/Endianness.idl>
+#endif
+#ifndef __com_sun_star_rendering_IntegerBitmapFormat_idl__
+#include <com/sun/star/rendering/IntegerBitmapFormat.idl>
+#endif
+
+module com { module sun { module star { module rendering {
+
+/** This structure describes the memory layout of a bitmap having
+    integer color channels.<p>
+
+    This structure collects all necessary information to describe the
+    memory layout of a bitmap having integer color channels<p>
+
+    @since #110496#
+ */
+struct IntegerBitmapLayout
+{
+    /// Number of scanlines for this bitmap.
+    long				ScanLines;
+
+    /// Number of data bytes per scanline.
+    long 				ScanLineBytes;
+
+    /// Byte offset between the start of two consecutive scanlines.
+    long				ScanLineStride;
+
+    /// Byte offset between the start of two consecutive planes.
+    long				PlaneStride;
+
+    /// Number of color components per pixel.
+    long			    NumComponents;
+
+    /** Mask values for packed bitmaps
+
+    	This member contains NumComponents 64 bit masks, which can be
+    	used to mask out the corresponding color component from the
+    	bitmap data. For the typical 32 bit RGBA color data, the four
+    	mask values would look like 0xFF000000, 0x00FF0000,
+    	0x0000FF00, and 0x000000FF.
+     */
+    sequence<hyper>	    ComponentMasks;
+
+    /** Endianness of the pixel values.
+
+    	This value must be one of the <type>Endianness</type> constants
+     */
+    byte			    Endianness;
+
+    /** Format type of this bitmap.<p>
+
+    	This value must be one of the <type>IntegerBitmapFormat</type>
+    	constants. The precise layout of the color channels within a
+    	bitmap pixel is further specified via the ComponentMasks member.<p>
+    */
+    byte				Format;
+
+    /** This member determines whether the bitmap data are actually
+        indices into a color map.<p>
+
+        The member must not be true for bitmap formats of more than
+        eight bits per pixel.<p>
+     */
+    boolean				IsPseudoColor;
+};
+
+}; }; }; };
+
+#endif
--- /dev/null	2004-08-25 23:04:59.000000000 +0530
+++ offapi/com/sun/star/rendering/InterpolationMode.idl	2005-02-28 13:41:29.000000000 +0530
@@ -0,0 +1,131 @@
+/*************************************************************************
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
+ *
+ *  Copyright: 2000 by Sun Microsystems, Inc.
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+#ifndef __com_sun_star_rendering_InterpolationMode_idl__
+#define __com_sun_star_rendering_InterpolationMode_idl__
+
+module com { module sun { module star { module rendering {
+
+/** These constants specify the interpolation type for animation
+    frames.<p>
+
+    With this constants, one specifies the way of interpolation that
+    takes place between two consecutive frames of a discrete animation
+    sequence.
+
+    @since #110496#
+ */
+constants InterpolationMode
+{
+    /** Perform a nearest neighbor interpolation.<p>
+
+    	That is, when interpolating between two values v0 and v1,
+    	positioned at t0 and t1, take the one which has the closest t
+    	coordinate.<p>
+     */
+	const byte NEAREST_NEIGHBOR=1;
+
+	//-------------------------------------------------------------------------
+
+    /** Perform a linear interpolation.<p>
+
+    	That is, when interpolating at position t between two values
+    	v0 and v1, positioned at t0 and t1, take the sum of v0
+    	weighted with (t-t0) and v1 weighted with (t1-t).<p>
+     */
+	const byte LINEAR=2;
+
+	//-------------------------------------------------------------------------
+
+    /** Perform a cubic interpolation.<p>
+
+    	That is, when interpolating at position t, take the four
+    	closest data points v0, v1, v2, and v3, fit a cubic curve
+    	through them, and take the interpolated value from this cubic
+    	curve.<p>
+     */
+	const byte CUBIC=3;
+
+	//-------------------------------------------------------------------------
+
+    /** Perform a cubic bezier spline interpolation.<p>
+
+    	That is, when interpolating at position t, take the three
+    	closest data points v0, v1, and v2, fit a cubic bezier spline
+    	through them, and take the interpolated value from this cubic
+    	curve.<p>
+     */
+	const byte BEZIERSPLINE3=4;
+
+	//-------------------------------------------------------------------------
+
+    /** Perform a quadric bezier spline interpolation.<p>
+
+    	That is, when interpolating at position t, take the four
+    	closest data points v0, v1, v2, and v3, fit a quadric bezier
+    	spline through them, and take the interpolated value from this
+    	quadric curve.<p>
+     */
+	const byte BEZIERSPLINE4=5;
+}; 
+
+}; }; }; };
+
+#endif
--- /dev/null	2004-08-25 23:04:59.000000000 +0530
+++ offapi/com/sun/star/rendering/makefile.mk	2005-02-28 13:41:29.000000000 +0530
@@ -0,0 +1,125 @@
+#*************************************************************************
+#
+#  $RCSfile$
+#
+#  $Revision$
+#
+#  last change: $Author$ $Date$
+#
+#  The Contents of this file are made available subject to the terms of
+#  the BSD license.
+#  
+#  Copyright (c) 2003 by Sun Microsystems, Inc.
+#  All rights reserved.
+#
+#  Redistribution and use in source and binary forms, with or without
+#  modification, are permitted provided that the following conditions
+#  are met:
+#  1. Redistributions of source code must retain the above copyright
+#     notice, this list of conditions and the following disclaimer.
+#  2. Redistributions in binary form must reproduce the above copyright
+#     notice, this list of conditions and the following disclaimer in the
+#     documentation and/or other materials provided with the distribution.
+#  3. Neither the name of Sun Microsystems, Inc. nor the names of its
+#     contributors may be used to endorse or promote products derived
+#     from this software without specific prior written permission.
+#
+#  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+#  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+#  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+#  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+#  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+#  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+#  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
+#  OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+#  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
+#  TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
+#  USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+#     
+#**************************************************************************
+
+PRJ=..$/..$/..$/..
+
+PRJNAME=rendering
+
+TARGET=cssrendering
+PACKAGE=com$/sun$/star$/rendering
+
+# --- Settings -----------------------------------------------------
+.INCLUDE :  $(PRJ)$/util$/makefile.pmk
+
+# ------------------------------------------------------------------------
+
+IDLFILES=\
+	PanoseFamilyTypes.idl \
+	PanoseSerifStyle.idl \
+	PanoseWeight.idl \
+	PanoseProportion.idl \
+	PanoseContrast.idl \
+	PanoseStrokeVariation.idl \
+	PanoseArmStyle.idl \
+	PanoseLetterForm.idl \
+	PanoseMidline.idl \
+	PanoseXHeight.idl \
+	Panose.idl \
+	AnimationAttributes.idl \
+	AnimationRepeat.idl \
+	PathCapType.idl \
+	PathJoinType.idl \
+	Caret.idl \
+	RenderState.idl \
+	RenderingIntent.idl \
+	ColorProfile.idl \
+	ColorSpaceType.idl \
+	XColorSpace.idl \
+	RepaintResult.idl \
+	CompositeOperation.idl \
+	StringContext.idl \
+	EmphasisMark.idl \
+	StrokeAttributes.idl \
+	Endianness.idl \
+	TextDirection.idl \
+	FillRule.idl \
+	TextHit.idl \
+	FloatingPointBitmapFormat.idl \
+	Texture.idl \
+	FloatingPointBitmapLayout.idl \
+	TexturingMode.idl \
+	XLinePolyPolygon2D.idl \
+	FontInfo.idl \
+	ViewState.idl \
+	XParametricPolyPolygon2D.idl \
+	VolatileContentDestroyedException.idl \
+	XParametricPolyPolygon2DFactory.idl \
+	FontMetrics.idl \
+	XAnimatedSprite.idl \
+	XPolyPolygon2D.idl \
+	FontRequest.idl \
+	XAnimation.idl \
+	XSprite.idl \
+	IntegerBitmapFormat.idl \
+	XBezierPolyPolygon2D.idl \
+	XSpriteCanvas.idl \
+	IntegerBitmapLayout.idl \
+	XBitmap.idl \
+	XTextLayout.idl \
+	XBitmapCanvas.idl \
+	XVolatileBitmap.idl \
+	InterpolationMode.idl \
+	XBitmapPalette.idl \
+	XBufferController.idl \
+	XCachedPrimitive.idl \
+	XGraphicDevice.idl \
+	XCanvas.idl \
+	XCustomSprite.idl \
+	XCanvasFont.idl \
+	XHalfFloatBitmap.idl \
+	XIeeeDoubleBitmap.idl \
+	XIeeeFloatBitmap.idl \
+	XIntegerBitmap.idl \
+	CanvasFactory.idl
+
+# ------------------------------------------------------------------
+
+.INCLUDE :  target.mk
+.INCLUDE :  $(PRJ)$/util$/target.pmk
--- /dev/null	2004-08-25 23:04:59.000000000 +0530
+++ offapi/com/sun/star/rendering/PanoseArmStyle.idl	2005-02-28 13:41:29.000000000 +0530
@@ -0,0 +1,84 @@
+/*************************************************************************
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
+ *
+ *  Copyright: 2000 by Sun Microsystems, Inc.
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+#ifndef __com_sun_star_rendering_PanoseArmStyle_idl__
+#define __com_sun_star_rendering_PanoseArmStyle_idl__
+
+module com { module sun { module star { module rendering {
+
+constants PanoseArmStyle
+{
+	const byte ANYTHING=0;
+	const byte NO_FIT=1;
+	const byte STRAIGHT_HORIZONTAL=2;
+	const byte STRAIGHT_WEDGE=3;
+	const byte STRAIGHT_VERTICAL=4;
+	const byte STRAIGHT_SINGLE_SERIF=5;
+	const byte STRAIGHT_DOUBLE_SERIF=6;
+	const byte BENT_HORIZONTAL=7;
+	const byte BENT_WEDGE=8;
+	const byte BENT_VERTICAL=9;
+	const byte BENT_SINGLE_SERIF=10;
+	const byte BENT_DOUBLE_SERIF=11;
+};
+
+}; }; }; };
+
+#endif
--- /dev/null	2004-08-25 23:04:59.000000000 +0530
+++ offapi/com/sun/star/rendering/PanoseContrast.idl	2005-02-28 13:41:29.000000000 +0530
@@ -0,0 +1,82 @@
+/*************************************************************************
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
+ *
+ *  Copyright: 2000 by Sun Microsystems, Inc.
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+#ifndef __com_sun_star_rendering_PanoseContrast_idl__
+#define __com_sun_star_rendering_PanoseContrast_idl__
+
+module com { module sun { module star { module rendering {
+
+constants PanoseContrast
+{
+	const byte ANYTHING=0;
+	const byte NO_FIT=1;
+	const byte NONE=2;
+	const byte VERY_LOW=3;
+	const byte LOW=4;
+	const byte MEDIUM_LOW=5;
+	const byte MEDIUM=6;
+	const byte MEDIUM_HIGH=7;
+	const byte HIGH=8;
+	const byte VERY_HIGH=9;
+};
+
+}; }; }; };
+
+#endif
--- /dev/null	2004-08-25 23:04:59.000000000 +0530
+++ offapi/com/sun/star/rendering/PanoseFamilyTypes.idl	2005-02-28 13:41:29.000000000 +0530
@@ -0,0 +1,78 @@
+/*************************************************************************
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
+ *
+ *  Copyright: 2000 by Sun Microsystems, Inc.
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+#ifndef __com_sun_star_rendering_PanoseFamilyTypes_idl__
+#define __com_sun_star_rendering_PanoseFamilyTypes_idl__
+
+module com { module sun { module star { module rendering {
+
+constants PanoseFamilyTypes
+{
+	const byte ANYTHING=0;
+	const byte NO_FIT=1;
+	const byte TEXT_DISPLAY=2;
+	const byte SCRIPT=3;
+	const byte DECORATIVE=4;
+	const byte PICTORIAL=5;
+};
+
+}; }; }; };
+
+#endif
--- /dev/null	2004-08-25 23:04:59.000000000 +0530
+++ offapi/com/sun/star/rendering/Panose.idl	2005-02-28 13:41:29.000000000 +0530
@@ -0,0 +1,101 @@
+/*************************************************************************
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
+ *
+ *  Copyright: 2000 by Sun Microsystems, Inc.
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+#ifndef __com_sun_star_rendering_Panose_idl__
+#define __com_sun_star_rendering_Panose_idl__
+
+module com { module sun { module star { module rendering {
+
+struct Panose 
+{
+    /// <type>PanoseFamilyTypes</type>
+    byte	FamilyType; 
+
+    /// <type>PanoseSerifStyle</type>
+    byte	SerifStyle; 
+
+    /// <type>PanoseWeight</type>
+    byte	Weight; 
+
+    /// <type>PanoseProportion</type>
+    byte	Proportion; 
+
+    /// <type>PanoseContrast</type>
+    byte	Contrast; 
+
+    /// <type>PanoseStrokeVariation</type>
+    byte	StrokeVariation; 
+
+    /// <type>PanoseArmStyle</type>
+    byte	ArmStyle; 
+
+    /// <type>PanoseLetterForm</type>
+    byte	Letterform; 
+
+    /// <type>PanoseMidline</type>
+    byte	Midline; 
+
+    /// <type>PanoseXHeight</type>
+    byte	XHeight; 
+};
+
+}; }; }; };
+
+#endif
--- /dev/null	2004-08-25 23:04:59.000000000 +0530
+++ offapi/com/sun/star/rendering/PanoseLetterForm.idl	2005-02-28 13:41:29.000000000 +0530
@@ -0,0 +1,88 @@
+/*************************************************************************
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
+ *
+ *  Copyright: 2000 by Sun Microsystems, Inc.
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+#ifndef __com_sun_star_rendering_PanoseLetterForm_idl__
+#define __com_sun_star_rendering_PanoseLetterForm_idl__
+
+module com { module sun { module star { module rendering {
+
+constants PanoseLetterForm
+{
+	const byte ANYTHING=0;
+	const byte NO_FIT=1;
+	const byte NORMAL_CONTACT=2;
+	const byte NORMAL_WEIGHTED=3;
+	const byte NORMAL_BOXED=4;
+	const byte NORMAL_FLATTENED=5;
+	const byte NORMAL_ROUNDED=6;
+	const byte NORMAL_OFF_CENTER=7;
+	const byte NORMAL_SQUARE=8;
+	const byte OBLIQUE_CONTACT=9;
+	const byte OBLIQUE_WEIGHTED=10;
+	const byte OBLIQUE_BOXED=11;
+	const byte OBLIQUE_FLATTENED=12;
+	const byte OBLIQUE_ROUNDED=13;
+	const byte OBLIQUE_OFF_CENTER=14;
+	const byte OBLIQUE_SQUARE=15;
+};
+
+}; }; }; };
+
+#endif
--- /dev/null	2004-08-25 23:04:59.000000000 +0530
+++ offapi/com/sun/star/rendering/PanoseMidline.idl	2005-02-28 13:41:29.000000000 +0530
@@ -0,0 +1,86 @@
+/*************************************************************************
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
+ *
+ *  Copyright: 2000 by Sun Microsystems, Inc.
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+#ifndef __com_sun_star_rendering_PanoseMidline_idl__
+#define __com_sun_star_rendering_PanoseMidline_idl__
+
+module com { module sun { module star { module rendering {
+
+constants PanoseMidline
+{
+	const byte ANYTHING=0;
+	const byte NO_FIT=1;
+	const byte STANDARD_TRIMMED=2;
+	const byte STANDARD_POINTED=3;
+	const byte STANDARD_SERIFED=4;
+	const byte HIGH_TRIMMER=5;
+	const byte HIGH_POINTED=6;
+	const byte HIGH_SERIFED=7;
+	const byte CONSTANT_TRIMMED=8;
+	const byte CONSTANT_POINTED=9;
+	const byte CONSTANT_SERIFED=10;
+	const byte LOW_TRIMMED=11;
+	const byte LOW_POINTED=12;
+	const byte LOW_SERIFED=13;
+};
+
+}; }; }; };
+
+#endif
--- /dev/null	2004-08-25 23:04:59.000000000 +0530
+++ offapi/com/sun/star/rendering/PanoseProportion.idl	2005-02-28 13:41:29.000000000 +0530
@@ -0,0 +1,82 @@
+/*************************************************************************
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
+ *
+ *  Copyright: 2000 by Sun Microsystems, Inc.
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+#ifndef __com_sun_star_rendering_PanoseProportion_idl__
+#define __com_sun_star_rendering_PanoseProportion_idl__
+
+module com { module sun { module star { module rendering {
+
+constants PanoseProportion
+{
+	const byte ANYTHING=0;
+	const byte NO_FIT=1;
+	const byte OLD_SKOOL=2;
+	const byte MODERN=3;
+	const byte EVEN_WIDTH=4;
+	const byte EXPANDED=5;
+	const byte CONDENSED=6;
+	const byte VERY_EXPANDED=7;
+	const byte VERY_CONDENSED=8;
+	const byte MONO_SPACED=9;
+};
+
+}; }; }; };
+
+#endif
--- /dev/null	2004-08-25 23:04:59.000000000 +0530
+++ offapi/com/sun/star/rendering/PanoseSerifStyle.idl	2005-02-28 13:41:29.000000000 +0530
@@ -0,0 +1,88 @@
+/*************************************************************************
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
+ *
+ *  Copyright: 2000 by Sun Microsystems, Inc.
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+#ifndef __com_sun_star_rendering_PanoseSerifStyle_idl__
+#define __com_sun_star_rendering_PanoseSerifStyle_idl__
+
+module com { module sun { module star { module rendering {
+
+constants PanoseSerifStyle
+{
+	const byte ANYTHING=0;
+	const byte NO_FIT=1;
+	const byte COVE=2;
+	const byte OBTUSE_COVE=3;
+	const byte SQUARE_COVE=4;
+	const byte OBTUSE_SQUARE_COVE=5;
+	const byte SQUARE=6;
+	const byte THIN=7;
+	const byte BONE=8;
+	const byte EXAGGERATED=9;
+	const byte TRIANGLE=10;
+	const byte NORMAL_SANS=11;
+	const byte OBTUSE_SANS=12;
+	const byte PERP_SANS=13;
+	const byte FLARED=14;
+	const byte ROUNDED=15;
+};
+
+}; }; }; };
+
+#endif
--- /dev/null	2004-08-25 23:04:59.000000000 +0530
+++ offapi/com/sun/star/rendering/PanoseStrokeVariation.idl	2005-02-28 13:41:29.000000000 +0530
@@ -0,0 +1,81 @@
+/*************************************************************************
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
+ *
+ *  Copyright: 2000 by Sun Microsystems, Inc.
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+#ifndef __com_sun_star_rendering_PanoseStrokeVariation_idl__
+#define __com_sun_star_rendering_PanoseStrokeVariation_idl__
+
+module com { module sun { module star { module rendering {
+
+constants PanoseStrokeVariation
+{
+	const byte ANYTHING=0;
+	const byte NO_FIT=1;
+	const byte GRADUAL_DIAGONAL=2;
+	const byte GRADUAL_TRANSITIONAL=3;
+	const byte GRADUAL_VERTICAL=4;
+	const byte GRADUAL_HORIZONTAL=5;
+	const byte RAPID_VERTICAL=6;
+	const byte RAPID_HORIZONTAL=7;
+	const byte INSTANT_VERTICAL=8;
+};
+
+}; }; }; };
+
+#endif
--- /dev/null	2004-08-25 23:04:59.000000000 +0530
+++ offapi/com/sun/star/rendering/PanoseWeight.idl	2005-02-28 13:41:29.000000000 +0530
@@ -0,0 +1,84 @@
+/*************************************************************************
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
+ *
+ *  Copyright: 2000 by Sun Microsystems, Inc.
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+#ifndef __com_sun_star_rendering_PanoseWeight_idl__
+#define __com_sun_star_rendering_PanoseWeight_idl__
+
+module com { module sun { module star { module rendering {
+
+constants PanoseWeight
+{
+	const byte ANYTHING=0;
+	const byte NO_FIT=1;
+	const byte VERY_LIGHT=2;
+	const byte LIGHT=3;
+	const byte THIN=4;
+	const byte BOOK=5;
+	const byte MEDIUM=6;
+	const byte DEMI_BOLD=7;
+	const byte BOLD=8;
+	const byte HEAVY=9;
+	const byte BLACK=10;
+	const byte NORD=11;
+};
+
+}; }; }; };
+
+#endif
--- /dev/null	2004-08-25 23:04:59.000000000 +0530
+++ offapi/com/sun/star/rendering/PanoseXHeight.idl	2005-02-28 13:41:29.000000000 +0530
@@ -0,0 +1,80 @@
+/*************************************************************************
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
+ *
+ *  Copyright: 2000 by Sun Microsystems, Inc.
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+#ifndef __com_sun_star_rendering_PanoseXHeight_idl__
+#define __com_sun_star_rendering_PanoseXHeight_idl__
+
+module com { module sun { module star { module rendering {
+
+constants PanoseXHeight
+{
+	const byte ANYTHING=0;
+	const byte NO_FIT=1;
+	const byte CONSTANT_SMALL=2;
+	const byte CONSTANT_STANDARD=3;
+	const byte CONSTANT_LARGE=4;
+	const byte DUCKING_SMALL=5;
+	const byte DUCKING_STANDARD=6;
+	const byte DUCKING_LARGE=7;
+};
+
+}; }; }; };
+
+#endif
--- /dev/null	2004-08-25 23:04:59.000000000 +0530
+++ offapi/com/sun/star/rendering/PathCapType.idl	2005-02-28 13:41:29.000000000 +0530
@@ -0,0 +1,93 @@
+/*************************************************************************
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
+ *
+ *  Copyright: 2000 by Sun Microsystems, Inc.
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+#ifndef __com_sun_star_rendering_PathCapType_idl__
+#define __com_sun_star_rendering_PathCapType_idl__
+
+module com { module sun { module star { module rendering {
+
+/** These constants determine which shape to use for start or end of a
+    stroked path.<p>
+
+    The start and end of stroked paths can have one out of several
+    different shapes (which are, of course, only visible for strokes
+    wider than one device pixel).<p>
+
+    @since #110496#
+ */
+constants PathCapType
+{
+    /// End the path at its start or end point, without any cap.
+	const byte BUTT=0;
+
+	//-------------------------------------------------------------------------
+
+    /// Extend the path with a half circle cap, diameter is the line width.
+    const byte ROUND=1;
+
+	//-------------------------------------------------------------------------
+
+    /// Extend the path with a rectangular cap, half the line width long.
+    const byte SQUARE=2;
+};
+
+}; }; }; }; 
+
+#endif
--- /dev/null	2004-08-25 23:04:59.000000000 +0530
+++ offapi/com/sun/star/rendering/PathJoinType.idl	2005-02-28 13:41:29.000000000 +0530
@@ -0,0 +1,107 @@
+/*************************************************************************
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
+ *
+ *  Copyright: 2000 by Sun Microsystems, Inc.
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+#ifndef __com_sun_star_rendering_PathJoinType_idl__
+#define __com_sun_star_rendering_PathJoinType_idl__
+
+module com { module sun { module star { module rendering {
+
+/** Determines which shape to use when joining path segments.<p>
+
+	The joins between different paths segments can be formed out of
+	several different shapes (which are of course only visible for
+	strokes wider than one device pixel).<p>
+
+    @since #110496#
+ */
+constants PathJoinType
+{
+    /** Do not join the path segments at all.<p>
+
+    	This join type might lead, depending on the angle between the
+    	segments, to visible cracks at the meeting points.<p>
+     */
+    const byte NONE=0;
+
+	//-------------------------------------------------------------------------
+
+    /** Join the path segment by extending the outer border until they
+        intersect.
+     */
+	const byte MITER=1;
+
+	//-------------------------------------------------------------------------
+
+    /** Join the path segment with a pie-like patch, such that the
+        outer line of the meeting point is round.
+     */
+    const byte ROUND=2;
+
+	//-------------------------------------------------------------------------
+
+    /** Join the path segment by connecting the outer ends of the
+        abutting segments with a straight line.
+     */
+    const byte BEVEL=3;
+};
+
+}; }; }; };
+
+#endif
--- /dev/null	2004-08-25 23:04:59.000000000 +0530
+++ offapi/com/sun/star/rendering/RenderingIntent.idl	2005-02-28 13:41:29.000000000 +0530
@@ -0,0 +1,116 @@
+/*************************************************************************
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
+ *
+ *  Copyright: 2000 by Sun Microsystems, Inc.
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+#ifndef __com_sun_star_rendering_RenderingIntent_idl__
+#define __com_sun_star_rendering_RenderingIntent_idl__
+
+module com { module sun { module star { module rendering {
+
+/* TODO: There's still a lot open here! */
+
+constants RenderingIntent
+{
+    /** Also known as the image intent, this rendering intent
+        aims to preserve the visual relationship between
+        colors in a way that is perceived as natural to the
+        human eye, although the color values themselves may
+        change. This intent is most suitable for photographic
+        images.  
+    */
+    const byte PERCEPTUAL=0;
+
+	//-------------------------------------------------------------------------
+
+    /** The rendering intent for business graphics that
+        maintains vivid color at the expense of accurate
+        color. It scales the source gamut to the destination
+        gamut but preserves relative saturation instead of
+        hue, so when scaling to a smaller gamut, hues may
+        shift. This rendering intent is primarily designed for
+        business graphics, where bright saturated colors are
+        more important than the exact relationship between
+        colors (such as in a photographic image). 
+    */
+    const byte SATURATION=1;
+    
+    /** The rendering intent almost identical to Absolute
+        Colorimetric except for the following difference:
+        Relative Colorimetric compares the white point
+        (extreme highlight) of the source color space to that
+        of the destination color space and shifts all colors
+        accordingly. 
+    */
+    const byte RELATIVE_COLORIMETRIC=2;
+    
+    /** The rendering intent that leaves colors that fall
+        inside the destination gamut unchanged. Out of gamut
+        colors are clipped. No scaling of colors to
+        destination white point is performed. This intent aims
+        to maintain color accuracy at the expense of
+        preserving relationships between colors, and is useful
+        for seeing how output will look on a non-neutral
+        substrate. 
+    */
+    const byte ABSOLUTE_COLORIMETRIC=3;
+};
+
+}; }; }; };
+
+#endif
--- /dev/null	2004-08-25 23:04:59.000000000 +0530
+++ offapi/com/sun/star/rendering/RenderState.idl	2005-02-28 13:41:29.000000000 +0530
@@ -0,0 +1,141 @@
+/*************************************************************************
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
+ *
+ *  Copyright: 2000 by Sun Microsystems, Inc.
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+#ifndef __com_sun_star_rendering_RenderState_idl__
+#define __com_sun_star_rendering_RenderState_idl__
+
+#ifndef __com_sun_star_geometry_AffineMatrix2D_idl__
+#include <com/sun/star/geometry/AffineMatrix2D.idl>
+#endif
+#ifndef __com_sun_star_rendering_XColorSpace_idl__
+#include <com/sun/star/rendering/XColorSpace.idl>
+#endif
+
+module com { module sun { module star { module rendering {
+
+interface XPolyPolygon2D;
+
+/** This structure contains information passed to each
+    <type>XCanvas</type> render operation.<p>
+
+	This structure contains information considered as the render
+	state, i.e. the common setup required to render each individual
+	<type>XCanvas</type> primitive.<p>
+
+    @since #110496#
+ */
+struct RenderState
+{
+	/** The affine transform associated with this render
+        operation.<p>
+
+        This is used to transform coordinates of canvas primitives
+        from user space to view space (from which they are
+        subsequently transformed to device space by the view
+        transform).<p>
+	 */
+    ::com::sun::star::geometry::AffineMatrix2D	AffineTransform;
+
+	//-------------------------------------------------------------------------
+
+	/** The clipping area associated with this render operation.<p>
+
+    	This clipping is interpreted in the user coordinate system,
+    	i.e. subject to the render state transform followed by the
+    	view transform before mapped to device coordinate space.<p>
+
+        Specifying an empty interface denotes no clipping,
+        i.e. everything rendered to the canvas will be visible
+        (subject to device-dependent constraints, of
+        course). Specifying an empty XPolyPolygon2D, i.e. a
+        poly-polygon containing zero polygons, denotes the NULL
+        clip. That means, nothing rendered to the canvas will be
+        visible.<p>
+	 */
+	XPolyPolygon2D										Clip;
+
+	//-------------------------------------------------------------------------
+
+	/** The device color associated with this render operation.<p>
+
+    	Note that this need not be RGB here, but depends on the active
+    	device color space.<p>
+
+        @see XGraphicDevice
+        @see XColorSpace
+	 */
+	sequence<ColorComponent>							DeviceColor;
+
+	//-------------------------------------------------------------------------
+
+	/** The composition mode associated with this render
+        operation.<p>
+
+        The composite mode determines in which way the primitive and
+        possibly existing background is combined. The permissible
+        values must be one out of the <type>CompositeOperation</type>
+        constants.<p>
+	 */
+	byte												CompositeOperation;
+};
+
+}; }; }; };
+
+#endif
--- /dev/null	2004-08-25 23:04:59.000000000 +0530
+++ offapi/com/sun/star/rendering/RepaintResult.idl	2005-02-28 13:41:29.000000000 +0530
@@ -0,0 +1,92 @@
+/*************************************************************************
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
+ *
+ *  Copyright: 2000 by Sun Microsystems, Inc.
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+#ifndef __com_sun_star_rendering_RepaintResult_idl__
+#define __com_sun_star_rendering_RepaintResult_idl__
+
+module com { module sun { module star { module rendering {
+
+/** These constants specify the result of the
+   <type>XCachedPrimitive</type> render operation.<p>
+
+   @since #110496#
+ */
+constants RepaintResult
+{
+    /** Repaint succeeded, primitive has been exactly reproduced.
+     */
+	const byte REDRAWN=1;
+
+	//-------------------------------------------------------------------------
+
+	/** Repaint succeeded, primitive has been reproduced in preview quality.
+	 */
+	const byte DRAFTED=2;
+
+	//-------------------------------------------------------------------------
+
+	/**	Repaint failed altogether.
+	 */
+	const byte FAILED=3;
+};
+
+}; }; }; };
+
+#endif
--- /dev/null	2004-08-25 23:04:59.000000000 +0530
+++ offapi/com/sun/star/rendering/StringContext.idl	2005-02-28 13:41:29.000000000 +0530
@@ -0,0 +1,102 @@
+/*************************************************************************
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
+ *
+ *  Copyright: 2000 by Sun Microsystems, Inc.
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+#ifndef __com_sun_star_rendering_StringContext_idl__
+#define __com_sun_star_rendering_StringContext_idl__
+
+module com { module sun { module star { module rendering {
+
+/** Collection of string-related arguments used on all canvas text
+    interfaces.<p>
+
+    A possibly much larger string than later rendered is necessary
+    here, because in several languages, glyph selection is context
+    dependent.<p>
+
+    @since #110496#
+ */
+struct StringContext
+{
+    /** The complete text, from which a subset is selected by the
+        parameters below.
+     */
+    string 	Text;
+
+	//-------------------------------------------------------------------------
+
+    /** Start position within the string.<p>
+
+    	The first character has index 0.<p>
+     */
+    long 	StartPosition;
+
+	//-------------------------------------------------------------------------
+
+    /** Length of the substring to actually use.<p>
+
+    	Must be within the range [0,INTMAX].<p>
+    */
+    long	Length;
+
+};
+
+}; }; }; };
+
+#endif
--- /dev/null	2004-08-25 23:04:59.000000000 +0530
+++ offapi/com/sun/star/rendering/StrokeAttributes.idl	2005-02-28 13:41:29.000000000 +0530
@@ -0,0 +1,176 @@
+/*************************************************************************
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
+ *
+ *  Copyright: 2000 by Sun Microsystems, Inc.
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+#ifndef __com_sun_star_rendering_StrokeAttributes_idl__
+#define __com_sun_star_rendering_StrokeAttributes_idl__
+
+#ifndef __com_sun_star_rendering_PathCapType_idl__
+#include <com/sun/star/rendering/PathCapType.idl>
+#endif
+#ifndef __com_sun_star_rendering_PathJoinType_idl__
+#include <com/sun/star/rendering/PathJoinType.idl>
+#endif
+
+
+module com { module sun { module star { module rendering {
+
+/** This structure contains all attributes required for path stroking.<p>
+
+	Path stroking is the process of drawing a polygon with a thick
+	pen. The various attributes contained in this structure can be
+	used to customize that process.<p>
+
+    @single #110496#
+ */
+struct StrokeAttributes
+{
+	/** Defines the width of the stroke, measured in user
+	    coordinate space.
+	 */	
+	double 				StrokeWidth;
+
+	//-------------------------------------------------------------------------
+
+	/** Determines the maximal length of the diagonal in mitered
+		corners.<p>
+
+        This attribute is only used when
+        <member>StrokeAttributes::JoinType</member> is set to
+        <member>PathJoinType::MITER</member>. Should the length of a
+        corner's diagonal exceed this limit, a bevelled join is used
+        instead.<p>
+	 */
+	double				MiterLimit;
+
+	//-------------------------------------------------------------------------
+
+	/** Array of ink on and off lengths, measured in user coordinate
+		space.<p>
+
+        The first element specifies the length of the first 'on'
+        segment of the dashing, the second element the length of the
+        first 'off' segment, and so forth. Give zero elements here for
+        solid strokes. This array always have an even number of
+        elements, with zero, as usual, counting as even here.<p>
+	 */
+	sequence<double>	DashArray;
+
+	//-------------------------------------------------------------------------
+
+	/** Array of line widths and spacings for multiple-line
+		strokes.<p>
+
+        The entries here are relative to the
+        <member>StrokeAttributes::StrokeWidth</member> attribute
+        above, i.e. the total width of all lines and spacings will
+        always equal
+        <member>StrokeAttributes::StrokeWidth</member>. The first
+        element specifies the width of the rightmost line, when
+        travelling from the start point of the path to the end
+        point. The second element specifies the space between the
+        first line and the second line, and so forth. If the array
+        ends with a spacing, this spacing is included in the total
+        width of the multiple-line stroke. That is, the stroke becomes
+        asymmetric.<p>
+	 */	
+	sequence<double>	LineArray;
+
+	//-------------------------------------------------------------------------
+
+	/** The start shape of the stroke.<p>
+
+    	The start point is the first point of every polygon of the
+    	path poly-polygon.<p>
+
+        @see <type>PathCapType</type>
+	 */
+	byte				StartCapType;
+
+	//-------------------------------------------------------------------------
+
+	/** The end shape of the stroke.<p>
+
+		The end point is the last point of every polygon of the path
+		poly-polygon.<p>
+
+        @see <type>PathCapType</type>
+	 */
+	byte				EndCapType;
+
+	//-------------------------------------------------------------------------
+
+	/** The join shape of the stroke.<p>
+
+		After every sub-stroke, i.e. after every line or curve segment
+		within a single path polygon, a shape of this type is inserted
+		into the stroke to glue the segments together. Please note
+		that distinct polygons within the path poly-polygon are not
+		connected, and therefore also not joined via the shape
+		specified here.<p>
+
+        @see <type>PathJoinType</type>
+	 */
+	byte				JoinType;
+
+};
+
+}; }; }; };
+
+#endif
--- /dev/null	2004-08-25 23:04:59.000000000 +0530
+++ offapi/com/sun/star/rendering/TextDirection.idl	2005-02-28 13:41:29.000000000 +0530
@@ -0,0 +1,85 @@
+/*************************************************************************
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
+ *
+ *  Copyright: 2000 by Sun Microsystems, Inc.
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+#ifndef __com_sun_star_rendering_TextDirection_idl__
+#define __com_sun_star_rendering_TextDirection_idl__
+
+module com { module sun { module star { module rendering {
+
+/** Specifies main text direction in a text portion.<p>
+
+	This also changes the interpretation of the start point.<p>
+
+    @since #110496#
+ */
+constants TextDirection
+{
+    /// Reference point is left, main direction is from left to right
+    const byte WEAK_LEFT_TO_RIGHT=0;
+    const byte STRONG_LEFT_TO_RIGHT=2;
+
+    /// Reference point is right, main direction is from right to left
+    const byte WEAK_RIGHT_TO_LEFT=1;
+    const byte STRONG_RIGHT_TO_LEFT=3;
+};
+
+}; }; }; };
+
+#endif
--- /dev/null	2004-08-25 23:04:59.000000000 +0530
+++ offapi/com/sun/star/rendering/TextHit.idl	2005-02-28 13:41:29.000000000 +0530
@@ -0,0 +1,104 @@
+/*************************************************************************
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
+ *
+ *  Copyright: 2000 by Sun Microsystems, Inc.
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+#ifndef __com_sun_star_rendering_TextHit_idl__
+#define __com_sun_star_rendering_TextHit_idl__
+
+module com { module sun { module star { module rendering {
+
+/** This structure contains hit information for <type>XTextLayout</type>.<p>
+
+	This structure is used from the <type>XTextLayout</type> interface
+	to transport information regarding hit tests.<p>
+
+    @since #110496#
+ */
+struct TextHit 
+{
+    /** This contains the entry index.<p>
+
+    	The entry index is the index of the insertion point in the
+    	character sequence. The insertion point denotes positions
+    	<em>between</em> the actual characters in the string, and can
+    	thus have values ranging from 0 up to the number of characters
+    	in the string. Hereby, an index of 0 denotes an insertion
+    	position <em>before</em> the first character, and an index
+    	containing the number of characters denotes an insertion
+    	<em>behind</em> the last character.<p>
+     */
+    long 		EntryIndex;
+
+    /** This member denotes whether the hit was on the leading
+        edge.<p>
+
+        Each character is divided in two halves, the leading and the
+        trailing part. The leading edge is the part of the glyph on
+        encounteres first when reading text of the corresponding
+        language (i.e. the leading edge of an Arabic glyph is the
+        right half of it, whereas it is the left half of a Latin
+        character). If the hit was on the leading edge, this member is
+        set to <TRUE>.
+     */
+    boolean		IsLeadingEdge;
+};
+
+}; }; }; };
+
+#endif
--- /dev/null	2004-08-25 23:04:59.000000000 +0530
+++ offapi/com/sun/star/rendering/Texture.idl	2005-02-28 13:41:29.000000000 +0530
@@ -0,0 +1,190 @@
+/*************************************************************************
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
+ *
+ *  Copyright: 2000 by Sun Microsystems, Inc.
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+#ifndef __com_sun_star_rendering_Texture_idl__
+#define __com_sun_star_rendering_Texture_idl__
+
+#ifndef __com_sun_star_geometry_AffineMatrix2D_idl__
+#include <com/sun/star/geometry/AffineMatrix2D.idl>
+#endif
+#ifndef __com_sun_star_rendering_StrokeAttributes_idl__
+#include <com/sun/star/rendering/StrokeAttributes.idl>
+#endif
+
+module com { module sun { module star { module rendering {
+
+interface XBitmap;
+interface XParametricPolyPolygon2D;
+
+/** Contains all information needed to define a texture.<p>
+
+	This structure contains all information necessary to define a
+	texture. A texture describes the filled area of polygonal shapes,
+	providing its own transformation matrix, repeat mode, and
+	transparency.<p>
+
+    To achieve uniformity, if this texture has a bitmap set, it is
+    scaled in such a way that it will cover the same [0,1]x[0,1] box
+    as the hatch and the gradient. The transformation member can then
+    be used to scale the complete texture as it fits suit.<p>
+
+	@since #110496#
+ */
+struct Texture
+{
+	/** Texture transformation from texture to primitive space.<p>
+
+		This member allows arbitrary transformations of the texture,
+		relative to the textured primitive. Thus, the total
+		transformation from the [0,1]x[0,1] texture space to the
+		device coordinate space is the concatenation of texture,
+		render state, and view state transformation (with only render
+		state and view state transformation being applied to the
+		textured primitive).<p>
+     */
+	::com::sun::star::geometry::AffineMatrix2D	AffineTransform;
+
+	//-------------------------------------------------------------------------
+
+	/** Overall transparency of the texturing.<p>
+
+    	The valid range for this value is [0,1], where 0 denotes
+    	complete transparency, and 1 denotes fully opaque.<p>
+     */
+	double					                    		Alpha;
+
+	//-------------------------------------------------------------------------
+
+	/** Specifies the number of parameterized polygons used for the texture.<p>
+
+    	This member specifies the number of polygons the parametric
+    	polygon interface is queried. The continuous range [0,1] of
+    	the XParametricPolyPolygon::getOutline() method is divided up
+    	into numberOfHatchPolygons equal parts, and for everyone of
+    	these parts, the start of the interval is plugged into the
+    	getOutline method. For example, if numberOfHatchPolygons is 2,
+    	then getOutline is called twice, once with 0.0 and once with
+    	0.5. Use this parameter to control the density of the
+    	hatching.<p>
+     */
+	long					                    		NumberOfHatchPolygons;
+
+	//-------------------------------------------------------------------------
+
+	/** Texture bitmap.<p>
+
+    	This member can be used together with gradient and hatching.<p>
+
+        The bitmap is scaled to a one-by-one rectangle, to cover the
+        same area as both the gradient and the hatching.<p>
+    */
+	XBitmap					                    		Bitmap;
+
+	//-------------------------------------------------------------------------
+
+	/** Texture gradient.<p>
+
+    	This member can be used together with bitmap and hatching. The
+    	parametric polygons color value is used to fill the returned
+    	polygonal outlines.<p>
+     */
+	XParametricPolyPolygon2D                    		Gradient;
+
+	//-------------------------------------------------------------------------
+
+	/** Texture hatching.<p>
+
+		This member can be used together with bitmap and gradient. The
+		parametric polygons color value is used to stroke the returned
+		polygonal outlines.<p>
+     */
+	XParametricPolyPolygon2D                    		Hatching;
+
+	//-------------------------------------------------------------------------
+
+	/** Specifies the stroke attributes used for hatching.<p>
+
+		Use 0.0 as the strokeWidth here to indicate hair lines.<p>
+     */
+	StrokeAttributes		                    		HatchAttributes;
+
+	//-------------------------------------------------------------------------
+
+	/** Repeat mode of the texture, x direction.<p>
+
+		The repeat mode is separated into x and y direction, this is
+		the x direction part. Permissible values are from the 
+		<type>TexturingMode</type> constants.<p>
+    */
+	byte				                				RepeatModeX;
+
+	/** Repeat mode of the texture, y direction.<p>
+
+		The repeat mode is separated into x and y direction, this is
+		the y direction part. Permissible values are from the 
+		<type>TexturingMode</type> constants.<p>
+    */
+	byte				                				RepeatModeY;
+
+};
+
+}; }; }; };
+
+#endif
--- /dev/null	2004-08-25 23:04:59.000000000 +0530
+++ offapi/com/sun/star/rendering/TexturingMode.idl	2005-02-28 13:41:29.000000000 +0530
@@ -0,0 +1,93 @@
+/*************************************************************************
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
+ *
+ *  Copyright: 2000 by Sun Microsystems, Inc.
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+#ifndef __com_sun_star_rendering_Texture_idl__
+#define __com_sun_star_rendering_Texture_idl__
+
+module com { module sun { module star { module rendering {
+
+/** Enumeration of possible values to spread a texture across a
+    primitive.
+
+    @since #110496#
+ */
+constants TexturingMode
+{
+	/** Clamp texture coordinate.<p>
+
+		This value clamps the texture coordinate to the range
+		[0,1]. This results in only one instance of the texture
+		generated per textured primitive.<p>
+  	 */
+	const byte CLAMP=0;
+
+	//-------------------------------------------------------------------------
+
+	/** Repeat the texture.<p>
+
+    	This value repeats the texture over the textured primitive,
+    	for the given texture coordinate.<p>
+	 */
+	const byte REPEAT=1;
+};
+
+}; }; }; };
+
+#endif
--- /dev/null	2004-08-25 23:04:59.000000000 +0530
+++ offapi/com/sun/star/rendering/ViewState.idl	2005-02-28 13:41:29.000000000 +0530
@@ -0,0 +1,110 @@
+/*************************************************************************
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
+ *
+ *  Copyright: 2000 by Sun Microsystems, Inc.
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+#ifndef __com_sun_star_rendering_ViewState_idl__
+#define __com_sun_star_rendering_ViewState_idl__
+
+#ifndef __com_sun_star_geometry_AffineMatrix2D_idl__
+#include <com/sun/star/geometry/AffineMatrix2D.idl>
+#endif
+
+module com { module sun { module star { module rendering {
+
+interface XPolyPolygon2D;
+
+/** This structure contains information considered the view state.<p>
+
+	This structure contains information considered the view state,
+    i.e. the invariant setup used when painting a whole view of
+    something.<p>
+
+    @since #110496#
+ */
+struct ViewState
+{
+	/** The affine transform associated with the view.<p>
+
+		This member is used to transform coordinates of draw
+		operations from user space to screen space.<p>
+	 */	
+	::com::sun::star::geometry::AffineMatrix2D	AffineTransform;
+
+	//-------------------------------------------------------------------------
+
+	/** The clipping area associated with the view.<p>
+
+    	This clipping is interpreted in the view coordinate systems,
+    	i.e. subject to the view transform before mapping to the
+    	device coordinate space.<p>
+
+        Specifying an empty interface denotes no clipping,
+        i.e. everything rendered to the canvas will be visible
+        (subject to device-dependent constraints, of
+        course). Specifying an empty XPolyPolygon2D, i.e. a
+        poly-polygon containing zero polygons, denotes the NULL
+        clip. That means, nothing rendered to the canvas will be
+        visible.<p>
+	 */
+	XPolyPolygon2D										Clip;
+};
+
+}; }; }; };
+
+#endif
--- /dev/null	2004-08-25 23:04:59.000000000 +0530
+++ offapi/com/sun/star/rendering/VolatileContentDestroyedException.idl	2005-02-28 13:41:29.000000000 +0530
@@ -0,0 +1,83 @@
+/*************************************************************************
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
+ *
+ *  Copyright: 2000 by Sun Microsystems, Inc.
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+#ifndef __com_sun_star_rendering_VolatileContentDestroyedException_idl__ 
+#define __com_sun_star_rendering_VolatileContentDestroyedException_idl__
+ 
+#ifndef __com_sun_star_uno_Exception_idl__ 
+#include <com/sun/star/uno/Exception.idl> 
+#endif 
+ 
+module com { module sun { module star { module rendering {  
+ 
+	/** This exception indicates an invalid volatile bitmap content.<p>
+
+    	When accessing or rendering XVolatileBitmap data, that has
+    	been invalidated by the system, this exception will be thrown.<p>
+
+        @since #110496#
+    */
+    exception VolatileContentDestroyedException : ::com::sun::star::uno::Exception
+    {
+    }; 
+
+}; }; }; };
+ 
+#endif
--- /dev/null	2004-08-25 23:04:59.000000000 +0530
+++ offapi/com/sun/star/rendering/XAnimatedSprite.idl	2005-02-28 13:41:29.000000000 +0530
@@ -0,0 +1,230 @@
+/*************************************************************************
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
+ *
+ *  Copyright: 2000 by Sun Microsystems, Inc.
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+#ifndef __com_sun_star_rendering_XAnimatedSprite_idl__
+#define __com_sun_star_rendering_XAnimatedSprite_idl__
+
+#ifndef __com_sun_star_uno_XInterface_idl__ 
+#include <com/sun/star/uno/XInterface.idl> 
+#endif 
+#ifndef __com_sun_star_lang_IllegalArgumentException_idl__
+#include <com/sun/star/lang/IllegalArgumentException.idl>
+#endif 
+#ifndef __com_sun_star_geometry_RealPoint2D_idl__
+#include <com/sun/star/geometry/RealPoint2D.idl>
+#endif
+#ifndef __com_sun_star_rendering_ViewState_idl__
+#include <com/sun/star/rendering/ViewState.idl>
+#endif
+#ifndef __com_sun_star_rendering_RenderState_idl__
+#include <com/sun/star/rendering/RenderState.idl>
+#endif
+#ifndef __com_sun_star_rendering_XSprite_idl__
+#include <com/sun/star/rendering/XSprite.idl>
+#endif
+
+
+module com { module sun { module star { module rendering {
+
+/** This interface can be used to control an animated sprite object.<p>
+
+	This interface can be used to control an animated sprite object on
+	an XSpriteCanvas. Sprites are moving, animated objects.<p>
+
+    @since #110496#
+ */
+interface XAnimatedSprite : XSprite
+{
+	/**	Start animation sequence of this sprite.<p>
+
+    	The speed of the animation is given in cycles per second
+    	(where a cycle is defined as one full animation run, i.e. the
+    	full [0,1] range of the <member>XAnimation::render</member>'s
+    	t parameter, or a full sequence of sprite bitmaps drawn). Once
+    	an animation is running, the associated
+    	<type>XSpriteCanvas</type> handles screen updates
+    	automatically. That means, changes to position or alpha are
+    	reflected on screen automatically. Please note further that
+    	sprite visibility and animation are unrelated, i.e. a hidden
+    	sprite can have a running animation, which then displays in
+    	the middle of the animation sequence, when a show() is called
+    	later on.<p>
+
+        @param nSpeed
+        The speed of the animation in cycles per second (where a cycle
+        is defined as one full animation run, i.e. the full [0,1]
+        range of the <member>XAnimation::render</member>'s t
+        parameter, or a full sequence of sprite bitmaps drawn).
+	 */
+	void startAnimation( [in] double nSpeed );
+
+	//-------------------------------------------------------------------------
+
+	/** Stop the animation sequence.<p>
+        
+    	A subsequent <member>XAnimatedSprite::startAnimation</member>
+    	will commence the sequence at the point where it was stopped
+    	with here. Once an animation is stopped, the associated
+    	<type>XSpriteCanvas</type> does not update changed sprites
+    	anymore.<p>
+	*/
+	void stopAnimation();
+
+	//-------------------------------------------------------------------------
+
+	/** Reset the animation sequence to start with the first frame.<p>
+
+    	If the animation is currently running, the next frame that is
+    	drawn after this method has finished, will be the first
+    	one. Please note that if an animation is not started, the
+    	associated <type>XSpriteCanvas</type> does not update changed
+    	sprites automatically.<p>
+	 */
+	void resetAnimation();
+
+	//-------------------------------------------------------------------------
+    
+    /** Issue an additional render call to this sprite's
+		animation.<p>
+
+        This method has no effect when called for a bitmap-sequence
+        sprite. Please note that if an animation is not started, the
+        associated <type>XSpriteCanvas</type> does not update changed
+        sprites automatically, but has to be told to do so via
+        <member>XSpriteCanvas::updateScreen()</member>.<p>
+     */
+    void updateAnimation();
+
+	//-------------------------------------------------------------------------
+
+    /** Changes the view state in place for this sprite's
+		animation.<p>
+
+        The state given here is used when calling the
+        <member>XAnimation::render()</member> method, or when drawing
+        the sprite's bitmaps, respectively. There's no need to call
+        <member>XSpriteCanvas::updateAnimation()</member> after this
+        method, as it automatically rerenders, if necessary. Please
+        note that if an animation is not started, the associated
+        <type>XSpriteCanvas</type> does not update changed sprites
+        automatically, but has to be told to do so via
+        <member>XSpriteCanvas::updateScreen()</member>.<p>
+
+        @param aViewState
+        The state given here is used when calling the
+        <member>XAnimation::render()</member> method, or when drawing
+        the sprite's bitmaps, respectively.
+
+        @throws com::sun::star::lang::IllegalArgumentException
+        if the view transformation matrix is singular.
+    */
+    void setViewState( [in] ViewState aViewState )
+        raises (com::sun::star::lang::IllegalArgumentException);
+
+	//-------------------------------------------------------------------------
+
+    /** Changes all of the sprite's attributes at one atomic
+        instance.<p>
+
+        This is useful at times where one does not want multiple
+        redraws for every state change.<p>
+        
+		Please note that if an animation is not started, the
+		associated <type>XSpriteCanvas</type> does not update changed
+		sprites automatically, but has to be told to do so via
+		<member>XSpriteCanvas::updateScreen()</member>.<p>
+
+        @param aNewPos
+        New left,top output position of the sprite. This position gets
+        transformed by the view and render state.
+
+        @param aViewState
+        New view state of the sprite, and part of the transformation
+        that is applied to aNewPos. The view transformation matrix
+        must not be singular.
+        
+        @param aRenderState
+        New render state of the sprite, and part of the transformation
+        that is applied to aNewPos. The render transformation matrix
+        must not be singular.
+        
+        @param nAlpha
+        New alpha value of the sprite. This value must be within the
+        [0,1] range.
+
+        @param bUpdateAnimation
+        Whether this method should implicitely call
+        <member>XSpriteCanvas::updateAnimation</member or not.
+
+        @throws com::sun::star::lang::IllegalArgumentException
+        if one of the passed parameters does not lie in the specified,
+        permissible range.
+     */
+    void setAll( [in] ::com::sun::star::geometry::RealPoint2D	aNewPos, 
+                 [in] ViewState 										aViewState, 
+                 [in] RenderState 										aRenderState,
+                 [in] double 											nAlpha,
+                 [in] boolean											bUpdateAnimation )
+        raises (com::sun::star::lang::IllegalArgumentException); 
+};
+
+}; }; }; };
+
+#endif
--- /dev/null	2004-08-25 23:04:59.000000000 +0530
+++ offapi/com/sun/star/rendering/XAnimation.idl	2005-02-28 13:41:29.000000000 +0530
@@ -0,0 +1,157 @@
+/*************************************************************************
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
+ *
+ *  Copyright: 2000 by Sun Microsystems, Inc.
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+#ifndef __com_sun_star_rendering_XAnimation_idl__
+#define __com_sun_star_rendering_XAnimation_idl__
+
+#ifndef __com_sun_star_uno_XInterface_idl__ 
+#include <com/sun/star/uno/XInterface.idl> 
+#endif 
+#ifndef __com_sun_star_lang_IllegalArgumentException_idl__
+#include <com/sun/star/lang/IllegalArgumentException.idl>
+#endif 
+#ifndef __com_sun_star_rendering_ViewState_idl__
+#include <com/sun/star/rendering/ViewState.idl>
+#endif
+#ifndef __com_sun_star_rendering_AnimationAttributes_idl__
+#include <com/sun/star/rendering/AnimationAttributes.idl>
+#endif
+#ifndef __com_sun_star_rendering_XCanvas_idl__
+#include <com/sun/star/rendering/XCanvas.idl>
+#endif
+
+
+module com { module sun { module star { module rendering {
+
+/* TODO: Have a property set here, to easily extend attributes? Think
+   that's advisable, because animations change the most. Implement
+   that with multiple inheritance interface types, please, not with
+   service description.
+*/
+
+/** This interface defines an animation sequence.<p>
+
+    This interface must be implemented by every animation object. It
+    is used by the <type>XCanvas</type> interface to render generic
+    animations.<p>
+
+    @since #110496#
+ */
+interface XAnimation : ::com::sun::star::uno::XInterface
+{
+    /** Render the animation content at time t into the specified
+        canvas.<p>
+
+        Note that it is perfectly legal to e.g. map t in a nonlinear
+        fashion to internal frames, for example to achieve
+        acceleration or decceleration effects. It is required that the
+        render method has const semantics, i.e. when called with the
+        same parameter set, identical output must be generated. This
+        is because e.g. a Sprite might decide arbitrarily to render an
+        animation once and cache the result, or repaint it via
+        XAnimation::render everytime.<p> 
+
+        The rendered content, although, must be exactly the same for
+        identical viewState, canvas and t values. Or, for that
+        matters, must call the same canvas methods in the same order
+        with the same parameter sets, for identical viewState and t
+        values. Furthermore, when viewState has the identity
+        transformation set, rendered output must be contained in a
+        rectangle with upper left corner at (0,0) and width and height
+        given by the AnimationAttributes' untransformedSize
+        member. Any content exceeding this box might get clipped off.<p>
+
+        @param canvas
+        The target canvas to render this animation to.
+
+        @param viewState
+        The view state to be used when rendering this animation to the
+        target canvas. The view transformation matrix must not be
+        singular.
+
+    	@param t
+        Time instant for which animation content is requested. The
+        range must always be [0,1], where 0 denotes the very beginning, and
+        1 the end of the animation sequence.
+
+        @throws com::sun::star::lang::IllegalArgumentException
+        if one of the passed parameters does not lie in the specified,
+        permissible range.
+     */
+    void 					render( [in] XCanvas canvas, [in] ViewState viewState, [in] double t )
+        raises (com::sun::star::lang::IllegalArgumentException); 
+
+	//-------------------------------------------------------------------------
+
+    /** Request the attribute information for this animation.<p>
+
+    	This method returns the <type>AnimationAttributes</type>
+    	structure, which defines more closely how to play this
+    	animation.<p>
+
+        @returns the requested <type>AnimationAttributes</type>
+        structure.
+     */
+    AnimationAttributes		getAnimationAttributes();
+};
+
+}; }; }; };
+
+#endif
--- /dev/null	2004-08-25 23:04:59.000000000 +0530
+++ offapi/com/sun/star/rendering/XBezierPolyPolygon2D.idl	2005-02-28 13:41:29.000000000 +0530
@@ -0,0 +1,213 @@
+/*************************************************************************
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
+ *
+ *  Copyright: 2000 by Sun Microsystems, Inc.
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+#ifndef __com_sun_star_rendering_XBezierPolyPolygon2D_idl__
+#define __com_sun_star_rendering_XBezierPolyPolygon2D_idl__
+
+#ifndef __com_sun_star_uno_XInterface_idl__ 
+#include <com/sun/star/uno/XInterface.idl> 
+#endif 
+#ifndef __com_sun_star_lang_IndexOutOfBoundsException_idl__
+#include <com/sun/star/lang/IndexOutOfBoundsException.idl>
+#endif 
+#ifndef __com_sun_star_rendering_XPolyPolygon2D_idl__
+#include <com/sun/star/rendering/XPolyPolygon2D.idl>
+#endif
+#ifndef __com_sun_star_geometry_RealBezierSegment2D_idl__
+#include <com/sun/star/geometry/RealBezierSegment2D.idl>
+#endif
+
+module com { module sun { module star { module rendering {
+
+/** This is a specialized interface for a 2D poly-polygon containing
+ 	straight line and bezier segments.<p>
+
+	This poly-polygon can contain polygons consisting of a mixture of
+	cubic bezier curves and straight lines. As the straight line is a
+	special case of a cubic bezier curve (control points collinear
+	with the line through start and end point), this can be expressed
+	uniformly with a sequence of <type>RealBezierSegment2D</type>s.<p>
+
+    By convention, a <type>RealBezierSegment2D</type> is a straight
+    line segment, if all three contained points are strictly equal.<p>
+
+    @since #110496#
+ */
+interface XBezierPolyPolygon2D : XPolyPolygon2D
+{
+	/** Query subset of this poly-polygon.<p>
+
+    	Query subset of this poly-polygon, starting at the given
+    	polygon and the given point within that polygon, and
+    	containing the specified number of polygons and points in the
+    	last polygon.<p>
+
+        @param nPolygonIndex
+        The index of the polygon to start point retrieval with. This
+        index must be in the range [0,numPolygons-1].
+
+        @param nNumberOfPolygons
+        The number of polygons to extract. This value must not exceed
+        numPolygons-nPolygonIndex.
+
+        @param nPointIndex
+        The index of the first point in the first polygon to
+        extract. This value must not exceed the number of points in
+        this polygon minus one.
+
+        @param nNumberOfPoints
+        The number of points to extract from the last polygon. This
+        value must not exceed the number of points in this last
+        polygon minus one.
+
+        @returns the sequence of extracted points.
+
+        @throws com::sun::star::lang::IndexOutOfBoundsException
+        if one of the given values exceed the permissible range.
+	 */
+	sequence< sequence < ::com::sun::star::geometry::RealBezierSegment2D > > getPoints( [in] long nPolygonIndex, [in] long nNumberOfPolygons, [in] long nPointIndex, [in] long nNumberOfPoints )
+        raises (com::sun::star::lang::IndexOutOfBoundsException); 
+
+	//-------------------------------------------------------------------------
+
+	/** Set the specified subset of points to the poly-polygon.<p>
+
+    	The subset of poly-polygon points not included in this sequence
+    	remains unchanged. Use
+    	<member>XBezierPolyPolygon2D::getNumberOfPolygons()</member>
+    	or
+    	<member>XBezierPolyPolygon2D::getNumberOfPolygonPoints()</member>
+    	to append points or polygons, respectively.<p>
+
+        @param points
+        A sequence of points to set at the poly-polygon.
+
+        @param nPolygonIndex
+        The index of the polygon to start point insertion with. This
+        index must be in the range [0,numPolygons].
+
+        @param nPointIndex
+        The index of the point in the polygon specified by
+        nPolygonIndex, <em>before<em> which insertion will take place.
+        This value must not exceed the number of points in this
+        polygon.
+        
+        @throws com::sun::star::lang::IndexOutOfBoundsException
+        if one of the given values exceed the permissible range.
+	 */
+	void							 					setPoints( [in] sequence< sequence< ::com::sun::star::geometry::RealBezierSegment2D > > points, [in] long nPolygonIndex, [in] long nPointIndex )
+        raises (com::sun::star::lang::IndexOutOfBoundsException); 
+
+	//-------------------------------------------------------------------------
+
+	/** Get a single point from the poly-polygon.
+
+        @param nPolygonIndex
+        The index of the polygon where the point to be extract is
+        contained within. This index must be in the range
+        [0,numPolygons-1].
+
+        @param nPointIndex
+        The index of the point in the polygon specified by
+        nPolygonIndex, which is to be retrieved.  This value must not
+        exceed the number of points in this polygon minus one.
+
+        @returns the requested point.
+        
+        @throws com::sun::star::lang::IndexOutOfBoundsException
+        if one of the given values exceed the permissible range.
+        
+	 */
+	::com::sun::star::geometry::RealBezierSegment2D	getPoint( [in] long nPolygonIndex, [in] long nPointIndex )
+        raises (com::sun::star::lang::IndexOutOfBoundsException); 
+
+	//-------------------------------------------------------------------------
+
+	/** Set a single point on the poly-polygon.<p>
+
+    	The remaining points of the poly-polygon will not be changed by
+    	this method. Use
+    	<member>XBezierPolyPolygon2D::getNumberOfPolygons()</member>
+    	or
+    	<member>XBezierPolyPolygon2D::getNumberOfPolygonPoints()</member>
+    	to append points or polygons, respectively.<p>
+
+        @param point
+        The point to be set at the poly-polygon.
+
+        @param nPolygonIndex
+        The index of the polygon to insert the point in. This index
+        must be in the range [0,numPolygons].
+
+        @param nPointIndex
+        The index of the point in the polygon specified by
+        nPolygonIndex, which is to be set.  This value must not
+        exceed the number of points in this polygon.
+        
+        @throws com::sun::star::lang::IndexOutOfBoundsException
+        if one of the given values exceed the permissible range.
+	 */
+    void												setPoint( [in] ::com::sun::star::geometry::RealBezierSegment2D point, [in] long nPolygonIndex, [in] long nPointIndex )
+        raises (com::sun::star::lang::IndexOutOfBoundsException); 
+};
+
+}; }; }; };
+
+#endif
--- /dev/null	2004-08-25 23:04:59.000000000 +0530
+++ offapi/com/sun/star/rendering/XBitmapCanvas.idl	2005-02-28 13:41:29.000000000 +0530
@@ -0,0 +1,185 @@
+/*************************************************************************
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
+ *
+ *  Copyright: 2000 by Sun Microsystems, Inc.
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+#ifndef __com_sun_star_rendering_XBitmapCanvas_idl__
+#define __com_sun_star_rendering_XBitmapCanvas_idl__
+
+#ifndef __com_sun_star_uno_XInterface_idl__ 
+#include <com/sun/star/uno/XInterface.idl> 
+#endif 
+#ifndef __com_sun_star_lang_IllegalArgumentException_idl__
+#include <com/sun/star/lang/IllegalArgumentException.idl>
+#endif 
+#ifndef __com_sun_star_geometry_RealRectangle2D_idl__
+#include <com/sun/star/geometry/RealRectangle2D.idl>
+#endif
+#ifndef __com_sun_star_rendering_RenderState_idl__
+#include <com/sun/star/rendering/RenderState.idl>
+#endif
+#ifndef __com_sun_star_rendering_XBitmap_idl__
+#include <com/sun/star/rendering/XBitmap.idl>
+#endif
+#ifndef __com_sun_star_rendering_XCanvas_idl__
+#include <com/sun/star/rendering/XCanvas.idl>
+#endif
+#ifndef __com_sun_star_rendering_VolatileContentDestroyedException_idl__
+#include <com/sun/star/rendering/VolatileContentDestroyedException.idl>
+#endif
+
+
+module com { module sun { module star { module rendering {
+
+/** This is a specialization of the canvas interface for bitmapped
+    canvases.<p>
+
+    This interface is a specialization of the canvas interface for
+    bitmapped canvases, where additional methods for accessing and
+    moving of bitmap content are provided.<p>
+
+    @since #110496#
+ */
+interface XBitmapCanvas : XCanvas
+{
+	/** This method copies a rectangular area from a place of one
+		canvas to a place on another.<p>
+
+        This method copies a rectangular area from a place of one
+        canvas to a place on another. Source and destination areas are
+        permitted to overlap. If the source view or render state has a
+        clipping set, the regions clipped away from the source
+        rectangle are regarded fully transparent for the copy
+        operation. The device color for both source and destination
+        render state is ignored, the compositing mode only for the
+        source render state.<p>
+        
+        @param sourceCanvas
+        Canvas from which to copy the bitmap data. Can be identical to
+        the canvas this method is called on, but must be valid.
+
+        @param sourceRect
+        Rectangle from which to copy the bitmap data. This rectangle
+        is subject to both view and render transformation, before
+        being applied. Thus, on screen, it does not necessarily
+        resemble a rectangle any more. The rectangle must be
+        non-empty, see
+        <type>::com::sun::star::geometry::RealRectangle2D</type>
+        for details.
+
+        @param sourceViewState
+        The view state to apply to the source of this copy
+        operation. The view transformation must be non-singular.
+
+        @param sourceRenderState
+        The render state to apply to the source of this copy
+        operation. The render transformation must be non-singular, and
+        the compositing mode must be one of the
+        <type>CompositingOperation</type> values.
+
+        @param destRect
+        Rectangle into which to copy the bitmap data. This rectangle
+        is subject to both view and render transformation, before
+        being applied. Thus, on screen, it does not necessarily
+        resemble a rectangle any more. The rectangle must be
+        non-empty, see
+        <type>::com::sun::star::geometry::RealRectangle2D</type>
+        for details.
+
+        @param destViewState
+        The view state to apply to the destination of this copy
+        operation. The view transformation must be non-singular.
+
+        @param destRenderState
+
+        The render state to apply to the destination of this copy
+        operation. The render transformation must be non-singular, and
+        the compositing mode must be one of the
+        <type>CompositingOperation</type> values.
+
+        @throws com::sun::star::lang::IllegalArgumentException
+        if one of the parameters are not within the specified range.
+	 */	
+	void copyRect( [in] XBitmapCanvas sourceCanvas, 
+                   [in] ::com::sun::star::geometry::RealRectangle2D sourceRect, [in] ViewState sourceViewState, [in] RenderState sourceRenderState,
+                   [in] ::com::sun::star::geometry::RealRectangle2D destRect, [in] ViewState destViewState, [in] RenderState destRenderState )
+        raises (com::sun::star::lang::IllegalArgumentException,
+                VolatileContentDestroyedException);  
+
+};
+
+//=============================================================================
+
+// TODO: Multiple-inheritance interfaces
+
+/** This service provides the interfaces for a BitmapCanvas
+ */
+service BitmapCanvas
+{
+    /** Canvas interface, to issue rendering operations.
+     */
+    interface XBitmapCanvas;
+
+    /** Bitmap interface, to directly manipulate the pixel.
+     */
+    interface XBitmap;
+};
+
+}; }; }; };
+
+#endif
--- /dev/null	2004-08-25 23:04:59.000000000 +0530
+++ offapi/com/sun/star/rendering/XBitmap.idl	2005-02-28 13:41:29.000000000 +0530
@@ -0,0 +1,153 @@
+/*************************************************************************
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
+ *
+ *  Copyright: 2000 by Sun Microsystems, Inc.
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+#ifndef __com_sun_star_rendering_XBitmap_idl__
+#define __com_sun_star_rendering_XBitmap_idl__
+
+#ifndef __com_sun_star_uno_XInterface_idl__ 
+#include <com/sun/star/uno/XInterface.idl> 
+#endif 
+#ifndef __com_sun_star_lang_IllegalArgumentException_idl__
+#include <com/sun/star/lang/IllegalArgumentException.idl>
+#endif 
+#ifndef __com_sun_star_geometry_IntegerSize2D_idl__
+#include <com/sun/star/geometry/IntegerSize2D.idl>
+#endif
+#ifndef __com_sun_star_geometry_RealSize2D_idl__
+#include <com/sun/star/geometry/RealSize2D.idl>
+#endif
+#ifndef __com_sun_star_rendering_VolatileContentDestroyedException_idl__
+#include <com/sun/star/rendering/VolatileContentDestroyedException.idl>
+#endif
+
+module com { module sun { module star { module rendering {
+
+interface XBitmapCanvas;
+
+/** This is a generic interface to a bitmap.<p>
+
+	This interface contains the generic functionality to be used on
+	every <type>XCanvas</type> bitmap object. More format-specific
+	methods can be found at the <type>XIntegerBitmap</type>,
+	<type>XIeeeDoubleBitmap</type>, <type>XIeeeFloatBitmap</type> and
+	<type>XHalfFloatBitmap</type> interfaces.<p>
+
+    @since #110496#
+ */
+interface XBitmap : ::com::sun::star::uno::XInterface 
+{
+	/** Query the size of the bitmap.<p>
+
+		This method queries the bitmap size in pixel.<p>
+
+        @return the bitmap size in pixel.
+ 	 */
+	::com::sun::star::geometry::IntegerSize2D	getSize();
+
+	//-------------------------------------------------------------------------
+
+	/** Query a canvas interface for this bitmap.<p>
+
+    	This method queries a canvas interface for this bitmap, to
+    	which draw operations can then be issued. Please note that
+    	concurrent draw operations on that <type>XBitmapCanvas</type>
+    	interface and modifying operations on this bitmap interface
+    	might cause undesired effects. Although the implementations
+    	are required to not crash in this case, the result of such
+    	concurrent operations are <em>undefined</em> (i.e. anything
+    	else, including corruption of the bitmap data, or deadlocking,
+    	might actually happen). Thus, it is highly recommended to
+    	externally serialize the access here.<p>
+
+        @returns an <type>XBitmapCanvas</type> interface, whose
+        rendering operations are directed into the bitmap.
+	 */
+	XBitmapCanvas					queryBitmapCanvas();
+
+	//-------------------------------------------------------------------------
+
+	/** Query a scaled version of the original bitmap.
+
+    	@param newSize
+        Requested size of the new bitmap. Both of the two size
+        components must be greater than zero.
+    
+		@param beFast
+		When set to true, this parameter advises getScaledBitmap to
+		use the fastest available algorithm to scale the bitmap, which
+		might cause visible artifacts.
+
+        @returns the new scaled bitmap.
+
+        @throws com::sun::star::lang::IllegalArgumentException
+        if the size components are outside the specified range.
+
+        @throws VolatileContentDestroyedException
+        if the contents of a volatile bitmap have been destroyed, and
+        thus cannot be read to generate the scaled bitmap.
+	 */
+	XBitmap							getScaledBitmap( [in] ::com::sun::star::geometry::RealSize2D newSize, [in] boolean beFast )
+        raises (com::sun::star::lang::IllegalArgumentException,
+                VolatileContentDestroyedException); 
+};
+
+}; }; }; };
+
+#endif
--- /dev/null	2004-08-25 23:04:59.000000000 +0530
+++ offapi/com/sun/star/rendering/XBitmapPalette.idl	2005-02-28 13:41:29.000000000 +0530
@@ -0,0 +1,140 @@
+/*************************************************************************
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
+ *
+ *  Copyright: 2000 by Sun Microsystems, Inc.
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+#ifndef __com_sun_star_rendering_XBitmapPalette_idl__
+#define __com_sun_star_rendering_XBitmapPalette_idl__
+
+#ifndef __com_sun_star_uno_XInterface_idl__ 
+#include <com/sun/star/uno/XInterface.idl> 
+#endif 
+#ifndef __com_sun_star_lang_IllegalArgumentException_idl__
+#include <com/sun/star/lang/IllegalArgumentException.idl>
+#endif 
+#ifndef __com_sun_star_lang_IndexOutOfBoundsException_idl__
+#include <com/sun/star/lang/IndexOutOfBoundsException.idl>
+#endif 
+#ifndef __com_sun_star_rendering_XColorSpace_idl__
+#include <com/sun/star/rendering/XColorSpace.idl>
+#endif
+
+
+module com { module sun { module star { module rendering {
+
+/** Interface to access the palette of a color-indexed bitmap.
+
+	@since #110496#
+ */
+interface XBitmapPalette : ::com::sun::star::uno::XInterface
+{
+    /** Request the number of palette entries available.
+
+    	@return the number of entries in this palette.
+     */
+    long						getNumberOfEntries();
+
+	//-------------------------------------------------------------------------
+
+    /** Request the color for the given palette entry.
+
+    	@param nIndex
+        The index of the palette entry to be retrieved. Valid range is
+        [0,getNumberOfEntries()-1].
+
+        @return the device color sequence of the requested palette
+        entry.
+
+        @throws com::sun::star::lang::IndexOutOfBoundsException
+        if the index is smaller than zero or larger than
+        <member>XBitmapPalette::getNumberOfEntries()</member-1.
+     */
+    sequence<ColorComponent>	getPaletteIndex( [in] long nIndex )
+        raises (com::sun::star::lang::IndexOutOfBoundsException); 
+
+	//-------------------------------------------------------------------------
+
+    /** Set the color for the given palette entry.
+
+    	@param color
+        Sequence of device color values in the associated bitmap's
+        device color format.
+
+    	@param nIndex
+        The index of the palette entry to be changed. Valid range is
+        [0,getNumberOfEntries()-1].
+
+    	@return whether the palette entry was changed. For read-only
+    	entries, this method always returns <FALSE>.
+
+        @throws com::sun::star::lang::IndexOutOfBoundsException
+        if the index is smaller than zero or larger than
+        <member>XBitmapPalette::getNumberOfEntries()</member-1.
+
+        @throws com::sun::star::lang::IllegalArgumentException
+        if the given sequence of color components does not match the
+        associated bitmap's device color format.
+     */
+    boolean						setPaletteIndex( [in] sequence<ColorComponent> color, [in] long nIndex )
+        raises (com::sun::star::lang::IndexOutOfBoundsException,
+                com::sun::star::lang::IllegalArgumentException); 
+};
+
+}; }; }; };
+
+#endif
--- /dev/null	2004-08-25 23:04:59.000000000 +0530
+++ offapi/com/sun/star/rendering/XBufferController.idl	2005-02-28 13:41:29.000000000 +0530
@@ -0,0 +1,148 @@
+/*************************************************************************
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
+ *
+ *  Copyright: 2000 by Sun Microsystems, Inc.
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+#ifndef __com_sun_star_rendering_XBufferController_idl__
+#define __com_sun_star_rendering_XBufferController_idl__
+
+#ifndef __com_sun_star_uno_XInterface_idl__ 
+#include <com/sun/star/uno/XInterface.idl> 
+#endif 
+#ifndef __com_sun_star_lang_IllegalArgumentException_idl__
+#include <com/sun/star/lang/IllegalArgumentException.idl>
+#endif 
+
+module com { module sun { module star { module rendering {
+
+/** Interface providing access to double/multi-buffer facilities of
+    screen devices.<p>
+
+    This interface provides methods to enable and control
+    double/multi-buffering facilities on screen devices.<p>
+
+    @since #110496#
+ */
+interface XBufferController : ::com::sun::star::uno::XInterface
+{
+	/** Create the given number of background buffers.<p>
+
+    	There's one buffer implicitely available, which is the canvas
+    	surface itself. Thus, calling <code>createBuffers(1)</code>
+    	creates a double-buffered object.<p>
+
+    	@param nBuffers
+        The number of background<buffers requested. Must be greater
+        than 0.
+
+    	@return the number of actually generated buffers, which might
+    	be between 0 (no double-buffering available) and nBuffers.
+
+        @throws com::sun::star::lang::IllegalArgumentException
+        if nBuffers is smaller than one.
+ 	 */
+	long 	createBuffers( [in] long nBuffers )
+        raises (com::sun::star::lang::IllegalArgumentException); 
+
+	//-------------------------------------------------------------------------
+
+	/** Destroy all buffers generated via this object.    	
+	 */
+	void 	destroyBuffers();
+
+	//-------------------------------------------------------------------------
+
+	/** Switch the display to show the specified buffer.<p>
+
+    	The method returns, when the switch is performed and the
+    	selected buffer is shown on screen, or immediately when an
+    	error occurs.<p>
+
+        @param nBuffer
+        Buffer to switch the display to. Valid range is from 0 to the
+        number returned by createBuffers()-1.
+
+        @return whether the switch was performed successfully.
+
+        @throws com::sun::star::lang::IllegalArgumentException
+        if nBuffer is outside the permissible range.
+	 */
+	boolean	showBuffer( [in] long nBuffer )
+        raises (com::sun::star::lang::IllegalArgumentException); 
+
+	//-------------------------------------------------------------------------
+
+	/** Switch the canvas to render into the buffer with the specified
+		index number. 
+
+        @param nBuffer
+        Buffer to change the rendering to. Valid range is from 0 to
+        the number returned by createBuffers()-1.
+
+        @return true, if this switch was successful.
+
+        @throws com::sun::star::lang::IllegalArgumentException
+        if nBuffer is outside the permissible range.
+	 */
+	boolean	renderToBuffer( [in] long nBuffer )
+        raises (com::sun::star::lang::IllegalArgumentException); 
+};
+
+}; }; }; };
+
+#endif
--- /dev/null	2004-08-25 23:04:59.000000000 +0530
+++ offapi/com/sun/star/rendering/XCachedPrimitive.idl	2005-02-28 13:41:29.000000000 +0530
@@ -0,0 +1,107 @@
+/*************************************************************************
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
+ *
+ *  Copyright: 2000 by Sun Microsystems, Inc.
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+#ifndef __com_sun_star_rendering_XCachedPrimitive_idl__
+#define __com_sun_star_rendering_XCachedPrimitive_idl__
+
+#ifndef __com_sun_star_uno_XInterface_idl__ 
+#include <com/sun/star/uno/XInterface.idl> 
+#endif 
+#ifndef __com_sun_star_lang_IllegalArgumentException_idl__
+#include <com/sun/star/lang/IllegalArgumentException.idl>
+#endif 
+#ifndef __com_sun_star_rendering_ViewState_idl__
+#include <com/sun/star/rendering/ViewState.idl>
+#endif
+
+module com { module sun { module star { module rendering {
+
+/** Interface for cached repaint of already drawn <type>XCanvas</type>
+    primitives.<p>
+
+    This interface provides a method to quickly redraw some
+    <type>XCanvas</type> primitives, using cached data.<p>
+
+    @since #110496#
+ */
+interface XCachedPrimitive : ::com::sun::star::uno::XInterface
+{
+	/** Redraw the cached primitive.<p>
+
+	    Redraw the cached primitive, with a possibly new view state.<p>
+
+        @param aState
+        The view state to be used when redrawing the primitive. The
+        view state is of course permitted to differ from the one used
+        for initial rendering.
+
+        @return a value of type <type>RepaintResult</type>, denoting
+        the result of this operation.
+
+        @throws com::sun::star::lang::IllegalArgumentException
+        if the view transformation matrix is singular.
+	 */
+	byte redraw( [in] ViewState aState )
+        raises (com::sun::star::lang::IllegalArgumentException);
+};
+
+}; }; }; };
+
+#endif
--- /dev/null	2004-08-25 23:04:59.000000000 +0530
+++ offapi/com/sun/star/rendering/XCanvasFont.idl	2005-02-28 13:41:29.000000000 +0530
@@ -0,0 +1,172 @@
+/*************************************************************************
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
+ *
+ *  Copyright: 2000 by Sun Microsystems, Inc.
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+#ifndef __com_sun_star_rendering_XCanvasFont_idl__
+#define __com_sun_star_rendering_XCanvasFont_idl__
+
+#ifndef __com_sun_star_uno_XInterface_idl__ 
+#include <com/sun/star/uno/XInterface.idl> 
+#endif 
+#ifndef __com_sun_star_lang_IllegalArgumentException_idl__
+#include <com/sun/star/lang/IllegalArgumentException.idl>
+#endif 
+#ifndef __com_sun_star_geometry_RealRectangle2D_idl__
+#include <com/sun/star/geometry/RealRectangle2D.idl>
+#endif
+#ifndef __com_sun_star_rendering_FontRequest_idl__
+#include <com/sun/star/rendering/FontRequest.idl>
+#endif
+#ifndef __com_sun_star_rendering_FontMetrics_idl__
+#include <com/sun/star/rendering/FontMetrics.idl>
+#endif
+#ifndef __com_sun_star_rendering_RenderState_idl__
+#include <com/sun/star/rendering/RenderState.idl>
+#endif 
+#ifndef __com_sun_star_rendering_ViewState_idl__
+#include <com/sun/star/rendering/ViewState.idl>
+#endif 
+#ifndef __com_sun_star_rendering_StringContext_idl__
+#include <com/sun/star/rendering/StringContext.idl>
+#endif
+
+#ifndef __com_sun_star_beans_PropertyValue_idl__
+#include <com/sun/star/beans/PropertyValue.idl>
+#endif
+
+
+module com { module sun { module star { module rendering {
+
+interface XCanvas;
+interface XTextLayout;
+interface XPolyPolygon2D;
+
+/** This interface provides access to a specific, XCanvas-dependent
+    font incarnation. This font is not universally usable, but belongs
+    to the XCanvas it was queried from.
+ */
+interface XCanvasFont : ::com::sun::star::uno::XInterface
+{
+    /** Create a text layout interface.<p>
+
+    	Create a text layout interface for the given string, using
+    	this font to generate the glyphs from.<p>
+
+        @param aText
+        The text to layout.
+
+        @param nDirection
+        Main text direction for the string specified. The main text
+        direction is e.g. important for characters that are not
+        strong, i.e. that change affinity according to the current
+        writing direction. Make sure that across text portions and
+        lines, the direction is set consistently.
+
+        @param nRandomSeed
+        Optional random seed for OpenType glyph variations.
+     */
+    XTextLayout											createTextLayout( [in] StringContext aText, [in] byte nDirection, [in] hyper nRandomSeed );
+
+	//-------------------------------------------------------------------------
+
+	/** Query the FontRequest that was used to generate this object.
+	 */
+	FontRequest											getFontRequest();
+
+	//-------------------------------------------------------------------------
+
+    /** Query metric information about the font, that is generic to
+        all its glyphs.<p>
+
+        Note that the metric values in the returned result are in the
+        device coordinate system, and already adjusted to the
+        corresponding size of this font.
+     */
+    FontMetrics											getFontMetrics();
+
+	//-------------------------------------------------------------------------
+
+    /** Query the list of available font sizes.<p>
+
+    	This method queries the list of available font sizes (in
+    	device units) for this font. For scalable fonts that are not
+    	restricted to discrete sizes, this list is <em>empty</em>,
+    	meaning that every size is possible. Fonts that <em>do</em>
+    	restrict the device size to certain discrete values, setting
+    	an overall transformation that scales the
+    	<member>FontRequest::CellSize</member> to something not
+    	contained in the list returned by this method can lead to
+    	visible disturbances.<p>
+     */
+    sequence< double > 									getAvailableSizes();
+
+	//-------------------------------------------------------------------------
+
+    /** Query the list of additional font properties.<p>
+     */
+    sequence< ::com::sun::star::beans::PropertyValue >	getExtraFontProperties();
+
+	//-------------------------------------------------------------------------
+
+};
+
+}; }; }; };
+
+#endif
+
--- /dev/null	2004-08-25 23:04:59.000000000 +0530
+++ offapi/com/sun/star/rendering/XCanvas.idl	2005-02-28 13:41:29.000000000 +0530
@@ -0,0 +1,750 @@
+/*************************************************************************
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
+ *
+ *  Copyright: 2000 by Sun Microsystems, Inc.
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+#ifndef __com_sun_star_rendering_XCanvas_idl__
+#define __com_sun_star_rendering_XCanvas_idl__
+
+#ifndef __com_sun_star_uno_XInterface_idl__ 
+#include <com/sun/star/uno/XInterface.idl> 
+#endif 
+#ifndef __com_sun_star_lang_IllegalArgumentException_idl__
+#include <com/sun/star/lang/IllegalArgumentException.idl>
+#endif 
+#ifndef __com_sun_star_geometry_RealPoint2D_idl__
+#include <com/sun/star/geometry/RealPoint2D.idl>
+#endif
+#ifndef __com_sun_star_geometry_RealBezierSegment2D_idl__
+#include <com/sun/star/geometry/RealBezierSegment2D.idl>
+#endif
+#ifndef __com_sun_star_geometry_RealRectangle2D_idl__
+#include <com/sun/star/geometry/RealRectangle2D.idl>
+#endif
+#ifndef __com_sun_star_geometry_Matrix2D_idl__
+#include <com/sun/star/geometry/Matrix2D.idl>
+#endif
+#ifndef __com_sun_star_rendering_ViewState_idl__
+#include <com/sun/star/rendering/ViewState.idl>
+#endif
+#ifndef __com_sun_star_rendering_RenderState_idl__
+#include <com/sun/star/rendering/RenderState.idl>
+#endif
+#ifndef __com_sun_star_rendering_FontRequest_idl__
+#include <com/sun/star/rendering/FontRequest.idl>
+#endif
+#ifndef __com_sun_star_rendering_FontInfo_idl__
+#include <com/sun/star/rendering/FontInfo.idl>
+#endif
+#ifndef __com_sun_star_rendering_Texture_idl__
+#include <com/sun/star/rendering/Texture.idl>
+#endif
+#ifndef __com_sun_star_rendering_StringContext_idl__
+#include <com/sun/star/rendering/StringContext.idl>
+#endif
+#ifndef __com_sun_star_rendering_StrokeAttributes_idl__
+#include <com/sun/star/rendering/StrokeAttributes.idl>
+#endif
+#ifndef __com_sun_star_rendering_VolatileContentDestroyedException_idl__
+#include <com/sun/star/rendering/VolatileContentDestroyedException.idl>
+#endif
+
+#ifndef __com_sun_star_beans_PropertyValue_idl__
+#include <com/sun/star/beans/PropertyValue.idl>
+#endif
+
+
+module com {  module sun {  module star {  module geometry {
+    interface XMapping2D;
+}; }; }; };
+
+module com { module sun { module star { module rendering {
+
+interface XCanvasFont;
+interface XPolyPolygon2D;
+interface XCachedPrimitive;
+interface XBitmap;
+interface XGraphicDevice;
+interface XTextLayout;
+
+/** Central interface for rendering.<p>
+
+	This is the central interface for graphical output production, and
+	the place where all draw methods are located.<p>
+
+    Some notes are in order to explain the concepts used here. The
+    <type>XCanvas</type> interface is free of client-modifiable state,
+    i.e. it can be used safely and without external synchronization in
+    a multi-threaded environment. On the other hand, this implies that
+    for nearly every canvas operation, external state is
+    required. This is provided by <type>ViewState</type> and
+    <type>RenderState</type> in a unified fashion, supplemented by a
+    few extra state parameters for some methods (e.g. textured
+    polygons or text rendering).<p>
+
+    When used careless, this scheme can be inefficient to some extend,
+    because internally, view, render and other states have to be
+    combined before rendering. This is especially expensive for
+    complex clip polygons, i.e. when both <type>ViewState</type> and
+    <type>RenderState</type> have a complex clip polygon set, which
+    have to be intersected before rendering. It is therefore
+    recommended to combine <type>ViewState</type> and
+    <type>RenderState</type> already at the client side, when objects
+    are organized in a hierarchical way: the classic example are
+    grouped draw shapes, whose parent group object imposes a
+    common clipping and a common transformation on its siblings. The
+    group object would therefore merge the <type>ViewState</type> and
+    the <type>RenderState</type> it is called with into a new
+    <type>ViewState</type>, and call its siblings with a
+    <type>RenderState</type> containing only the local offset (and no
+    extra clipping).<p>
+
+    Furtheron, this stateless nature provides easy ways for
+    caching. Every non-trivial operation on <type>XCanvas</type>
+    returns a cache object, which, when called to redraw, renders the
+    primitive usually much more quickly than the original method. Note
+    that such caching is a lot more complicated, should the actual
+    rendering a method yields depend on internal state (which is the
+    case e.g. for the
+    <type>::com::sun::star::drawing::XGraphics</type> interface).<p>
+
+    @since #110496#
+ */
+interface XCanvas : ::com::sun::star::uno::XInterface
+{
+	 /** Draw a point in device resolution on the device.
+
+     	@param aPoint
+        The point to draw.
+
+        @param aViewState
+        The viewstate to be used when drawing this point.
+
+        @param aRenderState
+        The renderstate to be used when drawing this point.
+
+        @throws com::sun::star::lang::IllegalArgumentException
+        if one of the view and renderstate parameters are outside the 
+        specified range.        
+	 */
+	void				drawPoint( [in] ::com::sun::star::geometry::RealPoint2D aPoint, [in] ViewState aViewState, [in] RenderState aRenderState )
+        raises (com::sun::star::lang::IllegalArgumentException); 
+
+	//-------------------------------------------------------------------------
+
+	/** Draw a line in device resolution width (i.e. one device	pixel
+		wide).
+
+     	@param aStartPoint
+        The start point of the line to draw.
+
+     	@param aEndPoint
+        The end point of the line to draw.
+
+        @param aViewState
+        The viewstate to be used when drawing this line.
+
+        @param aRenderState
+        The renderstate to be used when drawing this line.
+
+        @throws com::sun::star::lang::IllegalArgumentException
+        if one of the view and renderstate parameters are outside the 
+        specified range.        
+	 */
+	void				drawLine( [in] ::com::sun::star::geometry::RealPoint2D aStartPoint, [in] ::com::sun::star::geometry::RealPoint2D aEndPoint, [in] ViewState aViewState, [in] RenderState aRenderState )
+        raises (com::sun::star::lang::IllegalArgumentException); 
+
+	//-------------------------------------------------------------------------
+
+	/** Draw a cubic bezier curve in device resolution width (i.e. one
+		device pixel wide).
+
+        @param aBezierSegment
+        The start and the two control points of the bezier curve.
+
+        @param aEndPoint
+        The end point of the bezier curve.
+
+        @param aViewState
+        The viewstate to be used when drawing this curve.
+
+        @param aRenderState
+        The renderstate to be used when drawing this curve.
+
+        @throws com::sun::star::lang::IllegalArgumentException
+        if one of the view and renderstate parameters are outside the 
+        specified range.        
+	 */
+	void				drawBezier( [in] ::com::sun::star::geometry::RealBezierSegment2D aBezierSegment, [in] ::com::sun::star::geometry::RealPoint2D aEndPoint, [in] ViewState aViewState, [in] RenderState aRenderState )
+        raises (com::sun::star::lang::IllegalArgumentException); 
+ 
+	//-------------------------------------------------------------------------
+
+	/** Draw a poly-polygon in device resolution line width (i.e. the
+		lines are one device pixel wide).
+
+        @param xPolyPolygon
+        The poly-polygon to draw.
+
+        @param aViewState
+        The viewstate to be used when drawing this polygon.
+
+        @param aRenderState
+        The renderstate to be used when drawing this polygon.
+
+        @return a handle to the cached rendering output.
+        
+        @throws com::sun::star::lang::IllegalArgumentException
+        if one of the view and renderstate parameters are outside the 
+        specified range.        
+	 */
+	XCachedPrimitive	drawPolyPolygon( [in] XPolyPolygon2D xPolyPolygon, [in] ViewState aViewState, [in] RenderState aRenderState )
+        raises (com::sun::star::lang::IllegalArgumentException); 
+
+	//-------------------------------------------------------------------------
+
+	/** Stroke each polygon of the provided poly-polygon with the
+		specified stroke attributes.<p>
+
+        This method considers the stroking of all polygons as an
+        atomic operation in relation to the <type>RenderState</type>'s
+        <type>CompositeOperationy</type> operation. That means,
+        overlapping strokes from distinct polygons will look exactly
+        as overlapping segments of the same polygon, even with
+        transparency.<p>
+
+        @param xPolyPolygon
+        The poly-polygon to render.
+
+        @param aViewState
+        The viewstate to be used when stroking this polygon.
+
+        @param aRenderState
+        The renderstate to be used when stroking this polygon.
+
+        @param aStrokeAttributes
+        Further attributes used to parameterize the stroking.
+
+        @return a handle to the cached rendering output.
+        
+        @throws com::sun::star::lang::IllegalArgumentException
+        if one of the view and renderstate parameters are outside the 
+        specified range.        
+	 */
+	XCachedPrimitive	strokePolyPolygon( [in] XPolyPolygon2D xPolyPolygon, [in] ViewState aViewState, [in] RenderState aRenderState, [in] StrokeAttributes aStrokeAttributes )
+        raises (com::sun::star::lang::IllegalArgumentException); 
+
+	//-------------------------------------------------------------------------
+
+	/** Stroke each polygon of the provided poly-polygon with the
+		specified stroke attributes, fill the stroked outline
+		with the specified texture graphics.<p>
+
+        This method considers the stroking of all polygons as an
+        atomic operation in relation to the <type>RenderState</type>'s
+        <type>CompositeOp</type> operation. That means, overlapping
+        strokes from distinct polygons will look exactly as
+        overlapping segments of the same polygon, even with
+        transparency.<p>
+
+        @param xPolyPolygon
+        The poly-polygon to render.
+
+        @param aViewState
+        The viewstate to be used when strokes this polygon.
+
+        @param aRenderState
+        The renderstate to be used when stroking this polygon.
+
+        @param aTextures
+        A sequence of texture definitions, with which to fill the
+        stroked area.
+
+        @param aStrokeAttributes
+        Further attributes used to parameterize the stroking.
+
+        @return a handle to the cached rendering output.
+        
+        @throws com::sun::star::lang::IllegalArgumentException
+        if one of the view and renderstate parameters are outside the 
+        specified range.        
+
+        @throws VolatileContentDestroyedException
+        if a texture bitmap was volatile, and the content was
+        destroyed before the rendering could take place.
+	 */
+	XCachedPrimitive	strokeTexturedPolyPolygon( [in] XPolyPolygon2D xPolyPolygon, [in] ViewState aViewState, [in] RenderState aRenderState, [in] sequence<Texture> aTextures, [in] StrokeAttributes aStrokeAttributes )
+        raises (com::sun::star::lang::IllegalArgumentException,
+                VolatileContentDestroyedException); 
+
+	//-------------------------------------------------------------------------
+
+	/** Stroke each polygon of the provided poly-polygon with the
+		specified stroke attributes, fill the stroked outline
+		with the specified texture graphics, map the texture to the
+		outline via the specified texture mapping.<p>
+
+        This method considers the stroking of all polygons as an
+        atomic operation in relation to the <type>RenderState</type>'s
+        <type>CompositeOp</type> operation. That means, overlapping
+        strokes from distinct polygons will look exactly as
+        overlapping segments of the same polygon, even with
+        transparency.
+
+        @param xPolyPolygon
+        The poly-polygon to render.
+
+        @param aViewState
+        The viewstate to be used when stroking this polygon.
+
+        @param aRenderState
+        The renderstate to be used when stroking this polygon.
+
+        @param aTextures
+        A sequence of texture definitions, with which to fill the
+        stroked area.
+
+        @param xMapping
+        A bilinear mapping function which defines the warping of the
+        textures on the output area.
+
+        @param aStrokeAttributes
+        Further attributes used to parameterize the stroking.
+
+        @return a handle to the cached rendering output.
+        
+        @throws com::sun::star::lang::IllegalArgumentException
+        if one of the view and renderstate parameters are outside the 
+        specified range.        
+
+        @throws VolatileContentDestroyedException
+        if a texture bitmap was volatile, and the content was
+        destroyed before the rendering could take place.
+	 */
+	XCachedPrimitive	strokeTextureMappedPolyPolygon( [in] XPolyPolygon2D xPolyPolygon, [in] ViewState aViewState, [in] RenderState aRenderState, [in] sequence<Texture> aTextures, [in] ::com::sun::star::geometry::XMapping2D xMapping, [in] StrokeAttributes aStrokeAttributes )
+        raises (com::sun::star::lang::IllegalArgumentException,
+                VolatileContentDestroyedException); 
+
+	//-------------------------------------------------------------------------
+
+    //  [TODO: Method misplaced at this interface?]
+
+	/** Query the polygonal representation of the stroke outlines, as
+		it would be generated by the strokePolyPolygon methods.<p>
+
+        This method can be used to e.g. set a clipping which covers the same
+        area as a stroke.<p>
+
+        @param xPolyPolygon
+        The poly-polygon to render.
+
+        @param aViewState
+        The viewstate to be used when generating the outline.
+
+        @param aRenderState
+        The renderstate to be used when generating the outline.
+        
+        @param aStrokeAttributes
+        Further attributes used to parameterize the stroking.
+
+        @return a poly-polygon describing the outline of the stroked
+        area.
+
+        @throws com::sun::star::lang::IllegalArgumentException
+        if one of the view and renderstate parameters are outside the 
+        specified range.        
+	 */
+	XPolyPolygon2D 		queryStrokeShapes( [in] XPolyPolygon2D xPolyPolygon, [in] ViewState aViewState, [in] RenderState aRenderState, [in] StrokeAttributes aStrokeAttributes )
+        raises (com::sun::star::lang::IllegalArgumentException); 
+
+	//-------------------------------------------------------------------------
+
+	/** Fill the given poly-polygon.<p>
+
+    	This method fills the given poly-polygon according to the
+    	<type>RenderState</type>'s color and the poly-polygon's fill
+    	rule.<p>
+
+        @param xPolyPolygon
+        The poly-polygon to render.
+
+        @param aViewState
+        The viewstate to be used when filling this polygon.
+
+        @param aRenderState
+        The renderstate to be used when filling this polygon.
+        
+        @return a handle to the cached rendering output.
+
+        @throws com::sun::star::lang::IllegalArgumentException
+        if one of the view and renderstate parameters are outside the 
+        specified range.                
+	 */
+	XCachedPrimitive	fillPolyPolygon( [in] XPolyPolygon2D xPolyPolygon, [in] ViewState aViewState, [in] RenderState aRenderState )
+        raises (com::sun::star::lang::IllegalArgumentException); 
+
+	//-------------------------------------------------------------------------
+
+	/** Fill the given poly-polygon with a texture.<p>
+
+    	This method fills the given poly-polygon according to the
+    	<type>RenderState</type>'s color, the given textures and
+    	poly-polygon's fill rule.<p>
+
+        @param xPolyPolygon
+        The poly-polygon to render.
+
+        @param aViewState
+        The viewstate to be used when filling this polygon.
+
+        @param aRenderState
+        The renderstate to be used when filling this polygon.
+        
+        @param aTextures
+        A sequence of texture definitions, with which to fill the
+        polygonal area.
+
+        @return a handle to the cached rendering output.
+
+        @throws com::sun::star::lang::IllegalArgumentException
+        if one of the view and renderstate parameters are outside the 
+        specified range.        
+
+        @throws VolatileContentDestroyedException
+        if a texture bitmap was volatile, and the content was
+        destroyed before the rendering could take place.
+    */
+	XCachedPrimitive	fillTexturedPolyPolygon( [in] XPolyPolygon2D xPolyPolygon, [in] ViewState aViewState, [in] RenderState aRenderState, [in] sequence<Texture> xTextures )
+        raises (com::sun::star::lang::IllegalArgumentException,
+                VolatileContentDestroyedException); 
+
+	//-------------------------------------------------------------------------
+
+	/** Fill the given poly-polygon with a mapped texture.<p>
+
+    	This method fills the given poly-polygon according to the
+    	<type>RenderState</type>'s color, the given textures and
+    	poly-polygon's fill rule. The texture is mapped to the
+    	poly-polygon's interior via the given texture mapping.<p>
+
+        @param xPolyPolygon
+        The poly-polygon to render.
+
+        @param aViewState
+        The viewstate to be used when filling this polygon.
+
+        @param aRenderState
+        The renderstate to be used when filling this polygon.
+        
+        @param aTextures
+        A sequence of texture definitions, with which to fill the
+        polygonal area.
+
+        @param xMapping
+        A bilinear mapping function which defines the warping of the
+        textures on the output area.
+
+        @return a handle to the cached rendering output.
+
+        @throws com::sun::star::lang::IllegalArgumentException
+        if one of the view and renderstate parameters are outside the 
+        specified range.        
+
+        @throws VolatileContentDestroyedException
+        if a texture bitmap was volatile, and the content was
+        destroyed before the rendering could take place.
+     */
+	XCachedPrimitive	fillTextureMappedPolyPolygon( [in] XPolyPolygon2D xPolyPolygon, [in] ViewState aViewState, [in] RenderState aRenderState, [in] sequence<Texture> xTextures, [in] ::com::sun::star::geometry::XMapping2D xMapping )
+        raises (com::sun::star::lang::IllegalArgumentException,
+                VolatileContentDestroyedException); 
+
+	//-------------------------------------------------------------------------
+
+	/** Create a suitable font for the specified font description.
+
+    	@param aFontRequest
+
+        @param aExtraFontProperties
+        Additional font properties to be applied when selecting this
+        font. Normally, you should not need this parameter. Currently,
+        the following properties are recognized: 
+        <ul>
+
+        	<il>Kerning: a <type>double</type> between 0 and 1, where
+        	0 completely disables kerning. Whether kerning is on or
+        	off by default is font-dependent.</il>
+
+        	<il>IsEmphasisMarks: a <type>boolean</type>, where <TRUE>
+        	enables automatic placements of emphasis marks, e.g. for
+        	Hebrew. The default value, if this property is not
+        	specified, is <FALSE>.</il>
+
+        	<il>ExpandedSpacing: a <type>double</type> value which is added 
+            between all cell distances for this font. The default value for 
+            this property is zero. Use negative values for condensed output, 
+            and positive values for expanded output.</il>
+
+        	<il>OptionalLayoutFeatures: a sequence of <type
+        	scope=::com::sun::star::beans>PropertyValue</type> listing
+        	font-specific optional layout features, like glyph
+        	variants.</il>
+
+        </ul>
+
+        @param aFontMatrix
+        Font-specific transformation matrix, which affects both the
+        glyphs as well as the advancement.
+
+        @returns the requested font, or an invalid reference, if the
+        request failed.
+
+        @throws com::sun::star::lang::IllegalArgumentException
+        if one of the parameters is not within the allowed range.
+	 */
+	XCanvasFont				createFont( [in] FontRequest aFontRequest, [in] sequence< ::com::sun::star::beans::PropertyValue > aExtraFontProperties, [in] ::com::sun::star::geometry::Matrix2D aFontMatrix )
+        raises (com::sun::star::lang::IllegalArgumentException); 
+
+	//-------------------------------------------------------------------------
+
+	/** Query font information, specific to this canvas.<p>
+
+    	@param aFilter
+        Filter parameter to reduce the list of returned fonts. Every
+        member of <type>FontInfo</type> that is not the empty string
+        or the "don't care" value restricts the list of returned fonts
+        to contain only those that have the specified attribute.
+
+        @param xFontProperties
+        This interface can provide additional font properties to
+        filter the list of available fonts against.
+
+        @returns the list of fonts matching the filter set.
+
+        @throws com::sun::star::lang::IllegalArgumentException
+        if one of the font properties are invalid or not recognized,
+        or if one of the <type>FontInfo</type> members is not within
+        the permitted range.
+	 */
+	sequence< FontInfo >	queryAvailableFonts( [in] FontInfo aFilter, [in] sequence< ::com::sun::star::beans::PropertyValue > aFontProperties )
+        raises (com::sun::star::lang::IllegalArgumentException); 
+
+	//-------------------------------------------------------------------------
+
+	/** Draw the text given by the substring of the specified string
+		with the given font.<p>
+
+        The local origin of this output operation is either the left
+        end of the text baseline, for textDirection equal
+        LEFT_TO_RIGHT, or the right end of the baseline, for
+        textDirection equal to RIGHT_TO_LEFT, respectively.<p>
+
+        @param aText
+        The text to output.
+
+        @param xFont
+        The font retrieved from this canvas to be used when drawing
+        the text.
+
+        @param aViewState
+        The viewstate to be used when drawing this text.
+
+        @param aRenderState
+        The renderstate to be used when drawing this text.
+        
+        @param nTextDirection
+        A value from the <type>TextDirection</type> collection,
+        denoting the main writing direction for this string. The main
+        writing direction determines the origin of the text output,
+        i.e. the left edge for left-to-right and the right edge for
+        right-to-left text.
+
+        @return a handle to the cached rendering output.
+
+        @throws com::sun::star::lang::IllegalArgumentException
+        if one of the view and renderstate parameters are outside the 
+        specified range.        
+	 */
+	XCachedPrimitive		drawText( [in] StringContext aText, [in] XCanvasFont xFont, [in] ViewState aViewState, [in] RenderState aRenderState, [in] byte nTextDirection )
+        raises (com::sun::star::lang::IllegalArgumentException); 
+
+	//-------------------------------------------------------------------------
+
+	/** Draw the formatted text given by the text layout.<p>
+
+    	The glyphs as represented by the text layout are always output
+    	with the reference position being the leftmost edge of the
+    	layout object's baseline. If the layout contains more than one
+    	baseline, the baseline of the first strong character in
+    	logical order is used here (strong in this context means that
+    	the character can be unambiguously assigned to a unicode
+    	script).<p>
+
+        @param xLayoutetText
+        An interface to the readily layouted text, obtained from a
+        <type>XCanvasFont</type> created at this canvas. The text
+        layout already carries intrinsic font information.
+
+        @param aViewState
+        The viewstate to be used when drawing this text.
+
+        @param aRenderState
+        The renderstate to be used when drawing this text.
+
+        @return a handle to the cached rendering output.
+
+        @throws com::sun::star::lang::IllegalArgumentException
+        if one of the view and renderstate parameters are outside the 
+        specified range.        
+	 */
+	XCachedPrimitive		drawTextLayout( [in] XTextLayout xLayoutetText, [in] ViewState aViewState, [in] RenderState aRenderState )
+        raises (com::sun::star::lang::IllegalArgumentException); 
+
+	//-------------------------------------------------------------------------
+
+	/** Render the given bitmap.<p>
+
+    	This method renders the bitmap, at a position and shape as
+    	specified by the combined view and render transformations. For
+    	fast render speed, the bitmap should be created by the
+    	corresponding <type>XGraphicDevice</type>'s
+    	<member>XGraphicDevice::createCompatibleBitmap()</member>
+    	method.<p>
+
+        @param xBitmap
+        The bitmap to render.
+
+        @param aViewState
+        The viewstate to be used when drawing this text.
+
+        @param aRenderState
+        The renderstate to be used when drawing this text.
+
+        @return a handle to the cached rendering output.
+
+        @throws com::sun::star::lang::IllegalArgumentException
+        if one of the view and renderstate parameters are outside the 
+        specified range.        
+
+        @throws VolatileContentDestroyedException
+        if a texture bitmap was volatile, and the content was
+        destroyed before the rendering could take place.
+	 */
+	XCachedPrimitive		drawBitmap( [in] XBitmap xBitmap, [in] ViewState aViewState, [in] RenderState aRenderState )
+        raises (com::sun::star::lang::IllegalArgumentException,
+                VolatileContentDestroyedException); 
+
+	/** Render the given bitmap, with a global color modulation.<p>
+
+    	This method renders the bitmap, at a position and shape as
+    	specified by the combined view and render transformations. For
+    	fast render speed, the bitmap should be created by the
+    	corresponding <type>XGraphicDevice</type>'s
+    	<member>XGraphicDevice::createCompatibleBitmap()</member>
+    	method. The bitmap's color channel values are multiplied with
+    	the device color values as specified in the render state.<p>
+
+        @param xBitmap
+        The bitmap to render.
+
+        @param aViewState
+        The viewstate to be used when drawing this text.
+
+        @param aRenderState
+        The renderstate to be used when drawing this text. The device
+        color entry in the renderstate is multiplied with every pixel
+        color value, and only the result is rendered into the
+        canvas. If, for example, the bitmap should be rendered with
+        increased global transparency, set all device color channels
+        to 1.0, except for the alpha channel, which should be set to
+        the desired transparency.
+
+        @return a handle to the cached rendering output.
+
+        @throws com::sun::star::lang::IllegalArgumentException
+        if one of the view and renderstate parameters are outside the 
+        specified range.        
+
+        @throws VolatileContentDestroyedException
+        if a texture bitmap was volatile, and the content was
+        destroyed before the rendering could take place.
+	 */
+	XCachedPrimitive		drawBitmapModulated( [in] XBitmap xBitmap, [in] ViewState aViewState, [in] RenderState aRenderState )
+        raises (com::sun::star::lang::IllegalArgumentException,
+                VolatileContentDestroyedException); 
+
+	//-------------------------------------------------------------------------
+
+	/** Request the associated graphic device for this canvas.<p>
+
+    	A graphic device provides methods specific to the underlying
+    	output device capabilities, which are common for all canvases
+    	rendering to such a device. This includes device resolution,
+    	color space, or bitmap formats.
+
+    	@return the associated <type>XGraphicDevice</type>.
+	 */
+	XGraphicDevice			getDevice();
+};
+
+//=============================================================================
+
+service Canvas: XCanvas;
+
+}; }; }; };
+
+#endif
--- /dev/null	2004-08-25 23:04:59.000000000 +0530
+++ offapi/com/sun/star/rendering/XColorSpace.idl	2005-02-28 13:41:29.000000000 +0530
@@ -0,0 +1,95 @@
+/*************************************************************************
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
+ *
+ *  Copyright: 2000 by Sun Microsystems, Inc.
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+#ifndef __com_sun_star_rendering_XColorSpace_idl__
+#define __com_sun_star_rendering_XColorSpace_idl__
+
+#ifndef __com_sun_star_uno_XInterface_idl__ 
+#include <com/sun/star/uno/XInterface.idl> 
+#endif 
+
+#ifndef __com_sun_star_rendering_ColorSpaceType_idl__
+#include <com/sun/star/rendering/ColorSpaceType.idl>
+#endif
+#ifndef __com_sun_star_rendering_ColorProfile_idl__
+#include <com/sun/star/rendering/ColorProfile.idl>
+#endif
+
+module com { module sun { module star { module rendering {
+
+/* TODO: There's still a lot open here! */
+
+interface XColorSpace
+{
+    // TODO
+    byte			getRenderingIntent();
+    ColorProfile	getICCProfile();
+    string			getName();		
+    ColorSpaceType	getType(); // whatever
+};
+
+//=============================================================================
+
+/// Shorthand for the device-dependent color components, and easier to read
+typedef double ColorComponent;
+
+}; }; }; };
+
+#endif
--- /dev/null	2004-08-25 23:04:59.000000000 +0530
+++ offapi/com/sun/star/rendering/XCustomSprite.idl	2005-02-28 13:41:29.000000000 +0530
@@ -0,0 +1,125 @@
+/*************************************************************************
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
+ *
+ *  Copyright: 2000 by Sun Microsystems, Inc.
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+#ifndef __com_sun_star_rendering_XCustomSprite_idl__
+#define __com_sun_star_rendering_XCustomSprite_idl__
+
+#ifndef __com_sun_star_uno_XInterface_idl__ 
+#include <com/sun/star/uno/XInterface.idl> 
+#endif 
+#ifndef __com_sun_star_rendering_ViewState_idl__
+#include <com/sun/star/rendering/ViewState.idl>
+#endif
+#ifndef __com_sun_star_rendering_RenderState_idl__
+#include <com/sun/star/rendering/RenderState.idl>
+#endif
+#ifndef __com_sun_star_rendering_XSprite_idl__
+#include <com/sun/star/rendering/XSprite.idl>
+#endif
+
+module com { module sun { module star { module rendering {
+
+interface XCanvas;
+
+/** Interface to control a custom sprite object on a XSpriteCanvas.<p>
+
+	Every change performed on XCustomSprite objects is only visible
+	after a XSpriteCanvas::updateScreen() call, to facilitate
+	synchronized screen updates.
+
+    TODO: Maybe more than alpha has to be overridden from render state.
+    TODO: Provide means to change the output area
+ */
+interface XCustomSprite : XSprite
+{
+
+    /** Query a render canvas for this sprite's content.<p>
+
+    	Whatever is rendered to this canvas will become visible on the
+    	screen only after a XSpriteCanvas::updateScreen() call at the
+    	associated sprite canvas. This canvas is not equivalent to the
+    	host canvas of the sprite. At the very least, all output
+    	happens relative to the sprite's upper left corner, i.e. the
+    	origin of the sprite's canvas device coordinate system will
+    	move with the sprite across the screen.
+
+        @attention Everytime the XCustomSprite is updated, the content
+        canvas must be quried via this method. You are, on the other
+        hand, allowed to temporarily store the canvas while rendering
+        a single sprite update. You might even store the canvas
+        between subsequent calls to getContentCanvas(), but should be
+        aware of the fact that the returned interface might be a
+        different object everytime.
+
+        @attention Since changes to the sprite content will become
+        visible after a XSpriteCanvas::updateScreen(), calls to this
+        method must be synchronized externally. Otherwise, the sprite
+        content rendered to screen is undefined. This is nothing the
+        XCustomSprite can or will manage by itself.
+
+        @return the canvas the sprite content can be rendered into.
+     */
+    XCanvas getContentCanvas();
+
+};
+
+}; }; }; };
+
+#endif
--- /dev/null	2004-08-25 23:04:59.000000000 +0530
+++ offapi/com/sun/star/rendering/XGraphicDevice.idl	2005-02-28 13:41:29.000000000 +0530
@@ -0,0 +1,278 @@
+/*************************************************************************
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
+ *
+ *  Copyright: 2000 by Sun Microsystems, Inc.
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+#ifndef __com_sun_star_rendering_XGraphicDevice_idl__
+#define __com_sun_star_rendering_XGraphicDevice_idl__
+
+#ifndef __com_sun_star_uno_XInterface_idl__ 
+#include <com/sun/star/uno/XInterface.idl> 
+#endif 
+#ifndef __com_sun_star_lang_IllegalArgumentException_idl__
+#include <com/sun/star/lang/IllegalArgumentException.idl>
+#endif 
+#ifndef __com_sun_star_geometry_IntegerSize2D_idl__
+#include <com/sun/star/geometry/IntegerSize2D.idl>
+#endif
+#ifndef __com_sun_star_geometry_RealSize2D_idl__
+#include <com/sun/star/geometry/RealSize2D.idl>
+#endif
+#ifndef __com_sun_star_rendering_XLinePolyPolygon2D_idl__
+#include <com/sun/star/rendering/XLinePolyPolygon2D.idl>
+#endif
+#ifndef __com_sun_star_rendering_XBezierPolyPolygon2D_idl__
+#include <com/sun/star/rendering/XBezierPolyPolygon2D.idl>
+#endif
+#ifndef __com_sun_star_rendering_XParametricPolyPolygon2DFactory_idl__
+#include <com/sun/star/rendering/XParametricPolyPolygon2DFactory.idl>
+#endif
+#ifndef __com_sun_star_rendering_XColorSpace_idl__
+#include <com/sun/star/rendering/XColorSpace.idl>
+#endif
+
+module com { module sun { module star { module rendering {
+
+interface XBitmap;
+interface XVolatileBitmap;
+interface XBufferController;
+
+/* TODO: There's obviously a concept called window missing here, where
+   methods such as bufferController, fullscreen mode etc . belong
+   to. But see below
+ */
+
+/** This interface provides access to a graphic device, such as a
+    printer, or a screen device. Every canvas (@see XCanvas) has
+    exactly one associated graphic device, into which its output is
+    rendered.
+
+    For a typical windowing system, the graphic device is equivalent
+    to a distinct OS window, with it's own clipped output area,
+    fullscreen and double-buffering attributes. That is, even if one
+    can have multiple canvases per system window, they all share the
+    same graphic device and thus e.g. fullscreen state. If the OS
+    restrictions are in such a way that fullscreen or double-buffering
+    is screen-exclusive, i.e. that per screen, only one object can
+    have this state, it might even be that all windows on the screen
+    share a common graphic device.
+ */
+interface XGraphicDevice : ::com::sun::star::uno::XInterface
+{
+	/** Query the controller for multi buffering functionality on this
+		graphic device. 
+
+        If there is no such functionality available, the NULL
+        reference is returned.
+	 */
+	XBufferController 							getBufferController();
+
+	//-------------------------------------------------------------------------
+
+	/** Query the color space interface for this graphic device. 
+
+    	This is to be used when interpreting or setting device color
+    	values.
+	 */
+	XColorSpace		 							getDeviceColorSpace();
+
+	//-------------------------------------------------------------------------
+
+	/** Query the physical resolution of the device in pixel per
+        millimeter. 
+
+        A special floating point value of +infinity here indicates
+        'unknown', i.e. at the time of rendering undetermined or
+        possibly infinite resolution along the corresponding
+        direction.
+	 */
+	::com::sun::star::geometry::RealSize2D	getPhysicalResolution();
+
+	//-------------------------------------------------------------------------
+
+	/** Query the physical dimensions of the device in millimeter. 
+
+        A special floating point value of +infinity here indicates
+        'unknown', i.e. at the time of rendering undetermined or
+        possibly infinite resolution along the corresponding
+        direction.
+
+        @see XBitmap::getSize()
+	 */
+	::com::sun::star::geometry::RealSize2D	getSize();
+
+	//-------------------------------------------------------------------------
+
+	/** Create a line poly-polygon which can internally use
+        device-optimized representations already.
+
+        @param points
+        The points of the poly-polygon, in a separate array for every polygon.
+	 */
+	XLinePolyPolygon2D 				createCompatibleLinePolyPolygon( [in] sequence< sequence< ::com::sun::star::geometry::RealPoint2D > > points );
+
+	//-------------------------------------------------------------------------
+
+	/** Create a bezier poly-polygon which can internally use
+        device-optimized representations already.
+
+        @param points
+        The points of the poly-polygon, in a separate array for every polygon.
+	 */
+	XBezierPolyPolygon2D 			createCompatibleBezierPolyPolygon( [in] sequence< sequence< ::com::sun::star::geometry::RealBezierSegment2D > > points );
+
+	//-------------------------------------------------------------------------
+
+	/** Create a bitmap whose memory layout and sample model is
+		compatible to the graphic device.
+
+        @param size
+        Size of the requested bitmap in pixel. Both components of the
+        size must be greater than 0
+	 */
+	XBitmap			 				createCompatibleBitmap( [in] ::com::sun::star::geometry::IntegerSize2D size )
+        raises (com::sun::star::lang::IllegalArgumentException); 
+
+	//-------------------------------------------------------------------------
+
+	/** Create a volatile bitmap that is usable with this graphic device.
+
+    	A volatile bitmap's difference in comparison to a plain bitmap
+    	(e.g. generated via createCompatibleBitmap()) is the fact that
+    	its content might vanish at any point in time (making any
+    	operation with them produce a
+    	<type>VolatileContentDestroyedException</type>). The benefit,
+    	on the other hand, is that they might be easy to
+    	hardware-accelerate on certain platforms, without the need to
+    	keep a safety copy of the content internally.
+
+        @param size
+        Size of the requested bitmap in pixel. Both components of the
+        size must be greater than 0
+	 */
+	XVolatileBitmap	 				createVolatileBitmap( [in] ::com::sun::star::geometry::IntegerSize2D size )
+        raises (com::sun::star::lang::IllegalArgumentException); 
+
+	//-------------------------------------------------------------------------
+
+	/** Create a bitmap with alpha channel whose memory layout and
+		sample model is compatible to the graphic device.
+
+        @param size
+        Size of the requested bitmap in pixel. Both components of the
+        size must be greater than 0
+	 */
+	XBitmap			 				createCompatibleAlphaBitmap( [in] ::com::sun::star::geometry::IntegerSize2D size )
+        raises (com::sun::star::lang::IllegalArgumentException); 
+
+	//-------------------------------------------------------------------------
+
+	/** Create a volatile bitmap with alpha channel that is usable
+        with this graphic device.
+
+    	A volatile bitmap's difference in comparison to a plain bitmap
+    	(e.g. generated via createCompatibleBitmap()) is the fact that
+    	its content might vanish at any point in time (making any
+    	operation with them produce a
+    	<type>VolatileContentDestroyedException</type>). The benefit,
+    	on the other hand, is that they might be easy to
+    	hardware-accelerate on certain platforms, without the need to
+    	keep a safety copy of the content internally.
+
+        @param size
+        Size of the requested bitmap in pixel. Both components of the
+        size must be greater than 0
+	 */
+	XVolatileBitmap	 				createVolatileAlphaBitmap( [in] ::com::sun::star::geometry::IntegerSize2D size )
+        raises (com::sun::star::lang::IllegalArgumentException); 
+
+	//-------------------------------------------------------------------------
+
+	/** Get a reference to this device's parametric polygon factory.
+
+    	@return a reference to this device's parametric polygon
+    	factory. Although it is possible to use parametric polygons on
+    	all canvases, regardless of the associated graphic device,
+    	this is not advisable: each canvas implementation is free to
+    	internally generate optimized parametric polygons, which can
+    	be used more directly for e.g. texturing operations.
+	 */
+    XParametricPolyPolygon2DFactory getParametricPolyPolygonFactory();
+
+	//-------------------------------------------------------------------------
+
+	/** Tells whether this graphic device has a full screen mode,
+		i.e. whether a window can cover the whole screen exclusively.
+	 */
+	boolean			 				hasFullScreenMode();
+
+	//-------------------------------------------------------------------------
+
+	/** Enter or leave the fullscreen mode, if possible. The return
+		value denotes the success of the operation.
+
+        @attention depending on the underlying operating system,
+        fullscreen mode can be left without a enterFullScreenMode(
+        false ) call.
+	 */
+	boolean							enterFullScreenMode( [in] boolean bEnter );
+};
+
+}; }; }; };
+
+#endif
--- /dev/null	2004-08-25 23:04:59.000000000 +0530
+++ offapi/com/sun/star/rendering/XHalfFloatBitmap.idl	2005-02-28 13:41:29.000000000 +0530
@@ -0,0 +1,165 @@
+/*************************************************************************
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
+ *
+ *  Copyright: 2000 by Sun Microsystems, Inc.
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+#ifndef __com_sun_star_rendering_XHalfFloatBitmap_idl__
+#define __com_sun_star_rendering_XHalfFloatBitmap_idl__
+
+#ifndef __com_sun_star_lang_IllegalArgumentException_idl__
+#include <com/sun/star/lang/IllegalArgumentException.idl>
+#endif 
+#ifndef __com_sun_star_lang_IndexOutOfBoundsException_idl__
+#include <com/sun/star/lang/IndexOutOfBoundsException.idl>
+#endif 
+#ifndef __com_sun_star_rendering_FloatingPointBitmapLayout_idl__
+#include <com/sun/star/rendering/FloatingPointBitmapLayout.idl>
+#endif
+#ifndef __com_sun_star_geometry_IntegerPoint2D_idl__
+#include <com/sun/star/geometry/IntegerPoint2D.idl>
+#endif
+#ifndef __com_sun_star_geometry_IntegerRectangle2D_idl__
+#include <com/sun/star/geometry/IntegerRectangle2D.idl>
+#endif
+#ifndef __com_sun_star_rendering_XBitmap_idl__
+#include <com/sun/star/rendering/XBitmap.idl>
+#endif
+#ifndef __com_sun_star_rendering_VolatileContentDestroyedException_idl__
+#include <com/sun/star/rendering/VolatileContentDestroyedException.idl>
+#endif
+
+module com { module sun { module star { module rendering {
+
+/** Specialized interface for bitmaps containing half floats as their
+    color components. Half floats are 16 bit wide, and some high-end
+    GPUs already have them as supported frame buffer format.
+ */
+interface XHalfFloatBitmap : XBitmap
+{
+	/** Query the raw data of this bitmap.
+
+    	Query the raw data of this bitmap, in the format as defined by
+    	getMemoryLayout(). With the given rectangle, a subset of the
+    	whole bitmap can be queried. When querying subsets of the
+    	bitmap, the same scanline padding takes place as when the
+    	whole bitmap is requested. Note: as we currently have no 16
+    	bit float UNO data type, the values are transported as 16 bit
+    	integers across the API (which requires casting on both
+    	sides).
+
+        @throws VolatileContentDestroyedException
+        if the bitmap is volatile, and the content has been destroyed by the system.
+	 */
+	sequence<short>				getData( [in] ::com::sun::star::geometry::IntegerRectangle2D rect )
+        raises (com::sun::star::lang::IndexOutOfBoundsException,
+                VolatileContentDestroyedException); 
+
+	//-------------------------------------------------------------------------
+
+	/** Set raw data of a bitmap.
+
+    	Set raw data of a bitmap, in the format as defined by
+    	getMemoryLayout(). With the given rectangle, a subset of the
+    	bitmap can be changed. When setting subsets of the bitmap, the
+    	same scanline padding takes place as when the whole bitmap is
+    	changed.<p>
+        
+	 */
+	void						setData( [in] sequence<short> data, [in] FloatingPointBitmapLayout bitmapLayout, [in] ::com::sun::star::geometry::IntegerRectangle2D rect )
+        raises (com::sun::star::lang::IllegalArgumentException,
+                com::sun::star::lang::IndexOutOfBoundsException); 
+
+	//-------------------------------------------------------------------------
+
+	/** Set a single pixel of the bitmap with the given color
+		value.
+
+        When setting data on volatile bitmaps, always call isValid()
+        before, and retrieve a new memory layout via
+        getMemoryLayout(). At least under Windows, the memory layout
+        can change for the same bitmap, if the user e.g. switches the
+        screen resolution. Thus, this method will throw an
+        IllegalArgumentException, if the memory layout changed between
+        a call to getMemoryLayout() and setData().
+	 */
+	void						setPixel( [in] sequence<short> color, [in] FloatingPointBitmapLayout bitmapLayout, [in] ::com::sun::star::geometry::IntegerPoint2D pos )
+        raises (com::sun::star::lang::IllegalArgumentException,
+                com::sun::star::lang::IndexOutOfBoundsException); 
+
+	//-------------------------------------------------------------------------
+
+	/** Get a single pixel of the bitmap, returning its color
+		value.
+
+        @throws VolatileContentDestroyedException
+        if the bitmap is volatile, and the content has been destroyed by the system.
+	 */
+	sequence<short>				getPixel( [in] ::com::sun::star::geometry::IntegerPoint2D pos )
+        raises (com::sun::star::lang::IndexOutOfBoundsException,
+                VolatileContentDestroyedException); 
+
+	//-------------------------------------------------------------------------
+
+	/** Query the memory layout for this bitmap
+	 */
+	FloatingPointBitmapLayout	getMemoryLayout();
+};
+
+}; }; }; };
+
+#endif
--- /dev/null	2004-08-25 23:04:59.000000000 +0530
+++ offapi/com/sun/star/rendering/XIeeeDoubleBitmap.idl	2005-02-28 13:41:29.000000000 +0530
@@ -0,0 +1,162 @@
+/*************************************************************************
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
+ *
+ *  Copyright: 2000 by Sun Microsystems, Inc.
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+#ifndef __com_sun_star_rendering_XIeeeDoubleBitmap_idl__
+#define __com_sun_star_rendering_XIeeeDoubleBitmap_idl__
+
+#ifndef __com_sun_star_lang_IllegalArgumentException_idl__
+#include <com/sun/star/lang/IllegalArgumentException.idl>
+#endif 
+#ifndef __com_sun_star_lang_IndexOutOfBoundsException_idl__
+#include <com/sun/star/lang/IndexOutOfBoundsException.idl>
+#endif 
+#ifndef __com_sun_star_rendering_FloatingPointBitmapLayout_idl__
+#include <com/sun/star/rendering/FloatingPointBitmapLayout.idl>
+#endif
+#ifndef __com_sun_star_geometry_IntegerPoint2D_idl__
+#include <com/sun/star/geometry/IntegerPoint2D.idl>
+#endif
+#ifndef __com_sun_star_geometry_IntegerRectangle2D_idl__
+#include <com/sun/star/geometry/IntegerRectangle2D.idl>
+#endif
+#ifndef __com_sun_star_rendering_XBitmap_idl__
+#include <com/sun/star/rendering/XBitmap.idl>
+#endif
+#ifndef __com_sun_star_rendering_VolatileContentDestroyedException_idl__
+#include <com/sun/star/rendering/VolatileContentDestroyedException.idl>
+#endif
+
+
+module com { module sun { module star { module rendering {
+
+/** This is a specialized interface for bitmaps containing IEEE
+    doubles for their color components.
+ */
+interface XIeeeDoubleBitmap : XBitmap
+{
+	/** Query the raw data of this bitmap.
+
+    	Query the raw data of this bitmap, in the format as defined by
+    	getMemoryLayout(). With the given rectangle, a subset of the
+    	whole bitmap can be queried. When querying subsets of the
+    	bitmap, the same scanline padding takes place as when the
+    	whole bitmap is requested.
+
+        @throws VolatileContentDestroyedException
+        if the bitmap is volatile, and the content has been destroyed by the system.
+	 */
+	sequence<double>			getData( [in] ::com::sun::star::geometry::IntegerRectangle2D rect )
+        raises (com::sun::star::lang::IndexOutOfBoundsException,
+                VolatileContentDestroyedException); 
+
+	//-------------------------------------------------------------------------
+
+	/** Set raw data of a bitmap.
+
+    	Set raw data of a bitmap, in the format as defined by
+    	getMemoryLayout(). With the given rectangle, a subset of the
+    	bitmap can be changed. When setting subsets of the bitmap, the
+    	same scanline padding takes place as when the whole bitmap is
+    	changed.<p>
+        
+	 */
+	void						setData( [in] sequence<double> data, [in] FloatingPointBitmapLayout bitmapLayout, [in] ::com::sun::star::geometry::IntegerRectangle2D rect )
+        raises (com::sun::star::lang::IllegalArgumentException,
+                com::sun::star::lang::IndexOutOfBoundsException); 
+
+	//-------------------------------------------------------------------------
+
+	/** Set a single pixel of the bitmap with the given color
+		value.
+
+        When setting data on volatile bitmaps, always call isValid()
+        before, and retrieve a new memory layout via
+        getMemoryLayout(). At least under Windows, the memory layout
+        can change for the same bitmap, if the user e.g. switches the
+        screen resolution. Thus, this method will throw an
+        IllegalArgumentException, if the memory layout changed between
+        a call to getMemoryLayout() and setData().
+	 */
+	void						setPixel( [in] sequence<double> color, [in] FloatingPointBitmapLayout bitmapLayout, [in] ::com::sun::star::geometry::IntegerPoint2D pos )
+        raises (com::sun::star::lang::IllegalArgumentException,
+                com::sun::star::lang::IndexOutOfBoundsException); 
+
+	//-------------------------------------------------------------------------
+
+	/** Get a single pixel of the bitmap, returning its color
+		value.
+
+        @throws VolatileContentDestroyedException
+        if the bitmap is volatile, and the content has been destroyed by the system.
+	 */
+	sequence<double>			getPixel( [in] ::com::sun::star::geometry::IntegerPoint2D pos )
+        raises (com::sun::star::lang::IndexOutOfBoundsException,
+                VolatileContentDestroyedException); 
+
+	//-------------------------------------------------------------------------
+
+	/** Query the memory layout for this bitmap
+	 */
+	FloatingPointBitmapLayout	getMemoryLayout();
+};
+
+}; }; }; };
+
+#endif
--- /dev/null	2004-08-25 23:04:59.000000000 +0530
+++ offapi/com/sun/star/rendering/XIeeeFloatBitmap.idl	2005-02-28 13:41:29.000000000 +0530
@@ -0,0 +1,162 @@
+/*************************************************************************
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
+ *
+ *  Copyright: 2000 by Sun Microsystems, Inc.
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+#ifndef __com_sun_star_rendering_XIeeeFloatBitmap_idl__
+#define __com_sun_star_rendering_XIeeeFloatBitmap_idl__
+
+#ifndef __com_sun_star_lang_IllegalArgumentException_idl__
+#include <com/sun/star/lang/IllegalArgumentException.idl>
+#endif 
+#ifndef __com_sun_star_lang_IndexOutOfBoundsException_idl__
+#include <com/sun/star/lang/IndexOutOfBoundsException.idl>
+#endif 
+#ifndef __com_sun_star_rendering_FloatingPointBitmapLayout_idl__
+#include <com/sun/star/rendering/FloatingPointBitmapLayout.idl>
+#endif
+#ifndef __com_sun_star_geometry_IntegerPoint2D_idl__
+#include <com/sun/star/geometry/IntegerPoint2D.idl>
+#endif
+#ifndef __com_sun_star_geometry_IntegerRectangle2D_idl__
+#include <com/sun/star/geometry/IntegerRectangle2D.idl>
+#endif
+#ifndef __com_sun_star_rendering_XBitmap_idl__
+#include <com/sun/star/rendering/XBitmap.idl>
+#endif
+#ifndef __com_sun_star_rendering_VolatileContentDestroyedException_idl__
+#include <com/sun/star/rendering/VolatileContentDestroyedException.idl>
+#endif
+
+
+module com { module sun { module star { module rendering {
+
+/** Specialized interface for bitmaps containing IEEE floats as their
+    color components.
+ */
+interface XIeeeFloatBitmap : XBitmap
+{
+	/** Query the raw data of this bitmap.
+
+    	Query the raw data of this bitmap, in the format as defined by
+    	getMemoryLayout(). With the given rectangle, a subset of the
+    	whole bitmap can be queried. When querying subsets of the
+    	bitmap, the same scanline padding takes place as when the
+    	whole bitmap is requested.
+
+        @throws VolatileContentDestroyedException
+        if the bitmap is volatile, and the content has been destroyed by the system.
+	 */
+	sequence<float>				getData( [in] ::com::sun::star::geometry::IntegerRectangle2D rect )
+        raises (com::sun::star::lang::IndexOutOfBoundsException,
+                VolatileContentDestroyedException); 
+
+	//-------------------------------------------------------------------------
+
+	/** Set raw data of a bitmap.
+
+    	Set raw data of a bitmap, in the format as defined by
+    	getMemoryLayout(). With the given rectangle, a subset of the
+    	bitmap can be changed. When setting subsets of the bitmap, the
+    	same scanline padding takes place as when the whole bitmap is
+    	changed.<p>
+        
+	 */
+	void						setData( [in] sequence<float> data, [in] FloatingPointBitmapLayout bitmapLayout, [in] ::com::sun::star::geometry::IntegerRectangle2D rect )
+        raises (com::sun::star::lang::IllegalArgumentException,
+                com::sun::star::lang::IndexOutOfBoundsException); 
+
+	//-------------------------------------------------------------------------
+
+	/** Set a single pixel of the bitmap with the given color
+		value.
+
+        When setting data on volatile bitmaps, always call isValid()
+        before, and retrieve a new memory layout via
+        getMemoryLayout(). At least under Windows, the memory layout
+        can change for the same bitmap, if the user e.g. switches the
+        screen resolution. Thus, this method will throw an
+        IllegalArgumentException, if the memory layout changed between
+        a call to getMemoryLayout() and setData().
+	 */
+	void						setPixel( [in] sequence<float> color, [in] FloatingPointBitmapLayout bitmapLayout, [in] ::com::sun::star::geometry::IntegerPoint2D pos )
+        raises (com::sun::star::lang::IllegalArgumentException,
+                com::sun::star::lang::IndexOutOfBoundsException); 
+
+	//-------------------------------------------------------------------------
+
+	/** Get a single pixel of the bitmap, returning its color
+		value.
+
+        @throws VolatileContentDestroyedException
+        if the bitmap is volatile, and the content has been destroyed by the system.
+	 */
+	sequence<float>				getPixel( [in] ::com::sun::star::geometry::IntegerPoint2D pos )
+        raises (com::sun::star::lang::IndexOutOfBoundsException,
+                VolatileContentDestroyedException); 
+
+	//-------------------------------------------------------------------------
+
+	/** Query the memory layout for this bitmap
+	 */
+	FloatingPointBitmapLayout	getMemoryLayout();
+};
+
+}; }; }; };
+
+#endif
--- /dev/null	2004-08-25 23:04:59.000000000 +0530
+++ offapi/com/sun/star/rendering/XIntegerBitmap.idl	2005-02-28 13:41:29.000000000 +0530
@@ -0,0 +1,189 @@
+/*************************************************************************
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
+ *
+ *  Copyright: 2000 by Sun Microsystems, Inc.
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+#ifndef __com_sun_star_rendering_XIntegerBitmap_idl__
+#define __com_sun_star_rendering_XIntegerBitmap_idl__
+
+#ifndef __com_sun_star_lang_IllegalArgumentException_idl__
+#include <com/sun/star/lang/IllegalArgumentException.idl>
+#endif 
+#ifndef __com_sun_star_lang_IndexOutOfBoundsException_idl__
+#include <com/sun/star/lang/IndexOutOfBoundsException.idl>
+#endif 
+#ifndef __com_sun_star_geometry_IntegerPoint2D_idl__
+#include <com/sun/star/geometry/IntegerPoint2D.idl>
+#endif
+#ifndef __com_sun_star_geometry_IntegerRectangle2D_idl__
+#include <com/sun/star/geometry/IntegerRectangle2D.idl>
+#endif
+#ifndef __com_sun_star_rendering_IntegerBitmapLayout_idl__
+#include <com/sun/star/rendering/IntegerBitmapLayout.idl>
+#endif
+#ifndef __com_sun_star_rendering_XBitmap_idl__
+#include <com/sun/star/rendering/XBitmap.idl>
+#endif
+#ifndef __com_sun_star_rendering_VolatileContentDestroyedException_idl__
+#include <com/sun/star/rendering/VolatileContentDestroyedException.idl>
+#endif
+
+
+module com { module sun { module star { module rendering {
+
+interface XBitmapPalette;
+
+/** This is a specialized interface for bitmaps having integer color
+    channels.
+ */
+interface XIntegerBitmap : XBitmap
+{		  
+	/** Query the raw data of this bitmap.
+
+    	Query the raw data of this bitmap, in the format as defined by
+    	getMemoryLayout(). With the given rectangle, a subset of the
+    	whole bitmap can be queried. If the internal data format's
+    	pixel are not integer multiples of bytes (i.e. if one pixel
+    	occupies less than a byte), the leftover content of the bytes
+    	at the right of each scanline is filled with zero. When
+    	querying subsets of the bitmap, the same scanline padding
+    	takes place as when the whole bitmap is requested.
+
+        @throws VolatileContentDestroyedException
+        if the bitmap is volatile, and the content has been destroyed by the system.
+	 */
+	sequence<byte> 		getData( [in] ::com::sun::star::geometry::IntegerRectangle2D rect )
+        raises (com::sun::star::lang::IndexOutOfBoundsException,
+                VolatileContentDestroyedException); 
+
+	//-------------------------------------------------------------------------
+
+	/** Set raw data of a bitmap.
+
+		Set raw data of a bitmap, in the format as defined by
+		getMemoryLayout(). With the given rectangle, a subset of the
+		bitmap can be changed. If the internal data format's pixel are
+		not integer multiples of bytes (i.e. if one pixel occupies
+		less than a byte), the leftover content of the bytes at the
+		right of each scanline is ignored and left unchanged in the
+		bitmap. When setting subsets of the bitmap, the same scanline
+		padding takes place as when the whole bitmap is changed.<P>
+        
+	 */
+	void				setData( [in] sequence<byte> data, [in] IntegerBitmapLayout bitmapLayout, [in] ::com::sun::star::geometry::IntegerRectangle2D rect )
+        raises (com::sun::star::lang::IllegalArgumentException,
+                com::sun::star::lang::IndexOutOfBoundsException); 
+
+	//-------------------------------------------------------------------------
+
+	/** Set a single pixel of the bitmap with the given color
+		value. 
+
+        If the internal data format's pixel are not integer multiples
+        of bytes (i.e. if one pixel occupies less than a byte), the
+        color value is expected in the least significant bits of the
+        single byte given as the color.<p>
+
+        When setting data on volatile bitmaps, always call isValid()
+        before, and retrieve a new memory layout via
+        getMemoryLayout(). At least under Windows, the memory layout
+        can change for the same bitmap, if the user e.g. switches the
+        screen resolution. Thus, this method will throw an
+        IllegalArgumentException, if the memory layout changed between
+        a call to getMemoryLayout() and setData().
+	 */
+	void				setPixel( [in] sequence<byte> color, [in] IntegerBitmapLayout bitmapLayout, [in] ::com::sun::star::geometry::IntegerPoint2D pos )
+        raises (com::sun::star::lang::IllegalArgumentException,
+                com::sun::star::lang::IndexOutOfBoundsException); 
+
+	//-------------------------------------------------------------------------
+
+	/** Get a single pixel of the bitmap, returning its color
+		value. 
+
+		If the internal data format's pixel are not integer multiples
+		of bytes (i.e. if one pixel occupies less than a byte), the
+		color value is returned in the least significant bits of the
+		single byte returned as the color.
+
+        @throws VolatileContentDestroyedException
+        if the bitmap is volatile, and the content has been destroyed by the system.
+	 */
+	sequence<byte>		getPixel( [in] ::com::sun::star::geometry::IntegerPoint2D pos )
+        raises (com::sun::star::lang::IndexOutOfBoundsException,
+                VolatileContentDestroyedException); 
+
+	//-------------------------------------------------------------------------
+
+	/** Query the associated palette for this bitmap. 
+
+    	Returns empty interface or interface with empty palette for
+    	non-paletted bitmaps.
+	 */
+	XBitmapPalette		getPalette();
+
+	//-------------------------------------------------------------------------
+
+	/** Query the memory layout for this bitmap
+	 */
+	IntegerBitmapLayout	getMemoryLayout();
+};
+
+}; }; }; };
+
+#endif
--- /dev/null	2004-08-25 23:04:59.000000000 +0530
+++ offapi/com/sun/star/rendering/XLinePolyPolygon2D.idl	2005-02-28 13:41:29.000000000 +0530
@@ -0,0 +1,138 @@
+/*************************************************************************
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
+ *
+ *  Copyright: 2000 by Sun Microsystems, Inc.
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+#ifndef __com_sun_star_rendering_XLinePolyPolygon2D_idl__
+#define __com_sun_star_rendering_XLinePolyPolygon2D_idl__
+
+#ifndef __com_sun_star_uno_XInterface_idl__ 
+#include <com/sun/star/uno/XInterface.idl> 
+#endif 
+#ifndef __com_sun_star_lang_IndexOutOfBoundsException_idl__
+#include <com/sun/star/lang/IndexOutOfBoundsException.idl>
+#endif 
+#ifndef __com_sun_star_geometry_RealPoint2D_idl__
+#include <com/sun/star/geometry/RealPoint2D.idl>
+#endif
+#ifndef __com_sun_star_rendering_XPolyPolygon2D_idl__
+#include <com/sun/star/rendering/XPolyPolygon2D.idl>
+#endif
+
+module com { module sun { module star { module rendering {
+
+/** Specialized interface for a 2D poly-polygon containing only straight line segments.
+ */
+interface XLinePolyPolygon2D : XPolyPolygon2D
+{
+	/** Query subset of this poly-polygon, starting at the given
+		polygon and the given point within that polygon, and
+		containing the specified number of polygons and points in the
+		last polygon. 
+
+        @param nPolygonIndex
+        The index number of the polygon to start with extracting
+        points. Set to 0 to start with the first polygon.
+
+        @param nNumberOfPolygons
+        The number of polygons, starting with nPolygonIndex, to
+        extract points from. Set to -1 to extract all polygons,
+        starting with nPolygonIndex (i.e. a total of
+        getNumberOfPolygons() - nPolygonIndex polygons is extracted).
+
+        @param nPointIndex
+        The index of the point within the first polygon (that with the
+        index number nPolygonIndex) to start extraction with. Set to 0
+        to start with the first point in this polygon.
+
+        @param nNumberOfPoints
+        The number of points in the last polygon of the extraction
+        sequence, to be extracted. Set to -1 to extract all points
+        from the last polygon.
+	 */
+	sequence< sequence< ::com::sun::star::geometry::RealPoint2D > > getPoints( [in] long nPolygonIndex, [in] long nNumberOfPolygons, [in] long nPointIndex, [in] long nNumberOfPoints )
+        raises (com::sun::star::lang::IndexOutOfBoundsException); 
+
+	//-------------------------------------------------------------------------
+
+	/** Set the specified subset of points to the poly-polygon. The
+		subset of poly-polygon points not included in this sequence
+		remains unchanged.
+	 */
+	void										setPoints( [in] sequence< sequence< ::com::sun::star::geometry::RealPoint2D > > points, [in] long nPolygonIndex, [in] long nPointIndex )
+        raises (com::sun::star::lang::IndexOutOfBoundsException); 
+
+	//-------------------------------------------------------------------------
+
+	/** Get a single point from the poly-polygon
+	 */
+	::com::sun::star::geometry::RealPoint2D	getPoint( [in] long nPolygonIndex, [in] long nPointIndex )
+        raises (com::sun::star::lang::IndexOutOfBoundsException); 
+
+	//-------------------------------------------------------------------------
+
+	/** Set a single point on the poly-polygon. The remaining points of
+		the poly-polygon will not be changed by this method.
+	 */
+	void										setPoint( [in] ::com::sun::star::geometry::RealPoint2D point, [in] long nPolygonIndex, [in] long nPointIndex )
+        raises (com::sun::star::lang::IndexOutOfBoundsException); 
+};
+
+}; }; }; };
+
+#endif
--- /dev/null	2004-08-25 23:04:59.000000000 +0530
+++ offapi/com/sun/star/rendering/XParametricPolyPolygon2DFactory.idl	2005-02-28 13:41:29.000000000 +0530
@@ -0,0 +1,185 @@
+/*************************************************************************
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
+ *
+ *  Copyright: 2000 by Sun Microsystems, Inc.
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+#ifndef __com_sun_star_rendering_XParametricPolyPolygon2DFactory_idl__
+#define __com_sun_star_rendering_XParametricPolyPolygon2DFactory_idl__
+
+#ifndef __com_sun_star_uno_XInterface_idl__ 
+#include <com/sun/star/uno/XInterface.idl> 
+#endif 
+#ifndef __com_sun_star_lang_IllegalArgumentException_idl__
+#include <com/sun/star/lang/IllegalArgumentException.idl>
+#endif 
+#ifndef __com_sun_star_geometry_RealRectangle2D_idl__
+#include <com/sun/star/geometry/RealRectangle2D.idl>
+#endif
+#ifndef __com_sun_star_rendering_XColorSpace_idl__
+#include <com/sun/star/rendering/XColorSpace.idl>
+#endif
+
+
+module com { module sun { module star { module rendering {
+
+interface XParametricPolyPolygon2D;
+
+/** This interface provides factory methods to generate various
+    ready-made XParametricPolyPolygon2Ds
+ */
+interface XParametricPolyPolygon2DFactory : ::com::sun::star::uno::XInterface
+{
+    /** Create a linear gradient.
+
+		The gradient varies linearly between leftColor and rightColor
+		in the x direction, and has constant color for fixed x
+		coordinate value in y direction
+     */
+    XParametricPolyPolygon2D	createLinearHorizontalGradient( [in] sequence<ColorComponent> leftColor, [in] sequence<ColorComponent> rightColor )
+        raises (com::sun::star::lang::IllegalArgumentException); 
+
+    /** Create an axial gradient.
+
+		The gradient has middleColor in the middle, and varies
+		linearly between middleColor and endColor to both sides in the
+		x direction. For fixed x coordinate, the gradient has constant
+		color value in y direction.
+     */
+    XParametricPolyPolygon2D	createAxialHorizontalGradient( [in] sequence<ColorComponent> middleColor, [in] sequence<ColorComponent> endColor )
+        raises (com::sun::star::lang::IllegalArgumentException); 
+
+    /** Create an elliptical gradient.
+
+		The gradient has centerColor in the middle, and varies
+		linearly between center and endColor via concentric ellipses
+		around the center point. Note that the absolute size of the
+		rectangle given at this method does not matter, only it's
+		aspect ratio: if this aspect ratio s 1, the gradient is
+		circular. If it's not 1, the gradient is elliptical, with the
+		special twist that the aspect ratio is maintained also for the
+		center color: the gradient will not collapse into a single
+		point, but become a line of center color.
+     */
+    XParametricPolyPolygon2D	createEllipticalGradient( [in] sequence<ColorComponent> centerColor, [in] sequence<ColorComponent> endColor, [in] ::com::sun::star::geometry::RealRectangle2D boundRect )
+        raises (com::sun::star::lang::IllegalArgumentException); 
+
+    /** Create a rectangular gradient.
+
+		The gradient has centerColor in the middle, and varies
+		linearly between center and endColor via rectangular boxes
+		around the center point. Note that the absolute size of the
+		rectangle given at this method does not matter, only it's
+		aspect ratio: if this aspect ratio s 1, the gradient is
+		quadratic. If it's not 1, the gradient is rectangular, with
+		the special twist that the aspect ratio is maintained also for
+		the center color: the gradient will not collapse into a single
+		point, but become a line of center color.
+     */
+    XParametricPolyPolygon2D	createRectangularGradient( [in] sequence<ColorComponent> centerColor, [in] sequence<ColorComponent> endColor, [in] ::com::sun::star::geometry::RealRectangle2D boundRect )
+        raises (com::sun::star::lang::IllegalArgumentException); 
+
+    /** Create a line hash of vertical lines.
+
+    	The hashing consists of vertical lines, with colors varying
+    	linearly between leftColor and rightColor, when going from
+    	left to right
+     */
+    XParametricPolyPolygon2D	createVerticalLinesHatch( [in] sequence<ColorComponent> leftColor, [in] sequence<ColorComponent> rightColor )
+        raises (com::sun::star::lang::IllegalArgumentException); 
+
+    /** Create a line hash of orthogonally crossing lines.
+
+    	The hashing consists of vertical and horizontal lines, with
+    	colors varying linearly between leftTopColor and
+    	rightBottomColor, when going from left to right (for the
+    	vertical lines) and from top tzo bottom (for the horizontal
+    	lines).
+     */
+    XParametricPolyPolygon2D	createOrthogonalLinesHatch( [in] sequence<ColorComponent> leftTopColor, [in] sequence<ColorComponent> rightBottomColor )
+        raises (com::sun::star::lang::IllegalArgumentException); 
+
+    /** Create a repeating line hash pattern of three crossing lines.
+
+    	The hashing consists of vertical and horizontal lines plus
+    	diagonal lines from left, top to bottom, right. Each of the
+    	three groups of lines varies the line color of distinct lines
+    	linearly from startColor to endColor, starting at the leftmost
+    	or topmost position.
+     */
+    XParametricPolyPolygon2D	createThreeCrossingLinesHatch( [in] sequence<ColorComponent> startColor, [in] sequence<ColorComponent> endColor )
+        raises (com::sun::star::lang::IllegalArgumentException); 
+
+    /** Create a repeating line hash pattern of four crossing lines.
+
+    	The hashing consists of vertical and horizontal lines plus
+    	diagonal lines in both directions. Each of the four groups of
+    	lines varies the line color of distinct lines linearly from
+    	startColor to endColor, starting at the leftmost or topmost
+    	position.
+     */
+    XParametricPolyPolygon2D	createFourCrossingLinesHatch( [in] sequence<ColorComponent> startColor, [in] sequence<ColorComponent> endColor )
+        raises (com::sun::star::lang::IllegalArgumentException); 
+};
+
+//=============================================================================
+
+service ParametricPolyPolygon2DFactory: XParametricPolyPolygon2DFactory;
+
+}; }; }; };
+
+#endif
--- /dev/null	2004-08-25 23:04:59.000000000 +0530
+++ offapi/com/sun/star/rendering/XParametricPolyPolygon2D.idl	2005-02-28 13:41:29.000000000 +0530
@@ -0,0 +1,133 @@
+/*************************************************************************
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
+ *
+ *  Copyright: 2000 by Sun Microsystems, Inc.
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+#ifndef __com_sun_star_rendering_XParametricPolyPolygon2D_idl__
+#define __com_sun_star_rendering_XParametricPolyPolygon2D_idl__
+
+#ifndef __com_sun_star_uno_XInterface_idl__ 
+#include <com/sun/star/uno/XInterface.idl> 
+#endif 
+#ifndef __com_sun_star_lang_IllegalArgumentException_idl__
+#include <com/sun/star/lang/IllegalArgumentException.idl>
+#endif 
+#ifndef __com_sun_star_geometry_RealPoint2D_idl__
+#include <com/sun/star/geometry/RealPoint2D.idl>
+#endif
+#ifndef __com_sun_star_rendering_XPolyPolygon2D_idl__
+#include <com/sun/star/rendering/XPolyPolygon2D.idl>
+#endif
+#ifndef __com_sun_star_rendering_XColorSpace_idl__
+#include <com/sun/star/rendering/XColorSpace.idl>
+#endif
+
+module com { module sun { module star { module rendering {
+
+/** Interface to a dynamic poly-polygon generator, that generates
+    poly-polygons depending on a given parameter value.<p>
+
+    The returned poly-polygon should normally be contained in the
+    [0,1]x[0,1] rectangle. At least that is the dimension expected at
+    other places. e.g. <type>Texture</type>.
+ */
+interface XParametricPolyPolygon2D : ::com::sun::star::uno::XInterface
+{
+	/** Query the polygonal outline at the specified value. 
+
+		The returned outline should be clipped to the [0,1]x[0,1]
+		rectangle.
+	
+		@param t
+		Parameter value in the range [0,1]. During painting, this
+		range is sweeped through starting from 0. When using such a
+		parametric polypolygon for gradients, the area covered by the
+		returned XPolyPolygon2D should be monotonically decreasing
+		with t (unless singularities in e.g. the resulting gradient
+		are desired).
+	 */
+	XPolyPolygon2D 				getOutline( [in] double t )
+        raises (com::sun::star::lang::IllegalArgumentException); 
+
+	//-------------------------------------------------------------------------
+
+	/** Query the color value for the polygonal area at the specified
+		parameter value.
+
+		@param t
+		Parameter value in the range [0,1]. During painting, this
+		range is swept through starting from 0.
+	 */
+	sequence<ColorComponent> 	getColor( [in] double t )
+        raises (com::sun::star::lang::IllegalArgumentException); 
+
+	//-------------------------------------------------------------------------
+
+	/** Query the color for a dedicated point in the plane. 
+	
+		@param point
+		The permissible parameter range for point is [0,1]x[0,1]
+	 */
+	sequence<ColorComponent>	getPointColor( [in] ::com::sun::star::geometry::RealPoint2D point )
+        raises (com::sun::star::lang::IllegalArgumentException); 
+
+};
+
+}; }; }; };
+
+#endif
--- /dev/null	2004-08-25 23:04:59.000000000 +0530
+++ offapi/com/sun/star/rendering/XPolyPolygon2D.idl	2005-02-28 13:41:29.000000000 +0530
@@ -0,0 +1,147 @@
+/*************************************************************************
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
+ *
+ *  Copyright: 2000 by Sun Microsystems, Inc.
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+#ifndef __com_sun_star_rendering_XPolyPolygon2D_idl__
+#define __com_sun_star_rendering_XPolyPolygon2D_idl__
+
+#ifndef __com_sun_star_uno_XInterface_idl__ 
+#include <com/sun/star/uno/XInterface.idl> 
+#endif 
+#ifndef __com_sun_star_lang_IllegalArgumentException_idl__
+#include <com/sun/star/lang/IllegalArgumentException.idl>
+#endif 
+#ifndef __com_sun_star_rendering_FillRule_idl__
+#include <com/sun/star/rendering/FillRule.idl>
+#endif
+#ifndef __com_sun_star_geometry_RealPoint2D_idl__
+#include <com/sun/star/geometry/RealPoint2D.idl>
+#endif
+
+module com { module sun { module star { module rendering {
+
+/** Generic interface for poly-polygons in 2D.
+ */
+interface XPolyPolygon2D : ::com::sun::star::uno::XInterface
+{
+	/** Add the specified poly-polygon at the given position. 
+
+    	One can do symbolic path construction with this method. The
+    	poly-polygons added by this method are not joined in the sense
+    	that they participate in mutual fill rule calculations like
+    	the polygons inside a single poly-polygon do. When rendering
+    	such a poly-polygon without transparency, it will look like the
+    	constituing poly-polygons rendered separately on top of
+    	another. Alas, when rendering with transparency, separate
+    	rendering will combine the alpha of overlapping areas, whereas
+    	addPolyPolygon results in constant alpha, regardless how many
+    	internal poly-polygons overlap at a single place.
+	 */
+	void		addPolyPolygon( [in] ::com::sun::star::geometry::RealPoint2D position, [in] XPolyPolygon2D polyPolygon );
+
+	//-------------------------------------------------------------------------
+
+	/** Query number of polygons inside this poly-polygon
+	 */
+	long		getNumberOfPolygons();
+
+	//-------------------------------------------------------------------------
+
+	/** Query number of points inside given polygon
+
+    	@param polygon
+        The index of the polygon to query the number of points
+        for. Must be in the range [0,getNumberOfPolygons()-1].
+	 */
+	long		getNumberOfPolygonPoints( [in] long polygon )
+        raises (com::sun::star::lang::IllegalArgumentException); 
+
+	//-------------------------------------------------------------------------
+
+	/** Query the rule used to determine inside and outside of the
+        poly-polygon.
+	 */
+	FillRule	getFillRule();
+
+	//-------------------------------------------------------------------------
+
+	/** Set the rule used to determine inside and outside of the
+        poly-polygon.
+	 */
+	void		setFillRule( [in] FillRule fillRule );
+
+	//-------------------------------------------------------------------------
+
+	/** Query whether the specified polygon outline is closed.
+	 */
+	boolean		isClosed( [in] long index )
+        raises (com::sun::star::lang::IllegalArgumentException); 
+
+	//-------------------------------------------------------------------------
+
+	/** Set the close state of the specified polygon outline. Use -1
+        as the index to affect all polygons of this poly-polygon.
+	 */
+	void		setClosed( [in] long index, [in] boolean closedState )
+        raises (com::sun::star::lang::IllegalArgumentException); 
+};
+
+}; }; }; };
+
+#endif
--- /dev/null	2004-08-25 23:04:59.000000000 +0530
+++ offapi/com/sun/star/rendering/XSpriteCanvas.idl	2005-02-28 13:41:29.000000000 +0530
@@ -0,0 +1,189 @@
+/*************************************************************************
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
+ *
+ *  Copyright: 2000 by Sun Microsystems, Inc.
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+#ifndef __com_sun_star_rendering_XSpriteCanvas_idl__
+#define __com_sun_star_rendering_XSpriteCanvas_idl__
+
+#ifndef __com_sun_star_lang_IllegalArgumentException_idl__
+#include <com/sun/star/lang/IllegalArgumentException.idl>
+#endif 
+#ifndef __com_sun_star_rendering_XBitmapCanvas_idl__
+#include <com/sun/star/rendering/XBitmapCanvas.idl>
+#endif
+#ifndef __com_sun_star_rendering_XAnimation_idl__
+#include <com/sun/star/rendering/XAnimation.idl>
+#endif
+#ifndef __com_sun_star_rendering_VolatileContentDestroyedException_idl__
+#include <com/sun/star/rendering/VolatileContentDestroyedException.idl>
+#endif
+
+module com { module sun { module star { module rendering {
+
+interface XSprite;
+interface XAnimatedSprite;
+interface XCustomSprite;
+
+/** Specialization of a XBitmapCanvas, where moving, animated objects
+    (called sprites) are supported.    
+
+    @attention The screen output of canvas drawing operations is
+    undefined, unless XSpriteCanvas::updateScreen() is called. This is
+    because a sprite canvas might choose to employ double buffering to
+    reduce animation flicker, and cannot know the instant suitable to
+    display the newly rendered canvas content. When using external
+    double-buffering via XBufferController on a sprite canvas, the
+    implementation takes care of this issue, and in this case is able
+    to render correctly even without explicit updateScreen() calls
+    (because there's a defined moment in time where content display
+    can happen, namely the XBufferController::showBuffer()) call. If
+    you don't need sprite functionality, and don't want the
+    updateScreen hassle, simply use the XBitmapCanvas.
+ */
+interface XSpriteCanvas : XBitmapCanvas
+{
+	/** Create a sprite object from the specified animation
+		sequence. A sprite is a back-buffered object with its own,
+		independent animation.
+	 */	
+	XAnimatedSprite	createSpriteFromAnimation( [in] XAnimation animation )
+        raises (com::sun::star::lang::IllegalArgumentException); 
+
+	/** Create a sprite object from the specified animation
+		sequence.
+
+        A sprite is a back-buffered object with its own,
+		independent animation.
+        
+        @param animationBitmaps
+        Sequence of bitmaps. The bitmaps don't need to have the same
+        size, but they are all rendered with their left, top edges
+        aligned.
+
+        @param interpolationMode
+        Value of <type>InterpolationMode</type>, to determine whether
+        and how to interpolate between the provided bitmaps, if
+        animation runs fast enough.
+
+        @throws VolatileContentDestroyedException
+        if at least one of the bitmap is volatile, and its content has been destroyed by the system.
+	 */	
+	XAnimatedSprite	createSpriteFromBitmaps( [in] sequence<XBitmap> animationBitmaps, [in] byte interpolationMode )
+        raises (com::sun::star::lang::IllegalArgumentException,
+                VolatileContentDestroyedException); 
+
+	/** Create a custom, user-handles-it-all sprite object. 
+
+		A sprite is a back-buffered object with its own, independent
+		animation.
+
+        @param spriteSize
+        The required size of the sprite in device
+        coordinates. Everything that is rendered outside this area
+        might be clipped on output. Both components of the size must
+        be greater than zero.
+
+        @return an interface to a custom sprite object.
+	 */	
+	XCustomSprite createCustomSprite( [in] ::com::sun::star::geometry::RealSize2D spriteSize )
+        raises (com::sun::star::lang::IllegalArgumentException); 
+
+	/** Create a cloned version of an already existing sprite
+        object.
+
+        The cloned sprite always shows the same content as its
+        original. Furthermore, cloned copies of a hidden original are
+        never visible, although cloned copies of a visible original
+        can of course be invisible.
+
+        @param original
+        The original sprite to copy the content from. This sprite must
+        have been created by the same XSpriteCanvas instance as this
+        method is called on. Other sprite instances will generate an
+        IllegalArgumentException.
+
+        @return an interface to a sprite object.
+	 */	
+	XSprite createClonedSprite( [in] XSprite original )
+        raises (com::sun::star::lang::IllegalArgumentException); 
+
+    /** Tells the sprite canvas to now update the screen
+     	representation.
+        
+        Required to display rendered changes to the canvas, and
+        updates to stopped animations and XCustomSprites in
+        general. This method will return only after the screen update
+        is done, or earlier if an error happened.
+
+        @param bUpdateAll
+        When <TRUE>, update the whole screen. When <FALSE>,
+        implementation is permitted to restrict update to areas the
+        canvas itself changed (e.g. because of render operations, or
+        changes on the sprites). The former is useful for updates
+        after window expose events. the latter for animation display.
+
+        @return <TRUE>, if the screen update was successfully
+        performed
+     */
+    boolean updateScreen( [in] boolean bUpdateAll );
+};
+
+}; }; }; };
+
+#endif
--- /dev/null	2004-08-25 23:04:59.000000000 +0530
+++ offapi/com/sun/star/rendering/XSprite.idl	2005-02-28 13:41:29.000000000 +0530
@@ -0,0 +1,237 @@
+/*************************************************************************
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
+ *
+ *  Copyright: 2000 by Sun Microsystems, Inc.
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+#ifndef __com_sun_star_rendering_XSprite_idl__
+#define __com_sun_star_rendering_XSprite_idl__
+
+#ifndef __com_sun_star_uno_XInterface_idl__ 
+#include <com/sun/star/uno/XInterface.idl> 
+#endif 
+#ifndef __com_sun_star_lang_IllegalArgumentException_idl__
+#include <com/sun/star/lang/IllegalArgumentException.idl>
+#endif 
+#ifndef __com_sun_star_geometry_RealPoint2D_idl__
+#include <com/sun/star/geometry/RealPoint2D.idl>
+#endif
+#ifndef __com_sun_star_geometry_AffineMatrix2D_idl__
+#include <com/sun/star/geometry/AffineMatrix2D.idl>
+#endif
+#ifndef __com_sun_star_rendering_ViewState_idl__
+#include <com/sun/star/rendering/ViewState.idl>
+#endif
+#ifndef __com_sun_star_rendering_RenderState_idl__
+#include <com/sun/star/rendering/RenderState.idl>
+#endif
+
+module com { module sun { module star { module rendering {
+
+/** Interface to control a sprite object.<p>
+
+	This is the basic interface to control a sprite object on a
+	<type>XSpriteCanvas</type>. Sprites are moving, back-buffered
+	objects.<p>
+ */
+interface XSprite : ::com::sun::star::uno::XInterface
+{
+	/** Set overall transparency of the sprite.<p>
+
+		This method is useful for e.g. fading in/out of animations.<p>
+
+        Please note that if this sprite is not animated, the
+        associated <type>XSpriteCanvas</type> does not update changed
+        sprites automatically, but has to be told to do so via
+        <member>XSpriteCanvas::updateScreen()</member>.<p>
+
+        @param nAlpha
+        New global alpha value to composite this sprite with the
+        background. Valid range is [0,1].
+
+        @throws com::sun::star::lang::IllegalArgumentException
+        if nAlpha is not within the permissible range.        
+	 */
+	void setAlpha( [in] double nAlpha )
+        raises (com::sun::star::lang::IllegalArgumentException); 
+
+	//-------------------------------------------------------------------------
+
+	/** Move sprite to the specified position.<p>
+
+		The position specified here is first transformed by the
+		combined view and render transformation. The resulting
+		position is then used as the output position (also in device
+		coordinates) of the rendered sprite content.<p>
+
+        Please note that if this sprite is not animated, the
+        associated <type>XSpriteCanva</type> does not update changed sprites
+        automatically, but has to be told to do so via
+        <member>XSpriteCanvas::updateScreen()</member>.<p>
+
+        @param aNewPos
+        The new position, in user coordinate space, to move the sprite to.
+
+        @param aViewState
+        The viewstate to be used when interpreting aNewPos.
+
+        @param aRenderState
+        The renderstate to be used when interpreting aNewPos.
+
+        @throws com::sun::star::lang::IllegalArgumentException
+        if one of the view and renderstate parameters are outside the 
+        specified range.        
+	 */
+	void move( [in] ::com::sun::star::geometry::RealPoint2D aNewPos, [in] ViewState aViewState, [in] RenderState aRenderState )
+        raises (com::sun::star::lang::IllegalArgumentException); 
+
+	//-------------------------------------------------------------------------
+
+	/** Apply a local transformation to the sprite.<p>
+        
+        The given transformation matrix locally transforms the sprite
+        shape. If this transformation contains translational
+        components, be aware that sprite content moved beyond the
+        sprite area (a box from (0,0) to (spriteWidth,spriteHeight))
+        might be clipped. Use <member>XSprite::move</member> to change
+        the sprite location on screen. The canvas implementations are
+        free, if they have a cached representation of the sprite at
+        hand, to transform only this cached representation (e.g. a
+        bitmap), instead of re-rendering the sprite from first
+        principles. This is usually the case for an implementation of
+        a <type>XCustomSprite</type> interface, since it typically has
+        no other cached pictorial information at hand.<p>
+
+        Please note that if this sprite is not animated, the
+        associated <type>XSpriteCanvas</type> does not update changed sprites
+        automatically, but has to be told to do so via
+        <member>XSpriteCanvas::updateScreen()</member>.<p>
+
+        @param aTransformation
+        The transformation to apply to the sprite shape.
+
+        @throws com::sun::star::lang::IllegalArgumentException
+        if the given transformation matrix is singular.
+	 */
+	void transform( [in] com::sun::star::geometry::AffineMatrix2D aTransformation )
+        raises (com::sun::star::lang::IllegalArgumentException); 
+
+	//-------------------------------------------------------------------------
+
+    /** Apply a clipping to the shape output.<p>
+
+		The given clip poly-polygon is always interpreted in device
+		coordinate space. As the sprite has its own local coordinate
+		system, with its origin on screen being equal to its current
+		position, the clip poly-polygon's origin will always coincide
+		with the sprite's origin. The implementation is free, if it
+		has a cached representation of the sprite at hand, to
+		clip-output only this cached representation (e.g. a bitmap),
+		instead of re-rendering the sprite from first principles. This
+		is usually the case for an implementation of a
+		<type>XCustomSprite</type> interface, since it typically has
+		no other cached pictorial information at hand.<p>
+
+        Please note that if this sprite is not animated, the
+        associated <type>XSpriteCanvas</type> does not update changed
+        sprites automatically, but has to be told to do so via
+        <member>XSpriteCanvas::updateScreen()</member>.<p>
+
+        @param aClip
+        The clip poly-polygon to apply.
+     */
+	void clip( [in] XPolyPolygon2D aClip ); 
+
+	//-------------------------------------------------------------------------
+
+	/** Set sprite priority.<p>
+
+		The sprite priority determines the order of rendering relative
+		to all other sprites of the associated canvas. The higher the
+		priority, the later will the sprite be rendered, or, in other
+		words, the closer to the screen surface the sprite is shown.<p>
+
+        @param nPriority
+        New sprite priority value to serve as the sort key when
+        determining sprite rendering order. Avoid NaNs and other
+        irregular floating point values here, the order position for
+        sprites with such a priority value is undefined.
+	 */
+    void setPriority( [in] double nPriority ); 
+
+	//-------------------------------------------------------------------------
+
+    /** Make the sprite visible.<p>
+
+    	This method makes the sprite visible on the canvas it was
+    	created on.<p>
+     */
+    void show();
+
+	//-------------------------------------------------------------------------
+
+    /** Make the sprite invisible.<p>
+
+    	This method makes the sprite invisible.<p>
+     */
+    void hide();
+
+};
+
+}; }; }; };
+
+#endif
--- /dev/null	2004-08-25 23:04:59.000000000 +0530
+++ offapi/com/sun/star/rendering/XTextLayout.idl	2005-02-28 13:41:29.000000000 +0530
@@ -0,0 +1,456 @@
+/*************************************************************************
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
+ *
+ *  Copyright: 2000 by Sun Microsystems, Inc.
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+#ifndef __com_sun_star_rendering_XTextLayout_idl__
+#define __com_sun_star_rendering_XTextLayout_idl__
+
+#ifndef __com_sun_star_uno_XInterface_idl__ 
+#include <com/sun/star/uno/XInterface.idl> 
+#endif 
+#ifndef __com_sun_star_lang_IllegalArgumentException_idl__
+#include <com/sun/star/lang/IllegalArgumentException.idl>
+#endif 
+#ifndef __com_sun_star_lang_IndexOutOfBoundsException_idl__
+#include <com/sun/star/lang/IndexOutOfBoundsException.idl>
+#endif 
+#ifndef __com_sun_star_geometry_RealPoint2D_idl__
+#include <com/sun/star/geometry/RealPoint2D.idl>
+#endif
+#ifndef __com_sun_star_geometry_RealBezierSegment2D_idl__
+#include <com/sun/star/geometry/RealBezierSegment2D.idl>
+#endif
+#ifndef __com_sun_star_geometry_RealRectangle2D_idl__
+#include <com/sun/star/geometry/RealRectangle2D.idl>
+#endif
+#ifndef __com_sun_star_rendering_ViewState_idl__
+#include <com/sun/star/rendering/ViewState.idl>
+#endif
+#ifndef __com_sun_star_rendering_RenderState_idl__
+#include <com/sun/star/rendering/RenderState.idl>
+#endif
+#ifndef __com_sun_star_rendering_StringContext_idl__
+#include <com/sun/star/rendering/StringContext.idl>
+#endif
+#ifndef __com_sun_star_rendering_TextHit_idl__
+#include <com/sun/star/rendering/TextHit.idl>
+#endif
+#ifndef __com_sun_star_rendering_Caret_idl__
+#include <com/sun/star/rendering/Caret.idl>
+#endif
+
+
+module com { module sun { module star { module rendering {
+
+interface XCanvas;
+interface XCanvasFont;
+interface XPolyPolygon2D;
+
+/** This is the central interface for text layouting.<p>
+
+	This is the central interface for text-related tasks more
+	complicated than simple string rendering. Note that all query
+	methods are subject to the current layout state of this
+	object. That is, calls to <member>XTextLayout::justify()</member>
+	or <member>XTextLayout::applyLogicalAdvancements()</member> are
+	likely to change subsequent output of those query methods.<p>
+
+    Similar to <type>XCanvasFont</type>, all measurements and
+    coordinates accepted and returned by this interface are in device
+    coordinate space.<p>
+
+    @since #110496#
+ */
+interface XTextLayout : ::com::sun::star::uno::XInterface
+{
+	/** Extract the polygonal shapes of the layouted text.<p>
+
+    	Each glyph is represented by a separate
+    	<type>XPolyPolygon2D</type> in the returned sequence.<p>
+
+        @returns a sequence of <type>XPolyPolygon2D</type> in device
+        coordinate space, one for every glyph.
+	 */
+	sequence<XPolyPolygon2D>	queryTextShapes(); 
+
+	//-------------------------------------------------------------------------
+
+	/** Query the ink bounding boxes for every glyph in the layouted
+     	text.<p>
+
+        Ink, or tight bounding boxes in this case means that for
+        e.g. an 'a', the bounding box for the
+        <type>XPolyPolygon2D</type> describing the glyph 'a' is
+        returned, not the logical dimensions of the character in the
+        font.<p>
+
+        @returns a sequence of rectangles in device coordinate space,
+        specifying the bounds, one for every glyph.
+
+        @see <member>XTextLayout::queryMeasures()</member>
+	 */
+	sequence<::com::sun::star::geometry::RealRectangle2D >	queryInkMeasures(); 
+
+	//-------------------------------------------------------------------------
+
+	/** Query the logical bounding boxes of every character in the
+        given text string.<p>
+
+        Logical bounding boxes means the space that the font allocates
+        for the given character, which, e.g. for a '.', might be
+        significantly broader than the bounds returned via
+        <member>XTextLayout::queryInkMeasures()</member>.
+
+        @returns a sequence of rectangles specifying the bounds in
+        device coordinate space, one for every glyph.
+
+        @see <member>XTextLayout::queryInkMeasures()</member>
+	 */
+	sequence<::com::sun::star::geometry::RealRectangle2D>	queryMeasures(); 
+
+	//-------------------------------------------------------------------------
+
+	/** Query the advancements for every character in the input string.<p>
+
+    	This method returns a sequence of advancements, one for each
+    	character in the input string (<em>not</em> for every
+    	glyph. There might be multiple glyphs per input character, or
+    	multiple input characters per glyph). Adding up all
+    	advancements yields the total advancement of this layout. To
+    	manipulate the layout of a string on the level of characters,
+    	this method can be used to query for the layout's default
+    	advancements, which can subsequently be changed and applied to
+    	the layout via
+    	<member>XTextLayout::applyLogicalAdvancements()</member>.<p>
+
+        @returns a sequence of <type>double</type> specifying the
+        advancements per character in device coordinate space.
+
+        @see <member>XTextLayout::applyLogicalAdvancements()</member>
+	 */
+	sequence<double>			queryLogicalAdvancements(); 
+
+	//-------------------------------------------------------------------------
+
+	/** Apply explicit advancements for every character in the layout
+        string.<p>
+
+    	This method applies the specified advancements to every
+    	logical character in the input string (<em>not</em> for every
+    	glyph. There might be multiple glyphs per input character, or
+    	multiple input characters per glyph). This is useful to
+    	explicitely manipulate the exact output positions of
+    	characters, e.g. relative to a reference output device.<p>
+
+        @param aAdvancements
+        A sequence of character advancements, in device coordinate
+        space.
+
+        @see <member>XTextLayout::queryLogicalAdvancements()</member>
+
+        @throws com::sun::star::lang::IllegalArgumentException
+        if the size of aAdvancements does not match the number of
+        characters in the text.
+	 */
+	void						applyLogicalAdvancements( [in] sequence< double > aAdvancements )
+        raises (com::sun::star::lang::IllegalArgumentException); 
+
+	//-------------------------------------------------------------------------
+
+	/** Query the overall bounding box of the text.<p>
+
+    	This method is similar to
+    	<member>XTextLayout::queryTextMeasures</member>, only that the
+    	overall bounds are returned by this method.<p>
+
+        @return the overall bounding box for the given layout, in device coordinate space.
+	 */
+	::com::sun::star::geometry::RealRectangle2D   queryTextBounds(); 
+
+	//-------------------------------------------------------------------------
+
+    /** Justify the text to the given size.<p>
+
+    	This method is the core of the <type>XTextLayout</type>
+    	interface, because it layouts the text in a typographically
+    	correct way into the available space.<p>
+
+    	@param nSize
+        The requested size of the text after justification (either
+        width or height, depending on the writing mode). This
+        parameter is interpreted in device coordinate space.
+
+        @return the actual size of the text after the justification in
+        the device coordinate space. Depending on the font and the
+        script type, this might be somewhat different from the size
+        requested. If the requested size was smaller than the
+        justification algorithm could compress the text, this value
+        might even be significantly larger than nSize.
+
+        @throws com::sun::star::lang::IllegalArgumentException
+        if nSize is 0 or negative.
+     */
+    double justify( [in] double nSize )
+        raises (com::sun::star::lang::IllegalArgumentException); 
+
+	//-------------------------------------------------------------------------
+
+    /** Justify a number of text layouts to the given size.<p>
+
+    	This method can be used to combine the layout of a text line
+    	into a single justification run. This is e.g. useful if the
+    	line consists of several text portions (e.g. because of
+    	different fonts or colors), but it is desirable to spread the
+    	available space more globally across the different layout
+    	objects. If, for example, one layout object contains
+    	significantly more whitespace or Kashidas than the rest, this
+    	method can assign proportionally more space to this layout
+    	object.<p>
+
+        @param aNextLayouts
+        A sequence of layouts following this one in logical text
+        order.
+
+    	@param nSize
+        The requested size of the text for <em>all</em>
+        <type>XTextLayout</type>s after justification in device
+        coordinate space (either width or height, depending on the
+        writing mode).
+
+        @return the actual size of the text after the justification,
+        in device coordinate space. Depending on the font and the
+        script type, this might be somewhat different from the size
+        requested. If the requested size was smaller than the
+        justification algorithm could compress the text, this value
+        might even be significantly larger than nSize.
+
+        @throws com::sun::star::lang::IllegalArgumentException
+        if one of the parameters are not in the valid range.        
+     */
+    double combinedJustify( [in] sequence< XTextLayout > aNextLayouts, [in] double nSize )
+        raises (com::sun::star::lang::IllegalArgumentException); 
+
+	//-------------------------------------------------------------------------
+
+    /** This method determines the hit position in the text.<p>
+
+    	This method determines the index of the character hit at the
+    	specified position (in device coordinate space).<p>
+
+        @param aHitPoint
+        The position in device coordinate space to determine the
+        underlying character index for.
+
+     */
+    TextHit getTextHit( [in] ::com::sun::star::geometry::RealPoint2D aHitPoint ); 
+
+	//-------------------------------------------------------------------------
+
+    /** This method converts an insertion index to a caret.<p>
+
+    	This method generates caret information for a given insertion
+    	point in the layout text.<p>
+    
+    	@param nInsertionIndex
+        The insertion index, as e.g. returned by
+        <member>XTextLayout::getTextHit()</member>. This value must be
+        in the range 0 up to the number of characters in the string.
+
+        @param bExcludeLigatures
+        Set this to <TRUE>, to skip the positions inside ligatures as
+        valid caret placements. That means, on cannot e.g. set the
+        caret between the 'f' and the 'i' in a 'fi' ligature.
+
+        @returns the generated Caret structure.
+
+        @throws com::sun::star::lang::IndexOutOfBoundsException
+        if nInsertionIndex is outside the permissible range.
+     */
+	Caret getCaret( [in] long nInsertionIndex, 
+                    [in] boolean bExcludeLigatures )
+        raises (com::sun::star::lang::IndexOutOfBoundsException); 
+
+	//-------------------------------------------------------------------------
+
+    /** This method calculates a new insertion index.<p>
+
+    	This method calculates a new insertion index, given a start
+    	index and the number of characters to skip. This is most
+    	useful for caret traveling.<p>
+
+        @param nStartIndex
+        The insertion index to start from.
+
+    	@param nCaretAdvancement
+        For values greater than 0, the caret is visually moved to the
+        right. For values smaller than 0, the caret is visually moved
+        to the left.
+
+        @returns the new insertion index.
+
+        @throws com::sun::star::lang::IndexOutOfBoundsException 
+        if nStartIndex or nCaretAdvancement is outside the permissible
+        range.
+     */
+	long getNextInsertionIndex( [in] long nStartIndex, 
+                                [in] long nCaretAdvancement, 
+                                [in] boolean bExcludeLigatures )
+        raises (com::sun::star::lang::IndexOutOfBoundsException); 
+
+	//-------------------------------------------------------------------------
+
+    /** This method generates a highlight polygon.<p>
+
+    	This method generates a highlighting polygon from two
+    	insertion indices. This polygon will be visually continuous,
+    	i.e. will not have non-highlighted text in between.<p>
+
+        @param nStartIndex
+        Start of the selection range.
+
+        @param nEndIndex
+        End of the selection range.
+
+        @return the highlight polygon in the device coordinate space.
+
+        @throws com::sun::star::lang::IndexOutOfBoundsException 
+        if nStartIndex or nEndIndex are outside the permissible
+        range.
+     */
+    XPolyPolygon2D queryVisualHighlighting( [in] long nStartIndex, 
+                                            [in] long nEndIndex )
+        raises (com::sun::star::lang::IndexOutOfBoundsException);
+
+	//-------------------------------------------------------------------------
+
+    /** This method generates a highlight polygon.<p>
+
+    	This method generates a highlighting polygon from two
+    	insertion indices. This polygon will not always be visually
+    	continuous, if e.g. the text direction changes in the middle
+    	of the selection, the might be parts visually between start
+    	and end position that are not selected.<p>
+
+        @param nStartIndex
+        Start of the selection range.
+
+        @param nEndIndex
+        End of the selection range.
+
+        @return the highlight polygon in the device coordinate space.
+
+        @throws com::sun::star::lang::IndexOutOfBoundsException 
+        if nStartIndex or nEndIndex are outside the permissible
+        range.
+     */
+    XPolyPolygon2D queryLogicalHighlighting( [in] long nStartIndex, 
+                                             [in] long nEndIndex )
+        raises (com::sun::star::lang::IndexOutOfBoundsException);
+
+	//-------------------------------------------------------------------------
+
+    /** This method yields the baseline offset.<p>
+
+    	This method returns the baseline offset for this layout
+    	object, either measured from the top or the left edge,
+    	depending on the writing direction (horizontally or
+    	vertically). Since rendering this layout via
+    	<member>XCanvas::drawTextLayout()</member> outputs relative to
+    	the layout object's baseline, this method can be used to
+    	e.g. output relative to the left, top edge.<p>
+
+        @returns the distance of the main baseline from the top or the
+        left edge of this object, depending on the writing direction.
+     */
+    double getBaselineOffset();
+
+	//-------------------------------------------------------------------------
+
+    /** This method returns the main writing direction.<p>
+
+    	This method returns the main writing direction of this layout,
+    	i.e. either LEFT_TO_RIGHT or RIGHT_TO_LEFT.<p>
+
+        @returns the main text direction of this layout.
+     */
+    byte getMainTextDirection();
+
+	//-------------------------------------------------------------------------
+
+    /** Request the associated font for this layout..
+
+    	@returns the associated font for this layout.
+     */
+    XCanvasFont getFont();
+
+	//-------------------------------------------------------------------------
+
+    /** Request the text this layout contains.
+
+    	@returns the text this layout contains. 
+     */
+    StringContext getText();
+
+	//-------------------------------------------------------------------------
+
+};
+
+}; }; }; };
+
+#endif
--- /dev/null	2004-08-25 23:04:59.000000000 +0530
+++ offapi/com/sun/star/rendering/XVolatileBitmap.idl	2005-02-28 13:41:29.000000000 +0530
@@ -0,0 +1,87 @@
+/*************************************************************************
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
+ *
+ *  Copyright: 2000 by Sun Microsystems, Inc.
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+#ifndef __com_sun_star_rendering_XVolatileBitmap_idl__
+#define __com_sun_star_rendering_XVolatileBitmap_idl__
+
+#ifndef __com_sun_star_rendering_XBitmap_idl__
+#include <com/sun/star/rendering/XBitmap.idl>
+#endif
+
+module com { module sun { module star { module rendering {
+
+/** This is a specialized interface to a volatile bitmap (which can
+    become invalid at any point in time).
+ */
+interface XVolatileBitmap : XBitmap
+{		
+	/** Query whether this volatile bitmap still has valid content. 
+
+		As the video RAM allocated to this bitmap can be reclaimed at
+		any time, a return value of true here does not imply that the
+		next draw operation with this bitmap will succeed. Instead,
+		the exception VolatileContentDestroyed will be thrown then.
+	 */	
+	boolean	isValid();
+};
+
+}; }; }; };
+
+#endif
--- /dev/null	2004-08-25 23:04:59.000000000 +0530
+++ slideshow/source/engine/transitions/slidechangebase.cxx	2005-02-28 13:41:45.000000000 +0530
@@ -0,0 +1,590 @@
+/*************************************************************************
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
+ *
+ *  Copyright: 2000 by Sun Microsystems, Inc.
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+
+#include "slidechangebase.hxx"
+#include "canvas/debug.hxx"
+#include "basegfx/numeric/ftools.hxx"
+#include "basegfx/polygon/b2dpolygontools.hxx"
+#include "basegfx/polygon/b2dpolypolygontools.hxx"
+#include "cppcanvas/basegfxfactory.hxx"
+#include "boost/bind.hpp"
+#include <algorithm>
+
+using namespace com::sun::star;
+namespace css = com::sun::star; // resolving conflicts with ::presentation
+
+namespace presentation {
+namespace internal {
+
+// XModifyListener
+void SlideChangeBase::ModifyListener::modified( lang::EventObject const & evt )
+    throw (uno::RuntimeException)
+{
+    if (m_pSlideChangeBase != 0) {
+        m_pSlideChangeBase->notifyViewChange( evt );
+    }
+}
+
+// XEventListener
+void SlideChangeBase::ModifyListener::disposing( lang::EventObject const & evt )
+    throw (uno::RuntimeException)
+{
+    const uno::Reference<css::presentation::XSlideShowView> xSlideShowView(
+        evt.Source, uno::UNO_QUERY );
+    if (xSlideShowView.is() && m_pSlideChangeBase != 0)
+    {
+        const UnoViewSharedPtr pView(
+            m_pSlideChangeBase->findUnoView( xSlideShowView ) );
+        if (pView.get() != 0)
+            m_pSlideChangeBase->removeView( pView );
+    }
+}
+
+SlideChangeBase::~SlideChangeBase()
+{
+}
+
+SlideChangeBase::SlideChangeBase(
+    boost::optional<SlideSharedPtr> const & leavingSlide,
+    const SlideSharedPtr& pEnteringSlide,
+    const SoundPlayerSharedPtr& pSoundPlayer,
+    bool bCreateLeavingSprites, bool bCreateEnteringSprites )
+    : maMutex(),
+      maViews(),
+      mpSoundPlayer( pSoundPlayer ),
+      mLeavingSlide( leavingSlide ),
+      mpEnteringSlide( pEnteringSlide ),
+      mpLeavingBitmap(),
+      mpEnteringBitmap(),
+      maOutSprites(),
+      maInSprites(),
+      mbCreateLeavingSprites(bCreateLeavingSprites),
+      mbCreateEnteringSprites(bCreateEnteringSprites),
+      mbSpritesVisible(false),
+      mxModifyListener()
+{
+    ENSURE_AND_THROW(
+        pEnteringSlide.get(),
+        "SlideChangeBase::SlideChangeBase(): Invalid entering slide!" );
+}
+
+SlideBitmapSharedPtr SlideChangeBase::getLeavingBitmap() const
+{
+    osl::ResettableMutexGuard guard(maMutex);
+    if (mpLeavingBitmap.get() == 0) {
+        guard.clear();
+        const SlideBitmapSharedPtr pBitmap( createBitmap(mLeavingSlide) );
+        guard.reset();
+        if (mpLeavingBitmap.get() == 0)
+            mpLeavingBitmap = pBitmap;
+    }
+    return mpLeavingBitmap;
+}
+
+SlideBitmapSharedPtr SlideChangeBase::getEnteringBitmap() const
+{
+    osl::ResettableMutexGuard guard(maMutex);
+    if (mpEnteringBitmap.get() == 0) {
+        guard.clear();
+        const SlideBitmapSharedPtr pBitmap(
+            createBitmap( boost::optional<SlideSharedPtr>(mpEnteringSlide) ) );
+        guard.reset();
+        if (mpEnteringBitmap.get() == 0)
+            mpEnteringBitmap = pBitmap;
+    }
+    return mpEnteringBitmap;
+}
+
+SlideBitmapSharedPtr SlideChangeBase::createBitmap(
+    boost::optional<SlideSharedPtr> const & rSlide ) const
+{
+    SlideBitmapSharedPtr pRet;
+    OSL_ASSERT( ! maViews.empty() );
+    if (rSlide && !maViews.empty())
+    {
+        SlideSharedPtr const & pSlide = *rSlide;
+        if (pSlide.get() == 0)
+        {
+            // TODO(F2): Generalize to multiple, multi-device views
+            const basegfx::B2ISize slideSizePixel( 
+                getEnteringSizePixel( maViews.front() ) );
+
+            cppcanvas::CanvasSharedPtr pCanvas(
+                maViews.front()->getCanvas() );
+
+            // create a bitmap of appropriate size
+            cppcanvas::BitmapSharedPtr pBitmap( 
+                cppcanvas::BaseGfxFactory::getInstance().createBitmap( 
+                    pCanvas, 
+                    slideSizePixel ) );
+                
+            ENSURE_AND_THROW(
+                pBitmap.get(),
+                "SlideChangeBase::createBitmap(): Cannot create page bitmap" );
+                
+            cppcanvas::BitmapCanvasSharedPtr pBitmapCanvas(
+                pBitmap->getBitmapCanvas() );
+                
+            ENSURE_AND_THROW( pBitmapCanvas.get(),
+                              "SlideChangeBase::createBitmap(): "
+                              "Cannot create page bitmap canvas" );
+
+            // set transformation to identitiy (->device pixel)
+            pBitmapCanvas->setTransformation( ::basegfx::B2DHomMatrix() );
+
+            // fill the bounds rectangle in white
+            const ::basegfx::B2DPolygon aPoly(
+                ::basegfx::tools::createPolygonFromRect(
+                    ::basegfx::B2DRectangle( 0.0, 0.0,
+                                             slideSizePixel.getX(),
+                                             slideSizePixel.getY() ) ) );
+            
+            ::cppcanvas::PolyPolygonSharedPtr pPolyPoly( 
+                ::cppcanvas::BaseGfxFactory::getInstance().createPolyPolygon( pBitmapCanvas, 
+                                                                              aPoly ) );
+            
+            if( pPolyPoly.get() )
+            {
+                pPolyPoly->setRGBAFillColor( 0x000000FFU );
+                pPolyPoly->draw();
+            }
+                
+            pRet = SlideBitmapSharedPtr( new SlideBitmap( pBitmap ) );
+        }
+        else
+        {
+            // TODO(F2): Generalize to multiple, multi-device views
+            pRet = pSlide->getCurrentSlideBitmap( *maViews.begin() );
+        }
+    }
+    return pRet;
+}
+
+basegfx::B2ISize SlideChangeBase::getEnteringSizePixel(
+    UnoViewSharedPtr const & pView ) const
+{
+    return mpEnteringSlide->getSlideSizePixel( pView );
+}
+        
+basegfx::B2DSize SlideChangeBase::getEnteringSize() const
+{
+    return mpEnteringSlide->getSlideSize();
+}
+ 
+void SlideChangeBase::renderBitmap(
+    SlideBitmapSharedPtr const & pSlideBitmap,
+    cppcanvas::CanvasSharedPtr const & pCanvas )
+{
+    if (pSlideBitmap.get() != 0 && pCanvas.get() != 0)
+    {
+        // need to render without any transformation (we
+        // assume device units):
+        const basegfx::B2DHomMatrix viewTransform(
+            pCanvas->getTransformation() );
+        const basegfx::B2DPoint pageOrigin(
+            viewTransform * basegfx::B2DPoint() );
+        const cppcanvas::CanvasSharedPtr pDevicePixelCanvas(
+            pCanvas->clone() );
+        basegfx::B2DHomMatrix transform;
+        // render at output position, don't modify bitmap object (no move!):
+        transform.translate( pageOrigin.getX(), pageOrigin.getY() );
+        
+        pDevicePixelCanvas->setTransformation( transform );
+        pSlideBitmap->draw( pDevicePixelCanvas );
+    }
+}
+
+void SlideChangeBase::start( const AnimatableShapeSharedPtr&,
+                             const ShapeAttributeLayerSharedPtr& )
+{
+    // create slide bitmaps
+    getEnteringBitmap();
+    getLeavingBitmap();
+
+    // create sprites:
+    std::for_each( maViews.begin(), maViews.end(),
+                   boost::bind( &SlideChangeBase::addSprites, this, _1 ) );
+    
+    // start accompanying sound effect, if any
+    if( mpSoundPlayer.get() )
+        mpSoundPlayer->startPlayback();
+}
+
+void SlideChangeBase::end()
+{
+    // end accompanying sound effect, if any
+    if (mpSoundPlayer.get() != 0) {
+        mpSoundPlayer->stopPlayback();
+        mpSoundPlayer->dispose();
+        mpSoundPlayer.reset();
+    }
+    
+    // draw fully entered bitmap:
+    const SlideBitmapSharedPtr pSlideBitmap( getEnteringBitmap() );
+    pSlideBitmap->clip( basegfx::B2DPolyPolygon() /* no clipping */ );
+    for_each_canvas( boost::bind( &SlideChangeBase::renderBitmap, this,
+                                  boost::cref(pSlideBitmap), _1 ) );
+    // TODO: Slide::show() initial Sliderendering may be obsolete now
+    
+    mbSpritesVisible = false;
+
+    // drop all references
+    mLeavingSlide.reset();
+    mpEnteringSlide.reset();
+    {
+        const osl::MutexGuard guard(maMutex);
+        maOutSprites.clear();
+        maInSprites.clear();
+        mpEnteringBitmap.reset();
+        mpLeavingBitmap.reset();
+    }
+    
+    if (mxModifyListener.is())
+    {
+        UnoViewVector::const_iterator iPos( maViews.begin() );
+        const UnoViewVector::const_iterator iEnd( maViews.end() );
+        for ( ; iPos != iEnd; ++iPos )
+        {
+            const uno::Reference<css::presentation::XSlideShowView>
+                xSlideShowView( (*iPos)->getUnoView(), uno::UNO_QUERY );
+            if (xSlideShowView.is()) {
+                xSlideShowView->removeTransformationChangedListener(
+                    getModifyListener().get() );
+            }
+        }
+        // for safety:
+        mxModifyListener->m_pSlideChangeBase = 0;
+        mxModifyListener.clear();
+    }
+    maViews.clear();
+}
+
+bool SlideChangeBase::operator()( double nValue )
+{
+    SpriteVector aInSprites, aOutSprites;
+    {
+        const osl::MutexGuard guard(maMutex);
+        if (maInSprites.empty() && maOutSprites.empty())
+            return false;
+        aInSprites = maInSprites;
+        aOutSprites = maOutSprites;
+    }
+    
+    const std::size_t nEntries = std::max<std::size_t>(aInSprites.size(),
+                                                       aOutSprites.size());
+    ENSURE_AND_RETURN(
+        maViews.size() == nEntries,
+        "SlideChangeBase::operator(): Mismatching sprite/view numbers" );
+    
+    bool bSpritesVisible( mbSpritesVisible );
+    
+    for( ::std::size_t i=0; i<nEntries; ++i )
+    {
+        // calc sprite offsets. The enter/leaving bitmaps are only
+        // as large as the actual slides. For scaled-down
+        // presentations, we have to move the left, top edge of
+        // those bitmaps to the actual position, governed by the
+        // given view transform. The aSpritePosPixel local
+        // variable is already in device coordinate space
+        // (i.e. pixel).
+
+        UnoViewSharedPtr const & pView = maViews[i];
+        ::cppcanvas::CanvasSharedPtr const & pCanvas = pView->getCanvas();
+        ::cppcanvas::CustomSpriteSharedPtr pInSprite, pOutSprite;
+        
+        if (i < aInSprites.size())
+            pInSprite = aInSprites[i];
+        if (i < aOutSprites.size())
+            pOutSprite = aOutSprites[i];
+        
+        // TODO(F2): Properly respect clip here.
+
+        // Might have to be transformed, too.
+        const ::basegfx::B2DHomMatrix aViewTransform(
+            pCanvas->getTransformation() );
+        const ::basegfx::B2DPoint aSpritePosPixel(
+            aViewTransform * ::basegfx::B2DPoint() );
+        
+        // move sprite to final output position, in 
+        // device coordinates
+        if (pOutSprite.get() != 0)
+            pOutSprite->movePixel( aSpritePosPixel );
+        if (pInSprite.get() != 0)
+            pInSprite->movePixel( aSpritePosPixel );
+        
+        if (! mbSpritesVisible)
+        {
+            if (pOutSprite.get() != 0)
+            {
+                // only render once: clipping is done
+                // exclusively with the sprite
+                const ::cppcanvas::CanvasSharedPtr pOutContentCanvas(
+                    pOutSprite->getContentCanvas() );
+                if (pOutContentCanvas.get() != 0) {
+                    // TODO(Q2): Use basegfx bitmaps here
+
+                    // TODO(F1): SlideBitmap is not fully portable
+                    // between different canvases!
+                    
+                    // render the content
+                    OSL_ASSERT( getLeavingBitmap().get() != 0 );
+                    if (getLeavingBitmap().get() != 0)
+                        getLeavingBitmap()->draw( pOutContentCanvas );
+                }
+            }
+            
+            if (pInSprite.get() != 0) {
+                // only render once: clipping is done
+                // exclusively with the sprite
+                const ::cppcanvas::CanvasSharedPtr pInContentCanvas(
+                    pInSprite->getContentCanvas() );
+                if (pInContentCanvas.get() != 0) {
+                    // TODO(Q2): Use basegfx bitmaps here
+
+                    // TODO(F1): SlideBitmap is not fully portable
+                    // between different canvases!
+                    
+                    // render the content
+                    getEnteringBitmap()->draw( pInContentCanvas );
+                }
+            }
+        }
+        
+        if (pOutSprite.get() != 0)
+            performOut( pOutSprite, pView, pCanvas, nValue );
+        if (pInSprite.get() != 0)
+            performIn( pInSprite, pView, pCanvas, nValue );
+        
+        // finishing deeds for first run.
+        if (! mbSpritesVisible) {
+            // enable sprites:
+            if (pOutSprite.get() != 0)
+                pOutSprite->show();
+            if (pInSprite.get() != 0)
+                pInSprite->show();
+            bSpritesVisible = true;
+        }
+    } // for_each( sprite )
+    
+    mbSpritesVisible = bSpritesVisible;
+    
+    return true;
+}
+
+void SlideChangeBase::performIn(
+    const cppcanvas::CustomSpriteSharedPtr&   rSprite,
+    UnoViewSharedPtr const &                  pView,
+    const cppcanvas::CanvasSharedPtr&         rDestinationCanvas,
+    double                                    t )
+{
+}
+
+void SlideChangeBase::performOut(
+    const cppcanvas::CustomSpriteSharedPtr&  rSprite,
+    UnoViewSharedPtr const &                 pView,
+    const cppcanvas::CanvasSharedPtr&        rDestinationCanvas,
+    double                                   t )
+{
+}
+
+double SlideChangeBase::getUnderlyingValue() const
+{
+    return 0.0;     // though this should be used in concert with 
+				    // ActivitiesFactory::createSimpleActivity, better
+			    	// explicitely name our start value.
+				    // Permissible range for operator() above is [0,1]
+}
+
+cppcanvas::CustomSpriteSharedPtr SlideChangeBase::createSprite(
+    UnoViewSharedPtr const & pView, basegfx::B2DSize const & rSpriteSize ) const
+{
+    // TODO(P2): change to bitmapsprite once that's working
+    const cppcanvas::CustomSpriteSharedPtr pSprite(
+        pView->createSprite( rSpriteSize ) );
+    // alpha default is 0.0, which seems to be 
+    // a bad idea when viewing content...
+    pSprite->setAlpha( 1.0 );
+    if (mbSpritesVisible)
+        pSprite->show();
+    return pSprite;
+}
+
+void SlideChangeBase::addSprites( UnoViewSharedPtr const & pView )
+{
+    if (mbCreateLeavingSprites && mLeavingSlide) 
+    {
+        // create leaving sprite:
+        const basegfx::B2ISize leavingSlideSizePixel(
+            getLeavingBitmap()->getSize() );
+
+        const cppcanvas::CustomSpriteSharedPtr pLeavingSprite(
+            createSprite( pView, leavingSlideSizePixel ) );
+
+        const osl::MutexGuard guard(maMutex);
+        maOutSprites.push_back( pLeavingSprite );
+    }
+    
+    if (mbCreateEnteringSprites) 
+    {
+        // create entering sprite:
+        const basegfx::B2ISize enteringSlideSizePixel(
+            mpEnteringSlide->getSlideSizePixel( pView ) );
+
+        const cppcanvas::CustomSpriteSharedPtr pEnteringSprite(
+            createSprite( pView, enteringSlideSizePixel ) );
+
+        const osl::MutexGuard guard(maMutex);
+        maInSprites.push_back( pEnteringSprite );
+    }
+}
+
+void SlideChangeBase::notifyViewChange( lang::EventObject const & evt )
+{
+    const uno::Reference<css::presentation::XSlideShowView> xSlideShowView(
+        evt.Source, uno::UNO_QUERY );
+    if (xSlideShowView.is())
+    {
+        const UnoViewSharedPtr pView( findUnoView( xSlideShowView ) );
+        OSL_ASSERT( pView.get() );
+        if (pView.get() != 0)
+        {
+            // invalidate bitmaps and sprites for next update():
+            {
+                const osl::MutexGuard guard(maMutex);
+                mpLeavingBitmap.reset();
+                mpEnteringBitmap.reset();
+                maOutSprites.clear();
+                maInSprites.clear();
+            }
+            
+            // and create new ones (!in same order as added views!):
+            std::for_each(
+                maViews.begin(), maViews.end(),
+                boost::bind( &SlideChangeBase::addSprites, this, _1 ) );
+        }
+    }
+}
+
+UnoViewSharedPtr SlideChangeBase::findUnoView(
+    uno::Reference<css::presentation::XSlideShowView> const & xSlideShowView )
+    const
+{
+    UnoViewVector::const_iterator iFind;
+    const UnoViewVector::const_iterator iBegin( maViews.begin() );
+    const UnoViewVector::const_iterator iEnd( maViews.end() );
+    if ((iFind = std::find_if(
+             iBegin, iEnd,
+             boost::bind(
+                 std::equal_to<
+                     uno::Reference<css::presentation::XSlideShowView> >(),
+                 boost::bind( &UnoView::getUnoView, _1 ),
+                 boost::cref(xSlideShowView) ) )) != iEnd)
+    {
+        return *iFind;
+    }
+    else
+        return UnoViewSharedPtr();
+}
+
+void SlideChangeBase::addView( UnoViewSharedPtr const & pView )
+{
+    const UnoViewVector::iterator iEnd( maViews.end() );
+    if (std::find( maViews.begin(), iEnd, pView ) == iEnd)
+    {
+        // listen for view changes:
+        const uno::Reference<css::presentation::XSlideShowView> xSlideShowView(
+            pView->getUnoView(), uno::UNO_QUERY_THROW );
+        xSlideShowView->addTransformationChangedListener(
+            getModifyListener().get() );
+        maViews.push_back( pView );
+    }
+}
+
+bool SlideChangeBase::removeView( UnoViewSharedPtr const & pView )
+{
+    UnoViewVector::iterator iBegin( maViews.begin() );
+    const UnoViewVector::iterator iEnd( maViews.end() );
+    UnoViewVector::iterator iPos;
+    if ((iPos = std::find( iBegin, iEnd, pView )) == iEnd) {
+        // view seemingly was not added, failed
+        return false;
+    }
+    
+    // don't listen for view changes anymore:
+    const uno::Reference<css::presentation::XSlideShowView> xSlideShowView(
+        pView->getUnoView(), uno::UNO_QUERY_THROW );
+    xSlideShowView->removeTransformationChangedListener(
+        getModifyListener().get() );
+    
+    const std::size_t dist = std::distance( iBegin, iPos );
+    maViews.erase( iPos );
+    {
+        const osl::MutexGuard guard(maMutex);
+        if (mLeavingSlide && dist < maOutSprites.size())
+            maOutSprites.erase( maOutSprites.begin() + dist );
+        if (dist < maInSprites.size())
+            maInSprites.erase( maInSprites.begin() + dist );
+    }
+    return true;
+}
+
+} // namespace internal
+} // namespace presentation
--- /dev/null	2004-08-25 23:04:59.000000000 +0530
+++ slideshow/source/engine/transitions/slidechangebase.hxx	2005-02-28 13:41:45.000000000 +0530
@@ -0,0 +1,260 @@
+/*************************************************************************
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
+ *
+ *  Copyright: 2000 by Sun Microsystems, Inc.
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+
+#if ! defined(INCLUDED_PRESENTATION_INTERNAL_TRANSITIONS_SLIDECHANGEBASE_HXX)
+#define INCLUDED_PRESENTATION_INTERNAL_TRANSITIONS_SLIDECHANGEBASE_HXX
+
+#include "unoview.hxx"
+#include "slidechangeanimation.hxx"
+#include "slide.hxx"
+#include "soundplayer.hxx"
+#include "rtl/ref.hxx"
+#include "osl/mutex.hxx"
+#include "cppuhelper/implbase1.hxx"
+#include "com/sun/star/util/XModifyListener.hpp"
+#include "com/sun/star/presentation/XSlideShowView.hpp"
+#include "boost/utility.hpp" // for boost::noncopyable
+#include "boost/optional.hpp"
+#include "boost/bind.hpp"
+
+namespace presentation {
+namespace internal {
+
+/** Base class for all slide change effects.
+    
+    This class provides the basic sprite and view handling
+    functionality.  Derived classes should normally only need to
+    implement the perform() method.
+*/
+class SlideChangeBase : public SlideChangeAnimation,
+                        private ::boost::noncopyable
+{
+public:
+    // NumberAnimation
+    virtual bool operator()( double x );
+    virtual double getUnderlyingValue() const;
+    
+    // Animation
+    virtual void start( const AnimatableShapeSharedPtr&,
+                        const ShapeAttributeLayerSharedPtr& );
+    virtual void end();
+    
+    // SlideChangeAnimation
+    virtual void addView( UnoViewSharedPtr const & pView );
+    virtual bool removeView( UnoViewSharedPtr const & pView );
+    
+protected:
+    virtual ~SlideChangeBase();
+    
+    /** Create a new SlideChanger, for the given leaving and
+        entering slides.
+    */
+    SlideChangeBase(
+        ::boost::optional<SlideSharedPtr> const & leavingSlide,
+        const SlideSharedPtr& pEnteringSlide,
+        const SoundPlayerSharedPtr& pSoundPlayer,
+        bool bCreateLeavingSprites = true, bool bCreateEnteringSprites = true );
+    
+    SlideBitmapSharedPtr getLeavingBitmap() const;
+    SlideBitmapSharedPtr getEnteringBitmap() const;
+    
+    SlideBitmapSharedPtr SlideChangeBase::createBitmap(
+        ::boost::optional<SlideSharedPtr> const & rSlide_ ) const;
+    
+	/// Query the size of the bitmaps in device pixel
+    ::basegfx::B2ISize getEnteringSizePixel(
+        UnoViewSharedPtr const & pView ) const;
+    /// Query the XDrawPage's size
+    ::basegfx::B2DSize getEnteringSize() const; 
+
+    void renderBitmap(
+        SlideBitmapSharedPtr const & pSlideBitmap,
+        ::cppcanvas::CanvasSharedPtr const & pCanvas );
+
+    /** Loop over each View, and call func with that
+     */
+    template <typename FuncT>
+    FuncT for_each_view( FuncT func ) {
+        return ::std::for_each( maViews.begin(), maViews.end(), func );
+    }
+
+    /** Loop over each View's canvas, and call func with that
+     */
+    template <typename FuncT>
+    FuncT for_each_canvas( FuncT func ) {
+        // at least gcc 3.4.1 cannot cope with the below:
+//         ::std::for_each(
+//             maViews.begin(), maViews.end(),
+//             ::boost::bind( ::boost::ref(func),
+//                            ::boost::bind( &ViewLayer::getCanvas, _1 ) ) );
+        const UnoViewVector::const_iterator iEnd( maViews.end() );
+        for ( UnoViewVector::const_iterator iPos( maViews.begin() );
+              iPos != iEnd; ++iPos )
+        {
+            const ::cppcanvas::CanvasSharedPtr pCanvas( (*iPos)->getCanvas() );
+            func( pCanvas );
+        }
+        return func;
+    }
+    
+    /** Called on derived classes to implement actual slide change.
+        
+        This method is called with the sprite of the slide coming 'in'
+        
+        @param rSprite
+        Current sprite to operate on. This is the sprite of the
+        'entering' slide
+        
+        @param x
+        Current parameter value
+    */
+    virtual void performIn(
+        const ::cppcanvas::CustomSpriteSharedPtr&   rSprite,
+        UnoViewSharedPtr const &                    pView,
+        const ::cppcanvas::CanvasSharedPtr&         rDestinationCanvas,
+        double                                      t );
+    
+    /** Called on derived classes to implement actual slide change.
+        
+        This method is called with the sprite of the slide moving 'out'
+        
+        @param rSprite
+        Current sprite to operate on. This is the sprite of the
+        'leaving' slide
+        
+        @param x
+        Current parameter value
+    */
+    virtual void performOut(
+        const ::cppcanvas::CustomSpriteSharedPtr&  rSprite,
+        UnoViewSharedPtr const &                   pView,
+        const ::cppcanvas::CanvasSharedPtr&        rDestinationCanvas,
+        double                                     t );
+    
+private:
+    mutable ::osl::Mutex maMutex;
+    
+    UnoViewVector maViews;
+    UnoViewSharedPtr findUnoView(
+        ::com::sun::star::uno::Reference<
+        ::com::sun::star::presentation::XSlideShowView> const & xSlideShowView )
+        const;
+    
+    SoundPlayerSharedPtr mpSoundPlayer;
+    
+    ::boost::optional<SlideSharedPtr> mLeavingSlide;
+    SlideSharedPtr mpEnteringSlide;
+    mutable SlideBitmapSharedPtr mpLeavingBitmap;
+    mutable SlideBitmapSharedPtr mpEnteringBitmap;
+    
+    typedef ::std::vector< ::cppcanvas::CustomSpriteSharedPtr > SpriteVector;
+    SpriteVector maOutSprites;
+    SpriteVector maInSprites;
+    const bool mbCreateLeavingSprites;
+    const bool mbCreateEnteringSprites;
+    bool mbSpritesVisible;
+    
+    ::cppcanvas::CustomSpriteSharedPtr createSprite(
+        UnoViewSharedPtr const & pView,
+        ::basegfx::B2DSize const & rSpriteSize ) const;
+    void addSprites( UnoViewSharedPtr const & pView );
+    
+    void notifyViewChange( ::com::sun::star::lang::EventObject const & evt );
+    
+    class ModifyListener
+        : public ::cppu::WeakImplHelper1<
+              ::com::sun::star::util::XModifyListener >,
+          private ::boost::noncopyable
+    {
+    public:
+        // XModifyListener
+        virtual void SAL_CALL modified(
+            ::com::sun::star::lang::EventObject const & evt )
+            throw (::com::sun::star::uno::RuntimeException);
+        // XEventListener
+        virtual void SAL_CALL disposing(
+            ::com::sun::star::lang::EventObject const & evt )
+            throw (::com::sun::star::uno::RuntimeException);
+        
+        ModifyListener( SlideChangeBase * pSlideChangeBase )
+            : m_pSlideChangeBase(pSlideChangeBase)
+            {}
+        
+    private:
+        // TODO: think about boost::shared_ptr<> when
+        // enable_shared_ptr_from_this is available
+        SlideChangeBase * m_pSlideChangeBase;
+        friend class SlideChangeBase;
+    };
+    
+    ::rtl::Reference<ModifyListener> mxModifyListener;
+    ::rtl::Reference<ModifyListener> const & getModifyListener() {
+        if (! mxModifyListener.is()) // late init:
+            mxModifyListener = new ModifyListener(this);
+        return mxModifyListener;
+    }
+    friend class ModifyListener;
+};
+
+} // namespace internal
+} // namespace presentation
+
+#endif
--- /dev/null	2004-08-25 23:04:59.000000000 +0530
+++ vcl/inc/bmpfast.hxx	2005-02-28 13:40:52.000000000 +0530
@@ -0,0 +1,79 @@
+/*************************************************************************
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
+ *
+ *  Copyright: 2000 by Sun Microsystems, Inc.
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+
+#ifndef _SV_BMPFAST_HXX
+#define _SV_BMPFAST_HXX
+ 
+class BitmapWriteAccess;
+class BitmapReadAccess;
+class BitmapBuffer;
+class Size;
+class Point;
+struct SalTwoRect;
+ 
+bool ImplFastBitmapConversion( BitmapBuffer& rDst, const BitmapBuffer& rSrc,
+        const SalTwoRect& rTwoRect );
+
+bool ImplFastBitmapBlending( BitmapWriteAccess& rDst,
+    const BitmapReadAccess& rSrc, const BitmapReadAccess& rMask,
+    const SalTwoRect& rTwoRect );
+
+#endif // _SV_BMPFAST_HXX
--- /dev/null	2004-08-25 23:04:59.000000000 +0530
+++ vcl/inc/canvasbitmap.hxx	2005-02-28 13:40:53.000000000 +0530
@@ -0,0 +1,121 @@
+/*************************************************************************
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
+ *
+ *  Copyright: 2000 by Sun Microsystems, Inc.
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+
+#ifndef _VCL_CANVASBITMAP_HXX
+#define _VCL_CANVASBITMAP_HXX
+
+#ifndef _CPPUHELPER_COMPBASE3_HXX_
+#include <cppuhelper/compbase3.hxx>
+#endif
+#ifndef _COM_SUN_STAR_RENDERING_XINTEGERBITMAP_HPP_
+#include <com/sun/star/rendering/XIntegerBitmap.hpp>
+#endif
+#ifndef _COM_SUN_STAR_RENDERING_XBITMAPPALETTE_HPP_
+#include <com/sun/star/rendering/XBitmapPalette.hpp>
+#endif
+#ifndef _COM_SUN_STAR_LANG_XUNOTUNNEL_HPP_
+#include <com/sun/star/lang/XUnoTunnel.hpp>
+#endif
+
+#ifndef _SV_BITMAPEX_HXX
+#include <bitmapex.hxx>
+#endif
+
+namespace vcl
+{
+namespace unotools
+{
+    class VclCanvasBitmap : public
+        cppu::WeakImplHelper3< com::sun::star::rendering::XIntegerBitmap,
+                               com::sun::star::rendering::XBitmapPalette,
+                               com::sun::star::lang::XUnoTunnel>
+    {
+        BitmapEx*                                                   m_pBitmap;
+        com::sun::star::rendering::IntegerBitmapLayout      m_aLayout;
+        public:
+        VclCanvasBitmap( const BitmapEx& rBitmap );
+        virtual ~VclCanvasBitmap();
+        
+        // XBitmap
+        virtual com::sun::star::geometry::IntegerSize2D SAL_CALL getSize() throw (com::sun::star::uno::RuntimeException);
+        virtual com::sun::star::uno::Reference< com::sun::star::rendering::XBitmapCanvas > SAL_CALL queryBitmapCanvas() throw (com::sun::star::uno::RuntimeException);
+        virtual com::sun::star::uno::Reference< com::sun::star::rendering::XBitmap > SAL_CALL getScaledBitmap( const com::sun::star::geometry::RealSize2D& newSize, sal_Bool beFast ) throw (com::sun::star::uno::RuntimeException);
+
+        // XIntegerBitmap
+        virtual com::sun::star::uno::Sequence< sal_Int8 > SAL_CALL getData( const com::sun::star::geometry::IntegerRectangle2D& rect ) throw (com::sun::star::lang::IndexOutOfBoundsException, com::sun::star::rendering::VolatileContentDestroyedException, com::sun::star::uno::RuntimeException);
+        virtual void SAL_CALL setData( const com::sun::star::uno::Sequence< sal_Int8 >& data, const com::sun::star::rendering::IntegerBitmapLayout& bitmapLayout, const com::sun::star::geometry::IntegerRectangle2D& rect ) throw (com::sun::star::lang::IllegalArgumentException, com::sun::star::lang::IndexOutOfBoundsException, com::sun::star::uno::RuntimeException);
+        virtual void SAL_CALL setPixel( const com::sun::star::uno::Sequence< sal_Int8 >& color, const com::sun::star::rendering::IntegerBitmapLayout& bitmapLayout, const ::com::sun::star::geometry::IntegerPoint2D& pos ) throw (com::sun::star::lang::IllegalArgumentException, com::sun::star::lang::IndexOutOfBoundsException, com::sun::star::uno::RuntimeException);
+        virtual com::sun::star::uno::Sequence< sal_Int8 > SAL_CALL getPixel( const com::sun::star::geometry::IntegerPoint2D& pos ) throw (com::sun::star::lang::IndexOutOfBoundsException, ::com::sun::star::rendering::VolatileContentDestroyedException, com::sun::star::uno::RuntimeException);
+        virtual com::sun::star::uno::Reference< com::sun::star::rendering::XBitmapPalette > SAL_CALL getPalette() throw (com::sun::star::uno::RuntimeException);
+        virtual com::sun::star::rendering::IntegerBitmapLayout SAL_CALL getMemoryLayout() throw (com::sun::star::uno::RuntimeException);
+
+        // XBitmapPalette
+        virtual sal_Int32 SAL_CALL getNumberOfEntries() throw (com::sun::star::uno::RuntimeException);
+        virtual com::sun::star::uno::Sequence< double > SAL_CALL getPaletteIndex( sal_Int32 nIndex ) throw (::com::sun::star::lang::IndexOutOfBoundsException, com::sun::star::uno::RuntimeException);
+        virtual sal_Bool SAL_CALL setPaletteIndex( const com::sun::star::uno::Sequence< double >& color, ::sal_Int32 nIndex ) throw (com::sun::star::lang::IndexOutOfBoundsException, com::sun::star::lang::IllegalArgumentException, com::sun::star::uno::RuntimeException);
+        
+        // XUnoTunnel
+        virtual sal_Int64 SAL_CALL getSomething( const com::sun::star::uno::Sequence< sal_Int8 >& aIdentifier ) throw (com::sun::star::uno::RuntimeException);
+   };
+}
+}
+
+#endif
--- /dev/null	2004-08-25 23:04:59.000000000 +0530
+++ vcl/source/gdi/bmpfast.cxx	2005-02-28 13:40:58.000000000 +0530
@@ -0,0 +1,952 @@
+/*************************************************************************
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
+ *
+ *  Copyright: 2000 by Sun Microsystems, Inc.
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+
+#include <bmpfast.hxx>
+
+#ifndef NO_OPTIMIZED_BITMAP_ACCESS
+
+#include <tools/debug.hxx>
+#define _SOLAR__PRIVATE 1
+#include <bmpacc.hxx>
+
+//#define FAST_ARGB_BGRA
+
+#include <stdlib.h>
+static bool bDisableFastBitops = (getenv( "SAL_DISABLE_BITMAPS_OPTS" ) != NULL);
+
+typedef unsigned char PIXBYTE;
+
+class BasePixelPtr
+{
+public:
+            BasePixelPtr( PIXBYTE* p = NULL ) : mpPixel( p ) {}
+    void    SetRawPtr( PIXBYTE* pRawPtr )               { mpPixel = pRawPtr; }
+    PIXBYTE* GetRawPtr( void ) const                    { return mpPixel; }
+    void    AddByteOffset( int nByteOffset )            { mpPixel += nByteOffset; }
+    bool    operator<( const BasePixelPtr& rCmp ) const { return (mpPixel < rCmp.mpPixel); }
+   
+protected:
+   PIXBYTE* mpPixel;
+};
+
+template <ULONG PIXFMT>
+class TrueColorPixelPtr : public BasePixelPtr
+{
+public:
+    PIXBYTE GetRed() const;
+    PIXBYTE GetGreen() const;
+    PIXBYTE GetBlue() const;
+    PIXBYTE GetAlpha() const;
+    
+    void    SetColor( PIXBYTE r, PIXBYTE g, PIXBYTE b ) const;
+    void    SetAlpha( PIXBYTE a ) const;
+    void    operator++(int);
+};
+
+// =======================================================================
+// template specializations for truecolor pixel formats
+
+template <>
+class TrueColorPixelPtr<BMP_FORMAT_24BIT_TC_RGB> : public BasePixelPtr
+{
+public:
+    void    operator++()       { mpPixel += 3; }
+    
+    PIXBYTE GetRed() const     { return mpPixel[0]; }
+    PIXBYTE GetGreen() const   { return mpPixel[1]; }
+    PIXBYTE GetBlue() const    { return mpPixel[2]; }
+    PIXBYTE GetAlpha() const   { return 0; }
+    void SetAlpha( PIXBYTE ) const {}
+    
+    void SetColor( PIXBYTE r, PIXBYTE g, PIXBYTE b ) const
+    {
+        mpPixel[0] = r;
+        mpPixel[1] = g;
+        mpPixel[2] = b;
+    }
+};
+
+template <>
+class TrueColorPixelPtr<BMP_FORMAT_24BIT_TC_BGR> : public BasePixelPtr
+{
+public:
+    void    operator++()        { mpPixel += 3; }
+    
+    PIXBYTE GetRed() const      { return mpPixel[2]; }
+    PIXBYTE GetGreen() const    { return mpPixel[1]; }
+    PIXBYTE GetBlue() const     { return mpPixel[0]; }
+    PIXBYTE GetAlpha() const    { return 0; }
+    void SetAlpha( PIXBYTE ) const  {}
+    
+    void SetColor( PIXBYTE r, PIXBYTE g, PIXBYTE b ) const
+    {
+        mpPixel[0] = b;
+        mpPixel[1] = g;
+        mpPixel[2] = r;
+    }
+};
+
+template <>
+class TrueColorPixelPtr<BMP_FORMAT_32BIT_TC_ARGB> : public BasePixelPtr
+{
+public:
+    void    operator++()        { mpPixel += 4; }
+    
+    PIXBYTE GetRed() const      { return mpPixel[1]; }
+    PIXBYTE GetGreen() const    { return mpPixel[2]; }
+    PIXBYTE GetBlue() const     { return mpPixel[3]; }
+    PIXBYTE GetAlpha() const    { return mpPixel[0]; }
+    void SetAlpha( PIXBYTE a ) const { mpPixel[0] = a; }
+    
+    void SetColor( PIXBYTE r, PIXBYTE g, PIXBYTE b ) const
+    {
+        mpPixel[1] = r;
+        mpPixel[2] = g;
+        mpPixel[3] = b;
+    }
+};
+
+template <>
+class TrueColorPixelPtr<BMP_FORMAT_32BIT_TC_ABGR> : public BasePixelPtr
+{
+public:
+    void    operator++()        { mpPixel += 4; }
+    
+    PIXBYTE GetRed() const      { return mpPixel[3]; }
+    PIXBYTE GetGreen() const    { return mpPixel[2]; }
+    PIXBYTE GetBlue() const     { return mpPixel[1]; }
+    PIXBYTE GetAlpha() const    { return mpPixel[0]; }
+    void SetAlpha( PIXBYTE a ) const { mpPixel[0] = a; }
+    
+    void SetColor( PIXBYTE r, PIXBYTE g, PIXBYTE b ) const
+    {
+        mpPixel[1] = b;
+        mpPixel[2] = g;
+        mpPixel[3] = r;
+    }
+};
+
+template <>
+class TrueColorPixelPtr<BMP_FORMAT_32BIT_TC_RGBA> : public BasePixelPtr
+{
+public:
+    void    operator++()            { mpPixel += 4; }
+    
+    PIXBYTE GetRed() const          { return mpPixel[0]; }
+    PIXBYTE GetGreen() const        { return mpPixel[1]; }
+    PIXBYTE GetBlue() const         { return mpPixel[2]; }
+    PIXBYTE GetAlpha() const        { return mpPixel[3]; }
+    void SetAlpha( PIXBYTE a ) const{ mpPixel[3] = a; }
+    
+    void SetColor( PIXBYTE r, PIXBYTE g, PIXBYTE b ) const
+    {
+        mpPixel[0] = r;
+        mpPixel[1] = g;
+        mpPixel[2] = b;
+    }
+};
+
+template <>
+class TrueColorPixelPtr<BMP_FORMAT_32BIT_TC_BGRA> : public BasePixelPtr
+{
+public:
+    void    operator++()            { mpPixel += 4; }
+    
+    PIXBYTE GetRed() const          { return mpPixel[2]; }
+    PIXBYTE GetGreen() const        { return mpPixel[1]; }
+    PIXBYTE GetBlue() const         { return mpPixel[0]; }
+    PIXBYTE GetAlpha() const        { return mpPixel[3]; }
+    void SetAlpha( PIXBYTE a ) const{ mpPixel[3] = a; }
+    
+    void SetColor( PIXBYTE r, PIXBYTE g, PIXBYTE b ) const
+    {
+        mpPixel[0] = b;
+        mpPixel[1] = g;
+        mpPixel[2] = r;
+    }
+};
+
+template <>
+class TrueColorPixelPtr<BMP_FORMAT_16BIT_TC_MSB_MASK> : public BasePixelPtr
+{
+public:
+    void    operator++()            { mpPixel += 2; }
+    
+    // TODO: non565-RGB
+    PIXBYTE GetRed() const          { return (mpPixel[0] & 0xF8U); }
+    PIXBYTE GetGreen() const        { return (mpPixel[0]<<5U) | ((mpPixel[1]>>3U)&28U); }
+    PIXBYTE GetBlue() const         { return (mpPixel[1]<<3U); }
+    PIXBYTE GetAlpha() const        { return 0; }
+    void SetAlpha( PIXBYTE ) const  {}
+    
+    void SetColor( PIXBYTE r, PIXBYTE g, PIXBYTE b ) const
+    {
+        mpPixel[0] = ((g >> 5U) & 7U) | (r & 0xF8U);
+        mpPixel[1] = ((g & 28U)<< 3U) | (b >> 3U);
+    }
+};
+
+template <>
+class TrueColorPixelPtr<BMP_FORMAT_16BIT_TC_LSB_MASK> : public BasePixelPtr
+{
+public:
+    void    operator++()            { mpPixel += 2; }
+    
+    // TODO: non565-RGB
+    PIXBYTE GetRed() const          { return (mpPixel[1] & 0xF8U); }
+    PIXBYTE GetGreen() const        { return (mpPixel[1]<<5U) | ((mpPixel[0]>>3U)&28U); }
+    PIXBYTE GetBlue() const         { return (mpPixel[0]<<3U); }
+    PIXBYTE GetAlpha() const        { return 0; }
+    void SetAlpha( PIXBYTE ) const  {}
+    
+    void SetColor( PIXBYTE r, PIXBYTE g, PIXBYTE b ) const
+    {
+        mpPixel[0] = ((g & 28U)<< 3U) | (b >> 3U);
+        mpPixel[1] = ((g >> 5U) & 7U) | (r & 0xF8U);
+    }
+};
+
+// -----------------------------------------------------------------------
+
+template <>
+class TrueColorPixelPtr<BMP_FORMAT_8BIT_TC_MASK> : public BasePixelPtr
+{
+public:
+    void    operator++()                    { mpPixel += 1; }
+    PIXBYTE GetAlpha() const                { return mpPixel[0]; }
+    void    SetAlpha( PIXBYTE a ) const     { mpPixel[0] = a; }
+    void    SetColor( PIXBYTE, PIXBYTE, PIXBYTE ) const {}
+};
+
+// TODO: for some reason many Alpha maps are BMP_FORMAT_8BIT_PAL
+// they should be BMP_FORMAT_8BIT_TC_MASK
+template <>
+class TrueColorPixelPtr<BMP_FORMAT_8BIT_PAL>
+: public TrueColorPixelPtr<BMP_FORMAT_8BIT_TC_MASK>
+{};
+
+#if 0
+template <>
+class TrueColorPixelPtr<BMP_FORMAT_24BIT_TC_MASK> : public BasePixelPtr
+{
+public:
+    void operator++()   { mpPixel += 3; }
+
+    unsigned GetAlpha() const
+    {
+        unsigned nAlpha = mpPixel[0];
+        nAlpha |= mpPixel[1] << 8U;
+        nAlpha |= mpPixel[2] << 16U;
+        return nAlpha;
+    }
+
+    void SetAlpha( unsigned nAlpha ) const
+    {
+        mpPixel[0] = nAlpha;
+        mpPixel[1] = nAlpha >> 8U;
+        mpPixel[2] = nAlpha >> 16U;
+    }
+};
+
+template <>
+class TrueColorPixelPtr<BMP_FORMAT_32BIT_TC_MASK> : public BasePixelPtr
+{
+public:
+    void operator++()   { mpPixel += 4; }
+    
+    unsigned GetAlpha() const
+    {
+#ifdef OSL_BIGENDIAN
+        unsigned nAlpha = *reinterpret_cast<unsigned*>( mpPixel );
+#else
+        unsigned nAlpha = mpPixel[0];
+        nAlpha |= mpPixel[1] << 8U;
+        nAlpha |= mpPixel[2] << 16U;
+        nAlpha |= mpPixel[3] << 24U;
+#endif
+        return nAlpha;
+    }
+    
+    void SetAlpha( unsigned nAlpha ) const
+    {
+#ifdef OSL_BIGENDIAN
+        *reinterpret_cast<unsigned*>( mpPixel ) = nAlpha;
+#else
+        mpPixel[0] = nAlpha;
+        mpPixel[1] = nAlpha >> 8U;
+        mpPixel[2] = nAlpha >> 16U;
+        mpPixel[3] = nAlpha >> 24U;
+#endif
+    }
+};
+
+#endif
+
+// =======================================================================
+// converting truecolor formats
+
+template <ULONG SRCFMT, ULONG DSTFMT>
+inline void ImplConvertPixel( const TrueColorPixelPtr<DSTFMT>& rDst,
+    const TrueColorPixelPtr<SRCFMT>& rSrc )
+{
+    rDst.SetColor( rSrc.GetRed(), rSrc.GetGreen(), rSrc.GetBlue() );
+    rDst.SetAlpha( rSrc.GetAlpha() );
+}
+
+// -----------------------------------------------------------------------
+
+template <>
+inline void ImplConvertPixel<BMP_FORMAT_16BIT_TC_LSB_MASK, BMP_FORMAT_16BIT_TC_MSB_MASK> (
+    const TrueColorPixelPtr<BMP_FORMAT_16BIT_TC_MSB_MASK>& rDst,
+    const TrueColorPixelPtr<BMP_FORMAT_16BIT_TC_LSB_MASK>& rSrc )
+{
+    // byte swapping
+    const PIXBYTE* pSrc = rSrc.GetRawPtr();
+    PIXBYTE* pDst = rDst.GetRawPtr();
+    pDst[1] = pSrc[0];
+    pDst[0] = pSrc[1];
+}
+
+// -----------------------------------------------------------------------
+
+template <ULONG SRCFMT, ULONG DSTFMT>
+inline void ImplConvertLine( const TrueColorPixelPtr<DSTFMT>& rDst,
+    const TrueColorPixelPtr<SRCFMT>& rSrc, int nPixelCount )
+{
+    TrueColorPixelPtr<DSTFMT> aDst( rDst );
+    TrueColorPixelPtr<SRCFMT> aSrc( rSrc );
+    while( --nPixelCount >= 0 )
+    {
+        ImplConvertPixel( aDst, aSrc );
+        ++aSrc;
+        ++aDst;
+    }
+}
+
+// =======================================================================
+// alpha blending truecolor pixels
+
+template <unsigned ALPHABITS, ULONG SRCFMT, ULONG DSTFMT>
+inline void ImplBlendPixels( const TrueColorPixelPtr<DSTFMT>& rDst,
+    const TrueColorPixelPtr<SRCFMT>& rSrc, unsigned nAlphaVal )
+{
+    if( !nAlphaVal )
+        ImplConvertPixel( rDst, rSrc );
+    else if( nAlphaVal != ~(~0 << ALPHABITS) )
+    {
+        static const unsigned nAlphaShift = (ALPHABITS > 8) ? 8 : ALPHABITS;
+        if( ALPHABITS > nAlphaShift )
+            nAlphaVal >>= ALPHABITS - nAlphaShift;
+
+        int nR = rDst.GetRed();
+        int nS = rSrc.GetRed();
+        nR = nS + (((nR - nS) * nAlphaVal) >> nAlphaShift);
+
+        int nG = rDst.GetGreen();
+        nS = rSrc.GetGreen();
+        nG = nS + (((nG - nS) * nAlphaVal) >> nAlphaShift);
+
+        int nB = rDst.GetBlue();
+        nS = rSrc.GetBlue();
+        nB = nS + (((nB - nS) * nAlphaVal) >> nAlphaShift);
+
+        rDst.SetColor( nR, nG, nB );
+    }
+}
+
+// -----------------------------------------------------------------------
+
+template <unsigned ALPHABITS, ULONG MASKFMT, ULONG SRCFMT, ULONG DSTFMT>
+inline void ImplBlendLines( const TrueColorPixelPtr<DSTFMT>& rDst,
+    const TrueColorPixelPtr<SRCFMT>& rSrc, const TrueColorPixelPtr<MASKFMT>& rMsk,
+    int nPixelCount )
+{
+    TrueColorPixelPtr<MASKFMT> aMsk( rMsk );
+    TrueColorPixelPtr<DSTFMT> aDst( rDst );
+    TrueColorPixelPtr<SRCFMT> aSrc( rSrc );
+    while( --nPixelCount >= 0 )
+    {
+        ImplBlendPixels<ALPHABITS>( aDst, aSrc, aMsk.GetAlpha() );
+        ++aDst;
+        ++aSrc;
+        ++aMsk;
+    }
+}
+
+// -----------------------------------------------------------------------
+
+template <unsigned ALPHABITS, ULONG SRCFMT, ULONG DSTFMT>
+inline void ImplBlendLines( const TrueColorPixelPtr<DSTFMT>& rDst,
+    const TrueColorPixelPtr<SRCFMT>& rSrc, unsigned nAlphaVal,
+    int nPixelCount )
+{
+    if( nAlphaVal == ~(~0 << ALPHABITS) )
+        ImplConvertLine( rDst, rSrc, nPixelCount );
+    else if( nAlphaVal )
+    {
+        TrueColorPixelPtr<SRCFMT> aSrc( rSrc );
+        TrueColorPixelPtr<DSTFMT> aDst( rDst );
+        while( --nPixelCount >= 0 )
+        {
+            ImplBlendPixels<ALPHABITS>( aDst, aSrc, nAlphaVal );
+            ++aDst;
+            ++aSrc;
+        }
+    }
+}
+
+// =======================================================================
+
+static bool ImplCopyImage( BitmapBuffer& rDstBuffer, const BitmapBuffer& rSrcBuffer )
+{
+    const int nSrcLinestep = rSrcBuffer.mnScanlineSize;
+    int nDstLinestep = rDstBuffer.mnScanlineSize;
+    
+    const PIXBYTE* pRawSrc = rSrcBuffer.mpBits;
+    PIXBYTE* pRawDst = rDstBuffer.mpBits;
+
+    // source and destination don't match upside down
+    if( BMP_FORMAT_TOP_DOWN & (rSrcBuffer.mnFormat ^ rDstBuffer.mnFormat)  )
+    {
+        pRawDst += (rSrcBuffer.mnHeight - 1) * nDstLinestep;
+        nDstLinestep = -rDstBuffer.mnScanlineSize;
+    }
+    else if( nSrcLinestep == nDstLinestep )
+    {
+        memcpy( pRawDst, pRawSrc, rSrcBuffer.mnHeight * nDstLinestep );
+        return true;
+    }
+    
+    int nByteWidth = nSrcLinestep;
+    if( nByteWidth > rDstBuffer.mnScanlineSize )
+        nByteWidth = rDstBuffer.mnScanlineSize;
+    
+    for( int y = rSrcBuffer.mnHeight; --y >= 0; )
+    {
+        memcpy( pRawDst, pRawSrc, nByteWidth );
+        pRawSrc += nSrcLinestep;
+        pRawDst += nDstLinestep;
+    }
+    
+    return true;
+}
+
+// -----------------------------------------------------------------------
+
+template <ULONG DSTFMT,ULONG SRCFMT>
+static bool ImplConvertToBitmap( TrueColorPixelPtr<SRCFMT>& rSrcLine,
+    BitmapBuffer& rDstBuffer, const BitmapBuffer& rSrcBuffer )
+{
+    // help the compiler to avoid instantiations of unneeded conversions
+    DBG_ASSERT( SRCFMT != DSTFMT, "ImplConvertToBitmap into same format");
+    if( SRCFMT == DSTFMT )
+        return false;
+        
+    const int nSrcLinestep = rSrcBuffer.mnScanlineSize;
+    int nDstLinestep = rDstBuffer.mnScanlineSize;
+    
+    TrueColorPixelPtr<DSTFMT> aDstLine; aDstLine.SetRawPtr( rDstBuffer.mpBits );
+    
+    // source and destination don't match upside down
+    if( BMP_FORMAT_TOP_DOWN & (rSrcBuffer.mnFormat ^ rDstBuffer.mnFormat) )
+    {
+        aDstLine.AddByteOffset( (rSrcBuffer.mnHeight - 1) * nDstLinestep );
+        nDstLinestep = -nDstLinestep;
+    }
+        
+    for( int y = rSrcBuffer.mnHeight; --y >= 0; )
+    {
+        ImplConvertLine( aDstLine, rSrcLine, rSrcBuffer.mnWidth );
+        rSrcLine.AddByteOffset( nSrcLinestep );
+        aDstLine.AddByteOffset( nDstLinestep );
+    }
+    
+    return true;
+}
+
+// -----------------------------------------------------------------------
+
+template <ULONG SRCFMT>
+inline bool ImplConvertFromBitmap( BitmapBuffer& rDst, const BitmapBuffer& rSrc )
+{
+    TrueColorPixelPtr<SRCFMT> aSrcType; aSrcType.SetRawPtr( rSrc.mpBits );
+    
+    // select the matching instantiation for the destination's bitmap format
+    switch( rDst.mnFormat & ~BMP_FORMAT_TOP_DOWN )
+    {
+        case BMP_FORMAT_1BIT_MSB_PAL:
+        case BMP_FORMAT_1BIT_LSB_PAL:
+        case BMP_FORMAT_4BIT_MSN_PAL:
+        case BMP_FORMAT_4BIT_LSN_PAL:
+        case BMP_FORMAT_8BIT_PAL:
+            break;
+        
+        case BMP_FORMAT_8BIT_TC_MASK:
+//            return ImplConvertToBitmap<BMP_FORMAT_8BIT_TC_MASK>( aSrcType, rDst, rSrc );
+        case BMP_FORMAT_24BIT_TC_MASK:
+//            return ImplConvertToBitmap<BMP_FORMAT_24BIT_TC_MASK>( aSrcType, rDst, rSrc );
+        case BMP_FORMAT_32BIT_TC_MASK:
+//            return ImplConvertToBitmap<BMP_FORMAT_32BIT_TC_MASK>( aSrcType, rDst, rSrc );
+            break;
+        
+        case BMP_FORMAT_16BIT_TC_MSB_MASK:
+            return ImplConvertToBitmap<BMP_FORMAT_16BIT_TC_MSB_MASK>( aSrcType, rDst, rSrc );
+        case BMP_FORMAT_16BIT_TC_LSB_MASK:
+            return ImplConvertToBitmap<BMP_FORMAT_16BIT_TC_LSB_MASK>( aSrcType, rDst, rSrc );
+        
+        case BMP_FORMAT_24BIT_TC_BGR:
+            return ImplConvertToBitmap<BMP_FORMAT_24BIT_TC_BGR>( aSrcType, rDst, rSrc );
+        case BMP_FORMAT_24BIT_TC_RGB:
+            return ImplConvertToBitmap<BMP_FORMAT_24BIT_TC_RGB>( aSrcType, rDst, rSrc );
+
+        case BMP_FORMAT_32BIT_TC_ABGR:
+            return ImplConvertToBitmap<BMP_FORMAT_32BIT_TC_ABGR>( aSrcType, rDst, rSrc );
+#ifdef FAST_ARGB_BGRA
+        case BMP_FORMAT_32BIT_TC_ARGB:
+            return ImplConvertToBitmap<BMP_FORMAT_32BIT_TC_ARGB>( aSrcType, rDst, rSrc );
+        case BMP_FORMAT_32BIT_TC_BGRA:
+            return ImplConvertToBitmap<BMP_FORMAT_32BIT_TC_BGRA>( aSrcType, rDst, rSrc );
+#endif           
+        case BMP_FORMAT_32BIT_TC_RGBA:
+            return ImplConvertToBitmap<BMP_FORMAT_32BIT_TC_RGBA>( aSrcType, rDst, rSrc );
+    }
+    
+    static int nNotAccelerated = 0;
+    DBG_ASSERT( ++nNotAccelerated!=100, "ImplConvertFromBitmap for not accelerated case" );
+    return false;
+}
+    
+// =======================================================================
+
+// an universal stretching conversion is overkill in most common situations
+// => performance benefits for speeding up the non-stretching cases
+bool ImplFastBitmapConversion( BitmapBuffer& rDst, const BitmapBuffer& rSrc,
+    const SalTwoRect& rTR )
+{
+    if( bDisableFastBitops )
+        return false;
+
+    // horizontal mirroring not implemented yet
+    if( rTR.mnDestWidth < 0 )
+        return false;
+    // vertical mirroring
+    if( rTR.mnDestHeight < 0 )
+        // TODO: rDst.mnFormat ^= BMP_FORMAT_TOP_DOWN;
+        return false;
+    
+    // offseted conversion is not implemented yet
+    if( rTR.mnSrcX || rTR.mnSrcY )
+        return false;
+    if( rTR.mnDestX || rTR.mnDestY )
+        return false;
+        
+    // stretched conversion is not implemented yet
+    if( rTR.mnDestWidth != rTR.mnSrcWidth )
+        return false;
+    if( rTR.mnDestHeight!= rTR.mnSrcHeight )
+        return false;
+    
+    // check source image size
+    if( rSrc.mnWidth < rTR.mnSrcX + rTR.mnSrcWidth )
+        return false;
+    if( rSrc.mnHeight < rTR.mnSrcY + rTR.mnSrcHeight )
+        return false;
+
+    // check dest image size
+    if( rDst.mnWidth < rTR.mnDestX + rTR.mnDestWidth )
+        return false;
+    if( rDst.mnHeight < rTR.mnDestY + rTR.mnDestHeight )
+        return false;
+
+    const ULONG nSrcFormat = rSrc.mnFormat & ~BMP_FORMAT_TOP_DOWN;
+    const ULONG nDstFormat = rDst.mnFormat & ~BMP_FORMAT_TOP_DOWN;
+
+    // TODO: also implement conversions for 16bit colormasks with non-565 format
+    if( nSrcFormat & (BMP_FORMAT_16BIT_TC_LSB_MASK | BMP_FORMAT_16BIT_TC_MSB_MASK) )
+        if( rSrc.maColorMask.GetRedMask()  != 0xF800
+        ||  rSrc.maColorMask.GetGreenMask()!= 0x07E0
+        ||  rSrc.maColorMask.GetBlueMask() != 0x001F )
+            return false;
+    if( nDstFormat & (BMP_FORMAT_16BIT_TC_LSB_MASK | BMP_FORMAT_16BIT_TC_MSB_MASK) )
+        if( rDst.maColorMask.GetRedMask()  != 0xF800
+        ||  rDst.maColorMask.GetGreenMask()!= 0x07E0
+        ||  rDst.maColorMask.GetBlueMask() != 0x001F )
+            return false;
+    
+    // special handling of trivial cases
+    if( nSrcFormat == nDstFormat )
+    {
+        // accelerated palette conversions not yet implemented
+        if( rSrc.maPalette != rDst.maPalette )
+            return false;
+        return ImplCopyImage( rDst, rSrc );
+    }            
+    
+    // select the matching instantiation for the source's bitmap format
+    switch( nSrcFormat )
+    {
+        case BMP_FORMAT_1BIT_MSB_PAL:
+        case BMP_FORMAT_1BIT_LSB_PAL:
+        case BMP_FORMAT_4BIT_MSN_PAL:
+        case BMP_FORMAT_4BIT_LSN_PAL:
+        case BMP_FORMAT_8BIT_PAL:
+            break;
+        
+        case BMP_FORMAT_8BIT_TC_MASK:
+//            return ImplConvertFromBitmap<BMP_FORMAT_8BIT_TC_MASK>( rDst, rSrc );
+        case BMP_FORMAT_24BIT_TC_MASK:
+//            return ImplConvertFromBitmap<BMP_FORMAT_24BIT_TC_MASK>( rDst, rSrc );
+        case BMP_FORMAT_32BIT_TC_MASK:
+//            return ImplConvertFromBitmap<BMP_FORMAT_32BIT_TC_MASK>( rDst, rSrc );
+            break;
+        
+        case BMP_FORMAT_16BIT_TC_MSB_MASK:
+            return ImplConvertFromBitmap<BMP_FORMAT_16BIT_TC_MSB_MASK>( rDst, rSrc );
+        case BMP_FORMAT_16BIT_TC_LSB_MASK:
+            return ImplConvertFromBitmap<BMP_FORMAT_16BIT_TC_LSB_MASK>( rDst, rSrc );
+        
+        case BMP_FORMAT_24BIT_TC_BGR:
+            return ImplConvertFromBitmap<BMP_FORMAT_24BIT_TC_BGR>( rDst, rSrc );
+        case BMP_FORMAT_24BIT_TC_RGB:
+            return ImplConvertFromBitmap<BMP_FORMAT_24BIT_TC_RGB>( rDst, rSrc );
+        
+        case BMP_FORMAT_32BIT_TC_ABGR:
+            return ImplConvertFromBitmap<BMP_FORMAT_32BIT_TC_ABGR>( rDst, rSrc );
+#ifdef FAST_ARGB_BGRA
+        case BMP_FORMAT_32BIT_TC_ARGB:
+            return ImplConvertFromBitmap<BMP_FORMAT_32BIT_TC_ARGB>( rDst, rSrc );
+        case BMP_FORMAT_32BIT_TC_BGRA:
+            return ImplConvertFromBitmap<BMP_FORMAT_32BIT_TC_BGRA>( rDst, rSrc );
+#endif
+        case BMP_FORMAT_32BIT_TC_RGBA:
+            return ImplConvertFromBitmap<BMP_FORMAT_32BIT_TC_RGBA>( rDst, rSrc );
+    }
+
+    static int nNotAccelerated = 0;
+    DBG_ASSERT( ++nNotAccelerated!=100, "ImplFastBitmapConversion for not accelerated case" );
+    return false;
+}
+
+// =======================================================================
+
+template <ULONG DSTFMT,ULONG SRCFMT> //,ULONG MSKFMT>
+static bool ImplBlendToBitmap( TrueColorPixelPtr<SRCFMT>& rSrcLine,
+    BitmapBuffer& rDstBuffer, const BitmapBuffer& rSrcBuffer,
+    const BitmapBuffer& rMskBuffer )
+{
+    //DBG_ASSERT( rMskBuffer.mnFormat == MSKFMT, "FastBmp BlendImage: wrong MSKFMT" );
+    DBG_ASSERT( rMskBuffer.mnFormat == BMP_FORMAT_8BIT_PAL, "FastBmp BlendImage: unusual MSKFMT" );
+
+    const int nSrcLinestep = rSrcBuffer.mnScanlineSize;
+    int nMskLinestep = rMskBuffer.mnScanlineSize;
+    int nDstLinestep = rDstBuffer.mnScanlineSize;
+    
+    TrueColorPixelPtr<BMP_FORMAT_8BIT_PAL> aMskLine; aMskLine.SetRawPtr( rMskBuffer.mpBits );
+    TrueColorPixelPtr<DSTFMT> aDstLine; aDstLine.SetRawPtr( rDstBuffer.mpBits );
+    
+    // special case for single line masks
+    if( rMskBuffer.mnHeight == 1 )
+        nMskLinestep = 0;
+    
+    // source and mask don't match: upside down
+    if( (rSrcBuffer.mnFormat ^ rMskBuffer.mnFormat) & BMP_FORMAT_TOP_DOWN )
+    {
+        aMskLine.AddByteOffset( (rSrcBuffer.mnHeight - 1) * nMskLinestep );
+        nMskLinestep = -nMskLinestep;
+    }
+
+    // source and destination don't match: upside down
+    if( (rSrcBuffer.mnFormat ^ rDstBuffer.mnFormat) & BMP_FORMAT_TOP_DOWN )
+    {
+        aDstLine.AddByteOffset( (rSrcBuffer.mnHeight - 1) * nDstLinestep );
+        nDstLinestep = -nDstLinestep;
+    }
+        
+    for( int y = rSrcBuffer.mnHeight; --y >= 0; )
+    {
+        ImplBlendLines<8>( aDstLine, rSrcLine, aMskLine, rDstBuffer.mnWidth );
+        aDstLine.AddByteOffset( nDstLinestep );
+        rSrcLine.AddByteOffset( nSrcLinestep );
+        aMskLine.AddByteOffset( nMskLinestep );
+    }
+    
+    return true;
+}
+
+// some specializations to reduce the code size
+template <>
+inline bool ImplBlendToBitmap<BMP_FORMAT_24BIT_TC_BGR,BMP_FORMAT_24BIT_TC_BGR>(
+    TrueColorPixelPtr<BMP_FORMAT_24BIT_TC_BGR>& rSrcLine,
+    BitmapBuffer& rDstBuffer, const BitmapBuffer& rSrcBuffer,
+    const BitmapBuffer& rMskBuffer )
+ {
+    TrueColorPixelPtr<BMP_FORMAT_24BIT_TC_RGB> aSrcType; aSrcType.SetRawPtr( rSrcBuffer.mpBits );
+    return ImplBlendToBitmap<BMP_FORMAT_24BIT_TC_RGB>( aSrcType, rDstBuffer, rSrcBuffer, rMskBuffer );
+ }
+
+template <>
+inline bool ImplBlendToBitmap<BMP_FORMAT_32BIT_TC_ABGR,BMP_FORMAT_32BIT_TC_ABGR>(
+    TrueColorPixelPtr<BMP_FORMAT_32BIT_TC_ABGR>& rSrcLine,
+    BitmapBuffer& rDstBuffer, const BitmapBuffer& rSrcBuffer,
+    const BitmapBuffer& rMskBuffer )
+ {
+    TrueColorPixelPtr<BMP_FORMAT_32BIT_TC_ARGB> aSrcType; aSrcType.SetRawPtr( rSrcBuffer.mpBits );
+    return ImplBlendToBitmap<BMP_FORMAT_32BIT_TC_ARGB>( aSrcType, rDstBuffer, rSrcBuffer, rMskBuffer );
+ }
+
+template <>
+inline bool ImplBlendToBitmap<BMP_FORMAT_32BIT_TC_BGRA,BMP_FORMAT_32BIT_TC_BGRA>(
+    TrueColorPixelPtr<BMP_FORMAT_32BIT_TC_BGRA>& rSrcLine,
+    BitmapBuffer& rDstBuffer, const BitmapBuffer& rSrcBuffer,
+    const BitmapBuffer& rMskBuffer )
+ {
+    TrueColorPixelPtr<BMP_FORMAT_32BIT_TC_RGBA> aSrcType; aSrcType.SetRawPtr( rSrcBuffer.mpBits );
+    return ImplBlendToBitmap<BMP_FORMAT_32BIT_TC_RGBA>( aSrcType, rDstBuffer, rSrcBuffer, rMskBuffer );
+ }
+
+// -----------------------------------------------------------------------
+
+template <ULONG SRCFMT>
+static bool ImplBlendFromBitmap( BitmapBuffer& rDst, const BitmapBuffer& rSrc, const BitmapBuffer& rMsk )
+{
+    TrueColorPixelPtr<SRCFMT> aSrcType; aSrcType.SetRawPtr( rSrc.mpBits );
+    
+    // select the matching instantiation for the destination's bitmap format
+    switch( rDst.mnFormat & ~BMP_FORMAT_TOP_DOWN )
+    {
+        case BMP_FORMAT_1BIT_MSB_PAL:
+        case BMP_FORMAT_1BIT_LSB_PAL:
+        case BMP_FORMAT_4BIT_MSN_PAL:
+        case BMP_FORMAT_4BIT_LSN_PAL:
+        case BMP_FORMAT_8BIT_PAL:
+            break;
+        
+        case BMP_FORMAT_8BIT_TC_MASK:
+//            return ImplBlendToBitmap<BMP_FORMAT_8BIT_TC_MASK>( aSrcType, rDst, rSrc, rMsk );
+        case BMP_FORMAT_24BIT_TC_MASK:
+//            return ImplBlendToBitmap<BMP_FORMAT_24BIT_TC_MASK>( aSrcType, rDst, rSrc, rMsk );
+        case BMP_FORMAT_32BIT_TC_MASK:
+//            return ImplBlendToBitmap<BMP_FORMAT_32BIT_TC_MASK>( aSrcType, rDst, rSrc, rMsk );
+            break;
+        
+        case BMP_FORMAT_16BIT_TC_MSB_MASK:
+            return ImplBlendToBitmap<BMP_FORMAT_16BIT_TC_MSB_MASK>( aSrcType, rDst, rSrc, rMsk );
+        case BMP_FORMAT_16BIT_TC_LSB_MASK:
+            return ImplBlendToBitmap<BMP_FORMAT_16BIT_TC_LSB_MASK>( aSrcType, rDst, rSrc, rMsk );
+        
+        case BMP_FORMAT_24BIT_TC_BGR:
+            return ImplBlendToBitmap<BMP_FORMAT_24BIT_TC_BGR>( aSrcType, rDst, rSrc, rMsk );
+        case BMP_FORMAT_24BIT_TC_RGB:
+            return ImplBlendToBitmap<BMP_FORMAT_24BIT_TC_RGB>( aSrcType, rDst, rSrc, rMsk );
+
+        case BMP_FORMAT_32BIT_TC_ABGR:
+            return ImplBlendToBitmap<BMP_FORMAT_32BIT_TC_ABGR>( aSrcType, rDst, rSrc, rMsk );
+#ifdef FAST_ARGB_BGRA
+        case BMP_FORMAT_32BIT_TC_ARGB:
+            return ImplBlendToBitmap<BMP_FORMAT_32BIT_TC_ARGB>( aSrcType, rDst, rSrc, rMsk );
+        case BMP_FORMAT_32BIT_TC_BGRA:
+            return ImplBlendToBitmap<BMP_FORMAT_32BIT_TC_BGRA>( aSrcType, rDst, rSrc, rMsk );
+#endif
+        case BMP_FORMAT_32BIT_TC_RGBA:
+            return ImplBlendToBitmap<BMP_FORMAT_32BIT_TC_RGBA>( aSrcType, rDst, rSrc, rMsk );
+    }
+    
+    static int nNotAccelerated = 0;
+    DBG_ASSERT( ++nNotAccelerated!=100, "ImplConvertFromBitmap for not accelerated case" );
+    return false;
+}
+
+// -----------------------------------------------------------------------
+
+bool ImplFastBitmapBlending( BitmapWriteAccess& rDstWA,
+    const BitmapReadAccess& rSrcRA, const BitmapReadAccess& rMskRA,
+    const SalTwoRect& rTR )
+{
+    if( bDisableFastBitops )
+        return false;
+
+    // accelerated blending of paletted bitmaps not implemented yet
+    if( rSrcRA.HasPalette() )
+        return false;
+    if( rDstWA.HasPalette() )
+        return false;
+    // TODO: either get rid of mask's use of 8BIT_PAL or check the palette
+
+    // horizontal mirroring not implemented yet
+    if( rTR.mnDestWidth < 0 )
+        return false;
+    // vertical mirroring
+    if( rTR.mnDestHeight < 0 )
+        // TODO: rDst.mnFormat ^= BMP_FORMAT_TOP_DOWN;
+        return false;
+    
+    // offseted blending is not implemented yet
+    if( rTR.mnSrcX || rTR.mnSrcY )
+        return false;
+    if( rTR.mnDestX || rTR.mnDestY )
+        return false;
+        
+    // stretched blending is not implemented yet
+    if( rTR.mnDestWidth != rTR.mnSrcWidth )
+        return false;
+    if( rTR.mnDestHeight!= rTR.mnSrcHeight )
+        return false;
+    
+    // check source image size
+    if( rSrcRA.Width() < rTR.mnSrcX + rTR.mnSrcWidth )
+        return false;
+    if( rSrcRA.Height() < rTR.mnSrcY + rTR.mnSrcHeight )
+        return false;
+
+    // check mask image size
+    if( rMskRA.Width() < rTR.mnSrcX + rTR.mnSrcWidth )
+        return false;
+    if( rMskRA.Height() < rTR.mnSrcY + rTR.mnSrcHeight )
+        if( rMskRA.Height() != 1 )
+            return false;
+
+    // check dest image size
+    if( rDstWA.Width() < rTR.mnDestX + rTR.mnDestWidth )
+        return false;
+    if( rDstWA.Height() < rTR.mnDestY + rTR.mnDestHeight )
+        return false;
+    
+    BitmapBuffer& rDst = *rDstWA.ImplGetBitmapBuffer();
+    const BitmapBuffer& rSrc = *rSrcRA.ImplGetBitmapBuffer();
+    const BitmapBuffer& rMsk = *rMskRA.ImplGetBitmapBuffer();
+
+    const ULONG nSrcFormat = rSrc.mnFormat & ~BMP_FORMAT_TOP_DOWN;
+    const ULONG nDstFormat = rDst.mnFormat & ~BMP_FORMAT_TOP_DOWN;
+    
+    // accelerated conversions for 16bit colormasks with non-565 format are not yet implemented
+    if( nSrcFormat & (BMP_FORMAT_16BIT_TC_LSB_MASK | BMP_FORMAT_16BIT_TC_MSB_MASK) )
+        if( rSrc.maColorMask.GetRedMask()  != 0xF800
+        ||  rSrc.maColorMask.GetGreenMask()!= 0x07E0
+        ||  rSrc.maColorMask.GetBlueMask() != 0x001F)
+            return false;
+    if( nDstFormat & (BMP_FORMAT_16BIT_TC_LSB_MASK | BMP_FORMAT_16BIT_TC_MSB_MASK) )
+        if( rDst.maColorMask.GetRedMask()  != 0xF800
+        ||  rDst.maColorMask.GetGreenMask()!= 0x07E0
+        ||  rDst.maColorMask.GetBlueMask() != 0x001F)
+            return false;
+    
+    // select the matching instantiation for the source's bitmap format
+    switch( nSrcFormat )
+    {
+        case BMP_FORMAT_1BIT_MSB_PAL:
+        case BMP_FORMAT_1BIT_LSB_PAL:
+        case BMP_FORMAT_4BIT_MSN_PAL:
+        case BMP_FORMAT_4BIT_LSN_PAL:
+        case BMP_FORMAT_8BIT_PAL:
+            break;
+        
+        case BMP_FORMAT_8BIT_TC_MASK:
+//            return ImplBlendFromBitmap<BMP_FORMAT_8BIT_TC_MASK>( rDst, rSrc );
+        case BMP_FORMAT_24BIT_TC_MASK:
+//            return ImplBlendFromBitmap<BMP_FORMAT_24BIT_TC_MASK>( rDst, rSrc );
+        case BMP_FORMAT_32BIT_TC_MASK:
+//            return ImplBlendFromBitmap<BMP_FORMAT_32BIT_TC_MASK>( rDst, rSrc );
+            break;
+        
+        case BMP_FORMAT_16BIT_TC_MSB_MASK:
+            return ImplBlendFromBitmap<BMP_FORMAT_16BIT_TC_MSB_MASK>( rDst, rSrc, rMsk );
+        case BMP_FORMAT_16BIT_TC_LSB_MASK:
+            return ImplBlendFromBitmap<BMP_FORMAT_16BIT_TC_LSB_MASK>( rDst, rSrc, rMsk );
+        
+        case BMP_FORMAT_24BIT_TC_BGR:
+            return ImplBlendFromBitmap<BMP_FORMAT_24BIT_TC_BGR>( rDst, rSrc, rMsk );
+        case BMP_FORMAT_24BIT_TC_RGB:
+            return ImplBlendFromBitmap<BMP_FORMAT_24BIT_TC_RGB>( rDst, rSrc, rMsk );
+        
+        case BMP_FORMAT_32BIT_TC_ABGR:
+            return ImplBlendFromBitmap<BMP_FORMAT_32BIT_TC_ABGR>( rDst, rSrc, rMsk );
+#ifdef FAST_ARGB_BGRA
+        case BMP_FORMAT_32BIT_TC_ARGB:
+            return ImplBlendFromBitmap<BMP_FORMAT_32BIT_TC_ARGB>( rDst, rSrc, rMsk );
+        case BMP_FORMAT_32BIT_TC_BGRA:
+            return ImplBlendFromBitmap<BMP_FORMAT_32BIT_TC_BGRA>( rDst, rSrc, rMsk );
+#endif
+        case BMP_FORMAT_32BIT_TC_RGBA:
+            return ImplBlendFromBitmap<BMP_FORMAT_32BIT_TC_RGBA>( rDst, rSrc, rMsk );
+    }
+
+    static int nNotAccelerated = 0;
+    DBG_ASSERT( ++nNotAccelerated!=100, "ImplFastBlend invoked for not accelerated case" );
+    return false;
+}
+
+// =======================================================================
+
+#else // NO_OPTIMIZED_BITMAP_ACCESS
+
+bool ImplFastBitmapConversion( BitmapBuffer&, const BitmapBuffer& )
+{
+    return false;
+}
+
+bool ImplFastBitmapBlending( BitmapWriteAccess&,
+    const BitmapReadAccess&, const BitmapReadAccess&,
+    const Size&, const Point& )
+{
+    return false;
+}
+
+#endif
--- /dev/null	2004-08-25 23:04:59.000000000 +0530
+++ vcl/source/helper/canvasbitmap.cxx	2005-02-28 13:40:59.000000000 +0530
@@ -0,0 +1,555 @@
+/*************************************************************************
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
+ *
+ *  Copyright: 2000 by Sun Microsystems, Inc.
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+#ifndef _COM_SUN_STAR_RENDERING_ENDIANNESS_HPP_
+#include <com/sun/star/rendering/Endianness.hpp>
+#endif
+#ifndef _COM_SUN_STAR_RENDERING_INTEGERBITMAPFORMAT_HPP_
+#include <com/sun/star/rendering/IntegerBitmapFormat.hpp>
+#endif
+
+#ifndef _VOS_MUTEX_HXX
+#include <vos/mutex.hxx>
+#endif
+
+#include <canvasbitmap.hxx>
+#include <canvastools.hxx>
+#include <bmpacc.hxx>
+#include <svapp.hxx>
+
+using namespace vcl::unotools;
+using namespace com::sun::star::uno;
+using namespace ::com::sun::star::rendering;
+using namespace com::sun::star::lang;
+using namespace ::com::sun::star::geometry;
+
+VclCanvasBitmap::VclCanvasBitmap( const BitmapEx& rBitmap ) :
+    m_pBitmap( new BitmapEx(rBitmap) )
+{
+    vos::OGuard aGuard( Application::GetSolarMutex() );
+    Size aSz = m_pBitmap->GetSizePixel();
+    if( m_pBitmap->IsTransparent() )
+    {
+        m_aLayout.ScanLines         = aSz.Height();
+        m_aLayout.ScanLineBytes     = aSz.Width()*4;
+        m_aLayout.ScanLineStride    = 0;
+        m_aLayout.PlaneStride       = 0;
+        m_aLayout.NumComponents     = 4;
+        m_aLayout.ComponentMasks.realloc( 4 );
+        sal_Int64* pMasks = m_aLayout.ComponentMasks.getArray();
+        pMasks[0] = 0xff000000LL;
+        pMasks[1] = 0x00ff0000LL;
+        pMasks[2] = 0x0000ff00LL;
+        pMasks[3] = 0x000000ffLL;
+        m_aLayout.Endianness        = Endianness::BIG;
+        m_aLayout.Format            = IntegerBitmapFormat::CHUNKY_32BIT;
+        m_aLayout.IsPseudoColor     = sal_False;
+    }
+    else
+    {
+        Bitmap aBmp = m_pBitmap->GetBitmap();
+        BitmapReadAccess* pAcc = aBmp.AcquireReadAccess();
+        m_aLayout.ScanLines         = pAcc->Height();
+        m_aLayout.ScanLineBytes     = pAcc->GetScanlineSize();
+        m_aLayout.ScanLineStride    = m_aLayout.ScanLineBytes - pAcc->Width()*pAcc->GetBitCount()/8;
+        m_aLayout.PlaneStride       = 0;
+        switch( pAcc->GetScanlineFormat() )
+        {
+            case BMP_FORMAT_1BIT_MSB_PAL:
+                m_aLayout.NumComponents     = 1;
+                m_aLayout.ComponentMasks.realloc( 1 );
+                m_aLayout.ComponentMasks.getArray()[0] = 0x1LL;
+                m_aLayout.Endianness        = Endianness::BIG;
+                m_aLayout.Format            = IntegerBitmapFormat::CHUNKY_1BIT;
+                m_aLayout.IsPseudoColor     = sal_True;
+                break;
+            case BMP_FORMAT_1BIT_LSB_PAL:
+                m_aLayout.NumComponents     = 1;
+                m_aLayout.ComponentMasks.realloc( 1 );
+                m_aLayout.ComponentMasks.getArray()[0] = 1LL;
+                m_aLayout.Endianness        = Endianness::LITTLE;
+                m_aLayout.Format            = IntegerBitmapFormat::CHUNKY_1BIT;
+                m_aLayout.IsPseudoColor     = sal_True;
+                break;
+            case BMP_FORMAT_4BIT_MSN_PAL:
+                m_aLayout.NumComponents     = 1;
+                m_aLayout.ComponentMasks.realloc( 1 );
+                m_aLayout.ComponentMasks.getArray()[0] = 0x0fLL;
+                m_aLayout.Endianness        = Endianness::BIG;
+                m_aLayout.Format            = IntegerBitmapFormat::CHUNKY_4BIT;
+                m_aLayout.IsPseudoColor     = sal_True;
+                break;
+            case BMP_FORMAT_4BIT_LSN_PAL:
+                m_aLayout.NumComponents     = 1;
+                m_aLayout.ComponentMasks.realloc( 1 );
+                m_aLayout.ComponentMasks.getArray()[0] = 0x0fLL;
+                m_aLayout.Endianness        = Endianness::LITTLE;
+                m_aLayout.Format            = IntegerBitmapFormat::CHUNKY_4BIT;
+                m_aLayout.IsPseudoColor     = sal_True;
+                break;
+            case BMP_FORMAT_8BIT_PAL:
+                m_aLayout.NumComponents     = 1;
+                m_aLayout.ComponentMasks.realloc( 1 );
+                m_aLayout.ComponentMasks.getArray()[0] = 0xffLL;
+                m_aLayout.Endianness        = Endianness::BIG;
+                m_aLayout.Format            = IntegerBitmapFormat::CHUNKY_8BIT;
+                m_aLayout.IsPseudoColor     = sal_True;
+                break;
+                
+            case BMP_FORMAT_8BIT_TC_MASK:
+                m_aLayout.NumComponents     = 3;
+                m_aLayout.ComponentMasks.realloc( 3 );
+                m_aLayout.ComponentMasks.getArray()[0] = pAcc->GetColorMask().GetRedMask();
+                m_aLayout.ComponentMasks.getArray()[1] = pAcc->GetColorMask().GetGreenMask();
+                m_aLayout.ComponentMasks.getArray()[2] = pAcc->GetColorMask().GetBlueMask();
+                m_aLayout.Endianness        = Endianness::BIG;
+                m_aLayout.Format            = IntegerBitmapFormat::CHUNKY_8BIT;
+                m_aLayout.IsPseudoColor     = sal_False;
+                break;
+            case BMP_FORMAT_16BIT_TC_MSB_MASK:
+                m_aLayout.NumComponents     = 3;
+                m_aLayout.ComponentMasks.realloc( 3 );
+                m_aLayout.ComponentMasks.getArray()[0] = pAcc->GetColorMask().GetRedMask();
+                m_aLayout.ComponentMasks.getArray()[1] = pAcc->GetColorMask().GetGreenMask();
+                m_aLayout.ComponentMasks.getArray()[2] = pAcc->GetColorMask().GetBlueMask();
+                m_aLayout.Endianness        = Endianness::BIG;
+                m_aLayout.Format            = IntegerBitmapFormat::CHUNKY_16BIT;
+                m_aLayout.IsPseudoColor     = sal_False;
+                break;
+            case BMP_FORMAT_16BIT_TC_LSB_MASK:
+                m_aLayout.NumComponents     = 3;
+                m_aLayout.ComponentMasks.realloc( 3 );
+                m_aLayout.ComponentMasks.getArray()[0] = pAcc->GetColorMask().GetRedMask();
+                m_aLayout.ComponentMasks.getArray()[1] = pAcc->GetColorMask().GetGreenMask();
+                m_aLayout.ComponentMasks.getArray()[2] = pAcc->GetColorMask().GetBlueMask();
+                m_aLayout.Endianness        = Endianness::LITTLE;
+                m_aLayout.Format            = IntegerBitmapFormat::CHUNKY_16BIT;
+                m_aLayout.IsPseudoColor     = sal_False;
+                break;
+            case BMP_FORMAT_24BIT_TC_BGR:
+                m_aLayout.NumComponents     = 3;
+                m_aLayout.ComponentMasks.realloc( 3 );
+                m_aLayout.ComponentMasks.getArray()[0] = 0x0000ffLL;
+                m_aLayout.ComponentMasks.getArray()[1] = 0x00ff00LL;
+                m_aLayout.ComponentMasks.getArray()[2] = 0xff0000LL;
+                m_aLayout.Endianness        = Endianness::BIG;
+                m_aLayout.Format            = IntegerBitmapFormat::CHUNKY_24BIT;
+                m_aLayout.IsPseudoColor     = sal_False;
+                break;
+            case BMP_FORMAT_24BIT_TC_RGB:
+                m_aLayout.NumComponents     = 3;
+                m_aLayout.ComponentMasks.realloc( 3 );
+                m_aLayout.ComponentMasks.getArray()[0] = 0xff0000LL;
+                m_aLayout.ComponentMasks.getArray()[1] = 0x00ff00LL;
+                m_aLayout.ComponentMasks.getArray()[2] = 0x0000ffLL;
+                m_aLayout.Endianness        = Endianness::BIG;
+                m_aLayout.Format            = IntegerBitmapFormat::CHUNKY_24BIT;
+                m_aLayout.IsPseudoColor     = sal_False;
+                break;
+            case BMP_FORMAT_24BIT_TC_MASK:
+                m_aLayout.NumComponents     = 3;
+                m_aLayout.ComponentMasks.realloc( 3 );
+                m_aLayout.ComponentMasks.getArray()[0] = pAcc->GetColorMask().GetRedMask();
+                m_aLayout.ComponentMasks.getArray()[1] = pAcc->GetColorMask().GetGreenMask();
+                m_aLayout.ComponentMasks.getArray()[2] = pAcc->GetColorMask().GetBlueMask();
+                m_aLayout.Endianness        = Endianness::LITTLE;
+                m_aLayout.Format            = IntegerBitmapFormat::CHUNKY_24BIT;
+                m_aLayout.IsPseudoColor     = sal_False;
+                break;
+            case BMP_FORMAT_32BIT_TC_ABGR:
+                m_aLayout.NumComponents     = 4;
+                m_aLayout.ComponentMasks.realloc( 4 );
+                m_aLayout.ComponentMasks.getArray()[0] = 0x000000ffLL;
+                m_aLayout.ComponentMasks.getArray()[1] = 0x0000ff00LL;
+                m_aLayout.ComponentMasks.getArray()[2] = 0x00ff0000LL;
+                m_aLayout.ComponentMasks.getArray()[3] = 0xff000000LL;
+                m_aLayout.Endianness        = Endianness::BIG;
+                m_aLayout.Format            = IntegerBitmapFormat::CHUNKY_32BIT;
+                m_aLayout.IsPseudoColor     = sal_False;
+                break;
+            case BMP_FORMAT_32BIT_TC_ARGB:
+                m_aLayout.NumComponents     = 4;
+                m_aLayout.ComponentMasks.realloc( 4 );
+                m_aLayout.ComponentMasks.getArray()[0] = 0x00ff0000LL;
+                m_aLayout.ComponentMasks.getArray()[1] = 0x0000ff00LL;
+                m_aLayout.ComponentMasks.getArray()[2] = 0x000000ffLL;
+                m_aLayout.ComponentMasks.getArray()[3] = 0xff000000LL;
+                m_aLayout.Endianness        = Endianness::BIG;
+                m_aLayout.Format            = IntegerBitmapFormat::CHUNKY_32BIT;
+                m_aLayout.IsPseudoColor     = sal_False;
+                break;
+            case BMP_FORMAT_32BIT_TC_BGRA:
+                m_aLayout.NumComponents     = 4;
+                m_aLayout.ComponentMasks.realloc( 4 );
+                m_aLayout.ComponentMasks.getArray()[0] = 0x0000ff00LL;
+                m_aLayout.ComponentMasks.getArray()[1] = 0x00ff0000LL;
+                m_aLayout.ComponentMasks.getArray()[2] = 0xff000000LL;
+                m_aLayout.ComponentMasks.getArray()[3] = 0x000000ffLL;
+                m_aLayout.Endianness        = Endianness::BIG;
+                m_aLayout.Format            = IntegerBitmapFormat::CHUNKY_32BIT;
+                m_aLayout.IsPseudoColor     = sal_False;
+                break;
+            case BMP_FORMAT_32BIT_TC_RGBA:
+                m_aLayout.NumComponents     = 4;
+                m_aLayout.ComponentMasks.realloc( 4 );
+                m_aLayout.ComponentMasks.getArray()[0] = 0xff000000LL;
+                m_aLayout.ComponentMasks.getArray()[1] = 0x00ff0000LL;
+                m_aLayout.ComponentMasks.getArray()[2] = 0x0000ff00LL;
+                m_aLayout.ComponentMasks.getArray()[3] = 0x000000ffLL;
+                m_aLayout.Endianness        = Endianness::BIG;
+                m_aLayout.Format            = IntegerBitmapFormat::CHUNKY_32BIT;
+                m_aLayout.IsPseudoColor     = sal_False;
+                break;
+            case BMP_FORMAT_32BIT_TC_MASK:
+                m_aLayout.NumComponents     = 3;
+                m_aLayout.ComponentMasks.realloc( 3 );
+                m_aLayout.ComponentMasks.getArray()[0] = pAcc->GetColorMask().GetRedMask();
+                m_aLayout.ComponentMasks.getArray()[1] = pAcc->GetColorMask().GetGreenMask();
+                m_aLayout.ComponentMasks.getArray()[2] = pAcc->GetColorMask().GetBlueMask();
+                m_aLayout.Endianness        = Endianness::LITTLE;
+                m_aLayout.Format            = IntegerBitmapFormat::CHUNKY_32BIT;
+                m_aLayout.IsPseudoColor     = sal_False;
+                break;
+            default:
+                DBG_ERROR( "unsupported bitmap format" );
+                break;
+        }
+        aBmp.ReleaseAccess( pAcc );
+    }
+}
+
+VclCanvasBitmap::~VclCanvasBitmap()
+{
+    vos::OGuard aGuard( Application::GetSolarMutex() );
+    delete m_pBitmap;
+}
+
+// XBitmap
+IntegerSize2D SAL_CALL VclCanvasBitmap::getSize() throw (RuntimeException)
+{
+    vos::OGuard aGuard( Application::GetSolarMutex() );
+
+    return integerSize2DFromSize( m_pBitmap->GetSizePixel() );
+}
+
+Reference< XBitmapCanvas > SAL_CALL VclCanvasBitmap::queryBitmapCanvas() throw (RuntimeException)
+{
+    return Reference< XBitmapCanvas >();
+}
+
+Reference< XBitmap > SAL_CALL VclCanvasBitmap::getScaledBitmap( const RealSize2D& newSize, sal_Bool beFast ) throw (RuntimeException)
+{
+    vos::OGuard aGuard( Application::GetSolarMutex() );
+    
+    BitmapEx aNewBmp( *m_pBitmap );
+    aNewBmp.Scale( sizeFromRealSize2D( newSize ), beFast ? BMP_SCALE_FAST : BMP_SCALE_INTERPOLATE );
+    return Reference<XBitmap>( new VclCanvasBitmap( aNewBmp ) );
+}
+
+// XIntegerBitmap
+Sequence< sal_Int8 > SAL_CALL VclCanvasBitmap::getData( const IntegerRectangle2D& rect ) throw (IndexOutOfBoundsException, VolatileContentDestroyedException, RuntimeException)
+{
+    vos::OGuard aGuard( Application::GetSolarMutex() );
+
+    Bitmap aBmp = m_pBitmap->GetBitmap();
+    BitmapReadAccess* pAcc = aBmp.AcquireReadAccess();
+    Sequence< sal_Int8 > aRet; 
+    if( m_pBitmap->IsTransparent() )
+    {
+        int w = pAcc->Width();
+        int h = pAcc->Height();
+        aRet.realloc( 4 * w * h );
+        sal_Int8* pContent = aRet.getArray();
+        for( int y = 0; y < h; y++ )
+            for( int x = 0; x < w; x++ )
+        {
+            BitmapColor aCol = pAcc->GetColor( x, y );
+            *pContent++ = aCol.GetRed();
+            *pContent++ = aCol.GetGreen();
+            *pContent++ = aCol.GetBlue();
+            pContent++;
+        }
+        pContent = aRet.getArray()+3;
+        if( m_pBitmap->IsAlpha() )
+        {
+            AlphaMask aAlpha = m_pBitmap->GetAlpha();
+            BitmapReadAccess* pAlphaAcc = aAlpha.AcquireReadAccess();
+            for( int y = 0; y < h; y++ )
+            {
+                Scanline pLine = pAlphaAcc->GetScanline( y );
+                for( int x = 0; x < w; x++ )
+                {
+                    *pContent = *pLine++;
+                    pContent += 4;
+                }
+            }
+            aAlpha.ReleaseAccess( pAlphaAcc );
+        }
+        else if( m_pBitmap->GetTransparentType() == TRANSPARENT_BITMAP )
+        {
+            Bitmap aMask = m_pBitmap->GetMask();
+            BitmapReadAccess* pMaskAcc = aMask.AcquireReadAccess();
+            BitmapColor aZeroCol = pMaskAcc->GetPaletteColor( 0 );
+            sal_Int8 nIndexZeroAlpha = 0xff;
+            if( !aZeroCol.GetRed() && ! aZeroCol.GetGreen() && ! aZeroCol.GetBlue() )
+                nIndexZeroAlpha = 0;
+            sal_Int8 nIndexOneAlpha = ~nIndexZeroAlpha;
+            for( int y = 0; y < h; y++ )
+                for( int x = 0; x < w; x++ )
+            {
+                *pContent = pMaskAcc->GetPixel(x,y).GetIndex() ? nIndexOneAlpha : nIndexZeroAlpha;
+                pContent += 4;
+            }
+            aMask.ReleaseAccess( pMaskAcc );
+        }
+        else if( m_pBitmap->GetTransparentType() == TRANSPARENT_COLOR )
+        {
+            sal_Int8 nR = m_pBitmap->GetTransparentColor().GetRed();
+            sal_Int8 nG = m_pBitmap->GetTransparentColor().GetGreen();
+            sal_Int8 nB = m_pBitmap->GetTransparentColor().GetBlue();
+            for( int y = 0; y < h; y++ )
+                for( int x = 0; x < w; x++ )
+            {
+                *pContent = (pContent[-3] == nR && pContent[-2] == nG && pContent[-1] == nB) ? 0xff : 0;
+                pContent += 4;
+            }
+        }
+        else
+        {
+            aBmp.ReleaseAccess( pAcc );
+            DBG_ERROR( "unsupported transparency type" );
+            throw RuntimeException();
+        }
+    }
+    else
+    {
+        int nH = pAcc->Height();
+        int nScS = pAcc->GetScanlineSize();
+        aRet.realloc( nScS * nH );
+        sal_Int8* pContent = aRet.getArray();
+        for( int i = 0; i < nH; i++ )
+        {
+            Scanline pLine = pAcc->GetScanline( i );
+            rtl_copyMemory( pContent, pLine, nScS );
+            pContent += nScS;
+        }
+    }
+    aBmp.ReleaseAccess( pAcc );
+    return aRet;
+}
+
+void SAL_CALL VclCanvasBitmap::setData( const Sequence< sal_Int8 >& data, const IntegerBitmapLayout& bitmapLayout, const IntegerRectangle2D& rect ) throw (IllegalArgumentException, IndexOutOfBoundsException, RuntimeException)
+{
+    DBG_ERROR( "this XBitmap implementation is readonly" );
+    throw IllegalArgumentException();
+}
+
+void SAL_CALL VclCanvasBitmap::setPixel( const Sequence< sal_Int8 >& color, const IntegerBitmapLayout& bitmapLayout, const IntegerPoint2D& pos ) throw (IllegalArgumentException, IndexOutOfBoundsException, RuntimeException)
+{
+    DBG_ERROR( "this XBitmap implementation is readonly" );
+    throw IllegalArgumentException();
+}
+
+Sequence< sal_Int8 > SAL_CALL VclCanvasBitmap::getPixel( const IntegerPoint2D& pos ) throw (IndexOutOfBoundsException, VolatileContentDestroyedException, RuntimeException)
+{
+    vos::OGuard aGuard( Application::GetSolarMutex() );
+
+    Point aPos = pointFromIntegerPoint2D( pos );
+    if( aPos.X() < 0 || aPos.Y() < 0 )
+        throw IndexOutOfBoundsException();
+
+    Bitmap aBmp = m_pBitmap->GetBitmap();
+    BitmapReadAccess* pAcc = aBmp.AcquireReadAccess();
+    if( aPos.X() >= pAcc->Width() || aPos.Y() >= pAcc->Height() )
+    {
+        aBmp.ReleaseAccess( pAcc );
+        throw IndexOutOfBoundsException();        
+    }
+    
+    Sequence< sal_Int8 > aRet;
+    if( m_pBitmap->IsTransparent() )
+    {
+        BitmapColor aCol = pAcc->GetColor( aPos.X(), aPos.Y() );
+        sal_Int8 nAlpha = 0;
+        if( m_pBitmap->IsAlpha() )
+        {
+            AlphaMask aMask = m_pBitmap->GetAlpha();
+            BitmapReadAccess* pAlphaAcc = aMask.AcquireReadAccess();
+            BitmapColor aAlphaCol = pAlphaAcc->GetPixel( aPos.X(), aPos.Y() );
+            nAlpha = aAlphaCol.GetIndex();
+            aMask.ReleaseAccess( pAlphaAcc );
+        }
+        else if( m_pBitmap->GetTransparentType() == TRANSPARENT_COLOR )
+        {
+            Color aTranspCol = m_pBitmap->GetTransparentColor();
+            if( aCol.GetRed()   == aTranspCol.GetRed() &&
+                aCol.GetGreen() == aTranspCol.GetGreen() &&
+                aCol.GetBlue()  == aTranspCol.GetBlue() )
+                nAlpha = 0xff;
+        }
+        else if( m_pBitmap->GetTransparentType() == TRANSPARENT_BITMAP )
+        {
+            Bitmap aMask = m_pBitmap->GetMask();
+            BitmapReadAccess* pMaskAcc = aMask.AcquireReadAccess();
+            BitmapColor aMaskColor = pMaskAcc->GetColor( aPos.X(), aPos.Y() );
+            if( aMaskColor.GetRed() || aMaskColor.GetGreen() || aMaskColor.GetBlue() )
+                nAlpha = 0xff;
+            aMask.ReleaseAccess( pMaskAcc );
+        }
+        else
+        {
+            aBmp.ReleaseAccess( pAcc );
+            DBG_ERROR( "unsupported transparency type" );
+            throw RuntimeException();
+        }
+        aRet.realloc( 4 );
+        sal_Int8* pContent = aRet.getArray();
+        *pContent++ = aCol.GetRed();
+        *pContent++ = aCol.GetGreen();
+        *pContent++ = aCol.GetBlue();
+        *pContent = nAlpha;
+    }
+    else
+    {
+        if( pAcc->GetBitCount() < 8 )
+        {
+            aRet.realloc( 1 );
+            *aRet.getArray() = pAcc->GetPixel( aPos.X(), aPos.Y() ).GetIndex();
+        }
+        else
+        {
+            int nByteSize = pAcc->GetBitCount()/4;
+            aRet.realloc( nByteSize );
+            Scanline pLine = pAcc->GetScanline( aPos.Y() );
+            rtl_copyMemory( aRet.getArray(), pLine + aPos.X() * nByteSize, nByteSize );
+        }
+    }
+    aBmp.ReleaseAccess( pAcc );
+    
+    return aRet;
+}
+
+Reference< XBitmapPalette > SAL_CALL VclCanvasBitmap::getPalette() throw (RuntimeException)
+{
+    return m_aLayout.IsPseudoColor ?
+        Reference< XBitmapPalette >( (XBitmapPalette*)this, UNO_QUERY ) :
+        Reference< XBitmapPalette >();
+}
+
+IntegerBitmapLayout SAL_CALL VclCanvasBitmap::getMemoryLayout() throw (RuntimeException)
+{
+    return m_aLayout;
+}
+
+sal_Int32 SAL_CALL VclCanvasBitmap::getNumberOfEntries() throw (RuntimeException)
+{
+    vos::OGuard aGuard( Application::GetSolarMutex() );
+    Bitmap aBmp = m_pBitmap->GetBitmap();
+    BitmapReadAccess* pAcc = aBmp.AcquireReadAccess();
+    sal_Int32 nEntries = pAcc->HasPalette() ? pAcc->GetPaletteEntryCount() : 0 ;
+    aBmp.ReleaseAccess( pAcc );
+    
+    return nEntries;
+}
+
+Sequence< double > SAL_CALL VclCanvasBitmap::getPaletteIndex( sal_Int32 nIndex ) throw (IndexOutOfBoundsException, RuntimeException)
+{
+    vos::OGuard aGuard( Application::GetSolarMutex() );
+
+    Sequence< double > aRet( 3 );
+    double* pContents = aRet.getArray();
+    Bitmap aBmp = m_pBitmap->GetBitmap();
+    BitmapReadAccess* pAcc = aBmp.AcquireReadAccess();
+    if( nIndex >= 0 && nIndex < pAcc->GetPaletteEntryCount() )
+    {
+        const BitmapColor& rColor = pAcc->GetPaletteColor( nIndex );
+        *pContents++ = double(rColor.GetRed()) / 255.0;
+        *pContents++ = double(rColor.GetGreen()) / 255.0;
+        *pContents++ = double(rColor.GetBlue()) / 255.0;
+    }
+    else
+    {
+        aBmp.ReleaseAccess( pAcc );
+        throw IndexOutOfBoundsException();
+    }
+    aBmp.ReleaseAccess( pAcc );
+    
+    return aRet;
+}
+
+sal_Bool SAL_CALL VclCanvasBitmap::setPaletteIndex( const Sequence< double >& color, sal_Int32 nIndex ) throw (IndexOutOfBoundsException, IllegalArgumentException, RuntimeException)
+{
+    return sal_False; // read only implementation
+}
+
+sal_Int64 SAL_CALL VclCanvasBitmap::getSomething( const Sequence< sal_Int8 >& aIdentifier ) throw (RuntimeException)
+{
+    vos::OGuard aGuard( Application::GetSolarMutex() );
+
+    sal_Int64 nRet = 0;
+    const Sequence< sal_Int8 >& rTest = getTunnelIdentifier( Id_BitmapEx );
+    if( aIdentifier.getLength() == rTest.getLength() &&
+        rtl_compareMemory( rTest.getConstArray(), aIdentifier.getConstArray(), rTest.getLength() ) == 0
+        )
+    {
+        nRet = (sal_Int64)m_pBitmap;
+    }
+    return nRet;
+}
--- /dev/null	2004-08-25 23:04:59.000000000 +0530
+++ offapi/com/sun/star/drawing/EnhancedCustomShapeGeometry.idl	2005-02-28 13:41:26.000000000 +0530
@@ -0,0 +1,153 @@
+/*************************************************************************
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
+ *
+ *  Copyright: 2000 by Sun Microsystems, Inc.
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+#ifndef __drafts_com_sun_star_drawing_EnhancedCustomShapeGeometry_idl__
+#define __com_sun_star_drawing_EnhancedCustomShapeGeometry_idl__
+
+#ifndef __com_sun_star_awt_Rectangle_idl__ 
+#include <com/sun/star/awt/Rectangle.idl>
+#endif
+#ifndef __com_sun_star_beans_PropertyValue_idl__
+#include <com/sun/star/beans/PropertyValue.idl>
+#endif
+#ifndef __com_sun_star_beans_PropertyValues_idl__
+#include <com/sun/star/beans/PropertyValues.idl>
+#endif
+#ifndef __com_sun_star_drawing_EnhancedCustomShapeHandle_idl__ 
+#include <com/sun/star/drawing/EnhancedCustomShapeHandle.idl>
+#endif
+#ifndef __com_sun_star_drawing_EnhancedCustomShapeAdjustmentValue_idl__ 
+#include <com/sun/star/drawing/EnhancedCustomShapeAdjustmentValue.idl>
+#endif
+
+//=============================================================================
+
+module com { module sun { module star { module drawing { 
+
+//=============================================================================
+/**
+  This service may be represented by a ::com::sun::star::beans::PropertyValue []. 
+*/
+
+service EnhancedCustomShapeGeometry
+{
+	/**
+		The Type attribute contains the name of a shape type. This name can be
+		used to offer specialized user interfaces for certain classes of shapes, like
+		for arrows, smileys, etc. The shape type is rendering engine dependent and does
+		not influence the geometry of the shape. If the value of the draw:type
+		attribute is non-primitive, then no shape type is available.
+	*/
+	[property] string Type;
+
+	/** This property describes the user space of the shape in its canonical form
+	*/
+	[optional, property] ::com::sun::star::awt::Rectangle ViewBox;
+
+	/** This property specifies if the orientation of the shape is horizontal mirrored.
+	*/
+	[optional, property] boolean MirroredX;
+
+	/** This property specifies if the orientation of the shape is vertical mirrored.
+	*/
+	[optional, property] boolean MirroredY;
+
+	/** This property specifies the text rotation angle in degrees. The text rotation is added
+	    to the shape geometry rotation.
+	*/
+	[optional, property] double TextRotateAngle;
+
+	/** This property specifies a sequence of Adjustment values.
+	*/
+	[optional, property] sequence<::com::sun::star::drawing::EnhancedCustomShapeAdjustmentValue> AdjustmentValues;
+
+	/** This property sequence is including the extrusion description, the properties
+	    are as same as specified in the service ::drafts::com::sun::star:drawing::EnhancedCustomShapeExtrusion
+	*/
+	[optional, property] sequence<::com::sun::star::beans::PropertyValue> Extrusion;
+
+	/** This property sequence is including the path description, the properties
+	    are as same as specified in the service ::drafts::com::sun::star:drawing::EnhancedCustomShapePath
+	*/
+	[optional, property] sequence<::com::sun::star::beans::PropertyValue> Path;
+
+	/** This property sequence is including the textpath description, the properties
+	    are as same as specified in the service ::drafts::com::sun::star:drawing::EnhancedCustomShapeTextPath
+	*/
+	[optional, property] sequence<::com::sun::star::beans::PropertyValue> TextPath;
+
+	/** This property is describing the equations that are used, each equation can be referenced
+		by ::com::sun::star::drawing::EnhancedCustomShapeParameter which are often used in Path, Extrusion
+		and or Handle descriptions.
+	*/
+	[optional, property] sequence<string> Equations;
+
+	/** This property is describing the interaction handles that are used, each inner property sequence
+	    is having the same properties as they are specified in the service ::drafts::com::sun::star:drawing::EnhancedCustomShapeHandle
+	*/
+	[optional, property] sequence<::com::sun::star::beans::PropertyValues> Handles;
+};
+
+//=============================================================================
+
+}; }; }; }; 
+
+#endif
+
