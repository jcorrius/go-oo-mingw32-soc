--- hsqldb/hsqldb_1_8_0
+++ hsqldb/hsqldb_1_8_0
@@ -779,3 +779,21911 @@
      <property name="hsqldb.title" value="HSQLDB"/>
      <property name="hsqldb.vendor" value="The HSQLDB Development Group"/>
      <property name="src" value="${basedir}/src"/>
+diff -pcr misc/hsqldb/src/org/hsqldb/BaseMemoryNode.java misc/build/hsqldb/src/org/hsqldb/BaseMemoryNode.java
+*** misc/hsqldb/src/org/hsqldb/BaseMemoryNode.java	2006-06-15 13:15:46.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/BaseMemoryNode.java	2007-02-28 12:32:47.000000000 +0100
+*************** import org.hsqldb.rowio.RowOutputInterfa
+*** 83,91 ****
+   */
+  abstract class BaseMemoryNode extends Node {
+  
+!     protected Node nLeft;
+!     protected Node nRight;
+!     protected Node nParent;
+  
+      void delete() {
+          iBalance = -2;
+--- 83,91 ----
+   */
+  abstract class BaseMemoryNode extends Node {
+  
+!     public Node nLeft;
+!     public Node nRight;
+!     public Node nParent;
+  
+      void delete() {
+          iBalance = -2;
+diff -pcr misc/hsqldb/src/org/hsqldb/CachedRow.java misc/build/hsqldb/src/org/hsqldb/CachedRow.java
+*** misc/hsqldb/src/org/hsqldb/CachedRow.java	2006-07-15 22:18:53.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/CachedRow.java	2007-02-28 12:32:47.000000000 +0100
+*************** public class CachedRow extends Row {
+*** 99,111 ****
+      static final int NO_POS = -1;
+  
+      //
+!     protected Table tTable;
+      int             storageSize;
+  
+      /**
+       *  Flag indicating unwritten data.
+       */
+!     protected boolean hasDataChanged;
+  
+      /**
+       *  Flag indicating Node data has changed.
+--- 99,111 ----
+      static final int NO_POS = -1;
+  
+      //
+!     public Table tTable;
+      int             storageSize;
+  
+      /**
+       *  Flag indicating unwritten data.
+       */
+!     public boolean hasDataChanged;
+  
+      /**
+       *  Flag indicating Node data has changed.
+*************** public class CachedRow extends Row {
+*** 183,189 ****
+          oData = in.readData(tTable.getColumnTypes());
+      }
+  
+!     private void readRowInfo(RowInputInterface in)
+      throws IOException, HsqlException {
+  
+          // for use when additional transaction info is attached to rows
+--- 183,189 ----
+          oData = in.readData(tTable.getColumnTypes());
+      }
+  
+!     public void readRowInfo(RowInputInterface in)
+      throws IOException, HsqlException {
+  
+          // for use when additional transaction info is attached to rows
+*************** public class CachedRow extends Row {
+*** 323,329 ****
+          } catch (IOException e) {}
+      }
+  
+!     private void writeRowInfo(RowOutputInterface out) {
+  
+          // for use when additional transaction info is attached to rows
+      }
+--- 323,329 ----
+          } catch (IOException e) {}
+      }
+  
+!     public void writeRowInfo(RowOutputInterface out) {
+  
+          // for use when additional transaction info is attached to rows
+      }
+*************** public class CachedRow extends Row {
+*** 352,358 ****
+       * @throws IOException
+       * @throws HsqlException
+       */
+!     private void writeNodes(RowOutputInterface out) throws IOException {
+  
+          out.writeSize(storageSize);
+  
+--- 352,358 ----
+       * @throws IOException
+       * @throws HsqlException
+       */
+!     public void writeNodes(RowOutputInterface out) throws IOException {
+  
+          out.writeSize(storageSize);
+  
+diff -pcr misc/hsqldb/src/org/hsqldb/Column.java misc/build/hsqldb/src/org/hsqldb/Column.java
+*** misc/hsqldb/src/org/hsqldb/Column.java	2006-07-17 00:29:33.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/Column.java	2007-02-28 12:32:48.000000000 +0100
+*************** public class Column {
+*** 126,138 ****
+      // most variables are final but not declared so because of a bug in
+      // JDK 1.1.8 compiler
+      public HsqlName         columnName;
+!     private int             colType;
+!     private int             colSize;
+!     private int             colScale;
+!     private boolean         isNullable;
+!     private boolean         isIdentity;
+!     private boolean         isPrimaryKey;
+!     private Expression      defaultExpression;
+      long                    identityStart;
+      long                    identityIncrement;
+      static final BigInteger MAX_LONG = BigInteger.valueOf(Long.MAX_VALUE);
+--- 126,138 ----
+      // most variables are final but not declared so because of a bug in
+      // JDK 1.1.8 compiler
+      public HsqlName         columnName;
+!     public int             colType;
+!     public int             colSize;
+!     public int             colScale;
+!     public boolean         isNullable;
+!     public boolean         isIdentity;
+!     public boolean         isPrimaryKey;
+!     public Expression      defaultExpression;
+      long                    identityStart;
+      long                    identityIncrement;
+      static final BigInteger MAX_LONG = BigInteger.valueOf(Long.MAX_VALUE);
+*************** public class Column {
+*** 187,193 ****
+          }
+      }
+  
+!     private Column() {}
+  
+      /**
+       * Used for primary key changes.
+--- 187,193 ----
+          }
+      }
+  
+!     public Column() {}
+  
+      /**
+       * Used for primary key changes.
+*************** public class Column {
+*** 1207,1213 ****
+       * @return
+       * @throws  HsqlException
+       */
+!     private static Object convertString(String s,
+                                          int type) throws HsqlException {
+  
+          switch (type) {
+--- 1207,1213 ----
+       * @return
+       * @throws  HsqlException
+       */
+!     public static Object convertString(String s,
+                                          int type) throws HsqlException {
+  
+          switch (type) {
+diff -pcr misc/hsqldb/src/org/hsqldb/CompiledStatementExecutor.java misc/build/hsqldb/src/org/hsqldb/CompiledStatementExecutor.java
+*** misc/hsqldb/src/org/hsqldb/CompiledStatementExecutor.java	2006-01-07 17:01:22.000000000 +0100
+--- misc/build/hsqldb/src/org/hsqldb/CompiledStatementExecutor.java	2007-02-28 12:32:48.000000000 +0100
+*************** import org.hsqldb.lib.java.JavaSystem;
+*** 54,64 ****
+   */
+  final class CompiledStatementExecutor {
+  
+!     private Session session;
+!     private Result  updateResult;
+!     private static Result emptyZeroResult =
+          new Result(ResultConstants.UPDATECOUNT);
+!     private static Result updateOneResult =
+          new Result(ResultConstants.UPDATECOUNT);
+  
+      static {
+--- 54,64 ----
+   */
+  final class CompiledStatementExecutor {
+  
+!     public Session session;
+!     public Result  updateResult;
+!     public static Result emptyZeroResult =
+          new Result(ResultConstants.UPDATECOUNT);
+!     public static Result updateOneResult =
+          new Result(ResultConstants.UPDATECOUNT);
+  
+      static {
+*************** final class CompiledStatementExecutor {
+*** 120,126 ****
+       * @throws HsqlException if a database access error occurs
+       * @return the result of executing the statement
+       */
+!     private Result executeImpl(CompiledStatement cs) throws HsqlException {
+  
+          switch (cs.type) {
+  
+--- 120,126 ----
+       * @throws HsqlException if a database access error occurs
+       * @return the result of executing the statement
+       */
+!     public Result executeImpl(CompiledStatement cs) throws HsqlException {
+  
+          switch (cs.type) {
+  
+*************** final class CompiledStatementExecutor {
+*** 160,166 ****
+       * @throws HsqlException if a database access error occurs
+       * @return the result of executing the statement
+       */
+!     private Result executeCallStatement(CompiledStatement cs)
+      throws HsqlException {
+  
+          Expression e = cs.expression;          // representing CALL
+--- 160,166 ----
+       * @throws HsqlException if a database access error occurs
+       * @return the result of executing the statement
+       */
+!     public Result executeCallStatement(CompiledStatement cs)
+      throws HsqlException {
+  
+          Expression e = cs.expression;          // representing CALL
+*************** final class CompiledStatementExecutor {
+*** 197,203 ****
+       * @throws HsqlException if a database access error occurs
+       * @return the result of executing the statement
+       */
+!     private Result executeDeleteStatement(CompiledStatement cs)
+      throws HsqlException {
+  
+          Table       table  = cs.targetTable;
+--- 197,203 ----
+       * @throws HsqlException if a database access error occurs
+       * @return the result of executing the statement
+       */
+!     public Result executeDeleteStatement(CompiledStatement cs)
+      throws HsqlException {
+  
+          Table       table  = cs.targetTable;
+*************** final class CompiledStatementExecutor {
+*** 232,238 ****
+       * @throws HsqlException if a database access error occurs
+       * @return the result of executing the statement
+       */
+!     private Result executeInsertSelectStatement(CompiledStatement cs)
+      throws HsqlException {
+  
+          Table     t   = cs.targetTable;
+--- 232,238 ----
+       * @throws HsqlException if a database access error occurs
+       * @return the result of executing the statement
+       */
+!     public Result executeInsertSelectStatement(CompiledStatement cs)
+      throws HsqlException {
+  
+          Table     t   = cs.targetTable;
+*************** final class CompiledStatementExecutor {
+*** 286,292 ****
+       * @throws HsqlException if a database access error occurs
+       * @return the result of executing the statement
+       */
+!     private Result executeInsertValuesStatement(CompiledStatement cs)
+      throws HsqlException {
+  
+          Table        t    = cs.targetTable;
+--- 286,292 ----
+       * @throws HsqlException if a database access error occurs
+       * @return the result of executing the statement
+       */
+!     public Result executeInsertValuesStatement(CompiledStatement cs)
+      throws HsqlException {
+  
+          Table        t    = cs.targetTable;
+*************** final class CompiledStatementExecutor {
+*** 317,323 ****
+       * @throws HsqlException if a database access error occurs
+       * @return the result of executing the statement
+       */
+!     private Result executeSelectStatement(CompiledStatement cs)
+      throws HsqlException {
+  
+          Select select = cs.select;
+--- 317,323 ----
+       * @throws HsqlException if a database access error occurs
+       * @return the result of executing the statement
+       */
+!     public Result executeSelectStatement(CompiledStatement cs)
+      throws HsqlException {
+  
+          Select select = cs.select;
+*************** final class CompiledStatementExecutor {
+*** 358,364 ****
+       * @throws HsqlException if a database access error occurs
+       * @return the result of executing the statement
+       */
+!     private Result executeUpdateStatement(CompiledStatement cs)
+      throws HsqlException {
+  
+          Table       table  = cs.targetTable;
+--- 358,364 ----
+       * @throws HsqlException if a database access error occurs
+       * @return the result of executing the statement
+       */
+!     public Result executeUpdateStatement(CompiledStatement cs)
+      throws HsqlException {
+  
+          Table       table  = cs.targetTable;
+*************** final class CompiledStatementExecutor {
+*** 420,426 ****
+       * @throws HsqlException if a database access error occurs
+       * @return the result of executing the statement
+       */
+!     private Result executeDDLStatement(CompiledStatement cs)
+      throws HsqlException {
+          return session.sqlExecuteDirectNoPreChecks(cs.sql);
+      }
+--- 420,426 ----
+       * @throws HsqlException if a database access error occurs
+       * @return the result of executing the statement
+       */
+!     public Result executeDDLStatement(CompiledStatement cs)
+      throws HsqlException {
+          return session.sqlExecuteDirectNoPreChecks(cs.sql);
+      }
+diff -pcr misc/hsqldb/src/org/hsqldb/CompiledStatement.java misc/build/hsqldb/src/org/hsqldb/CompiledStatement.java
+*** misc/hsqldb/src/org/hsqldb/CompiledStatement.java	2006-04-11 16:40:52.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/CompiledStatement.java	2007-02-28 12:32:48.000000000 +0100
+*************** final class CompiledStatement {
+*** 359,365 ****
+      /**
+       * For parameters in INSERT_VALUES and INSERT_SELECT lists
+       */
+!     private void resolveInsertParameterTypes() {
+  
+          for (int i = 0; i < select.iResultLen; i++) {
+              Expression colexpr = select.exprColumns[i];
+--- 359,365 ----
+      /**
+       * For parameters in INSERT_VALUES and INSERT_SELECT lists
+       */
+!     public void resolveInsertParameterTypes() {
+  
+          for (int i = 0; i < select.iResultLen; i++) {
+              Expression colexpr = select.exprColumns[i];
+*************** final class CompiledStatement {
+*** 372,378 ****
+          }
+      }
+  
+!     private void setParameters(Expression[] params) {
+  
+          this.parameters = params;
+  
+--- 372,378 ----
+          }
+      }
+  
+!     public void setParameters(Expression[] params) {
+  
+          this.parameters = params;
+  
+*************** final class CompiledStatement {
+*** 385,391 ****
+          this.paramTypes = types;
+      }
+  
+!     private void setSubqueries(SubQuery[] subqueries) {
+          this.subqueries = subqueries;
+      }
+  
+--- 385,391 ----
+          this.paramTypes = types;
+      }
+  
+!     public void setSubqueries(SubQuery[] subqueries) {
+          this.subqueries = subqueries;
+      }
+  
+*************** final class CompiledStatement {
+*** 485,491 ****
+          table.checkDataReadOnly();
+      }
+  
+!     private static final Result updateCountResult =
+          new Result(ResultConstants.UPDATECOUNT);
+  
+      Result describeResult() {
+--- 485,491 ----
+          table.checkDataReadOnly();
+      }
+  
+!     public static final Result updateCountResult =
+          new Result(ResultConstants.UPDATECOUNT);
+  
+      Result describeResult() {
+*************** final class CompiledStatement {
+*** 619,625 ****
+       * @throws Exception if a database access or io error occurs
+       * @return the String representation of this object
+       */
+!     private String describeImpl(Session session) throws Exception {
+  
+          StringBuffer sb;
+  
+--- 619,625 ----
+       * @throws Exception if a database access or io error occurs
+       * @return the String representation of this object
+       */
+!     public String describeImpl(Session session) throws Exception {
+  
+          StringBuffer sb;
+  
+*************** final class CompiledStatement {
+*** 693,699 ****
+          }
+      }
+  
+!     private StringBuffer appendSubqueries(StringBuffer sb) {
+  
+          sb.append("SUBQUERIES[");
+  
+--- 693,699 ----
+          }
+      }
+  
+!     public StringBuffer appendSubqueries(StringBuffer sb) {
+  
+          sb.append("SUBQUERIES[");
+  
+*************** final class CompiledStatement {
+*** 715,728 ****
+          return sb;
+      }
+  
+!     private StringBuffer appendTable(StringBuffer sb) {
+  
+          sb.append("TABLE[").append(targetTable.getName().name).append(']');
+  
+          return sb;
+      }
+  
+!     private StringBuffer appendColumns(StringBuffer sb) {
+  
+          sb.append("COLUMNS=[");
+  
+--- 715,728 ----
+          return sb;
+      }
+  
+!     public StringBuffer appendTable(StringBuffer sb) {
+  
+          sb.append("TABLE[").append(targetTable.getName().name).append(']');
+  
+          return sb;
+      }
+  
+!     public StringBuffer appendColumns(StringBuffer sb) {
+  
+          sb.append("COLUMNS=[");
+  
+*************** final class CompiledStatement {
+*** 738,744 ****
+          return sb;
+      }
+  
+!     private StringBuffer appendParms(StringBuffer sb) {
+  
+          sb.append("PARAMETERS=[");
+  
+--- 738,744 ----
+          return sb;
+      }
+  
+!     public StringBuffer appendParms(StringBuffer sb) {
+  
+          sb.append("PARAMETERS=[");
+  
+*************** final class CompiledStatement {
+*** 752,758 ****
+          return sb;
+      }
+  
+!     private StringBuffer appendCondition(Session session, StringBuffer sb) {
+  
+          return condition == null ? sb.append("CONDITION[]\n")
+                                   : sb.append("CONDITION[").append(
+--- 752,758 ----
+          return sb;
+      }
+  
+!     public StringBuffer appendCondition(Session session, StringBuffer sb) {
+  
+          return condition == null ? sb.append("CONDITION[]\n")
+                                   : sb.append("CONDITION[").append(
+diff -pcr misc/hsqldb/src/org/hsqldb/CompiledStatementManager.java misc/build/hsqldb/src/org/hsqldb/CompiledStatementManager.java
+*** misc/hsqldb/src/org/hsqldb/CompiledStatementManager.java	2006-04-11 16:40:52.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/CompiledStatementManager.java	2007-02-28 12:32:48.000000000 +0100
+*************** final class CompiledStatementManager {
+*** 80,107 ****
+       * The Database for which this object is managing
+       * CompiledStatement objects.
+       */
+!     private Database database;
+  
+      /** Map: Schema id (int) => {Map: SQL String => Compiled Statement id (int)} */
+!     private IntKeyHashMap schemaMap;
+  
+      /** Map: Compiled Statement id (int) => SQL String */
+!     private IntKeyHashMap sqlLookup;
+  
+      /** Map: Compiled statment id (int) => CompiledStatement object. */
+!     private IntKeyHashMap csidMap;
+  
+      /** Map: Session id (int) => {Map: compiled statement id (int) => use count in session} */
+!     private IntKeyHashMap sessionUseMap;
+  
+      /** Map: Compiled statment id (int) => number of sessions that use the statement */
+!     private IntKeyIntValueHashMap useMap;
+  
+      /**
+       * Monotonically increasing counter used to assign unique ids to compiled
+       * statements.
+       */
+!     private int next_cs_id;
+  
+      /**
+       * Constructs a new instance of <code>CompiledStatementManager</code>.
+--- 80,107 ----
+       * The Database for which this object is managing
+       * CompiledStatement objects.
+       */
+!     public Database database;
+  
+      /** Map: Schema id (int) => {Map: SQL String => Compiled Statement id (int)} */
+!     public IntKeyHashMap schemaMap;
+  
+      /** Map: Compiled Statement id (int) => SQL String */
+!     public IntKeyHashMap sqlLookup;
+  
+      /** Map: Compiled statment id (int) => CompiledStatement object. */
+!     public IntKeyHashMap csidMap;
+  
+      /** Map: Session id (int) => {Map: compiled statement id (int) => use count in session} */
+!     public IntKeyHashMap sessionUseMap;
+  
+      /** Map: Compiled statment id (int) => number of sessions that use the statement */
+!     public IntKeyIntValueHashMap useMap;
+  
+      /**
+       * Monotonically increasing counter used to assign unique ids to compiled
+       * statements.
+       */
+!     public int next_cs_id;
+  
+      /**
+       * Constructs a new instance of <code>CompiledStatementManager</code>.
+*************** final class CompiledStatementManager {
+*** 155,161 ****
+       *
+       * @return the next compiled statement identifier in the sequence.
+       */
+!     private int nextID() {
+  
+          next_cs_id++;
+  
+--- 155,161 ----
+       *
+       * @return the next compiled statement identifier in the sequence.
+       */
+!     public int nextID() {
+  
+          next_cs_id++;
+  
+*************** final class CompiledStatementManager {
+*** 172,178 ****
+       * @return the compiled statement identifier associated with the
+       *      specified SQL String
+       */
+!     private int getStatementID(HsqlName schema, String sql) {
+  
+          IntValueHashMap sqlMap =
+              (IntValueHashMap) schemaMap.get(schema.hashCode());
+--- 172,178 ----
+       * @return the compiled statement identifier associated with the
+       *      specified SQL String
+       */
+!     public int getStatementID(HsqlName schema, String sql) {
+  
+          IntValueHashMap sqlMap =
+              (IntValueHashMap) schemaMap.get(schema.hashCode());
+*************** final class CompiledStatementManager {
+*** 229,235 ****
+       * @param csid the compiled statement identifier
+       * @param sid the session identifier
+       */
+!     private void linkSession(int csid, int sid) {
+  
+          IntKeyIntValueHashMap scsMap;
+  
+--- 229,235 ----
+       * @param csid the compiled statement identifier
+       * @param sid the session identifier
+       */
+!     public void linkSession(int csid, int sid) {
+  
+          IntKeyIntValueHashMap scsMap;
+  
+*************** final class CompiledStatementManager {
+*** 262,268 ****
+       * @return The compiled statement id assigned to the CompiledStatement
+       *  object
+       */
+!     private int registerStatement(int csid, CompiledStatement cs) {
+  
+          if (csid < 0) {
+              csid = nextID();
+--- 262,268 ----
+       * @return The compiled statement id assigned to the CompiledStatement
+       *  object
+       */
+!     public int registerStatement(int csid, CompiledStatement cs) {
+  
+          if (csid < 0) {
+              csid = nextID();
+*************** final class CompiledStatementManager {
+*** 438,444 ****
+          return cs;
+      }
+  
+!     private CompiledStatement compileSql(Session session, String sql,
+                                           String schemaName) throws Throwable {
+  
+          Session sys = database.sessionManager.getSysSession(schemaName,
+--- 438,444 ----
+          return cs;
+      }
+  
+!     public CompiledStatement compileSql(Session session, String sql,
+                                           String schemaName) throws Throwable {
+  
+          Session sys = database.sessionManager.getSysSession(schemaName,
+diff -pcr misc/hsqldb/src/org/hsqldb/Constraint.java misc/build/hsqldb/src/org/hsqldb/Constraint.java
+*** misc/hsqldb/src/org/hsqldb/Constraint.java	2007-02-28 12:31:52.000000000 +0100
+--- misc/build/hsqldb/src/org/hsqldb/Constraint.java	2007-02-28 12:32:48.000000000 +0100
+*************** class Constraint {
+*** 194,200 ****
+          core.updateAction = updateAction;
+      }
+  
+!     private Constraint() {}
+  
+      /**
+       * Returns the HsqlName.
+--- 194,200 ----
+          core.updateAction = updateAction;
+      }
+  
+!     public Constraint() {}
+  
+      /**
+       * Returns the HsqlName.
+*************** class Constraint {
+*** 206,212 ****
+      /**
+       * Changes constraint name.
+       */
+!     private void setName(String name, boolean isquoted) throws HsqlException {
+          constName.rename(name, isquoted);
+      }
+  
+--- 206,212 ----
+      /**
+       * Changes constraint name.
+       */
+!     public void setName(String name, boolean isquoted) throws HsqlException {
+          constName.rename(name, isquoted);
+      }
+  
+*************** class Constraint {
+*** 575,581 ****
+       * table. Also returns true if any column covered by the foreign key
+       * constraint has a null value.
+       */
+!     private static boolean hasReferencedRow(Session session,
+              Object[] rowdata, int[] rowColArray,
+              Index mainIndex) throws HsqlException {
+  
+--- 575,581 ----
+       * table. Also returns true if any column covered by the foreign key
+       * constraint has a null value.
+       */
+!     public static boolean hasReferencedRow(Session session,
+              Object[] rowdata, int[] rowColArray,
+              Index mainIndex) throws HsqlException {
+  
+diff -pcr misc/hsqldb/src/org/hsqldb/DatabaseCommandInterpreter.java misc/build/hsqldb/src/org/hsqldb/DatabaseCommandInterpreter.java
+*** misc/hsqldb/src/org/hsqldb/DatabaseCommandInterpreter.java	2007-02-28 12:31:52.000000000 +0100
+--- misc/build/hsqldb/src/org/hsqldb/DatabaseCommandInterpreter.java	2007-02-28 12:32:48.000000000 +0100
+*************** import org.hsqldb.scriptio.ScriptWriterT
+*** 111,119 ****
+  // fredt@users 20041209 - patch by tytar@users to set default table type
+  class DatabaseCommandInterpreter {
+  
+!     private Tokenizer tokenizer = new Tokenizer();
+!     private Database  database;
+!     private Session   session;
+  
+      /**
+       * Constructs a new DatabaseCommandInterpreter for the given Session
+--- 111,119 ----
+  // fredt@users 20041209 - patch by tytar@users to set default table type
+  class DatabaseCommandInterpreter {
+  
+!     public Tokenizer tokenizer = new Tokenizer();
+!     public Database  database;
+!     public Session   session;
+  
+      /**
+       * Constructs a new DatabaseCommandInterpreter for the given Session
+*************** class DatabaseCommandInterpreter {
+*** 201,207 ****
+                                : result;
+      }
+  
+!     private Result executePart(int cmd, String token) throws Throwable {
+  
+          Result result   = Session.emptyUpdateCount;
+          int    brackets = 0;
+--- 201,207 ----
+                                : result;
+      }
+  
+!     public Result executePart(int cmd, String token) throws Throwable {
+  
+          Result result   = Session.emptyUpdateCount;
+          int    brackets = 0;
+*************** class DatabaseCommandInterpreter {
+*** 397,403 ****
+       * @throws IOException
+       * @throws HsqlException
+       */
+!     private Result processScript() throws IOException, HsqlException {
+  
+          String           token = tokenizer.getString();
+          ScriptWriterText dsw   = null;
+--- 397,403 ----
+       * @throws IOException
+       * @throws HsqlException
+       */
+!     public Result processScript() throws IOException, HsqlException {
+  
+          String           token = tokenizer.getString();
+          ScriptWriterText dsw   = null;
+*************** class DatabaseCommandInterpreter {
+*** 438,444 ****
+       *
+       * @throws  HsqlException
+       */
+!     private void processCreate() throws HsqlException {
+  
+          boolean unique = false;
+          int     tableType;
+--- 438,444 ----
+       *
+       * @throws  HsqlException
+       */
+!     public void processCreate() throws HsqlException {
+  
+          boolean unique = false;
+          int     tableType;
+*************** class DatabaseCommandInterpreter {
+*** 558,564 ****
+       * @return  column index map
+       * @throws  HsqlException if a column is not found or is duplicate
+       */
+!     private int[] processColumnList(Table t,
+                                      boolean acceptAscDesc)
+                                      throws HsqlException {
+  
+--- 558,564 ----
+       * @return  column index map
+       * @throws  HsqlException if a column is not found or is duplicate
+       */
+!     public int[] processColumnList(Table t,
+                                      boolean acceptAscDesc)
+                                      throws HsqlException {
+  
+*************** class DatabaseCommandInterpreter {
+*** 582,588 ****
+       *
+       * @throws HsqlException
+       */
+!     private void processCreateTrigger() throws HsqlException {
+  
+          Table      t;
+          boolean    isForEach;
+--- 582,588 ----
+       *
+       * @throws HsqlException
+       */
+!     public void processCreateTrigger() throws HsqlException {
+  
+          Table      t;
+          boolean    isForEach;
+*************** class DatabaseCommandInterpreter {
+*** 703,709 ****
+  // --
+      }
+  
+!     private Column processCreateColumn() throws HsqlException {
+  
+          String   token    = tokenizer.getSimpleName();
+          boolean  isQuoted = tokenizer.wasQuotedIdentifier();
+--- 703,709 ----
+  // --
+      }
+  
+!     public Column processCreateColumn() throws HsqlException {
+  
+          String   token    = tokenizer.getSimpleName();
+          boolean  isQuoted = tokenizer.wasQuotedIdentifier();
+*************** class DatabaseCommandInterpreter {
+*** 720,726 ****
+       *  @return a Column object with indicated attributes
+       *  @throws  HsqlException
+       */
+!     private Column processCreateColumn(HsqlName hsqlName)
+      throws HsqlException {
+  
+          boolean    isIdentity        = false;
+--- 720,726 ----
+       *  @return a Column object with indicated attributes
+       *  @throws  HsqlException
+       */
+!     public Column processCreateColumn(HsqlName hsqlName)
+      throws HsqlException {
+  
+          boolean    isIdentity        = false;
+*************** class DatabaseCommandInterpreter {
+*** 892,898 ****
+       * @throws HsqlException
+       * @return new Expression
+       */
+!     private Expression processCreateDefaultExpression(int type, int length,
+              int scale) throws HsqlException {
+  
+          if (type == Types.OTHER) {
+--- 892,898 ----
+       * @throws HsqlException
+       * @return new Expression
+       */
+!     public Expression processCreateDefaultExpression(int type, int length,
+              int scale) throws HsqlException {
+  
+          if (type == Types.OTHER) {
+*************** class DatabaseCommandInterpreter {
+*** 963,969 ****
+       * @throws HsqlException
+       * @return list of constraints
+       */
+!     private HsqlArrayList processCreateConstraints(Table t,
+              boolean constraint, int[] primarykeycolumn) throws HsqlException {
+  
+          String        token;
+--- 963,969 ----
+       * @throws HsqlException
+       * @return list of constraints
+       */
+!     public HsqlArrayList processCreateConstraints(Table t,
+              boolean constraint, int[] primarykeycolumn) throws HsqlException {
+  
+          String        token;
+*************** class DatabaseCommandInterpreter {
+*** 1119,1125 ****
+       * @param c check constraint
+       * @throws HsqlException
+       */
+!     private void processCreateCheckConstraintCondition(Constraint c)
+      throws HsqlException {
+  
+          tokenizer.getThis(Token.T_OPENBRACKET);
+--- 1119,1125 ----
+       * @param c check constraint
+       * @throws HsqlException
+       */
+!     public void processCreateCheckConstraintCondition(Constraint c)
+      throws HsqlException {
+  
+          tokenizer.getThis(Token.T_OPENBRACKET);
+*************** class DatabaseCommandInterpreter {
+*** 1138,1144 ****
+       * @param type Description of the Parameter
+       * @throws HsqlException
+       */
+!     private void processCreateTable(int type) throws HsqlException {
+  
+          String token = tokenizer.getName();
+          HsqlName schemaname =
+--- 1138,1144 ----
+       * @param type Description of the Parameter
+       * @throws HsqlException
+       */
+!     public void processCreateTable(int type) throws HsqlException {
+  
+          String token = tokenizer.getName();
+          HsqlName schemaname =
+*************** class DatabaseCommandInterpreter {
+*** 1305,1311 ****
+       * @throws HsqlException
+       * @return constraint
+       */
+!     private Constraint processCreateFK(Table t,
+                                         HsqlName cname) throws HsqlException {
+  
+          int[]  localcol;
+--- 1305,1311 ----
+       * @throws HsqlException
+       * @return constraint
+       */
+!     public Constraint processCreateFK(Table t,
+                                         HsqlName cname) throws HsqlException {
+  
+          int[]  localcol;
+*************** class DatabaseCommandInterpreter {
+*** 1447,1453 ****
+       *
+       * @throws HsqlException
+       */
+!     private void processCreateView() throws HsqlException {
+  
+          String name = tokenizer.getName();
+          HsqlName schemaname =
+--- 1447,1453 ----
+       *
+       * @throws HsqlException
+       */
+!     public void processCreateView() throws HsqlException {
+  
+          String name = tokenizer.getName();
+          HsqlName schemaname =
+*************** class DatabaseCommandInterpreter {
+*** 1527,1533 ****
+       * @param t table
+       * @throws HsqlException
+       */
+!     private void processAlterTableRename(Table t) throws HsqlException {
+  
+          String  schema = t.getSchemaName();
+          String  newName;
+--- 1527,1533 ----
+       * @param t table
+       * @throws HsqlException
+       */
+!     public void processAlterTableRename(Table t) throws HsqlException {
+  
+          String  schema = t.getSchemaName();
+          String  newName;
+*************** class DatabaseCommandInterpreter {
+*** 1574,1580 ****
+       *
+       * @throws HsqlException
+       */
+!     private void processAlter() throws HsqlException {
+  
+          String token;
+  
+--- 1574,1580 ----
+       *
+       * @throws HsqlException
+       */
+!     public void processAlter() throws HsqlException {
+  
+          String token;
+  
+*************** class DatabaseCommandInterpreter {
+*** 1622,1628 ****
+       *
+       * @throws HsqlException
+       */
+!     private void processAlterTable() throws HsqlException {
+  
+          String tableName = tokenizer.getName();
+          String schema =
+--- 1622,1628 ----
+       *
+       * @throws HsqlException
+       */
+!     public void processAlterTable() throws HsqlException {
+  
+          String tableName = tokenizer.getName();
+          String schema =
+*************** class DatabaseCommandInterpreter {
+*** 1783,1789 ****
+       * @param t table
+       * @throws HsqlException
+       */
+!     private void processAlterColumn(Table t) throws HsqlException {
+  
+          String columnName  = tokenizer.getSimpleName();
+          int    columnIndex = t.getColumnNr(columnName);
+--- 1783,1789 ----
+       * @param t table
+       * @throws HsqlException
+       */
+!     public void processAlterColumn(Table t) throws HsqlException {
+  
+          String columnName  = tokenizer.getSimpleName();
+          int    columnIndex = t.getColumnNr(columnName);
+*************** class DatabaseCommandInterpreter {
+*** 1860,1866 ****
+          }
+      }
+  
+!     private void processAlterColumnType(Table table,
+                                          Column oldCol) throws HsqlException {
+  
+          Column     newCol = processCreateColumn(oldCol.columnName);
+--- 1860,1866 ----
+          }
+      }
+  
+!     public void processAlterColumnType(Table table,
+                                          Column oldCol) throws HsqlException {
+  
+          Column     newCol = processCreateColumn(oldCol.columnName);
+*************** class DatabaseCommandInterpreter {
+*** 1875,1881 ****
+       * @param column column
+       * @throws HsqlException
+       */
+!     private void processAlterColumnRename(Table t,
+                                            Column column)
+                                            throws HsqlException {
+  
+--- 1875,1881 ----
+       * @param column column
+       * @throws HsqlException
+       */
+!     public void processAlterColumnRename(Table t,
+                                            Column column)
+                                            throws HsqlException {
+  
+*************** class DatabaseCommandInterpreter {
+*** 1898,1910 ****
+       *
+       * @throws HsqlException
+       */
+!     private void processAlterIndex() throws HsqlException {
+  
+          // only the one supported operation, so far
+          processAlterIndexRename();
+      }
+  
+!     private void processAlterSchema() throws HsqlException {
+  
+          // only the one supported operation, so far
+          processAlterSchemaRename();
+--- 1898,1910 ----
+       *
+       * @throws HsqlException
+       */
+!     public void processAlterIndex() throws HsqlException {
+  
+          // only the one supported operation, so far
+          processAlterIndexRename();
+      }
+  
+!     public void processAlterSchema() throws HsqlException {
+  
+          // only the one supported operation, so far
+          processAlterSchemaRename();
+*************** class DatabaseCommandInterpreter {
+*** 1915,1921 ****
+       *
+       * @throws  HsqlException
+       */
+!     private void processDrop() throws HsqlException {
+  
+          String  token;
+          boolean isview;
+--- 1915,1921 ----
+       *
+       * @throws  HsqlException
+       */
+!     public void processDrop() throws HsqlException {
+  
+          String  token;
+          boolean isview;
+*************** class DatabaseCommandInterpreter {
+*** 1981,1987 ****
+       * @param grant true if grant, false if revoke
+       * @throws HsqlException
+       */
+!     private void processGrantOrRevoke(boolean grant) throws HsqlException {
+  
+          int    right;
+          Object accessKey;
+--- 1981,1987 ----
+       * @param grant true if grant, false if revoke
+       * @throws HsqlException
+       */
+!     public void processGrantOrRevoke(boolean grant) throws HsqlException {
+  
+          int    right;
+          Object accessKey;
+*************** class DatabaseCommandInterpreter {
+*** 2048,2054 ****
+       *
+       * @throws HsqlException
+       */
+!     private void processConnect() throws HsqlException {
+  
+          String userName;
+          String password;
+--- 2048,2054 ----
+       *
+       * @throws HsqlException
+       */
+!     public void processConnect() throws HsqlException {
+  
+          String userName;
+          String password;
+*************** class DatabaseCommandInterpreter {
+*** 2084,2090 ****
+       *
+       * @throws  HsqlException
+       */
+!     private void processSet() throws HsqlException {
+  
+          String token;
+  
+--- 2084,2090 ----
+       *
+       * @throws  HsqlException
+       */
+!     public void processSet() throws HsqlException {
+  
+          String token;
+  
+*************** class DatabaseCommandInterpreter {
+*** 2346,2352 ****
+       * @return   true if next token is "TRUE"; false if next token is "FALSE"
+       * @throws  HsqlException if the next token is neither "TRUE" or "FALSE"
+       */
+!     private boolean processTrueOrFalse() throws HsqlException {
+  
+          String sToken = tokenizer.getSimpleToken();
+  
+--- 2346,2352 ----
+       * @return   true if next token is "TRUE"; false if next token is "FALSE"
+       * @throws  HsqlException if the next token is neither "TRUE" or "FALSE"
+       */
+!     public boolean processTrueOrFalse() throws HsqlException {
+  
+          String sToken = tokenizer.getSimpleToken();
+  
+*************** class DatabaseCommandInterpreter {
+*** 2364,2370 ****
+       *
+       * @throws  HsqlException
+       */
+!     private void processCommit() throws HsqlException {
+          tokenizer.isGetThis(Token.T_WORK);
+          session.commit();
+      }
+--- 2364,2370 ----
+       *
+       * @throws  HsqlException
+       */
+!     public void processCommit() throws HsqlException {
+          tokenizer.isGetThis(Token.T_WORK);
+          session.commit();
+      }
+*************** class DatabaseCommandInterpreter {
+*** 2374,2380 ****
+       *
+       * @throws  HsqlException
+       */
+!     private void processRollback() throws HsqlException {
+  
+          String  token;
+          boolean toSavepoint;
+--- 2374,2380 ----
+       *
+       * @throws  HsqlException
+       */
+!     public void processRollback() throws HsqlException {
+  
+          String  token;
+          boolean toSavepoint;
+*************** class DatabaseCommandInterpreter {
+*** 2406,2412 ****
+       *
+       * @throws  HsqlException
+       */
+!     private void processSavepoint() throws HsqlException {
+  
+          String token;
+  
+--- 2406,2412 ----
+       *
+       * @throws  HsqlException
+       */
+!     public void processSavepoint() throws HsqlException {
+  
+          String token;
+  
+*************** class DatabaseCommandInterpreter {
+*** 2420,2426 ****
+       *
+       * @throws  HsqlException
+       */
+!     private void processShutdown() throws HsqlException {
+  
+          int    closemode;
+          String token;
+--- 2420,2426 ----
+       *
+       * @throws  HsqlException
+       */
+!     public void processShutdown() throws HsqlException {
+  
+          int    closemode;
+          String token;
+*************** class DatabaseCommandInterpreter {
+*** 2455,2461 ****
+       *
+       * @throws  HsqlException
+       */
+!     private void processCheckpoint() throws HsqlException {
+  
+          boolean defrag;
+          String  token;
+--- 2455,2461 ----
+       *
+       * @throws  HsqlException
+       */
+!     public void processCheckpoint() throws HsqlException {
+  
+          boolean defrag;
+          String  token;
+*************** class DatabaseCommandInterpreter {
+*** 2479,2485 ****
+      }
+  
+  // --------------------- new methods / simplifications ------------------------
+!     private HsqlName newIndexHsqlName(String name,
+                                        boolean isQuoted) throws HsqlException {
+  
+          return HsqlName.isReservedIndexName(name)
+--- 2479,2485 ----
+      }
+  
+  // --------------------- new methods / simplifications ------------------------
+!     public HsqlName newIndexHsqlName(String name,
+                                        boolean isQuoted) throws HsqlException {
+  
+          return HsqlName.isReservedIndexName(name)
+*************** class DatabaseCommandInterpreter {
+*** 2487,2493 ****
+                 : database.nameManager.newHsqlName(name, isQuoted);
+      }
+  
+!     private Table newTable(int type, String name, boolean quoted,
+                             HsqlName schema) throws HsqlException {
+  
+          HsqlName tableHsqlName = database.nameManager.newHsqlName(name,
+--- 2487,2493 ----
+                 : database.nameManager.newHsqlName(name, isQuoted);
+      }
+  
+!     public Table newTable(int type, String name, boolean quoted,
+                             HsqlName schema) throws HsqlException {
+  
+          HsqlName tableHsqlName = database.nameManager.newHsqlName(name,
+*************** class DatabaseCommandInterpreter {
+*** 2516,2522 ****
+       * @throws HsqlException if the operation of adding the Column, c, to
+       *      the table t is not valid
+       */
+!     private void checkAddColumn(Table t, Column c) throws HsqlException {
+  
+          boolean canAdd = true;
+  
+--- 2516,2522 ----
+       * @throws HsqlException if the operation of adding the Column, c, to
+       *      the table t is not valid
+       */
+!     public void checkAddColumn(Table t, Column c) throws HsqlException {
+  
+          boolean canAdd = true;
+  
+*************** class DatabaseCommandInterpreter {
+*** 2537,2543 ****
+          }
+      }
+  
+!     private void checkFKColumnDefaults(Table t,
+                                         Constraint tc) throws HsqlException {
+  
+          boolean check = tc.core.updateAction == Constraint.SET_DEFAULT;
+--- 2537,2543 ----
+          }
+      }
+  
+!     public void checkFKColumnDefaults(Table t,
+                                         Constraint tc) throws HsqlException {
+  
+          boolean check = tc.core.updateAction == Constraint.SET_DEFAULT;
+*************** class DatabaseCommandInterpreter {
+*** 2561,2567 ****
+          }
+      }
+  
+!     private void processAlterSequence() throws HsqlException {
+  
+          long   start;
+          String name       = tokenizer.getName();
+--- 2561,2567 ----
+          }
+      }
+  
+!     public void processAlterSequence() throws HsqlException {
+  
+          long   start;
+          String name       = tokenizer.getName();
+*************** class DatabaseCommandInterpreter {
+*** 2585,2591 ****
+       *
+       * @throws HsqlException
+       */
+!     private void processAlterIndexRename() throws HsqlException {
+  
+          String name = tokenizer.getName();
+          String schema =
+--- 2585,2591 ----
+       *
+       * @throws HsqlException
+       */
+!     public void processAlterIndexRename() throws HsqlException {
+  
+          String name = tokenizer.getName();
+          String schema =
+*************** class DatabaseCommandInterpreter {
+*** 2636,2642 ****
+       *
+       * @throws HsqlException
+       */
+!     private void processAlterSchemaRename() throws HsqlException {
+  
+          String name = tokenizer.getSimpleName();
+  
+--- 2636,2642 ----
+       *
+       * @throws HsqlException
+       */
+!     public void processAlterSchemaRename() throws HsqlException {
+  
+          String name = tokenizer.getSimpleName();
+  
+*************** class DatabaseCommandInterpreter {
+*** 2654,2660 ****
+       * @param t table
+       * @throws HsqlException
+       */
+!     private void processAlterTableAddColumn(Table t) throws HsqlException {
+  
+          String token;
+          int    colindex = t.getColumnCount();
+--- 2654,2660 ----
+       * @param t table
+       * @throws HsqlException
+       */
+!     public void processAlterTableAddColumn(Table t) throws HsqlException {
+  
+          String token;
+          int    colindex = t.getColumnCount();
+*************** class DatabaseCommandInterpreter {
+*** 2682,2688 ****
+       * @param t table
+       * @throws HsqlException
+       */
+!     private void processAlterTableDropColumn(Table t) throws HsqlException {
+  
+          String token;
+          int    colindex;
+--- 2682,2688 ----
+       * @param t table
+       * @throws HsqlException
+       */
+!     public void processAlterTableDropColumn(Table t) throws HsqlException {
+  
+          String token;
+          int    colindex;
+*************** class DatabaseCommandInterpreter {
+*** 2703,2709 ****
+       * @param t table
+       * @throws HsqlException
+       */
+!     private void processAlterTableDropConstraint(Table t)
+      throws HsqlException {
+          processAlterTableDropConstraint(t, tokenizer.getName());
+      }
+--- 2703,2709 ----
+       * @param t table
+       * @throws HsqlException
+       */
+!     public void processAlterTableDropConstraint(Table t)
+      throws HsqlException {
+          processAlterTableDropConstraint(t, tokenizer.getName());
+      }
+*************** class DatabaseCommandInterpreter {
+*** 2715,2721 ****
+       * @param name
+       * @throws HsqlException
+       */
+!     private void processAlterTableDropConstraint(Table t,
+              String cname) throws HsqlException {
+  
+          session.commit();
+--- 2715,2721 ----
+       * @param name
+       * @throws HsqlException
+       */
+!     public void processAlterTableDropConstraint(Table t,
+              String cname) throws HsqlException {
+  
+          session.commit();
+*************** class DatabaseCommandInterpreter {
+*** 2731,2737 ****
+       * If an invalid alias is encountered while processing an old script,
+       * simply discard it.
+       */
+!     private void processCreateAlias() throws HsqlException {
+  
+          String alias;
+          String methodFQN;
+--- 2731,2737 ----
+       * If an invalid alias is encountered while processing an old script,
+       * simply discard it.
+       */
+!     public void processCreateAlias() throws HsqlException {
+  
+          String alias;
+          String methodFQN;
+*************** class DatabaseCommandInterpreter {
+*** 2755,2761 ****
+          }
+      }
+  
+!     private void processCreateIndex(boolean unique) throws HsqlException {
+  
+          Table   t;
+          String  indexName       = tokenizer.getName();
+--- 2755,2761 ----
+          }
+      }
+  
+!     public void processCreateIndex(boolean unique) throws HsqlException {
+  
+          Table   t;
+          String  indexName       = tokenizer.getName();
+*************** class DatabaseCommandInterpreter {
+*** 2799,2805 ****
+       * be positive
+       * @throws HsqlException
+       */
+!     private void processCreateSequence() throws HsqlException {
+  
+  /*
+          CREATE SEQUENCE <name>
+--- 2799,2805 ----
+       * be positive
+       * @throws HsqlException
+       */
+!     public void processCreateSequence() throws HsqlException {
+  
+  /*
+          CREATE SEQUENCE <name>
+*************** class DatabaseCommandInterpreter {
+*** 2848,2854 ****
+       * CREATE SCHEMA PUBLIC in scripts should pass this, so we do not throw
+       * if this schema is created a second time
+       */
+!     private void processCreateSchema() throws HsqlException {
+  
+          String  name     = tokenizer.getSimpleName();
+          boolean isquoted = tokenizer.wasQuotedIdentifier();
+--- 2848,2854 ----
+       * CREATE SCHEMA PUBLIC in scripts should pass this, so we do not throw
+       * if this schema is created a second time
+       */
+!     public void processCreateSchema() throws HsqlException {
+  
+          String  name     = tokenizer.getSimpleName();
+          boolean isquoted = tokenizer.wasQuotedIdentifier();
+*************** class DatabaseCommandInterpreter {
+*** 2880,2886 ****
+          session.loggedSchema = session.currentSchema;
+      }
+  
+!     private void processCreateUser() throws HsqlException {
+  
+          String  name;
+          String  password;
+--- 2880,2886 ----
+          session.loggedSchema = session.currentSchema;
+      }
+  
+!     public void processCreateUser() throws HsqlException {
+  
+          String  name;
+          String  password;
+*************** class DatabaseCommandInterpreter {
+*** 2901,2911 ****
+          }
+      }
+  
+!     private void processDisconnect() throws HsqlException {
+          session.close();
+      }
+  
+!     private void processDropTable(boolean isView) throws HsqlException {
+  
+          boolean ifexists = false;
+          boolean cascade  = false;
+--- 2901,2911 ----
+          }
+      }
+  
+!     public void processDisconnect() throws HsqlException {
+          session.close();
+      }
+  
+!     public void processDropTable(boolean isView) throws HsqlException {
+  
+          boolean ifexists = false;
+          boolean cascade  = false;
+*************** class DatabaseCommandInterpreter {
+*** 2942,2948 ****
+                                           isView, cascade);
+      }
+  
+!     private void processDropUser() throws HsqlException {
+  
+          session.checkAdmin();
+          session.checkDDLWrite();
+--- 2942,2948 ----
+                                           isView, cascade);
+      }
+  
+!     public void processDropUser() throws HsqlException {
+  
+          session.checkAdmin();
+          session.checkDDLWrite();
+*************** class DatabaseCommandInterpreter {
+*** 2958,2964 ****
+          database.getUserManager().dropUser(userName);
+      }
+  
+!     private void processDropSequence() throws HsqlException {
+  
+          boolean ifexists = false;
+  
+--- 2958,2964 ----
+          database.getUserManager().dropUser(userName);
+      }
+  
+!     public void processDropSequence() throws HsqlException {
+  
+          boolean ifexists = false;
+  
+*************** class DatabaseCommandInterpreter {
+*** 2996,3002 ****
+          database.schemaManager.dropSequence(sequence);
+      }
+  
+!     private void processDropTrigger() throws HsqlException {
+  
+          session.checkAdmin();
+          session.checkDDLWrite();
+--- 2996,3002 ----
+          database.schemaManager.dropSequence(sequence);
+      }
+  
+!     public void processDropTrigger() throws HsqlException {
+  
+          session.checkAdmin();
+          session.checkDDLWrite();
+*************** class DatabaseCommandInterpreter {
+*** 3008,3014 ****
+          database.schemaManager.dropTrigger(session, triggername, schemaname);
+      }
+  
+!     private void processDropIndex() throws HsqlException {
+  
+          String name = tokenizer.getName();
+          String schema =
+--- 3008,3014 ----
+          database.schemaManager.dropTrigger(session, triggername, schemaname);
+      }
+  
+!     public void processDropIndex() throws HsqlException {
+  
+          String name = tokenizer.getName();
+          String schema =
+*************** class DatabaseCommandInterpreter {
+*** 3031,3037 ****
+          database.schemaManager.dropIndex(session, name, schema, ifexists);
+      }
+  
+!     private void processDropSchema() throws HsqlException {
+  
+          String  name    = tokenizer.getSimpleName();
+          boolean cascade = tokenizer.isGetThis(Token.T_CASCADE);
+--- 3031,3037 ----
+          database.schemaManager.dropIndex(session, name, schema, ifexists);
+      }
+  
+!     public void processDropSchema() throws HsqlException {
+  
+          String  name    = tokenizer.getSimpleName();
+          boolean cascade = tokenizer.isGetThis(Token.T_CASCADE);
+*************** class DatabaseCommandInterpreter {
+*** 3043,3049 ****
+          processDropSchema(name, cascade);
+      }
+  
+!     private void processDropSchema(String name,
+                                     boolean cascade) throws HsqlException {
+  
+          if (!database.schemaManager.schemaExists(name)) {
+--- 3043,3049 ----
+          processDropSchema(name, cascade);
+      }
+  
+!     public void processDropSchema(String name,
+                                     boolean cascade) throws HsqlException {
+  
+          if (!database.schemaManager.schemaExists(name)) {
+*************** class DatabaseCommandInterpreter {
+*** 3057,3063 ****
+          }
+      }
+  
+!     private Result processExplainPlan() throws IOException, HsqlException {
+  
+          // PRE:  we assume only one DML or DQL has been submitted
+          //       and simply ignore anything following the first
+--- 3057,3063 ----
+          }
+      }
+  
+!     public Result processExplainPlan() throws IOException, HsqlException {
+  
+          // PRE:  we assume only one DML or DQL has been submitted
+          //       and simply ignore anything following the first
+*************** class DatabaseCommandInterpreter {
+*** 3129,3135 ****
+      static final int    oldLibLen = oldLib.length();
+      static final String newLib    = "org.hsqldb.Library.";
+  
+!     private static String upgradeMethodFQN(String fqn) {
+  
+          if (fqn.startsWith(oldLib)) {
+              fqn = newLib + fqn.substring(oldLibLen);
+--- 3129,3135 ----
+      static final int    oldLibLen = oldLib.length();
+      static final String newLib    = "org.hsqldb.Library.";
+  
+!     public static String upgradeMethodFQN(String fqn) {
+  
+          if (fqn.startsWith(oldLib)) {
+              fqn = newLib + fqn.substring(oldLibLen);
+*************** class DatabaseCommandInterpreter {
+*** 3206,3212 ****
+       * @param t table
+       * @throws  HsqlException
+       */
+!     private void logTableDDL(Table t) throws HsqlException {
+  
+          StringBuffer tableDDL;
+          String       sourceDDL;
+--- 3206,3212 ----
+       * @param t table
+       * @throws  HsqlException
+       */
+!     public void logTableDDL(Table t) throws HsqlException {
+  
+          StringBuffer tableDDL;
+          String       sourceDDL;
+*************** class DatabaseCommandInterpreter {
+*** 3224,3230 ****
+          }
+      }
+  
+!     private void processAlterTableAddUniqueConstraint(Table t,
+              HsqlName n) throws HsqlException {
+  
+          int[] col;
+--- 3224,3230 ----
+          }
+      }
+  
+!     public void processAlterTableAddUniqueConstraint(Table t,
+              HsqlName n) throws HsqlException {
+  
+          int[] col;
+*************** class DatabaseCommandInterpreter {
+*** 3242,3248 ****
+          tableWorks.createUniqueConstraint(col, n);
+      }
+  
+!     private void processAlterTableAddForeignKeyConstraint(Table t,
+              HsqlName n) throws HsqlException {
+  
+          Constraint tc;
+--- 3242,3248 ----
+          tableWorks.createUniqueConstraint(col, n);
+      }
+  
+!     public void processAlterTableAddForeignKeyConstraint(Table t,
+              HsqlName n) throws HsqlException {
+  
+          Constraint tc;
+*************** class DatabaseCommandInterpreter {
+*** 3266,3272 ****
+                                      tc.core.updateAction);
+      }
+  
+!     private void processAlterTableAddCheckConstraint(Table table,
+              HsqlName name) throws HsqlException {
+  
+          Constraint check;
+--- 3266,3272 ----
+                                      tc.core.updateAction);
+      }
+  
+!     public void processAlterTableAddCheckConstraint(Table table,
+              HsqlName name) throws HsqlException {
+  
+          Constraint check;
+*************** class DatabaseCommandInterpreter {
+*** 3286,3292 ****
+          tableWorks.createCheckConstraint(check, name);
+      }
+  
+!     private void processAlterTableAddPrimaryKey(Table t,
+              HsqlName n) throws HsqlException {
+  
+          int[] col;
+--- 3286,3292 ----
+          tableWorks.createCheckConstraint(check, name);
+      }
+  
+!     public void processAlterTableAddPrimaryKey(Table t,
+              HsqlName n) throws HsqlException {
+  
+          int[] col;
+*************** class DatabaseCommandInterpreter {
+*** 3300,3306 ****
+          tableWorks.addPrimaryKey(col, n);
+      }
+  
+!     private void processReleaseSavepoint() throws HsqlException {
+  
+          String token;
+  
+--- 3300,3306 ----
+          tableWorks.addPrimaryKey(col, n);
+      }
+  
+!     public void processReleaseSavepoint() throws HsqlException {
+  
+          String token;
+  
+*************** class DatabaseCommandInterpreter {
+*** 3311,3317 ****
+          session.releaseSavepoint(token);
+      }
+  
+!     private void processAlterUser() throws HsqlException {
+  
+          String userName;
+          String password;
+--- 3311,3317 ----
+          session.releaseSavepoint(token);
+      }
+  
+!     public void processAlterUser() throws HsqlException {
+  
+          String userName;
+          String password;
+*************** class DatabaseCommandInterpreter {
+*** 3332,3338 ****
+          session.setScripting(false);
+      }
+  
+!     private String getUserIdentifier() throws HsqlException {
+  
+          String    token = tokenizer.getString();
+          Tokenizer t     = new Tokenizer(token);
+--- 3332,3338 ----
+          session.setScripting(false);
+      }
+  
+!     public String getUserIdentifier() throws HsqlException {
+  
+          String    token = tokenizer.getString();
+          Tokenizer t     = new Tokenizer(token);
+*************** class DatabaseCommandInterpreter {
+*** 3340,3346 ****
+          return t.getSimpleName();
+      }
+  
+!     private String getPassword() throws HsqlException {
+  
+          String token = tokenizer.getString();
+  
+--- 3340,3346 ----
+          return t.getSimpleName();
+      }
+  
+!     public String getPassword() throws HsqlException {
+  
+          String token = tokenizer.getString();
+  
+*************** class DatabaseCommandInterpreter {
+*** 3353,3359 ****
+       *
+       * @throws HsqlException
+       */
+!     private void processRoleGrantOrRevoke(boolean grant)
+      throws HsqlException {
+  
+          String         token;
+--- 3353,3359 ----
+       *
+       * @throws HsqlException
+       */
+!     public void processRoleGrantOrRevoke(boolean grant)
+      throws HsqlException {
+  
+          String         token;
+diff -pcr misc/hsqldb/src/org/hsqldb/DatabaseInformationFull.java misc/build/hsqldb/src/org/hsqldb/DatabaseInformationFull.java
+*** misc/hsqldb/src/org/hsqldb/DatabaseInformationFull.java	2006-04-11 16:40:54.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/DatabaseInformationFull.java	2007-02-28 12:32:48.000000000 +0100
+*************** final class DatabaseInformationFull
+*** 66,72 ****
+  extends org.hsqldb.DatabaseInformationMain {
+  
+      /** Provides SQL function/procedure reporting support. */
+!     protected DIProcedureInfo pi;
+  
+      /**
+       * Constructs a new DatabaseInformationFull instance. <p>
+--- 66,72 ----
+  extends org.hsqldb.DatabaseInformationMain {
+  
+      /** Provides SQL function/procedure reporting support. */
+!     public DIProcedureInfo pi;
+  
+      /**
+       * Constructs a new DatabaseInformationFull instance. <p>
+*************** extends org.hsqldb.DatabaseInformationMa
+*** 88,94 ****
+       * @throws HsqlException if a database access error occurs
+       * @return the system table corresponding to the specified index
+       */
+!     protected Table generateTable(int tableIndex) throws HsqlException {
+  
+          switch (tableIndex) {
+  
+--- 88,94 ----
+       * @throws HsqlException if a database access error occurs
+       * @return the system table corresponding to the specified index
+       */
+!     public Table generateTable(int tableIndex) throws HsqlException {
+  
+          switch (tableIndex) {
+  
+*************** extends org.hsqldb.DatabaseInformationMa
+*** 3237,3243 ****
+       *      in the table
+       *
+       */
+!     protected void addPColRows(Table t, HsqlArrayList l, String cat,
+                                 String schem, String pName, String cName,
+                                 Integer cType, Integer dType, String tName,
+                                 Integer prec, Integer len, Integer scale,
+--- 3237,3243 ----
+       *      in the table
+       *
+       */
+!     public void addPColRows(Table t, HsqlArrayList l, String cat,
+                                 String schem, String pName, String cName,
+                                 Integer cType, Integer dType, String tName,
+                                 Integer prec, Integer len, Integer scale,
+*************** extends org.hsqldb.DatabaseInformationMa
+*** 3337,3343 ****
+       *      in the table
+       *
+       */
+!     protected void addProcRows(Table t, HsqlArrayList l, String cat,
+                                 String schem, String pName, Integer ip,
+                                 Integer op, Integer rs, String remark,
+                                 Integer pType, String origin,
+--- 3337,3343 ----
+       *      in the table
+       *
+       */
+!     public void addProcRows(Table t, HsqlArrayList l, String cat,
+                                 String schem, String pName, Integer ip,
+                                 Integer op, Integer rs, String remark,
+                                 Integer pType, String origin,
+diff -pcr misc/hsqldb/src/org/hsqldb/DatabaseInformation.java misc/build/hsqldb/src/org/hsqldb/DatabaseInformation.java
+*** misc/hsqldb/src/org/hsqldb/DatabaseInformation.java	2005-05-16 18:49:35.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/DatabaseInformation.java	2007-02-28 12:32:48.000000000 +0100
+*************** import org.hsqldb.lib.IntValueHashMap;
+*** 56,124 ****
+  class DatabaseInformation {
+  
+      // ids for system table names strictly in order of sysTableNames[]
+!     protected static final int SYSTEM_BESTROWIDENTIFIER = 0;
+!     protected static final int SYSTEM_CATALOGS          = 1;
+!     protected static final int SYSTEM_COLUMNPRIVILEGES  = 2;
+!     protected static final int SYSTEM_COLUMNS           = 3;
+!     protected static final int SYSTEM_CROSSREFERENCE    = 4;
+!     protected static final int SYSTEM_INDEXINFO         = 5;
+!     protected static final int SYSTEM_PRIMARYKEYS       = 6;
+!     protected static final int SYSTEM_PROCEDURECOLUMNS  = 7;
+!     protected static final int SYSTEM_PROCEDURES        = 8;
+!     protected static final int SYSTEM_SCHEMAS           = 9;
+!     protected static final int SYSTEM_SUPERTABLES       = 10;
+!     protected static final int SYSTEM_SUPERTYPES        = 11;
+!     protected static final int SYSTEM_TABLEPRIVILEGES   = 12;
+!     protected static final int SYSTEM_TABLES            = 13;
+!     protected static final int SYSTEM_TABLETYPES        = 14;
+!     protected static final int SYSTEM_TYPEINFO          = 15;
+!     protected static final int SYSTEM_UDTATTRIBUTES     = 16;
+!     protected static final int SYSTEM_UDTS              = 17;
+!     protected static final int SYSTEM_USERS             = 18;
+!     protected static final int SYSTEM_VERSIONCOLUMNS    = 19;
+  
+      // HSQLDB-specific
+!     protected static final int SYSTEM_ALIASES         = 20;
+!     protected static final int SYSTEM_BYTECODE        = 21;
+!     protected static final int SYSTEM_CACHEINFO       = 22;
+!     protected static final int SYSTEM_CLASSPRIVILEGES = 23;
+!     protected static final int SYSTEM_SESSIONINFO     = 24;
+!     protected static final int SYSTEM_PROPERTIES      = 25;
+!     protected static final int SYSTEM_SESSIONS        = 26;
+!     protected static final int SYSTEM_TRIGGERCOLUMNS  = 27;
+!     protected static final int SYSTEM_TRIGGERS        = 28;
+!     protected static final int SYSTEM_ALLTYPEINFO     = 29;
+  
+  // boucherb@users 20030305 - brought in line with SQL 200n
+!     protected static final int SYSTEM_VIEWS = 30;
+  
+  // boucherb@users 20030403 - isolated and improved text table reporting
+!     protected static final int SYSTEM_TEXTTABLES = 31;
+  
+  // boucherb@users 20040107 - metadata support for sequences
+!     protected static final int SYSTEM_SEQUENCES        = 32;
+!     protected static final int SYSTEM_USAGE_PRIVILEGES = 33;
+  
+  // boucherb@users 20040107 - metadata support for constraints
+!     protected static final int SYSTEM_CHECK_CONSTRAINTS = 34;
+!     protected static final int SYSTEM_TABLE_CONSTRAINTS = 35;
+  
+  // boucherb@users 20040107 - metadata support for view usage breakdown- SQL 200n
+!     protected static final int SYSTEM_CHECK_COLUMN_USAGE  = 36;
+!     protected static final int SYSTEM_CHECK_ROUTINE_USAGE = 37;
+!     protected static final int SYSTEM_CHECK_TABLE_USAGE   = 38;
+!     protected static final int SYSTEM_VIEW_COLUMN_USAGE   = 39;
+!     protected static final int SYSTEM_VIEW_TABLE_USAGE    = 40;
+!     protected static final int SYSTEM_VIEW_ROUTINE_USAGE  = 41;
+  
+  // boucherb@users 20050514 - further SQL 200n metdata support
+!     protected static final int SYSTEM_AUTHORIZATIONS                 = 42;
+!     protected static final int SYSTEM_COLLATIONS                     = 43;
+!     protected static final int SYSTEM_ROLE_AUTHORIZATION_DESCRIPTORS = 44;
+!     protected static final int SYSTEM_SCHEMATA                       = 45;
+  
+      /** system table names strictly in order of their ids */
+!     protected static final String[] sysTableNames = {
+          "SYSTEM_BESTROWIDENTIFIER",                 //
+          "SYSTEM_CATALOGS",                          //
+          "SYSTEM_COLUMNPRIVILEGES",                  //
+--- 56,124 ----
+  class DatabaseInformation {
+  
+      // ids for system table names strictly in order of sysTableNames[]
+!     public static final int SYSTEM_BESTROWIDENTIFIER = 0;
+!     public static final int SYSTEM_CATALOGS          = 1;
+!     public static final int SYSTEM_COLUMNPRIVILEGES  = 2;
+!     public static final int SYSTEM_COLUMNS           = 3;
+!     public static final int SYSTEM_CROSSREFERENCE    = 4;
+!     public static final int SYSTEM_INDEXINFO         = 5;
+!     public static final int SYSTEM_PRIMARYKEYS       = 6;
+!     public static final int SYSTEM_PROCEDURECOLUMNS  = 7;
+!     public static final int SYSTEM_PROCEDURES        = 8;
+!     public static final int SYSTEM_SCHEMAS           = 9;
+!     public static final int SYSTEM_SUPERTABLES       = 10;
+!     public static final int SYSTEM_SUPERTYPES        = 11;
+!     public static final int SYSTEM_TABLEPRIVILEGES   = 12;
+!     public static final int SYSTEM_TABLES            = 13;
+!     public static final int SYSTEM_TABLETYPES        = 14;
+!     public static final int SYSTEM_TYPEINFO          = 15;
+!     public static final int SYSTEM_UDTATTRIBUTES     = 16;
+!     public static final int SYSTEM_UDTS              = 17;
+!     public static final int SYSTEM_USERS             = 18;
+!     public static final int SYSTEM_VERSIONCOLUMNS    = 19;
+  
+      // HSQLDB-specific
+!     public static final int SYSTEM_ALIASES         = 20;
+!     public static final int SYSTEM_BYTECODE        = 21;
+!     public static final int SYSTEM_CACHEINFO       = 22;
+!     public static final int SYSTEM_CLASSPRIVILEGES = 23;
+!     public static final int SYSTEM_SESSIONINFO     = 24;
+!     public static final int SYSTEM_PROPERTIES      = 25;
+!     public static final int SYSTEM_SESSIONS        = 26;
+!     public static final int SYSTEM_TRIGGERCOLUMNS  = 27;
+!     public static final int SYSTEM_TRIGGERS        = 28;
+!     public static final int SYSTEM_ALLTYPEINFO     = 29;
+  
+  // boucherb@users 20030305 - brought in line with SQL 200n
+!     public static final int SYSTEM_VIEWS = 30;
+  
+  // boucherb@users 20030403 - isolated and improved text table reporting
+!     public static final int SYSTEM_TEXTTABLES = 31;
+  
+  // boucherb@users 20040107 - metadata support for sequences
+!     public static final int SYSTEM_SEQUENCES        = 32;
+!     public static final int SYSTEM_USAGE_PRIVILEGES = 33;
+  
+  // boucherb@users 20040107 - metadata support for constraints
+!     public static final int SYSTEM_CHECK_CONSTRAINTS = 34;
+!     public static final int SYSTEM_TABLE_CONSTRAINTS = 35;
+  
+  // boucherb@users 20040107 - metadata support for view usage breakdown- SQL 200n
+!     public static final int SYSTEM_CHECK_COLUMN_USAGE  = 36;
+!     public static final int SYSTEM_CHECK_ROUTINE_USAGE = 37;
+!     public static final int SYSTEM_CHECK_TABLE_USAGE   = 38;
+!     public static final int SYSTEM_VIEW_COLUMN_USAGE   = 39;
+!     public static final int SYSTEM_VIEW_TABLE_USAGE    = 40;
+!     public static final int SYSTEM_VIEW_ROUTINE_USAGE  = 41;
+  
+  // boucherb@users 20050514 - further SQL 200n metdata support
+!     public static final int SYSTEM_AUTHORIZATIONS                 = 42;
+!     public static final int SYSTEM_COLLATIONS                     = 43;
+!     public static final int SYSTEM_ROLE_AUTHORIZATION_DESCRIPTORS = 44;
+!     public static final int SYSTEM_SCHEMATA                       = 45;
+  
+      /** system table names strictly in order of their ids */
+!     public static final String[] sysTableNames = {
+          "SYSTEM_BESTROWIDENTIFIER",                 //
+          "SYSTEM_CATALOGS",                          //
+          "SYSTEM_COLUMNPRIVILEGES",                  //
+*************** class DatabaseInformation {
+*** 266,272 ****
+      };
+  
+      /** Map: table name => table id */
+!     protected static final IntValueHashMap sysTableNamesMap;
+  
+      static {
+          sysTableNamesMap = new IntValueHashMap(47);
+--- 266,272 ----
+      };
+  
+      /** Map: table name => table id */
+!     public static final IntValueHashMap sysTableNamesMap;
+  
+      static {
+          sysTableNamesMap = new IntValueHashMap(47);
+*************** class DatabaseInformation {
+*** 281,293 ****
+      }
+  
+      /** Database for which to produce tables */
+!     protected final Database database;
+  
+      /**
+       * Simple object-wide flag indicating that all of this object's cached
+       * data is dirty.
+       */
+!     protected boolean isDirty = true;
+  
+      /**
+       * state flag -- if true, contentful tables are to be produced, else
+--- 281,293 ----
+      }
+  
+      /** Database for which to produce tables */
+!     public final Database database;
+  
+      /**
+       * Simple object-wide flag indicating that all of this object's cached
+       * data is dirty.
+       */
+!     public boolean isDirty = true;
+  
+      /**
+       * state flag -- if true, contentful tables are to be produced, else
+*************** class DatabaseInformation {
+*** 295,301 ****
+       * database startup where user views reference system tables and faster
+       * system table structural reflection for table metadata.
+       */
+!     protected boolean withContent = false;
+  
+      /**
+       * Factory method retuns the fullest system table producer
+--- 295,301 ----
+       * database startup where user views reference system tables and faster
+       * system table structural reflection for table metadata.
+       */
+!     public boolean withContent = false;
+  
+      /**
+       * Factory method retuns the fullest system table producer
+diff -pcr misc/hsqldb/src/org/hsqldb/DatabaseInformationMain.java misc/build/hsqldb/src/org/hsqldb/DatabaseInformationMain.java
+*** misc/hsqldb/src/org/hsqldb/DatabaseInformationMain.java	2006-01-29 16:08:25.000000000 +0100
+--- misc/build/hsqldb/src/org/hsqldb/DatabaseInformationMain.java	2007-02-28 12:32:48.000000000 +0100
+*************** class DatabaseInformationMain extends Da
+*** 118,157 ****
+      // HsqlName objects for the system tables
+  
+      /** The HsqlNames of the system tables. */
+!     protected static final HsqlName[] sysTableHsqlNames;
+  
+      /** Current user for each cached system table */
+!     protected final int[] sysTableSessions = new int[sysTableNames.length];
+  
+      /** true if the contents of a cached system table depends on the session */
+!     protected final boolean[] sysTableSessionDependent =
+          new boolean[sysTableNames.length];
+  
+      /** cache of system tables */
+!     protected final Table[] sysTables = new Table[sysTableNames.length];
+  
+      /** Set: { names of system tables that are not to be cached } */
+!     protected static final HashSet nonCachedTablesSet;
+  
+      /**
+       * Map: simple <code>Column</code> name <code>String</code> object =>
+       * <code>HsqlName</code> object.
+       */
+!     protected static final HashMap columnNameMap;
+  
+      /**
+       * The <code>Session</code> object under consideration in the current
+       * executution context.
+       */
+!     protected Session session;
+  
+      /** The table types HSQLDB supports. */
+!     protected static final String[] tableTypes = new String[] {
+          "GLOBAL TEMPORARY", "SYSTEM TABLE", "TABLE", "VIEW"
+      };
+  
+      /** Provides naming support. */
+!     protected DINameSpace ns;
+  
+      static {
+          columnNameMap      = new HashMap();
+--- 118,157 ----
+      // HsqlName objects for the system tables
+  
+      /** The HsqlNames of the system tables. */
+!     public static final HsqlName[] sysTableHsqlNames;
+  
+      /** Current user for each cached system table */
+!     public final int[] sysTableSessions = new int[sysTableNames.length];
+  
+      /** true if the contents of a cached system table depends on the session */
+!     public final boolean[] sysTableSessionDependent =
+          new boolean[sysTableNames.length];
+  
+      /** cache of system tables */
+!     public final Table[] sysTables = new Table[sysTableNames.length];
+  
+      /** Set: { names of system tables that are not to be cached } */
+!     public static final HashSet nonCachedTablesSet;
+  
+      /**
+       * Map: simple <code>Column</code> name <code>String</code> object =>
+       * <code>HsqlName</code> object.
+       */
+!     public static final HashMap columnNameMap;
+  
+      /**
+       * The <code>Session</code> object under consideration in the current
+       * executution context.
+       */
+!     public Session session;
+  
+      /** The table types HSQLDB supports. */
+!     public static final String[] tableTypes = new String[] {
+          "GLOBAL TEMPORARY", "SYSTEM TABLE", "TABLE", "VIEW"
+      };
+  
+      /** Provides naming support. */
+!     public DINameSpace ns;
+  
+      static {
+          columnNameMap      = new HashMap();
+*************** class DatabaseInformationMain extends Da
+*** 218,224 ****
+       * @throws HsqlException if a problem occurs when adding the
+       *      column (e.g. duplicate name)
+       */
+!     protected final void addColumn(Table t, String name, int type, int size,
+                                     boolean nullable) throws HsqlException {
+  
+          HsqlName cn;
+--- 218,224 ----
+       * @throws HsqlException if a problem occurs when adding the
+       *      column (e.g. duplicate name)
+       */
+!     public final void addColumn(Table t, String name, int type, int size,
+                                     boolean nullable) throws HsqlException {
+  
+          HsqlName cn;
+*************** class DatabaseInformationMain extends Da
+*** 249,255 ****
+       * @throws HsqlException if a problem occurs when adding the
+       *      column (e.g. duplicate name)
+       */
+!     protected final void addColumn(Table t, String name, int type,
+                                     boolean nullable) throws HsqlException {
+          addColumn(t, name, type, 0, nullable);
+      }
+--- 249,255 ----
+       * @throws HsqlException if a problem occurs when adding the
+       *      column (e.g. duplicate name)
+       */
+!     public final void addColumn(Table t, String name, int type,
+                                     boolean nullable) throws HsqlException {
+          addColumn(t, name, type, 0, nullable);
+      }
+*************** class DatabaseInformationMain extends Da
+*** 264,270 ****
+       * @throws HsqlException if a problem occurs when adding the
+       *      column (e.g. duplicate name)
+       */
+!     protected final void addColumn(Table t, String name,
+                                     int type) throws HsqlException {
+          addColumn(t, name, type, true);
+      }
+--- 264,270 ----
+       * @throws HsqlException if a problem occurs when adding the
+       *      column (e.g. duplicate name)
+       */
+!     public final void addColumn(Table t, String name,
+                                     int type) throws HsqlException {
+          addColumn(t, name, type, true);
+      }
+*************** class DatabaseInformationMain extends Da
+*** 276,282 ****
+       *
+       * @return an enumeration over all of the tables in this database
+       */
+!     protected final Iterator allTables() {
+          return new WrapperIterator(database.schemaManager.allTablesIterator(),
+                                     new WrapperIterator(sysTables, true));
+      }
+--- 276,282 ----
+       *
+       * @return an enumeration over all of the tables in this database
+       */
+!     public final Iterator allTables() {
+          return new WrapperIterator(database.schemaManager.allTablesIterator(),
+                                     new WrapperIterator(sysTables, true));
+      }
+*************** class DatabaseInformationMain extends Da
+*** 287,293 ****
+       *
+       * @throws HsqlException if a database access error occurs
+       */
+!     protected final void cacheClear() throws HsqlException {
+  
+          int i = sysTables.length;
+  
+--- 287,293 ----
+       *
+       * @throws HsqlException if a database access error occurs
+       */
+!     public final void cacheClear() throws HsqlException {
+  
+          int i = sysTables.length;
+  
+*************** class DatabaseInformationMain extends Da
+*** 312,318 ****
+       * @throws HsqlException if a database access error occurs
+       * @return the system table corresponding to the specified tableIndex value
+       */
+!     protected Table generateTable(int tableIndex) throws HsqlException {
+  
+          Table t = sysTables[tableIndex];
+  
+--- 312,318 ----
+       * @throws HsqlException if a database access error occurs
+       * @return the system table corresponding to the specified tableIndex value
+       */
+!     public Table generateTable(int tableIndex) throws HsqlException {
+  
+          Table t = sysTables[tableIndex];
+  
+*************** class DatabaseInformationMain extends Da
+*** 417,423 ****
+       *
+       * @throws HsqlException if a database access error occurs
+       */
+!     protected final void init() throws HsqlException {
+  
+          ns = new DINameSpace(database);
+  
+--- 417,423 ----
+       *
+       * @throws HsqlException if a database access error occurs
+       */
+!     public final void init() throws HsqlException {
+  
+          ns = new DINameSpace(database);
+  
+*************** class DatabaseInformationMain extends Da
+*** 488,494 ****
+       * @param table the table for which to check accessibility
+       * @throws HsqlException if a database access error occurs
+       */
+!     protected final boolean isAccessibleTable(Table table)
+      throws HsqlException {
+          return session.isAccessible(table.getName());
+      }
+--- 488,494 ----
+       * @param table the table for which to check accessibility
+       * @throws HsqlException if a database access error occurs
+       */
+!     public final boolean isAccessibleTable(Table table)
+      throws HsqlException {
+          return session.isAccessible(table.getName());
+      }
+*************** class DatabaseInformationMain extends Da
+*** 500,506 ****
+       * @param name of the table
+       * @throws HsqlException if a database access error occurs
+       */
+!     protected final Table createBlankTable(HsqlName name)
+      throws HsqlException {
+          return new Table(database, name, Table.SYSTEM_TABLE);
+      }
+--- 500,506 ----
+       * @param name of the table
+       * @throws HsqlException if a database access error occurs
+       */
+!     public final Table createBlankTable(HsqlName name)
+      throws HsqlException {
+          return new Table(database, name, Table.SYSTEM_TABLE);
+      }
+diff -pcr misc/hsqldb/src/org/hsqldb/Database.java misc/build/hsqldb/src/org/hsqldb/Database.java
+*** misc/hsqldb/src/org/hsqldb/Database.java	2006-04-11 16:40:53.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/Database.java	2007-02-28 12:32:48.000000000 +0100
+*************** public class Database {
+*** 123,135 ****
+      String sName;
+  
+  // loosecannon1@users 1.7.2 patch properties on the JDBC URL
+!     private HsqlProperties urlProperties;
+!     private String         sPath;
+      DatabaseInformation    dbInfo;
+      ClassLoader            classLoader;
+  
+      /** indicates the state of the database */
+!     private int   dbState;
+      public Logger logger;
+  
+      /** true means that all tables are readonly. */
+--- 123,135 ----
+      String sName;
+  
+  // loosecannon1@users 1.7.2 patch properties on the JDBC URL
+!     public HsqlProperties urlProperties;
+!     public String         sPath;
+      DatabaseInformation    dbInfo;
+      ClassLoader            classLoader;
+  
+      /** indicates the state of the database */
+!     public int   dbState;
+      public Logger logger;
+  
+      /** true means that all tables are readonly. */
+*************** public class Database {
+*** 139,157 ****
+       * true means that all CACHED and TEXT tables are readonly.
+       *  MEMORY tables are updatable but updates are not persisted.
+       */
+!     private boolean filesReadOnly;
+  
+      /** true means filesReadOnly but CACHED and TEXT tables are disallowed */
+!     private boolean                filesInJar;
+      public boolean                 sqlEnforceStrictSize;
+      public int                     firstIdentity;
+!     private boolean                bIgnoreCase;
+!     private boolean                bReferentialIntegrity;
+!     private HsqlDatabaseProperties databaseProperties;
+!     private boolean                shutdownOnNoConnection;
+  
+      // schema invarient objects
+!     private HashMap        hAlias;
+      public UserManager     userManager;
+      public GranteeManager  granteeManager;
+      public HsqlNameManager nameManager;
+--- 139,157 ----
+       * true means that all CACHED and TEXT tables are readonly.
+       *  MEMORY tables are updatable but updates are not persisted.
+       */
+!     public boolean filesReadOnly;
+  
+      /** true means filesReadOnly but CACHED and TEXT tables are disallowed */
+!     public boolean                filesInJar;
+      public boolean                 sqlEnforceStrictSize;
+      public int                     firstIdentity;
+!     public boolean                bIgnoreCase;
+!     public boolean                bReferentialIntegrity;
+!     public HsqlDatabaseProperties databaseProperties;
+!     public boolean                shutdownOnNoConnection;
+  
+      // schema invarient objects
+!     public HashMap        hAlias;
+      public UserManager     userManager;
+      public GranteeManager  granteeManager;
+      public HsqlNameManager nameManager;
+*************** public class Database {
+*** 513,519 ****
+       *  Called by the garbage collector on this Databases object when garbage
+       *  collection determines that there are no more references to it.
+       */
+!     protected void finalize() {
+  
+          if (getState() != DATABASE_ONLINE) {
+              return;
+--- 513,519 ----
+       *  Called by the garbage collector on this Databases object when garbage
+       *  collection determines that there are no more references to it.
+       */
+!     public void finalize() {
+  
+          if (getState() != DATABASE_ONLINE) {
+              return;
+*************** public class Database {
+*** 626,632 ****
+          }
+      }
+  
+!     private synchronized void setState(int state) {
+          dbState = state;
+      }
+  
+--- 626,632 ----
+          }
+      }
+  
+!     public synchronized void setState(int state) {
+          dbState = state;
+      }
+  
+*************** public class Database {
+*** 674,681 ****
+          return urlProperties;
+      }
+  
+!     private FileAccess fileaccess;
+!     private boolean    isStoredFileAccess;
+  
+      public synchronized FileAccess getFileAccess() {
+          return fileaccess;
+--- 674,681 ----
+          return urlProperties;
+      }
+  
+!     public FileAccess fileaccess;
+!     public boolean    isStoredFileAccess;
+  
+      public synchronized FileAccess getFileAccess() {
+          return fileaccess;
+diff -pcr misc/hsqldb/src/org/hsqldb/DatabaseManager.java misc/build/hsqldb/src/org/hsqldb/DatabaseManager.java
+*** misc/hsqldb/src/org/hsqldb/DatabaseManager.java	2006-01-07 17:01:24.000000000 +0100
+--- misc/build/hsqldb/src/org/hsqldb/DatabaseManager.java	2007-02-28 12:32:48.000000000 +0100
+*************** public class DatabaseManager {
+*** 62,68 ****
+      // Database and Server registry
+  
+      /** provides unique ID's for the Databases currently in registry */
+!     private static int dbIDCounter;
+  
+      /** name to Database mapping for mem: databases */
+      static final HashMap memDatabaseMap = new HashMap();
+--- 62,68 ----
+      // Database and Server registry
+  
+      /** provides unique ID's for the Databases currently in registry */
+!     public static int dbIDCounter;
+  
+      /** name to Database mapping for mem: databases */
+      static final HashMap memDatabaseMap = new HashMap();
+*************** public class DatabaseManager {
+*** 235,241 ****
+      }
+  
+  // loosecannon1@users 1.7.2 patch properties on the JDBC URL
+!     private static synchronized Database getDatabaseObject(String type,
+              String path, HsqlProperties props) throws HsqlException {
+  
+          Database db;
+--- 235,241 ----
+      }
+  
+  // loosecannon1@users 1.7.2 patch properties on the JDBC URL
+!     public static synchronized Database getDatabaseObject(String type,
+              String path, HsqlProperties props) throws HsqlException {
+  
+          Database db;
+*************** public class DatabaseManager {
+*** 274,280 ****
+       * Looks up database of a given type and path in the registry. Returns
+       * null if there is none.
+       */
+!     private static synchronized Database lookupDatabaseObject(String type,
+              String path) throws HsqlException {
+  
+          Object  key = path;
+--- 274,280 ----
+       * Looks up database of a given type and path in the registry. Returns
+       * null if there is none.
+       */
+!     public static synchronized Database lookupDatabaseObject(String type,
+              String path) throws HsqlException {
+  
+          Object  key = path;
+*************** public class DatabaseManager {
+*** 300,306 ****
+       * Adds a database to the registry. Returns
+       * null if there is none.
+       */
+!     private static synchronized void addDatabaseObject(String type,
+              String path, Database db) throws HsqlException {
+  
+          Object  key = path;
+--- 300,306 ----
+       * Adds a database to the registry. Returns
+       * null if there is none.
+       */
+!     public static synchronized void addDatabaseObject(String type,
+              String path, Database db) throws HsqlException {
+  
+          Object  key = path;
+*************** public class DatabaseManager {
+*** 408,414 ****
+      /**
+       * Deregisters a server as serving a given database. Not yet used.
+       */
+!     private static void deRegisterServer(Server server, Database db) {
+  
+          Iterator it = serverMap.values().iterator();
+  
+--- 408,414 ----
+      /**
+       * Deregisters a server as serving a given database. Not yet used.
+       */
+!     public static void deRegisterServer(Server server, Database db) {
+  
+          Iterator it = serverMap.values().iterator();
+  
+*************** public class DatabaseManager {
+*** 426,432 ****
+      /**
+       * Registers a server as serving a given database.
+       */
+!     private static void registerServer(Server server, Database db) {
+  
+          if (!serverMap.containsKey(server)) {
+              serverMap.put(server, new HashSet());
+--- 426,432 ----
+      /**
+       * Registers a server as serving a given database.
+       */
+!     public static void registerServer(Server server, Database db) {
+  
+          if (!serverMap.containsKey(server)) {
+              serverMap.put(server, new HashSet());
+*************** public class DatabaseManager {
+*** 441,447 ****
+       * Notifies all servers that serve the database that the database has been
+       * shutdown.
+       */
+!     private static void notifyServers(Database db) {
+  
+          Iterator it = serverMap.keySet().iterator();
+  
+--- 441,447 ----
+       * Notifies all servers that serve the database that the database has been
+       * shutdown.
+       */
+!     public static void notifyServers(Database db) {
+  
+          Iterator it = serverMap.keySet().iterator();
+  
+*************** public class DatabaseManager {
+*** 473,479 ****
+      }
+  
+      // Timer
+!     private static final HsqlTimer timer = new HsqlTimer();
+  
+      public static HsqlTimer getTimer() {
+          return timer;
+--- 473,479 ----
+      }
+  
+      // Timer
+!     public static final HsqlTimer timer = new HsqlTimer();
+  
+      public static HsqlTimer getTimer() {
+          return timer;
+*************** public class DatabaseManager {
+*** 481,487 ****
+  
+      // converts file path to database lookup key, converting any
+      // thrown exception to an HsqlException in the process
+!     private static String filePathToKey(String path) throws HsqlException {
+  
+          try {
+              return FileUtil.canonicalPath(path);
+--- 481,487 ----
+  
+      // converts file path to database lookup key, converting any
+      // thrown exception to an HsqlException in the process
+!     public static String filePathToKey(String path) throws HsqlException {
+  
+          try {
+              return FileUtil.canonicalPath(path);
+diff -pcr misc/hsqldb/src/org/hsqldb/DatabaseScript.java misc/build/hsqldb/src/org/hsqldb/DatabaseScript.java
+*** misc/hsqldb/src/org/hsqldb/DatabaseScript.java	2006-07-10 13:14:26.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/DatabaseScript.java	2007-02-28 12:32:48.000000000 +0100
+*************** public class DatabaseScript {
+*** 665,671 ****
+      /**
+       * Generates the column definitions for a table.
+       */
+!     private static void getColumnList(Table t, int[] col, int len,
+                                        StringBuffer a) {
+  
+          a.append('(');
+--- 665,671 ----
+      /**
+       * Generates the column definitions for a table.
+       */
+!     public static void getColumnList(Table t, int[] col, int len,
+                                        StringBuffer a) {
+  
+          a.append('(');
+*************** public class DatabaseScript {
+*** 684,690 ****
+      /**
+       * Generates the foreign key declaration for a given Constraint object.
+       */
+!     private static void getFKStatement(Constraint c, StringBuffer a) {
+  
+          a.append(Token.T_CONSTRAINT).append(' ');
+          a.append(c.getName().statementName);
+--- 684,690 ----
+      /**
+       * Generates the foreign key declaration for a given Constraint object.
+       */
+!     public static void getFKStatement(Constraint c, StringBuffer a) {
+  
+          a.append(Token.T_CONSTRAINT).append(' ');
+          a.append(c.getName().statementName);
+*************** public class DatabaseScript {
+*** 716,722 ****
+      /**
+       * Returns the foreign key action rule.
+       */
+!     private static String getFKAction(int action) {
+  
+          switch (action) {
+  
+--- 716,722 ----
+      /**
+       * Returns the foreign key action rule.
+       */
+!     public static String getFKAction(int action) {
+  
+          switch (action) {
+  
+*************** public class DatabaseScript {
+*** 737,743 ****
+      /**
+       * Adds a script line to the result.
+       */
+!     private static void addRow(Result r, String sql) {
+  
+          if (sql == null || sql.length() == 0) {
+              return;
+--- 737,743 ----
+      /**
+       * Adds a script line to the result.
+       */
+!     public static void addRow(Result r, String sql) {
+  
+          if (sql == null || sql.length() == 0) {
+              return;
+*************** public class DatabaseScript {
+*** 762,768 ****
+       * grant select on system tables
+       *
+       */
+!     private static void addRightsStatements(Database dDatabase, Result r) {
+  
+          StringBuffer   a;
+          HashMappedList userlist = dDatabase.getUserManager().getUsers();
+--- 762,768 ----
+       * grant select on system tables
+       *
+       */
+!     public static void addRightsStatements(Database dDatabase, Result r) {
+  
+          StringBuffer   a;
+          HashMappedList userlist = dDatabase.getUserManager().getUsers();
+diff -pcr misc/hsqldb/src/org/hsqldb/DINameSpace.java misc/build/hsqldb/src/org/hsqldb/DINameSpace.java
+*** misc/hsqldb/src/org/hsqldb/DINameSpace.java	2006-04-11 16:40:55.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/DINameSpace.java	2007-02-28 12:32:48.000000000 +0100
+*************** import org.hsqldb.lib.WrapperIterator;
+*** 61,70 ****
+  final class DINameSpace {
+  
+      /** The Database for which the name space functionality is provided */
+!     private Database database;
+  
+      /** The catalog name reported by this namespace */
+!     private String catalogName;
+  
+      /**
+       * Set { <code>Class</code> FQN <code>String</code> objects }. <p>
+--- 61,70 ----
+  final class DINameSpace {
+  
+      /** The Database for which the name space functionality is provided */
+!     public Database database;
+  
+      /** The catalog name reported by this namespace */
+!     public String catalogName;
+  
+      /**
+       * Set { <code>Class</code> FQN <code>String</code> objects }. <p>
+*************** final class DINameSpace {
+*** 74,80 ****
+       * support of the expected SQL CLI scalar functions and other core
+       * HSQLDB SQL functions and stored procedures. <p>
+       */
+!     private static HashSet builtin = new HashSet();
+  
+      // procedure columns
+      // make temporary ad-hoc spec a little more "official"
+--- 74,80 ----
+       * support of the expected SQL CLI scalar functions and other core
+       * HSQLDB SQL functions and stored procedures. <p>
+       */
+!     public static HashSet builtin = new HashSet();
+  
+      // procedure columns
+      // make temporary ad-hoc spec a little more "official"
+diff -pcr misc/hsqldb/src/org/hsqldb/DIProcedureInfo.java misc/build/hsqldb/src/org/hsqldb/DIProcedureInfo.java
+*** misc/hsqldb/src/org/hsqldb/DIProcedureInfo.java	2005-10-23 20:26:19.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/DIProcedureInfo.java	2007-02-28 12:32:48.000000000 +0100
+*************** final class DIProcedureInfo {
+*** 70,94 ****
+      static final int      procedureNoNulls         = 0;
+      static final int      procedureNullable        = 1;
+      static final int      procedureNullableUnknown = 2;
+!     private Class         clazz;
+!     private Class[]       colClasses;
+!     private int[]         colTypes;
+!     private int           colOffset;
+!     private int           colCount;
+!     private boolean       colsResolved;
+!     private String        fqn;
+!     private String        specificName;
+!     private int           hnd_remarks;
+!     private Method        method;
+!     private String        sig;
+!     private DINameSpace   nameSpace;
+!     private final HashMap typeMap = new HashMap();
+  
+      public DIProcedureInfo(DINameSpace ns) throws HsqlException {
+          setNameSpace(ns);
+      }
+  
+!     private int colOffset() {
+  
+          if (!colsResolved) {
+              resolveCols();
+--- 70,94 ----
+      static final int      procedureNoNulls         = 0;
+      static final int      procedureNullable        = 1;
+      static final int      procedureNullableUnknown = 2;
+!     public Class         clazz;
+!     public Class[]       colClasses;
+!     public int[]         colTypes;
+!     public int           colOffset;
+!     public int           colCount;
+!     public boolean       colsResolved;
+!     public String        fqn;
+!     public String        specificName;
+!     public int           hnd_remarks;
+!     public Method        method;
+!     public String        sig;
+!     public DINameSpace   nameSpace;
+!     public final HashMap typeMap = new HashMap();
+  
+      public DIProcedureInfo(DINameSpace ns) throws HsqlException {
+          setNameSpace(ns);
+      }
+  
+!     public int colOffset() {
+  
+          if (!colsResolved) {
+              resolveCols();
+*************** final class DIProcedureInfo {
+*** 512,518 ****
+          } catch (Exception e) {}
+      }
+  
+!     private void resolveCols() {
+  
+          Class   rType;
+          Class[] pTypes;
+--- 512,518 ----
+          } catch (Exception e) {}
+      }
+  
+!     public void resolveCols() {
+  
+          Class   rType;
+          Class[] pTypes;
+diff -pcr misc/hsqldb/src/org/hsqldb/DiskNode.java misc/build/hsqldb/src/org/hsqldb/DiskNode.java
+*** misc/hsqldb/src/org/hsqldb/DiskNode.java	2006-06-28 23:47:51.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/DiskNode.java	2007-02-28 12:32:48.000000000 +0100
+*************** import org.hsqldb.rowio.RowOutputInterfa
+*** 93,103 ****
+   */
+  class DiskNode extends Node {
+  
+!     protected Row    rData;
+!     private int      iLeft   = NO_POS;
+!     private int      iRight  = NO_POS;
+!     private int      iParent = NO_POS;
+!     private int      iId;    // id of Index object for this Node
+      static final int SIZE_IN_BYTE = 4 * 4;
+  
+      DiskNode(CachedRow r, RowInputInterface in,
+--- 93,103 ----
+   */
+  class DiskNode extends Node {
+  
+!     public Row    rData;
+!     public int      iLeft   = NO_POS;
+!     public int      iRight  = NO_POS;
+!     public int      iParent = NO_POS;
+!     public int      iId;    // id of Index object for this Node
+      static final int SIZE_IN_BYTE = 4 * 4;
+  
+      DiskNode(CachedRow r, RowInputInterface in,
+*************** class DiskNode extends Node {
+*** 162,168 ****
+          return rData;
+      }
+  
+!     private Node findNode(int pos) throws HsqlException {
+  
+          Node ret = null;
+          Row  r   = ((CachedRow) rData).getTable().getRow(pos);
+--- 162,168 ----
+          return rData;
+      }
+  
+!     public Node findNode(int pos) throws HsqlException {
+  
+          Node ret = null;
+          Row  r   = ((CachedRow) rData).getTable().getRow(pos);
+*************** class DiskNode extends Node {
+*** 378,384 ****
+          writeTranslatePointer(iParent, out, lookup);
+      }
+  
+!     private void writeTranslatePointer(int pointer, RowOutputInterface out,
+                                         IntLookup lookup) {
+  
+          int newPointer = 0;
+--- 378,384 ----
+          writeTranslatePointer(iParent, out, lookup);
+      }
+  
+!     public void writeTranslatePointer(int pointer, RowOutputInterface out,
+                                         IntLookup lookup) {
+  
+          int newPointer = 0;
+diff -pcr misc/hsqldb/src/org/hsqldb/DITableInfo.java misc/build/hsqldb/src/org/hsqldb/DITableInfo.java
+*** misc/hsqldb/src/org/hsqldb/DITableInfo.java	2005-12-06 02:31:16.000000000 +0100
+--- misc/build/hsqldb/src/org/hsqldb/DITableInfo.java	2007-02-28 12:32:48.000000000 +0100
+*************** final class DITableInfo {
+*** 55,73 ****
+      static final short tableIndexOther    = 3;
+  
+      /** Used in buffer size and character octet length determinations. */
+!     private static final int HALF_MAX_INT = Integer.MAX_VALUE >>> 1;
+  
+      /** BundleHandler id for column remarks resource bundle. */
+!     private int hnd_column_remarks = -1;
+  
+      /** BundleHandler id for table remarks resource bundle. */
+!     private int hnd_table_remarks = -1;
+  
+      /** The Table object upon which this object is reporting. */
+!     private Table table;
+  
+      /** Provides intrinsic type infformation support. */
+!     private static final DITypeInfo ti = new DITypeInfo();
+  
+      /**
+       * Creates a new DITableInfo object with the default Locale and reporting
+--- 55,73 ----
+      static final short tableIndexOther    = 3;
+  
+      /** Used in buffer size and character octet length determinations. */
+!     public static final int HALF_MAX_INT = Integer.MAX_VALUE >>> 1;
+  
+      /** BundleHandler id for column remarks resource bundle. */
+!     public int hnd_column_remarks = -1;
+  
+      /** BundleHandler id for table remarks resource bundle. */
+!     public int hnd_table_remarks = -1;
+  
+      /** The Table object upon which this object is reporting. */
+!     public Table table;
+  
+      /** Provides intrinsic type infformation support. */
+!     public static final DITypeInfo ti = new DITypeInfo();
+  
+      /**
+       * Creates a new DITableInfo object with the default Locale and reporting
+diff -pcr misc/hsqldb/src/org/hsqldb/DITypeInfo.java misc/build/hsqldb/src/org/hsqldb/DITypeInfo.java
+*** misc/hsqldb/src/org/hsqldb/DITypeInfo.java	2006-01-29 16:04:06.000000000 +0100
+--- misc/build/hsqldb/src/org/hsqldb/DITypeInfo.java	2007-02-28 12:32:48.000000000 +0100
+*************** final class DITypeInfo {
+*** 57,75 ****
+      static final int typeSearchable = 3;
+  
+      /** BundleHandler id for create params resource bundle. */
+!     private int hnd_create_params = -1;
+  
+      /** BundleHandler id for local names resource bundle. */
+!     private int hnd_local_names = -1;
+  
+      /** BundleHandler id for data type remarks resource bundle. */
+!     private int hnd_remarks = -1;
+  
+      /** The SQL type code on which this object is reporting. */
+!     private int type = Types.NULL;
+  
+      /** The HSQLDB subtype code on which this object is reporting. */
+!     private int typeSub = Types.TYPE_SUB_DEFAULT;
+      boolean     locale_set;
+  
+      /** Creates a new DITypeInfo object having the default Locale. */
+--- 57,75 ----
+      static final int typeSearchable = 3;
+  
+      /** BundleHandler id for create params resource bundle. */
+!     public int hnd_create_params = -1;
+  
+      /** BundleHandler id for local names resource bundle. */
+!     public int hnd_local_names = -1;
+  
+      /** BundleHandler id for data type remarks resource bundle. */
+!     public int hnd_remarks = -1;
+  
+      /** The SQL type code on which this object is reporting. */
+!     public int type = Types.NULL;
+  
+      /** The HSQLDB subtype code on which this object is reporting. */
+!     public int typeSub = Types.TYPE_SUB_DEFAULT;
+      boolean     locale_set;
+  
+      /** Creates a new DITypeInfo object having the default Locale. */
+diff -pcr misc/hsqldb/src/org/hsqldb/Expression.java misc/build/hsqldb/src/org/hsqldb/Expression.java
+*** misc/hsqldb/src/org/hsqldb/Expression.java	2006-07-10 13:02:53.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/Expression.java	2007-02-28 12:32:48.000000000 +0100
+*************** public class Expression {
+*** 222,249 ****
+          });
+      }
+  
+!     private static final int AGGREGATE_SELF     = -1;
+!     private static final int AGGREGATE_NONE     = 0;
+!     private static final int AGGREGATE_LEFT     = 1;
+!     private static final int AGGREGATE_RIGHT    = 2;
+!     private static final int AGGREGATE_BOTH     = 3;
+!     private static final int AGGREGATE_FUNCTION = 4;
+  
+      // type
+      int         exprType;
+!     private int aggregateSpec = AGGREGATE_NONE;
+  
+      // nodes
+      Expression eArg, eArg2;
+  
+      // VALUE
+      Object      valueData;
+!     private int dataType;
+  
+      // VALUE LIST NEW
+      HashSet         hList;
+      Expression[]    valueList;
+!     private boolean isFixedConstantValueList;
+  
+      // QUERY - in single value selects, IN or EXISTS predicates
+      SubQuery subQuery;
+--- 222,249 ----
+          });
+      }
+  
+!     public static final int AGGREGATE_SELF     = -1;
+!     public static final int AGGREGATE_NONE     = 0;
+!     public static final int AGGREGATE_LEFT     = 1;
+!     public static final int AGGREGATE_RIGHT    = 2;
+!     public static final int AGGREGATE_BOTH     = 3;
+!     public static final int AGGREGATE_FUNCTION = 4;
+  
+      // type
+      int         exprType;
+!     public int aggregateSpec = AGGREGATE_NONE;
+  
+      // nodes
+      Expression eArg, eArg2;
+  
+      // VALUE
+      Object      valueData;
+!     public int dataType;
+  
+      // VALUE LIST NEW
+      HashSet         hList;
+      Expression[]    valueList;
+!     public boolean isFixedConstantValueList;
+  
+      // QUERY - in single value selects, IN or EXISTS predicates
+      SubQuery subQuery;
+*************** public class Expression {
+*** 253,283 ****
+      Function function;
+  
+      // LIKE
+!     private Like likeObject;
+  
+      // COLUMN
+!     private String      catalog;
+!     private String      schema;
+!     private String      tableName;
+!     private String      columnName;
+!     private TableFilter tableFilter;                // null if not yet resolved
+      TableFilter         outerFilter;                // defined if this is part of an OUTER JOIN condition tree
+  
+      // COLUMN
+!     private int     columnIndex;
+!     private boolean columnQuoted;
+!     private int     precision;
+!     private int     scale;
+!     private String  columnAlias;                    // if it is a column of a select column list
+!     private boolean aliasQuoted;
+  
+      //
+!     private boolean isDescending;                   // if it is a column in a order by
+      int             joinedTableColumnIndex = -1;    // >= 0 when it is used for order by
+      boolean         isDistinctAggregate;
+  
+      // PARAM
+!     private boolean isParam;
+  
+      // does Expression stem from a JOIN <table> ON <expression>
+      boolean isInJoin;
+--- 253,283 ----
+      Function function;
+  
+      // LIKE
+!     public Like likeObject;
+  
+      // COLUMN
+!     public String      catalog;
+!     public String      schema;
+!     public String      tableName;
+!     public String      columnName;
+!     public TableFilter tableFilter;                // null if not yet resolved
+      TableFilter         outerFilter;                // defined if this is part of an OUTER JOIN condition tree
+  
+      // COLUMN
+!     public int     columnIndex;
+!     public boolean columnQuoted;
+!     public int     precision;
+!     public int     scale;
+!     public String  columnAlias;                    // if it is a column of a select column list
+!     public boolean aliasQuoted;
+  
+      //
+!     public boolean isDescending;                   // if it is a column in a order by
+      int             joinedTableColumnIndex = -1;    // >= 0 when it is used for order by
+      boolean         isDistinctAggregate;
+  
+      // PARAM
+!     public boolean isParam;
+  
+      // does Expression stem from a JOIN <table> ON <expression>
+      boolean isInJoin;
+*************** public class Expression {
+*** 496,502 ****
+                 && scale == other.scale;
+      }
+  
+!     private void checkAggregate() {
+  
+          if (isAggregate(exprType)) {
+              aggregateSpec = AGGREGATE_SELF;
+--- 496,502 ----
+                 && scale == other.scale;
+      }
+  
+!     public void checkAggregate() {
+  
+          if (isAggregate(exprType)) {
+              aggregateSpec = AGGREGATE_SELF;
+*************** public class Expression {
+*** 835,841 ****
+          throw Trace.error(Trace.EXPRESSION_NOT_SUPPORTED);
+      }
+  
+!     private String describe(Session session, int blanks) {
+  
+          int          lIType;
+          StringBuffer buf = new StringBuffer(64);
+--- 835,841 ----
+          throw Trace.error(Trace.EXPRESSION_NOT_SUPPORTED);
+      }
+  
+!     public String describe(Session session, int blanks) {
+  
+          int          lIType;
+          StringBuffer buf = new StringBuffer(64);
+*************** public class Expression {
+*** 1216,1222 ****
+       *
+       * @return boolean
+       */
+!     private boolean isColumn() {
+  
+          switch (exprType) {
+  
+--- 1216,1222 ----
+       *
+       * @return boolean
+       */
+!     public boolean isColumn() {
+  
+          switch (exprType) {
+  
+*************** public class Expression {
+*** 3478,3484 ****
+          return compareValues(session, o1, o2);
+      }
+  
+!     private Boolean compareValues(Session session, Object o1,
+                                    Object o2) throws HsqlException {
+  
+          int type = eArg.dataType;
+--- 3478,3484 ----
+          return compareValues(session, o1, o2);
+      }
+  
+!     public Boolean compareValues(Session session, Object o1,
+                                    Object o2) throws HsqlException {
+  
+          int type = eArg.dataType;
+*************** public class Expression {
+*** 3536,3542 ****
+       * @return boolean
+       * @throws HsqlException
+       */
+!     private Boolean testInCondition(Session session,
+                                      Object o) throws HsqlException {
+  
+          if (o == null) {
+--- 3536,3542 ----
+       * @return boolean
+       * @throws HsqlException
+       */
+!     public Boolean testInCondition(Session session,
+                                      Object o) throws HsqlException {
+  
+          if (o == null) {
+*************** public class Expression {
+*** 3600,3606 ****
+          throw Trace.error(Trace.WRONG_DATA_TYPE);
+      }
+  
+!     private Boolean testExistsCondition(Session session)
+      throws HsqlException {
+  
+          if (subQuery.isResolved) {
+--- 3600,3606 ----
+          throw Trace.error(Trace.WRONG_DATA_TYPE);
+      }
+  
+!     public Boolean testExistsCondition(Session session)
+      throws HsqlException {
+  
+          if (subQuery.isResolved) {
+*************** public class Expression {
+*** 3614,3620 ****
+          }
+      }
+  
+!     private Boolean testAnyAllCondition(Session session,
+                                          Object o) throws HsqlException {
+  
+          if (o == null) {
+--- 3614,3620 ----
+          }
+      }
+  
+!     public Boolean testAnyAllCondition(Session session,
+                                          Object o) throws HsqlException {
+  
+          if (o == null) {
+*************** public class Expression {
+*** 3637,3643 ****
+          return result;
+      }
+  
+!     private Boolean getAnyAllValue(Session session, Object o,
+                                     SubQuery subquery) throws HsqlException {
+  
+          boolean     empty    = subquery.table.isEmpty(session);
+--- 3637,3643 ----
+          return result;
+      }
+  
+!     public Boolean getAnyAllValue(Session session, Object o,
+                                     SubQuery subquery) throws HsqlException {
+  
+          boolean     empty    = subquery.table.isEmpty(session);
+diff -pcr misc/hsqldb/src/org/hsqldb/Function.java misc/build/hsqldb/src/org/hsqldb/Function.java
+*** misc/hsqldb/src/org/hsqldb/Function.java	2005-10-23 19:40:08.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/Function.java	2007-02-28 12:32:48.000000000 +0100
+*************** import org.hsqldb.types.JavaObject;
+*** 96,115 ****
+   */
+  class Function {
+  
+!     private String         sFunction;
+!     private Method         mMethod;
+!     private Class          cReturnClass;
+!     private Class[]        aArgClasses;
+!     private int            iReturnType;
+!     private int            iArgCount;
+!     private int            iSqlArgCount;
+!     private int            iSqlArgStart;
+!     private int[]          iArgType;
+!     private boolean[]      bArgNullable;
+      Expression[]           eArg;
+!     private boolean        bConnection;
+!     private static HashMap methodCache = new HashMap();
+!     private int            fID;
+      String                 name;        // name used to call function
+      boolean                isSimple;    //CURRENT_TIME, NOW etc.
+      boolean                hasAggregate;
+--- 96,115 ----
+   */
+  class Function {
+  
+!     public String         sFunction;
+!     public Method         mMethod;
+!     public Class          cReturnClass;
+!     public Class[]        aArgClasses;
+!     public int            iReturnType;
+!     public int            iArgCount;
+!     public int            iSqlArgCount;
+!     public int            iSqlArgStart;
+!     public int[]          iArgType;
+!     public boolean[]      bArgNullable;
+      Expression[]           eArg;
+!     public boolean        bConnection;
+!     public static HashMap methodCache = new HashMap();
+!     public int            fID;
+      String                 name;        // name used to call function
+      boolean                isSimple;    //CURRENT_TIME, NOW etc.
+      boolean                hasAggregate;
+*************** class Function {
+*** 368,374 ****
+          // Library function throw HsqlException
+      }
+  
+!     private Object[] getArguments(Session session) throws HsqlException {
+  
+          int      i    = bConnection ? 1
+                                      : 0;
+--- 368,374 ----
+          // Library function throw HsqlException
+      }
+  
+!     public Object[] getArguments(Session session) throws HsqlException {
+  
+          int      i    = bConnection ? 1
+                                      : 0;
+*************** class Function {
+*** 405,411 ****
+      /**
+       * returns null if any non-nullable element of values is null
+       */
+!     private Object[] getNotNull(Object[] values) throws HsqlException {
+  
+          int i = bConnection ? 1
+                              : 0;
+--- 405,411 ----
+      /**
+       * returns null if any non-nullable element of values is null
+       */
+!     public Object[] getNotNull(Object[] values) throws HsqlException {
+  
+          int i = bConnection ? 1
+                              : 0;
+diff -pcr misc/hsqldb/src/org/hsqldb/Grantee.java misc/build/hsqldb/src/org/hsqldb/Grantee.java
+*** misc/hsqldb/src/org/hsqldb/Grantee.java	2006-04-11 16:40:57.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/Grantee.java	2007-02-28 12:32:48.000000000 +0100
+*************** import org.hsqldb.lib.Set;
+*** 52,60 ****
+   * Method names ending in Direct indicate methods which do not recurse
+   * to look through Roles which "this" object is a member of.
+   *
+!  * We use the word "Admin" (e.g., in private variable "admin" and method
+   * "isAdmin()) to mean this Grantee has admin priv by any means.
+!  * We use the word "adminDirect" (e.g., in private variable "adminDirect"
+   * and method "isAdminDirect()) to mean this Grantee has admin priv
+   * directly.
+   *
+--- 52,60 ----
+   * Method names ending in Direct indicate methods which do not recurse
+   * to look through Roles which "this" object is a member of.
+   *
+!  * We use the word "Admin" (e.g., in public variable "admin" and method
+   * "isAdmin()) to mean this Grantee has admin priv by any means.
+!  * We use the word "adminDirect" (e.g., in public variable "adminDirect"
+   * and method "isAdminDirect()) to mean this Grantee has admin priv
+   * directly.
+   *
+*************** public class Grantee {
+*** 73,93 ****
+       * true if this grantee has database administrator priv directly
+       *  (ie., not by membership in any role)
+       */
+!     private boolean isAdminDirect = false;
+  
+      /** true if this grantee has database administrator priv by any means. */
+!     private boolean isAdmin = false;
+  
+      /** contains righs granted direct, or via roles, expept those of PUBLIC */
+!     private IntValueHashMap fullRightsMap = new IntValueHashMap();
+  
+      /**
+       * Grantee name.
+       */
+!     private String granteeName;
+  
+      /** map with database object identifier keys and access privileges values */
+!     private IntValueHashMap rightsMap;
+  
+      /** These are the DIRECT roles.  Each of these may contain nested roles */
+      HashSet roles = new HashSet();
+--- 73,93 ----
+       * true if this grantee has database administrator priv directly
+       *  (ie., not by membership in any role)
+       */
+!     public boolean isAdminDirect = false;
+  
+      /** true if this grantee has database administrator priv by any means. */
+!     public boolean isAdmin = false;
+  
+      /** contains righs granted direct, or via roles, expept those of PUBLIC */
+!     public IntValueHashMap fullRightsMap = new IntValueHashMap();
+  
+      /**
+       * Grantee name.
+       */
+!     public String granteeName;
+  
+      /** map with database object identifier keys and access privileges values */
+!     public IntValueHashMap rightsMap;
+  
+      /** These are the DIRECT roles.  Each of these may contain nested roles */
+      HashSet roles = new HashSet();
+*************** public class Grantee {
+*** 98,107 ****
+       * Note: All Grantee objects except the special
+       * SYS and PUBLIC Grantee objects contain a reference to this object
+       */
+!     private Grantee pubGrantee;
+  
+      /** Needed only to give access to the roles for this database */
+!     private GranteeManager granteeManager;
+  
+      /**
+       * Constructor, with a argument reference to the PUBLIC User Object which
+--- 98,107 ----
+       * Note: All Grantee objects except the special
+       * SYS and PUBLIC Grantee objects contain a reference to this object
+       */
+!     public Grantee pubGrantee;
+  
+      /** Needed only to give access to the roles for this database */
+!     public GranteeManager granteeManager;
+  
+      /**
+       * Constructor, with a argument reference to the PUBLIC User Object which
+*************** public class Grantee {
+*** 219,225 ****
+       *
+       * @return Given role with new elements added.
+       */
+!     private HashSet addGranteeAndRoles(HashSet set) {
+  
+          String candidateRole;
+  
+--- 219,225 ----
+       *
+       * @return Given role with new elements added.
+       */
+!     public HashSet addGranteeAndRoles(HashSet set) {
+  
+          String candidateRole;
+  
+*************** public class Grantee {
+*** 431,437 ****
+       * Considers none of pubGranee, nested roles, admin privs, globally
+       * available Class object.
+       */
+!     protected boolean isDirectlyAccessible(Object dbObject,
+                                             int rights) throws HsqlException {
+  
+          int n = rightsMap.get(dbObject, 0);
+--- 431,437 ----
+       * Considers none of pubGranee, nested roles, admin privs, globally
+       * available Class object.
+       */
+!     public boolean isDirectlyAccessible(Object dbObject,
+                                             int rights) throws HsqlException {
+  
+          int n = rightsMap.get(dbObject, 0);
+diff -pcr misc/hsqldb/src/org/hsqldb/GranteeManager.java misc/build/hsqldb/src/org/hsqldb/GranteeManager.java
+*** misc/hsqldb/src/org/hsqldb/GranteeManager.java	2005-10-29 20:30:23.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/GranteeManager.java	2007-02-28 12:32:48.000000000 +0100
+*************** class GranteeManager implements GrantCon
+*** 105,117 ****
+       * Map of String-to-Grantee-objects.<p>
+       * Primary object maintained by this class
+       */
+!     private HashMappedList map = new HashMappedList();
+  
+      /**
+       * This object's set of Role objects. <p>
+       * role-Strings-to-Grantee-object
+       */
+!     private HashMappedList roleMap = new HashMappedList();
+  
+      /**
+       * Construct the GranteeManager for a Database.
+--- 105,117 ----
+       * Map of String-to-Grantee-objects.<p>
+       * Primary object maintained by this class
+       */
+!     public HashMappedList map = new HashMappedList();
+  
+      /**
+       * This object's set of Role objects. <p>
+       * role-Strings-to-Grantee-object
+       */
+!     public HashMappedList roleMap = new HashMappedList();
+  
+      /**
+       * Construct the GranteeManager for a Database.
+*************** class GranteeManager implements GrantCon
+*** 451,457 ****
+          return list;
+      }
+  
+!     private static String[] getRightsArraySub(int right) {
+  
+  //        checkValidFlags(right);
+          if (right == 0) {
+--- 451,457 ----
+          return list;
+      }
+  
+!     public static String[] getRightsArraySub(int right) {
+  
+  //        checkValidFlags(right);
+          if (right == 0) {
+diff -pcr misc/hsqldb/src/org/hsqldb/GroupedResult.java misc/build/hsqldb/src/org/hsqldb/GroupedResult.java
+*** misc/hsqldb/src/org/hsqldb/GroupedResult.java	2005-10-23 20:26:20.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/GroupedResult.java	2007-02-28 12:32:48.000000000 +0100
+*************** import org.hsqldb.lib.Iterator;
+*** 68,80 ****
+  class GroupedResult {
+  
+  /** @todo fredt - initialise results on first use */
+!     private Result        result;
+      int                   groupBegin;
+      int                   groupEnd;
+!     private final boolean isGrouped;
+!     private final boolean isAggregated;
+!     private HashSet       groups;
+!     private ResultGroup   currGroup;
+  
+      GroupedResult(Select select, Result.ResultMetaData meta) {
+  
+--- 68,80 ----
+  class GroupedResult {
+  
+  /** @todo fredt - initialise results on first use */
+!     public Result        result;
+      int                   groupBegin;
+      int                   groupEnd;
+!     public final boolean isGrouped;
+!     public final boolean isAggregated;
+!     public HashSet       groups;
+!     public ResultGroup   currGroup;
+  
+      GroupedResult(Select select, Result.ResultMetaData meta) {
+  
+*************** class GroupedResult {
+*** 152,158 ****
+          Object[] row;
+          int      hashCode;
+  
+!         private ResultGroup(Object[] row) {
+  
+              this.row = row;
+              hashCode = 0;
+--- 152,158 ----
+          Object[] row;
+          int      hashCode;
+  
+!         public ResultGroup(Object[] row) {
+  
+              this.row = row;
+              hashCode = 0;
+*************** class GroupedResult {
+*** 189,195 ****
+              return true;
+          }
+  
+!         private boolean equals(Object o1, Object o2) {
+              return (o1 == null) ? o2 == null
+                                  : o1.equals(o2);
+          }
+--- 189,195 ----
+              return true;
+          }
+  
+!         public boolean equals(Object o1, Object o2) {
+              return (o1 == null) ? o2 == null
+                                  : o1.equals(o2);
+          }
+diff -pcr misc/hsqldb/src/org/hsqldb/HSQLClientConnection.java misc/build/hsqldb/src/org/hsqldb/HSQLClientConnection.java
+*** misc/hsqldb/src/org/hsqldb/HSQLClientConnection.java	2006-07-21 15:37:20.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/HSQLClientConnection.java	2007-02-28 12:32:48.000000000 +0100
+*************** public class HSQLClientConnection implem
+*** 56,73 ****
+  
+      static final int          BUFFER_SIZE = 0x1000;
+      final byte[]              mainBuffer  = new byte[BUFFER_SIZE];
+!     private boolean           isClosed;
+!     private Socket            socket;
+!     protected OutputStream    dataOutput;
+!     protected DataInputStream dataInput;
+!     protected RowOutputBinary rowOut;
+!     protected RowInputBinary  rowIn;
+!     private Result            resultOut;
+!     private int               sessionID;
+  
+      //
+!     private boolean isReadOnly   = false;
+!     private boolean isAutoCommit = true;
+  
+      //
+      String  host;
+--- 56,73 ----
+  
+      static final int          BUFFER_SIZE = 0x1000;
+      final byte[]              mainBuffer  = new byte[BUFFER_SIZE];
+!     public boolean           isClosed;
+!     public Socket            socket;
+!     public OutputStream    dataOutput;
+!     public DataInputStream dataInput;
+!     public RowOutputBinary rowOut;
+!     public RowInputBinary  rowIn;
+!     public Result            resultOut;
+!     public int               sessionID;
+  
+      //
+!     public boolean isReadOnly   = false;
+!     public boolean isAutoCommit = true;
+  
+      //
+      String  host;
+*************** public class HSQLClientConnection implem
+*** 113,119 ****
+       * resultOut is reused to trasmit all remote calls for session management.
+       * Here the structure is preset for sending attributes.
+       */
+!     private void initStructures() {
+  
+          rowOut    = new RowOutputBinary(mainBuffer);
+          rowIn     = new RowInputBinary(rowOut);
+--- 113,119 ----
+       * resultOut is reused to trasmit all remote calls for session management.
+       * Here the structure is preset for sending attributes.
+       */
+!     public void initStructures() {
+  
+          rowOut    = new RowOutputBinary(mainBuffer);
+          rowIn     = new RowInputBinary(rowOut);
+*************** public class HSQLClientConnection implem
+*** 122,133 ****
+          resultOut.add(new Object[7]);
+      }
+  
+!     protected void initConnection(String host, int port,
+                                    boolean isTLS) throws HsqlException {
+          openConnection(host, port, isTLS);
+      }
+  
+!     protected void openConnection(String host, int port,
+                                    boolean isTLS) throws HsqlException {
+  
+          try {
+--- 122,133 ----
+          resultOut.add(new Object[7]);
+      }
+  
+!     public void initConnection(String host, int port,
+                                    boolean isTLS) throws HsqlException {
+          openConnection(host, port, isTLS);
+      }
+  
+!     public void openConnection(String host, int port,
+                                    boolean isTLS) throws HsqlException {
+  
+          try {
+*************** public class HSQLClientConnection implem
+*** 143,149 ****
+          }
+      }
+  
+!     protected void closeConnection() {
+  
+          try {
+              if (socket != null) {
+--- 143,149 ----
+          }
+      }
+  
+!     public void closeConnection() {
+  
+          try {
+              if (socket != null) {
+*************** public class HSQLClientConnection implem
+*** 186,192 ****
+          } catch (Exception e) {}
+      }
+  
+!     private Object getAttribute(int id) throws HsqlException {
+  
+          resultOut.setResultType(ResultConstants.GETSESSIONATTR);
+  
+--- 186,192 ----
+          } catch (Exception e) {}
+      }
+  
+!     public Object getAttribute(int id) throws HsqlException {
+  
+          resultOut.setResultType(ResultConstants.GETSESSIONATTR);
+  
+*************** public class HSQLClientConnection implem
+*** 199,205 ****
+          return in.rRoot.data[id];
+      }
+  
+!     private void setAttribute(Object property, int id) throws HsqlException {
+  
+          resultOut.setResultType(ResultConstants.SETSESSIONATTR);
+          ArrayUtil.fillArray(resultOut.rRoot.data, null);
+--- 199,205 ----
+          return in.rRoot.data[id];
+      }
+  
+!     public void setAttribute(Object property, int id) throws HsqlException {
+  
+          resultOut.setResultType(ResultConstants.SETSESSIONATTR);
+          ArrayUtil.fillArray(resultOut.rRoot.data, null);
+*************** public class HSQLClientConnection implem
+*** 335,345 ****
+          databaseID = resultIn.databaseID;
+      }
+  
+!     protected void write(Result r) throws IOException, HsqlException {
+          Result.write(r, rowOut, dataOutput);
+      }
+  
+!     protected Result read() throws IOException, HsqlException {
+  
+          Result r = Result.read(rowIn, dataInput);
+  
+--- 335,345 ----
+          databaseID = resultIn.databaseID;
+      }
+  
+!     public void write(Result r) throws IOException, HsqlException {
+          Result.write(r, rowOut, dataOutput);
+      }
+  
+!     public Result read() throws IOException, HsqlException {
+  
+          Result r = Result.read(rowIn, dataInput);
+  
+diff -pcr misc/hsqldb/src/org/hsqldb/HsqlDateTime.java misc/build/hsqldb/src/org/hsqldb/HsqlDateTime.java
+*** misc/hsqldb/src/org/hsqldb/HsqlDateTime.java	2006-07-10 13:03:14.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/HsqlDateTime.java	2007-02-28 12:32:48.000000000 +0100
+*************** public class HsqlDateTime {
+*** 74,86 ****
+       * A reusable static value for today's date. Should only be accessed
+       * by getToday()
+       */
+!     private static Calendar today          = new GregorianCalendar();
+!     private static Calendar tempCal        = new GregorianCalendar();
+!     private static Calendar tempCalDefault = new GregorianCalendar();
+!     private static Calendar tempCalGMT =
+          new GregorianCalendar(TimeZone.getTimeZone("GMT"));
+!     private static Date tempDate = new Date(0);
+!     private static Date currentDate;
+  
+      static {
+          resetToday(System.currentTimeMillis());
+--- 74,86 ----
+       * A reusable static value for today's date. Should only be accessed
+       * by getToday()
+       */
+!     public static Calendar today          = new GregorianCalendar();
+!     public static Calendar tempCal        = new GregorianCalendar();
+!     public static Calendar tempCalDefault = new GregorianCalendar();
+!     public static Calendar tempCalGMT =
+          new GregorianCalendar(TimeZone.getTimeZone("GMT"));
+!     public static Date tempDate = new Date(0);
+!     public static Date currentDate;
+  
+      static {
+          resetToday(System.currentTimeMillis());
+*************** public class HsqlDateTime {
+*** 231,240 ****
+          return new Timestamp(millis);
+      }
+  
+!     private static final String sdftPattern     = "HH:mm:ss";
+!     private static final String sdfdPattern     = "yyyy-MM-dd";
+!     private static final String sdftsPattern    = "yyyy-MM-dd HH:mm:ss.";
+!     private static final String sdftsSysPattern = "yyyy-MM-dd HH:mm:ss.SSS";
+      static SimpleDateFormat     sdfd = new SimpleDateFormat(sdfdPattern);
+      static SimpleDateFormat     sdft = new SimpleDateFormat(sdftPattern);
+      static SimpleDateFormat     sdfts = new SimpleDateFormat(sdftsPattern);
+--- 231,240 ----
+          return new Timestamp(millis);
+      }
+  
+!     public static final String sdftPattern     = "HH:mm:ss";
+!     public static final String sdfdPattern     = "yyyy-MM-dd";
+!     public static final String sdftsPattern    = "yyyy-MM-dd HH:mm:ss.";
+!     public static final String sdftsSysPattern = "yyyy-MM-dd HH:mm:ss.SSS";
+      static SimpleDateFormat     sdfd = new SimpleDateFormat(sdfdPattern);
+      static SimpleDateFormat     sdft = new SimpleDateFormat(sdftPattern);
+      static SimpleDateFormat     sdfts = new SimpleDateFormat(sdftsPattern);
+*************** public class HsqlDateTime {
+*** 270,276 ****
+          }
+      }
+  
+!     private static java.util.Date sysDate = new java.util.Date();
+  
+      public static String getSytemTimeString() {
+  
+--- 270,276 ----
+          }
+      }
+  
+!     public static java.util.Date sysDate = new java.util.Date();
+  
+      public static String getSytemTimeString() {
+  
+*************** public class HsqlDateTime {
+*** 342,348 ****
+      /**
+       * resets the static reusable value today
+       */
+!     private static synchronized void resetToday(long millis) {
+  
+  //#ifdef JDBC3
+          // Use method directly
+--- 342,348 ----
+      /**
+       * resets the static reusable value today
+       */
+!     public static synchronized void resetToday(long millis) {
+  
+  //#ifdef JDBC3
+          // Use method directly
+*************** public class HsqlDateTime {
+*** 363,374 ****
+  
+      /**
+       * Sets the time in the given Calendar using the given milliseconds value; wrapper method to
+!      * allow use of more efficient JDK1.4 method on JDK1.4 (was protected in earlier versions).
+       *
+       * @param       cal                             the Calendar
+       * @param       millis                  the time value in milliseconds
+       */
+!     private static void setTimeInMillis(Calendar cal, long millis) {
+  
+  //#ifdef JDBC3
+          // Use method directly
+--- 363,374 ----
+  
+      /**
+       * Sets the time in the given Calendar using the given milliseconds value; wrapper method to
+!      * allow use of more efficient JDK1.4 method on JDK1.4 (was public in earlier versions).
+       *
+       * @param       cal                             the Calendar
+       * @param       millis                  the time value in milliseconds
+       */
+!     public static void setTimeInMillis(Calendar cal, long millis) {
+  
+  //#ifdef JDBC3
+          // Use method directly
+*************** public class HsqlDateTime {
+*** 408,414 ****
+  
+      /**
+       * Gets the time from the given Calendar as a milliseconds value; wrapper method to
+!      * allow use of more efficient JDK1.4 method on JDK1.4 (was protected in earlier versions).
+       *
+       * @param       cal                             the Calendar
+       * @return      the time value in milliseconds
+--- 408,414 ----
+  
+      /**
+       * Gets the time from the given Calendar as a milliseconds value; wrapper method to
+!      * allow use of more efficient JDK1.4 method on JDK1.4 (was public in earlier versions).
+       *
+       * @param       cal                             the Calendar
+       * @return      the time value in milliseconds
+*************** public class HsqlDateTime {
+*** 519,525 ****
+          }
+      }
+  
+!     private static final char[][] dateTokens     = {
+          {
+              'R', 'R', 'R', 'R'
+          }, {
+--- 519,525 ----
+          }
+      }
+  
+!     public static final char[][] dateTokens     = {
+          {
+              'R', 'R', 'R', 'R'
+          }, {
+*************** public class HsqlDateTime {
+*** 568,574 ****
+              'P', '.', 'M', '.'
+          }
+      };
+!     private static final String[] javaDateTokens = {
+          "yyyy", "yyyy", "yyyy", "yy", "yy", "G", "G", "G", "G", "MMM",
+          "MMMMM", "E", "w", "dd", "D", "k", "K", "K", "mm", "ss", "aaa", "aaa",
+          "aaa", "aaa"
+--- 568,574 ----
+              'P', '.', 'M', '.'
+          }
+      };
+!     public static final String[] javaDateTokens = {
+          "yyyy", "yyyy", "yyyy", "yy", "yy", "G", "G", "G", "G", "MMM",
+          "MMMMM", "E", "w", "dd", "D", "k", "K", "K", "mm", "ss", "aaa", "aaa",
+          "aaa", "aaa"
+*************** public class HsqlDateTime {
+*** 621,630 ****
+       */
+      static class Tokenizer {
+  
+!         private int     last;
+!         private int     offset;
+!         private long    state;
+!         private boolean consumed;
+  
+          public Tokenizer() {
+              reset();
+--- 621,630 ----
+       */
+      static class Tokenizer {
+  
+!         public int     last;
+!         public int     offset;
+!         public long    state;
+!         public boolean consumed;
+  
+          public Tokenizer() {
+              reset();
+*************** public class HsqlDateTime {
+*** 670,676 ****
+           * @param bit
+           * @return
+           */
+!         private boolean isZeroBit(int bit) {
+              return (state & (1L << bit)) == 0;
+          }
+  
+--- 670,676 ----
+           * @param bit
+           * @return
+           */
+!         public boolean isZeroBit(int bit) {
+              return (state & (1L << bit)) == 0;
+          }
+  
+*************** public class HsqlDateTime {
+*** 678,684 ****
+           * Sets the specified bit.
+           * @param bit
+           */
+!         private void setBit(int bit) {
+              state |= (1L << bit);
+          }
+  
+--- 678,684 ----
+           * Sets the specified bit.
+           * @param bit
+           */
+!         public void setBit(int bit) {
+              state |= (1L << bit);
+          }
+  
+diff -pcr misc/hsqldb/src/org/hsqldb/HsqlException.java misc/build/hsqldb/src/org/hsqldb/HsqlException.java
+*** misc/hsqldb/src/org/hsqldb/HsqlException.java	2006-07-21 15:37:35.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/HsqlException.java	2007-02-28 12:32:48.000000000 +0100
+*************** package org.hsqldb;
+*** 42,50 ****
+   */
+  public class HsqlException extends Exception {
+  
+!     private String message;
+!     private String state;
+!     private int    code;
+  
+      /**
+       * @param message String
+--- 42,50 ----
+   */
+  public class HsqlException extends Exception {
+  
+!     public String message;
+!     public String state;
+!     public int    code;
+  
+      /**
+       * @param message String
+diff -pcr misc/hsqldb/src/org/hsqldb/HsqlNameManager.java misc/build/hsqldb/src/org/hsqldb/HsqlNameManager.java
+*** misc/hsqldb/src/org/hsqldb/HsqlNameManager.java	2006-01-07 17:01:25.000000000 +0100
+--- misc/build/hsqldb/src/org/hsqldb/HsqlNameManager.java	2007-02-28 12:32:48.000000000 +0100
+*************** import org.hsqldb.lib.StringConverter;
+*** 61,74 ****
+   */
+  public class HsqlNameManager {
+  
+!     private static HsqlNameManager staticManager = new HsqlNameManager();
+  
+      static {
+          staticManager.serialNumber = Integer.MIN_VALUE;
+      }
+  
+!     private int serialNumber = 1;    // 0 is reserved in lookups
+!     private int sysNumber    = 0;
+  
+      static HsqlName newHsqlSystemObjectName(String name) {
+          return new HsqlName(staticManager, name);
+--- 61,74 ----
+   */
+  public class HsqlNameManager {
+  
+!     public static HsqlNameManager staticManager = new HsqlNameManager();
+  
+      static {
+          staticManager.serialNumber = Integer.MIN_VALUE;
+      }
+  
+!     public int serialNumber = 1;    // 0 is reserved in lookups
+!     public int sysNumber    = 0;
+  
+      static HsqlName newHsqlSystemObjectName(String name) {
+          return new HsqlName(staticManager, name);
+*************** public class HsqlNameManager {
+*** 133,153 ****
+          boolean           isNameQuoted;
+          public String     statementName;
+          public HsqlName   schema;
+!         private final int hashCode;
+  
+!         private HsqlName(HsqlNameManager man) {
+              manager  = man;
+              hashCode = manager.serialNumber++;
+          }
+  
+!         private HsqlName(HsqlNameManager man, String name, boolean isquoted) {
+  
+              this(man);
+  
+              rename(name, isquoted);
+          }
+  
+!         private HsqlName(HsqlNameManager man, String prefix, String name,
+                           boolean isquoted) {
+  
+              this(man);
+--- 133,153 ----
+          boolean           isNameQuoted;
+          public String     statementName;
+          public HsqlName   schema;
+!         public final int hashCode;
+  
+!         public HsqlName(HsqlNameManager man) {
+              manager  = man;
+              hashCode = manager.serialNumber++;
+          }
+  
+!         public HsqlName(HsqlNameManager man, String name, boolean isquoted) {
+  
+              this(man);
+  
+              rename(name, isquoted);
+          }
+  
+!         public HsqlName(HsqlNameManager man, String prefix, String name,
+                           boolean isquoted) {
+  
+              this(man);
+*************** public class HsqlNameManager {
+*** 155,161 ****
+              rename(prefix, name, isquoted);
+          }
+  
+!         private HsqlName(HsqlNameManager man, String name) {
+  
+              this(man);
+  
+--- 155,161 ----
+              rename(prefix, name, isquoted);
+          }
+  
+!         public HsqlName(HsqlNameManager man, String name) {
+  
+              this(man);
+  
+diff -pcr misc/hsqldb/src/org/hsqldb/HsqlServerFactory.java misc/build/hsqldb/src/org/hsqldb/HsqlServerFactory.java
+*** misc/hsqldb/src/org/hsqldb/HsqlServerFactory.java	2005-10-23 20:26:20.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/HsqlServerFactory.java	2007-02-28 12:32:48.000000000 +0100
+*************** import org.hsqldb.persist.HsqlProperties
+*** 49,55 ****
+   */
+  public class HsqlServerFactory {
+  
+!     private HsqlServerFactory() {}
+  
+      public static HsqlSocketRequestHandler createHsqlServer(String dbFilePath,
+              boolean debugMessages, boolean silentMode) throws SQLException {
+--- 49,55 ----
+   */
+  public class HsqlServerFactory {
+  
+!     public HsqlServerFactory() {}
+  
+      public static HsqlSocketRequestHandler createHsqlServer(String dbFilePath,
+              boolean debugMessages, boolean silentMode) throws SQLException {
+diff -pcr misc/hsqldb/src/org/hsqldb/HsqlSocketFactory.java misc/build/hsqldb/src/org/hsqldb/HsqlSocketFactory.java
+*** misc/hsqldb/src/org/hsqldb/HsqlSocketFactory.java	2005-10-23 20:26:20.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/HsqlSocketFactory.java	2007-02-28 12:32:48.000000000 +0100
+*************** import java.net.Socket;
+*** 48,55 ****
+  public class HsqlSocketFactory {
+  
+  // ----------------------------- static members ---------------------------------
+!     private static HsqlSocketFactory plainImpl;
+!     private static HsqlSocketFactory sslImpl;
+  
+  // ------------------------------ constructors ---------------------------------
+  
+--- 48,55 ----
+  public class HsqlSocketFactory {
+  
+  // ----------------------------- static members ---------------------------------
+!     public static HsqlSocketFactory plainImpl;
+!     public static HsqlSocketFactory sslImpl;
+  
+  // ------------------------------ constructors ---------------------------------
+  
+*************** public class HsqlSocketFactory {
+*** 57,63 ****
+       * External construction disabled.  New factory instances are retreived
+       * through the newHsqlSocketFactory method instead.
+       */
+!     protected HsqlSocketFactory() throws Exception {}
+  
+  // ------------------------- factory builder method ----------------------------
+  
+--- 57,63 ----
+       * External construction disabled.  New factory instances are retreived
+       * through the newHsqlSocketFactory method instead.
+       */
+!     public HsqlSocketFactory() throws Exception {}
+  
+  // ------------------------- factory builder method ----------------------------
+  
+*************** public class HsqlSocketFactory {
+*** 133,139 ****
+      }
+  
+  // ------------------------ static utility methods -----------------------------
+!     private static HsqlSocketFactory getPlainImpl() throws Exception {
+  
+          synchronized (HsqlSocketFactory.class) {
+              if (plainImpl == null) {
+--- 133,139 ----
+      }
+  
+  // ------------------------ static utility methods -----------------------------
+!     public static HsqlSocketFactory getPlainImpl() throws Exception {
+  
+          synchronized (HsqlSocketFactory.class) {
+              if (plainImpl == null) {
+*************** public class HsqlSocketFactory {
+*** 144,150 ****
+          return plainImpl;
+      }
+  
+!     private static HsqlSocketFactory getSSLImpl() throws Exception {
+  
+          synchronized (HsqlSocketFactory.class) {
+              if (sslImpl == null) {
+--- 144,150 ----
+          return plainImpl;
+      }
+  
+!     public static HsqlSocketFactory getSSLImpl() throws Exception {
+  
+          synchronized (HsqlSocketFactory.class) {
+              if (sslImpl == null) {
+*************** public class HsqlSocketFactory {
+*** 170,176 ****
+       * @throws Exception if a new secure socket factory cannot
+       *      be constructed
+       */
+!     private static HsqlSocketFactory newFactory(String implClass)
+      throws Exception {
+  
+          Class       clazz;
+--- 170,176 ----
+       * @throws Exception if a new secure socket factory cannot
+       *      be constructed
+       */
+!     public static HsqlSocketFactory newFactory(String implClass)
+      throws Exception {
+  
+          Class       clazz;
+*************** public class HsqlSocketFactory {
+*** 182,188 ****
+          clazz    = Class.forName(implClass);
+          ctorParm = new Class[0];
+  
+!         // protected constructor
+          ctor    = clazz.getDeclaredConstructor(ctorParm);
+          ctorArg = new Object[0];
+  
+--- 182,188 ----
+          clazz    = Class.forName(implClass);
+          ctorParm = new Class[0];
+  
+!         // public constructor
+          ctor    = clazz.getDeclaredConstructor(ctorParm);
+          ctorArg = new Object[0];
+  
+diff -pcr misc/hsqldb/src/org/hsqldb/HsqlSocketFactorySecure.java misc/build/hsqldb/src/org/hsqldb/HsqlSocketFactorySecure.java
+*** misc/hsqldb/src/org/hsqldb/HsqlSocketFactorySecure.java	2005-10-23 20:26:20.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/HsqlSocketFactorySecure.java	2007-02-28 12:32:48.000000000 +0100
+*************** implements HandshakeCompletedListener {
+*** 65,86 ****
+  // --------------------------------- members -----------------------------------
+  
+      /** The underlying socket factory implementation. */
+!     protected Object socketFactory;
+  
+      /** The underlying server socket factory implementation. */
+!     protected Object serverSocketFactory;
+  
+      /**
+       * Monitor object to guard against conncurrent modification
+       * of the underlying socket factory implementation member.
+       */
+!     protected final Object socket_factory_mutex = new Object();
+  
+      /**
+       * Monitor object to guard against concurrent modification of
+       * the underlying server socket factory implementation member.
+       */
+!     protected final Object server_socket_factory_mutex = new Object();
+  
+  // ------------------------------ constructors ---------------------------------
+  
+--- 65,86 ----
+  // --------------------------------- members -----------------------------------
+  
+      /** The underlying socket factory implementation. */
+!     public Object socketFactory;
+  
+      /** The underlying server socket factory implementation. */
+!     public Object serverSocketFactory;
+  
+      /**
+       * Monitor object to guard against conncurrent modification
+       * of the underlying socket factory implementation member.
+       */
+!     public final Object socket_factory_mutex = new Object();
+  
+      /**
+       * Monitor object to guard against concurrent modification of
+       * the underlying server socket factory implementation member.
+       */
+!     public final Object server_socket_factory_mutex = new Object();
+  
+  // ------------------------------ constructors ---------------------------------
+  
+*************** implements HandshakeCompletedListener {
+*** 88,94 ****
+       * External construction disabled.  New factory instances are retreived
+       * through the newHsqlSocketFactory method instead.
+       */
+!     protected HsqlSocketFactorySecure() throws Exception {
+  
+          super();
+  
+--- 88,94 ----
+       * External construction disabled.  New factory instances are retreived
+       * through the newHsqlSocketFactory method instead.
+       */
+!     public HsqlSocketFactorySecure() throws Exception {
+  
+          super();
+  
+*************** implements HandshakeCompletedListener {
+*** 174,180 ****
+          return ss;
+      }
+  
+!     private static void dump(String title, String[] as) {
+  
+          Trace.printSystemOut(title);
+          Trace.printSystemOut("----------------------------");
+--- 174,180 ----
+          return ss;
+      }
+  
+!     public static void dump(String title, String[] as) {
+  
+          Trace.printSystemOut(title);
+          Trace.printSystemOut("----------------------------");
+*************** implements HandshakeCompletedListener {
+*** 263,269 ****
+       *      underlying factory
+       * @return the underlying javax.net.ssl.SSLServerSocketFactory
+       */
+!     protected SSLServerSocketFactory getServerSocketFactoryImpl()
+      throws Exception {
+  
+          Object factory;
+--- 263,269 ----
+       *      underlying factory
+       * @return the underlying javax.net.ssl.SSLServerSocketFactory
+       */
+!     public SSLServerSocketFactory getServerSocketFactoryImpl()
+      throws Exception {
+  
+          Object factory;
+*************** implements HandshakeCompletedListener {
+*** 287,293 ****
+       *      underlying factory
+       * @return the underlying javax.net.ssl.SSLSocketFactory
+       */
+!     protected SSLSocketFactory getSocketFactoryImpl() throws Exception {
+  
+          Object factory;
+  
+--- 287,293 ----
+       *      underlying factory
+       * @return the underlying javax.net.ssl.SSLSocketFactory
+       */
+!     public SSLSocketFactory getSocketFactoryImpl() throws Exception {
+  
+          Object factory;
+  
+*************** implements HandshakeCompletedListener {
+*** 313,319 ****
+       * @param session SSLSession used on the connection to host
+       * @throws Exception if the certificate chain cannot be verified
+       */
+!     protected void verify(String host, SSLSession session) throws Exception {
+  
+          X509Certificate[] chain;
+          X509Certificate   certificate;
+--- 313,319 ----
+       * @param session SSLSession used on the connection to host
+       * @throws Exception if the certificate chain cannot be verified
+       */
+!     public void verify(String host, SSLSession session) throws Exception {
+  
+          X509Certificate[] chain;
+          X509Certificate   certificate;
+diff -pcr misc/hsqldb/src/org/hsqldb/HTTPClientConnection.java misc/build/hsqldb/src/org/hsqldb/HTTPClientConnection.java
+*** misc/hsqldb/src/org/hsqldb/HTTPClientConnection.java	2005-10-23 20:26:20.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/HTTPClientConnection.java	2007-02-28 12:32:48.000000000 +0100
+*************** public class HTTPClientConnection extend
+*** 53,59 ****
+          super(host, port, path, database, isTLS, user, password);
+      }
+  
+!     protected void initConnection(String host, int port,
+                                    boolean isTLS) throws HsqlException {}
+  
+      public synchronized Result execute(Result r) throws HsqlException {
+--- 53,59 ----
+          super(host, port, path, database, isTLS, user, password);
+      }
+  
+!     public void initConnection(String host, int port,
+                                    boolean isTLS) throws HsqlException {}
+  
+      public synchronized Result execute(Result r) throws HsqlException {
+*************** public class HTTPClientConnection extend
+*** 67,73 ****
+          return result;
+      }
+  
+!     protected void write(Result r) throws IOException, HsqlException {
+  
+          rowOut.reset();
+          r.write(rowOut);
+--- 67,73 ----
+          return result;
+      }
+  
+!     public void write(Result r) throws IOException, HsqlException {
+  
+          rowOut.reset();
+          r.write(rowOut);
+*************** public class HTTPClientConnection extend
+*** 84,90 ****
+          dataOutput.flush();
+      }
+  
+!     protected Result read() throws IOException, HsqlException {
+  
+          // fredt - for WebServer 4 lines should be skipped
+          // for Servlet, number of lines depends on Servlet container
+--- 84,90 ----
+          dataOutput.flush();
+      }
+  
+!     public Result read() throws IOException, HsqlException {
+  
+          // fredt - for WebServer 4 lines should be skipped
+          // for Servlet, number of lines depends on Servlet container
+diff -pcr misc/hsqldb/src/org/hsqldb/Index.java misc/build/hsqldb/src/org/hsqldb/Index.java
+*** misc/hsqldb/src/org/hsqldb/Index.java	2007-02-28 12:31:52.000000000 +0100
+--- misc/build/hsqldb/src/org/hsqldb/Index.java	2007-02-28 12:32:48.000000000 +0100
+*************** public class Index {
+*** 98,116 ****
+      static final int POINTER_INDEX = 2;
+  
+      // fields
+!     private final HsqlName indexName;
+      final boolean[]        colCheck;
+!     private final int[]    colIndex;
+!     private final int[]    colTypes;
+      final int[]            pkCols;
+      final int[]            pkTypes;
+!     private final boolean  isUnique;    // DDL uniqueness
+!     private final boolean  useRowId;
+      final boolean          isConstraint;
+      final boolean          isForward;
+      final boolean          isTemp;
+!     private Node           root;
+!     private int            depth;
+      final Collation        collation;
+      static IndexRowIterator emptyIterator = new IndexRowIterator(null, null,
+          null);
+--- 98,116 ----
+      static final int POINTER_INDEX = 2;
+  
+      // fields
+!     public final HsqlName indexName;
+      final boolean[]        colCheck;
+!     public final int[]    colIndex;
+!     public final int[]    colTypes;
+      final int[]            pkCols;
+      final int[]            pkTypes;
+!     public final boolean  isUnique;    // DDL uniqueness
+!     public final boolean  useRowId;
+      final boolean          isConstraint;
+      final boolean          isForward;
+      final boolean          isTemp;
+!     public Node           root;
+!     public int            depth;
+      final Collation        collation;
+      static IndexRowIterator emptyIterator = new IndexRowIterator(null, null,
+          null);
+*************** public class Index {
+*** 280,286 ****
+                                : root.getKey();
+      }
+  
+!     private Node getRoot(Session session) {
+  
+          if (isTemp && session != null) {
+              return session.getIndexRoot(indexName, onCommitPreserve);
+--- 280,286 ----
+                                : root.getKey();
+      }
+  
+!     public Node getRoot(Session session) {
+  
+          if (isTemp && session != null) {
+              return session.getIndexRoot(indexName, onCommitPreserve);
+*************** public class Index {
+*** 342,348 ****
+      /**
+       * Balances part of the tree after an alteration to the index.
+       */
+!     private void balance(Session session, Node x,
+                           boolean isleft) throws HsqlException {
+  
+          while (true) {
+--- 342,348 ----
+      /**
+       * Balances part of the tree after an alteration to the index.
+       */
+!     public void balance(Session session, Node x,
+                           boolean isleft) throws HsqlException {
+  
+          while (true) {
+*************** public class Index {
+*** 691,697 ****
+       * @return matching node or null
+       * @throws HsqlException
+       */
+!     private Node findNotNull(Session session, Object[] rowdata,
+                               int[] rowColMap,
+                               boolean first) throws HsqlException {
+  
+--- 691,697 ----
+       * @return matching node or null
+       * @throws HsqlException
+       */
+!     public Node findNotNull(Session session, Object[] rowdata,
+                               int[] rowColMap,
+                               boolean first) throws HsqlException {
+  
+*************** public class Index {
+*** 1075,1081 ****
+       *
+       * @throws HsqlException
+       */
+!     private Node child(Node x, boolean isleft) throws HsqlException {
+          return isleft ? x.getLeft()
+                        : x.getRight();
+      }
+--- 1075,1081 ----
+       *
+       * @throws HsqlException
+       */
+!     public Node child(Node x, boolean isleft) throws HsqlException {
+          return isleft ? x.getLeft()
+                        : x.getRight();
+      }
+*************** public class Index {
+*** 1088,1094 ****
+       *
+       * @throws HsqlException
+       */
+!     private void replace(Session session, Node x,
+                           Node n) throws HsqlException {
+  
+          if (x.isRoot()) {
+--- 1088,1094 ----
+       *
+       * @throws HsqlException
+       */
+!     public void replace(Session session, Node x,
+                           Node n) throws HsqlException {
+  
+          if (x.isRoot()) {
+*************** public class Index {
+*** 1113,1119 ****
+       *
+       * @throws HsqlException
+       */
+!     private void set(Node x, boolean isleft, Node n) throws HsqlException {
+  
+          x = x.getUpdatedNode();
+  
+--- 1113,1119 ----
+       *
+       * @throws HsqlException
+       */
+!     public void set(Node x, boolean isleft, Node n) throws HsqlException {
+  
+          x = x.getUpdatedNode();
+  
+*************** public class Index {
+*** 1139,1145 ****
+       *
+       * @throws HsqlException
+       */
+!     private Node search(Session session, Row row) throws HsqlException {
+  
+          Object[] d = row.getData();
+          Node     x = getRoot(session);
+--- 1139,1145 ----
+       *
+       * @throws HsqlException
+       */
+!     public Node search(Session session, Row row) throws HsqlException {
+  
+          Object[] d = row.getData();
+          Node     x = getRoot(session);
+*************** public class Index {
+*** 1233,1239 ****
+       *
+       * @throws HsqlException
+       */
+!     private int compareRowForInsert(Session session, Row newRow,
+                                      Row existingRow) throws HsqlException {
+  
+          Object[] a       = newRow.getData();
+--- 1233,1239 ----
+       *
+       * @throws HsqlException
+       */
+!     public int compareRowForInsert(Session session, Row newRow,
+                                      Row existingRow) throws HsqlException {
+  
+          Object[] a       = newRow.getData();
+*************** public class Index {
+*** 1315,1321 ****
+          }
+      }
+  
+!     private IndexRowIterator getIterator(Session session, Node x) {
+  
+          if (x == null) {
+              return emptyIterator;
+--- 1315,1321 ----
+          }
+      }
+  
+!     public IndexRowIterator getIterator(Session session, Node x) {
+  
+          if (x == null) {
+              return emptyIterator;
+*************** public class Index {
+*** 1331,1343 ****
+          Session                    session;
+          Index                      index;
+          Node                       nextnode;
+!         protected IndexRowIterator last;
+!         protected IndexRowIterator next;
+  
+          /**
+           * When session == null, rows from all sessions are returned
+           */
+!         private IndexRowIterator(Session session, Index index, Node node) {
+  
+              if (index == null) {
+                  return;
+--- 1331,1343 ----
+          Session                    session;
+          Index                      index;
+          Node                       nextnode;
+!         public IndexRowIterator last;
+!         public IndexRowIterator next;
+  
+          /**
+           * When session == null, rows from all sessions are returned
+           */
+!         public IndexRowIterator(Session session, Index index, Node node) {
+  
+              if (index == null) {
+                  return;
+diff -pcr misc/hsqldb/src/org/hsqldb/jdbc/jdbcCallableStatement.java misc/build/hsqldb/src/org/hsqldb/jdbc/jdbcCallableStatement.java
+*** misc/hsqldb/src/org/hsqldb/jdbc/jdbcCallableStatement.java	2006-01-29 13:58:58.000000000 +0100
+--- misc/build/hsqldb/src/org/hsqldb/jdbc/jdbcCallableStatement.java	2007-02-28 12:32:48.000000000 +0100
+*************** public class jdbcCallableStatement exten
+*** 296,306 ****
+  implements CallableStatement {
+  
+      /** parameter name => parameter index */
+!     private IntValueHashMap parameterNameMap;
+  
+      /** parameter index => registered OUT type */
+  
+!     //    private IntKeyIntValueHashMap outRegistrationMap;
+  
+      /**
+       * Constructs a new jdbcCallableStatement with the specified connection and
+--- 296,306 ----
+  implements CallableStatement {
+  
+      /** parameter name => parameter index */
+!     public IntValueHashMap parameterNameMap;
+  
+      /** parameter index => registered OUT type */
+  
+!     //    public IntKeyIntValueHashMap outRegistrationMap;
+  
+      /**
+       * Constructs a new jdbcCallableStatement with the specified connection and
+*************** implements CallableStatement {
+*** 385,391 ****
+       * @param i the one-based column index to check
+       * @throws SQLException if there is no such OUT or IN OUT column
+       */
+!     private void checkGetParameterIndex(int i) throws SQLException {
+  
+          checkClosed();
+  
+--- 385,391 ----
+       * @param i the one-based column index to check
+       * @throws SQLException if there is no such OUT or IN OUT column
+       */
+!     public void checkGetParameterIndex(int i) throws SQLException {
+  
+          checkClosed();
+  
+*************** implements CallableStatement {
+*** 421,427 ****
+       * @throws SQLException if not registered
+       */
+      /*
+!     private void checkIsRegisteredParameterIndex(int parameterIndex)
+      throws SQLException {
+  
+          int    type;
+--- 421,427 ----
+       * @throws SQLException if not registered
+       */
+      /*
+!     public void checkIsRegisteredParameterIndex(int parameterIndex)
+      throws SQLException {
+  
+          int    type;
+diff -pcr misc/hsqldb/src/org/hsqldb/jdbc/jdbcColumnMetaData.java misc/build/hsqldb/src/org/hsqldb/jdbc/jdbcColumnMetaData.java
+*** misc/hsqldb/src/org/hsqldb/jdbc/jdbcColumnMetaData.java	2005-10-23 20:26:21.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/jdbc/jdbcColumnMetaData.java	2007-02-28 12:32:48.000000000 +0100
+*************** public final class jdbcColumnMetaData {
+*** 126,132 ****
+       *
+       * @return a Sring representation of this object
+       */
+!     private String toStringImpl() throws Exception {
+  
+          StringBuffer sb;
+          Field[]      fields;
+--- 126,132 ----
+       *
+       * @return a Sring representation of this object
+       */
+!     public String toStringImpl() throws Exception {
+  
+          StringBuffer sb;
+          Field[]      fields;
+diff -pcr misc/hsqldb/src/org/hsqldb/jdbc/jdbcConnection.java misc/build/hsqldb/src/org/hsqldb/jdbc/jdbcConnection.java
+*** misc/hsqldb/src/org/hsqldb/jdbc/jdbcConnection.java	2006-07-08 01:09:07.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/jdbc/jdbcConnection.java	2007-02-28 12:32:48.000000000 +0100
+*************** public class jdbcConnection implements C
+*** 422,428 ****
+      boolean isInternal;
+  
+      /** Is this connection to a network server instance. */
+!     protected boolean isNetConn;
+  
+      /**
+       * Is this connection closed?
+--- 422,428 ----
+      boolean isInternal;
+  
+      /** Is this connection to a network server instance. */
+!     public boolean isNetConn;
+  
+      /**
+       * Is this connection closed?
+*************** public class jdbcConnection implements C
+*** 430,439 ****
+      boolean isClosed;
+  
+      /** The first warning in the chain. Null if there are no warnings. */
+!     private SQLWarning rootWarning;
+  
+      /** Synchronizes concurrent modification of the warning chain */
+!     private Object rootWarning_mutex = new Object();
+  
+      /**
+       * The set of open Statement objects returned by this Connection from
+--- 430,439 ----
+      boolean isClosed;
+  
+      /** The first warning in the chain. Null if there are no warnings. */
+!     public SQLWarning rootWarning;
+  
+      /** Synchronizes concurrent modification of the warning chain */
+!     public Object rootWarning_mutex = new Object();
+  
+      /**
+       * The set of open Statement objects returned by this Connection from
+*************** public class jdbcConnection implements C
+*** 441,447 ****
+       * used solely for closing the statements when this Connection is closed.
+       */
+      /*
+!     private org.hsqldb.lib.HashSet statementSet =
+          new org.hsqldb.lib.HashSet();
+       */
+  
+--- 441,447 ----
+       * used solely for closing the statements when this Connection is closed.
+       */
+      /*
+!     public org.hsqldb.lib.HashSet statementSet =
+          new org.hsqldb.lib.HashSet();
+       */
+  
+*************** public class jdbcConnection implements C
+*** 2448,2454 ****
+       *  The default implementation simply attempts to silently {@link
+       *  #close() close()} this <code>Connection</code>
+       */
+!     protected void finalize() {
+  
+          try {
+              close();
+--- 2448,2454 ----
+       *  The default implementation simply attempts to silently {@link
+       *  #close() close()} this <code>Connection</code>
+       */
+!     public void finalize() {
+  
+          try {
+              close();
+*************** public class jdbcConnection implements C
+*** 2654,2660 ****
+      /**
+       * is called from within nativeSQL when the start of an JDBC escape sequence is encountered
+       */
+!     private int onStartEscapeSequence(String sql, StringBuffer sb,
+                                        int i) throws SQLException {
+  
+          sb.setCharAt(i++, ' ');
+--- 2654,2660 ----
+      /**
+       * is called from within nativeSQL when the start of an JDBC escape sequence is encountered
+       */
+!     public int onStartEscapeSequence(String sql, StringBuffer sb,
+                                        int i) throws SQLException {
+  
+          sb.setCharAt(i++, ' ');
+diff -pcr misc/hsqldb/src/org/hsqldb/jdbc/jdbcDatabaseMetaData.java misc/build/hsqldb/src/org/hsqldb/jdbc/jdbcDatabaseMetaData.java
+*** misc/hsqldb/src/org/hsqldb/jdbc/jdbcDatabaseMetaData.java	2006-01-29 14:07:47.000000000 +0100
+--- misc/build/hsqldb/src/org/hsqldb/jdbc/jdbcDatabaseMetaData.java	2007-02-28 12:32:48.000000000 +0100
+*************** public class jdbcDatabaseMetaData implem
+*** 282,300 ****
+      static final Integer INT_COLUMNS_NO_NULLS = new Integer(columnNoNulls);
+  
+      // -----------------------------------------------------------------------
+!     // private attributes
+      // -----------------------------------------------------------------------
+  
+      /**
+       * The connection this object uses to retrieve database instance-specific
+       * metadata.
+       */
+!     private jdbcConnection connection;
+  
+      /**
+       * Connection property for schema reporting.
+       */
+!     private boolean useSchemaDefault;
+  
+      /**
+       * A CSV list representing the SQL IN list to use when generating
+--- 282,300 ----
+      static final Integer INT_COLUMNS_NO_NULLS = new Integer(columnNoNulls);
+  
+      // -----------------------------------------------------------------------
+!     // public attributes
+      // -----------------------------------------------------------------------
+  
+      /**
+       * The connection this object uses to retrieve database instance-specific
+       * metadata.
+       */
+!     public jdbcConnection connection;
+  
+      /**
+       * Connection property for schema reporting.
+       */
+!     public boolean useSchemaDefault;
+  
+      /**
+       * A CSV list representing the SQL IN list to use when generating
+*************** public class jdbcDatabaseMetaData implem
+*** 302,308 ****
+       * <code>scope</code> argument is <code>bestRowSession</code>.
+       * @since HSQLDB 1.7.2
+       */
+!     private static final String BRI_SESSION_SCOPE_IN_LIST = "("
+          + bestRowSession + ")";
+  
+      /**
+--- 302,308 ----
+       * <code>scope</code> argument is <code>bestRowSession</code>.
+       * @since HSQLDB 1.7.2
+       */
+!     public static final String BRI_SESSION_SCOPE_IN_LIST = "("
+          + bestRowSession + ")";
+  
+      /**
+*************** public class jdbcDatabaseMetaData implem
+*** 311,317 ****
+       * <code>scope</code> argument is <code>bestRowTemporary</code>.
+       * @since HSQLDB 1.7.2
+       */
+!     private static final String BRI_TEMPORARY_SCOPE_IN_LIST = "("
+          + bestRowTemporary + "," + bestRowTransaction + "," + bestRowSession
+          + ")";
+  
+--- 311,317 ----
+       * <code>scope</code> argument is <code>bestRowTemporary</code>.
+       * @since HSQLDB 1.7.2
+       */
+!     public static final String BRI_TEMPORARY_SCOPE_IN_LIST = "("
+          + bestRowTemporary + "," + bestRowTransaction + "," + bestRowSession
+          + ")";
+  
+*************** public class jdbcDatabaseMetaData implem
+*** 321,327 ****
+       * <code>scope</code> argument is <code>bestRowTransaction</code>.
+       * @since HSQLDB 1.7.2
+       */
+!     private static final String BRI_TRANSACTION_SCOPE_IN_LIST = "("
+          + bestRowTransaction + "," + bestRowSession + ")";
+  
+      /**
+--- 321,327 ----
+       * <code>scope</code> argument is <code>bestRowTransaction</code>.
+       * @since HSQLDB 1.7.2
+       */
+!     public static final String BRI_TRANSACTION_SCOPE_IN_LIST = "("
+          + bestRowTransaction + "," + bestRowSession + ")";
+  
+      /**
+*************** public class jdbcDatabaseMetaData implem
+*** 332,338 ****
+       *
+       * @since HSQLDB 1.7.2
+       */
+!     private static final String selstar = "SELECT * FROM INFORMATION_SCHEMA.";
+  
+      /**
+       * " WHERE 1=1 ". <p>
+--- 332,338 ----
+       *
+       * @since HSQLDB 1.7.2
+       */
+!     public static final String selstar = "SELECT * FROM INFORMATION_SCHEMA.";
+  
+      /**
+       * " WHERE 1=1 ". <p>
+*************** public class jdbcDatabaseMetaData implem
+*** 347,353 ****
+       * end of this and Presto! Everything works :-) <p>
+       * @since HSQLDB 1.7.2
+       */
+!     private static final String whereTrue = " WHERE 1=1";
+  
+      //----------------------------------------------------------------------
+      // First, a variety of minor information about the target database.
+--- 347,353 ----
+       * end of this and Presto! Everything works :-) <p>
+       * @since HSQLDB 1.7.2
+       */
+!     public static final String whereTrue = " WHERE 1=1";
+  
+      //----------------------------------------------------------------------
+      // First, a variety of minor information about the target database.
+*************** public class jdbcDatabaseMetaData implem
+*** 5467,5473 ****
+       *
+       *      </UL>
+       */
+!     private static String and(String id, String op, Object val) {
+  
+          // The JDBC standard for pattern arguments seems to be:
+          //
+--- 5467,5473 ----
+       *
+       *      </UL>
+       */
+!     public static String and(String id, String op, Object val) {
+  
+          // The JDBC standard for pattern arguments seems to be:
+          //
+*************** public class jdbcDatabaseMetaData implem
+*** 5543,5549 ****
+       * @return the result of issuing the statement
+       * @throws SQLException is a database error occurs
+       */
+!     private ResultSet execute(String sql) throws SQLException {
+  
+          // NOTE:
+          // Need to create a jdbcStatement here so jdbcResultSet can return
+--- 5543,5549 ----
+       * @return the result of issuing the statement
+       * @throws SQLException is a database error occurs
+       */
+!     public ResultSet execute(String sql) throws SQLException {
+  
+          // NOTE:
+          // Need to create a jdbcStatement here so jdbcResultSet can return
+*************** public class jdbcDatabaseMetaData implem
+*** 5571,5577 ****
+       *
+       *  If the <em>where</em> clause is null, it is ommited.  <p>
+       *
+!      *  It is assumed that the table name is non-null, since this is a private
+       *  method.  No check is performed. <p>
+       *
+       * @return the result of executing "SELECT * FROM " + table " " + where
+--- 5571,5577 ----
+       *
+       *  If the <em>where</em> clause is null, it is ommited.  <p>
+       *
+!      *  It is assumed that the table name is non-null, since this is a public
+       *  method.  No check is performed. <p>
+       *
+       * @return the result of executing "SELECT * FROM " + table " " + where
+*************** public class jdbcDatabaseMetaData implem
+*** 5579,5585 ****
+       * @param where the where condition for the select
+       * @throws SQLException if database error occurs
+       */
+!     private ResultSet executeSelect(String table,
+                                      String where) throws SQLException {
+  
+          String select = selstar + table;
+--- 5579,5585 ----
+       * @param where the where condition for the select
+       * @throws SQLException if database error occurs
+       */
+!     public ResultSet executeSelect(String table,
+                                      String where) throws SQLException {
+  
+          String select = selstar + table;
+*************** public class jdbcDatabaseMetaData implem
+*** 5603,5609 ****
+       *      "SELECT * FROM &lt;table&gt; WHERE 1=1"
+       * @param t the name of the table
+       */
+!     private StringBuffer toQueryPrefix(String t) {
+  
+          StringBuffer sb = new StringBuffer(255);
+  
+--- 5603,5609 ----
+       *      "SELECT * FROM &lt;table&gt; WHERE 1=1"
+       * @param t the name of the table
+       */
+!     public StringBuffer toQueryPrefix(String t) {
+  
+          StringBuffer sb = new StringBuffer(255);
+  
+*************** public class jdbcDatabaseMetaData implem
+*** 5619,5625 ****
+       * @return true if the argument, s, is filter paramter value that
+       *        requires a corresponding IS NULL predicate
+       */
+!     private static boolean wantsIsNull(String s) {
+          return (s != null && s.length() == 0);
+      }
+  
+--- 5619,5625 ----
+       * @return true if the argument, s, is filter paramter value that
+       *        requires a corresponding IS NULL predicate
+       */
+!     public static boolean wantsIsNull(String s) {
+          return (s != null && s.length() == 0);
+      }
+  
+*************** public class jdbcDatabaseMetaData implem
+*** 5628,5634 ****
+       * is present, any DatabaseMetaData call with an empty string as the
+       * schema parameter will use the default schema (noramlly "PUBLIC").
+       */
+!     private String translateSchema(String schemaName) throws SQLException {
+  
+          if (useSchemaDefault && schemaName != null
+                  && schemaName.length() == 0) {
+--- 5628,5634 ----
+       * is present, any DatabaseMetaData call with an empty string as the
+       * schema parameter will use the default schema (noramlly "PUBLIC").
+       */
+!     public String translateSchema(String schemaName) throws SQLException {
+  
+          if (useSchemaDefault && schemaName != null
+                  && schemaName.length() == 0) {
+diff -pcr misc/hsqldb/src/org/hsqldb/jdbc/jdbcDataSource.java misc/build/hsqldb/src/org/hsqldb/jdbc/jdbcDataSource.java
+*** misc/hsqldb/src/org/hsqldb/jdbc/jdbcDataSource.java	2005-10-23 20:26:22.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/jdbc/jdbcDataSource.java	2007-02-28 12:32:48.000000000 +0100
+*************** implements Serializable, Referenceable, 
+*** 97,123 ****
+      /**
+       * Login timeout
+       */
+!     private int loginTimeout = 0;
+  
+      /**
+       * Log writer
+       */
+!     private transient PrintWriter logWriter;
+  
+      /**
+       * Default password to use for connections
+       */
+!     private String password = "";
+  
+      /**
+       * Default user to use for connections
+       */
+!     private String user = "";
+  
+      /**
+       * Database location
+       */
+!     private String database = "";
+  
+      /**
+       * Constructor
+--- 97,123 ----
+      /**
+       * Login timeout
+       */
+!     public int loginTimeout = 0;
+  
+      /**
+       * Log writer
+       */
+!     public transient PrintWriter logWriter;
+  
+      /**
+       * Default password to use for connections
+       */
+!     public String password = "";
+  
+      /**
+       * Default user to use for connections
+       */
+!     public String user = "";
+  
+      /**
+       * Database location
+       */
+!     public String database = "";
+  
+      /**
+       * Constructor
+diff -pcr misc/hsqldb/src/org/hsqldb/jdbc/jdbcParameterMetaData.java misc/build/hsqldb/src/org/hsqldb/jdbc/jdbcParameterMetaData.java
+*** misc/hsqldb/src/org/hsqldb/jdbc/jdbcParameterMetaData.java	2005-10-23 20:26:22.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/jdbc/jdbcParameterMetaData.java	2007-02-28 12:32:48.000000000 +0100
+*************** public class jdbcParameterMetaData imple
+*** 314,320 ****
+       * @return a String representation of this object
+       * @throws Exception if a reflection error occurs
+       */
+!     private String toStringImpl() throws Exception {
+  
+          StringBuffer sb;
+          Method[]     methods;
+--- 314,320 ----
+       * @return a String representation of this object
+       * @throws Exception if a reflection error occurs
+       */
+!     public String toStringImpl() throws Exception {
+  
+          StringBuffer sb;
+          Method[]     methods;
+diff -pcr misc/hsqldb/src/org/hsqldb/jdbc/jdbcPreparedStatement.java misc/build/hsqldb/src/org/hsqldb/jdbc/jdbcPreparedStatement.java
+*** misc/hsqldb/src/org/hsqldb/jdbc/jdbcPreparedStatement.java	2006-07-17 00:29:27.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/jdbc/jdbcPreparedStatement.java	2007-02-28 12:32:48.000000000 +0100
+*************** public class jdbcPreparedStatement exten
+*** 204,247 ****
+  implements PreparedStatement {
+  
+      /** The parameter values for the next non-batch execution. */
+!     protected Object[] parameterValues;
+  
+      /** Flags for bound variables. */
+!     protected boolean[] parameterSet;
+  
+      /** Flags for bound stream variables. */
+!     protected boolean[] parameterStream;
+  
+      /** The SQL types of the parameters. */
+!     protected int[] parameterTypes;
+  
+      /** The (IN, IN OUT, or OUT) modes of parameters */
+!     protected int[] parameterModes;
+  
+      /** Lengths for streams. */
+!     protected int[] streamLengths;
+  
+      /** Has a stream or CLOB / BLOB parameter value. */
+!     protected boolean hasStreams;
+  
+      /**
+       * Description of result set metadata. <p>
+       */
+!     protected Result rsmdDescriptor;
+  
+      /** Description of parameter metadata. */
+!     protected Result pmdDescriptor;
+  
+      /** This object's one and one ResultSetMetaData object. */
+!     protected jdbcResultSetMetaData rsmd;
+  
+  // NOTE:  pmd is declared as Object to avoid yet another #ifdef.
+  
+      /** This object's one and only ParameterMetaData object. */
+!     protected Object pmd;
+  
+      /** The SQL character sequence that this object represents. */
+!     protected String sql;
+  
+      /**
+       * The id with which this object's corresponding
+--- 204,247 ----
+  implements PreparedStatement {
+  
+      /** The parameter values for the next non-batch execution. */
+!     public Object[] parameterValues;
+  
+      /** Flags for bound variables. */
+!     public boolean[] parameterSet;
+  
+      /** Flags for bound stream variables. */
+!     public boolean[] parameterStream;
+  
+      /** The SQL types of the parameters. */
+!     public int[] parameterTypes;
+  
+      /** The (IN, IN OUT, or OUT) modes of parameters */
+!     public int[] parameterModes;
+  
+      /** Lengths for streams. */
+!     public int[] streamLengths;
+  
+      /** Has a stream or CLOB / BLOB parameter value. */
+!     public boolean hasStreams;
+  
+      /**
+       * Description of result set metadata. <p>
+       */
+!     public Result rsmdDescriptor;
+  
+      /** Description of parameter metadata. */
+!     public Result pmdDescriptor;
+  
+      /** This object's one and one ResultSetMetaData object. */
+!     public jdbcResultSetMetaData rsmd;
+  
+  // NOTE:  pmd is declared as Object to avoid yet another #ifdef.
+  
+      /** This object's one and only ParameterMetaData object. */
+!     public Object pmd;
+  
+      /** The SQL character sequence that this object represents. */
+!     public String sql;
+  
+      /**
+       * The id with which this object's corresponding
+*************** implements PreparedStatement {
+*** 250,262 ****
+       * {@link org.hsqldb.CompiledStatementManager CompiledStatementManager}
+       * object.
+       */
+!     protected int statementID;
+  
+      /**
+       * Whether this statement generates only a single row update count in
+       * response to execution.
+       */
+!     protected boolean isRowCount;
+  
+  // fredt@users 20020215 - patch 517028 by peterhudson@users - method defined
+  // fredt@users 20020215 - patch 517028 by peterhudson@users - method defined
+--- 250,262 ----
+       * {@link org.hsqldb.CompiledStatementManager CompiledStatementManager}
+       * object.
+       */
+!     public int statementID;
+  
+      /**
+       * Whether this statement generates only a single row update count in
+       * response to execution.
+       */
+!     public boolean isRowCount;
+  
+  // fredt@users 20020215 - patch 517028 by peterhudson@users - method defined
+  // fredt@users 20020215 - patch 517028 by peterhudson@users - method defined
+*************** implements PreparedStatement {
+*** 1900,1906 ****
+       *      something other than a single row update count.
+       * @throws SQLException if the argument, yes, does not match
+       */
+!     protected void checkIsRowCount(boolean yes) throws SQLException {
+  
+          if (yes != isRowCount) {
+              int msg = yes ? Trace.JDBC_STATEMENT_NOT_ROW_COUNT
+--- 1900,1906 ----
+       *      something other than a single row update count.
+       * @throws SQLException if the argument, yes, does not match
+       */
+!     public void checkIsRowCount(boolean yes) throws SQLException {
+  
+          if (yes != isRowCount) {
+              int msg = yes ? Trace.JDBC_STATEMENT_NOT_ROW_COUNT
+*************** implements PreparedStatement {
+*** 1917,1923 ****
+       * @param i The parameter index to check
+       * @throws SQLException if the specified parameter index is invalid
+       */
+!     protected void checkSetParameterIndex(int i,
+                                            boolean isStream)
+                                            throws SQLException {
+  
+--- 1917,1923 ----
+       * @param i The parameter index to check
+       * @throws SQLException if the specified parameter index is invalid
+       */
+!     public void checkSetParameterIndex(int i,
+                                            boolean isStream)
+                                            throws SQLException {
+  
+*************** implements PreparedStatement {
+*** 1967,1979 ****
+       * again for the next reuse. When set using other methods, the parameter
+       * setting is retained for the next use.
+       */
+!     private void checkParametersSet() throws SQLException {
+          ;
+      }
+  
+  /*
+      // do not check for compatibility with 1.8.0.x
+!     private void checkParametersSet() throws SQLException {
+  
+          if (parameterStream == null) {
+              for (int i = 0; i < parameterSet.length; i++) {
+--- 1967,1979 ----
+       * again for the next reuse. When set using other methods, the parameter
+       * setting is retained for the next use.
+       */
+!     public void checkParametersSet() throws SQLException {
+          ;
+      }
+  
+  /*
+      // do not check for compatibility with 1.8.0.x
+!     public void checkParametersSet() throws SQLException {
+  
+          if (parameterStream == null) {
+              for (int i = 0; i < parameterSet.length; i++) {
+*************** implements PreparedStatement {
+*** 2004,2010 ****
+       * @param o object
+       * @throws SQLException if either argument is not acceptable.
+       */
+!     private void setParameter(int i, Object o) throws SQLException {
+  
+          checkSetParameterIndex(i, false);
+  
+--- 2004,2010 ----
+       * @param o object
+       * @throws SQLException if either argument is not acceptable.
+       */
+!     public void setParameter(int i, Object o) throws SQLException {
+  
+          checkSetParameterIndex(i, false);
+  
+*************** implements PreparedStatement {
+*** 2088,2094 ****
+       * @param value object to set
+       * @throws SQLException if either argument is not acceptable
+       */
+!     private void setIntParameter(int i, int value) throws SQLException {
+  
+          checkSetParameterIndex(i, false);
+  
+--- 2088,2094 ----
+       * @param value object to set
+       * @throws SQLException if either argument is not acceptable
+       */
+!     public void setIntParameter(int i, int value) throws SQLException {
+  
+          checkSetParameterIndex(i, false);
+  
+*************** implements PreparedStatement {
+*** 2117,2123 ****
+       * @param value object to set
+       * @throws SQLException if either argument is not acceptable
+       */
+!     private void setLongParameter(int i, long value) throws SQLException {
+  
+          checkSetParameterIndex(i, false);
+  
+--- 2117,2123 ----
+       * @param value object to set
+       * @throws SQLException if either argument is not acceptable
+       */
+!     public void setLongParameter(int i, long value) throws SQLException {
+  
+          checkSetParameterIndex(i, false);
+  
+diff -pcr misc/hsqldb/src/org/hsqldb/jdbc/jdbcResultSet.java misc/build/hsqldb/src/org/hsqldb/jdbc/jdbcResultSet.java
+*** misc/hsqldb/src/org/hsqldb/jdbc/jdbcResultSet.java	2006-01-07 17:01:28.000000000 +0100
+--- misc/build/hsqldb/src/org/hsqldb/jdbc/jdbcResultSet.java	2007-02-28 12:32:48.000000000 +0100
+*************** public class jdbcResultSet implements Re
+*** 412,442 ****
+      /**
+       * The current record containing the data for the row
+       */
+!     private Record nCurrent;
+  
+      /** The row upon which this ResultSet is currently positioned. */
+!     private int iCurrentRow;
+  
+      /** When the result of updating the database, the number of updated rows. */
+!     private int iUpdateCount;
+  
+      /** Is current row before the first row? */
+!     private boolean bInit;    // false if before first row
+  
+      /** How many columns does this ResultSet have? */
+      int iColumnCount;
+  
+      /** Did the last getXXX method encounter a null value? */
+!     private boolean bWasNull;
+  
+      /** The ResultSetMetaData object for this ResultSet */
+!     private ResultSetMetaData rsmd;
+  
+      /** Properties of this ResultSet's parent Connection. */
+!     private HsqlProperties connProperties;
+  
+      /** is the connection via network */
+!     private boolean isNetConn;
+  
+      /**
+       * The Statement that generated this result. Null if the result is
+--- 412,442 ----
+      /**
+       * The current record containing the data for the row
+       */
+!     public Record nCurrent;
+  
+      /** The row upon which this ResultSet is currently positioned. */
+!     public int iCurrentRow;
+  
+      /** When the result of updating the database, the number of updated rows. */
+!     public int iUpdateCount;
+  
+      /** Is current row before the first row? */
+!     public boolean bInit;    // false if before first row
+  
+      /** How many columns does this ResultSet have? */
+      int iColumnCount;
+  
+      /** Did the last getXXX method encounter a null value? */
+!     public boolean bWasNull;
+  
+      /** The ResultSetMetaData object for this ResultSet */
+!     public ResultSetMetaData rsmd;
+  
+      /** Properties of this ResultSet's parent Connection. */
+!     public HsqlProperties connProperties;
+  
+      /** is the connection via network */
+!     public boolean isNetConn;
+  
+      /**
+       * The Statement that generated this result. Null if the result is
+*************** public class jdbcResultSet implements Re
+*** 4862,4868 ****
+       *
+       * @throws  SQLException when no row data is available
+       */
+!     private void checkAvailable() throws SQLException {
+  
+          if (rResult == null ||!bInit || nCurrent == null) {
+              throw Util.sqlException(Trace.NO_DATA_IS_AVAILABLE);
+--- 4862,4868 ----
+       *
+       * @throws  SQLException when no row data is available
+       */
+!     public void checkAvailable() throws SQLException {
+  
+          if (rResult == null ||!bInit || nCurrent == null) {
+              throw Util.sqlException(Trace.NO_DATA_IS_AVAILABLE);
+*************** public class jdbcResultSet implements Re
+*** 4874,4880 ****
+       *
+       * @throws SQLException when this result set is closed
+       */
+!     private void checkClosed() throws SQLException {
+  
+          if (rResult == null
+                  || (sqlStatement != null && sqlStatement.isClosed)) {
+--- 4874,4880 ----
+       *
+       * @throws SQLException when this result set is closed
+       */
+!     public void checkClosed() throws SQLException {
+  
+          if (rResult == null
+                  || (sqlStatement != null && sqlStatement.isClosed)) {
+*************** public class jdbcResultSet implements Re
+*** 4901,4907 ****
+       *
+       * @param  o the Object to track
+       */
+!     private boolean checkNull(Object o) {
+  
+          if (o == null) {
+              bWasNull = true;
+--- 4901,4907 ----
+       *
+       * @param  o the Object to track
+       */
+!     public boolean checkNull(Object o) {
+  
+          if (o == null) {
+              bWasNull = true;
+*************** public class jdbcResultSet implements Re
+*** 4929,4935 ****
+       * @throws SQLException when there is no data, the column index is
+       *    invalid, or the conversion cannot be performed
+       */
+!     private Object getColumnInType(int columnIndex,
+                                     int type) throws SQLException {
+  
+          checkAvailable();
+--- 4929,4935 ----
+       * @throws SQLException when there is no data, the column index is
+       *    invalid, or the conversion cannot be performed
+       */
+!     public Object getColumnInType(int columnIndex,
+                                     int type) throws SQLException {
+  
+          checkAvailable();
+diff -pcr misc/hsqldb/src/org/hsqldb/jdbc/jdbcResultSetMetaData.java misc/build/hsqldb/src/org/hsqldb/jdbc/jdbcResultSetMetaData.java
+*** misc/hsqldb/src/org/hsqldb/jdbc/jdbcResultSetMetaData.java	2005-10-23 20:26:23.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/jdbc/jdbcResultSetMetaData.java	2007-02-28 12:32:48.000000000 +0100
+*************** public class jdbcResultSetMetaData imple
+*** 97,118 ****
+       * An array of objects, each of which represents the reported attributes
+       * for  a single column of this object's parent ResultSet.
+       */
+!     private jdbcColumnMetaData[] columnMetaData;
+  
+      /** The number of columns in this object's parent ResultSet. */
+!     private int columnCount;
+  
+      /**
+       * Whether to use the underlying column name or label when reporting
+       * getColumnName().
+       */
+!     private boolean useColumnName;
+  
+      /**
+       * If true, then timings for init() are printed
+       * to the console.
+       */
+!     private static final boolean TRACE = false;
+  
+      /**
+       * Constructs a new jdbcResultSetMetaData object from the specified
+--- 97,118 ----
+       * An array of objects, each of which represents the reported attributes
+       * for  a single column of this object's parent ResultSet.
+       */
+!     public jdbcColumnMetaData[] columnMetaData;
+  
+      /** The number of columns in this object's parent ResultSet. */
+!     public int columnCount;
+  
+      /**
+       * Whether to use the underlying column name or label when reporting
+       * getColumnName().
+       */
+!     public boolean useColumnName;
+  
+      /**
+       * If true, then timings for init() are printed
+       * to the console.
+       */
+!     public static final boolean TRACE = false;
+  
+      /**
+       * Constructs a new jdbcResultSetMetaData object from the specified
+*************** public class jdbcResultSetMetaData imple
+*** 1137,1143 ****
+       * @throws SQLException when this object's parent ResultSet has
+       *      no such column
+       */
+!     private void checkColumn(int column) throws SQLException {
+  
+          if (column < 1 || column > columnCount) {
+              throw Util.sqlException(Trace.COLUMN_NOT_FOUND,
+--- 1137,1143 ----
+       * @throws SQLException when this object's parent ResultSet has
+       *      no such column
+       */
+!     public void checkColumn(int column) throws SQLException {
+  
+          if (column < 1 || column > columnCount) {
+              throw Util.sqlException(Trace.COLUMN_NOT_FOUND,
+diff -pcr misc/hsqldb/src/org/hsqldb/jdbc/jdbcStatement.java misc/build/hsqldb/src/org/hsqldb/jdbc/jdbcStatement.java
+*** misc/hsqldb/src/org/hsqldb/jdbc/jdbcStatement.java	2006-02-16 03:29:20.000000000 +0100
+--- misc/build/hsqldb/src/org/hsqldb/jdbc/jdbcStatement.java	2007-02-28 12:32:48.000000000 +0100
+*************** public class jdbcStatement implements St
+*** 134,158 ****
+      volatile boolean isClosed;
+  
+      /** Is escape processing enabled? */
+!     private boolean isEscapeProcessing = true;
+  
+      /** The connection used to execute this statement. */
+!     protected jdbcConnection connection;
+  
+      /** The maximum number of rows to generate when executing this statement. */
+!     protected int maxRows;
+  
+      /** The result of executing this statement. */
+!     protected Result resultIn;
+  
+      /** The result set type obtained by executing this statement. */
+!     protected int rsType = jdbcResultSet.TYPE_FORWARD_ONLY;
+  
+      /** Used by this statement to communicate non-batched requests. */
+!     protected Result resultOut = new Result(ResultConstants.SQLEXECDIRECT);
+  
+      /** Use by this statement to communicate batched execution requests */
+!     protected Result batchResultOut = null;
+  
+      // boucherb@users
+      // NOTE:
+--- 134,158 ----
+      volatile boolean isClosed;
+  
+      /** Is escape processing enabled? */
+!     public boolean isEscapeProcessing = true;
+  
+      /** The connection used to execute this statement. */
+!     public jdbcConnection connection;
+  
+      /** The maximum number of rows to generate when executing this statement. */
+!     public int maxRows;
+  
+      /** The result of executing this statement. */
+!     public Result resultIn;
+  
+      /** The result set type obtained by executing this statement. */
+!     public int rsType = jdbcResultSet.TYPE_FORWARD_ONLY;
+  
+      /** Used by this statement to communicate non-batched requests. */
+!     public Result resultOut = new Result(ResultConstants.SQLEXECDIRECT);
+  
+      /** Use by this statement to communicate batched execution requests */
+!     public Result batchResultOut = null;
+  
+      // boucherb@users
+      // NOTE:
+*************** public class jdbcStatement implements St
+*** 1557,1563 ****
+       * @param sql a character sequence representing the SQL to be executed
+       * @throws SQLException when a database access error occurs
+       */
+!     private void fetchResult(String sql) throws SQLException {
+  
+          if (isEscapeProcessing) {
+              sql = connection.nativeSQL(sql);
+--- 1557,1563 ----
+       * @param sql a character sequence representing the SQL to be executed
+       * @throws SQLException when a database access error occurs
+       */
+!     public void fetchResult(String sql) throws SQLException {
+  
+          if (isEscapeProcessing) {
+              sql = connection.nativeSQL(sql);
+diff -pcr misc/hsqldb/src/org/hsqldb/lib/ArrayUtil.java misc/build/hsqldb/src/org/hsqldb/lib/ArrayUtil.java
+*** misc/hsqldb/src/org/hsqldb/lib/ArrayUtil.java	2006-02-16 03:29:36.000000000 +0100
+--- misc/build/hsqldb/src/org/hsqldb/lib/ArrayUtil.java	2007-02-28 12:32:48.000000000 +0100
+*************** public class ArrayUtil {
+*** 51,57 ****
+      public static final int        CLASS_CODE_OBJECT  = 'L';
+      public static final int        CLASS_CODE_SHORT   = 'S';
+      public static final int        CLASS_CODE_BOOLEAN = 'Z';
+!     private static IntValueHashMap classCodeMap       = new IntValueHashMap();
+  
+      static {
+          classCodeMap.put(byte.class, ArrayUtil.CLASS_CODE_BYTE);
+--- 51,57 ----
+      public static final int        CLASS_CODE_OBJECT  = 'L';
+      public static final int        CLASS_CODE_SHORT   = 'S';
+      public static final int        CLASS_CODE_BOOLEAN = 'Z';
+!     public static IntValueHashMap classCodeMap       = new IntValueHashMap();
+  
+      static {
+          classCodeMap.put(byte.class, ArrayUtil.CLASS_CODE_BYTE);
+diff -pcr misc/hsqldb/src/org/hsqldb/lib/BaseList.java misc/build/hsqldb/src/org/hsqldb/lib/BaseList.java
+*** misc/hsqldb/src/org/hsqldb/lib/BaseList.java	2005-10-23 20:26:24.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/lib/BaseList.java	2007-02-28 12:32:48.000000000 +0100
+*************** import java.util.NoSuchElementException;
+*** 42,48 ****
+   */
+  abstract class BaseList {
+  
+!     protected int elementCount;
+  
+      abstract Object get(int index);
+  
+--- 42,48 ----
+   */
+  abstract class BaseList {
+  
+!     public int elementCount;
+  
+      abstract Object get(int index);
+  
+*************** abstract class BaseList {
+*** 135,141 ****
+          return new BaseListIterator();
+      }
+  
+!     private class BaseListIterator implements Iterator {
+  
+          int     counter = 0;
+          boolean removed;
+--- 135,141 ----
+          return new BaseListIterator();
+      }
+  
+!     public class BaseListIterator implements Iterator {
+  
+          int     counter = 0;
+          boolean removed;
+diff -pcr misc/hsqldb/src/org/hsqldb/lib/DoubleIntIndex.java misc/build/hsqldb/src/org/hsqldb/lib/DoubleIntIndex.java
+*** misc/hsqldb/src/org/hsqldb/lib/DoubleIntIndex.java	2005-10-23 20:26:24.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/lib/DoubleIntIndex.java	2007-02-28 12:32:48.000000000 +0100
+*************** import java.util.NoSuchElementException;
+*** 52,68 ****
+   */
+  public class DoubleIntIndex implements IntLookup {
+  
+!     private int           count = 0;
+!     private int           capacity;
+!     private boolean       sorted       = true;
+!     private boolean       sortOnValues = true;
+!     private boolean       hasChanged;
+!     private final boolean fixedSize;
+!     private int[]         keys;
+!     private int[]         values;
+  
+  //
+!     private int targetSearchValue;
+  
+      public DoubleIntIndex(int capacity, boolean fixedSize) {
+  
+--- 52,68 ----
+   */
+  public class DoubleIntIndex implements IntLookup {
+  
+!     public int           count = 0;
+!     public int           capacity;
+!     public boolean       sorted       = true;
+!     public boolean       sortOnValues = true;
+!     public boolean       hasChanged;
+!     public final boolean fixedSize;
+!     public int[]         keys;
+!     public int[]         values;
+  
+  //
+!     public int targetSearchValue;
+  
+      public DoubleIntIndex(int capacity, boolean fixedSize) {
+  
+*************** public class DoubleIntIndex implements I
+*** 395,401 ****
+       * or -1
+       * @return index or -1 if not found
+       */
+!     private int binaryFirstSearch() {
+  
+          int low     = 0;
+          int high    = count;
+--- 395,401 ----
+       * or -1
+       * @return index or -1 if not found
+       */
+!     public int binaryFirstSearch() {
+  
+          int low     = 0;
+          int high    = count;
+*************** public class DoubleIntIndex implements I
+*** 425,431 ****
+       * Returns the index of the lowest element > the given search target
+       *     @return the index
+       */
+!     private int binaryGreaterSearch() {
+  
+          int low     = 0;
+          int high    = count;
+--- 425,431 ----
+       * Returns the index of the lowest element > the given search target
+       *     @return the index
+       */
+!     public int binaryGreaterSearch() {
+  
+          int low     = 0;
+          int high    = count;
+*************** public class DoubleIntIndex implements I
+*** 452,458 ****
+       * or count
+       *     @return the index
+       */
+!     private int binarySlotSearch() {
+  
+          int low     = 0;
+          int high    = count;
+--- 452,458 ----
+       * or count
+       *     @return the index
+       */
+!     public int binarySlotSearch() {
+  
+          int low     = 0;
+          int high    = count;
+*************** public class DoubleIntIndex implements I
+*** 478,484 ****
+       * or count or -1 if target is found
+       * @return the index
+       */
+!     private int binaryEmptySlotSearch() {
+  
+          int low     = 0;
+          int high    = count;
+--- 478,484 ----
+       * or count or -1 if target is found
+       * @return the index
+       */
+!     public int binaryEmptySlotSearch() {
+  
+          int low     = 0;
+          int high    = count;
+*************** public class DoubleIntIndex implements I
+*** 501,507 ****
+          return low;
+      }
+  
+!     private synchronized void fastQuickSort() {
+  
+          quickSort(0, count - 1);
+          insertionSort(0, count - 1);
+--- 501,507 ----
+          return low;
+      }
+  
+!     public synchronized void fastQuickSort() {
+  
+          quickSort(0, count - 1);
+          insertionSort(0, count - 1);
+*************** public class DoubleIntIndex implements I
+*** 509,515 ****
+          sorted = true;
+      }
+  
+!     private void quickSort(int l, int r) {
+  
+          int M = 4;
+          int i;
+--- 509,515 ----
+          sorted = true;
+      }
+  
+!     public void quickSort(int l, int r) {
+  
+          int M = 4;
+          int i;
+*************** public class DoubleIntIndex implements I
+*** 556,562 ****
+          }
+      }
+  
+!     private void insertionSort(int lo0, int hi0) {
+  
+          int i;
+          int j;
+--- 556,562 ----
+          }
+      }
+  
+!     public void insertionSort(int lo0, int hi0) {
+  
+          int i;
+          int j;
+*************** public class DoubleIntIndex implements I
+*** 574,580 ****
+          }
+      }
+  
+!     private void moveAndInsertRow(int i, int j) {
+  
+          int col1 = keys[i];
+          int col2 = values[i];
+--- 574,580 ----
+          }
+      }
+  
+!     public void moveAndInsertRow(int i, int j) {
+  
+          int col1 = keys[i];
+          int col2 = values[i];
+*************** public class DoubleIntIndex implements I
+*** 585,598 ****
+          values[j] = col2;
+      }
+  
+!     private void doubleCapacity() {
+  
+          keys     = (int[]) ArrayUtil.resizeArray(keys, capacity * 2);
+          values   = (int[]) ArrayUtil.resizeArray(values, capacity * 2);
+          capacity *= 2;
+      }
+  
+!     private void swap(int i1, int i2) {
+  
+          int col1 = keys[i1];
+          int col2 = values[i1];
+--- 585,598 ----
+          values[j] = col2;
+      }
+  
+!     public void doubleCapacity() {
+  
+          keys     = (int[]) ArrayUtil.resizeArray(keys, capacity * 2);
+          values   = (int[]) ArrayUtil.resizeArray(values, capacity * 2);
+          capacity *= 2;
+      }
+  
+!     public void swap(int i1, int i2) {
+  
+          int col1 = keys[i1];
+          int col2 = values[i1];
+*************** public class DoubleIntIndex implements I
+*** 603,609 ****
+          values[i2] = col2;
+      }
+  
+!     private void moveRows(int fromIndex, int toIndex, int rows) {
+          System.arraycopy(keys, fromIndex, keys, toIndex, rows);
+          System.arraycopy(values, fromIndex, values, toIndex, rows);
+      }
+--- 603,609 ----
+          values[i2] = col2;
+      }
+  
+!     public void moveRows(int fromIndex, int toIndex, int rows) {
+          System.arraycopy(keys, fromIndex, keys, toIndex, rows);
+          System.arraycopy(values, fromIndex, values, toIndex, rows);
+      }
+*************** public class DoubleIntIndex implements I
+*** 631,637 ****
+       * @param i the index
+       * @return -1, 0 or +1
+       */
+!     private int compare(int i) {
+  
+          if (sortOnValues) {
+              if (targetSearchValue > values[i]) {
+--- 631,637 ----
+       * @param i the index
+       * @return -1, 0 or +1
+       */
+!     public int compare(int i) {
+  
+          if (sortOnValues) {
+              if (targetSearchValue > values[i]) {
+*************** public class DoubleIntIndex implements I
+*** 668,674 ****
+       * @param j the second index
+       * @return true or false
+       */
+!     private boolean lessThan(int i, int j) {
+  
+          if (sortOnValues) {
+              if (values[i] < values[j]) {
+--- 668,674 ----
+       * @param j the second index
+       * @return true or false
+       */
+!     public boolean lessThan(int i, int j) {
+  
+          if (sortOnValues) {
+              if (values[i] < values[j]) {
+diff -pcr misc/hsqldb/src/org/hsqldb/lib/FileUtil.java misc/build/hsqldb/src/org/hsqldb/lib/FileUtil.java
+*** misc/hsqldb/src/org/hsqldb/lib/FileUtil.java	2006-07-17 00:29:34.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/lib/FileUtil.java	2007-02-28 12:32:48.000000000 +0100
+*************** import org.hsqldb.lib.java.JavaSystem;
+*** 52,58 ****
+   */
+  public class FileUtil implements FileAccess {
+  
+!     private static FileUtil fileUtil;
+  
+      /** Creates a new instance of FileUtil */
+      FileUtil() {}
+--- 52,58 ----
+   */
+  public class FileUtil implements FileAccess {
+  
+!     public static FileUtil fileUtil;
+  
+      /** Creates a new instance of FileUtil */
+      FileUtil() {}
+diff -pcr misc/hsqldb/src/org/hsqldb/lib/HashMappedList.java misc/build/hsqldb/src/org/hsqldb/lib/HashMappedList.java
+*** misc/hsqldb/src/org/hsqldb/lib/HashMappedList.java	2005-10-23 20:26:24.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/lib/HashMappedList.java	2007-02-28 12:32:48.000000000 +0100
+*************** public class HashMappedList extends Hash
+*** 182,188 ****
+          return getLookup(key, key.hashCode());
+      }
+  
+!     private void checkRange(int i) {
+  
+          if (i < 0 || i >= size()) {
+              throw new IndexOutOfBoundsException();
+--- 182,188 ----
+          return getLookup(key, key.hashCode());
+      }
+  
+!     public void checkRange(int i) {
+  
+          if (i < 0 || i >= size()) {
+              throw new IndexOutOfBoundsException();
+diff -pcr misc/hsqldb/src/org/hsqldb/lib/HsqlArrayHeap.java misc/build/hsqldb/src/org/hsqldb/lib/HsqlArrayHeap.java
+*** misc/hsqldb/src/org/hsqldb/lib/HsqlArrayHeap.java	2005-10-23 20:26:24.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/lib/HsqlArrayHeap.java	2007-02-28 12:32:48.000000000 +0100
+*************** package org.hsqldb.lib;
+*** 43,51 ****
+  public class HsqlArrayHeap implements HsqlHeap {
+  
+  // --------------------------------- members -----------------------------------
+!     protected ObjectComparator oc;
+!     protected int              count;
+!     protected Object[]         heap;
+  
+  // ------------------------------ constructors ---------------------------------
+  
+--- 43,51 ----
+  public class HsqlArrayHeap implements HsqlHeap {
+  
+  // --------------------------------- members -----------------------------------
+!     public ObjectComparator oc;
+!     public int              count;
+!     public Object[]         heap;
+  
+  // ------------------------------ constructors ---------------------------------
+  
+*************** public class HsqlArrayHeap implements Hs
+*** 311,317 ****
+  //        System.arraycopy(oldheap, 0, heap, 0, count);
+  //    }
+  // -------------------- internal implementation methods ------------------------
+!     private void increaseCapacity() {
+  
+          Object[] oldheap;
+  
+--- 311,317 ----
+  //        System.arraycopy(oldheap, 0, heap, 0, count);
+  //    }
+  // -------------------- internal implementation methods ------------------------
+!     public void increaseCapacity() {
+  
+          Object[] oldheap;
+  
+diff -pcr misc/hsqldb/src/org/hsqldb/lib/HsqlArrayList.java misc/build/hsqldb/src/org/hsqldb/lib/HsqlArrayList.java
+*** misc/hsqldb/src/org/hsqldb/lib/HsqlArrayList.java	2005-10-23 19:40:12.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/lib/HsqlArrayList.java	2007-02-28 12:32:48.000000000 +0100
+*************** public class HsqlArrayList extends BaseL
+*** 47,58 ****
+  
+  //fredt@users
+  /*
+!     private static Reporter reporter = new Reporter();
+  
+!     private static class Reporter {
+  
+!         private static int initCounter   = 0;
+!         private static int updateCounter = 0;
+  
+          Reporter() {
+  
+--- 47,58 ----
+  
+  //fredt@users
+  /*
+!     public static Reporter reporter = new Reporter();
+  
+!     public static class Reporter {
+  
+!         public static int initCounter   = 0;
+!         public static int updateCounter = 0;
+  
+          Reporter() {
+  
+*************** public class HsqlArrayList extends BaseL
+*** 61,67 ****
+              } catch (SecurityException e) {}
+          }
+  
+!         protected void finalize() {
+  
+              System.out.println("HsqlArrayList init count: " + initCounter);
+              System.out.println("HsqlArrayList update count: "
+--- 61,67 ----
+              } catch (SecurityException e) {}
+          }
+  
+!         public void finalize() {
+  
+              System.out.println("HsqlArrayList init count: " + initCounter);
+              System.out.println("HsqlArrayList update count: "
+*************** public class HsqlArrayList extends BaseL
+*** 69,78 ****
+          }
+      }
+  */
+!     private static final int   DEFAULT_INITIAL_CAPACITY = 10;
+!     private static final float DEFAULT_RESIZE_FACTOR    = 2.0f;
+!     private Object[]           elementData;
+!     private boolean            minimizeOnClear;
+  
+      /** Creates a new instance of HsqlArrayList */
+      public HsqlArrayList() {
+--- 69,78 ----
+          }
+      }
+  */
+!     public static final int   DEFAULT_INITIAL_CAPACITY = 10;
+!     public static final float DEFAULT_RESIZE_FACTOR    = 2.0f;
+!     public Object[]           elementData;
+!     public boolean            minimizeOnClear;
+  
+      /** Creates a new instance of HsqlArrayList */
+      public HsqlArrayList() {
+*************** public class HsqlArrayList extends BaseL
+*** 236,242 ****
+          return elementCount;
+      }
+  
+!     private void increaseCapacity() {
+  
+          int baseSize = elementData.length == 0 ? 1
+                                                 : elementData.length;
+--- 236,242 ----
+          return elementCount;
+      }
+  
+!     public void increaseCapacity() {
+  
+          int baseSize = elementData.length == 0 ? 1
+                                                 : elementData.length;
+*************** public class HsqlArrayList extends BaseL
+*** 259,265 ****
+  
+          Enumeration en = new Enumeration() {
+  
+!             private int pos = 0;
+  
+              public Object nextElement() {
+  
+--- 259,265 ----
+  
+          Enumeration en = new Enumeration() {
+  
+!             public int pos = 0;
+  
+              public Object nextElement() {
+  
+diff -pcr misc/hsqldb/src/org/hsqldb/lib/HsqlByteArrayInputStream.java misc/build/hsqldb/src/org/hsqldb/lib/HsqlByteArrayInputStream.java
+*** misc/hsqldb/src/org/hsqldb/lib/HsqlByteArrayInputStream.java	2005-10-23 20:26:24.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/lib/HsqlByteArrayInputStream.java	2007-02-28 12:32:48.000000000 +0100
+*************** import java.io.InputStream;
+*** 47,56 ****
+  public class HsqlByteArrayInputStream extends InputStream
+  implements DataInput {
+  
+!     protected byte[] buf;
+!     protected int    pos;
+!     protected int    mark = 0;
+!     protected int    count;
+  
+      public HsqlByteArrayInputStream(byte[] buf) {
+  
+--- 47,56 ----
+  public class HsqlByteArrayInputStream extends InputStream
+  implements DataInput {
+  
+!     public byte[] buf;
+!     public int    pos;
+!     public int    mark = 0;
+!     public int    count;
+  
+      public HsqlByteArrayInputStream(byte[] buf) {
+  
+diff -pcr misc/hsqldb/src/org/hsqldb/lib/HsqlByteArrayOutputStream.java misc/build/hsqldb/src/org/hsqldb/lib/HsqlByteArrayOutputStream.java
+*** misc/hsqldb/src/org/hsqldb/lib/HsqlByteArrayOutputStream.java	2006-06-11 14:05:36.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/lib/HsqlByteArrayOutputStream.java	2007-02-28 12:32:48.000000000 +0100
+*************** import java.io.UnsupportedEncodingExcept
+*** 48,55 ****
+  public class HsqlByteArrayOutputStream extends java.io.OutputStream
+  implements DataOutput {
+  
+!     protected byte[] buf;
+!     protected int    count;
+  
+      public HsqlByteArrayOutputStream() {
+          this(128);
+--- 48,55 ----
+  public class HsqlByteArrayOutputStream extends java.io.OutputStream
+  implements DataOutput {
+  
+!     public byte[] buf;
+!     public int    count;
+  
+      public HsqlByteArrayOutputStream() {
+          this(128);
+*************** implements DataOutput {
+*** 251,257 ****
+          return this.buf;
+      }
+  
+!     protected void ensureRoom(int extra) {
+  
+          int newcount = count + extra;
+          int newsize  = buf.length;
+--- 251,257 ----
+          return this.buf;
+      }
+  
+!     public void ensureRoom(int extra) {
+  
+          int newcount = count + extra;
+          int newsize  = buf.length;
+*************** implements DataOutput {
+*** 269,275 ****
+          }
+      }
+  
+!     protected void reset(int newSize) {
+  
+          count = 0;
+  
+--- 269,275 ----
+          }
+      }
+  
+!     public void reset(int newSize) {
+  
+          count = 0;
+  
+diff -pcr misc/hsqldb/src/org/hsqldb/lib/HsqlDeque.java misc/build/hsqldb/src/org/hsqldb/lib/HsqlDeque.java
+*** misc/hsqldb/src/org/hsqldb/lib/HsqlDeque.java	2005-10-23 19:40:12.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/lib/HsqlDeque.java	2007-02-28 12:32:48.000000000 +0100
+*************** import java.util.NoSuchElementException;
+*** 47,59 ****
+   */
+  public class HsqlDeque extends BaseList implements HsqlList {
+  
+!     private Object[] list;
+!     private int      firstindex = 0;    // index of first list element
+!     private int      endindex   = 0;    // index of last list element + 1
+  
+      // can grow to fill list
+      // if elementCount == 0 then firstindex == endindex
+!     private static final int DEFAULT_INITIAL_CAPACITY = 10;
+  
+      public HsqlDeque() {
+          list = new Object[DEFAULT_INITIAL_CAPACITY];
+--- 47,59 ----
+   */
+  public class HsqlDeque extends BaseList implements HsqlList {
+  
+!     public Object[] list;
+!     public int      firstindex = 0;    // index of first list element
+!     public int      endindex   = 0;    // index of last list element + 1
+  
+      // can grow to fill list
+      // if elementCount == 0 then firstindex == endindex
+!     public static final int DEFAULT_INITIAL_CAPACITY = 10;
+  
+      public HsqlDeque() {
+          list = new Object[DEFAULT_INITIAL_CAPACITY];
+*************** public class HsqlDeque extends BaseList 
+*** 242,248 ****
+          return value;
+      }
+  
+!     private int getInternalIndex(int i) throws IndexOutOfBoundsException {
+  
+          if (i < 0 || i >= elementCount) {
+              throw new IndexOutOfBoundsException();
+--- 242,248 ----
+          return value;
+      }
+  
+!     public int getInternalIndex(int i) throws IndexOutOfBoundsException {
+  
+          if (i < 0 || i >= elementCount) {
+              throw new IndexOutOfBoundsException();
+*************** public class HsqlDeque extends BaseList 
+*** 257,263 ****
+          return index;
+      }
+  
+!     private void resetCapacity() {
+  
+          if (elementCount < list.length) {
+              return;
+--- 257,263 ----
+          return index;
+      }
+  
+!     public void resetCapacity() {
+  
+          if (elementCount < list.length) {
+              return;
+diff -pcr misc/hsqldb/src/org/hsqldb/lib/HsqlLinkedList.java misc/build/hsqldb/src/org/hsqldb/lib/HsqlLinkedList.java
+*** misc/hsqldb/src/org/hsqldb/lib/HsqlLinkedList.java	2005-10-23 20:26:24.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/lib/HsqlLinkedList.java	2007-02-28 12:32:48.000000000 +0100
+*************** public class HsqlLinkedList extends Base
+*** 46,55 ****
+       * A reference to the head of the list.  It is a dummy head (that is, the
+       * Node for index 0 is actually first.next).
+       */
+!     private Node first;
+  
+      /** A reference to the tail of the list */
+!     private Node last;
+  
+      /**
+       * Creates a new instance of HsqlLinkedList.
+--- 46,55 ----
+       * A reference to the head of the list.  It is a dummy head (that is, the
+       * Node for index 0 is actually first.next).
+       */
+!     public Node first;
+  
+      /** A reference to the tail of the list */
+!     public Node last;
+  
+      /**
+       * Creates a new instance of HsqlLinkedList.
+*************** public class HsqlLinkedList extends Base
+*** 197,203 ****
+       * index within the list (0 &lt;= <code>index</code> &lt;
+       * <code>size</code>).
+       */
+!     protected final Node getInternal(int index) {
+  
+          //Check preconditions for the index variable
+          if (index >= size()) {
+--- 197,203 ----
+       * index within the list (0 &lt;= <code>index</code> &lt;
+       * <code>size</code>).
+       */
+!     public final Node getInternal(int index) {
+  
+          //Check preconditions for the index variable
+          if (index >= size()) {
+*************** public class HsqlLinkedList extends Base
+*** 232,238 ****
+       * jcpeck@users
+       * @version 05/24/2002
+       */
+!     private static class Node {
+  
+          public Node   next;
+          public Object data;
+--- 232,238 ----
+       * jcpeck@users
+       * @version 05/24/2002
+       */
+!     public static class Node {
+  
+          public Node   next;
+          public Object data;
+diff -pcr misc/hsqldb/src/org/hsqldb/lib/HsqlTaskQueue.java misc/build/hsqldb/src/org/hsqldb/lib/HsqlTaskQueue.java
+*** misc/hsqldb/src/org/hsqldb/lib/HsqlTaskQueue.java	2005-10-23 20:26:24.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/lib/HsqlTaskQueue.java	2007-02-28 12:32:48.000000000 +0100
+*************** package org.hsqldb.lib;
+*** 43,52 ****
+  public class HsqlTaskQueue {
+  
+      /** The thread used to process commands */
+!     protected Thread taskRunnerThread;
+  
+      /** Special queue element to signal termination */
+!     protected static final Runnable SHUTDOWNTASK = new Runnable() {
+          public void run() {}
+      };
+  
+--- 43,52 ----
+  public class HsqlTaskQueue {
+  
+      /** The thread used to process commands */
+!     public Thread taskRunnerThread;
+  
+      /** Special queue element to signal termination */
+!     public static final Runnable SHUTDOWNTASK = new Runnable() {
+          public void run() {}
+      };
+  
+*************** public class HsqlTaskQueue {
+*** 55,73 ****
+       *
+       * Once set true, stays true forever
+       */
+!     protected volatile boolean isShutdown;
+  
+      public synchronized Thread getTaskRunnerThread() {
+          return taskRunnerThread;
+      }
+  
+!     protected synchronized void clearThread() {
+          taskRunnerThread = null;
+      }
+  
+!     protected final HsqlDeque queue = new HsqlDeque();
+  
+!     protected class TaskRunner implements Runnable {
+  
+          public void run() {
+  
+--- 55,73 ----
+       *
+       * Once set true, stays true forever
+       */
+!     public volatile boolean isShutdown;
+  
+      public synchronized Thread getTaskRunnerThread() {
+          return taskRunnerThread;
+      }
+  
+!     public synchronized void clearThread() {
+          taskRunnerThread = null;
+      }
+  
+!     public final HsqlDeque queue = new HsqlDeque();
+  
+!     public class TaskRunner implements Runnable {
+  
+          public void run() {
+  
+*************** public class HsqlTaskQueue {
+*** 101,107 ****
+          }
+      }
+  
+!     protected final TaskRunner taskRunner = new TaskRunner();
+  
+      public HsqlTaskQueue() {}
+  
+--- 101,107 ----
+          }
+      }
+  
+!     public final TaskRunner taskRunner = new TaskRunner();
+  
+      public HsqlTaskQueue() {}
+  
+diff -pcr misc/hsqldb/src/org/hsqldb/lib/HsqlThreadFactory.java misc/build/hsqldb/src/org/hsqldb/lib/HsqlThreadFactory.java
+*** misc/hsqldb/src/org/hsqldb/lib/HsqlThreadFactory.java	2005-10-23 20:26:24.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/lib/HsqlThreadFactory.java	2007-02-28 12:32:48.000000000 +0100
+*************** class HsqlThreadFactory implements Threa
+*** 47,53 ****
+       * The factory implementation.  Typically, this will be the
+       * HsqlThreadFactory object itself.
+       */
+!     protected ThreadFactory factory;
+  
+      /**
+       * Constructs a new HsqlThreadFactory that uses itself as the factory
+--- 47,53 ----
+       * The factory implementation.  Typically, this will be the
+       * HsqlThreadFactory object itself.
+       */
+!     public ThreadFactory factory;
+  
+      /**
+       * Constructs a new HsqlThreadFactory that uses itself as the factory
+diff -pcr misc/hsqldb/src/org/hsqldb/lib/HsqlTimer.java misc/build/hsqldb/src/org/hsqldb/lib/HsqlTimer.java
+*** misc/hsqldb/src/org/hsqldb/lib/HsqlTimer.java	2005-10-23 20:26:24.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/lib/HsqlTimer.java	2007-02-28 12:32:48.000000000 +0100
+*************** import java.util.Date;
+*** 47,63 ****
+  public class HsqlTimer implements ObjectComparator {
+  
+      /** The priority queue for the scheduled tasks. */
+!     protected final TaskQueue taskQueue = new TaskQueue(16,
+          (ObjectComparator) this);
+  
+      /** The inner runnable that executes tasks in the background thread. */
+!     protected final TaskRunner taskRunner = new TaskRunner();
+  
+      /** The background thread. */
+!     protected Thread taskRunnerThread;
+  
+      /** The factory that procduces the background threads. */
+!     protected ThreadFactory threadFactory;
+  
+      /**
+       * Constructs a new HsqlTimer using the default thread factory
+--- 47,63 ----
+  public class HsqlTimer implements ObjectComparator {
+  
+      /** The priority queue for the scheduled tasks. */
+!     public final TaskQueue taskQueue = new TaskQueue(16,
+          (ObjectComparator) this);
+  
+      /** The inner runnable that executes tasks in the background thread. */
+!     public final TaskRunner taskRunner = new TaskRunner();
+  
+      /** The background thread. */
+!     public Thread taskRunnerThread;
+  
+      /** The factory that procduces the background threads. */
+!     public ThreadFactory threadFactory;
+  
+      /**
+       * Constructs a new HsqlTimer using the default thread factory
+*************** public class HsqlTimer implements Object
+*** 359,365 ****
+       * @param b if true, use fixed rate else use fixed period
+       * @return a reference to the scheduled task
+       */
+!     protected Task addTask(long n, Runnable r, long p, boolean b) {
+  
+          Task task;
+  
+--- 359,365 ----
+       * @param b if true, use fixed rate else use fixed period
+       * @return a reference to the scheduled task
+       */
+!     public Task addTask(long n, Runnable r, long p, boolean b) {
+  
+          Task task;
+  
+*************** public class HsqlTimer implements Object
+*** 375,381 ****
+      }
+  
+      /** Sets the background thread to null. */
+!     protected synchronized void clearThread() {
+          taskRunnerThread = null;
+      }
+  
+--- 375,381 ----
+      }
+  
+      /** Sets the background thread to null. */
+!     public synchronized void clearThread() {
+          taskRunnerThread = null;
+      }
+  
+*************** public class HsqlTimer implements Object
+*** 385,391 ****
+       *
+       * @return the next task to execute, or null
+       */
+!     protected synchronized Task nextTask() {
+  
+          Task    task;
+          long    now;
+--- 385,391 ----
+       *
+       * @return the next task to execute, or null
+       */
+!     public synchronized Task nextTask() {
+  
+          Task    task;
+          long    now;
+*************** public class HsqlTimer implements Object
+*** 452,458 ****
+       *
+       * @return System.currentTimeMillis()
+       */
+!     private static long now() {
+  
+          nowCount++;
+  
+--- 452,458 ----
+       *
+       * @return System.currentTimeMillis()
+       */
+!     public static long now() {
+  
+          nowCount++;
+  
+*************** public class HsqlTimer implements Object
+*** 467,473 ****
+       * but using an inner class protects the public run method
+       * from potential abuse.
+       */
+!     protected class TaskRunner implements Runnable {
+  
+          public void run() {
+  
+--- 467,473 ----
+       * but using an inner class protects the public run method
+       * from potential abuse.
+       */
+!     public class TaskRunner implements Runnable {
+  
+          public void run() {
+  
+*************** public class HsqlTimer implements Object
+*** 495,501 ****
+       * for execution by the enclosing HsqlTimer's TaskRunner in a
+       * background thread.
+       */
+!     protected class Task {
+  
+          /** What to run */
+          final Runnable runnable;
+--- 495,501 ----
+       * for execution by the enclosing HsqlTimer's TaskRunner in a
+       * background thread.
+       */
+!     public class Task {
+  
+          /** What to run */
+          final Runnable runnable;
+*************** public class HsqlTimer implements Object
+*** 504,523 ****
+          long period;
+  
+          /** The time this task was last executed, or 0 if never */
+!         private long last;
+  
+          /** The next time this task is scheduled to execute */
+!         private long next;
+  
+          /**
+           * Whether to remove this task instead of running it
+           * the next time it makes its way to the head of the
+           * timer queue.
+           */
+!         private boolean cancelled = false;
+  
+          /** protect the cancelled field under concurrent access */
+!         private Object cancel_mutex = new Object();
+  
+          /**
+           * Whether periodic task is sheduled using fixed delay or fixed rate.
+--- 504,523 ----
+          long period;
+  
+          /** The time this task was last executed, or 0 if never */
+!         public long last;
+  
+          /** The next time this task is scheduled to execute */
+!         public long next;
+  
+          /**
+           * Whether to remove this task instead of running it
+           * the next time it makes its way to the head of the
+           * timer queue.
+           */
+!         public boolean cancelled = false;
+  
+          /** protect the cancelled field under concurrent access */
+!         public Object cancel_mutex = new Object();
+  
+          /**
+           * Whether periodic task is sheduled using fixed delay or fixed rate.
+*************** public class HsqlTimer implements Object
+*** 628,634 ****
+       * only, as there is no public interface to reinsert Task objects after
+       * they have been removed.
+       */
+!     protected class TaskQueue extends HsqlArrayHeap {
+  
+          /**
+           * Constructs a new TaskQueue with the specified initial capacity and
+--- 628,634 ----
+       * only, as there is no public interface to reinsert Task objects after
+       * they have been removed.
+       */
+!     public class TaskQueue extends HsqlArrayHeap {
+  
+          /**
+           * Constructs a new TaskQueue with the specified initial capacity and
+*************** public class HsqlTimer implements Object
+*** 702,708 ****
+  //            return name;
+  //        }
+  //
+! //        protected void printstats() {
+  //            System.out.println(this + " avg. latency: " + (total/(runs-1)));
+  //        }
+  //    }
+--- 702,708 ----
+  //            return name;
+  //        }
+  //
+! //        public void printstats() {
+  //            System.out.println(this + " avg. latency: " + (total/(runs-1)));
+  //        }
+  //    }
+diff -pcr misc/hsqldb/src/org/hsqldb/lib/IntKeyIntValueHashMap.java misc/build/hsqldb/src/org/hsqldb/lib/IntKeyIntValueHashMap.java
+*** misc/hsqldb/src/org/hsqldb/lib/IntKeyIntValueHashMap.java	2005-10-23 20:26:24.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/lib/IntKeyIntValueHashMap.java	2007-02-28 12:32:48.000000000 +0100
+*************** import org.hsqldb.store.BaseHashMap;
+*** 42,49 ****
+   */
+  public class IntKeyIntValueHashMap extends BaseHashMap {
+  
+!     private Set        keySet;
+!     private Collection values;
+  
+      public IntKeyIntValueHashMap() {
+          this(16, 0.75f);
+--- 42,49 ----
+   */
+  public class IntKeyIntValueHashMap extends BaseHashMap {
+  
+!     public Set        keySet;
+!     public Collection values;
+  
+      public IntKeyIntValueHashMap() {
+          this(16, 0.75f);
+diff -pcr misc/hsqldb/src/org/hsqldb/lib/LongKeyIntValueHashMap.java misc/build/hsqldb/src/org/hsqldb/lib/LongKeyIntValueHashMap.java
+*** misc/hsqldb/src/org/hsqldb/lib/LongKeyIntValueHashMap.java	2005-10-23 20:26:24.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/lib/LongKeyIntValueHashMap.java	2007-02-28 12:32:48.000000000 +0100
+*************** import org.hsqldb.store.BaseHashMap;
+*** 42,49 ****
+   */
+  public class LongKeyIntValueHashMap extends BaseHashMap {
+  
+!     private Set        keySet;
+!     private Collection values;
+  
+      public LongKeyIntValueHashMap() {
+          this(16, 0.75f);
+--- 42,49 ----
+   */
+  public class LongKeyIntValueHashMap extends BaseHashMap {
+  
+!     public Set        keySet;
+!     public Collection values;
+  
+      public LongKeyIntValueHashMap() {
+          this(16, 0.75f);
+diff -pcr misc/hsqldb/src/org/hsqldb/lib/MD5.java misc/build/hsqldb/src/org/hsqldb/lib/MD5.java
+*** misc/hsqldb/src/org/hsqldb/lib/MD5.java	2004-01-12 20:30:40.000000000 +0100
+--- misc/build/hsqldb/src/org/hsqldb/lib/MD5.java	2007-02-28 12:32:48.000000000 +0100
+*************** public final class MD5 {
+*** 83,89 ****
+      /**
+       * The jce MD5 message digest generator.
+       */
+!     private static MessageDigest md5;
+  
+      /**
+       * Retrieves a hexidecimal character sequence representing the MD5
+--- 83,89 ----
+      /**
+       * The jce MD5 message digest generator.
+       */
+!     public static MessageDigest md5;
+  
+      /**
+       * Retrieves a hexidecimal character sequence representing the MD5
+diff -pcr misc/hsqldb/src/org/hsqldb/lib/SimpleLog.java misc/build/hsqldb/src/org/hsqldb/lib/SimpleLog.java
+*** misc/hsqldb/src/org/hsqldb/lib/SimpleLog.java	2006-07-17 00:29:33.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/lib/SimpleLog.java	2007-02-28 12:32:48.000000000 +0100
+*************** public class SimpleLog {
+*** 54,61 ****
+      public static int   LOG_NONE   = 0;
+      public static int   LOG_ERROR  = 1;
+      public static int   LOG_NORMAL = 2;
+!     private PrintWriter writer;
+!     private int         level;
+  
+      public SimpleLog(String path, int level, boolean useFile) {
+  
+--- 54,61 ----
+      public static int   LOG_NONE   = 0;
+      public static int   LOG_ERROR  = 1;
+      public static int   LOG_NORMAL = 2;
+!     public PrintWriter writer;
+!     public int         level;
+  
+      public SimpleLog(String path, int level, boolean useFile) {
+  
+*************** public class SimpleLog {
+*** 72,78 ****
+          }
+      }
+  
+!     private void makeLog(File file) {
+  
+          try {
+              FileUtil.makeParentDirectories(file);
+--- 72,78 ----
+          }
+      }
+  
+!     public void makeLog(File file) {
+  
+          try {
+              FileUtil.makeParentDirectories(file);
+diff -pcr misc/hsqldb/src/org/hsqldb/lib/Sort.java misc/build/hsqldb/src/org/hsqldb/lib/Sort.java
+*** misc/hsqldb/src/org/hsqldb/lib/Sort.java	2005-10-23 20:26:24.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/lib/Sort.java	2007-02-28 12:32:48.000000000 +0100
+*************** public class Sort {
+*** 146,152 ****
+      /**
+       * Swaps the a'th and b'th elements of the specified Row array.
+       */
+!     private static void swap(Object[] w, int a, int b) {
+  
+          Object t = w[a];
+  
+--- 146,152 ----
+      /**
+       * Swaps the a'th and b'th elements of the specified Row array.
+       */
+!     public static void swap(Object[] w, int a, int b) {
+  
+          Object t = w[a];
+  
+diff -pcr misc/hsqldb/src/org/hsqldb/lib/StopWatch.java misc/build/hsqldb/src/org/hsqldb/lib/StopWatch.java
+*** misc/hsqldb/src/org/hsqldb/lib/StopWatch.java	2005-10-23 20:26:24.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/lib/StopWatch.java	2007-02-28 12:32:48.000000000 +0100
+*************** public class StopWatch {
+*** 51,64 ****
+       * from stopped to running state, as reported
+       * by System.currentTimeMillis().
+       */
+!     private long startTime;
+!     private long lastStart;
+  
+      /**
+       * The accumulated running time of this object since
+       * it was last zeroed.
+       */
+!     private long total;
+  
+      /** Flags if this object is started or stopped. */
+      boolean running = false;
+--- 51,64 ----
+       * from stopped to running state, as reported
+       * by System.currentTimeMillis().
+       */
+!     public long startTime;
+!     public long lastStart;
+  
+      /**
+       * The accumulated running time of this object since
+       * it was last zeroed.
+       */
+!     public long total;
+  
+      /** Flags if this object is started or stopped. */
+      boolean running = false;
+diff -pcr misc/hsqldb/src/org/hsqldb/lib/StringConverter.java misc/build/hsqldb/src/org/hsqldb/lib/StringConverter.java
+*** misc/hsqldb/src/org/hsqldb/lib/StringConverter.java	2006-07-21 15:00:48.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/lib/StringConverter.java	2007-02-28 12:32:48.000000000 +0100
+*************** import java.io.UTFDataFormatException;
+*** 87,98 ****
+  // fredt@users 20020328 - patch 1.7.0 by fredt - error trapping
+  public class StringConverter {
+  
+!     private static final byte[] HEXBYTES = {
+          (byte) '0', (byte) '1', (byte) '2', (byte) '3', (byte) '4',
+          (byte) '5', (byte) '6', (byte) '7', (byte) '8', (byte) '9',
+          (byte) 'a', (byte) 'b', (byte) 'c', (byte) 'd', (byte) 'e', (byte) 'f'
+      };
+!     private static final String HEXINDEX = "0123456789abcdef0123456789ABCDEF";
+  
+      /**
+       * Converts a String into a byte array by using a big-endian two byte
+--- 87,98 ----
+  // fredt@users 20020328 - patch 1.7.0 by fredt - error trapping
+  public class StringConverter {
+  
+!     public static final byte[] HEXBYTES = {
+          (byte) '0', (byte) '1', (byte) '2', (byte) '3', (byte) '4',
+          (byte) '5', (byte) '6', (byte) '7', (byte) '8', (byte) '9',
+          (byte) 'a', (byte) 'b', (byte) 'c', (byte) 'd', (byte) 'e', (byte) 'f'
+      };
+!     public static final String HEXINDEX = "0123456789abcdef0123456789ABCDEF";
+  
+      /**
+       * Converts a String into a byte array by using a big-endian two byte
+diff -pcr misc/hsqldb/src/org/hsqldb/lib/StringInputStream.java misc/build/hsqldb/src/org/hsqldb/lib/StringInputStream.java
+*** misc/hsqldb/src/org/hsqldb/lib/StringInputStream.java	2005-10-23 20:26:24.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/lib/StringInputStream.java	2007-02-28 12:32:48.000000000 +0100
+*************** import java.io.InputStream;
+*** 42,51 ****
+   */
+  public class StringInputStream extends InputStream {
+  
+!     protected int    strOffset  = 0;
+!     protected int    charOffset = 0;
+!     protected int    available;
+!     protected String str;
+  
+      public StringInputStream(String s) {
+          str       = s;
+--- 42,51 ----
+   */
+  public class StringInputStream extends InputStream {
+  
+!     public int    strOffset  = 0;
+!     public int    charOffset = 0;
+!     public int    available;
+!     public String str;
+  
+      public StringInputStream(String s) {
+          str       = s;
+diff -pcr misc/hsqldb/src/org/hsqldb/lib/WrapperIterator.java misc/build/hsqldb/src/org/hsqldb/lib/WrapperIterator.java
+*** misc/hsqldb/src/org/hsqldb/lib/WrapperIterator.java	2005-10-23 20:26:24.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/lib/WrapperIterator.java	2007-02-28 12:32:48.000000000 +0100
+*************** import java.util.NoSuchElementException;
+*** 46,62 ****
+   */
+  public class WrapperIterator implements Iterator {
+  
+!     private static final Object[] emptyelements = new Object[0];
+!     private Object[]              elements;
+!     private int                   i;
+  
+      // chained iterators
+!     private boolean  chained;
+!     private Iterator it1;
+!     private Iterator it2;
+  
+      /** return only not null elements */
+!     private boolean notNull;
+  
+      /**
+       * Constructor for an empty iterator. <p>
+--- 46,62 ----
+   */
+  public class WrapperIterator implements Iterator {
+  
+!     public static final Object[] emptyelements = new Object[0];
+!     public Object[]              elements;
+!     public int                   i;
+  
+      // chained iterators
+!     public boolean  chained;
+!     public Iterator it1;
+!     public Iterator it2;
+  
+      /** return only not null elements */
+!     public boolean notNull;
+  
+      /**
+       * Constructor for an empty iterator. <p>
+diff -pcr misc/hsqldb/src/org/hsqldb/lib/ZipUnzipFile.java misc/build/hsqldb/src/org/hsqldb/lib/ZipUnzipFile.java
+*** misc/hsqldb/src/org/hsqldb/lib/ZipUnzipFile.java	2006-07-15 22:16:42.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/lib/ZipUnzipFile.java	2007-02-28 12:32:48.000000000 +0100
+*************** import java.util.zip.InflaterInputStream
+*** 86,92 ****
+   */
+  public class ZipUnzipFile {
+  
+!     private static final int COPY_BLOCK_SIZE = 1 << 16;
+  
+      public static void compressFile(String infilename, String outfilename,
+                                      FileAccess storage) throws IOException {
+--- 86,92 ----
+   */
+  public class ZipUnzipFile {
+  
+!     public static final int COPY_BLOCK_SIZE = 1 << 16;
+  
+      public static void compressFile(String infilename, String outfilename,
+                                      FileAccess storage) throws IOException {
+diff -pcr misc/hsqldb/src/org/hsqldb/Library.java misc/build/hsqldb/src/org/hsqldb/Library.java
+*** misc/hsqldb/src/org/hsqldb/Library.java	2006-07-21 15:37:53.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/Library.java	2007-02-28 12:32:48.000000000 +0100
+*************** public class Library {
+*** 291,297 ****
+          }
+      };
+  
+!     private Library() {}
+  
+      static HashMap getAliasMap() {
+  
+--- 291,297 ----
+          }
+      };
+  
+!     public Library() {}
+  
+      static HashMap getAliasMap() {
+  
+*************** public class Library {
+*** 305,318 ****
+          return h;
+      }
+  
+!     private static void register(HashMap h, String[][] s) {
+  
+          for (int i = 0; i < s.length; i++) {
+              h.put(s[i][0], s[i][1]);
+          }
+      }
+  
+!     private static final Random rRandom = new Random();
+  
+      // NUMERIC FUNCTIONS
+  // fredt@users 20020220 - patch 489184 by xclayl@users - thread safety
+--- 305,318 ----
+          return h;
+      }
+  
+!     public static void register(HashMap h, String[][] s) {
+  
+          for (int i = 0; i < s.length; i++) {
+              h.put(s[i][0], s[i][1]);
+          }
+      }
+  
+!     public static final Random rRandom = new Random();
+  
+      // NUMERIC FUNCTIONS
+  // fredt@users 20020220 - patch 489184 by xclayl@users - thread safety
+*************** public class Library {
+*** 361,367 ****
+      }
+  
+      // this magic number works for 100000000000000; but not for 0.1 and 0.01
+!     private static final double LOG10_FACTOR = 0.43429448190325183;
+  
+      /**
+       * Returns the base 10 logarithm of the given <code>double</code> value.
+--- 361,367 ----
+      }
+  
+      // this magic number works for 100000000000000; but not for 0.1 and 0.01
+!     public static final double LOG10_FACTOR = 0.43429448190325183;
+  
+      /**
+       * Returns the base 10 logarithm of the given <code>double</code> value.
+*************** public class Library {
+*** 1656,1662 ****
+       *           from this value to return the number of date-parts
+       *           between the two arguments.
+       */
+!     private static long getElapsed(int field, java.util.Date d1,
+                                     java.util.Date d2) {
+  
+          // can we do this very simply?
+--- 1656,1662 ----
+       *           from this value to return the number of date-parts
+       *           between the two arguments.
+       */
+!     public static long getElapsed(int field, java.util.Date d1,
+                                     java.util.Date d2) {
+  
+          // can we do this very simply?
+*************** public class Library {
+*** 1947,1953 ****
+  /** @todo  see bitxor and datediff numbering */
+  
+      //
+!     private static final IntValueHashMap functionMap =
+          new IntValueHashMap(67);
+      static final Double piValue = new Double(Library.pi());
+  
+--- 1947,1953 ----
+  /** @todo  see bitxor and datediff numbering */
+  
+      //
+!     public static final IntValueHashMap functionMap =
+          new IntValueHashMap(67);
+      static final Double piValue = new Double(Library.pi());
+  
+diff -pcr misc/hsqldb/src/org/hsqldb/Like.java misc/build/hsqldb/src/org/hsqldb/Like.java
+*** misc/hsqldb/src/org/hsqldb/Like.java	2005-10-23 20:26:25.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/Like.java	2007-02-28 12:32:48.000000000 +0100
+*************** import org.hsqldb.lib.StringUtil;
+*** 82,93 ****
+  // fredt@users 20031006 - patch 1.7.2 - reuse Like objects for all rows
+  class Like {
+  
+!     private char[]   cLike;
+!     private int[]    wildCardType;
+!     private int      iLen;
+!     private boolean  isIgnoreCase;
+!     private int      iFirstWildCard;
+!     private boolean  isNull;
+      Character        escapeChar;
+      boolean          hasCollation;
+      boolean          optimised;
+--- 82,93 ----
+  // fredt@users 20031006 - patch 1.7.2 - reuse Like objects for all rows
+  class Like {
+  
+!     public char[]   cLike;
+!     public int[]    wildCardType;
+!     public int      iLen;
+!     public boolean  isIgnoreCase;
+!     public int      iFirstWildCard;
+!     public boolean  isNull;
+      Character        escapeChar;
+      boolean          hasCollation;
+      boolean          optimised;
+*************** class Like {
+*** 121,127 ****
+          normalize(session, s);
+      }
+  
+!     private String getStartsWith() {
+  
+          if (iLen == 0) {
+              return "";
+--- 121,127 ----
+          normalize(session, s);
+      }
+  
+!     public String getStartsWith() {
+  
+          if (iLen == 0) {
+              return "";
+*************** class Like {
+*** 174,180 ****
+       *
+       * @return
+       */
+!     private boolean compareAt(String s, int i, int j, int jLen) {
+  
+          for (; i < iLen; i++) {
+              switch (wildCardType[i]) {
+--- 174,180 ----
+       *
+       * @return
+       */
+!     public boolean compareAt(String s, int i, int j, int jLen) {
+  
+          for (; i < iLen; i++) {
+              switch (wildCardType[i]) {
+*************** class Like {
+*** 223,229 ****
+       * @param pattern
+       * @param b
+       */
+!     private void normalize(Session session, String pattern) {
+  
+          isNull = pattern == null;
+  
+--- 223,229 ----
+       * @param pattern
+       * @param b
+       */
+!     public void normalize(Session session, String pattern) {
+  
+          isNull = pattern == null;
+  
+diff -pcr misc/hsqldb/src/org/hsqldb/MemoryNode.java misc/build/hsqldb/src/org/hsqldb/MemoryNode.java
+*** misc/hsqldb/src/org/hsqldb/MemoryNode.java	2005-10-23 20:26:25.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/MemoryNode.java	2007-02-28 12:32:48.000000000 +0100
+*************** package org.hsqldb;
+*** 79,85 ****
+   */
+  class MemoryNode extends BaseMemoryNode {
+  
+!     protected Row rData;
+  
+      /**
+       *  A MemoreyNode is permenently linked with the row it refers to.
+--- 79,85 ----
+   */
+  class MemoryNode extends BaseMemoryNode {
+  
+!     public Row rData;
+  
+      /**
+       *  A MemoreyNode is permenently linked with the row it refers to.
+diff -pcr misc/hsqldb/src/org/hsqldb/NumberSequence.java misc/build/hsqldb/src/org/hsqldb/NumberSequence.java
+*** misc/hsqldb/src/org/hsqldb/NumberSequence.java	2005-10-23 19:40:13.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/NumberSequence.java	2007-02-28 12:32:48.000000000 +0100
+*************** public class NumberSequence {
+*** 45,59 ****
+      HsqlName name;
+  
+      // original start value - used in CREATE and ALTER commands
+!     private long startValue;
+  
+      // present value
+!     private long currValue;
+  
+      // last value
+!     private long lastValue;
+!     private long increment;
+!     private int  dataType;
+  
+      /**
+       * constructor with initial value and increment;
+--- 45,59 ----
+      HsqlName name;
+  
+      // original start value - used in CREATE and ALTER commands
+!     public long startValue;
+  
+      // present value
+!     public long currValue;
+  
+      // last value
+!     public long lastValue;
+!     public long increment;
+!     public int  dataType;
+  
+      /**
+       * constructor with initial value and increment;
+diff -pcr misc/hsqldb/src/org/hsqldb/Parser.java misc/build/hsqldb/src/org/hsqldb/Parser.java
+*** misc/hsqldb/src/org/hsqldb/Parser.java	2006-06-14 14:24:48.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/Parser.java	2007-02-28 12:32:48.000000000 +0100
+*************** import org.hsqldb.lib.HashSet;
+*** 122,141 ****
+   */
+  class Parser {
+  
+!     private Database  database;
+!     private Tokenizer tokenizer;
+!     private Session   session;
+!     private String    sSchema;
+!     private String    sTable;
+!     private String    sToken;
+!     private boolean   wasQuoted;
+!     private Object    oData;
+!     private int       iType;
+!     private int       iToken;
+  
+      //
+!     private int           subQueryLevel;
+!     private HsqlArrayList subQueryList = new HsqlArrayList();
+  
+      /**
+       *  Constructs a new Parser object with the given context.
+--- 122,141 ----
+   */
+  class Parser {
+  
+!     public Database  database;
+!     public Tokenizer tokenizer;
+!     public Session   session;
+!     public String    sSchema;
+!     public String    sTable;
+!     public String    sToken;
+!     public boolean   wasQuoted;
+!     public Object    oData;
+!     public int       iType;
+!     public int       iToken;
+  
+      //
+!     public int           subQueryLevel;
+!     public HsqlArrayList subQueryList = new HsqlArrayList();
+  
+      /**
+       *  Constructs a new Parser object with the given context.
+*************** class Parser {
+*** 746,752 ****
+  // in other RDBMS's
+  // "SELECT LIMIT n 0" discards the first n rows and returns the remaining rows
+  // fredt@users 20020225 - patch 456679 by hiep256 - TOP keyword
+!     private void parseLimit(String token, Select select,
+                              boolean isEnd) throws HsqlException {
+  
+          if (select.limitCondition != null) {
+--- 746,752 ----
+  // in other RDBMS's
+  // "SELECT LIMIT n 0" discards the first n rows and returns the remaining rows
+  // fredt@users 20020225 - patch 456679 by hiep256 - TOP keyword
+!     public void parseLimit(String token, Select select,
+                              boolean isEnd) throws HsqlException {
+  
+          if (select.limitCondition != null) {
+*************** class Parser {
+*** 825,831 ****
+          throw Trace.error(Trace.WRONG_DATA_TYPE, messageid);
+      }
+  
+!     private void parseOrderBy(Select select,
+                                HsqlArrayList vcolumn) throws HsqlException {
+  
+          String token;
+--- 825,831 ----
+          throw Trace.error(Trace.WRONG_DATA_TYPE, messageid);
+      }
+  
+!     public void parseOrderBy(Select select,
+                                HsqlArrayList vcolumn) throws HsqlException {
+  
+          String token;
+*************** class Parser {
+*** 855,861 ****
+          select.iOrderLen = len;
+      }
+  
+!     private void resolveSelectTableFilter(Select select,
+                                            HsqlArrayList vcolumn,
+                                            HsqlArrayList vfilter)
+                                            throws HsqlException {
+--- 855,861 ----
+          select.iOrderLen = len;
+      }
+  
+!     public void resolveSelectTableFilter(Select select,
+                                            HsqlArrayList vcolumn,
+                                            HsqlArrayList vfilter)
+                                            throws HsqlException {
+*************** class Parser {
+*** 947,953 ****
+       * @throws HsqlException if an ambiguous reference to an alias or
+       *      non-integer column index is encountered
+       */
+!     private static Expression resolveOrderByExpression(Expression e,
+              Select select, HsqlArrayList vcolumn) throws HsqlException {
+  
+          int     visiblecols = select.iResultLen;
+--- 947,953 ----
+       * @throws HsqlException if an ambiguous reference to an alias or
+       *      non-integer column index is encountered
+       */
+!     public static Expression resolveOrderByExpression(Expression e,
+              Select select, HsqlArrayList vcolumn) throws HsqlException {
+  
+          int     visiblecols = select.iResultLen;
+*************** class Parser {
+*** 991,997 ****
+          return e;
+      }
+  
+!     private static Expression resolveOrderByColumnIndex(Expression e,
+              HsqlArrayList vcolumn, int visiblecols) throws HsqlException {
+  
+          // order by 1,2,3
+--- 991,997 ----
+          return e;
+      }
+  
+!     public static Expression resolveOrderByColumnIndex(Expression e,
+              HsqlArrayList vcolumn, int visiblecols) throws HsqlException {
+  
+          // order by 1,2,3
+*************** class Parser {
+*** 1010,1016 ****
+          throw Trace.error(Trace.INVALID_ORDER_BY);
+      }
+  
+!     private TableFilter parseSimpleTableFilter(int type)
+      throws HsqlException {
+  
+          String alias  = null;
+--- 1010,1016 ----
+          throw Trace.error(Trace.INVALID_ORDER_BY);
+      }
+  
+!     public TableFilter parseSimpleTableFilter(int type)
+      throws HsqlException {
+  
+          String alias  = null;
+*************** class Parser {
+*** 1042,1048 ****
+       * @return a newly constructed TableFilter object
+       * @throws  HsqlException if a parsing error occurs
+       */
+!     private TableFilter parseTableFilter(boolean outerjoin)
+      throws HsqlException {
+  
+          Table          t          = null;
+--- 1042,1048 ----
+       * @return a newly constructed TableFilter object
+       * @throws  HsqlException if a parsing error occurs
+       */
+!     public TableFilter parseTableFilter(boolean outerjoin)
+      throws HsqlException {
+  
+          Table          t          = null;
+*************** class Parser {
+*** 1125,1131 ****
+       * @param  e2
+       * @return
+       */
+!     private static Expression addCondition(Expression e1, Expression e2) {
+  
+          if (e1 == null) {
+              return e2;
+--- 1125,1131 ----
+       * @param  e2
+       * @return
+       */
+!     public static Expression addCondition(Expression e1, Expression e2) {
+  
+          if (e1 == null) {
+              return e2;
+*************** class Parser {
+*** 1149,1155 ****
+       *      in the join
+       * @return a new Expression object; the conjunction of e1 and e2
+       */
+!     private static Expression addJoinCondition(Expression e1, Expression e2,
+              TableFilter tf, boolean outer) throws HsqlException {
+  
+          if (!e2.setForJoin(tf, outer)) {
+--- 1149,1155 ----
+       *      in the join
+       * @return a new Expression object; the conjunction of e1 and e2
+       */
+!     public static Expression addJoinCondition(Expression e1, Expression e2,
+              TableFilter tf, boolean outer) throws HsqlException {
+  
+          if (!e2.setForJoin(tf, outer)) {
+*************** class Parser {
+*** 1176,1182 ****
+          return r;
+      }
+  
+!     private Expression readAggregate() throws HsqlException {
+  
+          boolean distinct = false;
+          boolean all      = false;
+--- 1176,1182 ----
+          return r;
+      }
+  
+!     public Expression readAggregate() throws HsqlException {
+  
+          boolean distinct = false;
+          boolean all      = false;
+*************** class Parser {
+*** 1221,1227 ****
+       * @return a disjuntion, possibly degenerate
+       * @throws  HsqlException
+       */
+!     private Expression readOr() throws HsqlException {
+  
+          Expression r = readAnd();
+  
+--- 1221,1227 ----
+       * @return a disjuntion, possibly degenerate
+       * @throws  HsqlException
+       */
+!     public Expression readOr() throws HsqlException {
+  
+          Expression r = readAnd();
+  
+*************** class Parser {
+*** 1243,1249 ****
+       * @return a conjunction, possibly degenerate
+       * @throws  HsqlException
+       */
+!     private Expression readAnd() throws HsqlException {
+  
+          Expression r = readCondition();
+  
+--- 1243,1249 ----
+       * @return a conjunction, possibly degenerate
+       * @throws  HsqlException
+       */
+!     public Expression readAnd() throws HsqlException {
+  
+          Expression r = readCondition();
+  
+*************** class Parser {
+*** 1265,1271 ****
+       * @return a predicate, possibly composite
+       * @throws  HsqlException
+       */
+!     private Expression readCondition() throws HsqlException {
+  
+          switch (iToken) {
+  
+--- 1265,1271 ----
+       * @return a predicate, possibly composite
+       * @throws  HsqlException
+       */
+!     public Expression readCondition() throws HsqlException {
+  
+          switch (iToken) {
+  
+*************** class Parser {
+*** 1382,1388 ****
+          }
+      }
+  
+!     private Expression parseLikePredicate(Expression a) throws HsqlException {
+  
+          read();
+  
+--- 1382,1388 ----
+          }
+      }
+  
+!     public Expression parseLikePredicate(Expression a) throws HsqlException {
+  
+          read();
+  
+*************** class Parser {
+*** 1420,1426 ****
+          return a;
+      }
+  
+!     private Expression parseBetweenPredicate(Expression a)
+      throws HsqlException {
+  
+          read();
+--- 1420,1426 ----
+          return a;
+      }
+  
+!     public Expression parseBetweenPredicate(Expression a)
+      throws HsqlException {
+  
+          read();
+*************** class Parser {
+*** 1446,1452 ****
+          return new Expression(Expression.AND, l, h);
+      }
+  
+!     private Expression parseInPredicate(Expression a) throws HsqlException {
+  
+          int type = iToken;
+  
+--- 1446,1452 ----
+          return new Expression(Expression.AND, l, h);
+      }
+  
+!     public Expression parseInPredicate(Expression a) throws HsqlException {
+  
+          int type = iToken;
+  
+*************** class Parser {
+*** 1504,1510 ****
+          return new Expression(type, a, b);
+      }
+  
+!     private Expression parseAllAnyPredicate() throws HsqlException {
+  
+          int type = iToken;
+  
+--- 1504,1510 ----
+          return new Expression(type, a, b);
+      }
+  
+!     public Expression parseAllAnyPredicate() throws HsqlException {
+  
+          int type = iToken;
+  
+*************** class Parser {
+*** 1544,1550 ****
+       * @param  type
+       * @throws  HsqlException
+       */
+!     private void readThis(int type) throws HsqlException {
+          Trace.check(iToken == type, Trace.UNEXPECTED_TOKEN);
+          read();
+      }
+--- 1544,1550 ----
+       * @param  type
+       * @throws  HsqlException
+       */
+!     public void readThis(int type) throws HsqlException {
+          Trace.check(iToken == type, Trace.UNEXPECTED_TOKEN);
+          read();
+      }
+*************** class Parser {
+*** 1555,1561 ****
+       * @return a concatenation, possibly degenerate
+       * @throws  HsqlException
+       */
+!     private Expression readConcat() throws HsqlException {
+  
+          Expression r = readSum();
+  
+--- 1555,1561 ----
+       * @return a concatenation, possibly degenerate
+       * @throws  HsqlException
+       */
+!     public Expression readConcat() throws HsqlException {
+  
+          Expression r = readSum();
+  
+*************** class Parser {
+*** 1592,1598 ****
+       * @return  a summation, possibly degenerate
+       * @throws  HsqlException
+       */
+!     private Expression readSum() throws HsqlException {
+  
+          Expression r = readFactor();
+  
+--- 1592,1598 ----
+       * @return  a summation, possibly degenerate
+       * @throws  HsqlException
+       */
+!     public Expression readSum() throws HsqlException {
+  
+          Expression r = readFactor();
+  
+*************** class Parser {
+*** 1623,1629 ****
+       * @return  a product, possibly degenerate
+       * @throws  HsqlException
+       */
+!     private Expression readFactor() throws HsqlException {
+  
+          Expression r = readTerm();
+  
+--- 1623,1629 ----
+       * @return  a product, possibly degenerate
+       * @throws  HsqlException
+       */
+!     public Expression readFactor() throws HsqlException {
+  
+          Expression r = readTerm();
+  
+*************** class Parser {
+*** 1645,1651 ****
+       * @return  a term, possibly composite
+       * @throws  HsqlException
+       */
+!     private Expression readTerm() throws HsqlException {
+  
+          Expression r = null;
+  
+--- 1645,1651 ----
+       * @return  a term, possibly composite
+       * @throws  HsqlException
+       */
+!     public Expression readTerm() throws HsqlException {
+  
+          Expression r = null;
+  
+*************** class Parser {
+*** 1832,1838 ****
+      /**
+       * Reads part of a CASE .. WHEN  expression
+       */
+!     private Expression parseCaseWhen(Expression r) throws HsqlException {
+  
+          readThis(Expression.WHEN);
+  
+--- 1832,1838 ----
+      /**
+       * Reads part of a CASE .. WHEN  expression
+       */
+!     public Expression parseCaseWhen(Expression r) throws HsqlException {
+  
+          readThis(Expression.WHEN);
+  
+*************** class Parser {
+*** 1858,1864 ****
+      /**
+       * reads a CASEWHEN expression
+       */
+!     private Expression readCaseWhenExpression() throws HsqlException {
+  
+          int        type = iToken;
+          Expression r    = null;
+--- 1858,1864 ----
+      /**
+       * reads a CASEWHEN expression
+       */
+!     public Expression readCaseWhenExpression() throws HsqlException {
+  
+          int        type = iToken;
+          Expression r    = null;
+*************** class Parser {
+*** 1886,1892 ****
+      /**
+       * Reads a CAST or CONVERT expression
+       */
+!     private Expression readCastExpression() throws HsqlException {
+  
+          boolean isConvert = iToken == Expression.CONVERT;
+  
+--- 1886,1892 ----
+      /**
+       * Reads a CAST or CONVERT expression
+       */
+!     public Expression readCastExpression() throws HsqlException {
+  
+          boolean isConvert = iToken == Expression.CONVERT;
+  
+*************** class Parser {
+*** 1946,1952 ****
+      /**
+       * reads a Column or Function expression
+       */
+!     private Expression readColumnExpression() throws HsqlException {
+  
+          String     name = sToken;
+          Expression r    = new Expression(sTable, name, wasQuoted);
+--- 1946,1952 ----
+      /**
+       * reads a Column or Function expression
+       */
+!     public Expression readColumnExpression() throws HsqlException {
+  
+          String     name = sToken;
+          Expression r    = new Expression(sTable, name, wasQuoted);
+*************** class Parser {
+*** 1995,2001 ****
+      /**
+       * reads a CONCAT expression
+       */
+!     private Expression readConcatExpression() throws HsqlException {
+  
+          int type = iToken;
+  
+--- 1995,2001 ----
+      /**
+       * reads a CONCAT expression
+       */
+!     public Expression readConcatExpression() throws HsqlException {
+  
+          int type = iToken;
+  
+*************** class Parser {
+*** 2016,2022 ****
+      /**
+       * Reads a NULLIF expression
+       */
+!     private Expression readNullIfExpression() throws HsqlException {
+  
+          // turn into a CASEWHEN
+          read();
+--- 2016,2022 ----
+      /**
+       * Reads a NULLIF expression
+       */
+!     public Expression readNullIfExpression() throws HsqlException {
+  
+          // turn into a CASEWHEN
+          read();
+*************** class Parser {
+*** 2041,2047 ****
+      /**
+       * Reads a COALESE or IFNULL expression
+       */
+!     private Expression readCoalesceExpression() throws HsqlException {
+  
+          Expression r = null;
+  
+--- 2041,2047 ----
+      /**
+       * Reads a COALESE or IFNULL expression
+       */
+!     public Expression readCoalesceExpression() throws HsqlException {
+  
+          Expression r = null;
+  
+*************** class Parser {
+*** 2085,2091 ****
+      /**
+       * Reads an EXTRACT expression
+       */
+!     private Expression readExtractExpression() throws HsqlException {
+  
+          read();
+          readThis(Expression.OPEN);
+--- 2085,2091 ----
+      /**
+       * Reads an EXTRACT expression
+       */
+!     public Expression readExtractExpression() throws HsqlException {
+  
+          read();
+          readThis(Expression.OPEN);
+*************** class Parser {
+*** 2112,2118 ****
+      /**
+       * Reads a POSITION expression
+       */
+!     private Expression readPositionExpression() throws HsqlException {
+  
+          read();
+          readThis(Expression.OPEN);
+--- 2112,2118 ----
+      /**
+       * Reads a POSITION expression
+       */
+!     public Expression readPositionExpression() throws HsqlException {
+  
+          read();
+          readThis(Expression.OPEN);
+*************** class Parser {
+*** 2131,2137 ****
+      /**
+       * Reads a SUBSTRING expression
+       */
+!     private Expression readSubstringExpression() throws HsqlException {
+  
+          boolean commas = false;
+  
+--- 2131,2137 ----
+      /**
+       * Reads a SUBSTRING expression
+       */
+!     public Expression readSubstringExpression() throws HsqlException {
+  
+          boolean commas = false;
+  
+*************** class Parser {
+*** 2172,2178 ****
+          return new Expression(f);
+      }
+  
+!     private Expression readSequenceExpression() throws HsqlException {
+  
+          tokenizer.getThis(Token.T_VALUE);
+          tokenizer.getThis(Token.T_FOR);
+--- 2172,2178 ----
+          return new Expression(f);
+      }
+  
+!     public Expression readSequenceExpression() throws HsqlException {
+  
+          tokenizer.getThis(Token.T_VALUE);
+          tokenizer.getThis(Token.T_FOR);
+*************** class Parser {
+*** 2196,2202 ****
+      /**
+       * Reads a TRIM expression
+       */
+!     private Expression readTrimExpression() throws HsqlException {
+  
+          read();
+          readThis(Expression.OPEN);
+--- 2196,2202 ----
+      /**
+       * Reads a TRIM expression
+       */
+!     public Expression readTrimExpression() throws HsqlException {
+  
+          read();
+          readThis(Expression.OPEN);
+*************** class Parser {
+*** 2310,2316 ****
+       *
+       * @throws  HsqlException
+       */
+!     private void read() throws HsqlException {
+  
+          sToken    = tokenizer.getString();
+          wasQuoted = tokenizer.wasQuotedIdentifier();
+--- 2310,2316 ----
+       *
+       * @throws  HsqlException
+       */
+!     public void read() throws HsqlException {
+  
+          sToken    = tokenizer.getString();
+          wasQuoted = tokenizer.wasQuotedIdentifier();
+*************** class Parser {
+*** 2422,2433 ****
+       *
+       * @throws HsqlException if a tokenization error occurs
+       */
+!     private void readToken() throws HsqlException {
+          sToken = tokenizer.getString();
+          iToken = tokenSet.get(sToken, -1);
+      }
+  
+!     private static IntValueHashMap tokenSet = new IntValueHashMap(37);
+  
+      static {
+          tokenSet.put(Token.T_COMMA, Expression.COMMA);
+--- 2422,2433 ----
+       *
+       * @throws HsqlException if a tokenization error occurs
+       */
+!     public void readToken() throws HsqlException {
+          sToken = tokenizer.getString();
+          iToken = tokenSet.get(sToken, -1);
+      }
+  
+!     public static IntValueHashMap tokenSet = new IntValueHashMap(37);
+  
+      static {
+          tokenSet.put(Token.T_COMMA, Expression.COMMA);
+*************** class Parser {
+*** 2493,2500 ****
+  // boucherb@users 20030411 - patch 1.7.2 - for prepared statements
+  // ---------------------------------------------------------------
+      HsqlArrayList                     parameters   = new HsqlArrayList();
+!     private static final Expression[] noParameters = new Expression[0];
+!     private static final SubQuery[]   noSubqueries = new SubQuery[0];
+  
+      /**
+       *  Destructive get method
+--- 2493,2500 ----
+  // boucherb@users 20030411 - patch 1.7.2 - for prepared statements
+  // ---------------------------------------------------------------
+      HsqlArrayList                     parameters   = new HsqlArrayList();
+!     public static final Expression[] noParameters = new Expression[0];
+!     public static final SubQuery[]   noSubqueries = new SubQuery[0];
+  
+      /**
+       *  Destructive get method
+*************** class Parser {
+*** 2593,2599 ****
+          return cs;
+      }
+  
+!     private void getInsertColumnValueExpressions(Table t, Expression[] acve,
+              int len) throws HsqlException {
+  
+          tokenizer.getThis(Token.T_OPENBRACKET);
+--- 2593,2599 ----
+          return cs;
+      }
+  
+!     public void getInsertColumnValueExpressions(Table t, Expression[] acve,
+              int len) throws HsqlException {
+  
+          tokenizer.getThis(Token.T_OPENBRACKET);
+diff -pcr misc/hsqldb/src/org/hsqldb/persist/Cache.java misc/build/hsqldb/src/org/hsqldb/persist/Cache.java
+*** misc/hsqldb/src/org/hsqldb/persist/Cache.java	2006-06-14 13:15:19.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/persist/Cache.java	2007-02-28 12:32:48.000000000 +0100
+*************** import org.hsqldb.store.ObjectCacheHashM
+*** 54,68 ****
+  public class Cache {
+  
+      final DataFileCache                  dataFileCache;
+!     private int                          capacity;         // number of Rows
+!     private long                         bytesCapacity;    // number of bytes
+!     private final CachedObjectComparator rowComparator;
+  
+  //
+!     private CachedObject[] rowTable;
+  
+  //
+!     private final ObjectCacheHashMap cacheMap;
+      long                             cacheBytesLength;
+  
+      // for testing
+--- 54,68 ----
+  public class Cache {
+  
+      final DataFileCache                  dataFileCache;
+!     public int                          capacity;         // number of Rows
+!     public long                         bytesCapacity;    // number of bytes
+!     public final CachedObjectComparator rowComparator;
+  
+  //
+!     public CachedObject[] rowTable;
+  
+  //
+!     public final ObjectCacheHashMap cacheMap;
+      long                             cacheBytesLength;
+  
+      // for testing
+*************** public class Cache {
+*** 148,154 ****
+       * in the cache.
+       *
+       */
+!     private synchronized void cleanUp() throws IOException {
+  
+          int removeCount = cacheMap.size() / 2;
+          int accessTarget = cacheMap.getAccessCountCeiling(removeCount,
+--- 148,154 ----
+       * in the cache.
+       *
+       */
+!     public synchronized void cleanUp() throws IOException {
+  
+          int removeCount = cacheMap.size() / 2;
+          int accessTarget = cacheMap.getAccessCountCeiling(removeCount,
+*************** public class Cache {
+*** 246,252 ****
+          static final int COMPARE_LAST_ACCESS = 0;
+          static final int COMPARE_POSITION    = 1;
+          static final int COMPARE_SIZE        = 2;
+!         private int      compareType;
+  
+          CachedObjectComparator() {}
+  
+--- 246,252 ----
+          static final int COMPARE_LAST_ACCESS = 0;
+          static final int COMPARE_POSITION    = 1;
+          static final int COMPARE_SIZE        = 2;
+!         public int      compareType;
+  
+          CachedObjectComparator() {}
+  
+diff -pcr misc/hsqldb/src/org/hsqldb/persist/DataFileBlockManager.java misc/build/hsqldb/src/org/hsqldb/persist/DataFileBlockManager.java
+*** misc/hsqldb/src/org/hsqldb/persist/DataFileBlockManager.java	2005-11-29 18:34:49.000000000 +0100
+--- misc/build/hsqldb/src/org/hsqldb/persist/DataFileBlockManager.java	2007-02-28 12:32:48.000000000 +0100
+*************** import org.hsqldb.lib.DoubleIntIndex;
+*** 42,54 ****
+   */
+  public class DataFileBlockManager {
+  
+!     private DoubleIntIndex lookup;
+!     private final int      capacity;
+!     private int            midSize;
+!     private final int      scale;
+!     private long           releaseCount;
+!     private long           requestCount;
+!     private long           requestSize;
+  
+      // reporting vars
+      long    lostFreeBlockSize;
+--- 42,54 ----
+   */
+  public class DataFileBlockManager {
+  
+!     public DoubleIntIndex lookup;
+!     public final int      capacity;
+!     public int            midSize;
+!     public final int      scale;
+!     public long           releaseCount;
+!     public long           requestCount;
+!     public long           requestSize;
+  
+      // reporting vars
+      long    lostFreeBlockSize;
+*************** public class DataFileBlockManager {
+*** 140,146 ****
+          return isModified;
+      }
+  
+!     private void resetList() {
+  
+          if (requestCount != 0) {
+              midSize = (int) (requestSize / requestCount);
+--- 140,146 ----
+          return isModified;
+      }
+  
+!     public void resetList() {
+  
+          if (requestCount != 0) {
+              midSize = (int) (requestSize / requestCount);
+*************** public class DataFileBlockManager {
+*** 155,161 ****
+          removeBlocks(first);
+      }
+  
+!     private void removeBlocks(int blocks) {
+  
+          for (int i = 0; i < blocks; i++) {
+              lostFreeBlockSize += lookup.getValue(i);
+--- 155,161 ----
+          removeBlocks(first);
+      }
+  
+!     public void removeBlocks(int blocks) {
+  
+          for (int i = 0; i < blocks; i++) {
+              lostFreeBlockSize += lookup.getValue(i);
+*************** public class DataFileBlockManager {
+*** 164,168 ****
+          lookup.removeRange(0, blocks);
+      }
+  
+!     private void checkIntegrity() throws NullPointerException {}
+  }
+--- 164,168 ----
+          lookup.removeRange(0, blocks);
+      }
+  
+!     public void checkIntegrity() throws NullPointerException {}
+  }
+diff -pcr misc/hsqldb/src/org/hsqldb/persist/DataFileCache.java misc/build/hsqldb/src/org/hsqldb/persist/DataFileCache.java
+*** misc/hsqldb/src/org/hsqldb/persist/DataFileCache.java	2006-07-26 19:01:35.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/persist/DataFileCache.java	2007-02-28 12:32:48.000000000 +0100
+*************** import org.hsqldb.store.BitMap;
+*** 63,69 ****
+   */
+  public class DataFileCache {
+  
+!     protected FileAccess fa;
+  
+      // flags
+      public static final int FLAG_ISSAVED = 2;
+--- 63,69 ----
+   */
+  public class DataFileCache {
+  
+!     public FileAccess fa;
+  
+      // flags
+      public static final int FLAG_ISSAVED = 2;
+*************** public class DataFileCache {
+*** 77,116 ****
+  
+      //
+      DataFileBlockManager     freeBlocks;
+!     private static final int FREE_BLOCKS_COUNT = 512;
+  
+      //
+!     protected String   fileName;
+!     protected String   backupFileName;
+!     protected Database database;
+  
+      // this flag is used externally to determine if a backup is required
+!     protected boolean fileModified;
+!     protected int     cacheFileScale;
+  
+      // post openning constant fields
+!     protected boolean cacheReadonly;
+  
+      // cache operation mode
+!     protected boolean storeOnInsert;
+  
+      //
+!     protected int     cachedRowPadding = 8;
+!     protected boolean hasRowInfo       = false;
+  
+      // reusable input / output streams
+!     protected RowInputInterface  rowIn;
+!     protected RowOutputInterface rowOut;
+  
+      //
+      public long maxDataFileSize;
+  
+      //
+!     protected Storage dataFile;
+!     protected long    fileFreePosition;
+!     protected int     maxCacheSize;             // number of Rows
+!     protected long    maxCacheBytes;            // number of bytes
+!     protected Cache   cache;
+  
+      public DataFileCache(Database db,
+                           String baseFileName) throws HsqlException {
+--- 77,116 ----
+  
+      //
+      DataFileBlockManager     freeBlocks;
+!     public static final int FREE_BLOCKS_COUNT = 512;
+  
+      //
+!     public String   fileName;
+!     public String   backupFileName;
+!     public Database database;
+  
+      // this flag is used externally to determine if a backup is required
+!     public boolean fileModified;
+!     public int     cacheFileScale;
+  
+      // post openning constant fields
+!     public boolean cacheReadonly;
+  
+      // cache operation mode
+!     public boolean storeOnInsert;
+  
+      //
+!     public int     cachedRowPadding = 8;
+!     public boolean hasRowInfo       = false;
+  
+      // reusable input / output streams
+!     public RowInputInterface  rowIn;
+!     public RowOutputInterface rowOut;
+  
+      //
+      public long maxDataFileSize;
+  
+      //
+!     public Storage dataFile;
+!     public long    fileFreePosition;
+!     public int     maxCacheSize;             // number of Rows
+!     public long    maxCacheBytes;            // number of bytes
+!     public Cache   cache;
+  
+      public DataFileCache(Database db,
+                           String baseFileName) throws HsqlException {
+*************** public class DataFileCache {
+*** 123,129 ****
+      /**
+       * initial external parameters are set here.
+       */
+!     protected void initParams(Database database,
+                                String baseFileName) throws HsqlException {
+  
+          fileName       = baseFileName + ".data";
+--- 123,129 ----
+      /**
+       * initial external parameters are set here.
+       */
+!     public void initParams(Database database,
+                                String baseFileName) throws HsqlException {
+  
+          fileName       = baseFileName + ".data";
+*************** public class DataFileCache {
+*** 388,394 ****
+          }
+      }
+  
+!     protected void initBuffers() {
+  
+          if (rowOut == null
+                  || ((RowOutputBinary) rowOut).getBuffer().length > 256) {
+--- 388,394 ----
+          }
+      }
+  
+!     public void initBuffers() {
+  
+          if (rowOut == null
+                  || ((RowOutputBinary) rowOut).getBuffer().length > 256) {
+*************** public class DataFileCache {
+*** 493,499 ****
+       * Free space is requested from the block manager if it exists.
+       * Otherwise the file is grown to accommodate it.
+       */
+!     private int setFilePos(CachedObject r) throws IOException {
+  
+          int rowSize = r.getStorageSize();
+          int i       = freeBlocks == null ? -1
+--- 493,499 ----
+       * Free space is requested from the block manager if it exists.
+       * Otherwise the file is grown to accommodate it.
+       */
+!     public int setFilePos(CachedObject r) throws IOException {
+  
+          int rowSize = r.getStorageSize();
+          int i       = freeBlocks == null ? -1
+*************** public class DataFileCache {
+*** 610,623 ****
+          return readObject(i);
+      }
+  
+!     protected synchronized int readSize(int pos) throws IOException {
+  
+          dataFile.seek((long) pos * cacheFileScale);
+  
+          return dataFile.readInt();
+      }
+  
+!     protected synchronized RowInputInterface readObject(int pos)
+      throws IOException {
+  
+          dataFile.seek((long) pos * cacheFileScale);
+--- 610,623 ----
+          return readObject(i);
+      }
+  
+!     public synchronized int readSize(int pos) throws IOException {
+  
+          dataFile.seek((long) pos * cacheFileScale);
+  
+          return dataFile.readInt();
+      }
+  
+!     public synchronized RowInputInterface readObject(int pos)
+      throws IOException {
+  
+          dataFile.seek((long) pos * cacheFileScale);
+*************** public class DataFileCache {
+*** 638,644 ****
+       * This is called internally when old rows need to be removed from the
+       * cache.
+       */
+!     protected synchronized void saveRows(CachedObject[] rows, int offset,
+                                           int count) throws IOException {
+  
+          for (int i = offset; i < offset + count; i++) {
+--- 638,644 ----
+       * This is called internally when old rows need to be removed from the
+       * cache.
+       */
+!     public synchronized void saveRows(CachedObject[] rows, int offset,
+                                           int count) throws IOException {
+  
+          for (int i = offset; i < offset + count; i++) {
+*************** public class DataFileCache {
+*** 765,771 ****
+          return fileModified;
+      }
+  
+!     protected synchronized void setFileModified() throws IOException {
+  
+          if (!fileModified) {
+  
+--- 765,771 ----
+          return fileModified;
+      }
+  
+!     public synchronized void setFileModified() throws IOException {
+  
+          if (!fileModified) {
+  
+diff -pcr misc/hsqldb/src/org/hsqldb/persist/HsqlDatabaseProperties.java misc/build/hsqldb/src/org/hsqldb/persist/HsqlDatabaseProperties.java
+*** misc/hsqldb/src/org/hsqldb/persist/HsqlDatabaseProperties.java	2006-07-21 01:28:22.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/persist/HsqlDatabaseProperties.java	2007-02-28 12:32:48.000000000 +0100
+*************** public class HsqlDatabaseProperties exte
+*** 60,70 ****
+      public static final int FILES_NEW          = 2;
+  
+      // sets of properties
+!     private static HashSet fullyProtectedProperties = new HashSet();
+!     private static HashSet setProtectedProperties   = new HashSet();
+!     private static HashSet booleanProperties        = new HashSet();
+!     private static HashSet integralProperties       = new HashSet();
+!     private static HashSet stringProperties         = new HashSet();
+  
+      // versions
+      public static final String VERSION_STRING_1_7_0     = "1.7.0";
+--- 60,70 ----
+      public static final int FILES_NEW          = 2;
+  
+      // sets of properties
+!     public static HashSet fullyProtectedProperties = new HashSet();
+!     public static HashSet setProtectedProperties   = new HashSet();
+!     public static HashSet booleanProperties        = new HashSet();
+!     public static HashSet integralProperties       = new HashSet();
+!     public static HashSet stringProperties         = new HashSet();
+  
+      // versions
+      public static final String VERSION_STRING_1_7_0     = "1.7.0";
+*************** public class HsqlDatabaseProperties exte
+*** 79,89 ****
+  
+      //
+      public static final String  db_version  = "version";
+!     private static final String db_readonly = "readonly";
+!     private static final String db_modified = "modified";
+  
+      //
+!     private static final String runtime_gc_interval = "runtime.gc_interval";
+      public static final String  hsqldb_applog       = "hsqldb.applog";
+      public static final String  hsqldb_cache_scale  = "hsqldb.cache_scale";
+      public static final String hsqldb_cache_file_scale =
+--- 79,89 ----
+  
+      //
+      public static final String  db_version  = "version";
+!     public static final String db_readonly = "readonly";
+!     public static final String db_modified = "modified";
+  
+      //
+!     public static final String runtime_gc_interval = "runtime.gc_interval";
+      public static final String  hsqldb_applog       = "hsqldb.applog";
+      public static final String  hsqldb_cache_scale  = "hsqldb.cache_scale";
+      public static final String hsqldb_cache_file_scale =
+*************** public class HsqlDatabaseProperties exte
+*** 91,115 ****
+      public static final String hsqldb_cache_size_scale =
+          "hsqldb.cache_size_scale";
+      public static final String  hsqldb_cache_version = "hsqldb.cache_version";
+!     private static final String hsqldb_catalogs      = "hsqldb.catalogs";
+      public static final String hsqldb_compatible_version =
+          "hsqldb.compatible_version";
+      public static final String hsqldb_default_table_type =
+          "hsqldb.default_table_type";
+      public static final String hsqldb_defrag_limit = "hsqldb.defrag_limit";
+!     private static final String hsqldb_files_readonly =
+          "hsqldb.files_readonly";
+      public static final String  hsqldb_log_size      = "hsqldb.log_size";
+      public static final String  hsqldb_nio_data_file = "hsqldb.nio_data_file";
+!     private static final String hsqldb_max_nio_scale = "hsqldb.max_nio_scale";
+!     private static final String hsqldb_original_version =
+          "hsqldb.original_version";
+      public static final String hsqldb_script_format = "hsqldb.script_format";
+  
+      //
+!     private static final String sql_compare_in_locale =
+          "sql.compare_in_locale";
+!     private static final String sql_enforce_strict_size =
+          "sql.enforce_strict_size";
+      public static final String sql_tx_no_multi_write =
+          "sql.tx_no_multi_rewrite";
+--- 91,115 ----
+      public static final String hsqldb_cache_size_scale =
+          "hsqldb.cache_size_scale";
+      public static final String  hsqldb_cache_version = "hsqldb.cache_version";
+!     public static final String hsqldb_catalogs      = "hsqldb.catalogs";
+      public static final String hsqldb_compatible_version =
+          "hsqldb.compatible_version";
+      public static final String hsqldb_default_table_type =
+          "hsqldb.default_table_type";
+      public static final String hsqldb_defrag_limit = "hsqldb.defrag_limit";
+!     public static final String hsqldb_files_readonly =
+          "hsqldb.files_readonly";
+      public static final String  hsqldb_log_size      = "hsqldb.log_size";
+      public static final String  hsqldb_nio_data_file = "hsqldb.nio_data_file";
+!     public static final String hsqldb_max_nio_scale = "hsqldb.max_nio_scale";
+!     public static final String hsqldb_original_version =
+          "hsqldb.original_version";
+      public static final String hsqldb_script_format = "hsqldb.script_format";
+  
+      //
+!     public static final String sql_compare_in_locale =
+          "sql.compare_in_locale";
+!     public static final String sql_enforce_strict_size =
+          "sql.enforce_strict_size";
+      public static final String sql_tx_no_multi_write =
+          "sql.tx_no_multi_rewrite";
+*************** public class HsqlDatabaseProperties exte
+*** 175,181 ****
+          stringProperties.addAll(stringPropertiesNames);
+      }
+  
+!     private Database database;
+  
+      public HsqlDatabaseProperties(Database db) {
+  
+--- 175,181 ----
+          stringProperties.addAll(stringPropertiesNames);
+      }
+  
+!     public Database database;
+  
+      public HsqlDatabaseProperties(Database db) {
+  
+diff -pcr misc/hsqldb/src/org/hsqldb/persist/HsqlProperties.java misc/build/hsqldb/src/org/hsqldb/persist/HsqlProperties.java
+*** misc/hsqldb/src/org/hsqldb/persist/HsqlProperties.java	2006-04-11 16:47:40.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/persist/HsqlProperties.java	2007-02-28 12:32:48.000000000 +0100
+*************** import org.hsqldb.lib.java.JavaSystem;
+*** 57,68 ****
+  public class HsqlProperties {
+  
+      public static final int NO_VALUE_FOR_KEY = 1;
+!     protected String        fileName;
+!     protected Properties    stringProps;
+!     protected int[]         errorCodes = new int[0];
+!     protected String[]      errorKeys  = new String[0];
+!     protected boolean       resource   = false;
+!     protected FileAccess    fa;
+  
+      public HsqlProperties() {
+          stringProps = new Properties();
+--- 57,68 ----
+  public class HsqlProperties {
+  
+      public static final int NO_VALUE_FOR_KEY = 1;
+!     public String        fileName;
+!     public Properties    stringProps;
+!     public int[]         errorCodes = new int[0];
+!     public String[]      errorKeys  = new String[0];
+!     public boolean       resource   = false;
+!     public FileAccess    fa;
+  
+      public HsqlProperties() {
+          stringProps = new Properties();
+*************** public class HsqlProperties {
+*** 274,280 ****
+       * is populated during construction or addition of elements and is used
+       * outside this class to act upon the errors.
+       */
+!     private void addError(int code, String key) {
+  
+          errorCodes = (int[]) ArrayUtil.resizeArray(errorCodes,
+                  errorCodes.length + 1);
+--- 274,280 ----
+       * is populated during construction or addition of elements and is used
+       * outside this class to act upon the errors.
+       */
+!     public void addError(int code, String key) {
+  
+          errorCodes = (int[]) ArrayUtil.resizeArray(errorCodes,
+                  errorCodes.length + 1);
+diff -pcr misc/hsqldb/src/org/hsqldb/persist/LockFile.java misc/build/hsqldb/src/org/hsqldb/persist/LockFile.java
+*** misc/hsqldb/src/org/hsqldb/persist/LockFile.java	2006-07-17 00:29:33.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/persist/LockFile.java	2007-02-28 12:32:48.000000000 +0100
+*************** import org.hsqldb.lib.java.JavaSystem;
+*** 101,107 ****
+   *    </ul>
+   * </ol> <p>
+   *
+!  * In addition to the generic lock and release rules, the protected methods
+   * {@link #lockImpl() lockImpl()} and {@link #releaseImpl() releaseImpl()}
+   * are called during lock and release attempts, respectively.  This allows
+   * transparent, JDK 1.1 compliant integration of extended strategies for
+--- 101,107 ----
+   *    </ul>
+   * </ol> <p>
+   *
+!  * In addition to the generic lock and release rules, the public methods
+   * {@link #lockImpl() lockImpl()} and {@link #releaseImpl() releaseImpl()}
+   * are called during lock and release attempts, respectively.  This allows
+   * transparent, JDK 1.1 compliant integration of extended strategies for
+*************** import org.hsqldb.lib.java.JavaSystem;
+*** 156,165 ****
+  public class LockFile {
+  
+      /** Canonical reference to this object's lock file. */
+!     protected File f;
+  
+      /** Cached value of the lock file's canonical path. */
+!     private String cpath = null;
+  
+      /**
+       * A RandomAccessFile constructed from this object's reference, f, to its
+--- 156,165 ----
+  public class LockFile {
+  
+      /** Canonical reference to this object's lock file. */
+!     public File f;
+  
+      /** Cached value of the lock file's canonical path. */
+!     public String cpath = null;
+  
+      /**
+       * A RandomAccessFile constructed from this object's reference, f, to its
+*************** public class LockFile {
+*** 168,174 ****
+       * This RandomAccessFile is used to periodically write out the heartbeat
+       * timestamp to this object's lock file.
+       */
+!     protected RandomAccessFile raf;
+  
+      /**
+       * The period, in milliseconds, at which heartbeat timestamps are written
+--- 168,174 ----
+       * This RandomAccessFile is used to periodically write out the heartbeat
+       * timestamp to this object's lock file.
+       */
+!     public RandomAccessFile raf;
+  
+      /**
+       * The period, in milliseconds, at which heartbeat timestamps are written
+*************** public class LockFile {
+*** 183,200 ****
+      public static final byte[] MAGIC = "HSQLLOCK".getBytes();
+  
+      /** Indicates whether this object has a lock condition on its lock file. */
+!     protected boolean locked;
+  
+      /**
+       * The timed scheduler with which to register this object's
+       * heartbeat task.
+       */
+!     protected static final HsqlTimer timer = DatabaseManager.getTimer();
+  
+      /**
+       * An opaque reference to this object's heatbeat task.
+       */
+!     private Object timerTask;
+  
+      /**
+       * Attempts to read the hearbeat timestamp from this object's lock file
+--- 183,200 ----
+      public static final byte[] MAGIC = "HSQLLOCK".getBytes();
+  
+      /** Indicates whether this object has a lock condition on its lock file. */
+!     public boolean locked;
+  
+      /**
+       * The timed scheduler with which to register this object's
+       * heartbeat task.
+       */
+!     public static final HsqlTimer timer = DatabaseManager.getTimer();
+  
+      /**
+       * An opaque reference to this object's heatbeat task.
+       */
+!     public Object timerTask;
+  
+      /**
+       * Attempts to read the hearbeat timestamp from this object's lock file
+*************** public class LockFile {
+*** 219,225 ****
+       *        or isolated class loader context currently has a
+       *        lock condition on this object's lock file
+       */
+!     private void checkHeartbeat() throws Exception {
+  
+          long   lastHeartbeat;
+          String mn;
+--- 219,225 ----
+       *        or isolated class loader context currently has a
+       *        lock condition on this object's lock file
+       */
+!     public void checkHeartbeat() throws Exception {
+  
+          long   lastHeartbeat;
+          String mn;
+*************** public class LockFile {
+*** 270,276 ****
+       *
+       * @throws Exception if an IOException occurs
+       */
+!     private void closeRAF() throws Exception {
+  
+          String mn;
+  
+--- 270,276 ----
+       *
+       * @throws Exception if an IOException occurs
+       */
+!     public void closeRAF() throws Exception {
+  
+          String mn;
+  
+*************** public class LockFile {
+*** 300,306 ****
+       * @param file a reference to the file this object is to use as its
+       *      lock file
+       */
+!     private void setFile(File file) throws Exception {
+  
+          if (isLocked()) {
+              try {
+--- 300,306 ----
+       * @param file a reference to the file this object is to use as its
+       *      lock file
+       */
+!     public void setFile(File file) throws Exception {
+  
+          if (isLocked()) {
+              try {
+*************** public class LockFile {
+*** 355,361 ****
+       *        actions are taken or the actions succeed,
+       *        else <code>false</code>.
+       */
+!     protected boolean lockImpl() throws Exception {
+  
+          String mn;
+  
+--- 355,361 ----
+       *        actions are taken or the actions succeed,
+       *        else <code>false</code>.
+       */
+!     public boolean lockImpl() throws Exception {
+  
+          String mn;
+  
+*************** public class LockFile {
+*** 372,378 ****
+       *
+       * @throws Exception if an IOException occurs
+       */
+!     private void openRAF() throws Exception {
+  
+          trace("openRAF(): entered.");
+  
+--- 372,378 ----
+       *
+       * @throws Exception if an IOException occurs
+       */
+!     public void openRAF() throws Exception {
+  
+          trace("openRAF(): entered.");
+  
+*************** public class LockFile {
+*** 394,400 ****
+       *      file does not exist, Long.MIN_VALUE, the earliest time
+       *      representable as a long in Java,
+       */
+!     private long readHeartbeat() throws Exception {
+  
+          DataInputStream dis;
+          long            heartbeat;
+--- 394,400 ----
+       *      file does not exist, Long.MIN_VALUE, the earliest time
+       *      representable as a long in Java,
+       */
+!     public long readHeartbeat() throws Exception {
+  
+          DataInputStream dis;
+          long            heartbeat;
+*************** public class LockFile {
+*** 447,453 ****
+       *        to be determined. (e.g. an IO exception
+       *        occurs here).
+       */
+!     protected boolean releaseImpl() throws Exception {
+  
+          trace("releaseImpl(): no action: returning true");
+  
+--- 447,453 ----
+       *        to be determined. (e.g. an IO exception
+       *        occurs here).
+       */
+!     public boolean releaseImpl() throws Exception {
+  
+          trace("releaseImpl(): no action: returning true");
+  
+*************** public class LockFile {
+*** 455,461 ****
+      }
+  
+      /** Schedules the lock heartbeat task. */
+!     private void startHeartbeat() {
+  
+          Runnable r;
+  
+--- 455,461 ----
+      }
+  
+      /** Schedules the lock heartbeat task. */
+!     public void startHeartbeat() {
+  
+          Runnable r;
+  
+*************** public class LockFile {
+*** 475,481 ****
+      }
+  
+      /** Cancels the lock heartbeat task. */
+!     private void stopHeartbeat() {
+  
+          String mn = "stopHeartbeat(): ";
+  
+--- 475,481 ----
+      }
+  
+      /** Cancels the lock heartbeat task. */
+!     public void stopHeartbeat() {
+  
+          String mn = "stopHeartbeat(): ";
+  
+*************** public class LockFile {
+*** 497,503 ****
+       * @throws Exception if the magic value cannot be written to
+       *      the lock file
+       */
+!     private void writeMagic() throws Exception {
+  
+          String mn   = "writeMagic(): ";
+          String path = "lock file [" + cpath + "]";
+--- 497,503 ----
+       * @throws Exception if the magic value cannot be written to
+       *      the lock file
+       */
+!     public void writeMagic() throws Exception {
+  
+          String mn   = "writeMagic(): ";
+          String path = "lock file [" + cpath + "]";
+*************** public class LockFile {
+*** 517,523 ****
+       * @throws Exception if the current heartbeat timestamp value
+       *      cannot be written
+       */
+!     private void writeHeartbeat() throws Exception {
+  
+          long   time;
+          String mn   = "writeHeartbeat(): ";
+--- 517,523 ----
+       * @throws Exception if the current heartbeat timestamp value
+       *      cannot be written
+       */
+!     public void writeHeartbeat() throws Exception {
+  
+          long   time;
+          String mn   = "writeHeartbeat(): ";
+*************** public class LockFile {
+*** 752,758 ****
+       * This Runnable class provides the implementation for the timed task
+       * that periodically writes out a heartbeat timestamp to the lock file.<p>
+       */
+!     protected class HeartbeatRunner implements Runnable {
+  
+          public void run() {
+  
+--- 752,758 ----
+       * This Runnable class provides the implementation for the timed task
+       * that periodically writes out a heartbeat timestamp to the lock file.<p>
+       */
+!     public class HeartbeatRunner implements Runnable {
+  
+          public void run() {
+  
+*************** public class LockFile {
+*** 797,803 ****
+       * @return an implementation-specific tail value for the toString() method
+       * @see #toString
+       */
+!     protected String toStringImpl() {
+          return "";
+      }
+  
+--- 797,803 ----
+       * @return an implementation-specific tail value for the toString() method
+       * @see #toString
+       */
+!     public String toStringImpl() {
+          return "";
+      }
+  
+*************** public class LockFile {
+*** 954,960 ****
+       *
+       * @param o the value to print
+       */
+!     protected void trace(Object o) {
+  
+          if (Trace.TRACE) {
+              Trace.printSystemOut("[" + super.toString() + "]: " + o);
+--- 954,960 ----
+       *
+       * @param o the value to print
+       */
+!     public void trace(Object o) {
+  
+          if (Trace.TRACE) {
+              Trace.printSystemOut("[" + super.toString() + "]: " + o);
+*************** public class LockFile {
+*** 969,975 ****
+       *        trying to release the lock condition,
+       *        if any, that it has on its lock file.
+       */
+!     protected void finalize() throws Throwable {
+          trace("finalize(): calling tryRelease()");
+          tryRelease();
+      }
+--- 969,975 ----
+       *        trying to release the lock condition,
+       *        if any, that it has on its lock file.
+       */
+!     public void finalize() throws Throwable {
+          trace("finalize(): calling tryRelease()");
+          tryRelease();
+      }
+diff -pcr misc/hsqldb/src/org/hsqldb/persist/Log.java misc/build/hsqldb/src/org/hsqldb/persist/Log.java
+*** misc/hsqldb/src/org/hsqldb/persist/Log.java	2006-07-21 02:58:55.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/persist/Log.java	2007-02-28 12:32:48.000000000 +0100
+*************** import org.hsqldb.scriptio.ScriptWriterB
+*** 126,143 ****
+   */
+  public class Log {
+  
+!     private HsqlDatabaseProperties properties;
+!     private String                 fileName;
+!     private Database               database;
+!     private FileAccess             fa;
+!     private ScriptWriterBase       dbLogWriter;
+!     private String                 scriptFileName;
+!     private String                 logFileName;
+!     private boolean                filesReadOnly;
+!     private long                   maxLogSize;
+!     private int                    writeDelay;
+!     private int                    scriptFormat;
+!     private DataFileCache          cache;
+  
+      Log(Database db) throws HsqlException {
+  
+--- 126,143 ----
+   */
+  public class Log {
+  
+!     public HsqlDatabaseProperties properties;
+!     public String                 fileName;
+!     public Database               database;
+!     public FileAccess             fa;
+!     public ScriptWriterBase       dbLogWriter;
+!     public String                 scriptFileName;
+!     public String                 logFileName;
+!     public boolean                filesReadOnly;
+!     public long                   maxLogSize;
+!     public int                    writeDelay;
+!     public int                    scriptFormat;
+!     public DataFileCache          cache;
+  
+      Log(Database db) throws HsqlException {
+  
+*************** public class Log {
+*** 586,592 ****
+       * Wrappers for openning-starting / stoping-closing the log file and
+       * writer.
+       */
+!     private void openLog() throws HsqlException {
+  
+          if (filesReadOnly) {
+              return;
+--- 586,592 ----
+       * Wrappers for openning-starting / stoping-closing the log file and
+       * writer.
+       */
+!     public void openLog() throws HsqlException {
+  
+          if (filesReadOnly) {
+              return;
+*************** public class Log {
+*** 604,610 ****
+          }
+      }
+  
+!     private synchronized void closeLog() throws HsqlException {
+  
+          if (dbLogWriter != null) {
+              dbLogWriter.close();
+--- 604,610 ----
+          }
+      }
+  
+!     public synchronized void closeLog() throws HsqlException {
+  
+          if (dbLogWriter != null) {
+              dbLogWriter.close();
+*************** public class Log {
+*** 614,620 ****
+      /**
+       * Write the .script file as .script.new.
+       */
+!     private void writeScript(boolean full) throws HsqlException {
+  
+          String sNewName = scriptFileName + ".new";
+  
+--- 614,620 ----
+      /**
+       * Write the .script file as .script.new.
+       */
+!     public void writeScript(boolean full) throws HsqlException {
+  
+          String sNewName = scriptFileName + ".new";
+  
+*************** public class Log {
+*** 637,643 ****
+      /**
+       * Performs all the commands in the .script file.
+       */
+!     private void processScript() throws HsqlException {
+  
+          ScriptReaderBase scr = null;
+  
+--- 637,643 ----
+      /**
+       * Performs all the commands in the .script file.
+       */
+!     public void processScript() throws HsqlException {
+  
+          ScriptReaderBase scr = null;
+  
+*************** public class Log {
+*** 680,686 ****
+      /**
+       * Defrag large data files when the sum of .log and .data files is large.
+       */
+!     private void processDataFile() throws HsqlException {
+  
+          if (cache == null || filesReadOnly || database.isStoredFileAccess()
+                  ||!fa.isStreamElement(logFileName)) {
+--- 680,686 ----
+      /**
+       * Defrag large data files when the sum of .log and .data files is large.
+       */
+!     public void processDataFile() throws HsqlException {
+  
+          if (cache == null || filesReadOnly || database.isStoredFileAccess()
+                  ||!fa.isStreamElement(logFileName)) {
+*************** public class Log {
+*** 699,705 ****
+      /**
+       * Performs all the commands in the .log file.
+       */
+!     private void processLog() throws HsqlException {
+  
+          if (!database.isFilesInJar() && fa.isStreamElement(logFileName)) {
+              ScriptRunner.runScript(database, logFileName,
+--- 699,705 ----
+      /**
+       * Performs all the commands in the .log file.
+       */
+!     public void processLog() throws HsqlException {
+  
+          if (!database.isFilesInJar() && fa.isStreamElement(logFileName)) {
+              ScriptRunner.runScript(database, logFileName,
+*************** public class Log {
+*** 710,716 ****
+      /**
+       * Restores a compressed backup or the .data file.
+       */
+!     private void restoreBackup() throws HsqlException {
+  
+          // in case data file cannot be deleted, reset it
+          DataFileCache.deleteOrResetFreePos(database, fileName + ".data");
+--- 710,716 ----
+      /**
+       * Restores a compressed backup or the .data file.
+       */
+!     public void restoreBackup() throws HsqlException {
+  
+          // in case data file cannot be deleted, reset it
+          DataFileCache.deleteOrResetFreePos(database, fileName + ".data");
+*************** public class Log {
+*** 728,734 ****
+      }
+  
+  // fredt@users 20020221 - patch 513005 by sqlbob@users (RMP) - text tables
+!     private HashMap textCacheList = new HashMap();
+  
+      DataFileCache openTextCache(Table table, String source,
+                                  boolean readOnlyData,
+--- 728,734 ----
+      }
+  
+  // fredt@users 20020221 - patch 513005 by sqlbob@users (RMP) - text tables
+!     public HashMap textCacheList = new HashMap();
+  
+      DataFileCache openTextCache(Table table, String source,
+                                  boolean readOnlyData,
+*************** public class Log {
+*** 775,781 ****
+          }
+      }
+  
+!     private void closeAllTextCaches(boolean compact) throws HsqlException {
+  
+          Iterator it = textCacheList.values().iterator();
+  
+--- 775,781 ----
+          }
+      }
+  
+!     public void closeAllTextCaches(boolean compact) throws HsqlException {
+  
+          Iterator it = textCacheList.values().iterator();
+  
+*************** public class Log {
+*** 788,794 ****
+          }
+      }
+  
+!     private void reopenAllTextCaches() throws HsqlException {
+  
+          Iterator it = textCacheList.values().iterator();
+  
+--- 788,794 ----
+          }
+      }
+  
+!     public void reopenAllTextCaches() throws HsqlException {
+  
+          Iterator it = textCacheList.values().iterator();
+  
+*************** public class Log {
+*** 797,803 ****
+          }
+      }
+  
+!     private boolean isAnyTextCacheModified() {
+  
+          Iterator it = textCacheList.values().iterator();
+  
+--- 797,803 ----
+          }
+      }
+  
+!     public boolean isAnyTextCacheModified() {
+  
+          Iterator it = textCacheList.values().iterator();
+  
+diff -pcr misc/hsqldb/src/org/hsqldb/persist/NIOLockFile.java misc/build/hsqldb/src/org/hsqldb/persist/NIOLockFile.java
+*** misc/hsqldb/src/org/hsqldb/persist/NIOLockFile.java	2005-10-23 20:26:26.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/persist/NIOLockFile.java	2007-02-28 12:32:48.000000000 +0100
+*************** final class NIOLockFile extends LockFile
+*** 61,73 ****
+       * The <code>fc</code> attribute is used to obtain this object's
+       * {@link #fl FileLock} attribute.
+       */
+!     private FileChannel fc;
+  
+      /**
+       * The <code>FileLock</code> object used to lock this object's
+       * lock file.
+       */
+!     private FileLock fl;
+  
+      /**
+       * Tries to obtain a valid NIO lock upon this object's lock file using
+--- 61,73 ----
+       * The <code>fc</code> attribute is used to obtain this object's
+       * {@link #fl FileLock} attribute.
+       */
+!     public FileChannel fc;
+  
+      /**
+       * The <code>FileLock</code> object used to lock this object's
+       * lock file.
+       */
+!     public FileLock fl;
+  
+      /**
+       * Tries to obtain a valid NIO lock upon this object's lock file using
+*************** final class NIOLockFile extends LockFile
+*** 77,83 ****
+       * @throws Exception if an error occurs while attempting to obtain the lock
+       *
+       */
+!     protected boolean lockImpl() throws Exception {
+  
+          boolean isValid;
+  
+--- 77,83 ----
+       * @throws Exception if an error occurs while attempting to obtain the lock
+       *
+       */
+!     public boolean lockImpl() throws Exception {
+  
+          boolean isValid;
+  
+*************** final class NIOLockFile extends LockFile
+*** 154,160 ****
+       * @return true if a valid lock is released, else false
+       * @throws Exception if na error occurs while attempting to release the lock
+       */
+!     protected boolean releaseImpl() throws Exception {
+  
+          // PRE: we know that this method is only called
+          // if isLocked() is true.
+--- 154,160 ----
+       * @return true if a valid lock is released, else false
+       * @throws Exception if na error occurs while attempting to release the lock
+       */
+!     public boolean releaseImpl() throws Exception {
+  
+          // PRE: we know that this method is only called
+          // if isLocked() is true.
+*************** final class NIOLockFile extends LockFile
+*** 200,206 ****
+       * Retrieves the String value: "fl =" + fl
+       * @return the String value: "fl =" + fl
+       */
+!     protected String toStringImpl() {
+          return "fl =" + fl;
+      }
+  }
+--- 200,206 ----
+       * Retrieves the String value: "fl =" + fl
+       * @return the String value: "fl =" + fl
+       */
+!     public String toStringImpl() {
+          return "fl =" + fl;
+      }
+  }
+diff -pcr misc/hsqldb/src/org/hsqldb/persist/ScaledRAFileHybrid.java misc/build/hsqldb/src/org/hsqldb/persist/ScaledRAFileHybrid.java
+*** misc/hsqldb/src/org/hsqldb/persist/ScaledRAFileHybrid.java	2006-07-27 20:05:23.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/persist/ScaledRAFileHybrid.java	2007-02-28 12:32:48.000000000 +0100
+*************** public class ScaledRAFileHybrid implemen
+*** 144,150 ****
+          return null;
+      }
+  
+!     private void checkLength(int length) throws IOException {
+  
+          if (store.canAccess(length)) {
+              return;
+--- 144,150 ----
+          return null;
+      }
+  
+!     public void checkLength(int length) throws IOException {
+  
+          if (store.canAccess(length)) {
+              return;
+*************** public class ScaledRAFileHybrid implemen
+*** 153,159 ****
+          newStore(store.getFilePointer() + length);
+      }
+  
+!     private void checkSeek(long position) throws IOException {
+  
+          if (store.canSeek(position)) {
+              return;
+--- 153,159 ----
+          newStore(store.getFilePointer() + length);
+      }
+  
+!     public void checkSeek(long position) throws IOException {
+  
+          if (store.canSeek(position)) {
+              return;
+diff -pcr misc/hsqldb/src/org/hsqldb/persist/ScaledRAFileInJar.java misc/build/hsqldb/src/org/hsqldb/persist/ScaledRAFileInJar.java
+*** misc/hsqldb/src/org/hsqldb/persist/ScaledRAFileInJar.java	2006-07-27 20:05:23.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/persist/ScaledRAFileInJar.java	2007-02-28 12:32:48.000000000 +0100
+*************** class ScaledRAFileInJar implements Scale
+*** 92,98 ****
+          return seekPosition;
+      }
+  
+!     private void readIntoBuffer() throws IOException {
+  
+          long filePos = seekPosition;
+  
+--- 92,98 ----
+          return seekPosition;
+      }
+  
+!     public void readIntoBuffer() throws IOException {
+  
+          long filePos = seekPosition;
+  
+*************** class ScaledRAFileInJar implements Scale
+*** 206,212 ****
+          return false;
+      }
+  
+!     private void resetStream() throws IOException {
+  
+          if (file != null) {
+              file.close();
+--- 206,212 ----
+          return false;
+      }
+  
+!     public void resetStream() throws IOException {
+  
+          if (file != null) {
+              file.close();
+*************** class ScaledRAFileInJar implements Scale
+*** 217,223 ****
+          file = new DataInputStream(fis);
+      }
+  
+!     private void fileSeek(long position) throws IOException {
+  
+          long skipPosition = realPosition;
+  
+--- 217,223 ----
+          file = new DataInputStream(fis);
+      }
+  
+!     public void fileSeek(long position) throws IOException {
+  
+          long skipPosition = realPosition;
+  
+diff -pcr misc/hsqldb/src/org/hsqldb/persist/ScaledRAFile.java misc/build/hsqldb/src/org/hsqldb/persist/ScaledRAFile.java
+*** misc/hsqldb/src/org/hsqldb/persist/ScaledRAFile.java	2006-07-27 20:05:23.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/persist/ScaledRAFile.java	2007-02-28 12:32:48.000000000 +0100
+*************** class ScaledRAFile implements ScaledRAIn
+*** 63,69 ****
+      //
+      final SimpleLog          appLog;
+      final RandomAccessFile   file;
+!     private final boolean    readOnly;
+      final String             fileName;
+      boolean                  isNio;
+      boolean                  bufferDirty = true;
+--- 63,69 ----
+      //
+      final SimpleLog          appLog;
+      final RandomAccessFile   file;
+!     public final boolean    readOnly;
+      final String             fileName;
+      boolean                  isNio;
+      boolean                  bufferDirty = true;
+*************** class ScaledRAFile implements ScaledRAIn
+*** 193,199 ****
+          return seekPosition;
+      }
+  
+!     private void readIntoBuffer() throws IOException {
+  
+          try {
+              long filePos = seekPosition;
+--- 193,199 ----
+          return seekPosition;
+      }
+  
+!     public void readIntoBuffer() throws IOException {
+  
+          try {
+              long filePos = seekPosition;
+diff -pcr misc/hsqldb/src/org/hsqldb/persist/ScaledRAFileNIO.java misc/build/hsqldb/src/org/hsqldb/persist/ScaledRAFileNIO.java
+*** misc/hsqldb/src/org/hsqldb/persist/ScaledRAFileNIO.java	2006-07-27 20:05:23.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/persist/ScaledRAFileNIO.java	2007-02-28 12:32:48.000000000 +0100
+*************** import org.hsqldb.lib.SimpleLog;
+*** 54,66 ****
+   */
+  class ScaledRAFileNIO implements ScaledRAInterface {
+  
+!     private final boolean    readOnly;
+!     private final long       bufferLength;
+!     private RandomAccessFile file;
+!     private MappedByteBuffer buffer;
+!     private FileChannel      channel;
+!     private boolean          bufferModified;
+!     private SimpleLog        appLog;
+  
+      ScaledRAFileNIO(Database database, String name, boolean readOnly,
+                      int bufferLength) throws Throwable {
+--- 54,66 ----
+   */
+  class ScaledRAFileNIO implements ScaledRAInterface {
+  
+!     public final boolean    readOnly;
+!     public final long       bufferLength;
+!     public RandomAccessFile file;
+!     public MappedByteBuffer buffer;
+!     public FileChannel      channel;
+!     public boolean          bufferModified;
+!     public SimpleLog        appLog;
+  
+      ScaledRAFileNIO(Database database, String name, boolean readOnly,
+                      int bufferLength) throws Throwable {
+diff -pcr misc/hsqldb/src/org/hsqldb/persist/TextCache.java misc/build/hsqldb/src/org/hsqldb/persist/TextCache.java
+*** misc/hsqldb/src/org/hsqldb/persist/TextCache.java	2007-02-28 12:31:52.000000000 +0100
+--- misc/build/hsqldb/src/org/hsqldb/persist/TextCache.java	2007-02-28 12:32:48.000000000 +0100
+*************** public class TextCache extends DataFileC
+*** 75,83 ****
+      public boolean             isQuoted;
+      public boolean             isAllQuoted;
+      public boolean             ignoreFirst;
+!     protected String           header;
+!     protected Table            table;
+!     private ObjectCacheHashMap uncommittedCache;
+  
+      //
+      final static char DOUBLE_QUOTE_CHAR = '\"';
+--- 75,83 ----
+      public boolean             isQuoted;
+      public boolean             isAllQuoted;
+      public boolean             ignoreFirst;
+!     public String           header;
+!     public Table            table;
+!     public ObjectCacheHashMap uncommittedCache;
+  
+      //
+      final static char DOUBLE_QUOTE_CHAR = '\"';
+*************** public class TextCache extends DataFileC
+*** 105,111 ****
+          uncommittedCache = new ObjectCacheHashMap(5);
+      }
+  
+!     protected void initParams(Database database,
+                                String baseFileName) throws HsqlException {
+  
+          fileName      = baseFileName;
+--- 105,111 ----
+          uncommittedCache = new ObjectCacheHashMap(5);
+      }
+  
+!     public void initParams(Database database,
+                                String baseFileName) throws HsqlException {
+  
+          fileName      = baseFileName;
+*************** public class TextCache extends DataFileC
+*** 186,192 ****
+          cacheFileScale   = 1;
+      }
+  
+!     protected void initBuffers() {
+  
+          if (isQuoted || isAllQuoted) {
+              rowIn = new RowInputTextQuoted(fs, vs, lvs, isAllQuoted);
+--- 186,192 ----
+          cacheFileScale   = 1;
+      }
+  
+!     public void initBuffers() {
+  
+          if (isQuoted || isAllQuoted) {
+              rowIn = new RowInputTextQuoted(fs, vs, lvs, isAllQuoted);
+*************** public class TextCache extends DataFileC
+*** 198,204 ****
+          }
+      }
+  
+!     private String translateSep(String sep) {
+          return translateSep(sep, false);
+      }
+  
+--- 198,204 ----
+          }
+      }
+  
+!     public String translateSep(String sep) {
+          return translateSep(sep, false);
+      }
+  
+*************** public class TextCache extends DataFileC
+*** 206,212 ****
+       * Translates the escaped characters in a separator string and returns
+       * the non-escaped string.
+       */
+!     private String translateSep(String sep, boolean isProperty) {
+  
+          if (sep == null) {
+              return (null);
+--- 206,212 ----
+       * Translates the escaped characters in a separator string and returns
+       * the non-escaped string.
+       */
+!     public String translateSep(String sep, boolean isProperty) {
+  
+          if (sep == null) {
+              return (null);
+*************** public class TextCache extends DataFileC
+*** 403,409 ****
+          release(pos);
+      }
+  
+!     private void clearRowImage(CachedObject row) throws IOException {
+  
+          int length = row.getStorageSize()
+                       - ScriptWriterText.BYTES_LINE_SEP.length;
+--- 403,409 ----
+          release(pos);
+      }
+  
+!     public void clearRowImage(CachedObject row) throws IOException {
+  
+          int length = row.getStorageSize()
+                       - ScriptWriterText.BYTES_LINE_SEP.length;
+*************** public class TextCache extends DataFileC
+*** 432,438 ****
+          clearRowImage(row);
+      }
+  
+!     protected synchronized RowInputInterface readObject(int pos)
+      throws IOException {
+  
+          ByteArray buffer   = new ByteArray(80);
+--- 432,438 ----
+          clearRowImage(row);
+      }
+  
+!     public synchronized RowInputInterface readObject(int pos)
+      throws IOException {
+  
+          ByteArray buffer   = new ByteArray(80);
+*************** public class TextCache extends DataFileC
+*** 670,676 ****
+       * uncommitted cache until such time that they are committed or rolled
+       * back- fredt
+       */
+!     protected synchronized void saveRows(CachedObject[] rows, int offset,
+                                           int count) throws IOException {
+  
+          if (count == 0) {
+--- 670,676 ----
+       * uncommitted cache until such time that they are committed or rolled
+       * back- fredt
+       */
+!     public synchronized void saveRows(CachedObject[] rows, int offset,
+                                           int count) throws IOException {
+  
+          if (count == 0) {
+*************** public class TextCache extends DataFileC
+*** 718,724 ****
+          throw Trace.error(Trace.TEXT_TABLE_HEADER);
+      }
+  
+!     private void writeHeader(String header) throws IOException {
+  
+          byte[] buf       = null;
+          String firstLine = header + NL;
+--- 718,724 ----
+          throw Trace.error(Trace.TEXT_TABLE_HEADER);
+      }
+  
+!     public void writeHeader(String header) throws IOException {
+  
+          byte[] buf       = null;
+          String firstLine = header + NL;
+*************** public class TextCache extends DataFileC
+*** 734,743 ****
+          fileFreePosition = buf.length;
+      }
+  
+!     private class ByteArray {
+  
+!         private byte[] buffer;
+!         private int    buflen;
+  
+          public ByteArray(int n) {
+              buffer = new byte[n];
+--- 734,743 ----
+          fileFreePosition = buf.length;
+      }
+  
+!     public class ByteArray {
+  
+!         public byte[] buffer;
+!         public int    buflen;
+  
+          public ByteArray(int n) {
+              buffer = new byte[n];
+*************** public class TextCache extends DataFileC
+*** 781,787 ****
+          return ((RowInputText) rowIn).getLineNumber();
+      }
+  
+!     protected void setFileModified() throws IOException {
+          fileModified = true;
+      }
+  }
+--- 781,787 ----
+          return ((RowInputText) rowIn).getLineNumber();
+      }
+  
+!     public void setFileModified() throws IOException {
+          fileModified = true;
+      }
+  }
+diff -pcr misc/hsqldb/src/org/hsqldb/PointerNode.java misc/build/hsqldb/src/org/hsqldb/PointerNode.java
+*** misc/hsqldb/src/org/hsqldb/PointerNode.java	2005-10-23 20:26:26.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/PointerNode.java	2007-02-28 12:32:48.000000000 +0100
+*************** package org.hsqldb;
+*** 87,94 ****
+  class PointerNode extends BaseMemoryNode {
+  
+      int           iData = NO_POS;
+!     private Table tTable;
+!     private Node  nPrimary;    // node of key / primary index for this row
+  
+      PointerNode(CachedRow r, int id) {
+  
+--- 87,94 ----
+  class PointerNode extends BaseMemoryNode {
+  
+      int           iData = NO_POS;
+!     public Table tTable;
+!     public Node  nPrimary;    // node of key / primary index for this row
+  
+      PointerNode(CachedRow r, int id) {
+  
+diff -pcr misc/hsqldb/src/org/hsqldb/resources/BundleHandler.java misc/build/hsqldb/src/org/hsqldb/resources/BundleHandler.java
+*** misc/hsqldb/src/org/hsqldb/resources/BundleHandler.java	2005-10-23 20:26:26.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/resources/BundleHandler.java	2007-02-28 12:32:48.000000000 +0100
+*************** import org.hsqldb.lib.HsqlArrayList;
+*** 58,85 ****
+  public final class BundleHandler {
+  
+      /** Used to synchronize access */
+!     private static final Object mutex = new Object();
+  
+      /** The Locale used internally to fetch resource bundles. */
+!     private static Locale locale = Locale.getDefault();
+  
+      /** Map:  Integer object handle => <code>ResourceBundle</code> object. */
+!     private static HashMap bundleHandleMap = new HashMap();
+  
+      /** List whose elements are <code>ResourceBundle</code> objects */
+!     private static HsqlArrayList bundleList = new HsqlArrayList();
+  
+      /**
+       * The resource path prefix of the <code>ResourceBundle</code> objects
+       * handled by this class.
+       */
+!     private static final String prefix = "org/hsqldb/resources/";
+  
+      /** JDK 1.1 compliance */
+!     private static final Method newGetBundleMethod = getNewGetBundleMethod();
+  
+      /** Pure utility class: external construction disabled. */
+!     private BundleHandler() {}
+  
+      /**
+       * Getter for property locale. <p>
+--- 58,85 ----
+  public final class BundleHandler {
+  
+      /** Used to synchronize access */
+!     public static final Object mutex = new Object();
+  
+      /** The Locale used internally to fetch resource bundles. */
+!     public static Locale locale = Locale.getDefault();
+  
+      /** Map:  Integer object handle => <code>ResourceBundle</code> object. */
+!     public static HashMap bundleHandleMap = new HashMap();
+  
+      /** List whose elements are <code>ResourceBundle</code> objects */
+!     public static HsqlArrayList bundleList = new HsqlArrayList();
+  
+      /**
+       * The resource path prefix of the <code>ResourceBundle</code> objects
+       * handled by this class.
+       */
+!     public static final String prefix = "org/hsqldb/resources/";
+  
+      /** JDK 1.1 compliance */
+!     public static final Method newGetBundleMethod = getNewGetBundleMethod();
+  
+      /** Pure utility class: external construction disabled. */
+!     public BundleHandler() {}
+  
+      /**
+       * Getter for property locale. <p>
+*************** public final class BundleHandler {
+*** 197,203 ****
+       * One-shot initialization of JDK 1.2+ ResourceBundle.getBundle() method
+       * having ClassLoader in the signature.
+       */
+!     private static Method getNewGetBundleMethod() {
+  
+          Class   clazz;
+          Class[] args;
+--- 197,203 ----
+       * One-shot initialization of JDK 1.2+ ResourceBundle.getBundle() method
+       * having ClassLoader in the signature.
+       */
+!     public static Method getNewGetBundleMethod() {
+  
+          Class   clazz;
+          Class[] args;
+diff -pcr misc/hsqldb/src/org/hsqldb/ResultBase.java misc/build/hsqldb/src/org/hsqldb/ResultBase.java
+*** misc/hsqldb/src/org/hsqldb/ResultBase.java	2005-10-23 20:26:26.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/ResultBase.java	2007-02-28 12:32:48.000000000 +0100
+*************** package org.hsqldb;
+*** 41,48 ****
+  public class ResultBase {
+  
+      public Record    rRoot;
+!     protected Record rTail;
+!     protected int    iSize;
+  
+      public ResultBase() {}
+  
+--- 41,48 ----
+  public class ResultBase {
+  
+      public Record    rRoot;
+!     public Record rTail;
+!     public int    iSize;
+  
+      public ResultBase() {}
+  
+diff -pcr misc/hsqldb/src/org/hsqldb/Result.java misc/build/hsqldb/src/org/hsqldb/Result.java
+*** misc/hsqldb/src/org/hsqldb/Result.java	2005-10-23 19:40:14.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/Result.java	2007-02-28 12:32:48.000000000 +0100
+*************** public class Result {
+*** 102,112 ****
+  
+      // record list
+      public Record  rRoot;
+!     private Record rTail;
+!     private int    size;
+  
+      // transient - number of significant columns
+!     private int significantColumns;
+  
+      // type of result
+      public int mode;
+--- 102,112 ----
+  
+      // record list
+      public Record  rRoot;
+!     public Record rTail;
+!     public int    size;
+  
+      // transient - number of significant columns
+!     public int significantColumns;
+  
+      // type of result
+      public int mode;
+*************** public class Result {
+*** 126,132 ****
+      String subSubString;
+  
+      // the exception if this is an error
+!     private Throwable exception;
+  
+      // prepared statement id / error vendor code
+      int statementID;
+--- 126,132 ----
+      String subSubString;
+  
+      // the exception if this is an error
+!     public Throwable exception;
+  
+      // prepared statement id / error vendor code
+      int statementID;
+*************** public class Result {
+*** 174,180 ****
+           *
+           * @param  columns
+           */
+!         private void prepareData(int columns) {
+  
+              colLabels     = new String[columns];
+              tableNames    = new String[columns];
+--- 174,180 ----
+           *
+           * @param  columns
+           */
+!         public void prepareData(int columns) {
+  
+              colLabels     = new String[columns];
+              tableNames    = new String[columns];
+*************** public class Result {
+*** 200,213 ****
+                     && colNames[i] != null && colNames[i].length() > 0;
+          }
+  
+!         private void decodeTableColumnAttrs(int in, int i) {
+  
+              colNullable[i] = in & 0x0000000f;
+              isIdentity[i]  = (in & 0x00000010) != 0;
+              isWritable[i]  = (in & 0x00000020) != 0;
+          }
+  
+!         private void writeTableColumnAttrs(RowOutputBinary out,
+                                             int i)
+                                             throws IOException, HsqlException {
+  
+--- 200,213 ----
+                     && colNames[i] != null && colNames[i].length() > 0;
+          }
+  
+!         public void decodeTableColumnAttrs(int in, int i) {
+  
+              colNullable[i] = in & 0x0000000f;
+              isIdentity[i]  = (in & 0x00000010) != 0;
+              isWritable[i]  = (in & 0x00000020) != 0;
+          }
+  
+!         public void writeTableColumnAttrs(RowOutputBinary out,
+                                             int i)
+                                             throws IOException, HsqlException {
+  
+*************** public class Result {
+*** 255,261 ****
+                                                     : schemaNames[i]);
+          }
+  
+!         private int encodeTableColumnAttrs(int i) {
+  
+              int out = colNullable[i];    // always between 0x00 and 0x02
+  
+--- 255,261 ----
+                                                     : schemaNames[i]);
+          }
+  
+!         public int encodeTableColumnAttrs(int i) {
+  
+              int out = colNullable[i];    // always between 0x00 and 0x02
+  
+*************** public class Result {
+*** 270,276 ****
+              return out;
+          }
+  
+!         private void readTableColumnAttrs(RowInputBinary in,
+                                            int i)
+                                            throws IOException, HsqlException {
+  
+--- 270,276 ----
+              return out;
+          }
+  
+!         public void readTableColumnAttrs(RowInputBinary in,
+                                            int i)
+                                            throws IOException, HsqlException {
+  
+*************** public class Result {
+*** 1082,1088 ****
+       * @return -1, 0, +1
+       * @throws  HsqlException
+       */
+!     private int compareRecord(Session session, Object[] a, final Object[] b,
+                                final int[] order,
+                                int[] way) throws HsqlException {
+  
+--- 1082,1088 ----
+       * @return -1, 0, +1
+       * @throws  HsqlException
+       */
+!     public int compareRecord(Session session, Object[] a, final Object[] b,
+                                final int[] order,
+                                int[] way) throws HsqlException {
+  
+*************** public class Result {
+*** 1112,1118 ****
+       * @return -1, 0, +1
+       * @throws  HsqlException
+       */
+!     private int compareRecord(Session session, Object[] a, Object[] b,
+                                int len) throws HsqlException {
+  
+          for (int j = 0; j < len; j++) {
+--- 1112,1118 ----
+       * @return -1, 0, +1
+       * @throws  HsqlException
+       */
+!     public int compareRecord(Session session, Object[] a, Object[] b,
+                                int len) throws HsqlException {
+  
+          for (int j = 0; j < len; j++) {
+*************** public class Result {
+*** 1306,1312 ****
+          }
+      }
+  
+!     private void writeMulti(RowOutputBinary out)
+      throws IOException, HsqlException {
+  
+          int startPos = out.size();
+--- 1306,1312 ----
+          }
+      }
+  
+!     public void writeMulti(RowOutputBinary out)
+      throws IOException, HsqlException {
+  
+          int startPos = out.size();
+*************** public class Result {
+*** 1489,1495 ****
+          return new ResultIterator();
+      }
+  
+!     private class ResultIterator implements Iterator {
+  
+          boolean removed;
+          int     counter;
+--- 1489,1495 ----
+          return new ResultIterator();
+      }
+  
+!     public class ResultIterator implements Iterator {
+  
+          boolean removed;
+          int     counter;
+diff -pcr misc/hsqldb/src/org/hsqldb/rowio/RowInputBase.java misc/build/hsqldb/src/org/hsqldb/rowio/RowInputBase.java
+*** misc/hsqldb/src/org/hsqldb/rowio/RowInputBase.java	2006-01-07 17:01:31.000000000 +0100
+--- misc/build/hsqldb/src/org/hsqldb/rowio/RowInputBase.java	2007-02-28 12:32:48.000000000 +0100
+*************** public abstract class RowInputBase exten
+*** 58,65 ****
+      static final int NO_POS = -1;
+  
+      // fredt - initialisation may be unnecessary as it's done in resetRow()
+!     protected int filePos = NO_POS;
+!     protected int size;
+  
+      public RowInputBase() {
+          this(new byte[4]);
+--- 58,65 ----
+      static final int NO_POS = -1;
+  
+      // fredt - initialisation may be unnecessary as it's done in resetRow()
+!     public int filePos = NO_POS;
+!     public int size;
+  
+      public RowInputBase() {
+          this(new byte[4]);
+*************** public abstract class RowInputBase exten
+*** 99,135 ****
+      public abstract String readString() throws IOException;
+  
+  // fredt@users - comment - methods used for SQL types
+!     protected abstract boolean checkNull() throws IOException;
+  
+!     protected abstract String readChar(int type)
+      throws IOException, HsqlException;
+  
+!     protected abstract Integer readSmallint()
+      throws IOException, HsqlException;
+  
+!     protected abstract Integer readInteger()
+      throws IOException, HsqlException;
+  
+!     protected abstract Long readBigint() throws IOException, HsqlException;
+  
+!     protected abstract Double readReal(int type)
+      throws IOException, HsqlException;
+  
+!     protected abstract BigDecimal readDecimal()
+      throws IOException, HsqlException;
+  
+!     protected abstract Boolean readBit() throws IOException, HsqlException;
+  
+!     protected abstract Time readTime() throws IOException, HsqlException;
+  
+!     protected abstract Date readDate() throws IOException, HsqlException;
+  
+!     protected abstract Timestamp readTimestamp()
+      throws IOException, HsqlException;
+  
+!     protected abstract Object readOther() throws IOException, HsqlException;
+  
+!     protected abstract Binary readBinary(int type)
+      throws IOException, HsqlException;
+  
+      /**
+--- 99,135 ----
+      public abstract String readString() throws IOException;
+  
+  // fredt@users - comment - methods used for SQL types
+!     public abstract boolean checkNull() throws IOException;
+  
+!     public abstract String readChar(int type)
+      throws IOException, HsqlException;
+  
+!     public abstract Integer readSmallint()
+      throws IOException, HsqlException;
+  
+!     public abstract Integer readInteger()
+      throws IOException, HsqlException;
+  
+!     public abstract Long readBigint() throws IOException, HsqlException;
+  
+!     public abstract Double readReal(int type)
+      throws IOException, HsqlException;
+  
+!     public abstract BigDecimal readDecimal()
+      throws IOException, HsqlException;
+  
+!     public abstract Boolean readBit() throws IOException, HsqlException;
+  
+!     public abstract Time readTime() throws IOException, HsqlException;
+  
+!     public abstract Date readDate() throws IOException, HsqlException;
+  
+!     public abstract Timestamp readTimestamp()
+      throws IOException, HsqlException;
+  
+!     public abstract Object readOther() throws IOException, HsqlException;
+  
+!     public abstract Binary readBinary(int type)
+      throws IOException, HsqlException;
+  
+      /**
+diff -pcr misc/hsqldb/src/org/hsqldb/rowio/RowInputBinary.java misc/build/hsqldb/src/org/hsqldb/rowio/RowInputBinary.java
+*** misc/hsqldb/src/org/hsqldb/rowio/RowInputBinary.java	2005-10-23 20:26:26.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/rowio/RowInputBinary.java	2007-02-28 12:32:48.000000000 +0100
+*************** import org.hsqldb.types.JavaObject;
+*** 58,64 ****
+  public class RowInputBinary extends RowInputBase
+  implements org.hsqldb.rowio.RowInputInterface {
+  
+!     private RowOutputBinary out;
+  
+      public RowInputBinary() {
+          super();
+--- 58,64 ----
+  public class RowInputBinary extends RowInputBase
+  implements org.hsqldb.rowio.RowInputInterface {
+  
+!     public RowOutputBinary out;
+  
+      public RowInputBinary() {
+          super();
+*************** implements org.hsqldb.rowio.RowInputInte
+*** 79,85 ****
+          this.out = out;
+      }
+  
+!     protected byte[] readByteArray() throws IOException {
+  
+          byte[] b = new byte[readInt()];
+  
+--- 79,85 ----
+          this.out = out;
+      }
+  
+!     public byte[] readByteArray() throws IOException {
+  
+          byte[] b = new byte[readInt()];
+  
+*************** implements org.hsqldb.rowio.RowInputInte
+*** 115,121 ****
+          return s;
+      }
+  
+!     protected boolean checkNull() throws IOException {
+  
+          int b = readByte();
+  
+--- 115,121 ----
+          return s;
+      }
+  
+!     public boolean checkNull() throws IOException {
+  
+          int b = readByte();
+  
+*************** implements org.hsqldb.rowio.RowInputInte
+*** 123,149 ****
+                        : false;
+      }
+  
+!     protected String readChar(int type) throws IOException {
+          return readString();
+      }
+  
+!     protected Integer readSmallint() throws IOException, HsqlException {
+          return ValuePool.getInt(readShort());
+      }
+  
+!     protected Integer readInteger() throws IOException, HsqlException {
+          return ValuePool.getInt(readInt());
+      }
+  
+!     protected Long readBigint() throws IOException, HsqlException {
+          return ValuePool.getLong(readLong());
+      }
+  
+!     protected Double readReal(int type) throws IOException, HsqlException {
+          return ValuePool.getDouble(readLong());
+      }
+  
+!     protected BigDecimal readDecimal() throws IOException, HsqlException {
+  
+          byte[]     bytes  = readByteArray();
+          int        scale  = readInt();
+--- 123,149 ----
+                        : false;
+      }
+  
+!     public String readChar(int type) throws IOException {
+          return readString();
+      }
+  
+!     public Integer readSmallint() throws IOException, HsqlException {
+          return ValuePool.getInt(readShort());
+      }
+  
+!     public Integer readInteger() throws IOException, HsqlException {
+          return ValuePool.getInt(readInt());
+      }
+  
+!     public Long readBigint() throws IOException, HsqlException {
+          return ValuePool.getLong(readLong());
+      }
+  
+!     public Double readReal(int type) throws IOException, HsqlException {
+          return ValuePool.getDouble(readLong());
+      }
+  
+!     public BigDecimal readDecimal() throws IOException, HsqlException {
+  
+          byte[]     bytes  = readByteArray();
+          int        scale  = readInt();
+*************** implements org.hsqldb.rowio.RowInputInte
+*** 152,182 ****
+          return ValuePool.getBigDecimal(new BigDecimal(bigint, scale));
+      }
+  
+!     protected Boolean readBit() throws IOException, HsqlException {
+          return readBoolean() ? Boolean.TRUE
+                               : Boolean.FALSE;
+      }
+  
+!     protected Time readTime() throws IOException, HsqlException {
+          return new Time(HsqlDateTime.getNormalisedTime(readLong()));
+      }
+  
+!     protected Date readDate() throws IOException, HsqlException {
+  
+          long date = HsqlDateTime.getNormalisedDate(readLong());
+  
+          return ValuePool.getDate(date);
+      }
+  
+!     protected Timestamp readTimestamp() throws IOException, HsqlException {
+          return HsqlDateTime.timestampValue(readLong(), readInt());
+      }
+  
+!     protected Object readOther() throws IOException, HsqlException {
+          return new JavaObject(readByteArray());
+      }
+  
+!     protected Binary readBinary(int type) throws IOException, HsqlException {
+          return new Binary(readByteArray(), false);
+      }
+  
+--- 152,182 ----
+          return ValuePool.getBigDecimal(new BigDecimal(bigint, scale));
+      }
+  
+!     public Boolean readBit() throws IOException, HsqlException {
+          return readBoolean() ? Boolean.TRUE
+                               : Boolean.FALSE;
+      }
+  
+!     public Time readTime() throws IOException, HsqlException {
+          return new Time(HsqlDateTime.getNormalisedTime(readLong()));
+      }
+  
+!     public Date readDate() throws IOException, HsqlException {
+  
+          long date = HsqlDateTime.getNormalisedDate(readLong());
+  
+          return ValuePool.getDate(date);
+      }
+  
+!     public Timestamp readTimestamp() throws IOException, HsqlException {
+          return HsqlDateTime.timestampValue(readLong(), readInt());
+      }
+  
+!     public Object readOther() throws IOException, HsqlException {
+          return new JavaObject(readByteArray());
+      }
+  
+!     public Binary readBinary(int type) throws IOException, HsqlException {
+          return new Binary(readByteArray(), false);
+      }
+  
+diff -pcr misc/hsqldb/src/org/hsqldb/rowio/RowInputText.java misc/build/hsqldb/src/org/hsqldb/rowio/RowInputText.java
+*** misc/hsqldb/src/org/hsqldb/rowio/RowInputText.java	2006-07-17 00:29:33.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/rowio/RowInputText.java	2007-02-28 12:32:48.000000000 +0100
+*************** import org.hsqldb.types.JavaObject;
+*** 55,75 ****
+  public class RowInputText extends RowInputBase implements RowInputInterface {
+  
+      // text table specific
+!     private String    fieldSep;
+!     private String    varSep;
+!     private String    longvarSep;
+!     private int       fieldSepLen;
+!     private int       varSepLen;
+!     private int       longvarSepLen;
+!     private boolean   fieldSepEnd;
+!     private boolean   varSepEnd;
+!     private boolean   longvarSepEnd;
+!     private int       textLen;
+!     protected String  text;
+!     protected int     line;
+!     protected int     field;
+!     protected int     next = 0;
+!     protected boolean allQuoted;
+  
+      /**
+       * fredt@users - comment - in future may use a custom subclasse of
+--- 55,75 ----
+  public class RowInputText extends RowInputBase implements RowInputInterface {
+  
+      // text table specific
+!     public String    fieldSep;
+!     public String    varSep;
+!     public String    longvarSep;
+!     public int       fieldSepLen;
+!     public int       varSepLen;
+!     public int       longvarSepLen;
+!     public boolean   fieldSepEnd;
+!     public boolean   varSepEnd;
+!     public boolean   longvarSepEnd;
+!     public int       textLen;
+!     public String  text;
+!     public int     line;
+!     public int     field;
+!     public int     next = 0;
+!     public boolean allQuoted;
+  
+      /**
+       * fredt@users - comment - in future may use a custom subclasse of
+*************** public class RowInputText extends RowInp
+*** 120,126 ****
+          field = 0;
+      }
+  
+!     protected String getField(String sep, int sepLen,
+                                boolean isEnd) throws IOException {
+  
+          String s = null;
+--- 120,126 ----
+          field = 0;
+      }
+  
+!     public String getField(String sep, int sepLen,
+                                boolean isEnd) throws IOException {
+  
+          String s = null;
+*************** public class RowInputText extends RowInp
+*** 168,178 ****
+          return getField(fieldSep, fieldSepLen, fieldSepEnd);
+      }
+  
+!     private String readVarString() throws IOException {
+          return getField(varSep, varSepLen, varSepEnd);
+      }
+  
+!     private String readLongVarString() throws IOException {
+          return getField(longvarSep, longvarSepLen, longvarSepEnd);
+      }
+  
+--- 168,178 ----
+          return getField(fieldSep, fieldSepLen, fieldSepEnd);
+      }
+  
+!     public String readVarString() throws IOException {
+          return getField(varSep, varSepLen, varSepEnd);
+      }
+  
+!     public String readLongVarString() throws IOException {
+          return getField(longvarSep, longvarSepLen, longvarSepEnd);
+      }
+  
+*************** public class RowInputText extends RowInp
+*** 206,218 ****
+          return 0;
+      }
+  
+!     protected boolean checkNull() {
+  
+          // Return null on each column read instead.
+          return false;
+      }
+  
+!     protected String readChar(int type) throws IOException {
+  
+          switch (type) {
+  
+--- 206,218 ----
+          return 0;
+      }
+  
+!     public boolean checkNull() {
+  
+          // Return null on each column read instead.
+          return false;
+      }
+  
+!     public String readChar(int type) throws IOException {
+  
+          switch (type) {
+  
+*************** public class RowInputText extends RowInp
+*** 229,235 ****
+          }
+      }
+  
+!     protected Integer readSmallint() throws IOException, HsqlException {
+  
+          String s = readString();
+  
+--- 229,235 ----
+          }
+      }
+  
+!     public Integer readSmallint() throws IOException, HsqlException {
+  
+          String s = readString();
+  
+*************** public class RowInputText extends RowInp
+*** 246,252 ****
+          return Integer.valueOf(s);
+      }
+  
+!     protected Integer readInteger() throws IOException, HsqlException {
+  
+          String s = readString();
+  
+--- 246,252 ----
+          return Integer.valueOf(s);
+      }
+  
+!     public Integer readInteger() throws IOException, HsqlException {
+  
+          String s = readString();
+  
+*************** public class RowInputText extends RowInp
+*** 263,269 ****
+          return Integer.valueOf(s);
+      }
+  
+!     protected Long readBigint() throws IOException, HsqlException {
+  
+          String s = readString();
+  
+--- 263,269 ----
+          return Integer.valueOf(s);
+      }
+  
+!     public Long readBigint() throws IOException, HsqlException {
+  
+          String s = readString();
+  
+*************** public class RowInputText extends RowInp
+*** 280,286 ****
+          return Long.valueOf(s);
+      }
+  
+!     protected Double readReal(int type) throws IOException, HsqlException {
+  
+          String s = readString();
+  
+--- 280,286 ----
+          return Long.valueOf(s);
+      }
+  
+!     public Double readReal(int type) throws IOException, HsqlException {
+  
+          String s = readString();
+  
+*************** public class RowInputText extends RowInp
+*** 297,303 ****
+          return Double.valueOf(s);
+      }
+  
+!     protected BigDecimal readDecimal() throws IOException, HsqlException {
+  
+          String s = readString();
+  
+--- 297,303 ----
+          return Double.valueOf(s);
+      }
+  
+!     public BigDecimal readDecimal() throws IOException, HsqlException {
+  
+          String s = readString();
+  
+*************** public class RowInputText extends RowInp
+*** 314,320 ****
+          return new BigDecimal(s);
+      }
+  
+!     protected Time readTime() throws IOException, HsqlException {
+  
+          String s = readString();
+  
+--- 314,320 ----
+          return new BigDecimal(s);
+      }
+  
+!     public Time readTime() throws IOException, HsqlException {
+  
+          String s = readString();
+  
+*************** public class RowInputText extends RowInp
+*** 331,337 ****
+          return HsqlDateTime.timeValue(s);
+      }
+  
+!     protected Date readDate() throws IOException, HsqlException {
+  
+          String s = readString();
+  
+--- 331,337 ----
+          return HsqlDateTime.timeValue(s);
+      }
+  
+!     public Date readDate() throws IOException, HsqlException {
+  
+          String s = readString();
+  
+*************** public class RowInputText extends RowInp
+*** 348,354 ****
+          return HsqlDateTime.dateValue(s);
+      }
+  
+!     protected Timestamp readTimestamp() throws IOException, HsqlException {
+  
+          String s = readString();
+  
+--- 348,354 ----
+          return HsqlDateTime.dateValue(s);
+      }
+  
+!     public Timestamp readTimestamp() throws IOException, HsqlException {
+  
+          String s = readString();
+  
+*************** public class RowInputText extends RowInp
+*** 365,371 ****
+          return HsqlDateTime.timestampValue(s);
+      }
+  
+!     protected Boolean readBit() throws IOException, HsqlException {
+  
+          String s = readString();
+  
+--- 365,371 ----
+          return HsqlDateTime.timestampValue(s);
+      }
+  
+!     public Boolean readBit() throws IOException, HsqlException {
+  
+          String s = readString();
+  
+*************** public class RowInputText extends RowInp
+*** 383,389 ****
+                                            : Boolean.FALSE;
+      }
+  
+!     protected Object readOther() throws IOException, HsqlException {
+  
+          byte[] data;
+          String s = readString();
+--- 383,389 ----
+                                            : Boolean.FALSE;
+      }
+  
+!     public Object readOther() throws IOException, HsqlException {
+  
+          byte[] data;
+          String s = readString();
+*************** public class RowInputText extends RowInp
+*** 403,409 ****
+          return new JavaObject(data);
+      }
+  
+!     protected Binary readBinary(int type) throws IOException, HsqlException {
+  
+          String s = readString();
+  
+--- 403,409 ----
+          return new JavaObject(data);
+      }
+  
+!     public Binary readBinary(int type) throws IOException, HsqlException {
+  
+          String s = readString();
+  
+diff -pcr misc/hsqldb/src/org/hsqldb/rowio/RowInputTextLog.java misc/build/hsqldb/src/org/hsqldb/rowio/RowInputTextLog.java
+*** misc/hsqldb/src/org/hsqldb/rowio/RowInputTextLog.java	2005-10-23 20:26:26.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/rowio/RowInputTextLog.java	2007-02-28 12:32:48.000000000 +0100
+*************** implements RowInputInterface {
+*** 115,121 ****
+          return schemaName;
+      }
+  
+!     protected String readField() throws IOException {
+  
+          try {
+              tokenizer.getString();
+--- 115,121 ----
+          return schemaName;
+      }
+  
+!     public String readField() throws IOException {
+  
+          try {
+              tokenizer.getString();
+*************** implements RowInputInterface {
+*** 137,143 ****
+          }
+      }
+  
+!     protected String readNumberField() throws IOException {
+  
+          try {
+              tokenizer.getString();
+--- 137,143 ----
+          }
+      }
+  
+!     public String readNumberField() throws IOException {
+  
+          try {
+              tokenizer.getString();
+*************** implements RowInputInterface {
+*** 205,221 ****
+          return 0;
+      }
+  
+!     protected boolean checkNull() {
+  
+          // Return null on each column read instead.
+          return false;
+      }
+  
+!     protected String readChar(int type) throws IOException {
+          return readString();
+      }
+  
+!     protected Integer readSmallint() throws IOException, HsqlException {
+  
+          String s = readNumberField();
+  
+--- 205,221 ----
+          return 0;
+      }
+  
+!     public boolean checkNull() {
+  
+          // Return null on each column read instead.
+          return false;
+      }
+  
+!     public String readChar(int type) throws IOException {
+          return readString();
+      }
+  
+!     public Integer readSmallint() throws IOException, HsqlException {
+  
+          String s = readNumberField();
+  
+*************** implements RowInputInterface {
+*** 228,234 ****
+          return ValuePool.getInt(i);
+      }
+  
+!     protected Integer readInteger() throws IOException, HsqlException {
+  
+          String s = readNumberField();
+  
+--- 228,234 ----
+          return ValuePool.getInt(i);
+      }
+  
+!     public Integer readInteger() throws IOException, HsqlException {
+  
+          String s = readNumberField();
+  
+*************** implements RowInputInterface {
+*** 241,247 ****
+          return ValuePool.getInt(i);
+      }
+  
+!     protected Long readBigint() throws IOException, HsqlException {
+  
+          String s = readNumberField();
+  
+--- 241,247 ----
+          return ValuePool.getInt(i);
+      }
+  
+!     public Long readBigint() throws IOException, HsqlException {
+  
+          String s = readNumberField();
+  
+*************** implements RowInputInterface {
+*** 254,260 ****
+          return ValuePool.getLong(i);
+      }
+  
+!     protected Double readReal(int type) throws IOException, HsqlException {
+  
+          String s = readNumberField();
+  
+--- 254,260 ----
+          return ValuePool.getLong(i);
+      }
+  
+!     public Double readReal(int type) throws IOException, HsqlException {
+  
+          String s = readNumberField();
+  
+*************** implements RowInputInterface {
+*** 282,288 ****
+          return ValuePool.getDouble(Double.doubleToLongBits(i));
+      }
+  
+!     protected BigDecimal readDecimal() throws IOException, HsqlException {
+  
+          String s = readNumberField();
+  
+--- 282,288 ----
+          return ValuePool.getDouble(Double.doubleToLongBits(i));
+      }
+  
+!     public BigDecimal readDecimal() throws IOException, HsqlException {
+  
+          String s = readNumberField();
+  
+*************** implements RowInputInterface {
+*** 295,301 ****
+          return ValuePool.getBigDecimal(i);
+      }
+  
+!     protected Time readTime() throws IOException, HsqlException {
+  
+          String s = readField();
+  
+--- 295,301 ----
+          return ValuePool.getBigDecimal(i);
+      }
+  
+!     public Time readTime() throws IOException, HsqlException {
+  
+          String s = readField();
+  
+*************** implements RowInputInterface {
+*** 306,312 ****
+          return HsqlDateTime.timeValue(s);
+      }
+  
+!     protected Date readDate() throws IOException, HsqlException {
+  
+          String s = readField();
+  
+--- 306,312 ----
+          return HsqlDateTime.timeValue(s);
+      }
+  
+!     public Date readDate() throws IOException, HsqlException {
+  
+          String s = readField();
+  
+*************** implements RowInputInterface {
+*** 317,323 ****
+          return HsqlDateTime.dateValue(s);
+      }
+  
+!     protected Timestamp readTimestamp() throws IOException, HsqlException {
+  
+          String s = readField();
+  
+--- 317,323 ----
+          return HsqlDateTime.dateValue(s);
+      }
+  
+!     public Timestamp readTimestamp() throws IOException, HsqlException {
+  
+          String s = readField();
+  
+*************** implements RowInputInterface {
+*** 328,334 ****
+          return HsqlDateTime.timestampValue(s);
+      }
+  
+!     protected Boolean readBit() throws IOException, HsqlException {
+  
+          String s = readField();
+  
+--- 328,334 ----
+          return HsqlDateTime.timestampValue(s);
+      }
+  
+!     public Boolean readBit() throws IOException, HsqlException {
+  
+          String s = readField();
+  
+*************** implements RowInputInterface {
+*** 340,346 ****
+                                            : Boolean.FALSE;
+      }
+  
+!     protected Object readOther() throws IOException, HsqlException {
+  
+          byte[] data;
+          String s = readField();
+--- 340,346 ----
+                                            : Boolean.FALSE;
+      }
+  
+!     public Object readOther() throws IOException, HsqlException {
+  
+          byte[] data;
+          String s = readField();
+*************** implements RowInputInterface {
+*** 354,360 ****
+          return new JavaObject(data);
+      }
+  
+!     protected Binary readBinary(int type) throws IOException, HsqlException {
+  
+          String s = readField();
+  
+--- 354,360 ----
+          return new JavaObject(data);
+      }
+  
+!     public Binary readBinary(int type) throws IOException, HsqlException {
+  
+          String s = readField();
+  
+diff -pcr misc/hsqldb/src/org/hsqldb/rowio/RowInputTextQuoted.java misc/build/hsqldb/src/org/hsqldb/rowio/RowInputTextQuoted.java
+*** misc/hsqldb/src/org/hsqldb/rowio/RowInputTextQuoted.java	2006-07-17 00:29:33.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/rowio/RowInputTextQuoted.java	2007-02-28 12:32:48.000000000 +0100
+*************** import org.hsqldb.Trace;
+*** 46,55 ****
+   */
+  public class RowInputTextQuoted extends RowInputText {
+  
+!     private static final int NORMAL_FIELD   = 0;
+!     private static final int NEED_END_QUOTE = 1;
+!     private static final int FOUND_QUOTE    = 2;
+!     private char[]           qtext;
+  
+      public RowInputTextQuoted(String fieldSep, String varSep,
+                                String longvarSep, boolean allQuoted) {
+--- 46,55 ----
+   */
+  public class RowInputTextQuoted extends RowInputText {
+  
+!     public static final int NORMAL_FIELD   = 0;
+!     public static final int NEED_END_QUOTE = 1;
+!     public static final int FOUND_QUOTE    = 2;
+!     public char[]           qtext;
+  
+      public RowInputTextQuoted(String fieldSep, String varSep,
+                                String longvarSep, boolean allQuoted) {
+*************** public class RowInputTextQuoted extends 
+*** 63,69 ****
+          qtext = text.toCharArray();
+      }
+  
+!     protected String getField(String sep, int sepLen,
+                                boolean isEnd) throws IOException {
+  
+          //fredt - now the only supported behaviour is emptyIsNull
+--- 63,69 ----
+          qtext = text.toCharArray();
+      }
+  
+!     public String getField(String sep, int sepLen,
+                                boolean isEnd) throws IOException {
+  
+          //fredt - now the only supported behaviour is emptyIsNull
+diff -pcr misc/hsqldb/src/org/hsqldb/rowio/RowOutputBase.java misc/build/hsqldb/src/org/hsqldb/rowio/RowOutputBase.java
+*** misc/hsqldb/src/org/hsqldb/rowio/RowOutputBase.java	2005-10-23 20:26:26.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/rowio/RowOutputBase.java	2007-02-28 12:32:48.000000000 +0100
+*************** implements RowOutputInterface {
+*** 62,68 ****
+      public static final int CACHED_ROW_170 = 1;
+  
+      // the last column in a table is an ID that should not be written to file
+!     protected boolean skipSystemId = false;
+  
+      /**
+       *  Constructor used for persistent storage of a Table row
+--- 62,68 ----
+      public static final int CACHED_ROW_170 = 1;
+  
+      // the last column in a table is an ID that should not be written to file
+!     public boolean skipSystemId = false;
+  
+      /**
+       *  Constructor used for persistent storage of a Table row
+*************** implements RowOutputInterface {
+*** 107,141 ****
+      public abstract void writeString(String s);
+  
+  // fredt@users - comment - methods used for writing each SQL type
+!     protected void writeFieldPrefix() {}
+  
+!     protected abstract void writeFieldType(int type);
+  
+!     protected abstract void writeNull(int type);
+  
+!     protected abstract void writeChar(String s, int t);
+  
+!     protected abstract void writeSmallint(Number o);
+  
+!     protected abstract void writeInteger(Number o);
+  
+!     protected abstract void writeBigint(Number o);
+  
+!     protected abstract void writeReal(Double o, int type);
+  
+!     protected abstract void writeDecimal(BigDecimal o);
+  
+!     protected abstract void writeBit(Boolean o);
+  
+!     protected abstract void writeDate(Date o);
+  
+!     protected abstract void writeTime(Time o);
+  
+!     protected abstract void writeTimestamp(Timestamp o);
+  
+!     protected abstract void writeOther(JavaObject o);
+  
+!     protected abstract void writeBinary(Binary o, int t);
+  
+      public void writeRow(Object[] data, Table t) {
+  
+--- 107,141 ----
+      public abstract void writeString(String s);
+  
+  // fredt@users - comment - methods used for writing each SQL type
+!     public void writeFieldPrefix() {}
+  
+!     public abstract void writeFieldType(int type);
+  
+!     public abstract void writeNull(int type);
+  
+!     public abstract void writeChar(String s, int t);
+  
+!     public abstract void writeSmallint(Number o);
+  
+!     public abstract void writeInteger(Number o);
+  
+!     public abstract void writeBigint(Number o);
+  
+!     public abstract void writeReal(Double o, int type);
+  
+!     public abstract void writeDecimal(BigDecimal o);
+  
+!     public abstract void writeBit(Boolean o);
+  
+!     public abstract void writeDate(Date o);
+  
+!     public abstract void writeTime(Time o);
+  
+!     public abstract void writeTimestamp(Timestamp o);
+  
+!     public abstract void writeOther(JavaObject o);
+  
+!     public abstract void writeBinary(Binary o, int t);
+  
+      public void writeRow(Object[] data, Table t) {
+  
+diff -pcr misc/hsqldb/src/org/hsqldb/rowio/RowOutputBinary.java misc/build/hsqldb/src/org/hsqldb/rowio/RowOutputBinary.java
+*** misc/hsqldb/src/org/hsqldb/rowio/RowOutputBinary.java	2005-10-23 20:26:26.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/rowio/RowOutputBinary.java	2007-02-28 12:32:48.000000000 +0100
+*************** import org.hsqldb.types.JavaObject;
+*** 57,63 ****
+   */
+  public class RowOutputBinary extends RowOutputBase {
+  
+!     private static final int INT_STORE_SIZE = 4;
+      int                      storageSize;
+  
+      public RowOutputBinary() {
+--- 57,63 ----
+   */
+  public class RowOutputBinary extends RowOutputBase {
+  
+!     public static final int INT_STORE_SIZE = 4;
+      int                      storageSize;
+  
+      public RowOutputBinary() {
+*************** public class RowOutputBinary extends Row
+*** 160,194 ****
+      }
+  
+  // fredt@users - comment - methods used for writing each SQL type
+!     protected void writeFieldType(int type) {
+          write(1);
+      }
+  
+!     protected void writeNull(int type) {
+          write(0);
+      }
+  
+!     protected void writeChar(String s, int t) {
+          writeString(s);
+      }
+  
+!     protected void writeSmallint(Number o) {
+          writeShort(o.intValue());
+      }
+  
+!     protected void writeInteger(Number o) {
+          writeInt(o.intValue());
+      }
+  
+!     protected void writeBigint(Number o) {
+          writeLong(o.longValue());
+      }
+  
+!     protected void writeReal(Double o, int type) {
+          writeLong(Double.doubleToLongBits((o.doubleValue())));
+      }
+  
+!     protected void writeDecimal(BigDecimal o) {
+  
+          int        scale   = o.scale();
+          BigInteger bigint  = JavaSystem.getUnscaledValue(o);
+--- 160,194 ----
+      }
+  
+  // fredt@users - comment - methods used for writing each SQL type
+!     public void writeFieldType(int type) {
+          write(1);
+      }
+  
+!     public void writeNull(int type) {
+          write(0);
+      }
+  
+!     public void writeChar(String s, int t) {
+          writeString(s);
+      }
+  
+!     public void writeSmallint(Number o) {
+          writeShort(o.intValue());
+      }
+  
+!     public void writeInteger(Number o) {
+          writeInt(o.intValue());
+      }
+  
+!     public void writeBigint(Number o) {
+          writeLong(o.longValue());
+      }
+  
+!     public void writeReal(Double o, int type) {
+          writeLong(Double.doubleToLongBits((o.doubleValue())));
+      }
+  
+!     public void writeDecimal(BigDecimal o) {
+  
+          int        scale   = o.scale();
+          BigInteger bigint  = JavaSystem.getUnscaledValue(o);
+*************** public class RowOutputBinary extends Row
+*** 198,231 ****
+          writeInt(scale);
+      }
+  
+!     protected void writeBit(Boolean o) {
+          write(o.booleanValue() ? 1
+                                 : 0);
+      }
+  
+!     protected void writeDate(Date o) {
+          writeLong(o.getTime());
+      }
+  
+!     protected void writeTime(Time o) {
+          writeLong(o.getTime());
+      }
+  
+!     protected void writeTimestamp(Timestamp o) {
+          writeLong(o.getTime());
+          writeInt(o.getNanos());
+      }
+  
+!     protected void writeOther(JavaObject o) {
+          writeByteArray(o.getBytes());
+      }
+  
+!     protected void writeBinary(Binary o, int t) {
+          writeByteArray(o.getBytes());
+      }
+  
+  // fredt@users - comment - helper and conversion methods
+!     protected void writeByteArray(byte[] b) {
+          writeInt(b.length);
+          write(b, 0, b.length);
+      }
+--- 198,231 ----
+          writeInt(scale);
+      }
+  
+!     public void writeBit(Boolean o) {
+          write(o.booleanValue() ? 1
+                                 : 0);
+      }
+  
+!     public void writeDate(Date o) {
+          writeLong(o.getTime());
+      }
+  
+!     public void writeTime(Time o) {
+          writeLong(o.getTime());
+      }
+  
+!     public void writeTimestamp(Timestamp o) {
+          writeLong(o.getTime());
+          writeInt(o.getNanos());
+      }
+  
+!     public void writeOther(JavaObject o) {
+          writeByteArray(o.getBytes());
+      }
+  
+!     public void writeBinary(Binary o, int t) {
+          writeByteArray(o.getBytes());
+      }
+  
+  // fredt@users - comment - helper and conversion methods
+!     public void writeByteArray(byte[] b) {
+          writeInt(b.length);
+          write(b, 0, b.length);
+      }
+*************** public class RowOutputBinary extends Row
+*** 239,245 ****
+       * @return size of byte array
+       * @exception  HsqlException when data is inconsistent
+       */
+!     private static int getSize(Object[] data, int l, int[] type) {
+  
+          int s = 0;
+  
+--- 239,245 ----
+       * @return size of byte array
+       * @exception  HsqlException when data is inconsistent
+       */
+!     public static int getSize(Object[] data, int l, int[] type) {
+  
+          int s = 0;
+  
+diff -pcr misc/hsqldb/src/org/hsqldb/rowio/RowOutputText.java misc/build/hsqldb/src/org/hsqldb/rowio/RowOutputText.java
+*** misc/hsqldb/src/org/hsqldb/rowio/RowOutputText.java	2006-01-07 17:01:31.000000000 +0100
+--- misc/build/hsqldb/src/org/hsqldb/rowio/RowOutputText.java	2007-02-28 12:32:48.000000000 +0100
+*************** import org.hsqldb.types.JavaObject;
+*** 54,69 ****
+   */
+  public class RowOutputText extends RowOutputBase {
+  
+!     protected String  fieldSep;
+!     protected String  varSep;
+!     protected String  longvarSep;
+!     private boolean   fieldSepEnd;
+!     private boolean   varSepEnd;
+!     private boolean   longvarSepEnd;
+!     private String    nextSep = "";
+!     private boolean   nextSepEnd;
+!     protected boolean allQuoted;
+!     private String    encoding;
+  
+      public RowOutputText(String fieldSep, String varSep, String longvarSep,
+                           boolean allQuoted, String encoding) {
+--- 54,69 ----
+   */
+  public class RowOutputText extends RowOutputBase {
+  
+!     public String  fieldSep;
+!     public String  varSep;
+!     public String  longvarSep;
+!     public boolean   fieldSepEnd;
+!     public boolean   varSepEnd;
+!     public boolean   longvarSepEnd;
+!     public String    nextSep = "";
+!     public boolean   nextSepEnd;
+!     public boolean allQuoted;
+!     public String    encoding;
+  
+      public RowOutputText(String fieldSep, String varSep, String longvarSep,
+                           boolean allQuoted, String encoding) {
+*************** public class RowOutputText extends RowOu
+*** 74,80 ****
+                                    encoding);
+      }
+  
+!     private void initTextDatabaseRowOutput(String fieldSep, String varSep,
+                                             String longvarSep,
+                                             boolean allQuoted,
+                                             String encoding) {
+--- 74,80 ----
+                                    encoding);
+      }
+  
+!     public void initTextDatabaseRowOutput(String fieldSep, String varSep,
+                                             String longvarSep,
+                                             boolean allQuoted,
+                                             String encoding) {
+*************** public class RowOutputText extends RowOu
+*** 142,148 ****
+          nextSepEnd = fieldSepEnd;
+      }
+  
+!     protected void writeVarString(String s) {
+  
+          s = checkConvertString(s, varSep);
+  
+--- 142,148 ----
+          nextSepEnd = fieldSepEnd;
+      }
+  
+!     public void writeVarString(String s) {
+  
+          s = checkConvertString(s, varSep);
+  
+*************** public class RowOutputText extends RowOu
+*** 159,165 ****
+          nextSepEnd = varSepEnd;
+      }
+  
+!     protected void writeLongVarString(String s) {
+  
+          s = checkConvertString(s, longvarSep);
+  
+--- 159,165 ----
+          nextSepEnd = varSepEnd;
+      }
+  
+!     public void writeLongVarString(String s) {
+  
+          s = checkConvertString(s, longvarSep);
+  
+*************** public class RowOutputText extends RowOu
+*** 176,182 ****
+          nextSepEnd = longvarSepEnd;
+      }
+  
+!     protected String checkConvertString(String s, String sep) {
+  
+          if (s.indexOf('\n') != -1 || s.indexOf('\r') != -1) {
+              throw new IllegalArgumentException(
+--- 176,182 ----
+          nextSepEnd = longvarSepEnd;
+      }
+  
+!     public String checkConvertString(String s, String sep) {
+  
+          if (s.indexOf('\n') != -1 || s.indexOf('\r') != -1) {
+              throw new IllegalArgumentException(
+*************** public class RowOutputText extends RowOu
+*** 188,194 ****
+          return s;
+      }
+  
+!     private byte[] getBytes(String s) {
+  
+          byte[] bytes = null;
+  
+--- 188,194 ----
+          return s;
+      }
+  
+!     public byte[] getBytes(String s) {
+  
+          byte[] bytes = null;
+  
+*************** public class RowOutputText extends RowOu
+*** 201,207 ****
+          return bytes;
+      }
+  
+!     protected void writeByteArray(byte[] b) {
+  
+          ensureRoom(b.length * 2);
+          StringConverter.writeHex(this.getBuffer(), count, b);
+--- 201,207 ----
+          return bytes;
+      }
+  
+!     public void writeByteArray(byte[] b) {
+  
+          ensureRoom(b.length * 2);
+          StringConverter.writeHex(this.getBuffer(), count, b);
+*************** public class RowOutputText extends RowOu
+*** 232,238 ****
+      }
+  
+  // fredt@users - comment - methods used for writing each SQL type
+!     protected void writeFieldType(int type) {
+  
+          writeBytes(nextSep);
+  
+--- 232,238 ----
+      }
+  
+  // fredt@users - comment - methods used for writing each SQL type
+!     public void writeFieldType(int type) {
+  
+          writeBytes(nextSep);
+  
+*************** public class RowOutputText extends RowOu
+*** 256,266 ****
+          }
+      }
+  
+!     protected void writeNull(int type) {
+          writeFieldType(type);
+      }
+  
+!     protected void writeChar(String s, int t) {
+  
+          switch (t) {
+  
+--- 256,266 ----
+          }
+      }
+  
+!     public void writeNull(int type) {
+          writeFieldType(type);
+      }
+  
+!     public void writeChar(String s, int t) {
+  
+          switch (t) {
+  
+*************** public class RowOutputText extends RowOu
+*** 283,332 ****
+          }
+      }
+  
+!     protected void writeSmallint(Number o) {
+          writeString(o.toString());
+      }
+  
+!     protected void writeInteger(Number o) {
+          writeString(o.toString());
+      }
+  
+!     protected void writeBigint(Number o) {
+          writeString(o.toString());
+      }
+  
+!     protected void writeReal(Double o, int type) {
+          writeString(o.toString());
+      }
+  
+!     protected void writeDecimal(BigDecimal o) {
+          writeString(o.toString());
+      }
+  
+!     protected void writeBit(Boolean o) {
+          writeString(o.toString());
+      }
+  
+!     protected void writeDate(Date o) {
+          writeString(o.toString());
+      }
+  
+!     protected void writeTime(Time o) {
+          writeString(o.toString());
+      }
+  
+!     protected void writeTimestamp(Timestamp o) {
+          writeString(o.toString());
+      }
+  
+!     protected void writeOther(JavaObject o) {
+  
+          byte[] ba = o.getBytes();
+  
+          writeByteArray(ba);
+      }
+  
+!     protected void writeBinary(Binary o, int t) {
+          writeByteArray(o.getBytes());
+      }
+  
+--- 283,332 ----
+          }
+      }
+  
+!     public void writeSmallint(Number o) {
+          writeString(o.toString());
+      }
+  
+!     public void writeInteger(Number o) {
+          writeString(o.toString());
+      }
+  
+!     public void writeBigint(Number o) {
+          writeString(o.toString());
+      }
+  
+!     public void writeReal(Double o, int type) {
+          writeString(o.toString());
+      }
+  
+!     public void writeDecimal(BigDecimal o) {
+          writeString(o.toString());
+      }
+  
+!     public void writeBit(Boolean o) {
+          writeString(o.toString());
+      }
+  
+!     public void writeDate(Date o) {
+          writeString(o.toString());
+      }
+  
+!     public void writeTime(Time o) {
+          writeString(o.toString());
+      }
+  
+!     public void writeTimestamp(Timestamp o) {
+          writeString(o.toString());
+      }
+  
+!     public void writeOther(JavaObject o) {
+  
+          byte[] ba = o.getBytes();
+  
+          writeByteArray(ba);
+      }
+  
+!     public void writeBinary(Binary o, int t) {
+          writeByteArray(o.getBytes());
+      }
+  
+diff -pcr misc/hsqldb/src/org/hsqldb/rowio/RowOutputTextLog.java misc/build/hsqldb/src/org/hsqldb/rowio/RowOutputTextLog.java
+*** misc/hsqldb/src/org/hsqldb/rowio/RowOutputTextLog.java	2005-10-23 20:26:26.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/rowio/RowOutputTextLog.java	2007-02-28 12:32:48.000000000 +0100
+*************** public class RowOutputTextLog extends Ro
+*** 57,101 ****
+      static final byte[]     BYTES_IS    = " IS ".getBytes();
+      public static final int MODE_DELETE = 1;
+      public static final int MODE_INSERT = 0;
+!     private boolean         isWritten;
+!     private int             logMode;
+  
+      public void setMode(int mode) {
+          logMode = mode;
+      }
+  
+!     protected void writeFieldPrefix() {
+  
+          if (logMode == MODE_DELETE && isWritten) {
+              write(BYTES_AND);
+          }
+      }
+  
+!     protected void writeChar(String s, int t) {
+  
+          write('\'');
+          StringConverter.unicodeToAscii(this, s, true);
+          write('\'');
+      }
+  
+!     protected void writeReal(Double o, int type) {
+          writeBytes(Column.createSQLString(((Number) o).doubleValue()));
+      }
+  
+!     protected void writeSmallint(Number o) {
+          this.writeBytes(o.toString());
+      }
+  
+      public void writeEnd() {}
+  
+!     protected void writeTime(Time o) {
+  
+          write('\'');
+          writeBytes(o.toString());
+          write('\'');
+      }
+  
+!     protected void writeBinary(Binary o, int t) {
+  
+          ensureRoom(o.getBytesLength() * 2 + 2);
+          write('\'');
+--- 57,101 ----
+      static final byte[]     BYTES_IS    = " IS ".getBytes();
+      public static final int MODE_DELETE = 1;
+      public static final int MODE_INSERT = 0;
+!     public boolean         isWritten;
+!     public int             logMode;
+  
+      public void setMode(int mode) {
+          logMode = mode;
+      }
+  
+!     public void writeFieldPrefix() {
+  
+          if (logMode == MODE_DELETE && isWritten) {
+              write(BYTES_AND);
+          }
+      }
+  
+!     public void writeChar(String s, int t) {
+  
+          write('\'');
+          StringConverter.unicodeToAscii(this, s, true);
+          write('\'');
+      }
+  
+!     public void writeReal(Double o, int type) {
+          writeBytes(Column.createSQLString(((Number) o).doubleValue()));
+      }
+  
+!     public void writeSmallint(Number o) {
+          this.writeBytes(o.toString());
+      }
+  
+      public void writeEnd() {}
+  
+!     public void writeTime(Time o) {
+  
+          write('\'');
+          writeBytes(o.toString());
+          write('\'');
+      }
+  
+!     public void writeBinary(Binary o, int t) {
+  
+          ensureRoom(o.getBytesLength() * 2 + 2);
+          write('\'');
+*************** public class RowOutputTextLog extends Ro
+*** 110,116 ****
+  
+      public void writeSize(int size) {}
+  
+!     protected void writeDate(Date o) {
+  
+          write('\'');
+          this.writeBytes(o.toString());
+--- 110,116 ----
+  
+      public void writeSize(int size) {}
+  
+!     public void writeDate(Date o) {
+  
+          write('\'');
+          this.writeBytes(o.toString());
+*************** public class RowOutputTextLog extends Ro
+*** 121,136 ****
+          return 0;
+      }
+  
+!     protected void writeInteger(Number o) {
+          this.writeBytes(o.toString());
+      }
+  
+!     protected void writeBigint(Number o) {
+          this.writeBytes(o.toString());
+      }
+  
+  //fredt@users - patch 1108647 by nkowalcz@users (NataliaK) fix for IS NULL
+!     protected void writeNull(int type) {
+  
+          if (logMode == MODE_DELETE) {
+              write(BYTES_IS);
+--- 121,136 ----
+          return 0;
+      }
+  
+!     public void writeInteger(Number o) {
+          this.writeBytes(o.toString());
+      }
+  
+!     public void writeBigint(Number o) {
+          this.writeBytes(o.toString());
+      }
+  
+  //fredt@users - patch 1108647 by nkowalcz@users (NataliaK) fix for IS NULL
+!     public void writeNull(int type) {
+  
+          if (logMode == MODE_DELETE) {
+              write(BYTES_IS);
+*************** public class RowOutputTextLog extends Ro
+*** 143,149 ****
+          write(BYTES_NULL);
+      }
+  
+!     protected void writeOther(JavaObject o) {
+  
+          ensureRoom(o.getBytesLength() * 2 + 2);
+          write('\'');
+--- 143,149 ----
+          write(BYTES_NULL);
+      }
+  
+!     public void writeOther(JavaObject o) {
+  
+          ensureRoom(o.getBytesLength() * 2 + 2);
+          write('\'');
+*************** public class RowOutputTextLog extends Ro
+*** 158,173 ****
+          StringConverter.unicodeToAscii(this, value, false);
+      }
+  
+!     protected void writeBit(Boolean o) {
+          write(o.booleanValue() ? BYTES_TRUE
+                                 : BYTES_FALSE);
+      }
+  
+!     protected void writeDecimal(BigDecimal o) {
+          this.writeBytes(o.toString());
+      }
+  
+!     protected void writeFieldType(int type) {
+  
+          if (logMode == MODE_DELETE) {
+              write('=');
+--- 158,173 ----
+          StringConverter.unicodeToAscii(this, value, false);
+      }
+  
+!     public void writeBit(Boolean o) {
+          write(o.booleanValue() ? BYTES_TRUE
+                                 : BYTES_FALSE);
+      }
+  
+!     public void writeDecimal(BigDecimal o) {
+          this.writeBytes(o.toString());
+      }
+  
+!     public void writeFieldType(int type) {
+  
+          if (logMode == MODE_DELETE) {
+              write('=');
+*************** public class RowOutputTextLog extends Ro
+*** 184,190 ****
+  
+      public void writeIntData(int i, int position) {}
+  
+!     protected void writeTimestamp(Timestamp o) {
+  
+          write('\'');
+          this.writeBytes(HsqlDateTime.getTimestampString(o));
+--- 184,190 ----
+  
+      public void writeIntData(int i, int position) {}
+  
+!     public void writeTimestamp(Timestamp o) {
+  
+          write('\'');
+          this.writeBytes(HsqlDateTime.getTimestampString(o));
+diff -pcr misc/hsqldb/src/org/hsqldb/rowio/RowOutputTextQuoted.java misc/build/hsqldb/src/org/hsqldb/rowio/RowOutputTextQuoted.java
+*** misc/hsqldb/src/org/hsqldb/rowio/RowOutputTextQuoted.java	2005-10-23 20:26:26.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/rowio/RowOutputTextQuoted.java	2007-02-28 12:32:48.000000000 +0100
+*************** public class RowOutputTextQuoted extends
+*** 49,55 ****
+          super(fieldSep, varSep, longvarSep, allQuoted, encoding);
+      }
+  
+!     protected String checkConvertString(String s, String sep) {
+  
+          if (allQuoted || s.length() == 0 || s.indexOf('\"') != -1
+                  || (sep.length() > 0 && s.indexOf(sep) != -1)
+--- 49,55 ----
+          super(fieldSep, varSep, longvarSep, allQuoted, encoding);
+      }
+  
+!     public String checkConvertString(String s, String sep) {
+  
+          if (allQuoted || s.length() == 0 || s.indexOf('\"') != -1
+                  || (sep.length() > 0 && s.indexOf(sep) != -1)
+*************** public class RowOutputTextQuoted extends
+*** 60,66 ****
+          return s;
+      }
+  
+!     private boolean hasUnprintable(String s) {
+  
+          for (int i = 0, len = s.length(); i < len; i++) {
+              if (Character.isISOControl(s.charAt(i))) {
+--- 60,66 ----
+          return s;
+      }
+  
+!     public boolean hasUnprintable(String s) {
+  
+          for (int i = 0, len = s.length(); i < len; i++) {
+              if (Character.isISOControl(s.charAt(i))) {
+diff -pcr misc/hsqldb/src/org/hsqldb/Row.java misc/build/hsqldb/src/org/hsqldb/Row.java
+*** misc/hsqldb/src/org/hsqldb/Row.java	2005-12-21 17:47:25.000000000 +0100
+--- misc/build/hsqldb/src/org/hsqldb/Row.java	2007-02-28 12:32:48.000000000 +0100
+*************** public class Row implements CachedObject
+*** 89,101 ****
+  
+      int                tableId;
+      int                iPos;
+!     protected Object[] oData;
+!     protected Node     nPrimaryNode;
+  
+      /**
+       *  Default constructor used only in subclasses.
+       */
+!     protected Row() {}
+  
+      /**
+       *  Constructor for MEMORY table Row. The result is a Row with Nodes that
+--- 89,101 ----
+  
+      int                tableId;
+      int                iPos;
+!     public Object[] oData;
+!     public Node     nPrimaryNode;
+  
+      /**
+       *  Default constructor used only in subclasses.
+       */
+!     public Row() {}
+  
+      /**
+       *  Constructor for MEMORY table Row. The result is a Row with Nodes that
+diff -pcr misc/hsqldb/src/org/hsqldb/sample/TriggerSample.java misc/build/hsqldb/src/org/hsqldb/sample/TriggerSample.java
+*** misc/hsqldb/src/org/hsqldb/sample/TriggerSample.java	2005-10-23 20:26:26.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/sample/TriggerSample.java	2007-02-28 12:32:48.000000000 +0100
+*************** public class TriggerSample implements Tr
+*** 211,217 ****
+          }
+      }
+  
+!     private static void doAssert(boolean b,
+                                   String msg) throws RuntimeException {
+  
+          if (b) {
+--- 211,217 ----
+          }
+      }
+  
+!     public static void doAssert(boolean b,
+                                   String msg) throws RuntimeException {
+  
+          if (b) {
+*************** public class TriggerSample implements Tr
+*** 224,230 ****
+          }
+      }
+  
+!     private static void doAuditStep(int typ, String tn, String ors,
+                                      String nrs) {
+  
+          Connection        conn;
+--- 224,230 ----
+          }
+      }
+  
+!     public static void doAuditStep(int typ, String tn, String ors,
+                                      String nrs) {
+  
+          Connection        conn;
+*************** public class TriggerSample implements Tr
+*** 373,379 ****
+          return sb.toString();
+      }
+  
+!     private static Connection getConnection() throws SQLException {
+  
+          try {
+              Class.forName(drv).newInstance();
+--- 373,379 ----
+          return sb.toString();
+      }
+  
+!     public static Connection getConnection() throws SQLException {
+  
+          try {
+              Class.forName(drv).newInstance();
+*************** public class TriggerSample implements Tr
+*** 386,397 ****
+          }
+      }
+  
+!     private static void createTrigger(Statement stmt, String trn,
+                                        int typ) throws SQLException {
+          stmt.execute(getTriggerDDL(trn, typ, tn, 0, impl));
+      }
+  
+!     private static void setup() throws SQLException {
+  
+          Connection conn = getConnection();
+          Statement  stmt = conn.createStatement();
+--- 386,397 ----
+          }
+      }
+  
+!     public static void createTrigger(Statement stmt, String trn,
+                                        int typ) throws SQLException {
+          stmt.execute(getTriggerDDL(trn, typ, tn, 0, impl));
+      }
+  
+!     public static void setup() throws SQLException {
+  
+          Connection conn = getConnection();
+          Statement  stmt = conn.createStatement();
+*************** public class TriggerSample implements Tr
+*** 416,422 ****
+          conn.close();
+      }
+  
+!     private static void doSomeWork() throws SQLException {
+  
+          Connection conn = getConnection();
+          Statement  stmt = conn.createStatement();
+--- 416,422 ----
+          conn.close();
+      }
+  
+!     public static void doSomeWork() throws SQLException {
+  
+          Connection conn = getConnection();
+          Statement  stmt = conn.createStatement();
+*************** public class TriggerSample implements Tr
+*** 448,454 ****
+          conn.close();
+      }
+  
+!     private static void dumpTable(String tn) throws SQLException {
+  
+          Connection        conn  = getConnection();
+          Statement         stmt  = conn.createStatement();
+--- 448,454 ----
+          conn.close();
+      }
+  
+!     public static void dumpTable(String tn) throws SQLException {
+  
+          Connection        conn  = getConnection();
+          Statement         stmt  = conn.createStatement();
+*************** public class TriggerSample implements Tr
+*** 483,489 ****
+          conn.close();
+      }
+  
+!     private static void runSample() throws SQLException {
+  
+          setup();
+          doSomeWork();
+--- 483,489 ----
+          conn.close();
+      }
+  
+!     public static void runSample() throws SQLException {
+  
+          setup();
+          doSomeWork();
+diff -pcr misc/hsqldb/src/org/hsqldb/scriptio/ScriptReaderBase.java misc/build/hsqldb/src/org/hsqldb/scriptio/ScriptReaderBase.java
+*** misc/hsqldb/src/org/hsqldb/scriptio/ScriptReaderBase.java	2005-10-23 20:26:27.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/scriptio/ScriptReaderBase.java	2007-02-28 12:32:48.000000000 +0100
+*************** public abstract class ScriptReaderBase {
+*** 82,98 ****
+          openFile();
+      }
+  
+!     protected abstract void openFile() throws IOException;
+  
+      public void readAll(Session session) throws IOException, HsqlException {
+          readDDL(session);
+          readExistingData(session);
+      }
+  
+!     protected abstract void readDDL(Session session)
+      throws IOException, HsqlException;
+  
+!     protected abstract void readExistingData(Session session)
+      throws IOException, HsqlException;
+  
+      public abstract boolean readLoggedStatement(Session session)
+--- 82,98 ----
+          openFile();
+      }
+  
+!     public abstract void openFile() throws IOException;
+  
+      public void readAll(Session session) throws IOException, HsqlException {
+          readDDL(session);
+          readExistingData(session);
+      }
+  
+!     public abstract void readDDL(Session session)
+      throws IOException, HsqlException;
+  
+!     public abstract void readExistingData(Session session)
+      throws IOException, HsqlException;
+  
+      public abstract boolean readLoggedStatement(Session session)
+diff -pcr misc/hsqldb/src/org/hsqldb/scriptio/ScriptReaderBinary.java misc/build/hsqldb/src/org/hsqldb/scriptio/ScriptReaderBinary.java
+*** misc/hsqldb/src/org/hsqldb/scriptio/ScriptReaderBinary.java	2006-07-27 01:16:33.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/scriptio/ScriptReaderBinary.java	2007-02-28 12:32:48.000000000 +0100
+*************** import org.hsqldb.rowio.RowInputBinary;
+*** 56,63 ****
+   */
+  class ScriptReaderBinary extends ScriptReaderBase {
+  
+!     private RowInputBinary    rowIn;
+!     protected DataInputStream dataStreamIn;
+  
+      ScriptReaderBinary(Database db,
+                         String file) throws HsqlException, IOException {
+--- 56,63 ----
+   */
+  class ScriptReaderBinary extends ScriptReaderBase {
+  
+!     public RowInputBinary    rowIn;
+!     public DataInputStream dataStreamIn;
+  
+      ScriptReaderBinary(Database db,
+                         String file) throws HsqlException, IOException {
+*************** class ScriptReaderBinary extends ScriptR
+*** 67,73 ****
+          rowIn = new RowInputBinary();
+      }
+  
+!     protected void openFile() throws IOException {
+  
+          InputStream d = db.isFilesInJar()
+                          ? getClass().getResourceAsStream(fileName)
+--- 67,73 ----
+          rowIn = new RowInputBinary();
+      }
+  
+!     public void openFile() throws IOException {
+  
+          InputStream d = db.isFilesInJar()
+                          ? getClass().getResourceAsStream(fileName)
+*************** class ScriptReaderBinary extends ScriptR
+*** 76,82 ****
+          dataStreamIn = new DataInputStream(new BufferedInputStream(d, 1 << 13));
+      }
+  
+!     protected void readDDL(Session session)
+      throws IOException, HsqlException {
+  
+          Result   r  = Result.read(rowIn, dataStreamIn);
+--- 76,82 ----
+          dataStreamIn = new DataInputStream(new BufferedInputStream(d, 1 << 13));
+      }
+  
+!     public void readDDL(Session session)
+      throws IOException, HsqlException {
+  
+          Result   r  = Result.read(rowIn, dataStreamIn);
+*************** class ScriptReaderBinary extends ScriptR
+*** 96,102 ****
+          }
+      }
+  
+!     protected void readExistingData(Session session)
+      throws IOException, HsqlException {
+  
+          for (;;) {
+--- 96,102 ----
+          }
+      }
+  
+!     public void readExistingData(Session session)
+      throws IOException, HsqlException {
+  
+          for (;;) {
+*************** class ScriptReaderBinary extends ScriptR
+*** 130,136 ****
+  
+      // int : row size (0 if no more rows) ,
+      // BinaryServerRowInput : row (column values)
+!     protected boolean readRow(Table t) throws IOException, HsqlException {
+  
+          boolean more = readRow(rowIn, 0);
+  
+--- 130,136 ----
+  
+      // int : row size (0 if no more rows) ,
+      // BinaryServerRowInput : row (column values)
+!     public boolean readRow(Table t) throws IOException, HsqlException {
+  
+          boolean more = readRow(rowIn, 0);
+  
+*************** class ScriptReaderBinary extends ScriptR
+*** 146,158 ****
+      }
+  
+      // int : rowcount
+!     protected int readTableTerm() throws IOException, HsqlException {
+          return dataStreamIn.readInt();
+      }
+  
+      // int : headersize (0 if no more tables), String : tablename, int : operation,
+      // String : schemaname
+!     protected String readTableInit() throws IOException, HsqlException {
+  
+          boolean more = readRow(rowIn, 0);
+  
+--- 146,158 ----
+      }
+  
+      // int : rowcount
+!     public int readTableTerm() throws IOException, HsqlException {
+          return dataStreamIn.readInt();
+      }
+  
+      // int : headersize (0 if no more tables), String : tablename, int : operation,
+      // String : schemaname
+!     public String readTableInit() throws IOException, HsqlException {
+  
+          boolean more = readRow(rowIn, 0);
+  
+diff -pcr misc/hsqldb/src/org/hsqldb/scriptio/ScriptReaderText.java misc/build/hsqldb/src/org/hsqldb/scriptio/ScriptReaderText.java
+*** misc/hsqldb/src/org/hsqldb/scriptio/ScriptReaderText.java	2006-07-17 00:29:34.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/scriptio/ScriptReaderText.java	2007-02-28 12:32:48.000000000 +0100
+*************** public class ScriptReaderText extends Sc
+*** 70,76 ****
+          rowIn = new RowInputTextLog();
+      }
+  
+!     protected void openFile() throws IOException {
+  
+          InputStream d = db.isFilesInJar()
+                          ? getClass().getResourceAsStream(fileName)
+--- 70,76 ----
+          rowIn = new RowInputTextLog();
+      }
+  
+!     public void openFile() throws IOException {
+  
+          InputStream d = db.isFilesInJar()
+                          ? getClass().getResourceAsStream(fileName)
+*************** public class ScriptReaderText extends Sc
+*** 80,86 ****
+              new InputStreamReader(new BufferedInputStream(d)));
+      }
+  
+!     protected void readDDL(Session session)
+      throws IOException, HsqlException {
+  
+          for (; readLoggedStatement(session); ) {
+--- 80,86 ----
+              new InputStreamReader(new BufferedInputStream(d)));
+      }
+  
+!     public void readDDL(Session session)
+      throws IOException, HsqlException {
+  
+          for (; readLoggedStatement(session); ) {
+*************** public class ScriptReaderText extends Sc
+*** 105,111 ****
+          }
+      }
+  
+!     protected void readExistingData(Session session)
+      throws IOException, HsqlException {
+  
+          try {
+--- 105,111 ----
+          }
+      }
+  
+!     public void readExistingData(Session session)
+      throws IOException, HsqlException {
+  
+          try {
+*************** public class ScriptReaderText extends Sc
+*** 165,171 ****
+          return true;
+      }
+  
+!     private void processStatement(Session session) throws IOException {
+  
+          try {
+              if (statement.startsWith("/*C")) {
+--- 165,171 ----
+          return true;
+      }
+  
+!     public void processStatement(Session session) throws IOException {
+  
+          try {
+              if (statement.startsWith("/*C")) {
+diff -pcr misc/hsqldb/src/org/hsqldb/scriptio/ScriptReaderZipped.java misc/build/hsqldb/src/org/hsqldb/scriptio/ScriptReaderZipped.java
+*** misc/hsqldb/src/org/hsqldb/scriptio/ScriptReaderZipped.java	2005-10-23 20:26:27.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/scriptio/ScriptReaderZipped.java	2007-02-28 12:32:48.000000000 +0100
+*************** class ScriptReaderZipped extends ScriptR
+*** 54,60 ****
+          super(db, file);
+      }
+  
+!     protected void openFile() throws IOException {
+  
+          InputStream d = db.isFilesInJar()
+                          ? getClass().getResourceAsStream(fileName)
+--- 54,60 ----
+          super(db, file);
+      }
+  
+!     public void openFile() throws IOException {
+  
+          InputStream d = db.isFilesInJar()
+                          ? getClass().getResourceAsStream(fileName)
+diff -pcr misc/hsqldb/src/org/hsqldb/scriptio/ScriptWriterBase.java misc/build/hsqldb/src/org/hsqldb/scriptio/ScriptWriterBase.java
+*** misc/hsqldb/src/org/hsqldb/scriptio/ScriptWriterBase.java	2006-07-19 12:52:18.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/scriptio/ScriptWriterBase.java	2007-02-28 12:32:48.000000000 +0100
+*************** public abstract class ScriptWriterBase i
+*** 101,107 ****
+      volatile boolean needsSync;
+      volatile boolean forceSync;
+      volatile boolean busyWriting;
+!     private int      syncCount;
+      static final int INSERT             = 0;
+      static final int INSERT_WITH_SCHEMA = 1;
+  
+--- 101,107 ----
+      volatile boolean needsSync;
+      volatile boolean forceSync;
+      volatile boolean busyWriting;
+!     public int      syncCount;
+      static final int INSERT             = 0;
+      static final int INSERT_WITH_SCHEMA = 1;
+  
+*************** public abstract class ScriptWriterBase i
+*** 167,173 ****
+          openFile();
+      }
+  
+!     protected abstract void initBuffers();
+  
+      /**
+       *  Called internally or externally in write delay intervals.
+--- 167,173 ----
+          openFile();
+      }
+  
+!     public abstract void initBuffers();
+  
+      /**
+       *  Called internally or externally in write delay intervals.
+*************** public abstract class ScriptWriterBase i
+*** 233,239 ****
+       *  File is opened in append mode although in current usage the file
+       *  never pre-exists
+       */
+!     protected void openFile() throws HsqlException {
+  
+          try {
+              FileAccess   fa  = isDump ? FileUtil.getDefaultInstance()
+--- 233,239 ----
+       *  File is opened in append mode although in current usage the file
+       *  never pre-exists
+       */
+!     public void openFile() throws HsqlException {
+  
+          try {
+              FileAccess   fa  = isDump ? FileUtil.getDefaultInstance()
+*************** public abstract class ScriptWriterBase i
+*** 254,262 ****
+       * This is not really useful in the current usage but may be if this
+       * class is used in a different way.
+       */
+!     protected void finishStream() throws IOException {}
+  
+!     protected void writeDDL() throws IOException, HsqlException {
+  
+          Result ddlPart = DatabaseScript.getScript(database,
+              !includeCachedData);
+--- 254,262 ----
+       * This is not really useful in the current usage but may be if this
+       * class is used in a different way.
+       */
+!     public void finishStream() throws IOException {}
+  
+!     public void writeDDL() throws IOException, HsqlException {
+  
+          Result ddlPart = DatabaseScript.getScript(database,
+              !includeCachedData);
+*************** public abstract class ScriptWriterBase i
+*** 264,270 ****
+          writeSingleColumnResult(ddlPart);
+      }
+  
+!     protected void writeExistingData() throws HsqlException, IOException {
+  
+          // start with blank schema - SET SCHEMA to log
+          currentSession.loggedSchema = null;
+--- 264,270 ----
+          writeSingleColumnResult(ddlPart);
+      }
+  
+!     public void writeExistingData() throws HsqlException, IOException {
+  
+          // start with blank schema - SET SCHEMA to log
+          currentSession.loggedSchema = null;
+*************** public abstract class ScriptWriterBase i
+*** 322,331 ****
+          writeDataTerm();
+      }
+  
+!     protected void writeTableInit(Table t)
+      throws HsqlException, IOException {}
+  
+!     protected void writeTableTerm(Table t) throws HsqlException, IOException {
+  
+          if (t.isDataReadOnly() &&!t.isTemp() &&!t.isText()) {
+              StringBuffer a = new StringBuffer("SET TABLE ");
+--- 322,331 ----
+          writeDataTerm();
+      }
+  
+!     public void writeTableInit(Table t)
+      throws HsqlException, IOException {}
+  
+!     public void writeTableTerm(Table t) throws HsqlException, IOException {
+  
+          if (t.isDataReadOnly() &&!t.isTemp() &&!t.isText()) {
+              StringBuffer a = new StringBuffer("SET TABLE ");
+*************** public abstract class ScriptWriterBase i
+*** 336,342 ****
+          }
+      }
+  
+!     protected void writeSingleColumnResult(Result r)
+      throws HsqlException, IOException {
+  
+          Iterator it = r.iterator();
+--- 336,342 ----
+          }
+      }
+  
+!     public void writeSingleColumnResult(Result r)
+      throws HsqlException, IOException {
+  
+          Iterator it = r.iterator();
+*************** public abstract class ScriptWriterBase i
+*** 351,359 ****
+      abstract void writeRow(Session session, Table table,
+                             Object[] data) throws HsqlException, IOException;
+  
+!     protected abstract void writeDataTerm() throws IOException;
+  
+!     protected abstract void addSessionId(Session session) throws IOException;
+  
+      public abstract void writeLogStatement(Session session,
+                                             String s)
+--- 351,359 ----
+      abstract void writeRow(Session session, Table table,
+                             Object[] data) throws HsqlException, IOException;
+  
+!     public abstract void writeDataTerm() throws IOException;
+  
+!     public abstract void addSessionId(Session session) throws IOException;
+  
+      public abstract void writeLogStatement(Session session,
+                                             String s)
+*************** public abstract class ScriptWriterBase i
+*** 372,381 ****
+      throws HsqlException, IOException;
+  
+      //
+!     private Object timerTask;
+  
+      // long write delay for scripts : 60s
+!     protected volatile int writeDelay = 60000;
+  
+      public void run() {
+  
+--- 372,381 ----
+      throws HsqlException, IOException;
+  
+      //
+!     public Object timerTask;
+  
+      // long write delay for scripts : 60s
+!     public volatile int writeDelay = 60000;
+  
+      public void run() {
+  
+diff -pcr misc/hsqldb/src/org/hsqldb/scriptio/ScriptWriterBinary.java misc/build/hsqldb/src/org/hsqldb/scriptio/ScriptWriterBinary.java
+*** misc/hsqldb/src/org/hsqldb/scriptio/ScriptWriterBinary.java	2005-10-23 20:26:27.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/scriptio/ScriptWriterBinary.java	2007-02-28 12:32:48.000000000 +0100
+*************** class ScriptWriterBinary extends ScriptW
+*** 55,72 ****
+          super(db, file, includeCached, newFile, false);
+      }
+  
+!     protected void initBuffers() {
+          rowOut = new RowOutputBinary();
+      }
+  
+!     protected void writeSingleColumnResult(Result r)
+      throws IOException, HsqlException {
+          Result.write(r, rowOut, fileStreamOut);
+      }
+  
+      // int : row size (0 if no more rows) ,
+      // RowInput/OutputBinary : row (column values)
+!     protected void writeRow(Session session, Table t,
+                              Object[] data) throws IOException, HsqlException {
+  
+          rowOut.reset();
+--- 55,72 ----
+          super(db, file, includeCached, newFile, false);
+      }
+  
+!     public void initBuffers() {
+          rowOut = new RowOutputBinary();
+      }
+  
+!     public void writeSingleColumnResult(Result r)
+      throws IOException, HsqlException {
+          Result.write(r, rowOut, fileStreamOut);
+      }
+  
+      // int : row size (0 if no more rows) ,
+      // RowInput/OutputBinary : row (column values)
+!     public void writeRow(Session session, Table t,
+                              Object[] data) throws IOException, HsqlException {
+  
+          rowOut.reset();
+*************** class ScriptWriterBinary extends ScriptW
+*** 77,83 ****
+      }
+  
+      // int : headersize (0 if no more tables), String : tablename, int : operation,
+!     protected void writeTableInit(Table t) throws HsqlException, IOException {
+  
+          tableRowCount = 0;
+  
+--- 77,83 ----
+      }
+  
+      // int : headersize (0 if no more tables), String : tablename, int : operation,
+!     public void writeTableInit(Table t) throws HsqlException, IOException {
+  
+          tableRowCount = 0;
+  
+*************** class ScriptWriterBinary extends ScriptW
+*** 90,96 ****
+          fileStreamOut.write(rowOut.getBuffer(), 0, rowOut.size());
+      }
+  
+!     protected void writeTableTerm(Table t) throws IOException {
+  
+          rowOut.reset();
+          rowOut.writeSize(0);
+--- 90,96 ----
+          fileStreamOut.write(rowOut.getBuffer(), 0, rowOut.size());
+      }
+  
+!     public void writeTableTerm(Table t) throws IOException {
+  
+          rowOut.reset();
+          rowOut.writeSize(0);
+*************** class ScriptWriterBinary extends ScriptW
+*** 98,104 ****
+          fileStreamOut.write(rowOut.getBuffer(), 0, rowOut.size());
+      }
+  
+!     protected void writeDataTerm() throws IOException {
+  
+          rowOut.reset();
+          rowOut.writeSize(0);
+--- 98,104 ----
+          fileStreamOut.write(rowOut.getBuffer(), 0, rowOut.size());
+      }
+  
+!     public void writeDataTerm() throws IOException {
+  
+          rowOut.reset();
+          rowOut.writeSize(0);
+*************** class ScriptWriterBinary extends ScriptW
+*** 109,115 ****
+                                    String s)
+                                    throws IOException, HsqlException {}
+  
+!     protected void addSessionId(Session session) throws IOException {}
+  
+      public void writeDeleteStatement(Session session, Table table,
+                                       Object[] ddata)
+--- 109,115 ----
+                                    String s)
+                                    throws IOException, HsqlException {}
+  
+!     public void addSessionId(Session session) throws IOException {}
+  
+      public void writeDeleteStatement(Session session, Table table,
+                                       Object[] ddata)
+diff -pcr misc/hsqldb/src/org/hsqldb/scriptio/ScriptWriterText.java misc/build/hsqldb/src/org/hsqldb/scriptio/ScriptWriterText.java
+*** misc/hsqldb/src/org/hsqldb/scriptio/ScriptWriterText.java	2006-07-19 19:14:45.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/scriptio/ScriptWriterText.java	2007-02-28 12:32:48.000000000 +0100
+*************** public class ScriptWriterText extends Sc
+*** 96,108 ****
+          super(db, file, includeCachedData, newFile, isDump);
+      }
+  
+!     protected void initBuffers() {
+          rowOut = new RowOutputTextLog();
+      }
+  
+!     protected void writeDataTerm() throws IOException {}
+  
+!     protected void addSessionId(Session session) throws IOException {
+  
+          if (session == null) {
+              return;
+--- 96,108 ----
+          super(db, file, includeCachedData, newFile, isDump);
+      }
+  
+!     public void initBuffers() {
+          rowOut = new RowOutputTextLog();
+      }
+  
+!     public void writeDataTerm() throws IOException {}
+  
+!     public void addSessionId(Session session) throws IOException {
+  
+          if (session == null) {
+              return;
+*************** public class ScriptWriterText extends Sc
+*** 123,129 ****
+          }
+      }
+  
+!     private void writeSchemaStatement(HsqlName schema) {
+  
+          rowOut.write(BYTES_SCHEMA);
+          rowOut.writeString(schema.statementName);
+--- 123,129 ----
+          }
+      }
+  
+!     public void writeSchemaStatement(HsqlName schema) {
+  
+          rowOut.write(BYTES_SCHEMA);
+          rowOut.writeString(schema.statementName);
+*************** public class ScriptWriterText extends Sc
+*** 152,158 ****
+          }
+      }
+  
+!     protected void writeRow(Session session, Table table,
+                              Object[] data) throws HsqlException, IOException {
+  
+          busyWriting = true;
+--- 152,158 ----
+          }
+      }
+  
+!     public void writeRow(Session session, Table table,
+                              Object[] data) throws HsqlException, IOException {
+  
+          busyWriting = true;
+*************** public class ScriptWriterText extends Sc
+*** 177,183 ****
+          }
+      }
+  
+!     protected void writeTableInit(Table t) throws HsqlException, IOException {
+  
+          if (t.isEmpty(currentSession)) {
+              return;
+--- 177,183 ----
+          }
+      }
+  
+!     public void writeTableInit(Table t) throws HsqlException, IOException {
+  
+          if (t.isEmpty(currentSession)) {
+              return;
+*************** public class ScriptWriterText extends Sc
+*** 275,281 ****
+          }
+      }
+  
+!     protected void finalize() {
+          sync();
+      }
+  }
+--- 275,281 ----
+          }
+      }
+  
+!     public void finalize() {
+          sync();
+      }
+  }
+diff -pcr misc/hsqldb/src/org/hsqldb/scriptio/ScriptWriterZipped.java misc/build/hsqldb/src/org/hsqldb/scriptio/ScriptWriterZipped.java
+*** misc/hsqldb/src/org/hsqldb/scriptio/ScriptWriterZipped.java	2006-07-17 00:29:33.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/scriptio/ScriptWriterZipped.java	2007-02-28 12:32:48.000000000 +0100
+*************** import org.hsqldb.lib.FileAccess;
+*** 48,54 ****
+   */
+  class ScriptWriterZipped extends ScriptWriterBinary {
+  
+!     private static final int bufferSize = 1 << 15;
+  
+      ScriptWriterZipped(Database db, String file, boolean includeCached,
+                         boolean newFile) throws HsqlException {
+--- 48,54 ----
+   */
+  class ScriptWriterZipped extends ScriptWriterBinary {
+  
+!     public static final int bufferSize = 1 << 15;
+  
+      ScriptWriterZipped(Database db, String file, boolean includeCached,
+                         boolean newFile) throws HsqlException {
+*************** class ScriptWriterZipped extends ScriptW
+*** 60,66 ****
+       */
+      public void sync() {}
+  
+!     protected void openFile() throws HsqlException {
+  
+          try {
+              FileAccess           fa  = database.getFileAccess();
+--- 60,66 ----
+       */
+      public void sync() {}
+  
+!     public void openFile() throws HsqlException {
+  
+          try {
+              FileAccess           fa  = database.getFileAccess();
+*************** class ScriptWriterZipped extends ScriptW
+*** 81,87 ****
+       * This may not really be necessary, unless we add implementations where
+       * non-compressed data is added to the end of the copressed part.
+       */
+!     protected void finishStream() throws IOException {
+          ((DeflaterOutputStream) fileStreamOut).finish();
+          fileStreamOut.flush();
+      }
+--- 81,87 ----
+       * This may not really be necessary, unless we add implementations where
+       * non-compressed data is added to the end of the copressed part.
+       */
+!     public void finishStream() throws IOException {
+          ((DeflaterOutputStream) fileStreamOut).finish();
+          fileStreamOut.flush();
+      }
+diff -pcr misc/hsqldb/src/org/hsqldb/Select.java misc/build/hsqldb/src/org/hsqldb/Select.java
+*** misc/hsqldb/src/org/hsqldb/Select.java	2006-07-10 13:03:43.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/Select.java	2007-02-28 12:32:48.000000000 +0100
+*************** class Select {
+*** 101,108 ****
+  
+      boolean               isDistinctSelect;
+      boolean               isAggregated;
+!     private boolean       isGrouped;
+!     private HashSet       groupColumnNames;
+      TableFilter[]         tFilter;
+      Expression            limitCondition;
+      Expression            queryCondition;     // null means no condition
+--- 101,108 ----
+  
+      boolean               isDistinctSelect;
+      boolean               isAggregated;
+!     public boolean       isGrouped;
+!     public HashSet       groupColumnNames;
+      TableFilter[]         tFilter;
+      Expression            limitCondition;
+      Expression            queryCondition;     // null means no condition
+*************** class Select {
+*** 127,133 ****
+                            UNIONALL  = 2,
+                            INTERSECT = 3,
+                            EXCEPT    = 4;
+!     private boolean       simpleLimit;        // true if maxrows can be uses as is
+      Result.ResultMetaData resultMetaData;
+  
+      /**
+--- 127,133 ----
+                            UNIONALL  = 2,
+                            INTERSECT = 3,
+                            EXCEPT    = 4;
+!     public boolean       simpleLimit;        // true if maxrows can be uses as is
+      Result.ResultMetaData resultMetaData;
+  
+      /**
+*************** class Select {
+*** 171,177 ****
+       *
+       * @throws HsqlException
+       */
+!     private void resolveTables() throws HsqlException {
+  
+          // replace the aliases with expressions
+          for (int i = iResultLen; i < exprColumns.length; i++) {
+--- 171,177 ----
+       *
+       * @throws HsqlException
+       */
+!     public void resolveTables() throws HsqlException {
+  
+          // replace the aliases with expressions
+          for (int i = iResultLen; i < exprColumns.length; i++) {
+*************** class Select {
+*** 277,283 ****
+          }
+      }
+  
+!     private void setFilterConditions(Session session) throws HsqlException {
+  
+          if (queryCondition == null) {
+              return;
+--- 277,283 ----
+          }
+      }
+  
+!     public void setFilterConditions(Session session) throws HsqlException {
+  
+          if (queryCondition == null) {
+              return;
+*************** class Select {
+*** 532,538 ****
+          return r;
+      }
+  
+!     private Result getResultMain(Session session) throws HsqlException {
+  
+          Result[] unionResults = new Result[unionArray.length];
+  
+--- 532,538 ----
+          return r;
+      }
+  
+!     public Result getResultMain(Session session) throws HsqlException {
+  
+          Result[] unionResults = new Result[unionArray.length];
+  
+*************** class Select {
+*** 587,593 ****
+       * Merges the second result into the first using the unionMode
+       * set operation.
+       */
+!     private void mergeResults(Session session, Result first,
+                                Result second) throws HsqlException {
+  
+          switch (unionType) {
+--- 587,593 ----
+       * Merges the second result into the first using the unionMode
+       * set operation.
+       */
+!     public void mergeResults(Session session, Result first,
+                                Result second) throws HsqlException {
+  
+          switch (unionType) {
+*************** class Select {
+*** 676,682 ****
+          return rowCount;
+      }
+  
+!     private Result getSingleResult(Session session,
+                                     int rowCount) throws HsqlException {
+  
+          if (resultMetaData == null) {
+--- 676,682 ----
+          return rowCount;
+      }
+  
+!     public Result getSingleResult(Session session,
+                                     int rowCount) throws HsqlException {
+  
+          if (resultMetaData == null) {
+*************** class Select {
+*** 700,706 ****
+          return r;
+      }
+  
+!     private void prepareSort() {
+  
+          if (iOrderLen == 0) {
+              return;
+--- 700,706 ----
+          return r;
+      }
+  
+!     public void prepareSort() {
+  
+          if (iOrderLen == 0) {
+              return;
+*************** class Select {
+*** 726,732 ****
+          }
+      }
+  
+!     private void sortResult(Session session, Result r) throws HsqlException {
+  
+          if (iOrderLen == 0) {
+              return;
+--- 726,732 ----
+          }
+      }
+  
+!     public void sortResult(Session session, Result r) throws HsqlException {
+  
+          if (iOrderLen == 0) {
+              return;
+*************** class Select {
+*** 740,746 ****
+       * If any result column is aggregated, then all result columns need to be
+       * aggregated, unless it is included in the group by clause.
+       */
+!     private void checkAggregateOrGroupByColumns(int start,
+              int end) throws HsqlException {
+  
+          if (start < end) {
+--- 740,746 ----
+       * If any result column is aggregated, then all result columns need to be
+       * aggregated, unless it is included in the group by clause.
+       */
+!     public void checkAggregateOrGroupByColumns(int start,
+              int end) throws HsqlException {
+  
+          if (start < end) {
+*************** class Select {
+*** 762,768 ****
+          }
+      }
+  
+!     private void checkAggregateOrGroupByOrderColumns(int start,
+              int end) throws HsqlException {
+  
+          checkAggregateOrGroupByColumns(start, end);
+--- 762,768 ----
+          }
+      }
+  
+!     public void checkAggregateOrGroupByOrderColumns(int start,
+              int end) throws HsqlException {
+  
+          checkAggregateOrGroupByColumns(start, end);
+*************** class Select {
+*** 799,805 ****
+       * <LI>All the columns in the expression are defined in the group by clause;
+       * </UL)
+       */
+!     private boolean inAggregateOrGroupByClause(Expression exp) {
+  
+          if (isGrouped) {
+              return isSimilarIn(exp, iResultLen, iResultLen + iGroupLen)
+--- 799,805 ----
+       * <LI>All the columns in the expression are defined in the group by clause;
+       * </UL)
+       */
+!     public boolean inAggregateOrGroupByClause(Expression exp) {
+  
+          if (isGrouped) {
+              return isSimilarIn(exp, iResultLen, iResultLen + iGroupLen)
+*************** class Select {
+*** 815,821 ****
+       * Check if the given expression is similar to any of the eColumn
+       * expressions within the given range.
+       */
+!     private boolean isSimilarIn(Expression exp, int start, int end) {
+  
+          for (int i = start; i < end; i++) {
+              if (exp.similarTo(exprColumns[i])) {
+--- 815,821 ----
+       * Check if the given expression is similar to any of the eColumn
+       * expressions within the given range.
+       */
+!     public boolean isSimilarIn(Expression exp, int start, int end) {
+  
+          for (int i = start; i < end; i++) {
+              if (exp.similarTo(exprColumns[i])) {
+*************** class Select {
+*** 853,859 ****
+      }
+  
+  // fredt@users 20030810 - patch 1.7.2 - OUTER JOIN rewrite
+!     private Result buildResult(Session session,
+                                 int limitcount) throws HsqlException {
+  
+          GroupedResult gResult   = new GroupedResult(this, resultMetaData);
+--- 853,859 ----
+      }
+  
+  // fredt@users 20030810 - patch 1.7.2 - OUTER JOIN rewrite
+!     public Result buildResult(Session session,
+                                 int limitcount) throws HsqlException {
+  
+          GroupedResult gResult   = new GroupedResult(this, resultMetaData);
+diff -pcr misc/hsqldb/src/org/hsqldb/ServerConfiguration.java misc/build/hsqldb/src/org/hsqldb/ServerConfiguration.java
+*** misc/hsqldb/src/org/hsqldb/ServerConfiguration.java	2006-05-06 13:27:32.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/ServerConfiguration.java	2007-02-28 12:32:48.000000000 +0100
+*************** import org.hsqldb.persist.HsqlProperties
+*** 49,55 ****
+   */
+  public final class ServerConfiguration implements ServerConstants {
+  
+!     private ServerConfiguration() {}
+  
+      /**
+       * Retrieves the default port that a Server will try to use in the
+--- 49,55 ----
+   */
+  public final class ServerConfiguration implements ServerConstants {
+  
+!     public ServerConfiguration() {}
+  
+      /**
+       * Retrieves the default port that a Server will try to use in the
+diff -pcr misc/hsqldb/src/org/hsqldb/ServerConnection.java misc/build/hsqldb/src/org/hsqldb/ServerConnection.java
+*** misc/hsqldb/src/org/hsqldb/ServerConnection.java	2006-01-07 17:01:32.000000000 +0100
+--- misc/build/hsqldb/src/org/hsqldb/ServerConnection.java	2007-02-28 12:32:48.000000000 +0100
+*************** import org.hsqldb.rowio.RowOutputBinary;
+*** 85,91 ****
+   *  and removed by this class when closed.<p>
+   *
+   *  When the database or server is shutdown, the signalClose() method is called
+!  *  for all current ServerConnection instances. This will call the private
+   *  close() method unless the ServerConnection thread itself has caused the
+   *  shutdown. In this case, the keepAlive flag is set to false, allowing the
+   *  thread to terminate once it has returned the result of the operation to
+--- 85,91 ----
+   *  and removed by this class when closed.<p>
+   *
+   *  When the database or server is shutdown, the signalClose() method is called
+!  *  for all current ServerConnection instances. This will call the public
+   *  close() method unless the ServerConnection thread itself has caused the
+   *  shutdown. In this case, the keepAlive flag is set to false, allowing the
+   *  thread to terminate once it has returned the result of the operation to
+*************** import org.hsqldb.rowio.RowOutputBinary;
+*** 102,117 ****
+  class ServerConnection implements Runnable {
+  
+      boolean                      keepAlive;
+!     private String               user;
+!     private String               password;
+      int                          dbID;
+!     private volatile Session     session;
+!     private Socket               socket;
+!     private Server               server;
+!     private DataInputStream      dataInput;
+!     private BufferedOutputStream dataOutput;
+!     private static int           mCurrentThread = 0;
+!     private int                  mThread;
+      static final int             BUFFER_SIZE = 0x1000;
+      final byte[]                 mainBuffer  = new byte[BUFFER_SIZE];
+      RowOutputBinary              rowOut = new RowOutputBinary(BUFFER_SIZE);
+--- 102,117 ----
+  class ServerConnection implements Runnable {
+  
+      boolean                      keepAlive;
+!     public String               user;
+!     public String               password;
+      int                          dbID;
+!     public volatile Session     session;
+!     public Socket               socket;
+!     public Server               server;
+!     public DataInputStream      dataInput;
+!     public BufferedOutputStream dataOutput;
+!     public static int           mCurrentThread = 0;
+!     public int                  mThread;
+      static final int             BUFFER_SIZE = 0x1000;
+      final byte[]                 mainBuffer  = new byte[BUFFER_SIZE];
+      RowOutputBinary              rowOut = new RowOutputBinary(BUFFER_SIZE);
+*************** class ServerConnection implements Runnab
+*** 157,163 ****
+      /**
+       * Closes this connection.
+       */
+!     private void close() {
+  
+          if (session != null) {
+              session.close();
+--- 157,163 ----
+      /**
+       * Closes this connection.
+       */
+!     public void close() {
+  
+          if (session != null) {
+              session.close();
+*************** class ServerConnection implements Runnab
+*** 178,184 ****
+      /**
+       * Initializes this connection.
+       */
+!     private void init() {
+  
+          runnerThread = Thread.currentThread();
+          keepAlive    = true;
+--- 178,184 ----
+      /**
+       * Initializes this connection.
+       */
+!     public void init() {
+  
+          runnerThread = Thread.currentThread();
+          keepAlive    = true;
+*************** class ServerConnection implements Runnab
+*** 272,278 ****
+       * Used by pooled connections to close the existing SQL session and open
+       * a new one.
+       */
+!     private Result resetSession() {
+  
+          Result resultOut;
+  
+--- 272,278 ----
+       * Used by pooled connections to close the existing SQL session and open
+       * a new one.
+       */
+!     public Result resetSession() {
+  
+          Result resultOut;
+  
+diff -pcr misc/hsqldb/src/org/hsqldb/Server.java misc/build/hsqldb/src/org/hsqldb/Server.java
+*** misc/hsqldb/src/org/hsqldb/Server.java	2006-05-09 20:13:36.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/Server.java	2007-02-28 12:32:48.000000000 +0100
+*************** import org.hsqldb.resources.BundleHandle
+*** 214,220 ****
+  public class Server implements HsqlSocketRequestHandler {
+  
+  //
+!     protected static final int serverBundleHandle =
+          BundleHandler.getBundleHandle("org_hsqldb_Server_messages", null);
+  
+  //
+--- 214,220 ----
+  public class Server implements HsqlSocketRequestHandler {
+  
+  //
+!     public static final int serverBundleHandle =
+          BundleHandler.getBundleHandle("org_hsqldb_Server_messages", null);
+  
+  //
+*************** public class Server implements HsqlSocke
+*** 224,253 ****
+      HashSet serverConnSet;
+  
+  //
+!     private String[]         dbAlias;
+!     private String[]         dbType;
+!     private String[]         dbPath;
+!     private HsqlProperties[] dbProps;
+!     private int[]            dbID;
+  
+  //  Currently unused
+!     private int maxConnections;
+  
+  //
+!     protected String            serverId;
+!     protected int               serverProtocol;
+!     protected ThreadGroup       serverConnectionThreadGroup;
+!     protected HsqlSocketFactory socketFactory;
+!     protected ServerSocket      socket;
+  
+  //
+!     private Thread           serverThread;
+!     private Throwable        serverError;
+!     private volatile int     serverState;
+!     private volatile boolean isSilent;
+!     private volatile boolean isRemoteOpen;
+!     private PrintWriter      logWriter;
+!     private PrintWriter      errWriter;
+  
+  //
+  
+--- 224,253 ----
+      HashSet serverConnSet;
+  
+  //
+!     public String[]         dbAlias;
+!     public String[]         dbType;
+!     public String[]         dbPath;
+!     public HsqlProperties[] dbProps;
+!     public int[]            dbID;
+  
+  //  Currently unused
+!     public int maxConnections;
+  
+  //
+!     public String            serverId;
+!     public int               serverProtocol;
+!     public ThreadGroup       serverConnectionThreadGroup;
+!     public HsqlSocketFactory socketFactory;
+!     public ServerSocket      socket;
+  
+  //
+!     public Thread           serverThread;
+!     public Throwable        serverError;
+!     public volatile int     serverState;
+!     public volatile boolean isSilent;
+!     public volatile boolean isRemoteOpen;
+!     public PrintWriter      logWriter;
+!     public PrintWriter      errWriter;
+  
+  //
+  
+*************** public class Server implements HsqlSocke
+*** 255,261 ****
+       * A specialized Thread inner class in which the run() method of this
+       * server executes.
+       */
+!     private class ServerThread extends Thread {
+  
+          /**
+           * Constructs a new thread in which to execute the run method
+--- 255,261 ----
+       * A specialized Thread inner class in which the run() method of this
+       * server executes.
+       */
+!     public class ServerThread extends Thread {
+  
+          /**
+           * Constructs a new thread in which to execute the run method
+*************** public class Server implements HsqlSocke
+*** 299,305 ****
+       * @param protocol the ServerConstants code indicating which
+       *      connection protocol to handle
+       */
+!     protected Server(int protocol) {
+          init(protocol);
+      }
+  
+--- 299,305 ----
+       * @param protocol the ServerConstants code indicating which
+       *      connection protocol to handle
+       */
+!     public Server(int protocol) {
+          init(protocol);
+      }
+  
+*************** public class Server implements HsqlSocke
+*** 419,425 ****
+          printWithThread("signalCloseAllServerConnections() exited");
+      }
+  
+!     protected void finalize() throws Throwable {
+  
+          if (serverThread != null) {
+              releaseServerSocket();
+--- 419,425 ----
+          printWithThread("signalCloseAllServerConnections() exited");
+      }
+  
+!     public void finalize() throws Throwable {
+  
+          if (serverThread != null) {
+              releaseServerSocket();
+*************** public class Server implements HsqlSocke
+*** 1289,1295 ****
+       *
+       * @param socket the socket to test.
+       */
+!     protected boolean allowConnection(Socket socket) {
+          return true;
+      }
+  
+--- 1289,1295 ----
+       *
+       * @param socket the socket to test.
+       */
+!     public boolean allowConnection(Socket socket) {
+          return true;
+      }
+  
+*************** public class Server implements HsqlSocke
+*** 1298,1304 ****
+       *
+       * @param protocol typically either SC_PROTOCOL_HTTP or SC_PROTOCOL_HSQL
+       */
+!     protected void init(int protocol) {
+  
+          // PRE:  This method is only called from the constructor
+          serverState      = ServerConstants.SERVER_STATE_SHUTDOWN;
+--- 1298,1304 ----
+       *
+       * @param protocol typically either SC_PROTOCOL_HTTP or SC_PROTOCOL_HSQL
+       */
+!     public void init(int protocol) {
+  
+          // PRE:  This method is only called from the constructor
+          serverState      = ServerConstants.SERVER_STATE_SHUTDOWN;
+*************** public class Server implements HsqlSocke
+*** 1318,1324 ****
+       *
+       * @param state the new value
+       */
+!     protected synchronized void setState(int state) {
+          serverState = state;
+      }
+  
+--- 1318,1324 ----
+       *
+       * @param state the new value
+       */
+!     public synchronized void setState(int state) {
+          serverState = state;
+      }
+  
+*************** public class Server implements HsqlSocke
+*** 1398,1404 ****
+       *
+       * @param msg The message to print
+       */
+!     protected synchronized void print(String msg) {
+  
+          PrintWriter writer = logWriter;
+  
+--- 1398,1404 ----
+       *
+       * @param msg The message to print
+       */
+!     public synchronized void print(String msg) {
+  
+          PrintWriter writer = logWriter;
+  
+*************** public class Server implements HsqlSocke
+*** 1443,1449 ****
+       *
+       * @param t the Throwable whose stack trace is to be printed
+       */
+!     protected synchronized void printStackTrace(Throwable t) {
+  
+          if (errWriter != null) {
+              t.printStackTrace(errWriter);
+--- 1443,1449 ----
+       *
+       * @param t the Throwable whose stack trace is to be printed
+       */
+!     public synchronized void printStackTrace(Throwable t) {
+  
+          if (errWriter != null) {
+              t.printStackTrace(errWriter);
+*************** public class Server implements HsqlSocke
+*** 1469,1475 ****
+       *
+       * @param msg the message to print
+       */
+!     protected void printWithThread(String msg) {
+  
+          if (!isSilent()) {
+              print("[" + Thread.currentThread() + "]: " + msg);
+--- 1469,1475 ----
+       *
+       * @param msg the message to print
+       */
+!     public void printWithThread(String msg) {
+  
+          if (!isSilent()) {
+              print("[" + Thread.currentThread() + "]: " + msg);
+*************** public class Server implements HsqlSocke
+*** 1483,1489 ****
+       *
+       * @param msg the message to print
+       */
+!     protected synchronized void printError(String msg) {
+  
+          PrintWriter writer = errWriter;
+  
+--- 1483,1489 ----
+       *
+       * @param msg the message to print
+       */
+!     public synchronized void printError(String msg) {
+  
+          PrintWriter writer = errWriter;
+  
+*************** public class Server implements HsqlSocke
+*** 1843,1849 ****
+      /**
+       * Initialises the database attributes lists from the server properties object.
+       */
+!     private void setDBInfoArrays() {
+  
+          dbAlias = getDBNameArray();
+          dbPath  = new String[dbAlias.length];
+--- 1843,1849 ----
+      /**
+       * Initialises the database attributes lists from the server properties object.
+       */
+!     public void setDBInfoArrays() {
+  
+          dbAlias = getDBNameArray();
+          dbPath  = new String[dbAlias.length];
+*************** public class Server implements HsqlSocke
+*** 1882,1888 ****
+       * Returns a possibly sparse array of all server.dbname.n values
+       * from the properties object.
+       */
+!     private String[] getDBNameArray() {
+  
+          final String prefix    = ServerConstants.SC_KEY_DBNAME + ".";
+          final int    prefixLen = prefix.length();
+--- 1882,1888 ----
+       * Returns a possibly sparse array of all server.dbname.n values
+       * from the properties object.
+       */
+!     public String[] getDBNameArray() {
+  
+          final String prefix    = ServerConstants.SC_KEY_DBNAME + ".";
+          final int    prefixLen = prefix.length();
+*************** public class Server implements HsqlSocke
+*** 1923,1929 ****
+       * @throws Exception if it is not possible to construct and install
+       *      a new ServerSocket
+       */
+!     private void openServerSocket() throws Exception {
+  
+          String    address;
+          int       port;
+--- 1923,1929 ----
+       * @throws Exception if it is not possible to construct and install
+       *      a new ServerSocket
+       */
+!     public void openServerSocket() throws Exception {
+  
+          String    address;
+          int       port;
+*************** public class Server implements HsqlSocke
+*** 1987,1993 ****
+      }
+  
+      /** Prints a timestamped message indicating that this server is online */
+!     private void printServerOnlineMessage() {
+  
+          String s = getProductName() + " " + getProductVersion()
+                     + " is online";
+--- 1987,1993 ----
+      }
+  
+      /** Prints a timestamped message indicating that this server is online */
+!     public void printServerOnlineMessage() {
+  
+          String s = getProductName() + " " + getProductVersion()
+                     + " is online";
+*************** public class Server implements HsqlSocke
+*** 1999,2005 ****
+      /**
+       * Prints a description of the server properties iff !isSilent().
+       */
+!     protected void printProperties() {
+  
+          Enumeration e;
+          String      key;
+--- 1999,2005 ----
+      /**
+       * Prints a description of the server properties iff !isSilent().
+       */
+!     public void printProperties() {
+  
+          Enumeration e;
+          String      key;
+*************** public class Server implements HsqlSocke
+*** 2027,2033 ****
+       * this method exists immediately, otherwise, the result is to fully
+       * shut down the server.
+       */
+!     private void releaseServerSocket() {
+  
+          printWithThread("releaseServerSocket() entered");
+  
+--- 2027,2033 ----
+       * this method exists immediately, otherwise, the result is to fully
+       * shut down the server.
+       */
+!     public void releaseServerSocket() {
+  
+          printWithThread("releaseServerSocket() entered");
+  
+*************** public class Server implements HsqlSocke
+*** 2056,2062 ****
+       * If any part of the process fails, then this server enters
+       * its shutdown sequence.
+       */
+!     private void run() {
+  
+          StopWatch   sw;
+          ThreadGroup tg;
+--- 2056,2062 ----
+       * If any part of the process fails, then this server enters
+       * its shutdown sequence.
+       */
+!     public void run() {
+  
+          StopWatch   sw;
+          ThreadGroup tg;
+*************** public class Server implements HsqlSocke
+*** 2140,2146 ****
+       *
+       * @param t The new value for the server error
+       */
+!     protected void setServerError(Throwable t) {
+          serverError = t;
+      }
+  
+--- 2140,2146 ----
+       *
+       * @param t The new value for the server error
+       */
+!     public void setServerError(Throwable t) {
+          serverError = t;
+      }
+  
+*************** public class Server implements HsqlSocke
+*** 2157,2163 ****
+       * @param error true if shutdown is in response to an error
+       *      state, else false
+       */
+!     protected synchronized void shutdown(boolean error) {
+  
+          if (serverState == ServerConstants.SERVER_STATE_SHUTDOWN) {
+              return;
+--- 2157,2163 ----
+       * @param error true if shutdown is in response to an error
+       *      state, else false
+       */
+!     public synchronized void shutdown(boolean error) {
+  
+          if (serverState == ServerConstants.SERVER_STATE_SHUTDOWN) {
+              return;
+*************** public class Server implements HsqlSocke
+*** 2240,2246 ****
+       *
+       * @param key for message
+       */
+!     protected static void printHelp(String key) {
+          System.out.print(BundleHandler.getString(serverBundleHandle, key));
+      }
+  }
+--- 2240,2246 ----
+       *
+       * @param key for message
+       */
+!     public static void printHelp(String key) {
+          System.out.print(BundleHandler.getString(serverBundleHandle, key));
+      }
+  }
+diff -pcr misc/hsqldb/src/org/hsqldb/Servlet.java misc/build/hsqldb/src/org/hsqldb/Servlet.java
+*** misc/hsqldb/src/org/hsqldb/Servlet.java	2006-07-21 15:38:03.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/Servlet.java	2007-02-28 12:32:48.000000000 +0100
+*************** import org.hsqldb.rowio.RowOutputBinary;
+*** 127,139 ****
+   */
+  public class Servlet extends javax.servlet.http.HttpServlet {
+  
+!     private static final int BUFFER_SIZE = 256;
+!     private String           dbType;
+!     private String           dbPath;
+!     private String           errorStr;
+!     private RowOutputBinary  rowOut;
+!     private RowInputBinary   rowIn;
+!     private int              iQueries;
+  
+      /**
+       * Method declaration
+--- 127,139 ----
+   */
+  public class Servlet extends javax.servlet.http.HttpServlet {
+  
+!     public static final int BUFFER_SIZE = 256;
+!     public String           dbType;
+!     public String           dbPath;
+!     public String           errorStr;
+!     public RowOutputBinary  rowOut;
+!     public RowInputBinary   rowIn;
+!     public int              iQueries;
+  
+      /**
+       * Method declaration
+*************** public class Servlet extends javax.servl
+*** 190,196 ****
+          log("Initialization completed.");
+      }
+  
+!     private static long lModified = 0;
+  
+      /**
+       * Method declaration
+--- 190,196 ----
+          log("Initialization completed.");
+      }
+  
+!     public static long lModified = 0;
+  
+      /**
+       * Method declaration
+*************** public class Servlet extends javax.servl
+*** 200,206 ****
+       *
+       * @return
+       */
+!     protected long getLastModified(HttpServletRequest req) {
+  
+          // this is made so that the cache of the http server is not used
+          // maybe there is some other way
+--- 200,206 ----
+       *
+       * @return
+       */
+!     public long getLastModified(HttpServletRequest req) {
+  
+          // this is made so that the cache of the http server is not used
+          // maybe there is some other way
+diff -pcr misc/hsqldb/src/org/hsqldb/Session.java misc/build/hsqldb/src/org/hsqldb/Session.java
+*** misc/hsqldb/src/org/hsqldb/Session.java	2006-04-11 16:41:05.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/Session.java	2007-02-28 12:32:48.000000000 +0100
+*************** import org.hsqldb.store.ValuePool;
+*** 112,156 ****
+  public class Session implements SessionInterface {
+  
+      //
+!     private volatile boolean isAutoCommit;
+!     private volatile boolean isReadOnly;
+!     private volatile boolean isClosed;
+  
+      //
+      Database          database;
+!     private User      user;
+      HsqlArrayList     rowActionList;
+!     private boolean   isNestedTransaction;
+!     private int       nestedOldTransIndex;
+      int               isolationMode = SessionInterface.TX_READ_COMMITTED;
+      long              actionTimestamp;
+      long              transactionTimestamp;
+!     private int       currentMaxRows;
+!     private int       sessionMaxRows;
+!     private Number    lastIdentity = ValuePool.getInt(0);
+!     private final int sessionId;
+      HashMappedList    savepoints;
+!     private boolean   script;
+!     private Tokenizer tokenizer;
+!     private Parser    parser;
+      static final Result emptyUpdateCount =
+          new Result(ResultConstants.UPDATECOUNT);
+  
+      //
+!     private jdbcConnection intConnection;
+  
+      // schema
+      public HsqlName  currentSchema;
+      public HsqlName  loggedSchema;
+!     private HsqlName oldSchema;
+  
+      // query processing
+      boolean isProcessingScript;
+      boolean isProcessingLog;
+  
+      // two types of temp tables
+!     private IntKeyHashMap indexArrayMap;
+!     private IntKeyHashMap indexArrayKeepMap;
+  
+      /** @todo fredt - clarify in which circumstances Session has to disconnect */
+      Session getSession() {
+--- 112,156 ----
+  public class Session implements SessionInterface {
+  
+      //
+!     public volatile boolean isAutoCommit;
+!     public volatile boolean isReadOnly;
+!     public volatile boolean isClosed;
+  
+      //
+      Database          database;
+!     public User      user;
+      HsqlArrayList     rowActionList;
+!     public boolean   isNestedTransaction;
+!     public int       nestedOldTransIndex;
+      int               isolationMode = SessionInterface.TX_READ_COMMITTED;
+      long              actionTimestamp;
+      long              transactionTimestamp;
+!     public int       currentMaxRows;
+!     public int       sessionMaxRows;
+!     public Number    lastIdentity = ValuePool.getInt(0);
+!     public final int sessionId;
+      HashMappedList    savepoints;
+!     public boolean   script;
+!     public Tokenizer tokenizer;
+!     public Parser    parser;
+      static final Result emptyUpdateCount =
+          new Result(ResultConstants.UPDATECOUNT);
+  
+      //
+!     public jdbcConnection intConnection;
+  
+      // schema
+      public HsqlName  currentSchema;
+      public HsqlName  loggedSchema;
+!     public HsqlName oldSchema;
+  
+      // query processing
+      boolean isProcessingScript;
+      boolean isProcessingLog;
+  
+      // two types of temp tables
+!     public IntKeyHashMap indexArrayMap;
+!     public IntKeyHashMap indexArrayKeepMap;
+  
+      /** @todo fredt - clarify in which circumstances Session has to disconnect */
+      Session getSession() {
+*************** public class Session implements SessionI
+*** 718,724 ****
+  
+  // boucherb@users 20020810 metadata 1.7.2
+  //----------------------------------------------------------------
+!     private final long connectTime = System.currentTimeMillis();
+  
+  // more effecient for MetaData concerns than checkAdmin
+  
+--- 718,724 ----
+  
+  // boucherb@users 20020810 metadata 1.7.2
+  //----------------------------------------------------------------
+!     public final long connectTime = System.currentTimeMillis();
+  
+  // more effecient for MetaData concerns than checkAdmin
+  
+*************** public class Session implements SessionI
+*** 994,1000 ****
+          }
+      }
+  
+!     private Result performPostExecute(Result r) {
+  
+          try {
+              if (database != null) {
+--- 994,1000 ----
+          }
+      }
+  
+!     public Result performPostExecute(Result r) {
+  
+          try {
+              if (database != null) {
+*************** public class Session implements SessionI
+*** 1024,1030 ****
+          return compiledStatementExecutor.execute(cs, pvals);
+      }
+  
+!     private Result sqlExecuteBatch(Result cmd) {
+  
+          int               csid;
+          Record            record;
+--- 1024,1030 ----
+          return compiledStatementExecutor.execute(cs, pvals);
+      }
+  
+!     public Result sqlExecuteBatch(Result cmd) {
+  
+          int               csid;
+          Record            record;
+*************** public class Session implements SessionI
+*** 1083,1089 ****
+          return out;
+      }
+  
+!     private Result sqlExecuteBatchDirect(Result cmd) {
+  
+          Record record;
+          Result out;
+--- 1083,1089 ----
+          return out;
+      }
+  
+!     public Result sqlExecuteBatchDirect(Result cmd) {
+  
+          Record record;
+          Result out;
+*************** public class Session implements SessionI
+*** 1144,1150 ****
+       *
+       * @return the result of executing the statement
+       */
+!     private Result sqlExecute(Result cmd) {
+  
+          int csid = cmd.getStatementID();
+          CompiledStatement cs = compiledStatementManager.getStatement(this,
+--- 1144,1150 ----
+       *
+       * @return the result of executing the statement
+       */
+!     public Result sqlExecute(Result cmd) {
+  
+          int csid = cmd.getStatementID();
+          CompiledStatement cs = compiledStatementManager.getStatement(this,
+*************** public class Session implements SessionI
+*** 1163,1169 ****
+          return sqlExecute(cs, pvals);
+      }
+  
+!     private Result sqlExecute(CompiledStatement cs, Object[] pvals) {
+          return sqlExecuteCompiledNoPreChecks(cs, pvals);
+      }
+  
+--- 1163,1169 ----
+          return sqlExecute(cs, pvals);
+      }
+  
+!     public Result sqlExecute(CompiledStatement cs, Object[] pvals) {
+          return sqlExecuteCompiledNoPreChecks(cs, pvals);
+      }
+  
+diff -pcr misc/hsqldb/src/org/hsqldb/SessionManager.java misc/build/hsqldb/src/org/hsqldb/SessionManager.java
+*** misc/hsqldb/src/org/hsqldb/SessionManager.java	2006-04-11 16:56:16.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/SessionManager.java	2007-02-28 12:32:48.000000000 +0100
+*************** import org.hsqldb.SchemaManager.Schema;
+*** 46,53 ****
+  public class SessionManager {
+  
+      int                   sessionIdCount = 1;
+!     private IntKeyHashMap sessionMap     = new IntKeyHashMap();
+!     private Session       sysSession;
+  
+  // TODO:
+  //
+--- 46,53 ----
+  public class SessionManager {
+  
+      int                   sessionIdCount = 1;
+!     public IntKeyHashMap sessionMap     = new IntKeyHashMap();
+!     public Session       sysSession;
+  
+  // TODO:
+  //
+diff -pcr misc/hsqldb/src/org/hsqldb/SetFunction.java misc/build/hsqldb/src/org/hsqldb/SetFunction.java
+*** misc/hsqldb/src/org/hsqldb/SetFunction.java	2005-10-23 20:26:27.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/SetFunction.java	2007-02-28 12:32:48.000000000 +0100
+*************** import org.hsqldb.store.ValuePool;
+*** 51,74 ****
+   */
+  public class SetFunction {
+  
+!     private HashSet distinctValues;
+!     private boolean isDistinct;
+  
+      //
+!     private int setType;
+!     private int type;
+  
+      //
+!     private int count;
+  
+      //
+!     private boolean    hasNull;
+!     private boolean    every = true;
+!     private boolean    some  = false;
+!     private long       currentLong;
+!     private double     currentDouble;
+!     private BigDecimal currentBigDecimal;
+!     private Object     currentValue;
+  
+      SetFunction(int setType, int type, boolean isDistinct) {
+  
+--- 51,74 ----
+   */
+  public class SetFunction {
+  
+!     public HashSet distinctValues;
+!     public boolean isDistinct;
+  
+      //
+!     public int setType;
+!     public int type;
+  
+      //
+!     public int count;
+  
+      //
+!     public boolean    hasNull;
+!     public boolean    every = true;
+!     public boolean    some  = false;
+!     public long       currentLong;
+!     public double     currentDouble;
+!     public BigDecimal currentBigDecimal;
+!     public Object     currentValue;
+  
+      SetFunction(int setType, int type, boolean isDistinct) {
+  
+*************** public class SetFunction {
+*** 423,435 ****
+      // end long sum
+      // statistics support - written by Campbell
+      // this section was orginally an independent class
+!     private double  sk;
+!     private double  vk;
+!     private long    n;
+!     private boolean initialized;
+!     private boolean sample;
+  
+!     private void addDataPoint(Number x) {    // optimized
+  
+          double xi;
+          double xsi;
+--- 423,435 ----
+      // end long sum
+      // statistics support - written by Campbell
+      // this section was orginally an independent class
+!     public double  sk;
+!     public double  vk;
+!     public long    n;
+!     public boolean initialized;
+!     public boolean sample;
+  
+!     public void addDataPoint(Number x) {    // optimized
+  
+          double xi;
+          double xsi;
+*************** public class SetFunction {
+*** 458,464 ****
+          sk  += xi;
+      }
+  
+!     private Number getVariance() {
+  
+          if (!initialized) {
+              return null;
+--- 458,464 ----
+          sk  += xi;
+      }
+  
+!     public Number getVariance() {
+  
+          if (!initialized) {
+              return null;
+*************** public class SetFunction {
+*** 469,475 ****
+                        : new Double(vk / (double) (n));
+      }
+  
+!     private Number getStdDev() {
+  
+          if (!initialized) {
+              return null;
+--- 469,475 ----
+                        : new Double(vk / (double) (n));
+      }
+  
+!     public Number getStdDev() {
+  
+          if (!initialized) {
+              return null;
+diff -pcr misc/hsqldb/src/org/hsqldb/SchemaManager.java misc/build/hsqldb/src/org/hsqldb/SchemaManager.java
+*** misc/hsqldb/src/org/hsqldb/SchemaManager.java	2006-05-06 13:16:34.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/SchemaManager.java	2007-02-28 12:32:48.000000000 +0100
+*************** public class SchemaManager {
+*** 780,786 ****
+      /**
+       * Throws if the table is referenced in a foreign key constraint.
+       */
+!     private void checkCascadeDropReferenced(Table table,
+              boolean cascade) throws HsqlException {
+  
+          Constraint[] constraints       = table.getConstraints();
+--- 780,786 ----
+      /**
+       * Throws if the table is referenced in a foreign key constraint.
+       */
+!     public void checkCascadeDropReferenced(Table table,
+              boolean cascade) throws HsqlException {
+  
+          Constraint[] constraints       = table.getConstraints();
+*************** public class SchemaManager {
+*** 903,909 ****
+      /**
+       * Returns an array of views that reference another view.
+       */
+!     private View[] getViewsWithView(View view) {
+  
+          HsqlArrayList list   = null;
+          Schema        schema = (Schema) schemaMap.get(view.getSchemaName());
+--- 903,909 ----
+      /**
+       * Returns an array of views that reference another view.
+       */
+!     public View[] getViewsWithView(View view) {
+  
+          HsqlArrayList list   = null;
+          Schema        schema = (Schema) schemaMap.get(view.getSchemaName());
+*************** public class SchemaManager {
+*** 932,938 ****
+       * Returns an array of views that reference the specified table or
+       * the specified column if column parameter is not null.
+       */
+!     private View[] getViewsWithTable(Table table, String column) {
+  
+          HsqlArrayList list = null;
+          Iterator      it   = allTablesIterator();
+--- 932,938 ----
+       * Returns an array of views that reference the specified table or
+       * the specified column if column parameter is not null.
+       */
+!     public View[] getViewsWithTable(Table table, String column) {
+  
+          HsqlArrayList list = null;
+          Iterator      it   = allTablesIterator();
+diff -pcr misc/hsqldb/src/org/hsqldb/store/BaseHashMap.java misc/build/hsqldb/src/org/hsqldb/store/BaseHashMap.java
+*** misc/hsqldb/src/org/hsqldb/store/BaseHashMap.java	2006-02-13 12:09:02.000000000 +0100
+--- misc/build/hsqldb/src/org/hsqldb/store/BaseHashMap.java	2007-02-28 12:32:48.000000000 +0100
+*************** public class BaseHashMap {
+*** 88,104 ****
+      boolean isObjectValue;
+  
+      //
+!     protected HashIndex hashIndex;
+  
+      //
+!     protected int[]    intKeyTable;
+!     protected Object[] objectKeyTable;
+!     protected long[]   longKeyTable;
+  
+      //
+!     protected int[]    intValueTable;
+!     protected Object[] objectValueTable;
+!     protected long[]   longValueTable;
+  
+      //
+      int   accessMin;
+--- 88,104 ----
+      boolean isObjectValue;
+  
+      //
+!     public HashIndex hashIndex;
+  
+      //
+!     public int[]    intKeyTable;
+!     public Object[] objectKeyTable;
+!     public long[]   longKeyTable;
+  
+      //
+!     public int[]    intValueTable;
+!     public Object[] objectValueTable;
+!     public long[]   longValueTable;
+  
+      //
+      int   accessMin;
+*************** public class BaseHashMap {
+*** 110,135 ****
+      final int         initialCapacity;
+      int               threshold;
+      int               maxCapacity;
+!     protected int     purgePolicy = NO_PURGE;
+!     protected boolean minimizeOnEmpty;
+  
+      //
+      boolean hasZeroKey;
+      int     zeroKeyIndex = -1;
+  
+      // keyOrValueTypes
+!     protected static final int noKeyOrValue     = 0;
+!     protected static final int intKeyOrValue    = 1;
+!     protected static final int longKeyOrValue   = 2;
+!     protected static final int objectKeyOrValue = 3;
+  
+      // purgePolicy
+!     protected static final int NO_PURGE      = 0;
+!     protected static final int PURGE_ALL     = 1;
+!     protected static final int PURGE_HALF    = 2;
+!     protected static final int PURGE_QUARTER = 3;
+  
+!     protected BaseHashMap(int initialCapacity, float loadFactor, int keyType,
+                            int valueType,
+                            boolean hasAccessCount)
+                            throws IllegalArgumentException {
+--- 110,135 ----
+      final int         initialCapacity;
+      int               threshold;
+      int               maxCapacity;
+!     public int     purgePolicy = NO_PURGE;
+!     public boolean minimizeOnEmpty;
+  
+      //
+      boolean hasZeroKey;
+      int     zeroKeyIndex = -1;
+  
+      // keyOrValueTypes
+!     public static final int noKeyOrValue     = 0;
+!     public static final int intKeyOrValue    = 1;
+!     public static final int longKeyOrValue   = 2;
+!     public static final int objectKeyOrValue = 3;
+  
+      // purgePolicy
+!     public static final int NO_PURGE      = 0;
+!     public static final int PURGE_ALL     = 1;
+!     public static final int PURGE_HALF    = 2;
+!     public static final int PURGE_QUARTER = 3;
+  
+!     public BaseHashMap(int initialCapacity, float loadFactor, int keyType,
+                            int valueType,
+                            boolean hasAccessCount)
+                            throws IllegalArgumentException {
+*************** public class BaseHashMap {
+*** 185,191 ****
+          }
+      }
+  
+!     protected int getLookup(Object key, int hash) {
+  
+          int    lookup = hashIndex.getLookup(hash);
+          Object tempKey;
+--- 185,191 ----
+          }
+      }
+  
+!     public int getLookup(Object key, int hash) {
+  
+          int    lookup = hashIndex.getLookup(hash);
+          Object tempKey;
+*************** public class BaseHashMap {
+*** 201,207 ****
+          return lookup;
+      }
+  
+!     protected int getLookup(int key) {
+  
+          int lookup = hashIndex.getLookup(key);
+          int tempKey;
+--- 201,207 ----
+          return lookup;
+      }
+  
+!     public int getLookup(int key) {
+  
+          int lookup = hashIndex.getLookup(key);
+          int tempKey;
+*************** public class BaseHashMap {
+*** 217,223 ****
+          return lookup;
+      }
+  
+!     protected int getLookup(long key) {
+  
+          int  lookup = hashIndex.getLookup((int) key);
+          long tempKey;
+--- 217,223 ----
+          return lookup;
+      }
+  
+!     public int getLookup(long key) {
+  
+          int  lookup = hashIndex.getLookup((int) key);
+          long tempKey;
+*************** public class BaseHashMap {
+*** 236,242 ****
+      /**
+       * generic method for adding or removing keys
+       */
+!     protected Object addOrRemove(long longKey, long longValue,
+                                   Object objectKey, Object objectValue,
+                                   boolean remove) {
+  
+--- 236,242 ----
+      /**
+       * generic method for adding or removing keys
+       */
+!     public Object addOrRemove(long longKey, long longValue,
+                                   Object objectKey, Object objectValue,
+                                   boolean remove) {
+  
+*************** public class BaseHashMap {
+*** 384,390 ****
+      /**
+       * type-specific method for adding or removing keys in int->Object maps
+       */
+!     protected Object addOrRemove(int intKey, Object objectValue,
+                                   boolean remove) {
+  
+          int    hash        = intKey;
+--- 384,390 ----
+      /**
+       * type-specific method for adding or removing keys in int->Object maps
+       */
+!     public Object addOrRemove(int intKey, Object objectValue,
+                                   boolean remove) {
+  
+          int    hash        = intKey;
+*************** public class BaseHashMap {
+*** 466,472 ****
+      /**
+       * type specific method for Object sets or Object->Object maps
+       */
+!     protected Object removeObject(Object objectKey) {
+  
+          if (objectKey == null) {
+              return null;
+--- 466,472 ----
+      /**
+       * type specific method for Object sets or Object->Object maps
+       */
+!     public Object removeObject(Object objectKey) {
+  
+          if (objectKey == null) {
+              return null;
+*************** public class BaseHashMap {
+*** 499,505 ****
+          return returnValue;
+      }
+  
+!     protected boolean reset() {
+  
+          if (maxCapacity == 0 || maxCapacity > threshold) {
+              rehash(hashIndex.hashTable.length * 2);
+--- 499,505 ----
+          return returnValue;
+      }
+  
+!     public boolean reset() {
+  
+          if (maxCapacity == 0 || maxCapacity > threshold) {
+              rehash(hashIndex.hashTable.length * 2);
+*************** public class BaseHashMap {
+*** 531,537 ****
+       *
+       * newCapacity must be larger or equal to existing number of elements.
+       */
+!     protected void rehash(int newCapacity) {
+  
+          int     limitLookup     = hashIndex.newNodePointer;
+          boolean oldZeroKey      = hasZeroKey;
+--- 531,537 ----
+       *
+       * newCapacity must be larger or equal to existing number of elements.
+       */
+!     public void rehash(int newCapacity) {
+  
+          int     limitLookup     = hashIndex.newNodePointer;
+          boolean oldZeroKey      = hasZeroKey;
+*************** public class BaseHashMap {
+*** 584,590 ****
+      /**
+       * resize the arrays contianing the key / value data
+       */
+!     private void resizeElementArrays(int dataLength, int newLength) {
+  
+          Object temp;
+          int    usedLength = newLength > dataLength ? dataLength
+--- 584,590 ----
+      /**
+       * resize the arrays contianing the key / value data
+       */
+!     public void resizeElementArrays(int dataLength, int newLength) {
+  
+          Object temp;
+          int    usedLength = newLength > dataLength ? dataLength
+*************** public class BaseHashMap {
+*** 643,649 ****
+      /**
+       * clear all the key / value data in a range.
+       */
+!     private void clearElementArrays(final int from, final int to) {
+  
+          if (isIntKey) {
+              int counter = to;
+--- 643,649 ----
+      /**
+       * clear all the key / value data in a range.
+       */
+!     public void clearElementArrays(final int from, final int to) {
+  
+          if (isIntKey) {
+              int counter = to;
+*************** public class BaseHashMap {
+*** 798,804 ****
+       * find the next lookup in the key/value tables with an entry
+       * uses current limits and zero integer key state
+       */
+!     protected int nextLookup(int lookup) {
+  
+          for (++lookup; lookup < hashIndex.newNodePointer; lookup++) {
+              if (isObjectKey) {
+--- 798,804 ----
+       * find the next lookup in the key/value tables with an entry
+       * uses current limits and zero integer key state
+       */
+!     public int nextLookup(int lookup) {
+  
+          for (++lookup; lookup < hashIndex.newNodePointer; lookup++) {
+              if (isObjectKey) {
+*************** public class BaseHashMap {
+*** 826,837 ****
+      /**
+       * row must already been freed of key / element
+       */
+!     protected void removeRow(int lookup) {
+          hashIndex.removeEmptyNode(lookup);
+          removeFromElementArrays(lookup);
+      }
+  
+!     protected Object removeLookup(int lookup) {
+  
+          if (isObjectKey) {
+              return addOrRemove(0, 0, objectKeyTable[lookup], null, true);
+--- 826,837 ----
+      /**
+       * row must already been freed of key / element
+       */
+!     public void removeRow(int lookup) {
+          hashIndex.removeEmptyNode(lookup);
+          removeFromElementArrays(lookup);
+      }
+  
+!     public Object removeLookup(int lookup) {
+  
+          if (isObjectKey) {
+              return addOrRemove(0, 0, objectKeyTable[lookup], null, true);
+*************** public class BaseHashMap {
+*** 862,868 ****
+       * Return the max accessCount value for count elements with the lowest
+       * access count. Always return at least accessMin + 1
+       */
+!     protected int getAccessCountCeiling(int count, int margin) {
+          return ArrayCounter.rank(accessTable, hashIndex.newNodePointer,
+                                   count, accessMin + 1, accessCount, margin);
+      }
+--- 862,868 ----
+       * Return the max accessCount value for count elements with the lowest
+       * access count. Always return at least accessMin + 1
+       */
+!     public int getAccessCountCeiling(int count, int margin) {
+          return ArrayCounter.rank(accessTable, hashIndex.newNodePointer,
+                                   count, accessMin + 1, accessCount, margin);
+      }
+*************** public class BaseHashMap {
+*** 873,879 ****
+       *
+       * Only for maps with Object key table
+       */
+!     protected void clear(int count, int margin) {
+  
+          if (margin < 64) {
+              margin = 64;
+--- 873,879 ----
+       *
+       * Only for maps with Object key table
+       */
+!     public void clear(int count, int margin) {
+  
+          if (margin < 64) {
+              margin = 64;
+*************** public class BaseHashMap {
+*** 917,923 ****
+          return hashIndex.elementCount == 0;
+      }
+  
+!     protected boolean containsKey(Object key) {
+  
+          if (key == null) {
+              return false;
+--- 917,923 ----
+          return hashIndex.elementCount == 0;
+      }
+  
+!     public boolean containsKey(Object key) {
+  
+          if (key == null) {
+              return false;
+*************** public class BaseHashMap {
+*** 929,935 ****
+                              : true;
+      }
+  
+!     protected boolean containsKey(int key) {
+  
+          int lookup = getLookup(key);
+  
+--- 929,935 ----
+                              : true;
+      }
+  
+!     public boolean containsKey(int key) {
+  
+          int lookup = getLookup(key);
+  
+*************** public class BaseHashMap {
+*** 937,943 ****
+                              : true;
+      }
+  
+!     protected boolean containsKey(long key) {
+  
+          int lookup = getLookup(key);
+  
+--- 937,943 ----
+                              : true;
+      }
+  
+!     public boolean containsKey(long key) {
+  
+          int lookup = getLookup(key);
+  
+*************** public class BaseHashMap {
+*** 945,951 ****
+                              : true;
+      }
+  
+!     protected boolean containsValue(Object value) {
+  
+          int lookup = 0;
+  
+--- 945,951 ----
+                              : true;
+      }
+  
+!     public boolean containsValue(Object value) {
+  
+          int lookup = 0;
+  
+*************** public class BaseHashMap {
+*** 986,992 ****
+       * Iterator returns Object, int or long and is used both for keys and
+       * values
+       */
+!     protected class BaseHashIterator implements org.hsqldb.lib.Iterator {
+  
+          boolean keys;
+          int     lookup = -1;
+--- 986,992 ----
+       * Iterator returns Object, int or long and is used both for keys and
+       * values
+       */
+!     public class BaseHashIterator implements org.hsqldb.lib.Iterator {
+  
+          boolean keys;
+          int     lookup = -1;
+diff -pcr misc/hsqldb/src/org/hsqldb/store/BitMap.java misc/build/hsqldb/src/org/hsqldb/store/BitMap.java
+*** misc/hsqldb/src/org/hsqldb/store/BitMap.java	2006-06-28 23:44:47.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/store/BitMap.java	2007-02-28 12:32:48.000000000 +0100
+*************** public class BitMap {
+*** 141,147 ****
+                                   : true;
+      }
+  
+!     private void doubleCapacity() {
+  
+          int[] newmap = new int[map.length * 2];
+  
+--- 141,147 ----
+                                   : true;
+      }
+  
+!     public void doubleCapacity() {
+  
+          int[] newmap = new int[map.length * 2];
+  
+diff -pcr misc/hsqldb/src/org/hsqldb/store/ValuePoolHashMap.java misc/build/hsqldb/src/org/hsqldb/store/ValuePoolHashMap.java
+*** misc/hsqldb/src/org/hsqldb/store/ValuePoolHashMap.java	2005-10-23 20:26:28.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/store/ValuePoolHashMap.java	2007-02-28 12:32:48.000000000 +0100
+*************** public class ValuePoolHashMap extends Ba
+*** 98,104 ****
+          this.purgePolicy = newPolicy;
+      }
+  
+!     protected Integer getOrAddInteger(int intKey) {
+  
+          Integer testValue;
+          int     index      = hashIndex.getHashIndex(intKey);
+--- 98,104 ----
+          this.purgePolicy = newPolicy;
+      }
+  
+!     public Integer getOrAddInteger(int intKey) {
+  
+          Integer testValue;
+          int     index      = hashIndex.getHashIndex(intKey);
+*************** public class ValuePoolHashMap extends Ba
+*** 140,146 ****
+          return testValue;
+      }
+  
+!     protected Long getOrAddLong(long longKey) {
+  
+          Long testValue;
+          int index = hashIndex.getHashIndex((int) (longKey
+--- 140,146 ----
+          return testValue;
+      }
+  
+!     public Long getOrAddLong(long longKey) {
+  
+          Long testValue;
+          int index = hashIndex.getHashIndex((int) (longKey
+*************** public class ValuePoolHashMap extends Ba
+*** 199,205 ****
+       * and hashCode().
+       * @return String from map or a new String
+       */
+!     protected String getOrAddString(Object key) {
+  
+          String testValue;
+          int    index      = hashIndex.getHashIndex(key.hashCode());
+--- 199,205 ----
+       * and hashCode().
+       * @return String from map or a new String
+       */
+!     public String getOrAddString(Object key) {
+  
+          String testValue;
+          int    index      = hashIndex.getHashIndex(key.hashCode());
+*************** public class ValuePoolHashMap extends Ba
+*** 241,247 ****
+          return testValue;
+      }
+  
+!     protected Date getOrAddDate(long longKey) {
+  
+          Date testValue;
+          int  hash       = (int) longKey ^ (int) (longKey >>> 32);
+--- 241,247 ----
+          return testValue;
+      }
+  
+!     public Date getOrAddDate(long longKey) {
+  
+          Date testValue;
+          int  hash       = (int) longKey ^ (int) (longKey >>> 32);
+*************** public class ValuePoolHashMap extends Ba
+*** 284,290 ****
+          return testValue;
+      }
+  
+!     protected Double getOrAddDouble(long longKey) {
+  
+          Double testValue;
+          int index = hashIndex.getHashIndex((int) (longKey
+--- 284,290 ----
+          return testValue;
+      }
+  
+!     public Double getOrAddDouble(long longKey) {
+  
+          Double testValue;
+          int index = hashIndex.getHashIndex((int) (longKey
+*************** public class ValuePoolHashMap extends Ba
+*** 327,333 ****
+          return testValue;
+      }
+  
+!     protected Object getOrAddObject(Object key) {
+  
+          Object testValue;
+          int    index      = hashIndex.getHashIndex(key.hashCode());
+--- 327,333 ----
+          return testValue;
+      }
+  
+!     public Object getOrAddObject(Object key) {
+  
+          Object testValue;
+          int    index      = hashIndex.getHashIndex(key.hashCode());
+diff -pcr misc/hsqldb/src/org/hsqldb/store/ValuePool.java misc/build/hsqldb/src/org/hsqldb/store/ValuePool.java
+*** misc/hsqldb/src/org/hsqldb/store/ValuePool.java	2005-10-23 20:26:28.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/store/ValuePool.java	2007-02-28 12:32:48.000000000 +0100
+*************** public class ValuePool {
+*** 77,83 ****
+          initPool();
+      }
+  
+!     private static void initPool() {
+  
+          int[] sizeArray  = defaultPoolLookupSize;
+          int   sizeFactor = defaultSizeFactor;
+--- 77,83 ----
+          initPool();
+      }
+  
+!     public static void initPool() {
+  
+          int[] sizeArray  = defaultPoolLookupSize;
+          int   sizeFactor = defaultSizeFactor;
+diff -pcr misc/hsqldb/src/org/hsqldb/TableFilter.java misc/build/hsqldb/src/org/hsqldb/TableFilter.java
+*** misc/hsqldb/src/org/hsqldb/TableFilter.java	2005-11-02 15:05:01.000000000 +0100
+--- misc/build/hsqldb/src/org/hsqldb/TableFilter.java	2007-02-28 12:32:48.000000000 +0100
+*************** final class TableFilter {
+*** 94,105 ****
+      static final int   CONDITION_END       = 3;    // candidate for eEnd
+      static final int   CONDITION_OUTER     = 4;    // add to this
+      Table              filterTable;
+!     private String     tableAlias;
+      HashMappedList     columnAliases;
+      Index              filterIndex;
+!     private Object[]   emptyData;
+      boolean[]          usedColumns;
+!     private Expression eStart, eEnd;
+  
+      //
+      Expression eAnd;
+--- 94,105 ----
+      static final int   CONDITION_END       = 3;    // candidate for eEnd
+      static final int   CONDITION_OUTER     = 4;    // add to this
+      Table              filterTable;
+!     public String     tableAlias;
+      HashMappedList     columnAliases;
+      Index              filterIndex;
+!     public Object[]   emptyData;
+      boolean[]          usedColumns;
+!     public Expression eStart, eEnd;
+  
+      //
+      Expression eAnd;
+*************** final class TableFilter {
+*** 111,117 ****
+      Expression[] findFirstExpressions;             // expressions for column values
+  
+      //
+!     private RowIterator it;
+      Object[]            currentData;
+      Row                 currentRow;
+  
+--- 111,117 ----
+      Expression[] findFirstExpressions;             // expressions for column values
+  
+      //
+!     public RowIterator it;
+      Object[]            currentData;
+      Row                 currentRow;
+  
+*************** final class TableFilter {
+*** 329,335 ****
+          }
+      }
+  
+!     private void setCondition(Session session,
+                                Expression e) throws HsqlException {
+  
+          int        type = e.getType();
+--- 329,335 ----
+          }
+      }
+  
+!     public void setCondition(Session session,
+                                Expression e) throws HsqlException {
+  
+          int        type = e.getType();
+*************** final class TableFilter {
+*** 649,655 ****
+       *
+       * @param e the condition to add
+       */
+!     private void addAndCondition(Expression e) {
+  
+          Expression e2 = new Expression(e);
+  
+--- 649,655 ----
+       *
+       * @param e the condition to add
+       */
+!     public void addAndCondition(Expression e) {
+  
+          Expression e2 = new Expression(e);
+  
+diff -pcr misc/hsqldb/src/org/hsqldb/Table.java misc/build/hsqldb/src/org/hsqldb/Table.java
+*** misc/hsqldb/src/org/hsqldb/Table.java	2007-02-28 12:31:52.000000000 +0100
+--- misc/build/hsqldb/src/org/hsqldb/Table.java	2007-02-28 12:32:48.000000000 +0100
+*************** public class Table extends BaseTable {
+*** 134,142 ****
+      // main properties
+  // boucherb@users - access changed in support of metadata 1.7.2
+      public HashMappedList columnList;                 // columns in table
+!     private int[]         primaryKeyCols;             // column numbers for primary key
+!     private int[]         primaryKeyTypes;            // types for primary key
+!     private int[]         primaryKeyColsSequence;     // {0,1,2,...}
+      int[]                 bestRowIdentifierCols;      // column set for best index
+      boolean               bestRowIdentifierStrict;    // true if it has no nullable column
+      int[]                 bestIndexForColumn;         // index of the 'best' index for each column
+--- 134,142 ----
+      // main properties
+  // boucherb@users - access changed in support of metadata 1.7.2
+      public HashMappedList columnList;                 // columns in table
+!     public int[]         primaryKeyCols;             // column numbers for primary key
+!     public int[]         primaryKeyTypes;            // types for primary key
+!     public int[]         primaryKeyColsSequence;     // {0,1,2,...}
+      int[]                 bestRowIdentifierCols;      // column set for best index
+      boolean               bestRowIdentifierStrict;    // true if it has no nullable column
+      int[]                 bestIndexForColumn;         // index of the 'best' index for each column
+*************** public class Table extends BaseTable {
+*** 148,177 ****
+  // -----------------------------------------------------------------------
+      Constraint[]      constraintList;                 // constrainst for the table
+      HsqlArrayList[]   triggerLists;                   // array of trigger lists
+!     private int[]     colTypes;                       // fredt - types of columns
+!     private int[]     colSizes;                       // fredt - copy of SIZE values for columns
+!     private int[]     colScales;                      // fredt - copy of SCALE values for columns
+!     private boolean[] colNullable;                    // fredt - modified copy of isNullable() values
+!     private Expression[] colDefaults;                 // fredt - expressions of DEFAULT values
+!     private int[]        defaultColumnMap;            // fred - holding 0,1,2,3,...
+!     private boolean      hasDefaultValues;            //fredt - shortcut for above
+      boolean              sqlEnforceSize;              // inherited from the database -
+  
+      // properties for subclasses
+!     protected int           columnCount;              // inclusive the hidden primary key
+      public Database         database;
+!     protected DataFileCache cache;
+!     protected HsqlName      tableName;                // SQL name
+!     private int             tableType;
+!     protected boolean       isReadOnly;
+!     protected boolean       isTemp;
+!     protected boolean       isCached;
+!     protected boolean       isText;
+!     protected boolean       isMemory;
+!     private boolean         isView;
+!     protected boolean       isLogged;
+!     protected int           indexType;                // fredt - type of index used
+!     protected boolean       onCommitPreserve;         // for temp tables
+  
+      //
+      PersistentStore rowStore;
+--- 148,177 ----
+  // -----------------------------------------------------------------------
+      Constraint[]      constraintList;                 // constrainst for the table
+      HsqlArrayList[]   triggerLists;                   // array of trigger lists
+!     public int[]     colTypes;                       // fredt - types of columns
+!     public int[]     colSizes;                       // fredt - copy of SIZE values for columns
+!     public int[]     colScales;                      // fredt - copy of SCALE values for columns
+!     public boolean[] colNullable;                    // fredt - modified copy of isNullable() values
+!     public Expression[] colDefaults;                 // fredt - expressions of DEFAULT values
+!     public int[]        defaultColumnMap;            // fred - holding 0,1,2,3,...
+!     public boolean      hasDefaultValues;            //fredt - shortcut for above
+      boolean              sqlEnforceSize;              // inherited from the database -
+  
+      // properties for subclasses
+!     public int           columnCount;              // inclusive the hidden primary key
+      public Database         database;
+!     public DataFileCache cache;
+!     public HsqlName      tableName;                // SQL name
+!     public int             tableType;
+!     public boolean       isReadOnly;
+!     public boolean       isTemp;
+!     public boolean       isCached;
+!     public boolean       isText;
+!     public boolean       isMemory;
+!     public boolean         isView;
+!     public boolean       isLogged;
+!     public int           indexType;                // fredt - type of index used
+!     public boolean       onCommitPreserve;         // for temp tables
+  
+      //
+      PersistentStore rowStore;
+*************** public class Table extends BaseTable {
+*** 353,359 ****
+      /**
+       * For text tables
+       */
+!     protected void setDataSource(Session s, String source, boolean isDesc,
+                                   boolean newFile) throws HsqlException {
+          throw (Trace.error(Trace.TABLE_NOT_FOUND));
+      }
+--- 353,359 ----
+      /**
+       * For text tables
+       */
+!     public void setDataSource(Session s, String source, boolean isDesc,
+                                   boolean newFile) throws HsqlException {
+          throw (Trace.error(Trace.TABLE_NOT_FOUND));
+      }
+*************** public class Table extends BaseTable {
+*** 361,374 ****
+      /**
+       * For text tables
+       */
+!     protected String getDataSource() {
+          return null;
+      }
+  
+      /**
+       * For text tables.
+       */
+!     protected boolean isDescDataSource() {
+          return false;
+      }
+  
+--- 361,374 ----
+      /**
+       * For text tables
+       */
+!     public String getDataSource() {
+          return null;
+      }
+  
+      /**
+       * For text tables.
+       */
+!     public boolean isDescDataSource() {
+          return false;
+      }
+  
+*************** public class Table extends BaseTable {
+*** 630,636 ****
+      /**
+       * returns a basic duplicate of the table without the data structures.
+       */
+!     protected Table duplicate() throws HsqlException {
+  
+          Table t = (new Table(database, tableName, tableType));
+  
+--- 630,636 ----
+      /**
+       * returns a basic duplicate of the table without the data structures.
+       */
+!     public Table duplicate() throws HsqlException {
+  
+          Table t = (new Table(database, tableName, tableType));
+  
+*************** public class Table extends BaseTable {
+*** 769,775 ****
+          return null;
+      }
+  
+!     private void copyIndexes(Table tn, int removeIndex, int colIndex,
+                               int adjust) throws HsqlException {
+  
+          for (int i = 1; i < getIndexCount(); i++) {
+--- 769,775 ----
+          return null;
+      }
+  
+!     public void copyIndexes(Table tn, int removeIndex, int colIndex,
+                               int adjust) throws HsqlException {
+  
+          for (int i = 1; i < getIndexCount(); i++) {
+*************** public class Table extends BaseTable {
+*** 840,846 ****
+          }
+      }
+  
+!     private void recompileCheckConstraints(Session session)
+      throws HsqlException {
+  
+          for (int i = 0, size = constraintList.length; i < size; i++) {
+--- 840,846 ----
+          }
+      }
+  
+!     public void recompileCheckConstraints(Session session)
+      throws HsqlException {
+  
+          for (int i = 0, size = constraintList.length; i < size; i++) {
+*************** public class Table extends BaseTable {
+*** 855,861 ****
+      /**
+       * Used after adding columns or indexes to the table.
+       */
+!     private void recompileCheckConstraint(Session session,
+                                            Constraint c) throws HsqlException {
+  
+          String     ddl       = c.core.check.getDDL();
+--- 855,861 ----
+      /**
+       * Used after adding columns or indexes to the table.
+       */
+!     public void recompileCheckConstraint(Session session,
+                                            Constraint c) throws HsqlException {
+  
+          String     ddl       = c.core.check.getDDL();
+*************** public class Table extends BaseTable {
+*** 938,944 ****
+      /**
+       * Used for rename column.
+       */
+!     private void renameColumnInCheckConstraints(String oldname,
+              String newname, boolean isquoted) throws HsqlException {
+  
+          for (int i = 0, size = constraintList.length; i < size; i++) {
+--- 938,944 ----
+      /**
+       * Used for rename column.
+       */
+!     public void renameColumnInCheckConstraints(String oldname,
+              String newname, boolean isquoted) throws HsqlException {
+  
+          for (int i = 0, size = constraintList.length; i < size; i++) {
+*************** public class Table extends BaseTable {
+*** 965,971 ****
+      /**
+       * Used for drop column.
+       */
+!     private void renameTableInCheckConstraints(Session session,
+              String oldname, String newname) throws HsqlException {
+  
+          for (int i = 0, size = constraintList.length; i < size; i++) {
+--- 965,971 ----
+      /**
+       * Used for drop column.
+       */
+!     public void renameTableInCheckConstraints(Session session,
+              String oldname, String newname) throws HsqlException {
+  
+          for (int i = 0, size = constraintList.length; i < size; i++) {
+*************** public class Table extends BaseTable {
+*** 1472,1478 ****
+       *  Create new index taking into account removal or addition of a column
+       *  to the table.
+       */
+!     private Index createAdjustedIndex(Index index, int colindex,
+                                        int adjust) throws HsqlException {
+  
+          int[] indexcolumns = (int[]) ArrayUtil.resizeArray(index.getColumns(),
+--- 1472,1478 ----
+       *  Create new index taking into account removal or addition of a column
+       *  to the table.
+       */
+!     public Index createAdjustedIndex(Index index, int colindex,
+                                        int adjust) throws HsqlException {
+  
+          int[] indexcolumns = (int[]) ArrayUtil.resizeArray(index.getColumns(),
+*************** public class Table extends BaseTable {
+*** 1596,1602 ****
+          return indexNo;
+      }
+  
+!     private int addIndex(Index index) {
+  
+          int i = 0;
+  
+--- 1596,1602 ----
+          return indexNo;
+      }
+  
+!     public int addIndex(Index index) {
+  
+          int i = 0;
+  
+*************** public class Table extends BaseTable {
+*** 1842,1848 ****
+       *  Mid level method for inserting rows. Performs constraint checks and
+       *  fires row level triggers.
+       */
+!     private void insertRow(Session session,
+                             Object[] data) throws HsqlException {
+  
+          if (triggerLists[Trigger.INSERT_BEFORE_ROW] != null) {
+--- 1842,1848 ----
+       *  Mid level method for inserting rows. Performs constraint checks and
+       *  fires row level triggers.
+       */
+!     public void insertRow(Session session,
+                             Object[] data) throws HsqlException {
+  
+          if (triggerLists[Trigger.INSERT_BEFORE_ROW] != null) {
+*************** public class Table extends BaseTable {
+*** 1889,1895 ****
+       *  UNIQUE or PRIMARY constraints are enforced by attempting to
+       *  add the row to the indexes.
+       */
+!     private void insertNoCheck(Session session,
+                                 Object[] data) throws HsqlException {
+  
+          Row row = newRow(data);
+--- 1889,1895 ----
+       *  UNIQUE or PRIMARY constraints are enforced by attempting to
+       *  add the row to the indexes.
+       */
+!     public void insertNoCheck(Session session,
+                                 Object[] data) throws HsqlException {
+  
+          Row row = newRow(data);
+*************** public class Table extends BaseTable {
+*** 2020,2026 ****
+       * Used by TextCache to insert a row into the indexes when the source
+       * file is first read.
+       */
+!     protected void insertFromTextSource(CachedRow row) throws HsqlException {
+  
+          Object[] data = row.getData();
+  
+--- 2020,2026 ----
+       * Used by TextCache to insert a row into the indexes when the source
+       * file is first read.
+       */
+!     public void insertFromTextSource(CachedRow row) throws HsqlException {
+  
+          Object[] data = row.getData();
+  
+*************** public class Table extends BaseTable {
+*** 2053,2059 ****
+      /**
+       * Checks a row against NOT NULL constraints on columns.
+       */
+!     protected void enforceNullConstraints(Object[] data)
+      throws HsqlException {
+  
+          for (int i = 0; i < columnCount; i++) {
+--- 2053,2059 ----
+      /**
+       * Checks a row against NOT NULL constraints on columns.
+       */
+!     public void enforceNullConstraints(Object[] data)
+      throws HsqlException {
+  
+          for (int i = 0; i < columnCount; i++) {
+*************** public class Table extends BaseTable {
+*** 2069,2075 ****
+       * If there is an identity column (visible or hidden) on the table, sets
+       * the value and/or adjusts the iIdentiy value for the table.
+       */
+!     protected void setIdentityColumn(Session session,
+                                       Object[] data) throws HsqlException {
+  
+          if (identityColumn != -1) {
+--- 2069,2075 ----
+       * If there is an identity column (visible or hidden) on the table, sets
+       * the value and/or adjusts the iIdentiy value for the table.
+       */
+!     public void setIdentityColumn(Session session,
+                                       Object[] data) throws HsqlException {
+  
+          if (identityColumn != -1) {
+*************** public class Table extends BaseTable {
+*** 2097,2103 ****
+       * If there is an identity column (visible or hidden) on the table, sets
+       * the max identity value.
+       */
+!     protected void updateIdentityValue(Object[] data) throws HsqlException {
+  
+          if (identityColumn != -1) {
+              Number id = (Number) data[identityColumn];
+--- 2097,2103 ----
+       * If there is an identity column (visible or hidden) on the table, sets
+       * the max identity value.
+       */
+!     public void updateIdentityValue(Object[] data) throws HsqlException {
+  
+          if (identityColumn != -1) {
+              Number id = (Number) data[identityColumn];
+*************** public class Table extends BaseTable {
+*** 2769,2775 ****
+       *  Mid level row delete method. Fires triggers but no integrity
+       *  constraint checks.
+       */
+!     private void deleteNoRefCheck(Session session,
+                                    Row row) throws HsqlException {
+  
+          Object[] data = row.getData();
+--- 2769,2775 ----
+       *  Mid level row delete method. Fires triggers but no integrity
+       *  constraint checks.
+       */
+!     public void deleteNoRefCheck(Session session,
+                                    Row row) throws HsqlException {
+  
+          Object[] data = row.getData();
+*************** public class Table extends BaseTable {
+*** 2785,2791 ****
+       * Low level row delete method. Removes the row from the indexes and
+       * from the Cache.
+       */
+!     private void deleteNoCheck(Session session, Row row,
+                                 boolean log) throws HsqlException {
+  
+          if (row.isCascadeDeleted()) {
+--- 2785,2791 ----
+       * Low level row delete method. Removes the row from the indexes and
+       * from the Cache.
+       */
+!     public void deleteNoCheck(Session session, Row row,
+                                 boolean log) throws HsqlException {
+  
+          if (row.isCascadeDeleted()) {
+diff -pcr misc/hsqldb/src/org/hsqldb/TableWorks.java misc/build/hsqldb/src/org/hsqldb/TableWorks.java
+*** misc/hsqldb/src/org/hsqldb/TableWorks.java	2007-02-28 12:31:52.000000000 +0100
+--- misc/build/hsqldb/src/org/hsqldb/TableWorks.java	2007-02-28 12:32:48.000000000 +0100
+*************** import org.hsqldb.lib.HashSet;
+*** 46,53 ****
+   */
+  class TableWorks {
+  
+!     private Table   table;
+!     private Session session;
+  
+      TableWorks(Session session, Table table) {
+          this.table   = table;
+--- 46,53 ----
+   */
+  class TableWorks {
+  
+!     public Table   table;
+!     public Session session;
+  
+      TableWorks(Session session, Table table) {
+          this.table   = table;
+diff -pcr misc/hsqldb/src/org/hsqldb/test/ExecHarness.java misc/build/hsqldb/src/org/hsqldb/test/ExecHarness.java
+*** misc/hsqldb/src/org/hsqldb/test/ExecHarness.java	2005-10-23 21:25:13.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/test/ExecHarness.java	2007-02-28 12:32:48.000000000 +0100
+*************** public class ExecHarness {
+*** 78,86 ****
+       * target program by a file, so that's all I'm implementing for stdin
+       * right now.
+       */
+!     private static final String SYNTAX_MSG =
+          "SYNTAX:  java org.hsqldb.test.ExecHarness targetprogram [args...]";
+!     private static final int MAX_PROG_OUTPUT = 10240;
+  
+      /**
+       * To test the ExecHarness class itself.
+--- 78,86 ----
+       * target program by a file, so that's all I'm implementing for stdin
+       * right now.
+       */
+!     public static final String SYNTAX_MSG =
+          "SYNTAX:  java org.hsqldb.test.ExecHarness targetprogram [args...]";
+!     public static final int MAX_PROG_OUTPUT = 10240;
+  
+      /**
+       * To test the ExecHarness class itself.
+*************** public class ExecHarness {
+*** 155,164 ****
+  
+      // The extra 1 is so we can request 1 more byte than we want.
+      // If that read is satisfied, we know that we read > MAX_PROG_OUTPUT.
+!     private byte[]              ba = new byte[MAX_PROG_OUTPUT + 1];
+!     private String              stdout          = null;
+!     private String              errout          = null;
+!     private static final String DEFAULT_CHARSET = "US-ASCII";
+  
+      /*
+       * Execute associated program synchronously, but in a separate process.
+--- 155,164 ----
+  
+      // The extra 1 is so we can request 1 more byte than we want.
+      // If that read is satisfied, we know that we read > MAX_PROG_OUTPUT.
+!     public byte[]              ba = new byte[MAX_PROG_OUTPUT + 1];
+!     public String              stdout          = null;
+!     public String              errout          = null;
+!     public static final String DEFAULT_CHARSET = "US-ASCII";
+  
+      /*
+       * Execute associated program synchronously, but in a separate process.
+diff -pcr misc/hsqldb/src/org/hsqldb/test/SqlToolHarness.java misc/build/hsqldb/src/org/hsqldb/test/SqlToolHarness.java
+*** misc/hsqldb/src/org/hsqldb/test/SqlToolHarness.java	2005-10-23 21:25:13.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/test/SqlToolHarness.java	2007-02-28 12:32:48.000000000 +0100
+*************** import java.util.regex.Pattern;
+*** 47,54 ****
+   */
+  public class SqlToolHarness {
+  
+!     private static final int MAX_SQLFILE_LEN = 10240;
+!     private static final String SYNTAX_MSG =
+          "SYNTAX:  java org.hsqldb.test.SqlToolHarness file1.sql [file2.sq...]";
+  
+      /**
+--- 47,54 ----
+   */
+  public class SqlToolHarness {
+  
+!     public static final int MAX_SQLFILE_LEN = 10240;
+!     public static final String SYNTAX_MSG =
+          "SYNTAX:  java org.hsqldb.test.SqlToolHarness file1.sql [file2.sq...]";
+  
+      /**
+*************** public class SqlToolHarness {
+*** 97,103 ****
+          Verbose = (tmp != null) && (tmp.trim().length() > 0);
+      }
+  
+!     private boolean Verbose = false;
+  
+      /**
+       * Run SqlTool according to metacommands embedded in given SQL file.
+--- 97,103 ----
+          Verbose = (tmp != null) && (tmp.trim().length() > 0);
+      }
+  
+!     public boolean Verbose = false;
+  
+      /**
+       * Run SqlTool according to metacommands embedded in given SQL file.
+*************** public class SqlToolHarness {
+*** 219,230 ****
+          return true;
+      }
+  
+!     private static String[]  mtString  = {};
+!     private static Pattern[] mtPattern = {};
+  
+!     private class Metadata {
+  
+!         private byte[] ba = new byte[MAX_SQLFILE_LEN + 1];
+  
+          public Metadata(File inFile)
+          throws FileNotFoundException, IOException {
+--- 219,230 ----
+          return true;
+      }
+  
+!     public static String[]  mtString  = {};
+!     public static Pattern[] mtPattern = {};
+  
+!     public class Metadata {
+  
+!         public byte[] ba = new byte[MAX_SQLFILE_LEN + 1];
+  
+          public Metadata(File inFile)
+          throws FileNotFoundException, IOException {
+*************** public class SqlToolHarness {
+*** 284,297 ****
+              }
+          }
+  
+!         private String[]  toolargs              = mtString;
+!         private String[]  jvmargs               = mtString;
+!         private Pattern[] requireStdoutPatterns = mtPattern;
+!         private Pattern[] rejectStdoutPatterns  = mtPattern;
+!         private Pattern[] requireErroutPatterns = mtPattern;
+!         private Pattern[] rejectErroutPatterns  = mtPattern;
+!         private boolean   inputAsFile           = false;
+!         private Integer   exitValue             = new Integer(0);
+  
+          public String toString() {
+  
+--- 284,297 ----
+              }
+          }
+  
+!         public String[]  toolargs              = mtString;
+!         public String[]  jvmargs               = mtString;
+!         public Pattern[] requireStdoutPatterns = mtPattern;
+!         public Pattern[] rejectStdoutPatterns  = mtPattern;
+!         public Pattern[] requireErroutPatterns = mtPattern;
+!         public Pattern[] rejectErroutPatterns  = mtPattern;
+!         public boolean   inputAsFile           = false;
+!         public Integer   exitValue             = new Integer(0);
+  
+          public String toString() {
+  
+*************** public class SqlToolHarness {
+*** 315,321 ****
+              return sb.toString();
+          }
+  
+!         private String getHarnessMetaBlock(File inFile)
+          throws FileNotFoundException, IOException {
+  
+              // The extra 1 is so we can request 1 more byte than we want.
+--- 315,321 ----
+              return sb.toString();
+          }
+  
+!         public String getHarnessMetaBlock(File inFile)
+          throws FileNotFoundException, IOException {
+  
+              // The extra 1 is so we can request 1 more byte than we want.
+diff -pcr misc/hsqldb/src/org/hsqldb/test/TestAllTypes.java misc/build/hsqldb/src/org/hsqldb/test/TestAllTypes.java
+*** misc/hsqldb/src/org/hsqldb/test/TestAllTypes.java	2005-10-23 20:26:28.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/test/TestAllTypes.java	2007-02-28 12:32:48.000000000 +0100
+*************** import org.hsqldb.persist.HsqlProperties
+*** 48,59 ****
+   */
+  public class TestAllTypes {
+  
+!     protected String url = "jdbc:hsqldb:";
+  
+! //    protected String filepath = ".";
+!     protected String filepath = "/hsql/testalltypes/test";
+  
+! //    protected String filepath = "hsql://localhost/yourtest";
+      boolean    network = true;
+      String     user;
+      String     password;
+--- 48,59 ----
+   */
+  public class TestAllTypes {
+  
+!     public String url = "jdbc:hsqldb:";
+  
+! //    public String filepath = ".";
+!     public String filepath = "/hsql/testalltypes/test";
+  
+! //    public String filepath = "hsql://localhost/yourtest";
+      boolean    network = true;
+      String     user;
+      String     password;
+*************** public class TestAllTypes {
+*** 79,85 ****
+      //
+      int bigrows = 1000;
+  
+!     protected void setUp() {
+  
+          user     = "sa";
+          password = "";
+--- 79,85 ----
+      //
+      int bigrows = 1000;
+  
+!     public void setUp() {
+  
+          user     = "sa";
+          password = "";
+*************** public class TestAllTypes {
+*** 266,274 ****
+          }
+      }
+  
+!     protected void tearDown() {}
+  
+!     protected void checkResults() {
+  
+          try {
+              StopWatch sw = new StopWatch();
+--- 266,274 ----
+          }
+      }
+  
+!     public void tearDown() {}
+  
+!     public void checkResults() {
+  
+          try {
+              StopWatch sw = new StopWatch();
+*************** public class TestAllTypes {
+*** 313,319 ****
+          }
+      }
+  
+!     private void checkSelects() {
+  
+          StopWatch        sw        = new StopWatch();
+          int              smallrows = 0xfff;
+--- 313,319 ----
+          }
+      }
+  
+!     public void checkSelects() {
+  
+          StopWatch        sw        = new StopWatch();
+          int              smallrows = 0xfff;
+*************** public class TestAllTypes {
+*** 368,374 ****
+                             + (i * 1000 / sw.elapsedTime()));
+      }
+  
+!     private void checkUpdates() {
+  
+          StopWatch        sw        = new StopWatch();
+          int              smallrows = 0xfff;
+--- 368,374 ----
+                             + (i * 1000 / sw.elapsedTime()));
+      }
+  
+!     public void checkUpdates() {
+  
+          StopWatch        sw        = new StopWatch();
+          int              smallrows = 0xfff;
+diff -pcr misc/hsqldb/src/org/hsqldb/test/TestBase.java misc/build/hsqldb/src/org/hsqldb/test/TestBase.java
+*** misc/hsqldb/src/org/hsqldb/test/TestBase.java	2006-04-11 16:48:36.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/test/TestBase.java	2007-02-28 12:32:48.000000000 +0100
+*************** public abstract class TestBase extends T
+*** 69,75 ****
+          this.url       = url;
+      }
+  
+!     protected void setUp() {
+  
+          if (isNetwork) {
+              if (url == null) {
+--- 69,75 ----
+          this.url       = url;
+      }
+  
+!     public void setUp() {
+  
+          if (isNetwork) {
+              if (url == null) {
+*************** public abstract class TestBase extends T
+*** 98,104 ****
+          }
+      }
+  
+!     protected void tearDown() {
+  
+          if (isNetwork) {
+              server.stop();
+--- 98,104 ----
+          }
+      }
+  
+!     public void tearDown() {
+  
+          if (isNetwork) {
+              server.stop();
+diff -pcr misc/hsqldb/src/org/hsqldb/test/TestBugBase.java misc/build/hsqldb/src/org/hsqldb/test/TestBugBase.java
+*** misc/hsqldb/src/org/hsqldb/test/TestBugBase.java	2005-06-08 21:52:37.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/test/TestBugBase.java	2007-02-28 12:32:48.000000000 +0100
+*************** public abstract class TestBugBase extend
+*** 59,65 ****
+          super(name);
+      }
+  
+!     protected void setUp() {
+  
+          server = new Server();
+  
+--- 59,65 ----
+          super(name);
+      }
+  
+!     public void setUp() {
+  
+          server = new Server();
+  
+*************** public abstract class TestBugBase extend
+*** 76,82 ****
+          }
+      }
+  
+!     protected void tearDown() {
+  
+          server.stop();
+  
+--- 76,82 ----
+          }
+      }
+  
+!     public void tearDown() {
+  
+          server.stop();
+  
+diff -pcr misc/hsqldb/src/org/hsqldb/test/TestCacheSize.java misc/build/hsqldb/src/org/hsqldb/test/TestCacheSize.java
+*** misc/hsqldb/src/org/hsqldb/test/TestCacheSize.java	2005-10-27 23:46:30.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/test/TestCacheSize.java	2007-02-28 12:32:48.000000000 +0100
+*************** import org.hsqldb.persist.HsqlProperties
+*** 70,86 ****
+  public class TestCacheSize {
+  
+      // program can edit the *.properties file to set cache_size, old files are deleted
+!     protected boolean filedb = true;
+  
+      // shutdown performed mid operation - not for mem: or hsql: URL's
+!     protected boolean shutdown = true;
+  
+      // fixed
+!     protected String url = "jdbc:hsqldb:";
+  
+! //    protected String  filepath = "hsql://localhost/mytest";
+! //    protected String filepath = "mem:test";
+!     protected String filepath = "/hsql/testcache/test";
+  
+      // frequent reporting of progress
+      boolean reportProgress = false;
+--- 70,86 ----
+  public class TestCacheSize {
+  
+      // program can edit the *.properties file to set cache_size, old files are deleted
+!     public boolean filedb = true;
+  
+      // shutdown performed mid operation - not for mem: or hsql: URL's
+!     public boolean shutdown = true;
+  
+      // fixed
+!     public String url = "jdbc:hsqldb:";
+  
+! //    public String  filepath = "hsql://localhost/mytest";
+! //    public String filepath = "mem:test";
+!     public String filepath = "/hsql/testcache/test";
+  
+      // frequent reporting of progress
+      boolean reportProgress = false;
+*************** public class TestCacheSize {
+*** 124,137 ****
+      Connection cConnection;
+      FileWriter writer;
+  
+!     private void checkSelects() {
+  
+          countTestID();
+          selectID();
+          selectZipTable();
+      }
+  
+!     private void checkUpdates() {
+  
+          updateIDLinear();
+          updateID();
+--- 124,137 ----
+      Connection cConnection;
+      FileWriter writer;
+  
+!     public void checkSelects() {
+  
+          countTestID();
+          selectID();
+          selectZipTable();
+      }
+  
+!     public void checkUpdates() {
+  
+          updateIDLinear();
+          updateID();
+*************** public class TestCacheSize {
+*** 141,147 ****
+          countZip();
+      }
+  
+!     protected void setUp() {
+  
+          try {
+              writer = new FileWriter("speedtests.html", true);
+--- 141,147 ----
+          countZip();
+      }
+  
+!     public void setUp() {
+  
+          try {
+              writer = new FileWriter("speedtests.html", true);
+*************** public class TestCacheSize {
+*** 313,319 ****
+          }
+      }
+  
+!     private void fillUpBigTable(String filler,
+                                  Random randomgen) throws SQLException {
+  
+          StopWatch sw = new StopWatch();
+--- 313,319 ----
+          }
+      }
+  
+!     public void fillUpBigTable(String filler,
+                                  Random randomgen) throws SQLException {
+  
+          StopWatch sw = new StopWatch();
+*************** public class TestCacheSize {
+*** 415,421 ****
+                             + " ms -- " + rate + " tps");
+      }
+  
+!     private void fillUpMultiTable(String filler,
+                                    Random randomgen) throws SQLException {
+  
+          StopWatch sw = new StopWatch();
+--- 415,421 ----
+                             + " ms -- " + rate + " tps");
+      }
+  
+!     public void fillUpMultiTable(String filler,
+                                    Random randomgen) throws SQLException {
+  
+          StopWatch sw = new StopWatch();
+*************** public class TestCacheSize {
+*** 468,474 ****
+                             + (i * 1000 / (sw.elapsedTime() + 1)));
+      }
+  
+!     protected void tearDown() {
+  
+          try {
+              writer.write("\n</table>\n");
+--- 468,474 ----
+                             + (i * 1000 / (sw.elapsedTime() + 1)));
+      }
+  
+!     public void tearDown() {
+  
+          try {
+              writer.write("\n</table>\n");
+*************** public class TestCacheSize {
+*** 476,482 ****
+          } catch (Exception e) {}
+      }
+  
+!     protected void checkResults() {
+  
+          try {
+              StopWatch sw = new StopWatch();
+--- 476,482 ----
+          } catch (Exception e) {}
+      }
+  
+!     public void checkResults() {
+  
+          try {
+              StopWatch sw = new StopWatch();
+*************** public class TestCacheSize {
+*** 623,629 ****
+                             + " rows  -- " + time + " ms -- " + rate + " tps");
+      }
+  
+!     private void countTestID() {
+  
+          try {
+              StopWatch sw = new StopWatch();
+--- 623,629 ----
+                             + " rows  -- " + time + " ms -- " + rate + " tps");
+      }
+  
+!     public void countTestID() {
+  
+          try {
+              StopWatch sw = new StopWatch();
+*************** public class TestCacheSize {
+*** 646,652 ****
+          } catch (SQLException e) {}
+      }
+  
+!     private void countTestZip() {
+  
+          try {
+              StopWatch sw = new StopWatch();
+--- 646,652 ----
+          } catch (SQLException e) {}
+      }
+  
+!     public void countTestZip() {
+  
+          try {
+              StopWatch sw = new StopWatch();
+*************** public class TestCacheSize {
+*** 667,673 ****
+          } catch (SQLException e) {}
+      }
+  
+!     private void countZip() {
+  
+          try {
+              StopWatch sw = new StopWatch();
+--- 667,673 ----
+          } catch (SQLException e) {}
+      }
+  
+!     public void countZip() {
+  
+          try {
+              StopWatch sw = new StopWatch();
+*************** public class TestCacheSize {
+*** 682,688 ****
+          } catch (SQLException e) {}
+      }
+  
+!     private void updateZip() {
+  
+          StopWatch        sw        = new StopWatch();
+          java.util.Random randomgen = new java.util.Random();
+--- 682,688 ----
+          } catch (SQLException e) {}
+      }
+  
+!     public void updateZip() {
+  
+          StopWatch        sw        = new StopWatch();
+          java.util.Random randomgen = new java.util.Random();
+diff -pcr misc/hsqldb/src/org/hsqldb/test/TestCascade.java misc/build/hsqldb/src/org/hsqldb/test/TestCascade.java
+*** misc/hsqldb/src/org/hsqldb/test/TestCascade.java	2005-10-23 20:26:29.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/test/TestCascade.java	2007-02-28 12:32:48.000000000 +0100
+*************** public class TestCascade extends TestCas
+*** 59,65 ****
+          super(name);
+      }
+  
+!     protected void setUp() {
+  
+          try {
+              Class.forName("org.hsqldb.jdbcDriver");
+--- 59,65 ----
+          super(name);
+      }
+  
+!     public void setUp() {
+  
+          try {
+              Class.forName("org.hsqldb.jdbcDriver");
+*************** public class TestCascade extends TestCas
+*** 72,78 ****
+          }
+      }
+  
+!     protected void tearDown() {
+  
+          try {
+              con.close();
+--- 72,78 ----
+          }
+      }
+  
+!     public void tearDown() {
+  
+          try {
+              con.close();
+*************** public class TestCascade extends TestCas
+*** 109,115 ****
+          }
+      }
+  
+!     private static void createDatabase() throws SQLException {
+  
+          new File("testdb.backup").delete();
+          new File("testdb.data").delete();
+--- 109,115 ----
+          }
+      }
+  
+!     public static void createDatabase() throws SQLException {
+  
+          new File("testdb.backup").delete();
+          new File("testdb.data").delete();
+*************** public class TestCascade extends TestCas
+*** 141,147 ****
+       * the CA table has 12 records. After, it should have 9, but instead it has
+       * 0.
+       */
+!     private static void deleteXBRecord(Connection con) throws SQLException {
+  
+          Statement stmt = con.createStatement();
+  
+--- 141,147 ----
+       * the CA table has 12 records. After, it should have 9, but instead it has
+       * 0.
+       */
+!     public static void deleteXBRecord(Connection con) throws SQLException {
+  
+          Statement stmt = con.createStatement();
+  
+*************** public class TestCascade extends TestCas
+*** 150,156 ****
+          stmt.close();
+      }    // deleteXBRecord
+  
+!     private static void insertData(Connection con) throws SQLException {
+  
+          String[] saData = {
+              "INSERT INTO XB VALUES('T850','LEAA','00','P',NULL,'LCN NAME','sa',NOW)",
+--- 150,156 ----
+          stmt.close();
+      }    // deleteXBRecord
+  
+!     public static void insertData(Connection con) throws SQLException {
+  
+          String[] saData = {
+              "INSERT INTO XB VALUES('T850','LEAA','00','P',NULL,'LCN NAME','sa',NOW)",
+diff -pcr misc/hsqldb/src/org/hsqldb/test/TestCollation.java misc/build/hsqldb/src/org/hsqldb/test/TestCollation.java
+*** misc/hsqldb/src/org/hsqldb/test/TestCollation.java	2005-10-23 20:26:29.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/test/TestCollation.java	2007-02-28 12:32:48.000000000 +0100
+*************** public class TestCollation extends TestB
+*** 54,60 ****
+          super.isNetwork = false;
+      }
+  
+!     protected void setUp() {
+  
+          super.setUp();
+  
+--- 54,60 ----
+          super.isNetwork = false;
+      }
+  
+!     public void setUp() {
+  
+          super.setUp();
+  
+*************** public class TestCollation extends TestB
+*** 68,74 ****
+          localeIterator = collation.getLocalesIterator();
+      }
+  
+!     protected void tearDown() {
+  
+          try {
+              statement = connection.createStatement();
+--- 68,74 ----
+          localeIterator = collation.getLocalesIterator();
+      }
+  
+!     public void tearDown() {
+  
+          try {
+              statement = connection.createStatement();
+*************** public class TestCollation extends TestB
+*** 192,198 ****
+      /**
+       * returns an SQL statement to set the database collation
+       */
+!     protected final String getSetCollationStmt(String collationName) {
+  
+          final String setCollationStmtPre  = "SET DATABASE COLLATION \"";
+          final String setCollationStmtPost = "\"";
+--- 192,198 ----
+      /**
+       * returns an SQL statement to set the database collation
+       */
+!     public final String getSetCollationStmt(String collationName) {
+  
+          final String setCollationStmtPre  = "SET DATABASE COLLATION \"";
+          final String setCollationStmtPost = "\"";
+*************** public class TestCollation extends TestB
+*** 203,209 ****
+      /**
+       * checks sorting a table with according to a given collation
+       */
+!     protected String checkSorting(String collationName) {
+  
+          String prepareStmt =
+              "DROP TABLE WORDLIST IF EXISTS;"
+--- 203,209 ----
+      /**
+       * checks sorting a table with according to a given collation
+       */
+!     public String checkSorting(String collationName) {
+  
+          String prepareStmt =
+              "DROP TABLE WORDLIST IF EXISTS;"
+diff -pcr misc/hsqldb/src/org/hsqldb/test/TestDataStructures.java misc/build/hsqldb/src/org/hsqldb/test/TestDataStructures.java
+*** misc/hsqldb/src/org/hsqldb/test/TestDataStructures.java	2005-10-23 20:26:29.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/test/TestDataStructures.java	2007-02-28 12:32:48.000000000 +0100
+*************** import junit.framework.TestCase;
+*** 51,69 ****
+   */
+  public class TestDataStructures extends TestCase {
+  
+!     private static final int NUMBER_OF_TEST_RUNS          = 100000;
+!     private static final int NUMBER_OF_ITERATIONS_PER_RUN = 80;
+!     private Random           randomGenerator;
+  
+      //Commands
+!     private static final int ADD        = 1;
+!     private static final int ADD_AT     = 2;
+!     private static final int GET        = 3;
+!     private static final int REMOVE     = 4;
+!     private static final int SET        = 5;
+!     private static final int OPTIMIZE   = 6;
+!     private static final int REMOVE_ALL = 7;
+!     private Vector           listCommandsCalled;
+  
+      /** Creates a new instance of TestDataStructures */
+      public TestDataStructures(String s) {
+--- 51,69 ----
+   */
+  public class TestDataStructures extends TestCase {
+  
+!     public static final int NUMBER_OF_TEST_RUNS          = 100000;
+!     public static final int NUMBER_OF_ITERATIONS_PER_RUN = 80;
+!     public Random           randomGenerator;
+  
+      //Commands
+!     public static final int ADD        = 1;
+!     public static final int ADD_AT     = 2;
+!     public static final int GET        = 3;
+!     public static final int REMOVE     = 4;
+!     public static final int SET        = 5;
+!     public static final int OPTIMIZE   = 6;
+!     public static final int REMOVE_ALL = 7;
+!     public Vector           listCommandsCalled;
+  
+      /** Creates a new instance of TestDataStructures */
+      public TestDataStructures(String s) {
+*************** public class TestDataStructures extends 
+*** 323,329 ****
+      }
+  
+      /** Returns whether three objects are equal */
+!     private boolean objectEquals(Object lObject, Object aObject,
+                                   Object vObject) {
+  
+          if (lObject == null && aObject == null && vObject == null) {
+--- 323,329 ----
+      }
+  
+      /** Returns whether three objects are equal */
+!     public boolean objectEquals(Object lObject, Object aObject,
+                                   Object vObject) {
+  
+          if (lObject == null && aObject == null && vObject == null) {
+*************** public class TestDataStructures extends 
+*** 348,354 ****
+      }
+  
+      /** Returns a random integer in the range of the lowBound and highBound */
+!     private int getRandomInt(int lowBound, int highBound) {
+  
+          double random = randomGenerator.nextDouble();
+  
+--- 348,354 ----
+      }
+  
+      /** Returns a random integer in the range of the lowBound and highBound */
+!     public int getRandomInt(int lowBound, int highBound) {
+  
+          double random = randomGenerator.nextDouble();
+  
+*************** public class TestDataStructures extends 
+*** 359,371 ****
+       * Returns an Integer object with a value between Integer.MIN_VALUE and
+       * Integer.MAX_VALUE
+       */
+!     private Integer getRandomInteger() {
+          return new Integer(getRandomInt(0, (int) (Integer.MAX_VALUE
+                  / 100.0)));
+      }
+  
+      /** Tells whether the given list contains the same data as the vector */
+!     private boolean equalsVector(HsqlList list, Vector vector) {
+  
+          if (list.size() != vector.size()) {
+              return false;
+--- 359,371 ----
+       * Returns an Integer object with a value between Integer.MIN_VALUE and
+       * Integer.MAX_VALUE
+       */
+!     public Integer getRandomInteger() {
+          return new Integer(getRandomInt(0, (int) (Integer.MAX_VALUE
+                  / 100.0)));
+      }
+  
+      /** Tells whether the given list contains the same data as the vector */
+!     public boolean equalsVector(HsqlList list, Vector vector) {
+  
+          if (list.size() != vector.size()) {
+              return false;
+diff -pcr misc/hsqldb/src/org/hsqldb/test/TestDateTime.java misc/build/hsqldb/src/org/hsqldb/test/TestDateTime.java
+*** misc/hsqldb/src/org/hsqldb/test/TestDateTime.java	2005-10-23 20:26:29.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/test/TestDateTime.java	2007-02-28 12:32:48.000000000 +0100
+*************** public class TestDateTime extends TestBa
+*** 51,57 ****
+          super(s);
+      }
+  
+!     protected void setUp() {
+  
+          super.setUp();
+  
+--- 51,57 ----
+          super(s);
+      }
+  
+!     public void setUp() {
+  
+          super.setUp();
+  
+diff -pcr misc/hsqldb/src/org/hsqldb/test/TestGroupByHaving.java misc/build/hsqldb/src/org/hsqldb/test/TestGroupByHaving.java
+*** misc/hsqldb/src/org/hsqldb/test/TestGroupByHaving.java	2005-10-23 20:26:29.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/test/TestGroupByHaving.java	2007-02-28 12:32:48.000000000 +0100
+*************** public class TestGroupByHaving extends T
+*** 54,69 ****
+      //------------------------------------------------------------
+      // Class variables
+      //------------------------------------------------------------
+!     private static final String databaseDriver   = "org.hsqldb.jdbcDriver";
+!     private static final String databaseURL      = "jdbc:hsqldb:mem:.";
+!     private static final String databaseUser     = "sa";
+!     private static final String databasePassword = "";
+  
+      //------------------------------------------------------------
+      // Instance variables
+      //------------------------------------------------------------
+!     private Connection conn;
+!     private Statement  stmt;
+  
+      //------------------------------------------------------------
+      // Constructors
+--- 54,69 ----
+      //------------------------------------------------------------
+      // Class variables
+      //------------------------------------------------------------
+!     public static final String databaseDriver   = "org.hsqldb.jdbcDriver";
+!     public static final String databaseURL      = "jdbc:hsqldb:mem:.";
+!     public static final String databaseUser     = "sa";
+!     public static final String databasePassword = "";
+  
+      //------------------------------------------------------------
+      // Instance variables
+      //------------------------------------------------------------
+!     public Connection conn;
+!     public Statement  stmt;
+  
+      //------------------------------------------------------------
+      // Constructors
+*************** public class TestGroupByHaving extends T
+*** 79,90 ****
+      //------------------------------------------------------------
+      // Class methods
+      //------------------------------------------------------------
+!     protected static Connection getJDBCConnection() throws SQLException {
+          return DriverManager.getConnection(databaseURL, databaseUser,
+                                             databasePassword);
+      }
+  
+!     protected void setUp() throws Exception {
+  
+          super.setUp();
+  
+--- 79,90 ----
+      //------------------------------------------------------------
+      // Class methods
+      //------------------------------------------------------------
+!     public static Connection getJDBCConnection() throws SQLException {
+          return DriverManager.getConnection(databaseURL, databaseUser,
+                                             databasePassword);
+      }
+  
+!     public void setUp() throws Exception {
+  
+          super.setUp();
+  
+*************** public class TestGroupByHaving extends T
+*** 127,133 ****
+          addEmployee(23, "Barbara", "Hood", 30000, 2);
+      }
+  
+!     protected void tearDown() throws Exception {
+  
+          super.tearDown();
+  
+--- 127,133 ----
+          addEmployee(23, "Barbara", "Hood", 30000, 2);
+      }
+  
+!     public void tearDown() throws Exception {
+  
+          super.tearDown();
+  
+*************** public class TestGroupByHaving extends T
+*** 152,158 ****
+          }
+      }
+  
+!     private void addEmployee(int id, String firstName, String lastName,
+                               double salary, int superiorId) throws Exception {
+  
+          stmt.execute("insert into employee values(" + id + ", '" + firstName
+--- 152,158 ----
+          }
+      }
+  
+!     public void addEmployee(int id, String firstName, String lastName,
+                               double salary, int superiorId) throws Exception {
+  
+          stmt.execute("insert into employee values(" + id + ", '" + firstName
+*************** public class TestGroupByHaving extends T
+*** 294,300 ****
+      //------------------------------------------------------------
+      // Helper methods
+      //------------------------------------------------------------
+!     private void compareResults(String sql, Object[][] rows,
+                                  int errorCode) throws SQLException {
+  
+          ResultSet rs = null;
+--- 294,300 ----
+      //------------------------------------------------------------
+      // Helper methods
+      //------------------------------------------------------------
+!     public void compareResults(String sql, Object[][] rows,
+                                  int errorCode) throws SQLException {
+  
+          ResultSet rs = null;
+diff -pcr misc/hsqldb/src/org/hsqldb/test/TestJDBCSavepoints.java misc/build/hsqldb/src/org/hsqldb/test/TestJDBCSavepoints.java
+*** misc/hsqldb/src/org/hsqldb/test/TestJDBCSavepoints.java	2005-10-23 20:26:29.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/test/TestJDBCSavepoints.java	2007-02-28 12:32:48.000000000 +0100
+*************** public class TestJDBCSavepoints extends 
+*** 75,81 ****
+          super(name);
+      }
+  
+!     protected void setUp() {
+  
+          user     = "sa";
+          password = "";
+--- 75,81 ----
+          super(name);
+      }
+  
+!     public void setUp() {
+  
+          user     = "sa";
+          password = "";
+*************** public class TestJDBCSavepoints extends 
+*** 103,109 ****
+          }
+      }
+  
+!     protected void tearDown() {
+  
+          try {
+              conn1.close();
+--- 103,109 ----
+          }
+      }
+  
+!     public void tearDown() {
+  
+          try {
+              conn1.close();
+diff -pcr misc/hsqldb/src/org/hsqldb/test/TestMultipleConnections.java misc/build/hsqldb/src/org/hsqldb/test/TestMultipleConnections.java
+*** misc/hsqldb/src/org/hsqldb/test/TestMultipleConnections.java	2005-10-23 20:26:29.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/test/TestMultipleConnections.java	2007-02-28 12:32:48.000000000 +0100
+*************** public class TestMultipleConnections {
+*** 85,91 ****
+      /**
+       * create a connection and wait
+       */
+!     protected Connection createObject() {
+  
+          try {
+              Class.forName("org.hsqldb.jdbcDriver");
+--- 85,91 ----
+      /**
+       * create a connection and wait
+       */
+!     public Connection createObject() {
+  
+          try {
+              Class.forName("org.hsqldb.jdbcDriver");
+diff -pcr misc/hsqldb/src/org/hsqldb/test/TestPreparedSubQueries.java misc/build/hsqldb/src/org/hsqldb/test/TestPreparedSubQueries.java
+*** misc/hsqldb/src/org/hsqldb/test/TestPreparedSubQueries.java	2005-10-23 20:26:29.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/test/TestPreparedSubQueries.java	2007-02-28 12:32:48.000000000 +0100
+*************** import java.sql.Statement;
+*** 40,48 ****
+   */
+  class TestPreparedSubQueries {
+  
+!     private Connection con = null;
+  
+!     private class sqlStmt {
+  
+          boolean prepare;
+          boolean update;
+--- 40,48 ----
+   */
+  class TestPreparedSubQueries {
+  
+!     public Connection con = null;
+  
+!     public class sqlStmt {
+  
+          boolean prepare;
+          boolean update;
+*************** class TestPreparedSubQueries {
+*** 57,63 ****
+      }
+      ;
+  
+!     private sqlStmt[] stmtArray = {
+          new sqlStmt("drop table a if exists", false, false),
+          new sqlStmt("create cached table a (a int identity,b int)", false,
+                      false),
+--- 57,63 ----
+      }
+      ;
+  
+!     public sqlStmt[] stmtArray = {
+          new sqlStmt("drop table a if exists", false, false),
+          new sqlStmt("create cached table a (a int identity,b int)", false,
+                      false),
+*************** class TestPreparedSubQueries {
+*** 77,83 ****
+              "update a set b=300 where b>(select b from a X where X.a=?)",
+              true, true)
+      };
+!     private Object[][] stmtArgs = {
+          {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, { new Integer(2) },
+          { new Integer(2) }
+      };
+--- 77,83 ----
+              "update a set b=300 where b>(select b from a X where X.a=?)",
+              true, true)
+      };
+!     public Object[][] stmtArgs = {
+          {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, { new Integer(2) },
+          { new Integer(2) }
+      };
+diff -pcr misc/hsqldb/src/org/hsqldb/test/TestQuotes.java misc/build/hsqldb/src/org/hsqldb/test/TestQuotes.java
+*** misc/hsqldb/src/org/hsqldb/test/TestQuotes.java	2005-10-23 20:26:29.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/test/TestQuotes.java	2007-02-28 12:32:48.000000000 +0100
+*************** import junit.framework.TestSuite;
+*** 50,63 ****
+   */
+  public class TestQuotes extends TestCase {
+  
+!     private static final String CREATETABLE =
+          "create table quotetest (test varchar)";
+!     private static final String DELETE = "delete from quotetest";
+!     private static final String TESTSTRING =
+          "insert into quotetest (test) values (?)";
+!     private static final String NOQUOTES = "the house of the dog of kevin";
+!     private static final String QUOTES   = "kevin's dog's house";
+!     private static final String RESULT   = "select * from quotetest";
+  
+      public TestQuotes(String testName) {
+          super(testName);
+--- 50,63 ----
+   */
+  public class TestQuotes extends TestCase {
+  
+!     public static final String CREATETABLE =
+          "create table quotetest (test varchar)";
+!     public static final String DELETE = "delete from quotetest";
+!     public static final String TESTSTRING =
+          "insert into quotetest (test) values (?)";
+!     public static final String NOQUOTES = "the house of the dog of kevin";
+!     public static final String QUOTES   = "kevin's dog's house";
+!     public static final String RESULT   = "select * from quotetest";
+  
+      public TestQuotes(String testName) {
+          super(testName);
+diff -pcr misc/hsqldb/src/org/hsqldb/test/TestSchemaParse.java misc/build/hsqldb/src/org/hsqldb/test/TestSchemaParse.java
+*** misc/hsqldb/src/org/hsqldb/test/TestSchemaParse.java	2005-10-23 20:26:29.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/test/TestSchemaParse.java	2007-02-28 12:32:48.000000000 +0100
+*************** implements org.hsqldb.Trigger {
+*** 42,50 ****
+  
+      Connection                  con = null;
+      Statement                   statement;
+!     private static final String ipref = "INFORMATION_SCHEMA.";
+  
+!     protected void setUp() throws Exception {
+  
+          org.hsqldb.jdbcDriver.class.getName();
+  
+--- 42,50 ----
+  
+      Connection                  con = null;
+      Statement                   statement;
+!     public static final String ipref = "INFORMATION_SCHEMA.";
+  
+!     public void setUp() throws Exception {
+  
+          org.hsqldb.jdbcDriver.class.getName();
+  
+*************** implements org.hsqldb.Trigger {
+*** 96,104 ****
+  
+      // Want to permit the SHUTDOWN SQL command in tearDown() to fail iff
+      // the test method run has tested SHUTDOWN.
+!     private boolean shutdownTested = false;
+  
+!     protected void tearDown() throws Exception {
+  
+          // Shut down to destroy all of the DB objects (only works because
+          // it's an in-memory instance.
+--- 96,104 ----
+  
+      // Want to permit the SHUTDOWN SQL command in tearDown() to fail iff
+      // the test method run has tested SHUTDOWN.
+!     public boolean shutdownTested = false;
+  
+!     public void tearDown() throws Exception {
+  
+          // Shut down to destroy all of the DB objects (only works because
+          // it's an in-memory instance.
+*************** implements org.hsqldb.Trigger {
+*** 931,941 ****
+      }
+  
+  /** @todo fredt - need to define additional identifiers to use for all cases of expect */
+!     private static final int SQL_ABORT   = -1234;
+!     private static final int SQL_INITIAL = -1233;
+!     private static final int SQL_FAIL    = -1;
+  
+!     private void execSQL(String s, boolean ignoreError) throws SQLException {
+  
+          try {
+              statement.execute(s);
+--- 931,941 ----
+      }
+  
+  /** @todo fredt - need to define additional identifiers to use for all cases of expect */
+!     public static final int SQL_ABORT   = -1234;
+!     public static final int SQL_INITIAL = -1233;
+!     public static final int SQL_FAIL    = -1;
+  
+!     public void execSQL(String s, boolean ignoreError) throws SQLException {
+  
+          try {
+              statement.execute(s);
+*************** implements org.hsqldb.Trigger {
+*** 949,955 ****
+          }
+      }
+  
+!     private void execSQL(String m, String s, int expect) {
+  
+          int retval = SQL_INITIAL;
+  
+--- 949,955 ----
+          }
+      }
+  
+!     public void execSQL(String m, String s, int expect) {
+  
+          int retval = SQL_INITIAL;
+  
+*************** implements org.hsqldb.Trigger {
+*** 965,975 ****
+      }
+  
+  /** @todo fredt - this method body seems to be incorrect */
+!     private void execSQL(String s, int expect) {
+          execSQL(s, s, expect);
+      }
+  
+!     private int queryRowCount(String query) throws SQLException {
+  
+          int count = 0;
+  
+--- 965,975 ----
+      }
+  
+  /** @todo fredt - this method body seems to be incorrect */
+!     public void execSQL(String s, int expect) {
+          execSQL(s, s, expect);
+      }
+  
+!     public int queryRowCount(String query) throws SQLException {
+  
+          int count = 0;
+  
+*************** implements org.hsqldb.Trigger {
+*** 990,996 ****
+          return count;
+      }
+  
+!     private int tableRowCount(String tableName) throws SQLException {
+  
+          String query = "SELECT count(*) FROM " + tableName;
+  
+--- 990,996 ----
+          return count;
+      }
+  
+!     public int tableRowCount(String tableName) throws SQLException {
+  
+          String query = "SELECT count(*) FROM " + tableName;
+  
+diff -pcr misc/hsqldb/src/org/hsqldb/test/TestSql.java misc/build/hsqldb/src/org/hsqldb/test/TestSql.java
+*** misc/hsqldb/src/org/hsqldb/test/TestSql.java	2006-02-13 16:23:25.000000000 +0100
+--- misc/build/hsqldb/src/org/hsqldb/test/TestSql.java	2007-02-28 12:32:48.000000000 +0100
+*************** public class TestSql extends TestBase {
+*** 58,64 ****
+          super(name);
+      }
+  
+!     protected void setUp() {
+  
+          super.setUp();
+  
+--- 58,64 ----
+          super(name);
+      }
+  
+!     public void setUp() {
+  
+          super.setUp();
+  
+*************** public class TestSql extends TestBase {
+*** 680,686 ****
+          }
+      }
+  
+!     protected void tearDown() {
+  
+          try {
+              connection.close();
+--- 680,686 ----
+          }
+      }
+  
+!     public void tearDown() {
+  
+          try {
+              connection.close();
+diff -pcr misc/hsqldb/src/org/hsqldb/test/TestSqlPersistent.java misc/build/hsqldb/src/org/hsqldb/test/TestSqlPersistent.java
+*** misc/hsqldb/src/org/hsqldb/test/TestSqlPersistent.java	2006-04-11 16:41:07.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/test/TestSqlPersistent.java	2007-02-28 12:32:48.000000000 +0100
+*************** public class TestSqlPersistent extends T
+*** 63,69 ****
+          super(name);
+      }
+  
+!     protected void setUp() throws Exception {
+  
+          super.setUp();
+  
+--- 63,69 ----
+          super(name);
+      }
+  
+!     public void setUp() throws Exception {
+  
+          super.setUp();
+  
+*************** public class TestSqlPersistent extends T
+*** 431,437 ****
+          }
+      }
+  
+!     protected void tearDown() {
+  
+          try {
+              cConnection.close();
+--- 431,437 ----
+          }
+      }
+  
+!     public void tearDown() {
+  
+          try {
+              cConnection.close();
+diff -pcr misc/hsqldb/src/org/hsqldb/test/TestSqlTool.java misc/build/hsqldb/src/org/hsqldb/test/TestSqlTool.java
+*** misc/hsqldb/src/org/hsqldb/test/TestSqlTool.java	2005-10-23 20:26:30.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/test/TestSqlTool.java	2007-02-28 12:32:48.000000000 +0100
+*************** public class TestSqlTool extends junit.f
+*** 45,51 ****
+       * Does not have getters/setters.  No purpose would be served by
+       * getters and setters, other than over-engineering.
+       */
+!     private class TestSqlFile {
+  
+          public File   file;
+          public String description;
+--- 45,51 ----
+       * Does not have getters/setters.  No purpose would be served by
+       * getters and setters, other than over-engineering.
+       */
+!     public class TestSqlFile {
+  
+          public File   file;
+          public String description;
+*************** public class TestSqlTool extends junit.f
+*** 66,72 ****
+      /**
+       * List of SQL files, with a description of the purpose.
+       */
+!     private class SqlFileList extends ArrayList {
+  
+          /**
+           * Loads a list of SQL files and descriptions for the specified
+--- 66,72 ----
+      /**
+       * List of SQL files, with a description of the purpose.
+       */
+!     public class SqlFileList extends ArrayList {
+  
+          /**
+           * Loads a list of SQL files and descriptions for the specified
+*************** public class TestSqlTool extends junit.f
+*** 109,115 ****
+  
+      SqlToolHarness harness = new SqlToolHarness();
+  
+!     private void runTestsInList(String testList) throws Exception {
+  
+          SqlFileList fileList = new SqlFileList(testList);
+          TestSqlFile sqlFile;
+--- 109,115 ----
+  
+      SqlToolHarness harness = new SqlToolHarness();
+  
+!     public void runTestsInList(String testList) throws Exception {
+  
+          SqlFileList fileList = new SqlFileList(testList);
+          TestSqlFile sqlFile;
+diff -pcr misc/hsqldb/src/org/hsqldb/test/TestStressInsert.java misc/build/hsqldb/src/org/hsqldb/test/TestStressInsert.java
+*** misc/hsqldb/src/org/hsqldb/test/TestStressInsert.java	2006-06-29 02:33:42.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/test/TestStressInsert.java	2007-02-28 12:32:48.000000000 +0100
+*************** import java.util.Random;
+*** 44,53 ****
+   */
+  public class TestStressInsert {
+  
+!     private Connection        con;
+!     private PreparedStatement insertStmt;
+!     private static final int  MAX_SIZE = 800000;
+!     private final Random      random   = new Random(0);
+      byte[]                    data     = getRandomBytes(MAX_SIZE);
+  
+      public void init() throws Exception {
+--- 44,53 ----
+   */
+  public class TestStressInsert {
+  
+!     public Connection        con;
+!     public PreparedStatement insertStmt;
+!     public static final int  MAX_SIZE = 800000;
+!     public final Random      random   = new Random(0);
+      byte[]                    data     = getRandomBytes(MAX_SIZE);
+  
+      public void init() throws Exception {
+*************** public class TestStressInsert {
+*** 143,149 ****
+          }
+      }
+  
+!     private byte[] getRandomBytes(int length) {
+  
+          byte[] ret = new byte[length];
+  
+--- 143,149 ----
+          }
+      }
+  
+!     public byte[] getRandomBytes(int length) {
+  
+          byte[] ret = new byte[length];
+  
+diff -pcr misc/hsqldb/src/org/hsqldb/test/TestSubselect.java misc/build/hsqldb/src/org/hsqldb/test/TestSubselect.java
+*** misc/hsqldb/src/org/hsqldb/test/TestSubselect.java	2006-04-11 16:41:08.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/test/TestSubselect.java	2007-02-28 12:32:48.000000000 +0100
+*************** public class TestSubselect extends TestC
+*** 52,67 ****
+      //------------------------------------------------------------
+      // Class variables
+      //------------------------------------------------------------
+!     private static final String databaseDriver = "org.hsqldb.jdbcDriver";
+!     private static final String databaseURL =
+          "jdbc:hsqldb:/hsql/test/subselect";
+!     private static final String databaseUser     = "sa";
+!     private static final String databasePassword = "";
+  
+      //------------------------------------------------------------
+      // Instance variables
+      //------------------------------------------------------------
+!     private Connection jdbcConnection;
+  
+      //------------------------------------------------------------
+      // Constructors
+--- 52,67 ----
+      //------------------------------------------------------------
+      // Class variables
+      //------------------------------------------------------------
+!     public static final String databaseDriver = "org.hsqldb.jdbcDriver";
+!     public static final String databaseURL =
+          "jdbc:hsqldb:/hsql/test/subselect";
+!     public static final String databaseUser     = "sa";
+!     public static final String databasePassword = "";
+  
+      //------------------------------------------------------------
+      // Instance variables
+      //------------------------------------------------------------
+!     public Connection jdbcConnection;
+  
+      //------------------------------------------------------------
+      // Constructors
+*************** public class TestSubselect extends TestC
+*** 77,88 ****
+      //------------------------------------------------------------
+      // Class methods
+      //------------------------------------------------------------
+!     protected static Connection getJDBCConnection() throws SQLException {
+          return DriverManager.getConnection(databaseURL, databaseUser,
+                                             databasePassword);
+      }
+  
+!     protected void setUp() throws Exception {
+  
+          TestSelf.deleteDatabase("/hsql/test/subselect");
+          Class.forName(databaseDriver);
+--- 77,88 ----
+      //------------------------------------------------------------
+      // Class methods
+      //------------------------------------------------------------
+!     public static Connection getJDBCConnection() throws SQLException {
+          return DriverManager.getConnection(databaseURL, databaseUser,
+                                             databasePassword);
+      }
+  
+!     public void setUp() throws Exception {
+  
+          TestSelf.deleteDatabase("/hsql/test/subselect");
+          Class.forName(databaseDriver);
+*************** public class TestSubselect extends TestC
+*** 92,98 ****
+          createDataset();
+      }
+  
+!     protected void tearDown() throws Exception {
+  
+          super.tearDown();
+          jdbcConnection.close();
+--- 92,98 ----
+          createDataset();
+      }
+  
+!     public void tearDown() throws Exception {
+  
+          super.tearDown();
+          jdbcConnection.close();
+*************** public class TestSubselect extends TestC
+*** 137,143 ****
+      //------------------------------------------------------------
+      // Helper methods
+      //------------------------------------------------------------
+!     private static void compareResults(String sql, String[] expected,
+                                         Connection jdbcConnection)
+                                         throws SQLException {
+  
+--- 137,143 ----
+      //------------------------------------------------------------
+      // Helper methods
+      //------------------------------------------------------------
+!     public static void compareResults(String sql, String[] expected,
+                                         Connection jdbcConnection)
+                                         throws SQLException {
+  
+diff -pcr misc/hsqldb/src/org/hsqldb/test/TestTimestamp.java misc/build/hsqldb/src/org/hsqldb/test/TestTimestamp.java
+*** misc/hsqldb/src/org/hsqldb/test/TestTimestamp.java	2005-10-23 20:26:30.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/test/TestTimestamp.java	2007-02-28 12:32:48.000000000 +0100
+*************** public class TestTimestamp extends TestC
+*** 57,63 ****
+          super(testName);
+      }
+  
+!     private void initOracle() throws Exception {
+  
+          Class.forName("oracle.jdbc.driver.OracleDriver");
+  
+--- 57,63 ----
+          super(testName);
+      }
+  
+!     public void initOracle() throws Exception {
+  
+          Class.forName("oracle.jdbc.driver.OracleDriver");
+  
+*************** public class TestTimestamp extends TestC
+*** 67,73 ****
+          conn.setAutoCommit(false);
+      }
+  
+!     private void initHypersonic() throws Exception {
+  
+          Class.forName("org.hsqldb.jdbcDriver");
+  
+--- 67,73 ----
+          conn.setAutoCommit(false);
+      }
+  
+!     public void initHypersonic() throws Exception {
+  
+          Class.forName("org.hsqldb.jdbcDriver");
+  
+*************** public class TestTimestamp extends TestC
+*** 102,110 ****
+  //        dropTestTable();
+      }
+  */
+!     private void checkExceptionTableExistsOracle(SQLException e) {}
+  
+!     private void checkExceptionTableExistsHsql(SQLException e) {
+  
+          Assert.assertTrue("Error code of SQLException is wrong",
+                            e.getErrorCode()
+--- 102,110 ----
+  //        dropTestTable();
+      }
+  */
+!     public void checkExceptionTableExistsOracle(SQLException e) {}
+  
+!     public void checkExceptionTableExistsHsql(SQLException e) {
+  
+          Assert.assertTrue("Error code of SQLException is wrong",
+                            e.getErrorCode()
+*************** public class TestTimestamp extends TestC
+*** 151,157 ****
+  //        dropTestTable();
+      }
+  
+!     private void dropAllTables() throws Exception {
+  
+          dropTestTable(nameTable);
+          dropTestTable("\"SITE_LIST_SITE\"");
+--- 151,157 ----
+  //        dropTestTable();
+      }
+  
+!     public void dropAllTables() throws Exception {
+  
+          dropTestTable(nameTable);
+          dropTestTable("\"SITE_LIST_SITE\"");
+*************** public class TestTimestamp extends TestC
+*** 161,169 ****
+          dropTestTable("\"CASH_CURR_VALUE\"");
+      }
+  
+!     private String nameTable = null;
+  
+!     private void doTest() throws Exception {
+  
+          PreparedStatement ps = conn.prepareStatement("select max(T) T1 from "
+              + nameTable + " where ID=?");
+--- 161,169 ----
+          dropTestTable("\"CASH_CURR_VALUE\"");
+      }
+  
+!     public String nameTable = null;
+  
+!     public void doTest() throws Exception {
+  
+          PreparedStatement ps = conn.prepareStatement("select max(T) T1 from "
+              + nameTable + " where ID=?");
+*************** public class TestTimestamp extends TestC
+*** 217,226 ****
+          }
+      }
+  
+!     private static Timestamp testTS =
+          new Timestamp(System.currentTimeMillis());
+  
+!     private void insertTestData() throws Exception {
+  
+  //        conn.createStatement().executeUpdate("INSERT INTO \"SITE_LIST_SITE\" VALUES(23,1,'ru','RU',NULL,'\u041f\u0440\u043e\u0431\u043d\u044b\u0439 \u0441\u0430\u0439\u0442',NULL,0,'''/front_styles.css''',1,NULL,0)");
+  //        conn.createStatement().executeUpdate("INSERT INTO \"SITE_VIRTUAL_HOST\" VALUES(36,23,'test-host')");
+--- 217,226 ----
+          }
+      }
+  
+!     public static Timestamp testTS =
+          new Timestamp(System.currentTimeMillis());
+  
+!     public void insertTestData() throws Exception {
+  
+  //        conn.createStatement().executeUpdate("INSERT INTO \"SITE_LIST_SITE\" VALUES(23,1,'ru','RU',NULL,'\u041f\u0440\u043e\u0431\u043d\u044b\u0439 \u0441\u0430\u0439\u0442',NULL,0,'''/front_styles.css''',1,NULL,0)");
+  //        conn.createStatement().executeUpdate("INSERT INTO \"SITE_VIRTUAL_HOST\" VALUES(36,23,'test-host')");
+*************** public class TestTimestamp extends TestC
+*** 245,251 ****
+          conn.commit();
+      }
+  
+!     private void createTestTable(String sql) throws Exception {
+  
+          Statement ps = conn.createStatement();
+  
+--- 245,251 ----
+          conn.commit();
+      }
+  
+!     public void createTestTable(String sql) throws Exception {
+  
+          Statement ps = conn.createStatement();
+  
+*************** public class TestTimestamp extends TestC
+*** 255,261 ****
+          ps = null;
+      }
+  
+!     private void dropTestTable(String nameTableDrop) throws Exception {
+  
+          String    sql = "drop table " + nameTableDrop;
+          Statement ps  = conn.createStatement();
+--- 255,261 ----
+          ps = null;
+      }
+  
+!     public void dropTestTable(String nameTableDrop) throws Exception {
+  
+          String    sql = "drop table " + nameTableDrop;
+          Statement ps  = conn.createStatement();
+*************** public class TestTimestamp extends TestC
+*** 269,282 ****
+          ps = null;
+      }
+  
+!     private void setTimeZone() {
+  
+          timeZone = TimeZone.getTimeZone("Asia/Irkutsk");
+  
+          TimeZone.setDefault(timeZone);
+      }
+  
+!     private Timestamp getCurrentCurs() throws Exception {
+  
+          long idCurrency = 134;
+          long idSite     = 23;
+--- 269,282 ----
+          ps = null;
+      }
+  
+!     public void setTimeZone() {
+  
+          timeZone = TimeZone.getTimeZone("Asia/Irkutsk");
+  
+          TimeZone.setDefault(timeZone);
+      }
+  
+!     public Timestamp getCurrentCurs() throws Exception {
+  
+          long idCurrency = 134;
+          long idSite     = 23;
+diff -pcr misc/hsqldb/src/org/hsqldb/test/TestUtil.java misc/build/hsqldb/src/org/hsqldb/test/TestUtil.java
+*** misc/hsqldb/src/org/hsqldb/test/TestUtil.java	2006-02-13 11:23:06.000000000 +0100
+--- misc/build/hsqldb/src/org/hsqldb/test/TestUtil.java	2007-02-28 12:32:48.000000000 +0100
+*************** public class TestUtil {
+*** 174,180 ****
+       * SQL for the statement).
+       * @param line line of the script file where this section started
+       */
+!     private static void testSection(Statement stat, HsqlArrayList section,
+                                      int line) {
+  
+          //create an appropriate instance of ParsedSection
+--- 174,180 ----
+       * SQL for the statement).
+       * @param line line of the script file where this section started
+       */
+!     public static void testSection(Statement stat, HsqlArrayList section,
+                                      int line) {
+  
+          //create an appropriate instance of ParsedSection
+*************** public class TestUtil {
+*** 201,207 ****
+       * @param aSection Vector containing the section of script
+       * @return a ParesedSection object
+       */
+!     private static ParsedSection parsedSectionFactory(
+              HsqlArrayList aSection) {
+  
+          //type of the section
+--- 201,207 ----
+       * @param aSection Vector containing the section of script
+       * @return a ParesedSection object
+       */
+!     public static ParsedSection parsedSectionFactory(
+              HsqlArrayList aSection) {
+  
+          //type of the section
+*************** abstract class ParsedSection {
+*** 298,329 ****
+       * Type of this test.
+       * @see isValidCase() for allowed values
+       */
+!     protected char type = ' ';
+  
+      /** error message for this section */
+      String message = null;
+  
+      /** contents of the section as an array of Strings, one for each line in the section. */
+!     protected String[] lines = null;
+  
+      /** number of the last row containing results in sectionLines */
+!     protected int resEndRow = 0;
+  
+      /** SQL query to be submitted to the database. */
+!     protected String sqlString = null;
+  
+      /**
+       * Constructor when the section's input lines do not need to be parsed
+       * into SQL.
+       */
+!     protected ParsedSection() {}
+  
+      /**
+       * Common constructor functions for this family.
+       * @param aLines Array of the script lines containing the section of script.
+       * database
+       */
+!     protected ParsedSection(String[] aLines) {
+  
+          lines = aLines;
+  
+--- 298,329 ----
+       * Type of this test.
+       * @see isValidCase() for allowed values
+       */
+!     public char type = ' ';
+  
+      /** error message for this section */
+      String message = null;
+  
+      /** contents of the section as an array of Strings, one for each line in the section. */
+!     public String[] lines = null;
+  
+      /** number of the last row containing results in sectionLines */
+!     public int resEndRow = 0;
+  
+      /** SQL query to be submitted to the database. */
+!     public String sqlString = null;
+  
+      /**
+       * Constructor when the section's input lines do not need to be parsed
+       * into SQL.
+       */
+!     public ParsedSection() {}
+  
+      /**
+       * Common constructor functions for this family.
+       * @param aLines Array of the script lines containing the section of script.
+       * database
+       */
+!     public ParsedSection(String[] aLines) {
+  
+          lines = aLines;
+  
+*************** abstract class ParsedSection {
+*** 400,413 ****
+       * returns a String representation of the expected result for the test
+       * @return The expected result(s) for the test
+       */
+!     protected abstract String getResultString();
+  
+      /**
+       *  returns the error message for the section
+       *
+       * @return message
+       */
+!     protected String getMessage() {
+          return message;
+      }
+  
+--- 400,413 ----
+       * returns a String representation of the expected result for the test
+       * @return The expected result(s) for the test
+       */
+!     public abstract String getResultString();
+  
+      /**
+       *  returns the error message for the section
+       *
+       * @return message
+       */
+!     public String getMessage() {
+          return message;
+      }
+  
+*************** abstract class ParsedSection {
+*** 415,421 ****
+       * returns the type of this section
+       * @return type of this section
+       */
+!     protected char getType() {
+          return type;
+      }
+  
+--- 415,421 ----
+       * returns the type of this section
+       * @return type of this section
+       */
+!     public char getType() {
+          return type;
+      }
+  
+*************** abstract class ParsedSection {
+*** 423,429 ****
+       * returns the SQL statement for this section
+       * @return SQL statement for this section
+       */
+!     protected String getSql() {
+          return sqlString;
+      }
+  
+--- 423,429 ----
+       * returns the SQL statement for this section
+       * @return SQL statement for this section
+       */
+!     public String getSql() {
+          return sqlString;
+      }
+  
+*************** abstract class ParsedSection {
+*** 432,438 ****
+       * @param aStatement Statement object
+       * @return true if the result(s) are as expected, otherwise false
+       */
+!     protected boolean test(Statement aStatement) {
+  
+          try {
+              aStatement.execute(getSql());
+--- 432,438 ----
+       * @param aStatement Statement object
+       * @return true if the result(s) are as expected, otherwise false
+       */
+!     public boolean test(Statement aStatement) {
+  
+          try {
+              aStatement.execute(getSql());
+*************** abstract class ParsedSection {
+*** 450,456 ****
+       * @param aCode type code to validate.
+       * @return true if the type code is valid, otherwise false.
+       */
+!     protected static boolean isValidCode(char aCode) {
+  
+          /* Allowed values for test codes are:
+           * (note that UPPERCASE codes, while valid are only processed if the
+--- 450,456 ----
+       * @param aCode type code to validate.
+       * @return true if the type code is valid, otherwise false.
+       */
+!     public static boolean isValidCode(char aCode) {
+  
+          /* Allowed values for test codes are:
+           * (note that UPPERCASE codes, while valid are only processed if the
+*************** abstract class ParsedSection {
+*** 485,499 ****
+  /** Represents a ParsedSection for a ResultSet test */
+  class ResultSetParsedSection extends ParsedSection {
+  
+!     private String delim = System.getProperty("TestUtilFieldDelimiter", ",");
+!     private String[] expectedRows = null;
+  
+      /**
+       * constructs a new instance of ResultSetParsedSection, interpreting
+       * the supplied results as one or more lines of delimited field values
+       * @param lines String[]
+       */
+!     protected ResultSetParsedSection(String[] lines) {
+  
+          super(lines);
+  
+--- 485,499 ----
+  /** Represents a ParsedSection for a ResultSet test */
+  class ResultSetParsedSection extends ParsedSection {
+  
+!     public String delim = System.getProperty("TestUtilFieldDelimiter", ",");
+!     public String[] expectedRows = null;
+  
+      /**
+       * constructs a new instance of ResultSetParsedSection, interpreting
+       * the supplied results as one or more lines of delimited field values
+       * @param lines String[]
+       */
+!     public ResultSetParsedSection(String[] lines) {
+  
+          super(lines);
+  
+*************** class ResultSetParsedSection extends Par
+*** 509,515 ****
+          }
+      }
+  
+!     protected String getResultString() {
+  
+          StringBuffer printVal = new StringBuffer();
+  
+--- 509,515 ----
+          }
+      }
+  
+!     public String getResultString() {
+  
+          StringBuffer printVal = new StringBuffer();
+  
+*************** class ResultSetParsedSection extends Par
+*** 520,526 ****
+          return printVal.toString();
+      }
+  
+!     protected boolean test(Statement aStatement) {
+  
+          try {
+              try {
+--- 520,526 ----
+          return printVal.toString();
+      }
+  
+!     public boolean test(Statement aStatement) {
+  
+          try {
+              try {
+*************** class ResultSetParsedSection extends Par
+*** 620,626 ****
+          return true;
+      }
+  
+!     private String[] getExpectedRows() {
+          return expectedRows;
+      }
+  }
+--- 620,626 ----
+          return true;
+      }
+  
+!     public String[] getExpectedRows() {
+          return expectedRows;
+      }
+  }
+*************** class UpdateParsedSection extends Parsed
+*** 631,637 ****
+      //expected update count
+      int countWeWant;
+  
+!     protected UpdateParsedSection(String[] lines) {
+  
+          super(lines);
+  
+--- 631,637 ----
+      //expected update count
+      int countWeWant;
+  
+!     public UpdateParsedSection(String[] lines) {
+  
+          super(lines);
+  
+*************** class UpdateParsedSection extends Parsed
+*** 639,653 ****
+          countWeWant = Integer.parseInt(lines[0]);
+      }
+  
+!     protected String getResultString() {
+          return Integer.toString(getCountWeWant());
+      }
+  
+!     private int getCountWeWant() {
+          return countWeWant;
+      }
+  
+!     protected boolean test(Statement aStatement) {
+  
+          try {
+              try {
+--- 639,653 ----
+          countWeWant = Integer.parseInt(lines[0]);
+      }
+  
+!     public String getResultString() {
+          return Integer.toString(getCountWeWant());
+      }
+  
+!     public int getCountWeWant() {
+          return countWeWant;
+      }
+  
+!     public boolean test(Statement aStatement) {
+  
+          try {
+              try {
+*************** class UpdateParsedSection extends Parsed
+*** 680,697 ****
+  /** Represents a ParsedSection for silent execution */
+  class SilentParsedSection extends ParsedSection {
+  
+!     protected SilentParsedSection(String[] lines) {
+  
+          super(lines);
+  
+          type = 's';
+      }
+  
+!     protected String getResultString() {
+          return null;
+      }
+  
+!     protected boolean test(Statement aStatement) {
+  
+          try {
+              aStatement.execute(getSql());
+--- 680,697 ----
+  /** Represents a ParsedSection for silent execution */
+  class SilentParsedSection extends ParsedSection {
+  
+!     public SilentParsedSection(String[] lines) {
+  
+          super(lines);
+  
+          type = 's';
+      }
+  
+!     public String getResultString() {
+          return null;
+      }
+  
+!     public boolean test(Statement aStatement) {
+  
+          try {
+              aStatement.execute(getSql());
+*************** class SilentParsedSection extends Parsed
+*** 705,713 ****
+  class CountParsedSection extends ParsedSection {
+  
+      //expected row count
+!     private int countWeWant;
+  
+!     protected CountParsedSection(String[] lines) {
+  
+          super(lines);
+  
+--- 705,713 ----
+  class CountParsedSection extends ParsedSection {
+  
+      //expected row count
+!     public int countWeWant;
+  
+!     public CountParsedSection(String[] lines) {
+  
+          super(lines);
+  
+*************** class CountParsedSection extends ParsedS
+*** 715,729 ****
+          countWeWant = Integer.parseInt(lines[0]);
+      }
+  
+!     protected String getResultString() {
+          return Integer.toString(getCountWeWant());
+      }
+  
+!     private int getCountWeWant() {
+          return countWeWant;
+      }
+  
+!     protected boolean test(Statement aStatement) {
+  
+          try {
+  
+--- 715,729 ----
+          countWeWant = Integer.parseInt(lines[0]);
+      }
+  
+!     public String getResultString() {
+          return Integer.toString(getCountWeWant());
+      }
+  
+!     public int getCountWeWant() {
+          return countWeWant;
+      }
+  
+!     public boolean test(Statement aStatement) {
+  
+          try {
+  
+*************** class CountParsedSection extends ParsedS
+*** 774,791 ****
+  /** Represents a ParsedSection for an Exception test */
+  class ExceptionParsedSection extends ParsedSection {
+  
+!     protected ExceptionParsedSection(String[] lines) {
+  
+          super(lines);
+  
+          type = 'e';
+      }
+  
+!     protected String getResultString() {
+          return "SQLException";
+      }
+  
+!     protected boolean test(Statement aStatement) {
+  
+          try {
+              aStatement.execute(getSql());
+--- 774,791 ----
+  /** Represents a ParsedSection for an Exception test */
+  class ExceptionParsedSection extends ParsedSection {
+  
+!     public ExceptionParsedSection(String[] lines) {
+  
+          super(lines);
+  
+          type = 'e';
+      }
+  
+!     public String getResultString() {
+          return "SQLException";
+      }
+  
+!     public boolean test(Statement aStatement) {
+  
+          try {
+              aStatement.execute(getSql());
+*************** class ExceptionParsedSection extends Par
+*** 804,817 ****
+  /** Represents a ParsedSection for a section with blank type */
+  class BlankParsedSection extends ParsedSection {
+  
+!     protected BlankParsedSection(String[] lines) {
+  
+          super(lines);
+  
+          type = ' ';
+      }
+  
+!     protected String getResultString() {
+          return "No result specified for this section";
+      }
+  }
+--- 804,817 ----
+  /** Represents a ParsedSection for a section with blank type */
+  class BlankParsedSection extends ParsedSection {
+  
+!     public BlankParsedSection(String[] lines) {
+  
+          super(lines);
+  
+          type = ' ';
+      }
+  
+!     public String getResultString() {
+          return "No result specified for this section";
+      }
+  }
+*************** class BlankParsedSection extends ParsedS
+*** 819,825 ****
+  /** Represents a ParsedSection that is to be ignored */
+  class IgnoreParsedSection extends ParsedSection {
+  
+!     protected IgnoreParsedSection(String[] inLines, char aType) {
+  
+          /* Extremely ambiguous to use input parameter of same exact
+           * variable name as the superclass member "lines".
+--- 819,825 ----
+  /** Represents a ParsedSection that is to be ignored */
+  class IgnoreParsedSection extends ParsedSection {
+  
+!     public IgnoreParsedSection(String[] inLines, char aType) {
+  
+          /* Extremely ambiguous to use input parameter of same exact
+           * variable name as the superclass member "lines".
+*************** class IgnoreParsedSection extends Parsed
+*** 833,839 ****
+          type = aType;
+      }
+  
+!     protected String getResultString() {
+          return "This section, of type '" + getType() + "' was ignored";
+      }
+  }
+--- 833,839 ----
+          type = aType;
+      }
+  
+!     public String getResultString() {
+          return "This section, of type '" + getType() + "' was ignored";
+      }
+  }
+*************** class IgnoreParsedSection extends Parsed
+*** 841,847 ****
+  /** Represents a Section to be Displayed, not executed */
+  class DisplaySection extends ParsedSection {
+  
+!     protected DisplaySection(String[] inLines) {
+  
+          /* Can't user the super constructor, since it does funny things when
+           * constructing the SQL Buffer, which we don't need. */
+--- 841,847 ----
+  /** Represents a Section to be Displayed, not executed */
+  class DisplaySection extends ParsedSection {
+  
+!     public DisplaySection(String[] inLines) {
+  
+          /* Can't user the super constructor, since it does funny things when
+           * constructing the SQL Buffer, which we don't need. */
+*************** class DisplaySection extends ParsedSecti
+*** 852,858 ****
+          lines[0] = lines[0].substring(firstSlash + 1);
+      }
+  
+!     protected String getResultString() {
+  
+          StringBuffer sb = new StringBuffer();
+  
+--- 852,858 ----
+          lines[0] = lines[0].substring(firstSlash + 1);
+      }
+  
+!     public String getResultString() {
+  
+          StringBuffer sb = new StringBuffer();
+  
+diff -pcr misc/hsqldb/src/org/hsqldb/TextTable.java misc/build/hsqldb/src/org/hsqldb/TextTable.java
+*** misc/hsqldb/src/org/hsqldb/TextTable.java	2006-02-07 04:12:24.000000000 +0100
+--- misc/build/hsqldb/src/org/hsqldb/TextTable.java	2007-02-28 12:32:48.000000000 +0100
+*************** import org.hsqldb.persist.TextCache;
+*** 48,55 ****
+   */
+  class TextTable extends org.hsqldb.Table {
+  
+!     private String  dataSource = "";
+!     private boolean isReversed = false;
+  
+      /**
+       *  Constructs a new TextTable from the given arguments.
+--- 48,55 ----
+   */
+  class TextTable extends org.hsqldb.Table {
+  
+!     public String  dataSource = "";
+!     public boolean isReversed = false;
+  
+      /**
+       *  Constructs a new TextTable from the given arguments.
+*************** class TextTable extends org.hsqldb.Table
+*** 72,78 ****
+       *
+       * Better clarification of the role of the methods is needed.
+       */
+!     private void openCache(String dataSourceNew, boolean isReversedNew,
+                             boolean isReadOnlyNew) throws HsqlException {
+  
+          if (dataSourceNew == null) {
+--- 72,78 ----
+       *
+       * Better clarification of the role of the methods is needed.
+       */
+!     public void openCache(String dataSourceNew, boolean isReversedNew,
+                             boolean isReadOnlyNew) throws HsqlException {
+  
+          if (dataSourceNew == null) {
+*************** class TextTable extends org.hsqldb.Table
+*** 153,159 ****
+       * High level command to assign a data source to the table definition.
+       * Reassigns only if the data source or direction has changed.
+       */
+!     protected void setDataSource(Session s, String dataSourceNew,
+                                   boolean isReversedNew,
+                                   boolean newFile) throws HsqlException {
+  
+--- 153,159 ----
+       * High level command to assign a data source to the table definition.
+       * Reassigns only if the data source or direction has changed.
+       */
+!     public void setDataSource(Session s, String dataSourceNew,
+                                   boolean isReversedNew,
+                                   boolean newFile) throws HsqlException {
+  
+*************** class TextTable extends org.hsqldb.Table
+*** 180,190 ****
+          }
+      }
+  
+!     protected String getDataSource() {
+          return dataSource;
+      }
+  
+!     protected boolean isDescDataSource() {
+          return isReversed;
+      }
+  
+--- 180,190 ----
+          }
+      }
+  
+!     public String getDataSource() {
+          return dataSource;
+      }
+  
+!     public boolean isDescDataSource() {
+          return isReversed;
+      }
+  
+*************** class TextTable extends org.hsqldb.Table
+*** 239,245 ****
+          return false;
+      }
+  
+!     protected Table duplicate() throws HsqlException {
+          return new TextTable(database, tableName, getTableType());
+      }
+  
+--- 239,245 ----
+          return false;
+      }
+  
+!     public Table duplicate() throws HsqlException {
+          return new TextTable(database, tableName, getTableType());
+      }
+  
+diff -pcr misc/hsqldb/src/org/hsqldb/Tokenizer.java misc/build/hsqldb/src/org/hsqldb/Tokenizer.java
+*** misc/hsqldb/src/org/hsqldb/Tokenizer.java	2006-07-21 15:38:12.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/Tokenizer.java	2007-02-28 12:32:48.000000000 +0100
+*************** import org.hsqldb.lib.java.JavaSystem;
+*** 98,104 ****
+   */
+  public class Tokenizer {
+  
+!     private static final int NO_TYPE     = 0,
+                               NAME        = 1,
+                               LONG_NAME   = 2,
+                               SPECIAL     = 3,
+--- 98,104 ----
+   */
+  public class Tokenizer {
+  
+!     public static final int NO_TYPE     = 0,
+                               NAME        = 1,
+                               LONG_NAME   = 2,
+                               SPECIAL     = 3,
+*************** public class Tokenizer {
+*** 115,142 ****
+                               NAMED_PARAM = 14;
+  
+      // used only internally
+!     private static final int QUOTED_IDENTIFIER = 15,
+                               REMARK_LINE       = 16,
+                               REMARK            = 17;
+!     private String           sCommand;
+!     private int              iLength;
+!     private int              iIndex;
+!     private int              tokenIndex;
+!     private int              nextTokenIndex;
+!     private int              beginIndex;
+!     private int              iType;
+!     private String           sToken;
+!     private String           sLongNameFirst = null;
+!     private int              typeLongNameFirst;
+  
+      // getToken() will clear LongNameFirst unless retainFirst is set.
+!     private boolean retainFirst = false;
+  
+! //    private String           sLongNameLast;
+      // WAIT.  Don't do anything before popping another Token (because the
+      // state variables aren't set properly due to a call of wait()).
+!     private boolean bWait;
+!     private boolean lastTokenQuotedID;
+  
+      // literals that are values
+      static IntValueHashMap valueTokens;
+--- 115,142 ----
+                               NAMED_PARAM = 14;
+  
+      // used only internally
+!     public static final int QUOTED_IDENTIFIER = 15,
+                               REMARK_LINE       = 16,
+                               REMARK            = 17;
+!     public String           sCommand;
+!     public int              iLength;
+!     public int              iIndex;
+!     public int              tokenIndex;
+!     public int              nextTokenIndex;
+!     public int              beginIndex;
+!     public int              iType;
+!     public String           sToken;
+!     public String           sLongNameFirst = null;
+!     public int              typeLongNameFirst;
+  
+      // getToken() will clear LongNameFirst unless retainFirst is set.
+!     public boolean retainFirst = false;
+  
+! //    public String           sLongNameLast;
+      // WAIT.  Don't do anything before popping another Token (because the
+      // state variables aren't set properly due to a call of wait()).
+!     public boolean bWait;
+!     public boolean lastTokenQuotedID;
+  
+      // literals that are values
+      static IntValueHashMap valueTokens;
+*************** public class Tokenizer {
+*** 731,737 ****
+       *
+       * @throws HsqlException
+       */
+!     private void getToken() throws HsqlException {
+  
+          if (bWait) {
+              bWait  = false;
+--- 731,737 ----
+       *
+       * @throws HsqlException
+       */
+!     public void getToken() throws HsqlException {
+  
+          if (bWait) {
+              bWait  = false;
+*************** public class Tokenizer {
+*** 1111,1117 ****
+  // because these strings might end up as part of internal data structures
+  // or table elements.
+  // we may consider using pools to avoid recreating the strings
+!     private String getString(char quoteChar) throws HsqlException {
+  
+          try {
+              int     nextIndex   = iIndex;
+--- 1111,1117 ----
+  // because these strings might end up as part of internal data structures
+  // or table elements.
+  // we may consider using pools to avoid recreating the strings
+!     public String getString(char quoteChar) throws HsqlException {
+  
+          try {
+              int     nextIndex   = iIndex;
+diff -pcr misc/hsqldb/src/org/hsqldb/Token.java misc/build/hsqldb/src/org/hsqldb/Token.java
+*** misc/hsqldb/src/org/hsqldb/Token.java	2005-10-23 19:40:18.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/Token.java	2007-02-28 12:32:48.000000000 +0100
+*************** import org.hsqldb.lib.IntValueHashMap;
+*** 45,51 ****
+   */
+  public class Token {
+  
+!     private static IntValueHashMap commandSet;
+  
+      //
+      static final String        T_ASTERISK     = "*";
+--- 45,51 ----
+   */
+  public class Token {
+  
+!     public static IntValueHashMap commandSet;
+  
+      //
+      static final String        T_ASTERISK     = "*";
+*************** public class Token {
+*** 716,722 ****
+       *
+       * @return a new map for the database command token set
+       */
+!     private static IntValueHashMap newCommandSet() {
+  
+          IntValueHashMap commandSet;
+  
+--- 716,722 ----
+       *
+       * @return a new map for the database command token set
+       */
+!     public static IntValueHashMap newCommandSet() {
+  
+          IntValueHashMap commandSet;
+  
+*************** public class Token {
+*** 798,804 ****
+          return commandSet.get(token, -1);
+      }
+  
+!     private static HashSet keywords;
+      static IntValueHashMap valueTokens;
+  
+      static {
+--- 798,804 ----
+          return commandSet.get(token, -1);
+      }
+  
+!     public static HashSet keywords;
+      static IntValueHashMap valueTokens;
+  
+      static {
+diff -pcr misc/hsqldb/src/org/hsqldb/Trace.java misc/build/hsqldb/src/org/hsqldb/Trace.java
+*** misc/hsqldb/src/org/hsqldb/Trace.java	2006-02-15 16:51:37.000000000 +0100
+--- misc/build/hsqldb/src/org/hsqldb/Trace.java	2007-02-28 12:32:48.000000000 +0100
+*************** public class Trace {
+*** 706,712 ****
+      /**
+       * Returns the stack trace for doAssert()
+       */
+!     private static String getStackTrace() {
+  
+          try {
+              Exception e = new Exception();
+--- 706,712 ----
+      /**
+       * Returns the stack trace for doAssert()
+       */
+!     public static String getStackTrace() {
+  
+          try {
+              Exception e = new Exception();
+diff -pcr misc/hsqldb/src/org/hsqldb/TransactionManager.java misc/build/hsqldb/src/org/hsqldb/TransactionManager.java
+*** misc/hsqldb/src/org/hsqldb/TransactionManager.java	2005-11-19 17:59:13.000000000 +0100
+--- misc/build/hsqldb/src/org/hsqldb/TransactionManager.java	2007-02-28 12:32:48.000000000 +0100
+*************** public class TransactionManager {
+*** 169,175 ****
+          }
+      }
+  
+!     private long globalActionTimestamp = 0;
+  
+      /**
+       * gets the next timestamp for an action
+--- 169,175 ----
+          }
+      }
+  
+!     public long globalActionTimestamp = 0;
+  
+      /**
+       * gets the next timestamp for an action
+diff -pcr misc/hsqldb/src/org/hsqldb/TriggerDef.java misc/build/hsqldb/src/org/hsqldb/TriggerDef.java
+*** misc/hsqldb/src/org/hsqldb/TriggerDef.java	2005-10-23 20:26:30.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/TriggerDef.java	2007-02-28 12:32:48.000000000 +0100
+*************** class TriggerDef extends Thread {
+*** 84,100 ****
+          return defaultQueueSize;
+      }
+  
+!     protected static int defaultQueueSize = 1024;
+      Table                table;
+      Trigger              trigger;
+      String               triggerClassName;
+      int                  vectorIndex;               // index into HsqlArrayList[]
+  
+!     //protected boolean busy;               // firing trigger in progress
+!     protected HsqlDeque        pendingQueue;        // row triggers pending
+!     protected int              rowsQueued;          // rows in pendingQueue
+!     protected boolean          valid     = true;    // parsing valid
+!     protected volatile boolean keepGoing = true;
+  
+      /**
+       *  Constructs a new TriggerDef object to represent an HSQLDB trigger
+--- 84,100 ----
+          return defaultQueueSize;
+      }
+  
+!     public static int defaultQueueSize = 1024;
+      Table                table;
+      Trigger              trigger;
+      String               triggerClassName;
+      int                  vectorIndex;               // index into HsqlArrayList[]
+  
+!     //public boolean busy;               // firing trigger in progress
+!     public HsqlDeque        pendingQueue;        // row triggers pending
+!     public int              rowsQueued;          // rows in pendingQueue
+!     public boolean          valid     = true;    // parsing valid
+!     public volatile boolean keepGoing = true;
+  
+      /**
+       *  Constructs a new TriggerDef object to represent an HSQLDB trigger
+diff -pcr misc/hsqldb/src/org/hsqldb/types/Binary.java misc/build/hsqldb/src/org/hsqldb/types/Binary.java
+*** misc/hsqldb/src/org/hsqldb/types/Binary.java	2005-10-23 20:26:30.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/types/Binary.java	2007-02-28 12:32:48.000000000 +0100
+*************** import org.hsqldb.lib.StringConverter;
+*** 46,52 ****
+   */
+  public class Binary {
+  
+!     private byte[] data;
+      int            hash;
+  
+      /**
+--- 46,52 ----
+   */
+  public class Binary {
+  
+!     public byte[] data;
+      int            hash;
+  
+      /**
+diff -pcr misc/hsqldb/src/org/hsqldb/types/JavaObject.java misc/build/hsqldb/src/org/hsqldb/types/JavaObject.java
+*** misc/hsqldb/src/org/hsqldb/types/JavaObject.java	2005-10-23 20:26:30.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/types/JavaObject.java	2007-02-28 12:32:48.000000000 +0100
+*************** import org.hsqldb.lib.InOutUtil;
+*** 65,71 ****
+   */
+  public class JavaObject {
+  
+!     private byte[] data;
+  
+      /**
+       * Constructor used inside the engine when an already serialized
+--- 65,71 ----
+   */
+  public class JavaObject {
+  
+!     public byte[] data;
+  
+      /**
+       * Constructor used inside the engine when an already serialized
+diff -pcr misc/hsqldb/src/org/hsqldb/Types.java misc/build/hsqldb/src/org/hsqldb/Types.java
+*** misc/hsqldb/src/org/hsqldb/Types.java	2006-07-10 13:03:54.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/Types.java	2007-02-28 12:32:48.000000000 +0100
+*************** public class Types {
+*** 461,467 ****
+  //                   Function.java whose number class is
+  //                   narrower than the corresponding internal
+  //                   wrapper
+!     private static org.hsqldb.lib.HashSet illegalParameterClasses;
+  
+      static {
+          typeAliases = new IntValueHashMap(67, 1);
+--- 461,467 ----
+  //                   Function.java whose number class is
+  //                   narrower than the corresponding internal
+  //                   wrapper
+!     public static org.hsqldb.lib.HashSet illegalParameterClasses;
+  
+      static {
+          typeAliases = new IntValueHashMap(67, 1);
+*************** public class Types {
+*** 1074,1080 ****
+      //
+      // 1.) refusing to directly display such columns in graphical query results
+      // 2.) providing other means to retrieve and display such values
+!     private static int MAX_CHAR_OR_VARCHAR_DISPLAY_SIZE() {
+  
+          try {
+              return Integer.getInteger(
+--- 1074,1080 ----
+      //
+      // 1.) refusing to directly display such columns in graphical query results
+      // 2.) providing other means to retrieve and display such values
+!     public static int MAX_CHAR_OR_VARCHAR_DISPLAY_SIZE() {
+  
+          try {
+              return Integer.getInteger(
+diff -pcr misc/hsqldb/src/org/hsqldb/User.java misc/build/hsqldb/src/org/hsqldb/User.java
+*** misc/hsqldb/src/org/hsqldb/User.java	2006-04-11 16:41:08.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/User.java	2007-02-28 12:32:48.000000000 +0100
+*************** import org.hsqldb.lib.IntValueHashMap;
+*** 91,112 ****
+  public class User {
+  
+      /** true if this user is the sys user. */
+!     private boolean isSys;
+  
+      /** true if this user is the public user. */
+!     private boolean isPublic;
+  
+      /** user name. */
+!     private String sName;
+  
+      /** password. */
+!     private String sPassword;
+  
+      /** default schema when new Sessions started (defaults to PUBLIC schema) */
+!     private HsqlName initialSchema = null;
+  
+      /** grantee object. */
+!     private Grantee grantee;
+  
+      /**
+       * Constructor
+--- 91,112 ----
+  public class User {
+  
+      /** true if this user is the sys user. */
+!     public boolean isSys;
+  
+      /** true if this user is the public user. */
+!     public boolean isPublic;
+  
+      /** user name. */
+!     public String sName;
+  
+      /** password. */
+!     public String sPassword;
+  
+      /** default schema when new Sessions started (defaults to PUBLIC schema) */
+!     public HsqlName initialSchema = null;
+  
+      /** grantee object. */
+!     public Grantee grantee;
+  
+      /**
+       * Constructor
+diff -pcr misc/hsqldb/src/org/hsqldb/UserManager.java misc/build/hsqldb/src/org/hsqldb/UserManager.java
+*** misc/hsqldb/src/org/hsqldb/UserManager.java	2006-04-11 16:41:08.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/UserManager.java	2007-02-28 12:32:48.000000000 +0100
+*************** class UserManager implements GrantConsta
+*** 112,119 ****
+       * User object is kept in the list because it's needed by MetaData
+       * routines via "listVisibleUsers(x, true)".
+       */
+!     private HashMappedList userList;
+!     private GranteeManager granteeManager;
+  
+      /**
+       * Construction happens once for each Database object.
+--- 112,119 ----
+       * User object is kept in the list because it's needed by MetaData
+       * routines via "listVisibleUsers(x, true)".
+       */
+!     public HashMappedList userList;
+!     public GranteeManager granteeManager;
+  
+      /**
+       * Construction happens once for each Database object.
+diff -pcr misc/hsqldb/src/org/hsqldb/util/CodeSwitcher.java misc/build/hsqldb/src/org/hsqldb/util/CodeSwitcher.java
+*** misc/hsqldb/src/org/hsqldb/util/CodeSwitcher.java	2006-07-17 00:29:35.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/util/CodeSwitcher.java	2007-02-28 12:32:48.000000000 +0100
+*************** import java.util.Vector;
+*** 109,121 ****
+   */
+  public class CodeSwitcher {
+  
+!     private static final String ls = System.getProperty("line.separator",
+          "\n");
+!     private Vector           vList;
+!     private Vector           vSwitchOn;
+!     private Vector           vSwitchOff;
+!     private Vector           vSwitches;
+!     private static final int MAX_LINELENGTH = 82;
+  
+      /**
+       * Method declaration
+--- 109,121 ----
+   */
+  public class CodeSwitcher {
+  
+!     public static final String ls = System.getProperty("line.separator",
+          "\n");
+!     public Vector           vList;
+!     public Vector           vSwitchOn;
+!     public Vector           vSwitchOff;
+!     public Vector           vSwitches;
+!     public static final int MAX_LINELENGTH = 82;
+  
+      /**
+       * Method declaration
+diff -pcr misc/hsqldb/src/org/hsqldb/util/CommonSwing.java misc/build/hsqldb/src/org/hsqldb/util/CommonSwing.java
+*** misc/hsqldb/src/org/hsqldb/util/CommonSwing.java	2006-02-16 03:33:19.000000000 +0100
+--- misc/build/hsqldb/src/org/hsqldb/util/CommonSwing.java	2007-02-28 12:32:48.000000000 +0100
+*************** import javax.swing.UIManager;
+*** 57,68 ****
+   */
+  class CommonSwing {
+  
+!     protected static String messagerHeader = "Database Manager Swing Error";
+!     protected static String Native         = "Native";
+!     protected static String Java           = "Java";
+!     protected static String Motif          = "Motif";
+!     protected static String plaf           = "plaf";
+!     protected static String GTK            = "GTK";
+  
+      // (ulrivo): An actual Image.
+      static Image getIcon(String target) {
+--- 57,68 ----
+   */
+  class CommonSwing {
+  
+!     public static String messagerHeader = "Database Manager Swing Error";
+!     public static String Native         = "Native";
+!     public static String Java           = "Java";
+!     public static String Motif          = "Motif";
+!     public static String plaf           = "plaf";
+!     public static String GTK            = "GTK";
+  
+      // (ulrivo): An actual Image.
+      static Image getIcon(String target) {
+*************** class CommonSwing {
+*** 106,112 ****
+      }
+  
+      // (weconsultants@users: Callable errorMessage method
+!     protected static void errorMessage(String errorMessage) {
+  
+          /**
+           * Display Jpanel Error messages any text Errors. Overloads
+--- 106,112 ----
+      }
+  
+      // (weconsultants@users: Callable errorMessage method
+!     public static void errorMessage(String errorMessage) {
+  
+          /**
+           * Display Jpanel Error messages any text Errors. Overloads
+diff -pcr misc/hsqldb/src/org/hsqldb/util/ConnectionDialogCommon.java misc/build/hsqldb/src/org/hsqldb/util/ConnectionDialogCommon.java
+*** misc/hsqldb/src/org/hsqldb/util/ConnectionDialogCommon.java	2005-10-23 20:26:31.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/util/ConnectionDialogCommon.java	2007-02-28 12:32:48.000000000 +0100
+*************** import org.hsqldb.lib.java.JavaSystem;
+*** 59,66 ****
+   */
+  class ConnectionDialogCommon {
+  
+!     private static String[][]       connTypes;
+!     private static final String[][] sJDBCTypes = {
+          {
+              "HSQL Database Engine In-Memory", "org.hsqldb.jdbcDriver",
+              "jdbc:hsqldb:mem:."
+--- 59,66 ----
+   */
+  class ConnectionDialogCommon {
+  
+!     public static String[][]       connTypes;
+!     public static final String[][] sJDBCTypes = {
+          {
+              "HSQL Database Engine In-Memory", "org.hsqldb.jdbcDriver",
+              "jdbc:hsqldb:mem:."
+*************** class ConnectionDialogCommon {
+*** 160,167 ****
+   */
+      }
+  
+!     private static final String fileName       = "hsqlprefs.dat";
+!     private static File         recentSettings = null;
+  
+      static Hashtable loadRecentConnectionSettings() throws IOException {
+  
+--- 160,167 ----
+   */
+      }
+  
+!     public static final String fileName       = "hsqlprefs.dat";
+!     public static File         recentSettings = null;
+  
+      static Hashtable loadRecentConnectionSettings() throws IOException {
+  
+*************** class ConnectionDialogCommon {
+*** 246,252 ****
+       * @param settings ConnectionSetting[]
+       * @throw IOException if something goes wrong while writing
+       */
+!     private static void storeRecentConnectionSettings(Hashtable settings) {
+  
+          try {
+              if (recentSettings == null) {
+--- 246,252 ----
+       * @param settings ConnectionSetting[]
+       * @throw IOException if something goes wrong while writing
+       */
+!     public static void storeRecentConnectionSettings(Hashtable settings) {
+  
+          try {
+              if (recentSettings == null) {
+*************** class ConnectionDialogCommon {
+*** 311,317 ****
+          } catch (Throwable t) {}
+      }
+  
+!     private static String homedir = null;
+  
+      public static void setHomeDir() {
+  
+--- 311,317 ----
+          } catch (Throwable t) {}
+      }
+  
+!     public static String homedir = null;
+  
+      public static void setHomeDir() {
+  
+diff -pcr misc/hsqldb/src/org/hsqldb/util/ConnectionDialog.java misc/build/hsqldb/src/org/hsqldb/util/ConnectionDialog.java
+*** misc/hsqldb/src/org/hsqldb/util/ConnectionDialog.java	2005-10-23 20:26:31.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/util/ConnectionDialog.java	2007-02-28 12:32:48.000000000 +0100
+*************** import java.awt.event.ItemListener;
+*** 67,78 ****
+  class ConnectionDialog extends Dialog
+  implements ActionListener, ItemListener {
+  
+!     protected Connection mConnection;
+!     protected TextField  mName, mDriver, mURL, mUser, mPassword;
+!     protected Label      mError;
+!     private String[][]   connTypes;
+!     private Hashtable    settings;
+!     private Choice       types, recent;
+  
+      /**
+       * Method declaration
+--- 67,78 ----
+  class ConnectionDialog extends Dialog
+  implements ActionListener, ItemListener {
+  
+!     public Connection mConnection;
+!     public TextField  mName, mDriver, mURL, mUser, mPassword;
+!     public Label      mError;
+!     public String[][]   connTypes;
+!     public Hashtable    settings;
+!     public Choice       types, recent;
+  
+      /**
+       * Method declaration
+*************** implements ActionListener, ItemListener 
+*** 110,116 ****
+       * Method declaration
+       *
+       */
+!     private void create() {
+  
+          Dimension d = Toolkit.getDefaultToolkit().getScreenSize();
+  
+--- 110,116 ----
+       * Method declaration
+       *
+       */
+!     public void create() {
+  
+          Dimension d = Toolkit.getDefaultToolkit().getScreenSize();
+  
+*************** implements ActionListener, ItemListener 
+*** 305,311 ****
+       *
+       * @return
+       */
+!     protected static Label createLabel(String s) {
+  
+          Label l = new Label(s);
+  
+--- 305,311 ----
+       *
+       * @return
+       */
+!     public static Label createLabel(String s) {
+  
+          Label l = new Label(s);
+  
+*************** implements ActionListener, ItemListener 
+*** 322,328 ****
+       *
+       * @return
+       */
+!     protected static Panel createBorderPanel(Component center) {
+  
+          Panel p = new Panel();
+  
+--- 322,328 ----
+       *
+       * @return
+       */
+!     public static Panel createBorderPanel(Component center) {
+  
+          Panel p = new Panel();
+  
+diff -pcr misc/hsqldb/src/org/hsqldb/util/ConnectionDialogSwing.java misc/build/hsqldb/src/org/hsqldb/util/ConnectionDialogSwing.java
+*** misc/hsqldb/src/org/hsqldb/util/ConnectionDialogSwing.java	2006-01-29 13:48:18.000000000 +0100
+--- misc/build/hsqldb/src/org/hsqldb/util/ConnectionDialogSwing.java	2007-02-28 12:32:48.000000000 +0100
+*************** implements ActionListener, ItemListener 
+*** 82,97 ****
+      /**
+       * Comment for <code>serialVersionUID</code>
+       */
+!     private static final long serialVersionUID = 1L;
+!     private Connection        mConnection;
+!     private JTextField        mName, mDriver, mURL, mUser;
+!     private JPasswordField    mPassword;
+!     private String[][]        connTypes;
+!     private Hashtable         settings;
+!     private JButton           okCancel, clear;
+!     private JComboBox mSettingName =
+          new JComboBox(loadRecentConnectionSettings());
+!     private static ConnectionSetting currentConnectionSetting = null;
+  
+      public static void setConnectionSetting(
+              ConnectionSetting connectionSetting) {
+--- 82,97 ----
+      /**
+       * Comment for <code>serialVersionUID</code>
+       */
+!     public static final long serialVersionUID = 1L;
+!     public Connection        mConnection;
+!     public JTextField        mName, mDriver, mURL, mUser;
+!     public JPasswordField    mPassword;
+!     public String[][]        connTypes;
+!     public Hashtable         settings;
+!     public JButton           okCancel, clear;
+!     public JComboBox mSettingName =
+          new JComboBox(loadRecentConnectionSettings());
+!     public static ConnectionSetting currentConnectionSetting = null;
+  
+      public static void setConnectionSetting(
+              ConnectionSetting connectionSetting) {
+*************** implements ActionListener, ItemListener 
+*** 110,116 ****
+          super(owner, title, true);
+      }
+  
+!     private void create() {
+  
+          Box main     = Box.createHorizontalBox();
+          Box labels   = Box.createVerticalBox();
+--- 110,116 ----
+          super(owner, title, true);
+      }
+  
+!     public void create() {
+  
+          Box main     = Box.createHorizontalBox();
+          Box labels   = Box.createVerticalBox();
+*************** implements ActionListener, ItemListener 
+*** 285,291 ****
+          return dialog.mConnection;
+      }
+  
+!     private static JLabel createLabel(String s) {
+  
+          JLabel l = new JLabel(s);
+  
+--- 285,291 ----
+          return dialog.mConnection;
+      }
+  
+!     public static JLabel createLabel(String s) {
+  
+          JLabel l = new JLabel(s);
+  
+diff -pcr misc/hsqldb/src/org/hsqldb/util/ConnectionSetting.java misc/build/hsqldb/src/org/hsqldb/util/ConnectionSetting.java
+*** misc/hsqldb/src/org/hsqldb/util/ConnectionSetting.java	2005-10-23 20:26:31.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/util/ConnectionSetting.java	2007-02-28 12:32:48.000000000 +0100
+*************** package org.hsqldb.util;
+*** 39,45 ****
+   */
+  public class ConnectionSetting implements java.io.Serializable {
+  
+!     private String name, driver, url, user, pw;
+  
+      String getName() {
+          return name;
+--- 39,45 ----
+   */
+  public class ConnectionSetting implements java.io.Serializable {
+  
+!     public String name, driver, url, user, pw;
+  
+      String getName() {
+          return name;
+*************** public class ConnectionSetting implement
+*** 62,68 ****
+      }
+  
+      // Constructors
+!     private ConnectionSetting() {}
+      ;
+  
+      ConnectionSetting(String name, String driver, String url, String user,
+--- 62,68 ----
+      }
+  
+      // Constructors
+!     public ConnectionSetting() {}
+      ;
+  
+      ConnectionSetting(String name, String driver, String url, String user,
+diff -pcr misc/hsqldb/src/org/hsqldb/util/CSVWriter.java misc/build/hsqldb/src/org/hsqldb/util/CSVWriter.java
+*** misc/hsqldb/src/org/hsqldb/util/CSVWriter.java	2005-10-23 20:26:31.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/util/CSVWriter.java	2007-02-28 12:32:48.000000000 +0100
+*************** import java.io.OutputStreamWriter;
+*** 49,58 ****
+   */
+  public class CSVWriter {
+  
+!     private String             newline = System.getProperty("line.separator");
+!     private OutputStreamWriter writer  = null;
+!     private int                nbrCols = 0;
+!     private int                nbrRows = 0;
+  
+      /**
+       * constructor.
+--- 49,58 ----
+   */
+  public class CSVWriter {
+  
+!     public String             newline = System.getProperty("line.separator");
+!     public OutputStreamWriter writer  = null;
+!     public int                nbrCols = 0;
+!     public int                nbrRows = 0;
+  
+      /**
+       * constructor.
+*************** public class CSVWriter {
+*** 100,106 ****
+          this.writer.close();
+      }
+  
+!     private void doWriteData(String[] values) throws IOException {
+  
+          for (int i = 0; i < values.length; i++) {
+              if (i > 0) {
+--- 100,106 ----
+          this.writer.close();
+      }
+  
+!     public void doWriteData(String[] values) throws IOException {
+  
+          for (int i = 0; i < values.length; i++) {
+              if (i > 0) {
+*************** public class CSVWriter {
+*** 119,125 ****
+          this.nbrRows++;
+      }
+  
+!     private String toCsvValue(String str) {
+  
+          StringBuffer sb = new StringBuffer();
+  
+--- 119,125 ----
+          this.nbrRows++;
+      }
+  
+!     public String toCsvValue(String str) {
+  
+          StringBuffer sb = new StringBuffer();
+  
+diff -pcr misc/hsqldb/src/org/hsqldb/util/DatabaseManagerCommon.java misc/build/hsqldb/src/org/hsqldb/util/DatabaseManagerCommon.java
+*** misc/hsqldb/src/org/hsqldb/util/DatabaseManagerCommon.java	2005-10-23 20:26:31.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/util/DatabaseManagerCommon.java	2007-02-28 12:32:48.000000000 +0100
+*************** import java.util.Random;
+*** 92,98 ****
+   */
+  class DatabaseManagerCommon {
+  
+!     private static Random rRandom    = new Random(100);
+      static String[]       selectHelp = {
+          "SELECT * FROM ",
+          "SELECT [LIMIT n m] [DISTINCT] \n"
+--- 92,98 ----
+   */
+  class DatabaseManagerCommon {
+  
+!     public static Random rRandom    = new Random(100);
+      static String[]       selectHelp = {
+          "SELECT * FROM ",
+          "SELECT [LIMIT n m] [DISTINCT] \n"
+*************** class DatabaseManagerCommon {
+*** 405,409 ****
+          return (System.currentTimeMillis() - start);
+      }
+  
+!     private DatabaseManagerCommon() {}
+  }
+--- 405,409 ----
+          return (System.currentTimeMillis() - start);
+      }
+  
+!     public DatabaseManagerCommon() {}
+  }
+diff -pcr misc/hsqldb/src/org/hsqldb/util/DatabaseManager.java misc/build/hsqldb/src/org/hsqldb/util/DatabaseManager.java
+*** misc/hsqldb/src/org/hsqldb/util/DatabaseManager.java	2006-04-11 17:03:31.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/util/DatabaseManager.java	2007-02-28 12:32:48.000000000 +0100
+*************** import org.hsqldb.lib.java.JavaSystem;
+*** 98,104 ****
+  public class DatabaseManager extends Applet
+  implements ActionListener, WindowListener, KeyListener {
+  
+!     private static final String DEFAULT_RCFILE =
+          System.getProperty("user.home") + "/dbmanager.rc";
+      static final String NL         = System.getProperty("line.separator");
+      static final int    iMaxRecent = 24;
+--- 98,104 ----
+  public class DatabaseManager extends Applet
+  implements ActionListener, WindowListener, KeyListener {
+  
+!     public static final String DEFAULT_RCFILE =
+          System.getProperty("user.home") + "/dbmanager.rc";
+      static final String NL         = System.getProperty("line.separator");
+      static final int    iMaxRecent = 24;
+*************** implements ActionListener, WindowListene
+*** 289,295 ****
+          m.connect(c);
+      }
+  
+!     private static void showUsage() {
+  
+          System.out.println(
+              "Usage: java DatabaseManager [--options]\n"
+--- 289,295 ----
+          m.connect(c);
+      }
+  
+!     public static void showUsage() {
+  
+          System.out.println(
+              "Usage: java DatabaseManager [--options]\n"
+*************** implements ActionListener, WindowListene
+*** 1149,1155 ****
+       *
+       * @param s
+       */
+!     private void addToRecent(String s) {
+  
+          for (int i = 0; i < iMaxRecent; i++) {
+              if (s.equals(sRecent[i])) {
+--- 1149,1155 ----
+       *
+       * @param s
+       */
+!     public void addToRecent(String s) {
+  
+          for (int i = 0; i < iMaxRecent; i++) {
+              if (s.equals(sRecent[i])) {
+*************** implements ActionListener, WindowListene
+*** 1180,1186 ****
+       * Method declaration
+       *
+       */
+!     private void initGUI() {
+  
+          Panel pQuery   = new Panel();
+          Panel pCommand = new Panel();
+--- 1180,1186 ----
+       * Method declaration
+       *
+       */
+!     public void initGUI() {
+  
+          Panel pQuery   = new Panel();
+          Panel pCommand = new Panel();
+*************** implements ActionListener, WindowListene
+*** 1240,1246 ****
+       * Method declaration
+       *
+       */
+!     protected void refreshTree() {
+  
+          tTree.removeAll();
+  
+--- 1240,1246 ----
+       * Method declaration
+       *
+       */
+!     public void refreshTree() {
+  
+          tTree.removeAll();
+  
+diff -pcr misc/hsqldb/src/org/hsqldb/util/DatabaseManagerSwing.java misc/build/hsqldb/src/org/hsqldb/util/DatabaseManagerSwing.java
+*** misc/hsqldb/src/org/hsqldb/util/DatabaseManagerSwing.java	2006-07-27 22:04:31.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/util/DatabaseManagerSwing.java	2007-02-28 12:32:48.000000000 +0100
+*************** implements ActionListener, WindowListene
+*** 196,202 ****
+       * be reserved for single-letter switches which can be mixed like
+       * "-u -r -l" = "-url".  -blaine
+       */
+!     private static String homedir = null;
+  
+      static {
+          try {
+--- 196,202 ----
+       * be reserved for single-letter switches which can be mixed like
+       * "-u -r -l" = "-url".  -blaine
+       */
+!     public static String homedir = null;
+  
+      static {
+          try {
+*************** implements ActionListener, WindowListene
+*** 242,255 ****
+      }
+  
+      ArrayList                   localActionList = new ArrayList();
+!     private JFrame              jframe          = null;
+!     private static final String DEFAULT_RCFILE  = homedir + "/dbmanager.rc";
+!     private static final String HELP_TEXT =
+          "See the forums, mailing lists, and HSQLDB User Guide\n"
+          + "at http://hsqldb.org.\n\n"
+          + "Please paste the following version identifier with any\n"
+          + "problem reports or help requests:  $Revision: 1.69 $";
+!     private static final String ABOUT_TEXT =
+          "$Revision: 1.69 $ of DatabaseManagerSwing\n\n"
+          + "Copyright (c) 1995-2000, The Hypersonic SQL Group.\n"
+          + "Copyright (c) 2001-2005, The HSQL Development Group.\n"
+--- 242,255 ----
+      }
+  
+      ArrayList                   localActionList = new ArrayList();
+!     public JFrame              jframe          = null;
+!     public static final String DEFAULT_RCFILE  = homedir + "/dbmanager.rc";
+!     public static final String HELP_TEXT =
+          "See the forums, mailing lists, and HSQLDB User Guide\n"
+          + "at http://hsqldb.org.\n\n"
+          + "Please paste the following version identifier with any\n"
+          + "problem reports or help requests:  $Revision: 1.69 $";
+!     public static final String ABOUT_TEXT =
+          "$Revision: 1.69 $ of DatabaseManagerSwing\n\n"
+          + "Copyright (c) 1995-2000, The Hypersonic SQL Group.\n"
+          + "Copyright (c) 2001-2005, The HSQL Development Group.\n"
+*************** implements ActionListener, WindowListene
+*** 300,309 ****
+      /** Value of this variable only retained if huge input script read in. */
+      String          sqlScriptBuffer = null;
+      JToolBar        jtoolbar;
+!     private boolean showSchemas  = true;
+!     private boolean showTooltips = true;
+!     private boolean autoRefresh  = true;
+!     private boolean gridFormat   = true;
+  
+      // Added: (weconsultants@users)
+      static DatabaseManagerSwing refForFontDialogSwing;
+--- 300,309 ----
+      /** Value of this variable only retained if huge input script read in. */
+      String          sqlScriptBuffer = null;
+      JToolBar        jtoolbar;
+!     public boolean showSchemas  = true;
+!     public boolean showTooltips = true;
+!     public boolean autoRefresh  = true;
+!     public boolean gridFormat   = true;
+  
+      // Added: (weconsultants@users)
+      static DatabaseManagerSwing refForFontDialogSwing;
+*************** implements ActionListener, WindowListene
+*** 339,352 ****
+          new JRadioButtonMenuItem("Motif Look & Feel");
+      JLabel                      jStatusLine;
+      static String               READY_STATUS         = "Ready";
+!     private static final String AUTOCOMMIT_BOX_TEXT  = "Autocommit mode";
+!     private static final String LOGGING_BOX_TEXT     = "Logging mode";
+!     private static final String SHOWSCHEMAS_BOX_TEXT = "Show schemas";
+!     private static final String AUTOREFRESH_BOX_TEXT = "Auto-refresh tree";
+!     private static final String SHOWTIPS_BOX_TEXT    = "Show Tooltips";
+!     private static final String ROWCOUNTS_BOX_TEXT   = "Show row counts";
+!     private static final String SHOWSYS_BOX_TEXT     = "Show system tables";
+!     private static final String GRID_BOX_TEXT =
+          "Show results in Grid (a.o.t. Text)";
+  
+      // variables to hold the default cursors for these top level swing objects
+--- 339,352 ----
+          new JRadioButtonMenuItem("Motif Look & Feel");
+      JLabel                      jStatusLine;
+      static String               READY_STATUS         = "Ready";
+!     public static final String AUTOCOMMIT_BOX_TEXT  = "Autocommit mode";
+!     public static final String LOGGING_BOX_TEXT     = "Logging mode";
+!     public static final String SHOWSCHEMAS_BOX_TEXT = "Show schemas";
+!     public static final String AUTOREFRESH_BOX_TEXT = "Auto-refresh tree";
+!     public static final String SHOWTIPS_BOX_TEXT    = "Show Tooltips";
+!     public static final String ROWCOUNTS_BOX_TEXT   = "Show row counts";
+!     public static final String SHOWSYS_BOX_TEXT     = "Show system tables";
+!     public static final String GRID_BOX_TEXT =
+          "Show results in Grid (a.o.t. Text)";
+  
+      // variables to hold the default cursors for these top level swing objects
+*************** implements ActionListener, WindowListene
+*** 355,368 ****
+      Cursor        txtCommandCursor;
+      Cursor        txtResultCursor;
+      HashMap       tipMap     = new HashMap();
+!     private JMenu mnuSchemas = new JMenu("Schemas");
+  
+      /**
+       * Wait Cursor
+       */
+  
+      // Changed: (weconsultants@users): commonted out the, out of the box, cursor to use a custom cursor
+!     private final Cursor waitCursor = new Cursor(Cursor.WAIT_CURSOR);
+  
+      //getToolkit().createCustomCursor(CommonSwing.getIcon("SystemCursor"),
+      //                                new Point(4, 4), "HourGlass cursor");
+--- 355,368 ----
+      Cursor        txtCommandCursor;
+      Cursor        txtResultCursor;
+      HashMap       tipMap     = new HashMap();
+!     public JMenu mnuSchemas = new JMenu("Schemas");
+  
+      /**
+       * Wait Cursor
+       */
+  
+      // Changed: (weconsultants@users): commonted out the, out of the box, cursor to use a custom cursor
+!     public final Cursor waitCursor = new Cursor(Cursor.WAIT_CURSOR);
+  
+      //getToolkit().createCustomCursor(CommonSwing.getIcon("SystemCursor"),
+      //                                new Point(4, 4), "HourGlass cursor");
+*************** implements ActionListener, WindowListene
+*** 373,379 ****
+      static String  defPassword = "";
+      static String  defScript;
+      static String  defDirectory;
+!     private String schemaFilter = null;
+  
+      public DatabaseManagerSwing() {
+          jframe = new JFrame("HSQLDB DatabaseManager");
+--- 373,379 ----
+      static String  defPassword = "";
+      static String  defScript;
+      static String  defDirectory;
+!     public String schemaFilter = null;
+  
+      public DatabaseManagerSwing() {
+          jframe = new JFrame("HSQLDB DatabaseManager");
+*************** implements ActionListener, WindowListene
+*** 648,654 ****
+          }
+      }
+  
+!     private static void showUsage() {
+  
+          System.out.println(
+              "Usage: java DatabaseManagerSwing [--options]\n"
+--- 648,654 ----
+          }
+      }
+  
+!     public static void showUsage() {
+  
+          System.out.println(
+              "Usage: java DatabaseManagerSwing [--options]\n"
+*************** implements ActionListener, WindowListene
+*** 665,671 ****
+              + "(Single-hypen switches like '-driver' are also supported)");
+      }
+  
+!     private void insertTestData() {
+  
+          try {
+              DatabaseManagerCommon.createTestTables(sStatement);
+--- 665,671 ----
+              + "(Single-hypen switches like '-driver' are also supported)");
+      }
+  
+!     public void insertTestData() {
+  
+          try {
+              DatabaseManagerCommon.createTestTables(sStatement);
+*************** implements ActionListener, WindowListene
+*** 689,695 ****
+          this.bMustExit = b;
+      }
+  
+!     private DBMPrefs prefs = null;
+  
+      public void main() {
+  
+--- 689,695 ----
+          this.bMustExit = b;
+      }
+  
+!     public DBMPrefs prefs = null;
+  
+      public void main() {
+  
+*************** implements ActionListener, WindowListene
+*** 966,972 ****
+          txtCommand.requestFocus();
+      }
+  
+!     private JMenu addMenu(JMenuBar b, String name, Object[] items) {
+  
+          JMenu menu = new JMenu(name);
+  
+--- 966,972 ----
+          txtCommand.requestFocus();
+      }
+  
+!     public JMenu addMenu(JMenuBar b, String name, Object[] items) {
+  
+          JMenu menu = new JMenu(name);
+  
+*************** implements ActionListener, WindowListene
+*** 977,983 ****
+          return menu;
+      }
+  
+!     private void addMenuItems(JMenu f, Object[] m) {
+  
+          /*
+           * This method needs to be completely written or just
+--- 977,983 ----
+          return menu;
+      }
+  
+!     public void addMenuItems(JMenu f, Object[] m) {
+  
+          /*
+           * This method needs to be completely written or just
+*************** implements ActionListener, WindowListene
+*** 1282,1288 ****
+          }
+      }
+  
+!     private void displayResults() {
+  
+          if (gridFormat) {
+              setResultsInGrid();
+--- 1282,1288 ----
+          }
+      }
+  
+!     public void displayResults() {
+  
+          if (gridFormat) {
+              setResultsInGrid();
+*************** implements ActionListener, WindowListene
+*** 1291,1297 ****
+          }
+      }
+  
+!     private void setResultsInGrid() {
+  
+          pResult.removeAll();
+          pResult.add(gScrollPane, BorderLayout.CENTER);
+--- 1291,1297 ----
+          }
+      }
+  
+!     public void setResultsInGrid() {
+  
+          pResult.removeAll();
+          pResult.add(gScrollPane, BorderLayout.CENTER);
+*************** implements ActionListener, WindowListene
+*** 1300,1306 ****
+          pResult.repaint();
+      }
+  
+!     private void setResultsInText() {
+  
+          pResult.removeAll();
+          pResult.add(txtResultScroll, BorderLayout.CENTER);
+--- 1300,1306 ----
+          pResult.repaint();
+      }
+  
+!     public void setResultsInText() {
+  
+          pResult.removeAll();
+          pResult.add(txtResultScroll, BorderLayout.CENTER);
+*************** implements ActionListener, WindowListene
+*** 1309,1315 ****
+          pResult.repaint();
+      }
+  
+!     private void showHelp(String[] help) {
+  
+          txtCommand.setText(help[0]);
+  
+--- 1309,1315 ----
+          pResult.repaint();
+      }
+  
+!     public void showHelp(String[] help) {
+  
+          txtCommand.setText(help[0]);
+  
+*************** implements ActionListener, WindowListene
+*** 1371,1377 ****
+          }
+      }
+  
+!     private void clear() {
+  
+          sqlScriptBuffer = null;
+  
+--- 1371,1377 ----
+          }
+      }
+  
+!     public void clear() {
+  
+          sqlScriptBuffer = null;
+  
+*************** implements ActionListener, WindowListene
+*** 1379,1387 ****
+          txtCommand.setEnabled(true);
+      }
+  
+!     private String busyText = null;
+  
+!     private void backgroundIt(Runnable r, String description) {
+  
+          if (busyText != null) {
+              Toolkit.getDefaultToolkit().beep();
+--- 1379,1387 ----
+          txtCommand.setEnabled(true);
+      }
+  
+!     public String busyText = null;
+  
+!     public void backgroundIt(Runnable r, String description) {
+  
+          if (busyText != null) {
+              Toolkit.getDefaultToolkit().beep();
+*************** implements ActionListener, WindowListene
+*** 1395,1401 ****
+          SwingUtilities.invokeLater(r);
+      }
+  
+!     private void clearResultPanel() {
+  
+          gResult.setHead(new Object[0]);
+          gResult.clear();
+--- 1395,1401 ----
+          SwingUtilities.invokeLater(r);
+      }
+  
+!     public void clearResultPanel() {
+  
+          gResult.setHead(new Object[0]);
+          gResult.clear();
+*************** implements ActionListener, WindowListene
+*** 1452,1474 ****
+                                                      : 0));
+      }
+  
+!     private Runnable enableButtonRunnable = new Runnable() {
+  
+          public void run() {
+              jbuttonClear.setEnabled(true);
+              jbuttonExecute.setEnabled(true);
+          }
+      };
+!     private Runnable disableButtonRunnable = new Runnable() {
+  
+          public void run() {
+              jbuttonClear.setEnabled(false);
+              jbuttonExecute.setEnabled(false);
+          }
+      };
+!     private Thread           buttonUpdaterThread = null;
+!     private static final int BUTTON_CHECK_PERIOD = 500;
+!     private Runnable         buttonUpdater       = new Runnable() {
+  
+          public void run() {
+  
+--- 1452,1474 ----
+                                                      : 0));
+      }
+  
+!     public Runnable enableButtonRunnable = new Runnable() {
+  
+          public void run() {
+              jbuttonClear.setEnabled(true);
+              jbuttonExecute.setEnabled(true);
+          }
+      };
+!     public Runnable disableButtonRunnable = new Runnable() {
+  
+          public void run() {
+              jbuttonClear.setEnabled(false);
+              jbuttonExecute.setEnabled(false);
+          }
+      };
+!     public Thread           buttonUpdaterThread = null;
+!     public static final int BUTTON_CHECK_PERIOD = 500;
+!     public Runnable         buttonUpdater       = new Runnable() {
+  
+          public void run() {
+  
+*************** implements ActionListener, WindowListene
+*** 1492,1499 ****
+              }
+          }
+      };
+!     private JButton jbuttonClear;
+!     private JButton jbuttonExecute;
+  
+      public void start() {
+  
+--- 1492,1499 ----
+              }
+          }
+      };
+!     public JButton jbuttonClear;
+!     public JButton jbuttonExecute;
+  
+      public void start() {
+  
+*************** implements ActionListener, WindowListene
+*** 1511,1517 ****
+          buttonUpdaterThread = null;
+      }
+  
+!     private Runnable treeRefreshRunnable = new Runnable() {
+  
+          public void run() {
+  
+--- 1511,1517 ----
+          buttonUpdaterThread = null;
+      }
+  
+!     public Runnable treeRefreshRunnable = new Runnable() {
+  
+          public void run() {
+  
+*************** implements ActionListener, WindowListene
+*** 1530,1536 ****
+      /**
+       * Schedules to run in a Gui-safe thread
+       */
+!     protected void executeCurrentSQL() {
+  
+          if (txtCommand.getText().length() < 1) {
+              CommonSwing.errorMessage("No SQL to execute");
+--- 1530,1536 ----
+      /**
+       * Schedules to run in a Gui-safe thread
+       */
+!     public void executeCurrentSQL() {
+  
+          if (txtCommand.getText().length() < 1) {
+              CommonSwing.errorMessage("No SQL to execute");
+*************** implements ActionListener, WindowListene
+*** 1541,1547 ****
+          backgroundIt(new StatementExecRunnable(), "Executing SQL");
+      }
+  
+!     protected class StatementExecRunnable implements Runnable {
+  
+          public void run() {
+  
+--- 1541,1547 ----
+          backgroundIt(new StatementExecRunnable(), "Executing SQL");
+      }
+  
+!     public class StatementExecRunnable implements Runnable {
+  
+          public void run() {
+  
+*************** implements ActionListener, WindowListene
+*** 1569,1575 ****
+      }
+      ;
+  
+!     private void executeSQL() {
+  
+          String[] g   = new String[1];
+          String   sql = null;
+--- 1569,1575 ----
+      }
+      ;
+  
+!     public void executeSQL() {
+  
+          String[] g   = new String[1];
+          String   sql = null;
+*************** implements ActionListener, WindowListene
+*** 1647,1653 ****
+       * results only if gridFormat is off (seems like it  does
+       * nothing otherwise, except for clearing help text and moving focus).
+       */
+!     private void updateResult() {
+  
+          if (gridFormat) {
+  
+--- 1647,1653 ----
+       * results only if gridFormat is off (seems like it  does
+       * nothing otherwise, except for clearing help text and moving focus).
+       */
+!     public void updateResult() {
+  
+          if (gridFormat) {
+  
+*************** implements ActionListener, WindowListene
+*** 1675,1681 ****
+       * VARCHARs, because this is the only class where there is any
+       * ambiguity about whether there is a null stored or not.
+       */
+!     private void formatResultSet(ResultSet r) {
+  
+          if (r == null) {
+              String[] g = new String[1];
+--- 1675,1681 ----
+       * VARCHARs, because this is the only class where there is any
+       * ambiguity about whether there is a null stored or not.
+       */
+!     public void formatResultSet(ResultSet r) {
+  
+          if (r == null) {
+              String[] g = new String[1];
+*************** implements ActionListener, WindowListene
+*** 1728,1734 ****
+          }
+      }
+  
+!     private void testPerformance() {
+  
+          String       all   = txtCommand.getText();
+          StringBuffer b     = new StringBuffer();
+--- 1728,1734 ----
+          }
+      }
+  
+!     public void testPerformance() {
+  
+          String       all   = txtCommand.getText();
+          StringBuffer b     = new StringBuffer();
+*************** implements ActionListener, WindowListene
+*** 1812,1818 ****
+       * Method declaration
+       *
+       */
+!     private void showResultInText() {
+  
+          Object[] col   = gResult.getHead();
+          int      width = col.length;
+--- 1812,1818 ----
+       * Method declaration
+       *
+       */
+!     public void showResultInText() {
+  
+          Object[] col   = gResult.getHead();
+          int      width = col.length;
+*************** implements ActionListener, WindowListene
+*** 1887,1893 ****
+          txtResult.setText(b.toString());
+      }
+  
+!     private void addToRecent(String s) {
+  
+          for (int i = 0; i < iMaxRecent; i++) {
+              if (s.equals(sRecent[i])) {
+--- 1887,1893 ----
+          txtResult.setText(b.toString());
+      }
+  
+!     public void addToRecent(String s) {
+  
+          for (int i = 0; i < iMaxRecent; i++) {
+              if (s.equals(sRecent[i])) {
+*************** implements ActionListener, WindowListene
+*** 1914,1920 ****
+          iRecent = (iRecent + 1) % iMaxRecent;
+      }
+  
+!     private void initGUI() {
+  
+          JPanel pCommand = new JPanel();
+  
+--- 1914,1920 ----
+          iRecent = (iRecent + 1) % iMaxRecent;
+      }
+  
+!     public void initGUI() {
+  
+          JPanel pCommand = new JPanel();
+  
+*************** implements ActionListener, WindowListene
+*** 2006,2012 ****
+  
+      /* Simple tree node factory method - set's parent and user object.
+       */
+!     private DefaultMutableTreeNode makeNode(Object userObject,
+              MutableTreeNode parent) {
+  
+          DefaultMutableTreeNode node = new DefaultMutableTreeNode(userObject);
+--- 2006,2012 ----
+  
+      /* Simple tree node factory method - set's parent and user object.
+       */
+!     public DefaultMutableTreeNode makeNode(Object userObject,
+              MutableTreeNode parent) {
+  
+          DefaultMutableTreeNode node = new DefaultMutableTreeNode(userObject);
+*************** implements ActionListener, WindowListene
+*** 2018,2031 ****
+          return node;
+      }
+  
+!     private static final String[] usertables       = {
+          "TABLE", "GLOBAL TEMPORARY", "VIEW", "SYSTEM TABLE"
+      };
+!     private static final String[] nonSystables     = {
+          "TABLE", "GLOBAL TEMPORARY", "VIEW"
+      };
+!     private static final HashSet  oracleSysUsers   = new HashSet();
+!     private static final String[] oracleSysSchemas = {
+          "SYS", "SYSTEM", "OUTLN", "DBSNMP", "OUTLN", "MDSYS", "ORDSYS",
+          "ORDPLUGINS", "CTXSYS", "DSSYS", "PERFSTAT", "WKPROXY", "WKSYS",
+          "WMSYS", "XDB", "ANONYMOUS", "ODM", "ODM_MTR", "OLAPSYS", "TRACESVR",
+--- 2018,2031 ----
+          return node;
+      }
+  
+!     public static final String[] usertables       = {
+          "TABLE", "GLOBAL TEMPORARY", "VIEW", "SYSTEM TABLE"
+      };
+!     public static final String[] nonSystables     = {
+          "TABLE", "GLOBAL TEMPORARY", "VIEW"
+      };
+!     public static final HashSet  oracleSysUsers   = new HashSet();
+!     public static final String[] oracleSysSchemas = {
+          "SYS", "SYSTEM", "OUTLN", "DBSNMP", "OUTLN", "MDSYS", "ORDSYS",
+          "ORDPLUGINS", "CTXSYS", "DSSYS", "PERFSTAT", "WKPROXY", "WKSYS",
+          "WMSYS", "XDB", "ANONYMOUS", "ODM", "ODM_MTR", "OLAPSYS", "TRACESVR",
+*************** implements ActionListener, WindowListene
+*** 2041,2047 ****
+      /**
+       * Schedules to run in a Gui-safe thread
+       */
+!     protected void refreshTree() {
+          backgroundIt(treeRefreshRunnable, "Refreshing object tree");
+      }
+  
+--- 2041,2047 ----
+      /**
+       * Schedules to run in a Gui-safe thread
+       */
+!     public void refreshTree() {
+          backgroundIt(treeRefreshRunnable, "Refreshing object tree");
+      }
+  
+*************** implements ActionListener, WindowListene
+*** 2050,2056 ****
+       *
+       * This method executes in current thread
+       */
+!     protected void directRefreshTree() {
+  
+          int[]                  rowCounts;
+          DefaultMutableTreeNode propertiesNode;
+--- 2050,2056 ----
+       *
+       * This method executes in current thread
+       */
+!     public void directRefreshTree() {
+  
+          int[]                  rowCounts;
+          DefaultMutableTreeNode propertiesNode;
+*************** implements ActionListener, WindowListene
+*** 2296,2302 ****
+      }
+  
+      // Added: (weconsultants@users) Needed to aggragate counts per table in jTree
+!     protected int[] getRowCounts(Vector inTable,
+                                   Vector inSchema) throws Exception {
+  
+          if (!displayRowCounts) {
+--- 2296,2302 ----
+      }
+  
+      // Added: (weconsultants@users) Needed to aggragate counts per table in jTree
+!     public int[] getRowCounts(Vector inTable,
+                                   Vector inSchema) throws Exception {
+  
+          if (!displayRowCounts) {
+*************** implements ActionListener, WindowListene
+*** 2340,2346 ****
+          return (counts);
+      }
+  
+!     protected JToolBar createToolBar() {
+  
+          // Build jtoolbar and jtoolbar Buttons
+          JToolBar jtoolbar = new JToolBar();
+--- 2340,2346 ----
+          return (counts);
+      }
+  
+!     public JToolBar createToolBar() {
+  
+          // Build jtoolbar and jtoolbar Buttons
+          JToolBar jtoolbar = new JToolBar();
+*************** implements ActionListener, WindowListene
+*** 2405,2411 ****
+          }
+      }
+  
+!     private void setLF(String newLAF) {
+  
+          if (currentLAF != null && currentLAF == newLAF) {    // No change
+              return;
+--- 2405,2411 ----
+          }
+      }
+  
+!     public void setLF(String newLAF) {
+  
+          if (currentLAF != null && currentLAF == newLAF) {    // No change
+              return;
+*************** implements ActionListener, WindowListene
+*** 2446,2452 ****
+          }
+      }
+  
+!     private void updateSchemaList() {
+  
+          ButtonGroup group  = new ButtonGroup();
+          ArrayList   list   = new ArrayList();
+--- 2446,2452 ----
+          }
+      }
+  
+!     public void updateSchemaList() {
+  
+          ButtonGroup group  = new ButtonGroup();
+          ArrayList   list   = new ArrayList();
+*************** implements ActionListener, WindowListene
+*** 2698,2703 ****
+          }
+      }
+  
+!     private static final String tString = Boolean.TRUE.toString();
+!     private static final String fString = Boolean.FALSE.toString();
+  }
+--- 2698,2703 ----
+          }
+      }
+  
+!     public static final String tString = Boolean.TRUE.toString();
+!     public static final String fString = Boolean.FALSE.toString();
+  }
+diff -pcr misc/hsqldb/src/org/hsqldb/util/FontDialogSwing.java misc/build/hsqldb/src/org/hsqldb/util/FontDialogSwing.java
+*** misc/hsqldb/src/org/hsqldb/util/FontDialogSwing.java	2005-10-23 20:26:31.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/util/FontDialogSwing.java	2007-02-28 12:32:49.000000000 +0100
+*************** import javax.swing.JFrame;
+*** 56,84 ****
+  //        for JComboBox fontSizesComboBox and String fontSizes[];
+  public class FontDialogSwing extends JDialog {
+  
+!     private static boolean      isRunning   = false;
+!     private static final String BACKGROUND  = "Background";
+!     private static String       defaultFont = "Dialog";
+!     private static final String FOREGROUND  = "Foreground";
+!     private static JButton      bgColorButton;
+!     private static JCheckBox    ckbbold;
+!     private static JButton      closeButton;
+!     private static JButton      fgColorButton;
+!     private static JComboBox    fontsComboBox;
+  
+      //  weconsultants@users 20050215 - Added for Compatbilty fix for JDK 1.3
+!     private static JComboBox      fontSizesComboBox;
+!     private static final String[] fontSizes = {
+          "8", "9", "10", "11", "12", "13", "14", "16", "18", "24", "36"
+      };
+  
+      // weconsultants@users 20050215 - Commented out for Compatbilty fix for JDK 1.3
+!     //  private static JSpinner           spinnerFontSizes;
+!     //  private static SpinnerNumberModel spinnerModelSizes;
+!     private static DatabaseManagerSwing fOwner;
+!     private static JFrame frame =
+          new JFrame("DataBaseManagerSwing Font Selection Dialog");
+!     private static JCheckBox ckbitalic;
+  
+      /**
+       * Create and display FontDialogSwing Dialog.
+--- 56,84 ----
+  //        for JComboBox fontSizesComboBox and String fontSizes[];
+  public class FontDialogSwing extends JDialog {
+  
+!     public static boolean      isRunning   = false;
+!     public static final String BACKGROUND  = "Background";
+!     public static String       defaultFont = "Dialog";
+!     public static final String FOREGROUND  = "Foreground";
+!     public static JButton      bgColorButton;
+!     public static JCheckBox    ckbbold;
+!     public static JButton      closeButton;
+!     public static JButton      fgColorButton;
+!     public static JComboBox    fontsComboBox;
+  
+      //  weconsultants@users 20050215 - Added for Compatbilty fix for JDK 1.3
+!     public static JComboBox      fontSizesComboBox;
+!     public static final String[] fontSizes = {
+          "8", "9", "10", "11", "12", "13", "14", "16", "18", "24", "36"
+      };
+  
+      // weconsultants@users 20050215 - Commented out for Compatbilty fix for JDK 1.3
+!     //  public static JSpinner           spinnerFontSizes;
+!     //  public static SpinnerNumberModel spinnerModelSizes;
+!     public static DatabaseManagerSwing fOwner;
+!     public static JFrame frame =
+          new JFrame("DataBaseManagerSwing Font Selection Dialog");
+!     public static JCheckBox ckbitalic;
+  
+      /**
+       * Create and display FontDialogSwing Dialog.
+diff -pcr misc/hsqldb/src/org/hsqldb/util/Grid.java misc/build/hsqldb/src/org/hsqldb/util/Grid.java
+*** misc/hsqldb/src/org/hsqldb/util/Grid.java	2005-10-23 20:26:31.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/util/Grid.java	2007-02-28 12:32:49.000000000 +0100
+*************** import java.awt.SystemColor;
+*** 90,129 ****
+  class Grid extends Panel {
+  
+      // drawing
+!     private Dimension dMinimum;
+  
+  // boucherb@users changed access for databasemanager2
+!     protected Font fFont;
+  
+  // --------------------------------------------------
+!     private FontMetrics fMetrics;
+!     private Graphics    gImage;
+!     private Image       iImage;
+  
+      // height / width
+!     private int iWidth, iHeight;
+!     private int iRowHeight, iFirstRow;
+!     private int iGridWidth, iGridHeight;
+!     private int iX, iY;
+  
+      // data
+  // boucherb@users changed access for databasemanager2
+!     protected String[] sColHead = new String[0];
+!     protected Vector   vData    = new Vector();
+  
+  // --------------------------------------------------
+!     private int[] iColWidth;
+!     private int   iColCount;
+  
+  // boucherb@users changed access for databasemanager2
+!     protected int iRowCount;
+  
+  // --------------------------------------------------
+      // scrolling
+!     private Scrollbar sbHoriz, sbVert;
+!     private int       iSbWidth, iSbHeight;
+!     private boolean   bDrag;
+!     private int       iXDrag, iColDrag;
+  
+      /**
+       * Constructor declaration
+--- 90,129 ----
+  class Grid extends Panel {
+  
+      // drawing
+!     public Dimension dMinimum;
+  
+  // boucherb@users changed access for databasemanager2
+!     public Font fFont;
+  
+  // --------------------------------------------------
+!     public FontMetrics fMetrics;
+!     public Graphics    gImage;
+!     public Image       iImage;
+  
+      // height / width
+!     public int iWidth, iHeight;
+!     public int iRowHeight, iFirstRow;
+!     public int iGridWidth, iGridHeight;
+!     public int iX, iY;
+  
+      // data
+  // boucherb@users changed access for databasemanager2
+!     public String[] sColHead = new String[0];
+!     public Vector   vData    = new Vector();
+  
+  // --------------------------------------------------
+!     public int[] iColWidth;
+!     public int   iColCount;
+  
+  // boucherb@users changed access for databasemanager2
+!     public int iRowCount;
+  
+  // --------------------------------------------------
+      // scrolling
+!     public Scrollbar sbHoriz, sbVert;
+!     public int       iSbWidth, iSbHeight;
+!     public boolean   bDrag;
+!     public int       iXDrag, iColDrag;
+  
+      /**
+       * Constructor declaration
+*************** class Grid extends Panel {
+*** 587,593 ****
+       *
+       * @param i
+       */
+!     private void calcAutoWidth(int i) {
+  
+          int w = 10;
+  
+--- 587,593 ----
+       *
+       * @param i
+       */
+!     public void calcAutoWidth(int i) {
+  
+          int w = 10;
+  
+*************** class Grid extends Panel {
+*** 611,617 ****
+       *
+       * @return
+       */
+!     private String getDisplay(int x, int y) {
+          return (((String[]) (vData.elementAt(y)))[x]);
+      }
+  
+--- 611,617 ----
+       *
+       * @return
+       */
+!     public String getDisplay(int x, int y) {
+          return (((String[]) (vData.elementAt(y)))[x]);
+      }
+  
+*************** class Grid extends Panel {
+*** 624,630 ****
+       *
+       * @return
+       */
+!     private String get(int x, int y) {
+          return (((String[]) (vData.elementAt(y)))[x]);
+      }
+  
+--- 624,630 ----
+       *
+       * @return
+       */
+!     public String get(int x, int y) {
+          return (((String[]) (vData.elementAt(y)))[x]);
+      }
+  
+*************** class Grid extends Panel {
+*** 636,642 ****
+       *
+       * @return
+       */
+!     private static int getMaxHeight(FontMetrics f) {
+          return f.getHeight() + 4;
+      }
+  }
+--- 636,642 ----
+       *
+       * @return
+       */
+!     public static int getMaxHeight(FontMetrics f) {
+          return f.getHeight() + 4;
+      }
+  }
+diff -pcr misc/hsqldb/src/org/hsqldb/util/JDBCTypes.java misc/build/hsqldb/src/org/hsqldb/util/JDBCTypes.java
+*** misc/hsqldb/src/org/hsqldb/util/JDBCTypes.java	2005-10-23 20:26:31.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/util/JDBCTypes.java	2007-02-28 12:32:49.000000000 +0100
+*************** class JDBCTypes {
+*** 48,55 ****
+      public static final int BLOB        = 2004;
+      public static final int CLOB        = 2005;
+      public static final int REF         = 2006;
+!     private Hashtable       hStringJDBCtypes;
+!     private Hashtable       hIntJDBCtypes;
+  
+      JDBCTypes() {
+  
+--- 48,55 ----
+      public static final int BLOB        = 2004;
+      public static final int CLOB        = 2005;
+      public static final int REF         = 2006;
+!     public Hashtable       hStringJDBCtypes;
+!     public Hashtable       hIntJDBCtypes;
+  
+      JDBCTypes() {
+  
+diff -pcr misc/hsqldb/src/org/hsqldb/util/MainInvoker.java misc/build/hsqldb/src/org/hsqldb/util/MainInvoker.java
+*** misc/hsqldb/src/org/hsqldb/util/MainInvoker.java	2005-10-23 21:25:14.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/util/MainInvoker.java	2007-02-28 12:32:49.000000000 +0100
+*************** public class MainInvoker {
+*** 51,59 ****
+       * It may or may not make sense to make this into a class with real
+       * instances that can keep track of status of stuff invoked by it.
+       */
+!     private static String[] emptyStringArray = new String[0];
+  
+!     private static void syntaxFailure() {
+          System.err.println(SYNTAX_MSG);
+          System.exit(2);
+      }
+--- 51,59 ----
+       * It may or may not make sense to make this into a class with real
+       * instances that can keep track of status of stuff invoked by it.
+       */
+!     public static String[] emptyStringArray = new String[0];
+  
+!     public static void syntaxFailure() {
+          System.err.println(SYNTAX_MSG);
+          System.exit(2);
+      }
+*************** public class MainInvoker {
+*** 108,114 ****
+          }
+      }
+  
+!     private static final String SYNTAX_MSG =
+          "    java org.hsqldb.util.MainInvoker "
+          + "[package1.Class1 [arg1a arg1b...] \"\"]... \\\n"
+          + "    packageX.ClassX [argXa argXb...]\nOR\n"
+--- 108,114 ----
+          }
+      }
+  
+!     public static final String SYNTAX_MSG =
+          "    java org.hsqldb.util.MainInvoker "
+          + "[package1.Class1 [arg1a arg1b...] \"\"]... \\\n"
+          + "    packageX.ClassX [argXa argXb...]\nOR\n"
+diff -pcr misc/hsqldb/src/org/hsqldb/util/OracleTransferHelper.java misc/build/hsqldb/src/org/hsqldb/util/OracleTransferHelper.java
+*** misc/hsqldb/src/org/hsqldb/util/OracleTransferHelper.java	2005-10-23 20:26:31.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/util/OracleTransferHelper.java	2007-02-28 12:32:49.000000000 +0100
+*************** import java.sql.SQLException;
+*** 46,53 ****
+   */
+  class OracleTransferHelper extends TransferHelper {
+  
+!     private final int ORACLE = 0;
+!     private final int HSQLDB = 1;
+      String[][]        Funcs  = {
+          {
+              "now()", "\'now\'"
+--- 46,53 ----
+   */
+  class OracleTransferHelper extends TransferHelper {
+  
+!     public final int ORACLE = 0;
+!     public final int HSQLDB = 1;
+      String[][]        Funcs  = {
+          {
+              "now()", "\'now\'"
+diff -pcr misc/hsqldb/src/org/hsqldb/util/PostgresTransferHelper.java misc/build/hsqldb/src/org/hsqldb/util/PostgresTransferHelper.java
+*** misc/hsqldb/src/org/hsqldb/util/PostgresTransferHelper.java	2005-10-23 20:26:31.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/util/PostgresTransferHelper.java	2007-02-28 12:32:49.000000000 +0100
+*************** import java.sql.Types;
+*** 47,54 ****
+   */
+  class PostgresTransferHelper extends TransferHelper {
+  
+!     private final int PostgreSQL = 0;
+!     private final int HSQLDB     = 1;
+      String[][]        Funcs      = {
+          {
+              "now()", "\'now\'"
+--- 47,54 ----
+   */
+  class PostgresTransferHelper extends TransferHelper {
+  
+!     public final int PostgreSQL = 0;
+!     public final int HSQLDB     = 1;
+      String[][]        Funcs      = {
+          {
+              "now()", "\'now\'"
+diff -pcr misc/hsqldb/src/org/hsqldb/util/QueryTool.java misc/build/hsqldb/src/org/hsqldb/util/QueryTool.java
+*** misc/hsqldb/src/org/hsqldb/util/QueryTool.java	2006-04-11 17:03:32.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/util/QueryTool.java	2007-02-28 12:32:49.000000000 +0100
+*************** implements WindowListener, ActionListene
+*** 419,425 ****
+      /**
+       * Adds a String to the Listbox of recent commands.
+       */
+!     private void setRecent(String s) {
+  
+          for (int i = 0; i < iMaxRecent; i++) {
+              if (s.equals(sRecent[i])) {
+--- 419,425 ----
+      /**
+       * Adds a String to the Listbox of recent commands.
+       */
+!     public void setRecent(String s) {
+  
+          for (int i = 0; i < iMaxRecent; i++) {
+              if (s.equals(sRecent[i])) {
+*************** implements WindowListener, ActionListene
+*** 449,455 ****
+      /**
+       * Create the graphical user interface. This is AWT code.
+       */
+!     private void initGUI() {
+  
+          // all panels
+          Panel pQuery       = new Panel();
+--- 449,455 ----
+      /**
+       * Create the graphical user interface. This is AWT code.
+       */
+!     public void initGUI() {
+  
+          // all panels
+          Panel pQuery       = new Panel();
+diff -pcr misc/hsqldb/src/org/hsqldb/util/ScriptTool.java misc/build/hsqldb/src/org/hsqldb/util/ScriptTool.java
+*** misc/hsqldb/src/org/hsqldb/util/ScriptTool.java	2005-10-23 20:26:32.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/util/ScriptTool.java	2007-02-28 12:32:49.000000000 +0100
+*************** import org.hsqldb.lib.java.JavaSystem;
+*** 54,66 ****
+   */
+  public class ScriptTool {
+  
+!     private static Properties pProperties = new Properties();
+!     private Connection        cConn;
+!     private Statement         sStatement;
+!     private boolean           BATCH = true;
+!     private String            EKW   = new String("go");
+!     private boolean           EOF   = false;
+!     private int               ln    = 0;
+  
+      /**
+       * Main method
+--- 54,66 ----
+   */
+  public class ScriptTool {
+  
+!     public static Properties pProperties = new Properties();
+!     public Connection        cConn;
+!     public Statement         sStatement;
+!     public boolean           BATCH = true;
+!     public String            EKW   = new String("go");
+!     public boolean           EOF   = false;
+!     public int               ln    = 0;
+  
+      /**
+       * Main method
+*************** public class ScriptTool {
+*** 180,186 ****
+       * Translate ResultSet to String representation
+       * @param r
+       */
+!     private String toString(ResultSet r) {
+  
+          try {
+              if (r == null) {
+--- 180,186 ----
+       * Translate ResultSet to String representation
+       * @param r
+       */
+!     public String toString(ResultSet r) {
+  
+          try {
+              if (r == null) {
+*************** public class ScriptTool {
+*** 218,224 ****
+      /**
+       * Read file and convert it to string.
+       */
+!     private String fileToString(BufferedReader in) {
+  
+          if (EOF) {
+              return null;
+--- 218,224 ----
+      /**
+       * Read file and convert it to string.
+       */
+!     public String fileToString(BufferedReader in) {
+  
+          if (EOF) {
+              return null;
+*************** public class ScriptTool {
+*** 268,274 ****
+       *
+       * @param s
+       */
+!     private void trace(String s) {
+          System.out.println(s);
+      }
+  
+--- 268,274 ----
+       *
+       * @param s
+       */
+!     public void trace(String s) {
+          System.out.println(s);
+      }
+  
+*************** public class ScriptTool {
+*** 276,282 ****
+       * Method declaration
+       *
+       */
+!     private static void printHelp() {
+  
+          System.out.println(
+              "Usage: java ScriptTool [-options]\n"
+--- 276,282 ----
+       * Method declaration
+       *
+       */
+!     public static void printHelp() {
+  
+          System.out.println(
+              "Usage: java ScriptTool [-options]\n"
+diff -pcr misc/hsqldb/src/org/hsqldb/util/SqlFile.java misc/build/hsqldb/src/org/hsqldb/util/SqlFile.java
+*** misc/hsqldb/src/org/hsqldb/util/SqlFile.java	2006-07-27 22:04:31.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/util/SqlFile.java	2007-02-28 12:32:49.000000000 +0100
+*************** import java.util.TreeMap;
+*** 110,135 ****
+   */
+  public class SqlFile {
+  
+!     private static final int DEFAULT_HISTORY_SIZE = 20;
+!     private File             file;
+!     private boolean          interactive;
+!     private String           primaryPrompt    = "sql> ";
+!     private String           chunkPrompt      = "raw> ";
+!     private String           contPrompt       = "  +> ";
+!     private Connection       curConn          = null;
+!     private boolean          htmlMode         = false;
+!     private HashMap          userVars         = null;
+!     private String[]         statementHistory = null;
+!     private boolean          chunking         = false;
+!     private String           csvNullRep       = null;
+  
+      /**
+       * Private class to "share" a variable among a family of SqlFile
+       * instances.
+       */
+!     private static class BooleanBucket {
+  
+!         private boolean bPriv = false;
+  
+          public void set(boolean bIn) {
+              bPriv = bIn;
+--- 110,135 ----
+   */
+  public class SqlFile {
+  
+!     public static final int DEFAULT_HISTORY_SIZE = 20;
+!     public File             file;
+!     public boolean          interactive;
+!     public String           primaryPrompt    = "sql> ";
+!     public String           chunkPrompt      = "raw> ";
+!     public String           contPrompt       = "  +> ";
+!     public Connection       curConn          = null;
+!     public boolean          htmlMode         = false;
+!     public HashMap          userVars         = null;
+!     public String[]         statementHistory = null;
+!     public boolean          chunking         = false;
+!     public String           csvNullRep       = null;
+  
+      /**
+       * Private class to "share" a variable among a family of SqlFile
+       * instances.
+       */
+!     public static class BooleanBucket {
+  
+!         public boolean bPriv = false;
+  
+          public void set(boolean bIn) {
+              bPriv = bIn;
+*************** public class SqlFile {
+*** 146,166 ****
+      BooleanBucket possiblyUncommitteds = new BooleanBucket();
+  
+      // Ascii field separator blanks
+!     private static final int SEP_LEN = 2;
+!     private static final String DIVIDER =
+          "-----------------------------------------------------------------"
+          + "-----------------------------------------------------------------";
+!     private static final String SPACES =
+          "                                                                 "
+          + "                                                                 ";
+!     private static String revnum = null;
+  
+      static {
+          revnum = "$Revision: 1.135 $".substring("$Revision: ".length(),
+                  "$Revision: 1.135 $".length() - 2);
+      }
+  
+!     private static String BANNER =
+          "(SqlFile processor v. " + revnum + ")\n"
+          + "Distribution is permitted under the terms of the HSQLDB license.\n"
+          + "(c) 2004-2005 Blaine Simpson and the HSQLDB Development Group.\n\n"
+--- 146,166 ----
+      BooleanBucket possiblyUncommitteds = new BooleanBucket();
+  
+      // Ascii field separator blanks
+!     public static final int SEP_LEN = 2;
+!     public static final String DIVIDER =
+          "-----------------------------------------------------------------"
+          + "-----------------------------------------------------------------";
+!     public static final String SPACES =
+          "                                                                 "
+          + "                                                                 ";
+!     public static String revnum = null;
+  
+      static {
+          revnum = "$Revision: 1.135 $".substring("$Revision: ".length(),
+                  "$Revision: 1.135 $".length() - 2);
+      }
+  
+!     public static String BANNER =
+          "(SqlFile processor v. " + revnum + ")\n"
+          + "Distribution is permitted under the terms of the HSQLDB license.\n"
+          + "(c) 2004-2005 Blaine Simpson and the HSQLDB Development Group.\n\n"
+*************** public class SqlFile {
+*** 176,182 ****
+          + "  statement into the buffer without executing) or a line ending with ';'\n"
+          + "  (which executes the statement).\n"
+          + "  SQL Statements may begin with '/PLVARNAME' and/or contain *{PLVARNAME}s.\n";
+!     private static final String BUFFER_HELP_TEXT =
+          "BUFFER Commands (only \":;\" is available for non-interactive use).\n"
+          + "    :?                Help\n"
+          + "    :;                Execute current buffer as an SQL Statement\n"
+--- 176,182 ----
+          + "  statement into the buffer without executing) or a line ending with ';'\n"
+          + "  (which executes the statement).\n"
+          + "  SQL Statements may begin with '/PLVARNAME' and/or contain *{PLVARNAME}s.\n";
+!     public static final String BUFFER_HELP_TEXT =
+          "BUFFER Commands (only \":;\" is available for non-interactive use).\n"
+          + "    :?                Help\n"
+          + "    :;                Execute current buffer as an SQL Statement\n"
+*************** public class SqlFile {
+*** 198,204 ****
+          + "                       2:  Narrows substitution to specified buffer line number\n"
+          + "                           (Use any line number in place of '2').\n"
+      ;
+!     private static final String HELP_TEXT = "SPECIAL Commands.\n"
+          + "* commands only available for interactive use.\n"
+          + "In place of \"3\" below, you can use nothing for the previous command, or\n"
+          + "an integer \"X\" to indicate the Xth previous command.\n"
+--- 198,204 ----
+          + "                       2:  Narrows substitution to specified buffer line number\n"
+          + "                           (Use any line number in place of '2').\n"
+      ;
+!     public static final String HELP_TEXT = "SPECIAL Commands.\n"
+          + "* commands only available for interactive use.\n"
+          + "In place of \"3\" below, you can use nothing for the previous command, or\n"
+          + "an integer \"X\" to indicate the Xth previous command.\n"
+*************** public class SqlFile {
+*** 226,232 ****
+          + "    \\m file/path.csv     iMport CSV text file records into a table\n"
+          + "    \\q [abort message]   Quit (or end input like Ctrl-Z or Ctrl-D)\n"
+      ;
+!     private static final String PL_HELP_TEXT = "PROCEDURAL LANGUAGE Commands.\n"
+          + "    *?                            Help\n"
+          + "    *                             Expand PL variables from now on.\n"
+          + "                                  (this is also implied by all the following).\n"
+--- 226,232 ----
+          + "    \\m file/path.csv     iMport CSV text file records into a table\n"
+          + "    \\q [abort message]   Quit (or end input like Ctrl-Z or Ctrl-D)\n"
+      ;
+!     public static final String PL_HELP_TEXT = "PROCEDURAL LANGUAGE Commands.\n"
+          + "    *?                            Help\n"
+          + "    *                             Expand PL variables from now on.\n"
+          + "                                  (this is also implied by all the following).\n"
+*************** public class SqlFile {
+*** 328,349 ****
+  
+      // So we can tell how to handle quit and break commands.
+      public boolean      recursed     = false;
+!     private String      curCommand   = null;
+!     private int         curLinenum   = -1;
+!     private int         curHist      = -1;
+!     private PrintStream psStd        = null;
+!     private PrintStream psErr        = null;
+!     private PrintWriter pwQuery      = null;
+!     private PrintWriter pwCsv        = null;
+      StringBuffer        stringBuffer = new StringBuffer();
+      /*
+       * This is reset upon each execute() invocation (to true if interactive,
+       * false otherwise).
+       */
+!     private boolean             continueOnError = false;
+!     private static final String DEFAULT_CHARSET = "US-ASCII";
+!     private BufferedReader      br              = null;
+!     private String              charset         = null;
+  
+      /**
+       * Process all the commands in the file (or stdin) associated with
+--- 328,349 ----
+  
+      // So we can tell how to handle quit and break commands.
+      public boolean      recursed     = false;
+!     public String      curCommand   = null;
+!     public int         curLinenum   = -1;
+!     public int         curHist      = -1;
+!     public PrintStream psStd        = null;
+!     public PrintStream psErr        = null;
+!     public PrintWriter pwQuery      = null;
+!     public PrintWriter pwCsv        = null;
+      StringBuffer        stringBuffer = new StringBuffer();
+      /*
+       * This is reset upon each execute() invocation (to true if interactive,
+       * false otherwise).
+       */
+!     public boolean             continueOnError = false;
+!     public static final String DEFAULT_CHARSET = "US-ASCII";
+!     public BufferedReader      br              = null;
+!     public String              charset         = null;
+  
+      /**
+       * Process all the commands in the file (or stdin) associated with
+*************** public class SqlFile {
+*** 736,742 ****
+       * @param inString Base String, which will not be modified (because
+       *                 a "copy" will be returned).
+       */
+!     private static String deTerminated(String inString) {
+  
+          int index = inString.lastIndexOf(';');
+  
+--- 736,742 ----
+       * @param inString Base String, which will not be modified (because
+       *                 a "copy" will be returned).
+       */
+!     public static String deTerminated(String inString) {
+  
+          int index = inString.lastIndexOf(';');
+  
+*************** public class SqlFile {
+*** 756,768 ****
+      /**
+       * Utility nested Exception class for internal use.
+       */
+!     private class BadSpecial extends Exception {
+  
+          // Special-purpose constructor
+!         private BadSpecial() {}
+  
+          // Normal use constructor
+!         private BadSpecial(String s) {
+              super(s);
+          }
+      }
+--- 756,768 ----
+      /**
+       * Utility nested Exception class for internal use.
+       */
+!     public class BadSpecial extends Exception {
+  
+          // Special-purpose constructor
+!         public BadSpecial() {}
+  
+          // Normal use constructor
+!         public BadSpecial(String s) {
+              super(s);
+          }
+      }
+*************** public class SqlFile {
+*** 775,781 ****
+       * thrown.
+       * SqlTool.execute() on throws a QuitNow if it is in a recursive call.
+       */
+!     private class QuitNow extends SqlToolError {
+  
+          public QuitNow(String s) {
+              super(s);
+--- 775,781 ----
+       * thrown.
+       * SqlTool.execute() on throws a QuitNow if it is in a recursive call.
+       */
+!     public class QuitNow extends SqlToolError {
+  
+          public QuitNow(String s) {
+              super(s);
+*************** public class SqlFile {
+*** 790,796 ****
+       * Utility nested Exception class for internal use.
+       * Very similar to QuitNow.
+       */
+!     private class BreakException extends SqlToolError {
+  
+          public BreakException() {
+              super();
+--- 790,796 ----
+       * Utility nested Exception class for internal use.
+       * Very similar to QuitNow.
+       */
+!     public class BreakException extends SqlToolError {
+  
+          public BreakException() {
+              super();
+*************** public class SqlFile {
+*** 805,811 ****
+       * Utility nested Exception class for internal use.
+       * Very similar to QuitNow.
+       */
+!     private class ContinueException extends SqlToolError {
+  
+          public ContinueException() {
+              super();
+--- 805,811 ----
+       * Utility nested Exception class for internal use.
+       * Very similar to QuitNow.
+       */
+!     public class ContinueException extends SqlToolError {
+  
+          public ContinueException() {
+              super();
+*************** public class SqlFile {
+*** 819,827 ****
+      /**
+       * Utility nested Exception class for internal use.
+       */
+!     private class BadSwitch extends Exception {
+  
+!         private BadSwitch(int i) {
+              super(Integer.toString(i));
+          }
+      }
+--- 819,827 ----
+      /**
+       * Utility nested Exception class for internal use.
+       */
+!     public class BadSwitch extends Exception {
+  
+!         public BadSwitch(int i) {
+              super(Integer.toString(i));
+          }
+      }
+*************** public class SqlFile {
+*** 836,842 ****
+       * @throws SQLException Passed through from processSQL()
+       * @throws BadSpecial Runtime error()
+       */
+!     private void processBuffer(String inString)
+      throws BadSpecial, SQLException {
+  
+          int    index = 0;
+--- 836,842 ----
+       * @throws SQLException Passed through from processSQL()
+       * @throws BadSpecial Runtime error()
+       */
+!     public void processBuffer(String inString)
+      throws BadSpecial, SQLException {
+  
+          int    index = 0;
+*************** public class SqlFile {
+*** 1065,1075 ****
+          throw new BadSpecial("Unknown Buffer Command");
+      }
+  
+!     private boolean doPrepare   = false;
+!     private String  prepareVar  = null;
+!     private String  csvColDelim = null;
+!     private String  csvRowDelim = null;
+!     private static final String CSV_SYNTAX_MSG =
+          "Export syntax:  x table_or_view_anme "
+          + "[column_delimiter [record_delimiter]]";
+  
+--- 1065,1075 ----
+          throw new BadSpecial("Unknown Buffer Command");
+      }
+  
+!     public boolean doPrepare   = false;
+!     public String  prepareVar  = null;
+!     public String  csvColDelim = null;
+!     public String  csvRowDelim = null;
+!     public static final String CSV_SYNTAX_MSG =
+          "Export syntax:  x table_or_view_anme "
+          + "[column_delimiter [record_delimiter]]";
+  
+*************** public class SqlFile {
+*** 1081,1087 ****
+       * @throws BadSpecial Runtime error()
+       * @throws QuitNot Command execution (but not the JVM!) should stop
+       */
+!     private void processSpecial(String inString)
+      throws BadSpecial, QuitNow, SQLException, SqlToolError {
+  
+          int    index = 0;
+--- 1081,1087 ----
+       * @throws BadSpecial Runtime error()
+       * @throws QuitNot Command execution (but not the JVM!) should stop
+       */
+!     public void processSpecial(String inString)
+      throws BadSpecial, QuitNow, SQLException, SqlToolError {
+  
+          int    index = 0;
+*************** public class SqlFile {
+*** 1526,1532 ****
+          throw new BadSpecial("Unknown Special Command");
+      }
+  
+!     private static final char[] nonVarChars = {
+          ' ', '\t', '=', '}', '\n', '\r'
+      };
+  
+--- 1526,1532 ----
+          throw new BadSpecial("Unknown Special Command");
+      }
+  
+!     public static final char[] nonVarChars = {
+          ' ', '\t', '=', '}', '\n', '\r'
+      };
+  
+*************** public class SqlFile {
+*** 1560,1566 ****
+       * @throws SQLException  This is really an inappropriate exception
+       * type.  Only using it because I don't have time to do things properly.
+       */
+!     private String dereference(String inString,
+                                 boolean permitAlias) throws SQLException {
+  
+          String       varName, varValue;
+--- 1560,1566 ----
+       * @throws SQLException  This is really an inappropriate exception
+       * type.  Only using it because I don't have time to do things properly.
+       */
+!     public String dereference(String inString,
+                                 boolean permitAlias) throws SQLException {
+  
+          String       varName, varValue;
+*************** public class SqlFile {
+*** 1627,1635 ****
+      public boolean plMode = false;
+  
+      //  PL variable name currently awaiting query output.
+!     private String  fetchingVar = null;
+!     private boolean silentFetch = false;
+!     private boolean fetchBinary = false;
+  
+      /**
+       * Process a Process Language Command.
+--- 1627,1635 ----
+      public boolean plMode = false;
+  
+      //  PL variable name currently awaiting query output.
+!     public String  fetchingVar = null;
+!     public boolean silentFetch = false;
+!     public boolean fetchBinary = false;
+  
+      /**
+       * Process a Process Language Command.
+*************** public class SqlFile {
+*** 1638,1644 ****
+       * @param inString Complete command, less the leading '\' character.
+       * @throws BadSpecial Runtime error()
+       */
+!     private void processPL(String inString)
+      throws BadSpecial, SqlToolError, SQLException {
+  
+          if (inString.length() < 1) {
+--- 1638,1644 ----
+       * @param inString Complete command, less the leading '\' character.
+       * @throws BadSpecial Runtime error()
+       */
+!     public void processPL(String inString)
+      throws BadSpecial, SqlToolError, SQLException {
+  
+          if (inString.length() < 1) {
+*************** public class SqlFile {
+*** 2061,2067 ****
+       * new SqlFile.execute() with a mode whereby commands are written
+       * to a separate history but not executed.
+       */
+!     private File plBlockFile(String type) throws IOException, SqlToolError {
+  
+          String          s;
+          StringTokenizer toker;
+--- 2061,2067 ----
+       * new SqlFile.execute() with a mode whereby commands are written
+       * to a separate history but not executed.
+       */
+!     public File plBlockFile(String type) throws IOException, SqlToolError {
+  
+          String          s;
+          StringTokenizer toker;
+*************** public class SqlFile {
+*** 2149,2163 ****
+      /**
+       * Wrapper methods so don't need to call x(..., false) in most cases.
+       */
+!     private void stdprintln() {
+          stdprintln(false);
+      }
+  
+!     private void stdprint(String s) {
+          stdprint(s, false);
+      }
+  
+!     private void stdprintln(String s) {
+          stdprintln(s, false);
+      }
+  
+--- 2149,2163 ----
+      /**
+       * Wrapper methods so don't need to call x(..., false) in most cases.
+       */
+!     public void stdprintln() {
+          stdprintln(false);
+      }
+  
+!     public void stdprint(String s) {
+          stdprint(s, false);
+      }
+  
+!     public void stdprintln(String s) {
+          stdprintln(s, false);
+      }
+  
+*************** public class SqlFile {
+*** 2166,2172 ****
+       *
+       * Conditionally HTML-ifies output.
+       */
+!     private void stdprintln(boolean queryOutput) {
+  
+          if (htmlMode) {
+              psStd.println("<BR>");
+--- 2166,2172 ----
+       *
+       * Conditionally HTML-ifies output.
+       */
+!     public void stdprintln(boolean queryOutput) {
+  
+          if (htmlMode) {
+              psStd.println("<BR>");
+*************** public class SqlFile {
+*** 2190,2196 ****
+       *
+       * Conditionally HTML-ifies error output.
+       */
+!     private void errprint(String s) {
+  
+          psErr.print(htmlMode
+                      ? ("<DIV style='color:white; background: red; "
+--- 2190,2196 ----
+       *
+       * Conditionally HTML-ifies error output.
+       */
+!     public void errprint(String s) {
+  
+          psErr.print(htmlMode
+                      ? ("<DIV style='color:white; background: red; "
+*************** public class SqlFile {
+*** 2203,2209 ****
+       *
+       * Conditionally HTML-ifies error output.
+       */
+!     private void errprintln(String s) {
+  
+          psErr.println(htmlMode
+                        ? ("<DIV style='color:white; background: red; "
+--- 2203,2209 ----
+       *
+       * Conditionally HTML-ifies error output.
+       */
+!     public void errprintln(String s) {
+  
+          psErr.println(htmlMode
+                        ? ("<DIV style='color:white; background: red; "
+*************** public class SqlFile {
+*** 2216,2222 ****
+       *
+       * Conditionally HTML-ifies output.
+       */
+!     private void stdprint(String s, boolean queryOutput) {
+  
+          psStd.print(htmlMode ? ("<P>" + s + "</P>")
+                               : s);
+--- 2216,2222 ----
+       *
+       * Conditionally HTML-ifies output.
+       */
+!     public void stdprint(String s, boolean queryOutput) {
+  
+          psStd.print(htmlMode ? ("<P>" + s + "</P>")
+                               : s);
+*************** public class SqlFile {
+*** 2233,2239 ****
+       *
+       * Conditionally HTML-ifies output.
+       */
+!     private void stdprintln(String s, boolean queryOutput) {
+  
+          psStd.println(htmlMode ? ("<P>" + s + "</P>")
+                                 : s);
+--- 2233,2239 ----
+       *
+       * Conditionally HTML-ifies output.
+       */
+!     public void stdprintln(String s, boolean queryOutput) {
+  
+          psStd.println(htmlMode ? ("<P>" + s + "</P>")
+                                 : s);
+*************** public class SqlFile {
+*** 2248,2270 ****
+      // Just because users may be used to seeing "[null]" in normal
+      // SqlFile output, we use the same default value for null in CSV
+      // files, but this CSV null representation can be changed to anything.
+!     private static final String DEFAULT_NULL_REP = "[null]";
+!     private static final String DEFAULT_ROW_DELIM =
+          System.getProperty("line.separator");
+!     private static final String DEFAULT_COL_DELIM = "|";
+!     private static final int    DEFAULT_ELEMENT   = 0,
+                                  HSQLDB_ELEMENT    = 1,
+                                  ORACLE_ELEMENT    = 2
+      ;
+  
+      // These do not specify order listed, just inclusion.
+!     private static final int[] listMDSchemaCols = { 1 };
+!     private static final int[] listMDIndexCols  = {
+          2, 6, 3, 9, 4, 10, 11
+      };
+  
+      /** Column numbering starting at 1. */
+!     private static final int[][] listMDTableCols = {
+          {
+              2, 3
+          },    // Default
+--- 2248,2270 ----
+      // Just because users may be used to seeing "[null]" in normal
+      // SqlFile output, we use the same default value for null in CSV
+      // files, but this CSV null representation can be changed to anything.
+!     public static final String DEFAULT_NULL_REP = "[null]";
+!     public static final String DEFAULT_ROW_DELIM =
+          System.getProperty("line.separator");
+!     public static final String DEFAULT_COL_DELIM = "|";
+!     public static final int    DEFAULT_ELEMENT   = 0,
+                                  HSQLDB_ELEMENT    = 1,
+                                  ORACLE_ELEMENT    = 2
+      ;
+  
+      // These do not specify order listed, just inclusion.
+!     public static final int[] listMDSchemaCols = { 1 };
+!     public static final int[] listMDIndexCols  = {
+          2, 6, 3, 9, 4, 10, 11
+      };
+  
+      /** Column numbering starting at 1. */
+!     public static final int[][] listMDTableCols = {
+          {
+              2, 3
+          },    // Default
+*************** public class SqlFile {
+*** 2297,2303 ****
+       * SCOTT, ADAMS, JONES, CLARK, BLAKE, OE, PM, SH, QS, QS_*, these
+       * contain sample data and the schemas can safely be removed.
+       */
+!     private static final String[] oracleSysSchemas = {
+          "SYS", "SYSTEM", "OUTLN", "DBSNMP", "OUTLN", "MDSYS", "ORDSYS",
+          "ORDPLUGINS", "CTXSYS", "DSSYS", "PERFSTAT", "WKPROXY", "WKSYS",
+          "WMSYS", "XDB", "ANONYMOUS", "ODM", "ODM_MTR", "OLAPSYS", "TRACESVR",
+--- 2297,2303 ----
+       * SCOTT, ADAMS, JONES, CLARK, BLAKE, OE, PM, SH, QS, QS_*, these
+       * contain sample data and the schemas can safely be removed.
+       */
+!     public static final String[] oracleSysSchemas = {
+          "SYS", "SYSTEM", "OUTLN", "DBSNMP", "OUTLN", "MDSYS", "ORDSYS",
+          "ORDPLUGINS", "CTXSYS", "DSSYS", "PERFSTAT", "WKPROXY", "WKSYS",
+          "WMSYS", "XDB", "ANONYMOUS", "ODM", "ODM_MTR", "OLAPSYS", "TRACESVR",
+*************** public class SqlFile {
+*** 2313,2319 ****
+       *
+       * @throws BadSpecial
+       */
+!     private void listTables(char c, String inFilter) throws BadSpecial {
+  
+          String   schema  = null;
+          int[]    listSet = null;
+--- 2313,2319 ----
+       *
+       * @throws BadSpecial
+       */
+!     public void listTables(char c, String inFilter) throws BadSpecial {
+  
+          String   schema  = null;
+          int[]    listSet = null;
+*************** public class SqlFile {
+*** 2632,2643 ****
+          }
+      }
+  
+!     private boolean excludeSysSchemas = false;
+  
+      /**
+       * Process the current command as an SQL Statement
+       */
+!     private void processSQL() throws SQLException {
+  
+          // Really don't know whether to take the network latency hit here
+          // in order to check autoCommit in order to set
+--- 2632,2643 ----
+          }
+      }
+  
+!     public boolean excludeSysSchemas = false;
+  
+      /**
+       * Process the current command as an SQL Statement
+       */
+!     public void processSQL() throws SQLException {
+  
+          // Really don't know whether to take the network latency hit here
+          // in order to check autoCommit in order to set
+*************** public class SqlFile {
+*** 2715,2721 ****
+       * @param incFilter Optional case-insensitive substring.
+       *                  Rows are skipped which to not contain this substring.
+       */
+!     private void displayResultSet(Statement statement, ResultSet r,
+                                    int[] incCols,
+                                    String filter) throws SQLException {
+  
+--- 2715,2721 ----
+       * @param incFilter Optional case-insensitive substring.
+       *                  Rows are skipped which to not contain this substring.
+       */
+!     public void displayResultSet(Statement statement, ResultSet r,
+                                    int[] incCols,
+                                    String filter) throws SQLException {
+  
+*************** public class SqlFile {
+*** 3094,3105 ****
+          }
+      }
+  
+!     private static final int    COL_HEAD = 0,
+                                  COL_ODD  = 1,
+                                  COL_EVEN = 2
+      ;
+!     private static final String PRE_TR   = spaces(4);
+!     private static final String PRE_TD   = spaces(8);
+  
+      /**
+       * Print a properly formatted HTML &lt;TR&gt; command for the given
+--- 3094,3105 ----
+          }
+      }
+  
+!     public static final int    COL_HEAD = 0,
+                                  COL_ODD  = 1,
+                                  COL_EVEN = 2
+      ;
+!     public static final String PRE_TR   = spaces(4);
+!     public static final String PRE_TD   = spaces(8);
+  
+      /**
+       * Print a properly formatted HTML &lt;TR&gt; command for the given
+*************** public class SqlFile {
+*** 3107,3113 ****
+       *
+       * @param colType Column type:  COL_HEAD, COL_ODD or COL_EVEN.
+       */
+!     private static String htmlRow(int colType) {
+  
+          switch (colType) {
+  
+--- 3107,3113 ----
+       *
+       * @param colType Column type:  COL_HEAD, COL_ODD or COL_EVEN.
+       */
+!     public static String htmlRow(int colType) {
+  
+          switch (colType) {
+  
+*************** public class SqlFile {
+*** 3133,3139 ****
+       *
+       * @param len Length of output String.
+       */
+!     private static String divider(int len) {
+          return (len > DIVIDER.length()) ? DIVIDER
+                                          : DIVIDER.substring(0, len);
+      }
+--- 3133,3139 ----
+       *
+       * @param len Length of output String.
+       */
+!     public static String divider(int len) {
+          return (len > DIVIDER.length()) ? DIVIDER
+                                          : DIVIDER.substring(0, len);
+      }
+*************** public class SqlFile {
+*** 3143,3149 ****
+       *
+       * @param len Length of output String.
+       */
+!     private static String spaces(int len) {
+          return (len > SPACES.length()) ? SPACES
+                                         : SPACES.substring(0, len);
+      }
+--- 3143,3149 ----
+       *
+       * @param len Length of output String.
+       */
+!     public static String spaces(int len) {
+          return (len > SPACES.length()) ? SPACES
+                                         : SPACES.substring(0, len);
+      }
+*************** public class SqlFile {
+*** 3156,3162 ****
+       * @param fulllen  Output String length.
+       * @param rightJustify  True to right justify, false to left justify.
+       */
+!     private static String pad(String inString, int fulllen,
+                                boolean rightJustify, boolean doPad) {
+  
+          if (!doPad) {
+--- 3156,3162 ----
+       * @param fulllen  Output String length.
+       * @param rightJustify  True to right justify, false to left justify.
+       */
+!     public static String pad(String inString, int fulllen,
+                                boolean rightJustify, boolean doPad) {
+  
+          if (!doPad) {
+*************** public class SqlFile {
+*** 3180,3186 ****
+       * Display command history, which consists of complete or incomplete SQL
+       * commands.
+       */
+!     private void showHistory() {
+  
+          int      ctr = -1;
+          String   s;
+--- 3180,3186 ----
+       * Display command history, which consists of complete or incomplete SQL
+       * commands.
+       */
+!     public void showHistory() {
+  
+          int      ctr = -1;
+          String   s;
+*************** public class SqlFile {
+*** 3228,3234 ****
+      /**
+       * Return a SQL Command from command history.
+       */
+!     private String commandFromHistory(int commandsAgo) throws BadSpecial {
+  
+          if (commandsAgo >= statementHistory.length) {
+              throw new BadSpecial("History can only hold up to "
+--- 3228,3234 ----
+      /**
+       * Return a SQL Command from command history.
+       */
+!     public String commandFromHistory(int commandsAgo) throws BadSpecial {
+  
+          if (commandsAgo >= statementHistory.length) {
+              throw new BadSpecial("History can only hold up to "
+*************** public class SqlFile {
+*** 3249,3255 ****
+       * Push a command onto the history array (the first element of which
+       * is the "Buffer").
+       */
+!     private void setBuf(String inString) {
+  
+          curHist++;
+  
+--- 3249,3255 ----
+       * Push a command onto the history array (the first element of which
+       * is the "Buffer").
+       */
+!     public void setBuf(String inString) {
+  
+          curHist++;
+  
+*************** public class SqlFile {
+*** 3266,3272 ****
+       * @param tableName  Table that will be described.
+       * @param filter  Substring to filter by
+       */
+!     private void describe(String tableName,
+                            String inFilter) throws SQLException {
+  
+          /*
+--- 3266,3272 ----
+       * @param tableName  Table that will be described.
+       * @param filter  Substring to filter by
+       */
+!     public void describe(String tableName,
+                            String inFilter) throws SQLException {
+  
+          /*
+*************** public class SqlFile {
+*** 3415,3421 ****
+          return sa;
+      }
+  
+!     private boolean eval(String[] inTokens) throws BadSpecial {
+  
+          // dereference *VARNAME variables.
+          // N.b. we work with a "copy" of the tokens.
+--- 3415,3421 ----
+          return sa;
+      }
+  
+!     public boolean eval(String[] inTokens) throws BadSpecial {
+  
+          // dereference *VARNAME variables.
+          // N.b. we work with a "copy" of the tokens.
+*************** public class SqlFile {
+*** 3468,3474 ****
+          throw new BadSpecial("Unrecognized logical operation");
+      }
+  
+!     private void closeQueryOutputStream() {
+  
+          if (pwQuery == null) {
+              return;
+--- 3468,3474 ----
+          throw new BadSpecial("Unrecognized logical operation");
+      }
+  
+!     public void closeQueryOutputStream() {
+  
+          if (pwQuery == null) {
+              return;
+*************** public class SqlFile {
+*** 3488,3494 ****
+       * Print to psStd and possibly pwQuery iff current HTML mode matches
+       * supplied printHtml.
+       */
+!     private void condlPrintln(String s, boolean printHtml) {
+  
+          if ((printHtml &&!htmlMode) || (htmlMode &&!printHtml)) {
+              return;
+--- 3488,3494 ----
+       * Print to psStd and possibly pwQuery iff current HTML mode matches
+       * supplied printHtml.
+       */
+!     public void condlPrintln(String s, boolean printHtml) {
+  
+          if ((printHtml &&!htmlMode) || (htmlMode &&!printHtml)) {
+              return;
+*************** public class SqlFile {
+*** 3506,3512 ****
+       * Print to psStd and possibly pwQuery iff current HTML mode matches
+       * supplied printHtml.
+       */
+!     private void condlPrint(String s, boolean printHtml) {
+  
+          if ((printHtml &&!htmlMode) || (htmlMode &&!printHtml)) {
+              return;
+--- 3506,3512 ----
+       * Print to psStd and possibly pwQuery iff current HTML mode matches
+       * supplied printHtml.
+       */
+!     public void condlPrint(String s, boolean printHtml) {
+  
+          if ((printHtml &&!htmlMode) || (htmlMode &&!printHtml)) {
+              return;
+*************** public class SqlFile {
+*** 3520,3526 ****
+          }
+      }
+  
+!     private static String formatNicely(Map map, boolean withValues) {
+  
+          String       key;
+          StringBuffer sb = new StringBuffer();
+--- 3520,3526 ----
+          }
+      }
+  
+!     public static String formatNicely(Map map, boolean withValues) {
+  
+          String       key;
+          StringBuffer sb = new StringBuffer();
+*************** public class SqlFile {
+*** 3550,3556 ****
+      /**
+       * Ascii file dump.
+       */
+!     private void dump(String varName,
+                        File dumpFile) throws IOException, BadSpecial {
+  
+          String val = (String) userVars.get(varName);
+--- 3550,3556 ----
+      /**
+       * Ascii file dump.
+       */
+!     public void dump(String varName,
+                        File dumpFile) throws IOException, BadSpecial {
+  
+          String val = (String) userVars.get(varName);
+*************** public class SqlFile {
+*** 3591,3597 ****
+      /**
+       * Binary file dump
+       */
+!     private void dump(File dumpFile) throws IOException, BadSpecial {
+  
+          if (binBuffer == null) {
+              throw new BadSpecial("Binary SqlFile buffer is currently empty");
+--- 3591,3597 ----
+      /**
+       * Binary file dump
+       */
+!     public void dump(File dumpFile) throws IOException, BadSpecial {
+  
+          if (binBuffer == null) {
+              throw new BadSpecial("Binary SqlFile buffer is currently empty");
+*************** public class SqlFile {
+*** 3610,3616 ****
+          stdprintln("Saved " + len + " bytes to '" + dumpFile + "'");
+      }
+  
+!     private String streamToString(InputStream is) throws IOException {
+  
+          char[]            xferBuffer   = new char[10240];
+          StringWriter      stringWriter = new StringWriter();
+--- 3610,3616 ----
+          stdprintln("Saved " + len + " bytes to '" + dumpFile + "'");
+      }
+  
+!     public String streamToString(InputStream is) throws IOException {
+  
+          char[]            xferBuffer   = new char[10240];
+          StringWriter      stringWriter = new StringWriter();
+*************** public class SqlFile {
+*** 3624,3630 ****
+          return stringWriter.toString();
+      }
+  
+!     private byte[] streamToBytes(InputStream is) throws IOException {
+  
+          byte[]                xferBuffer = new byte[10240];
+          ByteArrayOutputStream baos       = new ByteArrayOutputStream();
+--- 3624,3630 ----
+          return stringWriter.toString();
+      }
+  
+!     public byte[] streamToBytes(InputStream is) throws IOException {
+  
+          byte[]                xferBuffer = new byte[10240];
+          ByteArrayOutputStream baos       = new ByteArrayOutputStream();
+*************** public class SqlFile {
+*** 3640,3646 ****
+      /**
+       * Ascii file load.
+       */
+!     private void load(String varName, File asciiFile) throws IOException {
+  
+          char[]       xferBuffer   = new char[10240];
+          StringWriter stringWriter = new StringWriter();
+--- 3640,3646 ----
+      /**
+       * Ascii file load.
+       */
+!     public void load(String varName, File asciiFile) throws IOException {
+  
+          char[]       xferBuffer   = new char[10240];
+          StringWriter stringWriter = new StringWriter();
+*************** public class SqlFile {
+*** 3659,3665 ****
+      /**
+       * Binary file load
+       */
+!     private void load(File binFile) throws IOException {
+  
+          byte[]                xferBuffer = new byte[10240];
+          ByteArrayOutputStream baos       = new ByteArrayOutputStream();
+--- 3659,3665 ----
+      /**
+       * Binary file load
+       */
+!     public void load(File binFile) throws IOException {
+  
+          byte[]                xferBuffer = new byte[10240];
+          ByteArrayOutputStream baos       = new ByteArrayOutputStream();
+*************** public class SqlFile {
+*** 3719,3726 ****
+      }
+  
+      // won't compile with JDK 1.3 without these
+!     private static final int JDBC3_BOOLEAN  = 16;
+!     private static final int JDBC3_DATALINK = 70;
+  
+      public static String sqlTypeToString(int i) {
+  
+--- 3719,3726 ----
+      }
+  
+      // won't compile with JDK 1.3 without these
+!     public static final int JDBC3_BOOLEAN  = 16;
+!     public static final int JDBC3_DATALINK = 70;
+  
+      public static String sqlTypeToString(int i) {
+  
+diff -pcr misc/hsqldb/src/org/hsqldb/util/SqlServerTransferHelper.java misc/build/hsqldb/src/org/hsqldb/util/SqlServerTransferHelper.java
+*** misc/hsqldb/src/org/hsqldb/util/SqlServerTransferHelper.java	2005-10-23 20:26:32.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/util/SqlServerTransferHelper.java	2007-02-28 12:32:49.000000000 +0100
+*************** import java.sql.Types;
+*** 42,49 ****
+   */
+  class SqlServerTransferHelper extends TransferHelper {
+  
+!     private boolean firstTinyintRow;
+!     private boolean firstSmallintRow;
+  
+      SqlServerTransferHelper() {
+          super();
+--- 42,49 ----
+   */
+  class SqlServerTransferHelper extends TransferHelper {
+  
+!     public boolean firstTinyintRow;
+!     public boolean firstSmallintRow;
+  
+      SqlServerTransferHelper() {
+          super();
+diff -pcr misc/hsqldb/src/org/hsqldb/util/SqlTool.java misc/build/hsqldb/src/org/hsqldb/util/SqlTool.java
+*** misc/hsqldb/src/org/hsqldb/util/SqlTool.java	2006-07-27 22:04:31.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/util/SqlTool.java	2007-02-28 12:32:49.000000000 +0100
+*************** import java.util.StringTokenizer;
+*** 58,76 ****
+   */
+  public class SqlTool {
+  
+!     private static final String DEFAULT_RCFILE =
+          System.getProperty("user.home") + "/sqltool.rc";
+!     private static Connection conn;
+  
+      // N.b. the following is static!
+!     private static boolean noexit;    // Whether System.exit() may be called.
+!     private static String  revnum = null;
+  
+      /**
+       * The configuration identifier to use when connection parameters are
+       * specified on the command line
+       */
+!     private static String CMDLINE_ID = "cmdline";
+  
+      static {
+          revnum = "$Revision: 1.55 $".substring("$Revision: ".length(),
+--- 58,76 ----
+   */
+  public class SqlTool {
+  
+!     public static final String DEFAULT_RCFILE =
+          System.getProperty("user.home") + "/sqltool.rc";
+!     public static Connection conn;
+  
+      // N.b. the following is static!
+!     public static boolean noexit;    // Whether System.exit() may be called.
+!     public static String  revnum = null;
+  
+      /**
+       * The configuration identifier to use when connection parameters are
+       * specified on the command line
+       */
+!     public static String CMDLINE_ID = "cmdline";
+  
+      static {
+          revnum = "$Revision: 1.55 $".substring("$Revision: ".length(),
+*************** public class SqlTool {
+*** 78,84 ****
+                                                 - 2);
+      }
+  
+!     private static final String SYNTAX_MESSAGE =
+          "Usage: java [-Dsqlfile.X=Y...] org.hsqldb.util.SqlTool \\\n"
+          + "    [--optname [optval...]] urlid [file1.sql...]\n"
+          + "where arguments are:\n"
+--- 78,84 ----
+                                                 - 2);
+      }
+  
+!     public static final String SYNTAX_MESSAGE =
+          "Usage: java [-Dsqlfile.X=Y...] org.hsqldb.util.SqlTool \\\n"
+          + "    [--optname [optval...]] urlid [file1.sql...]\n"
+          + "where arguments are:\n"
+*************** public class SqlTool {
+*** 109,119 ****
+          + "SqlTool v. " + revnum + ".";
+  
+      /** Utility nested class for internal use. */
+!     private static class BadCmdline extends Exception {}
+      ;
+  
+      /** Utility object for internal use. */
+!     private static BadCmdline bcl = new BadCmdline();
+  
+      /** Nested class for external callers of SqlTool.main() */
+      public static class SqlToolException extends Exception {
+--- 109,119 ----
+          + "SqlTool v. " + revnum + ".";
+  
+      /** Utility nested class for internal use. */
+!     public static class BadCmdline extends Exception {}
+      ;
+  
+      /** Utility object for internal use. */
+!     public static BadCmdline bcl = new BadCmdline();
+  
+      /** Nested class for external callers of SqlTool.main() */
+      public static class SqlToolException extends Exception {
+*************** public class SqlTool {
+*** 133,139 ****
+       * Call return() right after you call this method, because this method
+       * will not exit if (noexit is true && retval == 0).
+       */
+!     private static void exitMain(int retval) throws SqlToolException {
+          exitMain(retval, null);
+      }
+  
+--- 133,139 ----
+       * Call return() right after you call this method, because this method
+       * will not exit if (noexit is true && retval == 0).
+       */
+!     public static void exitMain(int retval) throws SqlToolException {
+          exitMain(retval, null);
+      }
+  
+*************** public class SqlTool {
+*** 143,149 ****
+       * Call return() right after you call this method, because this method
+       * will not exit if (noexit is true && retval == 0).
+       */
+!     private static void exitMain(int retval,
+                                   String msg) throws SqlToolException {
+  
+          if (noexit) {
+--- 143,149 ----
+       * Call return() right after you call this method, because this method
+       * will not exit if (noexit is true && retval == 0).
+       */
+!     public static void exitMain(int retval,
+                                   String msg) throws SqlToolException {
+  
+          if (noexit) {
+*************** public class SqlTool {
+*** 170,176 ****
+       * @param username The user the password is for
+       * @return The password the user entered
+       */
+!     private static String promptForPassword(String username)
+      throws SqlToolException {
+  
+          BufferedReader console;
+--- 170,176 ----
+       * @param username The user the password is for
+       * @return The password the user entered
+       */
+!     public static String promptForPassword(String username)
+      throws SqlToolException {
+  
+          BufferedReader console;
+*************** public class SqlTool {
+*** 210,216 ****
+       * @param lowerCaseKeys Set to <code>true</code> if the map keys should be
+       *        converted to lower case
+       */
+!     private static void varParser(String varString, Map varMap,
+                                    boolean lowerCaseKeys)
+                                    throws SqlToolException {
+  
+--- 210,216 ----
+       * @param lowerCaseKeys Set to <code>true</code> if the map keys should be
+       *        converted to lower case
+       */
+!     public static void varParser(String varString, Map varMap,
+                                    boolean lowerCaseKeys)
+                                    throws SqlToolException {
+  
+diff -pcr misc/hsqldb/src/org/hsqldb/util/SqlToolSprayer.java misc/build/hsqldb/src/org/hsqldb/util/SqlToolSprayer.java
+*** misc/hsqldb/src/org/hsqldb/util/SqlToolSprayer.java	2005-10-23 21:25:14.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/util/SqlToolSprayer.java	2007-02-28 12:32:49.000000000 +0100
+*************** import java.util.Properties;
+*** 59,65 ****
+   */
+  public class SqlToolSprayer {
+  
+!     private static final String SYNTAX_MSG =
+          "SYNTAX:  java [-D...] SqlToolSprayer 'SQL;' [urlid1 urlid2...]\n"
+          + "System properties you may use [default values]:\n"
+          + "    sqltoolsprayer.period (in ms.) [500]\n"
+--- 59,65 ----
+   */
+  public class SqlToolSprayer {
+  
+!     public static final String SYNTAX_MSG =
+          "SYNTAX:  java [-D...] SqlToolSprayer 'SQL;' [urlid1 urlid2...]\n"
+          + "System properties you may use [default values]:\n"
+          + "    sqltoolsprayer.period (in ms.) [500]\n"
+*************** public class SqlToolSprayer {
+*** 184,190 ****
+          System.exit(0);
+      }
+  
+!     private static void getUrlsFromPropFile(String fileName,
+              ArrayList al) throws Exception {
+  
+          Properties p = new Properties();
+--- 184,190 ----
+          System.exit(0);
+      }
+  
+!     public static void getUrlsFromPropFile(String fileName,
+              ArrayList al) throws Exception {
+  
+          Properties p = new Properties();
+diff -pcr misc/hsqldb/src/org/hsqldb/util/TableSorter.java misc/build/hsqldb/src/org/hsqldb/util/TableSorter.java
+*** misc/hsqldb/src/org/hsqldb/util/TableSorter.java	2004-11-24 22:50:54.000000000 +0100
+--- misc/build/hsqldb/src/org/hsqldb/util/TableSorter.java	2007-02-28 12:32:49.000000000 +0100
+*************** import javax.swing.table.TableModel;
+*** 78,88 ****
+   */
+  public class TableSorter extends AbstractTableModel {
+  
+!     protected TableModel           tableModel;
+      public static final int        DESCENDING            = -1;
+      public static final int        NOT_SORTED            = 0;
+      public static final int        ASCENDING             = 1;
+!     private static Directive EMPTY_DIRECTIVE = new Directive(-1, NOT_SORTED);
+      public static final Comparator COMPARABLE_COMPARATOR = new Comparator() {
+  
+          public int compare(Object o1, Object o2) {
+--- 78,88 ----
+   */
+  public class TableSorter extends AbstractTableModel {
+  
+!     public TableModel           tableModel;
+      public static final int        DESCENDING            = -1;
+      public static final int        NOT_SORTED            = 0;
+      public static final int        ASCENDING             = 1;
+!     public static Directive EMPTY_DIRECTIVE = new Directive(-1, NOT_SORTED);
+      public static final Comparator COMPARABLE_COMPARATOR = new Comparator() {
+  
+          public int compare(Object o1, Object o2) {
+*************** public class TableSorter extends Abstrac
+*** 112,124 ****
+              return o1.toString().compareTo(o2.toString());
+          }
+      };
+!     private Row[]              viewToModel;
+!     private int[]              modelToView;
+!     private JTableHeader       tableHeader;
+!     private MouseListener      mouseListener;
+!     private TableModelListener tableModelListener;
+!     private Map                columnComparators = new HashMap();
+!     private List               sortingColumns    = new ArrayList();
+  
+      public TableSorter() {
+          this.mouseListener      = new MouseHandler();
+--- 112,124 ----
+              return o1.toString().compareTo(o2.toString());
+          }
+      };
+!     public Row[]              viewToModel;
+!     public int[]              modelToView;
+!     public JTableHeader       tableHeader;
+!     public MouseListener      mouseListener;
+!     public TableModelListener tableModelListener;
+!     public Map                columnComparators = new HashMap();
+!     public List               sortingColumns    = new ArrayList();
+  
+      public TableSorter() {
+          this.mouseListener      = new MouseHandler();
+*************** public class TableSorter extends Abstrac
+*** 140,146 ****
+          setTableModel(tableModel);
+      }
+  
+!     private void clearSortingState() {
+          viewToModel = null;
+          modelToView = null;
+      }
+--- 140,146 ----
+          setTableModel(tableModel);
+      }
+  
+!     public void clearSortingState() {
+          viewToModel = null;
+          modelToView = null;
+      }
+*************** public class TableSorter extends Abstrac
+*** 198,204 ****
+          return sortingColumns.size() != 0;
+      }
+  
+!     private Directive getDirective(int column) {
+  
+          for (int i = 0; i < sortingColumns.size(); i++) {
+              Directive directive = (Directive) sortingColumns.get(i);
+--- 198,204 ----
+          return sortingColumns.size() != 0;
+      }
+  
+!     public Directive getDirective(int column) {
+  
+          for (int i = 0; i < sortingColumns.size(); i++) {
+              Directive directive = (Directive) sortingColumns.get(i);
+*************** public class TableSorter extends Abstrac
+*** 215,221 ****
+          return getDirective(column).direction;
+      }
+  
+!     private void sortingStatusChanged() {
+  
+          clearSortingState();
+          fireTableDataChanged();
+--- 215,221 ----
+          return getDirective(column).direction;
+      }
+  
+!     public void sortingStatusChanged() {
+  
+          clearSortingState();
+          fireTableDataChanged();
+*************** public class TableSorter extends Abstrac
+*** 240,246 ****
+          sortingStatusChanged();
+      }
+  
+!     protected Icon getHeaderRendererIcon(int column, int size) {
+  
+          Directive directive = getDirective(column);
+  
+--- 240,246 ----
+          sortingStatusChanged();
+      }
+  
+!     public Icon getHeaderRendererIcon(int column, int size) {
+  
+          Directive directive = getDirective(column);
+  
+*************** public class TableSorter extends Abstrac
+*** 252,258 ****
+                           sortingColumns.indexOf(directive));
+      }
+  
+!     private void cancelSorting() {
+          sortingColumns.clear();
+          sortingStatusChanged();
+      }
+--- 252,258 ----
+                           sortingColumns.indexOf(directive));
+      }
+  
+!     public void cancelSorting() {
+          sortingColumns.clear();
+          sortingStatusChanged();
+      }
+*************** public class TableSorter extends Abstrac
+*** 266,272 ****
+          }
+      }
+  
+!     protected Comparator getComparator(int column) {
+  
+          Class columnType = tableModel.getColumnClass(column);
+          Comparator comparator =
+--- 266,272 ----
+          }
+      }
+  
+!     public Comparator getComparator(int column) {
+  
+          Class columnType = tableModel.getColumnClass(column);
+          Comparator comparator =
+*************** public class TableSorter extends Abstrac
+*** 283,289 ****
+          return LEXICAL_COMPARATOR;
+      }
+  
+!     private Row[] getViewToModel() {
+  
+          if (viewToModel == null) {
+              int tableModelRowCount = tableModel.getRowCount();
+--- 283,289 ----
+          return LEXICAL_COMPARATOR;
+      }
+  
+!     public Row[] getViewToModel() {
+  
+          if (viewToModel == null) {
+              int tableModelRowCount = tableModel.getRowCount();
+*************** public class TableSorter extends Abstrac
+*** 306,312 ****
+          return getViewToModel()[viewIndex].modelIndex;
+      }
+  
+!     private int[] getModelToView() {
+  
+          if (modelToView == null) {
+              int n = getViewToModel().length;
+--- 306,312 ----
+          return getViewToModel()[viewIndex].modelIndex;
+      }
+  
+!     public int[] getModelToView() {
+  
+          if (modelToView == null) {
+              int n = getViewToModel().length;
+*************** public class TableSorter extends Abstrac
+*** 353,361 ****
+      }
+  
+      // Helper classes
+!     private class Row implements Comparable {
+  
+!         private int modelIndex;
+  
+          public Row(int index) {
+              this.modelIndex = index;
+--- 353,361 ----
+      }
+  
+      // Helper classes
+!     public class Row implements Comparable {
+  
+!         public int modelIndex;
+  
+          public Row(int index) {
+              this.modelIndex = index;
+*************** public class TableSorter extends Abstrac
+*** 394,400 ****
+          }
+      }
+  
+!     private class TableModelHandler implements TableModelListener {
+  
+          public void tableChanged(TableModelEvent e) {
+  
+--- 394,400 ----
+          }
+      }
+  
+!     public class TableModelHandler implements TableModelListener {
+  
+          public void tableChanged(TableModelEvent e) {
+  
+*************** public class TableSorter extends Abstrac
+*** 457,463 ****
+          }
+      }
+  
+!     private class MouseHandler extends MouseAdapter {
+  
+          public void mouseClicked(MouseEvent e) {
+  
+--- 457,463 ----
+          }
+      }
+  
+!     public class MouseHandler extends MouseAdapter {
+  
+          public void mouseClicked(MouseEvent e) {
+  
+*************** public class TableSorter extends Abstrac
+*** 484,494 ****
+          }
+      }
+  
+!     private static class Arrow implements Icon {
+  
+!         private boolean descending;
+!         private int     size;
+!         private int     priority;
+  
+          public Arrow(boolean descending, int size, int priority) {
+  
+--- 484,494 ----
+          }
+      }
+  
+!     public static class Arrow implements Icon {
+  
+!         public boolean descending;
+!         public int     size;
+!         public int     priority;
+  
+          public Arrow(boolean descending, int size, int priority) {
+  
+*************** public class TableSorter extends Abstrac
+*** 548,556 ****
+          }
+      }
+  
+!     private class SortableHeaderRenderer implements TableCellRenderer {
+  
+!         private TableCellRenderer tableCellRenderer;
+  
+          public SortableHeaderRenderer(TableCellRenderer tableCellRenderer) {
+              this.tableCellRenderer = tableCellRenderer;
+--- 548,556 ----
+          }
+      }
+  
+!     public class SortableHeaderRenderer implements TableCellRenderer {
+  
+!         public TableCellRenderer tableCellRenderer;
+  
+          public SortableHeaderRenderer(TableCellRenderer tableCellRenderer) {
+              this.tableCellRenderer = tableCellRenderer;
+*************** public class TableSorter extends Abstrac
+*** 579,588 ****
+          }
+      }
+  
+!     private static class Directive {
+  
+!         private int column;
+!         private int direction;
+  
+          public Directive(int column, int direction) {
+              this.column    = column;
+--- 579,588 ----
+          }
+      }
+  
+!     public static class Directive {
+  
+!         public int column;
+!         public int direction;
+  
+          public Directive(int column, int direction) {
+              this.column    = column;
+diff -pcr misc/hsqldb/src/org/hsqldb/util/TransferCommon.java misc/build/hsqldb/src/org/hsqldb/util/TransferCommon.java
+*** misc/hsqldb/src/org/hsqldb/util/TransferCommon.java	2006-04-11 17:03:33.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/util/TransferCommon.java	2007-02-28 12:32:49.000000000 +0100
+*************** class TransferCommon {
+*** 155,159 ****
+          return (tTable);
+      }
+  
+!     private TransferCommon() {}
+  }
+--- 155,159 ----
+          return (tTable);
+      }
+  
+!     public TransferCommon() {}
+  }
+diff -pcr misc/hsqldb/src/org/hsqldb/util/TransferDb.java misc/build/hsqldb/src/org/hsqldb/util/TransferDb.java
+*** misc/hsqldb/src/org/hsqldb/util/TransferDb.java	2005-10-23 20:26:32.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/util/TransferDb.java	2007-02-28 12:32:49.000000000 +0100
+*************** class TransferDb extends DataAccessPoint
+*** 55,61 ****
+  
+      Connection          conn;
+      DatabaseMetaData    meta;
+!     protected Statement srcStatement = null;
+  
+      TransferDb(Connection c, Traceable t) throws DataAccessPointException {
+  
+--- 55,61 ----
+  
+      Connection          conn;
+      DatabaseMetaData    meta;
+!     public Statement srcStatement = null;
+  
+      TransferDb(Connection c, Traceable t) throws DataAccessPointException {
+  
+*************** class TransferDb extends DataAccessPoint
+*** 243,249 ****
+      }
+  
+  /*
+!     private void transferRow(TransferResultSet r,
+                               PreparedStatement p)
+                               throws DataAccessPointException, SQLException {
+          // TODO
+--- 243,249 ----
+      }
+  
+  /*
+!     public void transferRow(TransferResultSet r,
+                               PreparedStatement p)
+                               throws DataAccessPointException, SQLException {
+          // TODO
+*************** class TransferDb extends DataAccessPoint
+*** 904,910 ****
+       *
+       * @throws SQLException
+       */
+!     private void transferRow(TransferResultSet r, PreparedStatement p,
+                               int len,
+                               int[] types)
+                               throws DataAccessPointException, SQLException {
+--- 904,910 ----
+       *
+       * @throws SQLException
+       */
+!     public void transferRow(TransferResultSet r, PreparedStatement p,
+                               int len,
+                               int[] types)
+                               throws DataAccessPointException, SQLException {
+diff -pcr misc/hsqldb/src/org/hsqldb/util/TransferHelper.java misc/build/hsqldb/src/org/hsqldb/util/TransferHelper.java
+*** misc/hsqldb/src/org/hsqldb/util/TransferHelper.java	2005-10-23 20:26:32.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/util/TransferHelper.java	2007-02-28 12:32:49.000000000 +0100
+*************** import java.util.Hashtable;
+*** 44,54 ****
+   */
+  class TransferHelper {
+  
+!     protected TransferDb db;
+!     protected Traceable  tracer;
+!     protected String     sSchema;
+!     protected JDBCTypes  JDBCT;
+!     private String       quote;
+  
+      TransferHelper() {
+  
+--- 44,54 ----
+   */
+  class TransferHelper {
+  
+!     public TransferDb db;
+!     public Traceable  tracer;
+!     public String     sSchema;
+!     public JDBCTypes  JDBCT;
+!     public String       quote;
+  
+      TransferHelper() {
+  
+diff -pcr misc/hsqldb/src/org/hsqldb/util/Transfer.java misc/build/hsqldb/src/org/hsqldb/util/Transfer.java
+*** misc/hsqldb/src/org/hsqldb/util/Transfer.java	2006-07-17 12:29:00.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/util/Transfer.java	2007-02-28 12:32:49.000000000 +0100
+*************** implements WindowListener, ActionListene
+*** 204,210 ****
+          work(arg);
+      }
+  
+!     private boolean CatalogToSelect() {
+  
+          Vector result = null;
+  
+--- 204,210 ----
+          work(arg);
+      }
+  
+!     public boolean CatalogToSelect() {
+  
+          Vector result = null;
+  
+*************** implements WindowListener, ActionListene
+*** 284,290 ****
+          return (lTable.getItemCount() > 0);
+      }
+  
+!     private boolean SchemaToSelect() {
+  
+          Vector result = null;
+  
+--- 284,290 ----
+          return (lTable.getItemCount() > 0);
+      }
+  
+!     public boolean SchemaToSelect() {
+  
+          Vector result = null;
+  
+*************** implements WindowListener, ActionListene
+*** 491,497 ****
+          return;
+      }
+  
+!     private void RefreshMainDisplay() {
+  
+          lTable.removeAll();
+          lTable.repaint();
+--- 491,497 ----
+          return;
+      }
+  
+!     public void RefreshMainDisplay() {
+  
+          lTable.removeAll();
+          lTable.repaint();
+*************** implements WindowListener, ActionListene
+*** 531,537 ****
+       * @param f
+       * @param m
+       */
+!     private void addMenuItems(Menu f, String[] m) {
+  
+          for (int i = 0; i < m.length; i++) {
+              if (m[i].equals("-")) {
+--- 531,537 ----
+       * @param f
+       * @param m
+       */
+!     public void addMenuItems(Menu f, String[] m) {
+  
+          for (int i = 0; i < m.length; i++) {
+              if (m[i].equals("-")) {
+*************** implements WindowListener, ActionListene
+*** 586,592 ****
+       * Method declaration
+       *
+       */
+!     private void saveTable() {
+  
+          if (tCurrent == null) {
+              return;
+--- 586,592 ----
+       * Method declaration
+       *
+       */
+!     public void saveTable() {
+  
+          if (tCurrent == null) {
+              return;
+*************** implements WindowListener, ActionListene
+*** 644,650 ****
+       *
+       * @param t
+       */
+!     private void displayTable(TransferTable t) {
+  
+          tCurrent = t;
+  
+--- 644,650 ----
+       *
+       * @param t
+       */
+!     public void displayTable(TransferTable t) {
+  
+          tCurrent = t;
+  
+*************** implements WindowListener, ActionListene
+*** 680,686 ****
+       *
+       * @param and
+       */
+!     private void updateEnabled(boolean and) {
+  
+          boolean b = cTransfer.getState();
+  
+--- 680,686 ----
+       *
+       * @param and
+       */
+!     public void updateEnabled(boolean and) {
+  
+          boolean b = cTransfer.getState();
+  
+*************** implements WindowListener, ActionListene
+*** 712,718 ****
+      /**
+       * Method ProcessNextStep
+       */
+!     private void ProcessNextStep() {
+  
+          switch (iSelectionStep) {
+  
+--- 712,718 ----
+      /**
+       * Method ProcessNextStep
+       */
+!     public void ProcessNextStep() {
+  
+          switch (iSelectionStep) {
+  
+*************** implements WindowListener, ActionListene
+*** 902,908 ****
+       */
+      public void windowClosed(WindowEvent e) {}
+  
+!     private void cleanup() {
+  
+          try {
+              if (sourceDb != null) {
+--- 902,908 ----
+       */
+      public void windowClosed(WindowEvent e) {}
+  
+!     public void cleanup() {
+  
+          try {
+              if (sourceDb != null) {
+*************** implements WindowListener, ActionListene
+*** 958,964 ****
+       * Method declaration
+       *
+       */
+!     private void initGUI() {
+  
+          Font fFont = new Font("Dialog", Font.PLAIN, 12);
+  
+--- 958,964 ----
+       * Method declaration
+       *
+       */
+!     public void initGUI() {
+  
+          Font fFont = new Font("Dialog", Font.PLAIN, 12);
+  
+*************** implements WindowListener, ActionListene
+*** 1120,1126 ****
+       *
+       * @return
+       */
+!     private Panel createBorderPanel(Component center) {
+  
+          Panel p = new Panel();
+  
+--- 1120,1126 ----
+       *
+       * @return
+       */
+!     public Panel createBorderPanel(Component center) {
+  
+          Panel p = new Panel();
+  
+*************** implements WindowListener, ActionListene
+*** 1143,1149 ****
+       *
+       * @return
+       */
+!     private Label createLabel(String s) {
+  
+          Label l = new Label(s);
+  
+--- 1143,1149 ----
+       *
+       * @return
+       */
+!     public Label createLabel(String s) {
+  
+          Label l = new Label(s);
+  
+*************** implements WindowListener, ActionListene
+*** 1152,1163 ****
+          return l;
+      }
+  
+!     private void SavePrefs(String f) {
+          saveTable();
+          TransferCommon.savePrefs(f, sourceDb, targetDb, this, tTable);
+      }
+  
+!     private void LoadPrefs(String f) {
+  
+          TransferTable t;
+  
+--- 1152,1163 ----
+          return l;
+      }
+  
+!     public void SavePrefs(String f) {
+          saveTable();
+          TransferCommon.savePrefs(f, sourceDb, targetDb, this, tTable);
+      }
+  
+!     public void LoadPrefs(String f) {
+  
+          TransferTable t;
+  
+*************** implements WindowListener, ActionListene
+*** 1208,1214 ****
+       * Method declaration
+       *
+       */
+!     private void transfer() {
+  
+          saveTable();
+          updateEnabled(false);
+--- 1208,1214 ----
+       * Method declaration
+       *
+       */
+!     public void transfer() {
+  
+          saveTable();
+          updateEnabled(false);
+*************** implements WindowListener, ActionListene
+*** 1271,1277 ****
+          System.gc();
+      }
+  
+!     protected void Exit() {
+  
+          cleanup();
+          fMain.dispose();
+--- 1271,1277 ----
+          System.gc();
+      }
+  
+!     public void Exit() {
+  
+          cleanup();
+          fMain.dispose();
+diff -pcr misc/hsqldb/src/org/hsqldb/util/TransferSQLText.java misc/build/hsqldb/src/org/hsqldb/util/TransferSQLText.java
+*** misc/hsqldb/src/org/hsqldb/util/TransferSQLText.java	2005-10-23 20:26:33.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/util/TransferSQLText.java	2007-02-28 12:32:49.000000000 +0100
+*************** class TransferSQLText extends DataAccess
+*** 52,60 ****
+      String              sFileName              = null;
+      BufferedWriter      WTextWrite             = null;
+      BufferedReader      WTextRead              = null;
+!     protected boolean   StructureAlreadyParsed = false;
+      Hashtable           DbStmts                = null;
+!     protected JDBCTypes JDBCT                  = null;
+  
+      TransferSQLText(String _FileName,
+                      Traceable t) throws DataAccessPointException {
+--- 52,60 ----
+      String              sFileName              = null;
+      BufferedWriter      WTextWrite             = null;
+      BufferedReader      WTextRead              = null;
+!     public boolean   StructureAlreadyParsed = false;
+      Hashtable           DbStmts                = null;
+!     public JDBCTypes JDBCT                  = null;
+  
+      TransferSQLText(String _FileName,
+                      Traceable t) throws DataAccessPointException {
+*************** class TransferSQLText extends DataAccess
+*** 159,165 ****
+       *
+       * @throws SQLException
+       */
+!     private void transferRow(TransferResultSet r) throws Exception {
+  
+          String sLast = "";
+          int    len   = r.getColumnCount();
+--- 159,165 ----
+       *
+       * @throws SQLException
+       */
+!     public void transferRow(TransferResultSet r) throws Exception {
+  
+          String sLast = "";
+          int    len   = r.getColumnCount();
+diff -pcr misc/hsqldb/src/org/hsqldb/util/TransferTable.java misc/build/hsqldb/src/org/hsqldb/util/TransferTable.java
+*** misc/hsqldb/src/org/hsqldb/util/TransferTable.java	2005-10-23 20:26:33.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/util/TransferTable.java	2007-02-28 12:32:49.000000000 +0100
+*************** class TransferTable implements Serializa
+*** 471,477 ****
+          }
+      }
+  
+!     private void initTypes() throws SQLException {
+  
+          if (hTypes != null) {
+              return;
+--- 471,477 ----
+          }
+      }
+  
+!     public void initTypes() throws SQLException {
+  
+          if (hTypes != null) {
+              return;
+diff -pcr misc/hsqldb/src/org/hsqldb/util/Tree.java misc/build/hsqldb/src/org/hsqldb/util/Tree.java
+*** misc/hsqldb/src/org/hsqldb/util/Tree.java	2006-07-17 12:29:11.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/util/Tree.java	2007-02-28 12:32:49.000000000 +0100
+*************** import java.awt.Toolkit;
+*** 89,118 ****
+  class Tree extends Panel {
+  
+      // static
+!     private static Font        fFont;
+!     private static FontMetrics fMetrics;
+!     private static int         iRowHeight;
+!     private static int         iIndentWidth;
+!     private int                iMaxTextLength;
+  
+      // drawing
+!     private Dimension dMinimum;
+!     private Graphics  gImage;
+!     private Image     iImage;
+  
+      // height / width
+!     private int iWidth, iHeight;
+!     private int iFirstRow;
+!     private int iTreeWidth, iTreeHeight;
+!     private int iX, iY;
+  
+      // data
+!     private Vector vData;
+!     private int    iRowCount;
+  
+      // scrolling
+!     private Scrollbar sbHoriz, sbVert;
+!     private int       iSbWidth, iSbHeight;
+  
+      static {
+          fFont        = new Font("Dialog", Font.PLAIN, 12);
+--- 89,118 ----
+  class Tree extends Panel {
+  
+      // static
+!     public static Font        fFont;
+!     public static FontMetrics fMetrics;
+!     public static int         iRowHeight;
+!     public static int         iIndentWidth;
+!     public int                iMaxTextLength;
+  
+      // drawing
+!     public Dimension dMinimum;
+!     public Graphics  gImage;
+!     public Image     iImage;
+  
+      // height / width
+!     public int iWidth, iHeight;
+!     public int iFirstRow;
+!     public int iTreeWidth, iTreeHeight;
+!     public int iX, iY;
+  
+      // data
+!     public Vector vData;
+!     public int    iRowCount;
+  
+      // scrolling
+!     public Scrollbar sbHoriz, sbVert;
+!     public int       iSbWidth, iSbHeight;
+  
+      static {
+          fFont        = new Font("Dialog", Font.PLAIN, 12);
+*************** class Tree extends Panel {
+*** 544,550 ****
+       *
+       * @return
+       */
+!     private static int getMaxHeight(FontMetrics f) {
+          return f.getHeight() + 2;
+      }
+  }
+--- 544,550 ----
+       *
+       * @return
+       */
+!     public static int getMaxHeight(FontMetrics f) {
+          return f.getHeight() + 2;
+      }
+  }
+diff -pcr misc/hsqldb/src/org/hsqldb/util/ZaurusConnectionDialog.java misc/build/hsqldb/src/org/hsqldb/util/ZaurusConnectionDialog.java
+*** misc/hsqldb/src/org/hsqldb/util/ZaurusConnectionDialog.java	2005-10-23 20:26:33.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/util/ZaurusConnectionDialog.java	2007-02-28 12:32:49.000000000 +0100
+*************** implements ActionListener, ItemListener,
+*** 251,257 ****
+       *
+       *
+       */
+!     protected void finishCreate() {
+  
+          try {
+              mConnection = createConnection(mDriver.getText(), mURL.getText(),
+--- 251,257 ----
+       *
+       *
+       */
+!     public void finishCreate() {
+  
+          try {
+              mConnection = createConnection(mDriver.getText(), mURL.getText(),
+diff -pcr misc/hsqldb/src/org/hsqldb/util/ZaurusDatabaseManager.java misc/build/hsqldb/src/org/hsqldb/util/ZaurusDatabaseManager.java
+*** misc/hsqldb/src/org/hsqldb/util/ZaurusDatabaseManager.java	2005-10-23 20:26:33.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/util/ZaurusDatabaseManager.java	2007-02-28 12:32:49.000000000 +0100
+*************** implements ActionListener, WindowListene
+*** 247,253 ****
+          m.connect(c);
+      }
+  
+!     private static void showUsage() {
+  
+          System.out.println(
+              "Usage: java org.hsqldb.util.ZaurusDatabaseManager [options]");
+--- 247,253 ----
+          m.connect(c);
+      }
+  
+!     public static void showUsage() {
+  
+          System.out.println(
+              "Usage: java org.hsqldb.util.ZaurusDatabaseManager [options]");
+*************** implements ActionListener, WindowListene
+*** 587,593 ****
+       * Method declaration
+       *
+       */
+!     private void initGUI() {
+  
+          Panel pQuery   = new Panel();
+          Panel pCommand = new Panel();
+--- 587,593 ----
+       * Method declaration
+       *
+       */
+!     public void initGUI() {
+  
+          Panel pQuery   = new Panel();
+          Panel pCommand = new Panel();
+*************** implements ActionListener, WindowListene
+*** 663,669 ****
+          fMain.pack();
+      }
+  
+!     protected void refreshTree() {
+          super.refreshTree();
+          eEditor.refresh(cConn);
+      }
+--- 663,669 ----
+          fMain.pack();
+      }
+  
+!     public void refreshTree() {
+          super.refreshTree();
+          eEditor.refresh(cConn);
+      }
+diff -pcr misc/hsqldb/src/org/hsqldb/util/ZaurusEditor.java misc/build/hsqldb/src/org/hsqldb/util/ZaurusEditor.java
+*** misc/hsqldb/src/org/hsqldb/util/ZaurusEditor.java	2005-10-23 20:26:33.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/util/ZaurusEditor.java	2007-02-28 12:32:49.000000000 +0100
+*************** public class ZaurusEditor extends Panel 
+*** 401,407 ****
+          }
+      }
+  
+!     private void initGUI() {
+  
+          // without connection there are no tables
+          // vAllTables is a local variable with all table names in the database
+--- 401,407 ----
+          }
+      }
+  
+!     public void initGUI() {
+  
+          // without connection there are no tables
+          // vAllTables is a local variable with all table names in the database
+*************** public class ZaurusEditor extends Panel 
+*** 565,575 ****
+  
+      // process the buttons events
+      // *******************************************************
+!     // private methods
+      // *******************************************************
+      // read all table names over the current database connection
+      // exclude tables without primary key
+!     private Vector getAllTables() {
+  
+          Vector result = new Vector(20);
+  
+--- 565,575 ----
+  
+      // process the buttons events
+      // *******************************************************
+!     // public methods
+      // *******************************************************
+      // read all table names over the current database connection
+      // exclude tables without primary key
+!     public Vector getAllTables() {
+  
+          Vector result = new Vector(20);
+  
+*************** public class ZaurusEditor extends Panel 
+*** 608,614 ****
+  
+      // determine the index of the choosen table in Vector vHoldTableNames
+      // if the table name is not in vHoldTableNames, create a ZaurusTableForm for it
+!     private int getChoosenTableIndex() {
+  
+          String tableName = cTables.getSelectedItem();
+  
+--- 608,614 ----
+  
+      // determine the index of the choosen table in Vector vHoldTableNames
+      // if the table name is not in vHoldTableNames, create a ZaurusTableForm for it
+!     public int getChoosenTableIndex() {
+  
+          String tableName = cTables.getSelectedItem();
+  
+*************** public class ZaurusEditor extends Panel 
+*** 633,639 ****
+  
+      // determine the index of the given tableName in Vector vHoldTableNames
+      // if the name is not in vHoldTableNames, answer -1
+!     private int getTableIndex(String tableName) {
+  
+          int index;
+  
+--- 633,639 ----
+  
+      // determine the index of the given tableName in Vector vHoldTableNames
+      // if the name is not in vHoldTableNames, answer -1
+!     public int getTableIndex(String tableName) {
+  
+          int index;
+  
+*************** public class ZaurusEditor extends Panel 
+*** 650,656 ****
+      }
+  
+      // convert the search words in the textfield to an array of words
+!     private String[] getWords() {
+  
+          StringTokenizer tokenizer =
+              new StringTokenizer(fSearchWords.getText());
+--- 650,656 ----
+      }
+  
+      // convert the search words in the textfield to an array of words
+!     public String[] getWords() {
+  
+          StringTokenizer tokenizer =
+              new StringTokenizer(fSearchWords.getText());
+*************** public class ZaurusEditor extends Panel 
+*** 665,671 ****
+      }
+  
+      // init the three boxes for buttons
+!     private void initButtons() {
+  
+          // the buttons for the search form
+          bSearchRow = new Button("Search Rows");
+--- 665,671 ----
+      }
+  
+      // init the three boxes for buttons
+!     public void initButtons() {
+  
+          // the buttons for the search form
+          bSearchRow = new Button("Search Rows");
+*************** public class ZaurusEditor extends Panel 
+*** 722,728 ****
+  
+      // check whether the last button pressed was delete
+      // if so, clear status line and reset the flag
+!     private void resetLastButtonDelete() {
+  
+          if (lastButtonDelete) {
+              ZaurusEditor.printStatus("");
+--- 722,728 ----
+  
+      // check whether the last button pressed was delete
+      // if so, clear status line and reset the flag
+!     public void resetLastButtonDelete() {
+  
+          if (lastButtonDelete) {
+              ZaurusEditor.printStatus("");
+*************** public class ZaurusEditor extends Panel 
+*** 732,738 ****
+      }
+  
+      // reset  everything after changes in the database
+!     private void resetTableForms() {
+  
+          lForm.show(pForm, "search");
+          lButton.show(pButton, "search");
+--- 732,738 ----
+      }
+  
+      // reset  everything after changes in the database
+!     public void resetTableForms() {
+  
+          lForm.show(pForm, "search");
+          lButton.show(pButton, "search");
+diff -pcr misc/hsqldb/src/org/hsqldb/util/ZaurusChoice.java misc/build/hsqldb/src/org/hsqldb/util/ZaurusChoice.java
+*** misc/hsqldb/src/org/hsqldb/util/ZaurusChoice.java	2005-10-23 20:26:33.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/util/ZaurusChoice.java	2007-02-28 12:32:49.000000000 +0100
+*************** import java.awt.Color;
+*** 52,58 ****
+  // getContent() answers the value !!
+  public class ZaurusChoice extends Choice implements ZaurusComponent {
+  
+!     private static final int MaxLenInZChoice = 15;
+      Vector                   values;
+      int                      countChanges;
+  
+--- 52,58 ----
+  // getContent() answers the value !!
+  public class ZaurusChoice extends Choice implements ZaurusComponent {
+  
+!     public static final int MaxLenInZChoice = 15;
+      Vector                   values;
+      int                      countChanges;
+  
+*************** public class ZaurusChoice extends Choice
+*** 118,124 ****
+      }
+  
+      // find for a given value the index in values
+!     private int findValue(String s) {
+  
+          for (int i = 0; i < values.size(); i++) {
+              if (s.equals(values.elementAt(i))) {
+--- 118,124 ----
+      }
+  
+      // find for a given value the index in values
+!     public int findValue(String s) {
+  
+          for (int i = 0; i < values.size(); i++) {
+              if (s.equals(values.elementAt(i))) {
+diff -pcr misc/hsqldb/src/org/hsqldb/util/ZaurusTableForm.java misc/build/hsqldb/src/org/hsqldb/util/ZaurusTableForm.java
+*** misc/hsqldb/src/org/hsqldb/util/ZaurusTableForm.java	2005-10-23 20:26:33.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/util/ZaurusTableForm.java	2007-02-28 12:32:49.000000000 +0100
+*************** implements TextListener, ItemListener, A
+*** 542,551 ****
+      }
+  
+      // ******************************************************
+!     // private methods
+      // ******************************************************
+      // set all fields for primary keys to not editable
+!     private void disablePKFields() {
+  
+          for (int i = 0; i < primaryKeys.length; i++) {
+              komponente[pkColIndex[i]].setEditable(false);
+--- 542,551 ----
+      }
+  
+      // ******************************************************
+!     // public methods
+      // ******************************************************
+      // set all fields for primary keys to not editable
+!     public void disablePKFields() {
+  
+          for (int i = 0; i < primaryKeys.length; i++) {
+              komponente[pkColIndex[i]].setEditable(false);
+*************** implements TextListener, ItemListener, A
+*** 555,561 ****
+      // fetch all values from a table and a column
+      // fill the ZaurusChoice zc with the row values for the Choice
+      // and the column values as values
+!     private void fillZChoice(ZaurusChoice zc, String tab, String col) {
+  
+          try {
+              if (cConn == null) {
+--- 555,561 ----
+      // fetch all values from a table and a column
+      // fill the ZaurusChoice zc with the row values for the Choice
+      // and the column values as values
+!     public void fillZChoice(ZaurusChoice zc, String tab, String col) {
+  
+          try {
+              if (cConn == null) {
+*************** implements TextListener, ItemListener, A
+*** 590,596 ****
+      }
+  
+      // fetch all column names
+!     private void fetchColumns() {
+  
+          Vector temp     = new Vector(20);
+          Vector tempType = new Vector(20);
+--- 590,596 ----
+      }
+  
+      // fetch all column names
+!     public void fetchColumns() {
+  
+          Vector temp     = new Vector(20);
+          Vector tempType = new Vector(20);
+*************** implements TextListener, ItemListener, A
+*** 628,634 ****
+      }
+  
+      // fetch the imported keys i.e. columns which reference to foreign keys in other tables
+!     private void fetchImportedKeys() {
+  
+          Vector imKeys      = new Vector(20);
+          Vector imKeyNames  = null;
+--- 628,634 ----
+      }
+  
+      // fetch the imported keys i.e. columns which reference to foreign keys in other tables
+!     public void fetchImportedKeys() {
+  
+          Vector imKeys      = new Vector(20);
+          Vector imKeyNames  = null;
+*************** implements TextListener, ItemListener, A
+*** 714,720 ****
+          }
+      }
+  
+!     private void fetchPrimaryKeys() {
+  
+          Vector temp = new Vector(20);
+  
+--- 714,720 ----
+          }
+      }
+  
+!     public void fetchPrimaryKeys() {
+  
+          Vector temp = new Vector(20);
+  
+*************** implements TextListener, ItemListener, A
+*** 749,755 ****
+          }    // end of for (int i=0; i<primaryKeys.length; i++)
+      }
+  
+!     private String generatePKWhere() {
+  
+          String stmtString = " WHERE ";
+  
+--- 749,755 ----
+          }    // end of for (int i=0; i<primaryKeys.length; i++)
+      }
+  
+!     public String generatePKWhere() {
+  
+          String stmtString = " WHERE ";
+  
+*************** implements TextListener, ItemListener, A
+*** 765,771 ****
+      }
+  
+      // generate the Where-condition for the words
+!     private String generateWhere(String[] words, boolean allWords,
+                                   boolean ignoreCase, boolean noMatchWhole) {
+  
+          String result = "";
+--- 765,771 ----
+      }
+  
+      // generate the Where-condition for the words
+!     public String generateWhere(String[] words, boolean allWords,
+                                   boolean ignoreCase, boolean noMatchWhole) {
+  
+          String result = "";
+*************** implements TextListener, ItemListener, A
+*** 822,828 ****
+      }
+  
+      // answer the index of the column named name in the actual table
+!     private int getColIndex(String name) {
+  
+          for (int i = 0; i < columns.length; i++) {
+              if (name.equals(columns[i])) {
+--- 822,828 ----
+      }
+  
+      // answer the index of the column named name in the actual table
+!     public int getColIndex(String name) {
+  
+          for (int i = 0; i < columns.length; i++) {
+              if (name.equals(columns[i])) {
+*************** implements TextListener, ItemListener, A
+*** 834,840 ****
+      }
+  
+      // answer the index of the column named colName in the table tabName
+!     private int getColIndex(String colName, String tabName) {
+  
+          int ordPos = 0;
+  
+--- 834,840 ----
+      }
+  
+      // answer the index of the column named colName in the table tabName
+!     public int getColIndex(String colName, String tabName) {
+  
+          int ordPos = 0;
+  
+*************** implements TextListener, ItemListener, A
+*** 864,870 ****
+  
+      // answer the index of the constraint for the column index
+      // answer -1, if the column is not part of any constraint
+!     private int getConstraintIndex(int colIndex) {
+  
+          for (int i = 0; i < imColIndex.length; i++) {
+              for (int j = 0; j < imColIndex[i].length; j++) {
+--- 864,870 ----
+  
+      // answer the index of the constraint for the column index
+      // answer -1, if the column is not part of any constraint
+!     public int getConstraintIndex(int colIndex) {
+  
+          for (int i = 0; i < imColIndex.length; i++) {
+              for (int j = 0; j < imColIndex[i].length; j++) {
+*************** implements TextListener, ItemListener, A
+*** 877,883 ****
+          return -1;
+      }
+  
+!     private void initGUI() {
+  
+          Panel pEntry = new Panel();
+  
+--- 877,883 ----
+          return -1;
+      }
+  
+!     public void initGUI() {
+  
+          Panel pEntry = new Panel();
+  
+*************** implements TextListener, ItemListener, A
+*** 940,946 ****
+      }
+  
+      // get and show the values of the actual row in the GUI
+!     private void showAktRow() {
+  
+          try {
+              pStmt.clearParameters();
+--- 940,946 ----
+      }
+  
+      // get and show the values of the actual row in the GUI
+!     public void showAktRow() {
+  
+          try {
+              pStmt.clearParameters();
+diff -pcr misc/hsqldb/src/org/hsqldb/View.java misc/build/hsqldb/src/org/hsqldb/View.java
+*** misc/hsqldb/src/org/hsqldb/View.java	2005-10-23 19:40:21.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/View.java	2007-02-28 12:32:49.000000000 +0100
+*************** class View extends Table {
+*** 50,57 ****
+  
+      Select             viewSelect;
+      SubQuery           viewSubQuery;
+!     private String     statement;
+!     private HsqlName[] colList;
+  
+      /** schema at the time of compilation */
+      HsqlName compileTimeSchema;
+--- 50,57 ----
+  
+      Select             viewSelect;
+      SubQuery           viewSubQuery;
+!     public String     statement;
+!     public HsqlName[] colList;
+  
+      /** schema at the time of compilation */
+      HsqlName compileTimeSchema;
+diff -pcr misc/hsqldb/src/org/hsqldb/WebServerConnection.java misc/build/hsqldb/src/org/hsqldb/WebServerConnection.java
+*** misc/hsqldb/src/org/hsqldb/WebServerConnection.java	2006-07-21 15:38:22.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/WebServerConnection.java	2007-02-28 12:32:49.000000000 +0100
+*************** import org.hsqldb.rowio.RowOutputBinary;
+*** 76,95 ****
+  class WebServerConnection implements Runnable {
+  
+      static final String         ENCODING = "8859_1";
+!     private Socket              socket;
+!     private WebServer           server;
+!     private static final int    REQUEST_TYPE_BAD  = 0;
+!     private static final int    REQUEST_TYPE_GET  = 1;
+!     private static final int    REQUEST_TYPE_HEAD = 2;
+!     private static final int    REQUEST_TYPE_POST = 3;
+!     private static final String HEADER_OK         = "HTTP/1.0 200 OK";
+!     private static final String HEADER_BAD_REQUEST =
+          "HTTP/1.0 400 Bad Request";
+!     private static final String HEADER_NOT_FOUND = "HTTP/1.0 404 Not Found";
+!     private static final String HEADER_FORBIDDEN = "HTTP/1.0 403 Forbidden";
+      static final int            BUFFER_SIZE      = 256;
+!     private RowOutputBinary     rowOut = new RowOutputBinary(BUFFER_SIZE);
+!     private RowInputBinary      rowIn            = new RowInputBinary(rowOut);
+  
+      //
+      static final byte[] BYTES_GET        = "GET".getBytes();
+--- 76,95 ----
+  class WebServerConnection implements Runnable {
+  
+      static final String         ENCODING = "8859_1";
+!     public Socket              socket;
+!     public WebServer           server;
+!     public static final int    REQUEST_TYPE_BAD  = 0;
+!     public static final int    REQUEST_TYPE_GET  = 1;
+!     public static final int    REQUEST_TYPE_HEAD = 2;
+!     public static final int    REQUEST_TYPE_POST = 3;
+!     public static final String HEADER_OK         = "HTTP/1.0 200 OK";
+!     public static final String HEADER_BAD_REQUEST =
+          "HTTP/1.0 400 Bad Request";
+!     public static final String HEADER_NOT_FOUND = "HTTP/1.0 404 Not Found";
+!     public static final String HEADER_FORBIDDEN = "HTTP/1.0 403 Forbidden";
+      static final int            BUFFER_SIZE      = 256;
+!     public RowOutputBinary     rowOut = new RowOutputBinary(BUFFER_SIZE);
+!     public RowInputBinary      rowIn            = new RowInputBinary(rowOut);
+  
+      //
+      static final byte[] BYTES_GET        = "GET".getBytes();
+*************** class WebServerConnection implements Run
+*** 101,107 ****
+      };
+  
+      // default mime type mappings
+!     private static final int hnd_content_types =
+          BundleHandler.getBundleHandle("content-types", null);
+  
+      /**
+--- 101,107 ----
+      };
+  
+      // default mime type mappings
+!     public static final int hnd_content_types =
+          BundleHandler.getBundleHandle("content-types", null);
+  
+      /**
+*************** class WebServerConnection implements Run
+*** 125,131 ****
+       * @return a best-guess mime-type string using the file extension
+       *      of the name argument.
+       */
+!     private String getMimeTypeString(String name) {
+  
+          int    pos;
+          String key;
+--- 125,131 ----
+       * @return a best-guess mime-type string using the file extension
+       *      of the name argument.
+       */
+!     public String getMimeTypeString(String name) {
+  
+          int    pos;
+          String key;
+*************** class WebServerConnection implements Run
+*** 240,246 ****
+       * POST is used only for database access. So we can assume the strings
+       * are those generated by HTTPClientConnection
+       */
+!     private void processPost(InputStream inStream,
+                               String name) throws HsqlException, IOException {
+  
+          // fredt - parsing in this block is not actually necessary
+--- 240,246 ----
+       * POST is used only for database access. So we can assume the strings
+       * are those generated by HTTPClientConnection
+       */
+!     public void processPost(InputStream inStream,
+                               String name) throws HsqlException, IOException {
+  
+          // fredt - parsing in this block is not actually necessary
+*************** class WebServerConnection implements Run
+*** 344,350 ****
+       * @param  name the name of the content to get
+       * @param  send whether to send the content as well, or just the header
+       */
+!     private void processGet(String name, boolean send) {
+  
+          try {
+              String       hdr;
+--- 344,350 ----
+       * @param  name the name of the content to get
+       * @param  send whether to send the content as well, or just the header
+       */
+!     public void processGet(String name, boolean send) {
+  
+          try {
+              String       hdr;
+*************** class WebServerConnection implements Run
+*** 446,452 ****
+       *
+       * @param code the error condition code
+       */
+!     private void processError(int code) {
+  
+          String msg;
+  
+--- 446,452 ----
+       *
+       * @param code the error condition code
+       */
+!     public void processError(int code) {
+  
+          String msg;
+  
