Index: svtools/source/filter.vcl/jpeg/jpegc.c
===================================================================
RCS file: /cvs/util/svtools/source/filter.vcl/jpeg/jpegc.c,v
retrieving revision 1.4
diff -u -r1.4 jpegc.c
--- svtools/source/filter.vcl/jpeg/jpegc.c	19 Jun 2006 21:07:34 -0000	1.4
+++ svtools/source/filter.vcl/jpeg/jpegc.c	18 May 2007 11:08:52 -0000
@@ -39,7 +39,8 @@
 #include "jpeglib.h"
 #include "jerror.h"
 #include "jpeg.h"
-
+#include "rtl/alloc.h"
+#include "osl/diagnose.h"
 
 struct my_error_mgr
 {
@@ -76,6 +77,8 @@
     long                            nWidth;
     long                            nHeight;
     long                            nAlignedWidth;
+    HPBYTE pScanLineBuffer;
+    JSAMPLE * range_limit;
     // declare bDecompCreated volatile because of gcc
     // warning: variable 'bDecompCreated' might be clobbered by `longjmp' or `vfork'
 	volatile long					bDecompCreated = 0;
@@ -101,6 +104,10 @@
 	cinfo.output_gamma = 1.0;
 	cinfo.raw_data_out = FALSE;
 	cinfo.quantize_colors = FALSE;
-	if ( cinfo.jpeg_color_space != JCS_GRAYSCALE )
-		cinfo.out_color_space = JCS_RGB;
+	if ( cinfo.jpeg_color_space == JCS_YCbCr )
+	    cinfo.out_color_space = JCS_RGB;
+	else if ( cinfo.jpeg_color_space == JCS_YCCK )
+	    cinfo.out_color_space = JCS_CMYK;
+
+	OSL_ASSERT(cinfo.out_color_space == JCS_CMYK || cinfo.out_color_space == JCS_GRAYSCALE || cinfo.out_color_space == JCS_RGB);
 
@@ -116,6 +123,9 @@
     aCreateBitmapParam.bGray = cinfo.output_components == 1;
 	pDIB = CreateBitmap( pJPEGReader, &aCreateBitmapParam );
     nAlignedWidth = aCreateBitmapParam.nAlignedWidth;
+    pScanLineBuffer = (cinfo.out_color_space == JCS_CMYK ? rtl_allocateMemory( cinfo.output_components * cinfo.output_width ) : NULL);
+    range_limit=cinfo.sample_range_limit;
+
 	if( pDIB )
 	{
 		if( aCreateBitmapParam.bTopDown )
@@ -128,17 +138,37 @@
 
 		for ( *pLines = 0; *pLines < nHeight; (*pLines)++ )
 		{
+		    if (pScanLineBuffer!=NULL) { // in other words cinfo.out_color_space == JCS_CMYK
+			int i;
+			int j;
+			const int abs_nAlignedWidth = (nAlignedWidth < 0) ? -nAlignedWidth : nAlignedWidth;
+			jpeg_read_scanlines( &cinfo, (JSAMPARRAY) &pScanLineBuffer, 1 );
+			// convert CMYK to RGB
+			for(i=0,j=0;j<abs_nAlignedWidth;j+=3,i+=4) {
+			    int c_=255-pScanLineBuffer[i+0];
+			    int m_=255-pScanLineBuffer[i+1];
+			    int y_=255-pScanLineBuffer[i+2];
+			    int k_=255-pScanLineBuffer[i+3];
+			    pTmp[j+0]=range_limit[ 255L - ( c_ + k_ ) ];
+			    pTmp[j+1]=range_limit[ 255L - ( m_ + k_ ) ];
+			    pTmp[j+2]=range_limit[ 255L - ( y_ + k_ ) ];
+			}
+		    } else {
 			jpeg_read_scanlines( &cinfo, (JSAMPARRAY) &pTmp, 1 );
-
-			/* PENDING ??? */
-			if ( cinfo.err->msg_code == 113 )
-				break;
-
-			pTmp += nAlignedWidth;
+		    }
+		    /* PENDING ??? */
+		    if ( cinfo.err->msg_code == 113 )
+			break;
+		    
+		    pTmp += nAlignedWidth;
 		}
 	}
-
+	
 	jpeg_finish_decompress( &cinfo );
+	if (pScanLineBuffer!=NULL) {
+	    rtl_freeMemory( pScanLineBuffer );
+	    pScanLineBuffer=NULL;
+	}
 
 Exit:
 
