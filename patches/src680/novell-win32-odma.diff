--- ucb/prj/build.lst	18 Oct 2005 08:45:24 -0000	1.20
+++ ucb/prj/build.lst	13 Mar 2006 10:55:34 -0000
@@ -14,2 +14,3 @@ uc	ucb\source\ucp\package		nmake	-	all	u
 uc	ucb\source\ucp\tdoc			nmake	-	all	uc_tdoc NULL
 uc	ucb\source\ucp\expand		nmake	-	all	uc_expand NULL
+uc	ucb\source\ucp\odma			nmake	-	w	uc_odma NULL
dummy line to avoid confusing diff-mode
--- ucb/prj/d.lst	18 Oct 2005 08:45:24 -0000	1.20
+++ ucb/prj/d.lst	13 Mar 2006 10:55:34 -0000
@@ -23,6 +23,11 @@
 ..\%__SRC%\lib\ucp*.uno.dylib %_DEST%\lib%_EXT%\ucp*.uno.dylib
 ..\%__SRC%\misc\ucp*.map %_DEST%\bin%_EXT%\ucp*.map
 ..\%__SRC%\misc\ucp*.sym %_DEST%\bin%_EXT%\ucp*.sym
+
+..\%__SRC%\slb\odma_lib.lib %_DEST%\lib%_EXT%\odma_lib.lib
+..\source\ucp\odma\odma.h %_DEST%\inc%_EXT%\odma.h
+..\source\ucp\odma\odma_lib.hxx %_DEST%\inc%_EXT%\odma_lib.hxx
+
 ..\source\ucp\file\ucpfile.xml %_DEST%\xml%_EXT%\ucpfile.xml
 ..\source\ucp\ftp\ucpftp.xml %_DEST%\xml%_EXT%\ucpftp.xml
 ..\source\ucp\hierarchy\ucphier.xml %_DEST%\xml%_EXT%\ucphier.xml
Index: ucb/source/ucp/odma/makefile.mk
===================================================================
RCS file: /cvs/ucb/ucb/ucb/source/ucp/odma/makefile.mk,v
retrieving revision 1.4
diff -p -u -r1.4 makefile.mk
--- ucb/source/ucp/odma/makefile.mk	9 Sep 2005 15:49:57 -0000	1.4
+++ ucb/source/ucp/odma/makefile.mk	6 Nov 2006 00:12:08 -0000
@@ -63,8 +63,7 @@ LIB2TARGET=NO
 
 # --- General -----------------------------------------------------
 
-# @@@ Adjust template file names. Add own files here.
-SLOFILES=\
+SLO1FILES=\
 	$(SLO)$/odma_lib.obj    		\
 	$(SLO)$/odma_services.obj    	\
 	$(SLO)$/odma_provider.obj    	\
@@ -76,7 +75,7 @@ SLOFILES=\
 
 
 LIB1TARGET=$(SLB)$/_$(TARGET).lib
-LIB1OBJFILES=$(SLOFILES)
+LIB1OBJFILES=$(SLO1FILES)
 
 # --- Shared-Library ---------------------------------------------------
 
@@ -122,6 +121,13 @@ APP2STDLIBS+=$(LIBCIMT)
 # @@@ A description string for you UCP.
 DEF2DES=UCB ODMA URL converter
 
+# --- odma_lib library -----------------------------------------------
+
+SLO3FILES=$(SLO)$/odma_lib.obj
+
+LIB3TARGET=$(SLB)$/odma_lib.lib
+LIB3OBJFILES=$(SLO3FILES)
+
 # --- Targets ----------------------------------------------------------
 
 .INCLUDE: target.mk
Index: ucb/source/ucp/odma/odma.h
===================================================================
RCS file: /cvs/ucb/ucb/ucb/source/ucp/odma/odma.h,v
retrieving revision 1.4
diff -p -u -r1.4 odma.h
--- ucb/source/ucp/odma/odma.h	25 Aug 2003 13:00:04 -0000	1.4
+++ ucb/source/ucp/odma/odma.h	6 Nov 2006 00:12:08 -0000
@@ -1 +1,315 @@
-#error	"odma.h: This file is not included in OpenOffice.org (yet). Please download the latest version at http://www.infonuovo.com/odma/downloads"
+/* odma.h - Definitions, prototypes, etc. for Open Document Managment API
+	(ODMA) version 2.0.
+
+	COPYRIGHT (C) 1994, 1995
+	AIIM International
+	All Right Reserved
+*/
+
+#ifndef ODMA_H
+#define ODMA_H
+
+/* Type definitions */
+typedef LPVOID ODMHANDLE;
+typedef LPSTR (*ODMSAVEASCALLBACK)(DWORD dwEnvData, LPSTR lpszFormat, LPVOID pInstanceData);
+typedef int ODMSTATUS;
+
+/* Constants */
+#define ODM_API_VERSION			200		/* Version of the API */
+
+#ifdef WIN32
+	#define ODM_DOCID_MAX		255		/* Win32 */
+
+#elif defined( _WINDOWS_ ) || defined( _MSDOS )
+	#define ODM_DOCID_MAX		80		/* Windows 3.x */
+
+#else
+	#define ODM_DOCID_MAX		255		/* Other platforms */
+#endif
+
+#define ODM_DMSID_MAX			9		/* Max length of a DMS ID including the 
+										/* terminating NULL character.  */
+
+#define ODM_APPID_MAX			16		/* Max length of a application ID including
+										/* the terminating NULL character.  */
+
+// ODMA 2.0
+#define ODM_QUERYID_MAX			255		// Max length of a query ID including
+													// the terminating NULL character.
+
+#define ODM_FORMAT_MAX			81 // Max length of a format including
+													// the terminating NULL character.
+
+// Maximum length of a filename returned by ODMA including the terminating
+//	NULL character.  Platform dependent.
+
+#ifdef WIN32
+	#define ODM_FILENAME_MAX	255		/* Win32 */
+
+#elif defined( _WINDOWS_ ) || defined( _MSDOS )
+	#define ODM_FILENAME_MAX	128		/* Windows 3.x */
+
+#elif defined( unix ) || defined( _UNIX )
+	#define ODM_FILENAME_MAX	1024	/* Unix */
+
+#else
+	#define ODM_FILENAME_MAX	255		/* Other platforms */
+#endif
+
+
+/* Common format type names */
+#define ODM_FORMAT_TEXT	"Text"
+#define ODM_FORMAT_RTF	"Rich text format"
+#define ODM_FORMAT_DCA	"DCA RFT"		/* IBM DCA Rich Format Text */
+#define ODM_FORMAT_TIFF	"Tiff"
+#define ODM_FORMAT_GIF	"Gif"				/* Compuserve Graphics Interchange Format */
+#define ODM_FORMAT_BMP	"Windows bitmap"
+#define ODM_FORMAT_PCX	"PCX"
+#define ODM_FORMAT_CGM	"CGM"				/* Computer Graphics Metafile */
+#define ODM_FORMAT_EXE	"Executable file"
+#define ODM_FORMAT_PCL	"PCL"				/* HP Printer Control Language */
+#define ODM_FORMAT_PS	"PostScript"
+
+
+/* Error returns */
+#define ODM_SUCCESS			0		// Success!
+#define ODM_E_FAIL			1		/* Unspecified failure */
+#define ODM_E_CANCEL		2		/* Action was cancelled at user's request */
+#define ODM_E_NODMS			3		/* DMS not registered */
+#define ODM_E_CANTINIT		4		/* DMS failed to initalize */
+#define ODM_E_VERSION		5		/* DMS doesn't support the requested 
+									           version of ODMA */
+#define ODM_E_APPSELECT		6        /* User has indicated that he wants to use 
+                                       the application's file selection 
+                                       capabilities rather than those of the 
+                                       DMS. */
+#define ODM_E_USERINT		7        /* Requested action cannot be performed 
+                                       without user interaction, but silent 
+                                       mode was specified. */
+#define ODM_E_HANDLE		8        /* The DMHANDLE argument was invalid. */
+#define ODM_E_ACCESS		9        /* User does not have requested access 
+                                       rights to specified document. */
+#define ODM_E_INUSE			10        /* Document is currently in use and cannot 
+                                       be accessed in specified mode. */
+#define ODM_E_DOCID			11        /* Invalid document ID */
+#define ODM_E_OPENMODE		12        /* The specified action is incompatible 
+                                       with the mode in which the document was
+                                       opened. */
+#define ODM_E_NOOPEN		13        /* The specified document is not open. */
+#define ODM_E_ITEM			14        /* Invalid item specifier. */
+#define ODM_E_OTHERAPP		15        /* Selected document was for another app. */
+#define ODM_E_NOMOREDATA	16		/* No more data is available */
+#define ODM_E_PARTIALSUCCESS 17		/* */
+// Additional Error code from ODMA 2.0
+#define ODM_E_REQARG		18		/* */
+#define ODM_E_NOSUPPORT		19		/* */
+#define ODM_E_TRUNCATED		20		/* */
+#define ODM_E_INVARG  21
+#define ODM_E_OFFLINE  22		/* */
+
+
+// ODMOpenDoc modes
+#define ODM_MODIFYMODE		1        /* Open document in a modifiable mode. */
+#define ODM_VIEWMODE		2        /* Open document in non-modifiable mode. */
+// ODMA 2.0
+#define ODM_REFCOPY			3
+
+
+// Actions for ODMActivate
+#define ODM_NONE			0        /* No specific action is requested.  */
+#define ODM_DELETE			1        /* Delete the specified document.  */
+#define ODM_SHOWATTRIBUTES	2        /* Display the specified document's profile 
+                                       or attributes. */
+#define ODM_EDITATTRIBUTES	3        /* Edit the specified document's profile or
+                                       attributes. */
+#define ODM_VIEWDOC			4        /* Display the specified document in a 
+                                       viewer window. */
+#define ODM_OPENDOC			5        /* Open the specified document in its 
+                                       native application.  */
+// ODMA 2.0
+#define ODM_NEWDOC			6
+#define ODM_CHECKOUT		7
+#define ODM_CANCELCHECKOUT	8
+#define ODM_CHECKIN			9
+#define ODM_SHOWHISTORY		10
+
+
+// Item selectors for ODMGetDocInfo and ODMSetDocInfo
+#define ODM_AUTHOR			1        /* Author of the document. */
+#define ODM_NAME			2        /* Descriptive name of the document.  */
+#define ODM_TYPE			3        /* Type of the document.  */
+#define ODM_TITLETEXT		4        /* Suggested text to display in the 
+                                       document window's title bar. */
+#define ODM_DMS_DEFINED		5        /* DMS defined data. */
+#define ODM_CONTENTFORMAT	6        /* String describing document's format */
+// ODMA 2.0
+#define ODM_ALTERNATE_RENDERINGS	7
+#define ODM_CHECKEDOUTBY	8
+#define ODM_CHECKOUTCOMMENT	9
+#define ODM_CHECKOUTDATE	10
+#define ODM_CREATEDBY		11
+#define ODM_CREATEDDATE		12
+#define ODM_DOCID_LATEST	13
+#define ODM_DOCID_RELEASED	14
+#define ODM_DOCVERSION		15
+#define ODM_DOCVERSION_LATEST	16
+#define ODM_DOCVERSION_RELEASED	17
+#define ODM_LOCATION		18
+#define ODM_KEYWORDS		19
+#define ODM_LASTCHECKINBY	20
+#define ODM_LASTCHECKINDATE	21
+#define ODM_MODIFYDATE		22
+#define ODM_MODIFYDATE_LATEST	23
+#define ODM_MODIFYDATE_RELEASED	24
+#define ODM_OWNER			25
+#define ODM_SUBJECT			26
+#define ODM_TITLETEXT_RO	27
+#define ODM_URL				28
+
+
+// Item selectors for ODMQueryCapability ODMA 2.0
+#define ODM_QC_ACTIVATE				1
+#define ODM_QC_CLOSEDOC				2
+#define ODM_QC_CLOSEDOCEX			3
+#define ODM_QC_GETALTERNATECONTENT	4
+#define ODM_QC_GETDMSINFO			5
+#define ODM_QC_GETDOCINFO			6
+#define ODM_QC_GETDOCRELATION		7
+#define ODM_QC_GETLEADMONIKER		8
+#define ODM_QC_NEWDOC				9
+#define ODM_QC_OPENDOC				10
+#define ODM_QC_QUERYCLOSE			11
+#define ODM_QC_QUERYEXECUTE			12
+#define ODM_QC_QUERYGETRESULTS		13
+#define ODM_QC_SAVEAS				14
+#define ODM_QC_SAVEASEX				15
+#define ODM_QC_SAVEDOC				16
+#define ODM_QC_SAVEDOCEX			17
+#define ODM_QC_SELECTDOC			18
+#define ODM_QC_SELECTDOCEX			19
+#define ODM_QC_SETALTERNATECONTENT	20
+#define ODM_QC_SETDOCEVENT			21
+#define ODM_QC_SETDOCRELATION		22
+#define ODM_QC_SETDOCINFO			23
+
+
+// Misc. modes, flags
+#define ODM_SILENT			16        /* Don't interact with the user while
+                                       fulfilling this request. */
+//ODMA 2.0
+#define ODM_VERSION_SAME	1 
+#define ODM_VERSION_MAJOR	2
+#define ODM_VERSION_MINOR	4
+#define ODM_VERSION_CHANGED	8 
+#define ODM_ALT_DELETE		32
+
+//ODMA 2.0 DMS Info Flags 
+#define ODM_EXT_QUERY		1	
+#define ODM_EXT_WORKFLOW 	2	
+
+// Flags for Query Interface
+#define ODM_ALL				1		// All DMS's should be searched
+#define ODM_SPECIFIC		2		// Only specific DMS's should be searched
+
+
+// Function prototypes
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+ODMSTATUS WINAPI ODMRegisterApp(ODMHANDLE FAR *pOdmHandle, WORD version,
+	LPSTR lpszAppId, DWORD dwEnvData, LPVOID pReserved);
+
+void WINAPI ODMUnRegisterApp(ODMHANDLE odmHandle);
+
+ODMSTATUS WINAPI ODMSelectDoc(ODMHANDLE odmHandle, LPSTR lpszDocId,
+	LPDWORD pdwFlags);
+
+ODMSTATUS WINAPI ODMOpenDoc(ODMHANDLE odmHandle, DWORD flags,
+	LPSTR lpszDocId, LPSTR lpszDocLocation);
+
+ODMSTATUS WINAPI ODMSaveDoc(ODMHANDLE odmHandle, LPSTR lpszDocId,
+	LPSTR lpszNewDocId);
+
+ODMSTATUS WINAPI ODMCloseDoc(ODMHANDLE odmHandle, LPSTR lpszDocId,
+	DWORD activeTime, DWORD pagesPrinted, LPVOID sessionData, WORD dataLen);
+
+ODMSTATUS WINAPI ODMNewDoc(ODMHANDLE odmHandle, LPSTR lpszDocId,
+	DWORD dwFlags, LPSTR lpszFormat, LPSTR lpszDocLocation);
+
+ODMSTATUS WINAPI ODMSaveAs(ODMHANDLE odmHandle, LPSTR lpszDocId,
+	LPSTR lpszNewDocId, LPSTR lpszFormat, ODMSAVEASCALLBACK pcbCallBack,
+	LPVOID pInstanceData);
+
+ODMSTATUS WINAPI ODMActivate(ODMHANDLE odmHandle, WORD action,
+	LPSTR lpszDocId);
+
+ODMSTATUS WINAPI ODMGetDocInfo(ODMHANDLE odmHandle, LPSTR lpszDocId,
+	WORD item, LPSTR lpszData, WORD dataLen);
+
+ODMSTATUS WINAPI ODMSetDocInfo(ODMHANDLE odmHandle, LPSTR lpszDocId,
+	WORD item, LPSTR lpszData);
+
+ODMSTATUS WINAPI ODMGetDMSInfo(ODMHANDLE odmHandle, LPSTR lpszDmsId,
+	LPWORD pwVerNo, LPDWORD pdwExtensions);
+
+/* Query Enhancements */
+WORD WINAPI ODMGetDMSCount();
+
+WORD WINAPI ODMGetDMSList( LPSTR buffer, WORD buffer_size );
+
+ODMSTATUS WINAPI ODMGetDMS( LPCSTR lpszAppId, LPSTR lpszDMSId );
+
+ODMSTATUS WINAPI ODMSetDMS( LPCSTR lpszAppId, LPCSTR lpszDMSId );
+
+ODMSTATUS WINAPI ODMQueryExecute(ODMHANDLE odmHandle, LPCSTR lpszQuery,
+								 DWORD flags, LPCSTR lpszDMSList, LPSTR queryId );
+
+ODMSTATUS WINAPI ODMQueryGetResults(ODMHANDLE odmHandle, LPCSTR queryId,
+									LPSTR lpszDocId, LPSTR lpszDocName, WORD docNameLen,
+									WORD *docCount );
+
+ODMSTATUS WINAPI ODMQueryClose(ODMHANDLE odmHandle, LPCSTR queryId );
+
+/* ODMA 2.0 Enhancements */
+ODMSTATUS WINAPI ODMCloseDocEx(ODMHANDLE odmHandle, LPSTR lpszDocId,
+							LPDWORD pdwFlags, DWORD activeTime, DWORD pagesPrinted,
+							LPVOID sessionData, WORD dataLen);
+
+ODMSTATUS WINAPI ODMSaveAsEx(ODMHANDLE odmHandle, LPSTR lpszDocId,
+							LPSTR lpszNewDocId, LPSTR lpszFormat, ODMSAVEASCALLBACK pcbCallBack,
+							LPVOID pInstanceData, LPDWORD pdwFlags);
+
+ODMSTATUS WINAPI ODMSaveDocEx(ODMHANDLE odmHandle, LPSTR lpszDocId,
+							LPSTR lpszNewDocId,	LPDWORD pdwFlags);
+
+ODMSTATUS WINAPI ODMSelectDocEx(ODMHANDLE odmHandle, LPSTR lpszDocIds,
+							LPWORD pwDocIdsLen, LPWORD pwDocCount, LPDWORD pdwFlags,
+							LPSTR lpszFormatFilter);
+
+ODMSTATUS WINAPI ODMQueryCapability(ODMHANDLE odmHandle, LPCSTR lpszDmsId,
+							DWORD function, DWORD item, DWORD flags);
+
+ODMSTATUS WINAPI ODMSetDocEvent(ODMHANDLE odmHandle, LPSTR lpszDocId,
+							DWORD flags, DWORD event, LPVOID lpData, DWORD dwDataLen,
+							LPSTR lpszComment);
+
+ODMSTATUS WINAPI ODMGetAlternateContent(ODMHANDLE odmHandle, LPSTR lpszDocId,
+							LPDWORD pdwFlags, LPSTR lpszFormat, LPSTR lpszDocLocation);
+
+ODMSTATUS WINAPI ODMSetAlternateContent(ODMHANDLE odmHandle, LPSTR lpszDocId,
+							LPDWORD pdwFlags, LPSTR lpszFormat, LPSTR lpszDocLocation);
+
+ODMSTATUS WINAPI ODMGetDocRelation(ODMHANDLE odmHandle, LPSTR lpszDocId,
+							LPDWORD pdwFlags, LPSTR lpszLinkedId, LPSTR lpszFormat,
+							LPSTR lpszPreviousId);
+
+ODMSTATUS WINAPI ODMSetDocRelation(ODMHANDLE odmHandle, LPSTR lpszDocId,
+							LPDWORD pdwFlags, LPSTR lpszLinkedId, LPSTR lpszFormat,
+							LPSTR lpszPreviousId);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
Index: ucb/source/ucp/odma/odma_content.cxx
===================================================================
RCS file: /cvs/ucb/ucb/ucb/source/ucp/odma/odma_content.cxx,v
retrieving revision 1.5
diff -p -u -r1.5 odma_content.cxx
--- ucb/source/ucp/odma/odma_content.cxx	17 Sep 2006 13:57:15 -0000	1.5
+++ ucb/source/ucp/odma/odma_content.cxx	6 Nov 2006 00:12:08 -0000
@@ -126,21 +126,24 @@
 #ifndef ODMA_INPUTSTREAM_HXX
 #include "odma_inputstream.hxx"
 #endif
-#ifndef _UCBHELPER_CONTENT_HXX 
-#include <ucbhelper/content.hxx>
-#endif
 #ifndef _COM_SUN_STAR_UNO_EXCEPTION_HPP_
 #include <com/sun/star/uno/Exception.hpp>
 #endif
 #ifndef _RTL_REF_HXX_
 #include <rtl/ref.hxx>
 #endif
-#ifndef _OSL_FILE_HXX_ 
+#ifndef _OSL_FILE_HXX_
 #include <osl/file.hxx>
 #endif
 
-using namespace com::sun;
-using namespace com::sun::star;
+using namespace com::sun::star::beans;
+using namespace com::sun::star::container;
+using namespace com::sun::star::io;
+using namespace com::sun::star::lang;
+using namespace com::sun::star::sdbc;
+using namespace com::sun::star::ucb;
+using namespace com::sun::star::uno;
+using namespace com::sun::star::util;
 using namespace odma;
 
 //=========================================================================
@@ -151,16 +154,16 @@ using namespace odma;
 //=========================================================================
 //=========================================================================
 
-Content::Content( const uno::Reference< lang::XMultiServiceFactory >& rxSMgr,
+Content::Content( const Reference< XMultiServiceFactory >& rxSMgr,
                   ContentProvider* pProvider,
-                  const uno::Reference< star::ucb::XContentIdentifier >& Identifier,
-				  const ::vos::ORef<ContentProperties>& _rProps)
+                  const Reference< XContentIdentifier >& Identifier,
+				  const ::vos::ORef< ContentProperties >& _rProps)
 	: ContentImplHelper( rxSMgr, pProvider, Identifier )
-	,m_aProps(_rProps)
-	,m_pProvider(pProvider)
-	,m_pContent(NULL)
+	, m_aProps( _rProps )
+	, m_pProvider( pProvider )
+	, m_pContent( NULL )
 {
-	OSL_ENSURE(m_aProps.isValid(),"No valid ContentPropeties!");
+	OSL_ENSURE( m_aProps.isValid(), "No valid ContentPropeties!" );
 }
 
 //=========================================================================
@@ -177,24 +180,26 @@ Content::~Content()
 //=========================================================================
 
 // virtual
-void SAL_CALL Content::acquire() throw()
+void SAL_CALL Content::acquire()
+	throw ()
 {
 	ContentImplHelper::acquire();
 }
 
 //=========================================================================
 // virtual
-void SAL_CALL Content::release() throw()
+void SAL_CALL Content::release()
+	throw()
 {
 	ContentImplHelper::release();
 }
 
 //=========================================================================
 // virtual
-uno::Any SAL_CALL Content::queryInterface( const uno::Type & rType )
-    throw ( uno::RuntimeException )
+Any SAL_CALL Content::queryInterface( const Type & rType )
+    throw ( RuntimeException )
 {
-    uno::Any aRet;
+    Any aRet;
 
 	// @@@ Add support for additional interfaces.
 #if 0
@@ -215,8 +220,8 @@ XTYPEPROVIDER_COMMON_IMPL( Content );
 
 //=========================================================================
 // virtual
-uno::Sequence< uno::Type > SAL_CALL Content::getTypes()
-    throw( uno::RuntimeException )
+Sequence< Type > SAL_CALL Content::getTypes()
+    throw ( RuntimeException )
 {
 	// @@@ Add own interfaces.
 
@@ -228,16 +233,16 @@ uno::Sequence< uno::Type > SAL_CALL Cont
 	  	if ( !pCollection )
 	  	{
             static cppu::OTypeCollection aCollection(
-                CPPU_TYPE_REF( lang::XTypeProvider ),
-                CPPU_TYPE_REF( lang::XServiceInfo ),
-                CPPU_TYPE_REF( lang::XComponent ),
-                CPPU_TYPE_REF( star::ucb::XContent ),
-                CPPU_TYPE_REF( star::ucb::XCommandProcessor ),
-                CPPU_TYPE_REF( beans::XPropertiesChangeNotifier ),
-                CPPU_TYPE_REF( star::ucb::XCommandInfoChangeNotifier ),
-                CPPU_TYPE_REF( beans::XPropertyContainer ),
-                CPPU_TYPE_REF( beans::XPropertySetInfoChangeNotifier ),
-                CPPU_TYPE_REF( container::XChild ) );
+                CPPU_TYPE_REF( XTypeProvider ),
+                CPPU_TYPE_REF( XServiceInfo ),
+                CPPU_TYPE_REF( XComponent ),
+                CPPU_TYPE_REF( XContent ),
+                CPPU_TYPE_REF( XCommandProcessor ),
+                CPPU_TYPE_REF( XPropertiesChangeNotifier ),
+                CPPU_TYPE_REF( XCommandInfoChangeNotifier ),
+                CPPU_TYPE_REF( XPropertyContainer ),
+                CPPU_TYPE_REF( XPropertySetInfoChangeNotifier ),
+                CPPU_TYPE_REF( XChild ) );
 	  		pCollection = &aCollection;
 		}
 	}
@@ -253,7 +258,7 @@ uno::Sequence< uno::Type > SAL_CALL Cont
 
 // virtual
 rtl::OUString SAL_CALL Content::getImplementationName()
-    throw( uno::RuntimeException )
+    throw ( RuntimeException )
 {
     // @@@ Adjust implementation name. Keep the prefix "com.sun.star.comp."!
     return rtl::OUString::createFromAscii( "com.sun.star.comp.odma.Content" );
@@ -261,11 +266,11 @@ rtl::OUString SAL_CALL Content::getImple
 
 //=========================================================================
 // virtual
-uno::Sequence< rtl::OUString > SAL_CALL Content::getSupportedServiceNames()
-    throw( uno::RuntimeException )
+Sequence< rtl::OUString > SAL_CALL Content::getSupportedServiceNames()
+    throw ( RuntimeException )
 {
 	// @@@ Adjust macro name.
-    uno::Sequence< rtl::OUString > aSNS( 1 );
+    Sequence< rtl::OUString > aSNS( 1 );
 	aSNS.getArray()[ 0 ]
             = rtl::OUString::createFromAscii( ODMA_CONTENT_SERVICE_NAME );
 	return aSNS;
@@ -279,7 +284,7 @@ uno::Sequence< rtl::OUString > SAL_CALL 
 
 // virtual
 rtl::OUString SAL_CALL Content::getContentType()
-    throw( uno::RuntimeException )
+    throw ( RuntimeException )
 {
 	// @@@ Adjust macro name ( def in odma_provider.hxx ).
     return rtl::OUString::createFromAscii( ODMA_CONTENT_TYPE );
@@ -292,54 +297,43 @@ rtl::OUString SAL_CALL Content::getConte
 //=========================================================================
 
 // virtual
-uno::Any SAL_CALL Content::execute(
-        const star::ucb::Command& aCommand,
-        sal_Int32 CommandId,
-        const uno::Reference< star::ucb::XCommandEnvironment >& Environment )
-    throw( uno::Exception,
-           star::ucb::CommandAbortedException,
-           uno::RuntimeException )
+Any SAL_CALL Content::execute( const Command& aCommand,
+							   sal_Int32 /* CommandId */,
+							   const Reference< XCommandEnvironment >& Environment )
+    throw ( Exception,
+			CommandAbortedException,
+			RuntimeException )
 {
-    uno::Any aRet;
+    Any aRet;
 
-    if ( aCommand.Name.equalsAsciiL(
-			RTL_CONSTASCII_STRINGPARAM( "getPropertyValues" ) ) )
+    if ( aCommand.Name.equalsAscii( "getPropertyValues" ) )
 	{
-		//////////////////////////////////////////////////////////////////
-		// getPropertyValues
-		//////////////////////////////////////////////////////////////////
-
-        uno::Sequence< beans::Property > Properties;
+        Sequence< Property > Properties;
 		if ( !( aCommand.Argument >>= Properties ) )
 		{
             OSL_ENSURE( sal_False, "Wrong argument type!" );
             ucbhelper::cancelCommandExecution(
-                uno::makeAny( lang::IllegalArgumentException(
-                                    rtl::OUString(),
-                                    static_cast< cppu::OWeakObject * >( this ),
-                                    -1 ) ),
+                makeAny( IllegalArgumentException(
+							 rtl::OUString(),
+							 static_cast< cppu::OWeakObject * >( this ),
+							 -1 ) ),
                 Environment );
             // Unreachable
 		}
 
         aRet <<= getPropertyValues( Properties, Environment );
 	}
-    else if ( aCommand.Name.equalsAsciiL(
-				RTL_CONSTASCII_STRINGPARAM( "setPropertyValues" ) ) )
+    else if ( aCommand.Name.equalsAscii( "setPropertyValues" ) )
     {
-		//////////////////////////////////////////////////////////////////
-		// setPropertyValues
-		//////////////////////////////////////////////////////////////////
-
-        uno::Sequence< beans::PropertyValue > aProperties;
+        Sequence< PropertyValue > aProperties;
 		if ( !( aCommand.Argument >>= aProperties ) )
 		{
             OSL_ENSURE( sal_False, "Wrong argument type!" );
             ucbhelper::cancelCommandExecution(
-                uno::makeAny( lang::IllegalArgumentException(
-                                    rtl::OUString(),
-                                    static_cast< cppu::OWeakObject * >( this ),
-                                    -1 ) ),
+                makeAny( IllegalArgumentException(
+							 rtl::OUString(),
+							 static_cast< cppu::OWeakObject * >( this ),
+							 -1 ) ),
                 Environment );
             // Unreachable
         }
@@ -348,66 +342,52 @@ uno::Any SAL_CALL Content::execute(
 		{
             OSL_ENSURE( sal_False, "No properties!" );
             ucbhelper::cancelCommandExecution(
-                uno::makeAny( lang::IllegalArgumentException(
-                                    rtl::OUString(),
-                                    static_cast< cppu::OWeakObject * >( this ),
-                                    -1 ) ),
+                makeAny( IllegalArgumentException(
+							 rtl::OUString(),
+							 static_cast< cppu::OWeakObject * >( this ),
+							 -1 ) ),
                 Environment );
             // Unreachable
         }
 
         aRet <<= setPropertyValues( aProperties, Environment );
 	}
-    else if ( aCommand.Name.equalsAsciiL(
-				RTL_CONSTASCII_STRINGPARAM( "getPropertySetInfo" ) ) )
+    else if ( aCommand.Name.equalsAscii( "getPropertySetInfo" ) )
     {
-		//////////////////////////////////////////////////////////////////
-		// getPropertySetInfo
-		//////////////////////////////////////////////////////////////////
-
 		// Note: Implemented by base class.
 		aRet <<= getPropertySetInfo( Environment );
 	}
-    else if ( aCommand.Name.equalsAsciiL(
-				RTL_CONSTASCII_STRINGPARAM( "getCommandInfo" ) ) )
+    else if ( aCommand.Name.equalsAscii( "getCommandInfo" ) )
     {
-		//////////////////////////////////////////////////////////////////
-		// getCommandInfo
-		//////////////////////////////////////////////////////////////////
-
 		// Note: Implemented by base class.
 		aRet <<= getCommandInfo( Environment );
 	}
-    else if ( aCommand.Name.equalsAsciiL(
-				RTL_CONSTASCII_STRINGPARAM( "open" ) ) )
+    else if ( aCommand.Name.equalsAscii( "open" ) )
     {
-        star::ucb::OpenCommandArgument2 aOpenCommand;
+        OpenCommandArgument2 aOpenCommand;
       	if ( !( aCommand.Argument >>= aOpenCommand ) )
 		{
             OSL_ENSURE( sal_False, "Wrong argument type!" );
             ucbhelper::cancelCommandExecution(
-                uno::makeAny( lang::IllegalArgumentException(
-                                    rtl::OUString(),
-                                    static_cast< cppu::OWeakObject * >( this ),
-                                    -1 ) ),
+                makeAny( IllegalArgumentException(
+							 rtl::OUString(),
+							 static_cast< cppu::OWeakObject * >( this ),
+							 -1 ) ),
                 Environment );
             // Unreachable
         }
 
         sal_Bool bOpenFolder =
-            ( ( aOpenCommand.Mode == star::ucb::OpenMode::ALL ) ||
-              ( aOpenCommand.Mode == star::ucb::OpenMode::FOLDERS ) ||
-              ( aOpenCommand.Mode == star::ucb::OpenMode::DOCUMENTS ) );
+            ( ( aOpenCommand.Mode == OpenMode::ALL ) ||
+              ( aOpenCommand.Mode == OpenMode::FOLDERS ) ||
+              ( aOpenCommand.Mode == OpenMode::DOCUMENTS ) );
 
         if ( bOpenFolder)
 		{
             // open as folder - return result set
 
-            uno::Reference< star::ucb::XDynamicResultSet > xSet
-                            = new DynamicResultSet( m_xSMgr,
-													this,
-													aOpenCommand,
-													Environment );
+            Reference< XDynamicResultSet > xSet
+				= new DynamicResultSet( m_xSMgr, this, aOpenCommand, Environment );
     		aRet <<= xSet;
   		}
 
@@ -416,17 +396,15 @@ uno::Any SAL_CALL Content::execute(
             // Open document - supply document data stream.
 
             // Check open mode
-            if ( ( aOpenCommand.Mode
-                    == star::ucb::OpenMode::DOCUMENT_SHARE_DENY_NONE ) ||
-                 ( aOpenCommand.Mode
-                    == star::ucb::OpenMode::DOCUMENT_SHARE_DENY_WRITE ) )
+            if ( aOpenCommand.Mode == OpenMode::DOCUMENT_SHARE_DENY_NONE ||
+                 aOpenCommand.Mode == OpenMode::DOCUMENT_SHARE_DENY_WRITE )
             {
                 // Unsupported.
                 ucbhelper::cancelCommandExecution(
-                    uno::makeAny( star::ucb::UnsupportedOpenModeException(
-                                    rtl::OUString(),
-                                    static_cast< cppu::OWeakObject * >( this ),
-                                    sal_Int16( aOpenCommand.Mode ) ) ),
+                    makeAny( UnsupportedOpenModeException(
+								 rtl::OUString(),
+								 static_cast< cppu::OWeakObject * >( this ),
+								 sal_Int16( aOpenCommand.Mode ) ) ),
                     Environment );
                 // Unreachable
             }
@@ -435,41 +413,38 @@ uno::Any SAL_CALL Content::execute(
             rtl::OUString aURL = m_xIdentifier->getContentIdentifier();
 			rtl::OUString sFileURL = openDoc();
 			delete m_pContent;
-			m_pContent = new ::ucb::Content(sFileURL,NULL);
-			if(!m_pContent->isDocument())
+			m_pContent = new ::ucb::Content( sFileURL, NULL );
+			if ( ! m_pContent->isDocument() )
 			{
-				rtl::OUString sErrorMsg(RTL_CONSTASCII_USTRINGPARAM("File: "));
+				rtl::OUString sErrorMsg( RTL_CONSTASCII_USTRINGPARAM( "File: " ));
 				sErrorMsg += sFileURL;
-				sErrorMsg += rtl::OUString(RTL_CONSTASCII_USTRINGPARAM(" could not be found."));
+				sErrorMsg += rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( " could not be found." ));
 				ucbhelper::cancelCommandExecution(
-						uno::makeAny( io::IOException(
-										sErrorMsg,
-										static_cast< cppu::OWeakObject * >( this )) ),
-						Environment );
+					makeAny( IOException(
+								 sErrorMsg,
+								 static_cast< cppu::OWeakObject * >( this )) ),
+					Environment );
+				// Unreachable
 			}
 
-            uno::Reference< io::XOutputStream > xOut
-                = uno::Reference< io::XOutputStream >(
-                    aOpenCommand.Sink, uno::UNO_QUERY );
+            Reference< XOutputStream > xOut( aOpenCommand.Sink, UNO_QUERY );
     		if ( xOut.is() )
       		{
 				// @@@ PUSH: write data into xOut
-				m_pContent->openStream(xOut);
+				m_pContent->openStream( xOut );
       		}
     		else
       		{
-                uno::Reference< io::XActiveDataSink > xDataSink
-                    = uno::Reference< io::XActiveDataSink >(
-                        aOpenCommand.Sink, uno::UNO_QUERY );
+                Reference< XActiveDataSink > xDataSink( aOpenCommand.Sink, UNO_QUERY );
       			if ( xDataSink.is() )
 				{
 	  				// @@@ PULL: wait for client read
-					uno::Reference< io::XInputStream > xIn;
+					Reference< XInputStream > xIn;
 					try
 					{
 						xIn = m_pContent->openStream();
 					}
-					catch(uno::Exception&)
+					catch( Exception& )
 					{
 						OSL_ENSURE(0,"Exception occured while creating the file content!");
 					}
@@ -477,10 +452,10 @@ uno::Any SAL_CALL Content::execute(
 				}
       			else
 				{
-					uno::Reference< io::XActiveDataStreamer > activeDataStreamer( aOpenCommand.Sink,uno::UNO_QUERY );
-					if(activeDataStreamer.is())
+					Reference< XActiveDataStreamer > activeDataStreamer( aOpenCommand.Sink, UNO_QUERY );
+					if ( activeDataStreamer.is() )
 					{
-						activeDataStreamer->setStream(new OOdmaStream(m_pContent,getContentProvider(),m_aProps));
+						activeDataStreamer->setStream( new OOdmaStream( m_pContent,getContentProvider(), m_aProps ) );
 						m_pContent = NULL; // don't delete here because the stream is now the owner
 					}
 					else
@@ -489,10 +464,10 @@ uno::Any SAL_CALL Content::execute(
 						//       implementation. Support for this type of
 						//       sink is optional...
 						ucbhelper::cancelCommandExecution(
-							uno::makeAny( com::sun::star::ucb::UnsupportedDataSinkException(
-									rtl::OUString(),
-									static_cast< cppu::OWeakObject * >( this ),
-									aOpenCommand.Sink ) ),
+							makeAny( UnsupportedDataSinkException(
+										 rtl::OUString(),
+										 static_cast< cppu::OWeakObject * >( this ),
+										 aOpenCommand.Sink ) ),
 							Environment );
 						// Unreachable
 					}
@@ -500,173 +475,120 @@ uno::Any SAL_CALL Content::execute(
 	  		}
 		}
 	}
-	else if ( aCommand.Name.equalsAsciiL( RTL_CONSTASCII_STRINGPARAM( "close" ) ) )
+	else if ( aCommand.Name.equalsAscii( "close" ) )
     {
-		getContentProvider()->closeDocument(m_aProps->m_sDocumentId);
+		getContentProvider()->closeDocument( m_aProps->m_sDocumentId );
 	}
-	else if ( aCommand.Name.equalsAsciiL( RTL_CONSTASCII_STRINGPARAM( "delete" ) ) )
+	else if ( aCommand.Name.equalsAscii( "delete" ) )
     {
-		//////////////////////////////////////////////////////////////////
-		// delete
-		//////////////////////////////////////////////////////////////////
-
 		// Remove own and all children's Additional Core Properties.
 		removeAdditionalPropertySet( sal_True );
 		// Remove own and all childrens(!) persistent data.
-		if(!getContentProvider()->deleteDocument(m_aProps))
+		if ( ! getContentProvider()->deleteDocument( m_aProps ) )
 			ucbhelper::cancelCommandExecution(
-                uno::makeAny( lang::IllegalArgumentException(
-                                    rtl::OUString(),
-                                    static_cast< cppu::OWeakObject * >( this ),
-                                    -1 ) ),
+                makeAny( IllegalArgumentException(
+							 rtl::OUString(),
+							 static_cast< cppu::OWeakObject * >( this ),
+							 -1 ) ),
                 Environment );
+		// Unreachable
 	}
-    else if ( aCommand.Name.equalsAsciiL(
-				RTL_CONSTASCII_STRINGPARAM( "insert" ) ) )
+    else if ( aCommand.Name.equalsAscii( "insert" ) )
     {
-		//////////////////////////////////////////////////////////////////
-		// insert
-		//////////////////////////////////////////////////////////////////
-
-        star::ucb::InsertCommandArgument arg;
+        InsertCommandArgument arg;
       	if ( !( aCommand.Argument >>= arg ) )
 		{
 	  		OSL_ENSURE( sal_False, "Wrong argument type!" );
             ucbhelper::cancelCommandExecution(
-                uno::makeAny( lang::IllegalArgumentException(
-                                    rtl::OUString(),
-                                    static_cast< cppu::OWeakObject * >( this ),
-                                    -1 ) ),
+                makeAny( IllegalArgumentException(
+							 rtl::OUString(),
+							 static_cast< cppu::OWeakObject * >( this ),
+							 -1 ) ),
                 Environment );
             // Unreachable
 		}
 
       	insert( arg.Data, arg.ReplaceExisting, Environment );
     }
-	else if( ! aCommand.Name.compareToAscii( "transfer" ) )
+	else if ( aCommand.Name.equalsAscii( "transfer" ) )
 	{
-		com::sun::star::ucb::TransferInfo aTransferInfo;
-		if( ! ( aCommand.Argument >>= aTransferInfo ) )
+		// So far I have determined that this command is called when
+		// doing "Save As" to copy an already written backup copy of
+		// the document in the file system into the DMS.
+
+		// Maybe also in other situations.
+
+		TransferInfo aTransferInfo;
+		if ( ! ( aCommand.Argument >>= aTransferInfo ) )
 		{
 			OSL_ENSURE( sal_False, "Wrong argument type!" );
             ucbhelper::cancelCommandExecution(
-                uno::makeAny( lang::IllegalArgumentException(
-                                    rtl::OUString(),
-                                    static_cast< cppu::OWeakObject * >( this ),
-                                    -1 ) ),
+                makeAny( IllegalArgumentException(
+							 rtl::OUString(),
+							 static_cast< cppu::OWeakObject * >( this ),
+							 -1 ) ),
                 Environment );
             // Unreachable
 		}
+
 		::vos::ORef<ContentProperties> aProp = m_aProps;
-		if(aProp->m_bIsFolder)
+		if ( aProp->m_bIsFolder )
 		{
-			aProp = getContentProvider()->getContentPropertyWithTitle(aTransferInfo.NewTitle);
-			if(!aProp.isValid())
-				aProp = getContentProvider()->getContentPropertyWithSavedAsName(aTransferInfo.NewTitle);
+			aProp = getContentProvider()->getContentPropertyWithDocumentId( aTransferInfo.NewTitle );
+			if ( ! aProp.isValid() )
+				aProp = getContentProvider()->getContentPropertyWithSavedAsName( aTransferInfo.NewTitle );
 			sal_Bool bError = !aProp.isValid();
-			if(bError)
-			{
-				sal_Char* pExtension = NULL;
-				::rtl::OString sExt;
-				sal_Int32 nPos = aTransferInfo.NewTitle.lastIndexOf('.');
-				if(nPos != -1)
-				{
-					sExt = ::rtl::OUStringToOString(aTransferInfo.NewTitle.copy(nPos+1),RTL_TEXTENCODING_ASCII_US);
-					if(sExt.equalsIgnoreAsciiCase("txt"))
-						pExtension = ODM_FORMAT_TEXT;
-					else if(sExt.equalsIgnoreAsciiCase("rtf"))
-						pExtension = ODM_FORMAT_RTF;
-					else if(sExt.equalsIgnoreAsciiCase("ps"))
-						pExtension = ODM_FORMAT_PS;
-					else  
-						pExtension = const_cast<sal_Char*>(sExt.getStr());
-				}
-				else
-					pExtension = ODM_FORMAT_TEXT;
 
-				sal_Char* lpszNewDocId = new sal_Char[ODM_DOCID_MAX];
-				void *pData = NULL;
-				DWORD dwFlags = ODM_SILENT;
-				ODMSTATUS odm = NODMSaveAsEx(ContentProvider::getHandle(),
-											 NULL, // means it is saved the first time
-											 lpszNewDocId,
-											 pExtension,
-											 NULL, // no callback function here
-											 pData,
-											 &dwFlags);
-
-				// check if we have to call the DMS dialog
-				if(odm == ODM_E_USERINT) 
-				{ 
-					dwFlags = 0;
-					odm = NODMSaveAsEx(ContentProvider::getHandle(),
-											 NULL, // means it is saved the first time
-											 lpszNewDocId,
-											 pExtension,
-											 NULL, // no callback function here
-											 pData,
-											 &dwFlags);
-				}
-				bError = odm != ODM_SUCCESS;
-				if(!bError)
-				{
-					aProp = new ContentProperties();
-					aProp->m_sDocumentId	= ::rtl::OString(lpszNewDocId);
-					aProp->m_sContentType	= ::rtl::OUString(RTL_CONSTASCII_USTRINGPARAM(ODMA_CONTENT_TYPE));
-					aProp->m_sSavedAsName	= aTransferInfo.NewTitle;
-					getContentProvider()->append(aProp);
-
-					// now set the title
-					WORD nDocInfo = ODM_NAME;
-					::rtl::OUString sFileName = aTransferInfo.NewTitle;
-					sal_Int32 nIndex = aTransferInfo.NewTitle.lastIndexOf( sal_Unicode('.') );
-					if(nIndex != -1)
-						sFileName = aTransferInfo.NewTitle.copy(0,nIndex);
-
-					::rtl::OString sDocInfoValue = ::rtl::OUStringToOString(sFileName,RTL_TEXTENCODING_ASCII_US);
-					odm = NODMSetDocInfo(	ContentProvider::getHandle(),
-											lpszNewDocId,
-											nDocInfo,
-											const_cast<sal_Char*>(sDocInfoValue.getStr())
-											);
-
-				}
-				else if ( odm == ODM_E_CANCEL)
-					ODMSTATUS odm = NODMActivate(ContentProvider::getHandle(),
-												 ODM_DELETE,
-												 lpszNewDocId);
+			// There used to be code below that called ODMSaveAsEx,
+			// but that was very broken. We have already called
+			// ODMSaveAsEx in the ODMA file picker when selecting the
+			// name for a new document, or the document already exists
+			// in the DMS and we don't need any ODMSaveAsEx. The ODMA
+			// file picker tells odma::ContentProvider about the new
+			// document's DOCID, so the
+			// getContentPropertyWithDocumentId() call above should
+			// succeed.
 
-				delete lpszNewDocId;
-			}
-			if(bError)
+			if ( bError )
+			{
 				ucbhelper::cancelCommandExecution(
-						uno::makeAny( lang::IllegalArgumentException(
-											rtl::OUString(),
-											static_cast< cppu::OWeakObject * >( this ),
-											-1 ) ),
-						Environment );
+					makeAny( IllegalArgumentException(
+								 rtl::OUString(),
+								 static_cast< cppu::OWeakObject * >( this ),
+								 -1 ) ),
+					Environment );
+				// Unreachable
+			}
 		}
-		rtl::OUString sFileURL = ContentProvider::openDoc(aProp);
+		rtl::OUString sFileURL = ContentProvider::openDoc( aProp );
 
 		sal_Int32 nLastIndex = sFileURL.lastIndexOf( sal_Unicode('/') );
-		::ucb::Content aContent(sFileURL.copy(0,nLastIndex),NULL);
-		//	aTransferInfo.NameClash = com::sun::star::ucb::NameClash::OVERWRITE;
+
+		// Create a new Content object for the "shadow" file
+		// corresponding to the opened document from the DMS.
+		::ucb::Content aContent( sFileURL.copy( 0, nLastIndex), NULL );
 		aTransferInfo.NewTitle = sFileURL.copy( 1 + nLastIndex );
-		aContent.executeCommand(::rtl::OUString(RTL_CONSTASCII_USTRINGPARAM("transfer")),uno::makeAny(aTransferInfo));
-		getContentProvider()->saveDocument(aProp->m_sDocumentId);
+
+		// Copy our saved backup copy to the "shadow" file.
+		aContent.executeCommand(::rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "transfer" ) ), makeAny( aTransferInfo ) );
+
+		// Tell the DMS that the "shadow" file is done and can be
+		// imported.
+		getContentProvider()->saveDocument( aProp->m_sDocumentId );
+    }
+	else if ( aCommand.Name.equalsAscii( "getCasePreservingURL" ) )
+	{
+        rtl::OUString CasePreservingURL = openDoc();
+		aRet <<= CasePreservingURL;
 	}
 	else
 	{
-		//////////////////////////////////////////////////////////////////
-		// Unsupported command
-		//////////////////////////////////////////////////////////////////
-
         OSL_ENSURE( sal_False, "Content::execute - unsupported command!" );
 
         ucbhelper::cancelCommandExecution(
-            uno::makeAny( star::ucb::UnsupportedCommandException(
-                            rtl::OUString(),
-                            static_cast< cppu::OWeakObject * >( this ) ) ),
+            makeAny( UnsupportedCommandException(
+						 rtl::OUString(),
+						 static_cast< cppu::OWeakObject * >( this ) ) ),
             Environment );
         // Unreachable
     }
@@ -676,8 +598,8 @@ uno::Any SAL_CALL Content::execute(
 
 //=========================================================================
 // virtual
-void SAL_CALL Content::abort( sal_Int32 CommandId )
-    throw( uno::RuntimeException )
+void SAL_CALL Content::abort( sal_Int32 /* CommandId */ )
+    throw ( RuntimeException )
 {
 	// @@@ Implement logic to abort running commands, if this makes
 	//     sense for your content.
@@ -695,9 +617,9 @@ void SAL_CALL Content::abort( sal_Int32 
     ::rtl::OUString sURL = m_xIdentifier->getContentIdentifier();
 
     // @@@ Extract URL of parent from aURL and return it...
-	static ::rtl::OUString sScheme1(RTL_CONSTASCII_USTRINGPARAM(ODMA_URL_SCHEME ODMA_URL_SHORT "/"));
-	static ::rtl::OUString sScheme2(RTL_CONSTASCII_USTRINGPARAM(ODMA_URL_SCHEME ODMA_URL_SHORT));
-	if(sURL == sScheme1 || sURL == sScheme2)
+	static ::rtl::OUString sScheme1( RTL_CONSTASCII_USTRINGPARAM( ODMA_URL_SCHEME ODMA_URL_SHORT "/" ) );
+	static ::rtl::OUString sScheme2( RTL_CONSTASCII_USTRINGPARAM( ODMA_URL_SCHEME ODMA_URL_SHORT ) );
+	if ( sURL == sScheme1 || sURL == sScheme2 )
 		sURL = ::rtl::OUString();
 	else
 		sURL = sScheme1;
@@ -707,11 +629,11 @@ void SAL_CALL Content::abort( sal_Int32 
 
 //=========================================================================
 // static
-uno::Reference< sdbc::XRow > Content::getPropertyValues(
-            const uno::Reference< lang::XMultiServiceFactory >& rSMgr,
-            const uno::Sequence< beans::Property >& rProperties,
-            const ::vos::ORef<ContentProperties>& rData,
-            const vos::ORef< ::ucb::ContentProviderImplHelper >& rProvider,
+Reference< XRow > Content::getPropertyValues(
+            const Reference< XMultiServiceFactory >& rSMgr,
+            const Sequence< Property >& rProperties,
+            const ::vos::ORef< ContentProperties>& rData,
+            const vos::ORef< ucb::ContentProviderImplHelper >& rProvider,
             const rtl::OUString& rContentId )
 {
 	// Note: Empty sequence means "get values of all supported properties".
@@ -722,65 +644,55 @@ uno::Reference< sdbc::XRow > Content::ge
 	sal_Int32 nCount = rProperties.getLength();
 	if ( nCount )
 	{
-        uno::Reference< beans::XPropertySet > xAdditionalPropSet;
+        Reference< XPropertySet > xAdditionalPropSet;
 		sal_Bool bTriedToGetAdditonalPropSet = sal_False;
 
-        const beans::Property* pProps = rProperties.getConstArray();
+        const Property* pProps = rProperties.getConstArray();
 		for ( sal_Int32 n = 0; n < nCount; ++n )
 		{
-            const beans::Property& rProp = pProps[ n ];
+            const Property& rProp = pProps[ n ];
 
 			// Process Core properties.
 
-            if ( rProp.Name.equalsAsciiL(
-					RTL_CONSTASCII_STRINGPARAM( "ContentType" ) ) )
+            if ( rProp.Name.equalsAscii( "ContentType" ) )
             {
-				xRow->appendString ( rProp, rData->m_sContentType );
+				xRow->appendString( rProp, rData->m_sContentType );
 			}
-            else if ( rProp.Name.equalsAsciiL(
-                    RTL_CONSTASCII_STRINGPARAM( "Title" ) ) )
+            else if ( rProp.Name.equalsAscii( "Title" ) )
 			{
-				xRow->appendString ( rProp, rData->m_sTitle );
+				xRow->appendString( rProp, rData->m_sTitle );
 			}
-            else if ( rProp.Name.equalsAsciiL(
-                    RTL_CONSTASCII_STRINGPARAM( "IsDocument" ) ) )
+            else if ( rProp.Name.equalsAscii( "IsDocument" ) )
 			{
 				xRow->appendBoolean( rProp, rData->m_bIsDocument );
 			}
-            else if ( rProp.Name.equalsAsciiL(
-                    RTL_CONSTASCII_STRINGPARAM( "IsFolder" ) ) )
+            else if ( rProp.Name.equalsAscii( "IsFolder" ) )
 			{
 				xRow->appendBoolean( rProp, rData->m_bIsFolder );
 			}
-            else if ( rProp.Name.equalsAsciiL(
-                    RTL_CONSTASCII_STRINGPARAM( "DateCreated" ) ) )
+            else if ( rProp.Name.equalsAscii( "DateCreated" ) )
 			{
 				xRow->appendTimestamp( rProp, rData->m_aDateCreated );
 			}
-			else if ( rProp.Name.equalsAsciiL(
-                    RTL_CONSTASCII_STRINGPARAM( "DateModified" ) ) )
+			else if ( rProp.Name.equalsAscii( "DateModified" ) )
 			{
 				xRow->appendTimestamp( rProp, rData->m_aDateModified );
 			}
-			else if ( rProp.Name.equalsAsciiL(
-                    RTL_CONSTASCII_STRINGPARAM( "IsReadOnly" ) ) )
+			else if ( rProp.Name.equalsAscii( "IsReadOnly" ) )
 			{
 				xRow->appendBoolean( rProp, rData->m_bIsReadOnly );
 			}
-			else if ( rProp.Name.equalsAsciiL(
-                    RTL_CONSTASCII_STRINGPARAM( "Author" ) ) )
+			else if ( rProp.Name.equalsAscii( "Author" ) )
 			{
-				xRow->appendString ( rProp, rData->m_sAuthor );
+				xRow->appendString( rProp, rData->m_sAuthor );
 			}
-			else if ( rProp.Name.equalsAsciiL(
-                    RTL_CONSTASCII_STRINGPARAM( "Subject" ) ) )
+			else if ( rProp.Name.equalsAscii( "Subject" ) )
 			{
-				xRow->appendString ( rProp, rData->m_sSubject );
+				xRow->appendString( rProp, rData->m_sSubject );
 			}
-			else if ( rProp.Name.equalsAsciiL(
-                    RTL_CONSTASCII_STRINGPARAM( "Keywords" ) ) )
+			else if ( rProp.Name.equalsAscii( "Keywords" ) )
 			{
-				xRow->appendString ( rProp, rData->m_sKeywords );
+				xRow->appendString( rProp, rData->m_sKeywords );
 			}
 			else
 			{
@@ -795,19 +707,18 @@ uno::Reference< sdbc::XRow > Content::ge
 
 				if ( !bTriedToGetAdditonalPropSet && !xAdditionalPropSet.is() )
 				{
-					xAdditionalPropSet
-                        = uno::Reference< beans::XPropertySet >(
-							rProvider->getAdditionalPropertySet( rContentId,
-																 sal_False ),
-                            uno::UNO_QUERY );
+					xAdditionalPropSet = Reference< XPropertySet >(
+						rProvider->getAdditionalPropertySet( rContentId,
+															 sal_False ),
+						UNO_QUERY );
 					bTriedToGetAdditonalPropSet = sal_True;
 				}
 
 				if ( xAdditionalPropSet.is() )
 				{
 					if ( !xRow->appendPropertySetValue(
-												xAdditionalPropSet,
-												rProp ) )
+							 xAdditionalPropSet,
+							 rProp ) )
 					{
 						// Append empty entry.
 						xRow->appendVoid( rProp );
@@ -824,73 +735,67 @@ uno::Reference< sdbc::XRow > Content::ge
 	else
 	{
 		// Append all Core Properties.
-		xRow->appendString (
-            beans::Property( rtl::OUString::createFromAscii( "ContentType" ),
+		xRow->appendString(
+            Property( rtl::OUString::createFromAscii( "ContentType" ),
 					  -1,
                       getCppuType( static_cast< const rtl::OUString * >( 0 ) ),
-                      beans::PropertyAttribute::BOUND
-                        | beans::PropertyAttribute::READONLY ),
+                      PropertyAttribute::BOUND | PropertyAttribute::READONLY ),
 			rData->m_sContentType );
-		xRow->appendString (
-            beans::Property( rtl::OUString::createFromAscii( "Title" ),
+		xRow->appendString(
+            Property( rtl::OUString::createFromAscii( "Title" ),
 					  -1,
                       getCppuType( static_cast< const rtl::OUString * >( 0 ) ),
-                      beans::PropertyAttribute::BOUND ),
+                      PropertyAttribute::BOUND ),
 			rData->m_sTitle );
 		xRow->appendBoolean(
-            beans::Property( rtl::OUString::createFromAscii( "IsDocument" ),
+            Property( rtl::OUString::createFromAscii( "IsDocument" ),
 					  -1,
 					  getCppuBooleanType(),
-                      beans::PropertyAttribute::BOUND
-                        | beans::PropertyAttribute::READONLY ),
+                      PropertyAttribute::BOUND | PropertyAttribute::READONLY ),
 			rData->m_bIsDocument );
 		xRow->appendBoolean(
-            beans::Property( rtl::OUString::createFromAscii( "IsFolder" ),
+            Property( rtl::OUString::createFromAscii( "IsFolder" ),
 					  -1,
 					  getCppuBooleanType(),
-                      beans::PropertyAttribute::BOUND
-                        | beans::PropertyAttribute::READONLY ),
+                      PropertyAttribute::BOUND | PropertyAttribute::READONLY ),
 			rData->m_bIsFolder );
 
 		// @@@ Append other properties supported directly.
 		xRow->appendTimestamp(
-            beans::Property( rtl::OUString::createFromAscii( "DateCreated" ),
+            Property( rtl::OUString::createFromAscii( "DateCreated" ),
 					  -1,
-					  getCppuType(static_cast< const com::sun::star::util::DateTime * >( 0 ) ),
-                      beans::PropertyAttribute::BOUND
-                        | beans::PropertyAttribute::READONLY ),
+					  getCppuType( static_cast< const DateTime * >( 0 ) ),
+                      PropertyAttribute::BOUND | PropertyAttribute::READONLY ),
 			rData->m_aDateCreated );
 		xRow->appendTimestamp(
-            beans::Property( rtl::OUString::createFromAscii( "DateModified" ),
+            Property( rtl::OUString::createFromAscii( "DateModified" ),
 					  -1,
-					  getCppuType(static_cast< const com::sun::star::util::DateTime * >( 0 ) ),
-                      beans::PropertyAttribute::BOUND
-                        | beans::PropertyAttribute::READONLY ),
+					  getCppuType( static_cast< const DateTime * >( 0 ) ),
+                      PropertyAttribute::BOUND | PropertyAttribute::READONLY ),
 			rData->m_aDateModified );
 		xRow->appendBoolean(
-            beans::Property( rtl::OUString::createFromAscii( "IsReadOnly" ),
+            Property( rtl::OUString::createFromAscii( "IsReadOnly" ),
 					  -1,
 					  getCppuBooleanType(),
-                      beans::PropertyAttribute::BOUND
-                        | beans::PropertyAttribute::READONLY ),
+                      PropertyAttribute::BOUND | PropertyAttribute::READONLY ),
 			rData->m_bIsReadOnly );
-		xRow->appendString (
-            beans::Property( rtl::OUString::createFromAscii( "Author" ),
+		xRow->appendString(
+            Property( rtl::OUString::createFromAscii( "Author" ),
 					  -1,
                       getCppuType( static_cast< const rtl::OUString * >( 0 ) ),
-                      beans::PropertyAttribute::BOUND ),
+                      PropertyAttribute::BOUND ),
 			rData->m_sAuthor );
-		xRow->appendString (
-            beans::Property( rtl::OUString::createFromAscii( "Subject" ),
+		xRow->appendString(
+            Property( rtl::OUString::createFromAscii( "Subject" ),
 					  -1,
                       getCppuType( static_cast< const rtl::OUString * >( 0 ) ),
-                      beans::PropertyAttribute::BOUND ),
+                      PropertyAttribute::BOUND ),
 			rData->m_sSubject );
-		xRow->appendString (
-            beans::Property( rtl::OUString::createFromAscii( "Keywords" ),
+		xRow->appendString(
+            Property( rtl::OUString::createFromAscii( "Keywords" ),
 					  -1,
                       getCppuType( static_cast< const rtl::OUString * >( 0 ) ),
-                      beans::PropertyAttribute::BOUND ),
+                      PropertyAttribute::BOUND ),
 			rData->m_sKeywords );
 
 		// @@@ Note: If your data source supports adding/removing
@@ -902,19 +807,19 @@ uno::Reference< sdbc::XRow > Content::ge
 
 		// Append all Additional Core Properties.
 
-        uno::Reference< beans::XPropertySet > xSet(
+        Reference< XPropertySet > xSet(
 			rProvider->getAdditionalPropertySet( rContentId, sal_False ),
-            uno::UNO_QUERY );
+            UNO_QUERY );
 		xRow->appendPropertySet( xSet );
 	}
 
-    return uno::Reference< sdbc::XRow >( xRow.get() );
+    return Reference< XRow >( xRow.get() );
 }
 
 //=========================================================================
-uno::Reference< sdbc::XRow > Content::getPropertyValues(
-            const uno::Sequence< beans::Property >& rProperties,
-            const uno::Reference< star::ucb::XCommandEnvironment >& xEnv )
+Reference< XRow > Content::getPropertyValues(
+            const Sequence< Property >& rProperties,
+            const Reference< XCommandEnvironment >& /* xEnv */ )
 {
 	osl::Guard< osl::Mutex > aGuard( m_aMutex );
 	return getPropertyValues( m_xSMgr,
@@ -927,17 +832,17 @@ uno::Reference< sdbc::XRow > Content::ge
 }
 
 //=========================================================================
-uno::Sequence< uno::Any > Content::setPropertyValues(
-            const uno::Sequence< beans::PropertyValue >& rValues,
-            const uno::Reference< star::ucb::XCommandEnvironment >& xEnv )
+Sequence< Any > Content::setPropertyValues(
+            const Sequence< PropertyValue >& rValues,
+            const Reference< XCommandEnvironment >& /* xEnv */ )
 {
 	osl::ClearableGuard< osl::Mutex > aGuard( m_aMutex );
 
-    uno::Sequence< uno::Any > aRet( rValues.getLength() );
-    uno::Sequence< beans::PropertyChangeEvent > aChanges( rValues.getLength() );
+    Sequence< Any > aRet( rValues.getLength() );
+    Sequence< PropertyChangeEvent > aChanges( rValues.getLength() );
 	sal_Int32 nChanged = 0;
 
-    beans::PropertyChangeEvent aEvent;
+    PropertyChangeEvent aEvent;
     aEvent.Source         = static_cast< cppu::OWeakObject * >( this );
 	aEvent.Further 		  = sal_False;
 //	aEvent.PropertyName	  =
@@ -945,44 +850,43 @@ uno::Sequence< uno::Any > Content::setPr
 //	aEvent.OldValue		  =
 //	aEvent.NewValue       =
 
-    const beans::PropertyValue* pValues = rValues.getConstArray();
+    const PropertyValue* pValues = rValues.getConstArray();
 	sal_Int32 nCount = rValues.getLength();
 
-    uno::Reference< star::ucb::XPersistentPropertySet > xAdditionalPropSet;
+    Reference< XPersistentPropertySet > xAdditionalPropSet;
 	sal_Bool bTriedToGetAdditonalPropSet = sal_False;
 
 	for ( sal_Int32 n = 0; n < nCount; ++n )
 	{
-        const beans::PropertyValue& rValue = pValues[ n ];
+        const PropertyValue& rValue = pValues[ n ];
 
-        if ( rValue.Name.equalsAsciiL(RTL_CONSTASCII_STRINGPARAM( "Title" ) ) )
+        if ( rValue.Name.equalsAscii( "Title" ) )
 		{
-			changePropertyValue(rValue,n,m_aProps->m_sTitle,nChanged,aRet,aChanges);
+			changePropertyValue( rValue, n, m_aProps->m_sTitle, nChanged, aRet, aChanges );
 		}
-		else if ( rValue.Name.equalsAsciiL(RTL_CONSTASCII_STRINGPARAM( "Author") ) )
+		else if ( rValue.Name.equalsAscii( "Author") )
 		{
-			changePropertyValue(rValue,n,m_aProps->m_sAuthor,nChanged,aRet,aChanges);
+			changePropertyValue( rValue, n, m_aProps->m_sAuthor, nChanged, aRet, aChanges );
 		}
-		else if ( rValue.Name.equalsAsciiL(RTL_CONSTASCII_STRINGPARAM( "Keywords") ) )
+		else if ( rValue.Name.equalsAscii( "Keywords") )
 		{
-			changePropertyValue(rValue,n,m_aProps->m_sKeywords,nChanged,aRet,aChanges);
+			changePropertyValue( rValue, n, m_aProps->m_sKeywords, nChanged, aRet, aChanges );
 		}
-		else if ( rValue.Name.equalsAsciiL(RTL_CONSTASCII_STRINGPARAM( "Subject") ) )
+		else if ( rValue.Name.equalsAscii( "Subject") )
 		{
-			changePropertyValue(rValue,n,m_aProps->m_sSubject,nChanged,aRet,aChanges);
+			changePropertyValue( rValue, n, m_aProps->m_sSubject, nChanged, aRet, aChanges );
 		}
-		else if (	rValue.Name.equalsAsciiL(RTL_CONSTASCII_STRINGPARAM( "ContentType" ) )	||
-					rValue.Name.equalsAsciiL(RTL_CONSTASCII_STRINGPARAM( "IsDocument" ) )	||
-					rValue.Name.equalsAsciiL(RTL_CONSTASCII_STRINGPARAM( "IsFolder" ) )		||
-					rValue.Name.equalsAsciiL(RTL_CONSTASCII_STRINGPARAM( "DateCreated" ) )	||
-					rValue.Name.equalsAsciiL(RTL_CONSTASCII_STRINGPARAM( "DateModified" ) )	||
-					rValue.Name.equalsAsciiL(RTL_CONSTASCII_STRINGPARAM( "IsReadOnly" ) ) )
+		else if ( rValue.Name.equalsAscii( "ContentType" )	||
+				  rValue.Name.equalsAscii( "IsDocument" ) ||
+				  rValue.Name.equalsAscii( "IsFolder" ) ||
+				  rValue.Name.equalsAscii( "DateCreated" ) ||
+				  rValue.Name.equalsAscii( "DateModified" ) ||
+				  rValue.Name.equalsAscii( "IsReadOnly" ) )
         {
 			// Read-only property!
-            aRet[ n ] <<= lang::IllegalAccessException(
-                            rtl::OUString(RTL_CONSTASCII_USTRINGPARAM(
-                                "Property is read-only!") ),
-                            static_cast< cppu::OWeakObject * >( this ) );
+            aRet[ n ] <<= IllegalAccessException(
+				rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "Property is read-only!" ) ),
+				static_cast< cppu::OWeakObject * >( this ) );
 		}
 		else
 		{
@@ -1005,13 +909,12 @@ uno::Sequence< uno::Any > Content::setPr
 			{
 				try
 				{
-                    uno::Any aOldValue
-                        = xAdditionalPropSet->getPropertyValue( rValue.Name );
+                    Any aOldValue( xAdditionalPropSet->getPropertyValue( rValue.Name ));
 					if ( aOldValue != rValue.Value )
 					{
 						xAdditionalPropSet->setPropertyValue(
-												rValue.Name, rValue.Value );
-
+							rValue.Name, rValue.Value );
+						
 						aEvent.PropertyName = rValue.Name;
 						aEvent.OldValue		= aOldValue;
 						aEvent.NewValue     = rValue.Value;
@@ -1024,26 +927,26 @@ uno::Sequence< uno::Any > Content::setPr
                         // Old value equals new value. No error!
                     }
 				}
-                catch ( beans::UnknownPropertyException const & e )
+                catch ( UnknownPropertyException const & e )
 				{
                     aRet[ n ] <<= e;
 				}
-                catch ( lang::WrappedTargetException const & e )
+                catch ( WrappedTargetException const & e )
 				{
                     aRet[ n ] <<= e;
 				}
-                catch ( beans::PropertyVetoException const & e )
+                catch ( PropertyVetoException const & e )
 				{
                     aRet[ n ] <<= e;
 				}
-                catch ( lang::IllegalArgumentException const & e )
+                catch ( IllegalArgumentException const & e )
 				{
                     aRet[ n ] <<= e;
 				}
 			}
             else
             {
-                aRet[ n ] <<= uno::Exception(
+                aRet[ n ] <<= Exception(
                                 rtl::OUString::createFromAscii(
                                     "No property set for storing the value!" ),
                                 static_cast< cppu::OWeakObject * >( this ) );
@@ -1108,8 +1011,7 @@ void Content::queryChildren( ContentRefL
 			{
 				// No further slashes / only a final slash. It's a child!
 				rChildren.push_back(
-					ContentRef(
-						static_cast< Content * >( xChild.getBodyPtr() ) ) );
+					ContentRef( static_cast< Content * >( xChild.getBodyPtr() ) ) );
 			}
 		}
 		++it;
@@ -1117,12 +1019,10 @@ void Content::queryChildren( ContentRefL
 }
 #endif
 //=========================================================================
-void Content::insert(
-        const uno::Reference< io::XInputStream > & xInputStream,
-        sal_Bool bReplaceExisting,
-        const uno::Reference<
-            com::sun::star::ucb::XCommandEnvironment >& Environment )
-    throw( uno::Exception )
+void Content::insert( const Reference< XInputStream > & xInputStream,
+					  sal_Bool bReplaceExisting,
+					  const Reference< XCommandEnvironment >& Environment )
+    throw ( Exception )
 {
 	osl::ClearableGuard< osl::Mutex > aGuard( m_aMutex );
 
@@ -1131,13 +1031,13 @@ void Content::insert(
 	{
         OSL_ENSURE( sal_False, "Content::insert - property value missing!" );
 
-        uno::Sequence< rtl::OUString > aProps( 1 );
+        Sequence< rtl::OUString > aProps( 1 );
         aProps[ 0 ] = rtl::OUString::createFromAscii( "zzzz" );
         ucbhelper::cancelCommandExecution(
-            uno::makeAny( star::ucb::MissingPropertiesException(
-                                rtl::OUString(),
-                                static_cast< cppu::OWeakObject * >( this ),
-                                aProps ) ),
+            makeAny( MissingPropertiesException(
+						 rtl::OUString(),
+						 static_cast< cppu::OWeakObject * >( this ),
+						 aProps ) ),
             Environment );
         // Unreachable
 	}
@@ -1147,29 +1047,29 @@ void Content::insert(
         OSL_ENSURE( sal_False, "Content::insert - No data stream!" );
 
         ucbhelper::cancelCommandExecution(
-            uno::makeAny( star::ucb::MissingInputStreamException(
-                            rtl::OUString(),
-                            static_cast< cppu::OWeakObject * >( this ) ) ),
+            makeAny( MissingInputStreamException(
+						 rtl::OUString(),
+						 static_cast< cppu::OWeakObject * >( this ) ) ),
             Environment );
         // Unreachable
     }
 
 	// Assemble new content identifier...
 
-    //	uno::Reference< star::ucb::XContentIdentifier > xId = ...;
+    //	Reference< XContentIdentifier > xId = ...;
 
     // Fail, if a resource with given id already exists.
     if ( !bReplaceExisting ) // && hasData( m_xIdentifier ) )
     {
 		ucbhelper::cancelCommandExecution(
-            uno::makeAny( star::ucb::UnsupportedCommandException(
-                            rtl::OUString(),
-                            static_cast< cppu::OWeakObject * >( this ) ) ),
+            makeAny( UnsupportedCommandException(
+						 rtl::OUString(),
+						 static_cast< cppu::OWeakObject * >( this ) ) ),
             Environment );
 //        ucbhelper::cancelCommandExecution(
-//						star::ucb::IOErrorCode_ALREADY_EXISTING,
+//						IOErrorCode_ALREADY_EXISTING,
 //						Environment,
-//						uno::makeAny(static_cast< cppu::OWeakObject * >( this ))
+//						makeAny( static_cast< cppu::OWeakObject * >( this ) )
 //                         );
         // Unreachable
     }
@@ -1185,11 +1085,11 @@ void Content::insert(
 #if 0
 //=========================================================================
 void Content::destroy( sal_Bool bDeletePhysical )
-    throw( uno::Exception )
+    throw ( Exception )
 {
 	// @@@ take care about bDeletePhysical -> trashcan support
 
-    uno::Reference< star::ucb::XContent > xThis = this;
+    Reference< XContent > xThis = this;
 
 	deleted();
 
@@ -1214,16 +1114,17 @@ void Content::destroy( sal_Bool bDeleteP
 // -----------------------------------------------------------------------------
 ::rtl::OUString Content::openDoc()
 {
-	OSL_ENSURE(m_aProps.isValid(),"No valid content properties!");
-	return ContentProvider::openDoc(m_aProps);
+	OSL_ENSURE( m_aProps.isValid(), "No valid content properties!" );
+	return ContentProvider::openDoc( m_aProps );
 }
 // -----------------------------------------------------------------------------
-void Content::changePropertyValue(const beans::PropertyValue& _rValue,
-								  sal_Int32 _rnCurrentPos,
-								  ::rtl::OUString& _rsMemberValue,
-								  sal_Int32& _rnChanged,
-								  uno::Sequence< uno::Any >& _rRet,
-								  uno::Sequence< beans::PropertyChangeEvent >& _rChanges) throw (beans::IllegalTypeException)
+void Content::changePropertyValue( const PropertyValue& _rValue,
+								   sal_Int32 _rnCurrentPos,
+								   ::rtl::OUString& _rsMemberValue,
+								   sal_Int32& _rnChanged,
+								   Sequence< Any >& _rRet,
+								   Sequence< PropertyChangeEvent >& _rChanges )
+	throw ( IllegalTypeException )
 {
     rtl::OUString sNewValue;
 	sal_Bool bError = sal_False;
@@ -1233,35 +1134,35 @@ void Content::changePropertyValue(const 
 		{
 			osl::Guard< osl::Mutex > aGuard( m_aMutex );
 			// first we have to check if we could change the property inside the DMS
-			::rtl::OString sDocInfoValue = ::rtl::OUStringToOString(sNewValue,RTL_TEXTENCODING_ASCII_US);
-			WORD nDocInfo;
-			if(&_rsMemberValue == &m_aProps->m_sTitle)
+			::rtl::OString sDocInfoValue = ::rtl::OUStringToOString( sNewValue, RTL_TEXTENCODING_ASCII_US );
+			WORD nDocInfo = 0;
+			if ( &_rsMemberValue == &m_aProps->m_sTitle )
 				nDocInfo = ODM_TITLETEXT;
-			else if(&_rsMemberValue == &m_aProps->m_sAuthor)
+			else if ( &_rsMemberValue == &m_aProps->m_sAuthor )
 				nDocInfo = ODM_AUTHOR;
-			else if(&_rsMemberValue == &m_aProps->m_sSubject)
+			else if ( &_rsMemberValue == &m_aProps->m_sSubject )
 				nDocInfo = ODM_SUBJECT;
-			else if(&_rsMemberValue == &m_aProps->m_sKeywords)
+			else if ( &_rsMemberValue == &m_aProps->m_sKeywords )
 				nDocInfo = ODM_KEYWORDS;
 			else
 				bError = sal_True;
 
-			if(!bError)
+			if ( ! bError )
 			{
 				ODMSTATUS odm = NODMSetDocInfo(	ContentProvider::getHandle(),
-												const_cast<sal_Char*>(m_aProps->m_sDocumentId.getStr()),
+												const_cast<sal_Char*>( m_aProps->m_sDocumentId.getStr() ),
 												nDocInfo,
-												const_cast<sal_Char*>(sDocInfoValue.getStr())
+												const_cast<sal_Char*>( sDocInfoValue.getStr() )
 												);
-				if(odm == ODM_SUCCESS)
+				if ( odm == ODM_SUCCESS )
 				{
-					beans::PropertyChangeEvent aEvent;
+					PropertyChangeEvent aEvent;
 					aEvent.Source			= static_cast< cppu::OWeakObject * >( this );
 					aEvent.Further 			= sal_False;
 					aEvent.PropertyHandle	= -1;
 					aEvent.PropertyName		= _rValue.Name;
-					aEvent.OldValue			= uno::makeAny( _rsMemberValue );
-					aEvent.NewValue			= uno::makeAny( sNewValue );
+					aEvent.OldValue			= makeAny( _rsMemberValue );
+					aEvent.NewValue			= makeAny( sNewValue );
 
 					_rChanges.getArray()[ _rnChanged ] = aEvent;
 
@@ -1278,12 +1179,12 @@ void Content::changePropertyValue(const 
     else
 		bError = sal_True;
 
-	if(bError)
+	if ( bError )
     {
-        _rRet[ _rnCurrentPos ] <<= beans::IllegalTypeException(
-                        rtl::OUString::createFromAscii(
-                            "Property value has wrong type!" ),
-                        static_cast< cppu::OWeakObject * >( this ) );
+        _rRet[ _rnCurrentPos ] <<= IllegalTypeException(
+			rtl::OUString::createFromAscii(
+				"Property value has wrong type!" ),
+			static_cast< cppu::OWeakObject * >( this ) );
     }
 }
 // -----------------------------------------------------------------------------
Index: ucb/source/ucp/odma/odma_content.hxx
===================================================================
RCS file: /cvs/ucb/ucb/ucb/source/ucp/odma/odma_content.hxx,v
retrieving revision 1.4
diff -p -u -r1.4 odma_content.hxx
--- ucb/source/ucp/odma/odma_content.hxx	9 Sep 2005 15:50:31 -0000	1.4
+++ ucb/source/ucp/odma/odma_content.hxx	6 Nov 2006 00:12:08 -0000
@@ -39,29 +39,25 @@
 
 #include <list>
 
+#ifndef _COM_SUN_STAR_BEANS_PROPERTY_HPP_
+#include <com/sun/star/beans/Property.hpp>
+#endif
+#ifndef _COM_SUN_STAR_BEANS_PROPERTYVALUE_HPP_
+#include <com/sun/star/beans/PropertyValue.hpp>
+#endif
+#ifndef _COM_SUN_STAR_IO_XINPUTSTREAM_HPP_
+#include <com/sun/star/io/XInputStream.hpp>
+#endif
+#ifndef _COM_SUN_STAR_SDBC_XROW_HPP_
+#include <com/sun/star/sdbc/XRow.hpp>
+#endif
+#ifndef _UCBHELPER_CONTENT_HXX
+#include <ucbhelper/content.hxx>
+#endif
 #ifndef _UCBHELPER_CONTENTHELPER_HXX
 #include <ucbhelper/contenthelper.hxx>
 #endif
 
-namespace com { namespace sun { namespace star { 
-	namespace beans {
-		struct Property;
-		struct PropertyValue;
-	} 
-	namespace sdbc {
-		class XRow;
-	}
-	namespace io {
-		class XInputStream;
-	}
-}}}
-namespace ucb
-{
-	class Content;
-}
-
-
-// @@@ Adjust namespace name.
 namespace odma
 {
 
@@ -71,7 +67,7 @@ namespace odma
 
 // UNO service name for the content.
 #define ODMA_CONTENT_SERVICE_NAME \
-							"com.sun.star.ucb.OdmaContent"
+							"com.sun.star.ucb.ODMAContent"
 
 //=========================================================================
 class ContentProvider;
@@ -98,9 +94,9 @@ private:
 						::com::sun::star::ucb::XCommandEnvironment >& xEnv );
     ::com::sun::star::uno::Sequence< ::com::sun::star::uno::Any >
     setPropertyValues( const ::com::sun::star::uno::Sequence<
-                        ::com::sun::star::beans::PropertyValue >& rValues,
+                       ::com::sun::star::beans::PropertyValue >& rValues,
                        const ::com::sun::star::uno::Reference<
-                        ::com::sun::star::ucb::XCommandEnvironment >& xEnv );
+                       ::com::sun::star::ucb::XCommandEnvironment >& xEnv );
 
 	/** openDoc returns the file URL for the DOC ID
 		@return the url of the temporary file
@@ -128,10 +124,10 @@ private:
 
   // Command "insert"
     void insert( const ::com::sun::star::uno::Reference<
-                    ::com::sun::star::io::XInputStream > & xInputStream,
+                 ::com::sun::star::io::XInputStream > & xInputStream,
                  sal_Bool bReplaceExisting,
                  const com::sun::star::uno::Reference<
-                    com::sun::star::ucb::XCommandEnvironment >& Environment )
+                 com::sun::star::ucb::XCommandEnvironment >& Environment )
         throw( ::com::sun::star::uno::Exception );
 
 //  // Command "delete"
@@ -140,11 +136,11 @@ private:
 
 public:
 	Content( const ::com::sun::star::uno::Reference<
-				::com::sun::star::lang::XMultiServiceFactory >& rxSMgr,
-				ContentProvider* pProvider,
+			   ::com::sun::star::lang::XMultiServiceFactory >& rxSMgr,
+			 ContentProvider* pProvider,
 			 const ::com::sun::star::uno::Reference<
-				::com::sun::star::ucb::XContentIdentifier >& Identifier,
-				const ::vos::ORef<ContentProperties>& _rProps);
+			   ::com::sun::star::ucb::XContentIdentifier >& Identifier,
+			 const ::vos::ORef< ContentProperties >& _rProps);
 	virtual ~Content();
 
 	// XInterface
Index: ucb/source/ucp/odma/odma_contentcaps.cxx
===================================================================
RCS file: /cvs/ucb/ucb/ucb/source/ucp/odma/odma_contentcaps.cxx,v
retrieving revision 1.5
diff -p -u -r1.5 odma_contentcaps.cxx
--- ucb/source/ucp/odma/odma_contentcaps.cxx	17 Sep 2006 13:57:29 -0000	1.5
+++ ucb/source/ucp/odma/odma_contentcaps.cxx	6 Nov 2006 00:12:08 -0000
@@ -92,7 +92,7 @@ using namespace odma;
 
 // virtual
 uno::Sequence< beans::Property > Content::getProperties(
-             const uno::Reference< star::ucb::XCommandEnvironment > & xEnv )
+             const uno::Reference< star::ucb::XCommandEnvironment > & /* xEnv */ )
 {
 	// @@@ Add additional properties...
 
@@ -193,7 +193,7 @@ uno::Sequence< beans::Property > Content
 //=========================================================================
 // virtual
 uno::Sequence< star::ucb::CommandInfo > Content::getCommands(
-            const uno::Reference< star::ucb::XCommandEnvironment > & xEnv )
+            const uno::Reference< star::ucb::XCommandEnvironment > & /* xEnv */ )
 {
 	// @@@ Add additional commands...
 
Index: ucb/source/ucp/odma/odma_contentprops.hxx
===================================================================
RCS file: /cvs/ucb/ucb/ucb/source/ucp/odma/odma_contentprops.hxx,v
retrieving revision 1.4
diff -p -u -r1.4 odma_contentprops.hxx
--- ucb/source/ucp/odma/odma_contentprops.hxx	9 Sep 2005 15:51:07 -0000	1.4
+++ ucb/source/ucp/odma/odma_contentprops.hxx	6 Nov 2006 00:12:08 -0000
@@ -80,6 +80,7 @@ namespace odma
 		{}
 
 		inline ::rtl::OUString getTitle()		const { return m_sTitle;		}
+		inline ::rtl::OUString getDocumentId()	const { return ::rtl::OStringToOUString( m_sDocumentId, RTL_TEXTENCODING_ASCII_US ); }
 		inline ::rtl::OUString getSavedAsName() const { return m_sSavedAsName;	}
 	};
 	typedef ::std::binary_function< ::vos::ORef<ContentProperties>, ::rtl::OUString,bool> TContentPropertiesFunctorBase;
Index: ucb/source/ucp/odma/odma_datasupplier.cxx
===================================================================
RCS file: /cvs/ucb/ucb/ucb/source/ucp/odma/odma_datasupplier.cxx,v
retrieving revision 1.5
diff -p -u -r1.5 odma_datasupplier.cxx
--- ucb/source/ucp/odma/odma_datasupplier.cxx	17 Sep 2006 13:57:42 -0000	1.5
+++ ucb/source/ucp/odma/odma_datasupplier.cxx	6 Nov 2006 00:12:08 -0000
@@ -63,9 +63,6 @@
 #ifndef ODMA_PROVIDER_HXX
 #include "odma_provider.hxx"
 #endif
-#ifndef ODMA_LIB_HXX
-#include "odma_lib.hxx"
-#endif
 
 using namespace com::sun::star::beans;
 using namespace com::sun::star::lang;
@@ -170,11 +167,11 @@ DataSupplier::~DataSupplier()
 
 //=========================================================================
 // virtual
-::rtl::OUString DataSupplier::queryContentIdentifierString( sal_uInt32 nIndex )
+::rtl::OUString DataSupplier::queryContentIdentifierString( sal_Int32 nIndex )
 {
 	osl::Guard< osl::Mutex > aGuard( m_pImpl->m_aMutex );
 
-	if ( nIndex < m_pImpl->m_aResults.size() )
+	if ( nIndex < (sal_Int32) m_pImpl->m_aResults.size() )
 	{
 		::rtl::OUString aId = m_pImpl->m_aResults[ nIndex ]->aId;
 		if ( aId.getLength() )
@@ -200,11 +197,11 @@ DataSupplier::~DataSupplier()
 //=========================================================================
 // virtual
 Reference< XContentIdentifier > DataSupplier::queryContentIdentifier(
-														sal_uInt32 nIndex )
+														sal_Int32 nIndex )
 {
 	osl::Guard< osl::Mutex > aGuard( m_pImpl->m_aMutex );
 
-	if ( nIndex < m_pImpl->m_aResults.size() )
+	if ( nIndex < (sal_Int32) m_pImpl->m_aResults.size() )
 	{
 		Reference< XContentIdentifier > xId
 								= m_pImpl->m_aResults[ nIndex ]->xId;
@@ -227,11 +224,11 @@ Reference< XContentIdentifier > DataSupp
 
 //=========================================================================
 // virtual
-Reference< XContent > DataSupplier::queryContent( sal_uInt32 nIndex )
+Reference< XContent > DataSupplier::queryContent( sal_Int32 nIndex )
 {
 	osl::Guard< osl::Mutex > aGuard( m_pImpl->m_aMutex );
 
-	if ( nIndex < m_pImpl->m_aResults.size() )
+	if ( nIndex < (sal_Int32) m_pImpl->m_aResults.size() )
 	{
 		Reference< XContent > xContent
 								= m_pImpl->m_aResults[ nIndex ]->xContent;
@@ -262,11 +259,11 @@ Reference< XContent > DataSupplier::quer
 
 //=========================================================================
 // virtual
-sal_Bool DataSupplier::getResult( sal_uInt32 nIndex )
+sal_Bool DataSupplier::getResult( sal_Int32 nIndex )
 {
 	osl::ClearableGuard< osl::Mutex > aGuard( m_pImpl->m_aMutex );
 
-	if ( m_pImpl->m_aResults.size() > nIndex )
+	if ( (sal_Int32) m_pImpl->m_aResults.size() > nIndex )
 	{
 		// Result already present.
 		return sal_True;
@@ -281,10 +278,11 @@ sal_Bool DataSupplier::getResult( sal_uI
 
 	sal_uInt32 nOldCount = m_pImpl->m_aResults.size();
 	sal_Bool bFound = sal_False;
-	sal_uInt32 nPos = nOldCount;
 
 	// @@@ Obtain data and put it into result list...
 /*
+	sal_uInt32 nPos = nOldCount;
+
 	while ( m_pImpl->m_aFolder.next( m_pImpl->m_aIterator ) )
 	{
 		m_pImpl->m_aResults.push_back(
@@ -308,7 +306,7 @@ sal_Bool DataSupplier::getResult( sal_uI
 	ODMSTATUS odm = NODMGetDMS(ODMA_ODMA_REGNAME, lpszDMSList);
 	lpszDMSList[strlen(lpszDMSList)+1] = '\0';
 
-	::rtl::OString sQuery("SELECT ODM_DOCID, ODM_NAME");
+	::rtl::OString sQuery("SELECT ODM_DOCID_LATEST, ODM_NAME");
 	
 	DWORD dwFlags = ODM_SPECIFIC;
 	odm = NODMQueryExecute(ContentProvider::getHandle(), sQuery,dwFlags, lpszDMSList, pQueryId );
@@ -322,7 +320,7 @@ sal_Bool DataSupplier::getResult( sal_uI
 
 	
 	::rtl::OUString sContentType(RTL_CONSTASCII_USTRINGPARAM(ODMA_CONTENT_TYPE));
-	sal_uInt32 nCurrentCount = 0;
+	sal_Int32 nCurrentCount = 0;
 	do
 	{
 		if(nCount >= nMaxCount)
@@ -377,7 +375,7 @@ sal_Bool DataSupplier::getResult( sal_uI
 
 //=========================================================================
 // virtual
-sal_uInt32 DataSupplier::totalCount()
+sal_Int32 DataSupplier::totalCount()
 {
 	osl::ClearableGuard< osl::Mutex > aGuard( m_pImpl->m_aMutex );
 
@@ -412,7 +410,7 @@ sal_uInt32 DataSupplier::totalCount()
 
 //=========================================================================
 // virtual
-sal_uInt32 DataSupplier::currentCount()
+sal_Int32 DataSupplier::currentCount()
 {
 	return m_pImpl->m_aResults.size();
 }
@@ -426,11 +424,11 @@ sal_Bool DataSupplier::isCountFinal()
 
 //=========================================================================
 // virtual
-Reference< XRow > DataSupplier::queryPropertyValues( sal_uInt32 nIndex  )
+Reference< XRow > DataSupplier::queryPropertyValues( sal_Int32 nIndex  )
 {
 	osl::Guard< osl::Mutex > aGuard( m_pImpl->m_aMutex );
 
-	if ( nIndex < m_pImpl->m_aResults.size() )
+	if ( nIndex < (sal_Int32) m_pImpl->m_aResults.size() )
 	{
 		Reference< XRow > xRow = m_pImpl->m_aResults[ nIndex ]->xRow;
 		if ( xRow.is() )
@@ -457,11 +455,11 @@ Reference< XRow > DataSupplier::queryPro
 
 //=========================================================================
 // virtual
-void DataSupplier::releasePropertyValues( sal_uInt32 nIndex )
+void DataSupplier::releasePropertyValues( sal_Int32 nIndex )
 {
 	osl::Guard< osl::Mutex > aGuard( m_pImpl->m_aMutex );
 
-	if ( nIndex < m_pImpl->m_aResults.size() )
+	if ( nIndex < (sal_Int32) m_pImpl->m_aResults.size() )
 		m_pImpl->m_aResults[ nIndex ]->xRow = Reference< XRow >();
 }
 
Index: ucb/source/ucp/odma/odma_datasupplier.hxx
===================================================================
RCS file: /cvs/ucb/ucb/ucb/source/ucp/odma/odma_datasupplier.hxx,v
retrieving revision 1.4
diff -p -u -r1.4 odma_datasupplier.hxx
--- ucb/source/ucp/odma/odma_datasupplier.hxx	9 Sep 2005 15:51:37 -0000	1.4
+++ ucb/source/ucp/odma/odma_datasupplier.hxx	6 Nov 2006 00:12:08 -0000
@@ -49,6 +49,8 @@ class DataSupplier : public ucb::ResultS
 {
 	DataSupplier_Impl* m_pImpl;
 
+	virtual sal_Bool getResult( sal_Int32 nIndex );
+
 public:
 	DataSupplier( const com::sun::star::uno::Reference<
 				  	com::sun::star::lang::XMultiServiceFactory >& rxSMgr,
@@ -56,22 +58,20 @@ public:
 				  sal_Int32 nOpenMode );
 	virtual ~DataSupplier();
 
-	virtual rtl::OUString queryContentIdentifierString( sal_uInt32 nIndex );
+	virtual rtl::OUString queryContentIdentifierString( sal_Int32 nIndex );
 	virtual com::sun::star::uno::Reference<
 				com::sun::star::ucb::XContentIdentifier >
-	queryContentIdentifier( sal_uInt32 nIndex );
+	queryContentIdentifier( sal_Int32 nIndex );
 	virtual com::sun::star::uno::Reference< com::sun::star::ucb::XContent >
-	queryContent( sal_uInt32 nIndex );
-
-	virtual sal_Bool getResult( sal_uInt32 nIndex );
+	queryContent( sal_Int32 nIndex );
 
-	virtual sal_uInt32 totalCount();
-	virtual sal_uInt32 currentCount();
+	virtual sal_Int32 totalCount();
+	virtual sal_Int32 currentCount();
 	virtual sal_Bool isCountFinal();
 
 	virtual com::sun::star::uno::Reference< com::sun::star::sdbc::XRow >
-	queryPropertyValues( sal_uInt32 nIndex  );
-	virtual void releasePropertyValues( sal_uInt32 nIndex );
+	queryPropertyValues( sal_Int32 nIndex  );
+	virtual void releasePropertyValues( sal_Int32 nIndex );
 
 	virtual void close();
 
Index: ucb/source/ucp/odma/odma_lib.cxx
===================================================================
RCS file: /cvs/ucb/ucb/ucb/source/ucp/odma/odma_lib.cxx,v
retrieving revision 1.5
diff -p -u -r1.5 odma_lib.cxx
--- ucb/source/ucp/odma/odma_lib.cxx	17 Sep 2006 13:58:10 -0000	1.5
+++ ucb/source/ucp/odma/odma_lib.cxx	6 Nov 2006 00:12:08 -0000
@@ -44,6 +44,8 @@
 #ifndef _RTL_USTRING_HXX_ 
 #include <rtl/ustring.hxx>
 #endif
+#include <tools/prewin.h>
+#include <tools/postwin.h>
 #ifndef ODMA_LIB_HXX
 #include "odma_lib.hxx"
 #endif
@@ -84,17 +86,18 @@ namespace odma
 
 	sal_Bool LoadFunctions(oslModule _pODMA);
 
-	sal_Bool LoadLibrary()
+	sal_Bool DMSsAvailable()
 	{
 		static sal_Bool bLoaded = sal_False;
-		static oslModule pODMA = NULL;
+		static sal_Bool bBeenHere = sal_False;
+		oslModule pODMA = NULL;
 		
-		if (bLoaded) 
-			return sal_True;
+		if (bBeenHere) 
+			return bLoaded;
+
 		::rtl::OUString sPath;
 	#ifdef WIN
 		sPath = ::rtl::OUString(RTL_CONSTASCII_USTRINGPARAM("ODMA.DLL"));
-		
 	#endif
 	#ifdef WNT
 		sPath = ::rtl::OUString(RTL_CONSTASCII_USTRINGPARAM("ODMA32.DLL"));
@@ -103,11 +106,21 @@ namespace odma
 		sPath = ::rtl::OUString(RTL_CONSTASCII_USTRINGPARAM("libodma.so"));
 	#endif
 
+		bBeenHere = sal_True;
+
 		pODMA = osl_loadModule( sPath.pData,SAL_LOADMODULE_NOW );
 		if( !pODMA)
 			return sal_False;
 
-		return bLoaded = LoadFunctions(pODMA);
+		if (!LoadFunctions(pODMA))
+			return sal_False;
+
+		bLoaded = (NODMGetDMSCount() > 0);
+
+		if (getenv ("NO_ODMA"))
+			bLoaded = sal_False;
+
+		return bLoaded;
 	}
 	// -------------------------------------------------------------------------
 
Index: ucb/source/ucp/odma/odma_lib.hxx
===================================================================
RCS file: /cvs/ucb/ucb/ucb/source/ucp/odma/odma_lib.hxx,v
retrieving revision 1.4
diff -p -u -r1.4 odma_lib.hxx
--- ucb/source/ucp/odma/odma_lib.hxx	9 Sep 2005 15:52:48 -0000	1.4
+++ ucb/source/ucp/odma/odma_lib.hxx	6 Nov 2006 00:12:08 -0000
@@ -35,20 +35,8 @@
 #ifndef ODMA_LIB_HXX
 #define ODMA_LIB_HXX
 
-typedef void	            *LPVOID;
-typedef char				*LPSTR, 
-							*PSTR;
-typedef const char			*LPCSTR;
-typedef unsigned long       DWORD;
-typedef unsigned short      WORD;
-typedef unsigned short      *LPWORD;
-typedef DWORD		        *LPDWORD;
-
-#define WINAPI				__stdcall
-#define FAR
-
 #ifndef ODMA_H
-#include "odma.h"
+#include <odma.h>
 #endif
 
 namespace odma
@@ -215,37 +203,37 @@ namespace odma
 
 	// now we define some macros
 
-	#define NODMRegisterApp(a,b,c,d,e)			(*(pODMRegisterApp))(a,b,c,d,e)
-	#define NODMUnRegisterApp(a)				(*(pODMUnRegisterApp))(a)
-	#define NODMSelectDoc(a,b,c)				(*(pODMSelectDoc))(a,b,c)
-	#define NODMOpenDoc(a,b,c,d)				(*(pODMOpenDoc))(a,b,c,d)
-	#define NODMSaveDoc(a,b,c)					(*(pODMSaveDoc))(a,b,c)
-	#define NODMCloseDoc(a,b,c,d,e,f)			(*(pODMCloseDoc))(a,b,c,d,e,f)
-	#define NODMNewDoc(a,b,c,d,e)				(*(pODMNewDoc))(a,b,c,d,e)
-	#define NODMSaveAs(a,b,c,d,e,f)				(*(pODMSaveAs))(a,b,c,d,e,f)
-	#define NODMActivate(a,b,c)					(*(pODMActivate))(a,b,c)
-	#define NODMGetDocInfo(a,b,c,d,e)			(*(pODMGetDocInfo))(a,b,c,d,e)
-	#define NODMSetDocInfo(a,b,c,d)				(*(pODMSetDocInfo))(a,b,c,d)
-	#define NODMGetDMSInfo(a,b,c,d)				(*(pODMGetDMSInfo))(a,b,c,d)
-	#define NODMGetDMSCount()					(*(pODMGetDMSCount))()
-	#define NODMGetDMSList(a,b)					(*(pODMGetDMSList))(a,b)
-	#define NODMGetDMS(a,b)						(*(pODMGetDMS))(a,b)
-	#define NODMSetDMS(a,b)						(*(pODMSetDMS))(a,b)
-	#define NODMQueryExecute(a,b,c,d,e)			(*(pODMQueryExecute))(a,b,c,d,e)
-	#define NODMQueryGetResults(a,b,c,d,e,f)	(*(pODMQueryGetResults))(a,b,c,d,e,f)
-	#define NODMQueryClose(a,b)					(*(pODMQueryClose))(a,b)
-	#define NODMCloseDocEx(a,b,c,d,e,f,g)		(*(pODMCloseDocEx))(a,b,c,d,e,f,g)
-	#define NODMSaveAsEx(a,b,c,d,e,f,g)			(*(pODMSaveAsEx))(a,b,c,d,e,f,g)
-	#define NODMSaveDocEx(a,b,c,d)				(*(pODMSaveDocEx))(a,b,c,d)
-	#define NODMSelectDocEx(a,b,c,d,e,f)		(*(pODMSelectDocEx))(a,b,c,d,e,f)
-	#define NODMQueryCapability(a,b,c,d,e)		(*(pODMQueryCapability))(a,b,c,d,e)
-	#define NODMSetDocEvent(a,b,c,d,e,f,g)		(*(pODMSetDocEvent))(a,b,c,d,e,f,g)
-	#define NODMGetAlternateContent(a,b,c,d,e)	(*(pODMGetAlternateContent))(a,b,c,d,e)
-	#define NODMSetAlternateContent(a,b,c,d,e)	(*(pODMSetAlternateContent))(a,b,c,d,e)
-	#define NODMGetDocRelation(a,b,c,d,e,f)		(*(pODMGetDocRelation))(a,b,c,d,e,f)
-	#define NODMSetDocRelation(a,b,c,d,e,f)		(*(pODMSetDocRelation))(a,b,c,d,e,f)
+	#define NODMRegisterApp(a,b,c,d,e)			(*(::odma::pODMRegisterApp))(a,b,c,d,e)
+	#define NODMUnRegisterApp(a)				(*(::odma::pODMUnRegisterApp))(a)
+	#define NODMSelectDoc(a,b,c)				(*(::odma::pODMSelectDoc))(a,b,c)
+	#define NODMOpenDoc(a,b,c,d)				(*(::odma::pODMOpenDoc))(a,b,c,d)
+	#define NODMSaveDoc(a,b,c)					(*(::odma::pODMSaveDoc))(a,b,c)
+	#define NODMCloseDoc(a,b,c,d,e,f)			(*(::odma::pODMCloseDoc))(a,b,c,d,e,f)
+	#define NODMNewDoc(a,b,c,d,e)				(*(::odma::pODMNewDoc))(a,b,c,d,e)
+	#define NODMSaveAs(a,b,c,d,e,f)				(*(::odma::pODMSaveAs))(a,b,c,d,e,f)
+	#define NODMActivate(a,b,c)					(*(::odma::pODMActivate))(a,b,c)
+	#define NODMGetDocInfo(a,b,c,d,e)			(*(::odma::pODMGetDocInfo))(a,b,c,d,e)
+	#define NODMSetDocInfo(a,b,c,d)				(*(::odma::pODMSetDocInfo))(a,b,c,d)
+	#define NODMGetDMSInfo(a,b,c,d)				(*(::odma::pODMGetDMSInfo))(a,b,c,d)
+	#define NODMGetDMSCount()					(*(::odma::pODMGetDMSCount))()
+	#define NODMGetDMSList(a,b)					(*(::odma::pODMGetDMSList))(a,b)
+	#define NODMGetDMS(a,b)						(*(::odma::pODMGetDMS))(a,b)
+	#define NODMSetDMS(a,b)						(*(::odma::pODMSetDMS))(a,b)
+	#define NODMQueryExecute(a,b,c,d,e)			(*(::odma::pODMQueryExecute))(a,b,c,d,e)
+	#define NODMQueryGetResults(a,b,c,d,e,f)	(*(::odma::pODMQueryGetResults))(a,b,c,d,e,f)
+	#define NODMQueryClose(a,b)					(*(::odma::pODMQueryClose))(a,b)
+	#define NODMCloseDocEx(a,b,c,d,e,f,g)		(*(::odma::pODMCloseDocEx))(a,b,c,d,e,f,g)
+	#define NODMSaveAsEx(a,b,c,d,e,f,g)			(*(::odma::pODMSaveAsEx))(a,b,c,d,e,f,g)
+	#define NODMSaveDocEx(a,b,c,d)				(*(::odma::pODMSaveDocEx))(a,b,c,d)
+	#define NODMSelectDocEx(a,b,c,d,e,f)		(*(::odma::pODMSelectDocEx))(a,b,c,d,e,f)
+	#define NODMQueryCapability(a,b,c,d,e)		(*(::odma::pODMQueryCapability))(a,b,c,d,e)
+	#define NODMSetDocEvent(a,b,c,d,e,f,g)		(*(::odma::pODMSetDocEvent))(a,b,c,d,e,f,g)
+	#define NODMGetAlternateContent(a,b,c,d,e)	(*(::odma::pODMGetAlternateContent))(a,b,c,d,e)
+	#define NODMSetAlternateContent(a,b,c,d,e)	(*(::odma::pODMSetAlternateContent))(a,b,c,d,e)
+	#define NODMGetDocRelation(a,b,c,d,e,f)		(*(::odma::pODMGetDocRelation))(a,b,c,d,e,f)
+	#define NODMSetDocRelation(a,b,c,d,e,f)		(*(::odma::pODMSetDocRelation))(a,b,c,d,e,f)
 
-	sal_Bool LoadLibrary();
+	sal_Bool DMSsAvailable();
 
 	extern TODMRegisterApp			pODMRegisterApp;
 	extern TODMUnRegisterApp		pODMUnRegisterApp;
Index: ucb/source/ucp/odma/odma_main.cxx
===================================================================
RCS file: /cvs/ucb/ucb/ucb/source/ucp/odma/odma_main.cxx,v
retrieving revision 1.5
diff -p -u -r1.5 odma_main.cxx
--- ucb/source/ucp/odma/odma_main.cxx	17 Sep 2006 13:58:24 -0000	1.5
+++ ucb/source/ucp/odma/odma_main.cxx	6 Nov 2006 00:12:08 -0000
@@ -68,12 +68,12 @@ void _cdecl main( int argc, char * argv[
 		::rtl::OUString* pArguments = new ::rtl::OUString[argc-1];
 		for(int i = 1; i < argc;++i)
 		{
-			pArguments[i] = ::rtl::OUString::createFromAscii(argv[1]);
-			if( pArguments[i].matchIgnoreAsciiCaseAsciiL(RTL_CONSTASCII_STRINGPARAM(ODMA_URL_ODMAID)))
+			pArguments[i-1] = ::rtl::OUString::createFromAscii(argv[i]);
+			if( pArguments[i-1].matchIgnoreAsciiCaseAsciiL(RTL_CONSTASCII_STRINGPARAM(ODMA_URL_ODMAID)))
 			{
 				::rtl::OUString sArgument = ::rtl::OUString(RTL_CONSTASCII_USTRINGPARAM(ODMA_URL_SCHEME ODMA_URL_SHORT "/"));
-				sArgument += pArguments[i];
-				pArguments[i] = sArgument;
+				sArgument += pArguments[i-1];
+				pArguments[i-1] = sArgument;
 			}
 		}
 		{
Index: ucb/source/ucp/odma/odma_provider.cxx
===================================================================
RCS file: /cvs/ucb/ucb/ucb/source/ucp/odma/odma_provider.cxx,v
retrieving revision 1.5
diff -p -u -r1.5 odma_provider.cxx
--- ucb/source/ucp/odma/odma_provider.cxx	17 Sep 2006 13:58:37 -0000	1.5
+++ ucb/source/ucp/odma/odma_provider.cxx	6 Nov 2006 00:12:08 -0000
@@ -96,7 +96,7 @@ ContentProvider::ContentProvider(
 ContentProvider::~ContentProvider()
 {
 	ContentsMap::iterator aIter = m_aContents.begin();
-	for (;aIter != m_aContents.begin() ;++aIter )
+	for (;aIter != m_aContents.end() ;++aIter )
 	{
 		if(aIter->second->m_bIsOpen)
 			closeDocument(aIter->first);
@@ -112,20 +112,7 @@ ODMHANDLE ContentProvider::getHandle() 
 { 
 	if(!m_aOdmHandle)
 	{
-		ODMSTATUS odm = NODMRegisterApp(&m_aOdmHandle,ODM_API_VERSION,ODMA_ODMA_REGNAME,NULL,NULL);
-		switch(odm)
-		{
-		case ODM_SUCCESS:
-			break;
-		case ODM_E_NODMS:
-			break;
-		case ODM_E_CANTINIT:
-			break;
-		case ODM_E_VERSION:
-			break;
-		default:
-			break;
-		}
+		NODMRegisterApp(&m_aOdmHandle,ODM_API_VERSION,ODMA_ODMA_REGNAME,NULL,NULL);
 	}
 	return m_aOdmHandle; 
 }
@@ -194,12 +181,12 @@ uno::Reference< star::ucb::XContent > SA
     rtl::OUString aScheme( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM(ODMA_URL_SCHEME) ) );
 	sal_Int32 nIndex = 0;
 	rtl::OUString sOdma = aScheme.getToken(3,'.',nIndex);
-	rtl::OUString sCanonicURL = Identifier->getContentIdentifier();
 	// check if url starts with odma
     if ( !(Identifier->getContentProviderScheme().equalsIgnoreAsciiCase( aScheme ) || 
 		   Identifier->getContentProviderScheme().equalsIgnoreAsciiCase( sOdma )) )
         throw star::ucb::IllegalIdentifierException();
 
+	rtl::OUString sCanonicURL = Identifier->getContentIdentifier();
 	if(!(	sCanonicURL.matchIgnoreAsciiCaseAsciiL(RTL_CONSTASCII_STRINGPARAM(ODMA_URL_SCHEME_SHORT ODMA_URL_SHORT)) ||
 			sCanonicURL.matchIgnoreAsciiCaseAsciiL(RTL_CONSTASCII_STRINGPARAM(ODMA_URL_SCHEME ODMA_URL_SHORT))))
 		throw star::ucb::IllegalIdentifierException();
@@ -241,23 +228,22 @@ uno::Reference< star::ucb::XContent > SA
 	if( sCanonicURL.matchIgnoreAsciiCaseAsciiL(RTL_CONSTASCII_STRINGPARAM(ODMA_URL_ODMAID)))
 	{// we get an orignal ODMA id so we have to look for the name
 		::rtl::OString sDocId = ::rtl::OUStringToOString(sCanonicURL,RTL_TEXTENCODING_MS_1252);
-		sal_Char* lpszDocName = new sal_Char[ODM_NAME_MAX];
+		sal_Char szDocName[ODM_NAME_MAX];
 		
 		ODMSTATUS odm = NODMGetDocInfo(	getHandle(),
 										const_cast<sal_Char*>(sDocId.getStr()),
 										ODM_NAME,
-										lpszDocName,
+										szDocName,
 										ODM_NAME_MAX
 									);
 		if(odm == ODM_SUCCESS)
 		{
 			aProp = new ContentProperties();
-			aProp->m_sDocumentName = ::rtl::OStringToOUString(rtl::OString(lpszDocName),RTL_TEXTENCODING_ASCII_US);
+			aProp->m_sDocumentName = ::rtl::OStringToOUString(rtl::OString(szDocName),RTL_TEXTENCODING_ASCII_US);
 			aProp->m_sDocumentId   = sDocId;
 			aProp->m_sContentType  = ::rtl::OUString(RTL_CONSTASCII_USTRINGPARAM(ODMA_CONTENT_TYPE));
 			append(aProp);
 		}
-		delete lpszDocName;
 	}
 	else // we got an already fetched name here so look for it
 	{
@@ -315,20 +301,18 @@ void ContentProvider::saveDocument(const
 	ContentsMap::iterator aIter = m_aContents.find(_sDocumentId);
 	if(aIter != m_aContents.end())
 	{
-		sal_Char* lpszDocId = new sal_Char[ODM_DOCID_MAX];
+		sal_Char szDocId[ODM_DOCID_MAX];
 		DWORD dwFlags = ODM_SILENT;
 		ODMSTATUS odm = NODMSaveDocEx(getHandle(),
 									const_cast<sal_Char*>(_sDocumentId.getStr()),
-									lpszDocId,
+									szDocId,
 									&dwFlags);
 		OSL_ENSURE(odm == ODM_SUCCESS,"Could not save document!");
 		if(odm != ODM_SUCCESS)
 		{
-			delete lpszDocId;
 			throw uno::Exception();
 		}
-		aIter->second->m_sDocumentId = rtl::OString(lpszDocId);
-		delete lpszDocId;
+		aIter->second->m_sDocumentId = rtl::OString(szDocId);
 	}
 }
 // -----------------------------------------------------------------------------
@@ -367,80 +351,71 @@ util::DateTime toDateTime(const ::rtl::O
 void ContentProvider::fillDocumentProperties(const ::vos::ORef<ContentProperties>& _rProp)
 {
 	// read some properties from the DMS
-	sal_Char* lpszDocInfo = new sal_Char[ODM_DOCID_MAX];
+	sal_Char szDocInfo[ODM_DOCID_MAX];
 	sal_Char* pDocId = const_cast<sal_Char*>(_rProp->m_sDocumentId.getStr());
 
 	// read the create date of the document
 	ODMSTATUS odm = NODMGetDocInfo(	getHandle(),
 									pDocId,
 									ODM_CREATEDDATE,
-									lpszDocInfo,
+									szDocInfo,
 									ODM_DOCID_MAX);
 	if(odm == ODM_SUCCESS)
-		_rProp->m_aDateCreated = toDateTime(::rtl::OString(lpszDocInfo));
+		_rProp->m_aDateCreated = toDateTime(::rtl::OString(szDocInfo));
 
 	// read the modified date of the document
 	odm = NODMGetDocInfo(	getHandle(),
 							pDocId,
 							ODM_MODIFYDATE,
-							lpszDocInfo,
+							szDocInfo,
 							ODM_DOCID_MAX);
 	if(odm == ODM_SUCCESS)
-		_rProp->m_aDateModified = toDateTime(::rtl::OString(lpszDocInfo));
+		_rProp->m_aDateModified = toDateTime(::rtl::OString(szDocInfo));
 
 	// read the title of the document
 	odm = NODMGetDocInfo(	getHandle(),
 							pDocId,
 							ODM_TITLETEXT,
-							lpszDocInfo,
+							szDocInfo,
 							ODM_DOCID_MAX);
 	if(odm == ODM_SUCCESS)
-		_rProp->m_sTitle = ::rtl::OStringToOUString(rtl::OString(lpszDocInfo),RTL_TEXTENCODING_ASCII_US);
+		_rProp->m_sTitle = ::rtl::OStringToOUString(rtl::OString(szDocInfo),RTL_TEXTENCODING_ASCII_US);
 
 	// read the name of the document
 	odm = NODMGetDocInfo(	getHandle(),
 							pDocId,
 							ODM_NAME,
-							lpszDocInfo,
+							szDocInfo,
 							ODM_DOCID_MAX);
 	if(odm == ODM_SUCCESS)
-		_rProp->m_sDocumentName = ::rtl::OStringToOUString(rtl::OString(lpszDocInfo),RTL_TEXTENCODING_ASCII_US);
+		_rProp->m_sDocumentName = ::rtl::OStringToOUString(rtl::OString(szDocInfo),RTL_TEXTENCODING_ASCII_US);
 
 	// read the author of the document
 	odm = NODMGetDocInfo(	getHandle(),
 							pDocId,
 							ODM_AUTHOR,
-							lpszDocInfo,
+							szDocInfo,
 							ODM_DOCID_MAX);
 	if(odm == ODM_SUCCESS)
-		_rProp->m_sAuthor = ::rtl::OStringToOUString(rtl::OString(lpszDocInfo),RTL_TEXTENCODING_ASCII_US);
+		_rProp->m_sAuthor = ::rtl::OStringToOUString(rtl::OString(szDocInfo),RTL_TEXTENCODING_ASCII_US);
 
 	// read the subject of the document
 	odm = NODMGetDocInfo(	getHandle(),
 							pDocId,
 							ODM_SUBJECT,
-							lpszDocInfo,
+							szDocInfo,
 							ODM_DOCID_MAX);
 	if(odm == ODM_SUCCESS)
-		_rProp->m_sSubject = ::rtl::OStringToOUString(rtl::OString(lpszDocInfo),RTL_TEXTENCODING_ASCII_US);
+		_rProp->m_sSubject = ::rtl::OStringToOUString(rtl::OString(szDocInfo),RTL_TEXTENCODING_ASCII_US);
 
 	// read the keywords of the document
 	odm = NODMGetDocInfo(	getHandle(),
 							pDocId,
 							ODM_KEYWORDS,
-							lpszDocInfo,
+							szDocInfo,
 							ODM_DOCID_MAX);
 	if(odm == ODM_SUCCESS)
-		_rProp->m_sKeywords = ::rtl::OStringToOUString(rtl::OString(lpszDocInfo),RTL_TEXTENCODING_ASCII_US);
-
-/*
-	odm = NODMGetDocInfo(	getHandle(),
-									const_cast<sal_Char*>(_rProp->m_sDocumentId.getStr()),
-									ODM_URL,
-									lpszDocInfo,
-									ODM_DOCID_MAX);
-*/
-	delete lpszDocInfo;
+		_rProp->m_sKeywords = ::rtl::OStringToOUString(rtl::OString(szDocInfo),RTL_TEXTENCODING_ASCII_US);
 }
 // -----------------------------------------------------------------------------
 void ContentProvider::append(const ::vos::ORef<ContentProperties>& _rProp)
@@ -459,23 +434,23 @@ void ContentProvider::append(const ::vos
 	ODMSTATUS odm = NODMGetDMS(ODMA_ODMA_REGNAME, lpszDMSList);
 	if(odm == ODM_SUCCESS)
 	{
-		sal_Char* pQueryId = new sal_Char[ODM_QUERYID_MAX];
+		sal_Char szQueryId[ODM_QUERYID_MAX];
 		lpszDMSList[strlen(lpszDMSList)+1] = '\0';
 
 		::rtl::OString sTitleText(::rtl::OUStringToOString(_sDocumentName,RTL_TEXTENCODING_ASCII_US));
-		::rtl::OString sQuery("SELECT ODM_DOCID, ODM_NAME WHERE ODM_TITLETEXT = '");
+		::rtl::OString sQuery("SELECT ODM_DOCID_LATEST, ODM_NAME WHERE ODM_TITLETEXT = '");
 		sQuery += sTitleText;
 		sQuery += "'";
 		
 		DWORD dwFlags = ODM_SPECIFIC;
-		odm = NODMQueryExecute(getHandle(), sQuery,dwFlags, lpszDMSList, pQueryId );
+		odm = NODMQueryExecute(getHandle(), sQuery,dwFlags, lpszDMSList, szQueryId );
 		if(odm == ODM_SUCCESS)
 		{
 			sal_uInt16 nCount		= 10;
-			sal_uInt16 nMaxCount	= 10;
-			sal_Char* lpszDocId		= new sal_Char[ODM_DOCID_MAX * nMaxCount];
-			sal_Char* lpszDocName	= new sal_Char[ODM_NAME_MAX * nMaxCount];
-			sal_Char* lpszDocInfo	= new sal_Char[ODM_DOCID_MAX];
+			const int nMaxCount		= 10;
+			sal_Char szDocId[ODM_DOCID_MAX * nMaxCount];
+			sal_Char szDocName[ODM_NAME_MAX * nMaxCount];
+			sal_Char szDocInfo[ODM_DOCID_MAX];
 			
 			::rtl::OUString sContentType(RTL_CONSTASCII_USTRINGPARAM(ODMA_CONTENT_TYPE));
 			do
@@ -484,21 +459,21 @@ void ContentProvider::append(const ::vos
 				{
 					// get the result
 					nCount = nMaxCount;
-					odm = NODMQueryGetResults(getHandle(), pQueryId,lpszDocId, lpszDocName, ODM_NAME_MAX, (WORD*)&nCount);
+					odm = NODMQueryGetResults(getHandle(), szQueryId, szDocId, szDocName, ODM_NAME_MAX, (WORD*)&nCount);
 				}
 				if(odm == ODM_SUCCESS)
 					for(sal_uInt16 i = 0; i < nCount; ++i)
 					{
 						odm = NODMGetDocInfo(	getHandle(),
-												&lpszDocId[ODM_DOCID_MAX*i],
+												&szDocId[ODM_DOCID_MAX*i],
 												ODM_TITLETEXT,
-												lpszDocInfo,
+												szDocInfo,
 												ODM_DOCID_MAX);
-						if( odm == ODM_SUCCESS && sTitleText == ::rtl::OString(lpszDocInfo))
+						if( odm == ODM_SUCCESS && sTitleText == ::rtl::OString(szDocInfo))
 						{
 							aReturn = new ContentProperties();
-							aReturn->m_sDocumentName	= ::rtl::OStringToOUString(rtl::OString(&lpszDocName[ODM_NAME_MAX*i]),RTL_TEXTENCODING_ASCII_US);
-							aReturn->m_sDocumentId	= ::rtl::OString(&lpszDocId[ODM_DOCID_MAX*i]);
+							aReturn->m_sDocumentName	= ::rtl::OStringToOUString(rtl::OString(&szDocName[ODM_NAME_MAX*i]),RTL_TEXTENCODING_ASCII_US);
+							aReturn->m_sDocumentId	= ::rtl::OString(&szDocId[ODM_DOCID_MAX*i]);
 							aReturn->m_sContentType	= sContentType;
 							append(aReturn);
 							nCount = 0; // break condition from outer loop
@@ -507,15 +482,10 @@ void ContentProvider::append(const ::vos
 					}
 			}
 			while(nCount > nMaxCount);
-
-			delete lpszDocInfo;
-			delete lpszDocId;
-			delete lpszDocName;
 		}
 
 		// now close the query
-		odm = NODMQueryClose(ContentProvider::getHandle(), pQueryId);
-		delete pQueryId;
+		odm = NODMQueryClose(ContentProvider::getHandle(), szQueryId);
 	}
 	delete lpszDMSList;
 	
@@ -551,33 +521,36 @@ void ContentProvider::append(const ::vos
 	return getContentProperty(_sTitle,aFunc);
 }
 // -----------------------------------------------------------------------------
+::vos::ORef<ContentProperties> ContentProvider::getContentPropertyWithDocumentId(const ::rtl::OUString& _sDocumentId) const
+{
+	ContentPropertiesMemberFunctor aFunc(::std::mem_fun(&ContentProperties::getDocumentId));
+	return getContentProperty(_sDocumentId,aFunc);
+}
+// -----------------------------------------------------------------------------
 ::rtl::OUString ContentProvider::openDoc(const ::vos::ORef<ContentProperties>& _rProp)  throw (::com::sun::star::uno::Exception)
 {
 	OSL_ENSURE(_rProp.isValid(),"No valid content properties!");
 	if(!_rProp->m_bIsOpen)
 	{
-		sal_Char *pFileName = new sal_Char[ODM_FILENAME_MAX];
+		sal_Char szFileName[ODM_FILENAME_MAX];
 		
 		DWORD dwFlag = ODM_MODIFYMODE | ODM_SILENT;
-		ODMSTATUS odm = NODMOpenDoc(getHandle(), dwFlag, const_cast<sal_Char*>(_rProp->m_sDocumentId.getStr()), pFileName);
+		ODMSTATUS odm = NODMOpenDoc(getHandle(), dwFlag, const_cast<sal_Char*>(_rProp->m_sDocumentId.getStr()), szFileName);
 		switch(odm)
 		{
 			case ODM_E_INUSE:
 				dwFlag = ODM_VIEWMODE;
-				if( NODMOpenDoc(getHandle(), dwFlag, const_cast<sal_Char*>(_rProp->m_sDocumentId.getStr()), pFileName) != ODM_SUCCESS)
+				if( NODMOpenDoc(getHandle(), dwFlag, const_cast<sal_Char*>(_rProp->m_sDocumentId.getStr()), szFileName) != ODM_SUCCESS)
 					break;
 				// else run through
 			case ODM_SUCCESS:
-				::osl::FileBase::getFileURLFromSystemPath(::rtl::OStringToOUString(rtl::OString(pFileName),RTL_TEXTENCODING_ASCII_US)
+				::osl::FileBase::getFileURLFromSystemPath(::rtl::OStringToOUString(rtl::OString(szFileName),RTL_TEXTENCODING_ASCII_US)
 															,_rProp->m_sFileURL);
 				_rProp->m_bIsOpen = sal_True;
 				break;
 			default:
-				delete pFileName;
 				throw uno::Exception();  // TODO give a more precise error message here
 		}
-
-		delete pFileName;
 	}
 	return _rProp->m_sFileURL;
 }
Index: ucb/source/ucp/odma/odma_provider.hxx
===================================================================
RCS file: /cvs/ucb/ucb/ucb/source/ucp/odma/odma_provider.hxx,v
retrieving revision 1.4
diff -p -u -r1.4 odma_provider.hxx
--- ucb/source/ucp/odma/odma_provider.hxx	9 Sep 2005 15:53:43 -0000	1.4
+++ ucb/source/ucp/odma/odma_provider.hxx	6 Nov 2006 00:12:09 -0000
@@ -40,6 +40,8 @@
 #ifndef _UCBHELPER_PROVIDERHELPER_HXX
 #include <ucbhelper/providerhelper.hxx>
 #endif
+#include <tools/prewin.h>
+#include <tools/postwin.h>
 #ifndef ODMA_LIB_HXX
 #include "odma_lib.hxx"
 #endif
@@ -60,7 +62,7 @@ namespace odma {
 // UNO service name for the provider. This name will be used by the UCB to
 // create instances of the provider.
 #define ODMA_CONTENT_PROVIDER_SERVICE_NAME \
-				"com.sun.star.ucb.OdmaContentProvider"
+				"com.sun.star.ucb.ODMAContentProvider"
 //	#define ODMA_CONTENT_PROVIDER_SERVICE_NAME_LENGTH	34
 
 // URL scheme. This is the scheme the provider will be able to create
@@ -150,14 +152,21 @@ public:
 	*/
 	::vos::ORef<ContentProperties> queryContentProperty(const ::rtl::OUString& _sDocumentName);
 
-	/** getContentProperty returns the ContentProperties for the first content with that title
+	/** getContentPropertyWithTitle returns the ContentProperties for the first content with that title
 		@param	_sTitle	the title of the document
 
 		@return	the content properties
 	*/
 	::vos::ORef<ContentProperties> getContentPropertyWithTitle(const ::rtl::OUString& _sTitle) const;
 
-	/** getContentProperty returns the ContentProperties for the first content with that SavedAsName
+	/** getContentPropertyWithDocumentId returns the ContentProperties for the first content with that title
+		@param	_sTitle	the title of the document
+
+		@return	the content properties
+	*/
+	::vos::ORef<ContentProperties> getContentPropertyWithDocumentId(const ::rtl::OUString& _sDocumentId) const;
+
+	/** getContentPropertyWithSavedAsName returns the ContentProperties for the first content with that SavedAsName
 		@param	_sSaveAsName	the SavedAsName of the document
 
 		@return	the content properties
Index: ucb/source/ucp/odma/odma_services.cxx
===================================================================
RCS file: /cvs/ucb/ucb/ucb/source/ucp/odma/odma_services.cxx,v
retrieving revision 1.5
diff -p -u -r1.5 odma_services.cxx
--- ucb/source/ucp/odma/odma_services.cxx	17 Sep 2006 13:59:05 -0000	1.5
+++ ucb/source/ucp/odma/odma_services.cxx	6 Nov 2006 00:12:09 -0000
@@ -52,9 +52,6 @@
 #ifndef ODMA_PROVIDER_HXX
 #include "odma_provider.hxx"
 #endif
-#ifndef ODMA_LIB_HXX
-#include "odma_lib.hxx"
-#endif
 
 using namespace rtl;
 using namespace com::sun::star::uno;
@@ -102,14 +99,14 @@ static sal_Bool writeInfo( void * pRegis
 
 //=========================================================================
 extern "C" void SAL_CALL component_getImplementationEnvironment(
-	const sal_Char ** ppEnvTypeName, uno_Environment ** ppEnv )
+	const sal_Char ** ppEnvTypeName, uno_Environment ** /* ppEnv */ )
 {
 	*ppEnvTypeName = CPPU_CURRENT_LANGUAGE_BINDING_NAME;
 }
 
 //=========================================================================
 extern "C" sal_Bool SAL_CALL component_writeInfo(
-	void * pServiceManager, void * pRegistryKey )
+	void * /* pServiceManager */, void * pRegistryKey )
 {
 	return pRegistryKey &&
 
@@ -125,7 +122,7 @@ extern "C" sal_Bool SAL_CALL component_w
 
 //=========================================================================
 extern "C" void * SAL_CALL component_getFactory(
-	const sal_Char * pImplName, void * pServiceManager, void * pRegistryKey )
+	const sal_Char * pImplName, void * pServiceManager, void * /* pRegistryKey */ )
 {
 	void * pRet = 0;
 
@@ -141,10 +138,8 @@ extern "C" void * SAL_CALL component_get
 	if ( ::odma::ContentProvider::getImplementationName_Static().
 				compareToAscii( pImplName ) == 0 )
 	{
-		if(::odma::LoadLibrary())
+		if(::odma::DMSsAvailable())
 			xFactory = ::odma::ContentProvider::createServiceFactory( xSMgr );
-		else
-			OSL_ASSERT(!"Could not load library!");
 	}
 
 	//////////////////////////////////////////////////////////////////////
Index: ucb/source/ucp/odma/ucpodma.xml
===================================================================
RCS file: /cvs/ucb/ucb/ucb/source/ucp/odma/ucpodma.xml,v
retrieving revision 1.3
diff -p -u -r1.3 ucpodma.xml
--- ucb/source/ucp/odma/ucpodma.xml	25 Aug 2003 13:02:22 -0000	1.3
+++ ucb/source/ucp/odma/ucpodma.xml	6 Nov 2006 00:12:09 -0000
@@ -11,7 +11,7 @@
             Ocke Janssen
         </author>
         <name>
-            com.sun.star.comp.ucb.OdmaContentProvider
+            com.sun.star.comp.ucb.ODMAContentProvider
         </name>
         <description>
 	    This component implements a Content Provider for the Universal
dummy line to avoid confusing diff-mode
--- officecfg/registry/data/org/openoffice/ucb/Configuration.xcu	8 Sep 2005 15:07:17 -0000	1.9
+++ officecfg/registry/data/org/openoffice/ucb/Configuration.xcu	13 Mar 2006 11:05:44 -0000
@@ -151,4 +151,15 @@
               </prop>
             </node>
+            <node oor:name="Provider12" oor:op="replace">
+              <prop oor:name="ServiceName">
+                <value>com.sun.star.ucb.ODMAContentProvider</value>
+              </prop>
+              <prop oor:name="URLTemplate">
+                <value>vnd.sun.star.odma</value>
+              </prop>
+              <prop oor:name="Arguments">
+                <value/>
+              </prop>
+            </node>
           </node>
         </node>
dummy line to avoid confusing diff-mode
--- scp2/source/ooo/file_library_ooo.scp	17 Feb 2006 16:52:02 -0000	1.184.2.2
+++ scp2/source/ooo/file_library_ooo.scp	13 Mar 2006 11:07:23 -0000
@@ -2069,4 +2071,6 @@
 SPECIAL_UNO_COMPONENT_LIB_FILE(gid_File_Ucpexpand1, ucpexpand1.uno)
 
+SPECIAL_UNO_COMPONENT_LIB_FILE(gid_File_Ucpodma1, ucpodma1)
+
 #ifndef SYSTEM_HUNSPELL
 
dummy line to avoid confusing diff-mode
--- desktop/source/app/cmdlineargs.cxx	8 Sep 2005 17:05:40 -0000	1.28
+++ desktop/source/app/cmdlineargs.cxx	13 Mar 2006 12:00:25 -0000
@@ -275,4 +282,13 @@
 					else
 					{
+						if( bOpenEvent || bViewEvent || bForceNewEvent || bForceOpenEvent )
+						{
+							if( ::rtl::OUString(aArgStr).matchIgnoreAsciiCaseAsciiL(RTL_CONSTASCII_STRINGPARAM("::ODMA")) )
+							{
+								::rtl::OUString sArg = ::rtl::OUString(RTL_CONSTASCII_USTRINGPARAM("vnd.sun.star.odma:/"));
+								sArg += aArgStr;
+								aArgStr = sArg;
+							}	
+						}
 						// handle this argument as a filename
 						if ( bOpenEvent )
dummy line to avoid confusing diff-mode
--- fpicker/prj/build.lst
+++ fpicker/prj/build.lst
@@ -1,4 +1,5 @@
-fp	fpicker	:	rdbmaker svtools NULL
+fp	fpicker	:	ucb rdbmaker svtools NULL
 fp	fpicker\source\generic				nmake	-	all	fp_generic NULL
 fp	fpicker\source\office				nmake	-	all	fp_office NULL
+fp	fpicker\source\odma				nmake	-	w	fp_odma NULL
 fp	fpicker\source\unx\gnome			nmake	-	u	fp_gnome_filepicker NULL
dummy line to avoid confusing diff-mode
--- fpicker/source/generic/makefile.mk
+++ fpicker/source/generic/makefile.mk
@@ -54,6 +54,7 @@
 SHL1IMPLIB=	i$(TARGET)
 SHL1OBJS=	$(SLOFILES)
 SHL1STDLIBS=\
+	$(ODMA_LIB_LIB) \
 	$(VCLLIB) \
 	$(SVLLIB) \
 	$(CPPUHELPERLIB) \
dummy line to avoid confusing diff-mode
--- fpicker/source/generic/fpicker.cxx
+++ fpicker/source/generic/fpicker.cxx
@@ -51,6 +51,12 @@
 #include "com/sun/star/lang/XMultiComponentFactory.hpp"
 #endif
 
+#ifdef WNT
+#include <tools/prewin.h>
+#include <tools/postwin.h>
+#include <odma_lib.hxx>
+#endif
+
 #ifndef INCLUDED_SVTOOLS_MISCOPT_HXX
 #include "svtools/miscopt.hxx"
 #endif
@@ -75,13 +75,19 @@
  */
 static OUString FilePicker_getSystemPickerServiceName()
 {
+#ifdef UNX
 	OUString aDesktopEnvironment (Application::GetDesktopEnvironment());
 	if (aDesktopEnvironment.equalsIgnoreAsciiCaseAscii ("gnome"))
 		return OUString (RTL_CONSTASCII_USTRINGPARAM ("com.sun.star.ui.dialogs.GtkFilePicker"));
 	else if (aDesktopEnvironment.equalsIgnoreAsciiCaseAscii ("kde"))
 		return OUString (RTL_CONSTASCII_USTRINGPARAM ("com.sun.star.ui.dialogs.KDEFilePicker"));
- 	else
-		return OUString (RTL_CONSTASCII_USTRINGPARAM ("com.sun.star.ui.dialogs.SystemFilePicker"));
+#endif
+#ifdef WNT
+	if (::odma::DMSsAvailable()) {
+		return OUString (RTL_CONSTASCII_USTRINGPARAM ("com.sun.star.ui.dialogs.ODMAFilePicker"));
+	}
+#endif
+	return OUString (RTL_CONSTASCII_USTRINGPARAM ("com.sun.star.ui.dialogs.SystemFilePicker"));
 }
 
 static Reference< css::uno::XInterface > FilePicker_createInstance (
@@ -173,12 +173,18 @@
 static OUString FolderPicker_getSystemPickerServiceName()
 {
 	OUString aDesktopEnvironment (Application::GetDesktopEnvironment());
+#ifdef UNX
 	if (aDesktopEnvironment.equalsIgnoreAsciiCaseAscii ("gnome"))
 		return OUString (RTL_CONSTASCII_USTRINGPARAM ("com.sun.star.ui.dialogs.GtkFolderPicker"));
 	else if (aDesktopEnvironment.equalsIgnoreAsciiCaseAscii ("kde"))
 		return OUString (RTL_CONSTASCII_USTRINGPARAM ("com.sun.star.ui.dialogs.KDEFolderPicker"));
-	else
-		return OUString (RTL_CONSTASCII_USTRINGPARAM ("com.sun.star.ui.dialogs.SystemFolderPicker"));
+#endif
+#ifdef WNT
+	if (::odma::DMSsAvailable()) {
+		return OUString (RTL_CONSTASCII_USTRINGPARAM ("com.sun.star.ui.dialogs.ODMAFolderPicker"));
+	}
+#endif
+	return OUString (RTL_CONSTASCII_USTRINGPARAM ("com.sun.star.ui.dialogs.SystemFolderPicker"));
 }
 
 static Reference< css::uno::XInterface > FolderPicker_createInstance (
diff -ruN fpicker/source/odma/ODMAFilePicker.cxx fpicker/source/odma/ODMAFilePicker.cxx
--- fpicker/source/odma/ODMAFilePicker.cxx	1970-01-01 00:00:00.000000000 +0000
+++ fpicker/source/odma/ODMAFilePicker.cxx	2006-11-03 13:31:25.014750000 +0000
@@ -0,0 +1,565 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+
+// MARKER(update_precomp.py): autogen include statement, do not remove
+#include "precompiled_fpicker.hxx"
+
+#include "ODMAFilePicker.hxx"
+
+#ifndef _TOOLS_DEBUG_HXX
+#include <tools/debug.hxx>
+#endif
+
+#ifndef _COM_SUN_STAR_BEANS_PROPERTYVALUE_HPP_
+#include <com/sun/star/beans/PropertyValue.hpp>
+#endif
+#ifndef _COM_SUN_STAR_BEANS_STRINGPAIR_HPP_
+#include <com/sun/star/beans/StringPair.hpp>
+#endif
+#ifndef  _COM_SUN_STAR_UI_DIALOGS_FILEPREVIEWIMAGEFORMATS_HPP_
+#include <com/sun/star/ui/dialogs/FilePreviewImageFormats.hpp>
+#endif
+#ifndef _COM_SUN_STAR_UI_DIALOGS_EXECUTABLEDIALOGRESULTS_HPP_
+#include <com/sun/star/ui/dialogs/ExecutableDialogResults.hpp>
+#endif
+#ifndef _COM_SUN_STAR_UI_DIALOGS_TEMPLATEDESCRIPTION_HPP_
+#include <com/sun/star/ui/dialogs/TemplateDescription.hpp>
+#endif
+#ifndef _COM_SUN_STAR_UCB_XCOMMANDENVIRONMENT_HPP_
+#include <com/sun/star/ucb/XCommandEnvironment.hpp>
+#endif
+#ifndef  _COM_SUN_STAR_UNO_ANY_HXX_
+#include <com/sun/star/uno/Any.hxx>
+#endif
+#ifndef _COM_SUN_STAR_UNO_SEQUENCE_HXX_
+#include <com/sun/star/uno/Sequence.hxx>
+#endif
+
+#ifndef _COMPHELPER_SEQUENCE_HXX_
+#include <comphelper/sequence.hxx>
+#endif
+#ifndef _CPPUHELPER_TYPEPROVIDER_HXX_
+#include <cppuhelper/typeprovider.hxx>
+#endif
+#ifndef _UCBHELPER_CONTENT_HXX
+#include <ucbhelper/content.hxx>
+#endif
+#ifndef _UNOTOOLS_UCBHELPER_HXX
+#include <unotools/ucbhelper.hxx>
+#endif
+
+#ifndef ODMA_LIB_HXX
+#include <tools/prewin.h>
+#include <tools/postwin.h>
+#include <odma_lib.hxx>
+#endif
+
+// using ----------------------------------------------------------------
+
+using namespace ::com::sun::star::beans;
+using namespace ::com::sun::star::lang;
+using namespace ::com::sun::star::ui::dialogs;
+using namespace ::com::sun::star::ucb;
+using namespace ::com::sun::star::uno;
+using namespace ::com::sun::star::util;
+using namespace ::utl;
+
+//------------------------------------------------------------------------------------
+// class ODMAFilePicker
+//------------------------------------------------------------------------------------
+ODMAFilePicker::ODMAFilePicker( const Reference < XMultiServiceFactory >& xFactory ) :
+	cppu::WeakComponentImplHelper9<
+	  XFilterManager, 
+	  XFilterGroupManager,
+	  XFilePickerControlAccess,
+	  XFilePickerNotifier,
+	  XFilePreview,
+	  XInitialization,
+	  XCancellable,
+	  XEventListener,
+	  XServiceInfo>( m_rbHelperMtx ),
+	m_bMultiSelectionMode( sal_False ),
+	m_aDefaultName( ),
+	m_aFiles( ),
+	m_nDialogKind( OPEN )
+{
+	m_bUseDMS = ::odma::DMSsAvailable();
+	m_xSystemFilePicker = xFactory->createInstance(
+		::rtl::OUString::createFromAscii( "com.sun.star.ui.dialogs.SystemFilePicker" ) );
+}
+
+// XExecutableDialog functions
+
+void SAL_CALL ODMAFilePicker::setTitle( const ::rtl::OUString& aTitle )
+	throw (RuntimeException)
+{
+	Reference< XExecutableDialog > xExecutableDialog( m_xSystemFilePicker, UNO_QUERY );
+	xExecutableDialog->setTitle( aTitle);
+}
+
+sal_Int16 SAL_CALL ODMAFilePicker::execute( )
+	throw (RuntimeException)
+{
+	ODMSTATUS status;
+	ODMHANDLE handle;
+	WORD count = 0;
+	DWORD flags;
+
+	status = NODMRegisterApp( &handle, ODM_API_VERSION, "sodma", NULL, NULL );
+	if (status == ODM_SUCCESS)
+	{
+		if (m_nDialogKind == OPEN)
+		{
+			const int MAXDOCS = 10;
+			char docids[ODM_DOCID_MAX*MAXDOCS+1];
+			WORD docidslen = sizeof( docids );
+
+			flags = 0;
+			if (m_bMultiSelectionMode)
+				count = MAXDOCS;
+			else
+				count = 1;
+			status = NODMSelectDocEx( handle, docids, &docidslen, &count, &flags, NULL );
+			if (status == ODM_SUCCESS)
+			{
+				// GroupWise doesn't set docidslen or count, so
+				// calculate number of document IDs manually 
+				char *p = docids;
+				count = 0;
+				while (*p) {
+					count++;
+					p += strlen( p ) + 1;
+				}
+			}
+			else if (status == ODM_E_NOSUPPORT)
+			{
+				status = NODMSelectDoc( handle, docids, &flags );
+				if (status == ODM_SUCCESS)
+					count = 1;
+			}
+			NODMUnRegisterApp( handle );
+			if (status == ODM_SUCCESS)
+			{
+				rtl::OUString *strings = new rtl::OUString[count];
+				int i;
+				char *p = docids;
+				
+				for (i = 0; i < count; i++) {
+					// Insane API... the first element is a full URI, the rest
+					// are just the "basenames" in the same "directory".
+					if (i == 0)
+						strings[0] = rtl::OUString::createFromAscii( "vnd.sun.star.odma:/" ) + rtl::OUString::createFromAscii( p );
+					else
+						strings[i] = rtl::OUString::createFromAscii( p );
+					p += strlen( p );
+				}
+
+				m_aFiles = Sequence< rtl::OUString >( strings, count );
+				delete[] strings;
+				return ExecutableDialogResults::OK;
+			}
+		}
+		else /* m_nDialogKind == SAVE */
+		{
+			char newdocid[ODM_DOCID_MAX+1];
+			
+			if (m_aDefaultName.getLength() == 0)
+			{
+				char tempdocid[ODM_DOCID_MAX+1];
+
+				status = NODMNewDoc( handle, tempdocid, ODM_SILENT, NULL, NULL );
+				if (status == ODM_SUCCESS)
+					status = NODMSaveAs( handle, tempdocid, newdocid, NULL, NULL, NULL );
+			}
+			else
+			{
+				rtl::OString sDefaultName = rtl::OUStringToOString( m_aDefaultName, RTL_TEXTENCODING_ASCII_US );
+				status = NODMSaveAs( handle,
+									 const_cast<sal_Char*>( sDefaultName.getStr() ),
+									 newdocid, NULL, NULL, NULL );
+			}
+
+			NODMUnRegisterApp( handle );
+			if (status == ODM_SUCCESS)
+			{
+				rtl::OUString s( rtl::OUString::createFromAscii( "vnd.sun.star.odma:/" ) +
+								 rtl::OUString::createFromAscii( newdocid ) );
+				// Create a Content for the odma URL so that
+				// odma::ContentProvider will learn about the DOCID we
+				// just created.
+				ucb::Content content( s, Reference< XCommandEnvironment >() );
+				m_aFiles = Sequence< rtl::OUString >( &s, 1 );
+				return ExecutableDialogResults::OK;
+			}
+		}
+	}
+	if (status == ODM_E_APPSELECT)
+	{
+		m_bUseDMS = sal_False;
+
+		Reference< XExecutableDialog > xExecutableDialog( m_xSystemFilePicker, UNO_QUERY );
+		return xExecutableDialog->execute();
+	}
+
+	// Fallback
+	return ExecutableDialogResults::CANCEL;
+}
+
+// XFilePicker functions
+
+void SAL_CALL ODMAFilePicker::setMultiSelectionMode( sal_Bool bMode )
+	throw( RuntimeException )
+{
+	m_bMultiSelectionMode = bMode;
+
+	Reference< XFilePicker > xFilePicker( m_xSystemFilePicker, UNO_QUERY );
+	xFilePicker->setMultiSelectionMode( bMode );
+}
+
+void SAL_CALL ODMAFilePicker::setDefaultName( const rtl::OUString& aName )
+	throw( RuntimeException )
+{
+	// When editing a document from DMS, and doing Save As, this is
+	// called twice, first with the complete DOCID, the second time
+	// with the "extension" removed. Of course, this is bogus, as
+	// DOCIDs should be treated as opaque strings, they don't have
+	// "extensions".
+
+	// In the GroupWise case a DOCID is like
+	// ::ODMA\GRPWISE\FOO1.BAR.FOO-Bla_bla:12345.12 where the final
+	// dot separates the version number, not an "extension".
+	//
+	// So ignore the second call.
+	//
+	// The second call without "extension" is done if the
+	// XFilePickerControlAccess is set to have auto-extension turned
+	// on. (See sfx2/source/dialog/filedlghelper.cxx:
+	// FileDialogHelper_Impl::implInitializeFileName().) Thus we could
+	// alternatively make sure that a getValue call to get
+	// ExtendedFilePickerElementIds::CHECKBOX_AUTOEXTENSION returns
+	// false. But that might be hard as we don't know in advance
+	// whether the user will click the "use application dialog"
+	// button. If so, we indeed do use auto-extensions.
+	//
+	// Yes, this is ugly, relying on knowing details on how this
+	// function will be called.
+
+	if ( m_aDefaultName.getLength() == 0 )
+		m_aDefaultName = aName;
+
+	Reference< XFilePicker > xFilePicker( m_xSystemFilePicker, UNO_QUERY );
+	xFilePicker->setDefaultName( aName );
+}
+
+void SAL_CALL ODMAFilePicker::setDisplayDirectory( const rtl::OUString& aDirectory )
+    throw( IllegalArgumentException, RuntimeException )
+{
+	m_aDisplayDirectory = aDirectory;
+
+	Reference< XFilePicker > xFilePicker( m_xSystemFilePicker, UNO_QUERY );
+	xFilePicker->setDisplayDirectory( aDirectory );
+}
+
+rtl::OUString SAL_CALL ODMAFilePicker::getDisplayDirectory( )
+	throw( RuntimeException )
+{
+	if (m_bUseDMS)
+		return m_aDisplayDirectory;
+
+	Reference< XFilePicker > xFilePicker( m_xSystemFilePicker, UNO_QUERY );
+	return xFilePicker->getDisplayDirectory();
+}
+
+Sequence< rtl::OUString > SAL_CALL ODMAFilePicker::getFiles( )
+	throw( RuntimeException )
+{
+	if (m_bUseDMS)
+		return m_aFiles;
+
+	Reference< XFilePicker > xFilePicker( m_xSystemFilePicker, UNO_QUERY );
+	return xFilePicker->getFiles();
+}
+
+// XFilePickerControlAccess functions
+
+void SAL_CALL ODMAFilePicker::setValue( sal_Int16 nElementID,
+										sal_Int16 nControlAction,
+										const Any& rValue )
+    throw( RuntimeException )
+{
+	Reference< XFilePickerControlAccess > xFilePickerControlAccess( m_xSystemFilePicker, UNO_QUERY );
+	xFilePickerControlAccess->setValue( nElementID, nControlAction, rValue );
+}
+
+Any SAL_CALL ODMAFilePicker::getValue( sal_Int16 nElementID, sal_Int16 nControlAction )
+    throw( RuntimeException )
+{
+	Reference< XFilePickerControlAccess > xFilePickerControlAccess( m_xSystemFilePicker, UNO_QUERY );
+	return xFilePickerControlAccess->getValue( nElementID, nControlAction );
+}
+
+void SAL_CALL ODMAFilePicker::setLabel( sal_Int16 nLabelID, const rtl::OUString& rValue )
+    throw ( RuntimeException )
+{
+	Reference< XFilePickerControlAccess > xFilePickerControlAccess( m_xSystemFilePicker, UNO_QUERY );
+	xFilePickerControlAccess->setLabel( nLabelID, rValue );
+}
+
+rtl::OUString SAL_CALL ODMAFilePicker::getLabel( sal_Int16 nLabelID )
+    throw ( RuntimeException )
+{
+	Reference< XFilePickerControlAccess > xFilePickerControlAccess( m_xSystemFilePicker, UNO_QUERY );
+	return xFilePickerControlAccess->getLabel( nLabelID );
+}
+
+void SAL_CALL ODMAFilePicker::enableControl( sal_Int16 nElementID, sal_Bool bEnable )
+    throw( RuntimeException )
+{
+	Reference< XFilePickerControlAccess > xFilePickerControlAccess( m_xSystemFilePicker, UNO_QUERY );
+	xFilePickerControlAccess->enableControl( nElementID, bEnable );
+}
+
+// XFilePickerNotifier functions
+
+void SAL_CALL ODMAFilePicker::addFilePickerListener( const Reference< XFilePickerListener >& xListener )
+	throw ( RuntimeException )
+{
+	Reference< XFilePickerNotifier > xFilePickerNotifier( m_xSystemFilePicker, UNO_QUERY );
+	xFilePickerNotifier->addFilePickerListener( xListener );
+}
+
+void SAL_CALL ODMAFilePicker::removeFilePickerListener( const Reference< XFilePickerListener >& xListener )
+	throw ( RuntimeException )
+{
+	Reference< XFilePickerNotifier > xFilePickerNotifier( m_xSystemFilePicker, UNO_QUERY );
+	xFilePickerNotifier->removeFilePickerListener( xListener );
+}
+
+// XFilePreview functions
+
+Sequence< sal_Int16 > SAL_CALL ODMAFilePicker::getSupportedImageFormats( )
+    throw ( RuntimeException )
+{
+	Reference< XFilePreview > xFilePreview( m_xSystemFilePicker, UNO_QUERY );
+	return xFilePreview->getSupportedImageFormats();
+}
+
+sal_Int32 SAL_CALL ODMAFilePicker::getTargetColorDepth( )
+	throw ( RuntimeException )
+{
+	Reference< XFilePreview > xFilePreview( m_xSystemFilePicker, UNO_QUERY );
+	return xFilePreview->getTargetColorDepth();
+}
+
+sal_Int32 SAL_CALL ODMAFilePicker::getAvailableWidth( )
+	throw ( RuntimeException )
+{
+	Reference< XFilePreview > xFilePreview( m_xSystemFilePicker, UNO_QUERY );
+	return xFilePreview->getAvailableWidth();
+}
+
+sal_Int32 SAL_CALL ODMAFilePicker::getAvailableHeight( )
+	throw ( RuntimeException )
+{
+	Reference< XFilePreview > xFilePreview( m_xSystemFilePicker, UNO_QUERY );
+	return xFilePreview->getAvailableHeight();
+}
+
+void SAL_CALL ODMAFilePicker::setImage( sal_Int16 aImageFormat, const Any& rImage )
+    throw ( IllegalArgumentException, RuntimeException )
+{
+	Reference< XFilePreview > xFilePreview( m_xSystemFilePicker, UNO_QUERY );
+	xFilePreview->setImage( aImageFormat, rImage);
+}
+
+sal_Bool SAL_CALL ODMAFilePicker::setShowState( sal_Bool bShowState )
+    throw ( RuntimeException )
+{
+	Reference< XFilePreview > xFilePreview( m_xSystemFilePicker, UNO_QUERY );
+	return xFilePreview->setShowState( bShowState);
+}
+
+sal_Bool SAL_CALL ODMAFilePicker::getShowState( )
+	throw ( RuntimeException )
+{
+	Reference< XFilePreview > xFilePreview( m_xSystemFilePicker, UNO_QUERY );
+	return xFilePreview->getShowState();
+}
+
+// XFilterGroupManager functions
+
+void SAL_CALL ODMAFilePicker::appendFilterGroup( const ::rtl::OUString& sGroupTitle,
+												 const Sequence< StringPair >& aFilters )
+	throw ( IllegalArgumentException, RuntimeException )
+{
+	Reference< XFilterGroupManager > xFilterGroupManager( m_xSystemFilePicker, UNO_QUERY );
+	xFilterGroupManager->appendFilterGroup( sGroupTitle, aFilters );
+}
+
+// XFilterManager functions
+
+void SAL_CALL ODMAFilePicker::appendFilter( const rtl::OUString& aTitle,
+                                           const rtl::OUString& aFilter )
+    throw( IllegalArgumentException, RuntimeException )
+{
+	Reference< XFilterManager > xFilterManager( m_xSystemFilePicker, UNO_QUERY );
+	xFilterManager->appendFilter( aTitle, aFilter );
+}
+
+void SAL_CALL ODMAFilePicker::setCurrentFilter( const rtl::OUString& aTitle )
+    throw( IllegalArgumentException, RuntimeException )
+{
+	Reference< XFilterManager > xFilterManager( m_xSystemFilePicker, UNO_QUERY );
+	xFilterManager->setCurrentFilter( aTitle );
+}
+
+rtl::OUString SAL_CALL ODMAFilePicker::getCurrentFilter( )
+    throw( RuntimeException )
+{
+	Reference< XFilterManager > xFilterManager( m_xSystemFilePicker, UNO_QUERY );
+	return xFilterManager->getCurrentFilter();
+}
+
+// XInitialization functions
+
+void SAL_CALL ODMAFilePicker::initialize( const Sequence< Any >& aArguments )
+	throw ( Exception, RuntimeException )
+{
+	if (aArguments.getLength( ) > 0)
+	{
+		Any aAny = aArguments[0];
+
+		if ( (aAny.getValueType() == ::getCppuType((sal_Int16*)0)) ||
+			 (aAny.getValueType() == ::getCppuType((sal_Int8*)0)) )
+		{
+			sal_Int16 nTemplateId = -1;
+			aAny >>= nTemplateId;
+
+			switch (nTemplateId) {
+			case TemplateDescription::FILEOPEN_SIMPLE:
+			case TemplateDescription::FILEOPEN_LINK_PREVIEW_IMAGE_TEMPLATE:
+			case TemplateDescription::FILEOPEN_PLAY:
+			case TemplateDescription::FILEOPEN_READONLY_VERSION:
+			case TemplateDescription::FILEOPEN_LINK_PREVIEW:
+				m_nDialogKind = OPEN;
+				break;
+			default:
+				m_nDialogKind = SAVE;
+			}
+		}
+	}
+
+	Reference< XInitialization > xInitialization( m_xSystemFilePicker, UNO_QUERY );
+	xInitialization->initialize( aArguments );
+}
+
+// XCancellable functions
+
+void SAL_CALL ODMAFilePicker::cancel( )
+	throw( ::com::sun::star::uno::RuntimeException )
+{
+	Reference< XCancellable > xCancellable( m_xSystemFilePicker, UNO_QUERY );
+	xCancellable->cancel();
+}
+
+// XEventListener functions
+
+void SAL_CALL ODMAFilePicker::disposing( const ::com::sun::star::lang::EventObject& aEvent )
+	throw( RuntimeException )
+{
+	Reference< XEventListener > xEventListener( m_xSystemFilePicker, UNO_QUERY );
+	xEventListener->disposing( aEvent );
+}
+
+// XServiceInfo functions
+
+rtl::OUString SAL_CALL ODMAFilePicker::getImplementationName( )
+	throw( RuntimeException )
+{
+	return impl_getStaticImplementationName();
+}
+
+sal_Bool SAL_CALL ODMAFilePicker::supportsService( const rtl::OUString& sServiceName )
+	throw( RuntimeException )
+{
+    Sequence< rtl::OUString > seqServiceNames = getSupportedServiceNames();
+    const rtl::OUString* pArray = seqServiceNames.getConstArray();
+    for ( sal_Int32 i = 0; i < seqServiceNames.getLength(); i++ )
+	{
+        if ( sServiceName == pArray[i] )
+		{
+            return sal_True ;
+		}
+	}
+    return sal_False ;
+}
+
+Sequence< rtl::OUString > SAL_CALL ODMAFilePicker::getSupportedServiceNames( )
+	throw( RuntimeException )
+{
+	return impl_getStaticSupportedServiceNames();
+}
+
+Sequence< rtl::OUString > ODMAFilePicker::impl_getStaticSupportedServiceNames( )
+{
+    Sequence< rtl::OUString > seqServiceNames( 3 );
+    rtl::OUString* pArray = seqServiceNames.getArray();
+    pArray[0] = rtl::OUString::createFromAscii( "com.sun.star.ui.dialogs.FilePicker" );
+    pArray[1] = rtl::OUString::createFromAscii( "com.sun.star.ui.dialogs.ODMAFilePicker" );
+
+	// Super-ugly, but check the function sal_Bool
+	// lcl_isSystemFilePicker( const Reference< XFilePicker >& ) in
+	// sfx2/source/dialog/filedlghelper.cxx 
+
+    // Lovely undocumented coupling right across abstraction layers,
+    // isn't it?  If we don't claim to implement this "service" (which
+    // is not defined in any IDL file, btw), we get hangs.
+
+    pArray[2] = rtl::OUString::createFromAscii( "com.sun.star.ui.dialogs.SystemFilePicker" );
+    return seqServiceNames ;
+}
+
+rtl::OUString ODMAFilePicker::impl_getStaticImplementationName( )
+{
+    return rtl::OUString::createFromAscii( "com.sun.star.svtools.ODMAFilePicker" );
+}
+
+Reference< XInterface > SAL_CALL ODMAFilePicker::impl_createInstance(
+	const Reference< XComponentContext >& rxContext)
+	throw( Exception )
+{
+	Reference< XMultiServiceFactory > xServiceManager (rxContext->getServiceManager(), UNO_QUERY_THROW);
+	return Reference< XInterface >( *new ODMAFilePicker( xServiceManager ) );
+}
diff -ruN fpicker/source/odma/ODMAFilePicker.hxx fpicker/source/odma/ODMAFilePicker.hxx
--- fpicker/source/odma/ODMAFilePicker.hxx	1970-01-01 00:00:00.000000000 +0000
+++ fpicker/source/odma/ODMAFilePicker.hxx	2006-11-02 01:39:33.483549300 +0000
@@ -0,0 +1,242 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+#ifndef INCLUDED_ODMA_FILEPICKER_HXX
+#define INCLUDED_ODMA_FILEPICKER_HXX
+
+#ifndef _CPPUHELPER_COMPBASE9_HXX_
+#include <cppuhelper/compbase9.hxx>
+#endif
+
+#ifndef  _COM_SUN_STAR_UI_DIALOGS_XFILEPICKERCONTROLACCESS_HPP_
+#include <com/sun/star/ui/dialogs/XFilePickerControlAccess.hpp>
+#endif
+#ifndef  _COM_SUN_STAR_UI_DIALOGS_XFILEPICKERNOTIFIER_HPP_
+#include <com/sun/star/ui/dialogs/XFilePickerNotifier.hpp>
+#endif
+#ifndef  _COM_SUN_STAR_UI_DIALOGS_XFILEPREVIEW_HPP_
+#include <com/sun/star/ui/dialogs/XFilePreview.hpp>
+#endif
+#ifndef  _COM_SUN_STAR_UI_DIALOGS_XFILTERMANAGER_HPP_
+#include <com/sun/star/ui/dialogs/XFilterManager.hpp>
+#endif
+#ifndef _COM_SUN_STAR_UI_DIALOGS_XFILTERGROUPMANAGER_HPP_
+#include <com/sun/star/ui/dialogs/XFilterGroupManager.hpp>
+#endif
+#ifndef _COM_SUN_STAR_UI_DIALOGS_XFILEPICKERLISTENER_HPP_
+#include <com/sun/star/ui/dialogs/XFilePickerListener.hpp>
+#endif
+#ifndef _COM_SUN_STAR_UTIL_XCANCELLABLE_HPP_
+#include <com/sun/star/util/XCancellable.hpp>
+#endif
+#ifndef  _COM_SUN_STAR_LANG_XSERVICEINFO_HPP_
+#include <com/sun/star/lang/XServiceInfo.hpp>
+#endif
+#ifndef _COM_SUN_STAR_UNO_XCOMPONENT_CONTEXT_HPP_
+#include <com/sun/star/uno/XComponentContext.hpp>
+#endif
+
+#ifndef _COM_SUN_STAR_LANG_XINITIALIZATION_HPP_
+#include <com/sun/star/lang/XInitialization.hpp>
+#endif
+
+// class ODMAFilePicker ---------------------------------------------------
+
+class ODMAFilePicker :
+	public cppu::WeakComponentImplHelper9<
+	  ::com::sun::star::ui::dialogs::XFilterManager,
+	  ::com::sun::star::ui::dialogs::XFilterGroupManager,
+	  ::com::sun::star::ui::dialogs::XFilePickerControlAccess,
+	  ::com::sun::star::ui::dialogs::XFilePickerNotifier,
+	  ::com::sun::star::ui::dialogs::XFilePreview,
+	  ::com::sun::star::lang::XInitialization,
+      ::com::sun::star::util::XCancellable,
+	  ::com::sun::star::lang::XEventListener,
+	  ::com::sun::star::lang::XServiceInfo >		
+{
+private:
+	sal_Bool m_bUseDMS;
+	sal_Bool m_bMultiSelectionMode;
+	rtl::OUString m_aDefaultName;
+	rtl::OUString m_aDisplayDirectory;
+	::com::sun::star::uno::Sequence< rtl::OUString > m_aFiles;
+	enum { OPEN, SAVE } m_nDialogKind;
+
+	::com::sun::star::uno::Reference< ::com::sun::star::uno::XInterface > m_xSystemFilePicker;
+
+protected:
+	::osl::Mutex m_rbHelperMtx;
+
+public:
+
+	ODMAFilePicker( const ::com::sun::star::uno::Reference < ::com::sun::star::lang::XMultiServiceFactory >& xFactory );
+
+	// XFilterManager functions
+
+	virtual void SAL_CALL appendFilter( const ::rtl::OUString& aTitle,
+										const ::rtl::OUString& aFilter )
+		throw( ::com::sun::star::lang::IllegalArgumentException, ::com::sun::star::uno::RuntimeException );
+
+	virtual void SAL_CALL setCurrentFilter( const ::rtl::OUString& aTitle )
+		throw( ::com::sun::star::lang::IllegalArgumentException,
+			   ::com::sun::star::uno::RuntimeException );
+
+	virtual ::rtl::OUString SAL_CALL getCurrentFilter( )
+		throw( ::com::sun::star::uno::RuntimeException );
+
+	// XFilterGroupManager functions
+
+	virtual void SAL_CALL appendFilterGroup( const ::rtl::OUString& sGroupTitle,
+											 const ::com::sun::star::uno::Sequence< ::com::sun::star::beans::StringPair >& aFilters )
+		throw (::com::sun::star::lang::IllegalArgumentException,
+			   ::com::sun::star::uno::RuntimeException );
+
+	// XFilePickerControlAccess functions
+
+	virtual void SAL_CALL setValue( sal_Int16 nControlID,
+									sal_Int16 nControlAction,
+									const ::com::sun::star::uno::Any& aValue )
+		throw( ::com::sun::star::uno::RuntimeException );
+
+	virtual ::com::sun::star::uno::Any SAL_CALL getValue( sal_Int16 nControlID,
+											 sal_Int16 nControlAction )
+		throw( ::com::sun::star::uno::RuntimeException );
+
+    virtual void SAL_CALL setLabel( sal_Int16 nControlID,
+									const ::rtl::OUString& aValue )
+		throw ( ::com::sun::star::uno::RuntimeException );
+
+    virtual ::rtl::OUString SAL_CALL getLabel( sal_Int16 nControlID )
+		throw ( ::com::sun::star::uno::RuntimeException );
+
+	virtual void SAL_CALL enableControl( sal_Int16 nControlID,
+										 sal_Bool bEnable )
+		throw( ::com::sun::star::uno::RuntimeException );
+
+	// XFilePicker functions
+
+	virtual void SAL_CALL setMultiSelectionMode( sal_Bool bMode )
+		throw( ::com::sun::star::uno::RuntimeException );
+
+	virtual void SAL_CALL setDefaultName( const ::rtl::OUString& aName )
+		throw( ::com::sun::star::uno::RuntimeException );
+
+	virtual void SAL_CALL setDisplayDirectory( const ::rtl::OUString& aDirectory )
+		throw( ::com::sun::star::lang::IllegalArgumentException,
+			   ::com::sun::star::uno::RuntimeException );
+
+	virtual ::rtl::OUString SAL_CALL getDisplayDirectory( )
+		throw( ::com::sun::star::uno::RuntimeException );
+
+	virtual ::com::sun::star::uno::Sequence< ::rtl::OUString > SAL_CALL getFiles( )
+		throw( ::com::sun::star::uno::RuntimeException );
+
+	// XExecutableDialog functions
+
+	virtual void SAL_CALL setTitle( const ::rtl::OUString& aTitle )
+		throw (::com::sun::star::uno::RuntimeException);
+
+	virtual sal_Int16 SAL_CALL execute(  )
+		throw (::com::sun::star::uno::RuntimeException);
+
+	// XFilePickerNotifier functions
+
+    virtual void SAL_CALL addFilePickerListener( const ::com::sun::star::uno::Reference< ::com::sun::star::ui::dialogs::XFilePickerListener >& xListener )
+		throw ( ::com::sun::star::uno::RuntimeException );
+
+    virtual void SAL_CALL removeFilePickerListener( const ::com::sun::star::uno::Reference< ::com::sun::star::ui::dialogs::XFilePickerListener >& xListener )
+		throw ( ::com::sun::star::uno::RuntimeException );
+
+	// XFilePreview functions
+
+    virtual ::com::sun::star::uno::Sequence< sal_Int16 > SAL_CALL getSupportedImageFormats( )
+		throw ( ::com::sun::star::uno::RuntimeException );
+
+    virtual sal_Int32 SAL_CALL getTargetColorDepth( )
+		throw ( ::com::sun::star::uno::RuntimeException );
+
+    virtual sal_Int32 SAL_CALL getAvailableWidth( )
+		throw ( ::com::sun::star::uno::RuntimeException );
+
+    virtual sal_Int32 SAL_CALL getAvailableHeight( )
+		throw ( ::com::sun::star::uno::RuntimeException );
+
+    virtual void SAL_CALL setImage( sal_Int16 aImageFormat,
+									const ::com::sun::star::uno::Any& aImage )
+		throw ( ::com::sun::star::lang::IllegalArgumentException,
+				::com::sun::star::uno::RuntimeException );
+
+    virtual sal_Bool SAL_CALL setShowState( sal_Bool bShowState )
+		throw ( ::com::sun::star::uno::RuntimeException );
+
+    virtual sal_Bool SAL_CALL getShowState( )
+		throw ( ::com::sun::star::uno::RuntimeException );
+
+	// XInitialization functions
+
+    virtual void SAL_CALL initialize( const ::com::sun::star::uno::Sequence< ::com::sun::star::uno::Any >& aArguments )
+		throw ( ::com::sun::star::uno::Exception, ::com::sun::star::uno::RuntimeException );
+
+	// XCancellable functions
+
+	virtual void SAL_CALL cancel( )
+		throw( ::com::sun::star::uno::RuntimeException );
+
+	// XEventListener functions
+
+	using cppu::WeakComponentImplHelperBase::disposing;
+	virtual void SAL_CALL disposing( const ::com::sun::star::lang::EventObject& aEvent ) 
+		throw( ::com::sun::star::uno::RuntimeException );
+
+	// XServiceInfo functions
+
+    virtual ::rtl::OUString SAL_CALL getImplementationName( )
+		throw( ::com::sun::star::uno::RuntimeException );
+
+    virtual sal_Bool SAL_CALL supportsService( const ::rtl::OUString& sServiceName )
+		throw( ::com::sun::star::uno::RuntimeException );
+
+    virtual ::com::sun::star::uno::Sequence< ::rtl::OUString > SAL_CALL getSupportedServiceNames( )
+		throw( ::com::sun::star::uno::RuntimeException );
+
+	/* Helper for XServiceInfo */
+	static ::com::sun::star::uno::Sequence< ::rtl::OUString > impl_getStaticSupportedServiceNames( );
+	static ::rtl::OUString impl_getStaticImplementationName( );
+
+    /* Helper for registry */
+	static ::com::sun::star::uno::Reference< ::com::sun::star::uno::XInterface > SAL_CALL impl_createInstance ( const ::com::sun::star::uno::Reference< ::com::sun::star::uno::XComponentContext >& rxContext )
+		throw( ::com::sun::star::uno::Exception );
+};
+
+#endif // INCLUDED_ODMA_FILEPICKER_HXX
diff -ruN fpicker/source/odma/ODMAFolderPicker.cxx fpicker/source/odma/ODMAFolderPicker.cxx
--- fpicker/source/odma/ODMAFolderPicker.cxx	1970-01-01 00:00:00.000000000 +0000
+++ fpicker/source/odma/ODMAFolderPicker.cxx	2006-10-30 01:09:51.281250000 +0000
@@ -0,0 +1,203 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+
+// MARKER(update_precomp.py): autogen include statement, do not remove
+#include "precompiled_fpicker.hxx"
+
+#include "ODMAFolderPicker.hxx"
+
+#define _SVSTDARR_STRINGSDTOR
+#include "svtools/svstdarr.hxx"
+
+#ifndef  _COM_SUN_STAR_CONTAINER_XCONTENTENUMERATIONACCESS_HPP_
+#include <com/sun/star/container/XContentEnumerationAccess.hpp>
+#endif
+#ifndef  _COM_SUN_STAR_CONTAINER_XSET_HPP_
+#include <com/sun/star/container/XSet.hpp>
+#endif
+#ifndef  _COM_SUN_STAR_UNO_ANY_HXX_
+#include <com/sun/star/uno/Any.hxx>
+#endif
+#ifndef  _CPPUHELPER_FACTORY_HXX_
+#include <cppuhelper/factory.hxx>
+#endif
+#ifndef _COM_SUN_STAR_BEANS_XPROPERTYSET_HPP_
+#include <com/sun/star/beans/XPropertySet.hpp>
+#endif
+
+#ifndef INCLUDED_SVTOOLS_PATHOPTIONS_HXX
+#include <svtools/pathoptions.hxx>
+#endif
+
+#ifndef ODMA_LIB_HXX
+#include <tools/prewin.h>
+#include <odma_lib.hxx>
+#include <tools/postwin.h>
+#endif
+
+// using ----------------------------------------------------------------
+
+using namespace ::com::sun::star::beans;
+using namespace ::com::sun::star::container;
+using namespace ::com::sun::star::lang;
+using namespace ::com::sun::star::uno;
+
+//------------------------------------------------------------------------------------
+// class ODMAFolderPicker
+//------------------------------------------------------------------------------------
+
+//------------------------------------------------------------------------------------
+ODMAFolderPicker::ODMAFolderPicker( const Reference < XMultiServiceFactory >& xFactory ) :
+	cppu::WeakComponentImplHelper2<
+	  XFolderPicker,
+	  XServiceInfo>( m_rbHelperMtx ),
+	m_bUseDMS( sal_False )
+{
+	m_xInterface = xFactory->createInstance(
+		::rtl::OUString::createFromAscii( "com.sun.star.ui.dialogs.SystemFolderPicker" ) );
+}
+
+// XExecutableDialog functions
+
+void SAL_CALL ODMAFolderPicker::setTitle( const ::rtl::OUString& _rTitle ) throw (RuntimeException)
+{
+	if (m_bUseDMS)
+		return;
+
+	Reference< XExecutableDialog > xExecutableDialog( m_xInterface, UNO_QUERY );
+	xExecutableDialog->setTitle( _rTitle);
+}
+
+sal_Int16 SAL_CALL ODMAFolderPicker::execute( )
+	throw (RuntimeException)
+{
+	if (m_bUseDMS)
+		throw new RuntimeException( );
+
+	Reference< XExecutableDialog > xExecutableDialog( m_xInterface, UNO_QUERY );
+	return xExecutableDialog->execute();
+}
+
+// XFolderPicker functions
+
+void SAL_CALL ODMAFolderPicker::setDisplayDirectory( const ::rtl::OUString& aDirectory )
+    throw( IllegalArgumentException, RuntimeException )
+{
+	if (m_bUseDMS)
+		return;
+
+	Reference< XFolderPicker > xFolderPicker( m_xInterface, UNO_QUERY );
+	xFolderPicker->setDisplayDirectory( aDirectory );
+}
+
+::rtl::OUString SAL_CALL ODMAFolderPicker::getDisplayDirectory( )
+	throw( RuntimeException )
+{
+	if (m_bUseDMS)
+		return rtl::OUString();
+
+	Reference< XFolderPicker > xFolderPicker( m_xInterface, UNO_QUERY );
+	return xFolderPicker->getDisplayDirectory();
+}
+
+::rtl::OUString SAL_CALL ODMAFolderPicker::getDirectory( )
+	throw( RuntimeException )
+{
+	if (m_bUseDMS)
+		return rtl::OUString();
+
+	Reference< XFolderPicker > xFolderPicker( m_xInterface, UNO_QUERY );
+	return xFolderPicker->getDirectory();
+}
+
+void SAL_CALL ODMAFolderPicker::setDescription( const ::rtl::OUString& aDescription )
+    throw( RuntimeException )
+{
+	if (m_bUseDMS)
+		return;
+
+	Reference< XFolderPicker > xFolderPicker( m_xInterface, UNO_QUERY );
+	xFolderPicker->setDescription( aDescription );
+}
+
+// XServiceInfo
+
+::rtl::OUString SAL_CALL ODMAFolderPicker::getImplementationName( )
+	throw( RuntimeException )
+{
+	return impl_getStaticImplementationName();
+}
+
+sal_Bool SAL_CALL ODMAFolderPicker::supportsService( const ::rtl::OUString& sServiceName )
+	throw( RuntimeException )
+{
+    Sequence< ::rtl::OUString > seqServiceNames = getSupportedServiceNames();
+    const ::rtl::OUString* pArray = seqServiceNames.getConstArray();
+    for ( sal_Int32 i = 0; i < seqServiceNames.getLength(); i++ )
+	{
+        if ( sServiceName == pArray[i] )
+		{
+            return sal_True ;
+		}
+	}
+    return sal_False ;
+}
+
+Sequence< ::rtl::OUString > SAL_CALL ODMAFolderPicker::getSupportedServiceNames()
+	throw( RuntimeException )
+{
+	return impl_getStaticSupportedServiceNames();
+}
+
+Sequence< ::rtl::OUString > ODMAFolderPicker::impl_getStaticSupportedServiceNames( )
+{
+    Sequence< ::rtl::OUString > seqServiceNames( 2 );
+    ::rtl::OUString* pArray = seqServiceNames.getArray();
+    pArray[0] = ::rtl::OUString::createFromAscii( "com.sun.star.ui.dialogs.FolderPicker" );
+    pArray[1] = ::rtl::OUString::createFromAscii( "com.sun.star.ui.dialogs.ODMAFolderPicker" );
+    return seqServiceNames ;
+}
+
+::rtl::OUString ODMAFolderPicker::impl_getStaticImplementationName( )
+{
+    return ::rtl::OUString::createFromAscii( "com.sun.star.svtools.ODMAFolderPicker" );
+}
+
+Reference< XInterface > SAL_CALL ODMAFolderPicker::impl_createInstance( const Reference< XComponentContext >& rxContext )
+    throw( Exception )
+{
+	Reference< XMultiServiceFactory > xServiceManager (rxContext->getServiceManager(), UNO_QUERY_THROW);
+	return Reference< XInterface >( *new ODMAFolderPicker( xServiceManager ) );
+}
diff -ruN fpicker/source/odma/ODMAFolderPicker.hxx fpicker/source/odma/ODMAFolderPicker.hxx
--- fpicker/source/odma/ODMAFolderPicker.hxx	1970-01-01 00:00:00.000000000 +0000
+++ fpicker/source/odma/ODMAFolderPicker.hxx	2006-10-26 22:36:34.718125000 +0000
@@ -0,0 +1,118 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+#ifndef INCLUDED_ODMA_FOLDERPICKER_HXX
+#define INCLUDED_ODMA_FOLDERPICKER_HXX
+
+#ifndef _CPPUHELPER_COMPBASE2_HXX_
+#include <cppuhelper/compbase2.hxx>
+#endif
+
+#ifndef  _COM_SUN_STAR_UI_DIALOGS_XFOLDERPICKER_HPP_
+#include <com/sun/star/ui/dialogs/XFolderPicker.hpp>
+#endif
+#ifndef  _COM_SUN_STAR_LANG_XSERVICEINFO_HPP_
+#include <com/sun/star/lang/XServiceInfo.hpp>
+#endif
+#ifndef  _COM_SUN_STAR_LANG_XSINGLESERVICEFACTORY_HPP_
+#include <com/sun/star/lang/XSingleServiceFactory.hpp>
+#endif
+#ifndef _COM_SUN_STAR_LANG_DISPOSEDEXCEPTION_HPP_
+#include <com/sun/star/lang/DisposedException.hpp>
+#endif
+#ifndef _COM_SUN_STAR_UNO_XCOMPONENTCONTEXT_HPP_
+#include <com/sun/star/uno/XComponentContext.hpp>
+#endif
+
+// class ODMAFolderPicker ---------------------------------------------------
+
+class ODMAFolderPicker :
+	public cppu::WeakComponentImplHelper2<
+	  ::com::sun::star::ui::dialogs::XFolderPicker,	
+	  ::com::sun::star::lang::XServiceInfo >
+{
+private:
+	sal_Bool m_bUseDMS;
+
+protected:
+	::osl::Mutex m_rbHelperMtx;
+
+	::com::sun::star::uno::Reference< ::com::sun::star::uno::XInterface > m_xInterface;
+
+public:
+	ODMAFolderPicker( const ::com::sun::star::uno::Reference < ::com::sun::star::lang::XMultiServiceFactory >& xFactory );
+
+	// XFolderPicker functions
+
+	virtual void SAL_CALL setDisplayDirectory( const ::rtl::OUString& aDirectory )
+		throw( ::com::sun::star::lang::IllegalArgumentException, ::com::sun::star::uno::RuntimeException );
+
+	virtual ::rtl::OUString SAL_CALL getDisplayDirectory( )
+		throw( ::com::sun::star::uno::RuntimeException );
+
+    virtual ::rtl::OUString SAL_CALL getDirectory( )
+		throw( ::com::sun::star::uno::RuntimeException );
+
+    virtual void SAL_CALL setDescription( const ::rtl::OUString& aDescription )
+		throw ( ::com::sun::star::uno::RuntimeException );
+
+	// XExecutableDialog functions
+
+	virtual void SAL_CALL setTitle( const ::rtl::OUString& _rTitle )
+		throw (::com::sun::star::uno::RuntimeException);
+
+	virtual sal_Int16 SAL_CALL execute(  )
+		throw (::com::sun::star::uno::RuntimeException);
+
+	// XServiceInfo functions
+
+    virtual ::rtl::OUString SAL_CALL getImplementationName( )
+		throw( ::com::sun::star::uno::RuntimeException );
+
+    virtual sal_Bool SAL_CALL supportsService( const ::rtl::OUString& sServiceName )
+		throw( ::com::sun::star::uno::RuntimeException );
+
+    virtual com::sun::star::uno::Sequence< ::rtl::OUString > SAL_CALL getSupportedServiceNames( )
+		throw( ::com::sun::star::uno::RuntimeException );
+
+	/* Helper for XServiceInfo */
+	static com::sun::star::uno::Sequence< ::rtl::OUString > impl_getStaticSupportedServiceNames( );
+	static ::rtl::OUString impl_getStaticImplementationName( );
+
+	/* Helper for registry */
+	static ::com::sun::star::uno::Reference< com::sun::star::uno::XInterface > SAL_CALL impl_createInstance ( const ::com::sun::star::uno::Reference< com::sun::star::uno::XComponentContext >& rxContext )
+		throw( com::sun::star::uno::Exception );
+};
+
+#endif // INCLUDED_ODMA_FOLDERPICKER_HXX
diff -ruN fpicker/source/odma/exports.map fpicker/source/odma/exports.map
--- fpicker/source/odma/exports.map	1970-01-01 00:00:00.000000000 +0000
+++ fpicker/source/odma/exports.map	2006-10-25 20:34:28.536983200 +0000
@@ -0,0 +1,8 @@
+UDK_3_0_0 {
+    global:
+		component_getImplementationEnvironment;
+		component_writeInfo;
+		component_getFactory;
+	local:
+		*;
+};
diff -ruN fpicker/source/odma/fps_odma.cxx fpicker/source/odma/fps_odma.cxx
--- fpicker/source/odma/fps_odma.cxx	1970-01-01 00:00:00.000000000 +0000
+++ fpicker/source/odma/fps_odma.cxx	2006-10-25 01:19:43.329875000 +0000
@@ -0,0 +1,90 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+
+
+// MARKER(update_precomp.py): autogen include statement, do not remove
+#include "precompiled_fpicker.hxx"
+
+#ifndef _SAL_TYPES_H_
+#include "sal/types.h"
+#endif
+
+#ifndef _CPPUHELPER_IMPLEMENTATIONENTRY_HXX_
+#include "cppuhelper/implementationentry.hxx"
+#endif
+
+#include "ODMAFilePicker.hxx"
+#include "ODMAFolderPicker.hxx"
+
+static cppu::ImplementationEntry g_entries[] =
+{
+	{
+		ODMAFilePicker::impl_createInstance,
+		ODMAFilePicker::impl_getStaticImplementationName,
+		ODMAFilePicker::impl_getStaticSupportedServiceNames,
+		cppu::createSingleComponentFactory, 0, 0
+	},
+	{
+		ODMAFolderPicker::impl_createInstance,
+		ODMAFolderPicker::impl_getStaticImplementationName,
+		ODMAFolderPicker::impl_getStaticSupportedServiceNames,
+		cppu::createSingleComponentFactory, 0, 0
+	},
+	{ 0, 0, 0, 0, 0, 0 }
+};
+
+extern "C"
+{
+SAL_DLLPUBLIC_EXPORT void SAL_CALL component_getImplementationEnvironment (
+	const sal_Char ** ppEnvTypeName, uno_Environment ** /* ppEnv */)
+{
+	*ppEnvTypeName = CPPU_CURRENT_LANGUAGE_BINDING_NAME;
+}
+
+SAL_DLLPUBLIC_EXPORT sal_Bool SAL_CALL component_writeInfo (
+	void * pServiceManager, void * pRegistryKey)
+{
+	return cppu::component_writeInfoHelper (
+		pServiceManager, pRegistryKey, g_entries);
+}
+
+SAL_DLLPUBLIC_EXPORT void * SAL_CALL component_getFactory (
+	const sal_Char * pImplementationName, void * pServiceManager, void * pRegistryKey)
+{
+	return cppu::component_getFactoryHelper (
+		pImplementationName, pServiceManager, pRegistryKey, g_entries);
+}
+
+} // extern "C"
diff -ruN fpicker/source/odma/makefile.mk fpicker/source/odma/makefile.mk
--- fpicker/source/odma/makefile.mk	1970-01-01 00:00:00.000000000 +0000
+++ fpicker/source/odma/makefile.mk	2006-10-30 14:40:05.281250000 +0000
@@ -0,0 +1,79 @@
+#*************************************************************************
+#
+#   OpenOffice.org - a multi-platform office productivity suite
+#
+#   $RCSfile$
+#
+#   $Revision$
+#
+#   last change: $Author$ $Date$
+#
+#   The Contents of this file are made available subject to
+#   the terms of GNU Lesser General Public License Version 2.1.
+#
+#
+#     GNU Lesser General Public License Version 2.1
+#     =============================================
+#     Copyright 2005 by Sun Microsystems, Inc.
+#     901 San Antonio Road, Palo Alto, CA 94303, USA
+#
+#     This library is free software; you can redistribute it and/or
+#     modify it under the terms of the GNU Lesser General Public
+#     License version 2.1, as published by the Free Software Foundation.
+#
+#     This library is distributed in the hope that it will be useful,
+#     but WITHOUT ANY WARRANTY; without even the implied warranty of
+#     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+#     Lesser General Public License for more details.
+#
+#     You should have received a copy of the GNU Lesser General Public
+#     License along with this library; if not, write to the Free Software
+#     Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+#     MA  02111-1307  USA
+#
+#*************************************************************************
+
+PRJ=..$/..
+
+PRJNAME=fpicker
+TARGET=fps_odma
+LIBTARGET=NO
+ENABLE_EXCEPTIONS=TRUE
+GEN_HID=TRUE
+
+# --- Settings -----------------------------------------------------
+
+.INCLUDE :  settings.mk
+DLLPRE=
+
+# --- Files --------------------------------------------------------
+
+SLOFILES=\
+	$(SLO)$/ODMAFilePicker.obj \
+	$(SLO)$/ODMAFolderPicker.obj \
+	$(SLO)$/fps_odma.obj
+
+SHL1TARGET=	$(TARGET).uno
+SHL1IMPLIB=	i$(TARGET)
+SHL1OBJS=	$(SLOFILES)
+SHL1STDLIBS=\
+	$(ODMA_LIB_LIB) \
+	$(SVTOOLLIB) \
+	$(TKLIB) \
+	$(VCLLIB) \
+	$(SVLLIB) \
+	$(UNOTOOLSLIB) \
+	$(TOOLSLIB) \
+	$(UCBHELPERLIB) \
+	$(COMPHELPERLIB) \
+	$(CPPUHELPERLIB) \
+	$(CPPULIB) \
+	$(SALLIB)
+
+SHL1VERSIONMAP=exports.map
+SHL1DEF=	$(MISC)$/$(SHL1TARGET).def
+DEF1NAME=	$(SHL1TARGET)
+
+# --- Targets ------------------------------------------------------
+
+.INCLUDE :	target.mk
dummy line to avoid confusing diff-mode
--- scp2/source/ooo/file_library_ooo.scp
+++ scp2/source/ooo/file_library_ooo.scp
@@ -850,6 +850,16 @@
 #endif
 #endif
 
+#ifdef WNT
+File gid_File_Lib_Fps_ODMA
+    TXT_FILE_BODY;
+    Styles = (PACKED,PATCH);
+    RegistryID = gid_Starregistry_Services_Rdb;
+    Dir = gid_Dir_Program;
+    Name = SPECIAL_COMPONENT_LIB_NAME(fps_odma.uno);
+End
+#endif
+
 SPECIAL_UNO_COMPONENT_LIB_FILE_PATCH( gid_File_Lib_Fps_Office, fps_office.uno )
 SPECIAL_UNO_COMPONENT_LIB_FILE_PATCH( gid_File_Lib_Fpicker, fpicker.uno )
 
dummy line to avoid confusing diff-mode
--- solenv/inc/libs.mk
+++ solenv/inc/libs.mk
@@ -35,6 +35,9 @@
 LIBSMKREV!:="$$Revision$$"
 
 .IF "$(GUI)"=="UNX" || "$(GUI)"=="MAC"
+
+# No ODMA on UNX
+ODMA_LIB_LIB= 
 
 #
 #externe libs in plattform.mk
@@ -279,6 +279,7 @@
 					$(USED_UNO_LIBS)
 
 .ELSE				# "$(GUI)"=="UNX" || "$(GUI)"=="MAC"
+ODMA_LIB_LIB=odma_lib.lib
 AWTLIB*=jawt.lib
 AVMEDIALIB=iavmedia.lib
 ICUINLIB=icuin.lib
dummy line to avoid confusing diff-mode
