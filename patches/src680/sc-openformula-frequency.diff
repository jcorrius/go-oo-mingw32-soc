diff -urp --exclude=CVS --exclude=unxlngi6.pro --exclude=sc.vpj sc.clean/source/core/inc/interpre.hxx sc/source/core/inc/interpre.hxx
--- sc.clean/source/core/inc/interpre.hxx	2008-04-20 15:27:24.000000000 -0400
+++ sc/source/core/inc/interpre.hxx	2008-04-20 15:27:56.000000000 -0400
@@ -657,7 +657,8 @@ void ScStandard();
 void ScSkew();
 void ScMedian();
 void GetSortArray(BYTE nParamCount, double** ppSortArray, SCSIZE& nSize);
-void QuickSort(long nLo, long nHi, double* pSortArr);
+void GetSortArray(BYTE nParamCount, ::std::vector<double>& rSortArray, ::std::vector<long>* pIndexOrder = NULL);
+void QuickSort(::std::vector<double>& rSortArray, ::std::vector<long>* pIndexOrder = NULL);
 void ScModalValue();
 void ScAveDev();
 void ScDevSq();
diff -urp --exclude=CVS --exclude=unxlngi6.pro --exclude=sc.vpj sc.clean/source/core/tool/interpr3.cxx sc/source/core/tool/interpr3.cxx
--- sc.clean/source/core/tool/interpr3.cxx	2008-04-20 15:27:24.000000000 -0400
+++ sc/source/core/tool/interpr3.cxx	2008-04-20 16:58:36.000000000 -0400
@@ -56,6 +56,8 @@
 #include "scmatrix.hxx"
 #include "globstr.hrc"
 
+using ::std::vector;
+
 // STATIC DATA -----------------------------------------------------------
 
 #define SCdEpsilon                1.0E-7
@@ -3063,216 +3065,184 @@ void ScInterpreter::ScTrimMean()
 
 void ScInterpreter::GetSortArray(BYTE nParamCount, double** ppSortArray, SCSIZE& nSize)
 {
-	*ppSortArray = NULL;
-	nSize = 0;
+    // TODO: This is a glue method.  Check all the references of this method,
+    // and rewrite them to use the other GetSortArray method so that we can 
+    // remove this one.
+
+    nSize = 0;
+    vector<double> aSortArray;
+    GetSortArray(nParamCount, aSortArray);
+    if (aSortArray.empty())
+        return;
 
-	USHORT SaveSP = sp;
-	SCSIZE rValCount = 0;
-	ScAddress aAdr;
-	ScRange aRange;
-    BYTE nParam;
-	for (nParam = 0; nParam < nParamCount; nParam++)
-	{
-		switch (GetStackType())
-		{
-			case svDouble :
-                PopDouble();
-				rValCount++;
+    nSize = aSortArray.size();
+    *ppSortArray = new double[nSize];
+    double* pSortArray = *ppSortArray;
+    for (SCSIZE i = 0; i < nSize; ++i)
+        pSortArray[i] = aSortArray[i];
+}
+
+void ScInterpreter::GetSortArray(BYTE nParamCount, vector<double>& rSortArray, vector<long>* pIndexOrder)
+{
+    for (BYTE nParam = 0; nParam < nParamCount; ++nParam)
+    {
+        switch (GetStackType())
+        {
+            case svDouble:
+                rSortArray.push_back(GetDouble());
             break;
-			case svSingleRef :
-			{
-				PopSingleRef( aAdr );
-				ScBaseCell* pCell = GetCell( aAdr );
-				if (HasCellValueData(pCell))
-					rValCount++;
-			}
-			break;
-			case svDoubleRef :
-			{
-				PopDoubleRef( aRange );
-				USHORT nErr = 0;
-				double nCellVal;
-				ScValueIterator aValIter(pDok, aRange);
-				if (aValIter.GetFirst(nCellVal, nErr))
-				{
-					rValCount++;
-					SetError(nErr);
-					while ((nErr == 0) && aValIter.GetNext(nCellVal, nErr))
-						rValCount++;
-					SetError(nErr);
-				}
-			}
-			break;
-			case svMatrix :
-			{
-				ScMatrixRef pMat = PopMatrix();
-				if (pMat)
-				{
-                    SCSIZE nCount = pMat->GetElementCount();
-					if (pMat->IsNumeric())
-                        rValCount += nCount;
-					else
-					{
-                        for (SCSIZE i = 0; i < nCount; i++)
-                            if (!pMat->IsString(i))
-                                rValCount++;
-					}
-				}
-			}
-			break;
-			default :
-				SetError(errIllegalParameter);
-			break;
-		}
-	}
-	if (rValCount > MAX_ANZ_DOUBLE_FOR_SORT || nGlobalError)
-	{
-		SetError(errStackOverflow);
-		return;
-	}
-	else if (rValCount == 0)
-	{
-		SetNoValue();
-		return;
-	}
-	*ppSortArray = new double[rValCount];
-	double* pSortArray = *ppSortArray;
-	if (!*ppSortArray)
-	{
-		rValCount = 0;
-		SetError(errStackOverflow);
-		return;
-	}
-	sp = SaveSP;
-	SCSIZE nIndex = 0;
-	for (nParam = 0; nParam < nParamCount; nParam++)
-	{
-		switch (GetStackType())
-		{
-			case svDouble :
-				pSortArray[nIndex] = GetDouble();
-				nIndex++;
-				break;
-			case svSingleRef :
-			{
-				PopSingleRef( aAdr );
-				ScBaseCell* pCell = GetCell( aAdr );
-				if (HasCellValueData(pCell))
-				{
-					pSortArray[nIndex] = GetCellValue( aAdr, pCell );
-					nIndex++;
-				}
-			}
-			break;
-			case svDoubleRef :
-			{
-				PopDoubleRef( aRange );
-				USHORT nErr;
-				double nCellVal;
-				ScValueIterator aValIter(pDok, aRange);
-				if (aValIter.GetFirst(nCellVal, nErr))
-				{
-					pSortArray[nIndex] = nCellVal;
-					nIndex++;
-					while (aValIter.GetNext(nCellVal, nErr))
-					{
-						pSortArray[nIndex] = nCellVal;
-						nIndex++;
-					}
-				}
-			}
-			break;
-			case svMatrix :
-			{
-				ScMatrixRef pMat = PopMatrix();
-				if (pMat)
-				{
-                    SCSIZE nCount = pMat->GetElementCount();
-					if (pMat->IsNumeric())
-					{
-                        for (SCSIZE i = 0; i < nCount; i++)
-                        {
-                            pSortArray[nIndex] = pMat->GetDouble(i);
-                            nIndex++;
-                        }
-					}
-					else
-					{
-                        for (SCSIZE i = 0; i < nCount; i++)
-                            if (!pMat->IsString(i))
-							{
-                                pSortArray[nIndex] = pMat->GetDouble(i);
-								nIndex++;
-							}
-					}
-				}
-			}
-			break;
-			default : SetError(errIllegalParameter); break;
-		}
-	}
-	DBG_ASSERT(nIndex == rValCount,"nIndex != rValCount");
-	if (nGlobalError == 0)
-	{
-		double fVal;
-		SCSIZE nInd;
-		for (SCSIZE i = 0; (i + 4) <= rValCount-1; i += 4)
-		{
-			nInd = rand() % (int) (rValCount-1);
-			fVal = pSortArray[i];
-			pSortArray[i] = pSortArray[nInd];
-			pSortArray[nInd] = fVal;
-		}
-		QuickSort(0, static_cast<long>(rValCount)-1, pSortArray);
-	}
-	nSize = rValCount;
+            case svSingleRef:
+            {
+                ScAddress aAddr;
+                PopSingleRef(aAddr);
+                ScBaseCell* pCell = GetCell(aAddr);
+                if (HasCellValueData(pCell))
+                    rSortArray.push_back(GetCellValue(aAddr, pCell));
+            }
+            break;
+            case svDoubleRef :
+            {
+                ScRange aRange;
+                PopDoubleRef(aRange);
+                if (!aRange.IsValid())
+                    break;
+
+                aRange.Justify();
+                SCSIZE nCellCount = aRange.aEnd.Col() - aRange.aStart.Col() + 1;
+                nCellCount *= aRange.aEnd.Row() - aRange.aStart.Row() + 1;
+                rSortArray.reserve(rSortArray.size() + nCellCount);
+
+                USHORT nErr = 0;
+                double fCellVal;
+                ScValueIterator aValIter(pDok, aRange);
+                if (aValIter.GetFirst(fCellVal, nErr))
+                {
+                    rSortArray.push_back(fCellVal);
+                    SetError(nErr);
+                    while (nErr == 0 && aValIter.GetNext(fCellVal, nErr))
+                        rSortArray.push_back(fCellVal);
+                    SetError(nErr);
+                }
+            }
+            break;
+            case svMatrix :
+            {
+                ScMatrixRef pMat = PopMatrix();
+                if (!pMat)
+                    break;
+
+                SCSIZE nCount = pMat->GetElementCount();
+                rSortArray.reserve(rSortArray.size() + nCount);
+                if (pMat->IsNumeric())
+                {
+                    for (SCSIZE i = 0; i < nCount; ++i)
+                        rSortArray.push_back(pMat->GetDouble(i));
+                }
+                else
+                {
+                    for (SCSIZE i = 0; i < nCount; ++i)
+                        if (!pMat->IsString(i))
+                            rSortArray.push_back(pMat->GetDouble(i));
+                }
+            }
+            break;
+            default : 
+                SetError(errIllegalParameter); 
+                return;
+        }
+    }
+
+    if (rSortArray.size() > MAX_ANZ_DOUBLE_FOR_SORT || nGlobalError)
+    {
+        SetError(errStackOverflow);
+        return;
+    }
+
+    if (rSortArray.empty())
+    {
+        SetNoValue();
+        return;
+    }
+
+    if (nGlobalError == 0)
+        QuickSort(rSortArray, pIndexOrder);
 }
 
-void ScInterpreter::QuickSort(long nLo, long nHi, double* pSortArray)
+static void lcl_QuickSort(long nLo, long nHi, vector<double>& rSortArray, vector<long>* pIndexOrder)
 {
-	if (nHi - nLo == 1)
-	{
-		if (pSortArray[nLo] > pSortArray[nHi])
-		{
-			double fVal;
-			fVal = pSortArray[nLo];
-			pSortArray[nLo] = pSortArray[nHi];
-			pSortArray[nHi] = fVal;
-		}
-	}
-	else
-	{
-		long ni = nLo;
-		long nj = nHi;
-		do
-		{
-			while (ni <= nHi && pSortArray[ni]  < pSortArray[nLo]) ni++;
-			while (nj >= nLo && pSortArray[nLo] < pSortArray[nj])  nj--;
-			if (ni <= nj)
-			{
-				if (ni != nj)
-				{
-					double fVal;
-					fVal = pSortArray[ni];
-					pSortArray[ni] = pSortArray[nj];
-					pSortArray[nj] = fVal;
-				}
-				ni++;
-				nj--;
-			}
-		}
-		while (ni < nj);
-		if ((nj - nLo) < (nHi - ni))
-		{
-			if (nLo < nj) QuickSort(nLo, nj, pSortArray);
-			if (ni < nHi) QuickSort(ni, nHi, pSortArray);
-		}
-		else
-		{
-			if (ni < nHi) QuickSort(ni, nHi, pSortArray);
-			if (nLo < nj) QuickSort(nLo, nj, pSortArray);
-		}
-	}
+    // If pIndexOrder is not NULL, we assume rSortArray.size() == pIndexOrder->size().
+
+    using ::std::swap;
+
+    if (nHi - nLo == 1)
+    {
+        if (rSortArray[nLo] > rSortArray[nHi])
+        {
+            swap(rSortArray[nLo],  rSortArray[nHi]);
+            if (pIndexOrder)
+                swap(pIndexOrder->at(nLo), pIndexOrder->at(nHi));
+        }
+        return;
+    }
+
+    long ni = nLo;
+    long nj = nHi;
+    do
+    {
+        while (ni <= nHi && rSortArray[ni]  < rSortArray[nLo]) ni++;
+        while (nj >= nLo && rSortArray[nLo] < rSortArray[nj])  nj--;
+        if (ni <= nj)
+        {
+            if (ni != nj)
+            {
+                swap(rSortArray[ni],  rSortArray[nj]);
+                if (pIndexOrder)
+                    swap(pIndexOrder->at(ni), pIndexOrder->at(nj));
+            }
+
+            ++ni;
+            --nj;
+        }
+    }
+    while (ni < nj);
+
+    if ((nj - nLo) < (nHi - ni))
+    {
+        if (nLo < nj) lcl_QuickSort(nLo, nj, rSortArray, pIndexOrder);
+        if (ni < nHi) lcl_QuickSort(ni, nHi, rSortArray, pIndexOrder);
+    }
+    else
+    {
+        if (ni < nHi) lcl_QuickSort(ni, nHi, rSortArray, pIndexOrder);
+        if (nLo < nj) lcl_QuickSort(nLo, nj, rSortArray, pIndexOrder);
+    }
+}
+
+void ScInterpreter::QuickSort(vector<double>& rSortArray, vector<long>* pIndexOrder)
+{
+    size_t n = rSortArray.size();
+
+    if (pIndexOrder)
+    {
+        pIndexOrder->clear();
+        pIndexOrder->reserve(n);
+        for (size_t i = 0; i < n; ++i)
+            pIndexOrder->push_back(static_cast<long>(i));
+    }
+
+    if (n < 2)
+        return;
+
+    size_t nValCount = rSortArray.size();
+    for (size_t i = 0; (i + 4) <= nValCount-1; i += 4)
+    {
+        size_t nInd = rand() % (int) (nValCount-1);
+        ::std::swap( rSortArray[i], rSortArray[nInd]);
+        if (pIndexOrder)
+            ::std::swap( pIndexOrder->at(i), pIndexOrder->at(nInd));
+    }
+
+    lcl_QuickSort(0, n-1, rSortArray, pIndexOrder);
 }
 
 void ScInterpreter::ScRank()
diff -urp --exclude=CVS --exclude=unxlngi6.pro --exclude=sc.vpj sc.clean/source/core/tool/interpr5.cxx sc/source/core/tool/interpr5.cxx
--- sc.clean/source/core/tool/interpr5.cxx	2008-04-20 15:27:24.000000000 -0400
+++ sc/source/core/tool/interpr5.cxx	2008-04-20 16:07:06.000000000 -0400
@@ -63,6 +63,10 @@
 #include "globstr.hrc"
 #include "cellkeytranslator.hxx"
 
+#include <vector>
+
+using ::std::vector;
+
 const double fInvEpsilon = 1.0E-7;
 
 // -----------------------------------------------------------------------
@@ -2272,51 +2276,52 @@ void ScInterpreter::ScFrequency()
 	if ( !MustHaveParamCount( GetByte(), 2 ) )
 		return;
 
-	double* pSortArray1 = NULL;
-	SCSIZE nSize1 = 0;
-	GetSortArray(1, &pSortArray1, nSize1);
-	if (nGlobalError)
-		SetNoValue();
-	double* pSortArray2 = NULL;
-	SCSIZE nSize2 = 0;
-	GetSortArray(1, &pSortArray2, nSize2);
-	if (!pSortArray2 || nSize2 == 0 || nGlobalError)
-	{
-		if (pSortArray1)
-			delete pSortArray1;
-		if (pSortArray2)
-			delete pSortArray2;
-		SetNoValue();
-		return;
-	}
-	ScMatrixRef pResMat = GetNewMat( 1, nSize1+1);
-	if (!pResMat)
-	{
-		if (pSortArray1)
-			delete pSortArray1;
-		if (pSortArray2)
-			delete pSortArray2;
-		PushError();
-		return;
-	}
+    vector<double>  aBinArray;
+    vector<long>    aBinIndexOrder;
+
+    GetSortArray(1, aBinArray, &aBinIndexOrder);
+    SCSIZE nBinSize = aBinArray.size();
+    if (nGlobalError)
+    {
+        SetNoValue();
+        return;
+    }
+
+    vector<double>  aDataArray;
+    GetSortArray(1, aDataArray);
+    SCSIZE nDataSize = aDataArray.size();
+
+    if (aDataArray.empty() || nGlobalError)
+    {
+        SetNoValue();
+        return;
+    }
+    ScMatrixRef pResMat = GetNewMat(1, nBinSize+1);
+    if (!pResMat)
+    {
+        PushError();
+        return;
+    }
+
+    if (nBinSize != aBinIndexOrder.size())
+    {
+        PushError();
+        return;
+    }
 
 	SCSIZE j;
 	SCSIZE i = 0;
-	for (j = 0; j < nSize1; j++)
+    for (j = 0; j < nBinSize; ++j)
 	{
 		SCSIZE nCount = 0;
-		while (i < nSize2 && pSortArray2[i] <= pSortArray1[j])
-		{
-			nCount++;
-			i++;
-		}
-        pResMat->PutDouble((double) nCount, j);
-	}
-    pResMat->PutDouble((double) (nSize2-i), j);
-	if (pSortArray1)
-		delete pSortArray1;
-	if (pSortArray2)
-		delete pSortArray2;
+        while (i < nDataSize && aDataArray[i] <= aBinArray[j])
+        {
+            ++nCount;
+            ++i;
+        }
+        pResMat->PutDouble(static_cast<double>(nCount), aBinIndexOrder[j]);
+    }
+    pResMat->PutDouble(static_cast<double>(nDataSize-i), j);
 	PushMatrix(pResMat);
 }
 
