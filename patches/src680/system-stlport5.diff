--- sal/inc/internal/allocator.hxx.orig	2006-03-27 21:07:18.000000000 +0200
+++ sal/inc/internal/allocator.hxx	2006-03-27 21:08:06.000000000 +0200
@@ -171,6 +171,7 @@
 
 } /* namespace sal */
 
+#if STLPORT_VERSION < 500
 //######################################################
 /* REQUIRED BY STLPort (see stlport '_alloc.h'): 
    Hack for compilers that do not support member 
@@ -184,4 +185,5 @@
 	}
 }
 
+#endif /* STLPORT_VERSION < 500 */
 #endif /* INCLUDED_SAL_INTERNAL_ALLOCATOR_HXX */
--- store/source/storbase.cxx.orig	2006-03-27 21:09:31.000000000 +0200
+++ store/source/storbase.cxx	2006-03-27 21:10:51.000000000 +0200
@@ -907,6 +907,7 @@
 	return false;
 }
 
+#if STLPORT_VERSION < 500
 //----------------------------------------------------------------------------
 // see stlport '_alloc.h' comments why old compilers require the hack below.
 //----------------------------------------------------------------------------
@@ -921,6 +922,7 @@
 	}
 }
 #endif /* __STL_MEMBER_TEMPLATE_CLASSES */
+#endif /* STLPORT_VERSION < 500 */
 
 /*========================================================================
  *
--- connectivity/source/drivers/mdb/mdb_allocator.hxx.orig	2006-03-27 21:12:10.000000000 +0200
+++ connectivity/source/drivers/mdb/mdb_allocator.hxx	2006-03-27 21:12:50.000000000 +0200
@@ -200,6 +200,7 @@
 
 } /* namespace sal */
 
+#if STLPORT_VERSION < 500
 //######################################################
 /* REQUIRED BY STLPort (see stlport '_alloc.h'): 
    Hack for compilers that do not support member 
@@ -214,4 +215,5 @@
 	}
 }
 
+#endif /* STLPORT_VERSION < 500 */
 #endif /* INCLUDED_SAL_INTERNAL_ALLOCATOR_HXX */
--- configmgr/source/api/confeventhelpers.cxx.orig	2006-03-25 19:17:41.000000000 +0100
+++ configmgr/source/api/confeventhelpers.cxx	2006-03-25 20:57:50.000000000 +0100
@@ -105,7 +105,7 @@
 		Pathes const& pathes = iter->pathList();
 
 		// first clear the Path Map
-		for(Pathes::iterator itPath = pathes.begin(); itPath != pathes.end(); ++itPath)
+		for(Pathes::const_iterator itPath = pathes.begin(); itPath != pathes.end(); ++itPath)
 		{
 			typedef PathMap::iterator PMIter;
 			typedef std::pair<PMIter, PMIter> PMRange;
--- configmgr/source/tree/cmtree.cxx.orig	2006-03-25 20:52:15.000000000 +0100
+++ configmgr/source/tree/cmtree.cxx	2006-03-25 21:16:07.000000000 +0100
@@ -91,7 +91,7 @@
 // ------------------------ ChildListSet implementations ------------------------
     ChildListSet::ChildListSet(ChildListSet const& aSet, treeop::DeepChildCopy)
 	{
-		for(ChildList::iterator it = aSet.GetSet().begin();
+		for(ChildList::const_iterator it = aSet.GetSet().begin();
 			it != aSet.GetSet().end();
 			++it)
         {
@@ -258,7 +258,7 @@
 		}
 #endif
 
-		ChildList::iterator it = m_aChildren.GetSet().find(&searchObj);
+		ChildList::const_iterator it = m_aChildren.GetSet().find(&searchObj);
 		if (it == m_aChildren.GetSet().end())
 			return NULL;
 		else
@@ -278,7 +278,7 @@
 	::std::auto_ptr<INode> Subtree::removeChild(OUString const& aName)
 	{
 		SearchNode searchObj(aName);
-		ChildList::const_iterator it = m_aChildren.GetSet().find(&searchObj);
+		ChildList::iterator it = m_aChildren.GetSet().find(&searchObj);
 
 		::std::auto_ptr<INode> aReturn;
 		if (m_aChildren.GetSet().end() != it)
--- tools/source/generic/line.cxx.orig	2006-03-25 21:28:09.000000000 +0100
+++ tools/source/generic/line.cxx	2006-03-25 21:29:28.000000000 +0100
@@ -61,7 +61,12 @@
 
 double Line::GetLength() const
 {
+#if STLPORT_VERSION < 500
     return hypot( maStart.X() - maEnd.X(), maStart.Y() - maEnd.Y() );
+#else
+// STLport5 hypot does not accept long int's
+    return hypot( (long double)(maStart.X() - maEnd.X()), (long double)( maStart.Y() - maEnd.Y()) );
+#endif
 }
 
 // ------------------------------------------------------------------------
--- vcl/source/gdi/jobset.cxx.orig	2006-03-25 21:50:33.000000000 +0100
+++ vcl/source/gdi/jobset.cxx	2006-03-26 16:04:55.000000000 +0200
@@ -285,6 +285,18 @@
 
 	ImplJobSetup* pData1 = mpData;
 	ImplJobSetup* pData2 = rJobSetup.mpData;
+
+#if STLPORT_VERSION >= 500
+//FIXME: alternative map compare?
+	::std::hash_map< ::rtl::OUString, ::rtl::OUString, ::rtl::OUStringHash >::const_iterator it, rit;
+	for ( it = pData1->maValueMap.begin() ; it != pData1->maValueMap.end() ; it++ )
+	{
+		rit = pData2->maValueMap.find( it->first );
+		if ( ( rit == pData2->maValueMap.end() ) || ( it->second != rit->second ) )
+			return FALSE;
+	}
+#endif
+
 	if ( (pData1->mnSystem			== pData2->mnSystem)				&&
 		 (pData1->maPrinterName 	== pData2->maPrinterName)			&&
 		 (pData1->maDriver			== pData2->maDriver)				&&
@@ -294,8 +306,11 @@
 		 (pData1->mnPaperWidth		== pData2->mnPaperWidth)			&&
 		 (pData1->mnPaperHeight 	== pData2->mnPaperHeight)			&&
 		 (pData1->mnDriverDataLen	== pData2->mnDriverDataLen) 		&&
-		 (memcmp( pData1->mpDriverData, pData2->mpDriverData, pData1->mnDriverDataLen ) == 0)															&&
-		 (pData1->maValueMap		== pData2->maValueMap)
+		 (memcmp( pData1->mpDriverData, pData2->mpDriverData, pData1->mnDriverDataLen ) == 0)
+#if STLPORT_VERSION < 500
+// STLport5 cannot compare maps
+		 && (pData1->maValueMap		== pData2->maValueMap)
+#endif
 		 )
 		return TRUE;
 
--- slideshow/source/engine/drawshapesubsetting.cxx.orig	2006-03-26 12:17:50.000000000 +0200
+++ slideshow/source/engine/drawshapesubsetting.cxx	2006-03-26 12:18:36.000000000 +0200
@@ -355,7 +355,7 @@
             aEntry.mnStartActionIndex 	= rTreeNode.getStartIndex();
             aEntry.mnEndActionIndex 	= rTreeNode.getEndIndex();
 
-            ShapeSet::iterator aIter;
+            ShapeSet::const_iterator aIter;
             if( (aIter=maSubsetShapes.find( aEntry )) != maSubsetShapes.end() )
             {
                 // already created, return found entry
--- slideshow/source/engine/layer.cxx.orig	2006-03-26 12:20:26.000000000 +0200
+++ slideshow/source/engine/layer.cxx	2006-03-26 12:21:53.000000000 +0200
@@ -187,8 +187,8 @@
         {
             bool bRet( true );
 
-            const ShapeSet::iterator 	aEnd( maShapeSet.end() );
-            ShapeSet::iterator 			aCurr( maShapeSet.begin() );
+            const ShapeSet::const_iterator 	aEnd( maShapeSet.end() );
+            ShapeSet::const_iterator 			aCurr( maShapeSet.begin() );
             while( aCurr != aEnd )
             {
                 try
@@ -230,8 +230,8 @@
             bool bRet( true );
 
             // forward to each Shape's render() method
-            const ShapeSet::iterator 	aEnd( maShapeSet.end() );
-            ShapeSet::iterator 			aCurr( maShapeSet.begin() );
+            const ShapeSet::const_iterator 	aEnd( maShapeSet.end() );
+            ShapeSet::const_iterator 			aCurr( maShapeSet.begin() );
             while( aCurr != aEnd )
             {
                 try
--- xmloff/source/core/nmspmap.cxx.orig	2006-03-26 12:37:20.000000000 +0200
+++ xmloff/source/core/nmspmap.cxx	2006-03-26 15:38:07.000000000 +0200
@@ -103,7 +103,20 @@
 
 int SvXMLNamespaceMap::operator ==( const SvXMLNamespaceMap& rCmp ) const
 {
+#if STLPORT_VERSION < 500
+// STLport5 cannot compare maps
 	return static_cast < int > (aNameHash == rCmp.aNameHash);
+#else
+//FIXME: alternative map compare?
+	NameSpaceHash::const_iterator it, rit;
+	for ( it = aNameHash.begin() ; it != aNameHash.end() ; it++ )
+	{
+		rit = rCmp.aNameHash.find( it->first );
+		if ( ( rit == rCmp.aNameHash.end() ) || ( it->second != rit->second ) )
+			return static_cast < int > ( false );
+	}
+	return static_cast < int > ( true );
+#endif
 }
 
 sal_uInt16 SvXMLNamespaceMap::_Add( const OUString& rPrefix, const OUString &rName, sal_uInt16 nKey )
--- xmloff/source/style/xmlnumfe.cxx.orig	2006-03-26 15:54:06.000000000 +0200
+++ xmloff/source/style/xmlnumfe.cxx	2006-03-26 15:54:33.000000000 +0200
@@ -172,13 +172,13 @@
 
 sal_Bool SvXMLNumUsedList_Impl::IsUsed( sal_uInt32 nKey ) const
 {
-	SvXMLuInt32Set::iterator aItr = aUsed.find(nKey);
+	SvXMLuInt32Set::const_iterator aItr = aUsed.find(nKey);
 	return (aItr != aUsed.end());
 }
 
 sal_Bool SvXMLNumUsedList_Impl::IsWasUsed( sal_uInt32 nKey ) const
 {
-	SvXMLuInt32Set::iterator aItr = aWasUsed.find(nKey);
+	SvXMLuInt32Set::const_iterator aItr = aWasUsed.find(nKey);
 	return (aItr != aWasUsed.end());
 }
 
--- svx/source/svdraw/svdouno.cxx.orig	2006-03-26 17:21:56.000000000 +0200
+++ svx/source/svdraw/svdouno.cxx	2006-03-26 17:22:47.000000000 +0200
@@ -875,7 +875,7 @@
         SdrViewIter aIter( this );
 	    for ( SdrView* pView = aIter.FirstView(); pView; pView = aIter.NextView() )
         {
-            ::std::set< SdrView* >::const_iterator aPrevPos = aPreviouslyVisible.find( pView );
+            ::std::set< SdrView* >::iterator aPrevPos = aPreviouslyVisible.find( pView );
             if ( aPreviouslyVisible.end() != aPrevPos )
             {   // in pView, we were visible _before_ the layer change, and are
                 // visible _after_ the layer change, too
--- sc/source/core/inc/bcaslot.hxx.orig	2006-03-26 18:50:41.000000000 +0200
+++ sc/source/core/inc/bcaslot.hxx	2006-03-26 19:05:42.000000000 +0200
@@ -109,7 +109,7 @@
 	ScDocument*			pDoc;
 	ScBroadcastAreaSlotMachine* pBASM;
 
-    ScBroadcastAreas::iterator  FindBroadcastArea( const ScRange& rRange ) const;
+    ScBroadcastAreas::iterator  FindBroadcastArea( const ScRange& rRange );
 
 public:
 						ScBroadcastAreaSlot( ScDocument* pDoc,
--- sc/source/core/data/bcaslot.cxx.orig	2006-03-26 18:23:16.000000000 +0200
+++ sc/source/core/data/bcaslot.cxx	2006-03-26 19:04:58.000000000 +0200
@@ -204,7 +204,7 @@
 
 
 ScBroadcastAreas::iterator ScBroadcastAreaSlot::FindBroadcastArea(
-        const ScRange& rRange ) const
+        const ScRange& rRange )
 {
 	aTmpSeekBroadcastArea.UpdateRange( rRange);
     return aBroadcastAreaTbl.find( &aTmpSeekBroadcastArea);
--- sw/source/core/SwNumberTree/SwNumberTree.cxx.orig	2006-03-28 18:54:36.000000000 +0200
+++ sw/source/core/SwNumberTree/SwNumberTree.cxx	2006-03-28 19:13:32.000000000 +0200
@@ -160,7 +160,7 @@
     }
 }
 
-void SwNumberTreeNode::ValidateHierarchical(const SwNumberTreeNode * pNode) const
+void SwNumberTreeNode::ValidateHierarchical(const SwNumberTreeNode * pNode)
 {
     tSwNumberTreeChildren::iterator aValidateIt =
         GetIterator(pNode);
@@ -282,7 +282,7 @@
     }
 }
 
-void SwNumberTreeNode::ValidateContinuous(const SwNumberTreeNode * pNode) const
+void SwNumberTreeNode::ValidateContinuous(const SwNumberTreeNode * pNode)
 {
     tSwNumberTreeChildren::iterator aIt = mItLastValid;
 
@@ -316,7 +316,7 @@
     SetLastValid(aIt);
 }
 
-void SwNumberTreeNode::Validate(const SwNumberTreeNode * pNode) const
+void SwNumberTreeNode::Validate(const SwNumberTreeNode * pNode)
 {
     if (! IsValid(pNode))
     {
@@ -806,7 +806,7 @@
 {
     bool bResult = false;
 
-    tSwNumberTreeChildren::iterator aIt;
+    tSwNumberTreeChildren::const_iterator aIt;
 
     for (aIt = mChildren.begin(); aIt != mChildren.end(); aIt++)
     {
@@ -860,7 +860,7 @@
 
 bool SwNumberTreeNode::IsFirst(const SwNumberTreeNode * pNode) const
 {
-    tSwNumberTreeChildren::iterator aIt = mChildren.begin();
+    tSwNumberTreeChildren::const_iterator aIt = mChildren.begin();
 
     if ((*aIt)->IsPhantom())
         aIt++;
@@ -910,7 +910,7 @@
     return mChildren.size();
 }
 
-bool SwNumberTreeNode::Contains(const SwNumberTreeNode * pChild) const
+bool SwNumberTreeNode::Contains(const SwNumberTreeNode * pChild)
 {
     bool bResult = false;
 
@@ -1011,7 +1011,7 @@
 #endif // __SW_NUMBER_TREE_SANITY_CHECK
 
 SwNumberTreeNode::tSwNumberTreeChildren::iterator
-SwNumberTreeNode::GetIterator(const SwNumberTreeNode * pChild) const
+SwNumberTreeNode::GetIterator(const SwNumberTreeNode * pChild)
 {
     SwNumberTreeNode * pRoot = GetRoot();
 
@@ -1127,7 +1127,7 @@
     return ! SwNumberTreeNodeLessThan(pA, pB);
 }
 
-SwNumberTreeNode * SwNumberTreeNode::GetLastDescendant() const
+SwNumberTreeNode * SwNumberTreeNode::GetLastDescendant()
 {
     SwNumberTreeNode * pResult = NULL;
     tSwNumberTreeChildren::reverse_iterator aIt = mChildren.rbegin();
@@ -1170,7 +1170,7 @@
 
 void SwNumberTreeNode::SetLastValid
                     ( SwNumberTreeNode::tSwNumberTreeChildren::iterator aItValid,
-                      bool bValidating ) const
+                      bool bValidating )
 {
     if (! (aItValid == mChildren.end() ||
            GetIterator(*aItValid) != mChildren.end()))
@@ -1235,7 +1235,7 @@
     }
 }
 
-void SwNumberTreeNode::InvalidateTree() const
+void SwNumberTreeNode::InvalidateTree()
 {
     // do not call SetInvalid, would cause loop !!!
     mItLastValid = mChildren.end();
--- sw/inc/SwNumberTree.hxx.orig	2006-03-28 18:54:48.000000000 +0200
+++ sw/inc/SwNumberTree.hxx	2006-03-28 19:13:44.000000000 +0200
@@ -196,7 +196,7 @@
 
        @attention All invalid children preceding pNode are validated, too.
      */
-    void Validate(const SwNumberTreeNode * pNode) const;
+    void Validate(const SwNumberTreeNode * pNode);
 
     /**
        Validates a child using hierarchical numbering.
@@ -205,7 +205,7 @@
 
        @attention All invalid children preceding pNode are validated, too.
      */
-    void ValidateHierarchical(const SwNumberTreeNode * pNode) const;
+    void ValidateHierarchical(const SwNumberTreeNode * pNode);
 
     /**
        Validates a child using continuous numbering.
@@ -214,7 +214,7 @@
 
        @attention All invalid children preceding pNode are validated, too.
      */
-    void ValidateContinuous(const SwNumberTreeNode * pNode) const;
+    void ValidateContinuous(const SwNumberTreeNode * pNode);
 
     /**
         HB, OD : return node, if it isn't a phantom, otherwise return first
@@ -230,7 +230,7 @@
 
        @return last descendant of the node
     */
-    SwNumberTreeNode * GetLastDescendant() const;
+    SwNumberTreeNode * GetLastDescendant();
 
     /**
        Returns the greatest descendant of the root that is smaller than
@@ -250,7 +250,7 @@
                                         the current last valid node
      */
     void SetLastValid(tSwNumberTreeChildren::iterator aItLastValid,
-                      bool bValidating = false) const;
+                      bool bValidating = false);
 
     /**
        Set this node as last valid child of its parent.
@@ -266,7 +266,7 @@
        of childs are set to the end of this list, thereby stating all
        children in the list are invalid.
      */
-    void InvalidateTree() const;
+    void InvalidateTree();
 
     /**
        Notifies the node.
@@ -368,7 +368,7 @@
 #endif // __SW_NUMBER_TREE_SANITY_CHECK
 
     tSwNumberTreeChildren::iterator
-    GetIterator(const SwNumberTreeNode * pChild) const;
+    GetIterator(const SwNumberTreeNode * pChild);
 
     bool HasCountedChildren() const;
 
@@ -635,7 +635,7 @@
        @retval true    pChild is a child of this node
        @retval false   else
      */
-    bool Contains(const SwNumberTreeNode * pChild) const;
+    bool Contains(const SwNumberTreeNode * pChild);
 
     /**
        Returns a string representation of this node.
