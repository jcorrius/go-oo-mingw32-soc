--- /dev/null	2007-05-04 11:54:36.000000000 +0100
+++ svx/source/msfilter/msvbasicdir.hxx	2007-06-29 16:21:42.000000000 +0100
@@ -0,0 +1,95 @@
+#ifndef _MSVBASICDIR_HXX
+#define _MSVBASICDIR_HXX
+
+#ifdef _SOLAR_H
+#include <tools/solar.h>
+#endif
+#ifndef _TOOLS_DEBUG_HXX
+#include <tools/debug.hxx>
+#endif
+#ifndef _SVSTOR_HXX //autogen
+#include <sot/storage.hxx>
+#endif
+#ifndef _DYNARY_HXX
+#include <tools/dynary.hxx>
+#endif
+#ifndef __SGI_STL_VECTOR
+#include <vector>
+#endif
+#include <map>
+#include "svxmsbas.hxx"
+namespace MSLZSS {
+	void	        compressString( SvStream *pStream, const rtl::OString &rString );
+	void	        compressStream( SvStream *pStream, SvStream *pInStream );
+	SvMemoryStream *decompressAsStream( SvStream *pStream, sal_uInt32 nOffset, sal_uInt32 *pCompressedLength = NULL, sal_uInt32 *pLength = NULL );
+	rtl::OString    decompressAsString( SvStream *pStream, sal_uInt32 nOffset, sal_uInt32 *pCompressedLength = NULL, sal_uInt32 *pLength = NULL );
+};
+
+// An unset strings is 0 length & looks like a flag ...
+
+#define VBA_DIR_LONG_START			0x01 // seemingly always 1
+#define VBA_DIR_LONG_ENCODING_1		0x02 // normally 0x409
+#define VBA_DIR_SHORT_VERSION_1		0x03 // seemingly always 0x4e4
+#define VBA_DIR_STR_PROJECT_NAME	0x04
+#define VBA_DIR_STR_DESCRIPTION		0x05
+#define VBA_DIR_STR_HELP_FILENAME	0x06
+#define VBA_DIR_LONG_HELP_CTXT_ID	0x07
+#define VBA_DIR_LONG_UNKNOWN_0x08	0x08
+#define VBA_DIR_OP_PAPER_SIZE		0x09
+#define VBA_DIR_STR_COND_COMP_ARGS	0x0c
+#define VBA_DIR_EXTERNAL_LINKAGE	0x0d
+#define VBA_DIR_SHORT_OBJECT_COUNT	0x0f
+#define VBA_DIR_FLAG_END			0x10 // ?
+#define VBA_DIR_SHORT_UNKNOWN_0x13	0x13
+#define VBA_DIR_LONG_ENCODING_2		0x14 // normally 0x409
+#define VBA_DIR_STR_STREAM_TYPE		0x16
+#define VBA_DIR_STR_USER_NAME		0x19
+#define VBA_DIR_STR_STREAM_NAME		0x1a
+#define VBA_DIR_STR_UNKNOWN_0x1c	0x1c
+#define VBA_DIR_LONG_UNKNOWN_0x1e	0x1e
+#define VBA_DIR_FLAG_MACRO			0x21
+#define VBA_DIR_FLAG_DOCUMENT		0x22
+#define VBA_DIR_CLASS_MODULE		0x28
+#define VBA_DIR_SHORT_UNKNOWN_0x2c	0x2c
+#define VBA_DIR_OBJECT_END			0x2b
+#define VBA_DIR_LONG_VBA_OFFSET		0x31
+#define VBA_DIR_USTR_STREAM_NAME	0x32
+#define VBA_DIR_USTR_COND_COMP_ARGS	0x3c
+#define VBA_DIR_USTR_HELP_FILENAME	0x3d
+#define VBA_DIR_USTR_STREAM_TYPE	0x3e
+#define VBA_DIR_USTR_DESCRIPTION	0x40
+#define VBA_DIR_USTR_USER_NAME		0x47
+#define VBA_DIR_USTR_UNKNOWN_0x48	0x48
+typedef ::std::map< UniString, sal_Int16 > ModuleTypeHash;
+class VBADir
+{
+private:
+	SvStorageRef mxStorage;
+	SvStorageRef mxProjectStorage;
+	// #117718# member map of module names to types of module
+	ModuleTypeHash mhModHash;
+	bool mbMac; 
+	bool mbInited; 
+	rtl_TextEncoding meCharSet;
+	void deleteSRPs();
+	void clobberProject();
+	rtl::OUString stripOptions( const rtl::OUString &rSource, sal_Int16 rType );
+	void writeModule( const rtl::OUString &rName, const rtl::OUString &rSource, sal_Int16 rType );
+	void init();
+	//0 for failure, anything else for success, determines encoding, 
+	//product, if this is a mac doc etc.
+	int Read_VBA_PROJECT();
+	//reads the PROJECT stream to determine Module types
+	void Read_VBAPROJECT();
+public:
+	VBADir( SvStorageRef &xProjectStorage, SvStorageRef &xStorage );
+	~VBADir();
+
+	bool readBasic( SfxObjectShell &rDocSh, bool bComment, bool bStripped );
+	bool writeBasic( SfxObjectShell &rDocSh );
+	// #117718# member map of module names to types of module
+	sal_Int16 GetModuleType( const UniString& rModuleName ) const;
+};
+
+
+#endif // _MSVBASICDIR_HXX
--- /dev/null	2007-05-04 11:54:36.000000000 +0100
+++ svx/source/msfilter/msvbasicdir.cxx	2007-06-29 16:23:34.000000000 +0100
@@ -0,0 +1,1521 @@
+#include <string.h> 	// memset(), ...
+#ifndef UNX
+#include <io.h> 		// access()
+#endif
+#ifndef _SFX_OBJSH_HXX
+#include <sfx2/objsh.hxx>
+#endif
+#ifndef _SFXAPP_HXX
+#include <sfx2/app.hxx>
+#endif
+#ifndef _BASMGR_HXX
+#include <basic/basmgr.hxx>
+#endif
+#ifndef _SB_SBMOD_HXX
+#include <basic/sbmod.hxx>
+#endif
+#ifndef _SVXERR_HXX
+#include <svxerr.hxx>
+#endif
+#ifndef _SOT_STORINFO_HXX
+#include <sot/storinfo.hxx>
+#endif
+#ifndef _MSVBASIC_HXX
+#include "msvbasicdir.hxx"
+#endif
+#ifndef _RTL_TENCINFO_H
+#include <rtl/tencinfo.h>   //rtl_getTextEncodingFromWindowsCodePage
+#endif
+
+#include <com/sun/star/container/XNameContainer.hpp>
+#include <com/sun/star/script/XLibraryContainer.hpp>
+#include <com/sun/star/script/ModuleType.hpp>
+#include <com/sun/star/i18n/TransliterationModules.hpp>
+#include <com/sun/star/embed/XStorage.hpp>
+
+#include <vcl/svapp.hxx>
+#include <unotools/textsearch.hxx>
+#include <fstream>
+using namespace com::sun::star::container;
+using namespace com::sun::star::script;
+using namespace com::sun::star::script::ModuleType;
+using namespace com::sun::star::uno;
+using namespace com::sun::star::lang;
+using namespace com::sun::star::embed;
+using namespace rtl;
+
+#define nWINDOWLEN 4096
+#define STANDARD RTL_CONSTASCII_USTRINGPARAM("Standard")
+
+static unsigned int
+getShift( sal_uInt32 nPos )
+{
+	if (nPos <= 0x80) {
+		if (nPos <= 0x20)
+			return (nPos <= 0x10) ? 12 : 11;
+		else
+			return (nPos <= 0x40) ? 10 : 9;
+	} else {
+		if (nPos <= 0x200)
+			return (nPos <= 0x100) ? 8 : 7;
+		else if (nPos <= 0x800)
+			return (nPos <= 0x400) ? 6 : 5;
+		else
+			return 4;
+	}
+}
+
+struct CompressBuffer {
+	// buffer for match making
+	UINT8 mpBuffer[ nWINDOWLEN ];
+	sal_Int32 mnLength;
+
+	// output buffering
+	SvStream   *mpOutput;
+	UINT8       mnMask;
+	UINT8       maBlock[16];
+	UINT8		mnBlockLength;
+	UINT8		mnShift;
+
+	CompressBuffer( SvStream *pOutput )
+	{
+		memset( mpBuffer, 0, sizeof( mpBuffer ) );
+		mnLength = 0;
+		mnBlockLength = 0;
+		mpOutput = pOutput;
+		mnShift  = 0;
+		mnMask   = 0;
+	}
+
+	void
+	flush()
+	{
+		if( mnBlockLength ) {
+			*mpOutput << mnMask;
+			mpOutput->Write( maBlock, mnBlockLength );
+			mnBlockLength = 0;
+			mnMask = mnShift = 0;
+		}
+	}
+
+	void outputData( UINT8 *pData, bool bCompressed )
+	{
+		if (bCompressed)
+		{
+			mnMask |= 1 << mnShift;
+			maBlock[ mnBlockLength++ ] = pData[0];
+			maBlock[ mnBlockLength++ ] = pData[1];
+		}
+		else
+			maBlock[ mnBlockLength++ ] = pData[0];
+
+		if( ++mnShift == 8)
+			flush();
+	}
+
+	void
+	outputMatch( sal_uInt32 nCurPos, sal_uInt32 nMatchPos, sal_uInt32 nLength )
+	{
+		sal_uInt32 nShift, nToken, nDistance;
+		UINT8 aData[2];
+
+		nShift = getShift( nCurPos );
+
+		nDistance = nCurPos - nMatchPos - 1;
+		nToken = (nDistance << nShift) + ((nLength - 3) & ((1<<nShift)-1));
+
+		aData[0] = nToken & 0xff;
+		aData[1] = nToken >> 8;
+
+		outputData( aData, TRUE );
+	}
+
+	sal_Int32 /* Unbelievably slow, but ... */
+	findMatch (sal_Int32 nPos, sal_Int32 &rnLen)
+	{
+		sal_Int32 i;
+		sal_Int32 max_match = (1 << getShift( nPos ) ) - 1;
+
+		/* FIXME: the MS impl. does different to a linear search here
+		   and is not very good at this either; is happy to get much
+		   worse matches; perhaps some single-entry match lookup table ?
+		   it seems to ~regularly truncate strings, and get earlier
+		   / later matches of equivalent length with no predictability
+		   ( hashing ? ).
+		*/
+		for (i = nPos - 1; i >= 0; i--)
+		{
+			sal_Int32 j;
+
+			for (j = 0; j < mnLength - nPos && j < nPos; j++)
+				if (mpBuffer[nPos + j] != mpBuffer[i + j])
+					break;
+
+			if (j >= 3)
+			{
+				if( j > max_match )
+					j = max_match;
+				rnLen = j;
+				return i;
+			}
+		}
+		return -1;
+	}
+
+	bool
+	readBlock( SvStream *pInStream )
+	{
+		mnLength = pInStream->Read( mpBuffer, nWINDOWLEN );
+		return mnLength > 0;
+	}
+};
+
+static void
+compressBlock( CompressBuffer &rBuffer )
+{
+	sal_Int32 nPos, nMatchLen;
+	int   nMatchPos;
+
+	for (nPos = 0; nPos < rBuffer.mnLength;)
+	{
+		if ((nMatchPos = rBuffer.findMatch( nPos, /* ref */ nMatchLen )) >= 0)
+		{
+			rBuffer.outputMatch( nPos, nMatchPos, nMatchLen );
+			nPos += nMatchLen;
+		}
+		else
+			rBuffer.outputData( &(rBuffer.mpBuffer[ nPos++ ]), FALSE );
+	}
+}
+namespace MSLZSS {
+
+void compressStream( SvStream *pStream, SvStream *pInStream )
+{
+	sal_uInt32 nStartPos = pStream->Tell();
+	pStream->Seek( nStartPos + 3 );
+	CompressBuffer aBuffer( pStream );
+
+	while( aBuffer.readBlock( pInStream ) )
+			compressBlock( aBuffer );
+	aBuffer.flush();
+
+	sal_uInt32 nSize = pStream->Tell() - nStartPos;
+	sal_uInt32 nLength = nSize - 3 - 1;
+
+	if( nLength > 0x0c0c ) /* TESTME: really right ? */
+		nLength = 0x0c0c;  /* follow-on chunk sizes ? */
+
+	pStream->Seek( nStartPos );
+	*pStream << UINT8(0x01);
+	*pStream << UINT8( nLength & 0xff);
+	*pStream << UINT8( nLength >> 8 | 0xb0 );
+}
+
+void
+compressString( SvStream *pStream, const OString &rString )
+{
+	SvMemoryStream aStream( (void *) rString.getStr(), rString.getLength(), STREAM_READ );
+	compressStream( pStream, &aStream );
+}
+
+SvMemoryStream *decompressAsStream( SvStream *pStream, sal_uInt32 nOffset, sal_uInt32 *pCompressedLength, sal_uInt32 *pLength )
+{
+	SvMemoryStream *pResult;
+
+	pResult = new SvMemoryStream();
+	
+	sal_uInt8 nLeadbyte;
+	unsigned int nPos = 0;
+	int nLen, nDistance, nShift, nClean=1;
+	sal_uInt8 aHistory[ nWINDOWLEN ];
+
+	pStream->Seek( nOffset + 3 );
+
+	while( pStream->Read( &nLeadbyte, 1 ) )
+	{
+		for(int nMask=0x01; nMask < 0x100; nMask = nMask<<1)
+		{
+			// we see if the leadbyte has flagged this location as a dataunit
+			// which is actually a token which must be looked up in the history
+			if( nLeadbyte & nMask )
+			{
+				sal_uInt16 nToken;
+
+				*pStream >> nToken;
+
+				if (nClean == 0)
+					nClean=1;
+
+                //For some reason the division of the token into the length
+                //field of the data to be inserted, and the distance back into
+                //the history differs depending on how full the history is
+				nShift = getShift( nPos % nWINDOWLEN );
+
+				nLen = (nToken & ((1<<nShift) - 1)) + 3;
+				nDistance = nToken >> nShift;
+
+                //read the len of data from the history, wrapping around the
+                //nWINDOWLEN boundary if necessary data read from the history
+                //is also copied into the recent part of the history as well.
+				for (int i = 0; i < nLen; i++)
+				{
+					unsigned char c;
+					c = aHistory[(nPos-nDistance-1) % nWINDOWLEN];
+					aHistory[nPos % nWINDOWLEN] = c;
+					nPos++;
+				}
+			}
+			else
+			{
+                // special boundary case code, not guarantueed to be correct
+                // seems to work though, there is something wrong with the
+                // compression scheme (or maybe a feature) where when the data
+                // ends on a nWINDOWLEN boundary and the excess bytes in the 8
+                // dataunit list are discarded, and not interpreted as tokens
+                // or normal data.
+				if ((nPos != 0) && ((nPos % nWINDOWLEN) == 0) && (nClean))
+				{
+					pStream->SeekRel(2);
+					nClean=0;
+					pResult->Write( aHistory, nWINDOWLEN );
+					break;
+				}
+				//This is the normal case for when the data unit is not a
+				//token to be looked up, but instead some normal data which
+				//can be output, and placed in the history.
+				if (pStream->Read(&aHistory[nPos % nWINDOWLEN],1))
+					nPos++;
+
+				if (nClean == 0)
+					nClean=1;
+			}
+		}
+	}
+	if (nPos % nWINDOWLEN)
+		pResult->Write( aHistory, nPos % nWINDOWLEN );
+	pResult->Flush();
+
+	if( pCompressedLength )
+		*pCompressedLength = nPos;
+
+	if( pLength )
+		*pLength = pResult->Tell();
+
+#if 0
+ {
+	fprintf( stderr, "Decompressed stream: %d bytes, size: %d\n",
+			 pResult->Tell(), pResult->GetSize() );
+	pResult->Seek( 0 );
+	UINT8 aData[8];
+	sal_uInt32 nUrk = 0;
+	UINT8 nCnt;
+	while( ( nCnt = pResult->Read( aData, 8 ) ) > 0 )
+	{
+		int i;
+		fprintf( stderr, "%.8x : ", nUrk);
+		nUrk += nCnt;
+		for( i = 0; i < nCnt; i++ )
+			fprintf( stderr, "%.2x ", aData[i] );
+
+		fprintf( stderr," | " );
+		for( i = 0; i < nCnt; i++ )
+			fprintf( stderr, "%c", aData[i] >= 0x20 ? aData[i] : '.' );
+		fprintf( stderr, "\n" );
+	}
+ }
+#endif	
+
+	pResult->Seek( 0 );
+
+	return pResult;
+}
+
+OString decompressAsString( SvStream *pStream, sal_uInt32 nOffset, sal_uInt32 *pCompressedLength, sal_uInt32 *pLength )
+{
+	sal_uInt32 nResultLength;
+	SvMemoryStream *pResultStream = decompressAsStream( pStream, nOffset, pCompressedLength, &nResultLength );
+
+	// Isn't it just marvelous that SvMemoryStream has no sensible 'size'
+	// method that returns nEndOfData [!]
+	if( pLength )
+		*pLength = nResultLength;
+
+	OString aResult( (const sal_Char *)pResultStream->GetData(), nResultLength );
+	delete pResultStream;
+	return aResult;
+}
+
+}; /* End MSLZSS */
+
+static void
+stripAttributes( OUString &rVBA, bool bIsMac )
+{
+	OSL_TRACE("Strip Attributes - bIsMac = %d", bIsMac );
+	const sal_Unicode cLineEnd = bIsMac ? '\x0D' : '\x0A';
+	const rtl::OUString sAttribute( OUString::createFromAscii( "Attribute" ) );
+	//OSL_TRACE("** Before strip %s", rtl::OUStringToOString( rVBA, RTL_TEXTENCODING_UTF8 ).getStr() );
+	while( rVBA.indexOf( sAttribute ) == 0 )
+	{
+		sal_Int32 nEnd = rVBA.indexOf( cLineEnd );
+		if( nEnd == -1 )
+	 		break;
+		rVBA = rVBA.copy( nEnd + 1 );
+	}
+	//OSL_TRACE("** After strip %s", rtl::OUStringToOString( rVBA, RTL_TEXTENCODING_UTF8 ).getStr() );
+}
+
+static void
+commentSource( OUString &rVBA, const OUString &rName, bool bIsMac )
+{
+	OUString sTempStringa(OUString::createFromAscii(
+								  bIsMac ? "\x0D": "\x0D\x0A"));
+	OUString sTempStringb( sTempStringa );
+	OUString sTempRem = OUString::createFromAscii( "Rem " );
+	sTempStringb += sTempRem;
+	sal_Int32 nFromIndex = 0;
+	sal_Int32 nToIndex = -1;
+	while( (nToIndex = rVBA.indexOf( sTempStringa, nFromIndex ) ) != -1 )
+	{
+		rVBA = rVBA.replaceAt( nToIndex, sTempStringa.getLength(), sTempStringb);
+		nFromIndex = nToIndex += sTempStringb.getLength();
+	}
+	rVBA = sTempRem + rVBA;
+
+	// Streams can have spaces in them, but modulenames
+	// cannot !
+	rtl::OUString sTemp( rtl::OUString::createFromAscii( "Sub " ) );
+	sTemp += rName.replace( sal_Unicode(' '), sal_Unicode('_') );
+	sTemp += OUString::createFromAscii("\n");
+	rVBA = sTemp + rVBA;
+	rVBA += OUString::createFromAscii("\nEnd Sub");
+}
+
+struct DirTokenizer {
+	SvStream *mpStream;
+	sal_uInt16    mnToken;
+	sal_Int32    mnLength;
+	sal_uInt32    mnConsumed;
+	bool	  mnbEof;
+
+	DirTokenizer( SvStream *pStream ) :
+		mpStream(pStream), mnToken(0),
+		mnLength(0), mnConsumed(0),
+		mnbEof(false) {}
+	~DirTokenizer() {}
+
+	bool
+	nextToken()
+	{
+		mpStream->SeekRel( mnLength - mnConsumed );
+
+		mnToken = mnLength = mnConsumed = 0;
+
+		// Seeking clears the eof marker - so read first ...
+		*mpStream >> mnToken;
+		if( mpStream->IsEof() )
+			return !(mnbEof = true);
+
+		*mpStream >> mnLength;
+		if( mpStream->IsEof() )
+			return !(mnbEof = true);
+	
+		if( mnToken == VBA_DIR_OP_PAPER_SIZE ) /* Quirk */
+			mnLength += 2;
+
+		OSL_TRACE("Next token 0x%x (%d long)", mnToken, mnLength );
+
+		return true;
+	}
+
+	bool
+	isEof()
+	{
+		return mnbEof;
+	}
+
+	sal_uInt32
+	getLong()
+	{
+		sal_uInt32 nResult;
+		mnConsumed += 4;
+		*mpStream >> nResult;
+		return nResult;
+	}
+
+	sal_uInt16
+	getShort()
+	{
+		sal_uInt16 nResult;
+		mnConsumed += 2;
+		*mpStream >> nResult;
+		return nResult;
+	}
+
+	OUString
+	getUString()
+	{
+		sal_Unicode aData[ ( mnLength + 1 ) / 2 ];
+		mpStream->Read( aData, mnLength );
+		mnConsumed += mnLength;
+		return OUString( aData, mnLength/2 );
+	}
+
+	OUString
+	getString()
+	{
+		sal_Char aData[ mnLength ];
+		mpStream->Read( aData, mnLength );
+		mnConsumed += mnLength;
+		return OUString( aData, mnLength, RTL_TEXTENCODING_MS_1252 );
+	}
+
+	Reference< XNameContainer > 
+	parseHeader( const Reference< XLibraryContainer > &xLibContainer )
+	{
+		Reference< XNameContainer > xLib;
+
+		if( !xLibContainer.is() )
+			return xLib;
+
+		// Parse the header
+		while( nextToken() && mnToken != VBA_DIR_SHORT_OBJECT_COUNT )
+		{
+			switch( mnToken )
+			{
+			case VBA_DIR_STR_PROJECT_NAME:
+//				aProjectName = getString(); - this causes export grief.
+				break;
+			}
+		}
+
+		if( !mnToken )
+			return xLib;
+
+		OUString aProjectName = OUString::createFromAscii( "Standard" );
+		OSL_TRACE( "CreateLibrary: '%s'",
+					 (const sal_Char *) rtl::OUStringToOString(
+							 aProjectName, RTL_TEXTENCODING_UTF8 ) );
+				 
+		if( !xLibContainer->hasByName( aProjectName ) )
+			xLibContainer->createLibrary( aProjectName );
+
+		Any aLibAny = xLibContainer->getByName( aProjectName );
+		aLibAny >>= xLib;
+
+		return xLib;
+	}
+
+	bool
+	readObject( const SvStorageRef &xStorage,
+				Reference< XNameContainer > &xLib,
+				const VBADir& rVBA,
+				bool bStripped, bool bAsComment, bool bIsMac )
+	{
+		OUString aName;
+		sal_uInt32    nOffset = 0;
+		OUString aStreamName;
+
+		while( nextToken() && mnToken != VBA_DIR_OBJECT_END )
+		{
+			switch( mnToken )
+			{
+			case VBA_DIR_STR_USER_NAME:
+				aName = getString();
+				break;
+			case VBA_DIR_USTR_USER_NAME:
+				aName = getUString();
+				break;
+			case VBA_DIR_STR_STREAM_NAME:
+				aStreamName = getString();
+				break;
+			case VBA_DIR_USTR_STREAM_NAME:
+				aStreamName = getUString();
+				break;
+			case VBA_DIR_LONG_VBA_OFFSET:
+				nOffset = getLong();
+				break;
+			default:
+				break;
+			}
+		}
+		if( aStreamName.getLength() )
+		{
+			OSL_TRACE("Open stream: '%s' (0x%x)",
+					 (const sal_Char *) rtl::OUStringToOString(
+							 aStreamName, RTL_TEXTENCODING_UTF8 ),
+					 nOffset );
+
+			SotStorageStreamRef xVBA;
+
+			xVBA = xStorage->OpenSotStream( aStreamName, STREAM_STD_READ );
+			if( !xVBA.Is() )
+			{
+				OSL_TRACE("Failed to open stream" );
+				return false;
+			}
+			xVBA->SetNumberFormatInt( NUMBERFORMAT_INT_LITTLEENDIAN ); // #TODO CHECKME ( but I think module streams are always littleendian )
+
+			OUString sSource = OStringToOUString(
+					MSLZSS::decompressAsString( xVBA, nOffset ),
+					RTL_TEXTENCODING_MS_1252 );
+
+			if( bStripped )
+				stripAttributes( sSource, bIsMac );
+
+			if( sSource.getLength() <= 0 )
+				return true;
+
+			sal_Int16 mType = rVBA.GetModuleType( aName );
+
+			rtl::OUString modeTypeComment;
+			prependHelperAPIInfo( modeTypeComment, mType );
+
+			if( bAsComment )
+				commentSource( sSource, aName, bIsMac );
+			else
+			{
+				static ::rtl::OUString sVBAOption( RTL_CONSTASCII_USTRINGPARAM( "Option VBASupport 1\n" ) );
+				static ::rtl::OUString sClassOption( RTL_CONSTASCII_USTRINGPARAM( "Option ClassModule\n" ) );
+				modeTypeComment = modeTypeComment + sVBAOption;
+				if ( mType == Class )
+					modeTypeComment = modeTypeComment + sClassOption;
+			}
+
+			sSource = modeTypeComment + sSource;
+
+			rtl::OUString aModName( aName );
+			Any aSourceAny;
+			aSourceAny <<= sSource;
+			if (xLib->hasByName(aModName))
+				xLib->replaceByName(aModName, aSourceAny);
+			else
+				xLib->insertByName(aModName, aSourceAny);
+
+			return true;
+		}
+		else
+		{
+			OSL_TRACE( "Duff stream name" );
+		}
+		return false;
+	}
+
+	bool prependHelperAPIInfo( OUString& sSource, sal_Int16 mType )
+	{
+		rtl::OUString sClassRem( RTL_CONSTASCII_USTRINGPARAM( "Rem Attribute VBA_ModuleType=" ) );
+
+		rtl::OUString modeTypeComment;
+		switch( mType )
+		{
+			case ModuleType::Class:
+				modeTypeComment = sClassRem +
+					::rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "VBAClassModule\n" ) );
+				break;
+			case ModuleType::Form:
+				modeTypeComment = sClassRem +
+					::rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "VBAFormModule\n" ) );
+				break;
+			case ModuleType::Document:
+				modeTypeComment = sClassRem +
+					::rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "VBADocumentModule\n" ) );
+				break;
+			case ModuleType::Normal:
+				modeTypeComment = sClassRem +
+					::rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "VBAModule\n" ) );
+				break;
+			case ModuleType::Unknown:
+				modeTypeComment = sClassRem +
+					::rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "VBAUnknown\n" ) );
+			
+			default:
+				DBG_ERRORFILE( "SvxImportMSVBasic::ImportCode_Impl - unknown module type" );
+				return false;
+		}
+		sSource = modeTypeComment + sSource;
+		return true;
+	}
+};
+
+VBADir::VBADir( SvStorageRef &xProjectStorage, SvStorageRef &xStorage  ) :
+		mxStorage( xStorage ), mxProjectStorage( xProjectStorage ), mbMac( false ), meCharSet( RTL_TEXTENCODING_MS_1252)
+{
+	init();
+}
+
+VBADir::~VBADir()
+{
+}
+
+void 
+VBADir::init()
+{
+	Read_VBA_PROJECT();		
+	Read_VBAPROJECT();		
+}
+int 
+VBADir::Read_VBA_PROJECT()
+{
+	SvStorageStreamRef xVBAProject;
+	xVBAProject = mxStorage->OpenSotStream(
+	String( RTL_CONSTASCII_USTRINGPARAM( "_VBA_PROJECT" ) ),
+		STREAM_STD_READ | STREAM_NOCREATE );
+	
+	if( !xVBAProject.Is() || SVSTREAM_OK != xVBAProject->GetError() )
+	{
+		DBG_WARNING("Not able to find vba project, cannot find macros");
+		return 0;
+	}
+
+	static const sal_uInt8 aKnownId[] = {0xCC, 0x61};
+	sal_uInt8 aId[2];
+	xVBAProject->Read( aId, sizeof(aId) );
+	if (memcmp( aId, aKnownId, sizeof(aId)))
+	{
+		DBG_WARNING("unrecognized VBA macro project type");
+		return 0;
+	}
+
+	static const sal_uInt8 aOffice2003LE_2[] =
+	{
+		0x79, 0x00, 0x00, 0x01, 0x00, 0xFF
+	};
+	
+	static const sal_uInt8 aOffice2003LE[] =
+	{
+		0x76, 0x00, 0x00, 0x01, 0x00, 0xFF
+	};
+
+	static const sal_uInt8 aOfficeXPLE[] =
+	{
+		0x73, 0x00, 0x00, 0x01, 0x00, 0xFF
+	};
+
+	static const sal_uInt8 aOfficeXPBE[] =
+	{
+		0x63, 0x00, 0x00, 0x0E, 0x00, 0xFF
+	};
+
+	static const sal_uInt8 aOffice2000LE[] =
+	{
+		0x6D, 0x00, 0x00, 0x01, 0x00, 0xFF
+	};
+	static const sal_uInt8 aOffice98BE[] =
+	{
+		0x60, 0x00, 0x00, 0x0E, 0x00, 0xFF
+	};
+	static const sal_uInt8 aOffice97LE[] =
+	{
+		0x5E, 0x00, 0x00, 0x01, 0x00, 0xFF
+	};
+	sal_uInt8 aProduct[6];
+	xVBAProject->Read( aProduct, sizeof(aProduct) );
+
+	bool bIsUnicode = false;
+	if (!(memcmp(aProduct, aOffice2003LE, sizeof(aProduct))) ||
+		!(memcmp(aProduct, aOffice2003LE_2, sizeof(aProduct))) )
+	{
+		xVBAProject->SetNumberFormatInt( NUMBERFORMAT_INT_LITTLEENDIAN );
+		bIsUnicode = true;
+	}
+	else if (!(memcmp(aProduct, aOfficeXPLE, sizeof(aProduct))))
+	{
+		xVBAProject->SetNumberFormatInt( NUMBERFORMAT_INT_LITTLEENDIAN );
+		bIsUnicode = true;
+	}
+	else if (!(memcmp(aProduct, aOfficeXPBE, sizeof(aProduct))))
+	{
+		xVBAProject->SetNumberFormatInt( NUMBERFORMAT_INT_BIGENDIAN );
+		mbMac = true;
+		bIsUnicode = false;
+	}
+	else if (!(memcmp(aProduct, aOffice2000LE, sizeof(aProduct))))
+	{
+		xVBAProject->SetNumberFormatInt( NUMBERFORMAT_INT_LITTLEENDIAN );
+		bIsUnicode = true;
+	}
+	else if (!(memcmp(aProduct, aOffice98BE, sizeof(aProduct))))
+	{
+		xVBAProject->SetNumberFormatInt( NUMBERFORMAT_INT_BIGENDIAN );
+		mbMac = true;
+		bIsUnicode = false;
+	}
+	else if (!(memcmp(aProduct, aOffice97LE, sizeof(aProduct))))
+	{
+		xVBAProject->SetNumberFormatInt( NUMBERFORMAT_INT_LITTLEENDIAN );
+		bIsUnicode = true;
+	}
+	else
+	{
+		switch (aProduct[3])
+		{
+			case 0x1:
+				xVBAProject->SetNumberFormatInt(NUMBERFORMAT_INT_LITTLEENDIAN);
+				bIsUnicode = true;
+				DBG_ASSERT(!this, "unrecognized VBA macro version, report to cmc. Guessing at unicode little endian");
+				break;
+			case 0xe:
+				xVBAProject->SetNumberFormatInt(NUMBERFORMAT_INT_BIGENDIAN);
+				mbMac = true;
+				bIsUnicode = false;
+				DBG_ASSERT(!this, "unrecognized VBA macro version, report to cmc. Guessing at 8bit big endian");
+				break;
+			default:
+				DBG_ASSERT(!this, "totally unrecognized VBA macro version, report to cmc");
+				return 0;
+		}
+	}
+
+	sal_uInt32 nLidA;  //Language identifiers
+	sal_uInt32 nLidB;
+	sal_uInt16 nCharSet;
+	sal_uInt16 nLenA;
+	sal_uInt32 nUnknownB;
+	sal_uInt32 nUnknownC;
+	sal_uInt16 nLenB;
+	sal_uInt16 nLenC;
+	sal_uInt16 nLenD;
+	
+	*xVBAProject >> nLidA >> nLidB >> nCharSet >> nLenA >> nUnknownB;
+	*xVBAProject >> nUnknownC >> nLenB >> nLenC >> nLenD;
+	
+	meCharSet = rtl_getTextEncodingFromWindowsCodePage(nCharSet);
+	
+	DBG_ASSERT(meCharSet != RTL_TEXTENCODING_DONTKNOW,
+	"don't know what vba charset to use");
+	if (meCharSet == RTL_TEXTENCODING_DONTKNOW)
+		meCharSet = RTL_TEXTENCODING_MS_1252;
+
+	if (nLenD != 0x02)
+	{
+		DBG_WARNING("Warning VBA number is different, please report");
+		return 0;
+	}
+	OSL_TRACE( "mbMac = %d", mbMac );
+	return 1;
+}
+
+void 
+VBADir::Read_VBAPROJECT()
+{
+	// #TODO revisit
+
+	// Probably its possible to do this in the DirTokeniser also ( but
+	// I didn't *easily* see something to distinguish between the different
+	// 'Object' Modules ( Document & Form for instance )
+	// But also ....  *easily* meaning I didn't look that hard either.
+
+        /* #117718#
+         * Information regarding the type of module is contained in the
+         * "PROJECT" stream, this stream consists of a number of ascii lines
+         * entries are of the form Key=Value, the ones that we are interested
+         * in have the keys; Class, BaseClass & Module indicating the module
+         * ( value ) is either a Class Module, Form Module or a plain VB Module.        */
+        SvStorageStreamRef xProject = mxProjectStorage->OpenSotStream(
+            String( RTL_CONSTASCII_USTRINGPARAM( "PROJECT" ) ) );
+        SvStorageStream* pStp = xProject;
+        UniString tmp;
+        static const String sThisDoc(   RTL_CONSTASCII_USTRINGPARAM( "ThisDocument" ) );
+        static const String sModule(    RTL_CONSTASCII_USTRINGPARAM( "Module" ) );
+        static const String sClass(     RTL_CONSTASCII_USTRINGPARAM( "Class" ) );
+        static const String sBaseClass( RTL_CONSTASCII_USTRINGPARAM( "BaseClass" ) );
+        static const String sDocument(  RTL_CONSTASCII_USTRINGPARAM( "Document" ) );
+        mhModHash[ sThisDoc ] = Class;
+        while ( pStp->ReadByteStringLine( tmp, meCharSet ) )
+        {
+            xub_StrLen index = tmp.Search( '=' );
+            if ( index != STRING_NOTFOUND )
+            {
+                String key = tmp.Copy( 0, index  );
+                String value = tmp.Copy( index + 1 );
+                if ( key == sClass )
+                {
+                    mhModHash[ value ] = Class;
+                    OSL_TRACE("Module %s is of type Class",
+                        ::rtl::OUStringToOString( value ,
+                            RTL_TEXTENCODING_ASCII_US ).pData->buffer );
+                }
+                else if ( key == sBaseClass )
+                {
+                    mhModHash[ value ] =  Form;
+                    OSL_TRACE("Module %s is of type Form",
+                        ::rtl::OUStringToOString( value ,
+                            RTL_TEXTENCODING_ASCII_US ).pData->buffer );
+                }
+                else if ( key == sDocument )
+                {
+                    /*  #i37965# DR 2004-12-03: add "Document", used i.e.
+                        in Excel for macros attached to sheet or document. */
+
+                    // value is of form <name>/&H<identifier>, strip the identifier
+                    value.Erase( value.Search( '/' ) );
+
+                    mhModHash[ value ] = Document;
+                    OSL_TRACE("Module %s is of type Document VBA",
+                        ::rtl::OUStringToOString( value ,
+                            RTL_TEXTENCODING_ASCII_US ).pData->buffer );
+                }
+                else if ( key == sModule )
+                {
+                    mhModHash[ value ] = Normal;
+                    OSL_TRACE("Module %s is of type Normal VBA",
+                        ::rtl::OUStringToOString( value ,
+                            RTL_TEXTENCODING_ASCII_US ).pData->buffer );
+                }
+            }
+        }
+}
+
+sal_Int16 
+VBADir::GetModuleType( const UniString& rModuleName ) const
+{
+    ModuleTypeHash::const_iterator iter = mhModHash.find( rModuleName );
+    ModuleTypeHash::const_iterator iterEnd = mhModHash.end();
+    if ( iter != iterEnd )
+    {
+        return iter->second;
+    }
+    return Unknown;
+}
+
+bool
+VBADir::readBasic( SfxObjectShell &rDocSh, bool bAsComment, bool bStripped )
+{
+	bool bRet = false;
+	SotStorageStreamRef xDir;
+
+	xDir = mxStorage->OpenSotStream( OUString::createFromAscii( "dir"),
+									 STREAM_STD_READ );
+	if( !xDir.Is() )
+	{
+		DBG_WARNING( "No 'dir' stream" );
+		return FALSE;
+	}
+	xDir->SetNumberFormatInt( NUMBERFORMAT_INT_LITTLEENDIAN ); // #TODO - CHECKME ( is dir's endian-ness determined mbMac ( e.g. creating platfrom ) or is it always littleendian )
+
+	SvMemoryStream *pPlain = MSLZSS::decompressAsStream( xDir, 0 );
+#if 0
+	// hacky dump 
+	std::ofstream aOut("/home/npower/dir.out", std::ios::out );
+	sal_uInt8 aChar;
+	while (  !pPlain->IsEof() )
+	{
+		*pPlain >> aChar;
+		aOut << aChar;
+	}
+	pPlain->Seek(0);
+#endif
+	if( !pPlain )
+	{
+		DBG_WARNING( "Failed to decompress 'dir' stream" );
+		return FALSE;
+	}
+
+	SFX_APP()->EnterBasicCall();
+
+	Reference< XLibraryContainer > xLibContainer = rDocSh.GetBasicContainer();
+
+	DirTokenizer aTok( pPlain );
+	Reference< XNameContainer > xLib;
+
+	xLib = aTok.parseHeader( xLibContainer );
+	if( !xLib.is() )
+	{
+		DBG_WARNING( "Broken header /library" );
+		return FALSE;
+	}
+		
+	// Parse the objects
+	USHORT nItems = aTok.getShort();
+	for( USHORT nItem = 0; nItem < nItems && !aTok.isEof(); nItem++)
+		aTok.readObject( mxStorage, xLib, *this, bStripped, bAsComment, mbMac );
+	
+	bRet = true;
+	delete pPlain;
+
+	SFX_APP()->LeaveBasicCall();
+
+	return bRet;
+}
+
+void
+VBADir::deleteSRPs()
+{
+	SvStorageInfoList aInfoList;
+
+	mxStorage->FillInfoList( &aInfoList );
+
+	// Remove highly version specific compiled VBA streams
+	for( sal_uInt32 i = 0; i < aInfoList.Count(); i++ )
+	{
+		SvStorageInfo& rInfo = aInfoList[i];
+
+		if( rInfo.IsStream() &&
+			rInfo.GetName().EqualsAscii( "__SRP_", 0, 6 ) )
+			mxStorage->Remove( rInfo.GetName() );
+	}
+}
+
+void
+VBADir::clobberProject()
+{
+	SotStorageStreamRef xProject;
+
+	xProject = mxStorage->OpenSotStream( OUString::createFromAscii( "_VBA_PROJECT" ),
+										 STREAM_STD_WRITE );
+	if( !xProject.Is() )
+	{
+		DBG_WARNING( "Failed to clobber VBA project" );
+		return;
+	}
+
+	UINT8 nMagicVersion = 0xa0;
+	UINT8 nData[8] = { 0xcc, 0x61, 0x00, 0, 0,1,0,0 };
+	UINT8 nZeros[8] = { 0,0,0,0, 0,0,0,0 };
+	nData[2] = nMagicVersion;
+
+	xProject->Seek( 0 );
+	xProject->Write( nData, 8 );
+	xProject->Write( nZeros, 8 );
+	xProject->Write( nZeros, 8 );
+	for (int i = 0; i < 100; i++)
+			xProject->Write( nZeros, 8 );
+	xProject->Flush();
+}
+
+struct DirOutput {
+	SvStream *mpStream;
+
+	DirOutput( SvStream *pDirStream ) :
+		mpStream( pDirStream ) {}
+	~DirOutput() {}
+
+	void
+	writeLong( sal_uInt16 nToken, sal_uInt32 nLong )
+	{
+		*mpStream << nToken;
+		*mpStream << sal_uInt32(4);
+		*mpStream << nLong;
+	}
+
+	void
+	writeShort( sal_uInt16 nToken, sal_uInt16 nShort )
+	{
+		*mpStream << nToken;
+		*mpStream << sal_uInt32(2);
+		*mpStream << nShort;
+	}
+
+	void	
+	writeUString( sal_uInt16 nToken, const OUString &rString )
+	{
+		*mpStream << nToken;
+		*mpStream << sal_uInt32( rString.getLength() * 2 );
+		mpStream->Write( (const sal_Unicode *)rString,
+						 rString.getLength() * 2 );
+	}
+
+	void
+	writeString( sal_uInt16 nToken, const OString &rString )
+	{
+		*mpStream << nToken;
+		*mpStream << sal_uInt32( rString.getLength() );
+		mpStream->Write( (const sal_Char *)rString,
+						 rString.getLength() );
+	}
+
+	void
+	writeUStringPair( sal_uInt16 nPlainToken, sal_uInt16 nUniToken, const OUString &rString )
+	{
+		writeString( nPlainToken, OUStringToOString( rString, RTL_TEXTENCODING_MS_1252 ) );
+		writeUString( nUniToken, rString );
+	}
+
+	void
+	writeHeader()
+	{
+		writeLong( VBA_DIR_LONG_START, 1 );
+		writeLong( VBA_DIR_LONG_ENCODING_1, 0x409 );
+		writeLong( VBA_DIR_LONG_ENCODING_2, 0x409 );
+		writeShort( VBA_DIR_SHORT_VERSION_1, 0x4e4 );
+		writeString( VBA_DIR_STR_PROJECT_NAME, OString( "ProjectFoo" ) );
+		writeUStringPair( VBA_DIR_STR_DESCRIPTION,
+						  VBA_DIR_USTR_DESCRIPTION, OUString() );
+		writeUStringPair( VBA_DIR_STR_HELP_FILENAME,
+						  VBA_DIR_USTR_HELP_FILENAME, OUString() );
+		writeLong( VBA_DIR_LONG_HELP_CTXT_ID, 0 );
+		writeLong( VBA_DIR_LONG_UNKNOWN_0x08, 0 );
+
+		// Whacked out 0x09 token:
+		*mpStream << sal_uInt16( VBA_DIR_OP_PAPER_SIZE );
+		*mpStream << sal_uInt32( 6 - 2 ); // totally magic: A4
+		*mpStream << sal_uInt16( 0x4b0 ) << sal_uInt16( 0x419a ) << sal_uInt16( 0x34 );
+
+		writeUStringPair( VBA_DIR_STR_COND_COMP_ARGS,
+						  VBA_DIR_USTR_COND_COMP_ARGS, OUString() );
+
+/*		// Magic libraries we use
+		writeString( VBA_DIR_STR_STREAM_TYPE, OString( "stdole" ) );
+		writeUString( VBA_DIR_USTR_STREAM_TYPE,
+						OUString::createFromAscii( "stdole" ) ); */
+	}
+
+	void
+	writeModuleCount( sal_uInt32 nModules )
+	{
+		writeShort( VBA_DIR_SHORT_OBJECT_COUNT, nModules );
+		writeShort( VBA_DIR_SHORT_UNKNOWN_0x13, 0x7384 ); // Concerning ...
+	}
+
+	void
+	writeFlag( sal_uInt16 nToken )
+	{
+		*mpStream << sal_uInt16( nToken );
+		*mpStream << sal_uInt32( 0 );
+	}
+
+	void
+	writeEnd()
+	{
+		writeFlag( VBA_DIR_FLAG_END );
+		mpStream->Flush();
+	}
+
+	void
+	writeModule( const OUString &rName, sal_Int16 rType = Normal )
+	{
+		writeUStringPair( VBA_DIR_STR_USER_NAME,
+						  VBA_DIR_USTR_USER_NAME, rName );
+		writeUStringPair( VBA_DIR_STR_STREAM_NAME,
+						  VBA_DIR_USTR_STREAM_NAME, rName );
+		writeUStringPair( VBA_DIR_STR_UNKNOWN_0x1c,
+						  VBA_DIR_USTR_UNKNOWN_0x48, OUString() );
+		// Our streams start after 16 bytes of padded 0s ( to please Office97 )
+		writeLong( VBA_DIR_LONG_VBA_OFFSET, 0x10 );
+		writeLong( VBA_DIR_LONG_UNKNOWN_0x1e, 0x0 );
+		writeShort( VBA_DIR_SHORT_UNKNOWN_0x2c, 0x3672 ); // Concerning ...
+		switch ( rType )
+		{
+			case Document:
+			case Form:
+				writeFlag( VBA_DIR_FLAG_DOCUMENT );
+				break;
+			case Class: 
+				writeFlag( VBA_DIR_CLASS_MODULE );
+				break;
+			case Normal: 
+		    	writeFlag( VBA_DIR_FLAG_MACRO );
+				break;
+			case Unknown:
+				DBG_WARNING( "Unknown module type" );
+		}
+		writeFlag( VBA_DIR_OBJECT_END );
+	}
+
+	void
+	writeModules( const vecModuleTypes& rModTypes )
+	{ 
+		// a hack - these are the hard-coded names from the 'CODENAME'
+		// records in the Excel stream.
+		vecModuleTypes::const_iterator it = rModTypes.begin();
+		vecModuleTypes::const_iterator it_end = rModTypes.end();
+		for ( ; it != it_end; ++it )
+			writeModule( it->first, it->second );
+	}
+};
+
+struct ProjectOutput {
+	SotStorageStreamRef mxProject;
+	SotStorageStreamRef mxProjectWm;
+
+	ProjectOutput() {}
+	~ProjectOutput() {}
+
+	bool initialize( const SvStorageRef &xStorage )
+	{
+		mxProject = xStorage->OpenSotStream(
+				rtl::OUString::createFromAscii( "PROJECT" ),
+				STREAM_STD_WRITE );
+		mxProjectWm = xStorage->OpenSotStream(
+				rtl::OUString::createFromAscii( "PROJECTwm" ),
+				STREAM_STD_WRITE );
+
+		return mxProject.Is() && mxProjectWm.Is();
+	}
+
+	void writeString( const OString &rString )
+	{
+		OString sTempStringa( "\n" );
+		OString sTempStringb( "\x0D\x0A" );
+		OString sOutput = rString;
+		
+	   	sal_Int32 nFromIndex = 0;
+		sal_Int32 nToIndex = -1;
+		while( (nToIndex = sOutput.indexOf( sTempStringa, nFromIndex ) ) != -1 )
+		{
+			sOutput = sOutput.replaceAt( nToIndex, sTempStringa.getLength(), sTempStringb);
+			nFromIndex = nToIndex += sTempStringb.getLength();
+		}
+		mxProject->Write( (const sal_Char *) sOutput, sOutput.getLength() );
+	}
+
+	void writeModule( const OUString &rName, sal_Int16 rType = Normal )
+	{
+		OString sName = OUStringToOString( rName, RTL_TEXTENCODING_MS_1252 );
+		OSL_TRACE("writeModeule %s, type %d", sName.getStr(), rType );
+		switch( rType )
+		{
+			case Document:
+		    	writeString( "Document=" );
+				break;
+			case Normal:
+		    	writeString( "Module=" );
+				break;
+			case Class:
+		    	writeString( "Class=" );
+				break;
+			case Form:
+		    	writeString( "BaseClass=" );
+				break;
+			case Unknown:
+		    	writeString( "Module=" );
+				break;
+		}
+		writeString( sName );
+		if( rType == Document )
+		    writeString( "/&H00000000" );
+		writeString( "\n" );
+		mxProjectWm->Write( (const sal_Char *) sName, sName.getLength() );
+		*mxProjectWm << UINT8( 0 );
+		mxProjectWm->Write( (const sal_Unicode *) rName, rName.getLength() * 2);
+		*mxProjectWm << sal_uInt16( 0 );
+	}
+
+	void writeHeader()
+	{
+		writeString("ID=\"{33C90A8B-9E30-406E-BC0F-D2863F9025D7}\"\n");
+	}
+
+	void writeModules( const vecModuleTypes& rModTypes )
+	{
+		vecModuleTypes::const_iterator it = rModTypes.begin();
+		vecModuleTypes::const_iterator it_end = rModTypes.end();
+		for ( ; it != it_end; ++it )
+			writeModule( it->first, it->second );
+	}
+
+	void writeEnd()
+	{
+		*mxProjectWm << sal_uInt16( 0 );
+
+		mxProject->Flush();
+		mxProjectWm->Flush();
+	}
+};
+
+OUString 
+VBADir::stripOptions( const OUString& rSource, sal_Int16 rType )
+{
+	OUString newSource( rSource );
+	sal_Int32 nFromIndex = 0;
+	sal_Int32 nToIndex = -1;
+	OUString sNewLine( '\n' );
+
+	com::sun::star::util::SearchOptions aVBAOpt;
+	::com::sun::star::util::SearchResult aVBARes;
+	::com::sun::star::util::SearchResult aClassRes;
+	aVBAOpt.algorithmType = com::sun::star::util::SearchAlgorithms_REGEXP;
+
+	aVBAOpt.Locale = Application::GetSettings().GetLocale();
+
+	//aVBAOptSearch.searchString = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("^\\s*Option\\s+VBASupport\\s+1") );;		
+	aVBAOpt.searchString = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("^\\s*Option VBASupport 1") );;		
+
+	aVBAOpt.transliterateFlags |= com::sun::star::i18n::TransliterationModules_IGNORE_CASE;
+	com::sun::star::util::SearchOptions aClassOpt( aVBAOpt);
+
+	//aClassOpt.searchString = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("^\\s*Option\\s+ClassModule\\s*$") );;		
+	aClassOpt.searchString = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Option ClassModule") );;		
+	utl::TextSearch aVBASearch(aVBAOpt);
+	utl::TextSearch aClassSearch(aClassOpt);
+	bool bFoundVBA = false;
+	bool bFoundClass = false;
+	xub_StrLen nStart=0, nEnd=rSource.getLength();
+	while( (nToIndex = rSource.indexOf( sNewLine, nFromIndex ) ) != -1 )
+	{
+		OUString nLine = rSource.copy( nFromIndex, ( nToIndex - nFromIndex ) + 1 );
+		if ( !bFoundVBA ) // always search until found
+		{
+			if ( aVBASearch.SearchFrwrd(nLine, &nStart, &nEnd, &aVBARes ) )
+			{
+				// add index to the line we are processing
+				aVBARes.startOffset[0] += nFromIndex;
+				aVBARes.endOffset[0] += nFromIndex;
+				bFoundVBA = true;		
+			}
+		}
+		if ( ( rType == Class ) && !bFoundClass ) // always search until found
+		{
+			if ( aClassSearch.SearchFrwrd(nLine, &nStart, &nEnd, &aClassRes ) )
+			{
+				// add index to the line we are processing
+				aClassRes.startOffset[0] += nFromIndex;
+				aClassRes.endOffset[0] += nFromIndex;
+				bFoundClass = true;		
+			}
+		}
+		// determine if we are finished
+		if ( ( bFoundVBA && rType != Class ) || 
+		( ( rType == Class ) && bFoundClass ) && bFoundVBA )
+		{
+			break;
+		}
+		nFromIndex = nToIndex +  sNewLine.getLength();
+	}
+	if ( bFoundClass || bFoundVBA )
+	{
+		sal_Int32 nStartFirstOption = -1;
+		sal_Int32 nEndFirstOption = -1;
+		sal_Int32 nStartSecondOption = -1;
+		sal_Int32 nEndSecondOption = -1;
+
+		if ( bFoundClass )
+		{
+			if ( aClassRes.startOffset[0] > aVBARes.startOffset[0] )
+			{
+				nStartFirstOption =  aVBARes.startOffset[0];
+				nEndFirstOption =  aVBARes.endOffset[0];
+				nStartSecondOption = aClassRes.startOffset[0];
+				nEndSecondOption = aClassRes.endOffset[0];
+			}
+			else
+			{
+				nStartFirstOption =  aClassRes.startOffset[0];
+				nEndFirstOption =  aClassRes.endOffset[0];
+				nStartSecondOption = aVBARes.startOffset[0];
+				nEndSecondOption = aVBARes.endOffset[0];
+			}
+
+		}
+		else
+		{
+			nStartFirstOption =  aVBARes.startOffset[0];
+			nEndFirstOption =  aVBARes.endOffset[0];
+		}
+		// Copy up to First Option 
+		newSource = rSource.copy( 0, nStartFirstOption ); //
+		if ( bFoundClass )
+		{
+			newSource += rSource.copy( nEndFirstOption, nStartSecondOption - nEndFirstOption ); 
+			newSource += rSource.copy( nEndSecondOption, rSource.getLength() - nEndSecondOption );
+		}
+		else
+			newSource += rSource.copy( nEndFirstOption, rSource.getLength() - nEndFirstOption );
+	}
+	return newSource;
+}
+
+void
+VBADir::writeModule( const OUString &rName, const OUString &rSource, sal_Int16 rType = Normal)
+{
+	SvStorageStreamRef xStream;
+	xStream = mxStorage->OpenSotStream( rName, STREAM_STD_WRITE );
+	xStream->SetNumberFormatInt( NUMBERFORMAT_INT_LITTLEENDIAN ); // #TODO - CHECKME are module stream always little endian
+		
+	UINT8 aData[16] = { 0, };
+	xStream->Write( aData, 16 );
+
+	OString sAttribute;
+	if ( rType == Normal )
+		sAttribute = sAttribute + "Attribute VB_Name = \"" + OUStringToOString( rName, RTL_TEXTENCODING_MS_1252 ) + "\"";
+	else if ( rType == Document )
+	{
+		// #FIXME wacky hack, this will become an issue also for
+		// word :-( possibly we need another constant to handle this 
+		// special document module type
+		// Better still would be a distinct module object type in basic
+		if ( rName.equals(  OUString::createFromAscii( "ThisWorkbook" ) ) )
+		{
+			sAttribute = "Attribute VB_Base = \"0{00020819-0000-0000-C000-000000000046}\"";
+		}
+		else
+		{
+			sAttribute = "Attribute VB_Base = \"0{00020820-0000-0000-C000-000000000046}\"";
+		}
+
+	}
+	else if ( rType == Class )
+	{
+			sAttribute = "Attribute VB_Base = \"0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}\"";
+/*
+			sAttribute = sAttribute + "\r\nAttribute VB_GlobalNameSpace = False";
+			sAttribute = sAttribute + "\r\nAttribute VB_Creatable = False";
+			sAttribute = sAttribute + "\r\nAttribute VB_PredeclaredId = False";
+			sAttribute = sAttribute + "\r\nAttribute VB_Exposed = False";
+			sAttribute = sAttribute + "\r\nAttribute VB_TemplateDerived = False";
+			sAttribute = sAttribute + "\r\nAttribute VB_Customizable = False";
+*/
+	}
+	else if ( rType == Form )
+	{
+			sAttribute = "Attribute VB_Base = \"0{6FE35EE2-F5D3-4FD9-BBB2-A3253B2C0650}{D22BB890-287D-42D9-85E8-F98E3EB8559C}\"";
+	}
+	
+	// Remove any instances of Option VBASupport and/or Option ClassModule
+
+	OString sSource = OUStringToOString( stripOptions( rSource, rType ), RTL_TEXTENCODING_MS_1252 );
+
+	sSource = sAttribute + "\r\n" + sSource;
+	//OSL_TRACE("***************************");
+	//OSL_TRACE("source for %s", OUStringToOString( rName, RTL_TEXTENCODING_UTF8 ).getStr() );
+	//OSL_TRACE("->START\n%s<-END", sSource.getStr() );
+	
+
+	MSLZSS::compressString( xStream, sSource );
+}
+
+bool
+VBADir::writeBasic( SfxObjectShell &rDocSh )
+{
+	bool bRet = true;
+
+	OSL_TRACE("writeBasic");
+	deleteSRPs();
+	clobberProject();
+
+	SvMemoryStream aMemStream;
+	ProjectOutput  aProject;
+
+	if( !aProject.initialize( mxProjectStorage ) )
+	{
+		OSL_TRACE( "Error opening project streams");
+		return false;
+	}
+	aProject.writeHeader();
+
+	DirOutput aDir( &aMemStream );
+	aDir.writeHeader();
+
+	SFX_APP()->EnterBasicCall();
+
+	Reference< XNameAccess> xVBAObjects;
+	Reference< XMultiServiceFactory> xSF(rDocSh.GetModel(), UNO_QUERY);
+
+	if ( xSF.is() )
+		xVBAObjects.set ( xSF->createInstance( rtl::OUString(RTL_CONSTASCII_USTRINGPARAM( "org.openoffice.vba.VBAObjectsToExport"))), UNO_QUERY);
+
+	Reference< XLibraryContainer > xLibContainer = rDocSh.GetBasicContainer();
+	Reference< XNameContainer > xLib;
+	OSL_TRACE("about to test xLibContainer");
+	if ( xLibContainer.is() )
+	{
+		try
+		{
+			xLib.set( xLibContainer->getByName( rtl::OUString( STANDARD ) ), UNO_QUERY );
+		}
+		catch( Exception& ){}
+	}
+	if( xVBAObjects.is() && xLib.is() )
+	{
+		OSL_TRACE("Got document specific vbaobject service");
+		Sequence< OUString > aProjects;
+		aProjects = xVBAObjects->getElementNames();
+		sal_Int32 nLen = aProjects.getLength();	
+		Reference < XStorage > xSrcRoot( rDocSh.GetStorage() );
+		SvStorageRef xMSProject = SotStorage::OpenOLEStorage( xSrcRoot, SvxImportMSVBasic::GetMSBasicStorageName(), STREAM_STD_READ );
+
+		OSL_TRACE("******* aProjects has %d entries", nLen );
+
+		SvxMSUserFormHelper userformHelper( xMSProject, String( RTL_CONSTASCII_USTRINGPARAM("VBA"))) ;
+		vecModuleTypes vbaModuleTypes;
+		for ( sal_Int32 nIndex = 0; nIndex < nLen; ++nIndex )
+		{
+			sal_Int16 nType = Unknown;
+			xVBAObjects->getByName( aProjects[ nIndex ] ) >>= nType;
+			// Check to see if this is an imported Userform,
+			// If this module doesn't match a previously imported
+			// userform then we can't export a 'real' Userform 
+			// ( Object and code ). We can only export the code
+			// in this case ( so it can't be exported as a Userform
+			// code/object combination )
+			
+			if ( userformHelper.isUserFormModuleName( aProjects[ nIndex ] ) )
+				nType = Form;
+
+			vbaModuleTypes.push_back( ModuleDesc(  aProjects[ nIndex ], nType ) );
+			OSL_TRACE("about to export %s type %d", rtl::OUStringToOString( aProjects[ nIndex ], RTL_TEXTENCODING_UTF8 ).getStr(), nType );
+			
+		}
+		aProject.writeModules( vbaModuleTypes );		
+
+		aDir.writeModuleCount(  vbaModuleTypes.size() );
+
+		// really this is write modules	
+		aDir.writeModules( vbaModuleTypes );
+
+		vecModuleTypes::iterator it = vbaModuleTypes.begin();
+		vecModuleTypes::iterator it_end = vbaModuleTypes.end();
+		for ( ; it != it_end; ++it )
+		{
+			Any aSourceAny;
+			OUString sSource;
+			// its possible that e.g. sheet1..3 have no code therefore they don't exist in openoffice, ditto for ThisWorkbook
+			try
+			{
+				aSourceAny = xLib->getByName( it->first );
+				aSourceAny >>= sSource;
+			}
+			catch( com::sun::star::uno::Exception& )
+			{
+			}
+			if( sSource.getLength() >= 0 )
+				writeModule( it->first, sSource, it->second );
+
+			// copy userform streams
+			if ( it->second == Form )
+			{
+				OSL_TRACE("Copying userform %s", rtl::OUStringToOString( it->first, RTL_TEXTENCODING_UTF8 ).getStr() );
+				SvStorageRef xFormSrc = xMSProject->OpenOLEStorage( it->first, STREAM_STD_READ );
+				SvStorageRef xDst = mxProjectStorage->OpenSotStorage( it->first, STREAM_READWRITE | STREAM_TRUNC );
+
+				xFormSrc->CopyTo( xDst );	
+				xDst->Commit();
+				ErrCode nError = xDst->GetError();
+				if ( nError == ERRCODE_NONE )
+					nError = xFormSrc->GetError();
+				if ( nError != ERRCODE_NONE )
+				{
+					OSL_TRACE("Error writing %s", rtl::OUStringToOString( it->first, RTL_TEXTENCODING_UTF8 ).getStr() );
+					//return false;
+				}
+			}
+		}
+		
+	}
+	else
+		aDir.writeModuleCount( 0 );
+
+	aDir.writeEnd();
+	aProject.writeEnd();
+
+	aMemStream.Seek( 0 );
+
+	// Compress dir to the real stream
+	SvStorageStreamRef xDir;
+	xDir = mxStorage->OpenSotStream( OUString::createFromAscii( "dir" ),
+									 STREAM_STD_WRITE );
+	if( !xDir.Is() )
+	{
+		OSL_TRACE("Failed to open dir" );
+		bRet = false;
+	}
+	else
+	{
+		xDir->SetNumberFormatInt( NUMBERFORMAT_INT_LITTLEENDIAN ); // #TODO - CHECKME for endianess ( e.g. should Dir always be littleendian or not )
+		MSLZSS::compressStream( xDir, &aMemStream );
+		xDir->Flush();
+	}
+
+	SFX_APP()->LeaveBasicCall();
+
+	return bRet;
+}
