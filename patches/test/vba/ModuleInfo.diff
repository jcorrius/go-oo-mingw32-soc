--- /dev/null	2007-09-22 05:50:58.000000000 +0800
+++ udkapi/com/sun/star/script/ModuleInfo.idl	2007-10-15 11:51:05.000000000 +0800
@@ -0,0 +1,58 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile: ArrayWrapper.idl,v $
+ *
+ *  $Revision: 1.2 $
+ *
+ *  last change: $Author: rt $ $Date: 2006/05/05 10:14:46 $
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+
+#ifndef __com_sun_star_script_ModuleInfo_idl__
+#define __com_sun_star_script_ModuleInfo_idl__
+
+#ifndef __com_sun_star_uno_XInterface_idl__
+#include <com/sun/star/uno/XInterface.idl>
+#endif
+
+//=============================================================================
+module com {  module sun {  module star { module script {
+interface XObjectProvider;
+struct ModuleInfo
+{
+	string ModuleName; 
+	string ModuleSource; 
+	XObjectProvider ModuleObjectProvider; 
+	short ModuleType; // string?
+};
+
+//=============================================================================
+
+}; }; }; };
+
+#endif
--- /dev/null	2007-09-22 05:50:58.000000000 +0800
+++ udkapi/com/sun/star/script/XObjectProvider.idl	2007-10-15 11:51:05.000000000 +0800
@@ -0,0 +1,52 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile: XDefaultMethod.idl,v $
+ *
+ *  $Revision: 1.3 $
+ *
+ *  last change: $Author: vg $ $Date: 2006/11/02 16:34:45 $
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+
+#ifndef __com_sun_star_script_XObjectProvider_idl__
+#define __com_sun_star_script_XObjectProvider_idl__
+
+#ifndef __com_sun_star_uno_XInterface_idl__
+#include <com/sun/star/uno/XInterface.idl>
+#endif
+
+module com { module sun { module star { module script {
+//==============================================================================
+interface XObjectProvider : ::com::sun::star::uno::XInterface
+{
+  any getObject();
+
+};
+
+};  };  };  };
+#endif
--- udkapi/com/sun/star/script/makefile.mk.bak	1970-01-01 08:00:00.000000000 +0800
+++ udkapi/com/sun/star/script/makefile.mk	2007-10-15 11:51:05.000000000 +0800
@@ -0,0 +1,98 @@
+#*************************************************************************
+#
+#   OpenOffice.org - a multi-platform office productivity suite
+#
+#   $RCSfile: makefile.mk,v $
+#
+#   $Revision: 1.13 $
+#
+#   last change: $Author: vg $ $Date: 2006/11/02 16:35:10 $
+#
+#   The Contents of this file are made available subject to
+#   the terms of GNU Lesser General Public License Version 2.1.
+#
+#
+#     GNU Lesser General Public License Version 2.1
+#     =============================================
+#     Copyright 2005 by Sun Microsystems, Inc.
+#     901 San Antonio Road, Palo Alto, CA 94303, USA
+#
+#     This library is free software; you can redistribute it and/or
+#     modify it under the terms of the GNU Lesser General Public
+#     License version 2.1, as published by the Free Software Foundation.
+#
+#     This library is distributed in the hope that it will be useful,
+#     but WITHOUT ANY WARRANTY; without even the implied warranty of
+#     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+#     Lesser General Public License for more details.
+#
+#     You should have received a copy of the GNU Lesser General Public
+#     License along with this library; if not, write to the Free Software
+#     Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+#     MA  02111-1307  USA
+#
+#*************************************************************************
+
+PRJ=..$/..$/..$/..
+
+PRJNAME=api
+
+TARGET=cssscript
+PACKAGE=com$/sun$/star$/script
+
+# --- Settings -----------------------------------------------------
+.INCLUDE :  $(PRJ)$/util$/makefile.pmk
+
+# ------------------------------------------------------------------------
+
+IDLFILES=\
+	AllEventObject.idl\
+	AllListenerAdapter.idl\
+	BasicErrorException.idl\
+	CannotConvertException.idl\
+	CannotCreateAdapterException.idl\
+	ContextInformation.idl\
+	Converter.idl\
+	Engine.idl\
+	FailReason.idl\
+	FinishEngineEvent.idl\
+	FinishReason.idl\
+	InterruptEngineEvent.idl\
+	InterruptReason.idl\
+	Invocation.idl\
+	InvocationAdapterFactory.idl\
+	JavaScript.idl\
+	ScriptEvent.idl\
+	ScriptEventDescriptor.idl\
+	ArrayWrapper.idl\
+	XAllListener.idl\
+	XAllListenerAdapterService.idl\
+	XDebugging.idl\
+	XEngine.idl\
+	XEngineListener.idl\
+	XEventAttacher.idl\
+	XEventAttacherManager.idl\
+	XInvocationAdapterFactory.idl\
+	XInvocationAdapterFactory2.idl\
+	XInvocation.idl\
+	XInvocation2.idl\
+	InvocationInfo.idl\
+	MemberType.idl\
+	XLibraryAccess.idl\
+	XScriptListener.idl\
+	XTypeConverter.idl\
+	XStarBasicAccess.idl\
+	XStarBasicModuleInfo.idl\
+	XStarBasicDialogInfo.idl\
+	XStarBasicLibraryInfo.idl\
+	XScriptEventsSupplier.idl\
+	XScriptEventsAttacher.idl\
+	XDefaultMethod.idl\
+	XDefaultProperty.idl\
+    ModuleInfo.idl\
+    XObjectProvider.idl\
+
+# ------------------------------------------------------------------
+
+.INCLUDE :  target.mk
+.INCLUDE :  $(PRJ)$/util$/target.pmk
--- svx/source/msfilter/svxmsbas.cxx.bak	1970-01-01 08:00:00.000000000 +0800
+++ svx/source/msfilter/svxmsbas.cxx	2007-10-15 11:51:05.000000000 +0800
@@ -0,0 +1,533 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile: svxmsbas.cxx,v $
+ *
+ *  $Revision: 1.21 $
+ *
+ *  last change: $Author: hr $ $Date: 2007/06/27 18:35:58 $
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+
+// MARKER(update_precomp.py): autogen include statement, do not remove
+#include "precompiled_svx.hxx"
+
+/* -*- Mode: C; tab-width: 4; indent-tabs-mode: nil -*- */
+
+#ifndef _TOOLS_DEBUG_HXX
+#include <tools/debug.hxx>
+#endif
+#ifndef _SFX_OBJSH_HXX
+#include <sfx2/objsh.hxx>
+#endif
+#ifndef _SFXAPP_HXX
+#include <sfx2/app.hxx>
+#endif
+#ifndef _BASMGR_HXX
+#include <basic/basmgr.hxx>
+#endif
+#ifndef _SB_SBMOD_HXX
+#include <basic/sbmod.hxx>
+#endif
+#ifndef _SVXERR_HXX
+#include <svxerr.hxx>
+#endif
+
+#ifndef _SVXMSBAS_HXX
+#include <svxmsbas.hxx>
+#endif
+#ifndef _MSVBASIC_HXX
+#include <msvbasic.hxx>
+#endif
+#ifndef _MSOCXIMEX_HXX
+#include <svx/msocximex.hxx>
+#endif
+#ifndef _SOT_STORINFO_HXX
+#include <sot/storinfo.hxx>
+#endif
+#ifndef _COMPHELPER_PROCESSFACTORY_HXX_
+#include <comphelper/processfactory.hxx>
+#endif
+#ifndef _COM_SUN_STAR_BEANS_XPROPERTYSET_HPP_
+#include <com/sun/star/beans/XPropertySet.hpp>
+#endif
+#ifndef _COM_SUN_STAR_AWT_SIZE_HPP_
+#include <com/sun/star/awt/Size.hpp>
+#endif
+#ifndef _COM_SUN_STAR_AWT_XCONTROLMODEL_HPP_
+#include <com/sun/star/awt/XControlModel.hpp>
+#endif
+using namespace com::sun::star::beans;
+using namespace com::sun::star::io;
+using namespace com::sun::star::awt;
+#include <comphelper/storagehelper.hxx>
+
+#include <com/sun/star/container/XNameContainer.hpp>
+#include <com/sun/star/script/XLibraryContainer.hpp>
+#include <com/sun/star/script/ModuleInfo.hpp>
+using namespace com::sun::star::container;
+using namespace com::sun::star::script;
+using namespace com::sun::star::uno;
+using namespace com::sun::star::lang;
+using namespace com::sun::star;
+
+using rtl::OUString;
+
+bool lcl_hasVBAEnabled()
+{
+	try
+	{
+		Reference< XPropertySet > xProps( ::comphelper::getProcessServiceFactory(), UNO_QUERY_THROW );
+		// test if vba service is present
+		Reference< XComponentContext > xCtx( xProps->getPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "DefaultContext" ))), UNO_QUERY_THROW );
+		Reference< XInterface > xGlobals( xCtx->getValueByName( ::rtl::OUString::createFromAscii( "/singletons/org.openoffice.vba.theGlobals") ), UNO_QUERY_THROW );
+		return true;
+	}
+	catch( Exception& ) {}
+	return false;
+}
+
+int SvxImportMSVBasic::Import( const String& rStorageName,
+								const String &rSubStorageName,
+								BOOL bAsComment, BOOL bStripped )
+{
+	if ( lcl_hasVBAEnabled() )
+		bAsComment = FALSE;	
+	int nRet = 0;
+	if( bImport && ImportCode_Impl( rStorageName, rSubStorageName,
+									bAsComment, bStripped ))
+		nRet |= 1;
+
+    if (bImport)
+        ImportForms_Impl(rStorageName, rSubStorageName);
+
+	if( bCopy && CopyStorage_Impl( rStorageName, rSubStorageName ))
+		nRet |= 2;
+
+	return nRet;
+}
+
+bool SvxImportMSVBasic::ImportForms_Impl(const String& rStorageName,
+    const String& rSubStorageName)
+{
+    SvStorageRef xVBAStg(xRoot->OpenSotStorage(rStorageName,
+        STREAM_READWRITE | STREAM_NOCREATE | STREAM_SHARE_DENYALL));
+    if (!xVBAStg.Is() || xVBAStg->GetError())
+        return false;
+
+    std::vector<String> aUserForms;
+    SvStorageInfoList aContents;
+    xVBAStg->FillInfoList(&aContents);
+    for (USHORT nI = 0; nI < aContents.Count(); ++nI)
+    {
+          SvStorageInfo& rInfo = aContents.GetObject(nI);
+          if (!rInfo.IsStream() && rInfo.GetName() != rSubStorageName)
+              aUserForms.push_back(rInfo.GetName());
+    }
+
+    if (aUserForms.empty())
+        return false;
+
+    bool bRet = true;
+    SFX_APP()->EnterBasicCall();
+    try
+    {
+        Reference<XMultiServiceFactory> xSF(comphelper::getProcessServiceFactory());
+
+        Reference<XComponentContext> xContext;
+        Reference<XPropertySet> xProps(xSF, UNO_QUERY);
+        xProps->getPropertyValue(OUString(RTL_CONSTASCII_USTRINGPARAM("DefaultContext")) ) >>= xContext;
+
+
+        Reference<XLibraryContainer> xLibContainer = rDocSh.GetDialogContainer();
+        DBG_ASSERT( xLibContainer.is(), "No BasicContainer!" );
+
+        String aLibName( RTL_CONSTASCII_USTRINGPARAM( "Standard" ) );
+        Reference<XNameContainer> xLib;
+        if (xLibContainer.is())
+        {
+            if( !xLibContainer->hasByName(aLibName))
+                xLibContainer->createLibrary(aLibName);
+
+            Any aLibAny = xLibContainer->getByName( aLibName );
+            aLibAny >>= xLib;
+        }
+
+        if(xLib.is())
+        {
+            typedef std::vector<String>::iterator myIter;
+            myIter aEnd = aUserForms.end();
+            for (myIter aIter = aUserForms.begin(); aIter != aEnd; ++aIter)
+            {
+                SvStorageRef xForm (xVBAStg->OpenSotStorage(*aIter,
+                    STREAM_READWRITE | STREAM_NOCREATE | STREAM_SHARE_DENYALL));
+
+                if (!xForm.Is() || xForm->GetError())
+                    continue;
+
+                SvStorageStreamRef xFrame = xForm->OpenSotStream(
+                    String( RTL_CONSTASCII_USTRINGPARAM( "\3VBFrame" ) ),
+                    STREAM_STD_READ | STREAM_NOCREATE);
+
+                if (!xFrame.Is() || xFrame->GetError())
+                    continue;
+
+                SvStorageStreamRef xTypes = xForm->OpenSotStream(
+                    String( 'f' ), STREAM_STD_READ | STREAM_NOCREATE);
+
+                if (!xTypes.Is() || xTypes->GetError())
+                    continue;
+
+                //<UserForm Name=""><VBFrame></VBFrame>"
+                String sData;
+                String sLine;
+                while(xFrame->ReadByteStringLine(sLine, RTL_TEXTENCODING_MS_1252))
+                {
+                    sData += sLine;
+                    sData += '\n';
+                }
+                sData.ConvertLineEnd();
+
+                Reference<container::XNameContainer> xDialog(
+                    xSF->createInstance(
+                       OUString(RTL_CONSTASCII_USTRINGPARAM(
+                           "com.sun.star.awt.UnoControlDialogModel"))), uno::UNO_QUERY);
+
+                OCX_UserForm aForm(xVBAStg, *aIter, *aIter, xDialog, xSF );
+                aForm.pDocSh = &rDocSh;
+                sal_Bool bOk = aForm.Read(xTypes);
+                DBG_ASSERT(bOk, "Had unexpected content, not risking this module");
+                if (bOk)
+                    aForm.Import(xLib);
+            }
+        }
+    }
+    catch(...)
+    {
+        DBG_ERRORFILE( "SvxImportMSVBasic::ImportForms_Impl - any exception caught" );
+        //bRet = false;
+    }
+    SFX_APP()->LeaveBasicCall();
+    return bRet;
+}
+
+
+BOOL SvxImportMSVBasic::CopyStorage_Impl( const String& rStorageName,
+									 	const String& rSubStorageName)
+{
+	BOOL bValidStg = FALSE;
+	{
+		SvStorageRef xVBAStg( xRoot->OpenSotStorage( rStorageName,
+									STREAM_READWRITE | STREAM_NOCREATE |
+									STREAM_SHARE_DENYALL ));
+		if( xVBAStg.Is() && !xVBAStg->GetError() )
+		{
+			SvStorageRef xVBASubStg( xVBAStg->OpenSotStorage( rSubStorageName,
+								 	STREAM_READWRITE | STREAM_NOCREATE |
+									STREAM_SHARE_DENYALL ));
+			if( xVBASubStg.Is() && !xVBASubStg->GetError() )
+			{
+                // then we will copy these storages into the (temporary) storage of the document
+				bValidStg = TRUE;
+			}
+		}
+	}
+
+	if( bValidStg )
+	{
+		String aDstStgName( GetMSBasicStorageName() );
+        SotStorageRef xDst = SotStorage::OpenOLEStorage( rDocSh.GetStorage(), aDstStgName, STREAM_READWRITE | STREAM_TRUNC );
+        SotStorageRef xSrc = xRoot->OpenSotStorage( rStorageName, STREAM_STD_READ );
+
+        // TODO/LATER: should we commit the storage?
+        xSrc->CopyTo( xDst );
+        xDst->Commit();
+        ErrCode nError = xDst->GetError();
+        if ( nError == ERRCODE_NONE )
+            nError = xSrc->GetError();
+        if ( nError != ERRCODE_NONE )
+            xRoot->SetError( nError );
+        else
+            bValidStg = TRUE;
+	}
+
+	return bValidStg;
+}
+
+BOOL SvxImportMSVBasic::ImportCode_Impl( const String& rStorageName,
+										const String &rSubStorageName,
+										BOOL bAsComment, BOOL bStripped )
+{
+	BOOL bRet = FALSE;
+	bAsComment = FALSE;
+	VBA_Impl aVBA( *xRoot, bAsComment );
+	if( aVBA.Open(rStorageName,rSubStorageName) )
+	{
+		SFX_APP()->EnterBasicCall();
+        Reference<XLibraryContainer> xLibContainer = rDocSh.GetBasicContainer();
+		DBG_ASSERT( xLibContainer.is(), "No BasicContainer!" );
+
+        UINT16 nStreamCount = aVBA.GetNoStreams();
+		Reference<XNameContainer> xLib;
+        if( xLibContainer.is() && nStreamCount )
+        {
+            String aLibName( RTL_CONSTASCII_USTRINGPARAM( "Standard" ) );
+		    if( !xLibContainer->hasByName( aLibName ) )
+			    xLibContainer->createLibrary( aLibName );
+
+            Any aLibAny = xLibContainer->getByName( aLibName );
+		    aLibAny >>= xLib;
+        }
+		if( xLib.is() )
+		{
+			for( UINT16 i=0; i<nStreamCount;i++)
+			{
+				StringArray aDecompressed = aVBA.Decompress(i);
+#if 0
+/*  DR 2005-08-11 #124850# Do not filter special characters from module name.
+    Just put the original module name and let the Basic interpreter deal with
+    it. Needed for roundtrip...
+ */
+				ByteString sByteBasic(aVBA.GetStreamName(i),
+					RTL_TEXTENCODING_ASCII_US,
+						(RTL_UNICODETOTEXT_FLAGS_UNDEFINED_UNDERLINE|
+						RTL_UNICODETOTEXT_FLAGS_INVALID_UNDERLINE |
+						RTL_UNICODETOTEXT_FLAGS_PRIVATE_MAPTO0 |
+						RTL_UNICODETOTEXT_FLAGS_NOCOMPOSITE)
+				);
+
+				const String sBasicModule(sByteBasic,
+					RTL_TEXTENCODING_ASCII_US);
+#else
+                const String &sBasicModule = aVBA.GetStreamName( i);
+#endif
+                /* #117718# expose information regarding type of Module
+                * Class, Form or plain 'ould VBA module with a REM statment
+                * at the top of the module. Mapping of Module Name
+                * to type is performed in  VBA_Impl::Open() method,
+                * ( msvbasic.cxx ) by examining the PROJECT stream.
+                */
+
+                // using name from aVBA.GetStreamName
+                // because the encoding of the same returned
+                // is the same as the encoding for the names
+                // that are keys in the map used by GetModuleType method
+                const String &sOrigVBAModName = aVBA.GetStreamName( i );
+                ModuleType mType = aVBA.GetModuleType( sOrigVBAModName );
+
+                rtl::OUString sClassRem( RTL_CONSTASCII_USTRINGPARAM( "Rem Attribute VBA_ModuleType=" ) );
+
+                rtl::OUString modeTypeComment;
+
+                switch( mType )
+                {
+                    case Class:
+                        modeTypeComment = sClassRem +
+                            ::rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "VBAClassModule\n" ) );
+                        break;
+                    case Form:
+                        modeTypeComment = sClassRem +
+                            ::rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "VBAFormModule\n" ) );
+                        break;
+                    case Document:
+                        modeTypeComment = sClassRem +
+                            ::rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "VBADocumentModule\n" ) );
+                        break;
+                    case Normal:
+                        modeTypeComment = sClassRem +
+                            ::rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "VBAModule\n" ) );
+                        break;
+                    case Unknown:
+                        modeTypeComment = sClassRem +
+                            ::rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "VBAUnknown\n" ) );
+                        break;
+                    default:
+                        DBG_ERRORFILE( "SvxImportMSVBasic::ImportCode_Impl - unknown module type" );
+                        break;
+                }
+				static ::rtl::OUString sVBAOption( RTL_CONSTASCII_USTRINGPARAM( "Option VBASupport 1\n" ) ); 
+				static ::rtl::OUString sClassOption( RTL_CONSTASCII_USTRINGPARAM( "Option ClassModule\n" ) ); 
+				if ( !bAsComment )
+				{
+					modeTypeComment = modeTypeComment + sVBAOption;
+					if ( mType == Class )
+						modeTypeComment = modeTypeComment + sClassOption;
+
+				}
+
+				String sModule(sBasicModule); //#i52606# no need to split Macros in 64KB blocks any more!
+				String sTemp;
+				if (bAsComment)
+				{
+					sTemp+=String(RTL_CONSTASCII_USTRINGPARAM( "Sub " ));
+					String sMunge(sModule);
+					//Streams can have spaces in them, but modulenames
+					//cannot !
+					sMunge.SearchAndReplaceAll(' ','_');
+
+					sTemp += sMunge;
+					sTemp.AppendAscii("\n");
+				};
+	            ::rtl::OUString aSource(sTemp);
+
+				for(ULONG j=0;j<aDecompressed.GetSize();j++)
+				{
+					if (bStripped)
+					{
+                        String *pStr = aDecompressed.Get(j);
+                        bool bMac = true;
+                        xub_StrLen nBegin = pStr->Search('\x0D');
+                        if ((STRING_NOTFOUND != nBegin) && (pStr->Len() > 1) && (pStr->GetChar(nBegin+1) == '\x0A'))
+                            bMac = false;
+
+                        const char cLineEnd = bMac ? '\x0D' : '\x0A';
+                        const String sAttribute(String::CreateFromAscii(
+                            bAsComment ? "Rem Attribute" : "Attribute"));
+						nBegin = 0;
+						while (STRING_NOTFOUND != (nBegin =	pStr->Search(sAttribute, nBegin)))
+						{
+                            if ((nBegin) && pStr->GetChar(nBegin-1) != cLineEnd)
+							{
+                                // npower #i63766# Need to skip instances of Attribute
+								// that are NOT Attribute statements
+								nBegin = nBegin + sAttribute.Len();
+                                continue;
+							}
+							xub_StrLen nEnd = pStr->Search(cLineEnd ,nBegin);
+                            // DR #i26521# catch STRING_NOTFOUND, will loop endless otherwise
+                            if( nEnd == STRING_NOTFOUND )
+                                pStr->Erase();
+                            else
+                                pStr->Erase(nBegin, (nEnd-nBegin)+1);
+						}
+					}
+					if( aDecompressed.Get(j)->Len() )
+					{
+			            aSource+=::rtl::OUString( *aDecompressed.Get(j) );
+					}
+
+				}
+				if (bAsComment)
+				{
+						aSource += rtl::OUString::createFromAscii("\nEnd Sub");
+				}
+				::rtl::OUString aModName( sModule );
+				//if ( aSource.getLength() )
+				{
+                    Reference< script::XObjectProvider > xVBAObjectProvider;
+                    if( mType == Document )
+                    {
+                        Reference< XMultiServiceFactory> xSF(rDocSh.GetModel(), UNO_QUERY);
+                        if ( xSF.is() )
+                        {
+                            try
+                            {
+                                uno::Sequence< uno::Any > aArgs(1);
+                                aArgs[0] = uno::Any( aModName );
+                                    xVBAObjectProvider.set( xSF->createInstanceWithArguments( rtl::OUString(RTL_CONSTASCII_USTRINGPARAM( "org.openoffice.vba.VBAObjectModuleObjectProvider")), aArgs), UNO_QUERY );
+                            }
+                            catch( Exception& ) { }
+                        }
+                    }
+					aSource = modeTypeComment + aSource;
+
+					Any aSourceAny;
+                    if ( xVBAObjectProvider.is() && mType == Document )
+                    {
+                        script::ModuleInfo sModuleInfo;
+                        sModuleInfo.ModuleName = aModName;
+                        sModuleInfo.ModuleSource = aSource;
+                        sModuleInfo.ModuleType == Document;
+                        sModuleInfo.ModuleObjectProvider.set( xVBAObjectProvider, UNO_QUERY );
+                        aSourceAny <<= sModuleInfo;
+                    }
+                    else
+					    aSourceAny <<= aSource;
+					if( xLib->hasByName( aModName ) )
+						xLib->replaceByName( aModName, aSourceAny );
+					else
+						xLib->insertByName( aModName, aSourceAny );
+				}                                
+
+				bRet = true;
+			}
+		}
+		SFX_APP()->LeaveBasicCall();
+	}
+	return bRet;
+}
+
+ULONG SvxImportMSVBasic::SaveOrDelMSVBAStorage( BOOL bSaveInto,
+												const String& rStorageName )
+{
+	ULONG nRet = ERRCODE_NONE;
+    uno::Reference < embed::XStorage > xSrcRoot( rDocSh.GetStorage() );
+	String aDstStgName( GetMSBasicStorageName() );
+    SotStorageRef xVBAStg( SotStorage::OpenOLEStorage( xSrcRoot, aDstStgName,
+                                STREAM_READWRITE | STREAM_NOCREATE | STREAM_SHARE_DENYALL ) );
+	if( xVBAStg.Is() && !xVBAStg->GetError() )
+	{
+		xVBAStg = 0;
+		if( bSaveInto )
+		{
+			BasicManager *pBasicMan = rDocSh.GetBasicManager();
+			if( pBasicMan && pBasicMan->IsBasicModified() )
+				nRet = ERRCODE_SVX_MODIFIED_VBASIC_STORAGE;
+
+            SotStorageRef xSrc = SotStorage::OpenOLEStorage( xSrcRoot, aDstStgName, STREAM_STD_READ );
+            SotStorageRef xDst = xRoot->OpenSotStorage( rStorageName, STREAM_READWRITE | STREAM_TRUNC );
+            xSrc->CopyTo( xDst );
+            xDst->Commit();
+            ErrCode nError = xDst->GetError();
+            if ( nError == ERRCODE_NONE )
+                nError = xSrc->GetError();
+            if ( nError != ERRCODE_NONE )
+                xRoot->SetError( nError );
+		}
+	}
+
+	return nRet;
+}
+
+// check if the MS-VBA-Storage exists in the RootStorage of the DocShell.
+// If it exists, then return the WarningId for losing the information.
+ULONG SvxImportMSVBasic::GetSaveWarningOfMSVBAStorage( SfxObjectShell &rDocSh)
+{
+    uno::Reference < embed::XStorage > xSrcRoot( rDocSh.GetStorage() );
+    SvStorageRef xVBAStg( SotStorage::OpenOLEStorage( xSrcRoot, GetMSBasicStorageName(),
+					STREAM_READ | STREAM_NOCREATE | STREAM_SHARE_DENYALL ));
+	return ( xVBAStg.Is() && !xVBAStg->GetError() )
+					? ERRCODE_SVX_VBASIC_STORAGE_EXIST
+					: ERRCODE_NONE;
+}
+
+String SvxImportMSVBasic::GetMSBasicStorageName()
+{
+    return String( RTL_CONSTASCII_USTRINGPARAM( "_MS_VBA_Macros" ) );
+}
+
+/* vi:set tabstop=4 shiftwidth=4 expandtab: */
--- sc/inc/servuno.hxx.bak	1970-01-01 08:00:00.000000000 +0800
+++ sc/inc/servuno.hxx	2007-10-15 11:51:05.000000000 +0800
@@ -0,0 +1,125 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile: servuno.hxx,v $
+ *
+ *  $Revision: 1.12 $
+ *
+ *  last change: $Author: rt $ $Date: 2005/09/08 17:56:51 $
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+
+#ifndef SC_SERVUNO_HXX
+#define SC_SERVUNO_HXX
+
+#ifndef _COM_SUN_STAR_UNO_XINTERFACE_HPP_
+#include <com/sun/star/uno/XInterface.hpp>
+#endif
+#ifndef _COM_SUN_STAR_UNO_SEQUENCE_HXX_
+#include <com/sun/star/uno/Sequence.hxx>
+#endif
+
+class String;
+class ScDocShell;
+
+
+//!	AutoFormat wirklich hier oder besser global??????
+
+#define SC_SERVICE_SHEET		0
+#define SC_SERVICE_URLFIELD		1
+#define SC_SERVICE_PAGEFIELD	2
+#define SC_SERVICE_PAGESFIELD	3
+#define SC_SERVICE_DATEFIELD	4
+#define SC_SERVICE_TIMEFIELD	5
+#define SC_SERVICE_TITLEFIELD	6
+#define SC_SERVICE_FILEFIELD	7
+#define SC_SERVICE_SHEETFIELD	8
+#define SC_SERVICE_CELLSTYLE	9
+#define SC_SERVICE_PAGESTYLE	10
+#define SC_SERVICE_AUTOFORMAT	11
+#define SC_SERVICE_CELLRANGES	12
+
+//	drawing layer tables
+#define SC_SERVICE_GRADTAB		13
+#define SC_SERVICE_HATCHTAB		14
+#define SC_SERVICE_BITMAPTAB	15
+#define SC_SERVICE_TRGRADTAB	16
+#define SC_SERVICE_MARKERTAB	17
+#define SC_SERVICE_DASHTAB		18
+#define SC_SERVICE_NUMRULES		19
+
+#define SC_SERVICE_DOCDEFLTS	20
+#define SC_SERVICE_DRAWDEFLTS	21
+
+#define SC_SERVICE_DOCSPRSETT	22
+#define SC_SERVICE_DOCCONF		23
+
+#define SC_SERVICE_IMAP_RECT	24
+#define SC_SERVICE_IMAP_CIRC	25
+#define SC_SERVICE_IMAP_POLY	26
+
+// #100263# Support creation of GraphicObjectResolver and EmbeddedObjectResolver
+#define SC_SERVICE_EXPORT_GOR	27
+#define SC_SERVICE_IMPORT_GOR	28
+#define SC_SERVICE_EXPORT_EOR	29
+#define SC_SERVICE_IMPORT_EOR	30
+
+#define SC_SERVICE_VALBIND		31
+#define SC_SERVICE_LISTCELLBIND	32
+#define SC_SERVICE_LISTSOURCE	33
+
+#define SC_SERVICE_CELLADDRESS  34
+#define SC_SERVICE_RANGEADDRESS 35
+
+#define SC_SERVICE_SHEETDOCSET  36
+
+// BM
+#define SC_SERVICE_CHDATAPROV   37
+
+#define SC_SERVICE_FORMULAPARS  38
+#define SC_SERVICE_OPCODEMAPPER 39
+
+#define SC_SERVICE_VBAOBJECTPROVIDER   40
+#define SC_SERVICE_COUNT        41
+#define SC_SERVICE_INVALID		USHRT_MAX
+
+
+class ScServiceProvider
+{
+public:
+							// pDocShell wird nicht fuer alle Services benoetigt
+	static ::com::sun::star::uno::Reference< ::com::sun::star::uno::XInterface >
+							MakeInstance( sal_uInt16 nType, ScDocShell* pDocShell );
+	static ::com::sun::star::uno::Sequence<rtl::OUString> GetAllServiceNames();
+	static String			GetProviderName(sal_uInt16 nObjectType);
+	static sal_uInt16		GetProviderType(const String& rServiceName);
+};
+
+
+
+#endif
+
--- sc/source/ui/unoobj/servuno.cxx.bak	1970-01-01 08:00:00.000000000 +0800
+++ sc/source/ui/unoobj/servuno.cxx	2007-10-15 11:51:05.000000000 +0800
@@ -0,0 +1,475 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile: servuno.cxx,v $
+ *
+ *  $Revision: 1.15 $
+ *
+ *  last change: $Author: vg $ $Date: 2007/05/22 20:11:51 $
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+
+// MARKER(update_precomp.py): autogen include statement, do not remove
+#include "precompiled_sc.hxx"
+
+
+
+#include <tools/debug.hxx>
+#include <svtools/unoimap.hxx>
+#include <svx/unofill.hxx>
+
+#ifndef _SVX_UNONRULE_HXX
+#include <svx/unonrule.hxx>
+#endif
+
+#ifndef _COM_SUN_STAR_SHEET_XSPREADSHEETDOCUMENT_HPP_
+#include <com/sun/star/sheet/XSpreadsheetDocument.hpp>
+#endif
+
+#include "servuno.hxx"
+#include "unonames.hxx"
+#include "cellsuno.hxx"
+#include "fielduno.hxx"
+#include "styleuno.hxx"
+#include "afmtuno.hxx"
+#include "defltuno.hxx"
+#include "drdefuno.hxx"
+#include "docsh.hxx"
+#include "drwlayer.hxx"
+#include "confuno.hxx"
+#include "shapeuno.hxx"
+#include "cellvaluebinding.hxx"
+#include "celllistsource.hxx"
+#include "addruno.hxx"
+#include "chart2uno.hxx"
+#include "tokenuno.hxx"
+
+// #100263# Support creation of GraphicObjectResolver and EmbeddedObjectResolver
+#ifndef _XMLEOHLP_HXX
+#include <svx/xmleohlp.hxx>
+#endif
+
+#ifndef _XMLGRHLP_HXX
+#include <svx/xmlgrhlp.hxx>
+#endif
+
+#include "scextopt.hxx"
+#include <com/sun/star/script/XObjectProvider.hpp>
+#include <comphelper/processfactory.hxx>
+
+using namespace ::com::sun::star;
+
+class ScVbaObjectProvider : public ::cppu::WeakImplHelper2< script::XObjectProvider, lang::XInitialization >
+{
+    ScDocShell* mpDocShell;
+    uno::Any aObj;
+    String msName;
+public:
+    ScVbaObjectProvider( const rtl::OUString& sName, ScDocShell* pDocShell ) : mpDocShell( pDocShell ), msName(sName) {}
+    ScVbaObjectProvider( ScDocShell* pDocShell ) : mpDocShell( pDocShell ) {}
+    virtual void SAL_CALL initialize( const uno::Sequence< uno::Any >& aArguments ) throw (uno::Exception, uno::RuntimeException)
+    {
+        OSL_TRACE("ScVbaObjectProvider::initialize ");
+        if(aArguments.getLength() != 1)
+        {
+            throw lang::IllegalArgumentException(rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("give a string instanciating this component!") ), static_cast< script::XObjectProvider * >(this), 0 );
+        }
+        rtl::OUString sName;
+        aArguments[0] >>= sName;
+        msName = sName;
+    }
+    virtual uno::Any SAL_CALL getObject() throw (uno::RuntimeException)
+    {
+        if ( !aObj.hasValue() )
+        {
+            uno::Reference<lang::XMultiServiceFactory> xSF(comphelper::getProcessServiceFactory());
+            uno::Reference<beans::XPropertySet> xProps(xSF, uno::UNO_QUERY);
+            if( xProps.is() )
+            {
+                ScDocument* pDoc = mpDocShell->GetDocument();
+                ScExtDocOptions* pExtOptions = pDoc->GetExtDocOptions();
+                ScExtDocSettings pExtSettings = pExtOptions->GetDocSettings();
+                String sGlobCodeName = pExtSettings.maGlobCodeName;
+                uno::Reference< uno::XInterface > xIf;
+
+                uno::Sequence< uno::Any > aArgs(2);
+                aArgs[0] = uno::Any( uno::Reference< uno::XInterface >() );
+                aArgs[1] = uno::Any( mpDocShell->GetModel() );
+                uno::Reference< uno::XInterface > xWorkbook( xSF->createInstanceWithArguments(  rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("org.openoffice.excel.Workbook") ), aArgs ), uno::UNO_QUERY );
+                if( sGlobCodeName == msName )
+                {
+                    xIf.set( xWorkbook, uno::UNO_QUERY );
+                }
+                 else
+                 {
+                    String sCodeName;
+                    SCTAB nCount = pExtOptions->GetCodeNameCount();
+                    for( SCTAB i = 0; i < nCount; i++ )
+                    {
+                        sCodeName = pExtOptions->GetCodeName( i );
+                        if( sCodeName == msName )
+                        {
+                            String sSheetName;
+                            if( pDoc->GetName( i, sSheetName ) )
+                            {
+                            uno::Reference< frame::XModel > xModel( mpDocShell->GetModel() );
+                            uno::Reference <sheet::XSpreadsheetDocument> xSpreadDoc( xModel, uno::UNO_QUERY_THROW );
+                            uno::Reference<sheet::XSpreadsheets > xSheets( xSpreadDoc->getSheets(), uno::UNO_QUERY_THROW );
+                            uno::Reference< container::XIndexAccess > xIndexAccess( xSheets, uno::UNO_QUERY_THROW );
+                            uno::Reference< sheet::XSpreadsheet > xSheet( xIndexAccess->getByIndex( i ), uno::UNO_QUERY_THROW );
+                            uno::Sequence< uno::Any > aArgs(3);
+                            aArgs[0] = uno::Any( xWorkbook );
+                            aArgs[1] = uno::Any( xModel );
+                            aArgs[2] = uno::Any( rtl::OUString( sSheetName ) );
+                            xIf.set( xSF->createInstanceWithArguments(  rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("org.openoffice.excel.Worksheet") ), aArgs ), uno::UNO_QUERY );
+                            }
+                        }
+                    }
+                 }
+                 if( xIf.is() )
+                 {
+                    aObj <<= xIf;
+                 }
+            }
+        }
+        return aObj;
+    }
+};
+
+//------------------------------------------------------------------------
+
+static const sal_Char* __FAR_DATA aProvNames[SC_SERVICE_COUNT] =
+	{
+		"com.sun.star.sheet.Spreadsheet",			// SC_SERVICE_SHEET
+		"com.sun.star.text.TextField.URL",			// SC_SERVICE_URLFIELD
+		"com.sun.star.text.TextField.PageNumber",	// SC_SERVICE_PAGEFIELD
+		"com.sun.star.text.TextField.PageCount",	// SC_SERVICE_PAGESFIELD
+		"com.sun.star.text.TextField.Date",			// SC_SERVICE_DATEFIELD
+		"com.sun.star.text.TextField.Time",			// SC_SERVICE_TIMEFIELD
+		"com.sun.star.text.TextField.DocumentTitle",// SC_SERVICE_TITLEFIELD
+		"com.sun.star.text.TextField.FileName",		// SC_SERVICE_FILEFIELD
+		"com.sun.star.text.TextField.SheetName",	// SC_SERVICE_SHEETFIELD
+		"com.sun.star.style.CellStyle",				// SC_SERVICE_CELLSTYLE
+		"com.sun.star.style.PageStyle",				// SC_SERVICE_PAGESTYLE
+		"com.sun.star.sheet.TableAutoFormat",		// SC_SERVICE_AUTOFORMAT
+		"com.sun.star.sheet.SheetCellRanges",		// SC_SERVICE_CELLRANGES
+		"com.sun.star.drawing.GradientTable",		// SC_SERVICE_GRADTAB
+		"com.sun.star.drawing.HatchTable",			// SC_SERVICE_HATCHTAB
+		"com.sun.star.drawing.BitmapTable",			// SC_SERVICE_BITMAPTAB
+		"com.sun.star.drawing.TransparencyGradientTable",	// SC_SERVICE_TRGRADTAB
+		"com.sun.star.drawing.MarkerTable",			// SC_SERVICE_MARKERTAB
+		"com.sun.star.drawing.DashTable",			// SC_SERVICE_DASHTAB
+		"com.sun.star.text.NumberingRules",			// SC_SERVICE_NUMRULES
+		"com.sun.star.sheet.Defaults",				// SC_SERVICE_DOCDEFLTS
+		"com.sun.star.drawing.Defaults",			// SC_SERVICE_DRAWDEFLTS
+		"com.sun.star.comp.SpreadsheetSettings",	// SC_SERVICE_DOCSPRSETT
+		"com.sun.star.document.Settings",			// SC_SERVICE_DOCCONF
+		"com.sun.star.image.ImageMapRectangleObject",// SC_SERVICE_IMAP_RECT
+		"com.sun.star.image.ImageMapCircleObject",	// SC_SERVICE_IMAP_CIRC
+		"com.sun.star.image.ImageMapPolygonObject",	// SC_SERVICE_IMAP_POLY
+
+		// #100263# Support creation of GraphicObjectResolver and EmbeddedObjectResolver
+		"com.sun.star.document.ExportGraphicObjectResolver",	// SC_SERVICE_EXPORT_GOR
+		"com.sun.star.document.ImportGraphicObjectResolver",	// SC_SERVICE_IMPORT_GOR
+		"com.sun.star.document.ExportEmbeddedObjectResolver",	// SC_SERVICE_EXPORT_EOR
+		"com.sun.star.document.ImportEmbeddedObjectResolver",	// SC_SERVICE_IMPORT_EOR
+
+        SC_SERVICENAME_VALBIND,                    // SC_SERVICE_VALBIND
+        SC_SERVICENAME_LISTCELLBIND,               // SC_SERVICE_LISTCELLBIND
+        SC_SERVICENAME_LISTSOURCE,                 // SC_SERVICE_LISTSOURCE
+        SC_SERVICENAME_CELLADDRESS,                // SC_SERVICE_CELLADDRESS
+        SC_SERVICENAME_RANGEADDRESS,                // SC_SERVICE_RANGEADDRESS
+
+        "com.sun.star.sheet.DocumentSettings",      // SC_SERVICE_SHEETDOCSET
+
+        SC_SERVICENAME_CHDATAPROV,                  // SC_SERVICE_CHDATAPROV
+        SC_SERVICENAME_FORMULAPARS,                 // SC_SERVICE_FORMULAPARS
+        SC_SERVICENAME_OPCODEMAPPER,                 // SC_SERVICE_OPCODEMAPPER
+        "org.openoffice.vba.VBAObjectModuleObjectProvider",// SC_SERVICE_VBAOBJECTPROVIDER
+	};
+
+//
+//	old service names that were in 567 still work in createInstance,
+//	in case some macro is still using them
+//
+
+static const sal_Char* __FAR_DATA aOldNames[SC_SERVICE_COUNT] =
+	{
+		"",											// SC_SERVICE_SHEET
+		"stardiv.one.text.TextField.URL",			// SC_SERVICE_URLFIELD
+		"stardiv.one.text.TextField.PageNumber",	// SC_SERVICE_PAGEFIELD
+		"stardiv.one.text.TextField.PageCount",		// SC_SERVICE_PAGESFIELD
+		"stardiv.one.text.TextField.Date",			// SC_SERVICE_DATEFIELD
+		"stardiv.one.text.TextField.Time",			// SC_SERVICE_TIMEFIELD
+		"stardiv.one.text.TextField.DocumentTitle",	// SC_SERVICE_TITLEFIELD
+		"stardiv.one.text.TextField.FileName",		// SC_SERVICE_FILEFIELD
+		"stardiv.one.text.TextField.SheetName",		// SC_SERVICE_SHEETFIELD
+		"stardiv.one.style.CellStyle",				// SC_SERVICE_CELLSTYLE
+		"stardiv.one.style.PageStyle",				// SC_SERVICE_PAGESTYLE
+		"",											// SC_SERVICE_AUTOFORMAT
+		"",											// SC_SERVICE_CELLRANGES
+		"",											// SC_SERVICE_GRADTAB
+		"",											// SC_SERVICE_HATCHTAB
+		"",											// SC_SERVICE_BITMAPTAB
+		"",											// SC_SERVICE_TRGRADTAB
+		"",											// SC_SERVICE_MARKERTAB
+		"",											// SC_SERVICE_DASHTAB
+		"",											// SC_SERVICE_NUMRULES
+		"",											// SC_SERVICE_DOCDEFLTS
+		"",											// SC_SERVICE_DRAWDEFLTS
+		"",											// SC_SERVICE_DOCSPRSETT
+		"",											// SC_SERVICE_DOCCONF
+		"",											// SC_SERVICE_IMAP_RECT
+		"",											// SC_SERVICE_IMAP_CIRC
+		"",											// SC_SERVICE_IMAP_POLY
+
+		// #100263# Support creation of GraphicObjectResolver and EmbeddedObjectResolver
+		"",											// SC_SERVICE_EXPORT_GOR
+		"",											// SC_SERVICE_IMPORT_GOR
+		"",											// SC_SERVICE_EXPORT_EOR
+		"",											// SC_SERVICE_IMPORT_EOR
+
+		"",											// SC_SERVICE_VALBIND
+		"",											// SC_SERVICE_LISTCELLBIND
+		"",											// SC_SERVICE_LISTSOURCE
+		"",											// SC_SERVICE_CELLADDRESS
+		"",											// SC_SERVICE_RANGEADDRESS
+        "",                                         // SC_SERVICE_SHEETDOCSET
+        "",                                         // SC_SERVICE_CHDATAPROV
+        "",                                         // SC_SERVICE_FORMULAPARS
+        "",                                         // SC_SERVICE_VBAOBJECTPROVIDER
+        ""                                          // SC_SERVICE_OPCODEMAPPER
+	};
+
+
+
+
+//------------------------------------------------------------------------
+
+//	alles static
+
+String ScServiceProvider::GetProviderName(sal_uInt16 nObjectType)
+{
+	String sRet;
+	if (nObjectType < SC_SERVICE_COUNT)
+		sRet = String::CreateFromAscii( aProvNames[nObjectType] );
+	return sRet;
+}
+
+sal_uInt16 ScServiceProvider::GetProviderType(const String& rServiceName)
+{
+	if (rServiceName.Len())
+	{
+		USHORT i;
+		for (i=0; i<SC_SERVICE_COUNT; i++)
+			if (rServiceName.EqualsAscii( aProvNames[i] ))
+				return i;
+
+		for (i=0; i<SC_SERVICE_COUNT; i++)
+        {
+            DBG_ASSERT( aOldNames[i], "ScServiceProvider::GetProviderType: no oldname => crash");
+			if (rServiceName.EqualsAscii( aOldNames[i] ))
+			{
+				DBG_ERROR("old service name used");
+				return i;
+			}
+	}
+	}
+	return SC_SERVICE_INVALID;
+}
+
+uno::Reference<uno::XInterface> ScServiceProvider::MakeInstance(
+									sal_uInt16 nType, ScDocShell* pDocShell )
+{
+	uno::Reference<uno::XInterface> xRet;
+	switch (nType)
+	{
+		case SC_SERVICE_SHEET:
+			//	noch nicht eingefuegt - DocShell=Null
+			xRet.set((sheet::XSpreadsheet*)new ScTableSheetObj(NULL,0));
+			break;
+		case SC_SERVICE_URLFIELD:
+			xRet.set((text::XTextField*)new ScCellFieldObj( NULL, ScAddress(), ESelection() ));
+			break;
+		case SC_SERVICE_PAGEFIELD:
+		case SC_SERVICE_PAGESFIELD:
+		case SC_SERVICE_DATEFIELD:
+		case SC_SERVICE_TIMEFIELD:
+		case SC_SERVICE_TITLEFIELD:
+		case SC_SERVICE_FILEFIELD:
+		case SC_SERVICE_SHEETFIELD:
+			xRet.set((text::XTextField*)new ScHeaderFieldObj( NULL, 0, nType, ESelection() ));
+			break;
+		case SC_SERVICE_CELLSTYLE:
+			xRet.set((style::XStyle*)new ScStyleObj( NULL, SFX_STYLE_FAMILY_PARA, String() ));
+			break;
+		case SC_SERVICE_PAGESTYLE:
+			xRet.set((style::XStyle*)new ScStyleObj( NULL, SFX_STYLE_FAMILY_PAGE, String() ));
+			break;
+		case SC_SERVICE_AUTOFORMAT:
+			xRet.set((container::XIndexAccess*)new ScAutoFormatObj( SC_AFMTOBJ_INVALID ));
+			break;
+		case SC_SERVICE_CELLRANGES:
+			//	wird nicht eingefuegt, sondern gefuellt
+			//	-> DocShell muss gesetzt sein, aber leere Ranges
+			if (pDocShell)
+				xRet.set((sheet::XSheetCellRanges*)new ScCellRangesObj( pDocShell, ScRangeList() ));
+			break;
+
+		case SC_SERVICE_DOCDEFLTS:
+			if (pDocShell)
+				xRet.set((beans::XPropertySet*)new ScDocDefaultsObj( pDocShell ));
+			break;
+		case SC_SERVICE_DRAWDEFLTS:
+			if (pDocShell)
+				xRet.set((beans::XPropertySet*)new ScDrawDefaultsObj( pDocShell ));
+			break;
+
+		//	Drawing layer tables are not in SvxUnoDrawMSFactory,
+		//	because SvxUnoDrawMSFactory doesn't have a SdrModel pointer.
+		//	Drawing layer is always allocated if not there (MakeDrawLayer).
+
+		case SC_SERVICE_GRADTAB:
+			if (pDocShell)
+				xRet.set(SvxUnoGradientTable_createInstance( pDocShell->MakeDrawLayer() ));
+			break;
+		case SC_SERVICE_HATCHTAB:
+			if (pDocShell)
+				xRet.set(SvxUnoHatchTable_createInstance( pDocShell->MakeDrawLayer() ));
+			break;
+		case SC_SERVICE_BITMAPTAB:
+			if (pDocShell)
+				xRet.set(SvxUnoBitmapTable_createInstance( pDocShell->MakeDrawLayer() ));
+			break;
+		case SC_SERVICE_TRGRADTAB:
+			if (pDocShell)
+				xRet.set(SvxUnoTransGradientTable_createInstance( pDocShell->MakeDrawLayer() ));
+			break;
+		case SC_SERVICE_MARKERTAB:
+			if (pDocShell)
+				xRet.set(SvxUnoMarkerTable_createInstance( pDocShell->MakeDrawLayer() ));
+			break;
+		case SC_SERVICE_DASHTAB:
+			if (pDocShell)
+				xRet.set(SvxUnoDashTable_createInstance( pDocShell->MakeDrawLayer() ));
+			break;
+		case SC_SERVICE_NUMRULES:
+			if (pDocShell)
+				xRet.set(SvxCreateNumRule( pDocShell->MakeDrawLayer() ));
+			break;
+		case SC_SERVICE_DOCSPRSETT:
+        case SC_SERVICE_SHEETDOCSET:
+		case SC_SERVICE_DOCCONF:
+			if (pDocShell)
+				xRet.set((beans::XPropertySet*)new ScDocumentConfiguration(pDocShell));
+			break;
+
+		case SC_SERVICE_IMAP_RECT:
+			xRet.set(SvUnoImageMapRectangleObject_createInstance( ScShapeObj::GetSupportedMacroItems() ));
+			break;
+		case SC_SERVICE_IMAP_CIRC:
+			xRet.set(SvUnoImageMapCircleObject_createInstance( ScShapeObj::GetSupportedMacroItems() ));
+			break;
+		case SC_SERVICE_IMAP_POLY:
+			xRet.set(SvUnoImageMapPolygonObject_createInstance( ScShapeObj::GetSupportedMacroItems() ));
+			break;
+
+		// #100263# Support creation of GraphicObjectResolver and EmbeddedObjectResolver
+		case SC_SERVICE_EXPORT_GOR:
+			xRet.set((::cppu::OWeakObject * )new SvXMLGraphicHelper( GRAPHICHELPER_MODE_WRITE ));
+			break;
+
+		case SC_SERVICE_IMPORT_GOR:
+			xRet.set((::cppu::OWeakObject * )new SvXMLGraphicHelper( GRAPHICHELPER_MODE_READ ));
+			break;
+
+		case SC_SERVICE_EXPORT_EOR:
+			if (pDocShell)
+				xRet.set((::cppu::OWeakObject * )new SvXMLEmbeddedObjectHelper( *pDocShell, EMBEDDEDOBJECTHELPER_MODE_WRITE ));
+			break;
+
+		case SC_SERVICE_IMPORT_EOR:
+			if (pDocShell)
+				xRet.set((::cppu::OWeakObject * )new SvXMLEmbeddedObjectHelper( *pDocShell, EMBEDDEDOBJECTHELPER_MODE_READ ));
+			break;
+
+		case SC_SERVICE_VALBIND:
+		case SC_SERVICE_LISTCELLBIND:
+			if (pDocShell)
+			{
+				sal_Bool bListPos = ( nType == SC_SERVICE_LISTCELLBIND );
+				uno::Reference<sheet::XSpreadsheetDocument> xDoc( pDocShell->GetBaseModel(), uno::UNO_QUERY );
+				xRet.set(*new calc::OCellValueBinding( xDoc, bListPos ));
+			}
+			break;
+		case SC_SERVICE_LISTSOURCE:
+			if (pDocShell)
+			{
+				uno::Reference<sheet::XSpreadsheetDocument> xDoc( pDocShell->GetBaseModel(), uno::UNO_QUERY );
+				xRet.set(*new calc::OCellListSource( xDoc ));
+			}
+			break;
+		case SC_SERVICE_CELLADDRESS:
+		case SC_SERVICE_RANGEADDRESS:
+			if (pDocShell)
+			{
+				sal_Bool bRange = ( nType == SC_SERVICE_RANGEADDRESS );
+				xRet.set(*new ScAddressConversionObj( pDocShell, bRange ));
+			}
+			break;
+
+        case SC_SERVICE_CHDATAPROV:
+            if (pDocShell && pDocShell->GetDocument())
+                xRet = *new ScChart2DataProvider( pDocShell->GetDocument() );
+            break;
+
+        case SC_SERVICE_FORMULAPARS:
+            if (pDocShell)
+                xRet.set(static_cast<sheet::XFormulaParser*>(new ScFormulaParserObj( pDocShell )));
+            break;
+
+        case SC_SERVICE_OPCODEMAPPER:
+            xRet.set(static_cast<sheet::XFormulaOpCodeMapper*>(new ScFormulaOpCodeMapperObj));
+            break;
+        case SC_SERVICE_VBAOBJECTPROVIDER:
+            xRet.set(static_cast<script::XObjectProvider*>(new ScVbaObjectProvider( pDocShell )));
+	}
+	return xRet;
+}
+
+uno::Sequence<rtl::OUString> ScServiceProvider::GetAllServiceNames()
+{
+	uno::Sequence<rtl::OUString> aRet(SC_SERVICE_COUNT);
+	rtl::OUString* pArray = aRet.getArray();
+	for (sal_uInt16 i = 0; i < SC_SERVICE_COUNT; i++)
+		pArray[i] = rtl::OUString::createFromAscii( aProvNames[i] );
+	return aRet;
+}
+
+
+
+
--- sc/source/ui/unoobj/makefile.mk.bak	1970-01-01 08:00:00.000000000 +0800
+++ sc/source/ui/unoobj/makefile.mk	2007-10-15 11:51:05.000000000 +0800
@@ -0,0 +1,126 @@
+#*************************************************************************
+#
+#   OpenOffice.org - a multi-platform office productivity suite
+#
+#   $RCSfile: makefile.mk,v $
+#
+#   $Revision: 1.18 $
+#
+#   last change: $Author: vg $ $Date: 2007/05/22 20:11:40 $
+#
+#   The Contents of this file are made available subject to
+#   the terms of GNU Lesser General Public License Version 2.1.
+#
+#
+#     GNU Lesser General Public License Version 2.1
+#     =============================================
+#     Copyright 2005 by Sun Microsystems, Inc.
+#     901 San Antonio Road, Palo Alto, CA 94303, USA
+#
+#     This library is free software; you can redistribute it and/or
+#     modify it under the terms of the GNU Lesser General Public
+#     License version 2.1, as published by the Free Software Foundation.
+#
+#     This library is distributed in the hope that it will be useful,
+#     but WITHOUT ANY WARRANTY; without even the implied warranty of
+#     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+#     Lesser General Public License for more details.
+#
+#     You should have received a copy of the GNU Lesser General Public
+#     License along with this library; if not, write to the Free Software
+#     Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+#     MA  02111-1307  USA
+#
+#*************************************************************************
+
+PRJ=..$/..$/..
+
+PRJNAME=sc
+TARGET=unoobj
+
+PROJECTPCH4DLL=TRUE
+PROJECTPCH=ui_pch
+PDBTARGET=ui_pch
+PROJECTPCHSOURCE=..\pch\ui_pch
+LIBTARGET=NO
+ENABLE_EXCEPTIONS=TRUE
+
+AUTOSEG=true
+
+# --- Settings -----------------------------------------------------
+
+.INCLUDE :  scpre.mk
+.INCLUDE :  settings.mk
+.INCLUDE :  sc.mk
+.INCLUDE :  $(PRJ)$/util$/makefile.pmk
+
+INCPRE=$(INCCOM)$/vbaobj
+# --- Files --------------------------------------------------------
+SLO1FILES =  \
+        $(SLO)$/docuno.obj \
+        $(SLO)$/servuno.obj \
+        $(SLO)$/defltuno.obj \
+        $(SLO)$/drdefuno.obj \
+        $(SLO)$/cellsuno.obj \
+        $(SLO)$/tokenuno.obj \
+        $(SLO)$/textuno.obj \
+        $(SLO)$/notesuno.obj \
+        $(SLO)$/cursuno.obj \
+        $(SLO)$/srchuno.obj \
+        $(SLO)$/fielduno.obj \
+        $(SLO)$/miscuno.obj \
+        $(SLO)$/optuno.obj \
+        $(SLO)$/appluno.obj \
+        $(SLO)$/funcuno.obj \
+        $(SLO)$/nameuno.obj \
+        $(SLO)$/viewuno.obj \
+        $(SLO)$/dispuno.obj \
+        $(SLO)$/datauno.obj \
+        $(SLO)$/dapiuno.obj \
+        $(SLO)$/chartuno.obj \
+        $(SLO)$/chart2uno.obj \
+        $(SLO)$/shapeuno.obj \
+        $(SLO)$/pageuno.obj \
+        $(SLO)$/forbiuno.obj \
+        $(SLO)$/styleuno.obj \
+        $(SLO)$/afmtuno.obj \
+        $(SLO)$/fmtuno.obj \
+        $(SLO)$/linkuno.obj \
+        $(SLO)$/targuno.obj \
+        $(SLO)$/convuno.obj \
+        $(SLO)$/editsrc.obj \
+        $(SLO)$/unoguard.obj \
+        $(SLO)$/confuno.obj \
+        $(SLO)$/filtuno.obj \
+        $(SLO)$/unodoc.obj \
+        $(SLO)$/addruno.obj \
+        $(SLO)$/listenercalls.obj \
+        $(SLO)$/cellvaluebinding.obj \
+        $(SLO)$/celllistsource.obj \
+        $(SLO)$/warnpassword.obj \
+        $(SLO)$/unoreflist.obj \
+        $(SLO)$/ChartRangeSelectionListener.obj
+
+SLO2FILES = \
+	$(SLO)$/scdetect.obj								\
+	$(SLO)$/detreg.obj
+
+SLOFILES = \
+	$(SLO1FILES) \
+	$(SLO2FILES)
+
+LIB1TARGET = \
+	$(SLB)$/$(TARGET).lib
+
+LIB1OBJFILES = \
+	$(SLO1FILES)
+
+.IF "$(OS)$(COM)$(CPUNAME)"=="LINUXGCCSPARC"
+NOOPTFILES= \
+             $(SLO)$/cellsuno.obj
+.ENDIF
+
+# --- Tagets -------------------------------------------------------
+
+.INCLUDE :  target.mk
+
--- basctl/source/basicide/scriptdocument.cxx.bak	1970-01-01 08:00:00.000000000 +0800
+++ basctl/source/basicide/scriptdocument.cxx	2007-10-15 11:51:05.000000000 +0800
@@ -0,0 +1,1341 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile: scriptdocument.cxx,v $
+ *
+ *  $Revision: 1.3 $
+ *
+ *  last change: $Author: kz $ $Date: 2007/05/10 13:19:26 $
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+
+// MARKER(update_precomp.py): autogen include statement, do not remove
+#include "precompiled_basctl.hxx"
+
+#include "scriptdocument.hxx"
+#include "basobj.hxx"
+#include "basidesh.hrc"
+#include "iderid.hxx"
+#include "dlgeddef.hxx"
+#include "localizationmgr.hxx"
+
+/** === begin UNO includes === **/
+#ifndef _COM_SUN_STAR_BEANS_XPROPERTYSET_HPP_
+#include <com/sun/star/beans/XPropertySet.hpp>
+#endif
+#ifndef _COM_SUN_STAR_SCRIPT_XLIBRARYCONTAINER2_HPP_
+#include <com/sun/star/script/XLibraryContainer2.hpp>
+#endif
+#ifndef _COM_SUN_STAR_LANG_XMULTISERVICEFACTORY_HPP_
+#include <com/sun/star/lang/XMultiServiceFactory.hpp>
+#endif
+#ifndef _COM_SUN_STAR_URI_XURIREFERENCEFACTORY_HPP_
+#include <com/sun/star/uri/XUriReferenceFactory.hpp>
+#endif
+#ifndef _COM_SUN_STAR_UTIL_XMACROEXPANDER_HPP_
+#include <com/sun/star/util/XMacroExpander.hpp>
+#endif
+#ifndef _COM_SUN_STAR_DOCUMENT_MACROEXECMODE_HPP_
+#include <com/sun/star/document/MacroExecMode.hpp>
+#endif
+#ifndef _COM_SUN_STAR_SCRIPT_MODULEINFO_HPP_
+#include <com/sun/star/script/ModuleInfo.hpp>
+#endif
+/** === end UNO includes === **/
+
+#include <sfx2/objsh.hxx>
+#include <sfx2/app.hxx>
+#include <sfx2/viewfrm.hxx>
+#include <sfx2/bindings.hxx>
+#include <sfx2/docfile.hxx>
+
+#include <xmlscript/xmldlg_imexp.hxx>
+
+#include <tools/diagnose_ex.h>
+#include <tools/urlobj.hxx>
+
+#include <comphelper/processfactory.hxx>
+#include <comphelper/componentcontext.hxx>
+
+#include <rtl/uri.hxx>
+
+#include <osl/process.h>
+#include <osl/file.hxx>
+
+#include <algorithm>
+#include <set>
+
+//........................................................................
+namespace basctl
+{
+//........................................................................
+
+    /** === begin UNO using === **/
+    using ::com::sun::star::uno::Sequence;
+    using ::com::sun::star::uno::Reference;
+    using ::com::sun::star::frame::XModel;
+    using ::com::sun::star::beans::XPropertySet;
+    using ::com::sun::star::script::XLibraryContainer;
+    using ::com::sun::star::uno::UNO_QUERY_THROW;
+    using ::com::sun::star::beans::XPropertySetInfo;
+    using ::com::sun::star::uno::Exception;
+    using ::com::sun::star::container::XNameContainer;
+    using ::com::sun::star::container::NoSuchElementException;
+    using ::com::sun::star::uno::UNO_QUERY;
+    using ::com::sun::star::task::XStatusIndicator;
+    using ::com::sun::star::uno::makeAny;
+    using ::com::sun::star::script::XLibraryContainer2;
+    using ::com::sun::star::lang::XMultiServiceFactory;
+    using ::com::sun::star::uri::XUriReferenceFactory;
+    using ::com::sun::star::uri::XUriReference;
+    using ::com::sun::star::uno::XComponentContext;
+    using ::com::sun::star::util::XMacroExpander;
+    using ::com::sun::star::io::XInputStreamProvider;
+    using ::com::sun::star::uno::Any;
+    using ::com::sun::star::io::XInputStream;
+    using ::com::sun::star::script::ModuleInfo;
+    /** === end UNO using === **/
+    namespace MacroExecMode = ::com::sun::star::document::MacroExecMode;
+
+    //====================================================================
+    //= helper
+    //====================================================================
+    namespace
+    {
+        //----------------------------------------------------------------
+        static const ::rtl::OUString&   lcl_getScriptLibrariesPropertyName()
+        {
+            static ::rtl::OUString s_sBasicLibraries( RTL_CONSTASCII_USTRINGPARAM( "BasicLibraries" ) );
+            return s_sBasicLibraries;
+        }
+
+        //----------------------------------------------------------------
+        static const ::rtl::OUString&   lcl_getDialogLibrariesPropertyName()
+        {
+            static ::rtl::OUString s_sBasicLibraries( RTL_CONSTASCII_USTRINGPARAM( "DialogLibraries" ) );
+            return s_sBasicLibraries;
+        }
+
+        //----------------------------------------------------------------
+        static bool StringCompareLessThan( const String& lhs, const String& rhs )
+        {
+		    return ( lhs.CompareIgnoreCaseToAscii( rhs ) == COMPARE_LESS );
+        }
+    }
+
+    //====================================================================
+    //= ScriptDocument_Impl
+    //====================================================================
+    class ScriptDocument_Impl
+    {
+    private:
+        SfxObjectShell*             m_pShell;
+        bool                        m_bIsApplication;
+        bool                        m_bValid;
+        Reference< XModel >         m_aDocument;
+        Reference< XPropertySet >   m_xDocProperties;
+
+    public:
+        ScriptDocument_Impl( );
+        ScriptDocument_Impl( SfxObjectShell& _rShell );
+        ScriptDocument_Impl( const Reference< XModel >& _rxDocument );
+
+        /** determines whether the instance refers to a valid "document" with script and
+            dialog libraries
+        */
+        inline  bool    isValid()       const   { return m_bValid; }
+        /// determines whether the "document" refers to the application in real
+        inline  bool    isApplication() const   { return m_bValid && m_bIsApplication; }
+        /// determines whether the document refers to a real document (instead of the application)
+        inline  bool    isDocument()    const   { return m_bValid && !m_bIsApplication; }
+
+        /// returns the SfxObjectShell the document is based on
+        SfxObjectShell* getObjectShell() const { return m_pShell; }
+
+        /// returns a library container belonging to the document
+        Reference< XLibraryContainer > 
+                    getLibraryContainer( LibraryContainerType _eType ) const;
+
+        /// determines whether a given library is part of the shared installation
+        bool        isLibraryShared( const ::rtl::OUString& _rLibName, LibraryContainerType _eType );
+
+        // versions with the same signature/semantics as in ScriptDocument itself
+        bool        isReadOnly() const;
+        BasicManager*
+                    getBasicManager() const;
+        Reference< XModel >
+                    getDocument() const;
+        void        setDocumentModified() const;
+        bool        isDocumentModified() const;
+        bool        saveDocument( const Reference< XStatusIndicator >& _rxStatusIndicator ) const;
+
+        Reference< XNameContainer >
+                    getLibrary( LibraryContainerType _eType, const ::rtl::OUString& _rLibName, bool _bLoadLibrary ) const
+                        SAL_THROW((NoSuchElementException));
+        bool        hasLibrary( LibraryContainerType _eType, const ::rtl::OUString& _rLibName ) const;
+        Reference< XNameContainer >
+                    getOrCreateLibrary( LibraryContainerType _eType, const ::rtl::OUString& _rLibName ) const;
+
+        void        loadLibraryIfExists( LibraryContainerType _eType, const ::rtl::OUString& _rLibrary );
+
+        bool        removeModuleOrDialog( LibraryContainerType _eType, const ::rtl::OUString& _rLibName, const ::rtl::OUString& _rModuleName );
+        bool        hasModuleOrDialog( LibraryContainerType _eType, const ::rtl::OUString& _rLibName, const ::rtl::OUString& _rModName ) const;
+        bool        getModuleOrDialog( LibraryContainerType _eType, const ::rtl::OUString& _rLibName, const ::rtl::OUString& _rObjectName, Any& _out_rModuleOrDialog );
+        bool        renameModuleOrDialog( LibraryContainerType _eType, const ::rtl::OUString& _rLibName, const ::rtl::OUString& _rOldName, const ::rtl::OUString& _rNewName, const Reference< XNameContainer >& _rxExistingDialogModel );
+        bool        createModule( const ::rtl::OUString& _rLibName, const ::rtl::OUString& _rModName, bool _bCreateMain, ::rtl::OUString& _out_rNewModuleCode ) const;
+        bool        insertModuleOrDialog( LibraryContainerType _eType, const ::rtl::OUString& _rObjectName, const ::rtl::OUString& _rModName, const Any& _rElement ) const;
+        bool        updateModule( const ::rtl::OUString& _rLibName, const ::rtl::OUString& _rModName, const ::rtl::OUString& _rModuleCode ) const;
+        bool        createDialog( const ::rtl::OUString& _rLibName, const ::rtl::OUString& _rDialogName, Reference< XInputStreamProvider >& _out_rDialogProvider ) const;
+
+    private:
+        void    impl_initDocument_nothrow( SfxObjectShell& _rShell );
+    };
+
+    //--------------------------------------------------------------------
+    ScriptDocument_Impl::ScriptDocument_Impl()
+        :m_pShell( NULL )
+        ,m_bIsApplication( true )
+        ,m_bValid( true )
+    {
+    }
+
+    //--------------------------------------------------------------------
+    ScriptDocument_Impl::ScriptDocument_Impl( SfxObjectShell& _rShell )
+        :m_pShell( NULL )
+        ,m_bIsApplication( false )
+        ,m_bValid( false )
+    {
+        impl_initDocument_nothrow( _rShell );
+    }
+
+    //--------------------------------------------------------------------
+    ScriptDocument_Impl::ScriptDocument_Impl( const Reference< XModel >& _rxDocument )
+        :m_pShell( NULL )
+        ,m_bIsApplication( false )
+        ,m_bValid( false )
+    {
+        if ( _rxDocument.is() )
+        {
+            SfxObjectShell* pShell = SfxObjectShell::GetFirst();
+            while ( pShell )
+            {
+                if ( pShell->GetModel() == _rxDocument )
+                    break;
+                pShell = SfxObjectShell::GetNext( *pShell );
+            }
+
+            OSL_ENSURE( pShell, "ScriptDocument_Impl::ScriptDocument_Impl: did not find the shell for the given model!" );
+            if ( pShell )
+                impl_initDocument_nothrow( *pShell );
+        }
+    }
+
+    //--------------------------------------------------------------------
+    void ScriptDocument_Impl::impl_initDocument_nothrow( SfxObjectShell& _rShell )
+    {
+        m_pShell = &_rShell;
+
+        try
+        {
+            m_aDocument.set     ( m_pShell->GetModel(), UNO_QUERY_THROW );
+            m_xDocProperties.set( m_pShell->GetModel(), UNO_QUERY );
+            if ( m_xDocProperties.is() )
+            {
+
+                Reference< XPropertySetInfo >   xPSI( m_xDocProperties->getPropertySetInfo(), UNO_QUERY_THROW );
+                m_bValid =
+                        xPSI->hasPropertyByName( lcl_getScriptLibrariesPropertyName() )
+                    &&  xPSI->hasPropertyByName( lcl_getDialogLibrariesPropertyName() );
+            }
+            else
+                m_bValid = false;
+        }
+        catch( const Exception& )
+        {
+            DBG_UNHANDLED_EXCEPTION();
+            m_bValid = false;
+        }
+
+        if ( !m_bValid )
+        {
+            m_aDocument.clear();
+            m_xDocProperties.clear();
+        }
+    }
+    //--------------------------------------------------------------------
+    Reference< XLibraryContainer > ScriptDocument_Impl::getLibraryContainer( LibraryContainerType _eType ) const
+    {
+        OSL_ENSURE( isValid(), "ScriptDocument_Impl::getLibraryContainer: invalid!" );
+
+        Reference< XLibraryContainer > xContainer;
+        if ( !isValid() )
+            return xContainer;
+
+        try
+        {
+            if ( isApplication() )
+                xContainer.set( _eType == E_SCRIPTS ? SFX_APP()->GetBasicContainer() : SFX_APP()->GetDialogContainer(), UNO_QUERY_THROW );
+            else
+            {
+                xContainer.set( m_xDocProperties->getPropertyValue(
+                    _eType == E_SCRIPTS ? lcl_getScriptLibrariesPropertyName() : lcl_getDialogLibrariesPropertyName() ),
+                    UNO_QUERY_THROW );
+            }
+        }
+        catch( const Exception& )
+        {
+            DBG_UNHANDLED_EXCEPTION();
+        }
+        return xContainer;
+    }
+
+    //--------------------------------------------------------------------
+    bool ScriptDocument_Impl::isReadOnly() const
+    {
+        OSL_ENSURE( isValid(), "ScriptDocument_Impl::isReadOnly: invalid state!" );
+        OSL_ENSURE( !isApplication(), "ScriptDocument_Impl::isReadOnly: not allowed to be called for the application!" );
+        if ( !isValid() || isApplication() )
+            return true;
+        return m_pShell->IsReadOnly();
+    }
+
+    //--------------------------------------------------------------------
+    BasicManager* ScriptDocument_Impl::getBasicManager() const
+    {
+        OSL_ENSURE( isValid(), "ScriptDocument_Impl::getBasicManager: invalid state!" );
+        if ( !isValid() )
+            return NULL;
+
+        if ( isApplication() )
+            return SFX_APP()->GetBasicManager();
+
+        return m_pShell->GetBasicManager();
+    }
+
+    //--------------------------------------------------------------------
+    Reference< XModel > ScriptDocument_Impl::getDocument() const
+    {
+        OSL_ENSURE( isValid(), "ScriptDocument_Impl::getDocument: invalid state!" );
+        OSL_ENSURE( isDocument(), "ScriptDocument_Impl::getDocument: for documents only!" );
+        if ( !isValid() || !isDocument() )
+            return NULL;
+
+        return m_aDocument;
+    }
+
+    //--------------------------------------------------------------------
+    Reference< XNameContainer > ScriptDocument_Impl::getLibrary( LibraryContainerType _eType, const ::rtl::OUString& _rLibName, bool _bLoadLibrary ) const
+        SAL_THROW((NoSuchElementException))
+    {
+        OSL_ENSURE( isValid(), "ScriptDocument_Impl::getLibrary: invalid state!" );
+
+        Reference< XNameContainer > xContainer;
+        try
+        {
+	        Reference< XLibraryContainer > xLibContainer = getLibraryContainer( _eType );
+            if ( isValid() )
+            {
+                if ( xLibContainer.is() )
+                    xContainer.set( xLibContainer->getByName( _rLibName ), UNO_QUERY_THROW );
+            }
+
+            if ( !xContainer.is() )
+                throw NoSuchElementException();
+
+	        // load library
+	        if ( _bLoadLibrary && !xLibContainer->isLibraryLoaded( _rLibName ) )
+		        xLibContainer->loadLibrary( _rLibName );
+        }
+        catch( const NoSuchElementException& )
+        {
+            throw;  // allowed to leave
+        }
+        catch( const Exception& )
+        {
+        	DBG_UNHANDLED_EXCEPTION();
+        }
+
+        return xContainer;
+    }
+
+    //--------------------------------------------------------------------
+    bool ScriptDocument_Impl::hasLibrary( LibraryContainerType _eType, const ::rtl::OUString& _rLibName ) const
+    {
+	    bool bHas = false;
+        try
+        {
+	        Reference< XLibraryContainer > xLibContainer = getLibraryContainer( _eType );
+	        bHas = xLibContainer.is() && xLibContainer->hasByName( _rLibName );
+        }
+        catch( const Exception& )
+        {
+        	DBG_UNHANDLED_EXCEPTION();
+        }
+        return bHas;
+    }
+
+    //--------------------------------------------------------------------
+    Reference< XNameContainer > ScriptDocument_Impl::getOrCreateLibrary( LibraryContainerType _eType, const ::rtl::OUString& _rLibName ) const
+    {
+	    Reference< XNameContainer > xLibrary;
+        try
+        {
+	        Reference< XLibraryContainer > xLibContainer( getLibraryContainer( _eType ), UNO_QUERY_THROW );
+            if ( xLibContainer->hasByName( _rLibName ) )
+                xLibrary.set( xLibContainer->getByName( _rLibName ), UNO_QUERY_THROW );
+            else
+		        xLibrary.set( xLibContainer->createLibrary( _rLibName ), UNO_QUERY_THROW );
+
+            if ( !xLibContainer->isLibraryLoaded( _rLibName ) )
+		        xLibContainer->loadLibrary( _rLibName );
+        }
+        catch( const Exception& )
+        {
+        	DBG_UNHANDLED_EXCEPTION();
+        }
+        return xLibrary;
+    }
+
+    //--------------------------------------------------------------------
+    void ScriptDocument_Impl::loadLibraryIfExists( LibraryContainerType _eType, const ::rtl::OUString& _rLibrary )
+    {
+        try
+        {
+            Reference< XLibraryContainer > xLibContainer( getLibraryContainer( _eType ) );
+	        if ( xLibContainer.is() && xLibContainer->hasByName( _rLibrary ) && !xLibContainer->isLibraryLoaded( _rLibrary ) )
+                xLibContainer->loadLibrary( _rLibrary );
+        }
+        catch( const Exception& )
+        {
+        	DBG_UNHANDLED_EXCEPTION();
+        }
+    }
+
+    //--------------------------------------------------------------------
+    bool ScriptDocument_Impl::removeModuleOrDialog( LibraryContainerType _eType, const ::rtl::OUString& _rLibName, const ::rtl::OUString& _rModuleName )
+    {
+        OSL_ENSURE( isValid(), "ScriptDocument_Impl::removeModuleOrDialog: invalid!" );
+        if ( isValid() )
+        {
+            try
+            {
+	            Reference< XNameContainer > xLib( getLibrary( _eType, _rLibName, TRUE ) );
+	            if ( xLib.is() )
+	            {
+		            xLib->removeByName( _rModuleName );
+                    return true;
+	            }
+            }
+            catch( const Exception& )
+            {
+            	DBG_UNHANDLED_EXCEPTION();
+            }
+        }
+		return false;
+    }
+
+    //--------------------------------------------------------------------
+    bool ScriptDocument_Impl::hasModuleOrDialog( LibraryContainerType _eType, const ::rtl::OUString& _rLibName, const ::rtl::OUString& _rModName ) const
+    {
+        OSL_ENSURE( isValid(), "ScriptDocument_Impl::hasModuleOrDialog: invalid!" );
+        if ( !isValid() )
+            return false;
+
+        try
+        {
+	        Reference< XNameContainer > xLib( getLibrary( _eType, _rLibName, TRUE ) );
+	        if ( xLib.is() )
+		        return xLib->hasByName( _rModName );
+        }
+        catch( const Exception& )
+        {
+            DBG_UNHANDLED_EXCEPTION();
+        }
+        return false;
+    }
+
+    //--------------------------------------------------------------------
+    bool ScriptDocument_Impl::getModuleOrDialog( LibraryContainerType _eType, const ::rtl::OUString& _rLibName, const ::rtl::OUString& _rObjectName, Any& _out_rModuleOrDialog )
+    {
+        OSL_ENSURE( isValid(), "ScriptDocument_Impl::getModuleOrDialog: invalid!" );
+        if ( !isValid() )
+            return false;
+
+        _out_rModuleOrDialog.clear();
+        try
+        {
+	        Reference< XNameContainer > xLib( getLibrary( _eType, _rLibName, TRUE ), UNO_QUERY_THROW );
+            if ( xLib->hasByName( _rObjectName ) )
+            {
+                _out_rModuleOrDialog = xLib->getByName( _rObjectName );
+                return true;
+	        }
+        }
+        catch( const Exception& )
+        {
+        	DBG_UNHANDLED_EXCEPTION();
+        }
+        return false;
+    }
+
+    //--------------------------------------------------------------------
+    bool ScriptDocument_Impl::renameModuleOrDialog( LibraryContainerType _eType, const ::rtl::OUString& _rLibName,
+        const ::rtl::OUString& _rOldName, const ::rtl::OUString& _rNewName, const Reference< XNameContainer >& _rxExistingDialogModel )
+    {
+        OSL_ENSURE( isValid(), "ScriptDocument_Impl::renameModuleOrDialog: invalid!" );
+        if ( !isValid() )
+            return false;
+
+        try
+        {
+            Reference< XNameContainer > xLib( getLibrary( _eType, _rLibName, TRUE ), UNO_QUERY_THROW );
+            
+		    // get element
+		    Any aElement( xLib->getByName( _rOldName ) );
+
+		    // remove element from container
+		    xLib->removeByName( _rOldName );
+
+            // if it's a dialog, import and export, to reflect the new name
+            if ( _eType == E_DIALOGS )
+            {
+		        // create dialog model
+                ::comphelper::ComponentContext aContext( ::comphelper::getProcessServiceFactory() );
+                Reference< XNameContainer > xDialogModel;
+                if ( _rxExistingDialogModel.is() )
+                    xDialogModel = _rxExistingDialogModel;
+                else
+                    if ( !aContext.createComponent( "com.sun.star.awt.UnoControlDialogModel", xDialogModel ) )
+                        return false;
+
+                // import dialog model
+                Reference< XInputStreamProvider > xISP( aElement, UNO_QUERY_THROW );
+                if ( !_rxExistingDialogModel.is() )
+                {
+                    Reference< XInputStream > xInput( xISP->createInputStream(), UNO_QUERY_THROW );
+    			    ::xmlscript::importDialogModel( xInput, xDialogModel, aContext.getUNOContext() );
+                }
+
+			    // set new name as property
+			    Reference< XPropertySet > xDlgPSet( xDialogModel, UNO_QUERY_THROW );
+			    xDlgPSet->setPropertyValue( DLGED_PROP_NAME, makeAny( _rNewName ) );
+
+			    // export dialog model
+			    xISP = ::xmlscript::exportDialogModel( xDialogModel, aContext.getUNOContext() );
+			    aElement <<= xISP;
+            }
+
+		    // insert element by new name in container
+		    xLib->insertByName( _rNewName, aElement );
+            return true;
+        }
+        catch( const Exception& )
+        {
+        	DBG_UNHANDLED_EXCEPTION();
+        }
+        return false;
+    }
+
+    //--------------------------------------------------------------------
+    bool ScriptDocument_Impl::createModule( const ::rtl::OUString& _rLibName, const ::rtl::OUString& _rModName, bool _bCreateMain, ::rtl::OUString& _out_rNewModuleCode ) const
+    {
+        _out_rNewModuleCode = ::rtl::OUString();
+        try
+        {
+	        Reference< XNameContainer > xLib( getLibrary( E_SCRIPTS, _rLibName, TRUE ) );
+	        if ( !xLib.is() || xLib->hasByName( _rModName ) )
+                return false;
+
+		    // create new module
+		    _out_rNewModuleCode = ::rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "REM  *****  BASIC  *****\n\n" ) );
+		    if ( _bCreateMain )
+			    _out_rNewModuleCode += ::rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "Sub Main\n\nEnd Sub\n" ) );
+
+		    // insert module into library
+		    xLib->insertByName( _rModName, makeAny( _out_rNewModuleCode ) );
+        }
+        catch( const Exception& )
+        {
+        	DBG_UNHANDLED_EXCEPTION();
+            return false;
+        }
+
+	    return true;
+    }
+
+    //--------------------------------------------------------------------
+    bool ScriptDocument_Impl::insertModuleOrDialog( LibraryContainerType _eType, const ::rtl::OUString& _rLibName, const ::rtl::OUString& _rObjectName, const Any& _rElement ) const
+    {
+        try
+        {
+            Reference< XNameContainer > xLib( getOrCreateLibrary( _eType, _rLibName ), UNO_QUERY_THROW );
+	        if ( xLib->hasByName( _rObjectName ) )
+                return false;
+
+            xLib->insertByName( _rObjectName, _rElement );
+            return true;
+        }
+        catch( const Exception& )
+        {
+        	DBG_UNHANDLED_EXCEPTION();
+        }
+        return false;
+    }
+
+    //--------------------------------------------------------------------
+    bool ScriptDocument_Impl::updateModule( const ::rtl::OUString& _rLibName, const ::rtl::OUString& _rModName, const ::rtl::OUString& _rModuleCode ) const
+    {
+        try
+        {
+            Reference< XNameContainer > xLib( getOrCreateLibrary( E_SCRIPTS, _rLibName ), UNO_QUERY_THROW );
+	        if ( !xLib->hasByName( _rModName ) )
+                return false;
+
+            xLib->replaceByName( _rModName, makeAny( _rModuleCode ) );
+            return true;
+        }
+        catch( const Exception& )
+        {
+        	DBG_UNHANDLED_EXCEPTION();
+        }
+        return false;
+    }
+
+    //--------------------------------------------------------------------
+    bool ScriptDocument_Impl::createDialog( const ::rtl::OUString& _rLibName, const ::rtl::OUString& _rDialogName, Reference< XInputStreamProvider >& _out_rDialogProvider ) const
+    {
+        try
+        {
+	        Reference< XNameContainer > xLib( getLibrary( E_DIALOGS, _rLibName, TRUE ), UNO_QUERY_THROW );
+
+	        // create dialog
+	        _out_rDialogProvider.clear();
+	        if ( xLib->hasByName( _rDialogName ) )
+                return false;
+
+            // create new dialog model
+            ::comphelper::ComponentContext aContext( ::comphelper::getProcessServiceFactory() );
+            Reference< XNameContainer > xDialogModel;
+            if ( !aContext.createComponent( "com.sun.star.awt.UnoControlDialogModel", xDialogModel ) )
+                return false;
+
+		    // set name property
+		    Reference< XPropertySet > xDlgPSet( xDialogModel, UNO_QUERY_THROW );
+		    xDlgPSet->setPropertyValue( DLGED_PROP_NAME, makeAny( _rDialogName ) );
+
+		    // export dialog model
+            _out_rDialogProvider = ::xmlscript::exportDialogModel( xDialogModel, aContext.getUNOContext() );
+
+		    // insert dialog into library
+		    xLib->insertByName( _rDialogName, makeAny( _out_rDialogProvider ) );
+        }
+        catch( const Exception& )
+        {
+        	DBG_UNHANDLED_EXCEPTION();
+        }
+
+	    return _out_rDialogProvider.is();
+    }
+
+    //--------------------------------------------------------------------
+    void ScriptDocument_Impl::setDocumentModified() const
+    {
+        OSL_ENSURE( isValid() && isDocument(), "ScriptDocument_Impl::setDocumentModified: only to be called for real documents!" );
+        if ( isValid() && isDocument() )
+            getObjectShell()->SetModified();
+    }
+
+    //--------------------------------------------------------------------
+    bool ScriptDocument_Impl::isDocumentModified() const
+    {
+        OSL_ENSURE( isValid() && isDocument(), "ScriptDocument_Impl::isDocumentModified: only to be called for real documents!" );
+        if ( isValid() && isDocument() )
+            return getObjectShell()->IsModified();
+        return false;
+    }
+
+    //--------------------------------------------------------------------
+    bool ScriptDocument_Impl::saveDocument( const Reference< XStatusIndicator >& _rxStatusIndicator ) const
+    {
+        OSL_ENSURE( isValid() && isDocument(), "ScriptDocument_Impl::saveDocument: only to be called for real documents!" );
+        if ( !isValid() || !isDocument() )
+            return false;
+
+        const SfxPoolItem* aArgs[2];
+        aArgs[0] = aArgs[1] = NULL;
+
+        ::std::auto_ptr< SfxUnoAnyItem > pStatusIndicatorItem;
+        OSL_ENSURE( _rxStatusIndicator.is(), "ScriptDocument_Impl::saveDocument: no status indicator!" );
+        if ( _rxStatusIndicator.is() )
+            pStatusIndicatorItem.reset( new SfxUnoAnyItem( SID_PROGRESS_STATUSBAR_CONTROL, makeAny( _rxStatusIndicator ) ) );
+        aArgs[0] = pStatusIndicatorItem.get();
+
+        SfxViewFrame* pViewFrame = SfxViewFrame::GetFirst( getObjectShell() );
+        if ( !pViewFrame )
+            return false;
+
+        pViewFrame->GetBindings().Execute( SID_SAVEDOC, aArgs, 0, SFX_CALLMODE_SYNCHRON );
+        return true;
+    }
+
+    //--------------------------------------------------------------------
+    bool ScriptDocument_Impl::isLibraryShared( const ::rtl::OUString& _rLibName, LibraryContainerType _eType )
+    {
+        bool bIsShared = false;
+        try
+        {
+            Reference< XLibraryContainer2 > xLibContainer( getLibraryContainer( _eType ), UNO_QUERY_THROW );
+
+            if ( !xLibContainer->hasByName( _rLibName ) || !xLibContainer->isLibraryLink( _rLibName ) )
+                return false;
+            ::rtl::OUString aFileURL;
+            Reference< XMultiServiceFactory > xMSF( ::comphelper::getProcessServiceFactory() );
+            Reference< XUriReferenceFactory > xUriFac;
+            if ( xMSF.is() )
+            {
+                xUriFac.set(
+                    xMSF->createInstance( ::rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "com.sun.star.uri.UriReferenceFactory" ) ) ),
+                    UNO_QUERY_THROW );
+            }
+
+            ::rtl::OUString aLinkURL( xLibContainer->getLibraryLinkURL( _rLibName ) );
+            Reference< XUriReference > xUriRef( xUriFac->parse( aLinkURL ), UNO_QUERY_THROW );
+
+            ::rtl::OUString aScheme = xUriRef->getScheme();
+            if ( aScheme.equalsIgnoreAsciiCaseAscii( "file" ) )
+            {
+                aFileURL = aLinkURL;
+            }
+            else if ( aScheme.equalsIgnoreAsciiCaseAscii( "vnd.sun.star.pkg" ) )
+            {
+                ::rtl::OUString aAuthority = xUriRef->getAuthority();
+                if ( aAuthority.matchIgnoreAsciiCaseAsciiL( RTL_CONSTASCII_STRINGPARAM( "vnd.sun.star.expand:" ) ) )
+                {
+                    ::rtl::OUString aDecodedURL( aAuthority.copy( sizeof ( "vnd.sun.star.expand:" ) - 1 ) );
+                    aDecodedURL = ::rtl::Uri::decode( aDecodedURL, rtl_UriDecodeWithCharset, RTL_TEXTENCODING_UTF8 );
+                    Reference< XComponentContext > xContext;
+                    Reference< XPropertySet > xProps( xMSF, UNO_QUERY_THROW );
+                    xContext.set( xProps->getPropertyValue( ::rtl::OUString::createFromAscii( "DefaultContext" ) ), UNO_QUERY_THROW );
+                    Reference< XMacroExpander > xMacroExpander(
+                        xContext->getValueByName(
+                        ::rtl::OUString::createFromAscii( "/singletons/com.sun.star.util.theMacroExpander" ) ),
+                        UNO_QUERY_THROW );
+                    aFileURL = xMacroExpander->expandMacros( aDecodedURL );
+                }
+            }
+
+            if ( aFileURL.getLength() )
+            {
+                ::osl::DirectoryItem aFileItem;
+                ::osl::FileStatus aFileStatus( FileStatusMask_FileURL );
+                OSL_VERIFY( ::osl::DirectoryItem::get( aFileURL, aFileItem ) == ::osl::FileBase::E_None );
+                OSL_VERIFY( aFileItem.getFileStatus( aFileStatus ) == ::osl::FileBase::E_None );
+                ::rtl::OUString aCanonicalFileURL( aFileStatus.getFileURL() );
+
+                ::rtl::OUString aShareURL;
+                OSL_VERIFY( osl_getExecutableFile( &aShareURL.pData ) == osl_Process_E_None );
+                sal_Int32 nIndex = aShareURL.lastIndexOf( '/' );
+                if ( nIndex >= 0 )
+                {
+                    nIndex = aShareURL.lastIndexOf( '/', nIndex );
+                    if ( nIndex >= 0 )
+                    {
+                        aShareURL = aShareURL.copy( 0, nIndex + 1 );
+                        aShareURL += ::rtl::OUString::createFromAscii( "share" );
+                    }
+                }
+
+                ::osl::DirectoryItem aShareItem;
+                ::osl::FileStatus aShareStatus( FileStatusMask_FileURL );
+                OSL_VERIFY( ::osl::DirectoryItem::get( aShareURL, aShareItem ) == ::osl::FileBase::E_None );
+                OSL_VERIFY( aShareItem.getFileStatus( aShareStatus ) == ::osl::FileBase::E_None );
+                ::rtl::OUString aCanonicalShareURL( aShareStatus.getFileURL() );
+
+                if ( aCanonicalFileURL.match( aCanonicalShareURL ) )
+                    bIsShared = true;
+            }
+        }
+        catch( const Exception& )
+        {
+        	DBG_UNHANDLED_EXCEPTION();
+        }
+
+        return bIsShared;
+    }
+
+    //====================================================================
+    //= ScriptDocument
+    //====================================================================
+    //--------------------------------------------------------------------
+    ScriptDocument::ScriptDocument()
+        :m_pImpl( new ScriptDocument_Impl() )
+    {
+    }
+
+    //--------------------------------------------------------------------
+    ScriptDocument::ScriptDocument( ScriptDocument::SpecialDocument _eType )
+        :m_pImpl( new ScriptDocument_Impl( Reference< XModel >() ) )
+    {
+        OSL_ENSURE( _eType == NoDocument, "ScriptDocument::ScriptDocument: unknown SpecialDocument type!" );
+        (void)_eType;
+    }
+
+    //--------------------------------------------------------------------
+    ScriptDocument::ScriptDocument( SfxObjectShell& _rShell )
+        :m_pImpl( new ScriptDocument_Impl( _rShell ) )
+    {
+    }
+
+    //--------------------------------------------------------------------
+    ScriptDocument::ScriptDocument( const Reference< XModel >& _rxDocument )
+        :m_pImpl( new ScriptDocument_Impl( _rxDocument ) )
+    {
+        OSL_ENSURE( _rxDocument.is(), "ScriptDocument_Impl::ScriptDocument: document must not be NULL!" );
+            // a NULL document results in an uninitialized instance, and for this
+            // purpose, there is a dedicated constructor
+    }
+
+    //--------------------------------------------------------------------
+    ScriptDocument::ScriptDocument( const ScriptDocument& _rSource )
+        :m_pImpl( _rSource.m_pImpl )
+    {
+    }
+
+    //--------------------------------------------------------------------
+    ScriptDocument::~ScriptDocument()
+    {
+    }
+    
+    //--------------------------------------------------------------------
+    const ScriptDocument& ScriptDocument::getApplicationScriptDocument()
+    {
+        static ScriptDocument s_aApplicationScripts;
+        return s_aApplicationScripts;
+    }
+
+    //--------------------------------------------------------------------
+    ScriptDocument ScriptDocument::getDocumentForBasicManager( const BasicManager* _pManager )
+    {
+        if ( _pManager == SFX_APP()->GetBasicManager() )
+            return getApplicationScriptDocument();
+
+        SfxObjectShell* pDocShell = SfxObjectShell::GetFirst();
+	    while ( pDocShell )
+	    {
+		    if  (   ( pDocShell->GetBasicManager() != SFX_APP()->GetBasicManager() )
+                &&  ( pDocShell->GetBasicManager() == _pManager )
+                )
+		    {
+			    return ScriptDocument( *pDocShell );
+		    }
+		    pDocShell = SfxObjectShell::GetNext( *pDocShell );
+	    }
+
+        OSL_ENSURE( false, "ScriptDocument::getDocumentForBasicManager: did not find a document for this manager!" );
+	    return ScriptDocument( NoDocument );
+    }
+
+    //--------------------------------------------------------------------
+    ScriptDocument ScriptDocument::getDocumentWithCaption( const ::rtl::OUString& _rCaption )
+    {
+        ScriptDocument aDocument( getApplicationScriptDocument() );
+        if ( _rCaption.getLength() != 0 )
+        {
+            SfxViewFrame* pView = SfxViewFrame::GetFirst();
+            while ( pView )
+            {
+                SfxObjectShell* pObjShell = pView->GetObjectShell();
+                if ( pObjShell )
+                {
+                    SfxMedium* pMedium = pObjShell->GetMedium();
+                    if  (   (   pMedium
+                            &&  _rCaption == pMedium->GetURLObject().GetMainURL( INetURLObject::NO_DECODE )
+                            )
+                        ||  ( _rCaption == ::rtl::OUString( pObjShell->GetTitle( SFX_TITLE_CAPTION ) ) )
+                        )
+                    {
+                        aDocument = ScriptDocument( *pObjShell );
+                        break;
+                    }
+                }
+                pView = SfxViewFrame::GetNext( *pView );
+            }
+        }
+        return aDocument;
+    }
+
+    //--------------------------------------------------------------------
+    ScriptDocuments ScriptDocument::getAllScriptDocuments( bool _bIncludingApplication )
+    {
+        ScriptDocuments aDocuments;
+        if ( _bIncludingApplication )
+            aDocuments.push_back( getApplicationScriptDocument() );
+
+        SfxObjectShell* pDocShell = SfxObjectShell::GetFirst();
+        while ( pDocShell )
+        {
+            // exclude invisible docs, and docs without own scripts/dialogs
+            if  (   SfxViewFrame::GetFirst( pDocShell )
+                &&  pDocShell->GetBasicManager() != SFX_APP()->GetBasicManager()
+                )
+            {
+                ScriptDocument aDoc( *pDocShell );
+                OSL_ENSURE( aDoc.isValid(),
+                    "ScriptDocument::getAllScriptDocuments: an SfxObjectShell with own BasicManager, but without library containers?" );
+                if ( aDoc.isValid() )
+                    aDocuments.push_back( aDoc );
+            }
+
+			pDocShell = SfxObjectShell::GetNext( *pDocShell );
+        }
+
+        return aDocuments;
+    }
+    
+    //--------------------------------------------------------------------
+    bool ScriptDocument::operator==( const ScriptDocument& _rhs ) const
+    {
+        return m_pImpl->getObjectShell() == _rhs.m_pImpl->getObjectShell();
+    }
+
+    //--------------------------------------------------------------------
+    sal_Int32 ScriptDocument::hashCode() const
+    {
+        return sal::static_int_cast<sal_Int32>(reinterpret_cast< sal_IntPtr >( m_pImpl->getObjectShell() ));
+    }
+
+    //--------------------------------------------------------------------
+    bool ScriptDocument::isValid() const
+    {
+        return m_pImpl->isValid();
+    }
+
+    //--------------------------------------------------------------------
+    Reference< XLibraryContainer > ScriptDocument::getLibraryContainer( LibraryContainerType _eType ) const
+    {
+        return m_pImpl->getLibraryContainer( _eType );
+    }
+    
+    //--------------------------------------------------------------------
+    Reference< XNameContainer > ScriptDocument::getLibrary( LibraryContainerType _eType, const ::rtl::OUString& _rLibName, bool _bLoadLibrary ) const
+        SAL_THROW((NoSuchElementException))
+    {
+        return m_pImpl->getLibrary( _eType, _rLibName, _bLoadLibrary );
+    }
+
+    //--------------------------------------------------------------------
+    bool ScriptDocument::hasLibrary( LibraryContainerType _eType, const ::rtl::OUString& _rLibName ) const
+    {
+        return m_pImpl->hasLibrary( _eType, _rLibName );
+    }
+
+    //--------------------------------------------------------------------
+    Reference< XNameContainer > ScriptDocument::getOrCreateLibrary( LibraryContainerType _eType, const ::rtl::OUString& _rLibName ) const
+    {
+        return m_pImpl->getOrCreateLibrary( _eType, _rLibName );
+    }
+
+    //--------------------------------------------------------------------
+    void ScriptDocument::loadLibraryIfExists( LibraryContainerType _eType, const ::rtl::OUString& _rLibrary )
+    {
+        m_pImpl->loadLibraryIfExists( _eType, _rLibrary );
+    }
+
+    //--------------------------------------------------------------------
+    Sequence< ::rtl::OUString > ScriptDocument::getObjectNames( LibraryContainerType _eType, const ::rtl::OUString& _rLibName ) const
+    {
+        Sequence< ::rtl::OUString > aModuleNames;
+
+        try
+        {
+            Reference< XNameContainer > xLib( getLibrary( _eType, _rLibName, false ) );
+	        if ( xLib.is() )
+		        aModuleNames = xLib->getElementNames();
+        }
+        catch( const Exception& )
+        {
+        	DBG_UNHANDLED_EXCEPTION();
+        }
+
+		// sort
+        ::std::sort( aModuleNames.getArray() , aModuleNames.getArray() + aModuleNames.getLength() , StringCompareLessThan );
+
+        return aModuleNames;
+    }
+
+    //--------------------------------------------------------------------
+    ::rtl::OUString ScriptDocument::createObjectName( LibraryContainerType _eType, const ::rtl::OUString& _rLibName ) const
+    {
+        ::rtl::OUString aObjectName;
+
+        ::rtl::OUString aBaseName = _eType == E_SCRIPTS
+            ?   ::rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "Module" ) )
+            :   ::rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "Dialog" ) );
+
+        Sequence< ::rtl::OUString > aUsedNames( getObjectNames( _eType, _rLibName ) );
+        ::std::set< ::rtl::OUString > aUsedNamesCheck;
+        ::std::copy( aUsedNames.getConstArray(), aUsedNames.getConstArray() + aUsedNames.getLength(),
+            ::std::insert_iterator< ::std::set< ::rtl::OUString > >( aUsedNamesCheck, aUsedNamesCheck.begin() ) );
+
+	    bool bValid = false;
+	    USHORT i = 1;
+	    while ( !bValid )
+	    {
+		    aObjectName = aBaseName;
+		    aObjectName += String::CreateFromInt32( i );
+
+            if ( aUsedNamesCheck.find( aObjectName ) == aUsedNamesCheck.end() )
+			    bValid = TRUE;
+
+		    ++i;
+	    }
+
+	    return aObjectName;
+    }
+
+    //--------------------------------------------------------------------
+    Sequence< ::rtl::OUString > ScriptDocument::getLibraryNames() const
+    {
+        return BasicIDE::GetMergedLibraryNames( getLibraryContainer( E_SCRIPTS ), getLibraryContainer( E_DIALOGS ) );
+    }
+
+    //--------------------------------------------------------------------
+    bool ScriptDocument::isReadOnly() const
+    {
+        return m_pImpl->isReadOnly();
+    }
+
+    //--------------------------------------------------------------------
+    bool ScriptDocument::isApplication() const
+    {
+        return m_pImpl->isApplication();
+    }
+
+    //--------------------------------------------------------------------
+    BasicManager* ScriptDocument::getBasicManager() const
+    {
+        return m_pImpl->getBasicManager();
+    }
+
+    //--------------------------------------------------------------------
+    Reference< XModel > ScriptDocument::getDocument() const
+    {
+        return m_pImpl->getDocument();
+    }
+
+    //--------------------------------------------------------------------
+    Reference< XModel > ScriptDocument::getDocumentOrNull() const
+    {
+        if ( isDocument() )
+            return m_pImpl->getDocument();
+        return NULL;
+    }
+
+    //--------------------------------------------------------------------
+    void ScriptDocument::LEGACY_startDocumentListening( SfxListener& _rListener ) const
+    {
+        OSL_ENSURE( isValid(), "ScriptDocument::LEGACY_startDocumentListening: invalid, this will crash!" );
+        OSL_ENSURE( !isApplication(), "ScriptDocument::LEGACY_startDocumentListening: not allowed for the application!" );
+        if ( isValid() && !isApplication() )
+            _rListener.StartListening( *m_pImpl->getObjectShell(), TRUE );
+    }
+
+    //--------------------------------------------------------------------
+    void ScriptDocument::LEGACY_resetWorkingDocument()
+    {
+		SfxObjectShell::SetWorkingDocument( NULL );
+    }
+
+    //--------------------------------------------------------------------
+    void ScriptDocument::LEGACY_setWorkingDocument( const ScriptDocument& _rDocument )
+    {
+        if ( _rDocument.isApplication() )
+            LEGACY_resetWorkingDocument();
+        else
+		    SfxObjectShell::SetWorkingDocument( _rDocument.m_pImpl->getObjectShell() );
+    }
+
+    //--------------------------------------------------------------------
+    ScriptDocument ScriptDocument::LEGACY_getWorkingDocument()
+    {
+        SfxObjectShell* pWorkingDocument( SfxObjectShell::GetWorkingDocument() );
+        if ( pWorkingDocument )
+            return ScriptDocument( *pWorkingDocument );
+        return getApplicationScriptDocument();
+    }
+
+    //--------------------------------------------------------------------
+    bool ScriptDocument::removeModule( const ::rtl::OUString& _rLibName, const ::rtl::OUString& _rModuleName ) const
+    {
+        return m_pImpl->removeModuleOrDialog( E_SCRIPTS, _rLibName, _rModuleName );
+    }
+
+    //--------------------------------------------------------------------
+    bool ScriptDocument::hasModule( const ::rtl::OUString& _rLibName, const ::rtl::OUString& _rModuleName ) const
+    {
+        return m_pImpl->hasModuleOrDialog( E_SCRIPTS, _rLibName, _rModuleName );
+    }
+
+    //--------------------------------------------------------------------
+    bool ScriptDocument::getModule( const ::rtl::OUString& _rLibName, const ::rtl::OUString& _rModName, ::rtl::OUString& _out_rModuleSource ) const
+    {
+        Any aCode;
+        if ( !m_pImpl->getModuleOrDialog( E_SCRIPTS, _rLibName, _rModName, aCode ) )
+            return false;
+        ModuleInfo sModuleInfo;
+        rtl::OUString sMod;
+        if ( aCode >>= sModuleInfo )
+        {
+            sMod = sModuleInfo.ModuleSource;
+        }
+        else
+        {
+            aCode >>= sMod;
+        }
+        Any aMod(sMod);
+        OSL_VERIFY( aMod >>= _out_rModuleSource );
+        return true;
+    }
+
+    //--------------------------------------------------------------------
+    bool ScriptDocument::renameModule( const ::rtl::OUString& _rLibName, const ::rtl::OUString& _rOldName, const ::rtl::OUString& _rNewName ) const
+    {
+        return m_pImpl->renameModuleOrDialog( E_SCRIPTS, _rLibName, _rOldName, _rNewName, NULL );
+    }
+
+    //--------------------------------------------------------------------
+    bool ScriptDocument::createModule( const ::rtl::OUString& _rLibName, const ::rtl::OUString& _rModName, bool _bCreateMain, ::rtl::OUString& _out_rNewModuleCode ) const
+    {
+        if ( !m_pImpl->createModule( _rLibName, _rModName, _bCreateMain, _out_rNewModuleCode ) )
+            return false;
+
+        // doc shell modified
+		BasicIDE::MarkDocumentModified( *const_cast< ScriptDocument* >( this ) );    // here?
+        return true;
+    }
+
+    //--------------------------------------------------------------------
+    bool ScriptDocument::insertModule( const ::rtl::OUString& _rLibName, const ::rtl::OUString& _rModName, const ::rtl::OUString& _rModuleCode ) const
+    {
+        return m_pImpl->insertModuleOrDialog( E_SCRIPTS, _rLibName, _rModName, makeAny( _rModuleCode ) );
+    }
+
+    //--------------------------------------------------------------------
+    bool ScriptDocument::updateModule( const ::rtl::OUString& _rLibName, const ::rtl::OUString& _rModName, const ::rtl::OUString& _rModuleCode ) const
+    {
+        return m_pImpl->updateModule( _rLibName, _rModName, _rModuleCode );
+    }
+
+    //--------------------------------------------------------------------
+    bool ScriptDocument::removeDialog( const ::rtl::OUString& _rLibName, const ::rtl::OUString& _rDialogName ) const
+    {
+        return m_pImpl->removeModuleOrDialog( E_DIALOGS, _rLibName, _rDialogName );
+    }
+
+    //--------------------------------------------------------------------
+    bool ScriptDocument::hasDialog( const ::rtl::OUString& _rLibName, const ::rtl::OUString& _rDialogName ) const
+    {
+        return m_pImpl->hasModuleOrDialog( E_DIALOGS, _rLibName, _rDialogName );
+    }
+
+    //--------------------------------------------------------------------
+    bool ScriptDocument::getDialog( const ::rtl::OUString& _rLibName, const ::rtl::OUString& _rDialogName, Reference< XInputStreamProvider >& _out_rDialogProvider ) const
+    {
+        Any aCode;
+        if ( !m_pImpl->getModuleOrDialog( E_DIALOGS, _rLibName, _rDialogName, aCode ) )
+            return false;
+        OSL_VERIFY( aCode >>= _out_rDialogProvider );
+        return _out_rDialogProvider.is();
+    }
+
+    //--------------------------------------------------------------------
+    bool ScriptDocument::renameDialog( const ::rtl::OUString& _rLibName, const ::rtl::OUString& _rOldName, const ::rtl::OUString& _rNewName, const Reference< XNameContainer >& _rxExistingDialogModel ) const
+    {
+        return m_pImpl->renameModuleOrDialog( E_DIALOGS, _rLibName, _rOldName, _rNewName, _rxExistingDialogModel );
+    }
+
+    //--------------------------------------------------------------------
+    bool ScriptDocument::createDialog( const ::rtl::OUString& _rLibName, const ::rtl::OUString& _rDialogName, Reference< XInputStreamProvider >& _out_rDialogProvider ) const
+    {
+        if ( !m_pImpl->createDialog( _rLibName, _rDialogName, _out_rDialogProvider ) )
+            return false;
+
+		BasicIDE::MarkDocumentModified( *const_cast< ScriptDocument* >( this ) );    // here?
+        return true;
+    }
+
+    //--------------------------------------------------------------------
+    bool ScriptDocument::insertDialog( const ::rtl::OUString& _rLibName, const ::rtl::OUString& _rDialogName, const Reference< XInputStreamProvider >& _rxDialogProvider ) const
+    {
+        return m_pImpl->insertModuleOrDialog( E_DIALOGS, _rLibName, _rDialogName, makeAny( _rxDialogProvider ) );
+    }
+
+    //--------------------------------------------------------------------
+    void ScriptDocument::setDocumentModified() const
+    {
+        m_pImpl->setDocumentModified();
+    }
+
+    //--------------------------------------------------------------------
+    bool ScriptDocument::isDocumentModified() const
+    {
+        return m_pImpl->isDocumentModified();
+    }
+
+    //--------------------------------------------------------------------
+    bool ScriptDocument::saveDocument( const Reference< XStatusIndicator >& _rxStatusIndicator ) const
+    {
+        return m_pImpl->saveDocument( _rxStatusIndicator );
+    }
+
+    //--------------------------------------------------------------------
+    LibraryLocation ScriptDocument::getLibraryLocation( const ::rtl::OUString& _rLibName ) const
+    {
+        LibraryLocation eLocation = LIBRARY_LOCATION_UNKNOWN;
+        if ( _rLibName.getLength() )
+        {
+            if ( isDocument() )
+            {
+                eLocation = LIBRARY_LOCATION_DOCUMENT;
+            }
+            else
+            {
+                if  (  ( hasLibrary( E_SCRIPTS, _rLibName ) && !m_pImpl->isLibraryShared( _rLibName, E_SCRIPTS ) )
+                    || ( hasLibrary( E_DIALOGS, _rLibName ) && !m_pImpl->isLibraryShared( _rLibName, E_DIALOGS ) )
+                    )
+                {
+                    eLocation = LIBRARY_LOCATION_USER;
+                }
+                else
+                {
+                    eLocation = LIBRARY_LOCATION_SHARE;
+                }
+            }
+        }
+
+        return eLocation;
+    }
+
+    //--------------------------------------------------------------------
+    ::rtl::OUString ScriptDocument::getTitle( LibraryLocation _eLocation, LibraryType _eType ) const
+    {
+        ::rtl::OUString aTitle;
+
+        switch ( _eLocation )
+        {
+            case LIBRARY_LOCATION_USER:
+            {
+                switch ( _eType )
+                {
+                case LIBRARY_TYPE_MODULE:   aTitle = String( IDEResId( RID_STR_USERMACROS ) ); break;
+                case LIBRARY_TYPE_DIALOG:   aTitle = String( IDEResId( RID_STR_USERDIALOGS ) ); break;
+                case LIBRARY_TYPE_ALL:      aTitle = String( IDEResId( RID_STR_USERMACROSDIALOGS ) ); break;
+                default:
+                    break;
+            }
+            break;
+            case LIBRARY_LOCATION_SHARE:
+            {
+                switch ( _eType )
+                {
+                case LIBRARY_TYPE_MODULE:   aTitle = String( IDEResId( RID_STR_SHAREMACROS ) ); break;
+                case LIBRARY_TYPE_DIALOG:   aTitle = String( IDEResId( RID_STR_SHAREDIALOGS ) ); break;
+                case LIBRARY_TYPE_ALL:      aTitle = String( IDEResId( RID_STR_SHAREMACROSDIALOGS ) ); break;
+                default:
+                    break;
+                }
+            }
+            break;
+            case LIBRARY_LOCATION_DOCUMENT:
+            {
+                if ( isDocument() )
+                    aTitle = m_pImpl->getObjectShell()->GetTitle( SFX_TITLE_CAPTION );
+            }
+            break;
+		    default:
+                break;
+            }
+        }
+
+        return aTitle;
+    }
+
+    //--------------------------------------------------------------------
+    bool ScriptDocument::isClosing() const
+    {
+        OSL_ENSURE( isDocument(), "ScriptDocument::isClosing: for documents only!" );
+        if ( isDocument() )
+            return m_pImpl->getObjectShell()->IsInPrepareClose();
+        return false;
+    }
+
+    //--------------------------------------------------------------------
+    bool ScriptDocument::isActive() const
+    {
+        OSL_ENSURE( isDocument(), "ScriptDocument::isActive: for documents only!" );
+        if ( isDocument() )
+            return m_pImpl->getObjectShell() == SfxObjectShell::Current();
+        return false;
+    }
+
+    //--------------------------------------------------------------------
+    void ScriptDocument::signScriptingContent() const
+    {
+        OSL_ENSURE( isDocument(), "ScriptDocument::signScriptingContent: for documents only!" );
+        if ( isDocument() )
+            m_pImpl->getObjectShell()->SignScriptingContent();
+    }
+
+    //--------------------------------------------------------------------
+    sal_uInt16 ScriptDocument::getScriptingSignatureState() const
+    {
+        OSL_ENSURE( isDocument(), "ScriptDocument::getScriptingSignatureState: for documents only!" );
+        if ( isDocument() )
+            return m_pImpl->getObjectShell()->GetScriptingSignatureState();
+        return SIGNATURESTATE_NOSIGNATURES;
+    }
+
+    //--------------------------------------------------------------------
+    void ScriptDocument::adjustMacroMode( const ::rtl::OUString& _rScriptType ) const
+    {
+        OSL_ENSURE( isDocument(), "ScriptDocument::adjustMacroMode: for documents only!" );
+        if ( isDocument() )
+            m_pImpl->getObjectShell()->AdjustMacroMode( _rScriptType );
+    }
+
+    //--------------------------------------------------------------------
+    sal_Int16 ScriptDocument::getMacroMode() const
+    {
+        OSL_ENSURE( isDocument(), "ScriptDocument::getMacroMode: for documents only!" );
+        if ( isDocument() )
+            return m_pImpl->getObjectShell()->GetMacroMode();
+        return MacroExecMode::NEVER_EXECUTE;
+    }
+
+//........................................................................
+} // namespace basctl
+//........................................................................
--- basctl/source/basicide/basobj2.cxx	2007-08-03 17:58:20.000000000 +0800
+++ basctl/source/basicide/basobj2.cxx.bak	1970-01-01 08:00:00.000000000 +0800
@@ -1,441 +0,0 @@
-/*************************************************************************
- *
- *  OpenOffice.org - a multi-platform office productivity suite
- *
- *  $RCSfile: basobj2.cxx,v $
- *
- *  $Revision: 1.34 $
- *
- *  last change: $Author: hr $ $Date: 2007/08/03 09:58:20 $
- *
- *  The Contents of this file are made available subject to
- *  the terms of GNU Lesser General Public License Version 2.1.
- *
- *
- *    GNU Lesser General Public License Version 2.1
- *    =============================================
- *    Copyright 2005 by Sun Microsystems, Inc.
- *    901 San Antonio Road, Palo Alto, CA 94303, USA
- *
- *    This library is free software; you can redistribute it and/or
- *    modify it under the terms of the GNU Lesser General Public
- *    License version 2.1, as published by the Free Software Foundation.
- *
- *    This library is distributed in the hope that it will be useful,
- *    but WITHOUT ANY WARRANTY; without even the implied warranty of
- *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- *    Lesser General Public License for more details.
- *
- *    You should have received a copy of the GNU Lesser General Public
- *    License along with this library; if not, write to the Free Software
- *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- *    MA  02111-1307  USA
- *
- ************************************************************************/
-
-// MARKER(update_precomp.py): autogen include statement, do not remove
-#include "precompiled_basctl.hxx"
-
-
-#include <ide_pch.hxx>
-
-
-#include <vector>
-#include <algorithm>
-
-#ifndef _SBXCLASS_HXX //autogen
-#include <basic/sbx.hxx>
-#endif
-#ifndef INCLUDED_SVTOOLS_MODULEOPTIONS_HXX
-#include <svtools/moduleoptions.hxx>
-#endif
-#include <basobj.hxx>
-#include <iderdll.hxx>
-#include <iderdll2.hxx>
-#include <iderid.hxx>
-#include <macrodlg.hxx>
-#include <moduldlg.hxx>
-#include <basidesh.hxx>
-#include <basidesh.hrc>
-#include <baside2.hxx>
-#include <basicmod.hxx>
-#include <basdoc.hxx>
-
-using namespace ::com::sun::star;
-using namespace ::com::sun::star::uno;
-using namespace ::com::sun::star::container;
-
-
-//----------------------------------------------------------------------------
-
-extern "C" {
-    rtl_uString* basicide_choose_macro( void* pOnlyInDocument_AsXModel, BOOL bChooseOnly, rtl_uString* pMacroDesc )
-	{
-		::rtl::OUString aMacroDesc( pMacroDesc );
-        Reference< frame::XModel > aDocument( static_cast< frame::XModel* >( pOnlyInDocument_AsXModel ) );
-		::rtl::OUString aScriptURL = BasicIDE::ChooseMacro( aDocument, bChooseOnly, aMacroDesc );
-		rtl_uString* pScriptURL = aScriptURL.pData;
-        rtl_uString_acquire( pScriptURL );
-
-        return pScriptURL;
-	}
-    void basicide_macro_organizer( INT16 nTabId )
-    {
-        OSL_TRACE("in basicide_macro_organizer");
-        BasicIDE::Organize( nTabId );
-    }
-}
-
-//----------------------------------------------------------------------------
-
-SfxMacro* BasicIDE::CreateMacro()
-{
-	DBG_ERROR( "BasicIDE::CreateMacro() - war eigentlich nur fuer Macro-Recording!" );
-	IDE_DLL()->GetExtraData()->ChoosingMacro() = TRUE;
-	SFX_APP()->EnterBasicCall();
-	Window* pParent = Application::GetDefDialogParent();
-	SfxMacro* pMacro = 0;
-	MacroChooser* pChooser = new MacroChooser( pParent, TRUE );
-	Window* pOldModalDialogParent = Application::GetDefDialogParent();
-	Application::SetDefDialogParent( pChooser );
-	//pChooser->SetMode( MACROCHOOSER_RECORDING );
-	short nRetValue = pChooser->Execute();
-	(void)nRetValue;
-
-	Application::SetDefDialogParent( pOldModalDialogParent );
-	delete pChooser;
-
-	SFX_APP()->LeaveBasicCall();
-	IDE_DLL()->GetExtraData()->ChoosingMacro() = FALSE;
-
-	return pMacro;
-}
-
-//----------------------------------------------------------------------------
-
-void BasicIDE::Organize( INT16 tabId )
-{
-    BasicIDEDLL::Init();
-
-    BasicEntryDescriptor aDesc;
-    BasicIDEShell* pIDEShell = IDE_DLL()->GetShell();
-    if ( pIDEShell )
-    {
-        IDEBaseWindow* pCurWin = pIDEShell->GetCurWindow();
-        if ( pCurWin )
-            aDesc = pCurWin->CreateEntryDescriptor();
-    }
-
-	Window* pParent = Application::GetDefDialogParent();
-	OrganizeDialog* pDlg = new OrganizeDialog( pParent, tabId, aDesc );
-	pDlg->Execute();
-	delete pDlg;
-}
-
-//----------------------------------------------------------------------------
-
-BOOL BasicIDE::IsValidSbxName( const String& rName )
-{
-	for ( USHORT nChar = 0; nChar < rName.Len(); nChar++ )
-	{
-		BOOL bValid = (	( rName.GetChar(nChar) >= 'A' && rName.GetChar(nChar) <= 'Z' ) ||
-						( rName.GetChar(nChar) >= 'a' && rName.GetChar(nChar) <= 'z' ) ||
-						( rName.GetChar(nChar) >= '0' && rName.GetChar(nChar) <= '9' && nChar ) ||
-						( rName.GetChar(nChar) == '_' ) );
-		if ( !bValid )
-			return FALSE;
-	}
-	return TRUE;
-}
-
-//----------------------------------------------------------------------------
-
-SbMethod* BasicIDE::FindMacro( SbModule* pModule, const String& rMacroName )
-{
-	return (SbMethod*)pModule->GetMethods()->Find( rMacroName, SbxCLASS_METHOD );
-}
-
-//----------------------------------------------------------------------------
-
-USHORT BasicIDE::GetBasicDialogCount()
-{
-	return IDE_DLL()->GetExtraData()->GetBasicDialogCount();
-}
-
-//----------------------------------------------------------------------------
-
-void BasicIDE::IncBasicDialogCount()
-{
-	IDE_DLL()->GetExtraData()->IncBasicDialogCount();
-}
-
-//----------------------------------------------------------------------------
-
-void BasicIDE::DecBasicDialogCount()
-{
-	DBG_ASSERT( GetBasicDialogCount(), "DecBasicDialogCount() - Count allready 0!" );
-	IDE_DLL()->GetExtraData()->DecBasicDialogCount();
-}
-
-//----------------------------------------------------------------------------
-
-Sequence< ::rtl::OUString > BasicIDE::GetMergedLibraryNames( const Reference< script::XLibraryContainer >& xModLibContainer, const Reference< script::XLibraryContainer >& xDlgLibContainer )
-{
-    // create a sorted list of module library names
-    ::std::vector<String> aModLibList;
-    if ( xModLibContainer.is() )
-    {
-		Sequence< ::rtl::OUString > aModLibNames = xModLibContainer->getElementNames();
-		sal_Int32 nModLibCount = aModLibNames.getLength();
-		const ::rtl::OUString* pModLibNames = aModLibNames.getConstArray();
-        for ( sal_Int32 i = 0 ; i < nModLibCount ; i++ )
-			aModLibList.push_back( pModLibNames[ i ] );
-        ::std::sort( aModLibList.begin() , aModLibList.end() , StringCompareLessThan );
-    }
-
-    // create a sorted list of dialog library names
-	::std::vector<String> aDlgLibList;
-    if ( xDlgLibContainer.is() )
-    {
-		Sequence< ::rtl::OUString > aDlgLibNames = xDlgLibContainer->getElementNames();
-		sal_Int32 nDlgLibCount = aDlgLibNames.getLength();
-		const ::rtl::OUString* pDlgLibNames = aDlgLibNames.getConstArray();
-        for ( sal_Int32 i = 0 ; i < nDlgLibCount ; i++ )
-			aDlgLibList.push_back( pDlgLibNames[ i ] );
-        ::std::sort( aDlgLibList.begin() , aDlgLibList.end() , StringCompareLessThan );
-    }
-
-    // merge both lists
-    ::std::vector<String> aLibList( aModLibList.size() + aDlgLibList.size() );
-    ::std::merge( aModLibList.begin(), aModLibList.end(), aDlgLibList.begin(), aDlgLibList.end(), aLibList.begin(), StringCompareLessThan );
-    ::std::vector<String>::iterator aIterEnd = ::std::unique( aLibList.begin(), aLibList.end() );  // move unique elements to the front
-    aLibList.erase( aIterEnd, aLibList.end() ); // remove duplicates
-
-    // copy to sequence
-	sal_Int32 nLibCount = aLibList.size();
-	Sequence< ::rtl::OUString > aSeqLibNames( nLibCount );
-    for ( sal_Int32 i = 0 ; i < nLibCount ; i++ )
-        aSeqLibNames.getArray()[ i ] = aLibList[ i ];
-
-    return aSeqLibNames;
-}
-
-//----------------------------------------------------------------------------
-
-bool BasicIDE::RenameModule( Window* pErrorParent, const ScriptDocument& rDocument, const String& rLibName, const String& rOldName, const String& rNewName )
-{
-    if ( !rDocument.hasModule( rLibName, rOldName ) )
-    {
-        OSL_ENSURE( false, "BasicIDE::RenameModule: old module name is invalid!" );
-        return false;
-    }
-
-    if ( rDocument.hasModule( rLibName, rNewName ) )
-    {
-        ErrorBox aError( pErrorParent, WB_OK | WB_DEF_OK, String( IDEResId( RID_STR_SBXNAMEALLREADYUSED2 ) ) );
-        aError.Execute();
-		return false;
-    }
-
-	// #i74440
-	if ( rNewName.Len() == 0 )
-    {
-        ErrorBox aError( pErrorParent, WB_OK | WB_DEF_OK, String( IDEResId( RID_STR_BADSBXNAME ) ) );
-        aError.Execute();
-		return false;
-    }
-
-    if ( !rDocument.renameModule( rLibName, rOldName, rNewName ) )
-        return false;
-
-	BasicIDEShell* pIDEShell = IDE_DLL()->GetShell();
-	if ( pIDEShell )
-	{
-		IDEBaseWindow* pWin = pIDEShell->FindWindow( rDocument, rLibName, rOldName, BASICIDE_TYPE_MODULE, FALSE );
-		if ( pWin )
-		{
-			// set new name in window
-            pWin->SetName( rNewName );
-
-            // set new module in module window
-            ModulWindow* pModWin = (ModulWindow*)pWin;
-            pModWin->SetSbModule( (SbModule*)pModWin->GetBasic()->FindModule( rNewName ) );
-
-			// update tabwriter
-			USHORT nId = (USHORT)(pIDEShell->GetIDEWindowTable()).GetKey( pWin );
-			DBG_ASSERT( nId, "No entry in Tabbar!" );
-			if ( nId )
-			{
-				BasicIDETabBar*	pTabBar = (BasicIDETabBar*)pIDEShell->GetTabBar();
-				pTabBar->SetPageText( nId, rNewName );
-				pTabBar->Sort();
-				pTabBar->MakeVisible( pTabBar->GetCurPageId() );
-			}
-		}
-	}
-    return true;
-}
-
-//----------------------------------------------------------------------------
-
-::rtl::OUString BasicIDE::ChooseMacro( const uno::Reference< frame::XModel >& rxLimitToDocument, BOOL bChooseOnly, const ::rtl::OUString& rMacroDesc )
-{
-	(void)rMacroDesc;
-
-	BasicIDEDLL::Init();
-
-	IDE_DLL()->GetExtraData()->ChoosingMacro() = TRUE;
-	SFX_APP()->EnterBasicCall();
-
-    String aScriptURL;
-    BOOL bError = FALSE;
-    SbMethod* pMethod = NULL;
-
-	MacroChooser* pChooser = new MacroChooser( NULL, TRUE );
-	if ( bChooseOnly || !SvtModuleOptions().IsBasicIDE() )
-        pChooser->SetMode( MACROCHOOSER_CHOOSEONLY );
-
-    if ( !bChooseOnly && rxLimitToDocument.is() )
-        // Hack!
-        pChooser->SetMode( MACROCHOOSER_RECORDING );
-
-	short nRetValue = pChooser->Execute();
-
-	IDE_DLL()->GetExtraData()->ChoosingMacro() = FALSE;
-
-	switch ( nRetValue )
-	{
-		case MACRO_OK_RUN:
-		{
-			pMethod = pChooser->GetMacro();
-            if ( !pMethod && pChooser->GetMode() == MACROCHOOSER_RECORDING )
-                pMethod = pChooser->CreateMacro();
-
-            if ( pMethod )
-			{
-				SbModule* pModule = pMethod->GetModule();
-				DBG_ASSERT(pModule, "BasicIDE::ChooseMacro: No Module found!");
-				if ( pModule )
-				{
-					StarBASIC* pBasic = (StarBASIC*)pModule->GetParent();
-					DBG_ASSERT(pBasic, "BasicIDE::ChooseMacro: No Basic found!");
-					if ( pBasic )
-					{
-						BasicManager* pBasMgr = BasicIDE::FindBasicManager( pBasic );
-						DBG_ASSERT(pBasMgr, "BasicIDE::ChooseMacro: No BasicManager found!");
-						if ( pBasMgr )
-                        {
-                            // name
-                            String aName;                            
-							aName += pBasic->GetName();
-							aName += '.';
-							aName += pModule->GetName();
-							aName += '.';
-							aName += pMethod->GetName();
-
-                            // language
-                            String aLanguage = String::CreateFromAscii("Basic");
-
-                            // location
-                            String aLocation;
-							ScriptDocument aDocument( ScriptDocument::getDocumentForBasicManager( pBasMgr ) );
-                            if ( aDocument.isDocument() )
-                            {
-                                // document basic
-                                aLocation = String::CreateFromAscii("document");
-
-                                if ( rxLimitToDocument.is() && ( rxLimitToDocument != aDocument.getDocument() ) )
-                                {
-                                    // error
-                                    bError = TRUE;
-                                    ErrorBox( NULL, WB_OK | WB_DEF_OK, String( IDEResId( RID_STR_ERRORCHOOSEMACRO ) ) ).Execute();
-                                }
-                            }
-                            else
-                            {
-                                // application basic
-                                aLocation = String::CreateFromAscii("application");
-                            }
-
-                            // script URL
-                            if ( !bError )
-                            {
-                                aScriptURL = String::CreateFromAscii("vnd.sun.star.script:");
-                                aScriptURL += aName;
-                                aScriptURL += String::CreateFromAscii("?language=");
-                                aScriptURL += aLanguage;
-                                aScriptURL += String::CreateFromAscii("&location=");
-                                aScriptURL += aLocation;
-                            }
-                        }
-					}
-				}
-			}
-
-			if ( pMethod && !rxLimitToDocument.is() )
-			{
-				pMethod->AddRef();	// festhalten, bis Event abgearbeitet.
-				Application::PostUserEvent( LINK( IDE_DLL()->GetExtraData(), BasicIDEData, ExecuteMacroEvent ), pMethod );
-			}
-		}
-		break;
-	}
-
-	delete pChooser;
-
-	SFX_APP()->LeaveBasicCall();
-
-    return ::rtl::OUString( aScriptURL );
-}
-
-//----------------------------------------------------------------------------
-
-Sequence< ::rtl::OUString > BasicIDE::GetMethodNames( const ScriptDocument& rDocument, const String& rLibName, const String& rModName )
-	throw(NoSuchElementException )
-{
-    Sequence< ::rtl::OUString > aSeqMethods;
-
-	// get module
-    ::rtl::OUString aOUSource;
-    if ( rDocument.getModule( rLibName, rModName, aOUSource ) )
-    {
-	    SbModuleRef xModule = new SbModule( rModName );
-	    xModule->SetSource32( aOUSource );
-	    USHORT nCount = xModule->GetMethods()->Count();
-        aSeqMethods.realloc( nCount );
-
-	    for ( USHORT i = 0; i < nCount; i++ )
-	    {
-		    SbMethod* pMethod = (SbMethod*)xModule->GetMethods()->Get( i );
-		    DBG_ASSERT( pMethod, "Method not found! (NULL)" );
-		    aSeqMethods.getArray()[ i ] = pMethod->GetName();
-	    }
-    }
-
-	return aSeqMethods;
-}
-
-//----------------------------------------------------------------------------
-
-BOOL BasicIDE::HasMethod( const ScriptDocument& rDocument, const String& rLibName, const String& rModName, const String& rMethName )
-{
-    BOOL bHasMethod = FALSE;
-
-    ::rtl::OUString aOUSource;
-    if ( rDocument.hasModule( rLibName, rModName ) && rDocument.getModule( rLibName, rModName, aOUSource ) )
-    {
-        SbModuleRef xModule = new SbModule( rModName );
-        xModule->SetSource32( aOUSource );
-        SbxArray* pMethods = xModule->GetMethods();
-        if ( pMethods )
-        {
-            SbMethod* pMethod = (SbMethod*)pMethods->Find( rMethName, SbxCLASS_METHOD );
-            if ( pMethod )
-                bHasMethod = TRUE;
-        }
-    }
-
-    return bHasMethod;
-}
-
-//----------------------------------------------------------------------------
--- /dev/null	2007-09-22 05:50:58.000000000 +0800
+++ basic/inc/basic/sbobjmod.hxx	2007-10-15 11:51:06.000000000 +0800
@@ -0,0 +1,67 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile: sbobjmod.hxx,v $
+ *
+ *  $Revision: 1.4 $
+ *
+ *  last change: $Author:  $ $Date: 2007/08/27 16:31:39 $
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+
+#ifndef _SB_OBJMOD_HXX
+#define _SB_OBJMOD_HXX
+
+#include <basic/sbmod.hxx>
+#include <basic/sbstar.hxx>
+#include <com/sun/star/script/ModuleInfo.hpp>
+
+// Basic-Module for excel object.
+
+class SbObjModule : public SbModule
+{
+    com::sun::star::script::ModuleInfo m_mInfo;
+    SbxObjectRef pDocObject; // a excel object.
+protected:
+	//virtual ~SbObjModule();
+    void InitObject( const XubString& rName );
+public:
+    TYPEINFO();
+	SBX_DECL_PERSIST_NODATA(SBXCR_SBX,SBXID_DOCUMENTMOD,2);
+    SbObjModule( const rtl::OUString& rName, const com::sun::star::script::ModuleInfo& mInfo );
+    virtual SbxVariable* Find( const XubString& rName, SbxClassType t );
+    virtual SbxVariable* GetObject();
+    virtual void SetCodeName( const XubString& rName );
+};
+#ifndef __SB_SBOBJMODULEREF_HXX
+#define __SB_SBOBJMODULEREF_HXX
+
+SV_DECL_IMPL_REF(SbObjModule);
+
+#endif
+#endif
+
--- basic/prj/d.lst.bak	1970-01-01 08:00:00.000000000 +0800
+++ basic/prj/d.lst	2007-10-15 11:51:06.000000000 +0800
@@ -0,0 +1,61 @@
+mkdir: %COMMON_DEST%\bin%_EXT%\hid
+mkdir: %COMMON_DEST%\res%_EXT%
+
+..\%COMMON_OUTDIR%\misc\*.hid %COMMON_DEST%\bin%_EXT%\hid\*.hid
+..\%__SRC%\lib\basic.lib %_DEST%\lib%_EXT%\basic.lib
+..\%__SRC%\lib\lib*.so %_DEST%\lib%_EXT%
+..\%__SRC%\lib\*.dylib %_DEST%\lib%_EXT%\*.dylib
+..\%__SRC%\lib\*.a %_DEST%\lib%_EXT%\*.a
+..\%__SRC%\slb\sb.lib %_DEST%\lib%_EXT%\xsb.lib
+..\%__SRC%\srs\classes.srs %_DEST%\res%_EXT%\basic.srs
+..\%COMMON_OUTDIR%\srs\classes_srs.hid %COMMON_DEST%\res%_EXT%\basic_srs.hid
+..\%__SRC%\bin\sb?????.dll %_DEST%\bin%_EXT%\sb?????.dll
+..\%__SRC%\bin\sb?????.sym %_DEST%\bin%_EXT%\sb?????.sym
+..\%__SRC%\misc\sb?????.map %_DEST%\bin%_EXT%\sb?????.map
+..\%__SRC%\bin\stt*.res %_DEST%\bin%_EXT%\stt*.res
+..\%__SRC%\bin\sb*.res %_DEST%\bin%_EXT%\sb*.res
+..\%__SRC%\lib\app.lib %_DEST%\lib%_EXT%\app.lib
+..\%__SRC%\lib\libapp.a %_DEST%\lib%_EXT%\libapp.a
+..\%__SRC%\lib\sample.lib %_DEST%\lib%_EXT%\sample.lib
+..\%__SRC%\lib\libsample.a %_DEST%\lib%_EXT%\libsample.a
+
+mkdir: %_DEST%\inc%_EXT%\basic
+..\inc\testtool.hrc %_DEST%\inc%_EXT%\basic\testtool.hrc
+..\inc\ttmsg.hrc %_DEST%\inc%_EXT%\basic\ttmsg.hrc
+..\inc\basic\ttglobal.hrc %_DEST%\inc%_EXT%\basic\ttglobal.hrc
+..\inc\svtmsg.hrc %_DEST%\inc%_EXT%\basic\svtmsg.hrc
+
+..\inc\basic\sbdef.hxx %_DEST%\inc%_EXT%\basic\sbdef.hxx
+..\inc\basic\sbmod.hxx %_DEST%\inc%_EXT%\basic\sbmod.hxx
+..\inc\basic\sbobjmod.hxx %_DEST%\inc%_EXT%\basic\sbobjmod.hxx
+..\inc\basic\sbjsmod.hxx %_DEST%\inc%_EXT%\basic\sbjsmod.hxx
+..\inc\basic\sbmeth.hxx %_DEST%\inc%_EXT%\basic\sbmeth.hxx
+..\inc\basic\sbprop.hxx %_DEST%\inc%_EXT%\basic\sbprop.hxx
+..\inc\basic\sbstar.hxx %_DEST%\inc%_EXT%\basic\sbstar.hxx
+..\inc\basic\sbuno.hxx %_DEST%\inc%_EXT%\basic\sbuno.hxx
+..\inc\basic\basmgr.hxx %_DEST%\inc%_EXT%\basic\basmgr.hxx
+..\inc\basic\sberrors.hxx %_DEST%\inc%_EXT%\basic\sberrors.hxx
+..\inc\basic\basrdll.hxx %_DEST%\inc%_EXT%\basic\basrdll.hxx
+..\inc\basic\sbstdobj.hxx %_DEST%\inc%_EXT%\basic\sbstdobj.hxx
+..\inc\basic\hilight.hxx %_DEST%\inc%_EXT%\basic\hilight.hxx
+..\inc\basic\process.hxx %_DEST%\inc%_EXT%\basic\process.hxx
+..\inc\basic\mybasic.hxx %_DEST%\inc%_EXT%\basic\mybasic.hxx
+..\inc\basic\testtool.hxx %_DEST%\inc%_EXT%\basic\testtool.hxx
+..\inc\basic\basicrt.hxx %_DEST%\inc%_EXT%\basic\basicrt.hxx
+..\inc\basic\dispdefs.hxx %_DEST%\inc%_EXT%\basic\dispdefs.hxx
+..\inc\basic\ttstrhlp.hxx %_DEST%\inc%_EXT%\basic\ttstrhlp.hxx
+
+..\inc\basic\sbx.hxx %_DEST%\inc%_EXT%\basic\sbx.hxx
+..\inc\basic\sbxcore.hxx %_DEST%\inc%_EXT%\basic\sbxcore.hxx
+..\inc\basic\sbxdef.hxx %_DEST%\inc%_EXT%\basic\sbxdef.hxx
+..\inc\basic\sbxform.hxx %_DEST%\inc%_EXT%\basic\sbxform.hxx
+..\inc\basic\sbxmeth.hxx %_DEST%\inc%_EXT%\basic\sbxmeth.hxx
+..\inc\basic\sbxobj.hxx %_DEST%\inc%_EXT%\basic\sbxobj.hxx
+..\inc\basic\sbxprop.hxx %_DEST%\inc%_EXT%\basic\sbxprop.hxx
+..\inc\basic\sbxvar.hxx %_DEST%\inc%_EXT%\basic\sbxvar.hxx
+..\inc\basic\sbxbase.hxx %_DEST%\inc%_EXT%\basic\sbxbase.hxx
+..\inc\basic\sbxfac.hxx %_DEST%\inc%_EXT%\basic\sbxfac.hxx
+..\inc\basic\sbxmstrm.hxx %_DEST%\inc%_EXT%\basic\sbxmstrm.hxx
+
+..\inc\basic\basicmanagerrepository.hxx %_DEST%\inc%_EXT%\basic\basicmanagerrepository.hxx
+..\inc\modsizeexceeded.hxx %_DEST%\inc%_EXT%\basic\modsizeexceeded.hxx
--- basic/source/classes/sbxmod.cxx.bak	1970-01-01 08:00:00.000000000 +0800
+++ basic/source/classes/sbxmod.cxx	2007-10-16 16:55:33.000000000 +0800
@@ -0,0 +1,2198 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile: sbxmod.cxx,v $
+ *
+ *  $Revision: 1.38.2.1 $
+ *
+ *  last change: $Author: obo $ $Date: 2007/08/17 08:19:15 $
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+
+// MARKER(update_precomp.py): autogen include statement, do not remove
+#include "precompiled_basic.hxx"
+
+#include <list>
+
+#include <vos/macros.hxx>
+#include <vcl/svapp.hxx>
+
+#ifndef _STREAM_HXX //autogen
+#include <tools/stream.hxx>
+#endif
+#ifndef _SFXBRDCST_HXX //autogen
+#include <svtools/brdcst.hxx>
+#endif
+#ifndef _SHL_HXX //autogen
+#include <tools/shl.hxx>
+#endif
+#include <basic/sbx.hxx>
+#include "sb.hxx"
+#include <sbjsmeth.hxx>
+#include "sbjsmod.hxx"
+#include "sbintern.hxx"
+#include "image.hxx"
+#include "opcodes.hxx"
+#include "runtime.hxx"
+#include "token.hxx"
+#include "sbunoobj.hxx"
+#include <basic/hilight.hxx>
+#include <basic/basrdll.hxx>
+#include <basic/sbobjmod.hxx>
+#include <com/sun/star/script/XObjectProvider.hpp>
+
+#ifndef _VOS_MUTEX_HXX_
+#include <vos/mutex.hxx>
+#endif
+
+// for the bsearch
+#ifdef WNT
+#define CDECL _cdecl
+#endif
+#if defined(UNX)
+#define CDECL
+#endif
+#ifdef UNX
+#include <sys/resource.h>
+#endif
+
+#include <stdio.h>
+
+static const String sThisWorkbook( RTL_CONSTASCII_USTRINGPARAM("ThisWorkbook"));
+
+TYPEINIT1(SbModule,SbxObject)
+TYPEINIT1(SbMethod,SbxMethod)
+TYPEINIT1(SbProperty,SbxProperty)
+TYPEINIT1(SbProcedureProperty,SbxProperty)
+TYPEINIT1(SbJScriptModule,SbModule)
+TYPEINIT1(SbJScriptMethod,SbMethod)
+TYPEINIT1(SbObjModule,SbModule)
+
+SV_DECL_VARARR(SbiBreakpoints,USHORT,4,4)
+SV_IMPL_VARARR(SbiBreakpoints,USHORT)
+
+
+SV_IMPL_VARARR(HighlightPortions, HighlightPortion)
+
+// ##########################################################################
+// ACHTUNG!!!  Alle Woerter dieser Tabelle mssen KLEIN geschrieben werden!!!
+// ##########################################################################
+static const char* strListBasicKeyWords[] = {
+	"access",
+	"alias",
+	"and",
+	"any",
+	"append",
+	"as",
+	"base",
+	"binary",
+	"boolean",
+	"byref",
+	"byte",
+	"byval",
+	"call",
+	"case",
+	"cdecl",
+	"classmodule",
+	"close",
+	"compare",
+	"compatible",
+	"const",
+	"currency",
+	"date",
+	"declare",
+	"defbool",
+	"defcur",
+	"defdate",
+	"defdbl",
+	"deferr",
+	"defint",
+	"deflng",
+	"defobj",
+	"defsng",
+	"defstr",
+	"defvar",
+	"dim",
+	"do",
+	"double",
+	"each",
+	"else",
+	"elseif",
+	"end",
+	"end enum",
+	"end function",
+	"end if",
+	"end select",
+	"end sub",
+	"end type",
+	"endif",
+	"enum",
+	"eqv",
+	"erase",
+	"error",
+	"exit",
+	"explicit",
+	"for",
+	"function",
+	"get",
+	"global",
+	"gosub",
+	"goto",
+	"if",
+	"imp",
+	"implements",
+	"in",
+	"input",
+	"integer",
+	"is",
+	"let",
+	"lib",
+	"like",
+	"line",
+	"line input",
+	"local",
+	"lock",
+	"long",
+	"loop",
+	"lprint",
+	"lset",
+	"mod",
+	"name",
+	"new",
+	"next",
+	"not",
+	"object",
+	"on",
+	"open",
+	"option",
+	"optional",
+	"or",
+	"output",
+	"preserve",
+	"print",
+	"private",
+	"property",
+	"public",
+	"random",
+	"read",
+	"redim",
+	"rem",
+	"resume",
+	"return",
+	"rset",
+	"select",
+	"set",
+	"shared",
+	"single",
+	"static",
+	"step",
+	"stop",
+	"string",
+	"sub",
+	"system",
+	"text",
+	"then",
+	"to",
+	"type",
+	"typeof",
+	"until",
+	"variant",
+	"wend",
+	"while",
+	"with",
+	"write",
+	"xor"
+};
+
+extern "C" int CDECL compare_strings( const void *arg1, const void *arg2 )
+{
+	return strcmp( (char *)arg1, *(char **)arg2 );
+}
+
+
+
+/////////////////////////////////////////////////////////////////////////////
+
+// Ein BASIC-Modul hat EXTSEARCH gesetzt, damit die im Modul enthaltenen
+// Elemente von anderen Modulen aus gefunden werden koennen.
+
+SbModule::SbModule( const String& rName )
+		 : SbxObject( String( RTL_CONSTASCII_USTRINGPARAM("StarBASICModule") ) ),
+		   pImage( NULL ), pBreaks( NULL ), pClassData( NULL ), bThisWorkBook( false ), mbVBACompat( false )
+{
+	SetName( rName );
+	SetFlag( SBX_EXTSEARCH | SBX_GBLSEARCH );
+	if ( rName.EqualsIgnoreCaseAscii( sThisWorkbook ) )
+		bThisWorkBook = true;
+	
+}
+
+SbModule::~SbModule()
+{
+	if( pImage )
+		delete pImage;
+	if( pBreaks )
+		delete pBreaks;
+	if( pClassData )
+		delete pClassData;
+}
+
+BOOL SbModule::IsCompiled() const
+{
+	return BOOL( pImage != 0 );
+}
+
+const SbxObject* SbModule::FindType( String aTypeName ) const
+{ 
+	return pImage ? pImage->FindType( aTypeName ) : NULL; 
+}
+
+
+// Aus dem Codegenerator: Loeschen des Images und Invalidieren der Entries
+
+void SbModule::StartDefinitions()
+{
+	delete pImage; pImage = NULL;
+	if( pClassData )
+		pClassData->clear();
+
+	// Methoden und Properties bleiben erhalten, sind jedoch ungueltig
+	// schliesslich sind ja u.U. die Infos belegt
+	USHORT i;
+	for( i = 0; i < pMethods->Count(); i++ )
+	{
+		SbMethod* p = PTR_CAST(SbMethod,pMethods->Get( i ) );
+		if( p )
+			p->bInvalid = TRUE;
+	}
+	for( i = 0; i < pProps->Count(); )
+	{
+		SbProperty* p = PTR_CAST(SbProperty,pProps->Get( i ) );
+		if( p )
+			pProps->Remove( i );
+		else
+			i++;
+	}
+}
+
+// Methode anfordern/anlegen
+
+SbMethod* SbModule::GetMethod( const String& rName, SbxDataType t )
+{
+	SbxVariable* p = pMethods->Find( rName, SbxCLASS_METHOD );
+	SbMethod* pMeth = p ? PTR_CAST(SbMethod,p) : NULL;
+	if( p && !pMeth )
+		pMethods->Remove( p );
+	if( !pMeth )
+	{
+		pMeth = new SbMethod( rName, t, this );
+		pMeth->SetParent( this );
+		pMeth->SetFlags( SBX_READ );
+		pMethods->Put( pMeth, pMethods->Count() );
+		StartListening( pMeth->GetBroadcaster(), TRUE );
+	}
+	// Per Default ist die Methode GUELTIG, da sie auch vom Compiler
+	// (Codegenerator) erzeugt werden kann
+	pMeth->bInvalid = FALSE;
+	pMeth->ResetFlag( SBX_FIXED );
+	pMeth->SetFlag( SBX_WRITE );
+	pMeth->SetType( t );
+	pMeth->ResetFlag( SBX_WRITE );
+	if( t != SbxVARIANT )
+		pMeth->SetFlag( SBX_FIXED );
+	return pMeth;
+}
+
+// Property anfordern/anlegen
+
+SbProperty* SbModule::GetProperty( const String& rName, SbxDataType t )
+{
+	SbxVariable* p = pProps->Find( rName, SbxCLASS_PROPERTY );
+	SbProperty* pProp = p ? PTR_CAST(SbProperty,p) : NULL;
+	if( p && !pProp )
+		pProps->Remove( p );
+	if( !pProp )
+	{
+		pProp = new SbProperty( rName, t, this );
+		pProp->SetFlag( SBX_READWRITE );
+		pProp->SetParent( this );
+		pProps->Put( pProp, pProps->Count() );
+		StartListening( pProp->GetBroadcaster(), TRUE );
+	}
+	return pProp;
+}
+
+SbProcedureProperty* SbModule::GetProcedureProperty
+	( const String& rName, SbxDataType t )
+{
+	SbxVariable* p = pProps->Find( rName, SbxCLASS_PROPERTY );
+	SbProcedureProperty* pProp = p ? PTR_CAST(SbProcedureProperty,p) : NULL;
+	if( p && !pProp )
+		pProps->Remove( p );
+	if( !pProp )
+	{
+		pProp = new SbProcedureProperty( rName, t );
+		pProp->SetFlag( SBX_READWRITE );
+		pProp->SetParent( this );
+		pProps->Put( pProp, pProps->Count() );
+		StartListening( pProp->GetBroadcaster(), TRUE );
+	}
+	return pProp;
+}
+
+SbIfaceMapperMethod* SbModule::GetIfaceMapperMethod
+	( const String& rName, SbMethod* pImplMeth )
+{
+	SbxVariable* p = pMethods->Find( rName, SbxCLASS_METHOD );
+	SbIfaceMapperMethod* pMapperMethod = p ? PTR_CAST(SbIfaceMapperMethod,p) : NULL;
+	if( p && !pMapperMethod )
+		pMethods->Remove( p );
+	if( !pMapperMethod )
+	{
+		pMapperMethod = new SbIfaceMapperMethod( rName, pImplMeth );
+		pMapperMethod->SetParent( this );
+		pMapperMethod->SetFlags( SBX_READ );
+		pMethods->Put( pMapperMethod, pMethods->Count() );
+	}
+	pMapperMethod->bInvalid = FALSE;
+	return pMapperMethod;
+}
+
+SbIfaceMapperMethod::~SbIfaceMapperMethod()
+{
+}
+
+TYPEINIT1(SbIfaceMapperMethod,SbMethod)
+
+
+// Aus dem Codegenerator: Ungueltige Eintraege entfernen
+
+void SbModule::EndDefinitions( BOOL bNewState )
+{
+	for( USHORT i = 0; i < pMethods->Count(); )
+	{
+		SbMethod* p = PTR_CAST(SbMethod,pMethods->Get( i ) );
+		if( p )
+		{
+			if( p->bInvalid )
+				pMethods->Remove( p );
+			else
+			{
+				p->bInvalid = bNewState;
+				i++;
+			}
+		}
+		else
+			i++;
+	}
+	SetModified( TRUE );
+}
+
+void SbModule::Clear()
+{
+	delete pImage; pImage = NULL;
+	if( pClassData )
+		pClassData->clear();
+	SbxObject::Clear();
+}
+
+
+SbxVariable* SbModule::Find( const XubString& rName, SbxClassType t )
+{
+	// searching for ThisWorkbook from withing the module ThisWorkbook
+	// will find itself otherwise 
+	if ( SbiRuntime ::isVBAEnabled() && bThisWorkBook && rName.EqualsIgnoreCaseAscii( sThisWorkbook ) ) 
+		return NULL;
+	SbxVariable* pRes = SbxObject::Find( rName, t );
+	if( !pRes && pImage )
+	{
+		SbiInstance* pInst = pINST;
+		if( pInst && pInst->IsCompatibility() )
+		{
+			// Put enum types as objects into module,
+			// allows MyEnum.First notation
+			SbxArrayRef xArray = pImage->GetEnums();
+			if( xArray.Is() )
+			{
+				SbxVariable* pEnumVar = xArray->Find( rName, SbxCLASS_DONTCARE );
+				SbxObject* pEnumObject = PTR_CAST( SbxObject, pEnumVar );
+				if( pEnumObject )
+				{
+					bool bPrivate = pEnumObject->IsSet( SBX_PRIVATE );
+					String aEnumName = pEnumObject->GetName();
+
+					pRes = new SbxVariable( SbxOBJECT );
+					pRes->SetName( aEnumName );
+					pRes->SetParent( this );
+					pRes->SetFlag( SBX_READ );
+					if( bPrivate )
+						pRes->SetFlag( SBX_PRIVATE );
+					pRes->PutObject( pEnumObject );
+				}
+			}
+		}
+	}
+	return pRes;
+}
+
+const ::rtl::OUString& SbModule::GetSource32() const
+{
+	return aOUSource;
+}
+
+const String& SbModule::GetSource() const
+{
+    static String aRetStr;
+    aRetStr = aOUSource;
+	return aRetStr;
+}
+
+// Parent und BASIC sind eins!
+
+void SbModule::SetParent( SbxObject* p )
+{
+	// #118083: Assertion is not valid any more
+	// DBG_ASSERT( !p || p->IsA( TYPE(StarBASIC) ), "SbModules nur in BASIC eintragen" );
+	pParent = p;
+}
+
+void SbModule::SFX_NOTIFY( SfxBroadcaster& rBC, const TypeId& rBCType,
+						   const SfxHint& rHint, const TypeId& rHintType )
+{
+	const SbxHint* pHint = PTR_CAST(SbxHint,&rHint);
+	if( pHint )
+	{
+		SbxVariable* pVar = pHint->GetVar();
+		SbProperty* pProp = PTR_CAST(SbProperty,pVar);
+		SbMethod* pMeth = PTR_CAST(SbMethod,pVar);
+		if( pProp )
+		{
+			if( pProp->GetModule() != this )
+				SetError( SbxERR_BAD_ACTION );
+		}
+		else if( pMeth )
+		{
+			if( pHint->GetId() == SBX_HINT_DATAWANTED )
+			{
+				if( pMeth->bInvalid && !Compile() )
+					// Auto-Compile hat nicht geklappt!
+					StarBASIC::Error( SbERR_BAD_PROP_VALUE );
+				else
+				{
+					// Aufruf eines Unterprogramms
+					SbModule* pOld = pMOD;
+					pMOD = this;
+					Run( (SbMethod*) pVar );
+					pMOD = pOld;
+				}
+			}
+		}
+		else
+			SbxObject::SFX_NOTIFY( rBC, rBCType, rHint, rHintType );
+	}
+}
+
+// Das Setzen der Source macht das Image ungueltig
+// und scant die Methoden-Definitionen neu ein
+
+void SbModule::SetSource( const String& r )
+{
+    SetSource32( r );
+}
+
+void SbModule::SetSource32( const ::rtl::OUString& r )
+{
+	aOUSource = r;
+	StartDefinitions();
+	SbiTokenizer aTok( r );
+	while( !aTok.IsEof() )
+	{
+		SbiToken eEndTok = NIL;
+
+		// Suchen nach SUB oder FUNCTION
+		SbiToken eLastTok = NIL;
+		while( !aTok.IsEof() )
+		{
+			// #32385: Nicht bei declare
+			SbiToken eCurTok = aTok.Next();
+			if( eLastTok != DECLARE )
+			{
+				if( eCurTok == SUB )
+				{
+					eEndTok = ENDSUB; break;
+				}
+				if( eCurTok == FUNCTION )
+				{
+					eEndTok = ENDFUNC; break;
+				}
+				if( eCurTok == PROPERTY )
+				{
+					eEndTok = ENDPROPERTY; break;
+				}
+				if( eCurTok == OPTION )
+				{
+					eCurTok = aTok.Next();
+					mbVBACompat = ( eCurTok == VBASUPPORT ) && ( aTok.Next() == NUMBER ) && ( aTok.GetDbl()== 1 );
+					if( eCurTok == COMPATIBLE 
+					|| mbVBACompat )
+						aTok.SetCompatible( true );
+				}
+			}
+			eLastTok = eCurTok;
+		}
+		// Definition der Methode
+		SbMethod* pMeth = NULL;
+		if( eEndTok != NIL )
+		{
+			USHORT nLine1 = aTok.GetLine();
+			if( aTok.Next() == SYMBOL )
+			{
+				String aName_( aTok.GetSym() );
+				SbxDataType t = aTok.GetType();
+				if( t == SbxVARIANT && eEndTok == ENDSUB )
+					t = SbxVOID;
+				pMeth = GetMethod( aName_, t );
+				pMeth->nLine1 = pMeth->nLine2 = nLine1;
+				// Die Methode ist erst mal GUELTIG
+				pMeth->bInvalid = FALSE;
+			}
+			else
+				eEndTok = NIL;
+		}
+		// Skip bis END SUB/END FUNCTION
+		if( eEndTok != NIL )
+		{
+			while( !aTok.IsEof() )
+			{
+				if( aTok.Next() == eEndTok )
+				{
+					pMeth->nLine2 = aTok.GetLine();
+					break;
+				}
+			}
+			if( aTok.IsEof() )
+				pMeth->nLine2 = aTok.GetLine();
+		}
+	}
+	EndDefinitions( TRUE );
+}
+
+void SbModule::SetComment( const String& r )
+{
+	aComment = r;
+	SetModified( TRUE );
+}
+
+SbMethod* SbModule::GetFunctionForLine( USHORT nLine )
+{
+	for( USHORT i = 0; i < pMethods->Count(); i++ )
+	{
+		SbMethod* p = (SbMethod*) pMethods->Get( i );
+		if( p->GetSbxId() == SBXID_BASICMETHOD )
+		{
+			if( nLine >= p->nLine1 && nLine <= p->nLine2 )
+				return p;
+		}
+	}
+	return NULL;
+}
+
+// Ausstrahlen eines Hints an alle Basics
+
+static void _SendHint( SbxObject* pObj, ULONG nId, SbMethod* p )
+{
+	// Selbst ein BASIC?
+	if( pObj->IsA( TYPE(StarBASIC) ) && pObj->IsBroadcaster() )
+		pObj->GetBroadcaster().Broadcast( SbxHint( nId, p ) );
+	// Dann die Unterobjekte fragen
+	SbxArray* pObjs = pObj->GetObjects();
+	for( USHORT i = 0; i < pObjs->Count(); i++ )
+	{
+		SbxVariable* pVar = pObjs->Get( i );
+		if( pVar->IsA( TYPE(SbxObject) ) )
+			_SendHint( PTR_CAST(SbxObject,pVar), nId, p );
+	}
+}
+
+static void SendHint( SbxObject* pObj, ULONG nId, SbMethod* p )
+{
+	while( pObj->GetParent() )
+		pObj = pObj->GetParent();
+	_SendHint( pObj, nId, p );
+}
+
+// #57841 Uno-Objekte, die in RTL-Funktionen gehalten werden,
+// beim Programm-Ende freigeben, damit nichts gehalten wird.
+void ClearUnoObjectsInRTL_Impl_Rek( StarBASIC* pBasic )
+{
+	// return-Wert von CreateUnoService loeschen
+	static String aName( RTL_CONSTASCII_USTRINGPARAM("CreateUnoService") );
+	SbxVariable* pVar = pBasic->GetRtl()->Find( aName, SbxCLASS_METHOD );
+	if( pVar )
+		pVar->SbxValue::Clear();
+
+	// return-Wert von CreateUnoDialog loeschen
+	static String aName2( RTL_CONSTASCII_USTRINGPARAM("CreateUnoDialog") );
+	pVar = pBasic->GetRtl()->Find( aName2, SbxCLASS_METHOD );
+	if( pVar )
+		pVar->SbxValue::Clear();
+
+	// return-Wert von CDec loeschen
+	static String aName3( RTL_CONSTASCII_USTRINGPARAM("CDec") );
+	pVar = pBasic->GetRtl()->Find( aName3, SbxCLASS_METHOD );
+	if( pVar )
+		pVar->SbxValue::Clear();
+
+	// return-Wert von CreateObject loeschen
+	static String aName4( RTL_CONSTASCII_USTRINGPARAM("CreateObject") );
+	pVar = pBasic->GetRtl()->Find( aName4, SbxCLASS_METHOD );
+	if( pVar )
+		pVar->SbxValue::Clear();
+
+	// Ueber alle Sub-Basics gehen
+	SbxArray* pObjs = pBasic->GetObjects();
+	USHORT nCount = pObjs->Count();
+	for( USHORT i = 0 ; i < nCount ; i++ )
+	{
+		SbxVariable* pObjVar = pObjs->Get( i );
+		StarBASIC* pSubBasic = PTR_CAST( StarBASIC, pObjVar );
+		if( pSubBasic )
+			ClearUnoObjectsInRTL_Impl_Rek( pSubBasic );
+	}
+}
+
+void ClearUnoObjectsInRTL_Impl( StarBASIC* pBasic )
+{
+	// #67781 Rueckgabewerte der Uno-Methoden loeschen
+	clearUnoMethods();
+	
+	ClearUnoObjectsInRTL_Impl_Rek( pBasic );
+
+    // Oberstes Basic suchen
+	SbxObject* p = pBasic;
+	while( p->GetParent() )
+		p = p->GetParent();
+    if( ((StarBASIC*)p) != pBasic )
+	    ClearUnoObjectsInRTL_Impl_Rek( (StarBASIC*)p );
+}
+
+// Ausfuehren eines BASIC-Unterprogramms
+USHORT SbModule::Run( SbMethod* pMeth )
+{
+	static USHORT nMaxCallLevel = 0;
+	static String aMSOMacroRuntimeLibName = String::CreateFromAscii( "Launcher" );
+	static String aMSOMacroRuntimeAppSymbol = String::CreateFromAscii( "Application" );
+
+	USHORT nRes = 0;
+	BOOL bDelInst = BOOL( pINST == NULL );
+	StarBASICRef xBasic;
+	if( bDelInst )
+	{
+		// #32779: Basic waehrend der Ausfuehrung festhalten
+		xBasic = (StarBASIC*) GetParent();
+
+		pINST = new SbiInstance( (StarBASIC*) GetParent() );
+
+		// Launcher problem
+        // i80726 The Find below will genarate an error in Testtool so we reset it unless there was one before already
+        BOOL bWasError = SbxBase::GetError() != 0;
+		SbxVariable* pMSOMacroRuntimeLibVar = Find( aMSOMacroRuntimeLibName, SbxCLASS_OBJECT );
+        if ( !bWasError && (SbxBase::GetError() == SbxERR_PROC_UNDEFINED) )
+            SbxBase::ResetError();
+		if( pMSOMacroRuntimeLibVar )
+		{
+			StarBASIC* pMSOMacroRuntimeLib = PTR_CAST(StarBASIC,pMSOMacroRuntimeLibVar);
+			if( pMSOMacroRuntimeLib )
+			{
+				USHORT nGblFlag = pMSOMacroRuntimeLib->GetFlags() & SBX_GBLSEARCH;
+				pMSOMacroRuntimeLib->ResetFlag( SBX_GBLSEARCH );
+				SbxVariable* pAppSymbol = pMSOMacroRuntimeLib->Find( aMSOMacroRuntimeAppSymbol, SbxCLASS_METHOD );
+				pMSOMacroRuntimeLib->SetFlag( nGblFlag );
+				if( pAppSymbol )
+				{
+					pMSOMacroRuntimeLib->SetFlag( SBX_EXTSEARCH );		// Could have been disabled before
+					GetSbData()->pMSOMacroRuntimLib = pMSOMacroRuntimeLib;
+				}
+			}
+		}
+
+		// Error-Stack loeschen
+		SbErrorStack*& rErrStack = GetSbData()->pErrStack;
+		delete rErrStack;
+		rErrStack = NULL;
+
+		if( nMaxCallLevel == 0 )
+		{ 
+#ifdef UNX
+		  struct rlimit rl;
+		  getrlimit ( RLIMIT_STACK, &rl );
+		  // printf( "RLIMIT_STACK = %ld\n", rl.rlim_cur );
+#endif
+#if defined LINUX
+		  // Empiric value, 900 = needed bytes/Basic call level 
+		  // for Linux including 10% safety margin
+		  nMaxCallLevel = rl.rlim_cur / 900;
+#elif defined SOLARIS
+		  // Empiric value, 1650 = needed bytes/Basic call level 
+		  // for Solaris including 10% safety margin
+		  nMaxCallLevel = rl.rlim_cur / 1650;
+#elif defined WIN32
+		  nMaxCallLevel = 5800;
+#else
+		  nMaxCallLevel = MAXRECURSION;
+#endif
+		}
+	}
+
+	// Rekursion zu tief?
+	if( ++pINST->nCallLvl <= nMaxCallLevel )
+	{
+		// Globale Variable in allen Mods definieren
+		GlobalRunInit( /* bBasicStart = */ bDelInst );
+
+		// Trat ein Compiler-Fehler auf? Dann starten wir nicht
+		if( GetSbData()->bGlobalInitErr == FALSE )
+		{
+			if( bDelInst )
+			{
+				SendHint( GetParent(), SBX_HINT_BASICSTART, pMeth );
+
+				// 16.10.96: #31460 Neues Konzept fuer StepInto/Over/Out
+				// Erklaerung siehe runtime.cxx bei SbiInstance::CalcBreakCallLevel()
+				// BreakCallLevel ermitteln
+				pINST->CalcBreakCallLevel( pMeth->GetDebugFlags() );
+			}
+
+			SbModule* pOldMod = pMOD;
+			pMOD = this;
+			SbiRuntime* pRt = new SbiRuntime( this, pMeth, pMeth->nStart );
+			pRt->pNext = pINST->pRun;
+			if( pRt->pNext )
+				pRt->pNext->block();
+			pINST->pRun = pRt;
+			if ( SbiRuntime ::isVBAEnabled() )
+                        {
+				pINST->EnableCompatibility( TRUE );
+				pRt->SetVBAEnabled( true );
+                        }
+			while( pRt->Step() ) {}
+			if( pRt->pNext )
+				pRt->pNext->unblock();
+
+			// #63710 Durch ein anderes Thread-Handling bei Events kann es passieren,
+			// dass show-Aufruf an einem Dialog zurueckkehrt (durch schliessen des
+			// Dialogs per UI), BEVOR ein per Event ausgeloester weitergehender Call,
+			// der in Basic weiter oben im Stack steht und auf einen Basic-Breakpoint
+			// gelaufen ist, zurueckkehrt. Dann wird unten die Instanz zerstoert und
+			// wenn das noch im Call stehende Basic weiterlaeuft, gibt es einen GPF.
+			// Daher muss hier gewartet werden, bis andere Call zurueckkehrt.
+			if( bDelInst )
+			{
+				// Hier mit 1 statt 0 vergleichen, da vor nCallLvl--
+				while( pINST->nCallLvl != 1 )
+					GetpApp()->Yield();
+			}
+
+			nRes = TRUE;
+			pINST->pRun = pRt->pNext;
+			pINST->nCallLvl--;			// Call-Level wieder runter
+
+			// Gibt es eine uebergeordnete Runtime-Instanz?
+			// Dann SbDEBUG_BREAK uebernehmen, wenn gesetzt
+			SbiRuntime* pRtNext = pRt->pNext;
+			if( pRtNext && (pRt->GetDebugFlags() & SbDEBUG_BREAK) )
+				pRtNext->SetDebugFlags( SbDEBUG_BREAK );
+
+			delete pRt;
+			pMOD = pOldMod;
+			if( bDelInst )
+			{
+				// #57841 Uno-Objekte, die in RTL-Funktionen gehalten werden,
+				// beim Programm-Ende freigeben, damit nichts gehalten wird.
+				ClearUnoObjectsInRTL_Impl( xBasic );
+
+				DBG_ASSERT(pINST->nCallLvl==0,"BASIC-Call-Level > 0")
+				delete pINST, pINST = NULL, bDelInst = FALSE;
+
+				// #i30690
+				vos::OGuard aSolarGuard( Application::GetSolarMutex() );
+				SendHint( GetParent(), SBX_HINT_BASICSTOP, pMeth );
+
+		        GlobalRunDeInit();
+			}
+        }
+        else
+   			pINST->nCallLvl--;			// Call-Level wieder runter
+	}
+	else
+    {
+		pINST->nCallLvl--;			// Call-Level wieder runter
+		StarBASIC::FatalError( SbERR_STACK_OVERFLOW );
+    }
+	if( bDelInst )
+	{
+		// #57841 Uno-Objekte, die in RTL-Funktionen gehalten werden,
+		// beim Programm-Ende freigeben, damit nichts gehalten wird.
+		ClearUnoObjectsInRTL_Impl( xBasic );
+
+		delete pINST;
+		pINST = NULL;
+	}
+	return nRes;
+}
+
+// Ausfuehren der Init-Methode eines Moduls nach dem Laden
+// oder der Compilation
+
+void SbModule::RunInit()
+{
+	if( pImage
+	 && !pImage->bInit
+	 && pImage->GetFlag( SBIMG_INITCODE ) )
+	{
+		// Flag setzen, dass RunInit aktiv ist (Testtool)
+		GetSbData()->bRunInit = TRUE;
+
+		// BOOL bDelInst = BOOL( pINST == NULL );
+		// if( bDelInst )
+			// pINST = new SbiInstance( (StarBASIC*) GetParent() );
+		SbModule* pOldMod = pMOD;
+		pMOD = this;
+		// Der Init-Code beginnt immer hier
+		SbiRuntime* pRt = new SbiRuntime( this, NULL, 0 );
+		pRt->pNext = pINST->pRun;
+		pINST->pRun = pRt;
+		while( pRt->Step() ) {}
+		pINST->pRun = pRt->pNext;
+		delete pRt;
+		pMOD = pOldMod;
+		// if( bDelInst )
+			// delete pINST, pINST = NULL;
+		pImage->bInit = TRUE;
+        pImage->bFirstInit = FALSE;
+
+		// RunInit ist nicht mehr aktiv
+		GetSbData()->bRunInit = FALSE;
+	}
+}
+
+// Mit private/dim deklarierte Variablen loeschen
+void SbModule::ClearPrivateVars()
+{
+	for( USHORT i = 0 ; i < pProps->Count() ; i++ )
+	{
+		SbProperty* p = PTR_CAST(SbProperty,pProps->Get( i ) );
+		if( p )
+		{
+			// Arrays nicht loeschen, sondern nur deren Inhalt
+			if( p->GetType() & SbxARRAY )
+			{
+				SbxArray* pArray = PTR_CAST(SbxArray,p->GetObject());
+				if( pArray )
+				{
+					for( USHORT j = 0 ; j < pArray->Count() ; j++ )
+					{
+						SbxVariable* pj = PTR_CAST(SbxVariable,pArray->Get( j ));
+						pj->SbxValue::Clear();
+						/*
+						USHORT nFlags = pj->GetFlags();
+						pj->SetFlags( (nFlags | SBX_WRITE) & (~SBX_FIXED) );
+						pj->PutEmpty();
+						pj->SetFlags( nFlags );
+						*/
+					}
+				}
+			}
+			else
+			{
+				p->SbxValue::Clear();
+				/*
+				USHORT nFlags = p->GetFlags();
+				p->SetFlags( (nFlags | SBX_WRITE) & (~SBX_FIXED) );
+				p->PutEmpty();
+				p->SetFlags( nFlags );
+				*/
+			}
+		}
+	}
+}
+
+// Zunaechst in dieses Modul, um 358-faehig zu bleiben
+// (Branch in sb.cxx vermeiden)
+void StarBASIC::ClearAllModuleVars( void )
+{
+	// Eigene Module initialisieren
+	for ( USHORT nMod = 0; nMod < pModules->Count(); nMod++ )
+	{
+		SbModule* pModule = (SbModule*)pModules->Get( nMod );
+		// Nur initialisieren, wenn der Startcode schon ausgefuehrt wurde
+		if( pModule->pImage && pModule->pImage->bInit )
+			pModule->ClearPrivateVars();
+	}
+
+    /* #88042 This code can delete already used public vars during runtime!
+	// Alle Objekte ueberpruefen, ob es sich um ein Basic handelt
+	// Wenn ja, auch dort initialisieren
+	for ( USHORT nObj = 0; nObj < pObjs->Count(); nObj++ )
+	{
+		SbxVariable* pVar = pObjs->Get( nObj );
+		StarBASIC* pBasic = PTR_CAST(StarBASIC,pVar);
+		if( pBasic )
+			pBasic->ClearAllModuleVars();
+	}
+    */
+}
+
+// Ausfuehren des Init-Codes aller Module
+void SbModule::GlobalRunInit( BOOL bBasicStart )
+{
+	// Wenn kein Basic-Start, nur initialisieren, wenn Modul uninitialisiert
+	if( !bBasicStart )
+		if( !(pImage && !pImage->bInit) )
+			return;
+
+	// GlobalInitErr-Flag fuer Compiler-Error initialisieren
+	// Anhand dieses Flags kann in SbModule::Run() nach dem Aufruf
+	// von GlobalRunInit festgestellt werden, ob beim initialisieren
+	// der Module ein Fehler auftrat. Dann wird nicht gestartet.
+	GetSbData()->bGlobalInitErr = FALSE;
+
+	// Parent vom Modul ist ein Basic
+	StarBASIC *pBasic = PTR_CAST(StarBASIC,GetParent());
+	if( pBasic )
+	{
+		pBasic->InitAllModules();
+
+		SbxObject* pParent_ = pBasic->GetParent();
+		if( pParent_ )
+		{
+			StarBASIC * pParentBasic = PTR_CAST(StarBASIC,pParent_);
+			if( pParentBasic )
+			{
+				pParentBasic->InitAllModules( pBasic );
+
+				// #109018 Parent can also have a parent (library in doc)
+				SbxObject* pParentParent = pParentBasic->GetParent();
+				if( pParentParent )
+				{
+					StarBASIC * pParentParentBasic = PTR_CAST(StarBASIC,pParentParent);
+					if( pParentParentBasic )
+						pParentParentBasic->InitAllModules( pParentBasic );
+				}
+			}
+		}
+	}
+}
+
+void SbModule::GlobalRunDeInit( void )
+{
+	StarBASIC *pBasic = PTR_CAST(StarBASIC,GetParent());
+	if( pBasic )
+	{
+		pBasic->DeInitAllModules();
+
+		SbxObject* pParent_ = pBasic->GetParent();
+		if( pParent_ )
+			pBasic = PTR_CAST(StarBASIC,pParent_);
+		if( pBasic )
+			pBasic->DeInitAllModules();
+	}
+}
+
+// Suche nach dem naechsten STMNT-Befehl im Code. Wird vom STMNT-
+// Opcode verwendet, um die Endspalte zu setzen.
+
+const BYTE* SbModule::FindNextStmnt( const BYTE* p, USHORT& nLine, USHORT& nCol ) const
+{
+	return FindNextStmnt( p, nLine, nCol, FALSE );
+}
+
+const BYTE* SbModule::FindNextStmnt( const BYTE* p, USHORT& nLine, USHORT& nCol, 
+	BOOL bFollowJumps, const SbiImage* pImg ) const
+{
+	UINT32 nPC = (UINT32) ( p - (const BYTE*) pImage->GetCode() );
+	while( nPC < pImage->GetCodeSize() )
+	{
+		SbiOpcode eOp = (SbiOpcode ) ( *p++ );
+		nPC++;
+		if( bFollowJumps && eOp == _JUMP && pImg )
+		{
+			DBG_ASSERT( pImg, "FindNextStmnt: pImg==NULL with FollowJumps option" );
+			UINT32 nOp1 = *p++; nOp1 |= *p++ << 8;
+			nOp1 |= *p++ << 16; nOp1 |= *p++ << 24;
+			p = (const BYTE*) pImg->GetCode() + nOp1;
+		}
+		else if( eOp >= SbOP1_START && eOp <= SbOP1_END )
+			p += 4, nPC += 4;
+		else if( eOp == _STMNT )
+		{
+			UINT32 nl, nc;
+			nl = *p++; nl |= *p++ << 8;
+			nl |= *p++ << 16 ; nl |= *p++ << 24;
+			nc = *p++; nc |= *p++ << 8;
+			nc |= *p++ << 16 ; nc |= *p++ << 24;
+			nLine = (USHORT)nl; nCol = (USHORT)nc;
+			return p;
+		}
+		else if( eOp >= SbOP2_START && eOp <= SbOP2_END )
+			p += 8, nPC += 8;
+		else if( !( eOp >= SbOP0_START && eOp <= SbOP0_END ) )
+		{
+			StarBASIC::FatalError( SbERR_INTERNAL_ERROR );
+			break;
+		}
+	}
+	return NULL;
+}
+
+// Testen, ob eine Zeile STMNT-Opcodes enthaelt
+
+BOOL SbModule::IsBreakable( USHORT nLine ) const
+{
+	if( !pImage )
+		return FALSE;
+	const BYTE* p = (const BYTE* ) pImage->GetCode();
+	USHORT nl, nc;
+	while( ( p = FindNextStmnt( p, nl, nc ) ) != NULL )
+		if( nl == nLine )
+			return TRUE;
+	return FALSE;
+}
+
+USHORT SbModule::GetBPCount() const
+{
+	return pBreaks ? pBreaks->Count() : 0;
+}
+
+USHORT SbModule::GetBP( USHORT n ) const
+{
+	if( pBreaks && n < pBreaks->Count() )
+		return pBreaks->GetObject( n );
+	else
+		return 0;
+}
+
+BOOL SbModule::IsBP( USHORT nLine ) const
+{
+	if( pBreaks )
+	{
+		const USHORT* p = pBreaks->GetData();
+		USHORT n = pBreaks->Count();
+		for( USHORT i = 0; i < n; i++, p++ )
+		{
+			USHORT b = *p;
+			if( b == nLine )
+				return TRUE;
+			if( b < nLine )
+				break;
+		}
+	}
+	return FALSE;
+}
+
+BOOL SbModule::SetBP( USHORT nLine )
+{
+	if( !IsBreakable( nLine ) )
+		return FALSE;
+	if( !pBreaks )
+		pBreaks = new SbiBreakpoints;
+	const USHORT* p = pBreaks->GetData();
+	USHORT n = pBreaks->Count();
+	USHORT i;
+	for( i = 0; i < n; i++, p++ )
+	{
+		USHORT b = *p;
+		if( b == nLine )
+			return TRUE;
+		if( b < nLine )
+			break;
+	}
+	pBreaks->Insert( &nLine, 1, i );
+
+	// #38568: Zur Laufzeit auch hier SbDEBUG_BREAK setzen
+	if( pINST && pINST->pRun )
+		pINST->pRun->SetDebugFlags( SbDEBUG_BREAK );
+
+	return IsBreakable( nLine );
+}
+
+BOOL SbModule::ClearBP( USHORT nLine )
+{
+	BOOL bRes = FALSE;
+	if( pBreaks )
+	{
+		const USHORT* p = pBreaks->GetData();
+		USHORT n = pBreaks->Count();
+		for( USHORT i = 0; i < n; i++, p++ )
+		{
+			USHORT b = *p;
+			if( b == nLine )
+			{
+				pBreaks->Remove( i, 1 ); bRes = TRUE; break;
+			}
+			if( b < nLine )
+				break;
+		}
+		if( !pBreaks->Count() )
+			delete pBreaks, pBreaks = NULL;
+	}
+	return bRes;
+}
+
+void SbModule::ClearAllBP()
+{
+	delete pBreaks; pBreaks = NULL;
+}
+
+void
+SbModule::fixUpMethodStart( bool bCvtToLegacy, SbiImage* pImg ) const
+{	
+		if ( !pImg )
+			pImg = pImage;
+		for( UINT32 i = 0; i < pMethods->Count(); i++ )
+		{
+			SbMethod* pMeth = PTR_CAST(SbMethod,pMethods->Get( (USHORT)i ) );
+			if( pMeth )
+			{
+				//fixup method start positions
+				if ( bCvtToLegacy )
+					pMeth->nStart = pImg->CalcLegacyOffset( pMeth->nStart );
+				else
+					pMeth->nStart = pImg->CalcNewOffset( (USHORT)pMeth->nStart );
+			}
+		}
+	
+}
+
+BOOL SbModule::LoadData( SvStream& rStrm, USHORT nVer )
+{
+	Clear();
+	if( !SbxObject::LoadData( rStrm, 1 ) )
+		return FALSE;
+	// Sicherheitshalber...
+	SetFlag( SBX_EXTSEARCH | SBX_GBLSEARCH );
+	BYTE bImage;
+	rStrm >> bImage;
+	if( bImage )
+	{
+		SbiImage* p = new SbiImage;
+		UINT32 nImgVer = 0;
+
+		if( !p->Load( rStrm, nImgVer ) )
+		{
+			delete p;
+			return FALSE;
+		}
+		// If the image is in old format, we fix up the method start offsets
+		if ( nImgVer < B_EXT_IMG_VERSION ) 
+		{
+			fixUpMethodStart( false, p );
+			p->ReleaseLegacyBuffer();
+		}
+		aComment = p->aComment;
+		SetName( p->aName );
+		if( p->GetCodeSize() )
+		{
+			aOUSource = p->aOUSource;
+			// Alte Version: Image weg 
+			if( nVer == 1 ) 
+			{
+				SetSource32( p->aOUSource );
+				delete p;
+			}
+			else
+				pImage = p; 
+		}
+		else
+		{
+			SetSource32( p->aOUSource );
+			delete p;
+		}
+	}
+	return TRUE;
+}
+
+BOOL SbModule::StoreData( SvStream& rStrm ) const
+{
+	BOOL bFixup = ( pImage && !pImage->ExceedsLegacyLimits() );
+	if ( bFixup ) 
+		fixUpMethodStart( true );
+	BOOL bRet = SbxObject::StoreData( rStrm );
+	if ( !bRet )	
+		return FALSE;
+	
+	if( pImage )
+	{
+		pImage->aOUSource = aOUSource;
+		pImage->aComment = aComment;
+		pImage->aName = GetName();
+		rStrm << (BYTE) 1;
+		// # PCode is saved only for legacy formats only
+		// It should be noted that it probably isn't necessary
+		// It would be better not to store the image ( more flexible with
+		// formats )
+		bool bRes = pImage->Save( rStrm, B_LEGACYVERSION );
+		if ( bFixup ) 
+			fixUpMethodStart( false ); // restore method starts
+		return bRes;
+		
+	}
+	else
+	{
+		SbiImage aImg;
+		aImg.aOUSource = aOUSource;
+		aImg.aComment = aComment;
+		aImg.aName = GetName();
+		rStrm << (BYTE) 1;
+		return aImg.Save( rStrm );
+	}
+}
+
+BOOL SbModule::ExceedsLegacyModuleSize()
+{
+	if ( !IsCompiled() )
+		Compile();
+	if ( pImage && pImage->ExceedsLegacyLimits() )
+		return true;
+	return false;
+}
+
+
+// Store only image, no source
+BOOL SbModule::StoreBinaryData( SvStream& rStrm )
+{
+	return StoreBinaryData( rStrm, 0 );
+}
+
+BOOL SbModule::StoreBinaryData( SvStream& rStrm, USHORT nVer )
+{
+    BOOL bRet = Compile();
+    if( bRet )
+    {
+		BOOL bFixup = ( !nVer && !pImage->ExceedsLegacyLimits() );// save in old image format, fix up method starts
+
+		if ( bFixup ) // save in old image format, fix up method starts
+			fixUpMethodStart( true ); 
+     	bRet = SbxObject::StoreData( rStrm );
+        if( bRet )
+        {
+		    pImage->aOUSource = OUString();
+		    pImage->aComment = aComment;
+		    pImage->aName = GetName();
+
+		    rStrm << (BYTE) 1;
+                    if ( nVer )
+						bRet = pImage->Save( rStrm, B_EXT_IMG_VERSION );
+                    else
+                        bRet = pImage->Save( rStrm, B_LEGACYVERSION );
+                    if ( bFixup )
+                        fixUpMethodStart( false ); // restore method starts
+			
+		    pImage->aOUSource = aOUSource;
+        }
+    }
+    return bRet;
+}
+
+// Called for >= OO 1.0 passwd protected libraries only
+// 
+
+BOOL SbModule::LoadBinaryData( SvStream& rStrm )
+{
+	OUString aKeepSource = aOUSource;
+    bool bRet = LoadData( rStrm, 2 );
+	LoadCompleted();
+    aOUSource = aKeepSource;
+    return bRet;
+}
+
+
+BOOL SbModule::LoadCompleted()
+{
+	SbxArray* p = GetMethods();
+	USHORT i;
+	for( i = 0; i < p->Count(); i++ )
+	{
+		SbMethod* q = PTR_CAST(SbMethod,p->Get( i ) );
+		if( q )
+			q->pMod = this;
+	}
+	p = GetProperties();
+	for( i = 0; i < p->Count(); i++ )
+	{
+		SbProperty* q = PTR_CAST(SbProperty,p->Get( i ) );
+		if( q )
+			q->pMod = this;
+	}
+	return TRUE;
+}
+
+
+/////////////////////////////////////////////////////////////////////////
+// Hilfsklasse zur Untersuchung von JavaScript-Modulen, zunaechst zum
+// Heraussuchen der Funktionen, spaeter auch zum Syntax-Highlighting verwenden
+
+//	Flags fuer Zeichen-Eigenschaften
+#define CHAR_START_IDENTIFIER	0x0001
+#define CHAR_IN_IDENTIFIER		0x0002
+#define CHAR_START_NUMBER		0x0004
+#define CHAR_IN_NUMBER			0x0008
+#define CHAR_IN_HEX_NUMBER		0x0010
+#define CHAR_IN_OCT_NUMBER		0x0020
+#define CHAR_START_STRING		0x0040
+#define CHAR_OPERATOR			0x0080
+#define CHAR_SPACE				0x0100
+#define CHAR_EOL				0x0200
+
+#define CHAR_EOF				0x00
+
+
+class SimpleTokenizer_Impl
+{
+	// Zeichen-Info-Tabelle
+	USHORT aCharTypeTab[256];
+
+	const sal_Unicode* mpStringBegin;
+	const sal_Unicode* mpActualPos;
+
+	// Zeile und Spalte
+	UINT32 nLine;
+	UINT32 nCol;
+
+	sal_Unicode peekChar( void )	{ return *mpActualPos; }
+	sal_Unicode getChar( void )		{ nCol++; return *mpActualPos++; }
+
+	// Hilfsfunktion: Zeichen-Flag Testen
+	BOOL testCharFlags( sal_Unicode c, USHORT nTestFlags );
+
+	// Neues Token holen, Leerstring == nix mehr da
+	BOOL getNextToken( /*out*/TokenTypes& reType,
+		/*out*/const sal_Unicode*& rpStartPos, /*out*/const sal_Unicode*& rpEndPos );
+
+	String getTokStr( /*out*/const sal_Unicode* pStartPos, /*out*/const sal_Unicode* pEndPos );
+
+#ifndef PRODUCT
+	// TEST: Token ausgeben
+	String getFullTokenStr( /*out*/TokenTypes eType,
+		/*out*/const sal_Unicode* pStartPos, /*out*/const sal_Unicode* pEndPos );
+#endif
+
+	const char** ppListKeyWords;
+	UINT16 nKeyWordCount;
+
+public:
+	SimpleTokenizer_Impl( void );
+	~SimpleTokenizer_Impl( void );
+
+	UINT16 parseLine( UINT32 nLine, const String* aSource );
+	void getHighlightPortions( UINT32 nParseLine, const String& rLine,
+													/*out*/HighlightPortions& portions );
+	void setKeyWords( const char** ppKeyWords, UINT16 nCount );
+};
+
+// Hilfsfunktion: Zeichen-Flag Testen
+BOOL SimpleTokenizer_Impl::testCharFlags( sal_Unicode c, USHORT nTestFlags )
+{
+	bool bRet = false;
+	if( c != 0 && c <= 255 )
+	{
+		bRet = ( (aCharTypeTab[c] & nTestFlags) != 0 );
+	}
+	else if( c > 255 )
+	{
+		bRet = (( CHAR_START_IDENTIFIER | CHAR_IN_IDENTIFIER ) & nTestFlags) != 0
+			? BasicSimpleCharClass::isAlpha( c, true ) : false;
+	}
+	return bRet;
+}
+
+void SimpleTokenizer_Impl::setKeyWords( const char** ppKeyWords, UINT16 nCount )
+{
+	ppListKeyWords = ppKeyWords;
+	nKeyWordCount = nCount;
+}
+
+// Neues Token holen
+BOOL SimpleTokenizer_Impl::getNextToken( /*out*/TokenTypes& reType,
+	/*out*/const sal_Unicode*& rpStartPos, /*out*/const sal_Unicode*& rpEndPos )
+{
+	reType = TT_UNKNOWN;
+
+	// Position merken
+	rpStartPos = mpActualPos;
+
+	// Zeichen untersuchen
+	sal_Unicode c = peekChar();
+	if( c == CHAR_EOF )
+		return FALSE;
+
+	// Zeichen lesen
+	getChar();
+
+	//*** Alle Moeglichkeiten durchgehen ***
+	// Space?
+	if ( (testCharFlags( c, CHAR_SPACE ) == TRUE) )
+	{
+		while( testCharFlags( peekChar(), CHAR_SPACE ) == TRUE )
+			getChar();
+
+		reType = TT_WHITESPACE;
+	}
+
+	// Identifier?
+	else if ( (testCharFlags( c, CHAR_START_IDENTIFIER ) == TRUE) )
+	{
+		BOOL bIdentifierChar;
+		do
+		{
+			// Naechstes Zeichen holen
+			c = peekChar();
+			bIdentifierChar = testCharFlags( c, CHAR_IN_IDENTIFIER );
+			if( bIdentifierChar )
+				getChar();
+		}
+		while( bIdentifierChar );
+
+		reType = TT_IDENTIFIER;
+
+		// Schluesselwort-Tabelle
+		if (ppListKeyWords != NULL)
+		{
+			int nCount = mpActualPos - rpStartPos;
+
+			// No keyword if string contains char > 255
+			bool bCanBeKeyword = true;
+			for( int i = 0 ; i < nCount ; i++ )
+			{
+				if( rpStartPos[i] > 255 )
+				{
+					bCanBeKeyword = false;
+					break;
+				}
+			}
+
+			if( bCanBeKeyword )
+			{
+				String aKWString(
+                    rpStartPos, sal::static_int_cast< xub_StrLen >(nCount) );
+				ByteString aByteStr( aKWString, RTL_TEXTENCODING_ASCII_US );
+				aByteStr.ToLowerAscii();
+				if ( bsearch( aByteStr.GetBuffer(), ppListKeyWords, nKeyWordCount, sizeof( char* ),
+																		compare_strings ) )
+				{
+					reType = TT_KEYWORD;
+
+					if ( aByteStr.Equals( "rem" ) )
+					{
+						// Alle Zeichen bis Zeilen-Ende oder EOF entfernen
+						sal_Unicode cPeek = peekChar();
+						while( cPeek != CHAR_EOF && testCharFlags( cPeek, CHAR_EOL ) == FALSE )
+						{
+							c = getChar();
+							cPeek = peekChar();
+						}
+
+						reType = TT_COMMENT;
+					}
+				}
+			}
+		}
+	}
+
+	// Operator?
+	else if ( testCharFlags( c, CHAR_OPERATOR ) == TRUE || c == '\'' )
+	{
+		// Kommentar ?
+		if ( c == '\'' )
+		{
+			c = getChar();	// '/' entfernen
+
+			// Alle Zeichen bis Zeilen-Ende oder EOF entfernen
+			sal_Unicode cPeek = peekChar();
+			while( cPeek != CHAR_EOF && testCharFlags( cPeek, CHAR_EOL ) == FALSE )
+			{
+				getChar();
+				cPeek = peekChar();
+			}
+
+			reType = TT_COMMENT;
+		}
+
+		// Echter Operator, kann hier einfach behandelt werden,
+		// da nicht der wirkliche Operator, wie z.B. += interessiert,
+		// sondern nur die Tatsache, dass es sich um einen handelt.
+		if( reType != TT_COMMENT )
+		{
+			reType = TT_OPERATOR;
+		}
+	}
+
+	// Objekt-Trenner? Muss vor Number abgehandelt werden
+	else if( c == '.' && ( peekChar() < '0' || peekChar() > '9' ) )
+	{
+		reType = TT_OPERATOR;
+	}
+
+	// Zahl?
+	else if( testCharFlags( c, CHAR_START_NUMBER ) == TRUE )
+	{
+		reType = TT_NUMBER;
+
+		// Zahlensystem, 10 = normal, wird bei Oct/Hex geaendert
+		int nRadix = 10;
+
+		// Ist es eine Hex- oder Oct-Zahl?
+		if( c == '&' )
+		{
+			// Octal?
+			if( peekChar() == 'o' || peekChar() == 'O' )
+			{
+				// o entfernen
+				getChar();
+				nRadix = 8; 	// Octal-Basis
+
+				// Alle Ziffern einlesen
+				while( testCharFlags( peekChar(), CHAR_IN_OCT_NUMBER ) )
+					c = getChar();
+			}
+			// Hex?
+			else if( peekChar() == 'h' || peekChar() == 'H' )
+			{
+				// x entfernen
+				getChar();
+				nRadix = 16;	 // Hex-Basis
+
+				// Alle Ziffern einlesen und puffern
+				while( testCharFlags( peekChar(), CHAR_IN_HEX_NUMBER ) )
+					c = getChar();
+			}
+			else
+			{
+				reType = TT_OPERATOR;
+			}
+		}
+
+		// Wenn nicht Oct oder Hex als double ansehen
+		if( reType == TT_NUMBER && nRadix == 10 )
+		{
+			// Flag, ob das letzte Zeichen ein Exponent war
+			BOOL bAfterExpChar = FALSE;
+
+			// Alle Ziffern einlesen
+			while( testCharFlags( peekChar(), CHAR_IN_NUMBER ) ||
+					(bAfterExpChar && peekChar() == '+' ) ||
+					(bAfterExpChar && peekChar() == '-' ) )
+					// Nach Exponent auch +/- OK
+			{
+				c = getChar();					// Zeichen lesen
+				bAfterExpChar = ( c == 'e' || c == 'E' );
+			}
+		}
+
+		// reType = TT_NUMBER;
+	}
+
+	// String?
+	else if( testCharFlags( c, CHAR_START_STRING ) == TRUE )
+	{
+		// Merken, welches Zeichen den String eroeffnet hat
+		sal_Unicode cEndString = c;
+		if( c == '[' )
+			cEndString = ']';
+
+		// Alle Ziffern einlesen und puffern
+		while( peekChar() != cEndString )
+		{
+			// #58846 EOF vor getChar() abfangen, damit EOF micht verloren geht
+			if( peekChar() == CHAR_EOF )
+			{
+				// ERROR: unterminated string literal
+				reType = TT_ERROR;
+				break;
+			}
+			c = getChar();
+			if( testCharFlags( c, CHAR_EOL ) == TRUE )
+			{
+				// ERROR: unterminated string literal
+				reType = TT_ERROR;
+				break;
+			}
+		}
+
+		//	Zeichen lesen
+		if( reType != TT_ERROR )
+		{
+			getChar();
+			if( cEndString == ']' )
+				reType = TT_IDENTIFIER;
+			else
+				reType = TT_STRING;
+		}
+	}
+
+	// Zeilenende?
+	else if( testCharFlags( c, CHAR_EOL ) == TRUE )
+	{
+		// Falls ein weiteres anderes EOL-Char folgt, weg damit
+		sal_Unicode cNext = peekChar();
+		if( cNext != c && testCharFlags( cNext, CHAR_EOL ) == TRUE )
+			getChar();
+
+		// Positions-Daten auf Zeilen-Beginn setzen
+		nCol = 0;
+		nLine++;
+
+		reType = TT_EOL;
+	}
+
+	// Alles andere bleibt TT_UNKNOWN
+
+
+	// End-Position eintragen
+	rpEndPos = mpActualPos;
+	return TRUE;
+}
+
+String SimpleTokenizer_Impl::getTokStr
+	( /*out*/const sal_Unicode* pStartPos, /*out*/const sal_Unicode* pEndPos )
+{
+	return String( pStartPos, (USHORT)( pEndPos - pStartPos ) );
+}
+
+#ifndef PRODUCT
+// TEST: Token ausgeben
+String SimpleTokenizer_Impl::getFullTokenStr( /*out*/TokenTypes eType,
+	/*out*/const sal_Unicode* pStartPos, /*out*/const sal_Unicode* pEndPos )
+{
+	String aOut;
+	switch( eType )
+	{
+		case TT_UNKNOWN:	aOut = String( RTL_CONSTASCII_USTRINGPARAM("TT_UNKNOWN:") ); break;
+		case TT_IDENTIFIER:	aOut = String( RTL_CONSTASCII_USTRINGPARAM("TT_IDENTIFIER:") ); break;
+		case TT_WHITESPACE:	aOut = String( RTL_CONSTASCII_USTRINGPARAM("TT_WHITESPACE:") ); break;
+		case TT_NUMBER:		aOut = String( RTL_CONSTASCII_USTRINGPARAM("TT_NUMBER:") ); break;
+		case TT_STRING:		aOut = String( RTL_CONSTASCII_USTRINGPARAM("TT_STRING:") ); break;
+		case TT_EOL:		aOut = String( RTL_CONSTASCII_USTRINGPARAM("TT_EOL:") ); break;
+		case TT_COMMENT:	aOut = String( RTL_CONSTASCII_USTRINGPARAM("TT_COMMENT:") ); break;
+		case TT_ERROR:		aOut = String( RTL_CONSTASCII_USTRINGPARAM("TT_ERROR:") ); break;
+		case TT_OPERATOR:	aOut = String( RTL_CONSTASCII_USTRINGPARAM("TT_OPERATOR:") ); break;
+		case TT_KEYWORD:	aOut = String( RTL_CONSTASCII_USTRINGPARAM("TT_KEYWORD:") ); break;
+	}
+	if( eType != TT_EOL )
+	{
+		aOut += String( pStartPos, (USHORT)( pEndPos - pStartPos ) );
+	}
+	aOut += String( RTL_CONSTASCII_USTRINGPARAM("\n") );
+	return aOut;
+}
+#endif
+
+SimpleTokenizer_Impl::SimpleTokenizer_Impl( void )
+{
+	memset( aCharTypeTab, 0, sizeof( aCharTypeTab ) );
+
+	// Zeichen-Tabelle fuellen
+	USHORT i;
+
+	// Zulaessige Zeichen fuer Identifier
+	USHORT nHelpMask = (USHORT)( CHAR_START_IDENTIFIER | CHAR_IN_IDENTIFIER );
+	for( i = 'a' ; i <= 'z' ; i++ )
+		aCharTypeTab[i] |= nHelpMask;
+	for( i = 'A' ; i <= 'Z' ; i++ )
+		aCharTypeTab[i] |= nHelpMask;
+	// '_' extra eintragen
+	aCharTypeTab[(int)'_'] |= nHelpMask;
+	// AB 23.6.97: '$' ist auch erlaubt
+	aCharTypeTab[(int)'$'] |= nHelpMask;
+
+	// Ziffern (Identifier und Number ist moeglich)
+	nHelpMask = (USHORT)( CHAR_IN_IDENTIFIER | CHAR_START_NUMBER |
+						 CHAR_IN_NUMBER | CHAR_IN_HEX_NUMBER );
+	for( i = '0' ; i <= '9' ; i++ )
+		aCharTypeTab[i] |= nHelpMask;
+
+	// e und E sowie . von Hand ergaenzen
+	aCharTypeTab[(int)'e'] |= CHAR_IN_NUMBER;
+	aCharTypeTab[(int)'E'] |= CHAR_IN_NUMBER;
+	aCharTypeTab[(int)'.'] |= (USHORT)( CHAR_IN_NUMBER | CHAR_START_NUMBER );
+	aCharTypeTab[(int)'&'] |= CHAR_START_NUMBER;
+
+	// Hex-Ziffern
+	for( i = 'a' ; i <= 'f' ; i++ )
+		aCharTypeTab[i] |= CHAR_IN_HEX_NUMBER;
+	for( i = 'A' ; i <= 'F' ; i++ )
+		aCharTypeTab[i] |= CHAR_IN_HEX_NUMBER;
+
+	// Oct-Ziffern
+	for( i = '0' ; i <= '7' ; i++ )
+		aCharTypeTab[i] |= CHAR_IN_OCT_NUMBER;
+
+	// String-Beginn/End-Zeichen
+	aCharTypeTab[(int)'\''] |= CHAR_START_STRING;
+	aCharTypeTab[(int)'\"'] |= CHAR_START_STRING;
+	aCharTypeTab[(int)'[']  |= CHAR_START_STRING;
+
+	// Operator-Zeichen
+	aCharTypeTab[(int)'!'] |= CHAR_OPERATOR;
+	aCharTypeTab[(int)'%'] |= CHAR_OPERATOR;
+	// aCharTypeTab[(int)'&'] |= CHAR_OPERATOR;		Removed because of #i14140
+	aCharTypeTab[(int)'('] |= CHAR_OPERATOR;
+	aCharTypeTab[(int)')'] |= CHAR_OPERATOR;
+	aCharTypeTab[(int)'*'] |= CHAR_OPERATOR;
+	aCharTypeTab[(int)'+'] |= CHAR_OPERATOR;
+	aCharTypeTab[(int)','] |= CHAR_OPERATOR;
+	aCharTypeTab[(int)'-'] |= CHAR_OPERATOR;
+	aCharTypeTab[(int)'/'] |= CHAR_OPERATOR;
+	aCharTypeTab[(int)':'] |= CHAR_OPERATOR;
+	aCharTypeTab[(int)'<'] |= CHAR_OPERATOR;
+	aCharTypeTab[(int)'='] |= CHAR_OPERATOR;
+	aCharTypeTab[(int)'>'] |= CHAR_OPERATOR;
+	aCharTypeTab[(int)'?'] |= CHAR_OPERATOR;
+	aCharTypeTab[(int)'^'] |= CHAR_OPERATOR;
+	aCharTypeTab[(int)'|'] |= CHAR_OPERATOR;
+	aCharTypeTab[(int)'~'] |= CHAR_OPERATOR;
+	aCharTypeTab[(int)'{'] |= CHAR_OPERATOR;
+	aCharTypeTab[(int)'}'] |= CHAR_OPERATOR;
+	// aCharTypeTab[(int)'['] |= CHAR_OPERATOR;		Removed because of #i17826
+	aCharTypeTab[(int)']'] |= CHAR_OPERATOR;
+	aCharTypeTab[(int)';'] |= CHAR_OPERATOR;
+
+	// Space
+	aCharTypeTab[(int)' ' ] |= CHAR_SPACE;
+	aCharTypeTab[(int)'\t'] |= CHAR_SPACE;
+
+	// Zeilen-Ende-Zeichen
+	aCharTypeTab[(int)'\r'] |= CHAR_EOL;
+	aCharTypeTab[(int)'\n'] |= CHAR_EOL;
+
+	ppListKeyWords = NULL;
+}
+
+SimpleTokenizer_Impl::~SimpleTokenizer_Impl( void )
+{
+}
+
+SimpleTokenizer_Impl* getSimpleTokenizer( void )
+{
+	static SimpleTokenizer_Impl* pSimpleTokenizer = NULL;
+	if( !pSimpleTokenizer )
+		pSimpleTokenizer = new SimpleTokenizer_Impl();
+	return pSimpleTokenizer;
+}
+
+// Heraussuchen der jeweils naechsten Funktion aus einem JavaScript-Modul
+UINT16 SimpleTokenizer_Impl::parseLine( UINT32 nParseLine, const String* aSource )
+{
+	// Position auf den Anfang des Source-Strings setzen
+	mpStringBegin = mpActualPos = aSource->GetBuffer();
+
+	// Zeile und Spalte initialisieren
+	nLine = nParseLine;
+	nCol = 0L;
+
+	// Variablen fuer die Out-Parameter
+	TokenTypes eType;
+	const sal_Unicode* pStartPos;
+	const sal_Unicode* pEndPos;
+
+	// Schleife ueber alle Tokens
+	UINT16 nTokenCount = 0;
+	while( getNextToken( eType, pStartPos, pEndPos ) )
+		nTokenCount++;
+
+	return nTokenCount;
+}
+
+void SimpleTokenizer_Impl::getHighlightPortions( UINT32 nParseLine, const String& rLine,
+													/*out*/HighlightPortions& portions  )
+{
+	// Position auf den Anfang des Source-Strings setzen
+	mpStringBegin = mpActualPos = rLine.GetBuffer();
+
+	// Zeile und Spalte initialisieren
+	nLine = nParseLine;
+	nCol = 0L;
+
+	// Variablen fuer die Out-Parameter
+	TokenTypes eType;
+	const sal_Unicode* pStartPos;
+	const sal_Unicode* pEndPos;
+
+	// Schleife ueber alle Tokens
+	while( getNextToken( eType, pStartPos, pEndPos ) )
+	{
+		HighlightPortion portion;
+
+		portion.nBegin = (UINT16)(pStartPos - mpStringBegin);
+		portion.nEnd = (UINT16)(pEndPos - mpStringBegin);
+		portion.tokenType = eType;
+
+		portions.Insert(portion, portions.Count());
+	}
+}
+
+
+//////////////////////////////////////////////////////////////////////////
+// Implementierung des SyntaxHighlighter
+
+SyntaxHighlighter::SyntaxHighlighter()
+{
+	m_pSimpleTokenizer = new SimpleTokenizer_Impl();
+	m_pKeyWords = NULL;
+	m_nKeyWordCount = 0;
+}
+
+SyntaxHighlighter::~SyntaxHighlighter()
+{
+	delete(m_pSimpleTokenizer);
+	delete(m_pKeyWords);
+}
+
+void SyntaxHighlighter::initialize( HighlighterLanguage eLanguage_ )
+{
+	eLanguage = eLanguage_;
+	delete(m_pSimpleTokenizer);
+	m_pSimpleTokenizer = new SimpleTokenizer_Impl();
+
+	if (eLanguage == HIGHLIGHT_BASIC)
+	{
+		m_pSimpleTokenizer->setKeyWords( strListBasicKeyWords,
+											sizeof( strListBasicKeyWords ) / sizeof( char* ));
+	}
+	else
+	{
+		m_pSimpleTokenizer->setKeyWords( NULL, 0 );
+	}
+}
+
+const Range SyntaxHighlighter::notifyChange( UINT32 nLine, INT32 nLineCountDifference,
+								const String* pChangedLines, UINT32 nArrayLength)
+{
+    (void)nLineCountDifference;
+    
+	for( UINT32 i=0 ; i < nArrayLength ; i++ )
+		m_pSimpleTokenizer->parseLine(nLine+i, &pChangedLines[i]);
+
+	return Range( nLine, nLine + nArrayLength-1 );
+}
+
+void SyntaxHighlighter::getHighlightPortions( UINT32 nLine, const String& rLine,
+											/*out*/HighlightPortions& portions )
+{
+	m_pSimpleTokenizer->getHighlightPortions( nLine, rLine, portions );
+}
+
+/////////////////////////////////////////////////////////////////////////
+SbObjModule::SbObjModule( const rtl::OUString& rName, const com::sun::star::script::ModuleInfo& mInfo )
+    :SbModule( rName ), pDocObject( NULL )
+{
+    m_mInfo = mInfo;
+    SetSource32( mInfo.ModuleSource );
+}
+SbxVariable*
+SbObjModule::GetObject()
+{
+    if( !pDocObject )
+        InitObject( GetName() );
+    return pDocObject;
+}
+SbxVariable*
+SbObjModule::Find( const XubString& rName, SbxClassType t )
+{
+    OSL_TRACE("SbObjectModule find for %s", rtl::OUStringToOString(  rName, RTL_TEXTENCODING_UTF8 ).getStr() );
+    if ( !pDocObject )
+        InitObject( GetName() );
+    OSL_TRACE("!!!!try to find in derived module " );
+    SbxVariable* pVar = NULL;
+    if ( !pVar && pDocObject)
+    {
+        pVar = pDocObject->Find( rName, t );
+        if ( pVar )
+        {
+           OSL_TRACE("found in uno (psuedo-base) object" );
+        }
+        else
+           OSL_TRACE("NOT found in uno (psuedo-base) object" );
+    }
+    if ( !pVar )
+    {
+        pVar = SbModule::Find( rName, t );
+        if ( pVar )
+           OSL_TRACE("! found in (normal) module " );
+    }
+    if ( pVar && pVar->GetParent() == this )
+        pVar->SetFlag( SBX_PRIVATE );
+
+    return pVar;
+}
+void
+SbObjModule::InitObject( const XubString& rName )
+{
+    OSL_TRACE("Initialize pDocObject");
+    try
+    {
+        com::sun::star::uno::Reference< com::sun::star::script::XObjectProvider > xObjectProvider( m_mInfo.ModuleObjectProvider, com::sun::star::uno::UNO_QUERY_THROW );
+        pDocObject = new SbUnoObject( rName, xObjectProvider->getObject() );
+    }catch( com::sun::star::uno::RuntimeException e )
+    {
+        OSL_TRACE("Object is not exist." );
+    }
+}
+void
+SbObjModule::SetCodeName( const XubString& rName )
+{
+}
+
+/////////////////////////////////////////////////////////////////////////
+// Implementation SbJScriptModule (Basic-Modul fuer JavaScript-Sourcen)
+SbJScriptModule::SbJScriptModule( const String& rName )
+	:SbModule( rName )
+{
+}
+
+BOOL SbJScriptModule::LoadData( SvStream& rStrm, USHORT nVer )
+{
+    (void)nVer;
+    
+	Clear();
+	if( !SbxObject::LoadData( rStrm, 1 ) )
+		return FALSE;
+
+	// Source-String holen
+    String aTmp;
+	rStrm.ReadByteString( aTmp, gsl_getSystemTextEncoding() );
+    aOUSource = aTmp;
+	//rStrm >> aSource;
+	return TRUE;
+}
+
+BOOL SbJScriptModule::StoreData( SvStream& rStrm ) const
+{
+	if( !SbxObject::StoreData( rStrm ) )
+		return FALSE;
+
+	// Source-String schreiben
+    String aTmp = aOUSource;
+	rStrm.WriteByteString( aTmp, gsl_getSystemTextEncoding() );
+	//rStrm << aSource;
+	return TRUE;
+}
+
+
+/////////////////////////////////////////////////////////////////////////
+
+SbMethod::SbMethod( const String& r, SbxDataType t, SbModule* p )
+		: SbxMethod( r, t ), pMod( p )
+{
+	bInvalid	 = TRUE;
+	nStart		 =
+	nDebugFlags  =
+	nLine1		 =
+	nLine2		 = 0;
+	// AB: 2.7.1996: HACK wegen 'Referenz kann nicht gesichert werden'
+	SetFlag( SBX_NO_MODIFY );
+}
+
+SbMethod::SbMethod( const SbMethod& r )
+    : SvRefBase( r ), SbxMethod( r )
+{
+    pMod         = r.pMod;
+	bInvalid	 = r.bInvalid;
+	nStart		 = r.nStart;
+	nDebugFlags  = r.nDebugFlags;
+	nLine1		 = r.nLine1;
+	nLine2		 = r.nLine2;
+	SetFlag( SBX_NO_MODIFY );
+}
+
+SbMethod::~SbMethod()
+{
+}
+
+SbxArray* SbMethod::GetLocals()
+{
+	if( pINST )
+		return pINST->GetLocals( this );
+	else
+		return NULL;
+}
+
+SbxArray* SbMethod::GetStatics()
+{
+	DBG_ERROR( "SbMethod::GetStatics() invalid, AB fragen" )
+	return NULL;
+}
+
+BOOL SbMethod::LoadData( SvStream& rStrm, USHORT nVer )
+{
+	if( !SbxMethod::LoadData( rStrm, 1 ) )
+		return FALSE;
+	INT16 n;
+	rStrm >> n;
+	INT16 nTempStart = (INT16)nStart;
+	// nDebugFlags = n; 	// AB 16.1.96: Nicht mehr uebernehmen
+	if( nVer == 2 )
+		rStrm >> nLine1 >> nLine2 >> nTempStart >> bInvalid;
+	// AB: 2.7.1996: HACK wegen 'Referenz kann nicht gesichert werden'
+	SetFlag( SBX_NO_MODIFY );
+	nStart = nTempStart;
+	return TRUE;
+}
+
+BOOL SbMethod::StoreData( SvStream& rStrm ) const
+{
+	if( !SbxMethod::StoreData( rStrm ) )
+		return FALSE;
+	rStrm << (INT16) nDebugFlags
+		  << (INT16) nLine1
+		  << (INT16) nLine2
+		  << (INT16) nStart
+		  << (BYTE)  bInvalid;
+	return TRUE;
+}
+
+void SbMethod::GetLineRange( USHORT& l1, USHORT& l2 )
+{
+	l1 = nLine1; l2 = nLine2;
+}
+
+// Kann spaeter mal weg
+
+SbxInfo* SbMethod::GetInfo()
+{
+	return pInfo;
+}
+
+// Schnittstelle zum Ausfuehren einer Methode aus den Applikationen
+// #34191# Mit speziellem RefCounting, damit das Basic nicht durch CloseDocument()
+// abgeschossen werden kann. Rueckgabewert wird als String geliefert.
+ErrCode SbMethod::Call( SbxValue* pRet )
+{
+	// RefCount vom Modul hochzaehlen
+	SbModule* pMod_ = (SbModule*)GetParent();
+	pMod_->AddRef();
+
+	// RefCount vom Basic hochzaehlen
+	StarBASIC* pBasic = (StarBASIC*)pMod_->GetParent();
+	pBasic->AddRef();
+
+	// Values anlegen, um Return-Wert zu erhalten
+	SbxValues aVals;
+	aVals.eType = SbxVARIANT;
+
+    // #104083: Compile BEFORE get
+	if( bInvalid && !pMod_->Compile() )
+		StarBASIC::Error( SbERR_BAD_PROP_VALUE );
+
+	Get( aVals );
+	if ( pRet )
+		pRet->Put( aVals );
+
+	// Gab es einen Error
+	ErrCode nErr = SbxBase::GetError();
+	SbxBase::ResetError();
+
+	// Objekte freigeben
+	pMod_->ReleaseRef();
+	pBasic->ReleaseRef();
+
+	return nErr;
+}
+
+
+// #100883 Own Broadcast for SbMethod
+void SbMethod::Broadcast( ULONG nHintId )
+{
+	if( pCst && !IsSet( SBX_NO_BROADCAST ) && StaticIsEnabledBroadcasting() )
+	{
+		// Da die Methode von aussen aufrufbar ist, hier noch einmal
+		// die Berechtigung testen
+		if( nHintId & SBX_HINT_DATAWANTED )
+			if( !CanRead() )
+				return;
+		if( nHintId & SBX_HINT_DATACHANGED )
+			if( !CanWrite() )
+				return;
+
+        if( pMod && !pMod->IsCompiled() )
+            pMod->Compile();
+
+		// Block broadcasts while creating new method
+		SfxBroadcaster* pSave = pCst;
+		pCst = NULL;
+		SbMethod* pThisCopy = new SbMethod( *this );
+        SbMethodRef xHolder = pThisCopy;
+		if( mpPar.Is() )
+        {
+			// this, als Element 0 eintragen, aber den Parent nicht umsetzen!
+			if( GetType() != SbxVOID )
+        		mpPar->PutDirect( pThisCopy, 0 );
+       		SetParameters( NULL );
+        }
+
+		pCst = pSave;
+		pSave->Broadcast( SbxHint( nHintId, pThisCopy ) );
+
+		USHORT nSaveFlags = GetFlags();
+		SetFlag( SBX_READWRITE );
+        pCst = NULL;
+        Put( pThisCopy->GetValues_Impl() );
+		pCst = pSave;
+		SetFlags( nSaveFlags );
+	}
+}
+
+/////////////////////////////////////////////////////////////////////////
+
+// Implementation SbJScriptMethod (Method-Klasse als Wrapper fuer JavaScript-Funktionen)
+
+SbJScriptMethod::SbJScriptMethod( const String& r, SbxDataType t, SbModule* p )
+		: SbMethod( r, t, p )
+{
+}
+
+SbJScriptMethod::~SbJScriptMethod()
+{}
+
+
+/////////////////////////////////////////////////////////////////////////
+
+SbProperty::SbProperty( const String& r, SbxDataType t, SbModule* p )
+		: SbxProperty( r, t ), pMod( p )
+{
+	bInvalid = FALSE;
+}
+
+SbProperty::~SbProperty()
+{}
+
+/////////////////////////////////////////////////////////////////////////
+
+SbProcedureProperty::~SbProcedureProperty()
+{}
+
+
--- basic/source/classes/sb.cxx.bak	1970-01-01 08:00:00.000000000 +0800
+++ basic/source/classes/sb.cxx	2007-10-15 11:51:06.000000000 +0800
@@ -0,0 +1,1761 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile: sb.cxx,v $
+ *
+ *  $Revision: 1.32 $
+ *
+ *  last change: $Author: hr $ $Date: 2007/06/27 14:18:35 $
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+
+// MARKER(update_precomp.py): autogen include statement, do not remove
+#include "precompiled_basic.hxx"
+
+#include <stdio.h>
+
+#include "sb.hxx"
+#include <tools/rcid.h>
+#include <tools/config.hxx>
+
+#ifndef _STREAM_HXX //autogen
+#include <tools/stream.hxx>
+#endif
+#ifndef __RSC //autogen
+#include <tools/errinf.hxx>
+#endif
+#ifndef _SBXCLASS_HXX //autogen
+#include <basic/sbx.hxx>
+#endif
+#ifndef _LIST_HXX //autogen
+#include <tools/list.hxx>
+#endif
+#ifndef _SHL_HXX //autogen
+#include <tools/shl.hxx>
+#endif
+#ifndef _TOOLS_RC_HXX //autogen
+#include <tools/rc.hxx>
+#endif
+#ifndef _SV_SVAPP_HXX //autogen
+#include <vcl/svapp.hxx>
+#endif
+#include "sbunoobj.hxx"
+#include "sbjsmeth.hxx"
+#include "sbjsmod.hxx"
+#include "sbintern.hxx"
+#include "disas.hxx"
+#include "runtime.hxx"
+#include <basic/sbuno.hxx>
+#include <basic/sbobjmod.hxx>
+#include "stdobj.hxx"
+#include "filefmt.hxx"
+#include "sb.hrc"
+#include <basrid.hxx>
+
+#ifndef _VOS_MUTEX_HXX_
+#include <vos/mutex.hxx>
+#endif
+
+// #pragma SW_SEGMENT_CLASS( SBASIC, SBASIC_CODE )
+
+SV_IMPL_VARARR(SbTextPortions,SbTextPortion)
+
+TYPEINIT1(StarBASIC,SbxObject)
+
+#define RTLNAME "@SBRTL"
+
+
+//========================================================================
+// Array zur Umrechnung SFX <-> VB-Fehlercodes anlegen
+
+struct SFX_VB_ErrorItem
+{
+	USHORT  nErrorVB;
+	SbError nErrorSFX;
+};
+
+const SFX_VB_ErrorItem __FAR_DATA SFX_VB_ErrorTab[] =
+{
+	{ 1, SbERR_BASIC_EXCEPTION },  // #87844 Map exception to error code 1
+	{ 2, SbERR_SYNTAX },
+	{ 3, SbERR_NO_GOSUB },
+	{ 4, SbERR_REDO_FROM_START },
+	{ 5, SbERR_BAD_ARGUMENT },
+	{ 6, SbERR_MATH_OVERFLOW },
+	{ 7, SbERR_NO_MEMORY },
+	{ 8, SbERR_ALREADY_DIM },
+	{ 9, SbERR_OUT_OF_RANGE },
+	{ 10, SbERR_DUPLICATE_DEF },
+	{ 11, SbERR_ZERODIV },
+	{ 12, SbERR_VAR_UNDEFINED },
+	{ 13, SbERR_CONVERSION },
+	{ 14, SbERR_BAD_PARAMETER },
+	{ 18, SbERR_USER_ABORT },
+	{ 20, SbERR_BAD_RESUME },
+	{ 28, SbERR_STACK_OVERFLOW },
+	{ 35, SbERR_PROC_UNDEFINED },
+	{ 48, SbERR_BAD_DLL_LOAD },
+	{ 49, SbERR_BAD_DLL_CALL },
+	{ 51, SbERR_INTERNAL_ERROR },
+	{ 52, SbERR_BAD_CHANNEL },
+	{ 53, SbERR_FILE_NOT_FOUND },
+	{ 54, SbERR_BAD_FILE_MODE },
+	{ 55, SbERR_FILE_ALREADY_OPEN },
+	{ 57, SbERR_IO_ERROR },
+	{ 58, SbERR_FILE_EXISTS },
+	{ 59, SbERR_BAD_RECORD_LENGTH },
+	{ 61, SbERR_DISK_FULL },
+	{ 62, SbERR_READ_PAST_EOF },
+	{ 63, SbERR_BAD_RECORD_NUMBER },
+	{ 67, SbERR_TOO_MANY_FILES },
+	{ 68, SbERR_NO_DEVICE },
+	{ 70, SbERR_ACCESS_DENIED },
+	{ 71, SbERR_NOT_READY },
+	{ 73, SbERR_NOT_IMPLEMENTED },
+	{ 74, SbERR_DIFFERENT_DRIVE },
+	{ 75, SbERR_ACCESS_ERROR },
+	{ 76, SbERR_PATH_NOT_FOUND },
+	{ 91, SbERR_NO_OBJECT },
+	{ 93, SbERR_BAD_PATTERN },
+	{ 94, SBERR_IS_NULL },
+	{ 250, SbERR_DDE_ERROR },
+	{ 280, SbERR_DDE_WAITINGACK },
+	{ 281, SbERR_DDE_OUTOFCHANNELS },
+	{ 282, SbERR_DDE_NO_RESPONSE },
+	{ 283, SbERR_DDE_MULT_RESPONSES },
+	{ 284, SbERR_DDE_CHANNEL_LOCKED },
+	{ 285, SbERR_DDE_NOTPROCESSED },
+	{ 286, SbERR_DDE_TIMEOUT },
+	{ 287, SbERR_DDE_USER_INTERRUPT },
+	{ 288, SbERR_DDE_BUSY },
+	{ 289, SbERR_DDE_NO_DATA },
+	{ 290, SbERR_DDE_WRONG_DATA_FORMAT },
+	{ 291, SbERR_DDE_PARTNER_QUIT },
+	{ 292, SbERR_DDE_CONV_CLOSED },
+	{ 293, SbERR_DDE_NO_CHANNEL },
+	{ 294, SbERR_DDE_INVALID_LINK },
+	{ 295, SbERR_DDE_QUEUE_OVERFLOW },
+	{ 296, SbERR_DDE_LINK_ALREADY_EST },
+	{ 297, SbERR_DDE_LINK_INV_TOPIC },
+	{ 298, SbERR_DDE_DLL_NOT_FOUND },
+	{ 323, SbERR_CANNOT_LOAD },
+	{ 341, SbERR_BAD_INDEX },
+	{ 366, SbERR_NO_ACTIVE_OBJECT },
+	{ 380, SbERR_BAD_PROP_VALUE },
+	{ 382, SbERR_PROP_READONLY },
+	{ 394, SbERR_PROP_WRITEONLY },
+	{ 420, SbERR_INVALID_OBJECT },
+	{ 423, SbERR_NO_METHOD },
+	{ 424, SbERR_NEEDS_OBJECT },
+	{ 425, SbERR_INVALID_USAGE_OBJECT },
+	{ 430, SbERR_NO_OLE },
+	{ 438, SbERR_BAD_METHOD },
+	{ 440, SbERR_OLE_ERROR },
+	{ 445, SbERR_BAD_ACTION },
+	{ 446, SbERR_NO_NAMED_ARGS },
+	{ 447, SbERR_BAD_LOCALE },
+	{ 448, SbERR_NAMED_NOT_FOUND },
+	{ 449, SbERR_NOT_OPTIONAL },
+	{ 450, SbERR_WRONG_ARGS },
+	{ 451, SbERR_NOT_A_COLL },
+	{ 452, SbERR_BAD_ORDINAL },
+	{ 453, SbERR_DLLPROC_NOT_FOUND },
+	{ 460, SbERR_BAD_CLIPBD_FORMAT },
+	{ 951, SbERR_UNEXPECTED },
+	{ 952, SbERR_EXPECTED },
+	{ 953, SbERR_SYMBOL_EXPECTED },
+	{ 954, SbERR_VAR_EXPECTED },
+	{ 955, SbERR_LABEL_EXPECTED },
+	{ 956, SbERR_LVALUE_EXPECTED },
+	{ 957, SbERR_VAR_DEFINED },
+	{ 958, SbERR_PROC_DEFINED },
+	{ 959, SbERR_LABEL_DEFINED },
+	{ 960, SbERR_UNDEF_VAR },
+	{ 961, SbERR_UNDEF_ARRAY },
+	{ 962, SbERR_UNDEF_PROC },
+	{ 963, SbERR_UNDEF_LABEL },
+	{ 964, SbERR_UNDEF_TYPE },
+	{ 965, SbERR_BAD_EXIT },
+	{ 966, SbERR_BAD_BLOCK },
+	{ 967, SbERR_BAD_BRACKETS },
+	{ 968, SbERR_BAD_DECLARATION },
+	{ 969, SbERR_BAD_PARAMETERS },
+	{ 970, SbERR_BAD_CHAR_IN_NUMBER },
+	{ 971, SbERR_MUST_HAVE_DIMS },
+	{ 972, SbERR_NO_IF },
+	{ 973, SbERR_NOT_IN_SUBR },
+	{ 974, SbERR_NOT_IN_MAIN },
+	{ 975, SbERR_WRONG_DIMS },
+	{ 976, SbERR_BAD_OPTION },
+	{ 977, SbERR_CONSTANT_REDECLARED },
+	{ 978, SbERR_PROG_TOO_LARGE },
+	{ 979, SbERR_NO_STRINGS_ARRAYS },
+	{ 1000, SbERR_PROPERTY_NOT_FOUND },
+	{ 1001, SbERR_METHOD_NOT_FOUND },
+	{ 1002, SbERR_ARG_MISSING },
+	{ 1003, SbERR_BAD_NUMBER_OF_ARGS },
+	{ 1004, SbERR_METHOD_FAILED },
+	{ 1005, SbERR_SETPROP_FAILED },
+	{ 1006, SbERR_GETPROP_FAILED },
+	{ 1007, SbERR_BASIC_COMPAT },
+	{ 0xFFFF, 0xFFFFFFFFL }		// End-Marke
+};
+
+
+////////////////////////////////////////////////////////////////////////////
+
+// Die StarBASIC-Factory hat einen Hack. Wenn ein SbModule eingerichtet wird,
+// wird der Pointer gespeichert und an nachfolgende SbProperties/SbMethods
+// uebergeben. Dadurch wird die Modul-Relationship wiederhergestellt. Das
+// klappt aber nur, wenn ein Modul geladen wird. Fuer getrennt geladene
+// Properties kann es Probleme geben!
+
+SbxBase* SbiFactory::Create( UINT16 nSbxId, UINT32 nCreator )
+{
+	if( nCreator ==  SBXCR_SBX )
+	{
+		String aEmpty;
+		switch( nSbxId )
+		{
+			case SBXID_BASIC:
+				return new StarBASIC( NULL );
+			case SBXID_BASICMOD:
+				return new SbModule( aEmpty );
+			case SBXID_BASICPROP:
+				return new SbProperty( aEmpty, SbxVARIANT, NULL );
+			case SBXID_BASICMETHOD:
+				return new SbMethod( aEmpty, SbxVARIANT, NULL );
+			case SBXID_JSCRIPTMOD:
+				return new SbJScriptModule( aEmpty );
+			case SBXID_JSCRIPTMETH:
+				return new SbJScriptMethod( aEmpty, SbxVARIANT, NULL );
+		}
+	}
+	return NULL;
+}
+
+SbxObject* SbiFactory::CreateObject( const String& rClass )
+{
+	if( rClass.EqualsIgnoreCaseAscii( "StarBASIC" ) )
+		return new StarBASIC( NULL );
+	else
+	if( rClass.EqualsIgnoreCaseAscii( "StarBASICModule" ) )
+	{
+		String aEmpty;
+		return new SbModule( aEmpty );
+	}
+	else
+	if( rClass.EqualsIgnoreCaseAscii( "Collection" ) )
+	{
+		String aCollectionName( RTL_CONSTASCII_USTRINGPARAM("Collection") );
+		return new BasicCollection( aCollectionName );
+	}
+	else
+		return NULL;
+}
+
+
+// Factory class to create OLE objects
+class SbOLEFactory : public SbxFactory
+{
+public:
+	virtual SbxBase* Create( UINT16 nSbxId, UINT32 = SBXCR_SBX );
+	virtual SbxObject* CreateObject( const String& );
+};
+
+SbxBase* SbOLEFactory::Create( UINT16, UINT32 )
+{
+	// Not supported
+	return NULL;
+}
+
+SbUnoObject* createOLEObject_Impl( const String& aType );	// sbunoobj.cxx
+
+SbxObject* SbOLEFactory::CreateObject( const String& rClassName )
+{
+	SbxObject* pRet = createOLEObject_Impl( rClassName );
+	return pRet;
+}
+
+
+// Factory class to create user defined objects (type command)
+class SbTypeFactory : public SbxFactory
+{
+	SbxObject* cloneTypeObjectImpl( const SbxObject& rTypeObj );
+
+public:
+	virtual SbxBase* Create( UINT16 nSbxId, UINT32 = SBXCR_SBX );
+	virtual SbxObject* CreateObject( const String& );
+};
+
+SbxBase* SbTypeFactory::Create( UINT16, UINT32 )
+{
+	// Not supported
+	return NULL;
+}
+
+SbxObject* SbTypeFactory::cloneTypeObjectImpl( const SbxObject& rTypeObj )
+{
+	SbxObject* pRet = new SbxObject( rTypeObj );
+	pRet->PutObject( pRet );
+
+	// Copy the properties, not only the reference to them
+	SbxArray* pProps = pRet->GetProperties();
+	UINT32 nCount = pProps->Count32();
+	for( UINT32 i = 0 ; i < nCount ; i++ )
+	{
+		SbxVariable* pVar = pProps->Get32( i );
+		SbxProperty* pProp = PTR_CAST( SbxProperty, pVar );
+		if( pProp )
+		{
+			SbxProperty* pNewProp = new SbxProperty( *pProp );
+			pProps->PutDirect( pNewProp, i );
+		}
+	}
+	return pRet;
+}
+
+SbxObject* SbTypeFactory::CreateObject( const String& rClassName )
+{
+	SbxObject* pRet = NULL;
+	SbModule* pMod = pMOD;
+	if( pMod )
+	{
+		const SbxObject* pObj = pMod->FindType( rClassName );
+		if( pObj )
+			pRet = cloneTypeObjectImpl( *pObj );
+	}
+	return pRet;
+}
+
+SbxObject* createUserTypeImpl( const String& rClassName )
+{
+	SbxObject* pRetObj = pTYPEFAC->CreateObject( rClassName );
+	return pRetObj;
+}
+
+TYPEINIT1(SbClassModuleObject,SbModule)
+
+SbClassModuleObject::SbClassModuleObject( SbModule* pClassModule )
+	: SbModule( pClassModule->GetName() )
+	, mpClassModule( pClassModule )
+	, mbInitializeEventDone( false )
+{
+	aOUSource = pClassModule->aOUSource;
+	aComment = pClassModule->aComment;
+	pImage = pClassModule->pImage;
+	pBreaks = pClassModule->pBreaks;
+
+	SetClassName( pClassModule->GetName() );
+
+	// Allow search only internally
+	ResetFlag( SBX_GBLSEARCH );
+
+	// Copy the methods from original class module
+	SbxArray* pClassMethods = pClassModule->GetMethods();
+	UINT32 nMethodCount = pClassMethods->Count32();
+	UINT32 i;
+	for( i = 0 ; i < nMethodCount ; i++ )
+	{
+		SbxVariable* pVar = pClassMethods->Get32( i );
+
+		// Exclude SbIfaceMapperMethod to copy them in a second step
+		SbIfaceMapperMethod* pIfaceMethod = PTR_CAST( SbIfaceMapperMethod, pVar );
+		if( !pIfaceMethod )
+		{
+			SbMethod* pMethod = PTR_CAST(SbMethod, pVar );
+			if( pMethod )
+			{
+				USHORT nFlags_ = pMethod->GetFlags();
+				pMethod->SetFlag( SBX_NO_BROADCAST );
+				SbMethod* pNewMethod = new SbMethod( *pMethod );
+				pNewMethod->ResetFlag( SBX_NO_BROADCAST );
+				pMethod->SetFlags( nFlags_ );
+				pNewMethod->pMod = this;
+				pNewMethod->SetParent( this );
+				pMethods->PutDirect( pNewMethod, i );
+				StartListening( pNewMethod->GetBroadcaster(), TRUE );
+			}
+		}
+	}
+
+	// Copy SbIfaceMapperMethod in a second step to ensure that 
+	// the corresponding base methods have already been copied
+	for( i = 0 ; i < nMethodCount ; i++ )
+	{
+		SbxVariable* pVar = pClassMethods->Get32( i );
+
+		SbIfaceMapperMethod* pIfaceMethod = PTR_CAST( SbIfaceMapperMethod, pVar );
+		if( pIfaceMethod )
+		{
+			SbMethod* pImplMethod = pIfaceMethod->getImplMethod();
+			if( !pImplMethod )
+			{
+				DBG_ERROR( "No ImplMethod" );
+				continue;
+			}
+
+			// Search for own copy of ImplMethod
+			String aImplMethodName = pImplMethod->GetName();
+			SbxVariable* p = pMethods->Find( aImplMethodName, SbxCLASS_METHOD );
+			SbMethod* pImplMethodCopy = p ? PTR_CAST(SbMethod,p) : NULL;
+			if( !pImplMethodCopy )
+			{
+				DBG_ERROR( "Found no ImplMethod copy" );
+				continue;
+			}
+			SbIfaceMapperMethod* pNewIfaceMethod = 
+				new SbIfaceMapperMethod( pIfaceMethod->GetName(), pImplMethodCopy );
+			pMethods->PutDirect( pNewIfaceMethod, i );
+		}
+	}
+
+	// Copy the properties from original class module
+	SbxArray* pClassProps = pClassModule->GetProperties();
+	UINT32 nPropertyCount = pClassProps->Count32();
+	for( i = 0 ; i < nPropertyCount ; i++ )
+	{
+		SbxVariable* pVar = pClassProps->Get32( i );
+		SbProcedureProperty* pProcedureProp = PTR_CAST( SbProcedureProperty, pVar );
+		if( pProcedureProp )
+		{
+			USHORT nFlags_ = pProcedureProp->GetFlags();
+			pProcedureProp->SetFlag( SBX_NO_BROADCAST );
+			SbProcedureProperty* pNewProp = new SbProcedureProperty
+				( pProcedureProp->GetName(), pProcedureProp->GetType() );
+				// ( pProcedureProp->GetName(), pProcedureProp->GetType(), this );
+			pNewProp->ResetFlag( SBX_NO_BROADCAST );
+			pProcedureProp->SetFlags( nFlags_ );
+			pProps->PutDirect( pNewProp, i );
+			StartListening( pNewProp->GetBroadcaster(), TRUE );
+		}
+		else
+		{
+			SbxProperty* pProp = PTR_CAST( SbxProperty, pVar );
+			if( pProp )
+			{
+				USHORT nFlags_ = pProp->GetFlags();
+				pProp->SetFlag( SBX_NO_BROADCAST );
+				SbxProperty* pNewProp = new SbxProperty( *pProp );
+				pNewProp->ResetFlag( SBX_NO_BROADCAST );
+				pNewProp->SetParent( this );
+				pProps->PutDirect( pNewProp, i );
+				pProp->SetFlags( nFlags_ );
+			}
+		}
+	}
+}
+
+SbClassModuleObject::~SbClassModuleObject()
+{
+	triggerTerminateEvent();
+
+	// Must be deleted by base class dtor because this data 
+	// is not owned by the SbClassModuleObject object
+	pImage = NULL;
+	pBreaks = NULL;
+}
+
+void SbClassModuleObject::SFX_NOTIFY( SfxBroadcaster& rBC, const TypeId& rBCType,
+						   const SfxHint& rHint, const TypeId& rHintType )
+{
+	bool bDone = false;
+
+	const SbxHint* pHint = PTR_CAST(SbxHint,&rHint);
+	if( pHint )
+	{
+		SbxVariable* pVar = pHint->GetVar();
+		SbProcedureProperty* pProcProperty = PTR_CAST( SbProcedureProperty, pVar );
+		if( pProcProperty )
+		{
+			bDone = true;
+
+			if( pHint->GetId() == SBX_HINT_DATAWANTED )
+			{
+				String aProcName;
+				aProcName.AppendAscii( "Property Get " );
+				aProcName += pProcProperty->GetName();
+
+				SbxVariable* pMeth = Find( aProcName, SbxCLASS_METHOD );
+				if( pMeth )
+				{
+					SbxValues aVals;
+					aVals.eType = SbxVARIANT;
+					pMeth->Get( aVals );
+					pVar->Put( aVals );
+				}
+			}
+			else if( pHint->GetId() == SBX_HINT_DATACHANGED )
+			{
+				SbxVariable* pMeth = NULL;
+
+				bool bSet = pProcProperty->isSet();
+				if( bSet )
+				{
+					pProcProperty->setSet( false );
+
+					String aProcName;
+					aProcName.AppendAscii( "Property Set " );
+					aProcName += pProcProperty->GetName();
+					pMeth = Find( aProcName, SbxCLASS_METHOD );
+				}
+				if( !pMeth )	// Let
+				{
+					String aProcName;
+					aProcName.AppendAscii( "Property Let " );
+					aProcName += pProcProperty->GetName();
+					pMeth = Find( aProcName, SbxCLASS_METHOD );
+				}
+
+				if( pMeth )
+				{
+					// Setup parameters
+					SbxArrayRef xArray = new SbxArray;
+					xArray->Put( pMeth, 0 );	// Method as parameter 0
+					xArray->Put( pVar, 1 );
+					pMeth->SetParameters( xArray );
+
+					SbxValues aVals;
+					pMeth->Get( aVals );
+					pMeth->SetParameters( NULL );
+				}
+			}
+		}
+	}
+
+	if( !bDone )
+		SbModule::SFX_NOTIFY( rBC, rBCType, rHint, rHintType );
+}
+
+SbxVariable* SbClassModuleObject::Find( const XubString& rName, SbxClassType t )
+{
+	SbxVariable* pRes = SbxObject::Find( rName, t );
+	if( pRes )
+	{
+		triggerInitializeEvent();
+
+		SbIfaceMapperMethod* pIfaceMapperMethod = PTR_CAST(SbIfaceMapperMethod,pRes);
+		if( pIfaceMapperMethod )
+		{
+			pRes = pIfaceMapperMethod->getImplMethod();
+			pRes->SetFlag( SBX_EXTFOUND );
+		}
+	}
+	return pRes;
+}
+
+void SbClassModuleObject::triggerInitializeEvent( void )
+{
+	static String aInitMethodName( RTL_CONSTASCII_USTRINGPARAM("Class_Initialize") );
+
+	if( mbInitializeEventDone )
+		return;
+
+	mbInitializeEventDone = true;
+
+	// Search method
+	SbxVariable* pMeth = SbxObject::Find( aInitMethodName, SbxCLASS_METHOD );
+	if( pMeth )
+	{
+		SbxValues aVals;
+		pMeth->Get( aVals );
+	}
+}
+
+void SbClassModuleObject::triggerTerminateEvent( void )
+{
+	static String aTermMethodName( RTL_CONSTASCII_USTRINGPARAM("Class_Terminate") );
+
+	if( !mbInitializeEventDone || GetSbData()->bRunInit )
+		return;
+
+	// Search method
+	SbxVariable* pMeth = SbxObject::Find( aTermMethodName, SbxCLASS_METHOD );
+	if( pMeth )
+	{
+		SbxValues aVals;
+		pMeth->Get( aVals );
+	}
+}
+
+
+SbClassData::SbClassData( void )
+{
+	mxIfaces = new SbxArray();
+}
+
+void SbClassData::clear( void )
+{
+	mxIfaces->Clear(); 
+}
+
+SbClassFactory::SbClassFactory( void )
+{
+	String aDummyName;
+	xClassModules = new SbxObject( aDummyName );
+}
+
+SbClassFactory::~SbClassFactory()
+{}
+
+void SbClassFactory::AddClassModule( SbModule* pClassModule )
+{
+	SbxObject* pParent = pClassModule->GetParent();
+	xClassModules->Insert( pClassModule );
+	pClassModule->SetParent( pParent );
+}
+
+void SbClassFactory::RemoveClassModule( SbModule* pClassModule )
+{
+	xClassModules->Remove( pClassModule );
+}
+
+SbxBase* SbClassFactory::Create( UINT16, UINT32 )
+{
+	// Not supported
+	return NULL;
+}
+
+SbxObject* SbClassFactory::CreateObject( const String& rClassName )
+{
+	SbxVariable* pVar = xClassModules->Find( rClassName, SbxCLASS_DONTCARE );
+	SbxObject* pRet = NULL;
+	if( pVar )
+	{
+		SbModule* pMod = (SbModule*)pVar;
+		pRet = new SbClassModuleObject( pMod );
+	}
+	return pRet;
+}
+
+SbModule* SbClassFactory::FindClass( const String& rClassName )
+{
+	SbxVariable* pVar = xClassModules->Find( rClassName, SbxCLASS_DONTCARE );
+	SbModule* pMod = pVar ? (SbModule*)pVar : NULL;
+	return pMod;
+}
+
+
+////////////////////////////////////////////////////////////////////////////
+
+StarBASIC::StarBASIC( StarBASIC* p, BOOL bIsDocBasic  )
+	: SbxObject( String( RTL_CONSTASCII_USTRINGPARAM("StarBASIC") ) ), bDocBasic( bIsDocBasic )
+{
+	SetParent( p );
+	pLibInfo = NULL;
+	bNoRtl = bBreak = FALSE;
+	pModules = new SbxArray;
+
+	if( !GetSbData()->nInst++ )
+	{
+		pSBFAC = new SbiFactory;
+		AddFactory( pSBFAC );
+		pUNOFAC = new SbUnoFactory;
+		AddFactory( pUNOFAC );
+		pTYPEFAC = new SbTypeFactory;
+		AddFactory( pTYPEFAC );
+		pCLASSFAC = new SbClassFactory;
+		AddFactory( pCLASSFAC );
+		pOLEFAC = new SbOLEFactory;
+		AddFactory( pOLEFAC );
+	}
+	pRtl = new SbiStdObject( String( RTL_CONSTASCII_USTRINGPARAM(RTLNAME) ), this );
+	// Suche ueber StarBASIC ist immer global
+	SetFlag( SBX_GBLSEARCH );
+}
+
+// #51727 SetModified ueberladen, damit der Modified-
+// Zustand nicht an den Parent weitergegeben wird.
+void StarBASIC::SetModified( BOOL b )
+{
+	SbxBase::SetModified( b );
+}
+
+//***
+
+StarBASIC::~StarBASIC()
+{
+	if( !--GetSbData()->nInst )
+	{
+		RemoveFactory( pSBFAC );
+		pSBFAC = NULL;
+		RemoveFactory( pUNOFAC );
+		pUNOFAC = NULL;
+		RemoveFactory( pTYPEFAC );
+		pTYPEFAC = NULL;
+		RemoveFactory( pCLASSFAC );
+		pCLASSFAC = NULL;
+		RemoveFactory( pOLEFAC );
+		pOLEFAC = NULL;
+
+#ifdef DBG_UTIL
+	// SbiData braucht am Programm-Ende nicht abgeraeumt werden,
+	// aber wir wollen keine MLK's beim Purify
+	// Wo sollte es sonst geschehen???
+	SbiGlobals** pp = (SbiGlobals**) ::GetAppData( SHL_SBC );
+	SbiGlobals* p = *pp;
+	if( p )
+	{
+		delete p;
+		*pp = 0;
+	}
+#endif
+	}
+
+    // #100326 Set Parent NULL in registered listeners
+    if( xUnoListeners.Is() )
+    {
+        USHORT uCount = xUnoListeners->Count();
+	    for( USHORT i = 0 ; i < uCount ; i++ )
+	    {
+		    SbxVariable* pListenerObj = xUnoListeners->Get( i );
+            pListenerObj->SetParent( NULL );
+        }
+        xUnoListeners = NULL;
+    }
+}
+
+// operator new() wird hier versenkt, damit jeder eine Instanz
+// anlegen kann, ohne neu zu bilden.
+
+void* StarBASIC::operator new( size_t n )
+{
+	if( n < sizeof( StarBASIC ) )
+	{
+//		DBG_ASSERT( FALSE, "Warnung: inkompatibler BASIC-Stand!" );
+		n = sizeof( StarBASIC );
+	}
+	return ::operator new( n );
+}
+
+void StarBASIC::operator delete( void* p )
+{
+	::operator delete( p );
+}
+
+/**************************************************************************
+*
+*	Erzeugen/Verwalten von Modulen
+*
+**************************************************************************/
+
+SbModule* StarBASIC::MakeModule( const String& rName, const String& rSrc )
+{
+	return MakeModule32( rName, rSrc );
+}
+
+SbModule* StarBASIC::MakeModule32( const String& rName, const ::rtl::OUString& rSrc )
+{
+    SbModule* p = new SbModule( rName );
+	p->SetSource32( rSrc );
+	p->SetParent( this );
+	pModules->Insert( p, pModules->Count() );
+	SetModified( TRUE );
+	return p;
+}
+SbModule* StarBASIC::MakeObjModule( const String& rName, const com::sun::star::script::ModuleInfo& mInfo )
+{
+    SbObjModule* p = new SbObjModule( rName, mInfo );
+	p->SetParent( this );
+	pModules->Insert( p, pModules->Count() );
+	SetModified( TRUE );
+    return p;
+}
+
+void StarBASIC::Insert( SbxVariable* pVar )
+{
+	if( pVar->IsA( TYPE(SbModule) ) )
+	{
+		pModules->Insert( pVar, pModules->Count() );
+		pVar->SetParent( this );
+		StartListening( pVar->GetBroadcaster(), TRUE );
+	}
+	else
+	{
+		BOOL bWasModified = IsModified();
+		SbxObject::Insert( pVar );
+		if( !bWasModified && pVar->IsSet( SBX_DONTSTORE ) )
+			SetModified( FALSE );
+	}
+}
+
+void StarBASIC::Remove( SbxVariable* pVar )
+{
+	if( pVar->IsA( TYPE(SbModule) ) )
+	{
+        // #87540 Can be last reference!
+        SbxVariableRef xVar = pVar;
+		pModules->Remove( pVar );
+		pVar->SetParent( 0 );
+		EndListening( pVar->GetBroadcaster() );
+	}
+	else
+		SbxObject::Remove( pVar );
+}
+
+BOOL StarBASIC::Compile( SbModule* pMod )
+{
+	return pMod ? pMod->Compile() : FALSE;
+}
+
+BOOL StarBASIC::Disassemble( SbModule* pMod, String& rText )
+{
+	rText.Erase();
+	if( pMod )
+		pMod->Disassemble( rText );
+	return BOOL( rText.Len() != 0 );
+}
+
+void StarBASIC::Clear()
+{
+	while( pModules->Count() )
+		pModules->Remove( pModules->Count() - 1 );
+}
+
+SbModule* StarBASIC::FindModule( const String& rName )
+{
+	for( USHORT i = 0; i < pModules->Count(); i++ )
+	{
+		SbModule* p = (SbModule*) pModules->Get( i );
+		if( p->GetName().EqualsIgnoreCaseAscii( rName ) )
+			return p;
+	}
+	return NULL;
+}
+
+// Init-Code aller Module ausfuehren (auch in inserteten Bibliotheken)
+void StarBASIC::InitAllModules( StarBASIC* pBasicNotToInit )
+{
+	// Eigene Module initialisieren
+	for ( USHORT nMod = 0; nMod < pModules->Count(); nMod++ )
+	{
+		SbModule* pModule = (SbModule*)pModules->Get( nMod );
+		if(	!pModule->IsCompiled() )
+			pModule->Compile();
+	}
+	// compile modules first then RunInit ( otherwise there is 
+	// can be order dependency, e.g. classmodule A has a member
+	// of of type classmodule B and classmodule B hasn't been compiled yet )
+	for ( USHORT nMod = 0; nMod < pModules->Count(); nMod++ )
+	{
+		SbModule* pModule = (SbModule*)pModules->Get( nMod );
+		pModule->RunInit();
+	}
+
+	// Alle Objekte ueberpruefen, ob es sich um ein Basic handelt
+	// Wenn ja, auch dort initialisieren
+	for ( USHORT nObj = 0; nObj < pObjs->Count(); nObj++ )
+	{
+		SbxVariable* pVar = pObjs->Get( nObj );
+		StarBASIC* pBasic = PTR_CAST(StarBASIC,pVar);
+		if( pBasic && pBasic != pBasicNotToInit )
+			pBasic->InitAllModules();
+	}
+}
+
+// #88329 Put modules back to not initialised state to
+// force reinitialisation at next start
+void StarBASIC::DeInitAllModules( void )
+{
+	// Eigene Module initialisieren
+	for ( USHORT nMod = 0; nMod < pModules->Count(); nMod++ )
+	{
+		SbModule* pModule = (SbModule*)pModules->Get( nMod );
+        if( pModule->pImage )
+		    pModule->pImage->bInit = false;
+	}
+	// Alle Objekte ueberpruefen, ob es sich um ein Basic handelt
+	// Wenn ja, auch dort initialisieren
+	for ( USHORT nObj = 0; nObj < pObjs->Count(); nObj++ )
+	{
+		SbxVariable* pVar = pObjs->Get( nObj );
+		StarBASIC* pBasic = PTR_CAST(StarBASIC,pVar);
+		if( pBasic )
+			pBasic->DeInitAllModules();
+	}
+}
+
+// #43011 Fuer das TestTool, um globale Variablen loeschen zu koennen
+void StarBASIC::ClearGlobalVars( void )
+{
+	SbxArrayRef xProps( GetProperties() );
+	USHORT nPropCount = xProps->Count();
+	for ( USHORT nProp = 0 ; nProp < nPropCount ; ++nProp )
+	{
+		SbxBase* pVar = xProps->Get( nProp );
+		pVar->Clear();
+	}
+	SetModified( TRUE );
+}
+
+
+// Diese Implementation sucht erst innerhalb der Runtime-Library, dann
+// nach einem Element innerhalb eines Moduls. Dieses Element kann eine
+// Public-Variable oder ein Entrypoint sein. Wenn nicht gefunden, wird,
+// falls nach einer Methode gesucht wird und ein Modul mit dem angege-
+// benen Namen gefunden wurde, der Entrypoint "Main" gesucht. Wenn das
+// auch nicht klappt, laeuft die traditionelle Suche ueber Objekte an.
+
+SbxVariable* StarBASIC::Find( const String& rName, SbxClassType t )
+{
+	static String aMainStr( RTL_CONSTASCII_USTRINGPARAM("Main") );
+
+	SbxVariable* pRes = NULL;
+	SbModule* pNamed = NULL;
+	// "Extended" search in Runtime Lib
+	// aber nur, wenn SbiRuntime nicht das Flag gesetzt hat
+	if( !bNoRtl )
+	{
+		if( t == SbxCLASS_DONTCARE || t == SbxCLASS_OBJECT )
+		{
+			if( rName.EqualsIgnoreCaseAscii( RTLNAME ) )
+				pRes = pRtl;
+		}
+		if( !pRes )
+			pRes = ((SbiStdObject*) (SbxObject*) pRtl)->Find( rName, t );
+		if( pRes )
+			pRes->SetFlag( SBX_EXTFOUND );
+	}
+	// Module durchsuchen
+	if( !pRes )
+	  for( USHORT i = 0; i < pModules->Count(); i++ )
+	{
+		SbModule* p = (SbModule*) pModules->Get( i );
+		if( p->IsVisible() )
+		{
+			// Modul merken fuer Main()-Aufruf
+			// oder stimmt etwa der Name ueberein?!?
+			if( p->GetName().EqualsIgnoreCaseAscii( rName ) )
+			{
+				if( t == SbxCLASS_OBJECT || t == SbxCLASS_DONTCARE )
+				{
+					pRes = p; break;
+				}
+				pNamed = p;
+			}
+			// Sonst testen, ob das Element vorhanden ist
+			// GBLSEARCH-Flag rausnehmen (wg. Rekursion)
+			USHORT nGblFlag = p->GetFlags() & SBX_GBLSEARCH;
+			p->ResetFlag( SBX_GBLSEARCH );
+			pRes = p->Find( rName, t );
+			p->SetFlag( nGblFlag );
+			if( pRes )
+				break;
+		}
+	}
+	if( !pRes && pNamed && ( t == SbxCLASS_METHOD || t == SbxCLASS_DONTCARE ) &&
+		!pNamed->GetName().EqualsIgnoreCaseAscii( aMainStr ) )
+			pRes = pNamed->Find( aMainStr, SbxCLASS_METHOD );
+	if( !pRes )
+		pRes = SbxObject::Find( rName, t );
+	return pRes;
+}
+
+BOOL StarBASIC::Call( const String& rName, SbxArray* pParam )
+{
+	BOOL bRes = SbxObject::Call( rName, pParam );
+	if( !bRes )
+	{
+		SbxError eErr = SbxBase::GetError();
+		SbxBase::ResetError();
+		if( eErr != SbxERR_OK )
+			RTError( (SbError)eErr, 0, 0, 0 );
+	}
+	return bRes;
+}
+
+// Find-Funktion ueber Name (z.B. Abfrage aus BASIC-IDE)
+SbxBase* StarBASIC::FindSBXInCurrentScope( const String& rName )
+{
+	if( !pINST )
+		return NULL;
+	if( !pINST->pRun )
+		return NULL;
+	return pINST->pRun->FindElementExtern( rName );
+}
+
+// Alte Schnittstelle vorerst erhalten
+SbxVariable* StarBASIC::FindVarInCurrentScopy
+( const String& rName, USHORT& rStatus )
+{
+	rStatus = 1;			// Annahme: Nichts gefunden
+	SbxVariable* pVar = NULL;
+	SbxBase* pSbx = FindSBXInCurrentScope( rName );
+	if( pSbx )
+	{
+		if( !pSbx->ISA(SbxMethod) && !pSbx->ISA(SbxObject) )
+			pVar = PTR_CAST(SbxVariable,pSbx);
+	}
+	if( pVar )
+		rStatus = 0;		// doch gefunden
+	return pVar;
+}
+
+void StarBASIC::Stop()
+{
+	SbiInstance* p = pINST;
+	while( p )
+	{
+		p->Stop();
+		p = p->pNext;
+	}
+}
+
+BOOL StarBASIC::IsRunning()
+{
+	return BOOL( pINST != NULL );
+}
+
+/**************************************************************************
+*
+*	Objekt-Factories etc.
+*
+**************************************************************************/
+
+// Aktivierung eines Objekts. Aktive Objekte muessen nicht mehr
+// von BASIC aus ueber den Namen angesprochen werden. Ist
+// NULL angegeben, wird alles aktiviert.
+
+void StarBASIC::ActivateObject( const String* pName, BOOL bActivate )
+{
+	if( pName )
+	{
+		SbxObject* p = (SbxObject*) SbxObject::Find( *pName, SbxCLASS_OBJECT );
+		if( p )
+			if( bActivate )
+				p->SetFlag( SBX_EXTSEARCH );
+			else
+				p->ResetFlag( SBX_EXTSEARCH );
+	}
+	else
+	{
+		for( USHORT i = 0; i < GetObjects()->Count(); i++ )
+		{
+			SbxObject* p = (SbxObject*) GetObjects()->Get( i );
+			if( bActivate )
+				p->SetFlag( SBX_EXTSEARCH );
+			else
+				p->ResetFlag( SBX_EXTSEARCH );
+		}
+	}
+}
+
+/**************************************************************************
+*
+*	Debugging und Fehlerbehandlung
+*
+**************************************************************************/
+
+SbMethod* StarBASIC::GetActiveMethod( USHORT nLevel )
+{
+	if( pINST )
+		return pINST->GetCaller( nLevel );
+	else
+		return NULL;
+}
+
+SbModule* StarBASIC::GetActiveModule()
+{
+	if( pINST && !IsCompilerError() )
+		return pINST->GetActiveModule();
+	else
+		return pCMOD;
+}
+
+USHORT StarBASIC::BreakPoint( USHORT l, USHORT c1, USHORT c2 )
+{
+	SetErrorData( 0, l, c1, c2 );
+	bBreak = TRUE;
+	if( GetSbData()->aBreakHdl.IsSet() )
+		return (USHORT) GetSbData()->aBreakHdl.Call( this );
+	else
+		return BreakHdl();
+}
+
+USHORT StarBASIC::StepPoint( USHORT l, USHORT c1, USHORT c2 )
+{
+	SetErrorData( 0, l, c1, c2 );
+	bBreak = FALSE;
+	if( GetSbData()->aBreakHdl.IsSet() )
+		return (USHORT) GetSbData()->aBreakHdl.Call( this );
+	else
+		return BreakHdl();
+}
+
+USHORT __EXPORT StarBASIC::BreakHdl()
+{
+	return (USHORT) ( aBreakHdl.IsSet()
+		? aBreakHdl.Call( this ) : SbDEBUG_CONTINUE );
+}
+
+// Abfragen fuer den Error-Handler und den Break-Handler:
+USHORT StarBASIC::GetLine()		{ return GetSbData()->nLine; }
+USHORT StarBASIC::GetCol1()		{ return GetSbData()->nCol1; }
+USHORT StarBASIC::GetCol2()		{ return GetSbData()->nCol2; }
+
+// Spezifisch fuer den Error-Handler:
+SbError StarBASIC::GetErrorCode()		{ return GetSbData()->nCode; }
+const String& StarBASIC::GetErrorText()	{ return GetSbData()->aErrMsg; }
+BOOL StarBASIC::IsCompilerError()		{ return GetSbData()->bCompiler; }
+void StarBASIC::SetGlobalLanguageMode( SbLanguageMode eLanguageMode )
+{
+	GetSbData()->eLanguageMode = eLanguageMode;
+}
+SbLanguageMode StarBASIC::GetGlobalLanguageMode()
+{
+	return GetSbData()->eLanguageMode;
+}
+// Lokale Einstellung
+SbLanguageMode StarBASIC::GetLanguageMode()
+{
+	// Globale Einstellung nehmen?
+	if( eLanguageMode == SB_LANG_GLOBAL )
+		return GetSbData()->eLanguageMode;
+	else
+		return eLanguageMode;
+}
+
+// AB: 29.3.96
+// Das Mapping zwischen alten und neuen Fehlercodes erfolgt, indem die Tabelle
+// SFX_VB_ErrorTab[] durchsucht wird. Dies ist zwar nicht besonders performant,
+// verbraucht aber viel weniger Speicher als entsprechende switch-Bloecke.
+// Die Umrechnung von Fehlercodes muss nicht schnell sein, daher auch keine
+// binaere Suche bei VB-Error -> SFX-Error.
+
+// Neue Fehler-Codes auf alte, Sbx-Kompatible zurueckmappen
+USHORT StarBASIC::GetVBErrorCode( SbError nError )
+{
+	USHORT nRet = 0;
+
+	// Suchschleife
+	const SFX_VB_ErrorItem* pErrItem;
+	USHORT nIndex = 0;
+	do
+	{
+		pErrItem = SFX_VB_ErrorTab + nIndex;
+		if( pErrItem->nErrorSFX == nError )
+		{
+			nRet = pErrItem->nErrorVB;
+			break;
+		}
+		nIndex++;
+	}
+	while( pErrItem->nErrorVB != 0xFFFF );		// bis End-Marke
+	return nRet;
+}
+
+SbError	StarBASIC::GetSfxFromVBError( USHORT nError )
+{
+	SbError nRet = 0L;
+
+	// Suchschleife
+	const SFX_VB_ErrorItem* pErrItem;
+	USHORT nIndex = 0;
+	do
+	{
+		pErrItem = SFX_VB_ErrorTab + nIndex;
+		if( pErrItem->nErrorVB == nError )
+		{
+			nRet = pErrItem->nErrorSFX;
+			break;
+		}
+		else if( pErrItem->nErrorVB > nError )
+			break;				// kann nicht mehr gefunden werden
+
+		nIndex++;
+	}
+	while( pErrItem->nErrorVB != 0xFFFF );		// bis End-Marke
+	return nRet;
+}
+
+// Error- / Break-Daten setzen
+void StarBASIC::SetErrorData
+( SbError nCode, USHORT nLine, USHORT nCol1, USHORT nCol2 )
+{
+	SbiGlobals& aGlobals = *GetSbData();
+	aGlobals.nCode = nCode;
+	aGlobals.nLine = nLine;
+	aGlobals.nCol1 = nCol1;
+	aGlobals.nCol2 = nCol2;
+}
+
+//----------------------------------------------------------------
+// Hilfsklasse zum Zugriff auf String SubResourcen einer Resource.
+// Quelle: sfx2\source\doc\docfile.cxx (TLX)
+struct BasicStringList_Impl : private Resource
+{
+	ResId aResId;
+
+	BasicStringList_Impl( ResId& rErrIdP,  USHORT nId)
+		: Resource( rErrIdP ),aResId(nId, *rErrIdP.GetResMgr() ){}
+	~BasicStringList_Impl() { FreeResource(); }
+
+	String GetString(){ return String( aResId ); }
+	BOOL IsErrorTextAvailable( void )
+		{ return IsAvailableRes(aResId.SetRT(RSC_STRING)); }
+};
+//----------------------------------------------------------------
+
+// #60175 Flag, das bei Basic-Fehlern das Anziehen der SFX-Resourcen verhindert
+static BOOL bStaticSuppressSfxResource = FALSE;
+
+void StarBASIC::StaticSuppressSfxResource( BOOL bSuppress )
+{
+	bStaticSuppressSfxResource = bSuppress;
+}
+
+// Hack for #83750, use bStaticSuppressSfxResource as setup flag
+BOOL runsInSetup( void )
+{
+	return bStaticSuppressSfxResource;
+}
+
+
+void StarBASIC::MakeErrorText( SbError nId, const String& aMsg )
+{
+	vos::OGuard aSolarGuard( Application::GetSolarMutex() );
+
+	if( bStaticSuppressSfxResource )
+	{
+		GetSbData()->aErrMsg = String( RTL_CONSTASCII_USTRINGPARAM("No resource: Error message not available") );
+		return;
+	}
+
+	USHORT nOldID = GetVBErrorCode( nId );
+
+	// Hilfsklasse instanzieren
+	BasResId aId( RID_BASIC_START );
+	BasicStringList_Impl aMyStringList( aId, USHORT(nId & ERRCODE_RES_MASK) );
+
+	if( aMyStringList.IsErrorTextAvailable() )
+	{
+		// Merge Message mit Zusatztext
+		String aMsg1 = aMyStringList.GetString();
+		// Argument-Platzhalter durch %s ersetzen
+		String aSrgStr( RTL_CONSTASCII_USTRINGPARAM("$(ARG1)") );
+		USHORT nResult = aMsg1.Search( aSrgStr );
+
+		if( nResult != STRING_NOTFOUND )
+		{
+			aMsg1.Erase( nResult, aSrgStr.Len() );
+			aMsg1.Insert( aMsg, nResult );
+		}
+		GetSbData()->aErrMsg = aMsg1;
+	}
+	else if( nOldID != 0 )
+	{
+		String aStdMsg( RTL_CONSTASCII_USTRINGPARAM("Fehler ") );
+		aStdMsg += String::CreateFromInt32( nOldID);
+		aStdMsg += String( RTL_CONSTASCII_USTRINGPARAM(": Kein Fehlertext verfuegbar!") );
+		GetSbData()->aErrMsg = aStdMsg;
+	}
+	else
+		GetSbData()->aErrMsg = String::EmptyString();
+}
+
+BOOL StarBASIC::CError
+	( SbError code, const String& rMsg, USHORT l, USHORT c1, USHORT c2 )
+{
+	vos::OGuard aSolarGuard( Application::GetSolarMutex() );
+
+	// Compiler-Fehler waehrend der Laufzeit -> Programm anhalten
+	if( IsRunning() )
+	{
+		// #109018 Check if running Basic is affected
+		StarBASIC* pStartedBasic = pINST->GetBasic();
+		if( pStartedBasic != this )
+			return FALSE;
+
+		Stop();
+	}
+
+	// Flag setzen, damit GlobalRunInit den Fehler mitbekommt
+	GetSbData()->bGlobalInitErr = TRUE;
+
+	// Fehlertext basteln
+	MakeErrorText( code, rMsg );
+
+	// Umsetzung des Codes fuer String-Transport in SFX-Error
+	if( rMsg.Len() )
+		code = (ULONG)*new StringErrorInfo( code, String(rMsg) );
+
+	SetErrorData( code, l, c1, c2 );
+	GetSbData()->bCompiler = TRUE;
+	BOOL bRet;
+	if( GetSbData()->aErrHdl.IsSet() )
+		bRet = (BOOL) GetSbData()->aErrHdl.Call( this );
+	else
+		bRet = ErrorHdl();
+	GetSbData()->bCompiler = FALSE;		// nur TRUE fuer Error-Handler
+	return bRet;
+}
+
+BOOL StarBASIC::RTError
+	( SbError code, USHORT l, USHORT c1, USHORT c2 )
+{
+	return RTError( code, String(), l, c1, c2 );
+}
+
+BOOL StarBASIC::RTError( SbError code, const String& rMsg, USHORT l, USHORT c1, USHORT c2 )
+{
+	vos::OGuard aSolarGuard( Application::GetSolarMutex() );
+
+	SbError c = code;
+	if( (c & ERRCODE_CLASS_MASK) == ERRCODE_CLASS_COMPILER )
+		c = 0;
+	MakeErrorText( c, rMsg );
+
+	// Umsetzung des Codes fuer String-Transport in SFX-Error
+	if( rMsg.Len() )
+		code = (ULONG)*new StringErrorInfo( code, String(rMsg) );
+
+	SetErrorData( code, l, c1, c2 );
+	if( GetSbData()->aErrHdl.IsSet() )
+		return (BOOL) GetSbData()->aErrHdl.Call( this );
+	else
+		return ErrorHdl();
+}
+
+void StarBASIC::Error( SbError n )
+{
+	Error( n, String() );
+}
+
+void StarBASIC::Error( SbError n, const String& rMsg )
+{
+	if( pINST )
+		pINST->Error( n, rMsg );
+}
+
+void StarBASIC::FatalError( SbError n )
+{
+	if( pINST )
+		pINST->FatalError( n );
+}
+
+SbError StarBASIC::GetErrBasic()
+{
+	if( pINST )
+		return pINST->GetErr();
+	else
+		return 0;
+}
+
+// #66536 Zusatz-Message fuer RTL-Funktion Error zugreifbar machen
+String StarBASIC::GetErrorMsg()
+{
+	if( pINST )
+		return pINST->GetErrorMsg();
+	else
+		return String();
+}
+
+USHORT StarBASIC::GetErl()
+{
+	if( pINST )
+		return pINST->GetErl();
+	else
+		return 0;
+}
+
+BOOL __EXPORT StarBASIC::ErrorHdl()
+{
+	return (BOOL) ( aErrorHdl.IsSet()
+		? aErrorHdl.Call( this ) : FALSE );
+}
+
+Link StarBASIC::GetGlobalErrorHdl()
+{
+	return GetSbData()->aErrHdl;
+}
+
+void StarBASIC::SetGlobalErrorHdl( const Link& rLink )
+{
+	GetSbData()->aErrHdl = rLink;
+}
+
+
+Link StarBASIC::GetGlobalBreakHdl()
+{
+	return GetSbData()->aBreakHdl;
+}
+
+void StarBASIC::SetGlobalBreakHdl( const Link& rLink )
+{
+	GetSbData()->aBreakHdl = rLink;
+}
+
+SbxArrayRef StarBASIC::getUnoListeners( void )
+{
+    if( !xUnoListeners.Is() )
+        xUnoListeners = new SbxArray();
+    return xUnoListeners;
+}
+
+
+/**************************************************************************
+*
+*	Laden und Speichern
+*
+**************************************************************************/
+
+BOOL StarBASIC::LoadData( SvStream& r, USHORT nVer )
+{
+	if( !SbxObject::LoadData( r, nVer ) )
+		return FALSE;
+
+    // #95459 Delete dialogs, otherwise endless recursion
+    // in SbxVarable::GetType() if dialogs are accessed
+    USHORT nObjCount = pObjs->Count();
+    SbxVariable** ppDeleteTab = new SbxVariable*[ nObjCount ];
+	USHORT nObj;
+
+	for( nObj = 0 ; nObj < nObjCount ; nObj++ )
+	{
+		SbxVariable* pVar = pObjs->Get( nObj );
+		StarBASIC* pBasic = PTR_CAST( StarBASIC, pVar );
+        ppDeleteTab[nObj] = pBasic ? NULL : pVar;
+	}
+	for( nObj = 0 ; nObj < nObjCount ; nObj++ )
+	{
+        SbxVariable* pVar = ppDeleteTab[nObj];
+        if( pVar )
+            pObjs->Remove( pVar );
+    }
+    delete[] ppDeleteTab;
+
+	UINT16 nMod;
+	pModules->Clear();
+	r >> nMod;
+	for( USHORT i = 0; i < nMod; i++ )
+	{
+		SbModule* pMod = (SbModule*) SbxBase::Load( r );
+		if( !pMod )
+			return FALSE;
+		else if( pMod->ISA(SbJScriptModule) )
+		{
+			// Ref zuweisen, damit pMod deleted wird
+			SbModuleRef xRef = pMod;
+		}
+		else
+		{
+			pMod->SetParent( this );
+			pModules->Put( pMod, i );
+		}
+	}
+	// HACK fuer SFX-Mist!
+	SbxVariable* p = Find( String( RTL_CONSTASCII_USTRINGPARAM("FALSE") ), SbxCLASS_PROPERTY );
+	if( p )
+		Remove( p );
+	p = Find( String( RTL_CONSTASCII_USTRINGPARAM("TRUE") ), SbxCLASS_PROPERTY );
+	if( p )
+		Remove( p );
+	// Ende des Hacks!
+	// Suche ueber StarBASIC ist immer global
+	DBG_ASSERT( IsSet( SBX_GBLSEARCH ), "Basic ohne GBLSEARCH geladen" );
+	SetFlag( SBX_GBLSEARCH );
+	return TRUE;
+}
+
+BOOL StarBASIC::StoreData( SvStream& r ) const
+{
+	if( !SbxObject::StoreData( r ) )
+		return FALSE;
+	r << (UINT16) pModules->Count();
+	for( USHORT i = 0; i < pModules->Count(); i++ )
+	{
+		SbModule* p = (SbModule*) pModules->Get( i );
+		if( !p->Store( r ) )
+			return FALSE;
+	}
+	return TRUE;
+}
+
+BOOL StarBASIC::LoadOldModules( SvStream& )
+{
+	return FALSE;
+}
+
+
+//========================================================================
+// #118116 Implementation Collection object
+
+TYPEINIT1(BasicCollection,SbxObject)
+
+static const char pCountStr[]	= "Count";
+static const char pAddStr[]		= "Add";
+static const char pItemStr[]	= "Item";
+static const char pRemoveStr[]	= "Remove";
+static USHORT nCountHash = 0, nAddHash, nItemHash, nRemoveHash;
+
+SbxInfoRef BasicCollection::xAddInfo = NULL;
+SbxInfoRef BasicCollection::xItemInfo = NULL;
+
+BasicCollection::BasicCollection( const XubString& rClass )
+			 : SbxObject( rClass )
+{
+	if( !nCountHash )
+	{
+		nCountHash  = MakeHashCode( String::CreateFromAscii( pCountStr ) );
+		nAddHash    = MakeHashCode( String::CreateFromAscii( pAddStr ) );
+		nItemHash   = MakeHashCode( String::CreateFromAscii( pItemStr ) );
+		nRemoveHash = MakeHashCode( String::CreateFromAscii( pRemoveStr ) );
+	}
+	Initialize();
+	
+}
+
+BasicCollection::~BasicCollection()
+{}
+
+void BasicCollection::Clear()
+{
+	SbxObject::Clear();
+	Initialize();
+}
+
+void BasicCollection::Initialize()
+{
+	xItemArray = new SbxArray();
+	SetType( SbxOBJECT );
+	SetFlag( SBX_FIXED );
+	ResetFlag( SBX_WRITE );
+	SbxVariable* p;
+	p = Make( String::CreateFromAscii( pCountStr ), SbxCLASS_PROPERTY, SbxINTEGER );
+	p->ResetFlag( SBX_WRITE );
+	p->SetFlag( SBX_DONTSTORE );
+	p = Make( String::CreateFromAscii( pAddStr ), SbxCLASS_METHOD, SbxEMPTY );
+	p->SetFlag( SBX_DONTSTORE );
+	p = Make( String::CreateFromAscii( pItemStr ), SbxCLASS_METHOD, SbxVARIANT );
+	p->SetFlag( SBX_DONTSTORE );
+	p = Make( String::CreateFromAscii( pRemoveStr ), SbxCLASS_METHOD, SbxEMPTY );
+	p->SetFlag( SBX_DONTSTORE );
+	if ( !xAddInfo.Is() ) 
+	{
+		xAddInfo = new SbxInfo;
+		xAddInfo->AddParam(  String( RTL_CONSTASCII_USTRINGPARAM("Item") ), SbxVARIANT, SBX_READ );	
+		xAddInfo->AddParam(  String( RTL_CONSTASCII_USTRINGPARAM("Key") ), SbxVARIANT, SBX_READ | SBX_OPTIONAL );	
+		xAddInfo->AddParam(  String( RTL_CONSTASCII_USTRINGPARAM("Before") ), SbxVARIANT, SBX_READ | SBX_OPTIONAL );	
+		xAddInfo->AddParam(  String( RTL_CONSTASCII_USTRINGPARAM("After") ), SbxVARIANT, SBX_READ | SBX_OPTIONAL );	
+	}
+	if ( !xItemInfo.Is() ) 
+	{
+		xItemInfo = new SbxInfo;
+		xItemInfo->AddParam(  String( RTL_CONSTASCII_USTRINGPARAM("Index") ), SbxVARIANT, SBX_READ | SBX_OPTIONAL);	
+	}
+}
+
+SbxVariable* BasicCollection::Find( const XubString& rName, SbxClassType t )
+{
+	SbxVariable* pFind = SbxObject::Find( rName, t );
+	return pFind;
+}
+
+void BasicCollection::SFX_NOTIFY( SfxBroadcaster& rCst, const TypeId& rId1,
+								const SfxHint& rHint, const TypeId& rId2 )
+{
+	const SbxHint* p = PTR_CAST(SbxHint,&rHint);
+	if( p )
+	{
+		ULONG nId = p->GetId();
+		BOOL bRead  = BOOL( nId == SBX_HINT_DATAWANTED );
+		BOOL bWrite = BOOL( nId == SBX_HINT_DATACHANGED );
+		BOOL bRequestInfo = BOOL( nId == SBX_HINT_INFOWANTED );
+		SbxVariable* pVar = p->GetVar();
+		SbxArray* pArg = pVar->GetParameters();
+		XubString aVarName( pVar->GetName() );
+		if( bRead || bWrite )
+		{
+			if( pVar->GetHashCode() == nCountHash
+				  && aVarName.EqualsIgnoreCaseAscii( pCountStr ) )
+				pVar->PutLong( xItemArray->Count32() );
+			else if( pVar->GetHashCode() == nAddHash
+				  && aVarName.EqualsIgnoreCaseAscii( pAddStr ) )
+				CollAdd( pArg );
+			else if( pVar->GetHashCode() == nItemHash
+				  && aVarName.EqualsIgnoreCaseAscii( pItemStr ) )
+				CollItem( pArg );
+			else if( pVar->GetHashCode() == nRemoveHash
+				  && aVarName.EqualsIgnoreCaseAscii( pRemoveStr ) )
+				CollRemove( pArg );
+			else
+				SbxObject::SFX_NOTIFY( rCst, rId1, rHint, rId2 );
+			return;
+		}
+		else if ( bRequestInfo )
+		{
+			if( pVar->GetHashCode() == nAddHash
+				  && aVarName.EqualsIgnoreCaseAscii( pAddStr ) )
+				pVar->SetInfo( xAddInfo );
+			else if( pVar->GetHashCode() == nItemHash
+				  && aVarName.EqualsIgnoreCaseAscii( pItemStr ) )
+				pVar->SetInfo( xItemInfo );
+		}
+	}
+	SbxObject::SFX_NOTIFY( rCst, rId1, rHint, rId2 );
+}
+
+INT32 BasicCollection::implGetIndex( SbxVariable* pIndexVar )
+{
+	INT32 nIndex = -1;
+	if( pIndexVar->GetType() == SbxSTRING )
+		nIndex = implGetIndexForName( pIndexVar->GetString() );
+	else
+		nIndex = pIndexVar->GetLong() - 1;
+	return nIndex;
+}
+
+INT32 BasicCollection::implGetIndexForName( const String& rName )
+{
+	INT32 nIndex = -1;
+	INT32 nCount = xItemArray->Count32();
+	INT32 nNameHash = MakeHashCode( rName );
+	for( INT32 i = 0 ; i < nCount ; i++ )
+	{
+		SbxVariable* pVar = xItemArray->Get32( i );
+		if( pVar->GetHashCode() == nNameHash &&
+			pVar->GetName().EqualsIgnoreCaseAscii( rName ) )
+		{
+			nIndex = i;
+			break;
+		}
+	}
+	return nIndex;
+}
+
+void BasicCollection::CollAdd( SbxArray* pPar_ )
+{
+	USHORT nCount = pPar_->Count();
+	if( nCount < 2 || nCount > 5 )
+	{
+		SetError( SbxERR_WRONG_ARGS );
+		return;
+	}
+
+	SbxVariable* pItem = pPar_->Get(1);
+	if( pItem )
+	{
+		int nNextIndex;
+		if( nCount < 4 )
+		{
+			nNextIndex = xItemArray->Count();
+		}
+		else
+		{
+			SbxVariable* pBefore = pPar_->Get(3);
+			if( nCount == 5 )
+			{
+				if( !( pBefore->IsErr() || ( pBefore->GetType() == SbxEMPTY ) ) )
+				{
+					SetError( SbERR_BAD_ARGUMENT );
+					return;
+				}
+				SbxVariable* pAfter = pPar_->Get(4);
+				INT32 nAfterIndex = implGetIndex( pAfter );
+				if( nAfterIndex == -1 )
+				{
+					SetError( SbERR_BAD_ARGUMENT );
+					return;
+				}
+				nNextIndex = nAfterIndex + 1;
+			}
+			else // if( nCount == 4 )
+			{
+				INT32 nBeforeIndex = implGetIndex( pBefore );
+				if( nBeforeIndex == -1 )
+				{
+					SetError( SbERR_BAD_ARGUMENT );
+					return;
+				}
+				nNextIndex = nBeforeIndex;
+			}
+		}
+
+		SbxVariableRef pNewItem = new SbxVariable( *pItem );
+		if( nCount >= 3 )
+		{
+			SbxVariable* pKey = pPar_->Get(2);
+			if( !( pKey->IsErr() || ( pKey->GetType() == SbxEMPTY ) ) )
+			{
+				if( pKey->GetType() != SbxSTRING )
+				{
+					SetError( SbERR_BAD_ARGUMENT );
+					return;
+				}
+				String aKey = pKey->GetString();
+				if( implGetIndexForName( aKey ) != -1 )
+				{
+					SetError( SbERR_BAD_ARGUMENT );
+					return;
+				}
+				pNewItem->SetName( aKey );
+			}
+		}
+		pNewItem->SetFlag( SBX_READWRITE );
+		xItemArray->Insert32( pNewItem, nNextIndex );
+	}
+	else
+	{
+		SetError( SbERR_BAD_ARGUMENT );
+		return;
+	}
+}
+
+void BasicCollection::CollItem( SbxArray* pPar_ )
+{
+	if( pPar_->Count() != 2 )
+	{
+		SetError( SbxERR_WRONG_ARGS );
+		return;
+	}
+	SbxVariable* pRes = NULL;
+	SbxVariable* p = pPar_->Get( 1 );
+	INT32 nIndex = implGetIndex( p );
+	if( nIndex >= 0 && nIndex < (INT32)xItemArray->Count32() )
+		pRes = xItemArray->Get32( nIndex );
+	if( !pRes )
+		SetError( SbxERR_BAD_INDEX );
+	else
+		*(pPar_->Get(0)) = *pRes;
+}
+
+void BasicCollection::CollRemove( SbxArray* pPar_ )
+{
+	if( pPar_ == NULL || pPar_->Count() != 2 )
+	{
+		SetError( SbxERR_WRONG_ARGS );
+		return;
+	}
+
+	SbxVariable* p = pPar_->Get( 1 );
+	INT32 nIndex = implGetIndex( p );
+	if( nIndex >= 0 && nIndex < (INT32)xItemArray->Count32() )
+		xItemArray->Remove32( nIndex );
+	else
+		SetError( SbxERR_BAD_INDEX );
+}
+
--- basic/source/runtime/methods1.cxx.bak	1970-01-01 08:00:00.000000000 +0800
+++ basic/source/runtime/methods1.cxx	2007-10-15 11:51:06.000000000 +0800
@@ -0,0 +1,2626 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile: methods1.cxx,v $
+ *
+ *  $Revision: 1.34 $
+ *
+ *  last change: $Author: hr $ $Date: 2007/08/03 09:55:57 $
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+
+// MARKER(update_precomp.py): autogen include statement, do not remove
+#include "precompiled_basic.hxx"
+
+#if defined(WIN)
+#include <string.h>
+#else
+#include <stdlib.h> // getenv
+#endif
+
+#ifndef _SV_SVAPP_HXX //autogen
+#include <vcl/svapp.hxx>
+#endif
+#ifndef _SV_MAPMOD_HXX
+#include <vcl/mapmod.hxx>
+#endif
+#ifndef _SV_WRKWIN_HXX
+#include <vcl/wrkwin.hxx>
+#endif
+#ifndef _SV_TIMER_HXX
+#include <vcl/timer.hxx>
+#endif
+#ifndef _SBXVAR_HXX
+#include <basic/sbxvar.hxx>
+#endif
+#ifndef _SBX_HXX
+#include <basic/sbx.hxx>
+#endif
+#ifndef _SBSTAR_HXX
+#include <basic/sbstar.hxx>
+#endif
+#ifndef _ZFORLIST_HXX //autogen
+#include <svtools/zforlist.hxx>
+#endif
+#ifndef _FSYS_HXX
+#include <tools/fsys.hxx>
+#endif
+#include <tools/urlobj.hxx>
+#include <osl/file.hxx>
+
+#if defined(WIN)
+#ifndef _SVWIN_H
+#include <tools/svwin.h>
+#endif
+#endif
+
+#ifndef CLK_TCK
+#define CLK_TCK CLOCKS_PER_SEC
+#endif
+
+#include <vcl/jobset.hxx>
+#include <basic/sbobjmod.hxx>
+
+#include "sbintern.hxx"
+#include "runtime.hxx"
+#include "stdobj.hxx"
+#include "rtlproto.hxx"
+#include "dllmgr.hxx"
+#include <iosys.hxx>
+#ifndef SB_UNO_OBJ
+#include "sbunoobj.hxx"
+#endif
+#include "propacc.hxx"
+
+
+#ifndef _COMPHELPER_PROCESSFACTORY_HXX_
+#include <comphelper/processfactory.hxx>
+#endif
+
+#include <com/sun/star/uno/Sequence.hxx>
+#include <com/sun/star/lang/XMultiServiceFactory.hpp>
+#include <com/sun/star/i18n/XCalendar.hpp>
+
+using namespace comphelper;
+using namespace com::sun::star::uno;
+using namespace com::sun::star::i18n;
+
+
+static Reference< XCalendar > getLocaleCalendar( void )
+{
+	static Reference< XCalendar > xCalendar;
+	if( !xCalendar.is() )
+	{
+		Reference< XMultiServiceFactory > xSMgr = getProcessServiceFactory();
+		if( xSMgr.is() )
+		{
+			xCalendar = Reference< XCalendar >( xSMgr->createInstance
+				( OUString::createFromAscii( "com.sun.star.i18n.LocaleCalendar" ) ), UNO_QUERY );
+		}
+	}
+
+	static com::sun::star::lang::Locale aLastLocale;
+	static bool bNeedsInit = true;
+
+	com::sun::star::lang::Locale aLocale = Application::GetSettings().GetLocale();
+	bool bNeedsReload = false;
+	if( bNeedsInit )
+	{
+		bNeedsInit = false;
+		bNeedsReload = true;
+	}
+	else if( aLocale.Language != aLastLocale.Language ||
+			 aLocale.Country  != aLastLocale.Country )
+	{
+		bNeedsReload = true;
+	}
+	if( bNeedsReload )
+	{
+		aLastLocale = aLocale;
+		xCalendar->loadDefaultCalendar( aLocale );
+	}
+	return xCalendar;
+}
+
+
+RTLFUNC(CBool) // JSM
+{
+    (void)pBasic;
+    (void)bWrite;
+    
+	BOOL bVal = FALSE;
+	if ( rPar.Count() == 2 )
+	{
+		SbxVariable *pSbxVariable = rPar.Get(1);
+		bVal = pSbxVariable->GetBool();
+	}
+	else
+		StarBASIC::Error( SbERR_BAD_ARGUMENT );
+
+	rPar.Get(0)->PutBool(bVal);
+}
+
+RTLFUNC(CByte) // JSM
+{
+    (void)pBasic;
+    (void)bWrite;
+    
+	BYTE nByte = 0;
+	if ( rPar.Count() == 2 )
+	{
+		SbxVariable *pSbxVariable = rPar.Get(1);
+		nByte = pSbxVariable->GetByte();
+	}
+	else
+		StarBASIC::Error( SbERR_BAD_ARGUMENT );
+
+	rPar.Get(0)->PutByte(nByte);
+}
+
+RTLFUNC(CCur)  // JSM
+{
+    (void)pBasic;
+    (void)bWrite;
+    
+	SbxINT64 nCur;
+	if ( rPar.Count() == 2 )
+	{
+		SbxVariable *pSbxVariable = rPar.Get(1);
+		nCur = pSbxVariable->GetCurrency();
+	}
+	else
+		StarBASIC::Error( SbERR_BAD_ARGUMENT );
+
+	rPar.Get(0)->PutCurrency( nCur );
+}
+
+RTLFUNC(CDec)  // JSM
+{
+    (void)pBasic;
+    (void)bWrite;
+    
+#ifdef WNT
+	SbxDecimal* pDec = NULL;
+	if ( rPar.Count() == 2 )
+	{
+		SbxVariable *pSbxVariable = rPar.Get(1);
+		pDec = pSbxVariable->GetDecimal();
+	}
+	else
+		StarBASIC::Error( SbERR_BAD_ARGUMENT );
+
+	rPar.Get(0)->PutDecimal( pDec );
+#else
+	rPar.Get(0)->PutEmpty();
+	StarBASIC::Error(SbERR_NOT_IMPLEMENTED);
+#endif
+}
+
+RTLFUNC(CDate) // JSM
+{
+    (void)pBasic;
+    (void)bWrite;
+    
+	double nVal = 0.0;
+	if ( rPar.Count() == 2 )
+	{
+		SbxVariable *pSbxVariable = rPar.Get(1);
+		nVal = pSbxVariable->GetDate();
+	}
+	else
+		StarBASIC::Error( SbERR_BAD_ARGUMENT );
+
+	rPar.Get(0)->PutDate(nVal);
+}
+
+RTLFUNC(CDbl)  // JSM
+{
+    (void)pBasic;
+    (void)bWrite;
+    
+	double nVal = 0.0;
+	if ( rPar.Count() == 2 )
+	{
+		SbxVariable *pSbxVariable = rPar.Get(1);
+		if( pSbxVariable->GetType() == SbxSTRING )
+		{
+			// AB #41690 , String holen
+			String aScanStr = pSbxVariable->GetString();
+			SbError Error = SbxValue::ScanNumIntnl( aScanStr, nVal );
+			if( Error != SbxERR_OK )
+				StarBASIC::Error( Error );
+		}
+		else
+		{
+			nVal = pSbxVariable->GetDouble();
+		}
+	}
+	else
+		StarBASIC::Error( SbERR_BAD_ARGUMENT );
+
+	rPar.Get(0)->PutDouble(nVal);
+}
+
+RTLFUNC(CInt)  // JSM
+{
+    (void)pBasic;
+    (void)bWrite;
+    
+	INT16 nVal = 0;
+	if ( rPar.Count() == 2 )
+	{
+		SbxVariable *pSbxVariable = rPar.Get(1);
+		nVal = pSbxVariable->GetInteger();
+	}
+	else
+		StarBASIC::Error( SbERR_BAD_ARGUMENT );
+
+	rPar.Get(0)->PutInteger(nVal);
+}
+
+RTLFUNC(CLng)  // JSM
+{
+    (void)pBasic;
+    (void)bWrite;
+    
+	INT32 nVal = 0;
+	if ( rPar.Count() == 2 )
+	{
+		SbxVariable *pSbxVariable = rPar.Get(1);
+		nVal = pSbxVariable->GetLong();
+	}
+	else
+		StarBASIC::Error( SbERR_BAD_ARGUMENT );
+
+	rPar.Get(0)->PutLong(nVal);
+}
+
+RTLFUNC(CSng)  // JSM
+{
+    (void)pBasic;
+    (void)bWrite;
+    
+	float nVal = (float)0.0;
+	if ( rPar.Count() == 2 )
+	{
+		SbxVariable *pSbxVariable = rPar.Get(1);
+		if( pSbxVariable->GetType() == SbxSTRING )
+		{
+			// AB #41690 , String holen
+			double dVal = 0.0;
+			String aScanStr = pSbxVariable->GetString();
+			SbError Error = SbxValue::ScanNumIntnl( aScanStr, dVal, /*bSingle=*/TRUE );
+			if( SbxBase::GetError() == SbxERR_OK && Error != SbxERR_OK )
+				StarBASIC::Error( Error );
+			nVal = (float)dVal;
+		}
+		else
+		{
+			nVal = pSbxVariable->GetSingle();
+		}
+	}
+	else
+		StarBASIC::Error( SbERR_BAD_ARGUMENT );
+
+	rPar.Get(0)->PutSingle(nVal);
+}
+
+RTLFUNC(CStr)  // JSM
+{
+    (void)pBasic;
+    (void)bWrite;
+    
+	String aString;
+	if ( rPar.Count() == 2 )
+	{
+		SbxVariable *pSbxVariable = rPar.Get(1);
+		aString = pSbxVariable->GetString();
+	}
+	else
+		StarBASIC::Error( SbERR_BAD_ARGUMENT );
+
+	rPar.Get(0)->PutString(aString);
+}
+
+RTLFUNC(CVar)  // JSM
+{
+    (void)pBasic;
+    (void)bWrite;
+    
+	SbxValues aVals( SbxVARIANT );
+	if ( rPar.Count() == 2 )
+	{
+		SbxVariable *pSbxVariable = rPar.Get(1);
+		pSbxVariable->Get( aVals );
+	}
+	else
+		StarBASIC::Error( SbERR_BAD_ARGUMENT );
+
+	rPar.Get(0)->Put( aVals );
+}
+
+RTLFUNC(CVErr)
+{
+    (void)pBasic;
+    (void)bWrite;
+    
+	INT16 nErrCode = 0;
+	if ( rPar.Count() == 2 )
+	{
+		SbxVariable *pSbxVariable = rPar.Get(1);
+		nErrCode = pSbxVariable->GetInteger();
+	}
+	else
+		StarBASIC::Error( SbERR_BAD_ARGUMENT );
+
+	rPar.Get(0)->PutErr( nErrCode );
+}
+
+RTLFUNC(Iif) // JSM
+{
+    (void)pBasic;
+    (void)bWrite;
+    
+	if ( rPar.Count() == 4 )
+	{
+		if (rPar.Get(1)->GetBool())
+			*rPar.Get(0) = *rPar.Get(2);
+		else
+			*rPar.Get(0) = *rPar.Get(3);
+	}
+	else
+		StarBASIC::Error( SbERR_BAD_ARGUMENT );
+}
+
+RTLFUNC(GetSystemType)
+{
+    (void)pBasic;
+    (void)bWrite;
+    
+	if ( rPar.Count() != 1 )
+		StarBASIC::Error( SbERR_BAD_ARGUMENT );
+	else
+		// Removed for SRC595
+		rPar.Get(0)->PutInteger( -1 );
+}
+
+RTLFUNC(GetGUIType)
+{
+    (void)pBasic;
+    (void)bWrite;
+    
+	if ( rPar.Count() != 1 )
+		StarBASIC::Error( SbERR_BAD_ARGUMENT );
+	else
+	{
+		// 17.7.2000 Make simple solution for testtool / fat office
+#if defined (WNT)
+		rPar.Get(0)->PutInteger( 1 );
+#elif defined UNX
+		rPar.Get(0)->PutInteger( 4 );
+#elif
+		rPar.Get(0)->PutInteger( -1 );
+#endif
+	}
+}
+
+RTLFUNC(Red)
+{
+    (void)pBasic;
+    (void)bWrite;
+    
+	if ( rPar.Count() != 2 )
+		StarBASIC::Error( SbERR_BAD_ARGUMENT );
+	else
+	{
+		ULONG nRGB = (ULONG)rPar.Get(1)->GetLong();
+		nRGB &= 0x00FF0000;
+		nRGB >>= 16;
+		rPar.Get(0)->PutInteger( (INT16)nRGB );
+	}
+}
+
+RTLFUNC(Green)
+{
+    (void)pBasic;
+    (void)bWrite;
+    
+	if ( rPar.Count() != 2 )
+		StarBASIC::Error( SbERR_BAD_ARGUMENT );
+	else
+	{
+		ULONG nRGB = (ULONG)rPar.Get(1)->GetLong();
+		nRGB &= 0x0000FF00;
+		nRGB >>= 8;
+		rPar.Get(0)->PutInteger( (INT16)nRGB );
+	}
+}
+
+RTLFUNC(Blue)
+{
+    (void)pBasic;
+    (void)bWrite;
+    
+	if ( rPar.Count() != 2 )
+		StarBASIC::Error( SbERR_BAD_ARGUMENT );
+	else
+	{
+		ULONG nRGB = (ULONG)rPar.Get(1)->GetLong();
+		nRGB &= 0x000000FF;
+		rPar.Get(0)->PutInteger( (INT16)nRGB );
+	}
+}
+
+
+RTLFUNC(Switch)
+{
+    (void)pBasic;
+    (void)bWrite;
+    
+	USHORT nCount = rPar.Count();
+	if( !(nCount & 0x0001 ))
+		// Anzahl der Argumente muss ungerade sein
+		StarBASIC::Error( SbERR_BAD_ARGUMENT );
+	USHORT nCurExpr = 1;
+	while( nCurExpr < (nCount-1) )
+	{
+		if( rPar.Get( nCurExpr )->GetBool())
+		{
+			(*rPar.Get(0)) = *(rPar.Get(nCurExpr+1));
+			return;
+		}
+		nCurExpr += 2;
+	}
+	rPar.Get(0)->PutNull();
+}
+
+//i#64882# Common wait impl for existing Wait and new WaitUntil
+// rtl functions
+void Wait_Impl( bool bDurationBased, SbxArray& rPar )
+{
+	if( rPar.Count() != 2 )
+	{
+		StarBASIC::Error( SbERR_BAD_ARGUMENT );
+		return;
+	}
+	long nWait = 0;
+	if ( bDurationBased )
+	{
+		double dWait = rPar.Get(1)->GetDouble();
+		double dNow = Now_Impl();
+	 	double dSecs = (double)( ( dWait - dNow ) * (double)( 24.0*3600.0) );
+		nWait = (long)( dSecs * 1000 ); // wait in thousands of sec
+	}
+	else
+		nWait = rPar.Get(1)->GetLong();
+	if( nWait < 0 )
+	{
+		StarBASIC::Error( SbERR_BAD_ARGUMENT );
+		return;
+	}
+
+    Timer aTimer;
+    aTimer.SetTimeout( nWait );
+    aTimer.Start();
+    while ( aTimer.IsActive() )
+        Application::Yield();
+}
+
+//i#64882#
+RTLFUNC(Wait)
+{
+	(void)pBasic;
+	(void)bWrite;
+	Wait_Impl( false, rPar );
+}
+
+//i#64882# add new WaitUntil ( for application.wait )
+// share wait_impl with 'normal' oobasic wait
+RTLFUNC(WaitUntil)
+{
+	(void)pBasic;
+	(void)bWrite;
+	Wait_Impl( true, rPar );
+}
+
+RTLFUNC(GetGUIVersion)
+{
+    (void)pBasic;
+    (void)bWrite;
+    
+	if ( rPar.Count() != 1 )
+		StarBASIC::Error( SbERR_BAD_ARGUMENT );
+	else
+	{
+		// Removed for SRC595
+		rPar.Get(0)->PutLong( -1 );
+	}
+}
+
+RTLFUNC(Choose)
+{
+    (void)pBasic;
+    (void)bWrite;
+    
+	if ( rPar.Count() < 2 )
+		StarBASIC::Error( SbERR_BAD_ARGUMENT );
+	INT16 nIndex = rPar.Get(1)->GetInteger();
+	USHORT nCount = rPar.Count();
+	nCount--;
+	if( nCount == 1 || nIndex > (nCount-1) || nIndex < 1 )
+	{
+		rPar.Get(0)->PutNull();
+		return;
+	}
+	(*rPar.Get(0)) = *(rPar.Get(nIndex+1));
+}
+
+
+RTLFUNC(Trim)
+{
+    (void)pBasic;
+    (void)bWrite;
+    
+	if ( rPar.Count() < 2 )
+		StarBASIC::Error( SbERR_BAD_ARGUMENT );
+	else
+	{
+		String aStr( rPar.Get(1)->GetString() );
+		aStr.EraseLeadingChars();
+		aStr.EraseTrailingChars();
+		rPar.Get(0)->PutString( aStr );
+	}
+}
+
+RTLFUNC(GetSolarVersion)
+{
+    (void)pBasic;
+    (void)bWrite;
+    
+	rPar.Get(0)->PutLong( (INT32)SUPD );
+}
+
+RTLFUNC(TwipsPerPixelX)
+{
+    (void)pBasic;
+    (void)bWrite;
+    
+	INT32 nResult = 0;
+	Size aSize( 100,0 );
+	MapMode aMap( MAP_TWIP );
+	OutputDevice* pDevice = Application::GetDefaultDevice();
+	if( pDevice )
+	{
+		aSize = pDevice->PixelToLogic( aSize, aMap );
+		nResult = aSize.Width() / 100;
+	}
+	rPar.Get(0)->PutLong( nResult );
+}
+
+RTLFUNC(TwipsPerPixelY)
+{
+    (void)pBasic;
+    (void)bWrite;
+    
+	INT32 nResult = 0;
+	Size aSize( 0,100 );
+	MapMode aMap( MAP_TWIP );
+	OutputDevice* pDevice = Application::GetDefaultDevice();
+	if( pDevice )
+	{
+		aSize = pDevice->PixelToLogic( aSize, aMap );
+		nResult = aSize.Height() / 100;
+	}
+	rPar.Get(0)->PutLong( nResult );
+}
+
+
+RTLFUNC(FreeLibrary)
+{
+    (void)pBasic;
+    (void)bWrite;
+    
+	if ( rPar.Count() != 2 )
+		StarBASIC::Error( SbERR_BAD_ARGUMENT );
+	ByteString aByteDLLName( rPar.Get(1)->GetString(), gsl_getSystemTextEncoding() );
+	pINST->GetDllMgr()->FreeDll( aByteDLLName );
+}
+bool IsBaseIndexOne()
+{
+	bool result = false;
+	if ( pINST && pINST->pRun )
+	{
+		USHORT res = pINST->pRun->GetBase();
+		if ( res )
+			result = true;
+	}	
+	return result;
+}
+
+RTLFUNC(Array)
+{
+    (void)pBasic;
+    (void)bWrite;
+    
+	SbxDimArray* pArray = new SbxDimArray( SbxVARIANT );
+	USHORT nArraySize = rPar.Count() - 1;
+
+	// Option Base zunaechst ignorieren (kennt leider nur der Compiler)
+	bool bIncIndex = (IsBaseIndexOne() && SbiRuntime::isVBAEnabled() );
+	if( nArraySize )
+	{
+		if ( bIncIndex )	
+			pArray->AddDim( 1, nArraySize );
+		else
+			pArray->AddDim( 0, nArraySize-1 );
+	}
+	else
+	{
+		pArray->unoAddDim( 0, -1 );
+	}
+
+	// Parameter ins Array uebernehmen
+	for( short i = 0 ; i < nArraySize ; i++ )
+	{
+		SbxVariable* pVar = rPar.Get(i+1);
+		SbxVariable* pNew = new SbxVariable( *pVar );
+		pNew->SetFlag( SBX_WRITE );
+		short index = i;
+		if ( bIncIndex )
+			++index; 
+		pArray->Put( pNew, &index );
+	}
+
+	// Array zurueckliefern
+	SbxVariableRef refVar = rPar.Get(0);
+	USHORT nFlags = refVar->GetFlags();
+	refVar->ResetFlag( SBX_FIXED );
+	refVar->PutObject( pArray );
+	refVar->SetFlags( nFlags );
+	refVar->SetParameters( NULL );
+}
+
+
+// Featurewunsch #57868
+// Die Funktion liefert ein Variant-Array, wenn keine Parameter angegeben
+// werden, wird ein leeres Array erzeugt (entsprechend dim a(), entspricht
+// einer Sequence der Laenge 0 in Uno).
+// Wenn Parameter angegeben sind, wird fuer jeden eine Dimension erzeugt
+// DimArray( 2, 2, 4 ) entspricht DIM a( 2, 2, 4 )
+// Das Array ist immer vom Typ Variant
+RTLFUNC(DimArray)
+{
+    (void)pBasic;
+    (void)bWrite;
+    
+	SbxDimArray * pArray = new SbxDimArray( SbxVARIANT );
+	USHORT nArrayDims = rPar.Count() - 1;
+	if( nArrayDims > 0 )
+	{
+		for( USHORT i = 0; i < nArrayDims ; i++ )
+		{
+			INT32 ub = rPar.Get(i+1)->GetLong();
+			if( ub < 0 )
+			{
+				StarBASIC::Error( SbERR_OUT_OF_RANGE );
+				ub = 0;
+			}
+			pArray->AddDim32( 0, ub );
+		}
+	}
+	else
+		pArray->unoAddDim( 0, -1 );
+
+	// Array zurueckliefern
+	SbxVariableRef refVar = rPar.Get(0);
+	USHORT nFlags = refVar->GetFlags();
+	refVar->ResetFlag( SBX_FIXED );
+	refVar->PutObject( pArray );
+	refVar->SetFlags( nFlags );
+	refVar->SetParameters( NULL );
+}
+
+/*
+ * FindObject und FindPropertyObject ermoeglichen es,
+ * Objekte und Properties vom Typ Objekt zur Laufzeit
+ * ueber ihren Namen als String-Parameter anzusprechen.
+ *
+ * Bsp.:
+ * MyObj.Prop1.Bla = 5
+ *
+ * entspricht:
+ * dim ObjVar as Object
+ * dim ObjProp as Object
+ * ObjName$ = "MyObj"
+ * ObjVar = FindObject( ObjName$ )
+ * PropName$ = "Prop1"
+ * ObjProp = FindPropertyObject( ObjVar, PropName$ )
+ * ObjProp.Bla = 5
+ *
+ * Dabei koennen die Namen zur Laufzeit dynamisch
+ * erzeugt werden und, so dass z.B. ueber Controls
+ * "TextEdit1" bis "TextEdit5" in einem Dialog in
+ * einer Schleife iteriert werden kann.
+ */
+
+// Objekt ueber den Namen ansprechen
+// 1. Parameter = Name des Objekts als String
+RTLFUNC(FindObject)
+{
+    (void)pBasic;
+    (void)bWrite;
+    
+	// Wir brauchen einen Parameter
+	if ( rPar.Count() < 2 )
+	{
+		StarBASIC::Error( SbERR_BAD_ARGUMENT );
+		return;
+	}
+
+	// 1. Parameter ist der Name
+	String aNameStr = rPar.Get(1)->GetString();
+
+	// Basic-Suchfunktion benutzen
+	SbxBase* pFind =  StarBASIC::FindSBXInCurrentScope( aNameStr );
+	SbxObject* pFindObj = NULL;
+	if( pFind )
+		pFindObj = PTR_CAST(SbxObject,pFind);
+	/*
+	if( !pFindObj )
+	{
+		StarBASIC::Error( SbERR_VAR_UNDEFINED );
+		return;
+	}
+	*/
+
+	// Objekt zurueckliefern
+	SbxVariableRef refVar = rPar.Get(0);
+	refVar->PutObject( pFindObj );
+}
+
+// Objekt-Property in einem Objekt ansprechen
+// 1. Parameter = Objekt
+// 2. Parameter = Name der Property als String
+RTLFUNC(FindPropertyObject)
+{
+    (void)pBasic;
+    (void)bWrite;
+    
+	// Wir brauchen 2 Parameter
+	if ( rPar.Count() < 3 )
+	{
+		StarBASIC::Error( SbERR_BAD_ARGUMENT );
+		return;
+	}
+
+	// 1. Parameter holen, muss Objekt sein
+	SbxBase* pObjVar = (SbxObject*)rPar.Get(1)->GetObject();
+	SbxObject* pObj = NULL;
+	if( pObjVar )
+		pObj = PTR_CAST(SbxObject,pObjVar);
+	if( !pObj && pObjVar && pObjVar->ISA(SbxVariable) )
+	{
+		SbxBase* pObjVarObj = ((SbxVariable*)pObjVar)->GetObject();
+		pObj = PTR_CAST(SbxObject,pObjVarObj);
+	}
+	/*
+	if( !pObj )
+	{
+		StarBASIC::Error( SbERR_VAR_UNDEFINED );
+		return;
+	}
+	*/
+
+	// 2. Parameter ist der Name
+	String aNameStr = rPar.Get(2)->GetString();
+
+	// Jetzt muss ein Objekt da sein, sonst Error
+	SbxObject* pFindObj = NULL;
+	if( pObj )
+	{
+		// Im Objekt nach Objekt suchen
+		SbxVariable* pFindVar = pObj->Find( aNameStr, SbxCLASS_OBJECT );
+		pFindObj = PTR_CAST(SbxObject,pFindVar);
+	}
+	else
+		StarBASIC::Error( SbERR_BAD_PARAMETER );
+
+	// Objekt zurueckliefern
+	SbxVariableRef refVar = rPar.Get(0);
+	refVar->PutObject( pFindObj );
+}
+
+
+
+BOOL lcl_WriteSbxVariable( const SbxVariable& rVar, SvStream* pStrm,
+	BOOL bBinary, short nBlockLen, BOOL bIsArray )
+{
+	ULONG nFPos = pStrm->Tell();
+
+	BOOL bIsVariant = !rVar.IsFixed();
+	SbxDataType eType = rVar.GetType();
+
+	switch( eType )
+	{
+		case SbxBOOL:
+		case SbxCHAR:
+		case SbxBYTE:
+				if( bIsVariant )
+					*pStrm << (USHORT)SbxBYTE; // VarType Id
+				*pStrm << rVar.GetByte();
+				break;
+
+		case SbxEMPTY:
+		case SbxNULL:
+		case SbxVOID:
+		case SbxINTEGER:
+		case SbxUSHORT:
+		case SbxINT:
+		case SbxUINT:
+				if( bIsVariant )
+					*pStrm << (USHORT)SbxINTEGER; // VarType Id
+				*pStrm << rVar.GetInteger();
+				break;
+
+		case SbxLONG:
+		case SbxULONG:
+		case SbxLONG64:
+		case SbxULONG64:
+				if( bIsVariant )
+					*pStrm << (USHORT)SbxLONG; // VarType Id
+				*pStrm << rVar.GetLong();
+				break;
+
+		case SbxSINGLE:
+				if( bIsVariant )
+					*pStrm << (USHORT)eType; // VarType Id
+				*pStrm << rVar.GetSingle();
+				break;
+
+		case SbxDOUBLE:
+		case SbxCURRENCY:
+		case SbxDATE:
+				if( bIsVariant )
+					*pStrm << (USHORT)eType; // VarType Id
+				*pStrm << rVar.GetDouble();
+				break;
+
+		case SbxSTRING:
+		case SbxLPSTR:
+				{
+				const String& rStr = rVar.GetString();
+				if( !bBinary || bIsArray )
+				{
+					if( bIsVariant )
+						*pStrm << (USHORT)SbxSTRING;
+					pStrm->WriteByteString( rStr, gsl_getSystemTextEncoding() );
+					//*pStrm << rStr;
+				}
+				else
+				{
+					// ohne Laengenangabe! ohne Endekennung!
+					// What does that mean for Unicode?! Choosing conversion to ByteString...
+					ByteString aByteStr( rStr, gsl_getSystemTextEncoding() );
+					*pStrm << (const char*)aByteStr.GetBuffer();
+					//*pStrm << (const char*)rStr.GetStr();
+				}
+				}
+				break;
+
+		default:
+				StarBASIC::Error( SbERR_BAD_ARGUMENT );
+				return FALSE;
+	}
+
+	if( nBlockLen )
+		pStrm->Seek( nFPos + nBlockLen );
+	return pStrm->GetErrorCode() ? FALSE : TRUE;
+}
+
+BOOL lcl_ReadSbxVariable( SbxVariable& rVar, SvStream* pStrm,
+	BOOL bBinary, short nBlockLen, BOOL bIsArray )
+{
+    (void)bBinary;
+    (void)bIsArray;
+    
+	double aDouble;
+
+	ULONG nFPos = pStrm->Tell();
+
+	BOOL bIsVariant = !rVar.IsFixed();
+	SbxDataType eVarType = rVar.GetType();
+
+	SbxDataType eSrcType = eVarType;
+	if( bIsVariant )
+	{
+		USHORT nTemp;
+		*pStrm >> nTemp;
+		eSrcType = (SbxDataType)nTemp;
+	}
+
+	switch( eSrcType )
+	{
+		case SbxBOOL:
+		case SbxCHAR:
+		case SbxBYTE:
+				{
+				BYTE aByte;
+				*pStrm >> aByte;
+				rVar.PutByte( aByte );
+				}
+				break;
+
+		case SbxEMPTY:
+		case SbxNULL:
+		case SbxVOID:
+		case SbxINTEGER:
+		case SbxUSHORT:
+		case SbxINT:
+		case SbxUINT:
+				{
+				INT16 aInt;
+				*pStrm >> aInt;
+				rVar.PutInteger( aInt );
+				}
+				break;
+
+		case SbxLONG:
+		case SbxULONG:
+		case SbxLONG64:
+		case SbxULONG64:
+				{
+				INT32 aInt;
+				*pStrm >> aInt;
+				rVar.PutLong( aInt );
+				}
+				break;
+
+		case SbxSINGLE:
+				{
+				float nS;
+				*pStrm >> nS;
+				rVar.PutSingle( nS );
+				}
+				break;
+
+		case SbxDOUBLE:
+		case SbxCURRENCY:
+				{
+				*pStrm >> aDouble;
+				rVar.PutDouble( aDouble );
+				}
+				break;
+
+		case SbxDATE:
+				{
+				*pStrm >> aDouble;
+				rVar.PutDate( aDouble );
+				}
+				break;
+
+		case SbxSTRING:
+		case SbxLPSTR:
+				{
+				String aStr;
+				pStrm->ReadByteString( aStr, gsl_getSystemTextEncoding() );
+				rVar.PutString( aStr );
+				}
+				break;
+
+		default:
+				StarBASIC::Error( SbERR_BAD_ARGUMENT );
+				return FALSE;
+	}
+
+	if( nBlockLen )
+		pStrm->Seek( nFPos + nBlockLen );
+	return pStrm->GetErrorCode() ? FALSE : TRUE;
+}
+
+
+// nCurDim = 1...n
+BOOL lcl_WriteReadSbxArray( SbxDimArray& rArr, SvStream* pStrm,
+	BOOL bBinary, short nCurDim, short* pOtherDims, BOOL bWrite )
+{
+	DBG_ASSERT( nCurDim > 0,"Bad Dim");
+	short nLower, nUpper;
+	if( !rArr.GetDim( nCurDim, nLower, nUpper ) )
+		return FALSE;
+	for( short nCur = nLower; nCur <= nUpper; nCur++ )
+	{
+		pOtherDims[ nCurDim-1 ] = nCur;
+		if( nCurDim != 1 )
+			lcl_WriteReadSbxArray(rArr, pStrm, bBinary, nCurDim-1, pOtherDims, bWrite);
+		else
+		{
+			SbxVariable* pVar = rArr.Get( (const short*)pOtherDims );
+			BOOL bRet;
+			if( bWrite )
+				bRet = lcl_WriteSbxVariable(*pVar, pStrm, bBinary, 0, TRUE );
+			else
+				bRet = lcl_ReadSbxVariable(*pVar, pStrm, bBinary, 0, TRUE );
+			if( !bRet )
+				return FALSE;
+		}
+	}
+	return TRUE;
+}
+
+void PutGet( SbxArray& rPar, BOOL bPut )
+{
+	// Wir brauchen 3 Parameter
+	if ( rPar.Count() != 4 )
+	{
+		StarBASIC::Error( SbERR_BAD_ARGUMENT );
+		return;
+	}
+	INT16 nFileNo = rPar.Get(1)->GetInteger();
+	SbxVariable* pVar2 = rPar.Get(2);
+	BOOL bHasRecordNo = (BOOL)(pVar2->GetType() != SbxEMPTY);
+	long nRecordNo = pVar2->GetLong();
+	if ( nFileNo < 1 || ( bHasRecordNo && nRecordNo < 1 ) )
+	{
+		StarBASIC::Error( SbERR_BAD_ARGUMENT );
+		return;
+	}
+	nRecordNo--; // wir moegen's ab 0!
+	SbiIoSystem* pIO = pINST->GetIoSystem();
+	SbiStream* pSbStrm = pIO->GetStream( nFileNo );
+	// das File muss Random (feste Record-Laenge) oder Binary sein
+	if ( !pSbStrm || !(pSbStrm->GetMode() & (SBSTRM_BINARY | SBSTRM_RANDOM)) )
+	{
+		StarBASIC::Error( SbERR_BAD_CHANNEL );
+		return;
+	}
+
+	SvStream* pStrm = pSbStrm->GetStrm();
+	BOOL bRandom = pSbStrm->IsRandom();
+	short nBlockLen = bRandom ? pSbStrm->GetBlockLen() : 0;
+
+	if( bPut )
+	{
+		// Datei aufplustern, falls jemand uebers Dateiende hinaus geseekt hat
+		pSbStrm->ExpandFile();
+	}
+
+	// auf die Startposition seeken
+	if( bHasRecordNo )
+	{
+		ULONG nFilePos = bRandom ? (ULONG)(nBlockLen*nRecordNo) : (ULONG)nRecordNo;
+		pStrm->Seek( nFilePos );
+	}
+
+	SbxDimArray* pArr = 0;
+	SbxVariable* pVar = rPar.Get(3);
+	if( pVar->GetType() & SbxARRAY )
+	{
+		SbxBase* pParObj = pVar->GetObject();
+		pArr = PTR_CAST(SbxDimArray,pParObj);
+	}
+
+	BOOL bRet;
+
+	if( pArr )
+	{
+		ULONG nFPos = pStrm->Tell();
+		short nDims = pArr->GetDims();
+		short* pDims = new short[ nDims ];
+		bRet = lcl_WriteReadSbxArray(*pArr,pStrm,!bRandom,nDims,pDims,bPut);
+		delete [] pDims;
+		if( nBlockLen )
+			pStrm->Seek( nFPos + nBlockLen );
+	}
+	else
+	{
+		if( bPut )
+			bRet = lcl_WriteSbxVariable(*pVar, pStrm, !bRandom, nBlockLen, FALSE);
+		else
+			bRet = lcl_ReadSbxVariable(*pVar, pStrm, !bRandom, nBlockLen, FALSE);
+	}
+	if( !bRet || pStrm->GetErrorCode() )
+		StarBASIC::Error( SbERR_IO_ERROR );
+}
+
+RTLFUNC(Put)
+{
+    (void)pBasic;
+    (void)bWrite;
+    
+	PutGet( rPar, TRUE );
+}
+
+RTLFUNC(Get)
+{
+    (void)pBasic;
+    (void)bWrite;
+    
+	PutGet( rPar, FALSE );
+}
+
+RTLFUNC(Environ)
+{
+    (void)pBasic;
+    (void)bWrite;
+    
+	if ( rPar.Count() != 2 )
+	{
+		StarBASIC::Error( SbERR_BAD_ARGUMENT );
+		return;
+	}
+	String aResult;
+	// sollte ANSI sein, aber unter Win16 in DLL nicht moeglich
+#if defined(WIN)
+	LPSTR lpszEnv = GetDOSEnvironment();
+	String aCompareStr( rPar.Get(1)->GetString() );
+	aCompareStr += '=';
+	const char* pCompare = aCompareStr.GetStr();
+	int nCompareLen = aCompareStr.Len();
+	while ( *lpszEnv )
+	{
+		// Es werden alle EnvString in der Form ENV=VAL 0-terminiert
+		// aneinander gehaengt.
+
+		if ( strnicmp( pCompare, lpszEnv, nCompareLen ) == 0 )
+		{
+			aResult = (const char*)(lpszEnv+nCompareLen);
+			rPar.Get(0)->PutString( aResult );
+			return;
+		}
+		lpszEnv += lstrlen( lpszEnv ) + 1; 	// Next Enviroment-String
+	}
+#else
+	ByteString aByteStr( rPar.Get(1)->GetString(), gsl_getSystemTextEncoding() );
+	const char* pEnvStr = getenv( aByteStr.GetBuffer() );
+	if ( pEnvStr )
+		aResult = String::CreateFromAscii( pEnvStr );
+#endif
+	rPar.Get(0)->PutString( aResult );
+}
+
+static double GetDialogZoomFactor( BOOL bX, long nValue )
+{
+	OutputDevice* pDevice = Application::GetDefaultDevice();
+	double nResult = 0;
+	if( pDevice )
+	{
+		Size aRefSize( nValue, nValue );
+#ifndef WIN
+		Fraction aFracX( 1, 26 );
+#else
+		Fraction aFracX( 1, 23 );
+#endif
+		Fraction aFracY( 1, 24 );
+		MapMode aMap( MAP_APPFONT, Point(), aFracX, aFracY );
+		Size aScaledSize = pDevice->LogicToPixel( aRefSize, aMap );
+		aRefSize = pDevice->LogicToPixel( aRefSize, MapMode(MAP_TWIP) );
+
+		double nRef, nScaled;
+		if( bX )
+		{
+			nRef = aRefSize.Width();
+			nScaled = aScaledSize.Width();
+		}
+		else
+		{
+			nRef = aRefSize.Height();
+			nScaled = aScaledSize.Height();
+		}
+		nResult = nScaled / nRef;
+	}
+	return nResult;
+}
+
+
+RTLFUNC(GetDialogZoomFactorX)
+{
+    (void)pBasic;
+    (void)bWrite;
+    
+	if ( rPar.Count() != 2 )
+	{
+		StarBASIC::Error( SbERR_BAD_ARGUMENT );
+		return;
+	}
+	rPar.Get(0)->PutDouble( GetDialogZoomFactor( TRUE, rPar.Get(1)->GetLong() ));
+}
+
+RTLFUNC(GetDialogZoomFactorY)
+{
+    (void)pBasic;
+    (void)bWrite;
+    
+	if ( rPar.Count() != 2 )
+	{
+		StarBASIC::Error( SbERR_BAD_ARGUMENT );
+		return;
+	}
+	rPar.Get(0)->PutDouble( GetDialogZoomFactor( FALSE, rPar.Get(1)->GetLong()));
+}
+
+
+RTLFUNC(EnableReschedule)
+{
+    (void)pBasic;
+    (void)bWrite;
+    
+	rPar.Get(0)->PutEmpty();
+	if ( rPar.Count() != 2 )
+		StarBASIC::Error( SbERR_BAD_ARGUMENT );
+	if( pINST )
+		pINST->EnableReschedule( rPar.Get(1)->GetBool() );
+}
+
+RTLFUNC(GetSystemTicks)
+{
+    (void)pBasic;
+    (void)bWrite;
+    
+	if ( rPar.Count() != 1 )
+	{
+		StarBASIC::Error( SbERR_BAD_ARGUMENT );
+		return;
+	}
+	rPar.Get(0)->PutLong( Time::GetSystemTicks() );
+}
+
+RTLFUNC(GetPathSeparator)
+{
+    (void)pBasic;
+    (void)bWrite;
+    
+	if ( rPar.Count() != 1 )
+	{
+		StarBASIC::Error( SbERR_BAD_ARGUMENT );
+		return;
+	}
+	rPar.Get(0)->PutString( DirEntry::GetAccessDelimiter() );
+}
+
+RTLFUNC(ResolvePath)
+{
+    (void)pBasic;
+    (void)bWrite;
+    
+	if ( rPar.Count() == 2 )
+	{
+		String aStr = rPar.Get(1)->GetString();
+		DirEntry aEntry( aStr );
+		//if( aEntry.IsVirtual() )
+			//aStr = aEntry.GetRealPathFromVirtualURL();
+		rPar.Get(0)->PutString( aStr );
+	}
+	else
+		StarBASIC::Error( SbERR_BAD_ARGUMENT );
+}
+
+RTLFUNC(TypeLen)
+{
+    (void)pBasic;
+    (void)bWrite;
+    
+	if ( rPar.Count() != 2 )
+		StarBASIC::Error( SbERR_BAD_ARGUMENT );
+	else
+	{
+		SbxDataType eType = rPar.Get(1)->GetType();
+		INT16 nLen = 0;
+		switch( eType )
+		{
+			case SbxEMPTY:
+			case SbxNULL:
+			case SbxVECTOR:
+			case SbxARRAY:
+			case SbxBYREF:
+			case SbxVOID:
+			case SbxHRESULT:
+			case SbxPOINTER:
+			case SbxDIMARRAY:
+			case SbxCARRAY:
+			case SbxUSERDEF:
+				nLen = 0;
+				break;
+
+			case SbxINTEGER:
+			case SbxERROR:
+			case SbxUSHORT:
+			case SbxINT:
+			case SbxUINT:
+				nLen = 2;
+				break;
+
+			case SbxLONG:
+			case SbxSINGLE:
+			case SbxULONG:
+				nLen = 4;
+				break;
+
+			case SbxDOUBLE:
+			case SbxCURRENCY:
+			case SbxDATE:
+			case SbxLONG64:
+			case SbxULONG64:
+				nLen = 8;
+				break;
+
+			case SbxOBJECT:
+			case SbxVARIANT:
+			case SbxDATAOBJECT:
+				nLen = 0;
+				break;
+
+			case SbxCHAR:
+			case SbxBYTE:
+			case SbxBOOL:
+				nLen = 1;
+				break;
+
+			case SbxLPSTR:
+			case SbxLPWSTR:
+			case SbxCoreSTRING:
+			case SbxSTRING:
+				nLen = (INT16)rPar.Get(1)->GetString().Len();
+				break;
+
+			default:
+				nLen = 0;
+		}
+		rPar.Get(0)->PutInteger( nLen );
+	}
+}
+
+
+// Uno-Struct eines beliebigen Typs erzeugen
+// 1. Parameter == Klassename, weitere Parameter zur Initialisierung
+RTLFUNC(CreateUnoStruct)
+{
+    (void)pBasic;
+    (void)bWrite;
+    
+	RTL_Impl_CreateUnoStruct( pBasic, rPar, bWrite );
+}
+
+// Uno-Service erzeugen
+// 1. Parameter == Service-Name
+RTLFUNC(CreateUnoService)
+{
+    (void)pBasic;
+    (void)bWrite;
+    
+	RTL_Impl_CreateUnoService( pBasic, rPar, bWrite );
+}
+
+RTLFUNC(CreateUnoValue)
+{
+    (void)pBasic;
+    (void)bWrite;
+    
+	RTL_Impl_CreateUnoValue( pBasic, rPar, bWrite );
+}
+
+
+// ServiceManager liefern (keine Parameter)
+RTLFUNC(GetProcessServiceManager)
+{
+    (void)pBasic;
+    (void)bWrite;
+    
+	RTL_Impl_GetProcessServiceManager( pBasic, rPar, bWrite );
+}
+
+// PropertySet erzeugen
+// 1. Parameter == Sequence<PropertyValue>
+RTLFUNC(CreatePropertySet)
+{
+    (void)pBasic;
+    (void)bWrite;
+    
+	RTL_Impl_CreatePropertySet( pBasic, rPar, bWrite );
+}
+
+// Abfragen, ob ein Interface unterstuetzt wird
+// Mehrere Interface-Namen als Parameter
+RTLFUNC(HasUnoInterfaces)
+{
+    (void)pBasic;
+    (void)bWrite;
+    
+	RTL_Impl_HasInterfaces( pBasic, rPar, bWrite );
+}
+
+// Abfragen, ob ein Basic-Objekt ein Uno-Struct repraesentiert
+RTLFUNC(IsUnoStruct)
+{
+    (void)pBasic;
+    (void)bWrite;
+    
+	RTL_Impl_IsUnoStruct( pBasic, rPar, bWrite );
+}
+
+// Abfragen, ob zwei Uno-Objekte identisch sind
+RTLFUNC(EqualUnoObjects)
+{
+    (void)pBasic;
+    (void)bWrite;
+    
+	RTL_Impl_EqualUnoObjects( pBasic, rPar, bWrite );
+}
+
+// Instanciate "com.sun.star.awt.UnoControlDialog" on basis
+// of a DialogLibrary entry: Convert from XML-ByteSequence
+// and attach events. Implemented in classes\eventatt.cxx
+void RTL_Impl_CreateUnoDialog( StarBASIC* pBasic, SbxArray& rPar, BOOL bWrite );
+
+RTLFUNC(CreateUnoDialog)
+{
+    (void)pBasic;
+    (void)bWrite;
+    
+	RTL_Impl_CreateUnoDialog( pBasic, rPar, bWrite );
+}
+
+// Return the application standard lib as root scope
+RTLFUNC(GlobalScope)
+{
+    (void)pBasic;
+    (void)bWrite;
+    
+    SbxObject* p = pBasic;
+    while( p->GetParent() )
+	    p = p->GetParent();
+
+    SbxVariableRef refVar = rPar.Get(0);
+    refVar->PutObject( p );
+}
+
+// Helper functions to convert Url from/to system paths
+RTLFUNC(ConvertToUrl)
+{
+    (void)pBasic;
+    (void)bWrite;
+    
+	if ( rPar.Count() == 2 )
+	{
+		String aStr = rPar.Get(1)->GetString();
+        INetURLObject aURLObj( aStr, INET_PROT_FILE );
+	    OUString aFileURL = aURLObj.GetMainURL( INetURLObject::NO_DECODE );
+	    if( !aFileURL.getLength() )
+            ::osl::File::getFileURLFromSystemPath( aFileURL, aFileURL );
+	    if( !aFileURL.getLength() )
+            aFileURL = aStr;
+		rPar.Get(0)->PutString( String(aFileURL) );
+	}
+	else
+		StarBASIC::Error( SbERR_BAD_ARGUMENT );
+}
+
+RTLFUNC(ConvertFromUrl)
+{
+    (void)pBasic;
+    (void)bWrite;
+    
+	if ( rPar.Count() == 2 )
+	{
+		String aStr = rPar.Get(1)->GetString();
+	    OUString aSysPath;
+	    ::osl::File::getSystemPathFromFileURL( aStr, aSysPath );
+	    if( !aSysPath.getLength() )
+            aSysPath = aStr;
+		rPar.Get(0)->PutString( String(aSysPath) );
+	}
+	else
+		StarBASIC::Error( SbERR_BAD_ARGUMENT );
+}
+
+
+// Provide DefaultContext
+RTLFUNC(GetDefaultContext)
+{
+    (void)pBasic;
+    (void)bWrite;
+    
+	RTL_Impl_GetDefaultContext( pBasic, rPar, bWrite );
+}
+
+
+RTLFUNC(Join)
+{
+    (void)pBasic;
+    (void)bWrite;
+    
+	USHORT nParCount = rPar.Count();
+	if ( nParCount != 3 && nParCount != 2 )
+	{
+		StarBASIC::Error( SbERR_BAD_ARGUMENT );
+		return;
+	}
+	SbxBase* pParObj = rPar.Get(1)->GetObject();
+	SbxDimArray* pArr = PTR_CAST(SbxDimArray,pParObj);
+	if( pArr )
+	{
+		if( pArr->GetDims() != 1 )
+			StarBASIC::Error( SbERR_WRONG_DIMS );	// Syntax Error?!
+
+		String aDelim;
+		if( nParCount == 3 )
+			aDelim = rPar.Get(2)->GetString();
+		else
+			aDelim = String::CreateFromAscii( " " );
+
+		String aRetStr;
+		short nLower, nUpper;
+		pArr->GetDim( 1, nLower, nUpper );
+		for( short i = nLower ; i <= nUpper ; ++i )
+		{
+			String aStr = pArr->Get( &i )->GetString();
+			aRetStr += aStr;
+			if( i != nUpper )
+				aRetStr += aDelim;
+		}
+		rPar.Get(0)->PutString( aRetStr );
+	}
+	else
+		StarBASIC::Error( SbERR_MUST_HAVE_DIMS );
+}
+
+
+typedef ::std::vector< String > StringVector;
+
+RTLFUNC(Split)
+{
+    (void)pBasic;
+    (void)bWrite;
+    
+	USHORT nParCount = rPar.Count();
+	if ( nParCount < 2 )
+	{
+		StarBASIC::Error( SbERR_BAD_ARGUMENT );
+		return;
+	}
+
+	String aExpression = rPar.Get(1)->GetString();
+	short nArraySize = 0;
+	StringVector vRet;
+	if( aExpression.Len() )
+	{
+		String aDelim;
+		if( nParCount >= 3 )
+			aDelim = rPar.Get(2)->GetString();
+		else
+			aDelim = String::CreateFromAscii( " " );
+
+		INT32 nCount = -1;
+		if( nParCount == 4 )
+			nCount = rPar.Get(3)->GetLong();
+
+		xub_StrLen nDelimLen = aDelim.Len();
+		if( nDelimLen )
+		{
+			xub_StrLen iSearch = STRING_NOTFOUND; 
+			xub_StrLen iStart = 0;
+			do
+			{
+				bool bBreak = false;
+				if( nCount >= 0 && nArraySize == nCount - 1 )
+					bBreak = true;
+
+				iSearch = aExpression.Search( aDelim, iStart );
+				String aSubStr;
+				if( iSearch != STRING_NOTFOUND && !bBreak )
+				{
+					aSubStr = aExpression.Copy( iStart, iSearch - iStart );
+					iStart = iSearch + nDelimLen;
+				}
+				else
+				{
+					aSubStr = aExpression.Copy( iStart );
+				}
+				vRet.push_back( aSubStr );
+				nArraySize++;
+
+				if( bBreak )
+					break;
+			}
+			while( iSearch != STRING_NOTFOUND );
+		}
+		else
+		{
+			vRet.push_back( aExpression );
+			nArraySize = 1;
+		}
+	}
+
+	SbxDimArray* pArray = new SbxDimArray( SbxVARIANT );
+	pArray->unoAddDim( 0, nArraySize-1 );
+
+	// Parameter ins Array uebernehmen
+	for( short i = 0 ; i < nArraySize ; i++ )
+	{
+		SbxVariableRef xVar = new SbxVariable( SbxVARIANT );
+		xVar->PutString( vRet[i] );
+		pArray->Put( (SbxVariable*)xVar, &i );
+	}
+
+	// Array zurueckliefern
+	SbxVariableRef refVar = rPar.Get(0);
+	USHORT nFlags = refVar->GetFlags();
+	refVar->ResetFlag( SBX_FIXED );
+	refVar->PutObject( pArray );
+	refVar->SetFlags( nFlags );
+	refVar->SetParameters( NULL );
+}
+
+// MonthName(month[, abbreviate])
+RTLFUNC(MonthName)
+{
+    (void)pBasic;
+    (void)bWrite;
+    
+	USHORT nParCount = rPar.Count();
+	if( nParCount != 2 && nParCount != 3 )
+	{
+		StarBASIC::Error( SbERR_BAD_ARGUMENT );
+		return;
+	}
+
+	Reference< XCalendar > xCalendar = getLocaleCalendar();
+	if( !xCalendar.is() )
+	{
+		StarBASIC::Error( SbERR_INTERNAL_ERROR );
+		return;
+	}
+	Sequence< CalendarItem > aMonthSeq = xCalendar->getMonths();
+	sal_Int32 nMonthCount = aMonthSeq.getLength();
+
+	INT16 nVal = rPar.Get(1)->GetInteger();
+	if( nVal < 1 || nVal > nMonthCount )
+	{
+		StarBASIC::Error( SbERR_BAD_ARGUMENT );
+		return;
+	}
+
+	BOOL bAbbreviate = false;
+	if( nParCount == 3 )
+		bAbbreviate = rPar.Get(2)->GetBool();
+
+	const CalendarItem* pCalendarItems = aMonthSeq.getConstArray();
+	const CalendarItem& rItem = pCalendarItems[nVal - 1];
+
+	OUString aRetStr = ( bAbbreviate ? rItem.AbbrevName : rItem.FullName );
+	rPar.Get(0)->PutString( String(aRetStr) );
+}
+
+// WeekdayName(weekday, abbreviate, firstdayofweek)
+RTLFUNC(WeekdayName)
+{
+    (void)pBasic;
+    (void)bWrite;
+    
+	USHORT nParCount = rPar.Count();
+	if( nParCount < 2 || nParCount > 4 )
+	{
+		StarBASIC::Error( SbERR_BAD_ARGUMENT );
+		return;
+	}
+
+	Reference< XCalendar > xCalendar = getLocaleCalendar();
+	if( !xCalendar.is() )
+	{
+		StarBASIC::Error( SbERR_INTERNAL_ERROR );
+		return;
+	}
+
+	Sequence< CalendarItem > aDaySeq = xCalendar->getDays();
+	INT16 nDayCount = (INT16)aDaySeq.getLength();
+	INT16 nDay = rPar.Get(1)->GetInteger();
+	INT16 nFirstDay = 0;
+	if( nParCount == 4 )
+	{
+		nFirstDay = rPar.Get(3)->GetInteger();
+		if( nFirstDay < 0 || nFirstDay > 7 )
+		{
+			StarBASIC::Error( SbERR_BAD_ARGUMENT );
+			return;
+		}
+	}
+	if( nFirstDay == 0 )
+		nFirstDay = INT16( xCalendar->getFirstDayOfWeek() + 1 );
+
+	nDay = 1 + (nDay + nDayCount + nFirstDay - 2) % nDayCount;
+	if( nDay < 1 || nDay > nDayCount )
+	{
+		StarBASIC::Error( SbERR_BAD_ARGUMENT );
+		return;
+	}
+
+	BOOL bAbbreviate = false;
+	if( nParCount >= 3 )
+	{
+		SbxVariable* pPar2 = rPar.Get(2);
+		if( !pPar2->IsErr() )
+			bAbbreviate = pPar2->GetBool();
+	}
+
+	const CalendarItem* pCalendarItems = aDaySeq.getConstArray();
+	const CalendarItem& rItem = pCalendarItems[nDay - 1];
+
+	OUString aRetStr = ( bAbbreviate ? rItem.AbbrevName : rItem.FullName );
+	rPar.Get(0)->PutString( String(aRetStr) );
+}
+
+INT16 implGetWeekDay( double aDate, bool bFirstDayParam = false, INT16 nFirstDay = 0 )
+{
+	Date aRefDate( 1,1,1900 );
+	long nDays = (long) aDate;
+	nDays -= 2;	// normieren: 1.1.1900 => 0
+	aRefDate += nDays;
+	DayOfWeek aDay = aRefDate.GetDayOfWeek();
+	INT16 nDay;
+	if ( aDay != SUNDAY )
+		nDay = (INT16)aDay + 2;
+	else
+		nDay = 1;	// 1==Sonntag
+
+	// #117253 Optional 2. parameter "firstdayofweek"
+	if( bFirstDayParam )
+	{
+		if( nFirstDay < 0 || nFirstDay > 7 )
+		{
+			StarBASIC::Error( SbERR_BAD_ARGUMENT );
+			return 0;
+		}
+		if( nFirstDay == 0 )
+		{
+			Reference< XCalendar > xCalendar = getLocaleCalendar();
+			if( !xCalendar.is() )
+			{
+				StarBASIC::Error( SbERR_INTERNAL_ERROR );
+				return 0;
+			}
+			nFirstDay = INT16( xCalendar->getFirstDayOfWeek() + 1 );
+		}
+		nDay = 1 + (nDay + 7 - nFirstDay) % 7;
+	}
+	return nDay;
+}
+
+RTLFUNC(Weekday)
+{
+    (void)pBasic;
+    (void)bWrite;
+    
+	USHORT nParCount = rPar.Count();
+	if ( nParCount < 2 )
+		StarBASIC::Error( SbERR_BAD_ARGUMENT );
+	else
+	{
+		double aDate = rPar.Get(1)->GetDate();
+
+		bool bFirstDay = false;
+		INT16 nFirstDay = 0;
+		if ( nParCount > 2 )
+		{
+			nFirstDay = rPar.Get(2)->GetInteger();
+			bFirstDay = true;
+		}
+		INT16 nDay = implGetWeekDay( aDate, bFirstDay, nFirstDay );
+		rPar.Get(0)->PutInteger( nDay );
+	}
+}
+
+
+enum Interval
+{
+	INTERVAL_NONE,
+	INTERVAL_YYYY,
+	INTERVAL_Q,
+	INTERVAL_M,
+	INTERVAL_Y,
+	INTERVAL_D,
+	INTERVAL_W,
+	INTERVAL_WW,
+	INTERVAL_H,
+	INTERVAL_N,
+	INTERVAL_S
+};
+
+struct IntervalInfo
+{
+	Interval	meInterval;
+	const char* mpStringCode;
+	double		mdValue;
+	bool		mbSimple;
+
+	IntervalInfo( Interval eInterval, const char* pStringCode, double dValue, bool bSimple )
+		: meInterval( eInterval )
+		, mpStringCode( pStringCode )
+		, mdValue( dValue )
+		, mbSimple( bSimple )
+	{}
+};	
+
+static IntervalInfo pIntervalTable[] =
+{
+	IntervalInfo( INTERVAL_YYYY,	"yyyy",		 0.0,				false ),	// Year 
+	IntervalInfo( INTERVAL_Q,		"q",		 0.0,				false ),	// Quarter 
+	IntervalInfo( INTERVAL_M,		"m",		 0.0,				false ),	// Month 
+	IntervalInfo( INTERVAL_Y,		"y",		 1.0,				true ),		// Day of year 
+	IntervalInfo( INTERVAL_D,		"d",		 1.0,				true ),		// Day 
+	IntervalInfo( INTERVAL_W,		"w",		 1.0,				true ),		// Weekday 
+	IntervalInfo( INTERVAL_WW,		"ww",		 7.0,				true ),		// Week 
+	IntervalInfo( INTERVAL_H,		"h",		(1.0 /    24.0),	true ),		// Hour 
+	IntervalInfo( INTERVAL_N,		"n",		(1.0 /  1440.0),	true),		// Minute 
+	IntervalInfo( INTERVAL_S,		"s",		(1.0 / 86400.0),	true ),		// Second 
+	IntervalInfo( INTERVAL_NONE, NULL, 0.0, false )
+};
+
+IntervalInfo* getIntervalInfo( const String& rStringCode )
+{
+	IntervalInfo* pInfo = NULL;
+	INT16 i = 0;
+	while( (pInfo = pIntervalTable + i)->mpStringCode != NULL )
+	{
+		if( rStringCode.EqualsIgnoreCaseAscii( pInfo->mpStringCode ) )
+			break;
+		i++;
+	}
+	return pInfo;
+}
+
+// From methods.cxx
+BOOL implDateSerial( INT16 nYear, INT16 nMonth, INT16 nDay, double& rdRet );
+INT16 implGetDateDay( double aDate );
+INT16 implGetDateMonth( double aDate );
+INT16 implGetDateYear( double aDate );
+
+INT16 implGetHour( double dDate );
+INT16 implGetMinute( double dDate );
+INT16 implGetSecond( double dDate );
+
+
+inline void implGetDayMonthYear( INT16& rnYear, INT16& rnMonth, INT16& rnDay, double dDate )
+{
+	rnDay   = implGetDateDay( dDate );
+	rnMonth = implGetDateMonth( dDate );
+	rnYear  = implGetDateYear( dDate );
+}
+
+inline INT16 limitToINT16( INT32 n32 )
+{
+	if( n32 > 32767 )
+		n32 = 32767;
+	else if( n32 < -32768 )
+		n32 = -32768;
+	return (INT16)n32;
+}
+
+RTLFUNC(DateAdd)
+{
+    (void)pBasic;
+    (void)bWrite;
+    
+	USHORT nParCount = rPar.Count();
+	if( nParCount != 4 )
+	{
+		StarBASIC::Error( SbERR_BAD_ARGUMENT );
+		return;
+	}
+
+	String aStringCode = rPar.Get(1)->GetString();
+	IntervalInfo* pInfo = getIntervalInfo( aStringCode );
+	if( !pInfo )
+	{
+		StarBASIC::Error( SbERR_BAD_ARGUMENT );
+		return;
+	}
+
+	INT32 lNumber = rPar.Get(2)->GetLong();
+	double dDate = rPar.Get(3)->GetDate();
+	double dNewDate = 0;
+	if( pInfo->mbSimple )
+	{
+		double dAdd = pInfo->mdValue * lNumber;
+		dNewDate = dDate + dAdd;
+	}
+	else
+	{
+		// Keep hours, minutes, seconds
+		double dHoursMinutesSeconds = dDate - floor( dDate );
+
+		BOOL bOk = TRUE;
+		INT16 nYear, nMonth, nDay;
+		INT16 nTargetYear16 = 0, nTargetMonth = 0;
+		implGetDayMonthYear( nYear, nMonth, nDay, dDate );
+		switch( pInfo->meInterval )
+		{
+			case INTERVAL_YYYY:
+			{
+				INT32 nTargetYear = lNumber + nYear;
+				nTargetYear16 = limitToINT16( nTargetYear );
+				nTargetMonth = nMonth;
+				bOk = implDateSerial( nTargetYear16, nTargetMonth, nDay, dNewDate );
+				break;
+			}
+			case INTERVAL_Q:
+			case INTERVAL_M:
+			{
+				bool bNeg = (lNumber < 0);
+				if( bNeg )
+					lNumber = -lNumber;
+				INT32 nYearsAdd;
+				INT16 nMonthAdd;
+				if( pInfo->meInterval == INTERVAL_Q )
+				{
+					nYearsAdd = lNumber / 4;
+					nMonthAdd = (INT16)( 3 * (lNumber % 4) );
+				}
+				else
+				{
+					nYearsAdd = lNumber / 12;
+					nMonthAdd = (INT16)( lNumber % 12 );
+				}
+
+				INT32 nTargetYear;
+				if( bNeg )
+				{
+					nTargetMonth = nMonth - nMonthAdd;
+					if( nTargetMonth <= 0 )
+					{
+						nTargetMonth += 12;
+						nYearsAdd++;
+					}
+					nTargetYear = (INT32)nYear - nYearsAdd;
+				}
+				else
+				{
+					nTargetMonth = nMonth + nMonthAdd;
+					if( nTargetMonth > 12 )
+					{
+						nTargetMonth -= 12;
+						nYearsAdd++;
+					}
+					nTargetYear = (INT32)nYear + nYearsAdd;
+				}
+				nTargetYear16 = limitToINT16( nTargetYear );
+				bOk = implDateSerial( nTargetYear16, nTargetMonth, nDay, dNewDate );
+				break;
+			}
+			default: break;
+		}
+
+		if( bOk )
+		{
+			// Overflow?
+			INT16 nNewYear, nNewMonth, nNewDay;
+			implGetDayMonthYear( nNewYear, nNewMonth, nNewDay, dNewDate );
+			if( nNewYear > 9999 || nNewYear < 100 )
+			{
+				StarBASIC::Error( SbERR_BAD_ARGUMENT );
+				return;
+			}
+			INT16 nCorrectionDay = nDay;
+			while( nNewMonth > nTargetMonth )
+			{
+				nCorrectionDay--;
+				implDateSerial( nTargetYear16, nTargetMonth, nCorrectionDay, dNewDate );
+				implGetDayMonthYear( nNewYear, nNewMonth, nNewDay, dNewDate );
+			}
+			dNewDate += dHoursMinutesSeconds;
+		}
+	}
+
+	rPar.Get(0)->PutDate( dNewDate );
+}
+
+inline double RoundImpl( double d )
+{
+	return ( d >= 0 ) ? floor( d + 0.5 ) : -floor( -d + 0.5 );
+}
+
+RTLFUNC(DateDiff)
+{
+    (void)pBasic;
+    (void)bWrite;
+    
+	// DateDiff(interval, date1, date2[, firstdayofweek[, firstweekofyear]])
+
+	USHORT nParCount = rPar.Count();
+	if( nParCount < 4 || nParCount > 6 )
+	{
+		StarBASIC::Error( SbERR_BAD_ARGUMENT );
+		return;
+	}
+
+	String aStringCode = rPar.Get(1)->GetString();
+	IntervalInfo* pInfo = getIntervalInfo( aStringCode );
+	if( !pInfo )
+	{
+		StarBASIC::Error( SbERR_BAD_ARGUMENT );
+		return;
+	}
+
+	double dDate1 = rPar.Get(2)->GetDate();
+	double dDate2 = rPar.Get(3)->GetDate();
+
+	double dRet = 0.0;
+	switch( pInfo->meInterval )
+	{
+		case INTERVAL_YYYY:
+		{
+			INT16 nYear1 = implGetDateYear( dDate1 );
+			INT16 nYear2 = implGetDateYear( dDate2 );
+			dRet = nYear2 - nYear1;
+			break;
+		}
+		case INTERVAL_Q:
+		{
+			INT16 nYear1 = implGetDateYear( dDate1 );
+			INT16 nYear2 = implGetDateYear( dDate2 );
+			INT16 nQ1 = 1 + (implGetDateMonth( dDate1 ) - 1) / 3;
+			INT16 nQ2 = 1 + (implGetDateMonth( dDate2 ) - 1) / 3;
+			INT16 nQGes1 = 4 * nYear1 + nQ1;
+			INT16 nQGes2 = 4 * nYear2 + nQ2;
+			dRet = nQGes2 - nQGes1;
+			break;
+		}
+		case INTERVAL_M:
+		{
+			INT16 nYear1 = implGetDateYear( dDate1 );
+			INT16 nYear2 = implGetDateYear( dDate2 );
+			INT16 nMonth1 = implGetDateMonth( dDate1 );
+			INT16 nMonth2 = implGetDateMonth( dDate2 );
+			INT16 nMonthGes1 = 12 * nYear1 + nMonth1;
+			INT16 nMonthGes2 = 12 * nYear2 + nMonth2;
+			dRet = nMonthGes2 - nMonthGes1;
+			break;
+		}
+		case INTERVAL_Y:
+		case INTERVAL_D:
+		{
+			double dDays1 = floor( dDate1 );
+			double dDays2 = floor( dDate2 );
+			dRet = dDays2 - dDays1;
+			break;
+		}
+		case INTERVAL_W:
+		case INTERVAL_WW:
+		{
+			double dDays1 = floor( dDate1 );
+			double dDays2 = floor( dDate2 );
+			if( pInfo->meInterval == INTERVAL_WW )
+			{
+				INT16 nFirstDay = 1;	// Default
+				if( nParCount >= 5 )
+				{
+					nFirstDay = rPar.Get(4)->GetInteger();
+					if( nFirstDay < 0 || nFirstDay > 7 )
+					{
+						StarBASIC::Error( SbERR_BAD_ARGUMENT );
+						return;
+					}
+					if( nFirstDay == 0 )
+					{
+						Reference< XCalendar > xCalendar = getLocaleCalendar();
+						if( !xCalendar.is() )
+						{
+							StarBASIC::Error( SbERR_INTERNAL_ERROR );
+							return;
+						}
+						nFirstDay = INT16( xCalendar->getFirstDayOfWeek() + 1 );
+					}
+				}
+				INT16 nDay1 = implGetWeekDay( dDate1 );
+				INT16 nDay1_Diff = nDay1 - nFirstDay;
+				if( nDay1_Diff < 0 )
+					nDay1_Diff += 7;
+				dDays1 -= nDay1_Diff;
+
+				INT16 nDay2 = implGetWeekDay( dDate2 );
+				INT16 nDay2_Diff = nDay2 - nFirstDay;
+				if( nDay2_Diff < 0 )
+					nDay2_Diff += 7;
+				dDays2 -= nDay2_Diff;
+			}
+
+			double dDiff = dDays2 - dDays1;
+			dRet = ( dDiff >= 0 ) ? floor( dDiff / 7.0 ) : -floor( -dDiff / 7.0 );
+			break;
+		}
+		case INTERVAL_H:
+		{
+			double dFactor = 24.0;
+			dRet = RoundImpl( dFactor * (dDate2 - dDate1) );
+			break;
+		}
+		case INTERVAL_N:
+		{
+			double dFactor =1440.0;
+			dRet = RoundImpl( dFactor * (dDate2 - dDate1) );
+			break;
+		}
+		case INTERVAL_S:
+		{
+			double dFactor = 86400.0;
+			dRet = RoundImpl( dFactor * (dDate2 - dDate1) );
+			break;
+		}
+		case INTERVAL_NONE:
+			break;
+	}
+	rPar.Get(0)->PutDouble( dRet );
+}
+
+double implGetDateOfFirstDayInFirstWeek
+	( INT16 nYear, INT16& nFirstDay, INT16& nFirstWeek, bool* pbError = NULL )
+{
+	SbError nError = 0;
+	if( nFirstDay < 0 || nFirstDay > 7 )
+		nError = SbERR_BAD_ARGUMENT;
+
+	if( nFirstWeek < 0 || nFirstWeek > 3 )
+		nError = SbERR_BAD_ARGUMENT;
+
+	Reference< XCalendar > xCalendar;
+	if( nFirstDay == 0 || nFirstWeek == 0 )
+	{
+		xCalendar = getLocaleCalendar();
+		if( !xCalendar.is() )
+			nError = SbERR_BAD_ARGUMENT;
+	}
+
+	if( nError != 0 )
+	{
+		StarBASIC::Error( nError );
+		if( pbError )
+			*pbError = true;
+		return 0.0;
+	}
+
+	if( nFirstDay == 0 )
+		nFirstDay = INT16( xCalendar->getFirstDayOfWeek() + 1 );
+
+	INT16 nFirstWeekMinDays = 0;	// Not used for vbFirstJan1 = default
+	if( nFirstWeek == 0 )
+	{
+		nFirstWeekMinDays =	xCalendar->getMinimumNumberOfDaysForFirstWeek();
+		if( nFirstWeekMinDays == 1 )
+		{
+			nFirstWeekMinDays = 0;
+			nFirstWeek = 1;
+		}
+		else if( nFirstWeekMinDays == 4 )
+			nFirstWeek = 2;
+		else if( nFirstWeekMinDays == 7 )
+			nFirstWeek = 3;
+	}
+	else if( nFirstWeek == 2 )
+		nFirstWeekMinDays =	4;		// vbFirstFourDays
+	else if( nFirstWeek == 3 )
+		nFirstWeekMinDays =	7;		// vbFirstFourDays
+
+	double dBaseDate;
+	implDateSerial( nYear, 1, 1, dBaseDate );
+	double dRetDate = dBaseDate;
+
+	INT16 nWeekDay0101 = implGetWeekDay( dBaseDate );
+	INT16 nDayDiff = nWeekDay0101 - nFirstDay;
+	if( nDayDiff < 0 )
+		nDayDiff += 7;
+
+	if( nFirstWeekMinDays )
+	{
+		INT16 nThisWeeksDaysInYearCount = 7 - nDayDiff;
+		if( nThisWeeksDaysInYearCount < nFirstWeekMinDays )
+			nDayDiff -= 7;
+	}
+	dRetDate = dBaseDate - nDayDiff;
+	return dRetDate;
+}
+
+RTLFUNC(DatePart)
+{
+    (void)pBasic;
+    (void)bWrite;
+    
+	// DatePart(interval, date[,firstdayofweek[, firstweekofyear]])
+
+	USHORT nParCount = rPar.Count();
+	if( nParCount < 3 || nParCount > 5 )
+	{
+		StarBASIC::Error( SbERR_BAD_ARGUMENT );
+		return;
+	}
+
+	String aStringCode = rPar.Get(1)->GetString();
+	IntervalInfo* pInfo = getIntervalInfo( aStringCode );
+	if( !pInfo )
+	{
+		StarBASIC::Error( SbERR_BAD_ARGUMENT );
+		return;
+	}
+
+	double dDate = rPar.Get(2)->GetDate();
+
+	INT32 nRet = 0;
+	switch( pInfo->meInterval )
+	{
+		case INTERVAL_YYYY:
+		{
+			nRet = implGetDateYear( dDate );
+			break;
+		}
+		case INTERVAL_Q:
+		{
+			nRet = 1 + (implGetDateMonth( dDate ) - 1) / 3;
+			break;
+		}
+		case INTERVAL_M:
+		{
+			nRet = implGetDateMonth( dDate );
+			break;
+		}
+		case INTERVAL_Y:
+		{
+			INT16 nYear = implGetDateYear( dDate );
+			double dBaseDate;
+			implDateSerial( nYear, 1, 1, dBaseDate );
+			nRet = 1 + INT32( dDate - dBaseDate );
+			break;
+		}
+		case INTERVAL_D:
+		{
+			nRet = implGetDateDay( dDate );
+			break;
+		}
+		case INTERVAL_W:
+		{
+			bool bFirstDay = false;
+			INT16 nFirstDay = 1;	// Default
+			if( nParCount >= 4 )
+			{
+				nFirstDay = rPar.Get(3)->GetInteger();
+				bFirstDay = true;
+			}
+			nRet = implGetWeekDay( dDate, bFirstDay, nFirstDay );
+			break;
+		}
+		case INTERVAL_WW:
+		{
+			INT16 nFirstDay = 1;	// Default
+			if( nParCount >= 4 )
+				nFirstDay = rPar.Get(3)->GetInteger();
+
+			INT16 nFirstWeek = 1;	// Default
+			if( nParCount == 5 )
+				nFirstWeek = rPar.Get(4)->GetInteger();
+
+			INT16 nYear = implGetDateYear( dDate );
+			bool bError = false;
+			double dYearFirstDay = implGetDateOfFirstDayInFirstWeek( nYear, nFirstDay, nFirstWeek, &bError );
+			if( !bError )
+			{
+				if( dYearFirstDay > dDate )
+				{
+					// Date belongs to last year's week
+					dYearFirstDay = implGetDateOfFirstDayInFirstWeek( nYear - 1, nFirstDay, nFirstWeek );
+				}
+				else if( nFirstWeek != 1 )
+				{
+					// Check if date belongs to next year
+					double dNextYearFirstDay = implGetDateOfFirstDayInFirstWeek( nYear + 1, nFirstDay, nFirstWeek );
+					if( dDate >= dNextYearFirstDay )
+						dYearFirstDay = dNextYearFirstDay;
+				}
+
+				// Calculate week
+				double dDiff = dDate - dYearFirstDay;
+				nRet = 1 + INT32( dDiff / 7 );
+			}
+			break;
+		}
+		case INTERVAL_H:
+		{
+			nRet = implGetHour( dDate );
+			break;
+		}
+		case INTERVAL_N:
+		{
+			nRet = implGetMinute( dDate );
+			break;
+		}
+		case INTERVAL_S:
+		{
+			nRet = implGetSecond( dDate );
+			break;
+		}
+		case INTERVAL_NONE:
+			break;
+	}
+	rPar.Get(0)->PutLong( nRet );
+}
+
+// FormatDateTime(Date[,NamedFormat])
+RTLFUNC(FormatDateTime)
+{
+    (void)pBasic;
+    (void)bWrite;
+    
+	USHORT nParCount = rPar.Count();
+	if( nParCount < 2 || nParCount > 3 )
+	{
+		StarBASIC::Error( SbERR_BAD_ARGUMENT );
+		return;
+	}
+
+	double dDate = rPar.Get(1)->GetDate();
+	INT16 nNamedFormat = 0;
+	if( nParCount > 2 )
+	{
+		nNamedFormat = rPar.Get(2)->GetInteger();
+		if( nNamedFormat < 0 || nNamedFormat > 4 )
+		{
+			StarBASIC::Error( SbERR_BAD_ARGUMENT );
+			return;
+		}
+	}
+
+	Reference< XCalendar > xCalendar = getLocaleCalendar();
+	if( !xCalendar.is() )
+	{
+		StarBASIC::Error( SbERR_INTERNAL_ERROR );
+		return;
+	}
+
+	String aRetStr;
+	SbxVariableRef pSbxVar = new SbxVariable( SbxSTRING );
+	switch( nNamedFormat )
+	{
+		// GeneralDate: 
+		// Display a date and/or time. If there is a date part, 
+		// display it as a short date. If there is a time part, 
+		// display it as a long time. If present, both parts are displayed.
+
+		// 12/21/2004 11:24:50 AM
+		// 21.12.2004 12:13:51
+		case 0:
+			pSbxVar->PutDate( dDate );
+			aRetStr = pSbxVar->GetString();
+			break;
+
+		// LongDate: Display a date using the long date format specified 
+		// in your computer's regional settings. 
+		// Tuesday, December 21, 2004
+		// Dienstag, 21. December 2004
+		case 1:
+		{
+			SvNumberFormatter* pFormatter = NULL;
+			if( pINST )
+				pFormatter = pINST->GetNumberFormatter();
+			else
+			{
+				sal_uInt32 n;	// Dummy
+				SbiInstance::PrepareNumberFormatter( pFormatter, n, n, n );
+			}
+
+	        LanguageType eLangType = GetpApp()->GetSettings().GetLanguage();
+			ULONG nIndex = pFormatter->GetFormatIndex( NF_DATE_SYSTEM_LONG, eLangType );
+			Color* pCol;
+			pFormatter->GetOutputString( dDate, nIndex, aRetStr, &pCol );
+
+			if( !pINST )
+				delete pFormatter;
+
+			break;
+		}
+
+		// ShortDate: Display a date using the short date format specified 
+		// in your computer's regional settings. 
+		// 12/21/2004
+		// 21.12.2004
+		case 2:
+			pSbxVar->PutDate( floor(dDate) );
+			aRetStr = pSbxVar->GetString();
+			break;
+
+		// LongTime: Display a time using the time format specified 
+		// in your computer's regional settings. 
+		// 11:24:50 AM
+		// 12:13:51
+		case 3:
+		// ShortTime: Display a time using the 24-hour format (hh:mm). 
+		// 11:24
+		case 4:
+			double n;
+			double dTime = modf( dDate, &n );
+			pSbxVar->PutDate( dTime );
+			if( nNamedFormat == 3 )
+				aRetStr = pSbxVar->GetString();
+			else
+				aRetStr = pSbxVar->GetString().Copy( 0, 5 );
+			break;
+	}
+
+	rPar.Get(0)->PutString( aRetStr );
+}
+
+RTLFUNC(Round)
+{
+    (void)pBasic;
+    (void)bWrite;
+    
+	USHORT nParCount = rPar.Count();
+	if( nParCount != 2 && nParCount != 3 )
+	{
+		StarBASIC::Error( SbERR_BAD_ARGUMENT );
+		return;
+	}
+
+	SbxVariable *pSbxVariable = rPar.Get(1);
+	double dVal = pSbxVariable->GetDouble();
+	double dRes = 0.0;
+	if( dVal != 0.0 )
+	{
+		bool bNeg = false;
+		if( dVal < 0.0 )
+		{
+			bNeg = true;
+			dVal = -dVal;
+		}
+
+		INT16 numdecimalplaces = 0;
+		if( nParCount == 3 )
+		{
+			numdecimalplaces = rPar.Get(2)->GetInteger();
+			if( numdecimalplaces < 0 || numdecimalplaces > 22 )
+			{
+				StarBASIC::Error( SbERR_BAD_ARGUMENT );
+				return;
+			}
+		}
+
+		if( numdecimalplaces == 0 )
+		{
+			dRes = floor( dVal + 0.5 );
+		}
+		else
+		{
+			double dFactor = pow( 10.0, numdecimalplaces );
+			dVal *= dFactor;
+			dRes = floor( dVal + 0.5 );
+			dRes /= dFactor;
+		}
+
+		if( bNeg )
+			dRes = -dRes;
+	}
+	rPar.Get(0)->PutDouble( dRes );
+}
+
+RTLFUNC(StrReverse)
+{
+    (void)pBasic;
+    (void)bWrite;
+    
+	if ( rPar.Count() != 2 )
+	{
+		StarBASIC::Error( SbERR_BAD_ARGUMENT );
+		return;
+	}
+
+	SbxVariable *pSbxVariable = rPar.Get(1);
+	if( pSbxVariable->IsNull() )
+	{
+		StarBASIC::Error( SbERR_BAD_ARGUMENT );
+		return;
+	}
+
+	String aStr = pSbxVariable->GetString();
+	aStr.Reverse();
+	rPar.Get(0)->PutString( aStr );
+}
+
+RTLFUNC(CompatibilityMode)
+{
+    (void)pBasic;
+    (void)bWrite;
+    
+	bool bEnabled = false;
+	USHORT nCount = rPar.Count();
+	if ( nCount != 1 && nCount != 2 )
+		StarBASIC::Error( SbERR_BAD_ARGUMENT );
+
+	SbiInstance* pInst = pINST;
+	if( pInst )
+	{
+		if ( nCount == 2 )
+			pInst->EnableCompatibility( rPar.Get(1)->GetBool() );
+
+		bEnabled = pInst->IsCompatibility();
+	}
+	rPar.Get(0)->PutBool( bEnabled );
+}
+
+RTLFUNC(Input)
+{
+    (void)pBasic;
+    (void)bWrite;
+    
+	// 2 parameters needed
+	if ( rPar.Count() < 3 )
+	{
+		StarBASIC::Error( SbERR_BAD_ARGUMENT );
+		return;
+	}
+
+	USHORT nByteCount  = rPar.Get(1)->GetUShort();
+	INT16  nFileNumber = rPar.Get(2)->GetInteger();
+
+	SbiIoSystem* pIosys = pINST->GetIoSystem();
+	SbiStream* pSbStrm = pIosys->GetStream( nFileNumber );
+	if ( !pSbStrm || !(pSbStrm->GetMode() & (SBSTRM_BINARY | SBSTRM_INPUT)) )
+	{
+		StarBASIC::Error( SbERR_BAD_CHANNEL );
+		return;
+	}
+
+	ByteString aByteBuffer;
+	SbError err = pSbStrm->Read( aByteBuffer, nByteCount, true );
+	if( !err )
+		err = pIosys->GetError();
+
+	if( err )
+	{
+		StarBASIC::Error( err );
+		return;
+	}
+	rPar.Get(0)->PutString( String( aByteBuffer, gsl_getSystemTextEncoding() ) );
+}
+
+// #115824
+RTLFUNC(Me)
+{
+    (void)pBasic;
+    (void)bWrite;
+    
+	SbModule* pActiveModule = pINST->GetActiveModule();
+	SbClassModuleObject* pClassModuleObject = PTR_CAST(SbClassModuleObject,pActiveModule);
+	if( pClassModuleObject == NULL )
+	{
+        SbObjModule* pMod = PTR_CAST(SbObjModule,pActiveModule);
+        if ( pMod == NULL )
+		    StarBASIC::Error( SbERR_INVALID_USAGE_OBJECT );
+        else
+        {
+            SbxVariableRef refVar = rPar.Get(0);
+            refVar->PutObject( pMod->GetObject() );
+        }
+	}
+	else
+	{
+		SbxVariableRef refVar = rPar.Get(0);
+		refVar->PutObject( pClassModuleObject );
+	}
+}
--- basic/source/basmgr/basmgr.cxx.bak	1970-01-01 08:00:00.000000000 +0800
+++ basic/source/basmgr/basmgr.cxx	2007-10-15 11:51:06.000000000 +0800
@@ -0,0 +1,2546 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile: basmgr.cxx,v $
+ *
+ *  $Revision: 1.41 $
+ *
+ *  last change: $Author: hr $ $Date: 2007/06/27 14:17:23 $
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+
+// MARKER(update_precomp.py): autogen include statement, do not remove
+#include "precompiled_basic.hxx"
+
+#ifndef _STREAM_HXX //autogen
+#include <tools/stream.hxx>
+#endif
+#ifndef _SOT_STORAGE_HXX
+#include <sot/storage.hxx>
+#endif
+#ifndef _URLOBJ_HXX //autogen
+#include <tools/urlobj.hxx>
+#endif
+#ifndef _SFXSMPLHINT_HXX //autogen
+#include <svtools/smplhint.hxx>
+#endif
+#ifndef _SV_SVAPP_HXX //autogen
+#include <vcl/svapp.hxx>
+#endif
+#ifndef _SV_WINDOW_HXX //autogen
+#include <vcl/window.hxx>
+#endif
+#ifndef _SV_WRKWIN_HXX //autogen
+#include <vcl/wrkwin.hxx>
+#endif
+#ifndef _SV_MSGBOX_HXX //autogen
+#include <vcl/msgbox.hxx>
+#endif
+#ifndef _SBXCLASS_HXX //autogen
+#include <basic/sbx.hxx>
+#endif
+#ifndef _SOT_STORINFO_HXX //autogen
+#include <sot/storinfo.hxx>
+#endif
+#ifndef INCLUDED_SVTOOLS_PATHOPTIONS_HXX
+#include <svtools/pathoptions.hxx>
+#endif
+#ifndef _TOOLS_DEBUG_HXX
+#include <tools/debug.hxx>
+#endif
+#ifndef TOOLS_DIAGNOSE_EX_H
+#include <tools/diagnose_ex.h>
+#endif
+
+#ifndef _SB_SBMOD_HXX
+#include <basic/sbmod.hxx>
+#endif
+
+#include <basic/sbuno.hxx>
+#include <basic/basmgr.hxx>
+#include "basrid.hxx"
+#include "sbintern.hxx"
+#include <sb.hrc>
+
+
+#define LIB_SEP			0x01
+#define LIBINFO_SEP		0x02
+#define LIBINFO_ID		0x1491
+#define PASSWORD_MARKER	0x31452134
+
+
+// Library API, implemented for XML import/export
+
+#include <com/sun/star/container/XNameContainer.hpp>
+#include <com/sun/star/container/XContainer.hpp>
+#include <com/sun/star/script/XStarBasicAccess.hpp>
+#include <com/sun/star/script/XStarBasicModuleInfo.hpp>
+#include <com/sun/star/script/XStarBasicDialogInfo.hpp>
+#include <com/sun/star/script/XStarBasicLibraryInfo.hpp>
+#include <com/sun/star/script/XLibraryContainerPassword.hpp>
+#include <com/sun/star/script/ModuleInfo.hpp>
+
+#include <cppuhelper/implbase1.hxx>
+
+using com::sun::star::uno::Reference;
+using namespace com::sun::star::container;
+using namespace com::sun::star::uno;
+using namespace com::sun::star::lang;
+using namespace com::sun::star::script;
+using namespace cppu;
+using namespace rtl;
+
+typedef WeakImplHelper1< XNameContainer > NameContainerHelper;
+typedef WeakImplHelper1< XStarBasicModuleInfo > ModuleInfoHelper;
+typedef WeakImplHelper1< XStarBasicDialogInfo > DialogInfoHelper;
+typedef WeakImplHelper1< XStarBasicLibraryInfo > LibraryInfoHelper;
+typedef WeakImplHelper1< XStarBasicAccess > StarBasicAccessHelper;
+
+
+
+#define CURR_VER		2
+
+// Version 1
+//	  ULONG 	nEndPos
+//	  USHORT 	nId
+//	  USHORT	nVer
+//	  BOOL		bDoLoad
+//	  String	LibName
+//	  String	AbsStorageName
+//	  String	RelStorageName
+// Version 2
+//	+ BOOL		bReference
+
+static const char* szStdLibName = "Standard";
+static const char* szBasicStorage = "StarBASIC";
+static const char* szOldManagerStream = "BasicManager";
+static const char* szManagerStream = "BasicManager2";
+static const char* szImbedded = "LIBIMBEDDED";
+static const char* szCryptingKey = "CryptedBasic";
+static const char* szScriptLanguage = "StarBasic";
+
+static const String BasicStreamName( String::CreateFromAscii(szBasicStorage) );
+static const String ManagerStreamName( String::CreateFromAscii(szManagerStream) );
+
+enum ModuleType { Unknown = 0, Normal, Class, Form, Document };
+
+#define	DEFINE_CONST_UNICODE(CONSTASCII)    UniString(RTL_CONSTASCII_USTRINGPARAM(CONSTASCII))
+
+
+TYPEINIT1( BasicManager, SfxBroadcaster );
+DBG_NAME( BasicManager );
+
+StreamMode eStreamReadMode = STREAM_READ | STREAM_NOCREATE | STREAM_SHARE_DENYALL;
+StreamMode eStorageReadMode = STREAM_READ | STREAM_SHARE_DENYWRITE;
+
+DECLARE_LIST( BasErrorLst, BasicError* )
+
+
+//----------------------------------------------------------------------------
+// BasicManager impl data
+struct BasicManagerImpl
+{
+    LibraryContainerInfo    maContainerInfo;
+
+    // Save stream data
+    SvMemoryStream*  mpManagerStream;
+    SvMemoryStream** mppLibStreams;
+    sal_Int32        mnLibStreamCount;
+    sal_Bool         mbModifiedByLibraryContainer;
+    sal_Bool         mbError;
+
+	BasicManagerImpl( void )
+        : mpManagerStream( NULL )
+        , mppLibStreams( NULL )
+        , mnLibStreamCount( 0 )
+        , mbModifiedByLibraryContainer( sal_False )
+        , mbError( sal_False )
+	{}
+    ~BasicManagerImpl();
+};
+
+BasicManagerImpl::~BasicManagerImpl()
+{
+    delete mpManagerStream;
+    if( mppLibStreams )
+    {
+        for( sal_Int32 i = 0 ; i < mnLibStreamCount ; i++ )
+            delete mppLibStreams[i];
+        delete[] mppLibStreams;
+    }
+}
+
+//============================================================================
+// BasMgrContainerListenerImpl
+//============================================================================
+
+typedef ::cppu::WeakImplHelper1< ::com::sun::star::container::XContainerListener > ContainerListenerHelper;
+
+class BasMgrContainerListenerImpl: public ContainerListenerHelper
+{
+	BasicManager* mpMgr;
+	OUString maLibName;		// empty -> no lib, but lib container
+
+public:
+	BasMgrContainerListenerImpl( BasicManager* pMgr, OUString aLibName )
+        : mpMgr( pMgr )
+        , maLibName( aLibName ) {}
+
+	static void insertLibraryImpl( const Reference< XLibraryContainer >& xScriptCont, BasicManager* pMgr,
+		Any aLibAny, OUString aLibName );
+	static void addLibraryModulesImpl( BasicManager* pMgr, Reference< XNameAccess > xLibNameAccess,
+		OUString aLibName );
+
+
+	// XEventListener
+	virtual void SAL_CALL disposing( const  ::com::sun::star::lang::EventObject& Source )
+		throw(::com::sun::star::uno::RuntimeException);
+
+	// XContainerListener
+	virtual void SAL_CALL elementInserted( const ::com::sun::star::container::ContainerEvent& Event )
+		throw(::com::sun::star::uno::RuntimeException);
+	virtual void SAL_CALL elementReplaced( const ::com::sun::star::container::ContainerEvent& Event )
+		throw(::com::sun::star::uno::RuntimeException);
+	virtual void SAL_CALL elementRemoved( const ::com::sun::star::container::ContainerEvent& Event )
+		throw(::com::sun::star::uno::RuntimeException);
+};
+
+
+//============================================================================
+// BasMgrContainerListenerImpl
+//============================================================================
+
+void BasMgrContainerListenerImpl::insertLibraryImpl( const Reference< XLibraryContainer >& xScriptCont,
+	BasicManager* pMgr, Any aLibAny, OUString aLibName )
+{
+	Reference< XNameAccess > xLibNameAccess;
+	aLibAny >>= xLibNameAccess;
+
+	if( !pMgr->GetLib( aLibName ) )
+	{
+        BasicManager* pBasMgr = static_cast< BasicManager* >( pMgr );
+#ifdef DBG_UTIL
+		StarBASIC* pLib = 
+#endif
+		pBasMgr->CreateLibForLibContainer( aLibName, xScriptCont );
+		DBG_ASSERT( pLib, "XML Import: Basic library could not be created");
+	}
+
+	Reference< XContainer> xLibContainer( xLibNameAccess, UNO_QUERY );
+	if( xLibContainer.is() )
+	{
+		// Register listener for library
+		Reference< XContainerListener > xLibraryListener
+			= static_cast< XContainerListener* >
+				( new BasMgrContainerListenerImpl( pMgr, aLibName ) );
+		xLibContainer->addContainerListener( xLibraryListener );
+	}
+
+	if( xScriptCont->isLibraryLoaded( aLibName ) )
+	{
+		addLibraryModulesImpl( pMgr, xLibNameAccess, aLibName );
+	}
+}
+
+
+void BasMgrContainerListenerImpl::addLibraryModulesImpl( BasicManager* pMgr,
+	Reference< XNameAccess > xLibNameAccess, OUString aLibName )
+{
+	Sequence< OUString > aModuleNames = xLibNameAccess->getElementNames();
+	sal_Int32 nModuleCount = aModuleNames.getLength();
+
+	StarBASIC* pLib = pMgr->GetLib( aLibName );
+	DBG_ASSERT( pLib, "BasMgrContainerListenerImpl::addLibraryModulesImpl: Unknown lib!");
+	if( pLib )
+	{
+		const OUString* pNames = aModuleNames.getConstArray();
+		for( sal_Int32 j = 0 ; j < nModuleCount ; j++ )
+		{
+			OUString aModuleName = pNames[ j ];
+			Any aElement = xLibNameAccess->getByName( aModuleName );
+            ModuleInfo mInfo;
+			OUString aMod;
+            sal_Int16 mType;
+            if ( aElement >>= mInfo )
+            {
+                aMod = mInfo.ModuleSource;
+                mType = mInfo.ModuleType;
+                OSL_TRACE("#1 - aMod");
+                //pLib->MakeModule32( aModuleName, aMod, SBXID_DOCUMENTMOD );
+                pLib->MakeObjModule( aModuleName, mInfo );
+            }
+            else
+            {
+			    aElement >>= aMod;
+			    pLib->MakeModule32( aModuleName, aMod );
+            }
+		}
+	}
+
+	pLib->SetModified( FALSE );
+}
+
+
+
+// XEventListener
+//----------------------------------------------------------------------------
+
+void SAL_CALL BasMgrContainerListenerImpl::disposing( const  EventObject& Source )
+	throw( RuntimeException )
+{
+    (void)Source;
+}
+
+// XContainerListener
+//----------------------------------------------------------------------------
+
+void SAL_CALL BasMgrContainerListenerImpl::elementInserted( const ContainerEvent& Event )
+	throw( RuntimeException )
+{
+	sal_Bool bLibContainer = ( maLibName.getLength() == 0 );
+	OUString aName;
+	Event.Accessor >>= aName;
+
+    mpMgr->mpImpl->mbModifiedByLibraryContainer = sal_True;
+
+	if( bLibContainer )
+	{
+        Reference< XLibraryContainer > xScriptCont( Event.Source, UNO_QUERY );
+		insertLibraryImpl( xScriptCont, mpMgr, Event.Element, aName );
+	}
+	else
+	{
+        ModuleInfo mInfo;
+		OUString aMod;
+        sal_Int16 mType;
+        if( Event.Element >>= mInfo )
+        {
+            aMod = mInfo.ModuleSource;
+            mType = mInfo.ModuleType;
+        }
+        else
+		    Event.Element >>= aMod;
+
+		StarBASIC* pLib = mpMgr->GetLib( maLibName );
+		DBG_ASSERT( pLib, "BasMgrContainerListenerImpl::elementInserted: Unknown lib!");
+		if( pLib )
+		{
+    		SbModule* pMod = pLib->FindModule( aName );
+            if( !pMod )
+            {
+                if ( mType == Document )
+                {
+                    //pLib->MakeModule32( aName, aMod, SBXID_DOCUMENTMOD );
+                    pLib->MakeObjModule( aName, mInfo );
+                }
+                else
+                {
+			        pLib->MakeModule32( aName, aMod );
+                }
+			    pLib->SetModified( FALSE );
+            }
+		}
+	}
+}
+
+//----------------------------------------------------------------------------
+
+void SAL_CALL BasMgrContainerListenerImpl::elementReplaced( const ContainerEvent& Event )
+	throw( RuntimeException )
+{
+	OUString aName;
+	Event.Accessor >>= aName;
+
+    mpMgr->mpImpl->mbModifiedByLibraryContainer = sal_True;
+
+	// Replace not possible for library container
+#ifdef DBG_UTIL
+	sal_Bool bLibContainer = ( maLibName.getLength() == 0 );
+#endif
+    DBG_ASSERT( !bLibContainer, "library container fired elementReplaced()");
+
+	StarBASIC* pLib = mpMgr->GetLib( maLibName );
+	if( pLib )
+	{
+		SbModule* pMod = pLib->FindModule( aName );
+        ModuleInfo mInfo;
+		OUString aMod;
+        sal_Int16 mType;
+		Event.Element >>= aMod;
+		if( pMod )
+			pMod->SetSource32( aMod );
+		else
+        {
+            if( Event.Element >>= mInfo )
+            {
+                aMod = mInfo.ModuleSource;
+                mType = mInfo.ModuleType;
+                //pLib->MakeModule32( aName, aMod, SBXID_DOCUMENTMOD );
+                pLib->MakeObjModule( aName, mInfo );
+            }
+            else
+            {
+                Event.Element >>= aMod;
+			    pLib->MakeModule32( aName, aMod );
+            }
+        }
+
+		pLib->SetModified( FALSE );
+	}
+}
+
+//----------------------------------------------------------------------------
+
+void SAL_CALL BasMgrContainerListenerImpl::elementRemoved( const ContainerEvent& Event )
+	throw( RuntimeException )
+{
+	OUString aName;
+	Event.Accessor >>= aName;
+
+    mpMgr->mpImpl->mbModifiedByLibraryContainer = sal_True;
+
+	sal_Bool bLibContainer = ( maLibName.getLength() == 0 );
+	if( bLibContainer )
+	{
+		StarBASIC* pLib = mpMgr->GetLib( aName );
+		if( pLib )
+		{
+			USHORT nLibId = mpMgr->GetLibId( aName );
+			mpMgr->RemoveLib( nLibId, FALSE );
+		}
+	}
+	else
+	{
+		StarBASIC* pLib = mpMgr->GetLib( maLibName );
+		SbModule* pMod = pLib ? pLib->FindModule( aName ) : NULL;
+		if( pMod )
+		{
+			pLib->Remove( pMod );
+			pLib->SetModified( FALSE );
+		}
+	}
+}
+
+
+//=====================================================================
+
+class BasicErrorManager
+{
+private:
+	BasErrorLst	aErrorList;
+
+public:
+				~BasicErrorManager();
+
+	void		Reset();
+	void		InsertError( const BasicError& rError );
+
+	BOOL		HasErrors()			{ return (BOOL)aErrorList.Count(); }
+	BasicError*	GetFirstError()		{ return aErrorList.First(); }
+	BasicError*	GetNextError()		{ return aErrorList.Next(); }
+};
+
+
+BasicErrorManager::~BasicErrorManager()
+{
+	Reset();
+}
+
+void BasicErrorManager::Reset()
+{
+	BasicError* pError = (BasicError*)aErrorList.First();
+	while ( pError )
+	{
+		delete pError;
+		pError = (BasicError*)aErrorList.Next();
+	}
+	aErrorList.Clear();
+}
+
+void BasicErrorManager::InsertError( const BasicError& rError )
+{
+	aErrorList.Insert( new BasicError( rError ), LIST_APPEND );
+}
+
+
+BasicError::BasicError()
+{
+	nErrorId	= 0;
+	nReason 	= 0;
+}
+
+BasicError::BasicError( ULONG nId, USHORT nR, const String& rErrStr ) :
+	aErrStr( rErrStr )
+{
+	nErrorId 	= nId;
+	nReason 	= nR;
+}
+
+BasicError::BasicError( const BasicError& rErr ) :
+	aErrStr( rErr.aErrStr )
+{
+	nErrorId 	= rErr.nErrorId;
+	nReason		= rErr.nReason;
+}
+
+
+class BasicLibInfo
+{
+private:
+	StarBASICRef	xLib;
+	String			aLibName;
+	String			aStorageName;	// String reicht, da zur Laufzeit eindeutig.
+	String			aRelStorageName;
+	String			aPassword;
+
+	BOOL			bDoLoad;
+	BOOL			bReference;
+	BOOL			bPasswordVerified;
+	BOOL			bFoundInPath;	// Darf dann nicht neu relativiert werden!
+
+    // Lib represents library in new UNO library container
+    Reference< XLibraryContainer > mxScriptCont;
+
+public:
+	BasicLibInfo();
+	BasicLibInfo( const String& rStorageName );
+
+	BOOL			IsReference() const		{ return bReference; }
+	BOOL&			IsReference()			{ return bReference; }
+
+	BOOL			IsExtern() const 		{ return ! aStorageName.EqualsAscii(szImbedded); }
+
+	void			SetStorageName( const String& rName )	{ aStorageName = rName; }
+	const String&	GetStorageName() const					{ return aStorageName; }
+
+	void			SetRelStorageName( const String& rN )	{ aRelStorageName = rN; }
+	const String&	GetRelStorageName()	const				{ return aRelStorageName; }
+	void			CalcRelStorageName( const String& rMgrStorageName );
+
+	StarBASICRef	GetLib() const
+    {
+        if( mxScriptCont.is() && mxScriptCont->hasByName( aLibName ) &&
+            !mxScriptCont->isLibraryLoaded( aLibName ) )
+                return StarBASICRef();
+        return xLib;
+    }
+	StarBASICRef&	GetLibRef()							{ return xLib; }
+	void			SetLib( StarBASIC* pBasic )			{ xLib = pBasic; }
+
+	const String&	GetLibName() const					{ return aLibName; }
+	void			SetLibName( const String& rName )	{ aLibName = rName; }
+
+	// Nur temporaer fuer Laden/Speichern....
+	BOOL			DoLoad()							{ return bDoLoad; }
+
+	BOOL			HasPassword() const 				{ return aPassword.Len() != 0; }
+	const String&	GetPassword() const					{ return aPassword; }
+	void			SetPassword( const String& rNewPassword )
+														{ aPassword = rNewPassword;	}
+	BOOL			IsPasswordVerified() const			{ return bPasswordVerified; }
+	void			SetPasswordVerified()				{ bPasswordVerified = TRUE; }
+
+	BOOL			IsFoundInPath() const				{ return bFoundInPath; }
+	void			SetFoundInPath( BOOL bInPath )		{ bFoundInPath = bInPath; }
+
+	void 					Store( SotStorageStream& rSStream, const String& rBasMgrStorageName, BOOL bUseOldReloadInfo );
+	static BasicLibInfo*	Create( SotStorageStream& rSStream );
+
+    Reference< XLibraryContainer > GetLibraryContainer( void )
+        { return mxScriptCont; }
+    void SetLibraryContainer( const Reference< XLibraryContainer >& xScriptCont )
+        { mxScriptCont = xScriptCont; }
+};
+
+DECLARE_LIST( BasicLibsBase, BasicLibInfo* )
+
+class BasicLibs : public BasicLibsBase
+{
+public:
+	String	aBasicLibPath;		// soll eigentlich Member vom Manager werden, aber jetzt nicht inkompatibel!
+};
+
+BasicLibInfo::BasicLibInfo()
+{
+	bReference 			= FALSE;
+	bPasswordVerified 	= FALSE;
+	bDoLoad 			= FALSE;
+	bFoundInPath		= FALSE;
+    mxScriptCont    	= NULL;
+	aStorageName 		= String::CreateFromAscii(szImbedded);
+	aRelStorageName 	= String::CreateFromAscii(szImbedded);
+}
+
+BasicLibInfo::BasicLibInfo( const String& rStorageName )
+{
+	bReference 			= TRUE;
+	bPasswordVerified 	= FALSE;
+	bDoLoad 			= FALSE;
+    mxScriptCont    	= NULL;
+	aStorageName 		= rStorageName;
+}
+
+void BasicLibInfo::Store( SotStorageStream& rSStream, const String& rBasMgrStorageName, BOOL bUseOldReloadInfo )
+{
+	ULONG nStartPos = rSStream.Tell();
+	sal_uInt32 nEndPos = 0;
+
+	USHORT nId = LIBINFO_ID;
+	USHORT nVer = CURR_VER;
+
+	rSStream << nEndPos;
+	rSStream << nId;
+	rSStream << nVer;
+
+    String aCurStorageName = INetURLObject(rBasMgrStorageName, INET_PROT_FILE).GetMainURL( INetURLObject::NO_DECODE );
+    DBG_ASSERT(aCurStorageName.Len() != 0, "Bad storage name");
+
+	// Falls nicht gesetzt, StorageName initialisieren
+	if ( aStorageName.Len() == 0 )
+        aStorageName = aCurStorageName;
+
+	// Wieder laden?
+	BOOL bDoLoad_ = xLib.Is();
+	if ( bUseOldReloadInfo )
+		bDoLoad_ = DoLoad();
+	rSStream << bDoLoad_;
+
+	// Den Namen der Lib...
+	rSStream.WriteByteString(GetLibName());
+
+	// Absoluter Pfad....
+	if ( ! GetStorageName().EqualsAscii(szImbedded) )
+	{
+        String aSName = INetURLObject( GetStorageName(), INET_PROT_FILE).GetMainURL( INetURLObject::NO_DECODE );
+        DBG_ASSERT(aSName.Len() != 0, "Bad storage name");
+        rSStream.WriteByteString( aSName );
+	}
+	else
+		rSStream.WriteByteString( szImbedded );
+
+	// Relativer Pfad...
+	if ( ( aStorageName == aCurStorageName ) || ( aStorageName.EqualsAscii(szImbedded) ) )
+		rSStream.WriteByteString( szImbedded );
+	else
+	{
+		// Nicht den relativen Pfad ermitteln, wenn die Datei nur im Pfad
+		// gefunden wurde: Dann andert sich der relative Pfad und nach einem
+		// verschieben der Libs in einen anderen Pfad werden sie nicht gefunden.
+		if ( !IsFoundInPath() )
+			CalcRelStorageName( aCurStorageName );
+		rSStream.WriteByteString(aRelStorageName);
+	}
+
+	// ------------------------------
+	// Version 2
+	// ------------------------------
+
+	// Referenz...
+	rSStream << bReference;
+
+	// ------------------------------
+	// Schluss
+	// ------------------------------
+
+	nEndPos = rSStream.Tell();
+	rSStream.Seek( nStartPos );
+	rSStream << nEndPos;
+	rSStream.Seek( nEndPos );
+}
+
+BasicLibInfo* BasicLibInfo::Create( SotStorageStream& rSStream )
+{
+	BasicLibInfo* pInfo = new BasicLibInfo;
+
+	sal_uInt32 nEndPos;
+	USHORT nId;
+	USHORT nVer;
+
+	rSStream >> nEndPos;
+	rSStream >> nId;
+	rSStream >> nVer;
+
+	DBG_ASSERT( nId == LIBINFO_ID, "Keine BasicLibInfo !?" );
+	if( nId == LIBINFO_ID )
+	{
+		// Wieder laden?
+		BOOL bDoLoad;
+		rSStream >> bDoLoad;
+		pInfo->bDoLoad = bDoLoad;
+
+		// Den Namen der Lib...
+		String aName;
+		rSStream.ReadByteString(aName);
+		pInfo->SetLibName( aName );
+
+		// Absoluter Pfad....
+		String aStorageName;
+		rSStream.ReadByteString(aStorageName);
+		pInfo->SetStorageName( aStorageName );
+
+		// Relativer Pfad...
+		String aRelStorageName;
+		rSStream.ReadByteString(aRelStorageName);
+		pInfo->SetRelStorageName( aRelStorageName );
+
+		if ( nVer >= 2 )
+		{
+			BOOL bReferenz;
+			rSStream >> bReferenz;
+			pInfo->IsReference() = bReferenz;
+		}
+
+		rSStream.Seek( nEndPos );
+	}
+	return pInfo;
+}
+
+void BasicLibInfo::CalcRelStorageName( const String& rMgrStorageName )
+{
+	if ( rMgrStorageName.Len() )
+	{
+        INetURLObject aAbsURLObj( rMgrStorageName );
+		aAbsURLObj.removeSegment();
+		String aPath = aAbsURLObj.GetMainURL( INetURLObject::NO_DECODE );
+		UniString aRelURL = INetURLObject::GetRelURL( aPath, GetStorageName() );
+        SetRelStorageName( aRelURL );
+	}
+	else
+		SetRelStorageName( String() );
+}
+BasicManager::BasicManager( SotStorage& rStorage, const String& rBaseURL, StarBASIC* pParentFromStdLib, String* pLibPath, BOOL bDocMgr ) : mbDocMgr( bDocMgr )
+{
+	DBG_CTOR( BasicManager, 0 );
+
+	Init();
+
+	if( pLibPath )
+		pLibs->aBasicLibPath = *pLibPath;
+
+    String aStorName( rStorage.GetName() );
+    maStorageName = INetURLObject(aStorName, INET_PROT_FILE).GetMainURL( INetURLObject::NO_DECODE );
+
+    // #91251: Storage name not longer available for documents < 5.0
+    // Should be no real problem, because only relative storage names
+    // (links) can be affected.
+    // DBG_ASSERT( aStorName.Len(), "No Storage Name!" );
+    // DBG_ASSERT(aStorageName.Len() != 0, "Bad storage name");
+
+	// Wenn es den Manager-Stream nicht gibt, sind keine weiteren
+	// Aktionen noetig.
+	if ( rStorage.IsStream( ManagerStreamName ) )
+	{
+        LoadBasicManager( rStorage, rBaseURL );
+		// StdLib erhaelt gewuenschten Parent:
+		StarBASIC* pStdLib = GetStdLib();
+		DBG_ASSERT( pStdLib, "Standard-Lib nicht geladen?" );
+		if ( !pStdLib )
+		{
+			// Sollte eigentlich nie passieren, aber dann wenigstens nicht abstuerzen...
+			pStdLib = new StarBASIC( NULL, mbDocMgr );
+			BasicLibInfo* pStdLibInfo = pLibs->GetObject( 0 );
+			if ( !pStdLibInfo )
+				pStdLibInfo = CreateLibInfo();
+			pStdLibInfo->SetLib( pStdLib );
+            StarBASICRef xStdLib = pStdLibInfo->GetLib();
+			xStdLib->SetName( String::CreateFromAscii(szStdLibName) );
+			pStdLibInfo->SetLibName( String::CreateFromAscii(szStdLibName) );
+			xStdLib->SetFlag( SBX_DONTSTORE | SBX_EXTSEARCH );
+			xStdLib->SetModified( FALSE );
+		}
+		else
+		{
+			pStdLib->SetParent( pParentFromStdLib );
+			// Die anderen erhalten die StdLib als Parent:
+			for ( USHORT nBasic = 1; nBasic < GetLibCount(); nBasic++ )
+			{
+				StarBASIC* pBasic = GetLib( nBasic );
+				if ( pBasic )
+				{
+//					pBasic->SetParent( pStdLib );
+					pStdLib->Insert( pBasic );
+					pBasic->SetFlag( SBX_EXTSEARCH );
+				}
+			}
+			// Durch das Insert modified:
+			pStdLib->SetModified( FALSE );
+		}
+
+        // #91626 Save all stream data to save it unmodified if basic isn't modified
+        // in an 6.0+ office. So also the old basic dialogs can be saved.
+	    SotStorageStreamRef xManagerStream = rStorage.OpenSotStream
+		    ( ManagerStreamName, eStreamReadMode );
+        mpImpl->mpManagerStream = new SvMemoryStream();
+        *static_cast<SvStream*>(&xManagerStream) >> *mpImpl->mpManagerStream;
+
+	    SotStorageRef xBasicStorage = rStorage.OpenSotStorage
+							    ( BasicStreamName, eStorageReadMode, FALSE );
+	    if( xBasicStorage.Is() && !xBasicStorage->GetError() )
+	    {
+	        USHORT nLibs = GetLibCount();
+            mpImpl->mppLibStreams = new SvMemoryStream*[ nLibs ];
+            for( USHORT nL = 0; nL < nLibs; nL++ )
+	        {
+		        BasicLibInfo* pInfo = pLibs->GetObject( nL );
+		        DBG_ASSERT( pInfo, "pInfo?!" );
+    		    SotStorageStreamRef xBasicStream = xBasicStorage->OpenSotStream( pInfo->GetLibName(), eStreamReadMode );
+                mpImpl->mppLibStreams[nL] = new SvMemoryStream();
+                *static_cast<SvStream*>(&xBasicStream) >> *( mpImpl->mppLibStreams[nL] );
+            }
+        }
+        else
+            mpImpl->mbError = sal_True;
+	}
+	else
+	{
+		ImpCreateStdLib( pParentFromStdLib );
+		if ( rStorage.IsStream( String::CreateFromAscii(szOldManagerStream) ) )
+            LoadOldBasicManager( rStorage );
+	}
+
+	bBasMgrModified = FALSE;
+}
+
+void copyToLibraryContainer( StarBASIC* pBasic, const LibraryContainerInfo& rInfo )
+{
+    Reference< XLibraryContainer > xScriptCont( rInfo.mxScriptCont.get() );
+    if ( !xScriptCont.is() )
+        return;
+
+    String aLibName = pBasic->GetName();
+	if( !xScriptCont->hasByName( aLibName ) )
+		xScriptCont->createLibrary( aLibName );
+
+	Any aLibAny = xScriptCont->getByName( aLibName );
+	Reference< XNameContainer > xLib;
+	aLibAny >>= xLib;
+    if ( !xLib.is() )
+        return;
+
+    USHORT nModCount = pBasic->GetModules()->Count();
+	for ( USHORT nMod = 0 ; nMod < nModCount ; nMod++ )
+	{
+		SbModule* pModule = (SbModule*)pBasic->GetModules()->Get( nMod );
+		DBG_ASSERT( pModule, "Modul nicht erhalten!" );
+
+		String aModName = pModule->GetName();
+		if( !xLib->hasByName( aModName ) )
+		{
+			OUString aSource = pModule->GetSource32();
+			Any aSourceAny;
+			aSourceAny <<= aSource;
+			xLib->insertByName( aModName, aSourceAny );
+		}
+	}
+}
+
+const Reference< XPersistentLibraryContainer >& BasicManager::GetDialogLibraryContainer()  const
+{
+    return mpImpl->maContainerInfo.mxDialogCont;
+}
+
+const Reference< XPersistentLibraryContainer >& BasicManager::GetScriptLibraryContainer()  const
+{
+    return mpImpl->maContainerInfo.mxScriptCont;
+}
+
+void BasicManager::SetLibraryContainerInfo( const LibraryContainerInfo& rInfo )
+{
+	mpImpl->maContainerInfo = rInfo;
+
+	Reference< XLibraryContainer > xScriptCont( mpImpl->maContainerInfo.mxScriptCont.get() );
+	StarBASIC* pStdLib = GetStdLib();
+	String aLibName = pStdLib->GetName();
+	if( xScriptCont.is() )
+	{
+		// Register listener for lib container
+		OUString aEmptyLibName;
+		Reference< XContainerListener > xLibContainerListener
+			= static_cast< XContainerListener* >
+				( new BasMgrContainerListenerImpl( this, aEmptyLibName ) );
+
+    	Reference< XContainer> xLibContainer( xScriptCont, UNO_QUERY );
+		xLibContainer->addContainerListener( xLibContainerListener );
+
+		Sequence< OUString > aScriptLibNames = xScriptCont->getElementNames();
+		const OUString* pScriptLibName = aScriptLibNames.getConstArray();
+		sal_Int32 i, nNameCount = aScriptLibNames.getLength();
+
+        if( nNameCount )
+        {
+		    for( i = 0 ; i < nNameCount ; ++i, ++pScriptLibName )
+		    {
+			    Any aLibAny = xScriptCont->getByName( *pScriptLibName );
+
+                if ( pScriptLibName->equalsAscii( "Standard" ) )
+				    xScriptCont->loadLibrary( *pScriptLibName );
+
+			    BasMgrContainerListenerImpl::insertLibraryImpl
+				    ( xScriptCont, this, aLibAny, *pScriptLibName );
+		    }
+        }
+        else
+        {
+            // No libs? Maybe an 5.2 document already loaded
+	        USHORT nLibs = GetLibCount();
+		    for( USHORT nL = 0; nL < nLibs; nL++ )
+		    {
+			    BasicLibInfo* pBasLibInfo = pLibs->GetObject( nL );
+			    StarBASIC* pLib = pBasLibInfo->GetLib();
+			    if( !pLib )
+                {
+                    BOOL bLoaded = ImpLoadLibary( pBasLibInfo, NULL, FALSE );
+                    if( bLoaded )
+                        pLib = pBasLibInfo->GetLib();
+                }
+			    if( pLib )
+                {
+                    copyToLibraryContainer( pLib, mpImpl->maContainerInfo );
+                    if( pBasLibInfo->HasPassword() )
+                    {
+                        OldBasicPassword* pOldBasicPassword =
+                            mpImpl->maContainerInfo.mpOldBasicPassword;
+                        if( pOldBasicPassword )
+                        {
+                            pOldBasicPassword->setLibraryPassword
+                                ( pLib->GetName(), pBasLibInfo->GetPassword() );
+                            pBasLibInfo->SetPasswordVerified();
+                        }
+                    }
+                }
+		    }
+
+            mpImpl->mbModifiedByLibraryContainer = sal_False;
+        }
+	}
+
+    InsertGlobalUNOConstant( "BasicLibraries", makeAny( mpImpl->maContainerInfo.mxScriptCont ) );
+    InsertGlobalUNOConstant( "DialogLibraries", makeAny( mpImpl->maContainerInfo.mxDialogCont ) );
+}
+
+BasicManager::BasicManager( StarBASIC* pSLib, String* pLibPath, BOOL bDocMgr ) : mbDocMgr( bDocMgr )
+{
+	DBG_CTOR( BasicManager, 0 );
+	Init();
+	DBG_ASSERT( pSLib, "BasicManager kann nicht mit einem NULL-Pointer erzeugt werden!" );
+
+	if( pLibPath )
+		pLibs->aBasicLibPath = *pLibPath;
+
+	BasicLibInfo* pStdLibInfo = CreateLibInfo();
+	pStdLibInfo->SetLib( pSLib );
+    StarBASICRef xStdLib = pStdLibInfo->GetLib();
+	xStdLib->SetName( String::CreateFromAscii(szStdLibName));
+	pStdLibInfo->SetLibName( String::CreateFromAscii(szStdLibName) );
+	pSLib->SetFlag( SBX_DONTSTORE | SBX_EXTSEARCH );
+
+	// Speichern lohnt sich nur, wenn sich das Basic aendert.
+	xStdLib->SetModified( FALSE );
+	bBasMgrModified = FALSE;
+}
+
+BasicManager::BasicManager()
+{
+	DBG_CTOR( BasicManager, 0 );
+	// Diese CTOR darf nur verwendet werden um bei 'Speichern unter'
+	// die relativen Pfade anzupassen, das gibt kein AppBasic und somit
+	// duerfen auch keine Libs geladen werden...
+	Init();
+}
+
+void BasicManager::ImpMgrNotLoaded( const String& rStorageName )
+{
+	// pErrInf wird nur zerstoert, wenn der Fehler von einem ErrorHandler
+	// gehandelt wird!
+//	String aErrorText( BasicResId( IDS_SBERR_MGROPEN ) );
+//	aErrorText.SearchAndReplace( "XX", rStorageName );
+	StringErrorInfo* pErrInf = new StringErrorInfo( ERRCODE_BASMGR_MGROPEN,	rStorageName, ERRCODE_BUTTON_OK );
+	pErrorMgr->InsertError( BasicError( *pErrInf, BASERR_REASON_OPENMGRSTREAM, rStorageName ) );
+
+	// Eine STD-Lib erzeugen, sonst macht es Peng!
+	BasicLibInfo* pStdLibInfo = CreateLibInfo();
+	pStdLibInfo->SetLib( new StarBASIC( NULL, mbDocMgr ) );
+    StarBASICRef xStdLib = pStdLibInfo->GetLib();
+	xStdLib->SetName( String::CreateFromAscii(szStdLibName) );
+	pStdLibInfo->SetLibName( String::CreateFromAscii(szStdLibName) );
+	xStdLib->SetFlag( SBX_DONTSTORE | SBX_EXTSEARCH );
+	xStdLib->SetModified( FALSE );
+}
+
+
+void BasicManager::ImpCreateStdLib( StarBASIC* pParentFromStdLib )
+{
+	BasicLibInfo* pStdLibInfo = CreateLibInfo();
+	StarBASIC* pStdLib = new StarBASIC( pParentFromStdLib, mbDocMgr );
+	pStdLibInfo->SetLib( pStdLib );
+	pStdLib->SetName( String::CreateFromAscii(szStdLibName) );
+	pStdLibInfo->SetLibName( String::CreateFromAscii(szStdLibName) );
+	pStdLib->SetFlag( SBX_DONTSTORE | SBX_EXTSEARCH );
+}
+
+
+void BasicManager::LoadBasicManager( SotStorage& rStorage, const String& rBaseURL, BOOL bLoadLibs )
+{
+	DBG_CHKTHIS( BasicManager, 0 );
+
+//	StreamMode eStreamMode = STREAM_READ | STREAM_NOCREATE | STREAM_SHARE_DENYWRITE;
+
+	SotStorageStreamRef xManagerStream = rStorage.OpenSotStream
+		( ManagerStreamName, eStreamReadMode );
+
+    String aStorName( rStorage.GetName() );
+    // #i13114 removed, DBG_ASSERT( aStorName.Len(), "No Storage Name!" );
+
+	if ( !xManagerStream.Is() || xManagerStream->GetError() || ( xManagerStream->Seek( STREAM_SEEK_TO_END ) == 0 ) )
+	{
+        ImpMgrNotLoaded( aStorName );
+		return;
+	}
+
+    maStorageName = INetURLObject(aStorName, INET_PROT_FILE).GetMainURL( INetURLObject::NO_DECODE );
+    // #i13114 removed, DBG_ASSERT(aStorageName.Len() != 0, "Bad storage name");
+
+	String aRealStorageName = maStorageName;  // fuer relative Pfade, kann durch BaseURL umgebogen werden.
+
+	// Wenn aus Vorlagen geladen wird, gilt nur die BaseURL:
+    //String aBaseURL = INetURLObject::GetBaseURL();
+    if ( rBaseURL.Len() )
+	{
+        INetURLObject aObj( rBaseURL );
+		if ( aObj.GetProtocol() == INET_PROT_FILE )
+			aRealStorageName = aObj.PathToFileName();
+	}
+
+	xManagerStream->SetBufferSize( 1024 );
+	xManagerStream->Seek( STREAM_SEEK_TO_BEGIN );
+
+	sal_uInt32 nEndPos;
+	*xManagerStream >> nEndPos;
+
+	USHORT nLibs;
+	*xManagerStream >> nLibs;
+	// Plausi!
+	if( nLibs & 0xF000 )
+	{
+		DBG_ASSERT( !this, "BasicManager-Stream defekt!" );
+		return;
+	}
+	for ( USHORT nL = 0; nL < nLibs; nL++ )
+	{
+		BasicLibInfo* pInfo = BasicLibInfo::Create( *xManagerStream );
+
+		// ggf. absoluten Pfad-Namen korrigieren, wenn rel. existiert
+		// Immer erst den relativen versuchen, falls zwei Staende auf der Platte
+        if ( pInfo->GetRelStorageName().Len() && ( ! pInfo->GetRelStorageName().EqualsAscii(szImbedded) ) )
+		{
+            INetURLObject aObj( aRealStorageName, INET_PROT_FILE );
+            aObj.removeSegment();
+            bool bWasAbsolute = FALSE;
+            aObj = aObj.smartRel2Abs( pInfo->GetRelStorageName(), bWasAbsolute );
+
+            //*** TODO: Replace if still necessary
+            /* if ( SfxContentHelper::Exists( aObj.GetMainURL() ) )
+                pInfo->SetStorageName( aObj.GetMainURL() );
+			else */
+            //*** TODO-End
+            if ( pLibs->aBasicLibPath.Len() )
+			{
+				// Lib im Pfad suchen...
+				String aSearchFile = pInfo->GetRelStorageName();
+				SvtPathOptions aPathCFG;
+				if( aPathCFG.SearchFile( aSearchFile, SvtPathOptions::PATH_BASIC ) )
+				{
+                    pInfo->SetStorageName( aSearchFile );
+					pInfo->SetFoundInPath( TRUE );
+				}
+			}
+		}
+
+		pLibs->Insert( pInfo, LIST_APPEND );
+		// Libs aus externen Dateien sollen erst bei Bedarf geladen werden.
+		// Aber Referenzen werden gleich geladen, sonst bekommen die Grosskunden
+		// vielleicht Probleme...
+		if ( bLoadLibs && pInfo->DoLoad() &&
+			( ( !pInfo->IsExtern() ) || ( pInfo->IsReference() ) ) )
+		{
+            ImpLoadLibary( pInfo, &rStorage );
+		}
+	}
+
+	xManagerStream->Seek( nEndPos );
+	xManagerStream->SetBufferSize( 0 );
+	xManagerStream.Clear();
+}
+
+void BasicManager::LoadOldBasicManager( SotStorage& rStorage )
+{
+	DBG_CHKTHIS( BasicManager, 0 );
+
+//	StreamMode eStreamMode = STREAM_READ | STREAM_NOCREATE | STREAM_SHARE_DENYWRITE;
+
+	SotStorageStreamRef xManagerStream = rStorage.OpenSotStream
+		( String::CreateFromAscii(szOldManagerStream), eStreamReadMode );
+
+    String aStorName( rStorage.GetName() );
+    DBG_ASSERT( aStorName.Len(), "No Storage Name!" );
+
+	if ( !xManagerStream.Is() || xManagerStream->GetError() || ( xManagerStream->Seek( STREAM_SEEK_TO_END ) == 0 ) )
+	{
+        ImpMgrNotLoaded( aStorName );
+		return;
+	}
+
+	xManagerStream->SetBufferSize( 1024 );
+	xManagerStream->Seek( STREAM_SEEK_TO_BEGIN );
+	sal_uInt32 nBasicStartOff, nBasicEndOff;
+	*xManagerStream >> nBasicStartOff;
+	*xManagerStream >> nBasicEndOff;
+
+	DBG_ASSERT( !xManagerStream->GetError(), "Ungueltiger Manager-Stream!" );
+
+	xManagerStream->Seek( nBasicStartOff );
+	if( !ImplLoadBasic( *xManagerStream, pLibs->GetObject(0)->GetLibRef() ) )
+	{
+//		String aErrorText( BasicResId( IDS_SBERR_MGROPEN ) );
+//      aErrorText.SearchAndReplace( "XX", aStorName );
+        StringErrorInfo* pErrInf = new StringErrorInfo( ERRCODE_BASMGR_MGROPEN, aStorName, ERRCODE_BUTTON_OK );
+        pErrorMgr->InsertError( BasicError( *pErrInf, BASERR_REASON_OPENMGRSTREAM, aStorName ) );
+		// und es geht weiter...
+	}
+	xManagerStream->Seek( nBasicEndOff+1 );	// +1: 0x00 als Trenner
+	String aLibs;
+	xManagerStream->ReadByteString(aLibs);
+	xManagerStream->SetBufferSize( 0 );
+	xManagerStream.Clear();	// Sream schliessen
+
+	if ( aLibs.Len() )
+	{
+        String aCurStorageName( aStorName );
+        INetURLObject aCurStorage( aCurStorageName, INET_PROT_FILE );
+		USHORT nLibs = aLibs.GetTokenCount( LIB_SEP );
+		for ( USHORT nLib = 0; nLib < nLibs; nLib++ )
+		{
+			String aLibInfo( aLibs.GetToken( nLib, LIB_SEP ) );
+			// == 2 soll irgendwann weg!
+			DBG_ASSERT( ( aLibInfo.GetTokenCount( LIBINFO_SEP ) == 2 ) || ( aLibInfo.GetTokenCount( LIBINFO_SEP ) == 3 ), "Ungueltige Lib-Info!" );
+			String aLibName( aLibInfo.GetToken( 0, LIBINFO_SEP ) );
+			String aLibAbsStorageName( aLibInfo.GetToken( 1, LIBINFO_SEP ) );
+			String aLibRelStorageName( aLibInfo.GetToken( 2, LIBINFO_SEP ) );
+            INetURLObject aLibAbsStorage( aLibAbsStorageName, INET_PROT_FILE );
+
+            INetURLObject aLibRelStorage( aStorName );
+            aLibRelStorage.removeSegment();
+            bool bWasAbsolute = FALSE;
+            aLibRelStorage = aLibRelStorage.smartRel2Abs( aLibRelStorageName, bWasAbsolute);
+            DBG_ASSERT(!bWasAbsolute, "RelStorageName was absolute!" );
+
+			SotStorageRef xStorageRef;
+			if ( ( aLibAbsStorage == aCurStorage ) || ( aLibRelStorageName.EqualsAscii(szImbedded) ) )
+				xStorageRef = &rStorage;
+			else
+			{
+                xStorageRef = new SotStorage( FALSE, aLibAbsStorage.GetMainURL
+                    ( INetURLObject::NO_DECODE ), eStorageReadMode, TRUE );
+                if ( xStorageRef->GetError() != ERRCODE_NONE )
+                    xStorageRef = new SotStorage( FALSE, aLibRelStorage.
+                    GetMainURL( INetURLObject::NO_DECODE ), eStorageReadMode, TRUE );
+			}
+			if ( xStorageRef.Is() )
+                AddLib( *xStorageRef, aLibName, FALSE );
+			else
+			{
+//				String aErrorText( BasicResId( IDS_SBERR_LIBLOAD ) );
+//				aErrorText.SearchAndReplace( "XX", aLibName );
+                StringErrorInfo* pErrInf = new StringErrorInfo( ERRCODE_BASMGR_LIBLOAD, aStorName, ERRCODE_BUTTON_OK );
+                pErrorMgr->InsertError( BasicError( *pErrInf, BASERR_REASON_STORAGENOTFOUND, aStorName ) );
+			}
+		}
+	}
+}
+
+BasicManager::~BasicManager()
+{
+	DBG_DTOR( BasicManager, 0 );
+
+	// Listener benachrichtigen, falls noch etwas zu Speichern...
+	Broadcast( SfxSimpleHint( SFX_HINT_DYING) );
+
+	// Basic-Infos zerstoeren...
+	// In umgekehrter Reihenfolge, weil die StdLib Referenzen haelt, die
+	// anderen nur die StdLib als Parent haben.
+	BasicLibInfo* pInf = pLibs->Last();
+	while ( pInf )
+	{
+		delete pInf;
+		pInf = pLibs->Prev();
+	}
+	pLibs->Clear();
+	delete pLibs;
+	delete pErrorMgr;
+	delete mpImpl;
+}
+
+void BasicManager::LegacyDeleteBasicManager( BasicManager*& _rpManager )
+{
+    delete _rpManager;
+    _rpManager = NULL;
+}
+
+void BasicManager::Init()
+{
+	DBG_CHKTHIS( BasicManager, 0 );
+
+	bBasMgrModified = FALSE;
+	pErrorMgr = new BasicErrorManager;
+	pLibs = new BasicLibs;
+	mpImpl = new BasicManagerImpl();
+}
+
+BasicLibInfo* BasicManager::CreateLibInfo()
+{
+	DBG_CHKTHIS( BasicManager, 0 );
+
+	BasicLibInfo* pInf = new BasicLibInfo;
+	pLibs->Insert( pInf, LIST_APPEND );
+	return pInf;
+}
+
+BOOL BasicManager::ImpLoadLibary( BasicLibInfo* pLibInfo, SotStorage* pCurStorage, BOOL bInfosOnly ) const
+{
+	DBG_CHKTHIS( BasicManager, 0 );
+
+	DBG_ASSERT( pLibInfo, "LibInfo!?" );
+
+	String aStorageName( pLibInfo->GetStorageName() );
+	if ( !aStorageName.Len() || ( aStorageName.EqualsAscii(szImbedded) ) )
+		aStorageName = GetStorageName();
+
+	SotStorageRef xStorage;
+	// Der aktuelle darf nicht nochmal geoffnet werden...
+	if ( pCurStorage )
+	{
+        String aStorName( pCurStorage->GetName() );
+        // #i13114 removed, DBG_ASSERT( aStorName.Len(), "No Storage Name!" );
+
+        INetURLObject aCurStorageEntry(aStorName, INET_PROT_FILE);
+        // #i13114 removed, DBG_ASSERT(aCurStorageEntry.GetMainURL( INetURLObject::NO_DECODE ).Len() != 0, "Bad storage name");
+
+        INetURLObject aStorageEntry(aStorageName, INET_PROT_FILE);
+        // #i13114 removed, DBG_ASSERT(aCurStorageEntry.GetMainURL( INetURLObject::NO_DECODE ).Len() != 0, "Bad storage name");
+
+		if ( aCurStorageEntry == aStorageEntry )
+			xStorage = pCurStorage;
+	}
+
+	if ( !xStorage.Is() )
+		xStorage = new SotStorage( FALSE, aStorageName, eStorageReadMode );
+
+	SotStorageRef xBasicStorage = xStorage->OpenSotStorage
+							( BasicStreamName, eStorageReadMode, FALSE );
+
+	if ( !xBasicStorage.Is() || xBasicStorage->GetError() )
+	{
+		StringErrorInfo* pErrInf = new StringErrorInfo( ERRCODE_BASMGR_MGROPEN,	xStorage->GetName(), ERRCODE_BUTTON_OK );
+		pErrorMgr->InsertError( BasicError( *pErrInf, BASERR_REASON_OPENLIBSTORAGE, pLibInfo->GetLibName() ) );
+	}
+	else
+	{
+		// In dem Basic-Storage liegt jede Lib in einem Stream...
+		SotStorageStreamRef xBasicStream = xBasicStorage->OpenSotStream( pLibInfo->GetLibName(), eStreamReadMode );
+		if ( !xBasicStream.Is() || xBasicStream->GetError() )
+		{
+			StringErrorInfo* pErrInf = new StringErrorInfo( ERRCODE_BASMGR_LIBLOAD , pLibInfo->GetLibName(), ERRCODE_BUTTON_OK );
+			pErrorMgr->InsertError( BasicError( *pErrInf, BASERR_REASON_OPENLIBSTREAM, pLibInfo->GetLibName() ) );
+		}
+		else
+		{
+			BOOL bLoaded = FALSE;
+			if ( xBasicStream->Seek( STREAM_SEEK_TO_END ) != 0 )
+			{
+				if ( !bInfosOnly )
+				{
+					if ( !pLibInfo->GetLib().Is() )
+						pLibInfo->SetLib( new StarBASIC( GetStdLib(), mbDocMgr ) );
+					xBasicStream->SetBufferSize( 1024 );
+					xBasicStream->Seek( STREAM_SEEK_TO_BEGIN );
+					bLoaded = ImplLoadBasic( *xBasicStream, pLibInfo->GetLibRef() );
+					xBasicStream->SetBufferSize( 0 );
+                    StarBASICRef xStdLib = pLibInfo->GetLib();
+					xStdLib->SetName( pLibInfo->GetLibName() );
+					xStdLib->SetModified( FALSE );
+					xStdLib->SetFlag( SBX_DONTSTORE );
+				}
+				else
+				{
+					// Das Basic skippen...
+					xBasicStream->Seek( STREAM_SEEK_TO_BEGIN );
+					ImplEncryptStream( *xBasicStream );
+					SbxBase::Skip( *xBasicStream );
+					bLoaded = TRUE;
+				}
+			}
+			if ( !bLoaded )
+			{
+				StringErrorInfo* pErrInf = new StringErrorInfo( ERRCODE_BASMGR_LIBLOAD,	pLibInfo->GetLibName(), ERRCODE_BUTTON_OK );
+				pErrorMgr->InsertError( BasicError( *pErrInf, BASERR_REASON_BASICLOADERROR, pLibInfo->GetLibName() ) );
+			}
+			else
+			{
+				// Ggf. stehen weitere Informationen im Stream...
+				xBasicStream->SetKey( szCryptingKey );
+				xBasicStream->RefreshBuffer();
+				sal_uInt32 nPasswordMarker = 0;
+				*xBasicStream >> nPasswordMarker;
+				if ( ( nPasswordMarker == PASSWORD_MARKER ) && !xBasicStream->IsEof() )
+				{
+					String aPassword;
+					xBasicStream->ReadByteString(aPassword);
+					pLibInfo->SetPassword( aPassword );
+				}
+				xBasicStream->SetKey( ByteString() );
+				CheckModules( pLibInfo->GetLib(), pLibInfo->IsReference() );
+			}
+//			bBasMgrModified = TRUE;	// Warum?
+			return bLoaded;
+		}
+	}
+	return FALSE;
+}
+
+BOOL BasicManager::ImplEncryptStream( SvStream& rStrm ) const
+{
+	ULONG nPos = rStrm.Tell();
+	UINT32 nCreator;
+	rStrm >> nCreator;
+	rStrm.Seek( nPos );
+	BOOL bProtected = FALSE;
+	if ( nCreator != SBXCR_SBX )
+	{
+		// sollte nur bei verschluesselten Streams nicht stimmen.
+		bProtected = TRUE;
+		rStrm.SetKey( szCryptingKey );
+		rStrm.RefreshBuffer();
+	}
+	return bProtected;
+}
+
+// Dieser Code ist notwendig, um das BASIC der Beta 1 laden zu koennen
+BOOL BasicManager::ImplLoadBasic( SvStream& rStrm, StarBASICRef& rOldBasic ) const
+{
+	BOOL bProtected = ImplEncryptStream( rStrm );
+	SbxBaseRef xNew = SbxBase::Load( rStrm );
+	BOOL bLoaded = FALSE;
+	if( xNew.Is() )
+	{
+		if( xNew->IsA( TYPE(StarBASIC) ) )
+		{
+			StarBASIC* pNew = (StarBASIC*)(SbxBase*) xNew;
+			// Den Parent des alten BASICs uebernehmen
+			if( rOldBasic.Is() )
+			{
+				pNew->SetParent( rOldBasic->GetParent() );
+				if( pNew->GetParent() )
+					pNew->GetParent()->Insert( pNew );
+				pNew->SetFlag( SBX_EXTSEARCH );
+			}
+			rOldBasic = pNew;
+
+			// Fill new libray container (5.2 -> 6.0)
+            copyToLibraryContainer( pNew, mpImpl->maContainerInfo );
+
+/*
+			if( rOldBasic->GetParent() )
+			{
+				rOldBasic->GetParent()->Insert( rOldBasic );
+				rOldBasic->SetFlag( SBX_EXTSEARCH );
+			}
+*/
+			pNew->SetModified( FALSE );
+			bLoaded = TRUE;
+		}
+	}
+	if ( bProtected )
+		rStrm.SetKey( ByteString() );
+	return bLoaded;
+}
+
+void BasicManager::CheckModules( StarBASIC* pLib, BOOL bReference ) const
+{
+	if ( !pLib )
+		return;
+
+	BOOL bModified = pLib->IsModified();
+
+	for ( USHORT nMod = 0; nMod < pLib->GetModules()->Count(); nMod++ )
+	{
+		SbModule* pModule = (SbModule*)pLib->GetModules()->Get( nMod );
+		DBG_ASSERT( pModule, "Modul nicht erhalten!" );
+		if ( !pModule->IsCompiled() && !StarBASIC::GetErrorCode() )
+			pLib->Compile( pModule );
+	}
+
+	// #67477, AB 8.12.99 On demand Compilieren bei referenzierten
+	// Libraries sollte nicht zu modified fuehren
+	if( !bModified && bReference )
+	{
+		DBG_ERROR( "Per Reference eingebundene Basic-Library ist nicht compiliert!" );
+		pLib->SetModified( FALSE );
+	}
+}
+
+StarBASIC* BasicManager::AddLib( SotStorage& rStorage, const String& rLibName, BOOL bReference )
+{
+	DBG_CHKTHIS( BasicManager, 0 );
+
+    String aStorName( rStorage.GetName() );
+    DBG_ASSERT( aStorName.Len(), "No Storage Name!" );
+
+    String aStorageName = INetURLObject(aStorName, INET_PROT_FILE).GetMainURL( INetURLObject::NO_DECODE );
+    DBG_ASSERT(aStorageName.Len() != 0, "Bad storage name");
+
+	String aNewLibName( rLibName );
+	while ( HasLib( aNewLibName ) )
+		aNewLibName += '_';
+
+	BasicLibInfo* pLibInfo = CreateLibInfo();
+	// Erstmal mit dem Original-Namen, da sonst ImpLoadLibary nicht geht...
+	pLibInfo->SetLibName( rLibName );
+	// Funktioniert so aber nicht, wenn Name doppelt
+//	USHORT nLibId = GetLibId( rLibName );
+	USHORT nLibId = (USHORT) pLibs->GetPos( pLibInfo );
+
+	// Vorm Laden StorageNamen setzen, da er mit pCurStorage verglichen wird.
+	pLibInfo->SetStorageName( aStorageName );
+    BOOL bLoaded = ImpLoadLibary( pLibInfo, &rStorage );
+
+	if ( bLoaded )
+	{
+		if ( aNewLibName != rLibName )
+			SetLibName( nLibId, aNewLibName );
+
+		if ( bReference )
+		{
+			pLibInfo->GetLib()->SetModified( FALSE );	// Dann nicht speichern
+			pLibInfo->SetRelStorageName( String() );
+//			pLibInfo->CalcRelStorageName( GetStorageName() );
+			pLibInfo->IsReference() = TRUE;
+		}
+		else
+		{
+			pLibInfo->GetLib()->SetModified( TRUE );		// Muss nach Add gespeichert werden!
+			pLibInfo->SetStorageName( String::CreateFromAscii(szImbedded) );			// Im BasicManager-Storage speichern
+		}
+		bBasMgrModified = TRUE;
+	}
+	else
+	{
+		RemoveLib( nLibId, FALSE );
+		pLibInfo = 0;
+	}
+
+	if( pLibInfo )
+		return &*pLibInfo->GetLib() ;
+	else
+		return 0;
+}
+
+BOOL BasicManager::IsReference( USHORT nLib )
+{
+	DBG_CHKTHIS( BasicManager, 0 );
+
+	BasicLibInfo* pLibInfo = pLibs->GetObject( nLib );
+	DBG_ASSERT( pLibInfo, "Lib?!" );
+	if ( pLibInfo )
+		return pLibInfo->IsReference();
+
+	return FALSE;
+}
+
+BOOL BasicManager::RemoveLib( USHORT nLib )
+{
+	// Nur physikalisch loeschen, wenn keine Referenz.
+	return RemoveLib( nLib, !IsReference( nLib ) );
+}
+
+BOOL BasicManager::RemoveLib( USHORT nLib, BOOL bDelBasicFromStorage )
+{
+	DBG_CHKTHIS( BasicManager, 0 );
+	DBG_ASSERT( nLib, "Standard-Lib kann nicht entfernt werden!" );
+
+	BasicLibInfo* pLibInfo = pLibs->GetObject( nLib );
+	DBG_ASSERT( pLibInfo, "Lib nicht gefunden!" );
+
+	if ( !pLibInfo || !nLib )
+	{
+//		String aErrorText( BasicResId( IDS_SBERR_REMOVELIB ) );
+		StringErrorInfo* pErrInf = new StringErrorInfo( ERRCODE_BASMGR_REMOVELIB, String(), ERRCODE_BUTTON_OK );
+		pErrorMgr->InsertError( BasicError( *pErrInf, BASERR_REASON_STDLIB, pLibInfo->GetLibName() ) );
+		return FALSE;
+	}
+
+	// Wenn einer der Streams nicht geoeffnet werden kann, ist es kein
+	// Fehler, es gibt halt noch nichts zum loeschen, weil das Basic noch
+	// nie geschrieben wurde...
+	if ( bDelBasicFromStorage && !pLibInfo->IsReference() &&
+			( !pLibInfo->IsExtern() || SotStorage::IsStorageFile( pLibInfo->GetStorageName() ) ) )
+	{
+		SotStorageRef xStorage;
+		if ( !pLibInfo->IsExtern() )
+			xStorage = new SotStorage( FALSE, GetStorageName() );
+		else
+			xStorage = new SotStorage( FALSE, pLibInfo->GetStorageName() );
+
+		if ( xStorage->IsStorage( BasicStreamName ) )
+		{
+			SotStorageRef xBasicStorage = xStorage->OpenSotStorage
+							( BasicStreamName, STREAM_STD_READWRITE, FALSE );
+
+			if ( !xBasicStorage.Is() || xBasicStorage->GetError() )
+			{
+//				String aErrorText( BasicResId( IDS_SBERR_REMOVELIB ) );
+				StringErrorInfo* pErrInf = new StringErrorInfo( ERRCODE_BASMGR_REMOVELIB, String(), ERRCODE_BUTTON_OK );
+				pErrorMgr->InsertError( BasicError( *pErrInf, BASERR_REASON_OPENLIBSTORAGE, pLibInfo->GetLibName() ) );
+			}
+			else if ( xBasicStorage->IsStream( pLibInfo->GetLibName() ) )
+			{
+				xBasicStorage->Remove( pLibInfo->GetLibName() );
+				xBasicStorage->Commit();
+
+				// Wenn kein weiterer Stream vorhanden,
+				// dann auch den SubStorage loeschen.
+				SvStorageInfoList aInfoList( 0, 4 );
+				xBasicStorage->FillInfoList( &aInfoList );
+				if ( !aInfoList.Count() )
+				{
+					xBasicStorage.Clear();
+					xStorage->Remove( BasicStreamName );
+					xStorage->Commit();
+					// Wenn kein weiterer Streams oder SubStorages vorhanden,
+					// dann auch den Storage loeschen.
+					aInfoList.Clear();
+					xStorage->FillInfoList( &aInfoList );
+					if ( !aInfoList.Count() )
+					{
+                        String aName_( xStorage->GetName() );
+						xStorage.Clear();
+                        //*** TODO: Replace if still necessary
+                        //SfxContentHelper::Kill( aName );
+                        //*** TODO-End
+					}
+				}
+			}
+		}
+	}
+	bBasMgrModified = TRUE;
+	if ( pLibInfo->GetLib().Is() )
+		GetStdLib()->Remove( pLibInfo->GetLib() );
+	delete pLibs->Remove( pLibInfo );
+	return TRUE;	// Remove hat geklappt, Del unwichtig.
+}
+
+USHORT BasicManager::GetLibCount() const
+{
+	DBG_CHKTHIS( BasicManager, 0 );
+	return (USHORT)pLibs->Count();
+}
+
+StarBASIC* BasicManager::GetLib( USHORT nLib ) const
+{
+	DBG_CHKTHIS( BasicManager, 0 );
+	BasicLibInfo* pInf = pLibs->GetObject( nLib );
+	DBG_ASSERT( pInf, "Lib existiert nicht!" );
+	if ( pInf )
+		return pInf->GetLib();
+	return 0;
+}
+
+StarBASIC* BasicManager::GetStdLib() const
+{
+	DBG_CHKTHIS( BasicManager, 0 );
+	StarBASIC* pLib = GetLib( 0 );
+	return pLib;
+}
+
+StarBASIC* BasicManager::GetLib( const String& rName ) const
+{
+	DBG_CHKTHIS( BasicManager, 0 );
+
+	BasicLibInfo* pInf = pLibs->First();
+	while ( pInf )
+	{
+		if ( pInf->GetLibName().CompareIgnoreCaseToAscii( rName ) == COMPARE_EQUAL )		// prueffen, ob vorhanden...
+			return pInf->GetLib();
+
+		pInf = pLibs->Next();
+	}
+	return 0;
+}
+
+USHORT BasicManager::GetLibId( const String& rName ) const
+{
+	DBG_CHKTHIS( BasicManager, 0 );
+
+	BasicLibInfo* pInf = pLibs->First();
+	while ( pInf )
+	{
+		if ( pInf->GetLibName().CompareIgnoreCaseToAscii( rName ) == COMPARE_EQUAL )
+			return (USHORT)pLibs->GetCurPos();
+
+		pInf = pLibs->Next();
+	}
+	return LIB_NOTFOUND;
+}
+
+BOOL BasicManager::HasLib( const String& rName ) const
+{
+	DBG_CHKTHIS( BasicManager, 0 );
+
+	BasicLibInfo* pInf = pLibs->First();
+	while ( pInf )
+	{
+		if ( pInf->GetLibName().CompareIgnoreCaseToAscii( rName ) == COMPARE_EQUAL )
+			return TRUE;
+
+		pInf = pLibs->Next();
+	}
+	return FALSE;
+}
+
+BOOL BasicManager::SetLibName( USHORT nLib, const String& rName )
+{
+	DBG_CHKTHIS( BasicManager, 0 );
+
+	BasicLibInfo* pLibInfo = pLibs->GetObject( nLib );
+	DBG_ASSERT( pLibInfo, "Lib?!" );
+	if ( pLibInfo )
+	{
+		pLibInfo->SetLibName( rName );
+		if ( pLibInfo->GetLib().Is() )
+		{
+            StarBASICRef xStdLib = pLibInfo->GetLib();
+			xStdLib->SetName( rName );
+			xStdLib->SetModified( TRUE );
+		}
+		bBasMgrModified = TRUE;
+		return TRUE;
+	}
+	return FALSE;
+}
+
+String BasicManager::GetLibName( USHORT nLib )
+{
+	DBG_CHKTHIS( BasicManager, 0 );
+
+	BasicLibInfo* pLibInfo = pLibs->GetObject( nLib );
+	DBG_ASSERT( pLibInfo, "Lib?!" );
+	if ( pLibInfo )
+		return pLibInfo->GetLibName();
+	return String();
+}
+
+BOOL BasicManager::LoadLib( USHORT nLib )
+{
+	DBG_CHKTHIS( BasicManager, 0 );
+
+	BOOL bDone = FALSE;
+	BasicLibInfo* pLibInfo = pLibs->GetObject( nLib );
+	DBG_ASSERT( pLibInfo, "Lib?!" );
+	if ( pLibInfo )
+	{
+        Reference< XLibraryContainer > xLibContainer = pLibInfo->GetLibraryContainer();
+        if( xLibContainer.is() )
+        {
+            String aLibName = pLibInfo->GetLibName();
+            xLibContainer->loadLibrary( aLibName );
+            bDone = xLibContainer->isLibraryLoaded( aLibName );;
+        }
+        else
+        {
+            bDone = ImpLoadLibary( pLibInfo, NULL, FALSE );
+		    StarBASIC* pLib = GetLib( nLib );
+		    if ( pLib )
+		    {
+    //			pLib->SetParent( GetStdLib() );
+			    GetStdLib()->Insert( pLib );
+			    pLib->SetFlag( SBX_EXTSEARCH );
+		    }
+        }
+	}
+	else
+	{
+//		String aErrorText( BasicResId( IDS_SBERR_LIBLOAD ) );
+//		aErrorText.SearchAndReplace( "XX", "" );
+		StringErrorInfo* pErrInf = new StringErrorInfo( ERRCODE_BASMGR_LIBLOAD,	String(), ERRCODE_BUTTON_OK );
+		pErrorMgr->InsertError( BasicError( *pErrInf, BASERR_REASON_LIBNOTFOUND, String::CreateFromInt32(nLib) ) );
+	}
+	return bDone;
+}
+
+StarBASIC* BasicManager::CreateLib( const String& rLibName )
+{
+	DBG_CHKTHIS( BasicManager, 0 );
+	if ( GetLib( rLibName ) )
+		return 0;
+
+	BasicLibInfo* pLibInfo = CreateLibInfo();
+	StarBASIC* pNew = new StarBASIC( GetStdLib(), mbDocMgr );
+	GetStdLib()->Insert( pNew );
+	pNew->SetFlag( SBX_EXTSEARCH | SBX_DONTSTORE );
+	pLibInfo->SetLib( pNew );
+	pLibInfo->SetLibName( rLibName );
+	pLibInfo->GetLib()->SetName( rLibName );
+	return pLibInfo->GetLib();
+}
+
+// For XML import/export:
+StarBASIC* BasicManager::CreateLib
+    ( const String& rLibName, const String& Password, const String& LinkTargetURL )
+{
+	// Ask if lib exists because standard lib is always there
+	StarBASIC* pLib = GetLib( rLibName );
+	if( !pLib )
+	{
+	    if( LinkTargetURL.Len() != 0 )
+		{
+			SotStorageRef xStorage = new SotStorage( FALSE, LinkTargetURL, STREAM_READ | STREAM_SHARE_DENYWRITE );
+			if( !xStorage->GetError() )
+			{
+				pLib = AddLib( *xStorage, rLibName, TRUE );
+
+				//if( !pLibInfo )
+					//pLibInfo = FindLibInfo( pLib );
+				//pLibInfo->SetStorageName( LinkTargetURL );
+				//pLibInfo->GetLib()->SetModified( FALSE );	// Dann nicht speichern
+				//pLibInfo->SetRelStorageName( String() );
+				//pLibInfo->IsReference() = TRUE;
+			}
+			//else
+				//Message?
+
+			DBG_ASSERT( pLib, "XML Import: Linked basic library could not be loaded");
+		}
+		else
+		{
+			pLib = CreateLib( rLibName );
+			if( Password.Len() != 0 )
+			{
+				BasicLibInfo* pLibInfo = FindLibInfo( pLib );
+				pLibInfo ->SetPassword( Password );
+			}
+		}
+		//ExternalSourceURL ?
+	}
+	return pLib;
+}
+
+StarBASIC* BasicManager::CreateLibForLibContainer( const String& rLibName,
+    const Reference< XLibraryContainer >& xScriptCont )
+{
+	DBG_CHKTHIS( BasicManager, 0 );
+	if ( GetLib( rLibName ) )
+		return 0;
+
+	BasicLibInfo* pLibInfo = CreateLibInfo();
+	StarBASIC* pNew = new StarBASIC( GetStdLib(), mbDocMgr );
+	GetStdLib()->Insert( pNew );
+	pNew->SetFlag( SBX_EXTSEARCH | SBX_DONTSTORE );
+	pLibInfo->SetLib( pNew );
+	pLibInfo->SetLibName( rLibName );
+	pLibInfo->GetLib()->SetName( rLibName );
+    pLibInfo->SetLibraryContainer( xScriptCont );
+	return pNew;
+}
+
+
+BasicLibInfo* BasicManager::FindLibInfo( StarBASIC* pBasic ) const
+{
+	DBG_CHKTHIS( BasicManager, 0 );
+
+	BasicLibInfo* pInf = ((BasicManager*)this)->pLibs->First();
+	while ( pInf )
+	{
+		if ( pInf->GetLib() == pBasic )
+			return pInf;
+
+		pInf = ((BasicManager*)this)->pLibs->Next();
+	}
+	return 0;
+}
+
+
+BOOL BasicManager::IsModified() const
+{
+	DBG_CHKTHIS( BasicManager, 0 );
+
+	if ( bBasMgrModified )
+		return TRUE;
+	return IsBasicModified();
+}
+
+BOOL BasicManager::IsBasicModified() const
+{
+	DBG_CHKTHIS( BasicManager, 0 );
+
+	BasicLibInfo* pInf = pLibs->First();
+	while ( pInf )
+	{
+		if ( pInf->GetLib().Is() && pInf->GetLib()->IsModified() )
+			return TRUE;
+
+		pInf = pLibs->Next();
+	}
+	return FALSE;
+}
+
+void BasicManager::SetFlagToAllLibs( short nFlag, BOOL bSet ) const
+{
+	USHORT nLibs = GetLibCount();
+	for ( USHORT nL = 0; nL < nLibs; nL++ )
+	{
+		BasicLibInfo* pInfo = pLibs->GetObject( nL );
+		DBG_ASSERT( pInfo, "Info?!" );
+		StarBASIC* pLib = pInfo->GetLib();
+		if ( pLib )
+		{
+			if ( bSet )
+				pLib->SetFlag( nFlag );
+			else
+				pLib->ResetFlag( nFlag );
+		}
+	}
+}
+
+BOOL BasicManager::HasErrors()
+{
+	DBG_CHKTHIS( BasicManager, 0 );
+	return pErrorMgr->HasErrors();
+}
+
+void BasicManager::ClearErrors()
+{
+	DBG_CHKTHIS( BasicManager, 0 );
+	pErrorMgr->Reset();
+}
+
+BasicError* BasicManager::GetFirstError()
+{
+	DBG_CHKTHIS( BasicManager, 0 );
+	return pErrorMgr->GetFirstError();
+}
+
+BasicError* BasicManager::GetNextError()
+{
+	DBG_CHKTHIS( BasicManager, 0 );
+	return pErrorMgr->GetNextError();
+}
+
+void BasicManager::InsertGlobalUNOConstant( const sal_Char* _pAsciiName, const Any& _rValue )
+{
+	StarBASIC* pStandardLib = GetStdLib();
+    OSL_PRECOND( pStandardLib, "BasicManager::InsertGlobalUNOConstant: no lib to insert into!" );
+    OSL_PRECOND( _rValue.hasValue(), "BasicManager::InsertGlobalUNOConstant: empty constants not allowed!" );
+    if ( !pStandardLib || !_rValue.hasValue() )
+        return;
+
+    sal_Bool bWasModified = pStandardLib->IsModified();
+
+    SbxObjectRef xUnoObj = GetSbUnoObject( ::rtl::OUString::createFromAscii( _pAsciiName ), _rValue );
+    xUnoObj->SetFlag( SBX_DONTSTORE );
+    pStandardLib->Insert( xUnoObj );
+
+    pStandardLib->SetModified( bWasModified );
+}
+
+bool BasicManager::LegacyPsswdBinaryLimitExceeded( ::com::sun::star::uno::Sequence< rtl::OUString >& _out_rModuleNames )
+{
+    try
+    {
+        Reference< XNameAccess > xScripts( GetScriptLibraryContainer(), UNO_QUERY_THROW );
+        Reference< XLibraryContainerPassword > xPassword( GetScriptLibraryContainer(), UNO_QUERY_THROW );
+
+        Sequence< OUString > aNames( xScripts->getElementNames() );
+        const OUString* pNames = aNames.getConstArray();
+        const OUString* pNamesEnd = aNames.getConstArray() + aNames.getLength();
+        for ( ; pNames != pNamesEnd; ++pNames )
+        {
+            if( /*pLib->mbSharedIndexFile ||*/ !xPassword->isLibraryPasswordProtected( *pNames ) )
+                continue;
+
+            StarBASIC* pBasicLib = GetLib( *pNames );
+            if ( !pBasicLib )
+                continue;
+
+            Reference< XNameAccess > xScriptLibrary( xScripts->getByName( *pNames ), UNO_QUERY_THROW );
+            Sequence< OUString > aElementNames( xScriptLibrary->getElementNames() );
+            sal_Int32 nLen = aElementNames.getLength();
+
+            Sequence< OUString > aBigModules( nLen );
+            sal_Int32 nBigModules = 0;
+    
+            const OUString* pElementNames = aElementNames.getConstArray();
+            const OUString* pElementNamesEnd = aElementNames.getConstArray() + aElementNames.getLength();
+            for ( ; pElementNames != pElementNamesEnd; ++pElementNames )
+            {
+                SbModule* pMod = pBasicLib->FindModule( *pElementNames );
+                if ( pMod && pMod->ExceedsLegacyModuleSize() )
+                    aBigModules[ nBigModules++ ] = *pElementNames;
+            }
+
+            if ( nBigModules )
+            {
+                aBigModules.realloc( nBigModules );	
+                _out_rModuleNames = aBigModules;
+                return true;
+            }
+        }
+    }
+    catch( const Exception& )
+    {
+    	DBG_UNHANDLED_EXCEPTION();
+    }
+    return false;
+}
+
+//=====================================================================
+
+class ModuleInfo_Impl : public ModuleInfoHelper
+{
+	OUString maName;
+	OUString maLanguage;
+	OUString maSource;
+
+public:
+	ModuleInfo_Impl( const OUString& aName, const OUString& aLanguage, const OUString& aSource )
+		: maName( aName ), maLanguage( aLanguage), maSource( aSource ) {}
+
+    // Methods XStarBasicModuleInfo
+    virtual OUString SAL_CALL getName() throw(RuntimeException)
+		{ return maName; }
+    virtual OUString SAL_CALL getLanguage() throw(RuntimeException)
+		{ return maLanguage; }
+    virtual OUString SAL_CALL getSource() throw(RuntimeException)
+		{ return maSource; }
+};
+
+
+//=====================================================================
+
+class DialogInfo_Impl : public DialogInfoHelper
+{
+	OUString maName;
+	Sequence< sal_Int8 > mData;
+
+public:
+	DialogInfo_Impl( const OUString& aName, Sequence< sal_Int8 > Data )
+		: maName( aName ), mData( Data ) {}
+
+    // Methods XStarBasicDialogInfo
+    virtual OUString SAL_CALL getName() throw(RuntimeException)
+		{ return maName; }
+    virtual Sequence< sal_Int8 > SAL_CALL getData() throw(RuntimeException)
+		{ return mData; }
+};
+
+
+//=====================================================================
+
+class LibraryInfo_Impl : public LibraryInfoHelper
+{
+	OUString maName;
+	Reference< XNameContainer > mxModuleContainer;
+	Reference< XNameContainer > mxDialogContainer;
+	OUString maPassword;
+	OUString maExternaleSourceURL;
+	OUString maLinkTargetURL;
+
+public:
+	LibraryInfo_Impl
+	(
+		const OUString& aName,
+		Reference< XNameContainer > xModuleContainer,
+		Reference< XNameContainer > xDialogContainer,
+		const OUString& aPassword,
+		const OUString& aExternaleSourceURL,
+		const OUString& aLinkTargetURL
+	)
+		: maName( aName )
+		, mxModuleContainer( xModuleContainer )
+		, mxDialogContainer( xDialogContainer )
+		, maPassword( aPassword )
+		, maExternaleSourceURL( aExternaleSourceURL )
+		, maLinkTargetURL( aLinkTargetURL )
+	{}
+
+    // Methods XStarBasicLibraryInfo
+    virtual OUString SAL_CALL getName() throw(RuntimeException)
+		{ return maName; }
+    virtual Reference< XNameContainer > SAL_CALL getModuleContainer() throw(RuntimeException)
+		{ return mxModuleContainer; }
+    virtual Reference< XNameContainer > SAL_CALL getDialogContainer() throw(RuntimeException)
+		{ return mxDialogContainer; }
+    virtual OUString SAL_CALL getPassword() throw(RuntimeException)
+		{ return maPassword; }
+    virtual OUString SAL_CALL getExternalSourceURL() throw(RuntimeException)
+		{ return maExternaleSourceURL; }
+    virtual OUString SAL_CALL getLinkTargetURL() throw(RuntimeException)
+		{ return maLinkTargetURL; }
+};
+
+//=====================================================================
+
+class ModuleContainer_Impl : public NameContainerHelper
+{
+	StarBASIC* mpLib;
+
+public:
+	ModuleContainer_Impl( StarBASIC* pLib )
+		:mpLib( pLib ) {}
+
+    // Methods XElementAccess
+    virtual Type SAL_CALL getElementType()
+		throw(RuntimeException);
+    virtual sal_Bool SAL_CALL hasElements()
+		throw(RuntimeException);
+
+    // Methods XNameAccess
+    virtual Any SAL_CALL getByName( const OUString& aName )
+		throw(NoSuchElementException, WrappedTargetException, RuntimeException);
+    virtual Sequence< OUString > SAL_CALL getElementNames()
+		throw(RuntimeException);
+    virtual sal_Bool SAL_CALL hasByName( const OUString& aName )
+		throw(RuntimeException);
+
+    // Methods XNameReplace
+    virtual void SAL_CALL replaceByName( const OUString& aName, const Any& aElement )
+		throw(IllegalArgumentException, NoSuchElementException, WrappedTargetException, RuntimeException);
+
+    // Methods XNameContainer
+    virtual void SAL_CALL insertByName( const OUString& aName, const Any& aElement )
+		throw(IllegalArgumentException, ElementExistException, WrappedTargetException, RuntimeException);
+    virtual void SAL_CALL removeByName( const OUString& Name )
+		throw(NoSuchElementException, WrappedTargetException, RuntimeException);
+};
+
+// Methods XElementAccess
+Type ModuleContainer_Impl::getElementType()
+	throw(RuntimeException)
+{
+	Type aModuleType = ::getCppuType( (const Reference< XStarBasicModuleInfo > *)0 );
+	return aModuleType;
+}
+
+sal_Bool ModuleContainer_Impl::hasElements()
+	throw(RuntimeException)
+{
+    SbxArray* pMods = mpLib ? mpLib->GetModules() : NULL;
+    return pMods && pMods->Count() > 0;
+}
+
+// Methods XNameAccess
+Any ModuleContainer_Impl::getByName( const OUString& aName )
+	throw(NoSuchElementException, WrappedTargetException, RuntimeException)
+{
+    SbModule* pMod = mpLib ? mpLib->FindModule( aName ) : NULL;
+	if( !pMod )
+		throw NoSuchElementException();
+	Reference< XStarBasicModuleInfo > xMod = (XStarBasicModuleInfo*)new ModuleInfo_Impl
+		( aName, OUString::createFromAscii( szScriptLanguage ), pMod->GetSource32() );
+	Any aRetAny;
+	aRetAny <<= xMod;
+	return aRetAny;
+}
+
+Sequence< OUString > ModuleContainer_Impl::getElementNames()
+	throw(RuntimeException)
+{
+    SbxArray* pMods = mpLib ? mpLib->GetModules() : NULL;
+    USHORT nMods = pMods ? pMods->Count() : 0;
+	Sequence< OUString > aRetSeq( nMods );
+	OUString* pRetSeq = aRetSeq.getArray();
+	for( USHORT i = 0 ; i < nMods ; i++ )
+	{
+		SbxVariable* pMod = pMods->Get( i );
+		pRetSeq[i] = OUString( pMod->GetName() );
+	}
+	return aRetSeq;
+}
+
+sal_Bool ModuleContainer_Impl::hasByName( const OUString& aName )
+	throw(RuntimeException)
+{
+    SbModule* pMod = mpLib ? mpLib->FindModule( aName ) : NULL;
+	sal_Bool bRet = (pMod != NULL);
+	return bRet;
+}
+
+
+// Methods XNameReplace
+void ModuleContainer_Impl::replaceByName( const OUString& aName, const Any& aElement )
+	throw(IllegalArgumentException, NoSuchElementException, WrappedTargetException, RuntimeException)
+{
+	removeByName( aName );
+	insertByName( aName, aElement );
+}
+
+
+// Methods XNameContainer
+void ModuleContainer_Impl::insertByName( const OUString& aName, const Any& aElement )
+	throw(IllegalArgumentException, ElementExistException, WrappedTargetException, RuntimeException)
+{
+	Type aModuleType = ::getCppuType( (const Reference< XStarBasicModuleInfo > *)0 );
+	Type aAnyType = aElement.getValueType();
+	if( aModuleType != aAnyType )
+		throw IllegalArgumentException();
+	Reference< XStarBasicModuleInfo > xMod;
+	aElement >>= xMod;
+	mpLib->MakeModule32( aName, xMod->getSource() );
+}
+
+void ModuleContainer_Impl::removeByName( const OUString& Name )
+	throw(NoSuchElementException, WrappedTargetException, RuntimeException)
+{
+    SbModule* pMod = mpLib ? mpLib->FindModule( Name ) : NULL;
+	if( !pMod )
+		throw NoSuchElementException();
+	mpLib->Remove( pMod );
+}
+
+
+//=====================================================================
+
+Sequence< sal_Int8 > implGetDialogData( SbxObject* pDialog )
+{
+	SvMemoryStream aMemStream;
+	pDialog->Store( aMemStream );
+	sal_Int32 nLen = aMemStream.Tell();
+	Sequence< sal_Int8 > aData( nLen );
+	sal_Int8* pDestData = aData.getArray();
+	const sal_Int8* pSrcData = (const sal_Int8*)aMemStream.GetData();
+	rtl_copyMemory( pDestData, pSrcData, nLen );
+	return aData;
+}
+
+SbxObject* implCreateDialog( Sequence< sal_Int8 > aData )
+{
+	sal_Int8* pData = aData.getArray();
+	SvMemoryStream aMemStream( pData, aData.getLength(), STREAM_READ );
+	SbxObject* pDialog = (SbxObject*)SbxBase::Load( aMemStream );
+	return pDialog;
+}
+
+// HACK! Because this value is defined in basctl/inc/vcsbxdef.hxx
+// which we can't include here, we have to use the value directly
+#define SBXID_DIALOG		101
+
+
+class DialogContainer_Impl : public NameContainerHelper
+{
+	StarBASIC* mpLib;
+
+public:
+	DialogContainer_Impl( StarBASIC* pLib )
+		:mpLib( pLib ) {}
+
+    // Methods XElementAccess
+    virtual Type SAL_CALL getElementType()
+		throw(RuntimeException);
+    virtual sal_Bool SAL_CALL hasElements()
+		throw(RuntimeException);
+
+    // Methods XNameAccess
+    virtual Any SAL_CALL getByName( const OUString& aName )
+		throw(NoSuchElementException, WrappedTargetException, RuntimeException);
+    virtual Sequence< OUString > SAL_CALL getElementNames()
+		throw(RuntimeException);
+    virtual sal_Bool SAL_CALL hasByName( const OUString& aName )
+		throw(RuntimeException);
+
+    // Methods XNameReplace
+    virtual void SAL_CALL replaceByName( const OUString& aName, const Any& aElement )
+		throw(IllegalArgumentException, NoSuchElementException, WrappedTargetException, RuntimeException);
+
+    // Methods XNameContainer
+    virtual void SAL_CALL insertByName( const OUString& aName, const Any& aElement )
+		throw(IllegalArgumentException, ElementExistException, WrappedTargetException, RuntimeException);
+    virtual void SAL_CALL removeByName( const OUString& Name )
+		throw(NoSuchElementException, WrappedTargetException, RuntimeException);
+};
+
+// Methods XElementAccess
+Type DialogContainer_Impl::getElementType()
+	throw(RuntimeException)
+{
+	Type aModuleType = ::getCppuType( (const Reference< XStarBasicDialogInfo > *)0 );
+	return aModuleType;
+}
+
+sal_Bool DialogContainer_Impl::hasElements()
+	throw(RuntimeException)
+{
+	sal_Bool bRet = sal_False;
+
+	mpLib->GetAll( SbxCLASS_OBJECT );
+	sal_Int16 nCount = mpLib->GetObjects()->Count();
+	for( sal_Int16 nObj = 0; nObj < nCount ; nObj++ )
+	{
+		SbxVariable* pVar = mpLib->GetObjects()->Get( nObj );
+		if ( pVar->ISA( SbxObject ) && ( ((SbxObject*)pVar)->GetSbxId() == SBXID_DIALOG ) )
+		{
+			bRet = sal_True;
+			break;
+		}
+	}
+	return bRet;
+}
+
+// Methods XNameAccess
+Any DialogContainer_Impl::getByName( const OUString& aName )
+	throw(NoSuchElementException, WrappedTargetException, RuntimeException)
+{
+	SbxVariable* pVar = mpLib->GetObjects()->Find( aName, SbxCLASS_DONTCARE );
+	if( !( pVar && pVar->ISA( SbxObject ) &&
+		   ( ((SbxObject*)pVar)->GetSbxId() == SBXID_DIALOG ) ) )
+	{
+		throw NoSuchElementException();
+	}
+
+	Reference< XStarBasicDialogInfo > xDialog =
+		(XStarBasicDialogInfo*)new DialogInfo_Impl
+			( aName, implGetDialogData( (SbxObject*)pVar ) );
+
+	Any aRetAny;
+	aRetAny <<= xDialog;
+	return aRetAny;
+}
+
+Sequence< OUString > DialogContainer_Impl::getElementNames()
+	throw(RuntimeException)
+{
+	mpLib->GetAll( SbxCLASS_OBJECT );
+	sal_Int16 nCount = mpLib->GetObjects()->Count();
+	Sequence< OUString > aRetSeq( nCount );
+	OUString* pRetSeq = aRetSeq.getArray();
+	sal_Int32 nDialogCounter = 0;
+
+	for( sal_Int16 nObj = 0; nObj < nCount ; nObj++ )
+	{
+		SbxVariable* pVar = mpLib->GetObjects()->Get( nObj );
+		if ( pVar->ISA( SbxObject ) && ( ((SbxObject*)pVar)->GetSbxId() == SBXID_DIALOG ) )
+		{
+			pRetSeq[ nDialogCounter ] = OUString( pVar->GetName() );
+			nDialogCounter++;
+		}
+	}
+	aRetSeq.realloc( nDialogCounter );
+	return aRetSeq;
+}
+
+sal_Bool DialogContainer_Impl::hasByName( const OUString& aName )
+	throw(RuntimeException)
+{
+	sal_Bool bRet = sal_False;
+	SbxVariable* pVar = mpLib->GetObjects()->Find( aName, SbxCLASS_DONTCARE );
+	if( pVar && pVar->ISA( SbxObject ) &&
+		   ( ((SbxObject*)pVar)->GetSbxId() == SBXID_DIALOG ) )
+	{
+		bRet = sal_True;
+	}
+	return bRet;
+}
+
+
+// Methods XNameReplace
+void DialogContainer_Impl::replaceByName( const OUString& aName, const Any& aElement )
+	throw(IllegalArgumentException, NoSuchElementException, WrappedTargetException, RuntimeException)
+{
+	removeByName( aName );
+	insertByName( aName, aElement );
+}
+
+
+// Methods XNameContainer
+void DialogContainer_Impl::insertByName( const OUString& aName, const Any& aElement )
+	throw(IllegalArgumentException, ElementExistException, WrappedTargetException, RuntimeException)
+{
+    (void)aName;
+	Type aModuleType = ::getCppuType( (const Reference< XStarBasicDialogInfo > *)0 );
+	Type aAnyType = aElement.getValueType();
+	if( aModuleType != aAnyType )
+		throw IllegalArgumentException();
+	Reference< XStarBasicDialogInfo > xMod;
+	aElement >>= xMod;
+	SbxObjectRef xDialog = implCreateDialog( xMod->getData() );
+	mpLib->Insert( xDialog );
+}
+
+void DialogContainer_Impl::removeByName( const OUString& Name )
+	throw(NoSuchElementException, WrappedTargetException, RuntimeException)
+{
+    (void)Name;
+	SbxVariable* pVar = mpLib->GetObjects()->Find( Name, SbxCLASS_DONTCARE );
+	if( !( pVar && pVar->ISA( SbxObject ) &&
+		   ( ((SbxObject*)pVar)->GetSbxId() == SBXID_DIALOG ) ) )
+	{
+		throw NoSuchElementException();
+	}
+	mpLib->Remove( pVar );
+}
+
+
+//=====================================================================
+
+
+class LibraryContainer_Impl : public NameContainerHelper
+{
+	BasicManager* mpMgr;
+
+public:
+	LibraryContainer_Impl( BasicManager* pMgr )
+		:mpMgr( pMgr ) {}
+
+    // Methods XElementAccess
+    virtual Type SAL_CALL getElementType()
+		throw(RuntimeException);
+    virtual sal_Bool SAL_CALL hasElements()
+		throw(RuntimeException);
+
+    // Methods XNameAccess
+    virtual Any SAL_CALL getByName( const OUString& aName )
+		throw(NoSuchElementException, WrappedTargetException, RuntimeException);
+    virtual Sequence< OUString > SAL_CALL getElementNames()
+		throw(RuntimeException);
+    virtual sal_Bool SAL_CALL hasByName( const OUString& aName )
+		throw(RuntimeException);
+
+    // Methods XNameReplace
+    virtual void SAL_CALL replaceByName( const OUString& aName, const Any& aElement )
+		throw(IllegalArgumentException, NoSuchElementException, WrappedTargetException, RuntimeException);
+
+    // Methods XNameContainer
+    virtual void SAL_CALL insertByName( const OUString& aName, const Any& aElement )
+		throw(IllegalArgumentException, ElementExistException, WrappedTargetException, RuntimeException);
+    virtual void SAL_CALL removeByName( const OUString& Name )
+		throw(NoSuchElementException, WrappedTargetException, RuntimeException);
+};
+
+
+// Methods XElementAccess
+Type LibraryContainer_Impl::getElementType()
+	throw(RuntimeException)
+{
+	Type aType = ::getCppuType( (const Reference< XStarBasicLibraryInfo > *)0 );
+	return aType;
+}
+
+sal_Bool LibraryContainer_Impl::hasElements()
+	throw(RuntimeException)
+{
+	sal_Int32 nLibs = mpMgr->GetLibCount();
+	sal_Bool bRet = (nLibs > 0);
+	return bRet;
+}
+
+// Methods XNameAccess
+Any LibraryContainer_Impl::getByName( const OUString& aName )
+	throw(NoSuchElementException, WrappedTargetException, RuntimeException)
+{
+	Any aRetAny;
+	if( !mpMgr->HasLib( aName ) )
+		throw NoSuchElementException();
+	StarBASIC* pLib = mpMgr->GetLib( aName );
+
+	Reference< XNameContainer > xModuleContainer =
+		(XNameContainer*)new ModuleContainer_Impl( pLib );
+
+	Reference< XNameContainer > xDialogContainer;
+		(XNameContainer*)new DialogContainer_Impl( pLib );
+
+	BasicLibInfo* pLibInfo = mpMgr->FindLibInfo( pLib );
+
+	OUString aPassword = pLibInfo->GetPassword();
+
+	// TODO Nur extern-Info liefern!
+	OUString aExternaleSourceURL;
+	OUString aLinkTargetURL;
+	if( pLibInfo->IsReference() )
+		aLinkTargetURL = pLibInfo->GetStorageName();
+	else if( pLibInfo->IsExtern() )
+		aExternaleSourceURL = pLibInfo->GetStorageName();
+
+	Reference< XStarBasicLibraryInfo > xLibInfo = new LibraryInfo_Impl
+	(
+		aName,
+		xModuleContainer,
+		xDialogContainer,
+		aPassword,
+		aExternaleSourceURL,
+		aLinkTargetURL
+	);
+
+	aRetAny <<= xLibInfo;
+	return aRetAny;
+}
+
+Sequence< OUString > LibraryContainer_Impl::getElementNames()
+	throw(RuntimeException)
+{
+	USHORT nLibs = mpMgr->GetLibCount();
+	Sequence< OUString > aRetSeq( nLibs );
+	OUString* pRetSeq = aRetSeq.getArray();
+	for( USHORT i = 0 ; i < nLibs ; i++ )
+	{
+		pRetSeq[i] = OUString( mpMgr->GetLibName( i ) );
+	}
+	return aRetSeq;
+}
+
+sal_Bool LibraryContainer_Impl::hasByName( const OUString& aName )
+	throw(RuntimeException)
+{
+	sal_Bool bRet = mpMgr->HasLib( aName );
+	return bRet;
+}
+
+// Methods XNameReplace
+void LibraryContainer_Impl::replaceByName( const OUString& aName, const Any& aElement )
+	throw(IllegalArgumentException, NoSuchElementException, WrappedTargetException, RuntimeException)
+{
+	removeByName( aName );
+	insertByName( aName, aElement );
+}
+
+// Methods XNameContainer
+void LibraryContainer_Impl::insertByName( const OUString& aName, const Any& aElement )
+	throw(IllegalArgumentException, ElementExistException, WrappedTargetException, RuntimeException)
+{
+    (void)aName;
+    (void)aElement;
+	// TODO: Insert a complete Library?!
+}
+
+void LibraryContainer_Impl::removeByName( const OUString& Name )
+	throw(NoSuchElementException, WrappedTargetException, RuntimeException)
+{
+	StarBASIC* pLib = mpMgr->GetLib( Name );
+	if( !pLib )
+		throw NoSuchElementException();
+	USHORT nLibId = mpMgr->GetLibId( Name );
+	mpMgr->RemoveLib( nLibId );
+}
+
+//=====================================================================
+
+typedef WeakImplHelper1< XStarBasicAccess > StarBasicAccessHelper;
+
+
+class StarBasicAccess_Impl : public StarBasicAccessHelper
+{
+	BasicManager* mpMgr;
+	Reference< XNameContainer > mxLibContainer;
+
+public:
+	StarBasicAccess_Impl( BasicManager* pMgr )
+		:mpMgr( pMgr ) {}
+
+public:
+
+    // Methods
+    virtual Reference< XNameContainer > SAL_CALL getLibraryContainer()
+		throw(RuntimeException);
+    virtual void SAL_CALL createLibrary( const OUString& LibName, const OUString& Password,
+		const OUString& ExternalSourceURL, const OUString& LinkTargetURL )
+			throw(ElementExistException, RuntimeException);
+    virtual void SAL_CALL addModule( const OUString& LibraryName, const OUString& ModuleName,
+		const OUString& Language, const OUString& Source )
+			throw(NoSuchElementException, RuntimeException);
+    virtual void SAL_CALL addDialog( const OUString& LibraryName, const OUString& DialogName,
+		const Sequence< sal_Int8 >& Data )
+			throw(NoSuchElementException, RuntimeException);
+
+};
+
+Reference< XNameContainer > SAL_CALL StarBasicAccess_Impl::getLibraryContainer()
+	throw(RuntimeException)
+{
+	if( !mxLibContainer.is() )
+		mxLibContainer = (XNameContainer*)new LibraryContainer_Impl( mpMgr );
+	return mxLibContainer;
+}
+
+void SAL_CALL StarBasicAccess_Impl::createLibrary
+(
+	const OUString& LibName,
+	const OUString& Password,
+	const OUString& ExternalSourceURL,
+	const OUString& LinkTargetURL
+)
+	throw(ElementExistException, RuntimeException)
+{
+    (void)ExternalSourceURL;
+#ifdef DBG_UTIL
+	StarBASIC* pLib =
+#endif
+	mpMgr->CreateLib( LibName, Password, LinkTargetURL );
+	DBG_ASSERT( pLib, "XML Import: Basic library could not be created");
+}
+
+void SAL_CALL StarBasicAccess_Impl::addModule
+(
+	const OUString& LibraryName,
+	const OUString& ModuleName,
+	const OUString& Language,
+	const OUString& Source
+)
+	throw(NoSuchElementException, RuntimeException)
+{
+    (void)Language;
+	StarBASIC* pLib = mpMgr->GetLib( LibraryName );
+	DBG_ASSERT( pLib, "XML Import: Lib for module unknown");
+	if( pLib )
+		pLib->MakeModule32( ModuleName, Source );
+}
+
+void SAL_CALL StarBasicAccess_Impl::addDialog
+(
+	const OUString& LibraryName,
+	const OUString& DialogName,
+	const Sequence< sal_Int8 >& Data
+)
+	throw(NoSuchElementException, RuntimeException)
+{
+	(void)LibraryName;
+	(void)DialogName;
+	(void)Data;
+}
+
+// Basic XML Import/Export
+Reference< XStarBasicAccess > getStarBasicAccess( BasicManager* pMgr )
+{
+	Reference< XStarBasicAccess > xRet =
+		new StarBasicAccess_Impl( (BasicManager*)pMgr );
+	return xRet;
+}
--- basic/inc/basic/sbstar.hxx.bak	1970-01-01 08:00:00.000000000 +0800
+++ basic/inc/basic/sbstar.hxx	2007-10-15 11:51:06.000000000 +0800
@@ -0,0 +1,220 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile: sbstar.hxx,v $
+ *
+ *  $Revision: 1.2 $
+ *
+ *  last change: $Author: vg $ $Date: 2007/04/11 12:52:47 $
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+
+#ifndef _SB_SBSTAR_HXX
+#define _SB_SBSTAR_HXX
+
+#ifndef _SBXCLASS_HXX //autogen
+#include <basic/sbx.hxx>
+#endif
+#ifndef _SBX_SBXOBJECT_HXX //autogen
+#include <basic/sbxobj.hxx>
+#endif
+#ifndef _RTL_USTRING_HXX
+#include <rtl/ustring.hxx>
+#endif
+#ifndef _OSL_MUTEX_HXX_ 
+#include <osl/mutex.hxx>
+#endif
+
+#include <basic/sbdef.hxx>
+#include <basic/sberrors.hxx>
+#include <com/sun/star/script/ModuleInfo.hpp>
+
+class SbModule;                     // fertiges Modul
+class SbiInstance;                  // Laufzeit-Instanz
+class SbiRuntime;                   // aktuell laufende Prozedur
+class SbiImage;                     // compiliertes Image
+class BasicLibInfo;					// Infoblock fuer Basic-Manager
+class SbiBreakpoints;
+class SbTextPortions;
+class SbMethod;
+class BasicManager;
+
+class StarBASICImpl;
+
+class StarBASIC : public SbxObject
+{
+	friend class SbiScanner;
+	friend class SbiExpression;			// Zugriff auf RTL
+	friend class SbiInstance;
+	friend class SbiRuntime;
+
+	StarBASICImpl*	mpStarBASICImpl;
+
+	SbxArrayRef		pModules;			// Liste aller Module
+	SbxObjectRef	pRtl;				// Runtime Library
+	SbxArrayRef		xUnoListeners;		// Listener handled by CreateUnoListener
+										// Handler-Support:
+	Link			aErrorHdl;			// Fehlerbehandlung
+	Link			aBreakHdl;			// Breakpoint-Handler
+	BOOL			bNoRtl;				// TRUE: RTL nicht durchsuchen
+	BOOL			bBreak;				// TRUE: Break, sonst Step
+	BOOL			bDocBasic;
+	BasicLibInfo*	pLibInfo;			// Infoblock fuer Basic-Manager
+	SbLanguageMode	eLanguageMode;		// LanguageMode des Basic-Objekts
+protected:
+	BOOL 			CError( SbError, const String&, xub_StrLen, xub_StrLen, xub_StrLen );
+private:
+	BOOL 			RTError( SbError, xub_StrLen, xub_StrLen, xub_StrLen );
+	BOOL 			RTError( SbError, const String& rMsg, xub_StrLen, xub_StrLen, xub_StrLen );
+	USHORT 			BreakPoint( xub_StrLen nLine, xub_StrLen nCol1, xub_StrLen nCol2 );
+	USHORT 			StepPoint( xub_StrLen nLine, xub_StrLen nCol1, xub_StrLen nCol2 );
+	virtual BOOL LoadData( SvStream&, USHORT );
+	virtual BOOL StoreData( SvStream& ) const;
+
+protected:
+
+	virtual	BOOL  	ErrorHdl();
+	virtual	USHORT	BreakHdl();
+	virtual ~StarBASIC();
+
+public:
+
+	SBX_DECL_PERSIST_NODATA(SBXCR_SBX,SBXID_BASIC,1);
+	TYPEINFO();
+
+	StarBASIC( StarBASIC* pParent = NULL, BOOL bIsDocBasic = FALSE );
+
+	// #51727 SetModified ueberladen, damit der Modified-
+	// Zustand nicht an den Parent weitergegeben wird.
+	virtual void SetModified( BOOL );
+
+	void* operator 	new( size_t );
+	void operator 	delete( void* );
+
+	virtual void    Insert( SbxVariable* );
+	using SbxObject::Remove;
+	virtual void    Remove( SbxVariable* );
+	virtual void	Clear();
+
+	BasicLibInfo*	GetLibInfo()					{ return pLibInfo;	}
+	void			SetLibInfo( BasicLibInfo* p )   { pLibInfo = p;		}
+
+	// Compiler-Interface
+	SbModule*   	MakeModule( const String& rName, const String& rSrc );
+    SbModule*       MakeModule32( const String& rName, const ::rtl::OUString& rSrc );
+    SbModule*       MakeObjModule( const String& rName, const com::sun::star::script::ModuleInfo& mInfo );
+	BOOL			Compile( SbModule* );
+	BOOL 			Disassemble( SbModule*, String& rText );
+	static void 	Stop();
+	static void 	Error( SbError );
+	static void 	Error( SbError, const String& rMsg );
+	static void 	FatalError( SbError );
+	static BOOL 	IsRunning();
+	static SbError 	GetErrBasic();
+	// #66536 Zusatz-Message fuer RTL-Funktion Error zugreifbar machen
+	static String	GetErrorMsg();
+	static xub_StrLen GetErl();
+	// Highlighting
+	void 			Highlight( const String& rSrc, SbTextPortions& rList );
+
+	virtual SbxVariable* Find( const String&, SbxClassType );
+	virtual BOOL Call( const String&, SbxArray* = NULL );
+
+	SbxArray*		GetModules() { return pModules; }
+	SbxObject*		GetRtl()	 { return pRtl;		}
+	SbModule*		FindModule( const String& );
+	// Init-Code aller Module ausfuehren (auch in inserteten Doc-Basics)
+	void			InitAllModules( StarBASIC* pBasicNotToInit = NULL );
+	void			DeInitAllModules( void );
+	void			ClearAllModuleVars( void );
+	void			ActivateObject( const String*, BOOL );
+	BOOL 			LoadOldModules( SvStream& );
+
+	// #43011 Fuer das TestTool, um globale Variablen loeschen zu koennen
+	void			ClearGlobalVars( void );
+
+	// Abfragen fuer den Error-Handler und den Break-Handler:
+	static USHORT	GetLine();
+	static USHORT	GetCol1();
+	static USHORT	GetCol2();
+	static void		SetErrorData( SbError nCode, USHORT nLine,
+								  USHORT nCol1, USHORT nCol2 );
+
+	// Spezifisch fuer den Error-Handler:
+	static void		MakeErrorText( SbError, const String& aMsg );
+	static const	String&	GetErrorText();
+	static SbError	GetErrorCode();
+	static BOOL		IsCompilerError();
+	static USHORT	GetVBErrorCode( SbError nError );
+	static SbError	GetSfxFromVBError( USHORT nError );
+	static void		SetGlobalLanguageMode( SbLanguageMode eLangMode );
+	static SbLanguageMode GetGlobalLanguageMode();
+	// Lokale Einstellung
+	void SetLanguageMode( SbLanguageMode eLangMode )
+		{ eLanguageMode = eLangMode; }
+	SbLanguageMode GetLanguageMode();
+
+	// Spezifisch fuer den Break-Handler:
+	BOOL   			IsBreak() const				{ return bBreak; }
+
+	static Link 	GetGlobalErrorHdl();
+	static void 	SetGlobalErrorHdl( const Link& rNewHdl );
+	Link 			GetErrorHdl() const { return aErrorHdl; }
+	void 			SetErrorHdl( const Link& r ) { aErrorHdl = r; }
+
+	static Link 	GetGlobalBreakHdl();
+	static void 	SetGlobalBreakHdl( const Link& rNewHdl );
+	Link 			GetBreakHdl() const { return aBreakHdl; }
+	void 			SetBreakHdl( const Link& r ) { aBreakHdl = r; }
+
+    SbxArrayRef		getUnoListeners( void );
+
+	static SbxBase*	FindSBXInCurrentScope( const String& rName );
+	static SbxVariable*	FindVarInCurrentScopy
+					( const String& rName, USHORT& rStatus );
+	static SbMethod* GetActiveMethod( USHORT nLevel = 0 );
+	static SbModule* GetActiveModule();
+
+	// #60175 TRUE: SFX-Resource wird bei Basic-Fehlern nicht angezogen
+	static void StaticSuppressSfxResource( BOOL bSuppress );
+
+	// #91147 TRUE: Reschedule is enabled (default>, FALSE: No reschedule
+	static void StaticEnableReschedule( BOOL bReschedule );
+
+	SbxObjectRef getRTL( void ) { return pRtl; }
+	BOOL IsDocBasic() { return bDocBasic; }
+};
+
+#ifndef __SB_SBSTARBASICREF_HXX
+#define __SB_SBSTARBASICREF_HXX
+
+SV_DECL_IMPL_REF(StarBASIC)
+
+#endif
+
+#endif
+
--- basic/inc/basic/sbdef.hxx.bak	1970-01-01 08:00:00.000000000 +0800
+++ basic/inc/basic/sbdef.hxx	2007-10-15 11:51:06.000000000 +0800
@@ -0,0 +1,121 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile: sbdef.hxx,v $
+ *
+ *  $Revision: 1.2 $
+ *
+ *  last change: $Author: vg $ $Date: 2007/04/11 12:51:38 $
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+
+#ifndef _SB_SBDEF_HXX
+#define _SB_SBDEF_HXX
+
+#ifndef _SBXDEF_HXX
+#include <basic/sbxdef.hxx>
+#endif
+
+#ifndef _SVARRAY_HXX
+#include <svtools/svarray.hxx>
+#endif
+
+#define _BASIC_TEXTPORTIONS
+
+enum SbTextType {					// Typ eines Textteils (Syntax Hilite)
+	SB_KEYWORD = 1,					// Keywords
+	SB_SYMBOL,						// Symbole
+	SB_STRING,						// Strings
+	SB_NUMBER,						// Zahlen
+	SB_PUNCTUATION,					// Klammern, Punkte etc
+	SB_COMMENT,						// Kommentare
+    SB_DUMMY = 255                  // workaround for #i31479
+};
+
+enum SbLanguageMode {				// Aktive Sprache
+	SB_LANG_GLOBAL,					// wie in SbiGlobals-Struktur
+	SB_LANG_BASIC,					// StarBasic (Default)
+	SB_LANG_VBSCRIPT,				// Visual-Basic-Script
+	SB_LANG_JAVASCRIPT				// Java-Script
+};
+
+#ifdef _BASIC_TEXTPORTIONS
+struct SbTextPortion
+{									// Syntax Hiliting: eine Text-Portion
+	xub_StrLen nLine;					// Zeilennummer
+	xub_StrLen nStart, nEnd;			// 1. und letzte Spalte
+	SbTextType eType;				// Type der Portion
+};
+
+SV_DECL_VARARR(SbTextPortions, SbTextPortion,16,16)
+#else
+class SbTextPortions;
+#endif
+
+// Returns type name for Basic type, array flag is ignored
+// implementation: basic/source/runtime/methods.cxx
+String getBasicTypeName( SbxDataType eType );
+
+// Returns type name for Basic objects, especially
+// important for SbUnoObj instances
+// implementation: basic/source/classes/sbunoobj.cxx
+class SbxObject;
+String getBasicObjectTypeName( SbxObject* pObj );
+
+// Allows Basic IDE to set watch mode to suppress errors
+// implementation: basic/source/runtime/runtime.cxx
+void setBasicWatchMode( bool bOn );
+
+// Debug-Flags:
+
+#define SbDEBUG_BREAK       0x0001          // Break-Callback
+#define SbDEBUG_STEPINTO    0x0002          // Single Step-Callback
+#define SbDEBUG_STEPOVER    0x0004          // Zusatzflag Step Over
+#define	SbDEBUG_CONTINUE	0x0008			// Flags nicht aendern
+#define SbDEBUG_STEPOUT		0x0010          // Aus Sub raus
+
+#define SBXID_BASIC			0x6273			// sb: StarBASIC
+#define	SBXID_BASICMOD		0x6d62			// bm: StarBASIC-Modul
+#define SBXID_DOCUMENTMOD   0x6d63          // Special document Module
+#define SBXID_BASICPROP		0x7262			// pr: StarBASIC-Property
+#define	SBXID_BASICMETHOD	0x6d65          // me: StarBASIC-Methode
+#define	SBXID_JSCRIPTMOD	0x6a62			// jm: JavaScript-Modul
+#define	SBXID_JSCRIPTMETH	0x6a64			// jm: JavaScript-Modul
+
+#define SBX_HINT_BASICSTART		SFX_HINT_USER04
+#define SBX_HINT_BASICSTOP		SFX_HINT_USER05
+
+// #115826
+enum PropertyMode
+{
+	PROPERTY_MODE_NONE,
+	PROPERTY_MODE_GET,
+	PROPERTY_MODE_LET,
+	PROPERTY_MODE_SET
+};
+
+#endif
--- basic/source/uno/namecont.cxx.bak	1970-01-01 08:00:00.000000000 +0800
+++ basic/source/uno/namecont.cxx	2007-10-15 11:51:06.000000000 +0800
@@ -0,0 +1,2887 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile: namecont.cxx,v $
+ *
+ *  $Revision: 1.10 $
+ *
+ *  last change: $Author: hr $ $Date: 2007/06/27 14:33:56 $
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+
+// MARKER(update_precomp.py): autogen include statement, do not remove
+#include "precompiled_basic.hxx"
+
+#ifndef _COM_SUN_STAR_CONTAINER_XNAMECONTAINER_HPP_
+#include <com/sun/star/container/XNameContainer.hpp>
+#endif
+#ifndef _COM_SUN_STAR_CONTAINER_XCONTAINER_HPP_
+#include <com/sun/star/container/XContainer.hpp>
+#endif
+#ifndef _COM_SUN_STAR_EMBED_ELEMENTMODES_HPP_
+#include <com/sun/star/embed/ElementModes.hpp>
+#endif
+#ifndef _COM_SUN_STAR_EMBED_XTRANSACTEDOBJECT_HPP_
+#include <com/sun/star/embed/XTransactedObject.hpp>
+#endif
+#ifndef _COM_SUN_STAR_LANG_XSERVICEINFO_HPP_
+#include <com/sun/star/lang/XServiceInfo.hpp>
+#endif
+
+#ifndef _SV_SVAPP_HXX
+#include <vcl/svapp.hxx>
+#endif
+#ifndef _VOS_MUTEX_HXX_
+#include <vos/mutex.hxx>
+#endif
+#ifndef __RSC //autogen
+#include <tools/errinf.hxx>
+#endif
+#ifndef _OSL_MUTEX_HXX_
+#include <osl/mutex.hxx>
+#endif
+#ifndef _RTL_URI_HXX_
+#include <rtl/uri.hxx>
+#endif
+
+#ifndef _COMPHELPER_PROCESSFACTORY_HXX_
+#include <comphelper/processfactory.hxx>
+#endif
+#ifndef INCLUDED_COMPHELPER_ANYTOSTRING_HXX
+#include <comphelper/anytostring.hxx>
+#endif
+
+#include "namecont.hxx"
+#include <basic/basicmanagerrepository.hxx>
+
+#ifndef TOOLS_DIAGNOSE_EX_H
+#include <tools/diagnose_ex.h>
+#endif
+#ifndef _URLOBJ_HXX
+#include <tools/urlobj.hxx>
+#endif
+#ifndef _UTL_STREAM_WRAPPER_HXX_
+#include <unotools/streamwrap.hxx>
+#endif
+#ifndef INCLUDED_SVTOOLS_PATHOPTIONS_HXX
+#include <svtools/pathoptions.hxx>
+#endif
+#ifndef _SFXECODE_HXX
+#include <svtools/sfxecode.hxx>
+#endif
+#ifndef _EHDL_HXX
+#include <svtools/ehdl.hxx>
+#endif
+#ifndef _BASMGR_HXX
+#include <basic/basmgr.hxx>
+#endif
+
+#ifndef _COM_SUN_STAR_XML_SAX_XEXTENDEDDOCUMENTHANDLER_HPP_
+#include <com/sun/star/xml/sax/XExtendedDocumentHandler.hpp>
+#endif
+#ifndef _COM_SUN_STAR_XML_SAX_XPARSER_HPP_
+#include <com/sun/star/xml/sax/XParser.hpp>
+#endif
+#ifndef _COM_SUN_STAR_XML_SAX_INPUTSOURCE_HPP_
+#include <com/sun/star/xml/sax/InputSource.hpp>
+#endif
+#ifndef _COM_SUN_STAR_IO_XOUTPUTSTREAM_HPP_
+#include <com/sun/star/io/XOutputStream.hpp>
+#endif
+#ifndef _COM_SUN_STAR_IO_XINPUTSTREAM_HPP_
+#include <com/sun/star/io/XInputStream.hpp>
+#endif
+#ifndef _COM_SUN_STAR_IO_XACTIVEDATASOURCE_HPP_
+#include <com/sun/star/io/XActiveDataSource.hpp>
+#endif
+#ifndef _COM_SUN_STAR_BEANS_XPROPERTYSET_HPP_
+#include <com/sun/star/beans/XPropertySet.hpp>
+#endif
+#ifndef _COM_SUN_STAR_UNO_DEPLOYMENTEXCEPTION_HPP_
+#include <com/sun/star/uno/DeploymentException.hpp>
+#endif
+#ifndef _COM_SUN_STAR_LANG_DISPOSEDEXCEPTION_HPP_
+#include <com/sun/star/lang/DisposedException.hpp>
+#endif
+
+#ifndef _COMPHELPER_STORAGEHELPER_HXX
+#include <comphelper/storagehelper.hxx>
+#endif
+#ifndef _RTL_USTRING_HXX_
+#include <comphelper/anytostring.hxx>
+#endif
+#ifndef _CPPUHELPER_EXC_HLP_HXX_
+#include <cppuhelper/exc_hlp.hxx>
+#endif
+#include <basic/sbmod.hxx>
+
+#ifndef _COM_SUN_STAR_SCRIPT_MODULEINFO_HPP_
+#include <com/sun/star/script/ModuleInfo.hpp>
+#endif
+
+namespace basic
+{
+
+using namespace com::sun::star::document;
+using namespace com::sun::star::container;
+using namespace com::sun::star::uno;
+using namespace com::sun::star::lang;
+using namespace com::sun::star::io;
+using namespace com::sun::star::ucb;
+using namespace com::sun::star::script;
+using namespace com::sun::star::beans;
+using namespace com::sun::star::xml::sax;
+using namespace com::sun::star::util;
+using namespace com::sun::star::task;
+using namespace com::sun::star::embed;
+using namespace com::sun::star::frame;
+using namespace com::sun::star;
+using namespace cppu;
+using namespace rtl;
+using namespace osl;
+
+using com::sun::star::uno::Reference;
+
+// #i34411: Flag for error handling during migration 
+static bool GbMigrationSuppressErrors = false;
+
+//============================================================================
+// Implementation class NameContainer
+
+// Methods XElementAccess
+Type NameContainer::getElementType()
+	throw(RuntimeException)
+{
+	return mType;
+}
+
+sal_Bool NameContainer::hasElements()
+	throw(RuntimeException)
+{
+	sal_Bool bRet = (mnElementCount > 0);
+	return bRet;
+}
+
+// Methods XNameAccess
+Any NameContainer::getByName( const OUString& aName )
+	throw(NoSuchElementException, WrappedTargetException, RuntimeException)
+{
+	NameContainerNameMap::iterator aIt = mHashMap.find( aName );
+	if( aIt == mHashMap.end() )
+	{
+		throw NoSuchElementException();
+	}
+	sal_Int32 iHashResult = (*aIt).second;
+	Any aRetAny = mValues.getConstArray()[ iHashResult ];
+	return aRetAny;
+}
+
+Sequence< OUString > NameContainer::getElementNames()
+	throw(RuntimeException)
+{
+	return mNames;
+}
+
+sal_Bool NameContainer::hasByName( const OUString& aName )
+	throw(RuntimeException)
+{
+	NameContainerNameMap::iterator aIt = mHashMap.find( aName );
+	sal_Bool bRet = ( aIt != mHashMap.end() );
+	return bRet;
+}
+
+
+// Methods XNameReplace
+void NameContainer::replaceByName( const OUString& aName, const Any& aElement )
+	throw(IllegalArgumentException, NoSuchElementException, WrappedTargetException, RuntimeException)
+{
+	Type aAnyType = aElement.getValueType();
+    if( mType != aAnyType && aAnyType != getCppuType( static_cast< ModuleInfo* >( NULL ) ) )
+		throw IllegalArgumentException();
+
+	NameContainerNameMap::iterator aIt = mHashMap.find( aName );
+	if( aIt == mHashMap.end() )
+	{
+		throw NoSuchElementException();
+	}
+	sal_Int32 iHashResult = (*aIt).second;
+	Any aOldElement = mValues.getConstArray()[ iHashResult ];
+	mValues.getArray()[ iHashResult ] = aElement;
+
+
+	// Fire event
+	ContainerEvent aEvent;
+	aEvent.Source = mpxEventSource;
+	aEvent.Accessor <<= aName;
+	aEvent.Element = aElement;
+	aEvent.ReplacedElement = aOldElement;
+
+	OInterfaceIteratorHelper aIterator( maListenerContainer );
+	while( aIterator.hasMoreElements() )
+	{
+		Reference< XInterface > xIface = aIterator.next();
+		Reference< XContainerListener > xListener( xIface, UNO_QUERY );
+        try
+        {
+            xListener->elementReplaced( aEvent );
+        }
+        catch(RuntimeException&)
+        {
+            aIterator.remove();
+        }
+	}
+}
+
+
+// Methods XNameContainer
+void NameContainer::insertByName( const OUString& aName, const Any& aElement )
+	throw(IllegalArgumentException, ElementExistException, WrappedTargetException, RuntimeException)
+{
+	Type aAnyType = aElement.getValueType();
+    if( mType != aAnyType && aAnyType != getCppuType( static_cast< ModuleInfo* >( NULL ) ) )
+		throw IllegalArgumentException();
+
+	NameContainerNameMap::iterator aIt = mHashMap.find( aName );
+	if( aIt != mHashMap.end() )
+	{
+		throw ElementExistException();
+	}
+
+	sal_Int32 nCount = mNames.getLength();
+	mNames.realloc( nCount + 1 );
+	mValues.realloc( nCount + 1 );
+	mNames.getArray()[ nCount ] = aName;
+	mValues.getArray()[ nCount ] = aElement;
+
+	mHashMap[ aName ] = nCount;
+	mnElementCount++;
+
+
+	// Fire event
+	ContainerEvent aEvent;
+	aEvent.Source = mpxEventSource;
+	aEvent.Accessor <<= aName;
+	aEvent.Element = aElement;
+
+	OInterfaceIteratorHelper aIterator( maListenerContainer );
+	while( aIterator.hasMoreElements() )
+	{
+		Reference< XInterface > xIface = aIterator.next();
+		Reference< XContainerListener > xListener( xIface, UNO_QUERY );
+        try
+        {
+            xListener->elementInserted( aEvent );
+        }
+        catch(RuntimeException&)
+        {
+            aIterator.remove();
+        }
+	}
+}
+
+void NameContainer::removeByName( const OUString& Name )
+	throw(NoSuchElementException, WrappedTargetException, RuntimeException)
+{
+	NameContainerNameMap::iterator aIt = mHashMap.find( Name );
+	if( aIt == mHashMap.end() )
+	{
+		throw NoSuchElementException();
+	}
+
+	sal_Int32 iHashResult = (*aIt).second;
+	Any aOldElement = mValues.getConstArray()[ iHashResult ];
+	mHashMap.erase( aIt );
+	sal_Int32 iLast = mNames.getLength() - 1;
+	if( iLast != iHashResult )
+	{
+		OUString* pNames = mNames.getArray();
+		Any* pValues = mValues.getArray();
+		pNames[ iHashResult ] = pNames[ iLast ];
+		pValues[ iHashResult ] = pValues[ iLast ];
+		mHashMap[ pNames[ iHashResult ] ] = iHashResult;
+	}
+	mNames.realloc( iLast );
+	mValues.realloc( iLast );
+	mnElementCount--;
+
+
+	// Fire event
+	ContainerEvent aEvent;
+	aEvent.Source = mpxEventSource;
+	aEvent.Accessor <<= Name;
+	aEvent.Element = aOldElement;
+
+	OInterfaceIteratorHelper aIterator( maListenerContainer );
+	while( aIterator.hasMoreElements() )
+	{
+		Reference< XInterface > xIface = aIterator.next();
+		Reference< XContainerListener > xListener( xIface, UNO_QUERY );
+        try
+        {
+            xListener->elementRemoved( aEvent );
+        }
+        catch(RuntimeException&)
+        {
+            aIterator.remove();
+        }
+	}
+}
+
+
+// Methods XContainer
+void SAL_CALL NameContainer::addContainerListener( const Reference< XContainerListener >& xListener )
+	throw (RuntimeException)
+{
+	if( !xListener.is() )
+		throw RuntimeException();
+	Reference< XInterface > xIface( xListener, UNO_QUERY );
+	maListenerContainer.addInterface( xIface );
+}
+
+void SAL_CALL NameContainer::removeContainerListener( const Reference< XContainerListener >& xListener )
+	throw (RuntimeException)
+{
+	if( !xListener.is() )
+		throw RuntimeException();
+	Reference< XInterface > xIface( xListener, UNO_QUERY );
+	maListenerContainer.removeInterface( xIface );
+}
+
+//============================================================================
+// ModifiableHelper
+
+void ModifiableHelper::setModified( sal_Bool _bModified )
+{
+    if ( _bModified == mbModified )
+        return;
+    mbModified = _bModified;
+
+    if ( m_aModifyListeners.getLength() == 0 )
+        return;
+
+    EventObject aModifyEvent( m_rEventSource );
+    m_aModifyListeners.notifyEach( &XModifyListener::modified, aModifyEvent );
+}
+
+//============================================================================
+
+// Implementation class SfxLibraryContainer
+DBG_NAME( SfxLibraryContainer )
+
+// Ctor
+SfxLibraryContainer::SfxLibraryContainer( void )
+	: LibraryContainerHelper( maMutex )
+    , maModifiable( *this, maMutex )
+    , maNameContainer( getCppuType( (Reference< XNameAccess >*) NULL ) )
+    , mbOldInfoFormat( sal_False )
+    , mbOasis2OOoFormat( sal_False )
+    , mpBasMgr( NULL )
+    , mbOwnBasMgr( sal_False )
+{
+    DBG_CTOR( SfxLibraryContainer, NULL );
+
+	mxMSF = comphelper::getProcessServiceFactory();
+	if( !mxMSF.is() )
+	{
+		OSL_ENSURE( 0, "### couln't get ProcessServiceFactory\n" );
+	}
+
+	mxSFI = Reference< XSimpleFileAccess >( mxMSF->createInstance
+		( OUString::createFromAscii( "com.sun.star.ucb.SimpleFileAccess" ) ), UNO_QUERY );
+	if( !mxSFI.is() )
+	{
+		OSL_ENSURE( 0, "### couln't create SimpleFileAccess component\n" );
+	}
+
+	mxStringSubstitution = Reference< XStringSubstitution >( mxMSF->createInstance
+		( OUString::createFromAscii( "com.sun.star.util.PathSubstitution" ) ), UNO_QUERY );
+	if( !mxStringSubstitution.is() )
+	{
+		OSL_ENSURE( 0, "### couln't create PathSubstitution component\n" );
+	}
+}
+
+SfxLibraryContainer::~SfxLibraryContainer()
+{
+    if( mbOwnBasMgr )
+        BasicManager::LegacyDeleteBasicManager( mpBasMgr );
+    DBG_DTOR( SfxLibraryContainer, NULL );
+}
+
+void SfxLibraryContainer::checkDisposed() const
+{
+    if ( isDisposed() )
+        throw DisposedException( ::rtl::OUString(), *const_cast< SfxLibraryContainer* >( this ) );
+}
+
+void SfxLibraryContainer::enterMethod()
+{
+    Application::GetSolarMutex().acquire();
+    maMutex.acquire();
+    checkDisposed();
+}
+
+void SfxLibraryContainer::leaveMethod()
+{
+    maMutex.release();
+    Application::GetSolarMutex().release();
+}
+
+BasicManager* SfxLibraryContainer::getBasicManager( void )
+{
+    if ( mpBasMgr )
+        return mpBasMgr;
+
+    Reference< XModel > xDocument( mxOwnerDocument.get(), UNO_QUERY );
+    OSL_ENSURE( xDocument.is(), "SfxLibraryContainer::getBasicManager: cannot obtain a BasicManager without document!" );
+    if ( xDocument.is() )
+        mpBasMgr = BasicManagerRepository::getDocumentBasicManager( xDocument );
+
+    return mpBasMgr;
+}
+
+// Methods XStorageBasedLibraryContainer
+Reference< XStorage > SAL_CALL SfxLibraryContainer::getRootStorage() throw (RuntimeException)
+{
+    LibraryContainerMethodGuard aGuard( *this );
+    return mxStorage;
+}
+
+void SAL_CALL SfxLibraryContainer::setRootStorage( const Reference< XStorage >& _rxRootStorage ) throw (IllegalArgumentException, RuntimeException)
+{
+    LibraryContainerMethodGuard aGuard( *this );
+    if ( !_rxRootStorage.is() )
+        throw IllegalArgumentException();
+
+	mxStorage = _rxRootStorage;
+	implSetStorage( _rxRootStorage );
+}
+
+void SAL_CALL SfxLibraryContainer::storeLibrariesToStorage( const Reference< XStorage >& _rxRootStorage ) throw (IllegalArgumentException, WrappedTargetException, RuntimeException)
+{
+    LibraryContainerMethodGuard aGuard( *this );
+    if ( !_rxRootStorage.is() )
+        throw IllegalArgumentException();
+
+    try
+    {
+        storeLibraries_Impl( _rxRootStorage, sal_True );
+    }
+    catch( const Exception& )
+    {
+        throw WrappedTargetException( ::rtl::OUString(), *this, ::cppu::getCaughtException() );
+    }
+}
+
+
+// Methods XModifiable
+sal_Bool SfxLibraryContainer::isModified() throw (RuntimeException)
+{
+    LibraryContainerMethodGuard aGuard( *this );
+	if ( maModifiable.isModified() )
+		return sal_True;
+
+	// the library container is not modified, go through the libraries and check whether they are modified
+	Sequence< OUString > aNames = maNameContainer.getElementNames();
+	const OUString* pNames = aNames.getConstArray();
+	sal_Int32 nNameCount = aNames.getLength();
+
+	for( sal_Int32 i = 0 ; i < nNameCount ; i++ )
+	{
+		OUString aName = pNames[ i ];
+        SfxLibrary* pImplLib = getImplLib( aName );
+		if( pImplLib->isModified() )
+		{
+			if ( aName.equals( ::rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Standard") ) ) )
+			{
+				// this is a workaround that has to be implemented because
+				// empty standard library should stay marked as modified
+				// but should not be treated as modified while it is empty
+				if ( pImplLib->hasElements() )
+					return sal_True;
+			}
+			else
+				return sal_True;
+		}
+	}
+
+	return sal_False;
+}
+
+void SAL_CALL SfxLibraryContainer::setModified( sal_Bool _bModified ) throw (PropertyVetoException, RuntimeException)
+{
+    LibraryContainerMethodGuard aGuard( *this );
+    maModifiable.setModified( _bModified );
+}
+
+void SAL_CALL SfxLibraryContainer::addModifyListener( const Reference< XModifyListener >& _rxListener ) throw (RuntimeException)
+{
+    LibraryContainerMethodGuard aGuard( *this );
+    maModifiable.addModifyListener( _rxListener );
+}
+
+void SAL_CALL SfxLibraryContainer::removeModifyListener( const Reference< XModifyListener >& _rxListener ) throw (RuntimeException)
+{
+    LibraryContainerMethodGuard aGuard( *this );
+    maModifiable.removeModifyListener( _rxListener );
+}
+
+// Methods XPersistentLibraryContainer
+Any SAL_CALL SfxLibraryContainer::getRootLocation() throw (RuntimeException)
+{
+    LibraryContainerMethodGuard aGuard( *this );
+    return makeAny( getRootStorage() );
+}
+
+::rtl::OUString SAL_CALL SfxLibraryContainer::getContainerLocationName() throw (RuntimeException)
+{
+    LibraryContainerMethodGuard aGuard( *this );
+    return maLibrariesDir;
+}
+
+void SAL_CALL SfxLibraryContainer::storeLibraries(  ) throw (WrappedTargetException, RuntimeException)
+{
+    LibraryContainerMethodGuard aGuard( *this );
+    try
+    {
+	    storeLibraries_Impl( NULL, sal_False );
+    }
+    catch( const Exception& )
+    {
+        throw WrappedTargetException( ::rtl::OUString(), *this, ::cppu::getCaughtException() );
+    }
+}
+
+static void checkAndCopyFileImpl( const INetURLObject& rSourceFolderInetObj,
+								  const INetURLObject& rTargetFolderInetObj,
+								  const OUString& rCheckFileName,
+								  const OUString& rCheckExtension,
+								  Reference< XSimpleFileAccess > xSFI )
+{
+	INetURLObject aTargetFolderInetObj( rTargetFolderInetObj );
+	aTargetFolderInetObj.insertName( rCheckFileName, sal_True, INetURLObject::LAST_SEGMENT,
+									 sal_True, INetURLObject::ENCODE_ALL );
+	aTargetFolderInetObj.setExtension( rCheckExtension );
+	OUString aTargetFile = aTargetFolderInetObj.GetMainURL( INetURLObject::NO_DECODE );
+	if( !xSFI->exists( aTargetFile ) )
+	{
+		INetURLObject aSourceFolderInetObj( rSourceFolderInetObj );
+		aSourceFolderInetObj.insertName( rCheckFileName, sal_True, INetURLObject::LAST_SEGMENT,
+										 sal_True, INetURLObject::ENCODE_ALL );
+		aSourceFolderInetObj.setExtension( rCheckExtension );
+		OUString aSourceFile = aSourceFolderInetObj.GetMainURL( INetURLObject::NO_DECODE );
+		xSFI->copy( aSourceFile, aTargetFile );
+	}
+}
+
+static void createVariableURL( OUString& rStr, const OUString& rLibName,
+							   const OUString& rInfoFileName, bool bUser )
+{
+	if( bUser )
+		rStr = OUString::createFromAscii( "$(USER)/basic/" );
+	else
+		rStr = OUString::createFromAscii( "$(INST)/share/basic/" );
+
+	rStr += rLibName;
+	rStr += OUString::createFromAscii( "/" );
+	rStr += rInfoFileName;
+	rStr += OUString::createFromAscii( ".xlb/" );
+}
+
+sal_Bool SfxLibraryContainer::init( const OUString& rInitialDocumentURL, const uno::Reference< embed::XStorage >& rxInitialStorage )
+{
+    // this might be called from within the ctor, and the impl_init might (indirectly) create
+    // an UNO reference to ourself.
+    // Ensure that we're not destroyed while we're in here
+    osl_incrementInterlockedCount( &m_refCount );
+    sal_Bool bSuccess = init_Impl( rInitialDocumentURL, rxInitialStorage );
+    osl_decrementInterlockedCount( &m_refCount );
+
+    return bSuccess;
+}
+
+sal_Bool SfxLibraryContainer::init_Impl(
+    const OUString& rInitialDocumentURL, const uno::Reference< embed::XStorage >& rxInitialStorage )
+{
+	uno::Reference< embed::XStorage > xStorage = rxInitialStorage;
+
+    maInitialDocumentURL = rInitialDocumentURL;
+    maInfoFileName = OUString::createFromAscii( getInfoFileName() );
+	maOldInfoFileName = OUString::createFromAscii( getOldInfoFileName() );
+	maLibElementFileExtension = OUString::createFromAscii( getLibElementFileExtension() );
+	maLibrariesDir = OUString::createFromAscii( getLibrariesDir() );
+
+    meInitMode = DEFAULT;
+    INetURLObject aInitUrlInetObj( maInitialDocumentURL );
+    OUString aInitFileName = aInitUrlInetObj.GetMainURL( INetURLObject::NO_DECODE );
+    if( aInitFileName.getLength() )
+    {
+        // We need a BasicManager to avoid problems
+        StarBASIC* pBas = new StarBASIC();
+        mpBasMgr = new BasicManager( pBas );
+        mbOwnBasMgr = sal_True;
+
+        OUString aExtension = aInitUrlInetObj.getExtension();
+        if( aExtension.compareToAscii( "xlc" ) == COMPARE_EQUAL )
+        {
+            meInitMode = CONTAINER_INIT_FILE;
+	        INetURLObject aLibPathInetObj( aInitUrlInetObj );
+			aLibPathInetObj.removeSegment();
+	        maLibraryPath = aLibPathInetObj.GetMainURL( INetURLObject::NO_DECODE );
+        }
+        else if( aExtension.compareToAscii( "xlb" ) == COMPARE_EQUAL )
+        {
+            meInitMode = LIBRARY_INIT_FILE;
+        	uno::Reference< embed::XStorage > xDummyStor;
+            ::xmlscript::LibDescriptor aLibDesc;
+            sal_Bool bReadIndexFile = implLoadLibraryIndexFile( NULL, aLibDesc, xDummyStor, aInitFileName );
+           	return bReadIndexFile;
+        }
+        else
+        {
+            // Decide between old and new document
+            sal_Bool bOldStorage = SotStorage::IsOLEStorage( aInitFileName );
+            if ( bOldStorage )
+            {
+                meInitMode = OLD_BASIC_STORAGE;
+                importFromOldStorage( aInitFileName );
+                return sal_True;
+            }
+            else
+            {
+                meInitMode = OFFICE_DOCUMENT;
+                try
+                {
+                    xStorage = ::comphelper::OStorageHelper::GetStorageFromURL( aInitFileName, embed::ElementModes::READ );
+                }
+                catch ( uno::Exception& )
+                {
+                    // TODO: error handling
+                }
+            }
+        }
+    }
+    else
+    {
+        // Default pathes
+        maLibraryPath = SvtPathOptions().GetBasicPath();
+    }
+
+	Reference< XParser > xParser( mxMSF->createInstance(
+		OUString( RTL_CONSTASCII_USTRINGPARAM("com.sun.star.xml.sax.Parser") ) ), UNO_QUERY );
+	if( !xParser.is() )
+	{
+		OSL_ENSURE( 0, "### couln't create sax parser component\n" );
+		return sal_False;
+	}
+
+	uno::Reference< io::XInputStream > xInput;
+
+	mxStorage = xStorage;
+	sal_Bool bStorage = mxStorage.is();
+
+
+	// #110009: Scope to force the StorageRefs to be destructed and
+	// so the streams to be closed before the preload operation
+	{
+	// #110009
+
+	uno::Reference< embed::XStorage > xLibrariesStor;
+	String aFileName;
+
+	int nPassCount = 1;
+	if( !bStorage && meInitMode == DEFAULT )
+		nPassCount = 2;
+	for( int nPass = 0 ; nPass < nPassCount ; nPass++ )
+	{
+		if( bStorage )
+		{
+			OSL_ENSURE( meInitMode == DEFAULT || meInitMode == OFFICE_DOCUMENT,
+				"### Wrong InitMode for document\n" );
+			try
+			{
+				uno::Reference< io::XStream > xStream;
+				xLibrariesStor = xStorage->openStorageElement( maLibrariesDir, embed::ElementModes::READ );
+                //if ( !xLibrariesStor.is() )
+                    // TODO: the method must either return a storage or throw an exception
+                    //throw uno::RuntimeException();
+
+                if ( xLibrariesStor.is() )
+                {
+                    aFileName = maInfoFileName;
+                    aFileName += String( RTL_CONSTASCII_USTRINGPARAM("-lc.xml") );
+
+                    try
+                    {
+                        xStream = xLibrariesStor->openStreamElement( aFileName, embed::ElementModes::READ );
+                    }
+                    catch( uno::Exception& )
+                    {}
+
+                    if( !xStream.is() )
+                    {
+                        mbOldInfoFormat = true;
+
+                        // Check old version
+                        aFileName = maOldInfoFileName;
+                        aFileName += String( RTL_CONSTASCII_USTRINGPARAM(".xml") );
+
+                        try
+                        {
+                            xStream = xLibrariesStor->openStreamElement( aFileName, embed::ElementModes::READ );
+                        }
+                        catch( uno::Exception& )
+                        {}
+
+                        if( !xStream.is() )
+                        {
+                            // Check for EA2 document version with wrong extensions
+                            aFileName = maOldInfoFileName;
+                            aFileName += String( RTL_CONSTASCII_USTRINGPARAM(".xli") );
+                            xStream = xLibrariesStor->openStreamElement( aFileName, embed::ElementModes::READ );
+                        }
+                    }
+				}
+
+				if ( xStream.is() )
+					xInput = xStream->getInputStream();
+			}
+			catch( uno::Exception& )
+			{
+                // TODO: error handling?
+			}
+		}
+		else
+		{
+			INetURLObject* pLibInfoInetObj = NULL;
+			if( meInitMode == CONTAINER_INIT_FILE )
+			{
+				aFileName = aInitFileName;
+			}
+			else
+			{
+				if( nPass == 1 )
+					pLibInfoInetObj = new INetURLObject( String(maLibraryPath).GetToken(0) );
+				else
+					pLibInfoInetObj = new INetURLObject( String(maLibraryPath).GetToken(1) );
+				pLibInfoInetObj->insertName( maInfoFileName, sal_True, INetURLObject::LAST_SEGMENT, sal_True, INetURLObject::ENCODE_ALL );
+				pLibInfoInetObj->setExtension( OUString( RTL_CONSTASCII_USTRINGPARAM("xlc") ) );
+				aFileName = pLibInfoInetObj->GetMainURL( INetURLObject::NO_DECODE );
+			}
+
+			try
+			{
+				xInput = mxSFI->openFileRead( aFileName );
+			}
+			catch( Exception& )
+			{
+				xInput.clear();
+                if( nPass == 0 )
+                {
+		            SfxErrorContext aEc( ERRCTX_SFX_LOADBASIC, aFileName );
+                    ULONG nErrorCode = ERRCODE_IO_GENERAL;
+                    ErrorHandler::HandleError( nErrorCode );
+                }
+			}
+
+			// Old variant?
+			if( !xInput.is() && nPass == 0 )
+			{
+				INetURLObject aLibInfoInetObj( String(maLibraryPath).GetToken(1) );
+				aLibInfoInetObj.insertName( maOldInfoFileName, sal_True, INetURLObject::LAST_SEGMENT, sal_True, INetURLObject::ENCODE_ALL );
+				aLibInfoInetObj.setExtension( OUString( RTL_CONSTASCII_USTRINGPARAM("xli") ) );
+				aFileName = aLibInfoInetObj.GetMainURL( INetURLObject::NO_DECODE );
+
+				try
+				{
+					xInput = mxSFI->openFileRead( aFileName );
+					mbOldInfoFormat = true;
+				}
+				catch( Exception& )
+				{
+    				xInput.clear();
+		            SfxErrorContext aEc( ERRCTX_SFX_LOADBASIC, aFileName );
+                    ULONG nErrorCode = ERRCODE_IO_GENERAL;
+                    ErrorHandler::HandleError( nErrorCode );
+				}
+			}
+
+			delete pLibInfoInetObj;
+		}
+
+		if( xInput.is() )
+        {
+		    InputSource source;
+		    source.aInputStream = xInput;
+		    source.sSystemId 	= aFileName;
+
+		    // start parsing
+		    ::xmlscript::LibDescriptorArray* pLibArray = new ::xmlscript::LibDescriptorArray();
+
+            try
+            {
+                xParser->setDocumentHandler( ::xmlscript::importLibraryContainer( pLibArray ) );
+                xParser->parseStream( source );
+            }
+            catch ( xml::sax::SAXException& e )
+            {
+                (void) e; // avoid warning
+                OSL_ENSURE( 0, OUStringToOString( e.Message, RTL_TEXTENCODING_ASCII_US ).getStr() );
+                return sal_False;
+            }
+            catch ( io::IOException& e )
+            {
+                (void) e; // avoid warning
+                OSL_ENSURE( 0, OUStringToOString( e.Message, RTL_TEXTENCODING_ASCII_US ).getStr() );
+                return sal_False;
+            }
+
+		    sal_Int32 nLibCount = pLibArray->mnLibCount;
+		    for( sal_Int32 i = 0 ; i < nLibCount ; i++ )
+		    {
+			    ::xmlscript::LibDescriptor& rLib = pLibArray->mpLibs[i];
+
+			    // Check storage URL
+			    OUString aStorageURL = rLib.aStorageURL;
+			    if( !bStorage && !aStorageURL.getLength() && nPass == 0 )
+			    {
+					String aLibraryPath;
+					if( meInitMode == CONTAINER_INIT_FILE )
+						aLibraryPath = maLibraryPath;
+					else
+						aLibraryPath = String(maLibraryPath).GetToken(1);
+					INetURLObject aInetObj( aLibraryPath );
+
+				    aInetObj.insertName( rLib.aName, sal_True, INetURLObject::LAST_SEGMENT,
+					    sal_True, INetURLObject::ENCODE_ALL );
+				    OUString aLibDirPath = aInetObj.GetMainURL( INetURLObject::NO_DECODE );
+				    if( mxSFI->isFolder( aLibDirPath ) )
+				    {
+						createVariableURL( rLib.aStorageURL, rLib.aName, maInfoFileName, true );
+                        maModifiable.setModified( sal_True );
+				    }
+				    else if( rLib.bLink )
+				    {
+					    // Check "share" path
+					    INetURLObject aShareInetObj( String(maLibraryPath).GetToken(0) );
+					    aShareInetObj.insertName( rLib.aName, sal_True, INetURLObject::LAST_SEGMENT,
+						    sal_True, INetURLObject::ENCODE_ALL );
+					    OUString aShareLibDirPath = aShareInetObj.GetMainURL( INetURLObject::NO_DECODE );
+					    if( mxSFI->isFolder( aShareLibDirPath ) )
+					    {
+							createVariableURL( rLib.aStorageURL, rLib.aName, maInfoFileName, false );
+                            maModifiable.setModified( sal_True );
+					    }
+						else
+						{
+							// #i25537: Ignore lib if library folder does not really exist
+							continue;
+						}
+				    }
+			    }
+
+			    OUString aLibName = rLib.aName;
+
+			    // If the same library name is used by the shared and the
+			    // user lib container index files the user file wins
+			    if( nPass == 1 && hasByName( aLibName ) )
+				    continue;
+
+			    SfxLibrary* pImplLib;
+			    if( rLib.bLink )
+			    {
+				    Reference< XNameAccess > xLib =
+					    createLibraryLink( aLibName, rLib.aStorageURL, rLib.bReadOnly );
+				    pImplLib = static_cast< SfxLibrary* >( xLib.get() );
+			    }
+			    else
+			    {
+				    Reference< XNameContainer > xLib = createLibrary( aLibName );
+				    pImplLib = static_cast< SfxLibrary* >( xLib.get() );
+				    pImplLib->mbLoaded = sal_False;
+				    pImplLib->mbReadOnly = rLib.bReadOnly;
+				    if( !bStorage )
+					    checkStorageURL( rLib.aStorageURL, pImplLib->maLibInfoFileURL,
+                            pImplLib->maStorageURL, pImplLib->maUnexpandedStorageURL );
+			    }
+				maModifiable.setModified( sal_False );
+
+			    // Read library info files
+			    if( !mbOldInfoFormat )
+			    {
+        		    uno::Reference< embed::XStorage > xLibraryStor;
+          		    if( !pImplLib->mbInitialised && bStorage )
+				    {
+						try {
+							xLibraryStor = xLibrariesStor->openStorageElement( rLib.aName,
+																				embed::ElementModes::READ );
+						}
+						catch( uno::Exception& )
+						{
+						    OSL_ENSURE( 0, "### couln't open sub storage for library\n" );
+						}
+				    }
+
+				    // Link is already initialised in createLibraryLink()
+				    if( !pImplLib->mbInitialised && (!bStorage || xLibraryStor.is()) )
+				    {
+					    OUString aIndexFileName;
+					    sal_Bool bLoaded = implLoadLibraryIndexFile( pImplLib, rLib, xLibraryStor, aIndexFileName );
+					    if( bLoaded && aLibName != rLib.aName )
+					    {
+						    OSL_ENSURE( 0, "Different library names in library"
+							    " container and library info files!\n" );
+					    }
+						if( GbMigrationSuppressErrors && !bLoaded )
+							removeLibrary( aLibName );
+				    }
+			    }
+			    else if( !bStorage )
+			    {
+				    // Write new index file immediately because otherwise
+				    // the library elements will be lost when storing into
+				    // the new info format
+				    uno::Reference< embed::XStorage > xTmpStorage;
+				    implStoreLibraryIndexFile( pImplLib, rLib, xTmpStorage );
+			    }
+
+			    implImportLibDescriptor( pImplLib, rLib );
+
+			    if( nPass == 1 )
+			    {
+				    pImplLib->mbSharedIndexFile = sal_True;
+				    pImplLib->mbReadOnly = sal_True;
+			    }
+		    }
+
+		    // Keep flag for documents to force writing the new index files
+		    if( !bStorage )
+			    mbOldInfoFormat = sal_False;
+
+		    delete pLibArray;
+        }
+		// Only in the first pass it's an error when no index file is found
+		else if( nPass == 0 )
+		{
+			return sal_False;
+		}
+	}
+
+	// #110009: END Scope to force the StorageRefs to be destructed
+	}
+	// #110009
+
+	// #110009 Preload?
+    {
+	    Sequence< OUString > aNames = maNameContainer.getElementNames();
+	    const OUString* pNames = aNames.getConstArray();
+	    sal_Int32 nNameCount = aNames.getLength();
+	    for( sal_Int32 i = 0 ; i < nNameCount ; i++ )
+	    {
+		    OUString aName = pNames[ i ];
+            SfxLibrary* pImplLib = getImplLib( aName );
+		    if( pImplLib->mbPreload )
+			    loadLibrary( aName );
+	    }
+    }
+
+    // #118803# upgrade installation 7.0 -> 8.0
+    if( meInitMode == DEFAULT )
+    {
+        INetURLObject aUserBasicInetObj( String(maLibraryPath).GetToken(1) );
+		OUString aStandardStr( RTL_CONSTASCII_USTRINGPARAM("Standard") );
+
+		static char strPrevFolderName_1[] = "__basic_70";
+		static char strPrevFolderName_2[] = "__basic_70_2";
+        INetURLObject aPrevUserBasicInetObj_1( aUserBasicInetObj );
+        aPrevUserBasicInetObj_1.removeSegment();
+		INetURLObject aPrevUserBasicInetObj_2 = aPrevUserBasicInetObj_1;
+	    aPrevUserBasicInetObj_1.Append( strPrevFolderName_1 );
+	    aPrevUserBasicInetObj_2.Append( strPrevFolderName_2 );
+
+		INetURLObject aPrevUserBasicInetObj = aPrevUserBasicInetObj_1;
+        String aPrevFolder = aPrevUserBasicInetObj.GetMainURL( INetURLObject::NO_DECODE );
+		bool bSecondTime = false;
+	    if( mxSFI->isFolder( aPrevFolder ) )
+		{
+			// #110101 Check if Standard folder exists and is complete
+	        INetURLObject aUserBasicStandardInetObj( aUserBasicInetObj );
+			aUserBasicStandardInetObj.insertName( aStandardStr, sal_True, INetURLObject::LAST_SEGMENT,
+												  sal_True, INetURLObject::ENCODE_ALL );
+            INetURLObject aPrevUserBasicStandardInetObj( aPrevUserBasicInetObj );
+		    aPrevUserBasicStandardInetObj.insertName( aStandardStr, sal_True, INetURLObject::LAST_SEGMENT,
+                                                    sal_True, INetURLObject::ENCODE_ALL );
+		    OUString aPrevStandardFolder = aPrevUserBasicStandardInetObj.GetMainURL( INetURLObject::NO_DECODE );
+		    if( mxSFI->isFolder( aPrevStandardFolder ) )
+			{
+				OUString aXlbExtension( OUString( RTL_CONSTASCII_USTRINGPARAM("xlb") ) );
+				OUString aCheckFileName;
+
+				// Check if script.xlb exists
+				aCheckFileName = OUString( RTL_CONSTASCII_USTRINGPARAM("script") );
+				checkAndCopyFileImpl( aUserBasicStandardInetObj,
+									  aPrevUserBasicStandardInetObj,
+									  aCheckFileName, aXlbExtension, mxSFI );
+
+				// Check if dialog.xlb exists
+				aCheckFileName = OUString( RTL_CONSTASCII_USTRINGPARAM("dialog") );
+				checkAndCopyFileImpl( aUserBasicStandardInetObj,
+									  aPrevUserBasicStandardInetObj,
+									  aCheckFileName, aXlbExtension, mxSFI );
+
+				// Check if module1.xba exists
+				OUString aXbaExtension( OUString( RTL_CONSTASCII_USTRINGPARAM("xba") ) );
+				aCheckFileName = OUString( RTL_CONSTASCII_USTRINGPARAM("Module1") );
+				checkAndCopyFileImpl( aUserBasicStandardInetObj,
+									  aPrevUserBasicStandardInetObj,
+									  aCheckFileName, aXbaExtension, mxSFI );
+			}
+			else
+		    {
+	            String aStandardFolder = aUserBasicStandardInetObj.GetMainURL( INetURLObject::NO_DECODE );
+		        mxSFI->copy( aStandardFolder, aPrevStandardFolder );
+			}
+
+			String aPrevCopyToFolder = aPrevUserBasicInetObj_2.GetMainURL( INetURLObject::NO_DECODE );
+	        mxSFI->copy( aPrevFolder, aPrevCopyToFolder );
+		}
+		else
+		{
+			bSecondTime = true;
+			aPrevUserBasicInetObj = aPrevUserBasicInetObj_2;
+			aPrevFolder = aPrevUserBasicInetObj.GetMainURL( INetURLObject::NO_DECODE );
+		}
+	    if( mxSFI->isFolder( aPrevFolder ) )
+        {
+            SfxLibraryContainer* pPrevCont = createInstanceImpl();
+            Reference< XInterface > xRef = static_cast< XInterface* >( static_cast< OWeakObject* >(pPrevCont) );
+
+            // Rename previous basic folder to make storage URLs correct during initialisation
+            String aFolderUserBasic = aUserBasicInetObj.GetMainURL( INetURLObject::NO_DECODE );
+            INetURLObject aUserBasicTmpInetObj( aUserBasicInetObj );
+            aUserBasicTmpInetObj.removeSegment();
+	        aUserBasicTmpInetObj.Append( "__basic_tmp" );
+            String aFolderTmp = aUserBasicTmpInetObj.GetMainURL( INetURLObject::NO_DECODE );
+
+			bool bMoveOk = true;
+			try
+				{ mxSFI->move( aFolderUserBasic, aFolderTmp ); }
+			catch( CommandAbortedException& )
+				{ bMoveOk = false; }
+			catch( Exception& )
+				{ bMoveOk = false; }
+			if( bMoveOk )
+			{
+				try
+					{ mxSFI->move( aPrevFolder, aFolderUserBasic ); }
+				catch( CommandAbortedException& )
+					{ bMoveOk = false; }
+				catch( Exception& )
+					{ bMoveOk = false; }
+				if( !bMoveOk )
+				{
+					// Move back user/basic folder
+					try
+						{ mxSFI->move( aFolderTmp, aFolderUserBasic ); }
+					catch( CommandAbortedException& ) {}
+					catch( Exception& ) {}
+				}
+			}
+
+			if( bMoveOk )
+			{
+				INetURLObject aPrevUserBasicLibInfoInetObj( aUserBasicInetObj );
+				aPrevUserBasicLibInfoInetObj.insertName( maInfoFileName, sal_True, INetURLObject::LAST_SEGMENT,
+													sal_True, INetURLObject::ENCODE_ALL );
+				aPrevUserBasicLibInfoInetObj.setExtension( OUString( RTL_CONSTASCII_USTRINGPARAM("xlc") ) );
+				OUString aLibInfoFileName = aPrevUserBasicLibInfoInetObj.GetMainURL( INetURLObject::NO_DECODE );
+				Sequence<Any> aInitSeq( 1 );
+				aInitSeq.getArray()[0] <<= aLibInfoFileName;
+				GbMigrationSuppressErrors = true;
+				pPrevCont->initialize( aInitSeq );
+				GbMigrationSuppressErrors = false;
+
+				// Rename folders back
+				mxSFI->move( aFolderUserBasic, aPrevFolder );
+				mxSFI->move( aFolderTmp, aFolderUserBasic );
+
+				// Detect old share/basic folder to destinguish
+				// between own links and links to wizards
+				INetURLObject aPrevOrgShareFolderInetObj;
+				if( pPrevCont->hasByName( aStandardStr ) )
+				{
+					SfxLibrary* pImplLib = pPrevCont->getImplLib( aStandardStr );
+					aPrevOrgShareFolderInetObj = INetURLObject( pImplLib->maStorageURL );
+					for( int i = 0 ; i < 3 ; ++ i )
+						aPrevOrgShareFolderInetObj.removeSegment();
+        			aPrevOrgShareFolderInetObj.Append( "share" );
+        			aPrevOrgShareFolderInetObj.Append( "basic" );
+				}
+
+				Sequence< OUString > aNames = pPrevCont->getElementNames();
+				const OUString* pNames = aNames.getConstArray();
+				sal_Int32 nNameCount = aNames.getLength();
+
+				for( sal_Int32 i = 0 ; i < nNameCount ; i++ )
+				{
+					OUString aLibName = pNames[ i ];
+					if( hasByName( aLibName ) )
+					{
+						if( aLibName == aStandardStr )
+						{
+							SfxLibrary* pImplLib = getImplLib( aStandardStr );
+							INetURLObject aStandardFolderInetObj( pImplLib->maStorageURL );
+							String aStandardFolder = pImplLib->maStorageURL;
+                			mxSFI->kill( aStandardFolder );
+						}
+						else
+						{
+							continue;
+						}
+					}
+
+					SfxLibrary* pImplLib = pPrevCont->getImplLib( aLibName );
+					if( pImplLib->mbLink )
+					{
+						INetURLObject aPrevLinkInetObj( pImplLib->maStorageURL );
+						for( int j = 0 ; j < 3 ; ++ j )
+							aPrevLinkInetObj.removeSegment();
+        				aPrevLinkInetObj.Append( "share" );
+        				aPrevLinkInetObj.Append( "basic" );
+						if( aPrevLinkInetObj != aPrevOrgShareFolderInetObj )
+							createLibraryLink( aLibName, pImplLib->maStorageURL, pImplLib->mbReadOnly );
+					}
+					else
+					{
+						// Move folder if not already done
+						INetURLObject aUserBasicLibFolderInetObj( aUserBasicInetObj );
+        				aUserBasicLibFolderInetObj.Append( aLibName );
+						String aLibFolder = aUserBasicLibFolderInetObj.GetMainURL( INetURLObject::NO_DECODE );
+
+						INetURLObject aPrevUserBasicLibFolderInetObj( aPrevUserBasicInetObj );
+        				aPrevUserBasicLibFolderInetObj.Append( aLibName );
+						String aPrevLibFolder = aPrevUserBasicLibFolderInetObj.GetMainURL( INetURLObject::NO_DECODE );
+
+						if( mxSFI->isFolder( aPrevLibFolder ) && !mxSFI->isFolder( aLibFolder ) )
+							mxSFI->move( aPrevLibFolder, aLibFolder );
+
+						if( aLibName == aStandardStr )
+                       		maNameContainer.removeByName( aLibName );
+
+						// Create library
+						Reference< XNameContainer > xLib = createLibrary( aLibName );
+               			SfxLibrary* pNewLib = static_cast< SfxLibrary* >( xLib.get() );
+						pNewLib->mbLoaded = false;
+						pNewLib->implSetModified( sal_False );
+						checkStorageURL( aLibFolder, pNewLib->maLibInfoFileURL,
+							pNewLib->maStorageURL, pNewLib->maUnexpandedStorageURL );
+
+						uno::Reference< embed::XStorage > xDummyStor;
+						::xmlscript::LibDescriptor aLibDesc;
+						/*sal_Bool bReadIndexFile =*/ implLoadLibraryIndexFile
+							( pNewLib, aLibDesc, xDummyStor, pNewLib->maLibInfoFileURL );
+						implImportLibDescriptor( pNewLib, aLibDesc );
+					}
+				}
+   				mxSFI->kill( aPrevFolder );
+			}	// if( bMoveOk )
+        }
+    }
+
+	return sal_True;
+}
+
+// Handle maLibInfoFileURL and maStorageURL correctly
+void SfxLibraryContainer::checkStorageURL( const OUString& aSourceURL,
+    OUString& aLibInfoFileURL, OUString& aStorageURL, OUString& aUnexpandedStorageURL )
+{
+    OUString aExpandedSourceURL = expand_url( aSourceURL );
+    if( aExpandedSourceURL != aSourceURL )
+        aUnexpandedStorageURL = aSourceURL;
+
+	INetURLObject aInetObj( aExpandedSourceURL );
+    OUString aExtension = aInetObj.getExtension();
+    if( aExtension.compareToAscii( "xlb" ) == COMPARE_EQUAL )
+    {
+        // URL to xlb file
+		aLibInfoFileURL = aExpandedSourceURL;
+        aInetObj.removeSegment();
+		aStorageURL = aInetObj.GetMainURL( INetURLObject::NO_DECODE );
+    }
+    else
+    {
+        // URL to library folder
+        aStorageURL = aExpandedSourceURL;
+		aInetObj.insertName( maInfoFileName, sal_True, INetURLObject::LAST_SEGMENT, sal_True, INetURLObject::ENCODE_ALL );
+		aInetObj.setExtension( OUString( RTL_CONSTASCII_USTRINGPARAM("xlb") ) );
+		aLibInfoFileURL = aInetObj.GetMainURL( INetURLObject::NO_DECODE );
+    }
+}
+
+SfxLibrary* SfxLibraryContainer::getImplLib( const String& rLibraryName )
+{
+	Any aLibAny = maNameContainer.getByName( rLibraryName ) ;
+	Reference< XNameAccess > xNameAccess;
+	aLibAny >>= xNameAccess;
+	SfxLibrary* pImplLib = static_cast< SfxLibrary* >( xNameAccess.get() );
+    return pImplLib;
+}
+
+
+// Storing with password encryption
+
+// Empty implementation, avoids unneccesary implementation in dlgcont.cxx
+sal_Bool SfxLibraryContainer::implStorePasswordLibrary( 
+    SfxLibrary*,
+    const OUString&, 
+    const uno::Reference< embed::XStorage >&, const uno::Reference< task::XInteractionHandler >&  )
+{
+    return sal_False;
+}
+
+sal_Bool SfxLibraryContainer::implStorePasswordLibrary( 
+    SfxLibrary* /*pLib*/, 
+    const ::rtl::OUString& /*aName*/, 
+    const ::com::sun::star::uno::Reference< ::com::sun::star::embed::XStorage >& /*xStorage*/,
+    const ::rtl::OUString& /*aTargetURL*/, 
+    const Reference< XSimpleFileAccess > /*xToUseSFI*/,
+    const uno::Reference< task::XInteractionHandler >&  )
+{
+    return sal_False;
+}
+
+sal_Bool SfxLibraryContainer::implLoadPasswordLibrary( 
+    SfxLibrary* /*pLib*/, 
+    const OUString& /*Name*/, 
+    sal_Bool /*bVerifyPasswordOnly*/ )
+throw(WrappedTargetException, RuntimeException)
+{
+    return sal_True;
+}
+
+
+
+#define EXPAND_PROTOCOL "vnd.sun.star.expand"
+#define OUSTR(x) ::rtl::OUString( RTL_CONSTASCII_USTRINGPARAM(x) )
+
+OUString SfxLibraryContainer::createAppLibraryFolder
+    ( SfxLibrary* pLib, const OUString& aName )
+{
+	OUString aLibDirPath = pLib->maStorageURL;
+	if( !aLibDirPath.getLength() )
+    {
+		INetURLObject aInetObj( String(maLibraryPath).GetToken(1) );
+		aInetObj.insertName( aName, sal_True, INetURLObject::LAST_SEGMENT, sal_True, INetURLObject::ENCODE_ALL );
+        checkStorageURL( aInetObj.GetMainURL( INetURLObject::NO_DECODE ), pLib->maLibInfoFileURL,
+            pLib->maStorageURL, pLib->maUnexpandedStorageURL );
+		aLibDirPath = pLib->maStorageURL;
+    }
+
+	if( !mxSFI->isFolder( aLibDirPath ) )
+    {
+	    try
+	    {
+		    mxSFI->createFolder( aLibDirPath );
+        }
+        catch( Exception& )
+        {}
+    }
+
+    return aLibDirPath;
+}
+
+// Storing
+void SfxLibraryContainer::implStoreLibrary( SfxLibrary* pLib,
+	const OUString& aName, const uno::Reference< embed::XStorage >& xStorage )
+{
+	OUString aDummyLocation;
+	Reference< XSimpleFileAccess > xDummySFA;
+	Reference< XInteractionHandler > xDummyHandler;
+	implStoreLibrary( pLib, aName, xStorage, aDummyLocation, xDummySFA, xDummyHandler );
+}
+
+// New variant for library export
+void SfxLibraryContainer::implStoreLibrary( SfxLibrary* pLib,
+	const OUString& aName, const uno::Reference< embed::XStorage >& xStorage,
+	const ::rtl::OUString& aTargetURL, Reference< XSimpleFileAccess > xToUseSFI,
+	const Reference< XInteractionHandler >& xHandler )
+{
+	sal_Bool bLink = pLib->mbLink;
+	sal_Bool bStorage = xStorage.is() && !bLink;
+
+	Sequence< OUString > aElementNames = pLib->getElementNames();
+	sal_Int32 nNameCount = aElementNames.getLength();
+	const OUString* pNames = aElementNames.getConstArray();
+
+	if( bStorage )
+	{
+		for( sal_Int32 i = 0 ; i < nNameCount ; i++ )
+		{
+			OUString aElementName = pNames[ i ];
+
+			OUString aStreamName = aElementName;
+			aStreamName += String( RTL_CONSTASCII_USTRINGPARAM(".xml") );
+
+			Any aElement = pLib->getByName( aElementName );
+			if( isLibraryElementValid( aElement ) )
+			{
+				try {
+					uno::Reference< io::XStream > xElementStream = xStorage->openStreamElement(
+																		aStreamName,
+																		embed::ElementModes::READWRITE );
+                    //if ( !xElementStream.is() )
+                    //    throw uno::RuntimeException(); // TODO: method must either return the stream or throw an exception
+
+					String aPropName( String::CreateFromAscii( RTL_CONSTASCII_STRINGPARAM("MediaType") ) );
+					OUString aMime( RTL_CONSTASCII_USTRINGPARAM("text/xml") );
+
+					uno::Reference< beans::XPropertySet > xProps( xElementStream, uno::UNO_QUERY );
+					OSL_ENSURE( xProps.is(), "The StorageStream must implement XPropertySet interface!\n" );
+                    //if ( !xProps.is() ) //TODO
+                    //    throw uno::RuntimeException();
+
+                    if ( xProps.is() )
+                    {
+                        xProps->setPropertyValue( aPropName, uno::makeAny( aMime ) );
+
+                        // #87671 Allow encryption
+//REMOVE	                        aPropName = String::CreateFromAscii( RTL_CONSTASCII_STRINGPARAM("Encrypted") );
+                        aPropName = String::CreateFromAscii( RTL_CONSTASCII_STRINGPARAM( "UseCommonStoragePasswordEncryption" ) );
+                        xProps->setPropertyValue( aPropName, uno::makeAny( sal_True ) );
+
+                        Reference< XOutputStream > xOutput = xElementStream->getOutputStream();
+                        writeLibraryElement( aElement, aElementName, xOutput );
+						// writeLibraryElement closes the stream
+                        // xOutput->closeOutput();
+                    }
+				}
+				catch( uno::Exception& )
+				{
+					OSL_ENSURE( sal_False, "Problem during storing of library!\n" );
+                    // TODO: error handling?
+				}
+			}
+		}
+
+		pLib->storeResourcesToStorage( xStorage );
+	}
+	else
+	{
+		// Export?
+		bool bExport = aTargetURL.getLength();
+		try
+		{
+			Reference< XSimpleFileAccess > xSFI = mxSFI;
+			if( xToUseSFI.is() )
+				xSFI = xToUseSFI;
+
+            OUString aLibDirPath;
+			if( bExport )
+			{
+				INetURLObject aInetObj( aTargetURL );
+				aInetObj.insertName( aName, sal_True, INetURLObject::LAST_SEGMENT, sal_True, INetURLObject::ENCODE_ALL );
+				aLibDirPath = aInetObj.GetMainURL( INetURLObject::NO_DECODE );
+
+				if( !xSFI->isFolder( aLibDirPath ) )
+					xSFI->createFolder( aLibDirPath );
+
+				pLib->storeResourcesToURL( aLibDirPath, xHandler );
+			}
+			else
+			{
+	            aLibDirPath = createAppLibraryFolder( pLib, aName );
+				pLib->storeResources();
+			}
+
+			for( sal_Int32 i = 0 ; i < nNameCount ; i++ )
+			{
+				OUString aElementName = pNames[ i ];
+
+				INetURLObject aElementInetObj( aLibDirPath );
+				aElementInetObj.insertName( aElementName, sal_False,
+					INetURLObject::LAST_SEGMENT, sal_True, INetURLObject::ENCODE_ALL );
+				aElementInetObj.setExtension( maLibElementFileExtension );
+				String aElementPath( aElementInetObj.GetMainURL( INetURLObject::NO_DECODE ) );
+
+				Any aElement = pLib->getByName( aElementName );
+				if( isLibraryElementValid( aElement ) )
+				{
+					// TODO: Check modified
+		            try
+		            {
+					    if( xSFI->exists( aElementPath ) )
+						    xSFI->kill( aElementPath );
+    					Reference< XOutputStream > xOutput = xSFI->openFileWrite( aElementPath );
+					    writeLibraryElement( aElement, aElementName, xOutput );
+					    xOutput->closeOutput();
+                    }
+            		catch( Exception& )
+                    {
+						if( bExport )
+							throw;
+
+			            SfxErrorContext aEc( ERRCTX_SFX_SAVEDOC, aElementPath );
+                        ULONG nErrorCode = ERRCODE_IO_GENERAL;
+                	    ErrorHandler::HandleError( nErrorCode );
+                    }
+				}
+			}
+		}
+		catch( Exception& )
+		{
+			if( bExport )
+				throw;
+		}
+	}
+}
+
+void SfxLibraryContainer::implStoreLibraryIndexFile( SfxLibrary* pLib,
+	const ::xmlscript::LibDescriptor& rLib, const uno::Reference< embed::XStorage >& xStorage )
+{
+	OUString aDummyLocation;
+	Reference< XSimpleFileAccess > xDummySFA;
+	implStoreLibraryIndexFile( pLib, rLib, xStorage, aDummyLocation, xDummySFA );
+}
+
+// New variant for library export
+void SfxLibraryContainer::implStoreLibraryIndexFile( SfxLibrary* pLib,
+	const ::xmlscript::LibDescriptor& rLib, const uno::Reference< embed::XStorage >& xStorage,
+	const ::rtl::OUString& aTargetURL, Reference< XSimpleFileAccess > xToUseSFI )
+{
+	// Create sax writer
+	Reference< XExtendedDocumentHandler > xHandler(
+		mxMSF->createInstance(
+			OUString( RTL_CONSTASCII_USTRINGPARAM("com.sun.star.xml.sax.Writer") ) ), UNO_QUERY );
+	if( !xHandler.is() )
+	{
+		OSL_ENSURE( 0, "### couln't create sax-writer component\n" );
+		return;
+	}
+
+	sal_Bool bLink = pLib->mbLink;
+	sal_Bool bStorage = xStorage.is() && !bLink;
+
+	// Write info file
+	uno::Reference< io::XOutputStream > xOut;
+	uno::Reference< io::XStream > xInfoStream;
+	if( bStorage )
+	{
+		OUString aStreamName( maInfoFileName );
+		aStreamName += String( RTL_CONSTASCII_USTRINGPARAM("-lb.xml") );
+
+		try {
+			xInfoStream = xStorage->openStreamElement( aStreamName, embed::ElementModes::READWRITE );
+            OSL_ENSURE( xInfoStream.is(), "No stream!\n" );
+			uno::Reference< beans::XPropertySet > xProps( xInfoStream, uno::UNO_QUERY );
+            //if ( !xProps.is() )
+            //    throw uno::RuntimeException(); // TODO
+
+            if ( xProps.is() )
+            {
+                String aPropName( String::CreateFromAscii( RTL_CONSTASCII_STRINGPARAM("MediaType") ) );
+                OUString aMime( RTL_CONSTASCII_USTRINGPARAM("text/xml") );
+                xProps->setPropertyValue( aPropName, uno::makeAny( aMime ) );
+
+                // #87671 Allow encryption
+//REMOVE	                aPropName = String::CreateFromAscii( RTL_CONSTASCII_STRINGPARAM("Encrypted") );
+                aPropName = String::CreateFromAscii( RTL_CONSTASCII_STRINGPARAM( "UseCommonStoragePasswordEncryption" ) );
+                xProps->setPropertyValue( aPropName, uno::makeAny( sal_True ) );
+
+                xOut = xInfoStream->getOutputStream();
+            }
+		}
+		catch( uno::Exception& )
+		{
+			OSL_ENSURE( sal_False, "Problem during storing of library index file!\n" );
+            // TODO: error handling?
+		}
+	}
+	else
+	{
+		// Export?
+		bool bExport = aTargetURL.getLength();
+		Reference< XSimpleFileAccess > xSFI = mxSFI;
+		if( xToUseSFI.is() )
+			xSFI = xToUseSFI;
+
+        OUString aLibInfoPath;
+		if( bExport )
+		{
+			INetURLObject aInetObj( aTargetURL );
+			aInetObj.insertName( rLib.aName, sal_True, INetURLObject::LAST_SEGMENT, sal_True, INetURLObject::ENCODE_ALL );
+			OUString aLibDirPath = aInetObj.GetMainURL( INetURLObject::NO_DECODE );
+			if( !xSFI->isFolder( aLibDirPath ) )
+				xSFI->createFolder( aLibDirPath );
+
+			aInetObj.insertName( maInfoFileName, sal_True, INetURLObject::LAST_SEGMENT, sal_True, INetURLObject::ENCODE_ALL );
+			aInetObj.setExtension( OUString( RTL_CONSTASCII_USTRINGPARAM("xlb") ) );
+			aLibInfoPath = aInetObj.GetMainURL( INetURLObject::NO_DECODE );
+		}
+		else
+		{
+			createAppLibraryFolder( pLib, rLib.aName );
+			aLibInfoPath = pLib->maLibInfoFileURL;
+		}
+
+		try
+		{
+		    if( xSFI->exists( aLibInfoPath ) )
+			    xSFI->kill( aLibInfoPath );
+		    xOut = xSFI->openFileWrite( aLibInfoPath );
+        }
+        catch( Exception& )
+        {
+			if( bExport )
+				throw;
+
+			SfxErrorContext aEc( ERRCTX_SFX_SAVEDOC, aLibInfoPath );
+            ULONG nErrorCode = ERRCODE_IO_GENERAL;
+            ErrorHandler::HandleError( nErrorCode );
+        }
+	}
+	if( !xOut.is() )
+	{
+		OSL_ENSURE( 0, "### couln't open output stream\n" );
+		return;
+	}
+
+	Reference< XActiveDataSource > xSource( xHandler, UNO_QUERY );
+	xSource->setOutputStream( xOut );
+
+    xmlscript::exportLibrary( xHandler, rLib );
+}
+
+
+sal_Bool SfxLibraryContainer::implLoadLibraryIndexFile(  SfxLibrary* pLib,
+    ::xmlscript::LibDescriptor& rLib, const uno::Reference< embed::XStorage >& xStorage, const OUString& aIndexFileName )
+{
+	Reference< XParser > xParser( mxMSF->createInstance(
+		OUString( RTL_CONSTASCII_USTRINGPARAM("com.sun.star.xml.sax.Parser") ) ), UNO_QUERY );
+	if( !xParser.is() )
+	{
+		OSL_ENSURE( 0, "### couln't create sax parser component\n" );
+		return sal_False;
+	}
+
+	sal_Bool bLink = sal_False;
+	sal_Bool bStorage = sal_False;
+    if( pLib )
+    {
+	    bLink = pLib->mbLink;
+	    bStorage = xStorage.is() && !bLink;
+    }
+
+	// Read info file
+	uno::Reference< io::XInputStream > xInput;
+    String aLibInfoPath;
+	if( bStorage )
+	{
+		aLibInfoPath = maInfoFileName;
+		aLibInfoPath += String( RTL_CONSTASCII_USTRINGPARAM("-lb.xml") );
+
+		try {
+			uno::Reference< io::XStream > xInfoStream =
+						xStorage->openStreamElement( aLibInfoPath, embed::ElementModes::READ );
+			xInput = xInfoStream->getInputStream();
+		}
+		catch( uno::Exception& )
+		{}
+	}
+	else
+	{
+		// Create Input stream
+        //String aLibInfoPath; // attention: THIS PROBLEM MUST BE REVIEWED BY SCRIPTING OWNER!!!
+
+        if( pLib )
+        {
+            createAppLibraryFolder( pLib, rLib.aName );
+            aLibInfoPath = pLib->maLibInfoFileURL;
+        }
+        else
+            aLibInfoPath = aIndexFileName;
+
+		try
+		{
+			xInput = mxSFI->openFileRead( aLibInfoPath );
+		}
+		catch( Exception& )
+		{
+            xInput.clear();
+			if( !GbMigrationSuppressErrors )
+			{
+				SfxErrorContext aEc( ERRCTX_SFX_LOADBASIC, aLibInfoPath );
+				ULONG nErrorCode = ERRCODE_IO_GENERAL;
+				ErrorHandler::HandleError( nErrorCode );
+			}
+		}
+	}
+	if( !xInput.is() )
+	{
+		// OSL_ENSURE( 0, "### couln't open input stream\n" );
+		return sal_False;
+	}
+
+	InputSource source;
+	source.aInputStream = xInput;
+	source.sSystemId 	= aLibInfoPath;
+
+	// start parsing
+	try {
+		xParser->setDocumentHandler( ::xmlscript::importLibrary( rLib ) );
+		xParser->parseStream( source );
+	}
+	catch( Exception& )
+	{
+		// throw WrappedTargetException( OUString::createFromAscii( "parsing error!\n" ),
+		//								Reference< XInterface >(),
+		//								makeAny( e ) );
+		OSL_ENSURE( 0, "Parsing error\n" );
+		SfxErrorContext aEc( ERRCTX_SFX_LOADBASIC, aLibInfoPath );
+        ULONG nErrorCode = ERRCODE_IO_GENERAL;
+        ErrorHandler::HandleError( nErrorCode );
+		return sal_False;
+	}
+
+    if( !pLib )
+    {
+		Reference< XNameContainer > xLib = createLibrary( rLib.aName );
+		pLib = static_cast< SfxLibrary* >( xLib.get() );
+		pLib->mbLoaded = sal_False;
+        rLib.aStorageURL = aIndexFileName;
+        checkStorageURL( rLib.aStorageURL, pLib->maLibInfoFileURL, pLib->maStorageURL,
+            pLib->maUnexpandedStorageURL );
+
+        implImportLibDescriptor( pLib, rLib );
+    }
+
+    return sal_True;
+}
+
+void SfxLibraryContainer::implImportLibDescriptor
+    ( SfxLibrary* pLib, ::xmlscript::LibDescriptor& rLib )
+{
+    if( !pLib->mbInitialised )
+    {
+	    sal_Int32 nElementCount = rLib.aElementNames.getLength();
+	    const OUString* pElementNames = rLib.aElementNames.getConstArray();
+	    Any aDummyElement = createEmptyLibraryElement();
+	    for( sal_Int32 i = 0 ; i < nElementCount ; i++ )
+	    {
+		    pLib->maNameContainer.insertByName( pElementNames[i], aDummyElement );
+	    }
+        pLib->mbPasswordProtected = rLib.bPasswordProtected;
+        pLib->mbReadOnly = rLib.bReadOnly;
+		pLib->mbPreload  = rLib.bPreload;
+        pLib->implSetModified( sal_False );
+
+        pLib->mbInitialised = sal_True;
+    }
+}
+
+
+// Methods of new XLibraryStorage interface?
+void SfxLibraryContainer::storeLibraries_Impl( const uno::Reference< embed::XStorage >& xStorage, sal_Bool bComplete )
+{
+	Sequence< OUString > aNames = maNameContainer.getElementNames();
+	const OUString* pNames = aNames.getConstArray();
+	sal_Int32 i, nNameCount = aNames.getLength();
+
+	// Don't count libs from shared index file
+	sal_Int32 nLibsToSave = nNameCount;
+	for( i = 0 ; i < nNameCount ; i++ )
+	{
+        SfxLibrary* pImplLib = getImplLib( pNames[ i ] );
+		if( pImplLib->mbSharedIndexFile )
+			nLibsToSave--;
+	}
+    if( !nLibsToSave )
+        return;
+
+	::xmlscript::LibDescriptorArray* pLibArray = new ::xmlscript::LibDescriptorArray( nLibsToSave );
+
+	// Write to storage?
+	sal_Bool bStorage = xStorage.is();
+	uno::Reference< embed::XStorage > xLibrariesStor;
+	uno::Reference< embed::XStorage > xSourceLibrariesStor;
+	if( bStorage )
+	{
+		// first of all, clean the target library storage, since the storing procedure must do overwrite
+		try {
+			if ( xStorage->hasByName( maLibrariesDir ) )
+				xStorage->removeElement( maLibrariesDir );
+		}
+		catch( uno::Exception& )
+		{
+            DBG_UNHANDLED_EXCEPTION();
+			return;
+		}
+
+        // Don't write if only empty standard lib exists
+        if( nNameCount == 1 )
+        {
+            // Must be standard lib
+		    Any aLibAny = maNameContainer.getByName( pNames[0] );
+		    Reference< XNameAccess > xNameAccess;
+		    aLibAny >>= xNameAccess;
+            if( !xNameAccess->hasElements() )
+                return;
+        }
+
+		try {
+			xLibrariesStor = xStorage->openStorageElement( maLibrariesDir, embed::ElementModes::READWRITE );
+			if ( !xLibrariesStor.is() )
+				throw uno::RuntimeException();
+		}
+		catch( uno::Exception& )
+		{
+			uno::Any exc( cppu::getCaughtException() ); // cppuhelper/exc_hlp.hxx
+            ::rtl::OUString msg( ::comphelper::anyToString(exc) ); // comphelper/anytostring.hxx
+			OSL_ENSURE( 0, rtl::OUStringToOString( msg, RTL_TEXTENCODING_ASCII_US ).getStr() );
+			return;
+		}
+
+		try {
+			xSourceLibrariesStor = mxStorage->openStorageElement( maLibrariesDir, embed::ElementModes::READ );
+		}
+		catch( uno::Exception& )
+		{}
+	}
+
+	int iArray = 0;
+    for( i = 0 ; i < nNameCount ; i++ )
+	{
+        SfxLibrary* pImplLib = getImplLib( pNames[ i ] );
+		if( pImplLib->mbSharedIndexFile )
+			continue;
+		::xmlscript::LibDescriptor& rLib = pLibArray->mpLibs[iArray];
+		rLib.aName = pNames[ i ];
+		iArray++;
+
+		rLib.bLink = pImplLib->mbLink;
+		if( !bStorage || pImplLib->mbLink )
+		{
+			rLib.aStorageURL = ( pImplLib->maUnexpandedStorageURL.getLength() ) ?
+				pImplLib->maUnexpandedStorageURL : pImplLib->maLibInfoFileURL;
+		}
+		rLib.bReadOnly = pImplLib->mbReadOnly;
+		rLib.bPreload = pImplLib->mbPreload;
+		rLib.bPasswordProtected = pImplLib->mbPasswordProtected;
+		rLib.aElementNames = pImplLib->getElementNames();
+
+		if( pImplLib->implIsModified() || bComplete )
+		{
+            // Can we copy the storage?
+            if( !mbOldInfoFormat && !pImplLib->implIsModified() && !mbOasis2OOoFormat && xSourceLibrariesStor.is() )
+            {
+				try {
+                	xSourceLibrariesStor->copyElementTo( rLib.aName, xLibrariesStor, rLib.aName );
+				} catch( uno::Exception& )
+				{
+					OSL_ENSURE( sal_False, "Problem during storing of libraries!\n" );
+                    // TODO: error handling?
+				}
+            }
+            else
+            {
+				uno::Reference< embed::XStorage > xLibraryStor;
+				if( bStorage )
+				{
+					try {
+						xLibraryStor = xLibrariesStor->openStorageElement(
+																		rLib.aName,
+																		embed::ElementModes::READWRITE );
+					}
+					catch( uno::Exception& )
+					{
+						OSL_ENSURE( 0, "### couln't create sub storage for library\n" );
+						return;
+					}
+				}
+
+				// Maybe lib is not loaded?!
+				if( bComplete )
+					loadLibrary( rLib.aName );
+
+    			if( pImplLib->mbPasswordProtected )
+				    implStorePasswordLibrary( pImplLib, rLib.aName, xLibraryStor, uno::Reference< task::XInteractionHandler >() );
+                    // TODO: Check return value
+                else
+				    implStoreLibrary( pImplLib, rLib.aName, xLibraryStor );
+
+                implStoreLibraryIndexFile( pImplLib, rLib, xLibraryStor );
+				if( bStorage )
+				{
+					try {
+						uno::Reference< embed::XTransactedObject > xTransact( xLibraryStor, uno::UNO_QUERY );
+                        OSL_ENSURE( xTransact.is(), "The storage must implement XTransactedObject!\n" );
+						if ( !xTransact.is() )
+							throw uno::RuntimeException();
+
+						xTransact->commit();
+					}
+					catch( uno::Exception& )
+					{
+						OSL_ENSURE( sal_False, "Problem during storing of libraries!\n" );
+                        // TODO: error handling
+					}
+				}
+            }
+
+			maModifiable.setModified( sal_True );
+			pImplLib->implSetModified( sal_False );
+		}
+
+        // For container info ReadOnly refers to mbReadOnlyLink
+		rLib.bReadOnly = pImplLib->mbReadOnlyLink;
+	}
+
+	if( !mbOldInfoFormat && !maModifiable.isModified() )
+		return;
+	maModifiable.setModified( sal_False );
+    mbOldInfoFormat = sal_False;
+
+	// Write library container info
+	// Create sax writer
+	Reference< XExtendedDocumentHandler > xHandler(
+		mxMSF->createInstance(
+			OUString( RTL_CONSTASCII_USTRINGPARAM("com.sun.star.xml.sax.Writer") ) ), UNO_QUERY );
+	if( !xHandler.is() )
+	{
+		OSL_ENSURE( 0, "### couln't create sax-writer component\n" );
+		return;
+	}
+
+	// Write info file
+	uno::Reference< io::XOutputStream > xOut;
+	uno::Reference< io::XStream > xInfoStream;
+	if( bStorage )
+	{
+		OUString aStreamName( maInfoFileName );
+		aStreamName += String( RTL_CONSTASCII_USTRINGPARAM("-lc.xml") );
+
+		try {
+			xInfoStream = xLibrariesStor->openStreamElement( aStreamName, embed::ElementModes::READWRITE );
+			uno::Reference< beans::XPropertySet > xProps( xInfoStream, uno::UNO_QUERY );
+			OSL_ENSURE ( xProps.is(), "The stream must implement XPropertySet!\n" );
+			if ( !xProps.is() )
+				throw uno::RuntimeException();
+
+			String aPropName( String::CreateFromAscii( RTL_CONSTASCII_STRINGPARAM("MediaType") ) );
+			OUString aMime( RTL_CONSTASCII_USTRINGPARAM("text/xml") );
+			xProps->setPropertyValue( aPropName, uno::makeAny( aMime ) );
+
+            // #87671 Allow encryption
+			aPropName = String::CreateFromAscii( RTL_CONSTASCII_STRINGPARAM("UseCommonStoragePasswordEncryption") );
+			xProps->setPropertyValue( aPropName, uno::makeAny( sal_True ) );
+
+			xOut = xInfoStream->getOutputStream();
+		}
+		catch( uno::Exception& )
+		{
+			ULONG nErrorCode = ERRCODE_IO_GENERAL;
+			ErrorHandler::HandleError( nErrorCode );
+		}
+	}
+	else
+	{
+		// Create Output stream
+		INetURLObject aLibInfoInetObj( String(maLibraryPath).GetToken(1) );
+		aLibInfoInetObj.insertName( maInfoFileName, sal_True, INetURLObject::LAST_SEGMENT, sal_True, INetURLObject::ENCODE_ALL );
+		aLibInfoInetObj.setExtension( OUString( RTL_CONSTASCII_USTRINGPARAM("xlc") ) );
+		String aLibInfoPath( aLibInfoInetObj.GetMainURL( INetURLObject::NO_DECODE ) );
+
+		try
+		{
+		    if( mxSFI->exists( aLibInfoPath ) )
+			    mxSFI->kill( aLibInfoPath );
+		    xOut = mxSFI->openFileWrite( aLibInfoPath );
+        }
+        catch( Exception& )
+        {
+            xOut.clear();
+			SfxErrorContext aEc( ERRCTX_SFX_SAVEDOC, aLibInfoPath );
+            ULONG nErrorCode = ERRCODE_IO_GENERAL;
+            ErrorHandler::HandleError( nErrorCode );
+        }
+
+	}
+	if( !xOut.is() )
+	{
+		OSL_ENSURE( 0, "### couln't open output stream\n" );
+		return;
+	}
+
+	Reference< XActiveDataSource > xSource( xHandler, UNO_QUERY );
+	xSource->setOutputStream( xOut );
+
+    try 
+	{
+		xmlscript::exportLibraryContainer( xHandler, pLibArray );
+		if ( bStorage )
+		{
+            uno::Reference< embed::XTransactedObject > xTransact( xLibrariesStor, uno::UNO_QUERY );
+            OSL_ENSURE( xTransact.is(), "The storage must implement XTransactedObject!\n" );
+            if ( !xTransact.is() )
+                throw uno::RuntimeException();
+
+            xTransact->commit();
+        }
+    }
+    catch( uno::Exception& )
+    {
+		OSL_ENSURE( sal_False, "Problem during storing of libraries!\n" );
+        ULONG nErrorCode = ERRCODE_IO_GENERAL;
+        ErrorHandler::HandleError( nErrorCode );
+    }
+
+	delete pLibArray;
+}
+
+
+// Methods XElementAccess
+Type SAL_CALL SfxLibraryContainer::getElementType()
+	throw(RuntimeException)
+{
+    LibraryContainerMethodGuard aGuard( *this );
+	return maNameContainer.getElementType();
+}
+
+sal_Bool SfxLibraryContainer::hasElements()
+	throw(RuntimeException)
+{
+    LibraryContainerMethodGuard aGuard( *this );
+	sal_Bool bRet = maNameContainer.hasElements();
+	return bRet;
+}
+
+// Methods XNameAccess
+Any SfxLibraryContainer::getByName( const OUString& aName )
+	throw(NoSuchElementException, WrappedTargetException, RuntimeException)
+{
+    LibraryContainerMethodGuard aGuard( *this );
+	Any aRetAny = maNameContainer.getByName( aName ) ;
+	return aRetAny;
+}
+
+Sequence< OUString > SfxLibraryContainer::getElementNames()
+	throw(RuntimeException)
+{
+    LibraryContainerMethodGuard aGuard( *this );
+	return maNameContainer.getElementNames();
+}
+
+sal_Bool SfxLibraryContainer::hasByName( const OUString& aName )
+	throw(RuntimeException)
+{
+    LibraryContainerMethodGuard aGuard( *this );
+	return maNameContainer.hasByName( aName ) ;
+}
+
+// Methods XLibraryContainer
+Reference< XNameContainer > SAL_CALL SfxLibraryContainer::createLibrary( const OUString& Name )
+		throw(IllegalArgumentException, ElementExistException, RuntimeException)
+{
+    LibraryContainerMethodGuard aGuard( *this );
+	SfxLibrary* pNewLib = implCreateLibrary( Name );
+    pNewLib->maLibElementFileExtension = maLibElementFileExtension;
+
+	createVariableURL( pNewLib->maUnexpandedStorageURL, Name, maInfoFileName, true );
+
+	Reference< XNameAccess > xNameAccess = static_cast< XNameAccess* >( pNewLib );
+	Any aElement;
+	aElement <<= xNameAccess;
+	maNameContainer.insertByName( Name, aElement );
+	maModifiable.setModified( sal_True );
+    Reference< XNameContainer > xRet( xNameAccess, UNO_QUERY );
+	return xRet;
+}
+
+Reference< XNameAccess > SAL_CALL SfxLibraryContainer::createLibraryLink
+	( const OUString& Name, const OUString& StorageURL, sal_Bool ReadOnly )
+		throw(IllegalArgumentException, ElementExistException, RuntimeException)
+{
+    LibraryContainerMethodGuard aGuard( *this );
+    // TODO: Check other reasons to force ReadOnly status
+	//if( !ReadOnly )
+	//{
+	//}
+
+    OUString aLibInfoFileURL;
+    OUString aLibDirURL;
+    OUString aUnexpandedStorageURL;
+    checkStorageURL( StorageURL, aLibInfoFileURL, aLibDirURL, aUnexpandedStorageURL );
+
+
+	SfxLibrary* pNewLib = implCreateLibraryLink( Name, aLibInfoFileURL, aLibDirURL, ReadOnly );
+    pNewLib->maLibElementFileExtension = maLibElementFileExtension;
+    pNewLib->maUnexpandedStorageURL = aUnexpandedStorageURL;
+
+    OUString aInitFileName;
+	uno::Reference< embed::XStorage > xDummyStor;
+    ::xmlscript::LibDescriptor aLibDesc;
+    /*sal_Bool bReadIndexFile = */implLoadLibraryIndexFile( pNewLib, aLibDesc, xDummyStor, aInitFileName );
+    implImportLibDescriptor( pNewLib, aLibDesc );
+
+	Reference< XNameAccess > xRet = static_cast< XNameAccess* >( pNewLib );
+	Any aElement;
+	aElement <<= xRet;
+	maNameContainer.insertByName( Name, aElement );
+	maModifiable.setModified( sal_True );
+	return xRet;
+}
+
+void SAL_CALL SfxLibraryContainer::removeLibrary( const OUString& Name )
+	throw(NoSuchElementException, WrappedTargetException, RuntimeException)
+{
+    LibraryContainerMethodGuard aGuard( *this );
+    // Get and hold library before removing
+	Any aLibAny = maNameContainer.getByName( Name ) ;
+	Reference< XNameAccess > xNameAccess;
+	aLibAny >>= xNameAccess;
+	SfxLibrary* pImplLib = static_cast< SfxLibrary* >( xNameAccess.get() );
+	if( pImplLib->mbReadOnly && !pImplLib->mbLink )
+		throw IllegalArgumentException();
+
+    // Remove from container
+	maNameContainer.removeByName( Name );
+	maModifiable.setModified( sal_True );
+
+    // Delete library files, but not for linked libraries
+    if( !pImplLib->mbLink )
+    {
+	    if( mxStorage.is() )
+            return;
+	    if( xNameAccess->hasElements() )
+	    {
+		    Sequence< OUString > aNames = pImplLib->getElementNames();
+		    sal_Int32 nNameCount = aNames.getLength();
+		    const OUString* pNames = aNames.getConstArray();
+		    for( sal_Int32 i = 0 ; i < nNameCount ; i++ )
+		    {
+			    OUString aElementName = pNames[ i ];
+                pImplLib->removeByName( aElementName );
+		    }
+	    }
+
+        // Delete index file
+        createAppLibraryFolder( pImplLib, Name );
+        String aLibInfoPath = pImplLib->maLibInfoFileURL;
+		try
+		{
+		    if( mxSFI->exists( aLibInfoPath ) )
+			    mxSFI->kill( aLibInfoPath );
+        }
+        catch( Exception& ) {}
+
+        // Delete folder if empty
+	    INetURLObject aInetObj( String(maLibraryPath).GetToken(1) );
+	    aInetObj.insertName( Name, sal_True, INetURLObject::LAST_SEGMENT,
+		    sal_True, INetURLObject::ENCODE_ALL );
+	    OUString aLibDirPath = aInetObj.GetMainURL( INetURLObject::NO_DECODE );
+
+	    try
+	    {
+	        if( mxSFI->isFolder( aLibDirPath ) )
+	        {
+                Sequence< OUString > aContentSeq = mxSFI->getFolderContents( aLibDirPath, true );
+    		    sal_Int32 nCount = aContentSeq.getLength();
+	            if( !nCount )
+		            mxSFI->kill( aLibDirPath );
+	        }
+        }
+        catch( Exception& )
+        {
+        }
+    }
+}
+
+sal_Bool SAL_CALL SfxLibraryContainer::isLibraryLoaded( const OUString& Name )
+	throw(NoSuchElementException, RuntimeException)
+{
+    LibraryContainerMethodGuard aGuard( *this );
+    SfxLibrary* pImplLib = getImplLib( Name );
+	sal_Bool bRet = pImplLib->mbLoaded;
+	return bRet;
+}
+
+
+void SAL_CALL SfxLibraryContainer::loadLibrary( const OUString& Name )
+	throw(NoSuchElementException, WrappedTargetException, RuntimeException)
+{
+    LibraryContainerMethodGuard aGuard( *this );
+	Any aLibAny = maNameContainer.getByName( Name ) ;
+	Reference< XNameAccess > xNameAccess;
+	aLibAny >>= xNameAccess;
+	SfxLibrary* pImplLib = static_cast< SfxLibrary* >( xNameAccess.get() );
+
+    sal_Bool bLoaded = pImplLib->mbLoaded;
+	pImplLib->mbLoaded = sal_True;
+	if( !bLoaded && xNameAccess->hasElements() )
+	{
+        if( pImplLib->mbPasswordProtected )
+        {
+            implLoadPasswordLibrary( pImplLib, Name );
+            return;
+        }
+
+		sal_Bool bLink = pImplLib->mbLink;
+		sal_Bool bStorage = mxStorage.is() && !bLink;
+
+		uno::Reference< embed::XStorage > xLibrariesStor;
+		uno::Reference< embed::XStorage > xLibraryStor;
+		if( bStorage )
+		{
+			try {
+				xLibrariesStor = mxStorage->openStorageElement( maLibrariesDir, embed::ElementModes::READ );
+				OSL_ENSURE( xLibrariesStor.is(), "The method must either throw exception or return a storage!\n" );
+				if ( !xLibrariesStor.is() )
+					throw uno::RuntimeException();
+
+				xLibraryStor = xLibrariesStor->openStorageElement( Name, embed::ElementModes::READ );
+				OSL_ENSURE( xLibraryStor.is(), "The method must either throw exception or return a storage!\n" );
+				if ( !xLibrariesStor.is() )
+					throw uno::RuntimeException();
+			}
+			catch( uno::Exception& )
+			{
+				OSL_ENSURE( 0, "### couln't open sub storage for library\n" );
+				return;
+			}
+		}
+
+		Sequence< OUString > aNames = pImplLib->getElementNames();
+		sal_Int32 nNameCount = aNames.getLength();
+		const OUString* pNames = aNames.getConstArray();
+		for( sal_Int32 i = 0 ; i < nNameCount ; i++ )
+		{
+			OUString aElementName = pNames[ i ];
+
+			OUString aFile;
+			uno::Reference< io::XInputStream > xInStream;
+
+			if( bStorage )
+			{
+				uno::Reference< io::XStream > xElementStream;
+
+				aFile = aElementName;
+				aFile += String( RTL_CONSTASCII_USTRINGPARAM(".xml") );
+
+				try {
+					xElementStream = xLibraryStor->openStreamElement( aFile, embed::ElementModes::READ );
+				} catch( uno::Exception& )
+				{}
+
+				if( !xElementStream.is() )
+				{
+					// Check for EA2 document version with wrong extensions
+					aFile = aElementName;
+					aFile += String( RTL_CONSTASCII_USTRINGPARAM(".") );
+					aFile += maLibElementFileExtension;
+					try {
+						xElementStream = xLibraryStor->openStreamElement( aFile, embed::ElementModes::READ );
+					} catch( uno::Exception& )
+					{}
+				}
+
+				if ( xElementStream.is() )
+					xInStream = xElementStream->getInputStream();
+
+				if ( !xInStream.is() )
+				{
+					OSL_ENSURE( 0, "### couln't open library element stream\n" );
+					return;
+				}
+			}
+			else
+			{
+		        String aLibDirPath = pImplLib->maStorageURL;
+				INetURLObject aElementInetObj( aLibDirPath );
+				aElementInetObj.insertName( aElementName, sal_False,
+					INetURLObject::LAST_SEGMENT, sal_True, INetURLObject::ENCODE_ALL );
+				aElementInetObj.setExtension( maLibElementFileExtension );
+				aFile = aElementInetObj.GetMainURL( INetURLObject::NO_DECODE );
+			}
+
+			Any aAny = importLibraryElement( aFile, xInStream );
+			if( pImplLib->hasByName( aElementName ) )
+            {
+                if( aAny.hasValue() )
+				    pImplLib->maNameContainer.replaceByName( aElementName, aAny );
+            }
+			else
+            {
+				pImplLib->maNameContainer.insertByName( aElementName, aAny );
+            }
+		}
+
+        pImplLib->implSetModified( sal_False );
+	}
+}
+
+// Methods XLibraryContainer2
+sal_Bool SAL_CALL SfxLibraryContainer::isLibraryLink( const OUString& Name )
+    throw (NoSuchElementException, RuntimeException)
+{
+    LibraryContainerMethodGuard aGuard( *this );
+    SfxLibrary* pImplLib = getImplLib( Name );
+	sal_Bool bRet = pImplLib->mbLink;
+	return bRet;
+}
+
+OUString SAL_CALL SfxLibraryContainer::getLibraryLinkURL( const OUString& Name )
+    throw (IllegalArgumentException, NoSuchElementException, RuntimeException)
+{
+    LibraryContainerMethodGuard aGuard( *this );
+    SfxLibrary* pImplLib = getImplLib( Name );
+	sal_Bool bLink = pImplLib->mbLink;
+	if( !bLink )
+		throw IllegalArgumentException();
+    OUString aRetStr = pImplLib->maLibInfoFileURL;
+    return aRetStr;
+}
+
+sal_Bool SAL_CALL SfxLibraryContainer::isLibraryReadOnly( const OUString& Name )
+    throw (NoSuchElementException, RuntimeException)
+{
+    LibraryContainerMethodGuard aGuard( *this );
+    SfxLibrary* pImplLib = getImplLib( Name );
+	sal_Bool bRet = pImplLib->mbReadOnly || (pImplLib->mbLink && pImplLib->mbReadOnlyLink);
+	return bRet;
+}
+
+void SAL_CALL SfxLibraryContainer::setLibraryReadOnly( const OUString& Name, sal_Bool bReadOnly )
+    throw (NoSuchElementException, RuntimeException)
+{
+    LibraryContainerMethodGuard aGuard( *this );
+    SfxLibrary* pImplLib = getImplLib( Name );
+    if( pImplLib->mbLink )
+    {
+        if( pImplLib->mbReadOnlyLink != bReadOnly )
+        {
+            pImplLib->mbReadOnlyLink = bReadOnly;
+            pImplLib->implSetModified( sal_True );
+            maModifiable.setModified( sal_True );
+        }
+    }
+    else
+    {
+        if( pImplLib->mbReadOnly != bReadOnly )
+        {
+	        pImplLib->mbReadOnly = bReadOnly;
+            pImplLib->implSetModified( sal_True );
+        }
+    }
+}
+
+void SAL_CALL SfxLibraryContainer::renameLibrary( const OUString& Name, const OUString& NewName )
+    throw (NoSuchElementException, ElementExistException, RuntimeException)
+{
+    LibraryContainerMethodGuard aGuard( *this );
+	if( maNameContainer.hasByName( NewName ) )
+		throw ElementExistException();
+
+    // Get and hold library before removing
+	Any aLibAny = maNameContainer.getByName( Name ) ;
+
+	// #i24094 Maybe lib is not loaded!
+	Reference< XNameAccess > xNameAccess;
+	aLibAny >>= xNameAccess;
+	SfxLibrary* pImplLib = static_cast< SfxLibrary* >( xNameAccess.get() );
+	if( pImplLib->mbPasswordProtected && !pImplLib->mbPasswordVerified )
+		return;		// Lib with unverified password cannot be renamed
+	loadLibrary( Name );
+
+    // Remove from container
+	maNameContainer.removeByName( Name );
+	maModifiable.setModified( sal_True );
+
+    // Rename library folder, but not for linked libraries
+    bool bMovedSuccessful = true;
+
+    // Rename files
+    sal_Bool bStorage = mxStorage.is();
+    if( !bStorage && !pImplLib->mbLink )
+    {
+        bMovedSuccessful = false;
+
+	    OUString aLibDirPath = pImplLib->maStorageURL;
+
+	    INetURLObject aDestInetObj( String(maLibraryPath).GetToken(1) );
+	    aDestInetObj.insertName( NewName, sal_True, INetURLObject::LAST_SEGMENT,
+		    sal_True, INetURLObject::ENCODE_ALL );
+	    OUString aDestDirPath = aDestInetObj.GetMainURL( INetURLObject::NO_DECODE );
+
+        // Store new URL
+        OUString aLibInfoFileURL = pImplLib->maLibInfoFileURL;
+        checkStorageURL( aDestDirPath, pImplLib->maLibInfoFileURL, pImplLib->maStorageURL,
+            pImplLib->maUnexpandedStorageURL );
+
+	    try
+	    {
+	        if( mxSFI->isFolder( aLibDirPath ) )
+	        {
+			    if( !mxSFI->isFolder( aDestDirPath ) )
+				    mxSFI->createFolder( aDestDirPath );
+
+                // Move index file
+		        try
+		        {
+					if( mxSFI->exists( pImplLib->maLibInfoFileURL ) )
+						mxSFI->kill( pImplLib->maLibInfoFileURL );
+            	    mxSFI->move( aLibInfoFileURL, pImplLib->maLibInfoFileURL );
+                }
+            	catch( Exception& )
+                {
+                }
+
+			    Sequence< OUString > aElementNames = xNameAccess->getElementNames();
+			    sal_Int32 nNameCount = aElementNames.getLength();
+			    const OUString* pNames = aElementNames.getConstArray();
+			    for( sal_Int32 i = 0 ; i < nNameCount ; i++ )
+			    {
+				    OUString aElementName = pNames[ i ];
+
+				    INetURLObject aElementInetObj( aLibDirPath );
+				    aElementInetObj.insertName( aElementName, sal_False,
+					    INetURLObject::LAST_SEGMENT, sal_True, INetURLObject::ENCODE_ALL );
+				    aElementInetObj.setExtension( maLibElementFileExtension );
+				    String aElementPath( aElementInetObj.GetMainURL( INetURLObject::NO_DECODE ) );
+
+				    INetURLObject aElementDestInetObj( aDestDirPath );
+				    aElementDestInetObj.insertName( aElementName, sal_False,
+					    INetURLObject::LAST_SEGMENT, sal_True, INetURLObject::ENCODE_ALL );
+				    aElementDestInetObj.setExtension( maLibElementFileExtension );
+				    String aDestElementPath( aElementDestInetObj.GetMainURL( INetURLObject::NO_DECODE ) );
+
+		            try
+		            {
+					    if( mxSFI->exists( aDestElementPath ) )
+						    mxSFI->kill( aDestElementPath );
+            	        mxSFI->move( aElementPath, aDestElementPath );
+                    }
+            		catch( Exception& )
+                    {
+                    }
+			    }
+				pImplLib->storeResourcesAsURL( aDestDirPath, NewName );
+
+                // Delete folder if empty
+                Sequence< OUString > aContentSeq = mxSFI->getFolderContents( aLibDirPath, true );
+    		    sal_Int32 nCount = aContentSeq.getLength();
+	            if( !nCount )
+                {
+       	            mxSFI->kill( aLibDirPath );
+                }
+
+                bMovedSuccessful = true;
+				pImplLib->implSetModified( sal_True );
+	        }
+        }
+        catch( Exception& )
+        {
+            // Restore old library
+        	maNameContainer.insertByName( Name, aLibAny ) ;
+        }
+    }
+
+    if( bStorage && !pImplLib->mbLink )
+		pImplLib->implSetModified( sal_True );
+
+    if( bMovedSuccessful )
+       	maNameContainer.insertByName( NewName, aLibAny ) ;
+
+}
+
+
+// Methods XInitialization
+void SAL_CALL SfxLibraryContainer::initialize( const Sequence< Any >& _rArguments )
+    throw (Exception, RuntimeException)
+{
+    LibraryContainerMethodGuard aGuard( *this );
+	sal_Int32 nArgCount = _rArguments.getLength();
+    if ( nArgCount == 1 )
+    {
+        OUString sInitialDocumentURL;
+        Reference< XStorageBasedDocument > xDocument;
+        if ( _rArguments[0] >>= sInitialDocumentURL )
+        {
+            initializeFromDocumentURL( sInitialDocumentURL );
+            return;
+        }
+
+        if ( _rArguments[0] >>= xDocument )
+        {
+            initializeFromDocument( xDocument );
+            return;
+        }
+    }
+
+    throw IllegalArgumentException();
+}
+
+void SAL_CALL SfxLibraryContainer::initializeFromDocumentURL( const ::rtl::OUString& _rInitialDocumentURL )
+{
+    init( _rInitialDocumentURL, NULL );
+}
+
+void SAL_CALL SfxLibraryContainer::initializeFromDocument( const Reference< XStorageBasedDocument >& _rxDocument )
+{
+    // check whether this is a valid OfficeDocument, and obtain the document's root storage
+    Reference< XStorage > xDocStorage;
+    try
+    {
+        Reference< XServiceInfo > xSI( _rxDocument, UNO_QUERY_THROW );
+        if ( xSI->supportsService( ::rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "com.sun.star.document.OfficeDocument" ) ) ) )
+            xDocStorage.set( _rxDocument->getDocumentStorage(), UNO_QUERY_THROW );
+
+        Reference< XModel > xDocument( _rxDocument, UNO_QUERY_THROW );
+        Reference< XComponent > xDocComponent( _rxDocument, UNO_QUERY_THROW );
+
+        mxOwnerDocument = xDocument;
+        startComponentListening( xDocComponent );
+    }
+    catch( const Exception& ) { }
+
+    if ( !xDocStorage.is() )
+        throw IllegalArgumentException();
+
+    init( OUString(), xDocStorage );
+}
+
+// OEventListenerAdapter
+void SfxLibraryContainer::_disposing( const EventObject& _rSource )
+{
+#if OSL_DEBUG_LEVEL > 0
+    Reference< XModel > xDocument( mxOwnerDocument.get(), UNO_QUERY );
+    OSL_ENSURE( ( xDocument == _rSource.Source ) && xDocument.is(), "SfxLibraryContainer::_disposing: where does this come from?" );
+#else
+    (void)_rSource;
+#endif
+    dispose();
+}
+
+// OComponentHelper
+void SAL_CALL SfxLibraryContainer::disposing()
+{
+    stopAllComponentListening();
+    mxOwnerDocument = WeakReference< XModel >();
+}
+
+// Methods XLibraryContainerPassword
+sal_Bool SAL_CALL SfxLibraryContainer::isLibraryPasswordProtected( const OUString& )
+    throw (NoSuchElementException, RuntimeException)
+{
+    LibraryContainerMethodGuard aGuard( *this );
+    return sal_False;
+}
+
+sal_Bool SAL_CALL SfxLibraryContainer::isLibraryPasswordVerified( const OUString& )
+    throw (IllegalArgumentException, NoSuchElementException, RuntimeException)
+{
+    LibraryContainerMethodGuard aGuard( *this );
+	throw IllegalArgumentException();
+}
+
+sal_Bool SAL_CALL SfxLibraryContainer::verifyLibraryPassword
+    ( const OUString&, const OUString& )
+        throw (IllegalArgumentException, NoSuchElementException, RuntimeException)
+{
+    LibraryContainerMethodGuard aGuard( *this );
+	throw IllegalArgumentException();
+}
+
+void SAL_CALL SfxLibraryContainer::changeLibraryPassword( 
+    const OUString&, const OUString&, const OUString& )
+        throw (IllegalArgumentException, NoSuchElementException, RuntimeException)
+{
+    LibraryContainerMethodGuard aGuard( *this );
+	throw IllegalArgumentException();
+}
+
+// Methods XContainer
+void SAL_CALL SfxLibraryContainer::addContainerListener( const Reference< XContainerListener >& xListener )
+	throw (RuntimeException)
+{
+    LibraryContainerMethodGuard aGuard( *this );
+	maNameContainer.setEventSource( static_cast< XInterface* >( (OWeakObject*)this ) );
+	maNameContainer.addContainerListener( xListener );
+}
+
+void SAL_CALL SfxLibraryContainer::removeContainerListener( const Reference< XContainerListener >& xListener )
+	throw (RuntimeException)
+{
+    LibraryContainerMethodGuard aGuard( *this );
+	maNameContainer.removeContainerListener( xListener );
+}
+
+// Methods XLibraryContainerExport
+void SAL_CALL SfxLibraryContainer::exportLibrary( const OUString& Name, const OUString& URL, 
+	const Reference< XInteractionHandler >& Handler ) 
+		throw ( uno::Exception, NoSuchElementException, RuntimeException)
+{
+    LibraryContainerMethodGuard aGuard( *this );
+    SfxLibrary* pImplLib = getImplLib( Name );
+
+	Reference< XSimpleFileAccess > xToUseSFI;
+	if( Handler.is() )
+	{
+		xToUseSFI = Reference< XSimpleFileAccess >( mxMSF->createInstance
+			( OUString::createFromAscii( "com.sun.star.ucb.SimpleFileAccess" ) ), UNO_QUERY );
+		if( xToUseSFI.is() )
+			xToUseSFI->setInteractionHandler( Handler );
+	}
+
+	// Maybe lib is not loaded?!
+	loadLibrary( Name );
+
+	uno::Reference< ::com::sun::star::embed::XStorage > xDummyStor;
+    if( pImplLib->mbPasswordProtected )
+		implStorePasswordLibrary( pImplLib, Name, xDummyStor, URL, xToUseSFI, Handler );
+    else
+		implStoreLibrary( pImplLib, Name, xDummyStor, URL, xToUseSFI, Handler );
+
+	::xmlscript::LibDescriptor aLibDesc;
+	aLibDesc.aName = Name;
+	aLibDesc.bLink = false;				// Link status gets lost?
+	aLibDesc.bReadOnly = pImplLib->mbReadOnly;
+	aLibDesc.bPreload = false;			// Preload status gets lost?
+	aLibDesc.bPasswordProtected = pImplLib->mbPasswordProtected;
+	aLibDesc.aElementNames = pImplLib->getElementNames();
+
+	implStoreLibraryIndexFile( pImplLib, aLibDesc, xDummyStor, URL, xToUseSFI );
+}
+
+OUString SfxLibraryContainer::expand_url( const OUString& url )
+	throw(::com::sun::star::uno::RuntimeException)
+{
+    if (0 == url.compareToAscii( RTL_CONSTASCII_STRINGPARAM(EXPAND_PROTOCOL ":") ))
+    {
+        if( !mxMacroExpander.is() )
+        {
+            Reference< XPropertySet > xProps( mxMSF, UNO_QUERY );
+            OSL_ASSERT( xProps.is() );
+            if( xProps.is() )
+            {
+                Reference< XComponentContext > xContext;
+                xProps->getPropertyValue(
+                    OUString( RTL_CONSTASCII_USTRINGPARAM("DefaultContext") ) ) >>= xContext;
+                OSL_ASSERT( xContext.is() );
+                if( xContext.is() )
+                {
+                    Reference< util::XMacroExpander > xExpander;
+                    xContext->getValueByName(
+                        OUSTR("/singletons/com.sun.star.util.theMacroExpander") ) >>= xExpander;
+                    if(! xExpander.is())
+                    {
+                        throw DeploymentException(
+                            OUSTR("no macro expander singleton available!"), Reference< XInterface >() );
+                    }
+                    MutexGuard guard( Mutex::getGlobalMutex() );
+                    if( !mxMacroExpander.is() )
+                    {
+                        mxMacroExpander = xExpander;
+                    }
+                }
+            }
+        }
+
+        if( !mxMacroExpander.is() )
+            return url;
+
+        // cut protocol
+        OUString macro( url.copy( sizeof (EXPAND_PROTOCOL ":") -1 ) );
+        // decode uric class chars
+        macro = Uri::decode( macro, rtl_UriDecodeWithCharset, RTL_TEXTENCODING_UTF8 );
+        // expand macro string
+        OUString ret( mxMacroExpander->expandMacros( macro ) );
+        return ret;
+    }
+	else if( mxStringSubstitution.is() )
+	{
+		OUString ret( mxStringSubstitution->substituteVariables( url, false ) );
+        return ret;
+	}
+    else
+    {
+        return url;
+    }
+}
+
+// Methods XServiceInfo
+::sal_Bool SAL_CALL SfxLibraryContainer::supportsService( const ::rtl::OUString& _rServiceName )
+    throw (RuntimeException)
+{
+    LibraryContainerMethodGuard aGuard( *this );
+    Sequence< OUString > aSupportedServices( getSupportedServiceNames() );
+    const OUString* pSupportedServices = aSupportedServices.getConstArray();
+    for ( sal_Int32 i=0; i<aSupportedServices.getLength(); ++i, ++pSupportedServices )
+        if ( *pSupportedServices == _rServiceName )
+            return sal_True;
+    return sal_False;
+}
+
+//============================================================================
+
+// Implementation class SfxLibrary
+
+// Ctor
+SfxLibrary::SfxLibrary( ModifiableHelper& _rModifiable, const Type& aType,
+    const Reference< XMultiServiceFactory >& xMSF, const Reference< XSimpleFileAccess >& xSFI )
+		: OComponentHelper( m_aMutex )
+		, mxMSF( xMSF )
+		, mxSFI( xSFI )
+        , mrModifiable( _rModifiable )
+		, maNameContainer( aType )
+		, mbLoaded( sal_True )
+		, mbIsModified( sal_True )
+		, mbInitialised( sal_False )
+		, mbLink( sal_False )
+		, mbReadOnly( sal_False )
+		, mbReadOnlyLink( sal_False )
+		, mbPreload( sal_False )
+		, mbPasswordProtected( sal_False )
+		, mbPasswordVerified( sal_False )
+		, mbDoc50Password( sal_False )
+		, mbSharedIndexFile( sal_False )
+{
+}
+
+SfxLibrary::SfxLibrary( ModifiableHelper& _rModifiable, const Type& aType,
+    const Reference< XMultiServiceFactory >& xMSF, const Reference< XSimpleFileAccess >& xSFI,
+	const OUString& aLibInfoFileURL, const OUString& aStorageURL, sal_Bool ReadOnly )
+		: OComponentHelper( m_aMutex )
+		, mxMSF( xMSF )
+		, mxSFI( xSFI )
+        , mrModifiable( _rModifiable )
+		, maNameContainer( aType )
+		, mbLoaded( sal_False )
+		, mbIsModified( sal_True )
+		, mbInitialised( sal_False )
+		, maLibInfoFileURL( aLibInfoFileURL )
+		, maStorageURL( aStorageURL )
+		, mbLink( sal_True )
+		, mbReadOnly( sal_False )
+		, mbReadOnlyLink( ReadOnly )
+		, mbPreload( sal_False )
+		, mbPasswordProtected( sal_False )
+		, mbPasswordVerified( sal_False )
+		, mbDoc50Password( sal_False )
+		, mbSharedIndexFile( sal_False )
+{
+}
+
+void SfxLibrary::implSetModified( sal_Bool _bIsModified )
+{
+    if ( mbIsModified == _bIsModified )
+        return;
+    mbIsModified = _bIsModified;
+    if ( mbIsModified )
+        mrModifiable.setModified( sal_True );
+}
+
+// Methods XInterface
+Any SAL_CALL SfxLibrary::queryInterface( const Type& rType )
+	throw( RuntimeException )
+{
+	Any aRet;
+
+    /*
+	if( mbReadOnly )
+	{
+		aRet = Any( ::cppu::queryInterface( rType,
+			static_cast< XContainer * >( this ),
+			static_cast< XNameAccess * >( this ) ) );
+	}
+	else
+	{
+    */
+		aRet = Any( ::cppu::queryInterface( rType,
+			static_cast< XContainer * >( this ),
+			static_cast< XNameContainer * >( this ),
+			static_cast< XNameAccess * >( this ) ) );
+	//}
+	if( !aRet.hasValue() )
+		aRet = OComponentHelper::queryInterface( rType );
+	return aRet;
+}
+
+// Methods XElementAccess
+Type SfxLibrary::getElementType()
+	throw(RuntimeException)
+{
+	return maNameContainer.getElementType();
+}
+
+sal_Bool SfxLibrary::hasElements()
+	throw(RuntimeException)
+{
+	sal_Bool bRet = maNameContainer.hasElements();
+	return bRet;
+}
+
+// Methods XNameAccess
+Any SfxLibrary::getByName( const OUString& aName )
+	throw(NoSuchElementException, WrappedTargetException, RuntimeException)
+{
+	Any aRetAny = maNameContainer.getByName( aName ) ;
+	return aRetAny;
+}
+
+Sequence< OUString > SfxLibrary::getElementNames()
+	throw(RuntimeException)
+{
+	return maNameContainer.getElementNames();
+}
+
+sal_Bool SfxLibrary::hasByName( const OUString& aName )
+	throw(RuntimeException)
+{
+	sal_Bool bRet = maNameContainer.hasByName( aName );
+	return bRet;
+}
+
+void SfxLibrary::impl_checkReadOnly()
+{
+	if( mbReadOnly || (mbLink && mbReadOnlyLink) )
+        throw IllegalArgumentException(
+            ::rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "Library is readonly." ) ),
+            // TODO: resource
+            *this, 0
+        );
+}
+
+// Methods XNameReplace
+void SfxLibrary::replaceByName( const OUString& aName, const Any& aElement )
+	throw(IllegalArgumentException, NoSuchElementException, WrappedTargetException, RuntimeException)
+{
+    impl_checkReadOnly();
+
+	maNameContainer.replaceByName( aName, aElement );
+	implSetModified( sal_True );
+}
+
+
+// Methods XNameContainer
+void SfxLibrary::insertByName( const OUString& aName, const Any& aElement )
+	throw(IllegalArgumentException, ElementExistException, WrappedTargetException, RuntimeException)
+{
+    impl_checkReadOnly();
+
+	maNameContainer.insertByName( aName, aElement );
+	implSetModified( sal_True );
+}
+
+void SfxLibrary::removeByName( const OUString& Name )
+	throw(NoSuchElementException, WrappedTargetException, RuntimeException)
+{
+    impl_checkReadOnly();
+
+	maNameContainer.removeByName( Name );
+	implSetModified( sal_True );
+
+    // Remove element file
+	if( maStorageURL.getLength() )
+	{
+		INetURLObject aElementInetObj( maStorageURL );
+		aElementInetObj.insertName( Name, sal_False,
+			INetURLObject::LAST_SEGMENT, sal_True, INetURLObject::ENCODE_ALL );
+		aElementInetObj.setExtension( maLibElementFileExtension );
+		OUString aFile = aElementInetObj.GetMainURL( INetURLObject::NO_DECODE );
+
+		try
+		{
+	        if( mxSFI->exists( aFile ) )
+		        mxSFI->kill( aFile );
+        }
+        catch( Exception& )
+        {
+        }
+	}
+
+}
+
+// XTypeProvider
+Sequence< Type > SfxLibrary::getTypes()
+	throw( RuntimeException )
+{
+	static OTypeCollection * s_pTypes_NameContainer = 0;
+	{
+		if( !s_pTypes_NameContainer )
+		{
+			MutexGuard aGuard( Mutex::getGlobalMutex() );
+			if( !s_pTypes_NameContainer )
+			{
+				static OTypeCollection s_aTypes_NameContainer(
+					::getCppuType( (const Reference< XNameContainer > *)0 ),
+					::getCppuType( (const Reference< XContainer > *)0 ),
+					OComponentHelper::getTypes() );
+				s_pTypes_NameContainer = &s_aTypes_NameContainer;
+			}
+		}
+		return s_pTypes_NameContainer->getTypes();
+	}
+}
+
+
+Sequence< sal_Int8 > SfxLibrary::getImplementationId()
+	throw( RuntimeException )
+{
+	static OImplementationId * s_pId_NameContainer = 0;
+	{
+		if( !s_pId_NameContainer )
+		{
+			MutexGuard aGuard( Mutex::getGlobalMutex() );
+			if( !s_pId_NameContainer )
+			{
+				static OImplementationId s_aId_NameContainer;
+				s_pId_NameContainer = &s_aId_NameContainer;
+			}
+		}
+		return s_pId_NameContainer->getImplementationId();
+	}
+}
+
+
+//============================================================================
+
+// Methods XContainer
+void SAL_CALL SfxLibrary::addContainerListener( const Reference< XContainerListener >& xListener )
+	throw (RuntimeException)
+{
+	maNameContainer.setEventSource( static_cast< XInterface* >( (OWeakObject*)this ) );
+	maNameContainer.addContainerListener( xListener );
+}
+
+void SAL_CALL SfxLibrary::removeContainerListener( const Reference< XContainerListener >& xListener )
+	throw (RuntimeException)
+{
+	maNameContainer.removeContainerListener( xListener );
+}
+
+//============================================================================
+
+}   // namespace basic
