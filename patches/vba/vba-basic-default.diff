diff -rup basic.orig/source/classes/sbunoobj.cxx basic/source/classes/sbunoobj.cxx
--- basic.orig/source/classes/sbunoobj.cxx	2006-08-25 10:26:41.000000000 +0100
+++ basic/source/classes/sbunoobj.cxx	2006-08-24 17:18:56.000000000 +0100
@@ -134,6 +134,53 @@ static OUString aSeqLevelStr( RTL_CONSTA
 static OUString defaultNameSpace( RTL_CONSTASCII_USTRINGPARAM("org.openoffice.vba.") );
 static OUString defaultNameSpaceParent( RTL_CONSTASCII_USTRINGPARAM("org.openoffice") );
 
+// Gets the default property for an uno object. Note: There is some 
+// redirection built in. The property "_$DefaultProp" specifies the name
+// of the default property. This allows the implementing object to change
+// the name of the default property depending on its state.
+
+bool SbUnoObject::getDefaultPropName( SbUnoObject* pUnoObj, String& sDfltProp )
+{
+	OUString sName;
+	bool result = false;
+	Reference< XPropertySet > xProps( pUnoObj->maTmpUnoObj, UNO_QUERY );
+	if ( xProps.is() )
+	{
+		try
+		{
+			if ( xProps->getPropertyValue( OUString( RTL_CONSTASCII_USTRINGPARAM( "_$DefaultProp" ) ) ) >>= sName )
+			{
+				sDfltProp = sName;
+				result = true;
+			}
+		}
+		catch( Exception& e )
+		{
+		}// swallow exceptions
+	}
+	return result;
+}
+
+SbxVariable* getDefaultProp( SbxVariable* pRef )
+{
+	SbxVariable* pDefaultProp = NULL;		
+	SbxObject* pObj = PTR_CAST(SbxObject,(SbxVariable*) pRef);
+	if ( !pObj )
+	{
+		SbxBase* pObjVarObj = pRef->GetObject();
+		pObj = PTR_CAST(SbxObject,pObjVarObj);
+	}	
+	if ( pObj && pObj->ISA(SbUnoObject) )
+	{
+		String sDfltPropName;
+		SbUnoObject* pUnoObj = PTR_CAST(SbUnoObject,(SbxObject*)pObj);	
+		if ( SbUnoObject::getDefaultPropName( pUnoObj, sDfltPropName ) )
+		{
+			pDefaultProp = pUnoObj->Find( sDfltPropName , SbxCLASS_PROPERTY );
+		}
+	}
+	return pDefaultProp;
+}
 
 Reference< XComponentContext > getComponentContext_Impl( void )
 {
@@ -653,6 +703,16 @@ void unoToSbxValue( SbxVariable* pVar, c
 			// SbUnoObject instanzieren
 			String aName;
 			SbUnoObject* pSbUnoObject = new SbUnoObject( aName, aValue );
+#ifdef ENABLE_VBA
+			String sDfltPropName;
+			if ( SbUnoObject::getDefaultPropName( pSbUnoObject, sDfltPropName ) )
+			{
+				SbxProperty* pDefaultProp = ( SbxProperty*)pSbUnoObject->Find( 
+					String ( sDfltPropName ), SbxCLASS_PROPERTY );
+				if ( pDefaultProp )
+					pSbUnoObject->SetDfltProperty( pDefaultProp );
+			}
+#endif //ENABLE_VBA
 			SbxObjectRef xWrapper = (SbxObject*)pSbUnoObject;
 
 			// #51475 Wenn das Objekt ungueltig ist null liefern
diff -rup basic.orig/source/classes/sbxmod.cxx basic/source/classes/sbxmod.cxx
--- basic.orig/source/classes/sbxmod.cxx	2006-08-25 10:26:42.000000000 +0100
+++ basic/source/classes/sbxmod.cxx	2006-08-25 10:08:56.000000000 +0100
@@ -754,6 +754,7 @@ USHORT SbModule::Run( SbMethod* pMeth )
 			pINST->pRun = pRt;
 			if ( SbiRuntime ::isVBAEnabled() )
 				pINST->EnableCompatibility( TRUE );
+			//pRt->DumpPCode();
 			while( pRt->Step() ) {}
 			if( pRt->pNext )
 				pRt->pNext->unblock();
diff -rup basic.orig/source/comp/parser.cxx basic/source/comp/parser.cxx
--- basic.orig/source/comp/parser.cxx	2006-08-25 10:26:42.000000000 +0100
+++ basic/source/comp/parser.cxx	2006-08-24 17:18:56.000000000 +0100
@@ -600,10 +600,23 @@ void SbiParser::Set()
 		SbiExpression aExpr( this );
 		aLvalue.Gen();
 		aExpr.Gen();
+		// Its a good idea to distinguish between
+		// set someting = another & 
+		// someting = another  
+		// ( its necessary for vba objects where set is object
+		// specific and also doesn't involve processing default params )
 		if( pDef->GetTypeId() )
-			aGen.Gen( _SETCLASS, pDef->GetTypeId() );
+			if ( bVBASupportOn )
+				aGen.Gen( _VBASETCLASS, pDef->GetTypeId() );
+			else
+				aGen.Gen( _SETCLASS, pDef->GetTypeId() );
 		else
-			aGen.Gen( _SET );
+		{
+			if ( bVBASupportOn )
+				aGen.Gen( _VBASET );		
+			else
+				aGen.Gen( _SET );
+		}
 	}
 	// aGen.Gen( _SET );
 }
diff -rup basic.orig/source/inc/opcodes.hxx basic/source/inc/opcodes.hxx
--- basic.orig/source/inc/opcodes.hxx	2006-08-25 10:26:41.000000000 +0100
+++ basic/source/inc/opcodes.hxx	2006-08-24 17:18:56.000000000 +0100
@@ -98,6 +98,7 @@ enum SbiOpcode {
 	_RSET,              // Speichern Objekt TOS ==> TOS-1
 	_REDIMP_ERASE,		// Copies array to be later used by REDIM PRESERVE before erasing it
 	_INITFOREACH,
+	_VBASET,            // VBA-like Set
 	SbOP0_END,
 
 	// Alle Opcodes mit einem Operanden
@@ -131,7 +132,7 @@ enum SbiOpcode {
 	_BASED,          	// TOS wird um BASE erhoeht, BASE davor gepusht (+base)
 	// Typanpassung im Argv
 	_ARGTYP,          	// Letzten Parameter in Argv konvertieren (+Typ)
-
+	_VBASETCLASS,       // VBA-like Set
 	SbOP1_END,
 
 	// Alle Opcodes mit zwei Operanden
diff -rup basic.orig/source/inc/runtime.hxx basic/source/inc/runtime.hxx
--- basic.orig/source/inc/runtime.hxx	2006-08-25 10:26:42.000000000 +0100
+++ basic/source/inc/runtime.hxx	2006-08-24 17:18:56.000000000 +0100
@@ -428,6 +428,8 @@ class SbiRuntime
 	// #115829
 	bool implIsClass( SbxObject* pObj, const String& aClass );
 
+	void StepSETCLASS_impl( UINT32 nOp1, bool bHandleDflt = false );
+
 	// Die nachfolgenden Routinen werden vom Single Stepper
 	// gerufen und implementieren die einzelnen Opcodes
 	void StepNOP(),     StepEXP(),      StepMUL(),      StepDIV();
@@ -438,8 +440,8 @@ class SbiRuntime
 	void StepNOT(),     StepCAT(),      StepLIKE(),     StepIS();
 	void StepCLONE(),   StepOLDBASED(), StepARGC();
 	void StepARGV(),    StepINPUT(),	StepLINPUT(),	StepSTOP();
-	void StepGET(),		StepSET(),	 	StepPUT(),		StepPUTC();
-	void StepSET_Impl( SbxVariableRef& refVal, SbxVariableRef& refVar );
+	void StepGET(),		StepSET(),	StepVBASET(), 	StepPUT(),		StepPUTC();
+	void StepSET_Impl( SbxVariableRef& refVal, SbxVariableRef& refVar, bool bDefaultHandling = true );
 	void StepDIM(),     StepREDIM(),	StepREDIMP(),	StepERASE();
 	void StepINITFOR(), StepNEXT(),		StepERROR(),	StepINITFOREACH();
 	void StepCASE(),	StepENDCASE(),  StepSTDERROR();
@@ -454,7 +456,7 @@ class SbiRuntime
 	void StepJUMPF( UINT32 ),   StepONJUMP( UINT32 );
 	void StepGOSUB( UINT32 ),   StepRETURN( UINT32 );
 	void StepTESTFOR( UINT32 ), StepCASETO( UINT32 ),   StepERRHDL( UINT32 );
-	void StepRESUME( UINT32 ),  StepSETCLASS( UINT32 ),	StepTESTCLASS( UINT32 ), StepLIB( UINT32 );
+	void StepRESUME( UINT32 ),  StepSETCLASS( UINT32 ),	StepVBASETCLASS( UINT32 ),	StepTESTCLASS( UINT32 ), StepLIB( UINT32 );
 	bool checkClass_Impl( const SbxVariableRef& refVal, const String& aClass, bool bRaiseErrors );
 	void StepCLOSE( UINT32 ),   StepPRCHAR( UINT32 ),   StepARGTYP( UINT32 );
 	// Alle Opcodes mit zwei Operanden
diff -rup basic.orig/source/runtime/runtime.cxx basic/source/runtime/runtime.cxx
--- basic.orig/source/runtime/runtime.cxx	2006-08-25 10:26:42.000000000 +0100
+++ basic/source/runtime/runtime.cxx	2006-08-25 10:08:25.000000000 +0100
@@ -152,6 +152,7 @@ SbiRuntime::pStep0 SbiRuntime::aStep0[] 
 	MEMBER(SbiRuntime::StepRSET),		// Speichern Objekt TOS ==> TOS-1
 	MEMBER(SbiRuntime::StepREDIMP_ERASE),// Copy array object for REDIMP
 	MEMBER(SbiRuntime::StepINITFOREACH),// Init for each loop
+	MEMBER(SbiRuntime::StepVBASET),// vba-like set statement
 };
 
 SbiRuntime::pStep1 SbiRuntime::aStep1[] = {	// Alle Opcodes mit einem Operanden
@@ -180,6 +181,7 @@ SbiRuntime::pStep1 SbiRuntime::aStep1[] 
 	MEMBER(SbiRuntime::StepLIB),  		// Lib fuer Declare-Call (+StringId)
 	MEMBER(SbiRuntime::StepBASED),	  	// TOS wird um BASE erhoeht, BASE davor gepusht
 	MEMBER(SbiRuntime::StepARGTYP),	  	// Letzten Parameter in Argv konvertieren (+Typ)
+	MEMBER(SbiRuntime::StepVBASETCLASS),// vba-like set statement
 };
 
 SbiRuntime::pStep2 SbiRuntime::aStep2[] = {// Alle Opcodes mit zwei Operanden
--- basic.orig/source/runtime/step0.cxx	2006-08-25 11:18:30.000000000 +0100
+++ basic/source/runtime/step0.cxx	2006-08-25 12:29:10.000000000 +0100
@@ -50,6 +50,8 @@
 
 #include <algorithm>
 
+SbxVariable* getDefaultProp( SbxVariable* pRef );
+
 void SbiRuntime::StepNOP()
 {}
 
@@ -58,6 +60,37 @@ void SbiRuntime::StepArith( SbxOperator 
 	SbxVariableRef p1 = PopVar();
 	TOSMakeTemp();
 	SbxVariable* p2 = GetTOS();
+
+	bool bVBAInterop =  SbiRuntime::isVBAEnabled(); 
+	SbxVariable* defaultProp = NULL;
+
+	// This could & should be moved to the MakeTempTOS() method in runtime.cxx
+	// In the code which this is cut'npaste from there is a check for a ref
+	// count != 1 based on which the copy of the SbxVariable is done.
+	// see orig code in MakeTempTOS ( and I'm not sure what the significance,
+	// of that is )
+	// here we alway seem to have a refcount of 1. Also it seems that
+	// MakeTempTOS is called for other operation, so I hold off for now
+	// until I have a better idea
+	if ( bVBAInterop
+		&& ( p2->GetType() == SbxOBJECT || p2->GetType() == SbxVARIANT )
+	)
+	{
+		SbxVariable* pDflt = getDefaultProp( p2 );
+		if ( pDflt )
+		{
+			pDflt->Broadcast( SBX_HINT_DATAWANTED );
+			// replacing new p2 on stack causes object pointed by 
+			// pDft->pParent to be deleted, when p2->Compute() is
+			// called below pParent is accessed ( but its deleted )
+			// so set it to NULL now
+			pDflt->SetParent( NULL );  
+			p2 = new SbxVariable( *pDflt );
+			p2->SetFlag( SBX_READWRITE );
+			refExprStk->Put( p2, nExprLvl - 1 );
+		}
+	}
+
 	p2->ResetFlag( SBX_FIXED );
 	p2->Compute( eOp, *p1 );
 
@@ -209,9 +242,33 @@ void SbiRuntime::StepPUT()
 		n = refVar->GetFlags();
 		refVar->SetFlag( SBX_WRITE );
 	}
+	bool bVBAInterop =  SbiRuntime::isVBAEnabled(); 
+
+	// if left side arg is an object or variant and right handside isn't 
+	// either an object or a variant then try and see if a default 
+	// property exists.
+	// to use e.g. Range{"A1") = 34
+	// could equate to Range("A1").Value = 34 
+	if ( bVBAInterop
+		&& ( refVar->GetType() == SbxOBJECT  ) )
+	{
+		SbxVariable* pDflt = getDefaultProp( refVar );
+		if ( pDflt )
+			refVar = pDflt;
+	}
+	if ( bVBAInterop
+		&& ( refVal->GetType() == SbxOBJECT  ) )
+	{
+		SbxVariable* pDflt = getDefaultProp( refVal );
+		if ( pDflt )
+			refVal = pDflt;
+	}
+
 	*refVar = *refVal;
+	// lhs is a property who's value is currently null
+	if ( !bVBAInterop || ( bVBAInterop && refVar->GetType() != SbxEMPTY ) )
 	// #67607 Uno-Structs kopieren
-	checkUnoStructCopy( refVal, refVar );
+		checkUnoStructCopy( refVal, refVar );
 	if( bFlagsChanged )
 		refVar->SetFlags( n );
 }
@@ -220,29 +277,44 @@ void SbiRuntime::StepPUT()
 // Speichern Objektvariable
 // Nicht-Objekt-Variable fuehren zu Fehlern
 
-void SbiRuntime::StepSET_Impl( SbxVariableRef& refVal, SbxVariableRef& refVar )
+void SbiRuntime::StepSET_Impl( SbxVariableRef& refVal, SbxVariableRef& refVar, bool bHandleDefaultProp )
 {
+	bool bVBAInterop =  SbiRuntime::isVBAEnabled(); 
 	// #67733 Typen mit Array-Flag sind auch ok
 	SbxDataType eValType = refVal->GetType();
 	SbxDataType eVarType = refVar->GetType();
-	if( (eValType != SbxOBJECT && eValType != SbxEMPTY && !(eValType & SbxARRAY)) ||
-		(eVarType != SbxOBJECT && eVarType != SbxEMPTY && !(eVarType & SbxARRAY) ) )
+        if( (eValType != SbxOBJECT 
+			&& eValType != SbxEMPTY 
+// seems like when using the default method its possible for objects
+// to be empty ( no broadcast has taken place yet ) or the actual value is
+
+			&& !bVBAInterop
+			&& !(eValType & SbxARRAY)) ||
+            (eVarType != SbxOBJECT 
+			&& eVarType != SbxEMPTY 
+			&& !bVBAInterop
+			&& !(eVarType & SbxARRAY) ) )
 	{
 		Error( SbERR_INVALID_USAGE_OBJECT );
 	}
 	else
 	{
-		// Auf refVal GetObject fuer Collections ausloesen
-		SbxBase* pObjVarObj = refVal->GetObject();
-		if( pObjVarObj )
+		// Getting in here causes problems with vba objects
+		// if there are SbxEMPTY I guess
+		if ( !bVBAInterop || ( bVBAInterop && refVal->GetType() == SbxOBJECT ) )
 		{
-			SbxVariableRef refObjVal = PTR_CAST(SbxObject,pObjVarObj);
+		// Auf refVal GetObject fuer Collections ausloesen
+			SbxBase* pObjVarObj = refVal->GetObject();
+			if( pObjVarObj )
+			{
+				SbxVariableRef refObjVal = PTR_CAST(SbxObject,pObjVarObj);
 
-			// #67733 Typen mit Array-Flag sind auch ok
-			if( refObjVal )
-				refVal = refObjVal;
-			else if( !(eValType & SbxARRAY) )
-				refVal = NULL;
+				// #67733 Typen mit Array-Flag sind auch ok
+				if( refObjVal )
+					refVal = refObjVal;
+				else if( !(eValType & SbxARRAY) )
+					refVal = NULL;
+			}
 		}
 
 		// #52896 Wenn Uno-Sequences bzw. allgemein Arrays einer als
@@ -267,9 +339,62 @@ void SbiRuntime::StepSET_Impl( SbxVariab
 			if( pProcProperty )
 				pProcProperty->setSet( true );
 
+			// bVBAInterop is surely set if bHandleDefaultProp
+			// is set... but better safe than sorry
+			if ( bHandleDefaultProp && bVBAInterop )
+			{
+				// get default properties for lhs & rhs where necessary
+				// have to be careful though where a lhs object is null
+				// meaning a 'set something = someObject' has taken places
+				// which means we don't want to get the default prop for the rhs
+				SbxVariable* defaultProp = NULL;
+				bool bLHSHasDefaultProp = false;
+				// LHS try determine if a default prop exists
+				if ( refVar->GetType() == SbxOBJECT )
+				{
+					SbxVariable* pDflt = getDefaultProp( refVar );
+					if ( pDflt )
+					{
+						refVar = pDflt;
+						bLHSHasDefaultProp = true;
+					}
+				}
+				// RHS only get a default prop is the rhs has one
+				if (  refVal->GetType() == SbxOBJECT )
+				{
+					// check if lhs is a null object
+					// if it is then use the object not the default property
+					SbxObject* pObj = NULL;
+	
+					
+					pObj = PTR_CAST(SbxObject,(SbxVariable*)refVar);
+
+					// calling GetObject on a SbxEMPTY variable raises
+					// object not set errors, make sure its an Object
+					if ( !pObj && refVar->GetType() == SbxOBJECT )
+					{
+						SbxBase* pObjVarObj = refVar->GetObject();
+						pObj = PTR_CAST(SbxObject,pObjVarObj);
+					}	
+					SbxVariable* pDflt = NULL;
+					if ( pObj || bLHSHasDefaultProp )
+						// lhs is either a valid object || or has a defaultProp
+						pDflt = getDefaultProp( refVal );
+					if ( pDflt )
+						refVal = pDflt;
+				}
+			}	
+			
 			*refVar = *refVal;
+
+			// lhs is a property who's value is currently (Empty e.g. no broadcast yet)
+			// in this case if there is a default prop involved the value of the 
+			// default property may infact be void so the type will also be SbxEMPTY
+			// in this case we do not want to call checkUnoStructCopy 'cause that will
+			// cause an error also
+			if ( !bVBAInterop || ( bVBAInterop && ( refVar->GetType() != SbxEMPTY ) ) )
 			// #67607 Uno-Structs kopieren
-			checkUnoStructCopy( refVal, refVar );
+				checkUnoStructCopy( refVal, refVar );
 			if( bFlagsChanged )
 				refVar->SetFlags( n );
 		}
@@ -284,6 +409,15 @@ void SbiRuntime::StepSET()
 	StepSET_Impl( refVal, refVar );
 }
 
+void SbiRuntime::StepVBASET()
+{
+	SbxVariableRef refVal = PopVar();
+	SbxVariableRef refVar = PopVar();
+	// don't handle default property
+	StepSET_Impl( refVal, refVar, false );
+}
+
+
 // JSM 07.10.95
 void SbiRuntime::StepLSET()
 {
diff -rup basic.orig/source/runtime/step1.cxx basic/source/runtime/step1.cxx
--- basic.orig/source/runtime/step1.cxx	2006-08-25 10:26:42.000000000 +0100
+++ basic/source/runtime/step1.cxx	2006-08-24 17:18:56.000000000 +0100
@@ -505,14 +505,17 @@ bool SbiRuntime::checkClass_Impl( const 
 	}
 	else
 	{
-		if( bRaiseErrors )
-			Error( SbERR_NEEDS_OBJECT );
-		bOk = false;
+		if ( !SbiRuntime::isVBAEnabled() )
+		{
+			if( bRaiseErrors )
+				Error( SbERR_NEEDS_OBJECT );
+			bOk = false;
+		}
 	}
 	return bOk;
 }
 
-void SbiRuntime::StepSETCLASS( UINT32 nOp1 )
+void SbiRuntime::StepSETCLASS_impl( UINT32 nOp1, bool bHandleDflt )
 {
 	SbxVariableRef refVal = PopVar();
 	SbxVariableRef refVar = PopVar();
@@ -520,7 +523,17 @@ void SbiRuntime::StepSETCLASS( UINT32 nO
 
 	bool bOk = checkClass_Impl( refVal, aClass, true );
 	if( bOk )
-		StepSET_Impl( refVal, refVar );
+		StepSET_Impl( refVal, refVar, bHandleDflt ); // don't do handle dflt prop for a "proper" set
+}
+
+void SbiRuntime::StepVBASETCLASS( UINT32 nOp1 )
+{
+	StepSETCLASS_impl( nOp1, false );
+}
+
+void SbiRuntime::StepSETCLASS( UINT32 nOp1 )
+{
+	StepSETCLASS_impl( nOp1, true );
 }
 
 void SbiRuntime::StepTESTCLASS( UINT32 nOp1 )
--- /data4/sles/ooo-build-LATEST-copy/ooo-build/build/ood680-m5/basic/inc/sbxobj.hxx	2006-10-09 09:57:23.000000000 +0100
+++ basic/inc/sbxobj.hxx	2006-10-06 17:13:16.000000000 +0100
@@ -68,6 +68,7 @@ protected:
 	SbxArrayRef  pObjs;				// Objekte
 	SbxProperty* pDfltProp;			// Default-Property
 	String       aClassName;        // Klassenname
+	String       aDfltPropName;        // Klassenname
 	virtual BOOL LoadData( SvStream&, USHORT );
 	virtual BOOL StoreData( SvStream& ) const;
 	virtual ~SbxObject();
@@ -87,7 +88,7 @@ public:
 	const String& GetClassName() const { return aClassName; }
 	void		  SetClassName( const String &rNew ) { aClassName = rNew; }
 	// Default-Property
-	SbxProperty* GetDfltProperty() const { return pDfltProp; }
+	SbxProperty* GetDfltProperty() ;// const;  { return pDfltProp; }
 	void SetDfltProperty( const String& r );
 	void SetDfltProperty( SbxProperty* );
 	// Suchen eines Elements
--- /data4/sles/ooo-build-LATEST-copy/ooo-build/build/ood680-m5/basic/source/sbx/sbxobj.cxx	2006-06-19 18:51:00.000000000 +0100
+++ basic/source/sbx/sbxobj.cxx	2006-10-06 17:19:11.000000000 +0100
@@ -317,6 +317,16 @@ BOOL SbxObject::Call( const XubString& r
 	return FALSE;
 }
 
+SbxProperty* SbxObject::GetDfltProperty() 
+{
+	if ( !pDfltProp && aDfltPropName.Len() )
+	{
+		pDfltProp = (SbxProperty*) Find( aDfltPropName, SbxCLASS_PROPERTY );
+		if( !pDfltProp )
+			pDfltProp = (SbxProperty*) Make( aDfltPropName, SbxCLASS_PROPERTY, SbxVARIANT );
+	}
+	return pDfltProp;
+}
 void SbxObject::SetDfltProperty( const XubString& rName )
 {
 	if( rName.Len() )
--- /data4/sles/ooo-build-LATEST-copy/ooo-build/build/ood680-m5/basic/source/inc/sbunoobj.hxx	2006-06-19 18:44:31.000000000 +0100
+++ basic/source/inc/sbunoobj.hxx	2006-10-04 11:48:27.000000000 +0100
@@ -96,6 +96,7 @@ class SbUnoObject: public SbxObject
 	void implCreateAll( void );
 
 public:
+	static bool getDefaultPropName( SbUnoObject* pUnoObj, String& sDfltProp );
 	TYPEINFO();
 	SbUnoObject( const String& aName_, const Any& aUnoObj_ );
 	~SbUnoObject();
